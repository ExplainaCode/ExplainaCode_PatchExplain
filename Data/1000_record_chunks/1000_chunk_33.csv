record_number,buggy_code,fixed_code,code_similarity
32001,"@SuppressWarnings(""String_Node_Str"") public Tuple exec(Tuple input) throws IOException {
  if (input == null || input.size() == 0) {
    return null;
  }
  final String rawTag=input.get(tagColumnNum).toString();
  if (!super.tagSet.contains(rawTag)) {
    if (isPigEnabled(Constants.SHIFU_GROUP_COUNTER,""String_Node_Str"")) {
      PigStatusReporter.getInstance().getCounter(Constants.SHIFU_GROUP_COUNTER,""String_Node_Str"").increment(1);
    }
    return null;
  }
  boolean isNotSampled=DataSampler.isNotSampled(modelConfig.isRegression(),super.tagSet,super.posTagSet,super.negTagSet,modelConfig.getNormalizeSampleRate(),modelConfig.isNormalizeSampleNegOnly(),rawTag);
  if (isNotSampled) {
    return null;
  }
  Tuple tuple=TupleFactory.getInstance().newTuple();
  final NormType normType=modelConfig.getNormalizeType();
  for (int i=0; i < input.size(); i++) {
    ColumnConfig config=columnConfigList.get(i);
    String val=(input.get(i) == null) ? ""String_Node_Str"" : input.get(i).toString();
    if (weightExpr != null) {
      weightContext.set(config.getColumnName(),val);
    }
    if (tagColumnNum == i) {
      if (modelConfig.isRegression()) {
        String tagType=tagTypeCheck(super.posTagSet,super.negTagSet,rawTag);
        if (tagType == null) {
          log.error(""String_Node_Str"" + rawTag);
          return null;
        }
        tuple.append(tagType);
      }
 else {
        int index=-1;
        for (int j=0; j < tags.size(); j++) {
          Set<String> tagSet=tags.get(j);
          if (tagSet.contains(rawTag)) {
            index=j;
            break;
          }
        }
        if (index == -1) {
          log.error(""String_Node_Str"" + rawTag);
          return null;
        }
        tuple.append(index);
      }
      continue;
    }
    if (!CommonUtils.isGoodCandidate(modelConfig.isRegression(),config)) {
      tuple.append(null);
    }
 else {
      if (CommonUtils.isDesicionTreeAlgorithm(this.alg)) {
        Double normVal=0d;
        if (config.isCategorical()) {
          tuple.append(val);
        }
 else {
          try {
            normVal=Double.parseDouble(val);
          }
 catch (          Exception e) {
            log.debug(""String_Node_Str"" + val + ""String_Node_Str"");
            normVal=Normalizer.defaultMissingValue(config);
          }
        }
        tuple.append(df.format(normVal));
      }
 else {
        Double normVal=Normalizer.normalize(config,val,cutoff,normType);
        tuple.append(df.format(normVal));
      }
    }
  }
  double weight=evaluateWeight(weightExpr,weightContext);
  tuple.append(weight);
  return tuple;
}","@SuppressWarnings(""String_Node_Str"") public Tuple exec(Tuple input) throws IOException {
  if (input == null || input.size() == 0) {
    return null;
  }
  final String rawTag=input.get(tagColumnNum).toString();
  if (!super.tagSet.contains(rawTag)) {
    if (isPigEnabled(Constants.SHIFU_GROUP_COUNTER,""String_Node_Str"")) {
      PigStatusReporter.getInstance().getCounter(Constants.SHIFU_GROUP_COUNTER,""String_Node_Str"").increment(1);
    }
    return null;
  }
  boolean isNotSampled=DataSampler.isNotSampled(modelConfig.isRegression(),super.tagSet,super.posTagSet,super.negTagSet,modelConfig.getNormalizeSampleRate(),modelConfig.isNormalizeSampleNegOnly(),rawTag);
  if (isNotSampled) {
    return null;
  }
  Tuple tuple=TupleFactory.getInstance().newTuple();
  final NormType normType=modelConfig.getNormalizeType();
  for (int i=0; i < input.size(); i++) {
    ColumnConfig config=columnConfigList.get(i);
    String val=(input.get(i) == null) ? ""String_Node_Str"" : input.get(i).toString();
    if (weightExpr != null) {
      weightContext.set(config.getColumnName(),val);
    }
    if (tagColumnNum == i) {
      if (modelConfig.isRegression()) {
        String tagType=tagTypeCheck(super.posTagSet,super.negTagSet,rawTag);
        if (tagType == null) {
          log.error(""String_Node_Str"" + rawTag);
          return null;
        }
        tuple.append(tagType);
      }
 else {
        int index=-1;
        for (int j=0; j < tags.size(); j++) {
          Set<String> tagSet=tags.get(j);
          if (tagSet.contains(rawTag)) {
            index=j;
            break;
          }
        }
        if (index == -1) {
          log.error(""String_Node_Str"" + rawTag);
          return null;
        }
        tuple.append(index);
      }
      continue;
    }
    if (!CommonUtils.isGoodCandidate(modelConfig.isRegression(),config)) {
      tuple.append(null);
    }
 else {
      if (CommonUtils.isDesicionTreeAlgorithm(this.alg)) {
        Double normVal=0d;
        if (config.isCategorical()) {
          tuple.append(val);
        }
 else {
          try {
            normVal=Double.parseDouble(val);
          }
 catch (          Exception e) {
            log.debug(""String_Node_Str"" + val + ""String_Node_Str"");
            normVal=Normalizer.defaultMissingValue(config);
          }
          tuple.append(df.format(normVal));
        }
      }
 else {
        Double normVal=Normalizer.normalize(config,val,cutoff,normType);
        tuple.append(df.format(normVal));
      }
    }
  }
  double weight=evaluateWeight(weightExpr,weightContext);
  tuple.append(weight);
  return tuple;
}",0.983505945531262
32002,"private void setHeapSizeAndSplitSize(final List<String> args){
  if (this.isDebug()) {
    args.add(String.format(CommonConstants.MAPREDUCE_PARAM_FORMAT,GuaguaMapReduceConstants.MAPRED_CHILD_JAVA_OPTS,""String_Node_Str""));
  }
 else {
    args.add(String.format(CommonConstants.MAPREDUCE_PARAM_FORMAT,GuaguaMapReduceConstants.MAPRED_CHILD_JAVA_OPTS,""String_Node_Str""));
    args.add(String.format(CommonConstants.MAPREDUCE_PARAM_FORMAT,""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""));
  }
  if (super.modelConfig.getNormalize().getIsParquet()) {
    args.add(String.format(CommonConstants.MAPREDUCE_PARAM_FORMAT,GuaguaConstants.GUAGUA_SPLIT_COMBINABLE,Environment.getProperty(GuaguaConstants.GUAGUA_SPLIT_COMBINABLE,""String_Node_Str"")));
  }
 else {
    args.add(String.format(CommonConstants.MAPREDUCE_PARAM_FORMAT,GuaguaConstants.GUAGUA_SPLIT_COMBINABLE,Environment.getProperty(GuaguaConstants.GUAGUA_SPLIT_COMBINABLE,""String_Node_Str"")));
    args.add(String.format(CommonConstants.MAPREDUCE_PARAM_FORMAT,GuaguaConstants.GUAGUA_SPLIT_MAX_COMBINED_SPLIT_SIZE,Environment.getProperty(GuaguaConstants.GUAGUA_SPLIT_MAX_COMBINED_SPLIT_SIZE,""String_Node_Str"")));
  }
  args.add(String.format(CommonConstants.MAPREDUCE_PARAM_FORMAT,GuaguaConstants.GUAGUA_MIN_WORKERS_RATIO,0.98));
  args.add(String.format(CommonConstants.MAPREDUCE_PARAM_FORMAT,GuaguaConstants.GUAGUA_MIN_WORKERS_TIMEOUT,2 * 1000L));
}","private void setHeapSizeAndSplitSize(final List<String> args){
  if (this.isDebug()) {
    args.add(String.format(CommonConstants.MAPREDUCE_PARAM_FORMAT,GuaguaMapReduceConstants.MAPRED_CHILD_JAVA_OPTS,""String_Node_Str""));
  }
 else {
    args.add(String.format(CommonConstants.MAPREDUCE_PARAM_FORMAT,GuaguaMapReduceConstants.MAPRED_CHILD_JAVA_OPTS,""String_Node_Str""));
    args.add(String.format(CommonConstants.MAPREDUCE_PARAM_FORMAT,""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""));
  }
  if (super.modelConfig.getNormalize().getIsParquet()) {
    args.add(String.format(CommonConstants.MAPREDUCE_PARAM_FORMAT,GuaguaConstants.GUAGUA_SPLIT_COMBINABLE,Environment.getProperty(GuaguaConstants.GUAGUA_SPLIT_COMBINABLE,""String_Node_Str"")));
  }
 else {
    args.add(String.format(CommonConstants.MAPREDUCE_PARAM_FORMAT,GuaguaConstants.GUAGUA_SPLIT_COMBINABLE,Environment.getProperty(GuaguaConstants.GUAGUA_SPLIT_COMBINABLE,""String_Node_Str"")));
    args.add(String.format(CommonConstants.MAPREDUCE_PARAM_FORMAT,GuaguaConstants.GUAGUA_SPLIT_MAX_COMBINED_SPLIT_SIZE,Environment.getProperty(GuaguaConstants.GUAGUA_SPLIT_MAX_COMBINED_SPLIT_SIZE,""String_Node_Str"")));
  }
  args.add(String.format(CommonConstants.MAPREDUCE_PARAM_FORMAT,GuaguaConstants.GUAGUA_MIN_WORKERS_RATIO,0.97));
  args.add(String.format(CommonConstants.MAPREDUCE_PARAM_FORMAT,GuaguaConstants.GUAGUA_MIN_WORKERS_TIMEOUT,2 * 1000L));
}",0.9992892679459844
32003,"/** 
 * Update target, listMeta, listForceSelect, listForceRemove
 * @throws IOException
 * @throws IllegalArgumentException if modelConfig is null or columnConfigList is null.
 */
public static void updateColumnConfigFlags(ModelConfig modelConfig,List<ColumnConfig> columnConfigList) throws IOException {
  String targetColumnName=CommonUtils.getRelativePigHeaderColumnName(modelConfig.getTargetColumnName());
  Set<String> setCategorialColumns=new HashSet<String>();
  if (CollectionUtils.isNotEmpty(modelConfig.getCategoricalColumnNames())) {
    for (    String column : modelConfig.getCategoricalColumnNames()) {
      setCategorialColumns.add(CommonUtils.getRelativePigHeaderColumnName(column));
    }
  }
  Set<String> setMeta=new HashSet<String>();
  if (CollectionUtils.isNotEmpty(modelConfig.getMetaColumnNames())) {
    for (    String meta : modelConfig.getMetaColumnNames()) {
      setMeta.add(CommonUtils.getRelativePigHeaderColumnName(meta));
    }
  }
  Set<String> setForceRemove=new HashSet<String>();
  if (Boolean.TRUE.equals(modelConfig.getVarSelect().getForceEnable()) && CollectionUtils.isNotEmpty(modelConfig.getListForceRemove())) {
    for (    String forceRemoveName : modelConfig.getListForceRemove()) {
      setForceRemove.add(CommonUtils.getRelativePigHeaderColumnName(forceRemoveName));
    }
  }
  Set<String> setForceSelect=new HashSet<String>(512);
  if (Boolean.TRUE.equals(modelConfig.getVarSelect().getForceEnable()) && CollectionUtils.isNotEmpty(modelConfig.getListForceSelect())) {
    for (    String forceSelectName : modelConfig.getListForceSelect()) {
      setForceSelect.add(CommonUtils.getRelativePigHeaderColumnName(forceSelectName));
    }
  }
  for (  ColumnConfig config : columnConfigList) {
    config.setColumnFlag(null);
    config.setColumnType(ColumnType.N);
    String varName=config.getColumnName();
    if (targetColumnName.equals(varName)) {
      config.setColumnFlag(ColumnFlag.Target);
      config.setColumnType(null);
    }
    if (setMeta.contains(varName)) {
      config.setColumnFlag(ColumnFlag.Meta);
      config.setColumnType(null);
    }
    if (setForceRemove.contains(varName)) {
      config.setColumnFlag(ColumnFlag.ForceRemove);
    }
    if (setForceSelect.contains(varName)) {
      config.setColumnFlag(ColumnFlag.ForceSelect);
    }
    if (setCategorialColumns.contains(varName)) {
      config.setColumnType(ColumnType.C);
    }
  }
}","/** 
 * Update target, listMeta, listForceSelect, listForceRemove
 * @throws IOException
 * @throws IllegalArgumentException if modelConfig is null or columnConfigList is null.
 */
public static void updateColumnConfigFlags(ModelConfig modelConfig,List<ColumnConfig> columnConfigList) throws IOException {
  String targetColumnName=CommonUtils.getRelativePigHeaderColumnName(modelConfig.getTargetColumnName());
  Set<String> setCategorialColumns=new HashSet<String>();
  if (CollectionUtils.isNotEmpty(modelConfig.getCategoricalColumnNames())) {
    for (    String column : modelConfig.getCategoricalColumnNames()) {
      setCategorialColumns.add(CommonUtils.getRelativePigHeaderColumnName(column));
    }
  }
  Set<String> setMeta=new HashSet<String>();
  if (CollectionUtils.isNotEmpty(modelConfig.getMetaColumnNames())) {
    for (    String meta : modelConfig.getMetaColumnNames()) {
      setMeta.add(CommonUtils.getRelativePigHeaderColumnName(meta));
    }
  }
  Set<String> setForceRemove=new HashSet<String>();
  if (Boolean.TRUE.equals(modelConfig.getVarSelect().getForceEnable()) && CollectionUtils.isNotEmpty(modelConfig.getListForceRemove())) {
    for (    String forceRemoveName : modelConfig.getListForceRemove()) {
      setForceRemove.add(CommonUtils.getRelativePigHeaderColumnName(forceRemoveName));
    }
  }
  Set<String> setForceSelect=new HashSet<String>(512);
  if (Boolean.TRUE.equals(modelConfig.getVarSelect().getForceEnable()) && CollectionUtils.isNotEmpty(modelConfig.getListForceSelect())) {
    for (    String forceSelectName : modelConfig.getListForceSelect()) {
      setForceSelect.add(CommonUtils.getRelativePigHeaderColumnName(forceSelectName));
    }
  }
  for (  ColumnConfig config : columnConfigList) {
    String varName=config.getColumnName();
    if (targetColumnName.equals(varName)) {
      config.setColumnFlag(ColumnFlag.Target);
      config.setColumnType(null);
    }
 else     if (setMeta.contains(varName)) {
      config.setColumnFlag(ColumnFlag.Meta);
      config.setColumnType(null);
    }
 else     if (setForceRemove.contains(varName)) {
      config.setColumnFlag(ColumnFlag.ForceRemove);
    }
 else     if (setForceSelect.contains(varName)) {
      config.setColumnFlag(ColumnFlag.ForceSelect);
    }
 else     if (setCategorialColumns.contains(varName)) {
      config.setColumnType(ColumnType.C);
    }
  }
}",0.7967445742904842
32004,"@Override public void postIteration(final MasterContext<DTMasterParams,DTWorkerParams> context){
  final int tmpModelFactor=DTrainUtils.tmpModelFactor(context.getTotalIteration());
  if (context.getCurrentIteration() % tmpModelFactor == 0) {
    Thread tmpModelPersistThread=new Thread(new Runnable(){
      @Override public void run(){
        saveTmpModelToHDFS(context.getCurrentIteration(),context.getMasterResult().getTrees());
        Path out=new Path(context.getProps().getProperty(CommonConstants.GUAGUA_OUTPUT));
        writeModelToFileSystem(context.getMasterResult().getTrees(),out);
      }
    }
,""String_Node_Str"");
    tmpModelPersistThread.setDaemon(true);
    tmpModelPersistThread.start();
  }
  updateProgressLog(context);
}","@Override public void postIteration(final MasterContext<DTMasterParams,DTWorkerParams> context){
  final int tmpModelFactor=DTrainUtils.tmpModelFactor(context.getTotalIteration());
  if (isRF) {
    if (context.getCurrentIteration() % (tmpModelFactor * 2) == 0) {
      Thread tmpModelPersistThread=new Thread(new Runnable(){
        @Override public void run(){
          saveTmpModelToHDFS(context.getCurrentIteration(),context.getMasterResult().getTrees());
          Path out=new Path(context.getProps().getProperty(CommonConstants.GUAGUA_OUTPUT));
          writeModelToFileSystem(context.getMasterResult().getTrees(),out);
        }
      }
,""String_Node_Str"");
      tmpModelPersistThread.setDaemon(true);
      tmpModelPersistThread.start();
    }
  }
 else   if (isGBDT) {
    if (context.getMasterResult().isSwitchToNextTree() && context.getMasterResult().getTrees().size() % 25 == 0) {
      final List<TreeNode> trees=context.getMasterResult().getTrees();
      if (trees.size() > 1) {
        Thread tmpModelPersistThread=new Thread(new Runnable(){
          @Override public void run(){
            List<TreeNode> subTrees=trees.subList(0,trees.size() - 1);
            saveTmpModelToHDFS(context.getCurrentIteration(),subTrees);
            Path out=new Path(context.getProps().getProperty(CommonConstants.GUAGUA_OUTPUT));
            writeModelToFileSystem(subTrees,out);
          }
        }
,""String_Node_Str"");
        tmpModelPersistThread.setDaemon(true);
        tmpModelPersistThread.start();
      }
    }
  }
  updateProgressLog(context);
}",0.6300302899177845
32005,"@Override public void run(){
  saveTmpModelToHDFS(context.getCurrentIteration(),context.getMasterResult().getTrees());
  Path out=new Path(context.getProps().getProperty(CommonConstants.GUAGUA_OUTPUT));
  writeModelToFileSystem(context.getMasterResult().getTrees(),out);
}","@Override public void run(){
  List<TreeNode> subTrees=trees.subList(0,trees.size() - 1);
  saveTmpModelToHDFS(context.getCurrentIteration(),subTrees);
  Path out=new Path(context.getProps().getProperty(CommonConstants.GUAGUA_OUTPUT));
  writeModelToFileSystem(subTrees,out);
}",0.7285974499089253
32006,"@Override public void init(WorkerContext<DTMasterParams,DTWorkerParams> context){
  Properties props=context.getProps();
  try {
    SourceType sourceType=SourceType.valueOf(props.getProperty(CommonConstants.MODELSET_SOURCE_TYPE,SourceType.HDFS.toString()));
    this.modelConfig=CommonUtils.loadModelConfig(props.getProperty(CommonConstants.SHIFU_MODEL_CONFIG),sourceType);
    this.columnConfigList=CommonUtils.loadColumnConfigList(props.getProperty(CommonConstants.SHIFU_COLUMN_CONFIG),sourceType);
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
  for (  ColumnConfig config : this.columnConfigList) {
    if (config.isCategorical()) {
      Map<String,Integer> categoryMap=new HashMap<String,Integer>();
      for (int i=0; i < config.getBinCategory().size(); i++) {
        categoryMap.put(config.getBinCategory().get(i),i);
      }
      this.categoryIndexMap.put(config.getColumnNum(),categoryMap);
    }
  }
  this.isContinuousEnabled=Boolean.TRUE.toString().equalsIgnoreCase(context.getProps().getProperty(CommonConstants.CONTINUOUS_TRAINING));
  this.workerThreadCount=modelConfig.getTrain().getWorkerThreadCount();
  this.threadPool=Executors.newFixedThreadPool(this.workerThreadCount);
  context.addCompletionCallBack(new WorkerCompletionCallBack<DTMasterParams,DTWorkerParams>(){
    @Override public void callback(    WorkerContext<DTMasterParams,DTWorkerParams> context){
      DTWorker.this.threadPool.shutdownNow();
      try {
        DTWorker.this.threadPool.awaitTermination(2,TimeUnit.SECONDS);
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
      }
    }
  }
);
  this.trainerId=Integer.valueOf(context.getProps().getProperty(CommonConstants.SHIFU_TRAINER_ID,""String_Node_Str""));
  this.isOneVsAll=modelConfig.isClassification() && modelConfig.getTrain().isOneVsAll();
  GridSearch gs=new GridSearch(modelConfig.getTrain().getParams());
  Map<String,Object> validParams=this.modelConfig.getTrain().getParams();
  if (gs.hasHyperParam()) {
    validParams=gs.getParams(this.trainerId);
    LOG.info(""String_Node_Str"",validParams);
  }
  this.treeNum=Integer.valueOf(validParams.get(""String_Node_Str"").toString());
  double memoryFraction=Double.valueOf(context.getProps().getProperty(""String_Node_Str"",""String_Node_Str""));
  LOG.info(""String_Node_Str"",Runtime.getRuntime().maxMemory(),memoryFraction);
  double validationRate=this.modelConfig.getCrossValidationRate();
  if (Double.compare(validationRate,0d) != 0) {
    this.trainingData=new MemoryLimitedList<Data>((long)(Runtime.getRuntime().maxMemory() * memoryFraction * (1 - validationRate)),new LinkedList<Data>());
    this.validationData=new MemoryLimitedList<Data>((long)(Runtime.getRuntime().maxMemory() * memoryFraction * validationRate),new LinkedList<Data>());
  }
 else {
    this.trainingData=new MemoryLimitedList<Data>((long)(Runtime.getRuntime().maxMemory() * memoryFraction),new LinkedList<Data>());
  }
  int[] inputOutputIndex=DTrainUtils.getNumericAndCategoricalInputAndOutputCounts(this.columnConfigList);
  this.numericInputCount=inputOutputIndex[0];
  this.categoricalInputCount=inputOutputIndex[1];
  this.outputNodeCount=modelConfig.isRegression() ? inputOutputIndex[2] : modelConfig.getTags().size();
  this.isAfterVarSelect=inputOutputIndex[3] == 1 ? true : false;
  this.rng=new PoissonDistribution[treeNum];
  for (int i=0; i < treeNum; i++) {
    this.rng[i]=new PoissonDistribution(this.modelConfig.getTrain().getBaggingSampleRate());
  }
  int numClasses=this.modelConfig.isClassification() ? this.modelConfig.getTags().size() : 2;
  String imStr=validParams.get(""String_Node_Str"").toString();
  int minInstancesPerNode=Integer.valueOf(validParams.get(""String_Node_Str"").toString());
  double minInfoGain=Double.valueOf(validParams.get(""String_Node_Str"").toString());
  if (imStr.equalsIgnoreCase(""String_Node_Str"")) {
    impurity=new Entropy(numClasses,minInstancesPerNode,minInfoGain);
  }
 else   if (imStr.equalsIgnoreCase(""String_Node_Str"")) {
    impurity=new Gini(numClasses,minInstancesPerNode,minInfoGain);
  }
 else   if (imStr.equalsIgnoreCase(""String_Node_Str"")) {
    impurity=new FriedmanMSE(minInstancesPerNode,minInfoGain);
  }
 else {
    impurity=new Variance(minInstancesPerNode,minInfoGain);
  }
  this.isRF=ALGORITHM.RF.toString().equalsIgnoreCase(modelConfig.getAlgorithm());
  this.isGBDT=ALGORITHM.GBT.toString().equalsIgnoreCase(modelConfig.getAlgorithm());
  String lossStr=validParams.get(""String_Node_Str"").toString();
  if (lossStr.equalsIgnoreCase(""String_Node_Str"")) {
    this.loss=new LogLoss();
  }
 else   if (lossStr.equalsIgnoreCase(""String_Node_Str"")) {
    this.loss=new AbsoluteLoss();
  }
 else {
    this.loss=new SquaredLoss();
  }
  if (this.isGBDT) {
    this.learningRate=Double.valueOf(validParams.get(NNTrainer.LEARNING_RATE).toString());
    Object swrObj=validParams.get(""String_Node_Str"");
    if (swrObj != null) {
      this.gbdtSampleWithReplacement=Boolean.TRUE.toString().equalsIgnoreCase(swrObj.toString());
    }
  }
  LOG.info(""String_Node_Str"",isAfterVarSelect,treeNum,impurity.getClass().getName(),loss.getClass().getName(),this.learningRate,this.gbdtSampleWithReplacement,this.isRF,this.isGBDT);
}","@Override public void init(WorkerContext<DTMasterParams,DTWorkerParams> context){
  Properties props=context.getProps();
  try {
    SourceType sourceType=SourceType.valueOf(props.getProperty(CommonConstants.MODELSET_SOURCE_TYPE,SourceType.HDFS.toString()));
    this.modelConfig=CommonUtils.loadModelConfig(props.getProperty(CommonConstants.SHIFU_MODEL_CONFIG),sourceType);
    this.columnConfigList=CommonUtils.loadColumnConfigList(props.getProperty(CommonConstants.SHIFU_COLUMN_CONFIG),sourceType);
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
  for (  ColumnConfig config : this.columnConfigList) {
    if (config.isCategorical()) {
      Map<String,Integer> categoryMap=new HashMap<String,Integer>();
      for (int i=0; i < config.getBinCategory().size(); i++) {
        categoryMap.put(config.getBinCategory().get(i),i);
      }
      this.categoryIndexMap.put(config.getColumnNum(),categoryMap);
    }
  }
  this.isContinuousEnabled=Boolean.TRUE.toString().equalsIgnoreCase(context.getProps().getProperty(CommonConstants.CONTINUOUS_TRAINING));
  this.workerThreadCount=modelConfig.getTrain().getWorkerThreadCount();
  this.threadPool=Executors.newFixedThreadPool(this.workerThreadCount);
  context.addCompletionCallBack(new WorkerCompletionCallBack<DTMasterParams,DTWorkerParams>(){
    @Override public void callback(    WorkerContext<DTMasterParams,DTWorkerParams> context){
      DTWorker.this.threadPool.shutdownNow();
      try {
        DTWorker.this.threadPool.awaitTermination(2,TimeUnit.SECONDS);
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
      }
    }
  }
);
  this.trainerId=Integer.valueOf(context.getProps().getProperty(CommonConstants.SHIFU_TRAINER_ID,""String_Node_Str""));
  this.isOneVsAll=modelConfig.isClassification() && modelConfig.getTrain().isOneVsAll();
  GridSearch gs=new GridSearch(modelConfig.getTrain().getParams());
  Map<String,Object> validParams=this.modelConfig.getTrain().getParams();
  if (gs.hasHyperParam()) {
    validParams=gs.getParams(this.trainerId);
    LOG.info(""String_Node_Str"",validParams);
  }
  this.treeNum=Integer.valueOf(validParams.get(""String_Node_Str"").toString());
  double memoryFraction=Double.valueOf(context.getProps().getProperty(""String_Node_Str"",""String_Node_Str""));
  LOG.info(""String_Node_Str"",Runtime.getRuntime().maxMemory(),memoryFraction);
  double validationRate=this.modelConfig.getCrossValidationRate();
  if (Double.compare(validationRate,0d) != 0) {
    this.trainingData=new MemoryLimitedList<Data>((long)(Runtime.getRuntime().maxMemory() * memoryFraction * (1 - validationRate)),new LinkedList<Data>());
    this.validationData=new MemoryLimitedList<Data>((long)(Runtime.getRuntime().maxMemory() * memoryFraction * validationRate),new LinkedList<Data>());
  }
 else {
    this.trainingData=new MemoryLimitedList<Data>((long)(Runtime.getRuntime().maxMemory() * memoryFraction),new LinkedList<Data>());
  }
  int[] inputOutputIndex=DTrainUtils.getNumericAndCategoricalInputAndOutputCounts(this.columnConfigList);
  this.numericInputCount=inputOutputIndex[0];
  this.categoricalInputCount=inputOutputIndex[1];
  this.outputNodeCount=modelConfig.isRegression() ? inputOutputIndex[2] : modelConfig.getTags().size();
  this.isAfterVarSelect=inputOutputIndex[3] == 1 ? true : false;
  this.rng=new PoissonDistribution[treeNum];
  for (int i=0; i < treeNum; i++) {
    this.rng[i]=new PoissonDistribution(this.modelConfig.getTrain().getBaggingSampleRate());
  }
  int numClasses=this.modelConfig.isClassification() ? this.modelConfig.getTags().size() : 2;
  String imStr=validParams.get(""String_Node_Str"").toString();
  int minInstancesPerNode=Integer.valueOf(validParams.get(""String_Node_Str"").toString());
  double minInfoGain=Double.valueOf(validParams.get(""String_Node_Str"").toString());
  if (imStr.equalsIgnoreCase(""String_Node_Str"")) {
    impurity=new Entropy(numClasses,minInstancesPerNode,minInfoGain);
  }
 else   if (imStr.equalsIgnoreCase(""String_Node_Str"")) {
    impurity=new Gini(numClasses,minInstancesPerNode,minInfoGain);
  }
 else   if (imStr.equalsIgnoreCase(""String_Node_Str"")) {
    impurity=new FriedmanMSE(minInstancesPerNode,minInfoGain);
  }
 else {
    impurity=new Variance(minInstancesPerNode,minInfoGain);
  }
  this.isRF=ALGORITHM.RF.toString().equalsIgnoreCase(modelConfig.getAlgorithm());
  this.isGBDT=ALGORITHM.GBT.toString().equalsIgnoreCase(modelConfig.getAlgorithm());
  String lossStr=validParams.get(""String_Node_Str"").toString();
  if (lossStr.equalsIgnoreCase(""String_Node_Str"")) {
    this.loss=new LogLoss();
  }
 else   if (lossStr.equalsIgnoreCase(""String_Node_Str"")) {
    this.loss=new AbsoluteLoss();
  }
 else   if (lossStr.equalsIgnoreCase(""String_Node_Str"")) {
    this.loss=new HalfGradSquaredLoss();
  }
 else {
    this.loss=new SquaredLoss();
  }
  if (this.isGBDT) {
    this.learningRate=Double.valueOf(validParams.get(NNTrainer.LEARNING_RATE).toString());
    Object swrObj=validParams.get(""String_Node_Str"");
    if (swrObj != null) {
      this.gbdtSampleWithReplacement=Boolean.TRUE.toString().equalsIgnoreCase(swrObj.toString());
    }
  }
  LOG.info(""String_Node_Str"",isAfterVarSelect,treeNum,impurity.getClass().getName(),loss.getClass().getName(),this.learningRate,this.gbdtSampleWithReplacement,this.isRF,this.isGBDT);
}",0.9901626939084374
32007,"/** 
 * Check the setting for model training. It will make sure (num_of_layers > 0 && num_of_layers = hidden_nodes_size && num_of_layse = active_func_size)
 * @param train - @ModelTrainConf to check
 * @return @ValidateResult
 */
@SuppressWarnings(""String_Node_Str"") private ValidateResult checkTrainSetting(ModelConfig modelConfig,ModelTrainConf train){
  ValidateResult result=new ValidateResult(true);
  if (train.getBaggingNum() == null || train.getBaggingNum() < 0) {
    ValidateResult tmpResult=new ValidateResult(true);
    tmpResult.setStatus(false);
    tmpResult.getCauses().add(""String_Node_Str"");
    result=ValidateResult.mergeResult(result,tmpResult);
  }
  if (train.getBaggingSampleRate() == null || train.getBaggingSampleRate().compareTo(Double.valueOf(0)) <= 0 || train.getBaggingSampleRate().compareTo(Double.valueOf(1)) > 0) {
    ValidateResult tmpResult=new ValidateResult(true);
    tmpResult.setStatus(false);
    tmpResult.getCauses().add(""String_Node_Str"");
    result=ValidateResult.mergeResult(result,tmpResult);
  }
  if (train.getValidSetRate() == null || train.getValidSetRate().compareTo(Double.valueOf(0)) < 0 || train.getValidSetRate().compareTo(Double.valueOf(1)) >= 0) {
    ValidateResult tmpResult=new ValidateResult(true);
    tmpResult.setStatus(false);
    tmpResult.getCauses().add(""String_Node_Str"");
    result=ValidateResult.mergeResult(result,tmpResult);
  }
  if (train.getNumTrainEpochs() == null || train.getNumTrainEpochs() <= 0) {
    ValidateResult tmpResult=new ValidateResult(true);
    tmpResult.setStatus(false);
    tmpResult.getCauses().add(""String_Node_Str"");
    result=ValidateResult.mergeResult(result,tmpResult);
  }
  if (train.getEpochsPerIteration() != null && train.getEpochsPerIteration() <= 0) {
    ValidateResult tmpResult=new ValidateResult(true);
    tmpResult.setStatus(false);
    tmpResult.getCauses().add(""String_Node_Str"");
    result=ValidateResult.mergeResult(result,tmpResult);
  }
  if (train.getWorkerThreadCount() != null && (train.getWorkerThreadCount() <= 0 || train.getWorkerThreadCount() > 32)) {
    ValidateResult tmpResult=new ValidateResult(true);
    tmpResult.setStatus(false);
    tmpResult.getCauses().add(""String_Node_Str"");
    result=ValidateResult.mergeResult(result,tmpResult);
  }
  if (train.getConvergenceThreshold() != null && train.getConvergenceThreshold().compareTo(0.0) < 0) {
    ValidateResult tmpResult=new ValidateResult(true);
    tmpResult.setStatus(false);
    tmpResult.getCauses().add(""String_Node_Str"");
    result=ValidateResult.mergeResult(result,tmpResult);
  }
  if (modelConfig.isClassification() && train.isOneVsAll() && !CommonUtils.isDesicionTreeAlgorithm(train.getAlgorithm())&& !train.getAlgorithm().equalsIgnoreCase(""String_Node_Str"")) {
    ValidateResult tmpResult=new ValidateResult(true);
    tmpResult.setStatus(false);
    tmpResult.getCauses().add(""String_Node_Str"");
    result=ValidateResult.mergeResult(result,tmpResult);
  }
  if (modelConfig.isClassification() && train.getMultiClassifyMethod() == MultipleClassification.NATIVE && train.getAlgorithm().equalsIgnoreCase(CommonConstants.RF_ALG_NAME)) {
    Object impurity=train.getParams().get(""String_Node_Str"");
    if (impurity != null && !""String_Node_Str"".equalsIgnoreCase(impurity.toString()) && !""String_Node_Str"".equalsIgnoreCase(impurity.toString())) {
      ValidateResult tmpResult=new ValidateResult(true);
      tmpResult.setStatus(false);
      tmpResult.getCauses().add(""String_Node_Str"");
      result=ValidateResult.mergeResult(result,tmpResult);
    }
  }
  GridSearch gs=new GridSearch(train.getParams());
  if (modelConfig.isRegression() && !gs.hasHyperParam()) {
    if (train.getAlgorithm().equalsIgnoreCase(""String_Node_Str"")) {
      Map<String,Object> params=train.getParams();
      int layerCnt=(Integer)params.get(NNTrainer.NUM_HIDDEN_LAYERS);
      if (layerCnt < 0) {
        ValidateResult tmpResult=new ValidateResult(true);
        tmpResult.setStatus(false);
        tmpResult.getCauses().add(""String_Node_Str"");
        result=ValidateResult.mergeResult(result,tmpResult);
      }
      List<Integer> hiddenNode=(List<Integer>)params.get(NNTrainer.NUM_HIDDEN_NODES);
      List<String> activateFucs=(List<String>)params.get(NNTrainer.ACTIVATION_FUNC);
      if (hiddenNode.size() != activateFucs.size() || layerCnt != activateFucs.size()) {
        ValidateResult tmpResult=new ValidateResult(true);
        tmpResult.setStatus(false);
        tmpResult.getCauses().add(NNTrainer.NUM_HIDDEN_LAYERS + ""String_Node_Str"" + NNTrainer.NUM_HIDDEN_NODES+ ""String_Node_Str""+ ""String_Node_Str""+ NNTrainer.ACTIVATION_FUNC+ ""String_Node_Str""+ ""String_Node_Str"");
        result=ValidateResult.mergeResult(result,tmpResult);
      }
      Double learningRate=Double.valueOf(params.get(NNTrainer.LEARNING_RATE).toString());
      if (learningRate != null && (learningRate.compareTo(Double.valueOf(0)) <= 0)) {
        ValidateResult tmpResult=new ValidateResult(true);
        tmpResult.setStatus(false);
        tmpResult.getCauses().add(""String_Node_Str"");
        result=ValidateResult.mergeResult(result,tmpResult);
      }
      Object learningDecayO=params.get(""String_Node_Str"");
      if (learningDecayO != null) {
        Double learningDecay=Double.valueOf(learningDecayO.toString());
        if (learningDecay != null && ((learningDecay.compareTo(Double.valueOf(0)) < 0) || (learningDecay.compareTo(Double.valueOf(1)) >= 0))) {
          ValidateResult tmpResult=new ValidateResult(true);
          tmpResult.setStatus(false);
          tmpResult.getCauses().add(""String_Node_Str"");
          result=ValidateResult.mergeResult(result,tmpResult);
        }
      }
    }
    if (train.getAlgorithm().equalsIgnoreCase(CommonConstants.GBT_ALG_NAME) || train.getAlgorithm().equalsIgnoreCase(CommonConstants.RF_ALG_NAME)) {
      Map<String,Object> params=train.getParams();
      if (train.getAlgorithm().equalsIgnoreCase(CommonConstants.GBT_ALG_NAME)) {
        Object loss=params.get(""String_Node_Str"");
        if (loss != null && !""String_Node_Str"".equalsIgnoreCase(loss.toString()) && !""String_Node_Str"".equalsIgnoreCase(loss.toString()) && !""String_Node_Str"".equalsIgnoreCase(loss.toString())) {
          ValidateResult tmpResult=new ValidateResult(true);
          tmpResult.setStatus(false);
          tmpResult.getCauses().add(""String_Node_Str"");
          result=ValidateResult.mergeResult(result,tmpResult);
        }
      }
      Object maxDepthObj=params.get(""String_Node_Str"");
      if (maxDepthObj != null) {
        int maxDepth=Integer.valueOf(maxDepthObj.toString());
        if (maxDepth <= 0 || maxDepth > 20) {
          ValidateResult tmpResult=new ValidateResult(true);
          tmpResult.setStatus(false);
          tmpResult.getCauses().add(""String_Node_Str"");
          result=ValidateResult.mergeResult(result,tmpResult);
        }
      }
      Object maxStatsMemoryMBObj=params.get(""String_Node_Str"");
      if (maxStatsMemoryMBObj != null) {
        int maxStatsMemoryMB=Integer.valueOf(maxStatsMemoryMBObj.toString());
        if (maxStatsMemoryMB <= 0) {
          ValidateResult tmpResult=new ValidateResult(true);
          tmpResult.setStatus(false);
          tmpResult.getCauses().add(""String_Node_Str"");
          result=ValidateResult.mergeResult(result,tmpResult);
        }
      }
      if (train.getAlgorithm().equalsIgnoreCase(CommonConstants.GBT_ALG_NAME)) {
        Object learningRateObj=params.get(NNTrainer.LEARNING_RATE);
        if (learningRateObj != null) {
          Double learningRate=Double.valueOf(learningRateObj.toString());
          if (learningRate != null && (learningRate.compareTo(Double.valueOf(0)) <= 0)) {
            ValidateResult tmpResult=new ValidateResult(true);
            tmpResult.setStatus(false);
            tmpResult.getCauses().add(""String_Node_Str"");
            result=ValidateResult.mergeResult(result,tmpResult);
          }
        }
      }
      Object minInstancesPerNodeObj=params.get(""String_Node_Str"");
      if (minInstancesPerNodeObj != null) {
        int minInstancesPerNode=Integer.valueOf(minInstancesPerNodeObj.toString());
        if (minInstancesPerNode <= 0) {
          ValidateResult tmpResult=new ValidateResult(true);
          tmpResult.setStatus(false);
          tmpResult.getCauses().add(""String_Node_Str"");
          result=ValidateResult.mergeResult(result,tmpResult);
        }
      }
      Object treeNumObj=params.get(""String_Node_Str"");
      if (treeNumObj != null) {
        int treeNum=Integer.valueOf(treeNumObj.toString());
        if (treeNum <= 0 || treeNum > 2000) {
          ValidateResult tmpResult=new ValidateResult(true);
          tmpResult.setStatus(false);
          tmpResult.getCauses().add(""String_Node_Str"");
          result=ValidateResult.mergeResult(result,tmpResult);
        }
      }
      Object minInfoGainObj=params.get(""String_Node_Str"");
      if (minInfoGainObj != null) {
        Double minInfoGain=Double.valueOf(minInfoGainObj.toString());
        if (minInfoGain != null && (minInfoGain.compareTo(Double.valueOf(0)) < 0)) {
          ValidateResult tmpResult=new ValidateResult(true);
          tmpResult.setStatus(false);
          tmpResult.getCauses().add(""String_Node_Str"");
          result=ValidateResult.mergeResult(result,tmpResult);
        }
      }
      Object impurityObj=params.get(""String_Node_Str"");
      if (train.getAlgorithm().equalsIgnoreCase(CommonConstants.GBT_ALG_NAME)) {
        if (impurityObj != null && !""String_Node_Str"".equalsIgnoreCase(impurityObj.toString()) && !""String_Node_Str"".equalsIgnoreCase(impurityObj.toString())) {
          ValidateResult tmpResult=new ValidateResult(true);
          tmpResult.setStatus(false);
          tmpResult.getCauses().add(""String_Node_Str"");
          result=ValidateResult.mergeResult(result,tmpResult);
        }
      }
      if (train.getAlgorithm().equalsIgnoreCase(CommonConstants.RF_ALG_NAME)) {
        if (impurityObj != null && !""String_Node_Str"".equalsIgnoreCase(impurityObj.toString()) && !""String_Node_Str"".equalsIgnoreCase(impurityObj.toString()) && !""String_Node_Str"".equalsIgnoreCase(impurityObj.toString()) && !""String_Node_Str"".equalsIgnoreCase(impurityObj.toString())) {
          ValidateResult tmpResult=new ValidateResult(true);
          tmpResult.setStatus(false);
          tmpResult.getCauses().add(""String_Node_Str"");
          result=ValidateResult.mergeResult(result,tmpResult);
        }
      }
    }
  }
  return result;
}","/** 
 * Check the setting for model training. It will make sure (num_of_layers > 0 && num_of_layers = hidden_nodes_size && num_of_layse = active_func_size)
 * @param train - @ModelTrainConf to check
 * @return @ValidateResult
 */
@SuppressWarnings(""String_Node_Str"") private ValidateResult checkTrainSetting(ModelConfig modelConfig,ModelTrainConf train){
  ValidateResult result=new ValidateResult(true);
  if (train.getBaggingNum() == null || train.getBaggingNum() < 0) {
    ValidateResult tmpResult=new ValidateResult(true);
    tmpResult.setStatus(false);
    tmpResult.getCauses().add(""String_Node_Str"");
    result=ValidateResult.mergeResult(result,tmpResult);
  }
  if (train.getBaggingSampleRate() == null || train.getBaggingSampleRate().compareTo(Double.valueOf(0)) <= 0 || train.getBaggingSampleRate().compareTo(Double.valueOf(1)) > 0) {
    ValidateResult tmpResult=new ValidateResult(true);
    tmpResult.setStatus(false);
    tmpResult.getCauses().add(""String_Node_Str"");
    result=ValidateResult.mergeResult(result,tmpResult);
  }
  if (train.getValidSetRate() == null || train.getValidSetRate().compareTo(Double.valueOf(0)) < 0 || train.getValidSetRate().compareTo(Double.valueOf(1)) >= 0) {
    ValidateResult tmpResult=new ValidateResult(true);
    tmpResult.setStatus(false);
    tmpResult.getCauses().add(""String_Node_Str"");
    result=ValidateResult.mergeResult(result,tmpResult);
  }
  if (train.getNumTrainEpochs() == null || train.getNumTrainEpochs() <= 0) {
    ValidateResult tmpResult=new ValidateResult(true);
    tmpResult.setStatus(false);
    tmpResult.getCauses().add(""String_Node_Str"");
    result=ValidateResult.mergeResult(result,tmpResult);
  }
  if (train.getEpochsPerIteration() != null && train.getEpochsPerIteration() <= 0) {
    ValidateResult tmpResult=new ValidateResult(true);
    tmpResult.setStatus(false);
    tmpResult.getCauses().add(""String_Node_Str"");
    result=ValidateResult.mergeResult(result,tmpResult);
  }
  if (train.getWorkerThreadCount() != null && (train.getWorkerThreadCount() <= 0 || train.getWorkerThreadCount() > 32)) {
    ValidateResult tmpResult=new ValidateResult(true);
    tmpResult.setStatus(false);
    tmpResult.getCauses().add(""String_Node_Str"");
    result=ValidateResult.mergeResult(result,tmpResult);
  }
  if (train.getConvergenceThreshold() != null && train.getConvergenceThreshold().compareTo(0.0) < 0) {
    ValidateResult tmpResult=new ValidateResult(true);
    tmpResult.setStatus(false);
    tmpResult.getCauses().add(""String_Node_Str"");
    result=ValidateResult.mergeResult(result,tmpResult);
  }
  if (modelConfig.isClassification() && train.isOneVsAll() && !CommonUtils.isDesicionTreeAlgorithm(train.getAlgorithm())&& !train.getAlgorithm().equalsIgnoreCase(""String_Node_Str"")) {
    ValidateResult tmpResult=new ValidateResult(true);
    tmpResult.setStatus(false);
    tmpResult.getCauses().add(""String_Node_Str"");
    result=ValidateResult.mergeResult(result,tmpResult);
  }
  if (modelConfig.isClassification() && train.getMultiClassifyMethod() == MultipleClassification.NATIVE && train.getAlgorithm().equalsIgnoreCase(CommonConstants.RF_ALG_NAME)) {
    Object impurity=train.getParams().get(""String_Node_Str"");
    if (impurity != null && !""String_Node_Str"".equalsIgnoreCase(impurity.toString()) && !""String_Node_Str"".equalsIgnoreCase(impurity.toString())) {
      ValidateResult tmpResult=new ValidateResult(true);
      tmpResult.setStatus(false);
      tmpResult.getCauses().add(""String_Node_Str"");
      result=ValidateResult.mergeResult(result,tmpResult);
    }
  }
  GridSearch gs=new GridSearch(train.getParams());
  if (modelConfig.isRegression() && !gs.hasHyperParam()) {
    if (train.getAlgorithm().equalsIgnoreCase(""String_Node_Str"")) {
      Map<String,Object> params=train.getParams();
      int layerCnt=(Integer)params.get(NNTrainer.NUM_HIDDEN_LAYERS);
      if (layerCnt < 0) {
        ValidateResult tmpResult=new ValidateResult(true);
        tmpResult.setStatus(false);
        tmpResult.getCauses().add(""String_Node_Str"");
        result=ValidateResult.mergeResult(result,tmpResult);
      }
      List<Integer> hiddenNode=(List<Integer>)params.get(NNTrainer.NUM_HIDDEN_NODES);
      List<String> activateFucs=(List<String>)params.get(NNTrainer.ACTIVATION_FUNC);
      if (hiddenNode.size() != activateFucs.size() || layerCnt != activateFucs.size()) {
        ValidateResult tmpResult=new ValidateResult(true);
        tmpResult.setStatus(false);
        tmpResult.getCauses().add(NNTrainer.NUM_HIDDEN_LAYERS + ""String_Node_Str"" + NNTrainer.NUM_HIDDEN_NODES+ ""String_Node_Str""+ ""String_Node_Str""+ NNTrainer.ACTIVATION_FUNC+ ""String_Node_Str""+ ""String_Node_Str"");
        result=ValidateResult.mergeResult(result,tmpResult);
      }
      Double learningRate=Double.valueOf(params.get(NNTrainer.LEARNING_RATE).toString());
      if (learningRate != null && (learningRate.compareTo(Double.valueOf(0)) <= 0)) {
        ValidateResult tmpResult=new ValidateResult(true);
        tmpResult.setStatus(false);
        tmpResult.getCauses().add(""String_Node_Str"");
        result=ValidateResult.mergeResult(result,tmpResult);
      }
      Object learningDecayO=params.get(""String_Node_Str"");
      if (learningDecayO != null) {
        Double learningDecay=Double.valueOf(learningDecayO.toString());
        if (learningDecay != null && ((learningDecay.compareTo(Double.valueOf(0)) < 0) || (learningDecay.compareTo(Double.valueOf(1)) >= 0))) {
          ValidateResult tmpResult=new ValidateResult(true);
          tmpResult.setStatus(false);
          tmpResult.getCauses().add(""String_Node_Str"");
          result=ValidateResult.mergeResult(result,tmpResult);
        }
      }
    }
    if (train.getAlgorithm().equalsIgnoreCase(CommonConstants.GBT_ALG_NAME) || train.getAlgorithm().equalsIgnoreCase(CommonConstants.RF_ALG_NAME)) {
      Map<String,Object> params=train.getParams();
      if (train.getAlgorithm().equalsIgnoreCase(CommonConstants.GBT_ALG_NAME)) {
        Object loss=params.get(""String_Node_Str"");
        if (loss != null && !""String_Node_Str"".equalsIgnoreCase(loss.toString()) && !""String_Node_Str"".equalsIgnoreCase(loss.toString()) && !""String_Node_Str"".equalsIgnoreCase(loss.toString()) && !""String_Node_Str"".equalsIgnoreCase(loss.toString())) {
          ValidateResult tmpResult=new ValidateResult(true);
          tmpResult.setStatus(false);
          tmpResult.getCauses().add(""String_Node_Str"");
          result=ValidateResult.mergeResult(result,tmpResult);
        }
      }
      Object maxDepthObj=params.get(""String_Node_Str"");
      if (maxDepthObj != null) {
        int maxDepth=Integer.valueOf(maxDepthObj.toString());
        if (maxDepth <= 0 || maxDepth > 20) {
          ValidateResult tmpResult=new ValidateResult(true);
          tmpResult.setStatus(false);
          tmpResult.getCauses().add(""String_Node_Str"");
          result=ValidateResult.mergeResult(result,tmpResult);
        }
      }
      Object maxStatsMemoryMBObj=params.get(""String_Node_Str"");
      if (maxStatsMemoryMBObj != null) {
        int maxStatsMemoryMB=Integer.valueOf(maxStatsMemoryMBObj.toString());
        if (maxStatsMemoryMB <= 0) {
          ValidateResult tmpResult=new ValidateResult(true);
          tmpResult.setStatus(false);
          tmpResult.getCauses().add(""String_Node_Str"");
          result=ValidateResult.mergeResult(result,tmpResult);
        }
      }
      if (train.getAlgorithm().equalsIgnoreCase(CommonConstants.GBT_ALG_NAME)) {
        Object learningRateObj=params.get(NNTrainer.LEARNING_RATE);
        if (learningRateObj != null) {
          Double learningRate=Double.valueOf(learningRateObj.toString());
          if (learningRate != null && (learningRate.compareTo(Double.valueOf(0)) <= 0)) {
            ValidateResult tmpResult=new ValidateResult(true);
            tmpResult.setStatus(false);
            tmpResult.getCauses().add(""String_Node_Str"");
            result=ValidateResult.mergeResult(result,tmpResult);
          }
        }
      }
      Object minInstancesPerNodeObj=params.get(""String_Node_Str"");
      if (minInstancesPerNodeObj != null) {
        int minInstancesPerNode=Integer.valueOf(minInstancesPerNodeObj.toString());
        if (minInstancesPerNode <= 0) {
          ValidateResult tmpResult=new ValidateResult(true);
          tmpResult.setStatus(false);
          tmpResult.getCauses().add(""String_Node_Str"");
          result=ValidateResult.mergeResult(result,tmpResult);
        }
      }
      Object treeNumObj=params.get(""String_Node_Str"");
      if (treeNumObj != null) {
        int treeNum=Integer.valueOf(treeNumObj.toString());
        if (treeNum <= 0 || treeNum > 2000) {
          ValidateResult tmpResult=new ValidateResult(true);
          tmpResult.setStatus(false);
          tmpResult.getCauses().add(""String_Node_Str"");
          result=ValidateResult.mergeResult(result,tmpResult);
        }
      }
      Object minInfoGainObj=params.get(""String_Node_Str"");
      if (minInfoGainObj != null) {
        Double minInfoGain=Double.valueOf(minInfoGainObj.toString());
        if (minInfoGain != null && (minInfoGain.compareTo(Double.valueOf(0)) < 0)) {
          ValidateResult tmpResult=new ValidateResult(true);
          tmpResult.setStatus(false);
          tmpResult.getCauses().add(""String_Node_Str"");
          result=ValidateResult.mergeResult(result,tmpResult);
        }
      }
      Object impurityObj=params.get(""String_Node_Str"");
      if (train.getAlgorithm().equalsIgnoreCase(CommonConstants.GBT_ALG_NAME)) {
        if (impurityObj != null && !""String_Node_Str"".equalsIgnoreCase(impurityObj.toString()) && !""String_Node_Str"".equalsIgnoreCase(impurityObj.toString())) {
          ValidateResult tmpResult=new ValidateResult(true);
          tmpResult.setStatus(false);
          tmpResult.getCauses().add(""String_Node_Str"");
          result=ValidateResult.mergeResult(result,tmpResult);
        }
      }
      if (train.getAlgorithm().equalsIgnoreCase(CommonConstants.RF_ALG_NAME)) {
        if (impurityObj != null && !""String_Node_Str"".equalsIgnoreCase(impurityObj.toString()) && !""String_Node_Str"".equalsIgnoreCase(impurityObj.toString()) && !""String_Node_Str"".equalsIgnoreCase(impurityObj.toString()) && !""String_Node_Str"".equalsIgnoreCase(impurityObj.toString())) {
          ValidateResult tmpResult=new ValidateResult(true);
          tmpResult.setStatus(false);
          tmpResult.getCauses().add(""String_Node_Str"");
          result=ValidateResult.mergeResult(result,tmpResult);
        }
      }
    }
  }
  return result;
}",0.99734219269103
32008,"private InternalEntropyInfo getGiniInfo(double[] statsByClasses){
  double sumAll=0;
  for (int i=0; i < statsByClasses.length; i++) {
    sumAll+=statsByClasses[i];
  }
  double impurity=0d;
  int indexOfLargestElement=-1;
  if (sumAll != 0d) {
    double maxElement=Double.MIN_VALUE;
    for (int i=0; i < statsByClasses.length; i++) {
      double rate=statsByClasses[i] / sumAll;
      impurity-=rate * rate;
      if (statsByClasses[i] > maxElement) {
        maxElement=statsByClasses[i];
        indexOfLargestElement=i;
      }
    }
  }
  return new InternalEntropyInfo(sumAll,indexOfLargestElement,impurity);
}","private InternalGiniInfo getGiniInfo(double[] statsByClasses){
  double sumAll=0;
  for (int i=0; i < statsByClasses.length; i++) {
    sumAll+=statsByClasses[i];
  }
  double impurity=0d;
  int indexOfLargestElement=-1;
  if (sumAll != 0d) {
    double maxElement=Double.MIN_VALUE;
    for (int i=0; i < statsByClasses.length; i++) {
      double rate=statsByClasses[i] / sumAll;
      impurity-=rate * rate;
      if (statsByClasses[i] > maxElement) {
        maxElement=statsByClasses[i];
        indexOfLargestElement=i;
      }
    }
  }
  return new InternalGiniInfo(sumAll,indexOfLargestElement,impurity);
}",0.9821717990275528
32009,"@Override public GainInfo computeImpurity(double[] stats,ColumnConfig config){
  int numClasses=super.statsSize;
  double[] statsByClasses=new double[numClasses];
  for (int i=0; i < stats.length / numClasses; i++) {
    for (int j=0; j < numClasses; j++) {
      double oneStatValue=stats[i * super.statsSize + j];
      statsByClasses[j]+=oneStatValue;
    }
  }
  List<Pair> categoricalOrderList=null;
  if (config.isCategorical()) {
    categoricalOrderList=getCategoricalOrderList(stats,stats.length / super.statsSize);
  }
  InternalEntropyInfo info=getGiniInfo(statsByClasses);
  Predict predict=new Predict(info.sumAll == 0d ? 0d : statsByClasses[1] / info.sumAll,info.indexOfLargestElement);
  double[] leftStatByClasses=new double[numClasses];
  double[] rightStatByClasses=new double[numClasses];
  List<GainInfo> internalGainList=new ArrayList<GainInfo>();
  Set<String> leftCategories=config.isCategorical() ? new HashSet<String>() : null;
  for (int i=0; i < (stats.length / numClasses - 1); i++) {
    int index=i;
    if (config.isCategorical()) {
      index=categoricalOrderList.get(i).index;
    }
    for (int j=0; j < leftStatByClasses.length; j++) {
      leftStatByClasses[j]+=stats[index * numClasses + j];
    }
    InternalEntropyInfo leftInfo=getGiniInfo(leftStatByClasses);
    Predict leftPredict=new Predict(leftInfo.sumAll == 0d ? 0d : leftStatByClasses[1] / leftInfo.sumAll,leftInfo.indexOfLargestElement);
    for (int j=0; j < leftStatByClasses.length; j++) {
      rightStatByClasses[j]=statsByClasses[j] - leftStatByClasses[j];
    }
    InternalEntropyInfo rightInfo=getGiniInfo(rightStatByClasses);
    if (leftInfo.sumAll <= minInstancesPerNode || rightInfo.sumAll <= minInstancesPerNode) {
      continue;
    }
    Predict rightPredict=new Predict(rightInfo.sumAll == 0d ? 0d : rightStatByClasses[1] / rightInfo.sumAll,rightInfo.indexOfLargestElement);
    double leftWeight=info.sumAll == 0d ? 0d : (leftInfo.sumAll / info.sumAll);
    double rightWeight=info.sumAll == 0d ? 0d : (rightInfo.sumAll / info.sumAll);
    double gain=info.impurity - leftWeight * leftInfo.impurity - rightWeight * rightInfo.impurity;
    if (gain <= minInfoGain) {
      continue;
    }
    Split split=null;
    if (config.isCategorical()) {
      leftCategories.add(config.getBinCategory().get(i));
      split=new Split(config.getColumnNum(),FeatureType.CATEGORICAL,0d,leftCategories);
    }
 else {
      split=new Split(config.getColumnNum(),FeatureType.CONTINUOUS,config.getBinBoundary().get(i + 1),null);
    }
    internalGainList.add(new GainInfo(gain,info.impurity,predict,leftInfo.impurity,rightInfo.impurity,leftPredict,rightPredict,split));
  }
  return GainInfo.getGainInfoByMaxGain(internalGainList);
}","@Override public GainInfo computeImpurity(double[] stats,ColumnConfig config){
  int numClasses=super.statsSize;
  double[] statsByClasses=new double[numClasses];
  for (int i=0; i < stats.length / numClasses; i++) {
    for (int j=0; j < numClasses; j++) {
      double oneStatValue=stats[i * super.statsSize + j];
      statsByClasses[j]+=oneStatValue;
    }
  }
  List<Pair> categoricalOrderList=null;
  if (config.isCategorical()) {
    categoricalOrderList=getCategoricalOrderList(stats,stats.length / super.statsSize);
  }
  InternalGiniInfo info=getGiniInfo(statsByClasses);
  Predict predict=new Predict(info.sumAll == 0d ? 0d : statsByClasses[1] / info.sumAll,info.indexOfLargestElement);
  double[] leftStatByClasses=new double[numClasses];
  double[] rightStatByClasses=new double[numClasses];
  List<GainInfo> internalGainList=new ArrayList<GainInfo>();
  Set<String> leftCategories=config.isCategorical() ? new HashSet<String>() : null;
  for (int i=0; i < (stats.length / numClasses - 1); i++) {
    int index=i;
    if (config.isCategorical()) {
      index=categoricalOrderList.get(i).index;
    }
    for (int j=0; j < leftStatByClasses.length; j++) {
      leftStatByClasses[j]+=stats[index * numClasses + j];
    }
    InternalGiniInfo leftInfo=getGiniInfo(leftStatByClasses);
    Predict leftPredict=new Predict(leftInfo.sumAll == 0d ? 0d : leftStatByClasses[1] / leftInfo.sumAll,leftInfo.indexOfLargestElement);
    for (int j=0; j < leftStatByClasses.length; j++) {
      rightStatByClasses[j]=statsByClasses[j] - leftStatByClasses[j];
    }
    InternalGiniInfo rightInfo=getGiniInfo(rightStatByClasses);
    if (leftInfo.sumAll <= minInstancesPerNode || rightInfo.sumAll <= minInstancesPerNode) {
      continue;
    }
    Predict rightPredict=new Predict(rightInfo.sumAll == 0d ? 0d : rightStatByClasses[1] / rightInfo.sumAll,rightInfo.indexOfLargestElement);
    double leftWeight=info.sumAll == 0d ? 0d : (leftInfo.sumAll / info.sumAll);
    double rightWeight=info.sumAll == 0d ? 0d : (rightInfo.sumAll / info.sumAll);
    double gain=info.impurity - leftWeight * leftInfo.impurity - rightWeight * rightInfo.impurity;
    if (gain <= minInfoGain) {
      continue;
    }
    Split split=null;
    if (config.isCategorical()) {
      if (index >= config.getBinCategory().size()) {
        leftCategories.add(""String_Node_Str"");
      }
 else {
        leftCategories.add(config.getBinCategory().get(index));
      }
      split=new Split(config.getColumnNum(),FeatureType.CATEGORICAL,0d,new HashSet<String>(leftCategories));
    }
 else {
      split=new Split(config.getColumnNum(),FeatureType.CONTINUOUS,config.getBinBoundary().get(index + 1),null);
    }
    internalGainList.add(new GainInfo(gain,info.impurity,predict,leftInfo.impurity,rightInfo.impurity,leftPredict,rightPredict,split));
  }
  return GainInfo.getGainInfoByMaxGain(internalGainList);
}",0.951974386339381
32010,"public Pair(int index,double value){
  super();
  this.index=index;
  this.value=value;
}","public Pair(int index,double value){
  this.index=index;
  this.value=value;
}",0.934131736526946
32011,"@SuppressWarnings(""String_Node_Str"") public Tuple exec(Tuple input) throws IOException {
  if (input == null || input.size() == 0) {
    return null;
  }
  final String rawTag=input.get(tagColumnNum).toString();
  if (!super.tagSet.contains(rawTag)) {
    if (isPigEnabled(Constants.SHIFU_GROUP_COUNTER,""String_Node_Str"")) {
      PigStatusReporter.getInstance().getCounter(Constants.SHIFU_GROUP_COUNTER,""String_Node_Str"").increment(1);
    }
    return null;
  }
  boolean isNotSampled=DataSampler.isNotSampled(modelConfig.isRegression(),super.tagSet,super.posTagSet,super.negTagSet,modelConfig.getNormalizeSampleRate(),modelConfig.isNormalizeSampleNegOnly(),rawTag);
  if (isNotSampled) {
    return null;
  }
  Tuple tuple=TupleFactory.getInstance().newTuple();
  final NormType normType=modelConfig.getNormalizeType();
  for (int i=0; i < input.size(); i++) {
    ColumnConfig config=columnConfigList.get(i);
    String val=(input.get(i) == null) ? ""String_Node_Str"" : input.get(i).toString();
    if (weightExpr != null) {
      weightContext.set(config.getColumnName(),val);
    }
    if (tagColumnNum == i) {
      if (modelConfig.isRegression()) {
        String tagType=tagTypeCheck(super.posTagSet,super.negTagSet,rawTag);
        if (tagType == null) {
          log.error(""String_Node_Str"" + rawTag);
          return null;
        }
        tuple.append(tagType);
      }
 else {
        int index=-1;
        for (int j=0; j < tags.size(); j++) {
          Set<String> tagSet=tags.get(j);
          if (tagSet.contains(rawTag)) {
            index=j;
            break;
          }
        }
        if (index == -1) {
          log.error(""String_Node_Str"" + rawTag);
          return null;
        }
        tuple.append(index);
      }
      continue;
    }
    if (!CommonUtils.isGoodCandidate(modelConfig.isRegression(),config)) {
      tuple.append(null);
    }
 else {
      if (CommonUtils.isDesicionTreeAlgorithm(this.alg)) {
        Double normVal=0d;
        if (config.isCategorical()) {
          tuple.append(val);
        }
 else {
          try {
            normVal=Double.parseDouble(val);
          }
 catch (          Exception e) {
            log.debug(""String_Node_Str"" + val + ""String_Node_Str"");
            normVal=Normalizer.defaultMissingValue(config);
          }
          tuple.append(df.format(normVal));
        }
      }
 else {
        Double normVal=Normalizer.normalize(config,val,cutoff,normType);
        tuple.append(df.format(normVal));
      }
    }
  }
  double weight=evaluateWeight(weightExpr,weightContext);
  tuple.append(weight);
  return tuple;
}","@SuppressWarnings(""String_Node_Str"") public Tuple exec(Tuple input) throws IOException {
  if (input == null || input.size() == 0) {
    return null;
  }
  final String rawTag=input.get(tagColumnNum).toString();
  if (!super.tagSet.contains(rawTag)) {
    if (isPigEnabled(Constants.SHIFU_GROUP_COUNTER,""String_Node_Str"")) {
      PigStatusReporter.getInstance().getCounter(Constants.SHIFU_GROUP_COUNTER,""String_Node_Str"").increment(1);
    }
    return null;
  }
  boolean isNotSampled=DataSampler.isNotSampled(modelConfig.isRegression(),super.tagSet,super.posTagSet,super.negTagSet,modelConfig.getNormalizeSampleRate(),modelConfig.isNormalizeSampleNegOnly(),rawTag);
  if (isNotSampled) {
    return null;
  }
  Tuple tuple=TupleFactory.getInstance().newTuple();
  final NormType normType=modelConfig.getNormalizeType();
  for (int i=0; i < input.size(); i++) {
    ColumnConfig config=columnConfigList.get(i);
    String val=(input.get(i) == null) ? ""String_Node_Str"" : input.get(i).toString().trim();
    if (weightExpr != null) {
      weightContext.set(config.getColumnName(),val);
    }
    if (tagColumnNum == i) {
      if (modelConfig.isRegression()) {
        String tagType=tagTypeCheck(super.posTagSet,super.negTagSet,rawTag);
        if (tagType == null) {
          log.error(""String_Node_Str"" + rawTag);
          return null;
        }
        tuple.append(tagType);
      }
 else {
        int index=-1;
        for (int j=0; j < tags.size(); j++) {
          Set<String> tagSet=tags.get(j);
          if (tagSet.contains(rawTag)) {
            index=j;
            break;
          }
        }
        if (index == -1) {
          log.error(""String_Node_Str"" + rawTag);
          return null;
        }
        tuple.append(index);
      }
      continue;
    }
    if (!CommonUtils.isGoodCandidate(modelConfig.isRegression(),config)) {
      tuple.append(null);
    }
 else {
      if (CommonUtils.isDesicionTreeAlgorithm(this.alg)) {
        Double normVal=0d;
        if (config.isCategorical()) {
          int index=config.getBinCategory().indexOf(val);
          if (index == -1) {
            tuple.append(""String_Node_Str"");
          }
 else {
            tuple.append(val);
          }
        }
 else {
          try {
            normVal=Double.parseDouble(val);
          }
 catch (          Exception e) {
            log.debug(""String_Node_Str"" + val + ""String_Node_Str"");
            normVal=Normalizer.defaultMissingValue(config);
          }
          tuple.append(df.format(normVal));
        }
      }
 else {
        Double normVal=Normalizer.normalize(config,val,cutoff,normType);
        tuple.append(df.format(normVal));
      }
    }
  }
  double weight=evaluateWeight(weightExpr,weightContext);
  tuple.append(weight);
  return tuple;
}",0.9634440526999444
32012,"@Override public DTMasterParams doCompute(MasterContext<DTMasterParams,DTWorkerParams> context){
  if (context.isFirstIteration()) {
    return buildInitialMasterParams();
  }
  boolean isFirst=false;
  Map<Integer,NodeStats> nodeStatsMap=null;
  double trainError=0d, validationError=0d;
  long trainCount=0L, validationCount=0L;
  for (  DTWorkerParams params : context.getWorkerResults()) {
    if (!isFirst) {
      isFirst=true;
      nodeStatsMap=params.getNodeStatsMap();
    }
 else {
      Map<Integer,NodeStats> currNodeStatsmap=params.getNodeStatsMap();
      for (      Entry<Integer,NodeStats> entry : nodeStatsMap.entrySet()) {
        NodeStats resultNodeStats=entry.getValue();
        mergeNodeStats(resultNodeStats,currNodeStatsmap.get(entry.getKey()));
      }
    }
    trainError+=params.getTrainError();
    validationError+=params.getValidationError();
    if (this.isRF) {
      trainCount+=params.getTrainCount() * this.treeNum;
      validationCount+=params.getValidationCount() * this.treeNum;
    }
    if (this.isGBDT) {
      trainCount+=params.getTrainCount();
      validationCount+=params.getValidationCount();
    }
  }
  for (  Entry<Integer,NodeStats> entry : nodeStatsMap.entrySet()) {
    NodeStats nodeStats=entry.getValue();
    int treeId=nodeStats.getTreeId();
    Node doneNode=Node.getNode(trees.get(treeId).getNode(),nodeStats.getNodeId());
    Map<Integer,double[]> statistics=nodeStats.getFeatureStatistics();
    List<GainInfo> gainList=new ArrayList<GainInfo>();
    for (    Entry<Integer,double[]> gainEntry : statistics.entrySet()) {
      int columnNum=gainEntry.getKey();
      ColumnConfig config=this.columnConfigList.get(columnNum);
      double[] statsArray=gainEntry.getValue();
      GainInfo gainInfo=this.impurity.computeImpurity(statsArray,config);
      if (gainInfo != null) {
        gainList.add(gainInfo);
      }
    }
    GainInfo maxGainInfo=GainInfo.getGainInfoByMaxGain(gainList);
    if (maxGainInfo == null) {
      doneNode.setLeaf(true);
      continue;
    }
    populateGainInfoToNode(doneNode,maxGainInfo);
    boolean isLeaf=maxGainInfo.getGain() <= 0d || Node.indexToLevel(doneNode.getId()) == this.maxDepth;
    doneNode.setLeaf(isLeaf);
    if (!doneNode.isLeaf()) {
      boolean leftChildIsLeaf=Node.indexToLevel(doneNode.getId()) + 1 == this.maxDepth || Double.compare(maxGainInfo.getLeftImpurity(),0d) == 0;
      int leftIndex=Node.leftIndex(doneNode.getId());
      Node left=new Node(leftIndex,maxGainInfo.getLeftPredict(),maxGainInfo.getLeftImpurity(),true);
      doneNode.setLeft(left);
      if (!leftChildIsLeaf) {
        this.queue.offer(new TreeNode(treeId,left));
      }
 else {
        LOG.info(""String_Node_Str"",leftIndex,treeId);
      }
      boolean rightChildIsLeaf=Node.indexToLevel(doneNode.getId()) + 1 == this.maxDepth || Double.compare(maxGainInfo.getRightImpurity(),0d) == 0;
      int rightIndex=Node.rightIndex(doneNode.getId());
      Node right=new Node(rightIndex,maxGainInfo.getRightPredict(),maxGainInfo.getRightImpurity(),true);
      doneNode.setRight(right);
      if (!rightChildIsLeaf) {
        this.queue.offer(new TreeNode(treeId,right));
      }
 else {
        LOG.info(""String_Node_Str"",rightIndex,treeId);
      }
    }
 else {
      LOG.info(""String_Node_Str"",doneNode.getId(),treeId);
    }
  }
  Map<Integer,TreeNode> todoNodes=new HashMap<Integer,TreeNode>();
  DTMasterParams masterParams=new DTMasterParams(trainCount,trainError,validationCount,validationError);
  if (queue.isEmpty()) {
    if (this.isGBDT) {
      Node treeNode=this.trees.get(this.trees.size() - 1).getNode();
      if (this.trees.size() == this.treeNum + this.existingTreeSize) {
        masterParams.setHalt(true);
        LOG.info(""String_Node_Str"",context.getCurrentIteration());
      }
 else       if (treeNode.getLeft() == null && treeNode.getRight() == null) {
        masterParams.setHalt(true);
        LOG.warn(""String_Node_Str"",context.getCurrentIteration());
      }
 else {
        TreeNode newRootNode=new TreeNode(this.trees.size(),new Node(Node.ROOT_INDEX));
        LOG.info(""String_Node_Str"",this.trees.size());
        this.trees.add(newRootNode);
        newRootNode.setFeatures(getSubsamplingFeatures(this.featureSubsetStrategy));
        todoNodes.put(0,newRootNode);
        masterParams.setTodoNodes(todoNodes);
        masterParams.setSwitchToNextTree(true);
      }
    }
 else {
      masterParams.setHalt(true);
      LOG.info(""String_Node_Str"",context.getCurrentIteration());
    }
  }
 else {
    int nodeIndexInGroup=0;
    long currMem=0L;
    List<Integer> depthList=new ArrayList<Integer>();
    for (int i=0; i < this.trees.size(); i++) {
      depthList.add(-1);
    }
    while (!queue.isEmpty() && currMem <= this.maxStatsMemory) {
      TreeNode node=this.queue.poll();
      int treeId=node.getTreeId();
      int oldDepth=depthList.get(treeId);
      int currDepth=Node.indexToLevel(node.getNode().getId());
      if (currDepth > oldDepth) {
        depthList.set(treeId,currDepth);
      }
      List<Integer> subsetFeatures=getSubsamplingFeatures(featureSubsetStrategy);
      node.setFeatures(subsetFeatures);
      currMem+=getStatsMem(subsetFeatures);
      todoNodes.put(nodeIndexInGroup,node);
      nodeIndexInGroup+=1;
    }
    masterParams.setTreeDepth(depthList);
    masterParams.setTodoNodes(todoNodes);
    masterParams.setSwitchToNextTree(false);
    LOG.info(""String_Node_Str"",todoNodes.size());
  }
  masterParams.setTrees(trees);
  return masterParams;
}","@Override public DTMasterParams doCompute(MasterContext<DTMasterParams,DTWorkerParams> context){
  if (context.isFirstIteration()) {
    return buildInitialMasterParams();
  }
  boolean isFirst=false;
  Map<Integer,NodeStats> nodeStatsMap=null;
  double trainError=0d, validationError=0d;
  double weightedTrainCount=0d, weightedValidationCount=0d;
  for (  DTWorkerParams params : context.getWorkerResults()) {
    if (!isFirst) {
      isFirst=true;
      nodeStatsMap=params.getNodeStatsMap();
    }
 else {
      Map<Integer,NodeStats> currNodeStatsmap=params.getNodeStatsMap();
      for (      Entry<Integer,NodeStats> entry : nodeStatsMap.entrySet()) {
        NodeStats resultNodeStats=entry.getValue();
        mergeNodeStats(resultNodeStats,currNodeStatsmap.get(entry.getKey()));
      }
    }
    trainError+=params.getTrainError();
    validationError+=params.getValidationError();
    weightedTrainCount+=params.getTrainCount();
    weightedValidationCount+=params.getValidationCount();
  }
  for (  Entry<Integer,NodeStats> entry : nodeStatsMap.entrySet()) {
    NodeStats nodeStats=entry.getValue();
    int treeId=nodeStats.getTreeId();
    Node doneNode=Node.getNode(trees.get(treeId).getNode(),nodeStats.getNodeId());
    Map<Integer,double[]> statistics=nodeStats.getFeatureStatistics();
    List<GainInfo> gainList=new ArrayList<GainInfo>();
    for (    Entry<Integer,double[]> gainEntry : statistics.entrySet()) {
      int columnNum=gainEntry.getKey();
      ColumnConfig config=this.columnConfigList.get(columnNum);
      double[] statsArray=gainEntry.getValue();
      GainInfo gainInfo=this.impurity.computeImpurity(statsArray,config);
      if (gainInfo != null) {
        gainList.add(gainInfo);
      }
    }
    GainInfo maxGainInfo=GainInfo.getGainInfoByMaxGain(gainList);
    if (maxGainInfo == null) {
      doneNode.setLeaf(true);
      continue;
    }
    populateGainInfoToNode(doneNode,maxGainInfo);
    boolean isLeaf=maxGainInfo.getGain() <= 0d || Node.indexToLevel(doneNode.getId()) == this.maxDepth;
    doneNode.setLeaf(isLeaf);
    if (!doneNode.isLeaf()) {
      boolean leftChildIsLeaf=Node.indexToLevel(doneNode.getId()) + 1 == this.maxDepth || Double.compare(maxGainInfo.getLeftImpurity(),0d) == 0;
      int leftIndex=Node.leftIndex(doneNode.getId());
      Node left=new Node(leftIndex,maxGainInfo.getLeftPredict(),maxGainInfo.getLeftImpurity(),true);
      doneNode.setLeft(left);
      if (!leftChildIsLeaf) {
        this.queue.offer(new TreeNode(treeId,left));
      }
 else {
        LOG.info(""String_Node_Str"",leftIndex,treeId);
      }
      boolean rightChildIsLeaf=Node.indexToLevel(doneNode.getId()) + 1 == this.maxDepth || Double.compare(maxGainInfo.getRightImpurity(),0d) == 0;
      int rightIndex=Node.rightIndex(doneNode.getId());
      Node right=new Node(rightIndex,maxGainInfo.getRightPredict(),maxGainInfo.getRightImpurity(),true);
      doneNode.setRight(right);
      if (!rightChildIsLeaf) {
        this.queue.offer(new TreeNode(treeId,right));
      }
 else {
        LOG.info(""String_Node_Str"",rightIndex,treeId);
      }
    }
 else {
      LOG.info(""String_Node_Str"",doneNode.getId(),treeId);
    }
  }
  Map<Integer,TreeNode> todoNodes=new HashMap<Integer,TreeNode>();
  DTMasterParams masterParams=new DTMasterParams(weightedTrainCount,trainError,weightedValidationCount,validationError);
  if (queue.isEmpty()) {
    if (this.isGBDT) {
      Node treeNode=this.trees.get(this.trees.size() - 1).getNode();
      if (this.trees.size() == this.treeNum + this.existingTreeSize) {
        masterParams.setHalt(true);
        LOG.info(""String_Node_Str"",context.getCurrentIteration());
      }
 else       if (treeNode.getLeft() == null && treeNode.getRight() == null) {
        masterParams.setHalt(true);
        LOG.warn(""String_Node_Str"",context.getCurrentIteration());
      }
 else {
        TreeNode newRootNode=new TreeNode(this.trees.size(),new Node(Node.ROOT_INDEX));
        LOG.info(""String_Node_Str"",this.trees.size());
        this.trees.add(newRootNode);
        newRootNode.setFeatures(getSubsamplingFeatures(this.featureSubsetStrategy));
        todoNodes.put(0,newRootNode);
        masterParams.setTodoNodes(todoNodes);
        masterParams.setSwitchToNextTree(true);
      }
    }
 else {
      masterParams.setHalt(true);
      LOG.info(""String_Node_Str"",context.getCurrentIteration());
    }
  }
 else {
    int nodeIndexInGroup=0;
    long currMem=0L;
    List<Integer> depthList=new ArrayList<Integer>();
    for (int i=0; i < this.trees.size(); i++) {
      depthList.add(-1);
    }
    while (!queue.isEmpty() && currMem <= this.maxStatsMemory) {
      TreeNode node=this.queue.poll();
      int treeId=node.getTreeId();
      int oldDepth=depthList.get(treeId);
      int currDepth=Node.indexToLevel(node.getNode().getId());
      if (currDepth > oldDepth) {
        depthList.set(treeId,currDepth);
      }
      List<Integer> subsetFeatures=getSubsamplingFeatures(featureSubsetStrategy);
      node.setFeatures(subsetFeatures);
      currMem+=getStatsMem(subsetFeatures);
      todoNodes.put(nodeIndexInGroup,node);
      nodeIndexInGroup+=1;
    }
    masterParams.setTreeDepth(depthList);
    masterParams.setTodoNodes(todoNodes);
    masterParams.setSwitchToNextTree(false);
    LOG.info(""String_Node_Str"",todoNodes.size());
  }
  masterParams.setTrees(trees);
  return masterParams;
}",0.9748900293255132
32013,"@Override public void doReadFields(DataInput in) throws IOException {
  this.trainCount=in.readLong();
  this.validationCount=in.readLong();
  this.trainError=in.readDouble();
  this.validationError=in.readDouble();
  this.isSwitchToNextTree=in.readBoolean();
  int treeNum=in.readInt();
  this.trees=new ArrayList<TreeNode>(treeNum);
  for (int i=0; i < treeNum; i++) {
    TreeNode treeNode=new TreeNode();
    treeNode.readFieldsWithoutFeatures(in);
    this.trees.add(treeNode);
  }
  int todoNodesSize=in.readInt();
  if (todoNodesSize > 0) {
    todoNodes=new HashMap<Integer,TreeNode>(todoNodesSize,1f);
    for (int i=0; i < todoNodesSize; i++) {
      int key=in.readInt();
      TreeNode treeNode=new TreeNode();
      treeNode.readFields(in);
      todoNodes.put(key,treeNode);
    }
  }
  this.isContinuousRunningStart=in.readBoolean();
}","@Override public void doReadFields(DataInput in) throws IOException {
  this.trainCount=in.readDouble();
  this.validationCount=in.readDouble();
  this.trainError=in.readDouble();
  this.validationError=in.readDouble();
  this.isSwitchToNextTree=in.readBoolean();
  int treeNum=in.readInt();
  this.trees=new ArrayList<TreeNode>(treeNum);
  for (int i=0; i < treeNum; i++) {
    TreeNode treeNode=new TreeNode();
    treeNode.readFieldsWithoutFeatures(in);
    this.trees.add(treeNode);
  }
  int todoNodesSize=in.readInt();
  if (todoNodesSize > 0) {
    todoNodes=new HashMap<Integer,TreeNode>(todoNodesSize,1f);
    for (int i=0; i < todoNodesSize; i++) {
      int key=in.readInt();
      TreeNode treeNode=new TreeNode();
      treeNode.readFields(in);
      todoNodes.put(key,treeNode);
    }
  }
  this.isContinuousRunningStart=in.readBoolean();
}",0.988262910798122
32014,"/** 
 * @return the trainCount
 */
public long getTrainCount(){
  return trainCount;
}","/** 
 * @return the trainCount
 */
public double getTrainCount(){
  return trainCount;
}",0.9540229885057472
32015,"/** 
 * @return the validationCount
 */
public long getValidationCount(){
  return validationCount;
}","/** 
 * @return the validationCount
 */
public double getValidationCount(){
  return validationCount;
}",0.9607843137254902
32016,"/** 
 * @param validationCount the validationCount to set
 */
public void setValidationCount(long validationCount){
  this.validationCount=validationCount;
}","/** 
 * @param validationCount the validationCount to set
 */
public void setValidationCount(double validationCount){
  this.validationCount=validationCount;
}",0.9746835443037974
32017,"/** 
 * @param trainCount the trainCount to set
 */
public void setTrainCount(long trainCount){
  this.trainCount=trainCount;
}","/** 
 * @param trainCount the trainCount to set
 */
public void setTrainCount(double trainCount){
  this.trainCount=trainCount;
}",0.96875
32018,"@SuppressWarnings(""String_Node_Str"") private void updateProgressLog(final MasterContext<DTMasterParams,DTWorkerParams> context){
  int currentIteration=context.getCurrentIteration();
  if (context.isFirstIteration()) {
    return;
  }
  double trainError=context.getMasterResult().getTrainError() / context.getMasterResult().getTrainCount();
  double validationError=context.getMasterResult().getValidationCount() == 0L ? 0d : context.getMasterResult().getValidationError() / context.getMasterResult().getValidationCount();
  String info=""String_Node_Str"";
  if (this.isGBDT) {
    int treeSize=0;
    if (context.getMasterResult().isSwitchToNextTree() || context.getMasterResult().isHalt()) {
      treeSize=context.getMasterResult().isSwitchToNextTree() ? (context.getMasterResult().getTrees().size() - 1) : (context.getMasterResult().getTrees().size());
      info=new StringBuilder(200).append(""String_Node_Str"").append(this.trainerId).append(""String_Node_Str"").append(currentIteration - 1).append(""String_Node_Str"").append(String.format(""String_Node_Str"",trainError)).append(""String_Node_Str"").append(validationError == 0d ? ""String_Node_Str"" : String.format(""String_Node_Str"",validationError)).append(""String_Node_Str"").append(treeSize).append(""String_Node_Str"").toString();
    }
 else {
      int treeIndex=context.getMasterResult().getTrees().size() - 1;
      int nextDepth=context.getMasterResult().getTreeDepth().get(treeIndex);
      info=new StringBuilder(200).append(""String_Node_Str"").append(this.trainerId).append(""String_Node_Str"").append(currentIteration - 1).append(""String_Node_Str"").append(trainError == 0d ? ""String_Node_Str"" : String.format(""String_Node_Str"",trainError)).append(""String_Node_Str"").append(validationError == 0d ? ""String_Node_Str"" : String.format(""String_Node_Str"",validationError)).append(""String_Node_Str"").append(nextDepth).append(""String_Node_Str"").toString();
    }
  }
  if (this.isRF) {
    if (trainError != 0d) {
      List<Integer> treeDepth=context.getMasterResult().getTreeDepth();
      if (treeDepth.size() == 0) {
        info=new StringBuilder(200).append(""String_Node_Str"").append(this.trainerId).append(""String_Node_Str"").append(currentIteration - 1).append(""String_Node_Str"").append(trainError == 0d ? ""String_Node_Str"" : String.format(""String_Node_Str"",trainError)).append(""String_Node_Str"").append(validationError == 0d ? ""String_Node_Str"" : String.format(""String_Node_Str"",validationError)).append(""String_Node_Str"").toString();
      }
 else {
        info=new StringBuilder(200).append(""String_Node_Str"").append(this.trainerId).append(""String_Node_Str"").append(currentIteration - 1).append(""String_Node_Str"").append(trainError == 0d ? ""String_Node_Str"" : String.format(""String_Node_Str"",trainError)).append(""String_Node_Str"").append(validationError == 0d ? ""String_Node_Str"" : String.format(""String_Node_Str"",validationError)).append(""String_Node_Str"").append(toListString(treeDepth)).append(""String_Node_Str"").toString();
      }
    }
  }
  if (info.length() > 0) {
    try {
      LOG.debug(""String_Node_Str"",context.getCurrentIteration(),info.toString());
      this.progressOutput.write(info.getBytes(""String_Node_Str""));
      this.progressOutput.flush();
      this.progressOutput.sync();
    }
 catch (    IOException e) {
      LOG.error(""String_Node_Str"",e);
    }
  }
}","@SuppressWarnings(""String_Node_Str"") private void updateProgressLog(final MasterContext<DTMasterParams,DTWorkerParams> context){
  int currentIteration=context.getCurrentIteration();
  if (context.isFirstIteration()) {
    return;
  }
  double trainError=context.getMasterResult().getTrainError() / context.getMasterResult().getTrainCount();
  double validationError=context.getMasterResult().getValidationCount() == 0d ? 0d : context.getMasterResult().getValidationError() / context.getMasterResult().getValidationCount();
  String info=""String_Node_Str"";
  if (this.isGBDT) {
    int treeSize=0;
    if (context.getMasterResult().isSwitchToNextTree() || context.getMasterResult().isHalt()) {
      treeSize=context.getMasterResult().isSwitchToNextTree() ? (context.getMasterResult().getTrees().size() - 1) : (context.getMasterResult().getTrees().size());
      info=new StringBuilder(200).append(""String_Node_Str"").append(this.trainerId).append(""String_Node_Str"").append(currentIteration - 1).append(""String_Node_Str"").append(String.format(""String_Node_Str"",trainError)).append(""String_Node_Str"").append(validationError == 0d ? ""String_Node_Str"" : String.format(""String_Node_Str"",validationError)).append(""String_Node_Str"").append(treeSize).append(""String_Node_Str"").toString();
    }
 else {
      int treeIndex=context.getMasterResult().getTrees().size() - 1;
      int nextDepth=context.getMasterResult().getTreeDepth().get(treeIndex);
      info=new StringBuilder(200).append(""String_Node_Str"").append(this.trainerId).append(""String_Node_Str"").append(currentIteration - 1).append(""String_Node_Str"").append(trainError == 0d ? ""String_Node_Str"" : String.format(""String_Node_Str"",trainError)).append(""String_Node_Str"").append(validationError == 0d ? ""String_Node_Str"" : String.format(""String_Node_Str"",validationError)).append(""String_Node_Str"").append(nextDepth).append(""String_Node_Str"").toString();
    }
  }
  if (this.isRF) {
    if (trainError != 0d) {
      List<Integer> treeDepth=context.getMasterResult().getTreeDepth();
      if (treeDepth.size() == 0) {
        info=new StringBuilder(200).append(""String_Node_Str"").append(this.trainerId).append(""String_Node_Str"").append(currentIteration - 1).append(""String_Node_Str"").append(trainError == 0d ? ""String_Node_Str"" : String.format(""String_Node_Str"",trainError)).append(""String_Node_Str"").append(validationError == 0d ? ""String_Node_Str"" : String.format(""String_Node_Str"",validationError)).append(""String_Node_Str"").toString();
      }
 else {
        info=new StringBuilder(200).append(""String_Node_Str"").append(this.trainerId).append(""String_Node_Str"").append(currentIteration - 1).append(""String_Node_Str"").append(trainError == 0d ? ""String_Node_Str"" : String.format(""String_Node_Str"",trainError)).append(""String_Node_Str"").append(validationError == 0d ? ""String_Node_Str"" : String.format(""String_Node_Str"",validationError)).append(""String_Node_Str"").append(toListString(treeDepth)).append(""String_Node_Str"").toString();
      }
    }
  }
  if (info.length() > 0) {
    try {
      LOG.debug(""String_Node_Str"",context.getCurrentIteration(),info.toString());
      this.progressOutput.write(info.getBytes(""String_Node_Str""));
      this.progressOutput.flush();
      this.progressOutput.sync();
    }
 catch (    IOException e) {
      LOG.error(""String_Node_Str"",e);
    }
  }
}",0.999700956937799
32019,"@Override public DTWorkerParams doCompute(WorkerContext<DTMasterParams,DTWorkerParams> context){
  if (context.isFirstIteration()) {
    return new DTWorkerParams();
  }
  DTMasterParams lastMasterResult=context.getLastMasterResult();
  final List<TreeNode> trees=lastMasterResult.getTrees();
  final Map<Integer,TreeNode> todoNodes=lastMasterResult.getTodoNodes();
  if (todoNodes == null) {
    return new DTWorkerParams();
  }
  Map<Integer,NodeStats> statistics=initTodoNodeStats(todoNodes);
  double trainError=0d, validationError=0d;
  if (this.isGBDT && !this.gbdtSampleWithReplacement && lastMasterResult.isSwitchToNextTree()) {
    this.random=new Random();
  }
  for (  Data data : this.trainingData) {
    if (this.isRF) {
      for (      TreeNode treeNode : trees) {
        Node predictNode=predictNodeIndex(treeNode.getNode(),data);
        if (predictNode.getPredict() != null) {
          trainError+=loss.computeError((float)(predictNode.getPredict().getPredict()),data.label);
        }
      }
    }
    if (this.isGBDT) {
      if (this.isContinuousEnabled && lastMasterResult.isContinuousRunningStart()) {
        recoverGBTData(context,data.output,data.predict,data);
        trainError+=loss.computeError(data.predict,data.label);
      }
 else {
        int currTreeIndex=trees.size() - 1;
        if (lastMasterResult.isSwitchToNextTree()) {
          if (currTreeIndex >= 1) {
            Node node=trees.get(currTreeIndex - 1).getNode();
            Node predictNode=predictNodeIndex(node,data);
            if (predictNode.getPredict() != null) {
              double predict=predictNode.getPredict().getPredict();
              if (currTreeIndex == 1) {
                data.predict=(float)predict;
              }
 else {
                data.predict+=(float)(this.learningRate * predict);
              }
              data.output=-1f * loss.computeGradient(data.predict,data.label);
            }
            if (!this.gbdtSampleWithReplacement) {
              if (random.nextDouble() <= modelConfig.getTrain().getBaggingSampleRate()) {
                data.subsampleWeights[currTreeIndex % data.subsampleWeights.length]=1f;
              }
 else {
                data.subsampleWeights[currTreeIndex % data.subsampleWeights.length]=0f;
              }
            }
          }
        }
        Node predictNode=predictNodeIndex(trees.get(currTreeIndex).getNode(),data);
        if (currTreeIndex >= 1) {
          trainError+=loss.computeError(data.predict,data.label);
        }
 else {
          if (predictNode.getPredict() != null) {
            trainError+=loss.computeError(((float)predictNode.getPredict().getPredict()),data.label);
          }
        }
      }
    }
  }
  if (validationData != null) {
    for (    Data data : this.validationData) {
      if (this.isRF) {
        for (        TreeNode treeNode : trees) {
          Node predictNode=predictNodeIndex(treeNode.getNode(),data);
          if (predictNode.getPredict() != null) {
            validationError+=loss.computeError((float)(predictNode.getPredict().getPredict()),data.label);
          }
        }
      }
      if (this.isGBDT) {
        if (this.isContinuousEnabled && lastMasterResult.isContinuousRunningStart()) {
          recoverGBTData(context,data.output,data.predict,data);
          validationError+=loss.computeError(data.predict,data.label);
        }
 else {
          int currTreeIndex=trees.size() - 1;
          if (lastMasterResult.isSwitchToNextTree()) {
            if (currTreeIndex >= 1) {
              Node node=trees.get(currTreeIndex - 1).getNode();
              Node predictNode=predictNodeIndex(node,data);
              if (predictNode.getPredict() != null) {
                double predict=predictNode.getPredict().getPredict();
                if (currTreeIndex == 1) {
                  data.predict=(float)predict;
                }
 else {
                  data.predict+=(float)(this.learningRate * predict);
                }
                data.output=-1f * loss.computeGradient(data.predict,data.label);
              }
              if (!this.gbdtSampleWithReplacement) {
                if (random.nextDouble() <= modelConfig.getTrain().getBaggingSampleRate()) {
                  data.subsampleWeights[currTreeIndex % data.subsampleWeights.length]=1f;
                }
 else {
                  data.subsampleWeights[currTreeIndex % data.subsampleWeights.length]=0f;
                }
              }
            }
          }
          Node predictNode=predictNodeIndex(trees.get(currTreeIndex).getNode(),data);
          if (currTreeIndex >= 1) {
            validationError+=loss.computeError(data.predict,data.label);
          }
 else {
            if (predictNode.getPredict() != null) {
              validationError+=loss.computeError(((float)predictNode.getPredict().getPredict()),data.label);
            }
          }
        }
      }
    }
  }
  CompletionService<Map<Integer,NodeStats>> completionService=new ExecutorCompletionService<Map<Integer,NodeStats>>(this.threadPool);
  Set<Entry<Integer,TreeNode>> treeNodeEntrySet=todoNodes.entrySet();
  Iterator<Entry<Integer,TreeNode>> treeNodeIterator=treeNodeEntrySet.iterator();
  int roundNodeNumer=treeNodeEntrySet.size() / this.workerThreadCount;
  int modeNodeNumber=treeNodeEntrySet.size() % this.workerThreadCount;
  int realThreadCount=0;
  LOG.info(""String_Node_Str"",todoNodes.size());
  for (int i=0; i < this.workerThreadCount; i++) {
    final Map<Integer,TreeNode> localTodoNodes=new HashMap<Integer,TreeNode>();
    final Map<Integer,NodeStats> localStatistics=new HashMap<Integer,DTWorkerParams.NodeStats>();
    for (int j=0; j < roundNodeNumer; j++) {
      Entry<Integer,TreeNode> tmpTreeNode=treeNodeIterator.next();
      localTodoNodes.put(tmpTreeNode.getKey(),tmpTreeNode.getValue());
      localStatistics.put(tmpTreeNode.getKey(),statistics.get(tmpTreeNode.getKey()));
    }
    if (modeNodeNumber > 0) {
      Entry<Integer,TreeNode> tmpTreeNode=treeNodeIterator.next();
      localTodoNodes.put(tmpTreeNode.getKey(),tmpTreeNode.getValue());
      localStatistics.put(tmpTreeNode.getKey(),statistics.get(tmpTreeNode.getKey()));
      modeNodeNumber-=1;
    }
    LOG.info(""String_Node_Str"",i,localTodoNodes.size(),localStatistics.size());
    if (localTodoNodes.size() == 0) {
      continue;
    }
    realThreadCount+=1;
    completionService.submit(new Callable<Map<Integer,NodeStats>>(){
      @Override public Map<Integer,NodeStats> call() throws Exception {
        List<Integer> nodeIndexes=new ArrayList<Integer>(trees.size());
        for (        Data data : DTWorker.this.trainingData) {
          nodeIndexes.clear();
          if (DTWorker.this.isRF) {
            for (            TreeNode treeNode : trees) {
              Node predictNode=predictNodeIndex(treeNode.getNode(),data);
              nodeIndexes.add(predictNode.getId());
            }
          }
          if (DTWorker.this.isGBDT) {
            int currTreeIndex=trees.size() - 1;
            Node predictNode=predictNodeIndex(trees.get(currTreeIndex).getNode(),data);
            nodeIndexes.add(predictNode.getId());
          }
          for (          Map.Entry<Integer,TreeNode> entry : localTodoNodes.entrySet()) {
            Node todoNode=entry.getValue().getNode();
            int treeId=entry.getValue().getTreeId();
            int currPredictIndex=0;
            if (DTWorker.this.isRF) {
              currPredictIndex=nodeIndexes.get(entry.getValue().getTreeId());
            }
            if (DTWorker.this.isGBDT) {
              currPredictIndex=nodeIndexes.get(0);
            }
            if (todoNode.getId() == currPredictIndex) {
              List<Integer> features=entry.getValue().getFeatures();
              if (features.isEmpty()) {
                features=getAllValidFeatures();
              }
              for (              Integer columnNum : features) {
                ColumnConfig config=DTWorker.this.columnConfigList.get(columnNum);
                double[] featuerStatistic=localStatistics.get(entry.getKey()).getFeatureStatistics().get(columnNum);
                float weight=data.subsampleWeights[treeId % data.subsampleWeights.length];
                if (config.isNumerical()) {
                  float value=data.numericInputs[DTWorker.this.numericInputIndexMap.get(columnNum)];
                  int binIndex=getBinIndex(value,config.getBinBoundary());
                  DTWorker.this.impurity.featureUpdate(featuerStatistic,binIndex,data.output,data.significance,weight);
                }
 else                 if (config.isCategorical()) {
                  String category=data.categoricalInputs[DTWorker.this.categoricalInputIndexMap.get(columnNum)];
                  Integer binIndex=DTWorker.this.categoryIndexMap.get(columnNum).get(category);
                  if (binIndex == null) {
                    binIndex=config.getBinCategory().size();
                  }
                  DTWorker.this.impurity.featureUpdate(featuerStatistic,binIndex,data.output,data.significance,weight);
                }
 else {
                  throw new IllegalStateException(""String_Node_Str"");
                }
              }
            }
          }
        }
        return localStatistics;
      }
    }
);
  }
  int rCnt=0;
  while (rCnt < realThreadCount) {
    try {
      statistics.putAll(completionService.take().get());
    }
 catch (    ExecutionException e) {
      throw new RuntimeException(e);
    }
catch (    InterruptedException e) {
      Thread.currentThread().interrupt();
    }
    rCnt+=1;
  }
  LOG.info(""String_Node_Str"",count,trainError,statistics.size());
  return new DTWorkerParams(trainingData.size(),(this.validationData == null ? 0L : this.validationData.size()),trainError,validationError,statistics);
}","@Override public DTWorkerParams doCompute(WorkerContext<DTMasterParams,DTWorkerParams> context){
  if (context.isFirstIteration()) {
    return new DTWorkerParams();
  }
  DTMasterParams lastMasterResult=context.getLastMasterResult();
  final List<TreeNode> trees=lastMasterResult.getTrees();
  final Map<Integer,TreeNode> todoNodes=lastMasterResult.getTodoNodes();
  if (todoNodes == null) {
    return new DTWorkerParams();
  }
  Map<Integer,NodeStats> statistics=initTodoNodeStats(todoNodes);
  double trainError=0d, validationError=0d;
  double weightedTrainCount=0d, weightedValidationCount=0d;
  if (this.isGBDT && !this.gbdtSampleWithReplacement && lastMasterResult.isSwitchToNextTree()) {
    this.random=new Random();
  }
  for (  Data data : this.trainingData) {
    if (this.isRF) {
      for (      TreeNode treeNode : trees) {
        Node predictNode=predictNodeIndex(treeNode.getNode(),data);
        if (predictNode.getPredict() != null) {
          trainError+=data.significance * loss.computeError((float)(predictNode.getPredict().getPredict()),data.label);
          weightedTrainCount+=data.significance;
        }
      }
    }
    if (this.isGBDT) {
      if (this.isContinuousEnabled && lastMasterResult.isContinuousRunningStart()) {
        recoverGBTData(context,data.output,data.predict,data);
        trainError+=data.significance * loss.computeError(data.predict,data.label);
        weightedTrainCount+=data.significance;
      }
 else {
        int currTreeIndex=trees.size() - 1;
        if (lastMasterResult.isSwitchToNextTree()) {
          if (currTreeIndex >= 1) {
            Node node=trees.get(currTreeIndex - 1).getNode();
            Node predictNode=predictNodeIndex(node,data);
            if (predictNode.getPredict() != null) {
              double predict=predictNode.getPredict().getPredict();
              if (currTreeIndex == 1) {
                data.predict=(float)predict;
              }
 else {
                data.predict+=(float)(this.learningRate * predict);
              }
              data.output=-1f * loss.computeGradient(data.predict,data.label);
            }
            if (!this.gbdtSampleWithReplacement) {
              if (random.nextDouble() <= modelConfig.getTrain().getBaggingSampleRate()) {
                data.subsampleWeights[currTreeIndex % data.subsampleWeights.length]=1f;
              }
 else {
                data.subsampleWeights[currTreeIndex % data.subsampleWeights.length]=0f;
              }
            }
          }
        }
        Node predictNode=predictNodeIndex(trees.get(currTreeIndex).getNode(),data);
        if (currTreeIndex >= 1) {
          trainError+=data.significance * loss.computeError(data.predict,data.label);
          weightedTrainCount+=data.significance;
        }
 else {
          if (predictNode.getPredict() != null) {
            trainError+=data.significance * loss.computeError(((float)predictNode.getPredict().getPredict()),data.label);
            weightedTrainCount+=data.significance;
          }
        }
      }
    }
  }
  if (validationData != null) {
    for (    Data data : this.validationData) {
      if (this.isRF) {
        for (        TreeNode treeNode : trees) {
          Node predictNode=predictNodeIndex(treeNode.getNode(),data);
          if (predictNode.getPredict() != null) {
            validationError+=data.significance * loss.computeError((float)(predictNode.getPredict().getPredict()),data.label);
            weightedValidationCount+=data.significance;
          }
        }
      }
      if (this.isGBDT) {
        if (this.isContinuousEnabled && lastMasterResult.isContinuousRunningStart()) {
          recoverGBTData(context,data.output,data.predict,data);
          validationError+=data.significance * loss.computeError(data.predict,data.label);
          weightedValidationCount+=data.significance;
        }
 else {
          int currTreeIndex=trees.size() - 1;
          if (lastMasterResult.isSwitchToNextTree()) {
            if (currTreeIndex >= 1) {
              Node node=trees.get(currTreeIndex - 1).getNode();
              Node predictNode=predictNodeIndex(node,data);
              if (predictNode.getPredict() != null) {
                double predict=predictNode.getPredict().getPredict();
                if (currTreeIndex == 1) {
                  data.predict=(float)predict;
                }
 else {
                  data.predict+=(float)(this.learningRate * predict);
                }
                data.output=-1f * loss.computeGradient(data.predict,data.label);
              }
              if (!this.gbdtSampleWithReplacement) {
                if (random.nextDouble() <= modelConfig.getTrain().getBaggingSampleRate()) {
                  data.subsampleWeights[currTreeIndex % data.subsampleWeights.length]=1f;
                }
 else {
                  data.subsampleWeights[currTreeIndex % data.subsampleWeights.length]=0f;
                }
              }
            }
          }
          Node predictNode=predictNodeIndex(trees.get(currTreeIndex).getNode(),data);
          if (currTreeIndex >= 1) {
            validationError+=data.significance * loss.computeError(data.predict,data.label);
            weightedValidationCount+=data.significance;
          }
 else {
            if (predictNode.getPredict() != null) {
              validationError+=data.significance * loss.computeError(((float)predictNode.getPredict().getPredict()),data.label);
              weightedValidationCount+=data.significance;
            }
          }
        }
      }
    }
  }
  CompletionService<Map<Integer,NodeStats>> completionService=new ExecutorCompletionService<Map<Integer,NodeStats>>(this.threadPool);
  Set<Entry<Integer,TreeNode>> treeNodeEntrySet=todoNodes.entrySet();
  Iterator<Entry<Integer,TreeNode>> treeNodeIterator=treeNodeEntrySet.iterator();
  int roundNodeNumer=treeNodeEntrySet.size() / this.workerThreadCount;
  int modeNodeNumber=treeNodeEntrySet.size() % this.workerThreadCount;
  int realThreadCount=0;
  LOG.info(""String_Node_Str"",todoNodes.size());
  for (int i=0; i < this.workerThreadCount; i++) {
    final Map<Integer,TreeNode> localTodoNodes=new HashMap<Integer,TreeNode>();
    final Map<Integer,NodeStats> localStatistics=new HashMap<Integer,DTWorkerParams.NodeStats>();
    for (int j=0; j < roundNodeNumer; j++) {
      Entry<Integer,TreeNode> tmpTreeNode=treeNodeIterator.next();
      localTodoNodes.put(tmpTreeNode.getKey(),tmpTreeNode.getValue());
      localStatistics.put(tmpTreeNode.getKey(),statistics.get(tmpTreeNode.getKey()));
    }
    if (modeNodeNumber > 0) {
      Entry<Integer,TreeNode> tmpTreeNode=treeNodeIterator.next();
      localTodoNodes.put(tmpTreeNode.getKey(),tmpTreeNode.getValue());
      localStatistics.put(tmpTreeNode.getKey(),statistics.get(tmpTreeNode.getKey()));
      modeNodeNumber-=1;
    }
    LOG.info(""String_Node_Str"",i,localTodoNodes.size(),localStatistics.size());
    if (localTodoNodes.size() == 0) {
      continue;
    }
    realThreadCount+=1;
    completionService.submit(new Callable<Map<Integer,NodeStats>>(){
      @Override public Map<Integer,NodeStats> call() throws Exception {
        List<Integer> nodeIndexes=new ArrayList<Integer>(trees.size());
        for (        Data data : DTWorker.this.trainingData) {
          nodeIndexes.clear();
          if (DTWorker.this.isRF) {
            for (            TreeNode treeNode : trees) {
              Node predictNode=predictNodeIndex(treeNode.getNode(),data);
              nodeIndexes.add(predictNode.getId());
            }
          }
          if (DTWorker.this.isGBDT) {
            int currTreeIndex=trees.size() - 1;
            Node predictNode=predictNodeIndex(trees.get(currTreeIndex).getNode(),data);
            nodeIndexes.add(predictNode.getId());
          }
          for (          Map.Entry<Integer,TreeNode> entry : localTodoNodes.entrySet()) {
            Node todoNode=entry.getValue().getNode();
            int treeId=entry.getValue().getTreeId();
            int currPredictIndex=0;
            if (DTWorker.this.isRF) {
              currPredictIndex=nodeIndexes.get(entry.getValue().getTreeId());
            }
            if (DTWorker.this.isGBDT) {
              currPredictIndex=nodeIndexes.get(0);
            }
            if (todoNode.getId() == currPredictIndex) {
              List<Integer> features=entry.getValue().getFeatures();
              if (features.isEmpty()) {
                features=getAllValidFeatures();
              }
              for (              Integer columnNum : features) {
                ColumnConfig config=DTWorker.this.columnConfigList.get(columnNum);
                double[] featuerStatistic=localStatistics.get(entry.getKey()).getFeatureStatistics().get(columnNum);
                float weight=data.subsampleWeights[treeId % data.subsampleWeights.length];
                if (config.isNumerical()) {
                  float value=data.numericInputs[DTWorker.this.numericInputIndexMap.get(columnNum)];
                  int binIndex=getBinIndex(value,config.getBinBoundary());
                  DTWorker.this.impurity.featureUpdate(featuerStatistic,binIndex,data.output,data.significance,weight);
                }
 else                 if (config.isCategorical()) {
                  String category=data.categoricalInputs[DTWorker.this.categoricalInputIndexMap.get(columnNum)];
                  Integer binIndex=DTWorker.this.categoryIndexMap.get(columnNum).get(category);
                  if (binIndex == null) {
                    binIndex=config.getBinCategory().size();
                  }
                  DTWorker.this.impurity.featureUpdate(featuerStatistic,binIndex,data.output,data.significance,weight);
                }
 else {
                  throw new IllegalStateException(""String_Node_Str"");
                }
              }
            }
          }
        }
        return localStatistics;
      }
    }
);
  }
  int rCnt=0;
  while (rCnt < realThreadCount) {
    try {
      statistics.putAll(completionService.take().get());
    }
 catch (    ExecutionException e) {
      throw new RuntimeException(e);
    }
catch (    InterruptedException e) {
      Thread.currentThread().interrupt();
    }
    rCnt+=1;
  }
  LOG.info(""String_Node_Str"",count,trainError,statistics.size());
  return new DTWorkerParams(weightedTrainCount,weightedValidationCount,trainError,validationError,statistics);
}",0.962399328030041
32020,"@Override public void doReadFields(DataInput in) throws IOException {
  this.trainCount=in.readLong();
  this.validationCount=in.readLong();
  this.trainError=in.readDouble();
  this.validationError=in.readDouble();
  if (in.readBoolean()) {
    this.nodeStatsMap=new HashMap<Integer,NodeStats>();
    int len=in.readInt();
    for (int i=0; i < len; i++) {
      int key=in.readInt();
      NodeStats stats=new NodeStats();
      stats.readFields(in);
      this.nodeStatsMap.put(key,stats);
    }
  }
}","@Override public void doReadFields(DataInput in) throws IOException {
  this.trainCount=in.readDouble();
  this.validationCount=in.readDouble();
  this.trainError=in.readDouble();
  this.validationError=in.readDouble();
  if (in.readBoolean()) {
    this.nodeStatsMap=new HashMap<Integer,NodeStats>();
    int len=in.readInt();
    for (int i=0; i < len; i++) {
      int key=in.readInt();
      NodeStats stats=new NodeStats();
      stats.readFields(in);
      this.nodeStatsMap.put(key,stats);
    }
  }
}",0.9802371541501976
32021,"/** 
 * @return the trainCount
 */
public long getTrainCount(){
  return trainCount;
}","/** 
 * @return the trainCount
 */
public double getTrainCount(){
  return trainCount;
}",0.9540229885057472
32022,"/** 
 * @return the validationCount
 */
public long getValidationCount(){
  return validationCount;
}","/** 
 * @return the validationCount
 */
public double getValidationCount(){
  return validationCount;
}",0.9607843137254902
32023,"/** 
 * @param validationCount the validationCount to set
 */
public void setValidationCount(long validationCount){
  this.validationCount=validationCount;
}","/** 
 * @param validationCount the validationCount to set
 */
public void setValidationCount(double validationCount){
  this.validationCount=validationCount;
}",0.9746835443037974
32024,"@Override public void doWrite(DataOutput out) throws IOException {
  out.writeLong(trainCount);
  out.writeLong(validationCount);
  out.writeDouble(trainError);
  out.writeDouble(validationError);
  if (nodeStatsMap == null) {
    out.writeBoolean(false);
  }
 else {
    out.writeBoolean(true);
    out.writeInt(nodeStatsMap.size());
    for (    Entry<Integer,NodeStats> entry : nodeStatsMap.entrySet()) {
      out.writeInt(entry.getKey());
      entry.getValue().write(out);
    }
  }
}","@Override public void doWrite(DataOutput out) throws IOException {
  out.writeDouble(trainCount);
  out.writeDouble(validationCount);
  out.writeDouble(trainError);
  out.writeDouble(validationError);
  if (nodeStatsMap == null) {
    out.writeBoolean(false);
  }
 else {
    out.writeBoolean(true);
    out.writeInt(nodeStatsMap.size());
    for (    Entry<Integer,NodeStats> entry : nodeStatsMap.entrySet()) {
      out.writeInt(entry.getKey());
      entry.getValue().write(out);
    }
  }
}",0.9796747967479674
32025,"/** 
 * @param trainCount the trainCount to set
 */
public void setTrainCount(long trainCount){
  this.trainCount=trainCount;
}","/** 
 * @param trainCount the trainCount to set
 */
public void setTrainCount(double trainCount){
  this.trainCount=trainCount;
}",0.96875
32026,"public DTWorkerParams(long trainCount,long validationCount,double trainError,double validationError,Map<Integer,NodeStats> nodeStatsMap){
  this.trainCount=trainCount;
  this.validationCount=validationCount;
  this.trainError=trainError;
  this.validationError=validationError;
  this.nodeStatsMap=nodeStatsMap;
}","public DTWorkerParams(double trainCount,double validationCount,double trainError,double validationError,Map<Integer,NodeStats> nodeStatsMap){
  this.trainCount=trainCount;
  this.validationCount=validationCount;
  this.trainError=trainError;
  this.validationError=validationError;
  this.nodeStatsMap=nodeStatsMap;
}",0.9301587301587302
32027,"@Override public void init(WorkerContext<DTMasterParams,DTWorkerParams> context){
  Properties props=context.getProps();
  try {
    SourceType sourceType=SourceType.valueOf(props.getProperty(CommonConstants.MODELSET_SOURCE_TYPE,SourceType.HDFS.toString()));
    this.modelConfig=CommonUtils.loadModelConfig(props.getProperty(CommonConstants.SHIFU_MODEL_CONFIG),sourceType);
    this.columnConfigList=CommonUtils.loadColumnConfigList(props.getProperty(CommonConstants.SHIFU_COLUMN_CONFIG),sourceType);
    for (    ColumnConfig config : this.columnConfigList) {
      if (config.isCategorical()) {
        Map<String,Integer> categoryMap=new HashMap<String,Integer>();
        for (int i=0; i < config.getBinCategory().size(); i++) {
          categoryMap.put(config.getBinCategory().get(i),i);
        }
        this.categoryIndexMap.put(config.getColumnNum(),categoryMap);
      }
    }
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
  this.trainerId=Integer.valueOf(context.getProps().getProperty(CommonConstants.SHIFU_TRAINER_ID));
  this.isOneVsAll=modelConfig.isClassification() && modelConfig.getTrain().isOneVsAll();
  this.treeNum=Integer.valueOf(this.modelConfig.getTrain().getParams().get(""String_Node_Str"").toString());
  ;
  double memoryFraction=Double.valueOf(context.getProps().getProperty(""String_Node_Str"",""String_Node_Str""));
  LOG.info(""String_Node_Str"",Runtime.getRuntime().maxMemory(),memoryFraction);
  this.trainingData=new MemoryLimitedList<Data>((long)(Runtime.getRuntime().maxMemory() * memoryFraction),new LinkedList<Data>());
  int[] inputOutputIndex=DTrainUtils.getNumericAndCategoricalInputAndOutputCounts(this.columnConfigList);
  this.numericInputCount=inputOutputIndex[0];
  this.categoricalInputCount=inputOutputIndex[1];
  this.outputNodeCount=modelConfig.isRegression() ? inputOutputIndex[2] : modelConfig.getTags().size();
  this.isAfterVarSelect=inputOutputIndex[3] == 1 ? true : false;
  this.rng=new PoissonDistribution[treeNum];
  for (int i=0; i < treeNum; i++) {
    this.rng[i]=new PoissonDistribution(this.modelConfig.getTrain().getBaggingSampleRate());
  }
  int numClasses=this.modelConfig.isClassification() ? this.modelConfig.getFlattenTags().size() : 2;
  String imStr=this.modelConfig.getTrain().getParams().get(""String_Node_Str"").toString();
  int minInstancesPerNode=Integer.valueOf(this.modelConfig.getParams().get(""String_Node_Str"").toString());
  double minInfoGain=Double.valueOf(this.modelConfig.getParams().get(""String_Node_Str"").toString());
  if (imStr.equalsIgnoreCase(""String_Node_Str"")) {
    impurity=new Entropy(numClasses,minInstancesPerNode,minInfoGain);
  }
 else   if (imStr.equalsIgnoreCase(""String_Node_Str"")) {
    impurity=new Gini(numClasses,minInstancesPerNode,minInfoGain);
  }
 else {
    impurity=new Variance(minInstancesPerNode,minInfoGain);
  }
  this.isRF=ALGORITHM.RF.toString().equalsIgnoreCase(modelConfig.getAlgorithm());
  this.isGBDT=ALGORITHM.GBT.toString().equalsIgnoreCase(modelConfig.getAlgorithm());
  String lossStr=this.modelConfig.getTrain().getParams().get(""String_Node_Str"").toString();
  if (lossStr.equalsIgnoreCase(""String_Node_Str"")) {
    this.loss=new LogLoss();
  }
 else   if (lossStr.equalsIgnoreCase(""String_Node_Str"")) {
    this.loss=new AbsoluteLoss();
  }
 else {
    this.loss=new SquaredLoss();
  }
  if (this.isGBDT) {
    this.learningRate=Double.valueOf(this.modelConfig.getParams().get(NNTrainer.LEARNING_RATE).toString());
    Object swrObj=this.modelConfig.getParams().get(""String_Node_Str"");
    if (swrObj != null) {
      this.gbdtSampleWithReplacement=Boolean.TRUE.toString().equalsIgnoreCase(swrObj.toString());
    }
  }
  LOG.info(""String_Node_Str"",isAfterVarSelect,treeNum,impurity.getClass().getName(),loss.getClass().getName(),this.learningRate,this.gbdtSampleWithReplacement,this.isRF,this.isGBDT);
}","@Override public void init(WorkerContext<DTMasterParams,DTWorkerParams> context){
  Properties props=context.getProps();
  try {
    SourceType sourceType=SourceType.valueOf(props.getProperty(CommonConstants.MODELSET_SOURCE_TYPE,SourceType.HDFS.toString()));
    this.modelConfig=CommonUtils.loadModelConfig(props.getProperty(CommonConstants.SHIFU_MODEL_CONFIG),sourceType);
    this.columnConfigList=CommonUtils.loadColumnConfigList(props.getProperty(CommonConstants.SHIFU_COLUMN_CONFIG),sourceType);
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
  for (  ColumnConfig config : this.columnConfigList) {
    if (config.isCategorical()) {
      Map<String,Integer> categoryMap=new HashMap<String,Integer>();
      for (int i=0; i < config.getBinCategory().size(); i++) {
        categoryMap.put(config.getBinCategory().get(i),i);
      }
      this.categoryIndexMap.put(config.getColumnNum(),categoryMap);
    }
  }
  this.workerThreadCount=modelConfig.getTrain().getWorkerThreadCount();
  this.threadPool=Executors.newFixedThreadPool(this.workerThreadCount);
  context.addCompletionCallBack(new WorkerCompletionCallBack<DTMasterParams,DTWorkerParams>(){
    @Override public void callback(    WorkerContext<DTMasterParams,DTWorkerParams> context){
      DTWorker.this.threadPool.shutdownNow();
      try {
        DTWorker.this.threadPool.awaitTermination(2,TimeUnit.SECONDS);
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
      }
    }
  }
);
  this.trainerId=Integer.valueOf(context.getProps().getProperty(CommonConstants.SHIFU_TRAINER_ID,""String_Node_Str""));
  this.isOneVsAll=modelConfig.isClassification() && modelConfig.getTrain().isOneVsAll();
  this.treeNum=Integer.valueOf(this.modelConfig.getTrain().getParams().get(""String_Node_Str"").toString());
  ;
  double memoryFraction=Double.valueOf(context.getProps().getProperty(""String_Node_Str"",""String_Node_Str""));
  LOG.info(""String_Node_Str"",Runtime.getRuntime().maxMemory(),memoryFraction);
  this.trainingData=new MemoryLimitedList<Data>((long)(Runtime.getRuntime().maxMemory() * memoryFraction),new LinkedList<Data>());
  int[] inputOutputIndex=DTrainUtils.getNumericAndCategoricalInputAndOutputCounts(this.columnConfigList);
  this.numericInputCount=inputOutputIndex[0];
  this.categoricalInputCount=inputOutputIndex[1];
  this.outputNodeCount=modelConfig.isRegression() ? inputOutputIndex[2] : modelConfig.getTags().size();
  this.isAfterVarSelect=inputOutputIndex[3] == 1 ? true : false;
  this.rng=new PoissonDistribution[treeNum];
  for (int i=0; i < treeNum; i++) {
    this.rng[i]=new PoissonDistribution(this.modelConfig.getTrain().getBaggingSampleRate());
  }
  int numClasses=this.modelConfig.isClassification() ? this.modelConfig.getTags().size() : 2;
  String imStr=this.modelConfig.getTrain().getParams().get(""String_Node_Str"").toString();
  int minInstancesPerNode=Integer.valueOf(this.modelConfig.getParams().get(""String_Node_Str"").toString());
  double minInfoGain=Double.valueOf(this.modelConfig.getParams().get(""String_Node_Str"").toString());
  if (imStr.equalsIgnoreCase(""String_Node_Str"")) {
    impurity=new Entropy(numClasses,minInstancesPerNode,minInfoGain);
  }
 else   if (imStr.equalsIgnoreCase(""String_Node_Str"")) {
    impurity=new Gini(numClasses,minInstancesPerNode,minInfoGain);
  }
 else {
    impurity=new Variance(minInstancesPerNode,minInfoGain);
  }
  this.isRF=ALGORITHM.RF.toString().equalsIgnoreCase(modelConfig.getAlgorithm());
  this.isGBDT=ALGORITHM.GBT.toString().equalsIgnoreCase(modelConfig.getAlgorithm());
  String lossStr=this.modelConfig.getTrain().getParams().get(""String_Node_Str"").toString();
  if (lossStr.equalsIgnoreCase(""String_Node_Str"")) {
    this.loss=new LogLoss();
  }
 else   if (lossStr.equalsIgnoreCase(""String_Node_Str"")) {
    this.loss=new AbsoluteLoss();
  }
 else {
    this.loss=new SquaredLoss();
  }
  if (this.isGBDT) {
    this.learningRate=Double.valueOf(this.modelConfig.getParams().get(NNTrainer.LEARNING_RATE).toString());
    Object swrObj=this.modelConfig.getParams().get(""String_Node_Str"");
    if (swrObj != null) {
      this.gbdtSampleWithReplacement=Boolean.TRUE.toString().equalsIgnoreCase(swrObj.toString());
    }
  }
  LOG.info(""String_Node_Str"",isAfterVarSelect,treeNum,impurity.getClass().getName(),loss.getClass().getName(),this.learningRate,this.gbdtSampleWithReplacement,this.isRF,this.isGBDT);
}",0.8364339212370138
32028,"private float updateOneVsAllTargetValue(float ideal){
  float result=0f;
  if (Float.compare(ideal,trainerId) == 0) {
    result=1.0f;
  }
 else {
    result=0.0f;
  }
  return result;
}","private float updateOneVsAllTargetValue(float ideal){
  return Float.compare(ideal,trainerId) == 0 ? 1f : 0f;
}",0.7003367003367004
32029,"/** 
 * 'binBoundary' is ArrayList in fact, so we can use get method. [""-Infinity"", 1d, 4d, ....]
 */
private int getBinIndex(float value,List<Double> binBoundary){
  if (binBoundary.size() <= 1) {
    throw new IllegalArgumentException();
  }
  int low=0, high=binBoundary.size() - 1;
  while (low <= high) {
    int mid=(low + high) >>> 1;
    double lowThreshold=binBoundary.get(mid);
    double highThreshold=mid == binBoundary.size() - 1 ? Double.MAX_VALUE : binBoundary.get(mid + 1);
    if (value >= lowThreshold && value < highThreshold) {
      return mid;
    }
    if (value >= highThreshold) {
      low=mid + 1;
    }
 else {
      high=mid - 1;
    }
  }
  return -1;
}","/** 
 * 'binBoundary' is ArrayList in fact, so we can use get method. [""-Infinity"", 1d, 4d, ....]
 */
public static int getBinIndex(float value,List<Double> binBoundary){
  if (binBoundary.size() <= 1) {
    throw new IllegalArgumentException();
  }
  int low=0, high=binBoundary.size() - 1;
  while (low <= high) {
    int mid=(low + high) >>> 1;
    double lowThreshold=binBoundary.get(mid);
    double highThreshold=mid == binBoundary.size() - 1 ? Double.MAX_VALUE : binBoundary.get(mid + 1);
    if (value >= lowThreshold && value < highThreshold) {
      return mid;
    }
    if (value >= highThreshold) {
      low=mid + 1;
    }
 else {
      high=mid - 1;
    }
  }
  return -1;
}",0.9868804664723032
32030,"@Override public DTWorkerParams doCompute(WorkerContext<DTMasterParams,DTWorkerParams> context){
  if (context.isFirstIteration()) {
    return new DTWorkerParams();
  }
  DTMasterParams lastMasterResult=context.getLastMasterResult();
  List<TreeNode> trees=lastMasterResult.getTrees();
  Map<Integer,TreeNode> todoNodes=lastMasterResult.getTodoNodes();
  if (todoNodes == null) {
    return new DTWorkerParams();
  }
  Map<Integer,NodeStats> statistics=initTodoNodeStats(todoNodes);
  double squareError=0d;
  List<Integer> nodeIndexes=new ArrayList<Integer>(trees.size());
  if (this.isGBDT && !this.gbdtSampleWithReplacement && lastMasterResult.isSwitchToNextTree()) {
    this.random=new Random();
  }
  for (  Data data : this.trainingData) {
    nodeIndexes.clear();
    squareError+=computeErrorAndUpdateNodeIndex(lastMasterResult,trees,nodeIndexes,data);
    updateTodoNodeStats(todoNodes,statistics,nodeIndexes,data);
  }
  LOG.info(""String_Node_Str"",count,squareError,statistics.size());
  return new DTWorkerParams(count,squareError,statistics);
}","@Override public DTWorkerParams doCompute(WorkerContext<DTMasterParams,DTWorkerParams> context){
  if (context.isFirstIteration()) {
    return new DTWorkerParams();
  }
  DTMasterParams lastMasterResult=context.getLastMasterResult();
  final List<TreeNode> trees=lastMasterResult.getTrees();
  final Map<Integer,TreeNode> todoNodes=lastMasterResult.getTodoNodes();
  if (todoNodes == null) {
    return new DTWorkerParams();
  }
  Map<Integer,NodeStats> statistics=initTodoNodeStats(todoNodes);
  double squareError=0d;
  if (this.isGBDT && !this.gbdtSampleWithReplacement && lastMasterResult.isSwitchToNextTree()) {
    this.random=new Random();
  }
  for (  Data data : this.trainingData) {
    if (this.isRF) {
      for (      TreeNode treeNode : trees) {
        Node predictNode=predictNodeIndex(treeNode.getNode(),data);
        if (predictNode.getPredict() != null) {
          squareError+=loss.computeError((float)(predictNode.getPredict().getPredict()),data.label);
        }
      }
    }
    if (this.isGBDT) {
      int currTreeIndex=trees.size() - 1;
      if (lastMasterResult.isSwitchToNextTree()) {
        if (currTreeIndex >= 1) {
          Node node=trees.get(currTreeIndex - 1).getNode();
          Node predictNode=predictNodeIndex(node,data);
          if (predictNode.getPredict() != null) {
            double predict=predictNode.getPredict().getPredict();
            if (currTreeIndex == 1) {
              data.predict=(float)predict;
            }
 else {
              data.predict+=(float)(this.learningRate * predict);
            }
            data.output=-1f * loss.computeGradient(data.predict,data.label);
          }
          if (!this.gbdtSampleWithReplacement) {
            if (random.nextDouble() <= modelConfig.getTrain().getBaggingSampleRate()) {
              data.subsampleWeights[currTreeIndex]=1f;
            }
 else {
              data.subsampleWeights[currTreeIndex]=0f;
            }
          }
        }
      }
      Node predictNode=predictNodeIndex(trees.get(currTreeIndex).getNode(),data);
      if (currTreeIndex >= 1) {
        squareError+=loss.computeError(data.predict,data.label);
      }
 else {
        if (predictNode.getPredict() != null) {
          squareError+=loss.computeError(((float)predictNode.getPredict().getPredict()),data.label);
        }
      }
    }
  }
  CompletionService<Map<Integer,NodeStats>> completionService=new ExecutorCompletionService<Map<Integer,NodeStats>>(this.threadPool);
  Set<Entry<Integer,TreeNode>> treeNodeEntrySet=todoNodes.entrySet();
  Iterator<Entry<Integer,TreeNode>> treeNodeIterator=treeNodeEntrySet.iterator();
  int roundNodeNumer=treeNodeEntrySet.size() / this.workerThreadCount;
  int modeNodeNumber=treeNodeEntrySet.size() % this.workerThreadCount;
  int realThreadCount=0;
  LOG.info(""String_Node_Str"",todoNodes.size());
  for (int i=0; i < this.workerThreadCount; i++) {
    final Map<Integer,TreeNode> localTodoNodes=new HashMap<Integer,TreeNode>();
    final Map<Integer,NodeStats> localStatistics=new HashMap<Integer,DTWorkerParams.NodeStats>();
    for (int j=0; j < roundNodeNumer; j++) {
      Entry<Integer,TreeNode> tmpTreeNode=treeNodeIterator.next();
      localTodoNodes.put(tmpTreeNode.getKey(),tmpTreeNode.getValue());
      localStatistics.put(tmpTreeNode.getKey(),statistics.get(tmpTreeNode.getKey()));
    }
    if (modeNodeNumber > 0) {
      Entry<Integer,TreeNode> tmpTreeNode=treeNodeIterator.next();
      localTodoNodes.put(tmpTreeNode.getKey(),tmpTreeNode.getValue());
      localStatistics.put(tmpTreeNode.getKey(),statistics.get(tmpTreeNode.getKey()));
      modeNodeNumber-=1;
    }
    LOG.info(""String_Node_Str"",i,localTodoNodes.size(),localStatistics.size());
    if (localTodoNodes.size() == 0) {
      continue;
    }
    realThreadCount+=1;
    completionService.submit(new Callable<Map<Integer,NodeStats>>(){
      @Override public Map<Integer,NodeStats> call() throws Exception {
        List<Integer> nodeIndexes=new ArrayList<Integer>(trees.size());
        for (        Data data : DTWorker.this.trainingData) {
          nodeIndexes.clear();
          if (DTWorker.this.isRF) {
            for (            TreeNode treeNode : trees) {
              Node predictNode=predictNodeIndex(treeNode.getNode(),data);
              nodeIndexes.add(predictNode.getId());
            }
          }
          if (DTWorker.this.isGBDT) {
            int currTreeIndex=trees.size() - 1;
            Node predictNode=predictNodeIndex(trees.get(currTreeIndex).getNode(),data);
            nodeIndexes.add(predictNode.getId());
          }
          for (          Map.Entry<Integer,TreeNode> entry : localTodoNodes.entrySet()) {
            Node todoNode=entry.getValue().getNode();
            int treeId=entry.getValue().getTreeId();
            int currPredictIndex=0;
            if (DTWorker.this.isRF) {
              currPredictIndex=nodeIndexes.get(entry.getValue().getTreeId());
            }
            if (DTWorker.this.isGBDT) {
              currPredictIndex=nodeIndexes.get(0);
            }
            if (todoNode.getId() == currPredictIndex) {
              List<Integer> features=entry.getValue().getFeatures();
              if (features.isEmpty()) {
                features=getAllValidFeatures();
              }
              for (              Integer columnNum : features) {
                ColumnConfig config=DTWorker.this.columnConfigList.get(columnNum);
                double[] featuerStatistic=localStatistics.get(entry.getKey()).getFeatureStatistics().get(columnNum);
                float weight=data.subsampleWeights[treeId];
                if (config.isNumerical()) {
                  float value=data.numericInputs[DTWorker.this.numericInputIndexMap.get(columnNum)];
                  int binIndex=getBinIndex(value,config.getBinBoundary());
                  DTWorker.this.impurity.featureUpdate(featuerStatistic,binIndex,data.output,data.significance,weight);
                }
 else                 if (config.isCategorical()) {
                  String category=data.categoricalInputs[DTWorker.this.categoricalInputIndexMap.get(columnNum)];
                  Integer binIndex=DTWorker.this.categoryIndexMap.get(columnNum).get(category);
                  if (binIndex == null) {
                    binIndex=config.getBinCategory().size();
                  }
                  DTWorker.this.impurity.featureUpdate(featuerStatistic,binIndex,data.output,data.significance,weight);
                }
 else {
                  throw new IllegalStateException(""String_Node_Str"");
                }
              }
            }
          }
        }
        return localStatistics;
      }
    }
);
  }
  int rCnt=0;
  while (rCnt < realThreadCount) {
    try {
      statistics.putAll(completionService.take().get());
    }
 catch (    ExecutionException e) {
      throw new RuntimeException(e);
    }
catch (    InterruptedException e) {
      Thread.currentThread().interrupt();
    }
    rCnt+=1;
  }
  LOG.info(""String_Node_Str"",count,squareError,statistics.size());
  return new DTWorkerParams(count,squareError,statistics);
}",0.2174923547400611
32031,"@Override public void load(GuaguaWritableAdapter<LongWritable> currentKey,GuaguaWritableAdapter<Text> currentValue,WorkerContext<DTMasterParams,DTWorkerParams> context){
  this.count+=1;
  if ((this.count) % 100000 == 0) {
    LOG.info(""String_Node_Str"",this.count);
  }
  float[] numericInputs=new float[this.numericInputCount];
  String[] categoricalInputs=new String[this.categoricalInputCount];
  float ideal=0f;
  float significance=1f;
  int index=0, numericInputsIndex=0, categoricalInputsIndex=0;
  for (  String input : DEFAULT_SPLITTER.split(currentValue.getWritable().toString())) {
    float floatValue=NumberFormatUtils.getFloat(input,0f);
    if (Float.isNaN(floatValue) || Double.isNaN(floatValue)) {
      floatValue=0f;
    }
    if (index == this.columnConfigList.size()) {
      significance=NumberFormatUtils.getFloat(input,1f);
      break;
    }
 else {
      ColumnConfig columnConfig=this.columnConfigList.get(index);
      if (columnConfig != null && columnConfig.isTarget()) {
        ideal=floatValue;
      }
 else {
        if (!isAfterVarSelect) {
          if (!columnConfig.isMeta() && !columnConfig.isTarget() && CommonUtils.isGoodCandidate(columnConfig)) {
            if (columnConfig.isNumerical()) {
              numericInputs[numericInputsIndex]=floatValue;
              this.numericInputIndexMap.put(columnConfig.getColumnNum(),numericInputsIndex);
              numericInputsIndex+=1;
            }
 else             if (columnConfig.isCategorical()) {
              if (input == null) {
                categoricalInputs[categoricalInputsIndex]=""String_Node_Str"";
              }
 else {
                categoricalInputs[categoricalInputsIndex]=input;
              }
              this.categoricalInputIndexMap.put(columnConfig.getColumnNum(),categoricalInputsIndex);
              categoricalInputsIndex+=1;
            }
          }
        }
 else {
          if (columnConfig != null && !columnConfig.isMeta() && !columnConfig.isTarget() && columnConfig.isFinalSelect()) {
            if (columnConfig.isNumerical()) {
              numericInputs[numericInputsIndex]=floatValue;
              this.numericInputIndexMap.put(columnConfig.getColumnNum(),numericInputsIndex);
              numericInputsIndex+=1;
            }
 else             if (columnConfig.isCategorical()) {
              if (input == null) {
                categoricalInputs[categoricalInputsIndex]=""String_Node_Str"";
              }
 else {
                categoricalInputs[categoricalInputsIndex]=input;
              }
              this.categoricalInputIndexMap.put(columnConfig.getColumnNum(),categoricalInputsIndex);
              categoricalInputsIndex+=1;
            }
          }
        }
      }
    }
    index+=1;
  }
  if (this.isOneVsAll) {
    ideal=updateOneVsAllTargetValue(ideal);
  }
  float output=ideal;
  float predict=ideal;
  Data data=new Data(numericInputs,categoricalInputs,predict,output,output,significance,sampleWeights());
  boolean isNeedFailOver=!context.isFirstIteration();
  if (isNeedFailOver && this.isGBDT) {
    recoverGBTData(context,output,predict,data);
  }
  this.trainingData.append(data);
}","@Override public void load(GuaguaWritableAdapter<LongWritable> currentKey,GuaguaWritableAdapter<Text> currentValue,WorkerContext<DTMasterParams,DTWorkerParams> context){
  this.count+=1;
  if ((this.count) % 2000 == 0) {
    LOG.info(""String_Node_Str"",this.count);
  }
  float[] numericInputs=new float[this.numericInputCount];
  String[] categoricalInputs=new String[this.categoricalInputCount];
  float ideal=0f;
  float significance=1f;
  int index=0, numericInputsIndex=0, categoricalInputsIndex=0;
  for (  String input : DEFAULT_SPLITTER.split(currentValue.getWritable().toString())) {
    float floatValue=0f;
    if (input.length() == 0) {
      floatValue=0f;
    }
 else {
      floatValue=NumberFormatUtils.getFloat(input,0f);
    }
    if (Float.isNaN(floatValue) || Double.isNaN(floatValue)) {
      floatValue=0f;
    }
    if (index == this.columnConfigList.size()) {
      if (input.length() == 0) {
        significance=1f;
      }
 else {
        significance=NumberFormatUtils.getFloat(input,1f);
      }
      break;
    }
 else {
      ColumnConfig columnConfig=this.columnConfigList.get(index);
      if (columnConfig != null && columnConfig.isTarget()) {
        ideal=floatValue;
      }
 else {
        if (!isAfterVarSelect) {
          if (!columnConfig.isMeta() && !columnConfig.isTarget() && CommonUtils.isGoodCandidate(columnConfig)) {
            if (columnConfig.isNumerical()) {
              numericInputs[numericInputsIndex]=floatValue;
              this.numericInputIndexMap.put(columnConfig.getColumnNum(),numericInputsIndex);
              numericInputsIndex+=1;
            }
 else             if (columnConfig.isCategorical()) {
              if (input == null || input.length() == 0) {
                categoricalInputs[categoricalInputsIndex]=""String_Node_Str"";
              }
 else {
                categoricalInputs[categoricalInputsIndex]=input;
              }
              this.categoricalInputIndexMap.put(columnConfig.getColumnNum(),categoricalInputsIndex);
              categoricalInputsIndex+=1;
            }
          }
        }
 else {
          if (columnConfig != null && !columnConfig.isMeta() && !columnConfig.isTarget() && columnConfig.isFinalSelect()) {
            if (columnConfig.isNumerical()) {
              numericInputs[numericInputsIndex]=floatValue;
              this.numericInputIndexMap.put(columnConfig.getColumnNum(),numericInputsIndex);
              numericInputsIndex+=1;
            }
 else             if (columnConfig.isCategorical()) {
              if (input == null || input.length() == 0) {
                categoricalInputs[categoricalInputsIndex]=""String_Node_Str"";
              }
 else {
                categoricalInputs[categoricalInputsIndex]=input;
              }
              this.categoricalInputIndexMap.put(columnConfig.getColumnNum(),categoricalInputsIndex);
              categoricalInputsIndex+=1;
            }
          }
        }
      }
    }
    index+=1;
  }
  if (this.isOneVsAll) {
    ideal=updateOneVsAllTargetValue(ideal);
  }
  float output=ideal;
  float predict=ideal;
  Data data=new Data(numericInputs,categoricalInputs,predict,output,output,significance,sampleWeights());
  boolean isNeedFailOver=!context.isFirstIteration();
  if (isNeedFailOver && this.isGBDT) {
    recoverGBTData(context,output,predict,data);
  }
  this.trainingData.append(data);
}",0.9652745907908826
32032,"@Override public void load(GuaguaWritableAdapter<LongWritable> currentKey,GuaguaWritableAdapter<Text> currentValue,WorkerContext<LogisticRegressionParams,LogisticRegressionParams> context){
  ++this.count;
  if ((this.count) % 100000 == 0) {
    LOG.info(""String_Node_Str"",this.count);
  }
  double baggingSampleRate=this.modelConfig.getBaggingSampleRate();
  if (!this.modelConfig.isFixInitialInput() && Double.compare(Math.random(),baggingSampleRate) >= 0) {
    return;
  }
  String line=currentValue.getWritable().toString();
  float[] inputData=new float[inputNum];
  float[] outputData=new float[outputNum];
  int index=0, inputIndex=0, outputIndex=0;
  long hashcode=0;
  double significance=CommonConstants.DEFAULT_SIGNIFICANCE_VALUE;
  for (  String unit : splitter.split(line)) {
    float floatValue=NumberFormatUtils.getFloat(unit.trim(),0f);
    if (Double.isNaN(floatValue)) {
      floatValue=0f;
    }
    if (index == this.columnConfigList.size()) {
      significance=NumberFormatUtils.getDouble(unit.trim(),1.0d);
      break;
    }
 else {
      ColumnConfig columnConfig=this.columnConfigList.get(index);
      if (columnConfig != null && columnConfig.isTarget()) {
        outputData[outputIndex++]=floatValue;
      }
 else {
        if (this.inputNum == this.candidateNum) {
          if (!columnConfig.isMeta() && !columnConfig.isTarget() && CommonUtils.isGoodCandidate(columnConfig)) {
            inputData[inputIndex++]=floatValue;
            hashcode=hashcode * 31 + Float.valueOf(floatValue).hashCode();
          }
        }
 else {
          if (columnConfig != null && !columnConfig.isMeta() && !columnConfig.isTarget() && columnConfig.isFinalSelect()) {
            inputData[inputIndex++]=floatValue;
            hashcode=hashcode * 31 + Float.valueOf(floatValue).hashCode();
          }
        }
      }
    }
    index+=1;
  }
  long longBaggingSampleRate=Double.valueOf(baggingSampleRate * 100).longValue();
  if (modelConfig.isFixInitialInput() && hashcode % 100 >= longBaggingSampleRate) {
    return;
  }
  this.sampleCount+=1;
  if (modelConfig.isRegression() && isUpSampleEnabled() && Double.compare(outputData[0],1d) == 0) {
    significance*=(this.upSampleRng.sample() + 1);
  }
  this.addDataPairToDataSet(hashcode,new Data(inputData,outputData,significance));
}","@Override public void load(GuaguaWritableAdapter<LongWritable> currentKey,GuaguaWritableAdapter<Text> currentValue,WorkerContext<LogisticRegressionParams,LogisticRegressionParams> context){
  ++this.count;
  if ((this.count) % 100000 == 0) {
    LOG.info(""String_Node_Str"",this.count);
  }
  double baggingSampleRate=this.modelConfig.getBaggingSampleRate();
  if (!this.modelConfig.isFixInitialInput() && Double.compare(Math.random(),baggingSampleRate) >= 0) {
    return;
  }
  String line=currentValue.getWritable().toString();
  float[] inputData=new float[inputNum];
  float[] outputData=new float[outputNum];
  int index=0, inputIndex=0, outputIndex=0;
  long hashcode=0;
  double significance=CommonConstants.DEFAULT_SIGNIFICANCE_VALUE;
  for (  String unit : splitter.split(line)) {
    float floatValue=0f;
    if (unit.length() == 0) {
      floatValue=0f;
    }
 else {
      floatValue=NumberFormatUtils.getFloat(unit,0f);
    }
    if (Double.isNaN(floatValue)) {
      floatValue=0f;
    }
    if (index == this.columnConfigList.size()) {
      significance=NumberFormatUtils.getDouble(unit.trim(),1.0d);
      break;
    }
 else {
      ColumnConfig columnConfig=this.columnConfigList.get(index);
      if (columnConfig != null && columnConfig.isTarget()) {
        outputData[outputIndex++]=floatValue;
      }
 else {
        if (this.inputNum == this.candidateNum) {
          if (!columnConfig.isMeta() && !columnConfig.isTarget() && CommonUtils.isGoodCandidate(columnConfig)) {
            inputData[inputIndex++]=floatValue;
            hashcode=hashcode * 31 + Float.valueOf(floatValue).hashCode();
          }
        }
 else {
          if (columnConfig != null && !columnConfig.isMeta() && !columnConfig.isTarget() && columnConfig.isFinalSelect()) {
            inputData[inputIndex++]=floatValue;
            hashcode=hashcode * 31 + Float.valueOf(floatValue).hashCode();
          }
        }
      }
    }
    index+=1;
  }
  long longBaggingSampleRate=Double.valueOf(baggingSampleRate * 100).longValue();
  if (modelConfig.isFixInitialInput() && hashcode % 100 >= longBaggingSampleRate) {
    return;
  }
  this.sampleCount+=1;
  if (modelConfig.isRegression() && isUpSampleEnabled() && Double.compare(outputData[0],1d) == 0) {
    significance*=(this.upSampleRng.sample() + 1);
  }
  this.addDataPairToDataSet(hashcode,new Data(inputData,outputData,significance));
}",0.9789585547290116
32033,"@Override public void load(GuaguaWritableAdapter<LongWritable> currentKey,GuaguaWritableAdapter<Text> currentValue,WorkerContext<NNParams,NNParams> workerContext){
  super.count+=1;
  if ((super.count) % 100000 == 0) {
    LOG.info(""String_Node_Str"",super.count);
  }
  double baggingSampleRate=super.modelConfig.getBaggingSampleRate();
  if (!super.modelConfig.isFixInitialInput() && Double.compare(Math.random(),baggingSampleRate) >= 0) {
    return;
  }
  float[] inputs=new float[super.inputNodeCount];
  float[] ideal=new float[super.outputNodeCount];
  if (super.isDry) {
    addDataPairToDataSet(0,new BasicFloatMLDataPair(new BasicFloatMLData(inputs),new BasicFloatMLData(ideal)));
    return;
  }
  long hashcode=0;
  float significance=1f;
  int index=0, inputsIndex=0, outputIndex=0;
  for (  String input : DEFAULT_SPLITTER.split(currentValue.getWritable().toString())) {
    float floatValue=NumberFormatUtils.getFloat(input.trim(),0f);
    if (Float.isNaN(floatValue) || Double.isNaN(floatValue)) {
      floatValue=0f;
    }
    if (index == super.columnConfigList.size()) {
      significance=NumberFormatUtils.getFloat(input,1f);
      break;
    }
 else {
      ColumnConfig columnConfig=super.columnConfigList.get(index);
      if (columnConfig != null && columnConfig.isTarget()) {
        if (modelConfig.isRegression()) {
          ideal[outputIndex++]=floatValue;
        }
 else {
          int ideaIndex=(int)floatValue;
          ideal[ideaIndex]=1f;
        }
      }
 else {
        if (super.inputNodeCount == super.candidateCount) {
          if (!columnConfig.isMeta() && !columnConfig.isTarget() && CommonUtils.isGoodCandidate(columnConfig)) {
            inputs[inputsIndex++]=floatValue;
            hashcode=hashcode * 31 + Double.valueOf(floatValue).hashCode();
          }
        }
 else {
          if (columnConfig != null && !columnConfig.isMeta() && !columnConfig.isTarget() && columnConfig.isFinalSelect()) {
            inputs[inputsIndex++]=floatValue;
            hashcode=hashcode * 31 + Double.valueOf(floatValue).hashCode();
          }
        }
      }
    }
    index+=1;
  }
  long longBaggingSampleRate=Double.valueOf(baggingSampleRate * 100).longValue();
  if (super.modelConfig.isFixInitialInput() && hashcode % 100 >= longBaggingSampleRate) {
    return;
  }
  super.sampleCount+=1;
  FloatMLDataPair pair=new BasicFloatMLDataPair(new BasicFloatMLData(inputs),new BasicFloatMLData(ideal));
  if (modelConfig.isRegression() && isUpSampleEnabled() && Double.compare(ideal[0],1d) == 0) {
    pair.setSignificance(significance * (super.upSampleRng.sample() + 1));
  }
 else {
    pair.setSignificance(significance);
  }
  addDataPairToDataSet(hashcode,pair);
}","@Override public void load(GuaguaWritableAdapter<LongWritable> currentKey,GuaguaWritableAdapter<Text> currentValue,WorkerContext<NNParams,NNParams> workerContext){
  super.count+=1;
  if ((super.count) % 5000 == 0) {
    LOG.info(""String_Node_Str"",super.count);
  }
  double baggingSampleRate=super.modelConfig.getBaggingSampleRate();
  if (!super.modelConfig.isFixInitialInput() && Double.compare(Math.random(),baggingSampleRate) >= 0) {
    return;
  }
  float[] inputs=new float[super.inputNodeCount];
  float[] ideal=new float[super.outputNodeCount];
  if (super.isDry) {
    addDataPairToDataSet(0,new BasicFloatMLDataPair(new BasicFloatMLData(inputs),new BasicFloatMLData(ideal)));
    return;
  }
  long hashcode=0;
  float significance=1f;
  int index=0, inputsIndex=0, outputIndex=0;
  for (  String input : DEFAULT_SPLITTER.split(currentValue.getWritable().toString())) {
    float floatValue=0f;
    if (input.length() == 0) {
      floatValue=0f;
    }
 else {
      floatValue=NumberFormatUtils.getFloat(input,0f);
    }
    if (Float.isNaN(floatValue) || Double.isNaN(floatValue)) {
      floatValue=0f;
    }
    if (index == super.columnConfigList.size()) {
      if (input.length() == 0) {
        significance=1f;
      }
 else {
        significance=NumberFormatUtils.getFloat(input,1f);
      }
      break;
    }
 else {
      ColumnConfig columnConfig=super.columnConfigList.get(index);
      if (columnConfig != null && columnConfig.isTarget()) {
        if (modelConfig.isRegression()) {
          ideal[outputIndex++]=floatValue;
        }
 else {
          int ideaIndex=(int)floatValue;
          ideal[ideaIndex]=1f;
        }
      }
 else {
        if (super.inputNodeCount == super.candidateCount) {
          if (!columnConfig.isMeta() && !columnConfig.isTarget() && CommonUtils.isGoodCandidate(columnConfig)) {
            inputs[inputsIndex++]=floatValue;
            hashcode=hashcode * 31 + Double.valueOf(floatValue).hashCode();
          }
        }
 else {
          if (columnConfig != null && !columnConfig.isMeta() && !columnConfig.isTarget() && columnConfig.isFinalSelect()) {
            inputs[inputsIndex++]=floatValue;
            hashcode=hashcode * 31 + Double.valueOf(floatValue).hashCode();
          }
        }
      }
    }
    index+=1;
  }
  long longBaggingSampleRate=Double.valueOf(baggingSampleRate * 100).longValue();
  if (super.modelConfig.isFixInitialInput() && hashcode % 100 >= longBaggingSampleRate) {
    return;
  }
  super.sampleCount+=1;
  FloatMLDataPair pair=new BasicFloatMLDataPair(new BasicFloatMLData(inputs),new BasicFloatMLData(ideal));
  if (modelConfig.isRegression() && isUpSampleEnabled() && Double.compare(ideal[0],1d) == 0) {
    pair.setSignificance(significance * (super.upSampleRng.sample() + 1));
  }
 else {
    pair.setSignificance(significance);
  }
  addDataPairToDataSet(hashcode,pair);
}",0.9663925634608508
32034,"@SuppressWarnings(""String_Node_Str"") private void incrementTagCounters(String tag,String weight){
  long weightLong=(long)(Double.parseDouble(weight) * Constants.EVAL_COUNTER_WEIGHT_SCALE);
  if (isPigEnabled(Constants.SHIFU_GROUP_COUNTER,Constants.COUNTER_RECORDS)) {
    PigStatusReporter.getInstance().getCounter(Constants.SHIFU_GROUP_COUNTER,Constants.COUNTER_RECORDS).increment(1);
  }
  if (posTagSet.contains(tag)) {
    if (isPigEnabled(Constants.SHIFU_GROUP_COUNTER,Constants.COUNTER_POSTAGS)) {
      PigStatusReporter.getInstance().getCounter(Constants.SHIFU_GROUP_COUNTER,Constants.COUNTER_POSTAGS).increment(1);
    }
    if (isPigEnabled(Constants.SHIFU_GROUP_COUNTER,Constants.COUNTER_WPOSTAGS)) {
      PigStatusReporter.getInstance().getCounter(Constants.SHIFU_GROUP_COUNTER,Constants.COUNTER_WPOSTAGS).increment(weightLong);
    }
  }
  if (negTagSet.contains(tag)) {
    if (isPigEnabled(Constants.SHIFU_GROUP_COUNTER,Constants.COUNTER_NEGTAGS)) {
      PigStatusReporter.getInstance().getCounter(Constants.SHIFU_GROUP_COUNTER,Constants.COUNTER_NEGTAGS).increment(1);
    }
    if (isPigEnabled(Constants.SHIFU_GROUP_COUNTER,Constants.COUNTER_WNEGTAGS)) {
      PigStatusReporter.getInstance().getCounter(Constants.SHIFU_GROUP_COUNTER,Constants.COUNTER_WNEGTAGS).increment(weightLong);
    }
  }
}","@SuppressWarnings(""String_Node_Str"") private void incrementTagCounters(String tag,String weight){
  if (tag == null || weight == null) {
    log.warn(""String_Node_Str"" + tag + ""String_Node_Str""+ weight);
    return;
  }
  double dWeight=1;
  if (weight.length() != 0) {
    dWeight=NumberFormatUtils.getDouble(weight,1);
  }
  long weightLong=(long)(dWeight * Constants.EVAL_COUNTER_WEIGHT_SCALE);
  if (isPigEnabled(Constants.SHIFU_GROUP_COUNTER,Constants.COUNTER_RECORDS)) {
    PigStatusReporter.getInstance().getCounter(Constants.SHIFU_GROUP_COUNTER,Constants.COUNTER_RECORDS).increment(1);
  }
  if (posTagSet.contains(tag)) {
    if (isPigEnabled(Constants.SHIFU_GROUP_COUNTER,Constants.COUNTER_POSTAGS)) {
      PigStatusReporter.getInstance().getCounter(Constants.SHIFU_GROUP_COUNTER,Constants.COUNTER_POSTAGS).increment(1);
    }
    if (isPigEnabled(Constants.SHIFU_GROUP_COUNTER,Constants.COUNTER_WPOSTAGS)) {
      PigStatusReporter.getInstance().getCounter(Constants.SHIFU_GROUP_COUNTER,Constants.COUNTER_WPOSTAGS).increment(weightLong);
    }
  }
  if (negTagSet.contains(tag)) {
    if (isPigEnabled(Constants.SHIFU_GROUP_COUNTER,Constants.COUNTER_NEGTAGS)) {
      PigStatusReporter.getInstance().getCounter(Constants.SHIFU_GROUP_COUNTER,Constants.COUNTER_NEGTAGS).increment(1);
    }
    if (isPigEnabled(Constants.SHIFU_GROUP_COUNTER,Constants.COUNTER_WNEGTAGS)) {
      PigStatusReporter.getInstance().getCounter(Constants.SHIFU_GROUP_COUNTER,Constants.COUNTER_WNEGTAGS).increment(weightLong);
    }
  }
}",0.9119718309859156
32035,"public void bufferedComputeConfusionMatrixAndPerformance(long pigPosTags,long pigNegTags,double pigPosWeightTags,double pigNegWeightTags,long records) throws IOException {
  PathFinder pathFinder=new PathFinder(modelConfig);
  SourceType sourceType=evalConfig.getDataSet().getSource();
  List<Scanner> scanners=ShifuFileUtils.getDataScanners(pathFinder.getEvalScorePath(evalConfig,sourceType),sourceType);
  int numBucket=evalConfig.getPerformanceBucketNum();
  boolean isWeight=evalConfig.getDataSet().getWeightColumnName() != null;
  boolean isDir=ShifuFileUtils.isDir(pathFinder.getEvalScorePath(evalConfig,sourceType),sourceType);
  List<PerformanceObject> FPRList=new ArrayList<PerformanceObject>(numBucket + 1);
  List<PerformanceObject> catchRateList=new ArrayList<PerformanceObject>(numBucket + 1);
  List<PerformanceObject> gainList=new ArrayList<PerformanceObject>(numBucket + 1);
  List<PerformanceObject> FPRWeightList=new ArrayList<PerformanceObject>(numBucket + 1);
  List<PerformanceObject> catchRateWeightList=new ArrayList<PerformanceObject>(numBucket + 1);
  List<PerformanceObject> gainWeightList=new ArrayList<PerformanceObject>(numBucket + 1);
  int fpBin=1, tpBin=1, gainBin=1, fpWeightBin=1, tpWeightBin=1, gainWeightBin=1;
  double binCapacity=1.0 / numBucket;
  PerformanceObject po=null;
  int i=0;
  log.info(""String_Node_Str"",scanners.size());
  int cnt=0;
  Set<String> posTags=new HashSet<String>(modelConfig.getPosTags(evalConfig));
  Set<String> negTags=new HashSet<String>(modelConfig.getNegTags(evalConfig));
  ConfusionMatrixObject prevCmo=new ConfusionMatrixObject();
  prevCmo.setTp(0.0);
  prevCmo.setFp(0.0);
  prevCmo.setFn(pigPosTags);
  prevCmo.setTn(pigNegTags);
  prevCmo.setWeightedTp(0.0);
  prevCmo.setWeightedFp(0.0);
  prevCmo.setWeightedFn(pigPosWeightTags);
  prevCmo.setWeightedTn(pigNegWeightTags);
  prevCmo.setScore(1000);
  po=PerformanceEvaluator.setPerformanceObject(prevCmo);
  po.precision=1.0;
  po.weightedPrecision=1.0;
  po.liftUnit=0.0;
  po.weightLiftUnit=0.0;
  FPRList.add(po);
  catchRateList.add(po);
  gainList.add(po);
  FPRWeightList.add(po);
  catchRateWeightList.add(po);
  gainWeightList.add(po);
  for (  Scanner scanner : scanners) {
    while (scanner.hasNext()) {
      if ((++cnt) % 100000 == 0) {
        log.info(""String_Node_Str"" + cnt + ""String_Node_Str"");
      }
      String[] raw=scanner.nextLine().split(""String_Node_Str"");
      if ((!isDir) && cnt == 1) {
        continue;
      }
      String tag=raw[targetColumnIndex];
      if (StringUtils.isBlank(tag) || (!posTags.contains(tag) && !negTags.contains(tag))) {
        if (rd.nextDouble() < 0.01) {
          log.warn(""String_Node_Str"",tag);
        }
        continue;
      }
      double weight=1.0d;
      if (this.weightColumnIndex > 0) {
        try {
          weight=Double.parseDouble(raw[1]);
        }
 catch (        NumberFormatException e) {
        }
      }
      double score=0.0;
      try {
        score=Double.parseDouble(raw[scoreColumnIndex]);
      }
 catch (      NumberFormatException e) {
        if (rd.nextDouble() < 0.05) {
          log.warn(""String_Node_Str"",raw[scoreColumnIndex]);
        }
        continue;
      }
      ConfusionMatrixObject cmo=new ConfusionMatrixObject(prevCmo);
      if (posTags.contains(tag)) {
        cmo.setTp(cmo.getTp() + 1);
        cmo.setFn(cmo.getFn() - 1);
        cmo.setWeightedTp(cmo.getWeightedTp() + weight * 1.0);
        cmo.setWeightedFn(cmo.getWeightedFn() - weight * 1.0);
      }
 else {
        cmo.setFp(cmo.getFp() + 1);
        cmo.setTn(cmo.getTn() - 1);
        cmo.setWeightedFp(cmo.getWeightedFp() + weight * 1.0);
        cmo.setWeightedTn(cmo.getWeightedTn() - weight * 1.0);
      }
      cmo.setScore(score);
      ConfusionMatrixObject object=cmo;
      po=PerformanceEvaluator.setPerformanceObject(object);
      if (po.fpr >= fpBin * binCapacity) {
        po.binNum=fpBin++;
        FPRList.add(po);
      }
      if (po.recall >= tpBin * binCapacity) {
        po.binNum=tpBin++;
        catchRateList.add(po);
      }
      if ((double)(i + 1) / records >= gainBin * binCapacity) {
        po.binNum=gainBin++;
        gainList.add(po);
      }
      if (po.weightedFpr >= fpWeightBin * binCapacity) {
        po.binNum=fpWeightBin++;
        FPRWeightList.add(po);
      }
      if (po.weightedRecall >= tpWeightBin * binCapacity) {
        po.binNum=tpWeightBin++;
        catchRateWeightList.add(po);
      }
      if ((object.getWeightedTp() + object.getWeightedFp() + 1) / object.getWeightedTotal() >= gainWeightBin * binCapacity) {
        po.binNum=gainWeightBin++;
        gainWeightList.add(po);
      }
      i++;
      prevCmo=cmo;
    }
    scanner.close();
  }
  log.info(""String_Node_Str"" + cnt + ""String_Node_Str"");
  PerformanceEvaluator.logResult(FPRList,""String_Node_Str"");
  if (isWeight) {
    PerformanceEvaluator.logResult(FPRWeightList,""String_Node_Str"");
  }
  PerformanceEvaluator.logResult(catchRateList,""String_Node_Str"");
  if (isWeight) {
    PerformanceEvaluator.logResult(catchRateWeightList,""String_Node_Str"");
  }
  PerformanceEvaluator.logResult(gainList,""String_Node_Str"");
  if (isWeight) {
    PerformanceEvaluator.logResult(gainWeightList,""String_Node_Str"");
  }
  PerformanceResult result=new PerformanceResult();
  result.version=Constants.version;
  result.pr=catchRateList;
  result.weightedPr=catchRateWeightList;
  result.roc=FPRList;
  result.weightedRoc=FPRWeightList;
  result.gains=gainList;
  result.weightedGains=gainWeightList;
  result.areaUnderRoc=AreaUnderCurve.ofRoc(result.roc);
  result.weightedAreaUnderRoc=AreaUnderCurve.ofWeightedRoc(result.weightedRoc);
  result.areaUnderPr=AreaUnderCurve.ofPr(result.pr);
  result.weightedAreaUnderPr=AreaUnderCurve.ofWeightedPr(result.weightedPr);
  PerformanceEvaluator.logAucResult(result,isWeight);
  Writer writer=null;
  try {
    writer=ShifuFileUtils.getWriter(pathFinder.getEvalPerformancePath(evalConfig,evalConfig.getDataSet().getSource()),evalConfig.getDataSet().getSource());
    JSONUtils.writeValue(writer,result);
  }
 catch (  IOException e) {
    IOUtils.closeQuietly(writer);
  }
  if (cnt == 0) {
    log.error(""String_Node_Str"");
    throw new ShifuException(ShifuErrorCode.ERROR_EVALSCORE);
  }
}","public void bufferedComputeConfusionMatrixAndPerformance(long pigPosTags,long pigNegTags,double pigPosWeightTags,double pigNegWeightTags,long records) throws IOException {
  PathFinder pathFinder=new PathFinder(modelConfig);
  SourceType sourceType=evalConfig.getDataSet().getSource();
  List<Scanner> scanners=ShifuFileUtils.getDataScanners(pathFinder.getEvalScorePath(evalConfig,sourceType),sourceType);
  int numBucket=evalConfig.getPerformanceBucketNum();
  boolean isWeight=evalConfig.getDataSet().getWeightColumnName() != null;
  boolean isDir=ShifuFileUtils.isDir(pathFinder.getEvalScorePath(evalConfig,sourceType),sourceType);
  List<PerformanceObject> FPRList=new ArrayList<PerformanceObject>(numBucket + 1);
  List<PerformanceObject> catchRateList=new ArrayList<PerformanceObject>(numBucket + 1);
  List<PerformanceObject> gainList=new ArrayList<PerformanceObject>(numBucket + 1);
  List<PerformanceObject> FPRWeightList=new ArrayList<PerformanceObject>(numBucket + 1);
  List<PerformanceObject> catchRateWeightList=new ArrayList<PerformanceObject>(numBucket + 1);
  List<PerformanceObject> gainWeightList=new ArrayList<PerformanceObject>(numBucket + 1);
  int fpBin=1, tpBin=1, gainBin=1, fpWeightBin=1, tpWeightBin=1, gainWeightBin=1;
  double binCapacity=1.0 / numBucket;
  PerformanceObject po=null;
  int i=0;
  log.info(""String_Node_Str"",scanners.size());
  int cnt=0;
  Set<String> posTags=new HashSet<String>(modelConfig.getPosTags(evalConfig));
  Set<String> negTags=new HashSet<String>(modelConfig.getNegTags(evalConfig));
  ConfusionMatrixObject prevCmo=new ConfusionMatrixObject();
  prevCmo.setTp(0.0);
  prevCmo.setFp(0.0);
  prevCmo.setFn(pigPosTags);
  prevCmo.setTn(pigNegTags);
  prevCmo.setWeightedTp(0.0);
  prevCmo.setWeightedFp(0.0);
  prevCmo.setWeightedFn(pigPosWeightTags);
  prevCmo.setWeightedTn(pigNegWeightTags);
  prevCmo.setScore(1000);
  po=PerformanceEvaluator.setPerformanceObject(prevCmo);
  po.precision=1.0;
  po.weightedPrecision=1.0;
  po.liftUnit=0.0;
  po.weightLiftUnit=0.0;
  FPRList.add(po);
  catchRateList.add(po);
  gainList.add(po);
  FPRWeightList.add(po);
  catchRateWeightList.add(po);
  gainWeightList.add(po);
  for (  Scanner scanner : scanners) {
    while (scanner.hasNext()) {
      if ((++cnt) % 100000 == 0) {
        log.info(""String_Node_Str"" + cnt + ""String_Node_Str"");
      }
      String[] raw=scanner.nextLine().split(""String_Node_Str"");
      if ((!isDir) && cnt == 1) {
        continue;
      }
      String tag=raw[targetColumnIndex];
      if (StringUtils.isBlank(tag) || (!posTags.contains(tag) && !negTags.contains(tag))) {
        if (rd.nextDouble() < 0.01) {
          log.warn(""String_Node_Str"",tag);
        }
        continue;
      }
      double weight=1.0d;
      if (this.weightColumnIndex > 0) {
        try {
          weight=Double.parseDouble(raw[1]);
        }
 catch (        NumberFormatException e) {
        }
      }
      double score=0.0;
      try {
        score=Double.parseDouble(raw[scoreColumnIndex]);
      }
 catch (      NumberFormatException e) {
        if (rd.nextDouble() < 0.05) {
          log.warn(""String_Node_Str"",raw[scoreColumnIndex]);
        }
        continue;
      }
      if (cnt == 1 && CommonConstants.GBDT_ALG_NAME.equalsIgnoreCase(modelConfig.getAlgorithm())) {
        po.binLowestScore=score;
      }
      ConfusionMatrixObject cmo=new ConfusionMatrixObject(prevCmo);
      if (posTags.contains(tag)) {
        cmo.setTp(cmo.getTp() + 1);
        cmo.setFn(cmo.getFn() - 1);
        cmo.setWeightedTp(cmo.getWeightedTp() + weight * 1.0);
        cmo.setWeightedFn(cmo.getWeightedFn() - weight * 1.0);
      }
 else {
        cmo.setFp(cmo.getFp() + 1);
        cmo.setTn(cmo.getTn() - 1);
        cmo.setWeightedFp(cmo.getWeightedFp() + weight * 1.0);
        cmo.setWeightedTn(cmo.getWeightedTn() - weight * 1.0);
      }
      cmo.setScore(score);
      ConfusionMatrixObject object=cmo;
      po=PerformanceEvaluator.setPerformanceObject(object);
      if (po.fpr >= fpBin * binCapacity) {
        po.binNum=fpBin++;
        FPRList.add(po);
      }
      if (po.recall >= tpBin * binCapacity) {
        po.binNum=tpBin++;
        catchRateList.add(po);
      }
      if ((double)(i + 1) / records >= gainBin * binCapacity) {
        po.binNum=gainBin++;
        gainList.add(po);
      }
      if (po.weightedFpr >= fpWeightBin * binCapacity) {
        po.binNum=fpWeightBin++;
        FPRWeightList.add(po);
      }
      if (po.weightedRecall >= tpWeightBin * binCapacity) {
        po.binNum=tpWeightBin++;
        catchRateWeightList.add(po);
      }
      if ((object.getWeightedTp() + object.getWeightedFp() + 1) / object.getWeightedTotal() >= gainWeightBin * binCapacity) {
        po.binNum=gainWeightBin++;
        gainWeightList.add(po);
      }
      i++;
      prevCmo=cmo;
    }
    scanner.close();
  }
  log.info(""String_Node_Str"" + cnt + ""String_Node_Str"");
  PerformanceEvaluator.logResult(FPRList,""String_Node_Str"");
  if (isWeight) {
    PerformanceEvaluator.logResult(FPRWeightList,""String_Node_Str"");
  }
  PerformanceEvaluator.logResult(catchRateList,""String_Node_Str"");
  if (isWeight) {
    PerformanceEvaluator.logResult(catchRateWeightList,""String_Node_Str"");
  }
  PerformanceEvaluator.logResult(gainList,""String_Node_Str"");
  if (isWeight) {
    PerformanceEvaluator.logResult(gainWeightList,""String_Node_Str"");
  }
  PerformanceResult result=new PerformanceResult();
  result.version=Constants.version;
  result.pr=catchRateList;
  result.weightedPr=catchRateWeightList;
  result.roc=FPRList;
  result.weightedRoc=FPRWeightList;
  result.gains=gainList;
  result.weightedGains=gainWeightList;
  result.areaUnderRoc=AreaUnderCurve.ofRoc(result.roc);
  result.weightedAreaUnderRoc=AreaUnderCurve.ofWeightedRoc(result.weightedRoc);
  result.areaUnderPr=AreaUnderCurve.ofPr(result.pr);
  result.weightedAreaUnderPr=AreaUnderCurve.ofWeightedPr(result.weightedPr);
  PerformanceEvaluator.logAucResult(result,isWeight);
  Writer writer=null;
  try {
    writer=ShifuFileUtils.getWriter(pathFinder.getEvalPerformancePath(evalConfig,evalConfig.getDataSet().getSource()),evalConfig.getDataSet().getSource());
    JSONUtils.writeValue(writer,result);
  }
 catch (  IOException e) {
    IOUtils.closeQuietly(writer);
  }
  if (cnt == 0) {
    log.error(""String_Node_Str"");
    throw new ShifuException(ShifuErrorCode.ERROR_EVALSCORE);
  }
}",0.988859919412183
32036,"@Override public final MLData compute(final MLData input){
  double[] data=input.getData();
  double predictSum=0d;
  double weightSum=0d;
  for (int i=0; i < this.trees.size(); i++) {
    TreeNode treeNode=this.trees.get(i);
    Double weight=this.weights.get(i);
    weightSum+=weight;
    predictSum+=predictNode(treeNode.getNode(),data) * weight;
  }
  double finalPredict=predictSum / weightSum;
  MLData result=new BasicMLData(1);
  result.setData(0,finalPredict);
  return result;
}","@Override public final MLData compute(final MLData input){
  double[] data=input.getData();
  double predictSum=0d;
  double weightSum=0d;
  for (int i=0; i < this.trees.size(); i++) {
    TreeNode treeNode=this.trees.get(i);
    Double weight=this.weights.get(i);
    weightSum+=weight;
    predictSum+=predictNode(treeNode.getNode(),data) * weight;
  }
  double finalPredict;
  if (this.isGBDT) {
    finalPredict=predictSum;
  }
 else {
    finalPredict=predictSum / weightSum;
  }
  MLData result=new BasicMLData(1);
  result.setData(0,finalPredict);
  return result;
}",0.9209039548022598
32037,"@Override public void load(GuaguaWritableAdapter<LongWritable> currentKey,GuaguaWritableAdapter<Text> currentValue,WorkerContext<DTMasterParams,DTWorkerParams> context){
  this.count+=1;
  if ((this.count) % 100000 == 0) {
    LOG.info(""String_Node_Str"",this.count);
  }
  float[] numericInputs=new float[this.numericInputCount];
  String[] categoricalInputs=new String[this.categoricalInputCount];
  float ideal=0f;
  float significance=1f;
  int index=0, numericInputsIndex=0, categoricalInputsIndex=0;
  for (  String input : DEFAULT_SPLITTER.split(currentValue.getWritable().toString())) {
    float floatValue=NumberFormatUtils.getFloat(input,0f);
    if (Float.isNaN(floatValue) || Double.isNaN(floatValue)) {
      floatValue=0f;
    }
    if (index == this.columnConfigList.size()) {
      significance=NumberFormatUtils.getFloat(input,1f);
      break;
    }
 else {
      ColumnConfig columnConfig=this.columnConfigList.get(index);
      if (columnConfig != null && columnConfig.isTarget()) {
        ideal=floatValue;
      }
 else {
        if (!isAfterVarSelect) {
          if (!columnConfig.isMeta() && !columnConfig.isTarget() && CommonUtils.isGoodCandidate(columnConfig)) {
            if (columnConfig.isNumerical()) {
              numericInputs[numericInputsIndex]=floatValue;
              this.numericInputIndexMap.put(columnConfig.getColumnNum(),numericInputsIndex);
              numericInputsIndex+=1;
            }
 else             if (columnConfig.isCategorical()) {
              if (input == null) {
                categoricalInputs[categoricalInputsIndex]=""String_Node_Str"";
              }
 else {
                categoricalInputs[categoricalInputsIndex]=input;
              }
              this.categoricalInputIndexMap.put(columnConfig.getColumnNum(),categoricalInputsIndex);
              categoricalInputsIndex+=1;
            }
          }
        }
 else {
          if (columnConfig != null && !columnConfig.isMeta() && !columnConfig.isTarget() && columnConfig.isFinalSelect()) {
            if (columnConfig.isNumerical()) {
              numericInputs[numericInputsIndex]=floatValue;
              this.numericInputIndexMap.put(columnConfig.getColumnNum(),numericInputsIndex);
              numericInputsIndex+=1;
            }
 else             if (columnConfig.isCategorical()) {
              if (input == null) {
                categoricalInputs[categoricalInputsIndex]=""String_Node_Str"";
              }
 else {
                categoricalInputs[categoricalInputsIndex]=input;
              }
              this.categoricalInputIndexMap.put(columnConfig.getColumnNum(),categoricalInputsIndex);
              categoricalInputsIndex+=1;
            }
          }
        }
      }
    }
    index+=1;
  }
  float[] sampleWeights;
  if (this.treeNum == 1 || this.isGBDT) {
    sampleWeights=new float[this.treeNum];
    if (random.nextDouble() <= modelConfig.getTrain().getBaggingSampleRate()) {
      sampleWeights[0]=1f;
    }
 else {
      sampleWeights[0]=0f;
    }
    for (int i=1; i < sampleWeights.length; i++) {
      sampleWeights[i]=1f;
    }
  }
 else {
    sampleWeights=new float[this.treeNum];
    for (int i=0; i < sampleWeights.length; i++) {
      sampleWeights[i]=this.rng[i].sample();
    }
  }
  float output=ideal;
  float predict=ideal;
  Data data=new Data(numericInputs,categoricalInputs,predict,output,output,significance,sampleWeights);
  boolean isNeedFailOver=!context.isFirstIteration();
  if (isNeedFailOver && this.isGBDT) {
    DTMasterParams lastMasterResult=context.getLastMasterResult();
    if (lastMasterResult != null) {
      List<TreeNode> trees=lastMasterResult.getTrees();
      if (trees.size() > 1) {
        for (int i=0; i < trees.size() - 1; i++) {
          TreeNode currTree=trees.get(i);
          if (i == 0) {
            double oldPredict=predictNodeIndex(currTree.getNode(),data).getPredict().getPredict();
            predict=(float)oldPredict;
            output=-loss.computeGradient(predict,data.label);
          }
 else {
            double oldPredict=predictNodeIndex(currTree.getNode(),data).getPredict().getPredict();
            predict+=(float)(this.learningRate * oldPredict);
            output=-loss.computeGradient(predict,data.label);
          }
        }
        data.output=output;
        data.predict=predict;
      }
    }
  }
  this.trainingData.append(data);
}","@Override public void load(GuaguaWritableAdapter<LongWritable> currentKey,GuaguaWritableAdapter<Text> currentValue,WorkerContext<DTMasterParams,DTWorkerParams> context){
  this.count+=1;
  if ((this.count) % 100000 == 0) {
    LOG.info(""String_Node_Str"",this.count);
  }
  float[] numericInputs=new float[this.numericInputCount];
  String[] categoricalInputs=new String[this.categoricalInputCount];
  float ideal=0f;
  float significance=1f;
  int index=0, numericInputsIndex=0, categoricalInputsIndex=0;
  for (  String input : DEFAULT_SPLITTER.split(currentValue.getWritable().toString())) {
    float floatValue=NumberFormatUtils.getFloat(input,0f);
    if (Float.isNaN(floatValue) || Double.isNaN(floatValue)) {
      floatValue=0f;
    }
    if (index == this.columnConfigList.size()) {
      significance=NumberFormatUtils.getFloat(input,1f);
      break;
    }
 else {
      ColumnConfig columnConfig=this.columnConfigList.get(index);
      if (columnConfig != null && columnConfig.isTarget()) {
        ideal=floatValue;
      }
 else {
        if (!isAfterVarSelect) {
          if (!columnConfig.isMeta() && !columnConfig.isTarget() && CommonUtils.isGoodCandidate(columnConfig)) {
            if (columnConfig.isNumerical()) {
              numericInputs[numericInputsIndex]=floatValue;
              this.numericInputIndexMap.put(columnConfig.getColumnNum(),numericInputsIndex);
              numericInputsIndex+=1;
            }
 else             if (columnConfig.isCategorical()) {
              if (input == null) {
                categoricalInputs[categoricalInputsIndex]=""String_Node_Str"";
              }
 else {
                categoricalInputs[categoricalInputsIndex]=input;
              }
              this.categoricalInputIndexMap.put(columnConfig.getColumnNum(),categoricalInputsIndex);
              categoricalInputsIndex+=1;
            }
          }
        }
 else {
          if (columnConfig != null && !columnConfig.isMeta() && !columnConfig.isTarget() && columnConfig.isFinalSelect()) {
            if (columnConfig.isNumerical()) {
              numericInputs[numericInputsIndex]=floatValue;
              this.numericInputIndexMap.put(columnConfig.getColumnNum(),numericInputsIndex);
              numericInputsIndex+=1;
            }
 else             if (columnConfig.isCategorical()) {
              if (input == null) {
                categoricalInputs[categoricalInputsIndex]=""String_Node_Str"";
              }
 else {
                categoricalInputs[categoricalInputsIndex]=input;
              }
              this.categoricalInputIndexMap.put(columnConfig.getColumnNum(),categoricalInputsIndex);
              categoricalInputsIndex+=1;
            }
          }
        }
      }
    }
    index+=1;
  }
  float[] sampleWeights;
  if (this.treeNum == 1 || this.isGBDT) {
    sampleWeights=new float[this.treeNum];
    if (random.nextDouble() <= modelConfig.getTrain().getBaggingSampleRate()) {
      sampleWeights[0]=1f;
    }
 else {
      sampleWeights[0]=0f;
    }
    for (int i=1; i < sampleWeights.length; i++) {
      sampleWeights[i]=1f;
    }
  }
 else {
    sampleWeights=new float[this.treeNum];
    for (int i=0; i < sampleWeights.length; i++) {
      sampleWeights[i]=this.rng[i].sample();
    }
  }
  float output=ideal;
  float predict=ideal;
  Data data=new Data(numericInputs,categoricalInputs,predict,output,output,significance,sampleWeights);
  boolean isNeedFailOver=!context.isFirstIteration();
  if (isNeedFailOver && this.isGBDT) {
    DTMasterParams lastMasterResult=context.getLastMasterResult();
    if (lastMasterResult != null) {
      List<TreeNode> trees=lastMasterResult.getTrees();
      if (trees.size() > 1) {
        int iterLen=lastMasterResult.isSwitchToNextTree() ? trees.size() - 2 : trees.size() - 1;
        for (int i=0; i < iterLen; i++) {
          TreeNode currTree=trees.get(i);
          if (i == 0) {
            double oldPredict=predictNodeIndex(currTree.getNode(),data).getPredict().getPredict();
            predict=(float)oldPredict;
            output=-1f * loss.computeGradient(predict,data.label);
          }
 else {
            double oldPredict=predictNodeIndex(currTree.getNode(),data).getPredict().getPredict();
            predict+=(float)(this.learningRate * oldPredict);
            output=-1f * loss.computeGradient(predict,data.label);
          }
        }
        data.output=output;
        data.predict=predict;
      }
    }
  }
  this.trainingData.append(data);
}",0.9853438556933484
32038,"private NeuralInputs getNeuralInputs(final NeuralNetwork model){
  NeuralInputs nnInputs=new NeuralInputs();
  HashMap<FieldName,FieldName> miningTransformMap=new HashMap<FieldName,FieldName>();
  for (  DerivedField dField : model.getLocalTransformations().getDerivedFields()) {
    if (dField.getExpression() instanceof NormContinuous) {
      miningTransformMap.put(((NormContinuous)dField.getExpression()).getField(),dField.getName());
    }
 else     if (dField.getExpression() instanceof MapValues) {
      miningTransformMap.put(((MapValues)dField.getExpression()).getFieldColumnPairs().get(0).getField(),dField.getName());
    }
 else     if (dField.getExpression() instanceof Discretize) {
      miningTransformMap.put(((Discretize)dField.getExpression()).getField(),dField.getName());
    }
  }
  List<MiningField> miningList=model.getMiningSchema().getMiningFields();
  int index=0;
  for (int i=0; i < miningList.size(); i++) {
    MiningField mField=miningList.get(i);
    if (mField.getUsageType() != FieldUsageType.ACTIVE)     continue;
    FieldName mFieldName=mField.getName();
    FieldName fName=(miningTransformMap.containsKey(mFieldName)) ? miningTransformMap.get(mFieldName) : mFieldName;
    DerivedField field=new DerivedField(OpType.CONTINUOUS,DataType.DOUBLE).withName(fName).withExpression(new FieldRef(fName));
    nnInputs.withNeuralInputs(new NeuralInput(field,""String_Node_Str"" + (index++)));
  }
  DerivedField field=new DerivedField(OpType.CONTINUOUS,DataType.DOUBLE).withName(new FieldName(PluginConstants.biasValue)).withExpression(new FieldRef(new FieldName(PluginConstants.biasValue)));
  nnInputs.withNeuralInputs(new NeuralInput(field,PluginConstants.biasValue));
  return nnInputs;
}","private NeuralInputs getNeuralInputs(final NeuralNetwork model){
  NeuralInputs nnInputs=new NeuralInputs();
  HashMap<FieldName,FieldName> miningTransformMap=new HashMap<FieldName,FieldName>();
  for (  DerivedField dField : model.getLocalTransformations().getDerivedFields()) {
    if (dField.getExpression() instanceof NormContinuous) {
      miningTransformMap.put(((NormContinuous)dField.getExpression()).getField(),dField.getName());
    }
 else     if (dField.getExpression() instanceof MapValues) {
      miningTransformMap.put(((MapValues)dField.getExpression()).getFieldColumnPairs().get(0).getField(),dField.getName());
    }
 else     if (dField.getExpression() instanceof Discretize) {
      miningTransformMap.put(((Discretize)dField.getExpression()).getField(),dField.getName());
    }
  }
  List<MiningField> miningList=model.getMiningSchema().getMiningFields();
  int index=0;
  for (int i=0; i < miningList.size(); i++) {
    MiningField mField=miningList.get(i);
    if (mField.getUsageType() != FieldUsageType.ACTIVE)     continue;
    FieldName mFieldName=mField.getName();
    FieldName fName=mFieldName;
    while (miningTransformMap.containsKey(fName)) {
      fName=miningTransformMap.get(fName);
    }
    DerivedField field=new DerivedField(OpType.CONTINUOUS,DataType.DOUBLE).withName(fName).withExpression(new FieldRef(fName));
    nnInputs.withNeuralInputs(new NeuralInput(field,""String_Node_Str"" + (index++)));
  }
  DerivedField field=new DerivedField(OpType.CONTINUOUS,DataType.DOUBLE).withName(new FieldName(PluginConstants.biasValue)).withExpression(new FieldRef(new FieldName(PluginConstants.biasValue)));
  nnInputs.withNeuralInputs(new NeuralInput(field,PluginConstants.biasValue));
  return nnInputs;
}",0.971989604389258
32039,"/** 
 * Create @DerivedField for numerical variable
 * @param config - ColumnConfig for numerical variable
 * @param cutoff - cutoff of normalization
 * @return DerivedField for variable
 */
protected List<DerivedField> createNumericalDerivedField(ColumnConfig config,double cutoff){
  ModelNormalizeConf.NormType normType=this.modelConfig.getNormalizeType();
  List<Double> binWoeList=(normType.equals(ModelNormalizeConf.NormType.WOE) ? config.getBinCountWoe() : config.getBinWeightedWoe());
  List<Double> binBoundaryList=config.getBinBoundary();
  List<DiscretizeBin> discretizeBinList=new ArrayList<DiscretizeBin>();
  for (int i=0; i < binBoundaryList.size(); i++) {
    DiscretizeBin discretizeBin=new DiscretizeBin();
    Interval interval=new Interval();
    if (i == 0) {
      interval.withClosure(Interval.Closure.OPEN_OPEN).withRightMargin(binBoundaryList.get(i + 1));
    }
 else     if (i == binBoundaryList.size() - 1) {
      interval.withClosure(Interval.Closure.CLOSED_OPEN).withLeftMargin(binBoundaryList.get(i));
    }
 else {
      interval.withClosure(Interval.Closure.CLOSED_OPEN).withLeftMargin(binBoundaryList.get(i)).withRightMargin(binBoundaryList.get(i + 1));
    }
    discretizeBin.withInterval(interval).withBinValue(Double.toString(binWoeList.get(i)));
    discretizeBinList.add(discretizeBin);
  }
  Discretize discretize=new Discretize();
  discretize.withDataType(DataType.DOUBLE).withField(FieldName.create(config.getColumnName())).withMapMissingTo(Normalizer.normalize(config,null,cutoff,this.modelConfig.getNormalizeType()).toString()).withDefaultValue(Normalizer.normalize(config,null,cutoff,this.modelConfig.getNormalizeType()).toString()).withDiscretizeBins(discretizeBinList);
  List<DerivedField> derivedFields=new ArrayList<DerivedField>();
  derivedFields.add(new DerivedField(OpType.CONTINUOUS,DataType.DOUBLE).withName(FieldName.create(genPmmlColumnName(config.getColumnName()))).withExpression(discretize));
  return derivedFields;
}","/** 
 * Create @DerivedField for numerical variable
 * @param config - ColumnConfig for numerical variable
 * @param cutoff - cutoff of normalization
 * @param normType - the normalization method that is used to generate DerivedField
 * @return DerivedField for variable
 */
@Override protected List<DerivedField> createNumericalDerivedField(ColumnConfig config,double cutoff,ModelNormalizeConf.NormType normType){
  List<Double> binWoeList=(normType.equals(ModelNormalizeConf.NormType.WOE) ? config.getBinCountWoe() : config.getBinWeightedWoe());
  List<Double> binBoundaryList=config.getBinBoundary();
  List<DiscretizeBin> discretizeBinList=new ArrayList<DiscretizeBin>();
  for (int i=0; i < binBoundaryList.size(); i++) {
    DiscretizeBin discretizeBin=new DiscretizeBin();
    Interval interval=new Interval();
    if (i == 0) {
      if (binBoundaryList.size() == 1) {
        interval.withClosure(Interval.Closure.OPEN_OPEN).withLeftMargin(Double.NEGATIVE_INFINITY).withRightMargin(Double.POSITIVE_INFINITY);
      }
 else {
        interval.withClosure(Interval.Closure.OPEN_OPEN).withRightMargin(binBoundaryList.get(i + 1));
      }
    }
 else     if (i == binBoundaryList.size() - 1) {
      interval.withClosure(Interval.Closure.CLOSED_OPEN).withLeftMargin(binBoundaryList.get(i));
    }
 else {
      interval.withClosure(Interval.Closure.CLOSED_OPEN).withLeftMargin(binBoundaryList.get(i)).withRightMargin(binBoundaryList.get(i + 1));
    }
    discretizeBin.withInterval(interval).withBinValue(Double.toString(binWoeList.get(i)));
    discretizeBinList.add(discretizeBin);
  }
  Discretize discretize=new Discretize();
  discretize.withDataType(DataType.DOUBLE).withField(FieldName.create(config.getColumnName())).withMapMissingTo(Normalizer.normalize(config,null,cutoff,normType).toString()).withDefaultValue(Normalizer.normalize(config,null,cutoff,normType).toString()).withDiscretizeBins(discretizeBinList);
  List<DerivedField> derivedFields=new ArrayList<DerivedField>();
  derivedFields.add(new DerivedField(OpType.CONTINUOUS,DataType.DOUBLE).withName(FieldName.create(genPmmlColumnName(config.getColumnName(),normType))).withExpression(discretize));
  return derivedFields;
}",0.816267942583732
32040,"/** 
 * Create @DerivedField for numerical variable
 * @param config - ColumnConfig for numerical variable
 * @param cutoff - cutoff of normalization
 * @return DerivedField for variable
 */
protected List<DerivedField> createNumericalDerivedField(ColumnConfig config,double cutoff){
  List<DerivedField> derivedFields=new ArrayList<DerivedField>();
  DerivedField derivedField=super.createNumericalDerivedField(config,cutoff).get(0);
  derivedFields.add(derivedField);
  double[] meanAndStdDev=Normalizer.calculateWoeMeanAndStdDev(config,isWeightedNorm);
  LinearNorm from=new LinearNorm().withOrig(meanAndStdDev[0] - meanAndStdDev[1] * cutoff).withNorm(-cutoff);
  LinearNorm to=new LinearNorm().withOrig(meanAndStdDev[0] + meanAndStdDev[1] * cutoff).withNorm(cutoff);
  NormContinuous normContinuous=new NormContinuous(FieldName.create(derivedField.getName().getValue())).withLinearNorms(from,to).withMapMissingTo(0.0).withOutliers(OutlierTreatmentMethodType.AS_EXTREME_VALUES);
  derivedFields.add(new DerivedField(OpType.CONTINUOUS,DataType.DOUBLE).withName(FieldName.create(genPmmlColumnName(config.getColumnName()))).withExpression(normContinuous));
  return derivedFields;
}","/** 
 * Create @DerivedField for numerical variable
 * @param config - ColumnConfig for numerical variable
 * @param cutoff - cutoff of normalization
 * @return DerivedField for variable
 */
@Override protected List<DerivedField> createNumericalDerivedField(ColumnConfig config,double cutoff,ModelNormalizeConf.NormType normType){
  List<DerivedField> derivedFields=new ArrayList<DerivedField>();
  DerivedField derivedField=super.createNumericalDerivedField(config,cutoff,ModelNormalizeConf.NormType.WOE).get(0);
  derivedFields.add(derivedField);
  double[] meanAndStdDev=Normalizer.calculateWoeMeanAndStdDev(config,isWeightedNorm);
  LinearNorm from=new LinearNorm().withOrig(meanAndStdDev[0] - meanAndStdDev[1] * cutoff).withNorm(-cutoff);
  LinearNorm to=new LinearNorm().withOrig(meanAndStdDev[0] + meanAndStdDev[1] * cutoff).withNorm(cutoff);
  NormContinuous normContinuous=new NormContinuous(FieldName.create(derivedField.getName().getValue())).withLinearNorms(from,to).withMapMissingTo(0.0).withOutliers(OutlierTreatmentMethodType.AS_EXTREME_VALUES);
  derivedFields.add(new DerivedField(OpType.CONTINUOUS,DataType.DOUBLE).withName(FieldName.create(genPmmlColumnName(config.getColumnName(),normType))).withExpression(normContinuous));
  return derivedFields;
}",0.964110929853181
32041,"/** 
 * Create @DerivedField for categorical variable
 * @param config - ColumnConfig for categorical variable
 * @param cutoff - cutoff for normalization
 * @return DerivedField for variable
 */
protected List<DerivedField> createCategoricalDerivedField(ColumnConfig config,double cutoff){
  Document document=null;
  try {
    document=DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();
  }
 catch (  ParserConfigurationException e) {
    LOG.error(""String_Node_Str"",e);
    throw new RuntimeException(""String_Node_Str"",e);
  }
  String defaultValue=Normalizer.normalize(config,""String_Node_Str"",cutoff,this.modelConfig.getNormalizeType()).toString();
  String missingValue=Normalizer.normalize(config,null,cutoff,this.modelConfig.getNormalizeType()).toString();
  InlineTable inlineTable=new InlineTable();
  for (int i=0; i < config.getBinCategory().size(); i++) {
    String cval=config.getBinCategory().get(i);
    String dval=Normalizer.normalize(config,cval,cutoff,this.modelConfig.getNormalizeType()).toString();
    Element out=document.createElementNS(NAME_SPACE_URI,ELEMENT_OUT);
    out.setTextContent(dval);
    Element origin=document.createElementNS(NAME_SPACE_URI,ELEMENT_ORIGIN);
    origin.setTextContent(cval);
    inlineTable.withRows(new Row().withContent(origin).withContent(out));
  }
  MapValues mapValues=new MapValues(""String_Node_Str"").withDataType(DataType.DOUBLE).withDefaultValue(defaultValue).withFieldColumnPairs(new FieldColumnPair(new FieldName(config.getColumnName()),ELEMENT_ORIGIN)).withInlineTable(inlineTable).withMapMissingTo(missingValue);
  List<DerivedField> derivedFields=new ArrayList<DerivedField>();
  derivedFields.add(new DerivedField(OpType.CONTINUOUS,DataType.DOUBLE).withName(FieldName.create(genPmmlColumnName(config.getColumnName()))).withExpression(mapValues));
  return derivedFields;
}","/** 
 * Create @DerivedField for categorical variable
 * @param config - ColumnConfig for categorical variable
 * @param cutoff - cutoff for normalization
 * @param normType - the normalization method that is used to generate DerivedField
 * @return DerivedField for variable
 */
protected List<DerivedField> createCategoricalDerivedField(ColumnConfig config,double cutoff,ModelNormalizeConf.NormType normType){
  Document document=null;
  try {
    document=DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();
  }
 catch (  ParserConfigurationException e) {
    LOG.error(""String_Node_Str"",e);
    throw new RuntimeException(""String_Node_Str"",e);
  }
  String defaultValue=Normalizer.normalize(config,""String_Node_Str"",cutoff,normType).toString();
  String missingValue=Normalizer.normalize(config,null,cutoff,normType).toString();
  InlineTable inlineTable=new InlineTable();
  for (int i=0; i < config.getBinCategory().size(); i++) {
    String cval=config.getBinCategory().get(i);
    String dval=Normalizer.normalize(config,cval,cutoff,normType).toString();
    Element out=document.createElementNS(NAME_SPACE_URI,ELEMENT_OUT);
    out.setTextContent(dval);
    Element origin=document.createElementNS(NAME_SPACE_URI,ELEMENT_ORIGIN);
    origin.setTextContent(cval);
    inlineTable.withRows(new Row().withContent(origin).withContent(out));
  }
  MapValues mapValues=new MapValues(""String_Node_Str"").withDataType(DataType.DOUBLE).withDefaultValue(defaultValue).withFieldColumnPairs(new FieldColumnPair(new FieldName(config.getColumnName()),ELEMENT_ORIGIN)).withInlineTable(inlineTable).withMapMissingTo(missingValue);
  List<DerivedField> derivedFields=new ArrayList<DerivedField>();
  derivedFields.add(new DerivedField(OpType.CONTINUOUS,DataType.DOUBLE).withName(FieldName.create(genPmmlColumnName(config.getColumnName(),normType))).withExpression(mapValues));
  return derivedFields;
}",0.9002381582429214
32042,"@Override public LocalTransformations build(){
  LocalTransformations localTransformations=new LocalTransformations();
  for (  ColumnConfig config : columnConfigList) {
    if (config.isFinalSelect()) {
      double cutoff=modelConfig.getNormalizeStdDevCutOff();
      localTransformations.withDerivedFields(config.isCategorical() ? createCategoricalDerivedField(config,cutoff) : createNumericalDerivedField(config,cutoff));
    }
  }
  return localTransformations;
}","@Override public LocalTransformations build(){
  LocalTransformations localTransformations=new LocalTransformations();
  for (  ColumnConfig config : columnConfigList) {
    if (config.isFinalSelect()) {
      double cutoff=modelConfig.getNormalizeStdDevCutOff();
      localTransformations.withDerivedFields(config.isCategorical() ? createCategoricalDerivedField(config,cutoff,modelConfig.getNormalizeType()) : createNumericalDerivedField(config,cutoff,modelConfig.getNormalizeType()));
    }
  }
  return localTransformations;
}",0.937875751503006
32043,"/** 
 * Create @DerivedField for numerical variable
 * @param config - ColumnConfig for numerical variable
 * @param cutoff - cutoff of normalization
 * @return DerivedField for variable
 */
protected List<DerivedField> createNumericalDerivedField(ColumnConfig config,double cutoff){
  LinearNorm from=new LinearNorm().withOrig(config.getMean() - config.getStdDev() * cutoff).withNorm(-cutoff);
  LinearNorm to=new LinearNorm().withOrig(config.getMean() + config.getStdDev() * cutoff).withNorm(cutoff);
  NormContinuous normContinuous=new NormContinuous(FieldName.create(config.getColumnName())).withLinearNorms(from,to).withMapMissingTo(0.0).withOutliers(OutlierTreatmentMethodType.AS_EXTREME_VALUES);
  List<DerivedField> derivedFields=new ArrayList<DerivedField>();
  derivedFields.add(new DerivedField(OpType.CONTINUOUS,DataType.DOUBLE).withName(FieldName.create(genPmmlColumnName(config.getColumnName()))).withExpression(normContinuous));
  return derivedFields;
}","/** 
 * Create @DerivedField for numerical variable
 * @param config - ColumnConfig for numerical variable
 * @param cutoff - cutoff of normalization
 * @param normType - the normalization method that is used to generate DerivedField
 * @return DerivedField for variable
 */
protected List<DerivedField> createNumericalDerivedField(ColumnConfig config,double cutoff,ModelNormalizeConf.NormType normType){
  LinearNorm from=new LinearNorm().withOrig(config.getMean() - config.getStdDev() * cutoff).withNorm(-cutoff);
  LinearNorm to=new LinearNorm().withOrig(config.getMean() + config.getStdDev() * cutoff).withNorm(cutoff);
  NormContinuous normContinuous=new NormContinuous(FieldName.create(config.getColumnName())).withLinearNorms(from,to).withMapMissingTo(0.0).withOutliers(OutlierTreatmentMethodType.AS_EXTREME_VALUES);
  List<DerivedField> derivedFields=new ArrayList<DerivedField>();
  derivedFields.add(new DerivedField(OpType.CONTINUOUS,DataType.DOUBLE).withName(FieldName.create(genPmmlColumnName(config.getColumnName(),normType))).withExpression(normContinuous));
  return derivedFields;
}",0.937137330754352
32044,"/** 
 * Convert column name into PMML format(with normalization)
 * @param columnName
 * @return - PMML standard column name
 */
protected String genPmmlColumnName(String columnName){
  return columnName + ""String_Node_Str"" + this.modelConfig.getNormalizeType().name().toLowerCase();
}","/** 
 * Convert column name into PMML format(with normalization)
 * @param columnName
 * @parm normType
 * @return - PMML standard column name
 */
protected String genPmmlColumnName(String columnName,ModelNormalizeConf.NormType normType){
  return columnName + ""String_Node_Str"" + normType.name().toLowerCase();
}",0.8327759197324415
32045,"/** 
 * Return first line split string array. This is used to detect data schema.
 */
public static String[] takeFirstLine(String dataSetRawPath,String headerDelimiter,SourceType source) throws IOException {
  if (dataSetRawPath == null || headerDelimiter == null || source == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  String firstValidFile=null;
  if (ShifuFileUtils.isDir(dataSetRawPath,source)) {
    FileSystem fs=ShifuFileUtils.getFileSystemBySourceType(source);
    FileStatus[] globStatus=fs.globStatus(new Path(dataSetRawPath),HIDDEN_FILE_FILTER);
    if (globStatus == null || globStatus.length == 0) {
      throw new IllegalArgumentException(""String_Node_Str"" + dataSetRawPath);
    }
 else {
      FileStatus[] listStatus=fs.listStatus(globStatus[0].getPath(),HIDDEN_FILE_FILTER);
      if (listStatus == null || listStatus.length == 0) {
        throw new IllegalArgumentException(""String_Node_Str"" + globStatus[0].getPath());
      }
      firstValidFile=listStatus[0].getPath().toString();
    }
  }
 else {
    firstValidFile=dataSetRawPath;
  }
  BufferedReader reader=null;
  try {
    reader=ShifuFileUtils.getReader(firstValidFile,source);
    String firstLine=reader.readLine();
    if (firstLine != null && firstLine.length() > 0) {
      List<String> list=new ArrayList<String>();
      for (      String unit : Splitter.on(headerDelimiter).split(firstLine)) {
        list.add(unit);
      }
      return list.toArray(new String[0]);
    }
  }
  finally {
    IOUtils.closeQuietly(reader);
  }
}","/** 
 * Return first line split string array. This is used to detect data schema.
 */
public static String[] takeFirstLine(String dataSetRawPath,String headerDelimiter,SourceType source) throws IOException {
  if (dataSetRawPath == null || headerDelimiter == null || source == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  String firstValidFile=null;
  if (ShifuFileUtils.isDir(dataSetRawPath,source)) {
    FileSystem fs=ShifuFileUtils.getFileSystemBySourceType(source);
    FileStatus[] globStatus=fs.globStatus(new Path(dataSetRawPath),HIDDEN_FILE_FILTER);
    if (globStatus == null || globStatus.length == 0) {
      throw new IllegalArgumentException(""String_Node_Str"" + dataSetRawPath);
    }
 else {
      FileStatus[] listStatus=fs.listStatus(globStatus[0].getPath(),HIDDEN_FILE_FILTER);
      if (listStatus == null || listStatus.length == 0) {
        throw new IllegalArgumentException(""String_Node_Str"" + globStatus[0].getPath());
      }
      firstValidFile=listStatus[0].getPath().toString();
    }
  }
 else {
    firstValidFile=dataSetRawPath;
  }
  BufferedReader reader=null;
  try {
    reader=ShifuFileUtils.getReader(firstValidFile,source);
    String firstLine=reader.readLine();
    if (firstLine != null && firstLine.length() > 0) {
      List<String> list=new ArrayList<String>();
      for (      String unit : Splitter.on(headerDelimiter).split(firstLine)) {
        list.add(unit);
      }
      return list.toArray(new String[0]);
    }
  }
  finally {
    IOUtils.closeQuietly(reader);
  }
  return new String[0];
}",0.9923175416133164
32046,"@Override public int run() throws Exception {
  int status=0;
  File pmmls=new File(""String_Node_Str"");
  FileUtils.forceMkdir(pmmls);
  if (StringUtils.isBlank(type)) {
    type=PMML;
  }
  if (type.equalsIgnoreCase(PMML)) {
    log.info(""String_Node_Str"",type);
    ModelConfig modelConfig=CommonUtils.loadModelConfig();
    List<ColumnConfig> columnConfigList=CommonUtils.loadColumnConfigList();
    PathFinder pathFinder=new PathFinder(modelConfig);
    List<BasicML> models=CommonUtils.loadBasicModels(pathFinder.getModelsPath(SourceType.LOCAL),ALGORITHM.valueOf(modelConfig.getAlgorithm().toUpperCase()));
    PMMLTranslator translator=PMMLConstructorFactory.produce(modelConfig,columnConfigList,this.isConcise);
    for (int index=0; index < models.size(); index++) {
      log.info(""String_Node_Str"" + ""String_Node_Str"" + File.separator + modelConfig.getModelSetName()+ Integer.toString(index)+ ""String_Node_Str"");
      PMML pmml=translator.build(models.get(index));
      PMMLUtils.savePMML(pmml,""String_Node_Str"" + File.separator + modelConfig.getModelSetName()+ Integer.toString(index)+ ""String_Node_Str"");
    }
  }
 else   if (type.equalsIgnoreCase(COLUMN_STATS)) {
    saveColumnStatus();
  }
 else {
    log.error(""String_Node_Str"",type);
    status=-1;
  }
  log.info(""String_Node_Str"");
  return status;
}","@Override public int run() throws Exception {
  setUp(ModelStep.EXPORT);
  int status=0;
  File pmmls=new File(""String_Node_Str"");
  FileUtils.forceMkdir(pmmls);
  if (StringUtils.isBlank(type)) {
    type=PMML;
  }
  if (type.equalsIgnoreCase(PMML)) {
    log.info(""String_Node_Str"",type);
    ModelConfig modelConfig=CommonUtils.loadModelConfig();
    List<ColumnConfig> columnConfigList=CommonUtils.loadColumnConfigList();
    PathFinder pathFinder=new PathFinder(modelConfig);
    List<BasicML> models=CommonUtils.loadBasicModels(pathFinder.getModelsPath(SourceType.LOCAL),ALGORITHM.valueOf(modelConfig.getAlgorithm().toUpperCase()));
    PMMLTranslator translator=PMMLConstructorFactory.produce(modelConfig,columnConfigList,this.isConcise);
    for (int index=0; index < models.size(); index++) {
      log.info(""String_Node_Str"" + ""String_Node_Str"" + File.separator + modelConfig.getModelSetName()+ Integer.toString(index)+ ""String_Node_Str"");
      PMML pmml=translator.build(models.get(index));
      PMMLUtils.savePMML(pmml,""String_Node_Str"" + File.separator + modelConfig.getModelSetName()+ Integer.toString(index)+ ""String_Node_Str"");
    }
  }
 else   if (type.equalsIgnoreCase(COLUMN_STATS)) {
    saveColumnStatus();
  }
 else {
    log.error(""String_Node_Str"",type);
    status=-1;
  }
  clearUp(ModelStep.EXPORT);
  log.info(""String_Node_Str"");
  return status;
}",0.9792746113989638
32047,"public ScoreObject score(MLDataPair pair,Map<String,String> rawDataMap){
  if (pair == null) {
    return null;
  }
  List<Integer> scores=new ArrayList<Integer>();
  if (modelConfig.getAlgorithm().equalsIgnoreCase(CommonConstants.GBDT_ALG_NAME)) {
    double learningRate=Double.valueOf(this.modelConfig.getParams().get(NNTrainer.LEARNING_RATE).toString());
    BasicML model=models.get(0);
    if (model instanceof TreeModel) {
      TreeModel trees=(TreeModel)model;
      if (trees.getInputCount() != pair.getInput().size()) {
        log.error(""String_Node_Str"" + trees.getInputCount() + ""String_Node_Str""+ pair.getInput().size());
      }
      List<TreeNode> treeNodes=trees.getTrees();
      String algorithm=modelConfig.getAlgorithm();
      List<Double> weights=new ArrayList<Double>(treeNodes.size());
      for (int i=0; i < treeNodes.size(); i++) {
        if (CommonConstants.RF_ALG_NAME.equalsIgnoreCase(algorithm)) {
          weights.add(1d);
        }
        if (CommonConstants.GBDT_ALG_NAME.equalsIgnoreCase(algorithm)) {
          if (i == 0) {
            weights.add(1d);
          }
 else {
            weights.add(learningRate);
          }
        }
      }
      TreeModel treeModel=new TreeModel(treeNodes,weights,CommonConstants.GBDT_ALG_NAME.equalsIgnoreCase(algorithm),columnConfigList,columnMapping);
      MLData internalScore=treeModel.compute(pair.getInput());
      scores.add(toScore(internalScore.getData(0)));
    }
  }
 else {
    for (    BasicML model : models) {
      if (model instanceof BasicNetwork) {
        BasicNetwork network=(BasicNetwork)model;
        if (network.getInputCount() != pair.getInput().size()) {
          log.error(""String_Node_Str"" + network.getInputCount() + ""String_Node_Str""+ pair.getInput().size());
          continue;
        }
        MLData score=network.compute(pair.getInput());
        if (modelConfig != null && modelConfig.isBinaryClassification()) {
          scores.add(toScore(score.getData(0)));
        }
 else {
          double[] outputs=score.getData();
          for (          double d : outputs) {
            scores.add(toScore(d));
          }
        }
      }
 else       if (model instanceof SVM) {
        SVM svm=(SVM)model;
        if (svm.getInputCount() != pair.getInput().size()) {
          log.error(""String_Node_Str"" + svm.getInputCount() + ""String_Node_Str""+ pair.getInput().size());
          continue;
        }
        MLData score=svm.compute(pair.getInput());
        scores.add(toScore(score.getData(0)));
      }
 else       if (model instanceof LR) {
        LR lr=(LR)model;
        if (lr.getInputCount() != pair.getInput().size()) {
          log.error(""String_Node_Str"" + lr.getInputCount() + ""String_Node_Str""+ pair.getInput().size());
          continue;
        }
        MLData score=lr.compute(pair.getInput());
        scores.add(toScore(score.getData(0)));
      }
 else       if (model instanceof TreeModel) {
        TreeModel rf=(TreeModel)model;
        if (rf.getInputCount() != pair.getInput().size()) {
          log.error(""String_Node_Str"" + rf.getInputCount() + ""String_Node_Str""+ pair.getInput().size());
          continue;
        }
        MLData score=rf.compute(pair.getInput());
        scores.add(toScore(score.getData(0)));
      }
 else {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
  }
  Integer tag=(int)pair.getIdeal().getData(0);
  if (scores.size() == 0) {
    log.error(""String_Node_Str"");
    return null;
  }
  return new ScoreObject(scores,tag);
}","public ScoreObject score(MLDataPair pair,Map<String,String> rawDataMap){
  if (pair == null) {
    return null;
  }
  List<Integer> scores=new ArrayList<Integer>();
  if (modelConfig != null && modelConfig.getAlgorithm().equalsIgnoreCase(CommonConstants.GBDT_ALG_NAME)) {
    double learningRate=Double.valueOf(this.modelConfig.getParams().get(NNTrainer.LEARNING_RATE).toString());
    BasicML model=models.get(0);
    if (model instanceof TreeModel) {
      TreeModel trees=(TreeModel)model;
      if (trees.getInputCount() != pair.getInput().size()) {
        log.error(""String_Node_Str"" + trees.getInputCount() + ""String_Node_Str""+ pair.getInput().size());
      }
      List<TreeNode> treeNodes=trees.getTrees();
      String algorithm=modelConfig.getAlgorithm();
      List<Double> weights=new ArrayList<Double>(treeNodes.size());
      for (int i=0; i < treeNodes.size(); i++) {
        if (CommonConstants.RF_ALG_NAME.equalsIgnoreCase(algorithm)) {
          weights.add(1d);
        }
        if (CommonConstants.GBDT_ALG_NAME.equalsIgnoreCase(algorithm)) {
          if (i == 0) {
            weights.add(1d);
          }
 else {
            weights.add(learningRate);
          }
        }
      }
      TreeModel treeModel=new TreeModel(treeNodes,weights,CommonConstants.GBDT_ALG_NAME.equalsIgnoreCase(algorithm),columnConfigList,columnMapping);
      MLData internalScore=treeModel.compute(pair.getInput());
      scores.add(toScore(internalScore.getData(0)));
    }
  }
 else {
    for (    BasicML model : models) {
      if (model instanceof BasicNetwork) {
        BasicNetwork network=(BasicNetwork)model;
        if (network.getInputCount() != pair.getInput().size()) {
          log.error(""String_Node_Str"" + network.getInputCount() + ""String_Node_Str""+ pair.getInput().size());
          continue;
        }
        MLData score=network.compute(pair.getInput());
        if (modelConfig != null && modelConfig.isBinaryClassification()) {
          scores.add(toScore(score.getData(0)));
        }
 else {
          double[] outputs=score.getData();
          for (          double d : outputs) {
            scores.add(toScore(d));
          }
        }
      }
 else       if (model instanceof SVM) {
        SVM svm=(SVM)model;
        if (svm.getInputCount() != pair.getInput().size()) {
          log.error(""String_Node_Str"" + svm.getInputCount() + ""String_Node_Str""+ pair.getInput().size());
          continue;
        }
        MLData score=svm.compute(pair.getInput());
        scores.add(toScore(score.getData(0)));
      }
 else       if (model instanceof LR) {
        LR lr=(LR)model;
        if (lr.getInputCount() != pair.getInput().size()) {
          log.error(""String_Node_Str"" + lr.getInputCount() + ""String_Node_Str""+ pair.getInput().size());
          continue;
        }
        MLData score=lr.compute(pair.getInput());
        scores.add(toScore(score.getData(0)));
      }
 else       if (model instanceof TreeModel) {
        TreeModel rf=(TreeModel)model;
        if (rf.getInputCount() != pair.getInput().size()) {
          log.error(""String_Node_Str"" + rf.getInputCount() + ""String_Node_Str""+ pair.getInput().size());
          continue;
        }
        MLData score=rf.compute(pair.getInput());
        scores.add(toScore(score.getData(0)));
      }
 else {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
  }
  Integer tag=(int)pair.getIdeal().getData(0);
  if (scores.size() == 0) {
    log.error(""String_Node_Str"");
    return null;
  }
  return new ScoreObject(scores,tag);
}",0.9967518712046322
32048,"public Scorer(List<BasicML> models,List<ColumnConfig> columnConfigList,String algorithm,ModelConfig modelConfig,Double cutoff){
  this.models=models;
  this.columnConfigList=columnConfigList;
  this.cutoff=cutoff;
  this.alg=algorithm;
  this.modelConfig=modelConfig;
  if (this.columnConfigList != null) {
    int[] inputOutputIndex=DTrainUtils.getInputOutputCandidateCounts(this.columnConfigList);
    int inputNodeCount=inputOutputIndex[0] == 0 ? inputOutputIndex[2] : inputOutputIndex[0];
    int candidateCount=inputOutputIndex[2];
    if (inputNodeCount == candidateCount) {
      this.noVarSelect=true;
    }
 else {
      this.noVarSelect=false;
    }
  }
  if (CommonUtils.isDesicionTreeAlgorithm(alg)) {
    for (    ColumnConfig columnConfig : columnConfigList) {
      if (columnConfig.isCategorical()) {
        Map<String,Integer> map=new HashMap<String,Integer>();
        List<String> categories=columnConfig.getBinCategory();
        for (int i=0; i < categories.size(); i++) {
          map.put(categories.get(i) == null ? ""String_Node_Str"" : categories.get(i),i);
        }
        this.binCategoryMap.put(columnConfig.getColumnNum(),map);
      }
    }
  }
  if (columnConfigList != null) {
    this.columnMapping=new HashMap<Integer,Integer>(columnConfigList.size(),1f);
    int[] inputOutputIndex=DTrainUtils.getNumericAndCategoricalInputAndOutputCounts(this.columnConfigList);
    boolean isAfterVarSelect=inputOutputIndex[3] == 1 ? true : false;
    int index=0;
    for (int i=0; i < columnConfigList.size(); i++) {
      ColumnConfig columnConfig=columnConfigList.get(i);
      if (isAfterVarSelect) {
        if (!columnConfig.isMeta() && !columnConfig.isTarget() && CommonUtils.isGoodCandidate(columnConfig)) {
          this.columnMapping.put(columnConfig.getColumnNum(),index);
          index+=1;
        }
      }
 else {
        if (columnConfig != null && !columnConfig.isMeta() && !columnConfig.isTarget() && columnConfig.isFinalSelect()) {
          this.columnMapping.put(columnConfig.getColumnNum(),index);
          index+=1;
        }
      }
    }
  }
}","public Scorer(List<BasicML> models,List<ColumnConfig> columnConfigList,String algorithm,ModelConfig modelConfig,Double cutoff){
  if (modelConfig == null || (columnConfigList == null || columnConfigList.size() == 0)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.models=models;
  this.columnConfigList=columnConfigList;
  this.cutoff=cutoff;
  this.alg=algorithm;
  this.modelConfig=modelConfig;
  if (this.columnConfigList != null) {
    int[] inputOutputIndex=DTrainUtils.getInputOutputCandidateCounts(this.columnConfigList);
    int inputNodeCount=inputOutputIndex[0] == 0 ? inputOutputIndex[2] : inputOutputIndex[0];
    int candidateCount=inputOutputIndex[2];
    if (inputNodeCount == candidateCount) {
      this.noVarSelect=true;
    }
 else {
      this.noVarSelect=false;
    }
  }
  if (CommonUtils.isDesicionTreeAlgorithm(alg)) {
    for (    ColumnConfig columnConfig : columnConfigList) {
      if (columnConfig.isCategorical()) {
        Map<String,Integer> map=new HashMap<String,Integer>();
        List<String> categories=columnConfig.getBinCategory();
        for (int i=0; i < categories.size(); i++) {
          map.put(categories.get(i) == null ? ""String_Node_Str"" : categories.get(i),i);
        }
        this.binCategoryMap.put(columnConfig.getColumnNum(),map);
      }
    }
  }
  if (columnConfigList != null) {
    this.columnMapping=new HashMap<Integer,Integer>(columnConfigList.size(),1f);
    int[] inputOutputIndex=DTrainUtils.getNumericAndCategoricalInputAndOutputCounts(this.columnConfigList);
    boolean isAfterVarSelect=inputOutputIndex[3] == 1 ? true : false;
    int index=0;
    for (int i=0; i < columnConfigList.size(); i++) {
      ColumnConfig columnConfig=columnConfigList.get(i);
      if (isAfterVarSelect) {
        if (!columnConfig.isMeta() && !columnConfig.isTarget() && CommonUtils.isGoodCandidate(columnConfig)) {
          this.columnMapping.put(columnConfig.getColumnNum(),index);
          index+=1;
        }
      }
 else {
        if (columnConfig != null && !columnConfig.isMeta() && !columnConfig.isTarget() && columnConfig.isFinalSelect()) {
          this.columnMapping.put(columnConfig.getColumnNum(),index);
          index+=1;
        }
      }
    }
  }
}",0.9645324735145094
32049,"/** 
 * Create a new RGB file.
 * @param theInputCount The input count.
 * @param theIdealCount The ideal count.
 */
public final void create(final int theInputCount,final int theIdealCount){
  try {
    this.inputCount=theInputCount;
    this.idealCount=theIdealCount;
    final float[] input=new float[inputCount];
    final float[] ideal=new float[idealCount];
    this.file.delete();
    this.raf=new RandomAccessFile(this.file,""String_Node_Str"");
    this.fc=this.raf.getChannel();
    this.headerBuffer.clear();
    this.headerBuffer.order(ByteOrder.LITTLE_ENDIAN);
    this.headerBuffer.put((byte)'E');
    this.headerBuffer.put((byte)'N');
    this.headerBuffer.put((byte)'C');
    this.headerBuffer.put((byte)'O');
    this.headerBuffer.put((byte)'G');
    this.headerBuffer.put((byte)'-');
    this.headerBuffer.put((byte)'0');
    this.headerBuffer.put((byte)'0');
    this.headerBuffer.putFloat(input.length);
    this.headerBuffer.putFloat(ideal.length);
    this.numberOfRecords=0;
    this.recordCount=this.inputCount + this.idealCount + 1;
    this.recordSize=this.recordCount * EncogFloatEGBFile.FLOAT_SIZE;
    this.recordBuffer=ByteBuffer.allocate(this.recordSize);
    this.headerBuffer.flip();
    this.fc.write(this.headerBuffer);
  }
 catch (  final IOException ex) {
    throw new RuntimeException(ex);
  }
}","/** 
 * Create a new RGB file.
 * @param theInputCount The input count.
 * @param theIdealCount The ideal count.
 */
public final void create(final int theInputCount,final int theIdealCount){
  try {
    this.inputCount=theInputCount;
    this.idealCount=theIdealCount;
    final float[] input=new float[inputCount];
    final float[] ideal=new float[idealCount];
    boolean delete=this.file.delete();
    if (!delete) {
      throw new IOException(""String_Node_Str"");
    }
    this.raf=new RandomAccessFile(this.file,""String_Node_Str"");
    this.fc=this.raf.getChannel();
    this.headerBuffer.clear();
    this.headerBuffer.order(ByteOrder.LITTLE_ENDIAN);
    this.headerBuffer.put((byte)'E');
    this.headerBuffer.put((byte)'N');
    this.headerBuffer.put((byte)'C');
    this.headerBuffer.put((byte)'O');
    this.headerBuffer.put((byte)'G');
    this.headerBuffer.put((byte)'-');
    this.headerBuffer.put((byte)'0');
    this.headerBuffer.put((byte)'0');
    this.headerBuffer.putFloat(input.length);
    this.headerBuffer.putFloat(ideal.length);
    this.numberOfRecords=0;
    this.recordCount=this.inputCount + this.idealCount + 1;
    this.recordSize=this.recordCount * EncogFloatEGBFile.FLOAT_SIZE;
    this.recordBuffer=ByteBuffer.allocate(this.recordSize);
    this.headerBuffer.flip();
    this.fc.write(this.headerBuffer);
  }
 catch (  final IOException ex) {
    throw new RuntimeException(ex);
  }
}",0.9542151162790696
32050,"@Override public void load(GuaguaWritableAdapter<LongWritable> currentKey,GuaguaWritableAdapter<Tuple> currentValue,WorkerContext<NNParams,NNParams> workerContext){
  this.initFieldList();
  super.count+=1;
  if ((super.count) % 100000 == 0) {
    LOG.info(""String_Node_Str"",super.count);
  }
  double baggingSampleRate=super.modelConfig.getBaggingSampleRate();
  if (!super.modelConfig.isFixInitialInput() && Double.compare(Math.random(),baggingSampleRate) >= 0) {
    return;
  }
  float[] inputs=new float[super.inputNodeCount];
  float[] ideal=new float[super.outputNodeCount];
  if (super.isDry) {
    addDataPairToDataSet(0,new BasicFloatMLDataPair(new BasicFloatMLData(inputs),new BasicFloatMLData(ideal)));
    return;
  }
  long hashcode=0;
  float significance=1f;
  int index=0, inputsIndex=0, outputIndex=0;
  Tuple tuple=currentValue.getWritable();
  for (int i=0; i < tuple.size(); i++) {
    Object element=null;
    try {
      element=tuple.get(i);
    }
 catch (    ExecException e) {
      throw new GuaguaRuntimeException(e);
    }
    float floatValue=0f;
    if (element != null) {
      if (element instanceof Double) {
        floatValue=(Float)element;
      }
 else {
        floatValue=NumberFormatUtils.getFloat(element.toString().trim(),0f);
      }
    }
    if (Double.isNaN(floatValue)) {
      floatValue=0f;
    }
    if (index == (super.inputNodeCount + super.outputNodeCount)) {
      if (element != null && element instanceof Float) {
        significance=(Float)element;
      }
 else {
        significance=NumberFormatUtils.getFloat(element.toString().trim(),1f);
        ;
      }
      break;
    }
 else {
      int columnIndex=requiredFieldList.getFields().get(index).getIndex();
      if (columnIndex >= super.columnConfigList.size()) {
        if (element != null && element instanceof Float) {
          significance=(Float)element;
        }
 else {
          significance=NumberFormatUtils.getFloat(element.toString().trim(),1f);
          ;
        }
        break;
      }
 else {
        ColumnConfig columnConfig=super.columnConfigList.get(columnIndex);
        if (columnConfig != null && columnConfig.isTarget()) {
          ideal[outputIndex++]=floatValue;
        }
 else {
          if (super.inputNodeCount == super.candidateCount) {
            if (columnConfig != null && !columnConfig.isMeta() && !columnConfig.isTarget() && CommonUtils.isGoodCandidate(columnConfig)) {
              inputs[inputsIndex++]=floatValue;
              hashcode=hashcode * 31 + Double.valueOf(floatValue).hashCode();
            }
          }
 else {
            if (columnConfig != null && !columnConfig.isMeta() && !columnConfig.isTarget() && columnConfig.isFinalSelect()) {
              inputs[inputsIndex++]=floatValue;
              hashcode=hashcode * 31 + Double.valueOf(floatValue).hashCode();
            }
          }
        }
      }
    }
    index+=1;
  }
  long longBaggingSampleRate=Double.valueOf(baggingSampleRate * 100).longValue();
  if (super.modelConfig.isFixInitialInput() && hashcode % 100 >= longBaggingSampleRate) {
    return;
  }
  super.sampleCount+=1;
  FloatMLDataPair pair=new BasicFloatMLDataPair(new BasicFloatMLData(inputs),new BasicFloatMLData(ideal));
  if (modelConfig.isBinaryClassification() && isUpSampleEnabled() && Double.compare(ideal[0],1d) == 0) {
    pair.setSignificance(significance * (super.upSampleRng.sample() + 1));
  }
 else {
    pair.setSignificance(significance);
  }
  addDataPairToDataSet(hashcode,pair);
}","@Override public void load(GuaguaWritableAdapter<LongWritable> currentKey,GuaguaWritableAdapter<Tuple> currentValue,WorkerContext<NNParams,NNParams> workerContext){
}",0.0903893275251837
32051,"@Override public void postApplication(MasterContext<VarSelMasterResult,VarSelWorkerResult> context){
  VarSelMasterResult varSelMasterResult=context.getMasterResult();
  @SuppressWarnings(""String_Node_Str"") List<CandidateSeed> candidateSeeds=varSelMasterResult.getSeedList();
  LOG.info(""String_Node_Str"",varSelMasterResult.getBestSeed());
  String out=context.getProps().getProperty(Constants.VAR_SEL_COLUMN_IDS_OUPUT);
  writeColumnIdsIntoHDFS(out,varSelMasterResult.getBestSeed().getColumnIdList());
}","@Override public void postApplication(MasterContext<VarSelMasterResult,VarSelWorkerResult> context){
  VarSelMasterResult varSelMasterResult=context.getMasterResult();
  LOG.info(""String_Node_Str"",varSelMasterResult.getBestSeed());
  String out=context.getProps().getProperty(Constants.VAR_SEL_COLUMN_IDS_OUPUT);
  writeColumnIdsIntoHDFS(out,varSelMasterResult.getBestSeed().getColumnIdList());
}",0.88
32052,"private List<CandidatePerf> getIndividual(Iterable<VarSelWorkerResult> workerResults){
  Map<Integer,List<Double>> errorMap=new HashMap<Integer,List<Double>>();
  for (  VarSelWorkerResult workerResult : workerResults) {
    List<CandidatePerf> seedPerfList=workerResult.getSeedPerfList();
    for (    CandidatePerf perf : seedPerfList) {
      if (!errorMap.containsKey(perf.getId())) {
        errorMap.put(perf.getId(),new ArrayList<Double>());
      }
      errorMap.get(perf.getId()).add(perf.getVerror());
    }
  }
  List<CandidatePerf> perfs=new ArrayList<CandidatePerf>(errorMap.size());
  for (  Integer id : errorMap.keySet()) {
    double vError=mean(errorMap.get(id));
    perfs.add(new CandidatePerf(id,vError));
  }
  return perfs;
}","private List<CandidatePerf> getIndividual(Iterable<VarSelWorkerResult> workerResults){
  Map<Integer,List<Double>> errorMap=new HashMap<Integer,List<Double>>();
  for (  VarSelWorkerResult workerResult : workerResults) {
    List<CandidatePerf> seedPerfList=workerResult.getSeedPerfList();
    for (    CandidatePerf perf : seedPerfList) {
      if (!errorMap.containsKey(perf.getId())) {
        errorMap.put(perf.getId(),new ArrayList<Double>());
      }
      errorMap.get(perf.getId()).add(perf.getVerror());
    }
  }
  List<CandidatePerf> perfs=new ArrayList<CandidatePerf>(errorMap.size());
  for (  Entry<Integer,List<Double>> entry : errorMap.entrySet()) {
    double vError=mean(entry.getValue());
    perfs.add(new CandidatePerf(entry.getKey(),vError));
  }
  return perfs;
}",0.9485342019543974
32053,"/** 
 * Calculate the PSI
 * @throws IOException
 */
private void runPSI() throws IOException {
  if (StringUtils.isNotEmpty(modelConfig.getPSIColumnName())) {
    ColumnConfig columnConfig=CommonUtils.findColumnConfigByName(columnConfigList,modelConfig.getPSIColumnName());
    if (columnConfig == null || !columnConfig.isMeta()) {
      log.warn(""String_Node_Str"");
      return;
    }
    log.info(""String_Node_Str"",columnConfig.getColumnName());
    Map<String,String> paramsMap=new HashMap<String,String>();
    paramsMap.put(""String_Node_Str"",CommonUtils.escapePigString(modelConfig.getDataSetDelimiter()));
    paramsMap.put(""String_Node_Str"",modelConfig.getPSIColumnName().trim());
    paramsMap.put(""String_Node_Str"",""String_Node_Str"");
    PigExecutor.getExecutor().submitJob(modelConfig,pathFinder.getAbsolutePath(""String_Node_Str""),paramsMap);
    List<Scanner> scanners=ShifuFileUtils.getDataScanners(pathFinder.getPSIInfoPath(),modelConfig.getDataSet().getSource());
    for (    Scanner scanner : scanners) {
      while (scanner.hasNext()) {
        String[] output=scanner.nextLine().trim().split(""String_Node_Str"");
        try {
          int columnNum=Integer.parseInt(output[0]);
          ColumnConfig config=this.columnConfigList.get(columnNum);
          config.setPSI(Double.parseDouble(output[1]));
        }
 catch (        Exception e) {
        }
      }
    }
  }
}","/** 
 * Calculate the PSI
 * @throws IOException
 */
private void runPSI() throws IOException {
  if (StringUtils.isNotEmpty(modelConfig.getPSIColumnName())) {
    ColumnConfig columnConfig=CommonUtils.findColumnConfigByName(columnConfigList,modelConfig.getPSIColumnName());
    if (columnConfig == null || !columnConfig.isMeta()) {
      log.warn(""String_Node_Str"");
      return;
    }
    log.info(""String_Node_Str"",columnConfig.getColumnName());
    Map<String,String> paramsMap=new HashMap<String,String>();
    paramsMap.put(""String_Node_Str"",CommonUtils.escapePigString(modelConfig.getDataSetDelimiter()));
    paramsMap.put(""String_Node_Str"",modelConfig.getPSIColumnName().trim());
    paramsMap.put(""String_Node_Str"",""String_Node_Str"");
    PigExecutor.getExecutor().submitJob(modelConfig,pathFinder.getAbsolutePath(""String_Node_Str""),paramsMap);
    List<Scanner> scanners=ShifuFileUtils.getDataScanners(pathFinder.getPSIInfoPath(),modelConfig.getDataSet().getSource());
    for (    Scanner scanner : scanners) {
      while (scanner.hasNext()) {
        String[] output=scanner.nextLine().trim().split(""String_Node_Str"");
        try {
          int columnNum=Integer.parseInt(output[0]);
          ColumnConfig config=this.columnConfigList.get(columnNum);
          config.setPSI(Double.parseDouble(output[1]));
        }
 catch (        Exception e) {
          log.error(""String_Node_Str"",e);
        }
      }
    }
  }
}",0.9851694915254238
32054,"@SuppressWarnings(""String_Node_Str"") private void prepareVarSelParams(final List<String> args,final SourceType sourceType){
  args.add(""String_Node_Str"");
  args.add(addRuntimeJars());
  args.add(""String_Node_Str"");
  args.add(ShifuFileUtils.getFileSystemBySourceType(sourceType).makeQualified(new Path(modelConfig.getDataSetRawPath())).toString());
  String zkServers=Environment.getProperty(Environment.ZOO_KEEPER_SERVERS);
  if (StringUtils.isEmpty(zkServers)) {
    log.warn(""String_Node_Str"");
  }
 else {
    args.add(""String_Node_Str"");
    args.add(zkServers);
  }
  args.add(""String_Node_Str"");
  args.add(VarSelWorker.class.getName());
  args.add(""String_Node_Str"");
  args.add(VarSelMaster.class.getName());
  args.add(""String_Node_Str"");
  int expectVarCount=this.modelConfig.getVarSelectFilterNum();
  int forceSelectCount=0;
  int candidateCount=0;
  for (  ColumnConfig columnConfig : columnConfigList) {
    if (columnConfig.isForceSelect()) {
      forceSelectCount++;
    }
    if (CommonUtils.isGoodCandidate(columnConfig)) {
      candidateCount++;
    }
  }
  int iterationCnt=(Integer)this.modelConfig.getVarSelect().getParams().get(CandidateGenerator.POPULATION_MULTIPLY_CNT) + 1;
  args.add(Integer.toString(iterationCnt));
  args.add(""String_Node_Str"");
  args.add(VarSelMasterResult.class.getName());
  args.add(""String_Node_Str"");
  args.add(VarSelWorkerResult.class.getName());
  args.add(String.format(CommonConstants.MAPREDUCE_PARAM_FORMAT,ml.shifu.shifu.util.Constants.VAR_SEL_MASTER_CONDUCTOR,Environment.getProperty(Environment.VAR_SEL_MASTER_CONDUCTOR,WrapperMasterConductor.class.getName())));
  args.add(String.format(CommonConstants.MAPREDUCE_PARAM_FORMAT,ml.shifu.shifu.util.Constants.VAR_SEL_WORKER_CONDUCTOR,Environment.getProperty(Environment.VAR_SEL_MASTER_CONDUCTOR,WrapperWorkerConductor.class.getName())));
  args.add(String.format(CommonConstants.MAPREDUCE_PARAM_FORMAT,NNConstants.MAPRED_JOB_QUEUE_NAME,Environment.getProperty(Environment.HADOOP_JOB_QUEUE,ml.shifu.shifu.util.Constants.DEFAULT_JOB_QUEUE)));
  args.add(String.format(CommonConstants.MAPREDUCE_PARAM_FORMAT,NNConstants.MAPRED_TASK_TIMEOUT,Environment.getInt(NNConstants.MAPRED_TASK_TIMEOUT,ml.shifu.shifu.util.Constants.DEFAULT_MAPRED_TIME_OUT)));
  args.add(String.format(CommonConstants.MAPREDUCE_PARAM_FORMAT,GuaguaConstants.GUAGUA_MASTER_INTERCEPTERS,VarSelOutput.class.getName()));
  args.add(String.format(CommonConstants.MAPREDUCE_PARAM_FORMAT,CommonConstants.SHIFU_MODEL_CONFIG,ShifuFileUtils.getFileSystemBySourceType(sourceType).makeQualified(new Path(super.getPathFinder().getModelConfigPath(sourceType)))));
  args.add(String.format(CommonConstants.MAPREDUCE_PARAM_FORMAT,CommonConstants.SHIFU_COLUMN_CONFIG,ShifuFileUtils.getFileSystemBySourceType(sourceType).makeQualified(new Path(super.getPathFinder().getColumnConfigPath(sourceType)))));
  args.add(String.format(CommonConstants.MAPREDUCE_PARAM_FORMAT,CommonConstants.MODELSET_SOURCE_TYPE,sourceType));
  args.add(String.format(CommonConstants.MAPREDUCE_PARAM_FORMAT,GuaguaConstants.GUAGUA_COMPUTATION_TIME_THRESHOLD,60 * 60 * 1000l));
  setHeapSizeAndSplitSize(args);
  for (  Map.Entry<Object,Object> entry : Environment.getProperties().entrySet()) {
    if (entry.getKey().toString().startsWith(""String_Node_Str"") || entry.getKey().toString().startsWith(""String_Node_Str"") || entry.getKey().toString().startsWith(""String_Node_Str"")) {
      args.add(String.format(CommonConstants.MAPREDUCE_PARAM_FORMAT,entry.getKey().toString(),entry.getValue().toString()));
    }
  }
}","@SuppressWarnings(""String_Node_Str"") private void prepareVarSelParams(final List<String> args,final SourceType sourceType){
  args.add(""String_Node_Str"");
  args.add(addRuntimeJars());
  args.add(""String_Node_Str"");
  args.add(ShifuFileUtils.getFileSystemBySourceType(sourceType).makeQualified(new Path(modelConfig.getDataSetRawPath())).toString());
  String zkServers=Environment.getProperty(Environment.ZOO_KEEPER_SERVERS);
  if (StringUtils.isEmpty(zkServers)) {
    log.warn(""String_Node_Str"");
  }
 else {
    args.add(""String_Node_Str"");
    args.add(zkServers);
  }
  args.add(""String_Node_Str"");
  args.add(VarSelWorker.class.getName());
  args.add(""String_Node_Str"");
  args.add(VarSelMaster.class.getName());
  args.add(""String_Node_Str"");
  int forceSelectCount=0;
  int candidateCount=0;
  for (  ColumnConfig columnConfig : columnConfigList) {
    if (columnConfig.isForceSelect()) {
      forceSelectCount++;
    }
    if (CommonUtils.isGoodCandidate(columnConfig)) {
      candidateCount++;
    }
  }
  int iterationCnt=(Integer)this.modelConfig.getVarSelect().getParams().get(CandidateGenerator.POPULATION_MULTIPLY_CNT) + 1;
  args.add(Integer.toString(iterationCnt));
  args.add(""String_Node_Str"");
  args.add(VarSelMasterResult.class.getName());
  args.add(""String_Node_Str"");
  args.add(VarSelWorkerResult.class.getName());
  args.add(String.format(CommonConstants.MAPREDUCE_PARAM_FORMAT,ml.shifu.shifu.util.Constants.VAR_SEL_MASTER_CONDUCTOR,Environment.getProperty(Environment.VAR_SEL_MASTER_CONDUCTOR,WrapperMasterConductor.class.getName())));
  args.add(String.format(CommonConstants.MAPREDUCE_PARAM_FORMAT,ml.shifu.shifu.util.Constants.VAR_SEL_WORKER_CONDUCTOR,Environment.getProperty(Environment.VAR_SEL_MASTER_CONDUCTOR,WrapperWorkerConductor.class.getName())));
  args.add(String.format(CommonConstants.MAPREDUCE_PARAM_FORMAT,NNConstants.MAPRED_JOB_QUEUE_NAME,Environment.getProperty(Environment.HADOOP_JOB_QUEUE,ml.shifu.shifu.util.Constants.DEFAULT_JOB_QUEUE)));
  args.add(String.format(CommonConstants.MAPREDUCE_PARAM_FORMAT,NNConstants.MAPRED_TASK_TIMEOUT,Environment.getInt(NNConstants.MAPRED_TASK_TIMEOUT,ml.shifu.shifu.util.Constants.DEFAULT_MAPRED_TIME_OUT)));
  args.add(String.format(CommonConstants.MAPREDUCE_PARAM_FORMAT,GuaguaConstants.GUAGUA_MASTER_INTERCEPTERS,VarSelOutput.class.getName()));
  args.add(String.format(CommonConstants.MAPREDUCE_PARAM_FORMAT,CommonConstants.SHIFU_MODEL_CONFIG,ShifuFileUtils.getFileSystemBySourceType(sourceType).makeQualified(new Path(super.getPathFinder().getModelConfigPath(sourceType)))));
  args.add(String.format(CommonConstants.MAPREDUCE_PARAM_FORMAT,CommonConstants.SHIFU_COLUMN_CONFIG,ShifuFileUtils.getFileSystemBySourceType(sourceType).makeQualified(new Path(super.getPathFinder().getColumnConfigPath(sourceType)))));
  args.add(String.format(CommonConstants.MAPREDUCE_PARAM_FORMAT,CommonConstants.MODELSET_SOURCE_TYPE,sourceType));
  args.add(String.format(CommonConstants.MAPREDUCE_PARAM_FORMAT,GuaguaConstants.GUAGUA_COMPUTATION_TIME_THRESHOLD,60 * 60 * 1000l));
  setHeapSizeAndSplitSize(args);
  for (  Map.Entry<Object,Object> entry : Environment.getProperties().entrySet()) {
    if (entry.getKey().toString().startsWith(""String_Node_Str"") || entry.getKey().toString().startsWith(""String_Node_Str"") || entry.getKey().toString().startsWith(""String_Node_Str"")) {
      args.add(String.format(CommonConstants.MAPREDUCE_PARAM_FORMAT,entry.getKey().toString(),entry.getValue().toString()));
    }
  }
}",0.9910549481754934
32055,"private boolean isHadoop2(){
  @SuppressWarnings(""String_Node_Str"") Class<?> mapContextImplClazz=null;
  try {
    mapContextImplClazz=Class.forName(""String_Node_Str"");
    return true;
  }
 catch (  ClassNotFoundException e) {
    return false;
  }
}","private boolean isHadoop2(){
  try {
    Class.forName(""String_Node_Str"");
    return true;
  }
 catch (  ClassNotFoundException e) {
    return false;
  }
}",0.7696078431372549
32056,"/** 
 * Return first line split string array. This is used to detect data schema.
 */
public static String[] takeFirstLine(String dataSetRawPath,String headerDelimiter,SourceType source) throws IOException {
  if (dataSetRawPath == null || headerDelimiter == null || source == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  String firstValidFile=null;
  if (ShifuFileUtils.isDir(dataSetRawPath,source)) {
    FileSystem fs=ShifuFileUtils.getFileSystemBySourceType(source);
    FileStatus[] globStatus=fs.globStatus(new Path(dataSetRawPath),HIDDEN_FILE_FILTER);
    if (globStatus == null || globStatus.length == 0) {
      throw new IllegalArgumentException(""String_Node_Str"" + dataSetRawPath);
    }
 else {
      FileStatus[] listStatus=fs.listStatus(globStatus[0].getPath(),HIDDEN_FILE_FILTER);
      if (listStatus == null || listStatus.length == 0) {
        throw new IllegalArgumentException(""String_Node_Str"" + globStatus[0].getPath());
      }
      firstValidFile=listStatus[0].getPath().toString();
    }
  }
 else {
    firstValidFile=dataSetRawPath;
  }
  BufferedReader reader=null;
  try {
    reader=ShifuFileUtils.getReader(firstValidFile,source);
    String firstLine=reader.readLine();
    List<String> list=new ArrayList<String>();
    for (    String unit : Splitter.on(headerDelimiter).split(firstLine)) {
      list.add(unit);
    }
    return list.toArray(new String[0]);
  }
  finally {
    IOUtils.closeQuietly(reader);
  }
}","/** 
 * Return first line split string array. This is used to detect data schema.
 */
public static String[] takeFirstLine(String dataSetRawPath,String headerDelimiter,SourceType source) throws IOException {
  if (dataSetRawPath == null || headerDelimiter == null || source == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  String firstValidFile=null;
  if (ShifuFileUtils.isDir(dataSetRawPath,source)) {
    FileSystem fs=ShifuFileUtils.getFileSystemBySourceType(source);
    FileStatus[] globStatus=fs.globStatus(new Path(dataSetRawPath),HIDDEN_FILE_FILTER);
    if (globStatus == null || globStatus.length == 0) {
      throw new IllegalArgumentException(""String_Node_Str"" + dataSetRawPath);
    }
 else {
      FileStatus[] listStatus=fs.listStatus(globStatus[0].getPath(),HIDDEN_FILE_FILTER);
      if (listStatus == null || listStatus.length == 0) {
        throw new IllegalArgumentException(""String_Node_Str"" + globStatus[0].getPath());
      }
      firstValidFile=listStatus[0].getPath().toString();
    }
  }
 else {
    firstValidFile=dataSetRawPath;
  }
  BufferedReader reader=null;
  try {
    reader=ShifuFileUtils.getReader(firstValidFile,source);
    String firstLine=reader.readLine();
    if (firstLine != null && firstLine.length() > 0) {
      List<String> list=new ArrayList<String>();
      for (      String unit : Splitter.on(headerDelimiter).split(firstLine)) {
        list.add(unit);
      }
      return list.toArray(new String[0]);
    }
  }
  finally {
    IOUtils.closeQuietly(reader);
  }
}",0.9725801123224316
32057,"/** 
 * @param alg
 * @return
 */
public static Map<String,Object> createParamsByAlg(ALGORITHM alg){
  Map<String,Object> params=new HashMap<String,Object>();
  if (ALGORITHM.NN.equals(alg)) {
    params.put(NNTrainer.PROPAGATION,""String_Node_Str"");
    params.put(NNTrainer.LEARNING_RATE,0.1);
    params.put(NNTrainer.NUM_HIDDEN_LAYERS,1);
    List<Integer> nodes=new ArrayList<Integer>();
    nodes.add(50);
    params.put(NNTrainer.NUM_HIDDEN_NODES,nodes);
    List<String> func=new ArrayList<String>();
    func.add(""String_Node_Str"");
    params.put(NNTrainer.ACTIVATION_FUNC,func);
    params.put(""String_Node_Str"",0.0);
  }
 else   if (ALGORITHM.SVM.equals(alg)) {
    params.put(SVMTrainer.SVM_KERNEL,""String_Node_Str"");
    params.put(SVMTrainer.SVM_GAMMA,1.0);
    params.put(SVMTrainer.SVM_CONST,1.0);
  }
 else   if (ALGORITHM.RF.equals(alg)) {
    params.put(""String_Node_Str"",""String_Node_Str"");
    params.put(""String_Node_Str"",10);
    params.put(""String_Node_Str"",256);
    params.put(""String_Node_Str"",""String_Node_Str"");
  }
 else   if (ALGORITHM.GBDT.equals(alg)) {
    params.put(""String_Node_Str"",""String_Node_Str"");
    params.put(""String_Node_Str"",10);
    params.put(""String_Node_Str"",256);
    params.put(""String_Node_Str"",""String_Node_Str"");
    params.put(NNTrainer.LEARNING_RATE,0.1);
  }
 else   if (ALGORITHM.LR.equals(alg)) {
    params.put(LogisticRegressionTrainer.LEARNING_RATE,0.1);
    params.put(""String_Node_Str"",0.0);
    params.put(""String_Node_Str"",""String_Node_Str"");
  }
  return params;
}","/** 
 * @param alg
 * @return
 */
public static Map<String,Object> createParamsByAlg(ALGORITHM alg){
  Map<String,Object> params=new HashMap<String,Object>();
  if (ALGORITHM.NN.equals(alg)) {
    params.put(NNTrainer.PROPAGATION,""String_Node_Str"");
    params.put(NNTrainer.LEARNING_RATE,0.1);
    params.put(NNTrainer.NUM_HIDDEN_LAYERS,1);
    List<Integer> nodes=new ArrayList<Integer>();
    nodes.add(50);
    params.put(NNTrainer.NUM_HIDDEN_NODES,nodes);
    List<String> func=new ArrayList<String>();
    func.add(""String_Node_Str"");
    params.put(NNTrainer.ACTIVATION_FUNC,func);
    params.put(""String_Node_Str"",0.0);
  }
 else   if (ALGORITHM.SVM.equals(alg)) {
    params.put(SVMTrainer.SVM_KERNEL,""String_Node_Str"");
    params.put(SVMTrainer.SVM_GAMMA,1.0);
    params.put(SVMTrainer.SVM_CONST,1.0);
  }
 else   if (ALGORITHM.RF.equals(alg)) {
    params.put(""String_Node_Str"",""String_Node_Str"");
    params.put(""String_Node_Str"",10);
    params.put(""String_Node_Str"",1);
    params.put(""String_Node_Str"",0.0);
    params.put(""String_Node_Str"",256);
    params.put(""String_Node_Str"",""String_Node_Str"");
    params.put(""String_Node_Str"",""String_Node_Str"");
  }
 else   if (ALGORITHM.GBDT.equals(alg)) {
    params.put(""String_Node_Str"",""String_Node_Str"");
    params.put(""String_Node_Str"",10);
    params.put(""String_Node_Str"",1);
    params.put(""String_Node_Str"",0.0);
    params.put(""String_Node_Str"",256);
    params.put(""String_Node_Str"",""String_Node_Str"");
    params.put(NNTrainer.LEARNING_RATE,0.1);
    params.put(""String_Node_Str"",""String_Node_Str"");
  }
 else   if (ALGORITHM.LR.equals(alg)) {
    params.put(LogisticRegressionTrainer.LEARNING_RATE,0.1);
    params.put(""String_Node_Str"",0.0);
    params.put(""String_Node_Str"",""String_Node_Str"");
  }
  return params;
}",0.9224293445580276
32058,"public ScoreObject score(MLDataPair pair,Map<String,String> rawDataMap){
  if (pair == null) {
    return null;
  }
  List<Integer> scores=new ArrayList<Integer>();
  if (modelConfig != null && (modelConfig.getAlgorithm().equalsIgnoreCase(CommonConstants.GBDT_ALG_NAME) || modelConfig.getAlgorithm().equalsIgnoreCase(CommonConstants.RF_ALG_NAME))) {
    double learningRate=Double.valueOf(this.modelConfig.getParams().get(NNTrainer.LEARNING_RATE).toString());
    BasicML model=models.get(0);
    if (model instanceof TreeModel) {
      TreeModel trees=(TreeModel)model;
      if (trees.getInputCount() != pair.getInput().size()) {
        log.error(""String_Node_Str"" + trees.getInputCount() + ""String_Node_Str""+ pair.getInput().size());
      }
      List<TreeNode> treeNodes=trees.getTrees();
      String algorithm=modelConfig.getAlgorithm();
      List<Double> weights=new ArrayList<Double>(treeNodes.size());
      for (int i=0; i < treeNodes.size(); i++) {
        if (CommonConstants.RF_ALG_NAME.equalsIgnoreCase(algorithm)) {
          weights.add(1d);
        }
        if (CommonConstants.GBDT_ALG_NAME.equalsIgnoreCase(algorithm)) {
          if (i == 0) {
            weights.add(1d);
          }
 else {
            weights.add(learningRate);
          }
        }
      }
      TreeModel treeModel=new TreeModel(treeNodes,weights,CommonConstants.GBDT_ALG_NAME.equalsIgnoreCase(algorithm),columnConfigList,columnMapping);
      MLData internalScore=treeModel.compute(pair.getInput());
      scores.add(toScore(internalScore.getData(0)));
    }
  }
 else {
    for (    BasicML model : models) {
      if (model instanceof BasicNetwork) {
        BasicNetwork network=(BasicNetwork)model;
        if (network.getInputCount() != pair.getInput().size()) {
          log.error(""String_Node_Str"" + network.getInputCount() + ""String_Node_Str""+ pair.getInput().size());
          continue;
        }
        MLData score=network.compute(pair.getInput());
        if (modelConfig != null && modelConfig.isBinaryClassification()) {
          scores.add(toScore(score.getData(0)));
        }
 else {
          double[] outputs=score.getData();
          for (          double d : outputs) {
            scores.add(toScore(d));
          }
        }
      }
 else       if (model instanceof SVM) {
        SVM svm=(SVM)model;
        if (svm.getInputCount() != pair.getInput().size()) {
          log.error(""String_Node_Str"" + svm.getInputCount() + ""String_Node_Str""+ pair.getInput().size());
          continue;
        }
        MLData score=svm.compute(pair.getInput());
        scores.add(toScore(score.getData(0)));
      }
 else       if (model instanceof LR) {
        LR lr=(LR)model;
        if (lr.getInputCount() != pair.getInput().size()) {
          log.error(""String_Node_Str"" + lr.getInputCount() + ""String_Node_Str""+ pair.getInput().size());
          continue;
        }
        MLData score=lr.compute(pair.getInput());
        scores.add(toScore(score.getData(0)));
      }
 else       if (model instanceof TreeModel) {
        TreeModel rf=(TreeModel)model;
        if (rf.getInputCount() != pair.getInput().size()) {
          log.error(""String_Node_Str"" + rf.getInputCount() + ""String_Node_Str""+ pair.getInput().size());
          continue;
        }
        MLData score=rf.compute(pair.getInput());
        scores.add(toScore(score.getData(0)));
      }
 else {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
  }
  Integer tag=(int)pair.getIdeal().getData(0);
  if (scores.size() == 0) {
    log.error(""String_Node_Str"");
    return null;
  }
  return new ScoreObject(scores,tag);
}","public ScoreObject score(MLDataPair pair,Map<String,String> rawDataMap){
  if (pair == null) {
    return null;
  }
  List<Integer> scores=new ArrayList<Integer>();
  for (  BasicML model : models) {
    if (model instanceof BasicNetwork) {
      BasicNetwork network=(BasicNetwork)model;
      if (network.getInputCount() != pair.getInput().size()) {
        log.error(""String_Node_Str"" + network.getInputCount() + ""String_Node_Str""+ pair.getInput().size());
        continue;
      }
      MLData score=network.compute(pair.getInput());
      if (modelConfig != null && modelConfig.isBinaryClassification()) {
        scores.add(toScore(score.getData(0)));
      }
 else {
        double[] outputs=score.getData();
        for (        double d : outputs) {
          scores.add(toScore(d));
        }
      }
    }
 else     if (model instanceof SVM) {
      SVM svm=(SVM)model;
      if (svm.getInputCount() != pair.getInput().size()) {
        log.error(""String_Node_Str"" + svm.getInputCount() + ""String_Node_Str""+ pair.getInput().size());
        continue;
      }
      MLData score=svm.compute(pair.getInput());
      scores.add(toScore(score.getData(0)));
    }
 else     if (model instanceof LR) {
      LR lr=(LR)model;
      if (lr.getInputCount() != pair.getInput().size()) {
        log.error(""String_Node_Str"" + lr.getInputCount() + ""String_Node_Str""+ pair.getInput().size());
        continue;
      }
      MLData score=lr.compute(pair.getInput());
      scores.add(toScore(score.getData(0)));
    }
 else     if (model instanceof TreeModel) {
      TreeModel rf=(TreeModel)model;
      if (rf.getInputCount() != pair.getInput().size()) {
        throw new RuntimeException(""String_Node_Str"" + rf.getInputCount() + ""String_Node_Str""+ pair.getInput().size());
      }
      MLData score=rf.compute(pair.getInput());
      scores.add(toScore(score.getData(0)));
    }
 else {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
  Integer tag=(int)pair.getIdeal().getData(0);
  if (scores.size() == 0) {
    log.error(""String_Node_Str"");
    return null;
  }
  return new ScoreObject(scores,tag);
}",0.367112810707457
32059,"@Override public final MLData compute(final MLData input){
  double[] data=input.getData();
  double predictSum=0d;
  double weightSum=0d;
  for (int i=0; i < this.trees.size(); i++) {
    TreeNode treeNode=this.trees.get(i);
    Double weight=this.weights.get(i);
    weightSum+=weight;
    predictSum+=predictNode(treeNode.getNode(),data) * weight;
  }
  double finalPredict=predictSum / weightSum;
  MLData result=new BasicMLData(1);
  result.setData(0,finalPredict);
  return result;
}","@Override public final MLData compute(final MLData input){
  double[] data=input.getData();
  double predictSum=0d;
  double weightSum=0d;
  for (int i=0; i < this.trees.size(); i++) {
    TreeNode treeNode=this.trees.get(i);
    Double weight=this.weights.get(i);
    weightSum+=weight;
    predictSum+=predictNode(treeNode.getNode(),data) * weight;
  }
  double finalPredict;
  if (this.isGBDT) {
    finalPredict=predictSum;
  }
 else {
    finalPredict=predictSum / weightSum;
  }
  MLData result=new BasicMLData(1);
  result.setData(0,finalPredict);
  return result;
}",0.9209039548022598
32060,"public static TreeModel loadFromStream(InputStream input,ModelConfig modelConfig,List<ColumnConfig> columnConfigList) throws IOException {
  DataInputStream dis=new DataInputStream(input);
  int treeNum=dis.readInt();
  List<TreeNode> trees=new ArrayList<TreeNode>(treeNum);
  String algorithm=modelConfig.getAlgorithm();
  List<Double> weights=new ArrayList<Double>(treeNum);
  for (int i=0; i < treeNum; i++) {
    TreeNode treeNode=new TreeNode();
    treeNode.readFields(dis);
    double learningRate=Double.valueOf(modelConfig.getParams().get(NNTrainer.LEARNING_RATE).toString());
    trees.add(treeNode);
    if (CommonConstants.RF_ALG_NAME.equalsIgnoreCase(algorithm)) {
      weights.add(1d);
    }
    if (CommonConstants.GBDT_ALG_NAME.equalsIgnoreCase(algorithm)) {
      if (i == 0) {
        weights.add(1d);
      }
 else {
        weights.add(learningRate);
      }
    }
  }
  return new TreeModel(trees,weights,CommonConstants.GBDT_ALG_NAME.equalsIgnoreCase(algorithm),columnConfigList);
}","public static TreeModel loadFromStream(InputStream input,ModelConfig modelConfig,List<ColumnConfig> columnConfigList) throws IOException {
  DataInputStream dis=new DataInputStream(input);
  int treeNum=dis.readInt();
  List<TreeNode> trees=new ArrayList<TreeNode>(treeNum);
  String algorithm=modelConfig.getAlgorithm();
  List<Double> weights=new ArrayList<Double>(treeNum);
  for (int i=0; i < treeNum; i++) {
    TreeNode treeNode=new TreeNode();
    treeNode.readFields(dis);
    double learningRate=Double.valueOf(modelConfig.getParams().get(NNTrainer.LEARNING_RATE).toString());
    trees.add(treeNode);
    if (CommonConstants.RF_ALG_NAME.equalsIgnoreCase(algorithm)) {
      weights.add(1d);
    }
    if (CommonConstants.GBDT_ALG_NAME.equalsIgnoreCase(algorithm)) {
      if (i == 0) {
        weights.add(1d);
      }
 else {
        weights.add(learningRate);
      }
    }
  }
  Map<Integer,Integer> columnMapping=new HashMap<Integer,Integer>(columnConfigList.size(),1f);
  int[] inputOutputIndex=DTrainUtils.getNumericAndCategoricalInputAndOutputCounts(columnConfigList);
  boolean isAfterVarSelect=inputOutputIndex[3] == 1 ? true : false;
  int index=0;
  for (int i=0; i < columnConfigList.size(); i++) {
    ColumnConfig columnConfig=columnConfigList.get(i);
    if (!isAfterVarSelect) {
      if (!columnConfig.isMeta() && !columnConfig.isTarget() && CommonUtils.isGoodCandidate(columnConfig)) {
        columnMapping.put(columnConfig.getColumnNum(),index);
        index+=1;
      }
    }
 else {
      if (columnConfig != null && !columnConfig.isMeta() && !columnConfig.isTarget() && columnConfig.isFinalSelect()) {
        columnMapping.put(columnConfig.getColumnNum(),index);
        index+=1;
      }
    }
  }
  return new TreeModel(trees,weights,CommonConstants.GBDT_ALG_NAME.equalsIgnoreCase(algorithm),columnConfigList,columnMapping);
}",0.700836820083682
32061,"public Scorer(List<BasicML> models,List<ColumnConfig> columnConfigList,String algorithm,ModelConfig modelConfig,Double cutoff){
  if (modelConfig == null || (columnConfigList == null || columnConfigList.size() == 0)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.models=models;
  this.columnConfigList=columnConfigList;
  this.cutoff=cutoff;
  this.alg=algorithm;
  this.modelConfig=modelConfig;
  if (this.columnConfigList != null) {
    int[] inputOutputIndex=DTrainUtils.getInputOutputCandidateCounts(this.columnConfigList);
    int inputNodeCount=inputOutputIndex[0] == 0 ? inputOutputIndex[2] : inputOutputIndex[0];
    int candidateCount=inputOutputIndex[2];
    if (inputNodeCount == candidateCount) {
      this.noVarSelect=true;
    }
 else {
      this.noVarSelect=false;
    }
  }
  if (CommonUtils.isDesicionTreeAlgorithm(alg)) {
    for (    ColumnConfig columnConfig : columnConfigList) {
      if (columnConfig.isCategorical()) {
        Map<String,Integer> map=new HashMap<String,Integer>();
        List<String> categories=columnConfig.getBinCategory();
        for (int i=0; i < categories.size(); i++) {
          map.put(categories.get(i) == null ? ""String_Node_Str"" : categories.get(i),i);
        }
        this.binCategoryMap.put(columnConfig.getColumnNum(),map);
      }
    }
  }
  if (columnConfigList != null) {
    this.columnMapping=new HashMap<Integer,Integer>(columnConfigList.size(),1f);
    int[] inputOutputIndex=DTrainUtils.getNumericAndCategoricalInputAndOutputCounts(this.columnConfigList);
    boolean isAfterVarSelect=inputOutputIndex[3] == 1 ? true : false;
    int index=0;
    for (int i=0; i < columnConfigList.size(); i++) {
      ColumnConfig columnConfig=columnConfigList.get(i);
      if (isAfterVarSelect) {
        if (!columnConfig.isMeta() && !columnConfig.isTarget() && CommonUtils.isGoodCandidate(columnConfig)) {
          this.columnMapping.put(columnConfig.getColumnNum(),index);
          index+=1;
        }
      }
 else {
        if (columnConfig != null && !columnConfig.isMeta() && !columnConfig.isTarget() && columnConfig.isFinalSelect()) {
          this.columnMapping.put(columnConfig.getColumnNum(),index);
          index+=1;
        }
      }
    }
  }
}","public Scorer(List<BasicML> models,List<ColumnConfig> columnConfigList,String algorithm,ModelConfig modelConfig,Double cutoff){
  if (modelConfig == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.models=models;
  this.columnConfigList=columnConfigList;
  this.cutoff=cutoff;
  this.alg=algorithm;
  this.modelConfig=modelConfig;
  if (this.columnConfigList != null) {
    int[] inputOutputIndex=DTrainUtils.getInputOutputCandidateCounts(this.columnConfigList);
    int inputNodeCount=inputOutputIndex[0] == 0 ? inputOutputIndex[2] : inputOutputIndex[0];
    int candidateCount=inputOutputIndex[2];
    if (inputNodeCount == candidateCount) {
      this.noVarSelect=true;
    }
 else {
      this.noVarSelect=false;
    }
  }
  if (CommonUtils.isDesicionTreeAlgorithm(alg)) {
    for (    ColumnConfig columnConfig : columnConfigList) {
      if (columnConfig.isCategorical()) {
        Map<String,Integer> map=new HashMap<String,Integer>();
        List<String> categories=columnConfig.getBinCategory();
        for (int i=0; i < categories.size(); i++) {
          map.put(categories.get(i) == null ? ""String_Node_Str"" : categories.get(i),i);
        }
        this.binCategoryMap.put(columnConfig.getColumnNum(),map);
      }
    }
  }
  if (columnConfigList != null) {
    this.columnMapping=new HashMap<Integer,Integer>(columnConfigList.size(),1f);
    int[] inputOutputIndex=DTrainUtils.getNumericAndCategoricalInputAndOutputCounts(this.columnConfigList);
    boolean isAfterVarSelect=inputOutputIndex[3] == 1 ? true : false;
    int index=0;
    for (int i=0; i < columnConfigList.size(); i++) {
      ColumnConfig columnConfig=columnConfigList.get(i);
      if (isAfterVarSelect) {
        if (!columnConfig.isMeta() && !columnConfig.isTarget() && CommonUtils.isGoodCandidate(columnConfig)) {
          this.columnMapping.put(columnConfig.getColumnNum(),index);
          index+=1;
        }
      }
 else {
        if (columnConfig != null && !columnConfig.isMeta() && !columnConfig.isTarget() && columnConfig.isFinalSelect()) {
          this.columnMapping.put(columnConfig.getColumnNum(),index);
          index+=1;
        }
      }
    }
  }
}",0.9860171402796571
32062,"@SuppressWarnings(""String_Node_Str"") private void saveColumnStatus() throws IOException {
  Path localColumnStatsPath=new Path(pathFinder.getLocalColumnStatsPath());
  log.info(""String_Node_Str"",localColumnStatsPath);
  if (HDFSUtils.getLocalFS().exists(localColumnStatsPath)) {
    HDFSUtils.getLocalFS().delete(localColumnStatsPath);
  }
  BufferedWriter writer=null;
  try {
    writer=ShifuFileUtils.getWriter(localColumnStatsPath.toString(),SourceType.LOCAL);
    writer.write(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    StringBuilder builder=new StringBuilder(500);
    for (    ColumnConfig columnConfig : columnConfigList) {
      builder.setLength(0);
      builder.append(modelConfig.getBasic().getName()).append(',');
      builder.append(columnConfig.getColumnFlag()).append(',');
      builder.append(columnConfig.getColumnName()).append(',');
      builder.append(columnConfig.getColumnNum()).append(',');
      builder.append(columnConfig.getIv()).append(',');
      builder.append(columnConfig.getKs()).append(',');
      builder.append(columnConfig.getColumnStats().getMax()).append(',');
      builder.append(columnConfig.getColumnStats().getMean()).append(',');
      builder.append(columnConfig.getColumnStats().getMedian()).append(',');
      builder.append(columnConfig.getColumnStats().getMin()).append(',');
      builder.append(columnConfig.getColumnStats().getMissingCount()).append(',');
      builder.append(columnConfig.getColumnStats().getMissingPercentage()).append(',');
      builder.append(columnConfig.getColumnStats().getStdDev()).append(',');
      builder.append(columnConfig.getColumnStats().getTotalCount()).append(',');
      builder.append(columnConfig.getColumnStats().getDistinctCount()).append(',');
      builder.append(columnConfig.getColumnStats().getWeightedIv()).append(',');
      builder.append(columnConfig.getColumnStats().getWeightedKs()).append(',');
      builder.append(columnConfig.getColumnStats().getWeightedWoe()).append(',');
      builder.append(columnConfig.getColumnStats().getWoe()).append(',');
      builder.append(columnConfig.getColumnStats().getSkewness()).append(',');
      builder.append(columnConfig.getColumnStats().getKurtosis()).append(',');
      builder.append(columnConfig.getColumnType()).append(',');
      builder.append(columnConfig.isFinalSelect()).append(',');
      builder.append(modelConfig.getBasic().getVersion()).append(""String_Node_Str"");
      writer.write(builder.toString());
    }
  }
  finally {
    writer.close();
  }
}","private void saveColumnStatus() throws IOException {
  Path localColumnStatsPath=new Path(pathFinder.getLocalColumnStatsPath());
  log.info(""String_Node_Str"",localColumnStatsPath);
  if (HDFSUtils.getLocalFS().exists(localColumnStatsPath)) {
    HDFSUtils.getLocalFS().delete(localColumnStatsPath,true);
  }
  BufferedWriter writer=null;
  try {
    writer=ShifuFileUtils.getWriter(localColumnStatsPath.toString(),SourceType.LOCAL);
    writer.write(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    StringBuilder builder=new StringBuilder(500);
    for (    ColumnConfig columnConfig : columnConfigList) {
      builder.setLength(0);
      builder.append(modelConfig.getBasic().getName()).append(',');
      builder.append(columnConfig.getColumnFlag()).append(',');
      builder.append(columnConfig.getColumnName()).append(',');
      builder.append(columnConfig.getColumnNum()).append(',');
      builder.append(columnConfig.getIv()).append(',');
      builder.append(columnConfig.getKs()).append(',');
      builder.append(columnConfig.getColumnStats().getMax()).append(',');
      builder.append(columnConfig.getColumnStats().getMean()).append(',');
      builder.append(columnConfig.getColumnStats().getMedian()).append(',');
      builder.append(columnConfig.getColumnStats().getMin()).append(',');
      builder.append(columnConfig.getColumnStats().getMissingCount()).append(',');
      builder.append(columnConfig.getColumnStats().getMissingPercentage()).append(',');
      builder.append(columnConfig.getColumnStats().getStdDev()).append(',');
      builder.append(columnConfig.getColumnStats().getTotalCount()).append(',');
      builder.append(columnConfig.getColumnStats().getDistinctCount()).append(',');
      builder.append(columnConfig.getColumnStats().getWeightedIv()).append(',');
      builder.append(columnConfig.getColumnStats().getWeightedKs()).append(',');
      builder.append(columnConfig.getColumnStats().getWeightedWoe()).append(',');
      builder.append(columnConfig.getColumnStats().getWoe()).append(',');
      builder.append(columnConfig.getColumnStats().getSkewness()).append(',');
      builder.append(columnConfig.getColumnStats().getKurtosis()).append(',');
      builder.append(columnConfig.getColumnType()).append(',');
      builder.append(columnConfig.isFinalSelect()).append(',');
      builder.append(columnConfig.getPSI()).append(',');
      builder.append(StringUtils.join(columnConfig.getUnitStats(),'|')).append(',');
      builder.append(modelConfig.getBasic().getVersion()).append(""String_Node_Str"");
      writer.write(builder.toString());
    }
  }
  finally {
    writer.close();
  }
}",0.9645608628659476
32063,"/** 
 * run mapreduce stats
 * @throws IOException
 */
private void runMapRedStats() throws IOException {
  log.info(""String_Node_Str"");
  ShifuFileUtils.deleteFile(pathFinder.getPreTrainingStatsPath(),modelConfig.getDataSet().getSource());
  Map<String,String> paramsMap=new HashMap<String,String>();
  paramsMap.put(""String_Node_Str"",CommonUtils.escapePigString(modelConfig.getDataSetDelimiter()));
  if (columnConfigList.size() <= 1000) {
    paramsMap.put(""String_Node_Str"",Integer.toString(columnConfigList.size() / 5));
  }
 else {
    paramsMap.put(""String_Node_Str"",Integer.toString(columnConfigList.size() / 4));
  }
  paramsMap.put(""String_Node_Str"",Environment.getProperty(""String_Node_Str"",""String_Node_Str""));
  try {
    log.info(""String_Node_Str"",modelConfig.getBinningAlgorithm().toString());
    if (modelConfig.getBinningAlgorithm().equals(ModelStatsConf.BinningAlgorithm.MunroPat)) {
      PigExecutor.getExecutor().submitJob(modelConfig,pathFinder.getAbsolutePath(""String_Node_Str""),paramsMap);
    }
 else     if (modelConfig.getBinningAlgorithm().equals(ModelStatsConf.BinningAlgorithm.SPDT)) {
      PigExecutor.getExecutor().submitJob(modelConfig,pathFinder.getAbsolutePath(""String_Node_Str""),paramsMap);
    }
 else     if (modelConfig.getBinningAlgorithm().equals(ModelStatsConf.BinningAlgorithm.SPDTI)) {
      paramsMap.put(""String_Node_Str"",Integer.toString(columnConfigList.size() / (5 * 8)));
      ShifuFileUtils.deleteFile(pathFinder.getUpdatedBinningInfoPath(modelConfig.getDataSet().getSource()),modelConfig.getDataSet().getSource());
      PigExecutor.getExecutor().submitJob(modelConfig,pathFinder.getAbsolutePath(""String_Node_Str""),paramsMap);
      log.info(""String_Node_Str"");
      updateBinningInfoWithMRJob();
    }
 else     if (modelConfig.getBinningAlgorithm().equals(ModelStatsConf.BinningAlgorithm.MunroPatI)) {
      ShifuFileUtils.deleteFile(pathFinder.getUpdatedBinningInfoPath(modelConfig.getDataSet().getSource()),modelConfig.getDataSet().getSource());
      PigExecutor.getExecutor().submitJob(modelConfig,pathFinder.getAbsolutePath(""String_Node_Str""),paramsMap);
      log.info(""String_Node_Str"");
      updateBinningInfoWithMRJob();
    }
  }
 catch (  IOException e) {
    throw new ShifuException(ShifuErrorCode.ERROR_RUNNING_PIG_JOB,e);
  }
catch (  Throwable e) {
    throw new RuntimeException(e);
  }
  log.info(""String_Node_Str"");
  updateColumnConfigWithPreTrainingStats();
  saveColumnConfigListAndColumnStats(true);
  syncDataToHdfs(modelConfig.getDataSet().getSource());
  runPSI();
  saveColumnConfigListAndColumnStats(true);
  syncDataToHdfs(modelConfig.getDataSet().getSource());
}","/** 
 * run mapreduce stats
 * @throws IOException
 */
private void runMapRedStats() throws IOException {
  log.info(""String_Node_Str"");
  ShifuFileUtils.deleteFile(pathFinder.getPreTrainingStatsPath(),modelConfig.getDataSet().getSource());
  Map<String,String> paramsMap=new HashMap<String,String>();
  paramsMap.put(""String_Node_Str"",CommonUtils.escapePigString(modelConfig.getDataSetDelimiter()));
  if (columnConfigList.size() <= 1000) {
    paramsMap.put(""String_Node_Str"",Integer.toString(columnConfigList.size() / 5));
  }
 else {
    paramsMap.put(""String_Node_Str"",Integer.toString(columnConfigList.size() / 4));
  }
  paramsMap.put(""String_Node_Str"",Environment.getProperty(""String_Node_Str"",""String_Node_Str""));
  try {
    log.info(""String_Node_Str"",modelConfig.getBinningAlgorithm().toString());
    if (modelConfig.getBinningAlgorithm().equals(ModelStatsConf.BinningAlgorithm.MunroPat)) {
      PigExecutor.getExecutor().submitJob(modelConfig,pathFinder.getAbsolutePath(""String_Node_Str""),paramsMap);
    }
 else     if (modelConfig.getBinningAlgorithm().equals(ModelStatsConf.BinningAlgorithm.SPDT)) {
      PigExecutor.getExecutor().submitJob(modelConfig,pathFinder.getAbsolutePath(""String_Node_Str""),paramsMap);
    }
 else     if (modelConfig.getBinningAlgorithm().equals(ModelStatsConf.BinningAlgorithm.SPDTI)) {
      paramsMap.put(""String_Node_Str"",Integer.toString(columnConfigList.size() / (5 * 8)));
      ShifuFileUtils.deleteFile(pathFinder.getUpdatedBinningInfoPath(modelConfig.getDataSet().getSource()),modelConfig.getDataSet().getSource());
      PigExecutor.getExecutor().submitJob(modelConfig,pathFinder.getAbsolutePath(""String_Node_Str""),paramsMap);
      log.info(""String_Node_Str"");
      updateBinningInfoWithMRJob();
    }
 else     if (modelConfig.getBinningAlgorithm().equals(ModelStatsConf.BinningAlgorithm.MunroPatI)) {
      ShifuFileUtils.deleteFile(pathFinder.getUpdatedBinningInfoPath(modelConfig.getDataSet().getSource()),modelConfig.getDataSet().getSource());
      PigExecutor.getExecutor().submitJob(modelConfig,pathFinder.getAbsolutePath(""String_Node_Str""),paramsMap);
      log.info(""String_Node_Str"");
      updateBinningInfoWithMRJob();
    }
  }
 catch (  IOException e) {
    throw new ShifuException(ShifuErrorCode.ERROR_RUNNING_PIG_JOB,e);
  }
catch (  Throwable e) {
    throw new RuntimeException(e);
  }
  log.info(""String_Node_Str"");
  updateColumnConfigWithPreTrainingStats();
  saveColumnConfigListAndColumnStats(true);
  syncDataToHdfs(modelConfig.getDataSet().getSource());
  runPSI();
  saveColumnConfigListAndColumnStats(true);
}",0.9893252001524973
32064,"/** 
 * Calculate the PSI
 * @throws IOException
 */
private void runPSI() throws IOException {
  if (StringUtils.isNotEmpty(modelConfig.getPSIColumnName())) {
    ColumnConfig columnConfig=CommonUtils.findColumnConfigByName(columnConfigList,modelConfig.getPSIColumnName());
    if (columnConfig == null || !columnConfig.isMeta()) {
      log.warn(""String_Node_Str"");
      return;
    }
    log.info(""String_Node_Str"",columnConfig.getColumnName());
    Map<String,String> paramsMap=new HashMap<String,String>();
    paramsMap.put(""String_Node_Str"",CommonUtils.escapePigString(modelConfig.getDataSetDelimiter()));
    paramsMap.put(""String_Node_Str"",modelConfig.getPSIColumnName().trim());
    paramsMap.put(""String_Node_Str"",""String_Node_Str"");
    PigExecutor.getExecutor().submitJob(modelConfig,pathFinder.getAbsolutePath(""String_Node_Str""),paramsMap);
    List<Scanner> scanners=ShifuFileUtils.getDataScanners(pathFinder.getPSIInfoPath(),modelConfig.getDataSet().getSource());
    for (    Scanner scanner : scanners) {
      while (scanner.hasNext()) {
        String[] output=scanner.nextLine().trim().split(""String_Node_Str"");
        try {
          int columnNum=Integer.parseInt(output[0]);
          ColumnConfig config=this.columnConfigList.get(columnNum);
          config.setPSI(Double.parseDouble(output[1]));
        }
 catch (        Exception e) {
          log.error(""String_Node_Str"",e);
        }
      }
    }
  }
}","/** 
 * Calculate the PSI
 * @throws IOException
 */
private void runPSI() throws IOException {
  log.info(""String_Node_Str"",modelConfig.getPsiColumnName());
  if (StringUtils.isNotEmpty(modelConfig.getPsiColumnName())) {
    ColumnConfig columnConfig=CommonUtils.findColumnConfigByName(columnConfigList,modelConfig.getPsiColumnName());
    if (columnConfig == null || !columnConfig.isMeta()) {
      log.warn(""String_Node_Str"");
      return;
    }
    log.info(""String_Node_Str"",columnConfig.getColumnName());
    Map<String,String> paramsMap=new HashMap<String,String>();
    paramsMap.put(""String_Node_Str"",CommonUtils.escapePigString(modelConfig.getDataSetDelimiter()));
    paramsMap.put(""String_Node_Str"",modelConfig.getPsiColumnName().trim());
    paramsMap.put(""String_Node_Str"",Integer.toString(columnConfigList.size() / 10));
    paramsMap.put(""String_Node_Str"",""String_Node_Str"");
    PigExecutor.getExecutor().submitJob(modelConfig,pathFinder.getAbsolutePath(""String_Node_Str""),paramsMap);
    List<Scanner> scanners=ShifuFileUtils.getDataScanners(pathFinder.getPSIInfoPath(),modelConfig.getDataSet().getSource());
    for (    Scanner scanner : scanners) {
      while (scanner.hasNext()) {
        String[] output=scanner.nextLine().trim().split(""String_Node_Str"");
        try {
          int columnNum=Integer.parseInt(output[0]);
          ColumnConfig config=this.columnConfigList.get(columnNum);
          config.setPSI(Double.parseDouble(output[1]));
          config.setUnitStats(Arrays.asList(StringUtils.split(output[2],CalculateStatsUDF.CATEGORY_VAL_SEPARATOR)));
        }
 catch (        Exception e) {
          log.error(""String_Node_Str"",e);
        }
      }
    }
  }
  log.info(""String_Node_Str"");
}",0.8923950773114547
32065,"@Override public Tuple exec(Tuple input) throws IOException {
  if (input == null || input.size() < 2) {
    return null;
  }
  Integer columnId=(Integer)input.get(0);
  DataBag databag=(DataBag)input.get(1);
  ColumnConfig columnConfig=this.columnConfigList.get(columnId);
  List<Integer> negativeBin=columnConfig.getBinCountNeg();
  List<Integer> positiveBin=columnConfig.getBinCountPos();
  List<Double> expected=new ArrayList<Double>(negativeBin.size());
  for (int i=0; i < columnConfig.getBinCountNeg().size(); i++) {
    if (columnConfig.getTotalCount() == 0) {
      expected.add(0D);
    }
 else {
      expected.add(((double)negativeBin.get(i) + (double)positiveBin.get(i)) / columnConfig.getTotalCount());
    }
  }
  Iterator<Tuple> iter=databag.iterator();
  Double psi=0D;
  while (iter.hasNext()) {
    Tuple tuple=iter.next();
    if (tuple != null && tuple.size() != 0) {
      String subBinStr=(String)tuple.get(1);
      String[] subBinArr=StringUtils.split(subBinStr,CalculateStatsUDF.CATEGORY_VAL_SEPARATOR);
      List<Double> subCounter=new ArrayList<Double>();
      Double total=0D;
      for (      String binningElement : subBinArr) {
        Double dVal=Double.valueOf(binningElement);
        subCounter.add(dVal);
        total+=dVal;
      }
      int i=0;
      for (      Double sub : subCounter) {
        if (total == 0) {
          continue;
        }
 else         if (expected.get(i) == 0) {
          continue;
        }
 else {
          double logNum=(sub / total) / expected.get(i);
          if (logNum <= 0) {
            continue;
          }
 else {
            psi=psi + ((sub / total - expected.get(i)) * Math.log((sub / total) / expected.get(i)));
          }
        }
        i++;
      }
    }
  }
  Tuple output=TupleFactory.getInstance().newTuple(2);
  output.set(0,columnId);
  output.set(1,psi);
  return output;
}","@Override public Tuple exec(Tuple input) throws IOException {
  if (input == null || input.size() < 2) {
    return null;
  }
  Integer columnId=(Integer)input.get(0);
  DataBag databag=(DataBag)input.get(1);
  ColumnConfig columnConfig=this.columnConfigList.get(columnId);
  List<Integer> negativeBin=columnConfig.getBinCountNeg();
  List<Integer> positiveBin=columnConfig.getBinCountPos();
  List<Double> expected=new ArrayList<Double>(negativeBin.size());
  for (int i=0; i < columnConfig.getBinCountNeg().size(); i++) {
    if (columnConfig.getTotalCount() == 0) {
      expected.add(0D);
    }
 else {
      expected.add(((double)negativeBin.get(i) + (double)positiveBin.get(i)) / columnConfig.getTotalCount());
    }
  }
  Iterator<Tuple> iter=databag.iterator();
  Double psi=0D;
  List<String> unitStats=new ArrayList<String>();
  while (iter.hasNext()) {
    Tuple tuple=iter.next();
    if (tuple != null && tuple.size() != 0) {
      String subBinStr=(String)tuple.get(1);
      String[] subBinArr=StringUtils.split(subBinStr,CalculateStatsUDF.CATEGORY_VAL_SEPARATOR);
      List<Double> subCounter=new ArrayList<Double>();
      Double total=0D;
      for (      String binningElement : subBinArr) {
        Double dVal=Double.valueOf(binningElement);
        subCounter.add(dVal);
        total+=dVal;
      }
      int i=0;
      for (      Double sub : subCounter) {
        if (total == 0) {
          continue;
        }
 else         if (expected.get(i) == 0) {
          continue;
        }
 else {
          double logNum=(sub / total) / expected.get(i);
          if (logNum <= 0) {
            continue;
          }
 else {
            psi=psi + ((sub / total - expected.get(i)) * Math.log((sub / total) / expected.get(i)));
          }
        }
        i++;
      }
      unitStats.add((String)tuple.get(2));
    }
  }
  Collections.sort(unitStats);
  Tuple output=TupleFactory.getInstance().newTuple(3);
  output.set(0,columnId);
  output.set(1,psi);
  output.set(2,StringUtils.join(unitStats,CalculateStatsUDF.CATEGORY_VAL_SEPARATOR));
  return output;
}",0.9463291139240506
32066,"/** 
 * Copy local file to HDFS. This is used to set as classpath by distributed cache.
 */
private static Path shipToHDFS(Configuration conf,String fileName) throws IOException {
  Path dst=new Path(""String_Node_Str"",fileName.substring(fileName.lastIndexOf(File.separator) + 1));
  FileSystem fs=dst.getFileSystem(conf);
  OutputStream os=null;
  InputStream is=null;
  try {
    is=FileSystem.getLocal(conf).open(new Path(fileName));
    os=fs.create(dst);
    IOUtils.copyBytes(is,os,4096,true);
  }
  finally {
    org.apache.commons.io.IOUtils.closeQuietly(is);
    if (os != null) {
      os.close();
    }
  }
  return dst;
}","/** 
 * Copy local file to HDFS. This is used to set as classpath by distributed cache.
 */
private static Path shipToHDFS(Configuration conf,String fileName) throws IOException {
  Path dst=new Path(File.separator + ""String_Node_Str"" + File.separator+ System.getProperty(""String_Node_Str"")+ ""String_Node_Str""+ System.currentTimeMillis(),fileName.substring(fileName.lastIndexOf(File.separator) + 1));
  FileSystem fs=dst.getFileSystem(conf);
  OutputStream os=null;
  InputStream is=null;
  try {
    is=FileSystem.getLocal(conf).open(new Path(fileName));
    os=fs.create(dst);
    IOUtils.copyBytes(is,os,4096,true);
  }
  finally {
    org.apache.commons.io.IOUtils.closeQuietly(is);
    if (os != null) {
      os.close();
    }
  }
  return dst;
}",0.9132947976878611
32067,"private void saveColumnStatus() throws IOException {
  Path localColumnStatsPath=new Path(pathFinder.getLocalColumnStatsPath());
  log.info(""String_Node_Str"",localColumnStatsPath);
  if (HDFSUtils.getLocalFS().exists(localColumnStatsPath)) {
    HDFSUtils.getLocalFS().delete(localColumnStatsPath);
  }
  BufferedWriter writer=null;
  try {
    writer=ShifuFileUtils.getWriter(localColumnStatsPath.toString(),SourceType.LOCAL);
    writer.write(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    StringBuilder builder=new StringBuilder(500);
    for (    ColumnConfig columnConfig : columnConfigList) {
      builder.setLength(0);
      builder.append(modelConfig.getBasic().getName()).append(',');
      builder.append(columnConfig.getColumnFlag()).append(',');
      builder.append(columnConfig.getColumnName()).append(',');
      builder.append(columnConfig.getColumnNum()).append(',');
      builder.append(columnConfig.getIv()).append(',');
      builder.append(columnConfig.getKs()).append(',');
      builder.append(columnConfig.getColumnStats().getMax()).append(',');
      builder.append(columnConfig.getColumnStats().getMean()).append(',');
      builder.append(columnConfig.getColumnStats().getMedian()).append(',');
      builder.append(columnConfig.getColumnStats().getMin()).append(',');
      builder.append(columnConfig.getColumnStats().getMissingCount()).append(',');
      builder.append(columnConfig.getColumnStats().getMissingPercentage()).append(',');
      builder.append(columnConfig.getColumnStats().getStdDev()).append(',');
      builder.append(columnConfig.getColumnStats().getTotalCount()).append(',');
      builder.append(columnConfig.getColumnStats().getWeightedIv()).append(',');
      builder.append(columnConfig.getColumnStats().getWeightedKs()).append(',');
      builder.append(columnConfig.getColumnStats().getWeightedWoe()).append(',');
      builder.append(columnConfig.getColumnStats().getWoe()).append(',');
      builder.append(columnConfig.getColumnStats().getSkewness()).append(',');
      builder.append(columnConfig.getColumnStats().getKurtosis()).append(',');
      builder.append(columnConfig.getColumnType()).append(',');
      builder.append(columnConfig.isFinalSelect()).append(',');
      builder.append(modelConfig.getBasic().getVersion()).append(""String_Node_Str"");
      writer.write(builder.toString());
    }
  }
  finally {
    writer.close();
  }
}","@SuppressWarnings(""String_Node_Str"") private void saveColumnStatus() throws IOException {
  Path localColumnStatsPath=new Path(pathFinder.getLocalColumnStatsPath());
  log.info(""String_Node_Str"",localColumnStatsPath);
  if (HDFSUtils.getLocalFS().exists(localColumnStatsPath)) {
    HDFSUtils.getLocalFS().delete(localColumnStatsPath);
  }
  BufferedWriter writer=null;
  try {
    writer=ShifuFileUtils.getWriter(localColumnStatsPath.toString(),SourceType.LOCAL);
    writer.write(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    StringBuilder builder=new StringBuilder(500);
    for (    ColumnConfig columnConfig : columnConfigList) {
      builder.setLength(0);
      builder.append(modelConfig.getBasic().getName()).append(',');
      builder.append(columnConfig.getColumnFlag()).append(',');
      builder.append(columnConfig.getColumnName()).append(',');
      builder.append(columnConfig.getColumnNum()).append(',');
      builder.append(columnConfig.getIv()).append(',');
      builder.append(columnConfig.getKs()).append(',');
      builder.append(columnConfig.getColumnStats().getMax()).append(',');
      builder.append(columnConfig.getColumnStats().getMean()).append(',');
      builder.append(columnConfig.getColumnStats().getMedian()).append(',');
      builder.append(columnConfig.getColumnStats().getMin()).append(',');
      builder.append(columnConfig.getColumnStats().getMissingCount()).append(',');
      builder.append(columnConfig.getColumnStats().getMissingPercentage()).append(',');
      builder.append(columnConfig.getColumnStats().getStdDev()).append(',');
      builder.append(columnConfig.getColumnStats().getTotalCount()).append(',');
      builder.append(columnConfig.getColumnStats().getWeightedIv()).append(',');
      builder.append(columnConfig.getColumnStats().getWeightedKs()).append(',');
      builder.append(columnConfig.getColumnStats().getWeightedWoe()).append(',');
      builder.append(columnConfig.getColumnStats().getWoe()).append(',');
      builder.append(columnConfig.getColumnStats().getSkewness()).append(',');
      builder.append(columnConfig.getColumnStats().getKurtosis()).append(',');
      builder.append(columnConfig.getColumnType()).append(',');
      builder.append(columnConfig.isFinalSelect()).append(',');
      builder.append(modelConfig.getBasic().getVersion()).append(""String_Node_Str"");
      writer.write(builder.toString());
    }
  }
  finally {
    writer.close();
  }
}",0.992413368874308
32068,"@Override public void readFields(DataInput in) throws IOException {
  int len=in.readInt();
  hyperBytes=new byte[len];
  in.readFully(hyperBytes);
  len=in.readInt();
  frequetItems=new HashSet<String>(len);
  for (int i=0; i < len; i++) {
    int unitLen=in.readInt();
    byte[] bytes=new byte[unitLen];
    in.readFully(bytes);
    frequetItems.add(new String(bytes,Constants.DEFAULT_CHARSET));
  }
}","@Override public void readFields(DataInput in) throws IOException {
  int len=in.readInt();
  hyperBytes=new byte[len];
  if (len != 0) {
    for (int i=0; i < len; i++) {
      hyperBytes[i]=in.readByte();
    }
  }
  len=in.readInt();
  frequetItems=new HashSet<String>(len,1f);
  if (len != 0) {
    for (int i=0; i < len; i++) {
      if (in.readBoolean()) {
        frequetItems.add(in.readUTF());
      }
    }
  }
}",0.6053268765133172
32069,"@Override public void write(DataOutput out) throws IOException {
  out.writeInt(hyperBytes.length);
  out.write(hyperBytes,0,hyperBytes.length);
  int setSize=Math.min(frequetItems.size(),FREQUET_ITEM_MAX_SIZE);
  out.writeInt(setSize);
  Iterator<String> iter=frequetItems.iterator();
  int i=0;
  while (i < setSize) {
    String unit=iter.next();
    out.writeInt(unit.length());
    byte[] bytes=unit.getBytes(Constants.DEFAULT_CHARSET);
    out.write(bytes,0,bytes.length);
    i++;
  }
}","@Override public void write(DataOutput out) throws IOException {
  if (hyperBytes == null) {
    out.writeInt(0);
  }
 else {
    out.writeInt(hyperBytes.length);
    for (int i=0; i < hyperBytes.length; i++) {
      out.writeByte(hyperBytes[i]);
    }
  }
  if (frequetItems == null) {
    out.writeInt(0);
  }
 else {
    int setSize=Math.min(frequetItems.size(),FREQUET_ITEM_MAX_SIZE);
    out.writeInt(setSize);
    Iterator<String> iter=frequetItems.iterator();
    int i=0;
    while (i < setSize) {
      String unit=iter.next();
      if (unit == null) {
        out.writeBoolean(false);
      }
 else {
        out.writeBoolean(true);
        out.writeUTF(unit);
      }
      i++;
    }
  }
}",0.5439330543933054
32070,"private int setCategoricalColumnsAndDistinctAccount(Map<Integer,Data> distinctCountMap,boolean cateOn,boolean distinctOn){
  int cateCount=0;
  for (  ColumnConfig columnConfig : columnConfigList) {
    Long distinctCount=distinctCountMap.get(columnConfig.getColumnNum()).count;
    if (distinctCount != null && modelConfig.getDataSet().getAutoTypeThreshold() != null) {
      if (cateOn) {
        if (distinctCount < modelConfig.getDataSet().getAutoTypeThreshold().longValue()) {
          String[] items=distinctCountMap.get(columnConfig.getColumnNum()).items;
          if (is01Variable(distinctCount,items)) {
            log.info(""String_Node_Str"",columnConfig.getColumnName(),columnConfig.getColumnNum(),distinctCount,Arrays.toString(items));
            columnConfig.setColumnType(ColumnType.N);
          }
 else           if (isDoubleFrequentVariable(distinctCount,items)) {
            log.info(""String_Node_Str"",columnConfig.getColumnName(),columnConfig.getColumnNum(),distinctCount,Arrays.toString(items));
            columnConfig.setColumnType(ColumnType.N);
          }
 else {
            columnConfig.setColumnType(ColumnType.C);
            cateCount+=1;
            log.info(""String_Node_Str"",columnConfig.getColumnName(),columnConfig.getColumnNum(),distinctCount,modelConfig.getDataSet().getAutoTypeThreshold());
          }
        }
      }
      if (distinctOn) {
        columnConfig.getColumnStats().setDistinctCount(distinctCount);
      }
    }
  }
  return cateCount;
}","private int setCategoricalColumnsAndDistinctAccount(Map<Integer,Data> distinctCountMap,boolean cateOn,boolean distinctOn){
  int cateCount=0;
  for (  ColumnConfig columnConfig : columnConfigList) {
    Data data=distinctCountMap.get(columnConfig.getColumnNum());
    if (data == null) {
      continue;
    }
    Long distinctCount=data.count;
    if (distinctCount != null && modelConfig.getDataSet().getAutoTypeThreshold() != null) {
      if (cateOn) {
        if (distinctCount < modelConfig.getDataSet().getAutoTypeThreshold().longValue()) {
          String[] items=data.items;
          if (is01Variable(distinctCount,items)) {
            log.info(""String_Node_Str"",columnConfig.getColumnName(),columnConfig.getColumnNum(),distinctCount,Arrays.toString(items));
            columnConfig.setColumnType(ColumnType.N);
          }
 else           if (isDoubleFrequentVariable(distinctCount,items)) {
            log.info(""String_Node_Str"",columnConfig.getColumnName(),columnConfig.getColumnNum(),distinctCount,Arrays.toString(items));
            columnConfig.setColumnType(ColumnType.N);
          }
 else {
            columnConfig.setColumnType(ColumnType.C);
            cateCount+=1;
            log.info(""String_Node_Str"",columnConfig.getColumnName(),columnConfig.getColumnNum(),distinctCount,modelConfig.getDataSet().getAutoTypeThreshold());
          }
        }
      }
      if (distinctOn) {
        columnConfig.getColumnStats().setDistinctCount(distinctCount);
      }
    }
  }
  return cateCount;
}",0.9294000662910176
32071,"/** 
 * To do some auto variable selection like remove ID-like variables, remove variable with high missing rate.
 */
private void autoVarSelCondition(){
  for (  ColumnConfig config : columnConfigList) {
    if (isIDLikeVariable(config)) {
      log.warn(""String_Node_Str"",config.getColumnName());
      config.setFinalSelect(false);
      continue;
    }
    if (isHighMissingRateColumn(config)) {
      log.warn(""String_Node_Str"",config.getColumnName());
      config.setFinalSelect(false);
      continue;
    }
    if (config.getIv() == null || config.getIv() <= BAD_IV_THRESHOLD) {
      log.warn(""String_Node_Str"",config.getColumnName(),BAD_IV_THRESHOLD);
      config.setFinalSelect(false);
      continue;
    }
  }
}","/** 
 * To do some auto variable selection like remove ID-like variables, remove variable with high missing rate.
 */
private void autoVarSelCondition(){
  for (  ColumnConfig config : columnConfigList) {
    if (isIDLikeVariable(config) && !config.isForceSelect()) {
      log.warn(""String_Node_Str"",config.getColumnName());
      config.setFinalSelect(false);
      continue;
    }
    if (isHighMissingRateColumn(config) && !config.isForceSelect()) {
      log.warn(""String_Node_Str"",config.getColumnName());
      config.setFinalSelect(false);
      continue;
    }
    if ((config.getIv() == null || config.getIv() <= BAD_IV_THRESHOLD) && !config.isForceSelect()) {
      log.warn(""String_Node_Str"",config.getColumnName(),BAD_IV_THRESHOLD);
      config.setFinalSelect(false);
      continue;
    }
  }
}",0.9459283387622148
32072,"/** 
 * @param alg
 * @return
 */
public static Map<String,Object> createParamsByAlg(ALGORITHM alg){
  Map<String,Object> params=new HashMap<String,Object>();
  if (ALGORITHM.NN.equals(alg)) {
    params.put(NNTrainer.PROPAGATION,""String_Node_Str"");
    params.put(NNTrainer.LEARNING_RATE,0.1);
    params.put(""String_Node_Str"",0.0);
    params.put(NNTrainer.NUM_HIDDEN_LAYERS,1);
    List<Integer> nodes=new ArrayList<Integer>();
    nodes.add(50);
    params.put(NNTrainer.NUM_HIDDEN_NODES,nodes);
    List<String> func=new ArrayList<String>();
    func.add(""String_Node_Str"");
    params.put(NNTrainer.ACTIVATION_FUNC,func);
    params.put(""String_Node_Str"",0.0);
    params.put(""String_Node_Str"",0.0);
  }
 else   if (ALGORITHM.SVM.equals(alg)) {
    params.put(SVMTrainer.SVM_KERNEL,""String_Node_Str"");
    params.put(SVMTrainer.SVM_GAMMA,1.0);
    params.put(SVMTrainer.SVM_CONST,1.0);
  }
 else   if (ALGORITHM.RF.equals(alg)) {
    params.put(""String_Node_Str"",""String_Node_Str"");
    params.put(""String_Node_Str"",10);
    params.put(""String_Node_Str"",256);
    params.put(""String_Node_Str"",""String_Node_Str"");
  }
 else   if (ALGORITHM.GBDT.equals(alg)) {
    params.put(""String_Node_Str"",""String_Node_Str"");
    params.put(""String_Node_Str"",10);
    params.put(""String_Node_Str"",256);
    params.put(""String_Node_Str"",""String_Node_Str"");
    params.put(NNTrainer.LEARNING_RATE,0.1);
  }
 else   if (ALGORITHM.LR.equals(alg)) {
    params.put(LogisticRegressionTrainer.LEARNING_RATE,0.1);
    params.put(""String_Node_Str"",0.0);
    params.put(""String_Node_Str"",""String_Node_Str"");
    params.put(NNTrainer.PROPAGATION,""String_Node_Str"");
  }
  return params;
}","/** 
 * @param alg
 * @return
 */
public static Map<String,Object> createParamsByAlg(ALGORITHM alg){
  Map<String,Object> params=new HashMap<String,Object>();
  if (ALGORITHM.NN.equals(alg)) {
    params.put(NNTrainer.PROPAGATION,""String_Node_Str"");
    params.put(NNTrainer.LEARNING_RATE,0.1);
    params.put(""String_Node_Str"",0.0);
    params.put(NNTrainer.NUM_HIDDEN_LAYERS,1);
    List<Integer> nodes=new ArrayList<Integer>();
    nodes.add(50);
    params.put(NNTrainer.NUM_HIDDEN_NODES,nodes);
    List<String> func=new ArrayList<String>();
    func.add(""String_Node_Str"");
    params.put(NNTrainer.ACTIVATION_FUNC,func);
    params.put(""String_Node_Str"",0.0);
    params.put(""String_Node_Str"",0.0);
  }
 else   if (ALGORITHM.SVM.equals(alg)) {
    params.put(SVMTrainer.SVM_KERNEL,""String_Node_Str"");
    params.put(SVMTrainer.SVM_GAMMA,1.0);
    params.put(SVMTrainer.SVM_CONST,1.0);
  }
 else   if (ALGORITHM.RF.equals(alg)) {
    params.put(""String_Node_Str"",""String_Node_Str"");
    params.put(""String_Node_Str"",10);
    params.put(""String_Node_Str"",256);
    params.put(""String_Node_Str"",""String_Node_Str"");
  }
 else   if (ALGORITHM.GBDT.equals(alg)) {
    params.put(""String_Node_Str"",""String_Node_Str"");
    params.put(""String_Node_Str"",10);
    params.put(""String_Node_Str"",256);
    params.put(""String_Node_Str"",""String_Node_Str"");
    params.put(NNTrainer.LEARNING_RATE,0.1);
  }
 else   if (ALGORITHM.LR.equals(alg)) {
    params.put(LogisticRegressionTrainer.LEARNING_RATE,0.1);
    params.put(""String_Node_Str"",0.0);
    params.put(""String_Node_Str"",""String_Node_Str"");
  }
  return params;
}",0.982627247790308
32073,"@Override public DTWorkerParams doCompute(WorkerContext<DTMasterParams,DTWorkerParams> context){
  if (context.isFirstIteration()) {
    return new DTWorkerParams();
  }
  DTMasterParams lastMasterResult=context.getLastMasterResult();
  List<TreeNode> trees=lastMasterResult.getTrees();
  Map<Integer,TreeNode> todoNodes=lastMasterResult.getTodoNodes();
  Map<Integer,NodeStats> statistics=new HashMap<Integer,NodeStats>(todoNodes.size(),1f);
  for (  Map.Entry<Integer,TreeNode> entry : todoNodes.entrySet()) {
    List<Integer> features=entry.getValue().getFeatures();
    if (features.isEmpty()) {
      features=getAllValidFeatures();
    }
    Map<Integer,double[]> featureStatistics=new HashMap<Integer,double[]>(features.size(),1f);
    for (    Integer columnNum : features) {
      ColumnConfig columnConfig=this.columnConfigList.get(columnNum);
      if (columnConfig.isNumerical()) {
        int featureStatsSize=columnConfig.getBinBoundary().size() * this.impurity.getStatsSize();
        featureStatistics.put(columnNum,new double[featureStatsSize]);
      }
 else       if (columnConfig.isCategorical()) {
        int featureStatsSize=(columnConfig.getBinCategory().size() + 1) * this.impurity.getStatsSize();
        featureStatistics.put(columnNum,new double[featureStatsSize]);
      }
    }
    statistics.put(entry.getKey(),new NodeStats(entry.getValue().getTreeId(),entry.getValue().getNode().getId(),featureStatistics));
  }
  this.trainingData.reOpen();
  double squareError=0d;
  for (  Data data : this.trainingData) {
    List<Integer> nodeIndexes=new ArrayList<Integer>(trees.size());
    if (this.isRF) {
      for (      TreeNode treeNode : trees) {
        Node predictNode=predictNodeIndex(treeNode.getNode(),data);
        if (predictNode.getPredict() != null) {
          double error=data.output - predictNode.getPredict().getPredict();
          squareError+=error * error;
        }
        int predictNodeIndex=predictNode.getId();
        nodeIndexes.add(predictNodeIndex);
      }
    }
    if (this.isGBDT) {
      if (lastMasterResult.isSwitchToNextTree()) {
        int currTreeIndex=trees.size() - 1;
        if (currTreeIndex >= 1) {
          double predict=predictNodeIndex(trees.get(currTreeIndex - 1).getNode(),data).getPredict().getPredict();
          if (currTreeIndex == 1) {
            data.predict=1.0f * ((float)predict);
          }
 else {
            data.predict=data.predict + (float)(this.learningRate * predict);
          }
          data.output=-loss.computeGradient(data.predict,data.output);
        }
      }
      Node predictNode=predictNodeIndex(trees.get(trees.size() - 1).getNode(),data);
      if (predictNode.getPredict() != null) {
        double error=data.output - predictNode.getPredict().getPredict();
        squareError+=error * error;
      }
      int predictNodeIndex=predictNode.getId();
      nodeIndexes.add(predictNodeIndex);
    }
    for (    Map.Entry<Integer,TreeNode> entry : todoNodes.entrySet()) {
      Node todoNode=entry.getValue().getNode();
      int treeId=entry.getValue().getTreeId();
      int currPredictIndex=0;
      if (this.isRF) {
        currPredictIndex=nodeIndexes.get(entry.getValue().getTreeId());
      }
      if (this.isGBDT) {
        currPredictIndex=nodeIndexes.get(0);
      }
      if (todoNode.getId() == currPredictIndex) {
        List<Integer> features=entry.getValue().getFeatures();
        if (features.isEmpty()) {
          features=getAllValidFeatures();
        }
        for (        Integer columnNum : features) {
          ColumnConfig config=this.columnConfigList.get(columnNum);
          double[] featuerStatistic=statistics.get(entry.getKey()).getFeatureStatistics().get(columnNum);
          float weight=data.subsampleWeights[treeId];
          if (config.isNumerical()) {
            float value=data.numericInputs[this.numericInputIndexMap.get(columnNum)];
            int binIndex=getBinIndex(value,config.getBinBoundary());
            this.impurity.featureUpdate(featuerStatistic,binIndex,data.output,data.significance,weight);
          }
 else           if (config.isCategorical()) {
            String category=data.categoricalInputs[this.categoricalInputIndexMap.get(columnNum)];
            Integer binIndex=this.categoryIndexMap.get(columnNum).get(category);
            this.impurity.featureUpdate(featuerStatistic,binIndex,data.output,data.significance,weight);
          }
 else {
            throw new IllegalStateException(""String_Node_Str"");
          }
        }
      }
    }
  }
  for (  Map.Entry<Integer,NodeStats> entry : statistics.entrySet()) {
    NodeStats nodeStats=entry.getValue();
    LOG.info(""String_Node_Str"",entry.getKey(),nodeStats.getNodeId(),nodeStats.getTreeId());
    Map<Integer,double[]> featureStatistics=nodeStats.getFeatureStatistics();
    for (    Entry<Integer,double[]> feaEntry : featureStatistics.entrySet()) {
      LOG.info(""String_Node_Str"",feaEntry.getKey(),Arrays.toString(feaEntry.getValue()));
    }
  }
  LOG.debug(""String_Node_Str"",statistics);
  return new DTWorkerParams(count,squareError,statistics);
}","@Override public DTWorkerParams doCompute(WorkerContext<DTMasterParams,DTWorkerParams> context){
  if (context.isFirstIteration()) {
    return new DTWorkerParams();
  }
  DTMasterParams lastMasterResult=context.getLastMasterResult();
  List<TreeNode> trees=lastMasterResult.getTrees();
  Map<Integer,TreeNode> todoNodes=lastMasterResult.getTodoNodes();
  Map<Integer,NodeStats> statistics=new HashMap<Integer,NodeStats>(todoNodes.size(),1f);
  for (  Map.Entry<Integer,TreeNode> entry : todoNodes.entrySet()) {
    List<Integer> features=entry.getValue().getFeatures();
    if (features.isEmpty()) {
      features=getAllValidFeatures();
    }
    Map<Integer,double[]> featureStatistics=new HashMap<Integer,double[]>(features.size(),1f);
    for (    Integer columnNum : features) {
      ColumnConfig columnConfig=this.columnConfigList.get(columnNum);
      if (columnConfig.isNumerical()) {
        int featureStatsSize=columnConfig.getBinBoundary().size() * this.impurity.getStatsSize();
        featureStatistics.put(columnNum,new double[featureStatsSize]);
      }
 else       if (columnConfig.isCategorical()) {
        int featureStatsSize=(columnConfig.getBinCategory().size() + 1) * this.impurity.getStatsSize();
        featureStatistics.put(columnNum,new double[featureStatsSize]);
      }
    }
    statistics.put(entry.getKey(),new NodeStats(entry.getValue().getTreeId(),entry.getValue().getNode().getId(),featureStatistics));
  }
  this.trainingData.reOpen();
  double squareError=0d;
  for (  Data data : this.trainingData) {
    List<Integer> nodeIndexes=new ArrayList<Integer>(trees.size());
    if (this.isRF) {
      for (      TreeNode treeNode : trees) {
        Node predictNode=predictNodeIndex(treeNode.getNode(),data);
        if (predictNode.getPredict() != null) {
          double error=data.output - predictNode.getPredict().getPredict();
          squareError+=error * error;
        }
        int predictNodeIndex=predictNode.getId();
        nodeIndexes.add(predictNodeIndex);
      }
    }
    if (this.isGBDT) {
      if (lastMasterResult.isSwitchToNextTree()) {
        int currTreeIndex=trees.size() - 1;
        if (currTreeIndex >= 1) {
          double predict=predictNodeIndex(trees.get(currTreeIndex - 1).getNode(),data).getPredict().getPredict();
          if (currTreeIndex == 1) {
            data.predict=1.0f * ((float)predict);
          }
 else {
            data.predict=data.predict + (float)(this.learningRate * predict);
          }
          data.output=-loss.computeGradient(data.predict,data.output);
        }
      }
      Node predictNode=predictNodeIndex(trees.get(trees.size() - 1).getNode(),data);
      int predictNodeIndex=predictNode.getId();
      nodeIndexes.add(predictNodeIndex);
      squareError+=loss.computeError(data.predict,data.output);
    }
    for (    Map.Entry<Integer,TreeNode> entry : todoNodes.entrySet()) {
      Node todoNode=entry.getValue().getNode();
      int treeId=entry.getValue().getTreeId();
      int currPredictIndex=0;
      if (this.isRF) {
        currPredictIndex=nodeIndexes.get(entry.getValue().getTreeId());
      }
      if (this.isGBDT) {
        currPredictIndex=nodeIndexes.get(0);
      }
      if (todoNode.getId() == currPredictIndex) {
        List<Integer> features=entry.getValue().getFeatures();
        if (features.isEmpty()) {
          features=getAllValidFeatures();
        }
        for (        Integer columnNum : features) {
          ColumnConfig config=this.columnConfigList.get(columnNum);
          double[] featuerStatistic=statistics.get(entry.getKey()).getFeatureStatistics().get(columnNum);
          float weight=data.subsampleWeights[treeId];
          if (config.isNumerical()) {
            float value=data.numericInputs[this.numericInputIndexMap.get(columnNum)];
            int binIndex=getBinIndex(value,config.getBinBoundary());
            this.impurity.featureUpdate(featuerStatistic,binIndex,data.output,data.significance,weight);
          }
 else           if (config.isCategorical()) {
            String category=data.categoricalInputs[this.categoricalInputIndexMap.get(columnNum)];
            Integer binIndex=this.categoryIndexMap.get(columnNum).get(category);
            this.impurity.featureUpdate(featuerStatistic,binIndex,data.output,data.significance,weight);
          }
 else {
            throw new IllegalStateException(""String_Node_Str"");
          }
        }
      }
    }
  }
  for (  Map.Entry<Integer,NodeStats> entry : statistics.entrySet()) {
    NodeStats nodeStats=entry.getValue();
    LOG.info(""String_Node_Str"",entry.getKey(),nodeStats.getNodeId(),nodeStats.getTreeId());
    Map<Integer,double[]> featureStatistics=nodeStats.getFeatureStatistics();
    for (    Entry<Integer,double[]> feaEntry : featureStatistics.entrySet()) {
      LOG.info(""String_Node_Str"",feaEntry.getKey(),Arrays.toString(feaEntry.getValue()));
    }
  }
  LOG.debug(""String_Node_Str"",statistics);
  return new DTWorkerParams(count,squareError,statistics);
}",0.9658035184819134
32074,"@Override public void doWrite(DataOutput out) throws IOException {
  if (parameters != null) {
    out.writeInt(this.parameters.length);
    for (int i=0; i < this.parameters.length; i++) {
      out.writeDouble(this.parameters[i]);
    }
  }
  out.writeDouble(this.trainError);
  out.writeDouble(this.testError);
  out.writeLong(this.trainSize);
  out.writeLong(this.testSize);
}","@Override public void doWrite(DataOutput out) throws IOException {
  if (parameters == null) {
    out.writeInt(0);
  }
 else {
    out.writeInt(this.parameters.length);
    for (int i=0; i < this.parameters.length; i++) {
      out.writeDouble(this.parameters[i]);
    }
  }
  out.writeDouble(this.trainError);
  out.writeDouble(this.testError);
  out.writeLong(this.trainSize);
  out.writeLong(this.testSize);
}",0.9407313997477932
32075,"/** 
 * Loading model according to existing model path.
 * @param modelPath the path to store model
 * @param fs file system used to store model
 * @return model object or null if no modelPath file,
 * @throws IOException if loading file for any IOException
 * @throws GuaguaRuntimeException if any exception to load model object and cast to  {@link BasicNetwork}
 */
public static BasicML loadModel(ModelConfig modelConfig,List<ColumnConfig> columnConfigList,Path modelPath,FileSystem fs) throws IOException {
  if (!fs.exists(modelPath)) {
    return null;
  }
  PersistorRegistry.getInstance().add(new PersistBasicFloatNetwork());
  FSDataInputStream stream=null;
  BufferedReader br=null;
  try {
    stream=fs.open(modelPath);
    if (modelPath.getName().endsWith(LogisticRegressionContants.LR_ALG_NAME.toLowerCase())) {
      br=new BufferedReader(new InputStreamReader(stream));
      return LR.loadFromString(br.readLine());
    }
 else     if (modelPath.getName().endsWith(CommonConstants.RF_ALG_NAME.toLowerCase()) || modelPath.getName().endsWith(CommonConstants.GBDT_ALG_NAME.toLowerCase())) {
      return TreeModel.loadFromStream(stream,columnConfigList);
    }
 else {
      return BasicML.class.cast(EncogDirectoryPersistence.loadObject(stream));
    }
  }
 catch (  Exception e) {
    String msg=""String_Node_Str"" + modelPath;
    throw new ShifuException(ShifuErrorCode.ERROR_FAIL_TO_LOAD_MODEL_FILE,e,msg);
  }
 finally {
    if (br != null) {
      IOUtils.closeQuietly(br);
    }
    if (stream != null) {
      IOUtils.closeQuietly(stream);
    }
  }
}","/** 
 * Loading model according to existing model path.
 * @param modelPath the path to store model
 * @param fs file system used to store model
 * @return model object or null if no modelPath file,
 * @throws IOException if loading file for any IOException
 * @throws GuaguaRuntimeException if any exception to load model object and cast to  {@link BasicNetwork}
 */
public static BasicML loadModel(ModelConfig modelConfig,List<ColumnConfig> columnConfigList,Path modelPath,FileSystem fs) throws IOException {
  if (!fs.exists(modelPath)) {
    return null;
  }
  PersistorRegistry.getInstance().add(new PersistBasicFloatNetwork());
  FSDataInputStream stream=null;
  BufferedReader br=null;
  try {
    stream=fs.open(modelPath);
    if (modelPath.getName().endsWith(LogisticRegressionContants.LR_ALG_NAME.toLowerCase())) {
      br=new BufferedReader(new InputStreamReader(stream));
      return LR.loadFromString(br.readLine());
    }
 else     if (modelPath.getName().endsWith(CommonConstants.RF_ALG_NAME.toLowerCase()) || modelPath.getName().endsWith(CommonConstants.GBDT_ALG_NAME)) {
      return TreeModel.loadFromStream(stream,columnConfigList);
    }
 else {
      return BasicML.class.cast(EncogDirectoryPersistence.loadObject(stream));
    }
  }
 catch (  Exception e) {
    String msg=""String_Node_Str"" + modelPath;
    throw new ShifuException(ShifuErrorCode.ERROR_FAIL_TO_LOAD_MODEL_FILE,e,msg);
  }
 finally {
    if (br != null) {
      IOUtils.closeQuietly(br);
    }
    if (stream != null) {
      IOUtils.closeQuietly(stream);
    }
  }
}",0.995530012771392
32076,"private InternalEntropyInfo getEntropyInterInfo(double[] statsByClasses){
  double sumAll=0;
  for (int i=0; i < statsByClasses.length; i++) {
    sumAll+=statsByClasses[i];
  }
  double impurity=0d;
  int indexOfLargestElement=0;
  double maxElement=Double.MIN_VALUE;
  for (int i=0; i < statsByClasses.length; i++) {
    double rate=statsByClasses[i] / sumAll;
    impurity-=rate * rate;
    if (statsByClasses[i] > maxElement) {
      maxElement=statsByClasses[i];
      indexOfLargestElement=i;
    }
  }
  return new InternalEntropyInfo(sumAll,indexOfLargestElement,impurity);
}","private InternalEntropyInfo getEntropyInterInfo(double[] statsByClasses){
  double sumAll=0;
  for (int i=0; i < statsByClasses.length; i++) {
    sumAll+=statsByClasses[i];
  }
  double impurity=0d;
  int indexOfLargestElement=-1;
  if (sumAll != 0d) {
    double maxElement=Double.MIN_VALUE;
    for (int i=0; i < statsByClasses.length; i++) {
      double rate=statsByClasses[i] / sumAll;
      impurity-=rate * rate;
      if (statsByClasses[i] > maxElement) {
        maxElement=statsByClasses[i];
        indexOfLargestElement=i;
      }
    }
  }
  return new InternalEntropyInfo(sumAll,indexOfLargestElement,impurity);
}",0.9595375722543352
32077,"@Override public GainInfo computeImpurity(double[] stats,ColumnConfig config){
  int numClasses=super.statsSize;
  double[] statsByClasses=new double[numClasses];
  for (int i=0; i < stats.length / numClasses; i++) {
    for (int j=0; j < numClasses; j++) {
      double oneStatValue=stats[i * super.statsSize + j];
      statsByClasses[j]+=oneStatValue;
    }
  }
  InternalEntropyInfo info=getEntropyInterInfo(statsByClasses);
  Predict predict=new Predict(info.indexOfLargestElement,statsByClasses[1] / info.sumAll);
  double[] leftStatByClasses=new double[numClasses];
  double[] rightStatByClasses=new double[numClasses];
  List<GainInfo> internalGainList=new ArrayList<GainInfo>();
  Set<String> leftCategories=config.isCategorical() ? new HashSet<String>() : null;
  for (int i=0; i < (stats.length / numClasses - 1); i++) {
    for (int j=0; j < leftStatByClasses.length; j++) {
      leftStatByClasses[j]+=stats[i * numClasses + j];
    }
    InternalEntropyInfo leftInfo=getEntropyInterInfo(leftStatByClasses);
    Predict leftPredict=new Predict(leftInfo.indexOfLargestElement,leftStatByClasses[1] / leftInfo.sumAll);
    for (int j=0; j < leftStatByClasses.length; j++) {
      rightStatByClasses[j]=statsByClasses[j] - leftStatByClasses[j];
    }
    InternalEntropyInfo rightInfo=getEntropyInterInfo(rightStatByClasses);
    Predict rightPredict=new Predict(rightInfo.indexOfLargestElement,rightStatByClasses[1] / rightInfo.sumAll);
    double gain=info.impurity - (leftInfo.sumAll / info.sumAll) * leftInfo.impurity - (rightInfo.sumAll / info.sumAll) * rightInfo.impurity;
    Split split=null;
    if (config.isCategorical()) {
      leftCategories.add(config.getBinCategory().get(i));
      split=new Split(config.getColumnNum(),FeatureType.CATEGORICAL,0d,leftCategories);
    }
 else {
      split=new Split(config.getColumnNum(),FeatureType.CONTINUOUS,config.getBinBoundary().get(i + 1),null);
    }
    internalGainList.add(new GainInfo(gain,info.impurity,predict,leftInfo.impurity,rightInfo.impurity,leftPredict,rightPredict,split));
  }
  return GainInfo.getGainInfoByMaxGain(internalGainList);
}","@Override public GainInfo computeImpurity(double[] stats,ColumnConfig config){
  int numClasses=super.statsSize;
  double[] statsByClasses=new double[numClasses];
  for (int i=0; i < stats.length / numClasses; i++) {
    for (int j=0; j < numClasses; j++) {
      double oneStatValue=stats[i * super.statsSize + j];
      statsByClasses[j]+=oneStatValue;
    }
  }
  InternalEntropyInfo info=getEntropyInterInfo(statsByClasses);
  Predict predict=new Predict(info.sumAll == 0d ? 0d : statsByClasses[1] / info.sumAll,info.indexOfLargestElement);
  double[] leftStatByClasses=new double[numClasses];
  double[] rightStatByClasses=new double[numClasses];
  List<GainInfo> internalGainList=new ArrayList<GainInfo>();
  Set<String> leftCategories=config.isCategorical() ? new HashSet<String>() : null;
  for (int i=0; i < (stats.length / numClasses - 1); i++) {
    for (int j=0; j < leftStatByClasses.length; j++) {
      leftStatByClasses[j]+=stats[i * numClasses + j];
    }
    InternalEntropyInfo leftInfo=getEntropyInterInfo(leftStatByClasses);
    Predict leftPredict=new Predict(leftInfo.sumAll == 0d ? 0d : leftStatByClasses[1] / leftInfo.sumAll,leftInfo.indexOfLargestElement);
    for (int j=0; j < leftStatByClasses.length; j++) {
      rightStatByClasses[j]=statsByClasses[j] - leftStatByClasses[j];
    }
    InternalEntropyInfo rightInfo=getEntropyInterInfo(rightStatByClasses);
    Predict rightPredict=new Predict(rightInfo.sumAll == 0d ? 0d : rightStatByClasses[1] / rightInfo.sumAll,rightInfo.indexOfLargestElement);
    double gain=info.impurity - (leftInfo.sumAll / info.sumAll) * leftInfo.impurity - (rightInfo.sumAll / info.sumAll) * rightInfo.impurity;
    Split split=null;
    if (config.isCategorical()) {
      leftCategories.add(config.getBinCategory().get(i));
      split=new Split(config.getColumnNum(),FeatureType.CATEGORICAL,0d,leftCategories);
    }
 else {
      split=new Split(config.getColumnNum(),FeatureType.CONTINUOUS,config.getBinBoundary().get(i + 1),null);
    }
    internalGainList.add(new GainInfo(gain,info.impurity,predict,leftInfo.impurity,rightInfo.impurity,leftPredict,rightPredict,split));
  }
  return GainInfo.getGainInfoByMaxGain(internalGainList);
}",0.95
32078,"@Override protected void map(LongWritable key,Text value,Context context) throws IOException, InterruptedException {
  String valueStr=value.toString();
  if (!this.dataPurifier.isFilterOut(valueStr)) {
    return;
  }
  if (valueStr == null || valueStr.length() == 0 || valueStr.trim().length() == 0) {
    LOG.warn(""String_Node_Str"");
    return;
  }
  String[] units=CommonUtils.split(valueStr,this.modelConfig.getDataSetDelimiter());
  String tag=units[this.tagColumnNum];
  if (!this.tags.contains(tag)) {
    if (System.currentTimeMillis() % 20 == 0) {
      LOG.warn(""String_Node_Str"",tag);
    }
    return;
  }
  int i=0;
  for (  String unit : units) {
    if (unit == null || this.modelConfig.getDataSet().getMissingOrInvalidValues().contains(unit.toLowerCase())) {
      i++;
      continue;
    }
    CountAndFrequentItems countAndFrequentItems=this.variableCountMap.get(i);
    if (countAndFrequentItems == null) {
      countAndFrequentItems=new CountAndFrequentItems();
      this.variableCountMap.put(i,countAndFrequentItems);
    }
    countAndFrequentItems.offer(unit);
    i++;
  }
}","@Override protected void map(LongWritable key,Text value,Context context) throws IOException, InterruptedException {
  String valueStr=value.toString();
  if (valueStr == null || valueStr.length() == 0 || valueStr.trim().length() == 0) {
    LOG.warn(""String_Node_Str"");
    return;
  }
  if (!this.dataPurifier.isFilterOut(valueStr)) {
    return;
  }
  String[] units=CommonUtils.split(valueStr,this.modelConfig.getDataSetDelimiter());
  String tag=units[this.tagColumnNum];
  if (!this.tags.contains(tag)) {
    if (System.currentTimeMillis() % 20 == 0) {
      LOG.warn(""String_Node_Str"",tag);
    }
    return;
  }
  int i=0;
  for (  String unit : units) {
    if (unit == null || this.modelConfig.getDataSet().getMissingOrInvalidValues().contains(unit.toLowerCase())) {
      i++;
      continue;
    }
    CountAndFrequentItems countAndFrequentItems=this.variableCountMap.get(i);
    if (countAndFrequentItems == null) {
      countAndFrequentItems=new CountAndFrequentItems();
      this.variableCountMap.put(i,countAndFrequentItems);
    }
    countAndFrequentItems.offer(unit);
    i++;
  }
}",0.9401631912964642
32079,"/** 
 * Mapper implementation includes: 1. Invalid data purifier 2. Column statistics update.
 */
@Override protected void map(LongWritable key,Text value,Context context) throws IOException, InterruptedException {
  String valueStr=value.toString();
  if (!this.dataPurifier.isFilterOut(valueStr)) {
    return;
  }
  if (valueStr == null || valueStr.length() == 0 || valueStr.trim().length() == 0) {
    LOG.warn(""String_Node_Str"");
    return;
  }
  String[] units=CommonUtils.split(valueStr,this.dataSetDelimiter);
  String tag=units[this.tagColumnNum];
  if (modelConfig.isBinaryClassification()) {
    if (tag == null || (!posTags.contains(tag) && !negTags.contains(tag))) {
      return;
    }
  }
 else {
    if (tag == null || (!tags.contains(tag))) {
      return;
    }
  }
  Double weight=this.weightedColumnNum == -1 ? 1.0d : Double.valueOf(units[this.weightedColumnNum]);
  boolean isMissingValue=false;
  boolean isInvalidValue=false;
  for (int i=0; i < units.length; i++) {
    ColumnConfig columnConfig=this.columnConfigList.get(i);
    if (columnConfig.isMeta() || columnConfig.isTarget()) {
      continue;
    }
    isMissingValue=false;
    isInvalidValue=false;
    BinningInfoWritable binningInfoWritable=this.columnBinningInfo.get(i);
    if (binningInfoWritable == null) {
      continue;
    }
    binningInfoWritable.setTotalCount(binningInfoWritable.getTotalCount() + 1L);
    if (columnConfig.isCategorical()) {
      int lastBinIndex=binningInfoWritable.getBinCategories().size();
      int binNum=0;
      if (units[i] == null || missingOrInvalidValues.contains(units[i].toLowerCase())) {
        isMissingValue=true;
      }
 else {
        String str=StringUtils.trim(units[i]);
        binNum=quickLocateCategorialBin(this.categoricalBinMap.get(i),str);
        if (binNum < 0) {
          isInvalidValue=true;
        }
      }
      if (isInvalidValue || isMissingValue) {
        binningInfoWritable.setMissingCount(binningInfoWritable.getMissingCount() + 1L);
        binNum=lastBinIndex;
      }
      if (modelConfig.isBinaryClassification()) {
        if (posTags.contains(tag)) {
          binningInfoWritable.getBinCountPos()[binNum]+=1L;
          binningInfoWritable.getBinWeightPos()[binNum]+=weight;
        }
 else         if (negTags.contains(tag)) {
          binningInfoWritable.getBinCountNeg()[binNum]+=1L;
          binningInfoWritable.getBinWeightNeg()[binNum]+=weight;
        }
      }
    }
 else     if (columnConfig.isNumerical()) {
      int lastBinIndex=binningInfoWritable.getBinBoundaries().size();
      double douVal=0.0;
      if (units[i] == null || units[i].length() == 0) {
        isMissingValue=true;
      }
 else {
        try {
          douVal=Double.parseDouble(units[i].trim());
        }
 catch (        Exception e) {
          isInvalidValue=true;
        }
      }
      if (Double.compare(douVal,modelConfig.getNumericalValueThreshold()) > 0) {
        isInvalidValue=true;
      }
      if (isInvalidValue || isMissingValue) {
        binningInfoWritable.setMissingCount(binningInfoWritable.getMissingCount() + 1L);
        if (modelConfig.isBinaryClassification()) {
          if (posTags.contains(tag)) {
            binningInfoWritable.getBinCountPos()[lastBinIndex]+=1L;
            binningInfoWritable.getBinWeightPos()[lastBinIndex]+=weight;
          }
 else           if (negTags.contains(tag)) {
            binningInfoWritable.getBinCountNeg()[lastBinIndex]+=1L;
            binningInfoWritable.getBinWeightNeg()[lastBinIndex]+=weight;
          }
        }
      }
 else {
        int binNum=getBinNum(binningInfoWritable.getBinBoundaries(),units[i]);
        if (binNum == -1) {
          throw new RuntimeException(""String_Node_Str"");
        }
        if (modelConfig.isBinaryClassification()) {
          if (posTags.contains(tag)) {
            binningInfoWritable.getBinCountPos()[binNum]+=1L;
            binningInfoWritable.getBinWeightPos()[binNum]+=weight;
          }
 else           if (negTags.contains(tag)) {
            binningInfoWritable.getBinCountNeg()[binNum]+=1L;
            binningInfoWritable.getBinWeightNeg()[binNum]+=weight;
          }
        }
        binningInfoWritable.setSum(binningInfoWritable.getSum() + douVal);
        double squaredVal=douVal * douVal;
        binningInfoWritable.setSquaredSum(binningInfoWritable.getSquaredSum() + squaredVal);
        binningInfoWritable.setTripleSum(binningInfoWritable.getTripleSum() + squaredVal * douVal);
        binningInfoWritable.setQuarticSum(binningInfoWritable.getQuarticSum() + squaredVal * squaredVal);
        if (Double.compare(binningInfoWritable.getMax(),douVal) < 0) {
          binningInfoWritable.setMax(douVal);
        }
        if (Double.compare(binningInfoWritable.getMin(),douVal) > 0) {
          binningInfoWritable.setMin(douVal);
        }
      }
    }
  }
}","/** 
 * Mapper implementation includes: 1. Invalid data purifier 2. Column statistics update.
 */
@Override protected void map(LongWritable key,Text value,Context context) throws IOException, InterruptedException {
  String valueStr=value.toString();
  if (valueStr == null || valueStr.length() == 0 || valueStr.trim().length() == 0) {
    LOG.warn(""String_Node_Str"");
    return;
  }
  if (!this.dataPurifier.isFilterOut(valueStr)) {
    return;
  }
  String[] units=CommonUtils.split(valueStr,this.dataSetDelimiter);
  String tag=units[this.tagColumnNum];
  if (modelConfig.isBinaryClassification()) {
    if (tag == null || (!posTags.contains(tag) && !negTags.contains(tag))) {
      return;
    }
  }
 else {
    if (tag == null || (!tags.contains(tag))) {
      return;
    }
  }
  Double weight=this.weightedColumnNum == -1 ? 1.0d : Double.valueOf(units[this.weightedColumnNum]);
  boolean isMissingValue=false;
  boolean isInvalidValue=false;
  for (int i=0; i < units.length; i++) {
    ColumnConfig columnConfig=this.columnConfigList.get(i);
    if (columnConfig.isMeta() || columnConfig.isTarget()) {
      continue;
    }
    isMissingValue=false;
    isInvalidValue=false;
    BinningInfoWritable binningInfoWritable=this.columnBinningInfo.get(i);
    if (binningInfoWritable == null) {
      continue;
    }
    binningInfoWritable.setTotalCount(binningInfoWritable.getTotalCount() + 1L);
    if (columnConfig.isCategorical()) {
      int lastBinIndex=binningInfoWritable.getBinCategories().size();
      int binNum=0;
      if (units[i] == null || missingOrInvalidValues.contains(units[i].toLowerCase())) {
        isMissingValue=true;
      }
 else {
        String str=StringUtils.trim(units[i]);
        binNum=quickLocateCategorialBin(this.categoricalBinMap.get(i),str);
        if (binNum < 0) {
          isInvalidValue=true;
        }
      }
      if (isInvalidValue || isMissingValue) {
        binningInfoWritable.setMissingCount(binningInfoWritable.getMissingCount() + 1L);
        binNum=lastBinIndex;
      }
      if (modelConfig.isBinaryClassification()) {
        if (posTags.contains(tag)) {
          binningInfoWritable.getBinCountPos()[binNum]+=1L;
          binningInfoWritable.getBinWeightPos()[binNum]+=weight;
        }
 else         if (negTags.contains(tag)) {
          binningInfoWritable.getBinCountNeg()[binNum]+=1L;
          binningInfoWritable.getBinWeightNeg()[binNum]+=weight;
        }
      }
    }
 else     if (columnConfig.isNumerical()) {
      int lastBinIndex=binningInfoWritable.getBinBoundaries().size();
      double douVal=0.0;
      if (units[i] == null || units[i].length() == 0) {
        isMissingValue=true;
      }
 else {
        try {
          douVal=Double.parseDouble(units[i].trim());
        }
 catch (        Exception e) {
          isInvalidValue=true;
        }
      }
      if (Double.compare(douVal,modelConfig.getNumericalValueThreshold()) > 0) {
        isInvalidValue=true;
      }
      if (isInvalidValue || isMissingValue) {
        binningInfoWritable.setMissingCount(binningInfoWritable.getMissingCount() + 1L);
        if (modelConfig.isBinaryClassification()) {
          if (posTags.contains(tag)) {
            binningInfoWritable.getBinCountPos()[lastBinIndex]+=1L;
            binningInfoWritable.getBinWeightPos()[lastBinIndex]+=weight;
          }
 else           if (negTags.contains(tag)) {
            binningInfoWritable.getBinCountNeg()[lastBinIndex]+=1L;
            binningInfoWritable.getBinWeightNeg()[lastBinIndex]+=weight;
          }
        }
      }
 else {
        int binNum=getBinNum(binningInfoWritable.getBinBoundaries(),units[i]);
        if (binNum == -1) {
          throw new RuntimeException(""String_Node_Str"");
        }
        if (modelConfig.isBinaryClassification()) {
          if (posTags.contains(tag)) {
            binningInfoWritable.getBinCountPos()[binNum]+=1L;
            binningInfoWritable.getBinWeightPos()[binNum]+=weight;
          }
 else           if (negTags.contains(tag)) {
            binningInfoWritable.getBinCountNeg()[binNum]+=1L;
            binningInfoWritable.getBinWeightNeg()[binNum]+=weight;
          }
        }
        binningInfoWritable.setSum(binningInfoWritable.getSum() + douVal);
        double squaredVal=douVal * douVal;
        binningInfoWritable.setSquaredSum(binningInfoWritable.getSquaredSum() + squaredVal);
        binningInfoWritable.setTripleSum(binningInfoWritable.getTripleSum() + squaredVal * douVal);
        binningInfoWritable.setQuarticSum(binningInfoWritable.getQuarticSum() + squaredVal * squaredVal);
        if (Double.compare(binningInfoWritable.getMax(),douVal) < 0) {
          binningInfoWritable.setMax(douVal);
        }
        if (Double.compare(binningInfoWritable.getMin(),douVal) > 0) {
          binningInfoWritable.setMin(douVal);
        }
      }
    }
  }
}",0.9864225468010698
32080,"@Override public void readFields(DataInput in) throws IOException {
  int len=in.readInt();
  hyperBytes=new byte[len];
  in.readFully(hyperBytes);
  len=in.readInt();
  frequetItems=new HashSet<String>(len);
  for (int i=0; i < len; i++) {
    int unitLen=in.readInt();
    byte[] bytes=new byte[unitLen];
    in.readFully(bytes);
    frequetItems.add(new String(bytes,Constants.UTF8_CHARSET));
  }
}","@Override public void readFields(DataInput in) throws IOException {
  int len=in.readInt();
  hyperBytes=new byte[len];
  in.readFully(hyperBytes);
  len=in.readInt();
  frequetItems=new HashSet<String>(len);
  for (int i=0; i < len; i++) {
    int unitLen=in.readInt();
    byte[] bytes=new byte[unitLen];
    in.readFully(bytes);
    frequetItems.add(new String(bytes,Constants.DEFAULT_CHARSET));
  }
}",0.991304347826087
32081,"@Override public void write(DataOutput out) throws IOException {
  out.writeInt(hyperBytes.length);
  out.write(hyperBytes,0,hyperBytes.length);
  int setSize=Math.min(frequetItems.size(),FREQUET_ITEM_MAX_SIZE);
  out.writeInt(setSize);
  Iterator<String> iter=frequetItems.iterator();
  int i=0;
  while (i < setSize) {
    String unit=iter.next();
    out.writeInt(unit.length());
    byte[] bytes=unit.getBytes(Constants.UTF8_CHARSET);
    out.write(bytes,0,bytes.length);
    i++;
  }
}","@Override public void write(DataOutput out) throws IOException {
  out.writeInt(hyperBytes.length);
  out.write(hyperBytes,0,hyperBytes.length);
  int setSize=Math.min(frequetItems.size(),FREQUET_ITEM_MAX_SIZE);
  out.writeInt(setSize);
  Iterator<String> iter=frequetItems.iterator();
  int i=0;
  while (i < setSize) {
    String unit=iter.next();
    out.writeInt(unit.length());
    byte[] bytes=unit.getBytes(Constants.DEFAULT_CHARSET);
    out.write(bytes,0,bytes.length);
    i++;
  }
}",0.992878942014242
32082,"@JsonIgnore public List<String> getTags(){
  List<String> tags=new ArrayList<String>();
  if (CollectionUtils.isNotEmpty(dataSet.getPosTags())) {
    for (    String tag : dataSet.getPosTags()) {
      tags.add(tag);
    }
  }
  if (CollectionUtils.isNotEmpty(dataSet.getNegTags())) {
    for (    String tag : dataSet.getNegTags()) {
      tags.add(tag);
    }
  }
  return tags;
}","@JsonIgnore public List<String> getTags(){
  return getTags(dataSet.getPosTags(),dataSet.getNegTags());
}",0.3901437371663244
32083,"/** 
 * Flattened tags for multiple classification. '1', '2|3' will be flattened to '1', '2', '3'. While '2' and '3' are combined to one class.
 */
@JsonIgnore public List<String> getFlattenTags(){
  List<String> tags=new ArrayList<String>();
  if (CollectionUtils.isNotEmpty(dataSet.getPosTags())) {
    for (    String tag : dataSet.getPosTags()) {
      if (tag.contains(""String_Node_Str"")) {
        for (        String inTag : tag.split(""String_Node_Str"")) {
          if (StringUtils.isNotBlank(inTag)) {
            tags.add(inTag);
          }
        }
      }
 else {
        tags.add(tag);
      }
    }
  }
  if (CollectionUtils.isNotEmpty(dataSet.getNegTags())) {
    for (    String tag : dataSet.getNegTags()) {
      if (tag.contains(""String_Node_Str"")) {
        for (        String inTag : tag.split(""String_Node_Str"")) {
          if (StringUtils.isNotBlank(inTag)) {
            tags.add(inTag);
          }
        }
      }
 else {
        tags.add(tag);
      }
    }
  }
  return tags;
}","@JsonIgnore public List<String> getFlattenTags(List<String> tags1,List<String> tags2){
  List<String> tags=new ArrayList<String>();
  if (CollectionUtils.isNotEmpty(tags1)) {
    for (    String tag : tags1) {
      if (tag.contains(""String_Node_Str"")) {
        for (        String inTag : tag.split(""String_Node_Str"")) {
          if (StringUtils.isNotBlank(inTag)) {
            tags.add(inTag);
          }
        }
      }
 else {
        tags.add(tag);
      }
    }
  }
  if (CollectionUtils.isNotEmpty(tags2)) {
    for (    String tag : tags2) {
      if (tag.contains(""String_Node_Str"")) {
        for (        String inTag : tag.split(""String_Node_Str"")) {
          if (StringUtils.isNotBlank(inTag)) {
            tags.add(inTag);
          }
        }
      }
 else {
        tags.add(tag);
      }
    }
  }
  return tags;
}",0.8460291734197731
32084,"@JsonIgnore public List<Set<String>> getSetTags(){
  List<String> tags=getTags();
  List<Set<String>> result=new ArrayList<Set<String>>();
  for (  String tag : tags) {
    Set<String> set=new HashSet<String>(16);
    if (tag.contains(""String_Node_Str"")) {
      for (      String inTag : tag.split(""String_Node_Str"")) {
        if (StringUtils.isNotBlank(inTag)) {
          set.add(inTag);
        }
      }
    }
 else {
      set.add(tag);
    }
    result.add(set);
  }
  return result;
}","@JsonIgnore public List<Set<String>> getSetTags(){
  return getSetTags(dataSet.getPosTags(),dataSet.getNegTags());
}",0.2167487684729064
32085,"@SuppressWarnings(""String_Node_Str"") public void computeConfusionMatixForMultipleClassification(long records) throws IOException {
  PathFinder pathFinder=new PathFinder(modelConfig);
  SourceType sourceType=evalConfig.getDataSet().getSource();
  List<Scanner> scanners=ShifuFileUtils.getDataScanners(pathFinder.getEvalScorePath(evalConfig,sourceType),sourceType);
  boolean isDir=ShifuFileUtils.isDir(pathFinder.getEvalScorePath(evalConfig,sourceType),sourceType);
  int cnt=0;
  Set<String> posTags=new HashSet<String>(modelConfig.getPosTags(evalConfig));
  Set<String> negTags=new HashSet<String>(modelConfig.getNegTags(evalConfig));
  List<String> tags=getTags(modelConfig.getPosTags(evalConfig),modelConfig.getNegTags(evalConfig));
  int classes=tags.size();
  long[][] confusionMatrix=new long[classes][classes];
  for (  Scanner scanner : scanners) {
    while (scanner.hasNext()) {
      if ((++cnt) % 100000 == 0) {
        log.info(""String_Node_Str"" + cnt + ""String_Node_Str"");
      }
      String[] raw=scanner.nextLine().split(""String_Node_Str"");
      if (!isDir && cnt == 1) {
        continue;
      }
      String tag=raw[targetColumnIndex];
      if (StringUtils.isBlank(tag) || (!posTags.contains(tag) && !negTags.contains(tag))) {
        if (rd.nextDouble() < 0.01) {
          log.warn(""String_Node_Str"");
        }
        continue;
      }
      double[] scores=new double[classes];
      int maxIndex=-1;
      double maxScore=Double.NEGATIVE_INFINITY;
      for (int i=0; i < classes; i++) {
        for (int j=0; j < multiClassModelCnt; j++) {
          double dd=NumberFormatUtils.getDouble(raw[this.multiClassScore1Index + j * classes + i],0d);
          scores[i]+=dd;
        }
        scores[i]/=multiClassModelCnt;
        if (scores[i] > maxScore) {
          maxIndex=i;
          maxScore=scores[i];
        }
      }
      int tagIndex=tags.indexOf(tag);
      confusionMatrix[tagIndex][maxIndex]+=1L;
    }
    scanner.close();
  }
  Path localEvalMatrixFile=new Path(pathFinder.getEvalLocalMultiMatrixFile(evalConfig.getName()));
  log.info(""String_Node_Str"",localEvalMatrixFile);
  if (HDFSUtils.getLocalFS().exists(localEvalMatrixFile)) {
    HDFSUtils.getLocalFS().delete(localEvalMatrixFile);
  }
  BufferedWriter writer=null;
  try {
    writer=ShifuFileUtils.getWriter(localEvalMatrixFile.toString(),SourceType.LOCAL);
    writer.write(""String_Node_Str"" + StringUtils.join(tags,""String_Node_Str"") + ""String_Node_Str"");
    for (int i=0; i < confusionMatrix.length; i++) {
      StringBuilder sb=new StringBuilder(300);
      sb.append(tags.get(i));
      for (int j=0; j < confusionMatrix[i].length; j++) {
        sb.append(""String_Node_Str"").append(confusionMatrix[i][j]);
      }
      sb.append(""String_Node_Str"");
      writer.write(tags.get(i) + ""String_Node_Str"" + sb.toString());
    }
  }
  finally {
    writer.close();
  }
  log.info(""String_Node_Str"");
  log.info(""String_Node_Str"",tags.toString());
  for (int i=0; i < confusionMatrix.length; i++) {
    log.info(""String_Node_Str"",tags.get(i),Arrays.toString(confusionMatrix[i]));
  }
}","@SuppressWarnings(""String_Node_Str"") public void computeConfusionMatixForMultipleClassification(long records) throws IOException {
  PathFinder pathFinder=new PathFinder(modelConfig);
  SourceType sourceType=evalConfig.getDataSet().getSource();
  List<Scanner> scanners=ShifuFileUtils.getDataScanners(pathFinder.getEvalScorePath(evalConfig,sourceType),sourceType);
  boolean isDir=ShifuFileUtils.isDir(pathFinder.getEvalScorePath(evalConfig,sourceType),sourceType);
  int cnt=0;
  Set<String> posTags=new HashSet<String>(modelConfig.getPosTags(evalConfig));
  Set<String> negTags=new HashSet<String>(modelConfig.getNegTags(evalConfig));
  Set<String> tagSet=new HashSet<String>(modelConfig.getFlattenTags(modelConfig.getPosTags(evalConfig),modelConfig.getNegTags(evalConfig)));
  List<Set<String>> tags=modelConfig.getSetTags(modelConfig.getPosTags(evalConfig),modelConfig.getNegTags(evalConfig));
  int classes=tags.size();
  long[][] confusionMatrix=new long[classes][classes];
  for (  Scanner scanner : scanners) {
    while (scanner.hasNext()) {
      if ((++cnt) % 100000 == 0) {
        log.info(""String_Node_Str"" + cnt + ""String_Node_Str"");
      }
      String[] raw=scanner.nextLine().split(""String_Node_Str"");
      if (!isDir && cnt == 1) {
        continue;
      }
      String tag=raw[targetColumnIndex];
      if (modelConfig.isBinaryClassification()) {
        if (StringUtils.isBlank(tag) || (!posTags.contains(tag) && !negTags.contains(tag))) {
          if (rd.nextDouble() < 0.01) {
            log.warn(""String_Node_Str"");
          }
          continue;
        }
      }
 else {
        if (StringUtils.isBlank(tag) || !tagSet.contains(tag)) {
          if (rd.nextDouble() < 0.01) {
            log.warn(""String_Node_Str"");
          }
          continue;
        }
      }
      double[] scores=new double[classes];
      int maxIndex=-1;
      double maxScore=Double.NEGATIVE_INFINITY;
      for (int i=0; i < classes; i++) {
        for (int j=0; j < multiClassModelCnt; j++) {
          double dd=NumberFormatUtils.getDouble(raw[this.multiClassScore1Index + j * classes + i],0d);
          scores[i]+=dd;
        }
        scores[i]/=multiClassModelCnt;
        if (scores[i] > maxScore) {
          maxIndex=i;
          maxScore=scores[i];
        }
      }
      int tagIndex=-1;
      for (int i=0; i < tags.size(); i++) {
        if (tags.get(i).contains(tag)) {
          tagIndex=i;
          break;
        }
      }
      confusionMatrix[tagIndex][maxIndex]+=1L;
    }
    scanner.close();
  }
  Path localEvalMatrixFile=new Path(pathFinder.getEvalLocalMultiMatrixFile(evalConfig.getName()));
  log.info(""String_Node_Str"",localEvalMatrixFile);
  if (HDFSUtils.getLocalFS().exists(localEvalMatrixFile)) {
    HDFSUtils.getLocalFS().delete(localEvalMatrixFile);
  }
  BufferedWriter writer=null;
  try {
    writer=ShifuFileUtils.getWriter(localEvalMatrixFile.toString(),SourceType.LOCAL);
    writer.write(""String_Node_Str"" + StringUtils.join(tags,""String_Node_Str"") + ""String_Node_Str"");
    for (int i=0; i < confusionMatrix.length; i++) {
      StringBuilder sb=new StringBuilder(300);
      sb.append(tags.get(i));
      for (int j=0; j < confusionMatrix[i].length; j++) {
        sb.append(""String_Node_Str"").append(confusionMatrix[i][j]);
      }
      sb.append(""String_Node_Str"");
      writer.write(tags.get(i) + ""String_Node_Str"" + sb.toString());
    }
  }
  finally {
    writer.close();
  }
  log.info(""String_Node_Str"");
  log.info(""String_Node_Str"",tags.toString());
  for (int i=0; i < confusionMatrix.length; i++) {
    log.info(""String_Node_Str"",tags.get(i),Arrays.toString(confusionMatrix[i]));
  }
}",0.9078518518518518
32086,"public ScoreObject score(MLDataPair pair,Map<String,String> rawDataMap){
  if (pair == null) {
    return null;
  }
  List<Integer> scores=new ArrayList<Integer>();
  for (  BasicML model : models) {
    if (model instanceof BasicNetwork) {
      BasicNetwork network=(BasicNetwork)model;
      if (network.getInputCount() != pair.getInput().size()) {
        log.error(""String_Node_Str"" + network.getInputCount() + ""String_Node_Str""+ pair.getInput().size());
        continue;
      }
      MLData score=network.compute(pair.getInput());
      if (modelConfig.isBinaryClassification()) {
        scores.add(toScore(score.getData(0)));
      }
 else {
        double[] outputs=score.getData();
        for (        double d : outputs) {
          scores.add(toScore(d));
        }
      }
    }
 else     if (model instanceof SVM) {
      SVM svm=(SVM)model;
      if (svm.getInputCount() != pair.getInput().size()) {
        log.error(""String_Node_Str"" + svm.getInputCount() + ""String_Node_Str""+ pair.getInput().size());
        continue;
      }
      MLData score=svm.compute(pair.getInput());
      scores.add(toScore(score.getData(0)));
    }
 else     if (model instanceof LR) {
      LR lr=(LR)model;
      if (lr.getInputCount() != pair.getInput().size()) {
        log.error(""String_Node_Str"" + lr.getInputCount() + ""String_Node_Str""+ pair.getInput().size());
        continue;
      }
      MLData score=lr.compute(pair.getInput());
      scores.add(toScore(score.getData(0)));
    }
 else {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
  Integer tag=(int)pair.getIdeal().getData(0);
  if (scores.size() == 0) {
    log.error(""String_Node_Str"");
    return null;
  }
  return new ScoreObject(scores,tag);
}","public ScoreObject score(MLDataPair pair,Map<String,String> rawDataMap){
  if (pair == null) {
    return null;
  }
  List<Integer> scores=new ArrayList<Integer>();
  for (  BasicML model : models) {
    if (model instanceof BasicNetwork) {
      BasicNetwork network=(BasicNetwork)model;
      if (network.getInputCount() != pair.getInput().size()) {
        log.error(""String_Node_Str"" + network.getInputCount() + ""String_Node_Str""+ pair.getInput().size());
        continue;
      }
      MLData score=network.compute(pair.getInput());
      if (modelConfig != null && modelConfig.isBinaryClassification()) {
        scores.add(toScore(score.getData(0)));
      }
 else {
        double[] outputs=score.getData();
        for (        double d : outputs) {
          scores.add(toScore(d));
        }
      }
    }
 else     if (model instanceof SVM) {
      SVM svm=(SVM)model;
      if (svm.getInputCount() != pair.getInput().size()) {
        log.error(""String_Node_Str"" + svm.getInputCount() + ""String_Node_Str""+ pair.getInput().size());
        continue;
      }
      MLData score=svm.compute(pair.getInput());
      scores.add(toScore(score.getData(0)));
    }
 else     if (model instanceof LR) {
      LR lr=(LR)model;
      if (lr.getInputCount() != pair.getInput().size()) {
        log.error(""String_Node_Str"" + lr.getInputCount() + ""String_Node_Str""+ pair.getInput().size());
        continue;
      }
      MLData score=lr.compute(pair.getInput());
      scores.add(toScore(score.getData(0)));
    }
 else {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
  Integer tag=(int)pair.getIdeal().getData(0);
  if (scores.size() == 0) {
    log.error(""String_Node_Str"");
    return null;
  }
  return new ScoreObject(scores,tag);
}",0.9934116299054712
32087,"private static String limitedFrequentItems(Set<String> fis){
  StringBuilder sb=new StringBuilder(200);
  int size=Math.min(fis.size(),CountAndFrequentItemsWritable.FREQUET_ITEM_MAX_SIZE);
  Iterator<String> iterator=fis.iterator();
  int i=0;
  while (i < size) {
    String next=iterator.next().replaceAll(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"");
    sb.append(next);
    if (i != size - 1) {
      sb.append(""String_Node_Str"");
    }
    i+=1;
  }
  return sb.toString();
}","private static String limitedFrequentItems(Set<String> fis){
  StringBuilder sb=new StringBuilder(200);
  int size=Math.min(fis.size(),CountAndFrequentItemsWritable.FREQUET_ITEM_MAX_SIZE * 10);
  Iterator<String> iterator=fis.iterator();
  int i=0;
  while (i < size) {
    String next=iterator.next().replaceAll(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"");
    sb.append(next);
    if (i != size - 1) {
      sb.append(""String_Node_Str"");
    }
    i+=1;
  }
  return sb.toString();
}",0.9951969260326607
32088,"@Override public void load(GuaguaWritableAdapter<LongWritable> currentKey,GuaguaWritableAdapter<Tuple> currentValue,WorkerContext<NNParams,NNParams> workerContext){
  this.initFieldList();
  super.count+=1;
  if ((super.count) % 100000 == 0) {
    LOG.info(""String_Node_Str"",super.count);
  }
  double baggingSampleRate=super.modelConfig.getBaggingSampleRate();
  if (!super.modelConfig.isFixInitialInput() && Double.compare(Math.random(),baggingSampleRate) >= 0) {
    return;
  }
  double[] inputs=new double[super.inputNodeCount];
  double[] ideal=new double[super.outputNodeCount];
  if (super.isDry) {
    addDataPairToDataSet(0,new BasicMLDataPair(new BasicMLData(inputs),new BasicMLData(ideal)));
    return;
  }
  long hashcode=0;
  double significance=NNConstants.DEFAULT_SIGNIFICANCE_VALUE;
  int index=0, inputsIndex=0, outputIndex=0;
  for (  Object element : currentValue.getWritable()) {
    double doubleValue=0d;
    if (element != null) {
      if (element instanceof Double) {
        doubleValue=(Double)element;
      }
 else {
        doubleValue=NumberFormatUtils.getDouble(element.toString().trim(),0d);
      }
    }
    if (index == (super.inputNodeCount + super.outputNodeCount)) {
      if (element != null && element instanceof Double) {
        significance=(Double)element;
      }
 else {
        significance=NumberFormatUtils.getDouble(element.toString().trim(),NNConstants.DEFAULT_SIGNIFICANCE_VALUE);
        ;
      }
      break;
    }
 else {
      ColumnConfig columnConfig=super.columnConfigList.get(requiredFieldList.getFields().get(index).getIndex());
      if (columnConfig != null && columnConfig.isTarget()) {
        ideal[outputIndex++]=doubleValue;
      }
 else {
        inputs[inputsIndex++]=doubleValue;
        hashcode=hashcode * 31 + Double.valueOf(doubleValue).hashCode();
      }
    }
    index+=1;
  }
  long longBaggingSampleRate=Double.valueOf(baggingSampleRate * 100).longValue();
  if (super.modelConfig.isFixInitialInput() && hashcode % 100 >= longBaggingSampleRate) {
    return;
  }
  super.sampleCount+=1;
  MLDataPair pair=new BasicMLDataPair(new BasicMLData(inputs),new BasicMLData(ideal));
  pair.setSignificance(significance);
  addDataPairToDataSet(hashcode,pair);
}","@Override public void load(GuaguaWritableAdapter<LongWritable> currentKey,GuaguaWritableAdapter<Tuple> currentValue,WorkerContext<NNParams,NNParams> workerContext){
  this.initFieldList();
  super.count+=1;
  if ((super.count) % 100000 == 0) {
    LOG.info(""String_Node_Str"",super.count);
  }
  double baggingSampleRate=super.modelConfig.getBaggingSampleRate();
  if (!super.modelConfig.isFixInitialInput() && Double.compare(Math.random(),baggingSampleRate) >= 0) {
    return;
  }
  double[] inputs=new double[super.inputNodeCount];
  double[] ideal=new double[super.outputNodeCount];
  if (super.isDry) {
    addDataPairToDataSet(0,new BasicMLDataPair(new BasicMLData(inputs),new BasicMLData(ideal)));
    return;
  }
  long hashcode=0;
  double significance=NNConstants.DEFAULT_SIGNIFICANCE_VALUE;
  int index=0, inputsIndex=0, outputIndex=0;
  Tuple tuple=currentValue.getWritable();
  for (int i=0; i < tuple.size(); i++) {
    Object element=null;
    try {
      element=tuple.get(i);
    }
 catch (    ExecException e) {
      throw new GuaguaRuntimeException(e);
    }
    double doubleValue=0d;
    if (element != null) {
      if (element instanceof Double) {
        doubleValue=(Double)element;
      }
 else {
        doubleValue=NumberFormatUtils.getDouble(element.toString().trim(),0d);
      }
    }
    if (index == (super.inputNodeCount + super.outputNodeCount)) {
      if (element != null && element instanceof Double) {
        significance=(Double)element;
      }
 else {
        significance=NumberFormatUtils.getDouble(element.toString().trim(),NNConstants.DEFAULT_SIGNIFICANCE_VALUE);
        ;
      }
      break;
    }
 else {
      ColumnConfig columnConfig=super.columnConfigList.get(requiredFieldList.getFields().get(index).getIndex());
      if (columnConfig != null && columnConfig.isTarget()) {
        ideal[outputIndex++]=doubleValue;
      }
 else {
        inputs[inputsIndex++]=doubleValue;
        hashcode=hashcode * 31 + Double.valueOf(doubleValue).hashCode();
      }
    }
    index+=1;
  }
  long longBaggingSampleRate=Double.valueOf(baggingSampleRate * 100).longValue();
  if (super.modelConfig.isFixInitialInput() && hashcode % 100 >= longBaggingSampleRate) {
    return;
  }
  super.sampleCount+=1;
  MLDataPair pair=new BasicMLDataPair(new BasicMLData(inputs),new BasicMLData(ideal));
  pair.setSignificance(significance);
  addDataPairToDataSet(hashcode,pair);
}",0.9471195184866724
32089,"@Override public void initialize(GuaguaFileSplit split) throws IOException {
  ReadSupport<Tuple> readSupport=getReadSupportInstance(this.conf);
  this.parquetRecordReader=new ParquetRecordReader<Tuple>(readSupport,getFilter(this.conf));
  ParquetInputSplit parquetInputSplit=new ParquetInputSplit(new Path(split.getPath()),split.getOffset(),split.getOffset() + split.getLength(),split.getLength(),null,null);
  try {
    this.parquetRecordReader.initialize(parquetInputSplit,new TaskAttemptContextImpl(this.conf,new TaskAttemptID(""String_Node_Str"",-1,TaskType.MAP,-1,-1)));
  }
 catch (  InterruptedException e) {
    throw new GuaguaRuntimeException(e);
  }
}","@Override public void initialize(GuaguaFileSplit split) throws IOException {
  ReadSupport<Tuple> readSupport=getReadSupportInstance(this.conf);
  this.parquetRecordReader=new ParquetRecordReader<Tuple>(readSupport,getFilter(this.conf));
  ParquetInputSplit parquetInputSplit=new ParquetInputSplit(new Path(split.getPath()),split.getOffset(),split.getOffset() + split.getLength(),split.getLength(),null,null);
  try {
    this.parquetRecordReader.initialize(parquetInputSplit,buildContext());
  }
 catch (  InterruptedException e) {
    throw new GuaguaRuntimeException(e);
  }
}",0.9241935483870968
32090,"@Override public LogisticRegressionParams compute(MasterContext<LogisticRegressionParams,LogisticRegressionParams> context){
  if (context.isFirstIteration()) {
    init(context);
    weights=new double[this.inputNum];
    for (int i=0; i < weights.length; i++) {
      weights[i]=nextDouble(-1,1);
    }
    return new LogisticRegressionParams(weights);
  }
 else {
    double[] gradients=new double[this.inputNum];
    double trainError=0.0d, testError=0d;
    long trainSize=0, testSize=0;
    for (    LogisticRegressionParams param : context.getWorkerResults()) {
      if (param != null) {
        for (int i=0; i < gradients.length; i++) {
          gradients[i]+=param.getParameters()[i];
        }
        trainError+=param.getTrainError();
        testError+=param.getTestError();
        trainSize+=param.getTrainSize();
        testSize+=param.getTestSize();
      }
    }
    for (int i=0; i < weights.length; i++) {
      weights[i]-=learningRate * ((gradients[i] + this.regularizedConstant * weights[i]) / trainSize);
    }
    double reg=this.regularizedParameter(this.regularizedConstant,trainSize);
    LOG.debug(""String_Node_Str"",Arrays.toString(this.weights));
    double finalTrainError=trainError / trainSize + reg;
    double finalTestError=testError / testSize + reg;
    LOG.info(""String_Node_Str"",context.getCurrentIteration(),finalTrainError,finalTestError);
    return new LogisticRegressionParams(weights,finalTrainError,finalTestError,trainSize,testSize);
  }
}","@Override public LogisticRegressionParams compute(MasterContext<LogisticRegressionParams,LogisticRegressionParams> context){
  if (context.isFirstIteration()) {
    init(context);
    weights=new double[this.inputNum + 1];
    for (int i=0; i < weights.length; i++) {
      weights[i]=nextDouble(-1,1);
    }
    return new LogisticRegressionParams(weights);
  }
 else {
    double[] gradients=new double[this.inputNum + 1];
    double trainError=0.0d, testError=0d;
    long trainSize=0, testSize=0;
    for (    LogisticRegressionParams param : context.getWorkerResults()) {
      if (param != null) {
        for (int i=0; i < gradients.length; i++) {
          gradients[i]+=param.getParameters()[i];
        }
        trainError+=param.getTrainError();
        testError+=param.getTestError();
        trainSize+=param.getTrainSize();
        testSize+=param.getTestSize();
      }
    }
    if (this.weightCalculator == null) {
      this.weightCalculator=new Weight(weights.length,trainSize,learningRate,""String_Node_Str"");
    }
    this.weights=this.weightCalculator.calculateWeights(this.weights,gradients);
    double reg=this.regularizedParameter(this.regularizedConstant,trainSize);
    LOG.debug(""String_Node_Str"",Arrays.toString(this.weights));
    double finalTrainError=trainError / trainSize + reg;
    double finalTestError=testError / testSize + reg;
    LOG.info(""String_Node_Str"",context.getCurrentIteration(),finalTrainError,finalTestError);
    return new LogisticRegressionParams(weights,finalTrainError,finalTestError,trainSize,testSize);
  }
}",0.8925187847108788
32091,"public final double nextDouble(final double min,final double max){
  final double range=max - min;
  return (range * RANDOM.nextDouble()) + min;
}","public final double nextDouble(final double min,final double max){
  final double range=max - min;
  return (range * Math.random()) + min;
}",0.93006993006993
32092,"@Override public LogisticRegressionParams doCompute(WorkerContext<LogisticRegressionParams,LogisticRegressionParams> context){
  if (context.isFirstIteration()) {
    return new LogisticRegressionParams();
  }
 else {
    this.weights=context.getLastMasterResult().getParameters();
    double[] gradients=new double[this.inputNum];
    double trainingFinalError=0.0d;
    double testingFinalError=0.0d;
    long trainingSize=this.trainingData.size();
    long testingSize=this.testingData.size();
    this.trainingData.reOpen();
    for (    Data data : trainingData) {
      double result=sigmoid(data.inputs,this.weights);
      double error=result - data.outputs[0];
      trainingFinalError+=error * error;
      for (int i=0; i < gradients.length; i++) {
        gradients[i]+=error * data.inputs[i] * data.getSignificance();
      }
    }
    this.testingData.reOpen();
    for (    Data data : testingData) {
      double result=sigmoid(data.inputs,this.weights);
      double error=result - data.outputs[0];
      testingFinalError+=error * error;
    }
    double trainingReg=this.regularizedParameter(this.regularizedConstant,trainingSize);
    double testingReg=this.regularizedParameter(this.regularizedConstant,testingSize);
    LOG.info(""String_Node_Str"",context.getCurrentIteration(),trainingFinalError / trainingSize + trainingReg);
    LOG.info(""String_Node_Str"",context.getCurrentIteration(),testingFinalError / testingSize + testingReg);
    return new LogisticRegressionParams(gradients,trainingFinalError,testingFinalError,trainingSize,testingSize);
  }
}","@Override public LogisticRegressionParams doCompute(WorkerContext<LogisticRegressionParams,LogisticRegressionParams> context){
  if (context.isFirstIteration()) {
    return new LogisticRegressionParams();
  }
 else {
    this.weights=context.getLastMasterResult().getParameters();
    double[] gradients=new double[this.inputNum + 1];
    double trainingFinalError=0.0d;
    double testingFinalError=0.0d;
    long trainingSize=this.trainingData.size();
    long testingSize=this.testingData.size();
    this.trainingData.reOpen();
    for (    Data data : trainingData) {
      double result=sigmoid(data.inputs,this.weights);
      double error=data.outputs[0] - result;
      trainingFinalError+=error * error;
      for (int i=0; i < gradients.length; i++) {
        if (i < gradients.length - 1) {
          gradients[i]+=error * data.inputs[i] * (result * (1d - result) + 0.1d)* data.getSignificance();
        }
 else {
          gradients[i]+=error * 1d * (result * (1d - result) + 0.1d)* data.getSignificance();
        }
      }
    }
    this.testingData.reOpen();
    for (    Data data : testingData) {
      double result=sigmoid(data.inputs,this.weights);
      double error=result - data.outputs[0];
      testingFinalError+=error * error;
    }
    double trainingReg=this.regularizedParameter(this.regularizedConstant,trainingSize);
    double testingReg=this.regularizedParameter(this.regularizedConstant,testingSize);
    LOG.info(""String_Node_Str"",context.getCurrentIteration(),trainingFinalError / trainingSize + trainingReg);
    LOG.info(""String_Node_Str"",context.getCurrentIteration(),testingFinalError / testingSize + testingReg);
    return new LogisticRegressionParams(gradients,trainingFinalError,testingFinalError,trainingSize,testingSize);
  }
}",0.934685356397256
32093,"/** 
 * Compute sigmoid value by dot operation of two vectors.
 */
private double sigmoid(double[] inputs,double[] weights){
  double value=0.0d;
  for (int i=0; i < weights.length; i++) {
    value+=weights[i] * inputs[i];
  }
  return 1.0d / (1.0d + BoundMath.exp(-1 * value));
}","/** 
 * Compute sigmoid value by dot operation of two vectors.
 */
private double sigmoid(double[] inputs,double[] weights){
  double value=0.0d;
  for (int i=0; i < inputs.length; i++) {
    value+=weights[i] * inputs[i];
  }
  value+=weights[inputs.length] * 1d;
  return 1.0d / (1.0d + BoundMath.exp(-1 * value));
}",0.9215358931552587
32094,"@Override protected void postLoad(WorkerContext<LogisticRegressionParams,LogisticRegressionParams> context){
  this.trainingData.switchState();
  this.testingData.switchState();
}","@Override protected void postLoad(WorkerContext<LogisticRegressionParams,LogisticRegressionParams> context){
  this.trainingData.switchState();
  this.testingData.switchState();
  LOG.info(""String_Node_Str"",this.count);
  LOG.info(""String_Node_Str"",this.modelConfig.getBaggingSampleRate());
  LOG.info(""String_Node_Str"",this.modelConfig.isBaggingWithReplacement());
  LOG.info(""String_Node_Str"",this.modelConfig.getCrossValidationRate());
  LOG.info(""String_Node_Str"",this.trainingData.size());
  LOG.info(""String_Node_Str"",this.testingData.size());
}",0.4904109589041096
32095,"public Weight(int numWeight,double numTrainSize,double rate,String algorithm){
  this.lastDelta=new double[numWeight];
  this.lastGradient=new double[numWeight];
  this.eps=this.outputEpsilon / numTrainSize;
  this.shrink=rate / (1.0 + rate);
  this.setLearningRate(rate);
  this.algorithm=algorithm;
  this.updateValues=new double[numWeight];
  for (int i=0; i < this.updateValues.length; i++) {
    this.updateValues[i]=DEFAULT_INITIAL_UPDATE;
    this.lastDelta[i]=0;
  }
}","public Weight(int numWeight,double numTrainSize,double rate,String algorithm){
  this.lastDelta=new double[numWeight];
  this.lastGradient=new double[numWeight];
  this.eps=this.outputEpsilon / numTrainSize;
  this.shrink=rate / (1.0 + rate);
  this.learningRate=rate;
  this.algorithm=algorithm;
  this.updateValues=new double[numWeight];
  for (int i=0; i < this.updateValues.length; i++) {
    this.updateValues[i]=DEFAULT_INITIAL_UPDATE;
    this.lastDelta[i]=0;
  }
}",0.9831223628691984
32096,"@Override public NNParams doCompute(WorkerContext<NNParams,NNParams> workerContext){
  if (this.isDry || workerContext.isFirstIteration()) {
    return buildEmptyNNParams(workerContext);
  }
  if (workerContext.getLastMasterResult() == null) {
    LOG.warn(""String_Node_Str"");
    return null;
  }
  LOG.debug(""String_Node_Str"",workerContext.getLastMasterResult());
  if (gradient == null) {
    initGradient(this.trainingData,this.testingData,workerContext.getLastMasterResult().getWeights(),this.isCrossOver);
  }
  if (this.isCrossOver) {
    this.gradient.setSeed(System.currentTimeMillis());
  }
  this.gradient.setWeights(workerContext.getLastMasterResult().getWeights());
  for (int i=0; i < epochsPerIteration; i++) {
    this.gradient.run();
    this.gradient.setWeights(this.gradient.getWeights());
  }
  double trainError=this.gradient.getError();
  double testError=this.testingData.getRecordCount() > 0 ? (this.gradient.calculateError()) : this.gradient.getError();
  LOG.info(""String_Node_Str"",new Object[]{workerContext.getCurrentIteration(),trainError,(this.testingData.getRecordCount() > 0 ? testError : ""String_Node_Str"")});
  NNParams params=new NNParams();
  params.setTestError(testError);
  params.setTrainError(trainError);
  params.setGradients(this.gradient.getGradients());
  params.setWeights(new double[0]);
  params.setTrainSize(this.trainingData.getRecordCount());
  return params;
}","@Override public NNParams doCompute(WorkerContext<NNParams,NNParams> workerContext){
  if (this.isDry || workerContext.isFirstIteration()) {
    return buildEmptyNNParams(workerContext);
  }
  if (workerContext.getLastMasterResult() == null) {
    LOG.warn(""String_Node_Str"");
    return null;
  }
  LOG.debug(""String_Node_Str"",workerContext.getLastMasterResult());
  double[] weights=workerContext.getLastMasterResult().getWeights();
  if (gradient == null) {
    initGradient(this.trainingData,this.testingData,weights,this.isCrossOver);
  }
  if (this.isCrossOver) {
    this.gradient.setSeed(System.currentTimeMillis());
  }
  this.gradient.setWeights(weights);
  for (int i=0; i < epochsPerIteration; i++) {
    this.gradient.run();
    this.gradient.setWeights(this.gradient.getWeights());
  }
  double trainError=this.gradient.getError();
  double testError=this.testingData.getRecordCount() > 0 ? (this.gradient.calculateError()) : this.gradient.getError();
  LOG.info(""String_Node_Str"",new Object[]{workerContext.getCurrentIteration(),trainError,(this.testingData.getRecordCount() > 0 ? testError : ""String_Node_Str"")});
  NNParams params=new NNParams();
  params.setTestError(testError);
  params.setTrainError(trainError);
  params.setGradients(this.gradient.getGradients());
  params.setWeights(new double[0]);
  params.setTrainSize(this.trainingData.getRecordCount());
  return params;
}",0.9377888375399928
32097,"@SuppressWarnings({""String_Node_Str""}) private NNParams initWeights(){
  NNParams params=new NNParams();
  int[] inputAndOutput=NNUtils.getInputOutputCandidateCounts(this.columnConfigList);
  int inputNodeCount=inputAndOutput[0] == 0 ? inputAndOutput[2] : inputAndOutput[0];
  int outputNodeCount=inputAndOutput[1];
  int numLayers=(Integer)this.modelConfig.getParams().get(NNTrainer.NUM_HIDDEN_LAYERS);
  List<String> actFunc=(List<String>)this.modelConfig.getParams().get(NNTrainer.ACTIVATION_FUNC);
  List<Integer> hiddenNodeList=(List<Integer>)this.modelConfig.getParams().get(NNTrainer.NUM_HIDDEN_NODES);
  BasicNetwork network=NNUtils.generateNetwork(inputNodeCount,outputNodeCount,numLayers,actFunc,hiddenNodeList);
  params.setTrainError(0);
  params.setTestError(0);
  params.setGradients(new double[0]);
  params.setWeights(network.getFlat().getWeights());
  return params;
}","@SuppressWarnings({""String_Node_Str""}) private NNParams initWeights(){
  NNParams params=new NNParams();
  int[] inputAndOutput=NNUtils.getInputOutputCandidateCounts(this.columnConfigList);
  int inputNodeCount=inputAndOutput[0] == 0 ? inputAndOutput[2] : inputAndOutput[0];
  int outputNodeCount=inputAndOutput[1];
  int numLayers=(Integer)this.modelConfig.getParams().get(NNTrainer.NUM_HIDDEN_LAYERS);
  List<String> actFunc=(List<String>)this.modelConfig.getParams().get(NNTrainer.ACTIVATION_FUNC);
  List<Integer> hiddenNodeList=(List<Integer>)this.modelConfig.getParams().get(NNTrainer.NUM_HIDDEN_NODES);
  LOG.info(""String_Node_Str"",inputNodeCount,outputNodeCount);
  BasicNetwork network=NNUtils.generateNetwork(inputNodeCount,outputNodeCount,numLayers,actFunc,hiddenNodeList);
  params.setTrainError(0);
  params.setTestError(0);
  params.setGradients(new double[0]);
  params.setWeights(network.getFlat().getWeights());
  return params;
}",0.9661572052401748
32098,"@Override public void initRecordReader(GuaguaFileSplit fileSplit) throws IOException {
  Configuration conf=new Configuration();
  String pigSchema=super.props.getProperty(""String_Node_Str"");
  LOG.info(""String_Node_Str"",pigSchema);
  conf.set(""String_Node_Str"",pigSchema);
  String requiredFieldList=super.props.getProperty(""String_Node_Str"");
  conf.set(""String_Node_Str"",requiredFieldList);
  LOG.info(""String_Node_Str"",requiredFieldList);
  String indexAccess=super.props.getProperty(""String_Node_Str"");
  conf.set(""String_Node_Str"",indexAccess);
  LOG.info(""String_Node_Str"",indexAccess);
  super.setRecordReader(new GuaguaParquetRecordReader(conf,fileSplit));
}","@Override public void initRecordReader(GuaguaFileSplit fileSplit) throws IOException {
  Configuration conf=new Configuration();
  String pigSchema=super.props.getProperty(""String_Node_Str"");
  LOG.debug(""String_Node_Str"",pigSchema);
  conf.set(""String_Node_Str"",pigSchema);
  String requiredFieldList=super.props.getProperty(""String_Node_Str"");
  conf.set(""String_Node_Str"",requiredFieldList);
  LOG.debug(""String_Node_Str"",requiredFieldList);
  String indexAccess=super.props.getProperty(""String_Node_Str"");
  conf.set(""String_Node_Str"",indexAccess);
  LOG.debug(""String_Node_Str"",indexAccess);
  super.setRecordReader(new GuaguaParquetRecordReader(conf,fileSplit));
}",0.9798055347793568
32099,"@Override public void load(GuaguaWritableAdapter<LongWritable> currentKey,GuaguaWritableAdapter<Tuple> currentValue,WorkerContext<NNParams,NNParams> workerContext){
  this.initFieldList();
  super.count+=1;
  if ((super.count) % 100000 == 0) {
    LOG.info(""String_Node_Str"",super.count);
  }
  double baggingSampleRate=super.modelConfig.getBaggingSampleRate();
  if (!super.modelConfig.isFixInitialInput() && Double.compare(Math.random(),baggingSampleRate) >= 0) {
    return;
  }
  double[] inputs=new double[super.inputNodeCount];
  double[] ideal=new double[super.outputNodeCount];
  if (super.isDry) {
    addDataPairToDataSet(0,new BasicMLDataPair(new BasicMLData(inputs),new BasicMLData(ideal)));
    return;
  }
  long hashcode=0;
  double significance=NNConstants.DEFAULT_SIGNIFICANCE_VALUE;
  int index=0, inputsIndex=0, outputIndex=0;
  Tuple tuple=currentValue.getWritable();
  for (int i=0; i < tuple.size(); i++) {
    Object element=null;
    try {
      element=tuple.get(i);
    }
 catch (    ExecException e) {
      throw new GuaguaRuntimeException(e);
    }
    double doubleValue=0d;
    if (element != null) {
      if (element instanceof Double) {
        doubleValue=(Double)element;
      }
 else {
        doubleValue=NumberFormatUtils.getDouble(element.toString().trim(),0d);
      }
    }
    if (index == (super.inputNodeCount + super.outputNodeCount)) {
      if (element != null && element instanceof Double) {
        significance=(Double)element;
      }
 else {
        significance=NumberFormatUtils.getDouble(element.toString().trim(),NNConstants.DEFAULT_SIGNIFICANCE_VALUE);
        ;
      }
      break;
    }
 else {
      ColumnConfig columnConfig=super.columnConfigList.get(requiredFieldList.getFields().get(index).getIndex());
      if (columnConfig != null && columnConfig.isTarget()) {
        ideal[outputIndex++]=doubleValue;
      }
 else {
        inputs[inputsIndex++]=doubleValue;
        hashcode=hashcode * 31 + Double.valueOf(doubleValue).hashCode();
      }
    }
    index+=1;
  }
  long longBaggingSampleRate=Double.valueOf(baggingSampleRate * 100).longValue();
  if (super.modelConfig.isFixInitialInput() && hashcode % 100 >= longBaggingSampleRate) {
    return;
  }
  super.sampleCount+=1;
  MLDataPair pair=new BasicMLDataPair(new BasicMLData(inputs),new BasicMLData(ideal));
  pair.setSignificance(significance);
  addDataPairToDataSet(hashcode,pair);
}","@Override public void load(GuaguaWritableAdapter<LongWritable> currentKey,GuaguaWritableAdapter<Tuple> currentValue,WorkerContext<NNParams,NNParams> workerContext){
  this.initFieldList();
  super.count+=1;
  if ((super.count) % 100000 == 0) {
    LOG.info(""String_Node_Str"",super.count);
  }
  double baggingSampleRate=super.modelConfig.getBaggingSampleRate();
  if (!super.modelConfig.isFixInitialInput() && Double.compare(Math.random(),baggingSampleRate) >= 0) {
    return;
  }
  double[] inputs=new double[super.inputNodeCount];
  double[] ideal=new double[super.outputNodeCount];
  if (super.isDry) {
    addDataPairToDataSet(0,new BasicMLDataPair(new BasicMLData(inputs),new BasicMLData(ideal)));
    return;
  }
  long hashcode=0;
  double significance=NNConstants.DEFAULT_SIGNIFICANCE_VALUE;
  int index=0, inputsIndex=0, outputIndex=0;
  Tuple tuple=currentValue.getWritable();
  for (int i=0; i < tuple.size(); i++) {
    Object element=null;
    try {
      element=tuple.get(i);
    }
 catch (    ExecException e) {
      throw new GuaguaRuntimeException(e);
    }
    double doubleValue=0d;
    if (element != null) {
      if (element instanceof Double) {
        doubleValue=(Double)element;
      }
 else {
        doubleValue=NumberFormatUtils.getDouble(element.toString().trim(),0d);
      }
    }
    if (index == (super.inputNodeCount + super.outputNodeCount)) {
      if (element != null && element instanceof Double) {
        significance=(Double)element;
      }
 else {
        significance=NumberFormatUtils.getDouble(element.toString().trim(),NNConstants.DEFAULT_SIGNIFICANCE_VALUE);
        ;
      }
      break;
    }
 else {
      int columnIndex=requiredFieldList.getFields().get(index).getIndex();
      if (columnIndex >= super.columnConfigList.size()) {
        if (element != null && element instanceof Double) {
          significance=(Double)element;
        }
 else {
          significance=NumberFormatUtils.getDouble(element.toString().trim(),NNConstants.DEFAULT_SIGNIFICANCE_VALUE);
          ;
        }
        break;
      }
 else {
        ColumnConfig columnConfig=super.columnConfigList.get(columnIndex);
        if (columnConfig != null && columnConfig.isTarget()) {
          ideal[outputIndex++]=doubleValue;
        }
 else {
          if (super.inputNodeCount == super.candidateCount) {
            if (columnConfig != null && !columnConfig.isMeta() && !columnConfig.isTarget() && CommonUtils.isGoodCandidate(columnConfig)) {
              inputs[inputsIndex++]=doubleValue;
              hashcode=hashcode * 31 + Double.valueOf(doubleValue).hashCode();
            }
          }
 else {
            if (columnConfig != null && !columnConfig.isMeta() && !columnConfig.isTarget() && columnConfig.isFinalSelect()) {
              inputs[inputsIndex++]=doubleValue;
              hashcode=hashcode * 31 + Double.valueOf(doubleValue).hashCode();
            }
          }
        }
      }
    }
    index+=1;
  }
  long longBaggingSampleRate=Double.valueOf(baggingSampleRate * 100).longValue();
  if (super.modelConfig.isFixInitialInput() && hashcode % 100 >= longBaggingSampleRate) {
    return;
  }
  super.sampleCount+=1;
  MLDataPair pair=new BasicMLDataPair(new BasicMLData(inputs),new BasicMLData(ideal));
  pair.setSignificance(significance);
  addDataPairToDataSet(hashcode,pair);
}",0.792354474370113
32100,"private void initFieldList(){
  if (requiredFieldList == null) {
    try {
      requiredFieldList=(RequiredFieldList)ObjectSerializer.deserialize(super.props.getProperty(""String_Node_Str""));
      LOG.debug(""String_Node_Str"",requiredFieldList);
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
  }
}","private void initFieldList(){
  if (requiredFieldList == null) {
    try {
      requiredFieldList=(RequiredFieldList)ObjectSerializer.deserialize(super.props.getProperty(""String_Node_Str""));
      LOG.info(""String_Node_Str"",requiredFieldList);
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
  }
}",0.9863013698630136
32101,"/** 
 * Get input nodes number (final select) and output nodes number from column config, and candidate input node number. <p> If number of column in final-select is 0, which means to select all non meta and non target columns. So the input number is set to all candidates.
 * @throws NullPointerException if columnConfigList or ColumnConfig object in columnConfigList is null.
 */
public static int[] getInputOutputCandidateCounts(List<ColumnConfig> columnConfigList){
  int input=0, output=0, candidate=0;
  for (  ColumnConfig config : columnConfigList) {
    if (!config.isTarget() && !config.isMeta()) {
      candidate++;
    }
    if (config.isFinalSelect()) {
      input++;
    }
    if (config.isTarget()) {
      output++;
    }
  }
  return new int[]{input,output,candidate};
}","/** 
 * Get input nodes number (final select) and output nodes number from column config, and candidate input node number. <p> If number of column in final-select is 0, which means to select all non meta and non target columns. So the input number is set to all candidates.
 * @throws NullPointerException if columnConfigList or ColumnConfig object in columnConfigList is null.
 */
public static int[] getInputOutputCandidateCounts(List<ColumnConfig> columnConfigList){
  @SuppressWarnings(""String_Node_Str"") int input=0, output=0, totalCandidate=0, goodCandidate=0;
  for (  ColumnConfig config : columnConfigList) {
    if (!config.isTarget() && !config.isMeta()) {
      totalCandidate++;
      if (CommonUtils.isGoodCandidate(config)) {
        goodCandidate++;
      }
    }
    if (config.isFinalSelect() && !config.isTarget() && !config.isMeta()) {
      input++;
    }
    if (config.isTarget()) {
      output++;
    }
  }
  return new int[]{input,output,goodCandidate};
}",0.8395480225988701
32102,"@Override public void initRecordReader(GuaguaFileSplit fileSplit) throws IOException {
  super.setRecordReader(new GuaguaLineRecordReader());
  super.getRecordReader().initialize(fileSplit);
}","@Override public void initRecordReader(GuaguaFileSplit fileSplit) throws IOException {
  super.setRecordReader(new GuaguaLineRecordReader(fileSplit));
}",0.877906976744186
32103,"@Override public void load(GuaguaWritableAdapter<LongWritable> currentKey,GuaguaWritableAdapter<Text> currentValue,WorkerContext<NNParams,NNParams> workerContext){
  super.count+=1;
  if ((super.count) % 100000 == 0) {
    LOG.info(""String_Node_Str"",super.count);
  }
  double baggingSampleRate=super.modelConfig.getBaggingSampleRate();
  if (!super.modelConfig.isFixInitialInput() && Double.compare(Math.random(),baggingSampleRate) >= 0) {
    return;
  }
  double[] inputs=new double[super.inputNodeCount];
  double[] ideal=new double[super.outputNodeCount];
  if (super.isDry) {
    addDataPairToDataSet(0,new BasicMLDataPair(new BasicMLData(inputs),new BasicMLData(ideal)));
    return;
  }
  long hashcode=0;
  double significance=NNConstants.DEFAULT_SIGNIFICANCE_VALUE;
  int index=0, inputsIndex=0, outputIndex=0;
  for (  String input : DEFAULT_SPLITTER.split(currentValue.getWritable().toString())) {
    double doubleValue=NumberFormatUtils.getDouble(input.trim(),0.0d);
    if (index == super.columnConfigList.size()) {
      significance=NumberFormatUtils.getDouble(input,NNConstants.DEFAULT_SIGNIFICANCE_VALUE);
      break;
    }
 else {
      ColumnConfig columnConfig=super.columnConfigList.get(index);
      if (columnConfig != null && columnConfig.isTarget()) {
        ideal[outputIndex++]=doubleValue;
      }
 else {
        if (super.inputNodeCount == super.candidateCount) {
          if (CommonUtils.isGoodCandidate(columnConfig)) {
            inputs[inputsIndex++]=doubleValue;
            hashcode=hashcode * 31 + Double.valueOf(doubleValue).hashCode();
          }
        }
 else {
          if (columnConfig != null && !columnConfig.isMeta() && !columnConfig.isTarget() && columnConfig.isFinalSelect()) {
            inputs[inputsIndex++]=doubleValue;
            hashcode=hashcode * 31 + Double.valueOf(doubleValue).hashCode();
          }
        }
      }
    }
    index+=1;
  }
  long longBaggingSampleRate=Double.valueOf(baggingSampleRate * 100).longValue();
  if (super.modelConfig.isFixInitialInput() && hashcode % 100 >= longBaggingSampleRate) {
    return;
  }
  super.sampleCount+=1;
  MLDataPair pair=new BasicMLDataPair(new BasicMLData(inputs),new BasicMLData(ideal));
  pair.setSignificance(significance);
  addDataPairToDataSet(hashcode,pair);
}","@Override public void load(GuaguaWritableAdapter<LongWritable> currentKey,GuaguaWritableAdapter<Text> currentValue,WorkerContext<NNParams,NNParams> workerContext){
  super.count+=1;
  if ((super.count) % 100000 == 0) {
    LOG.info(""String_Node_Str"",super.count);
  }
  double baggingSampleRate=super.modelConfig.getBaggingSampleRate();
  if (!super.modelConfig.isFixInitialInput() && Double.compare(Math.random(),baggingSampleRate) >= 0) {
    return;
  }
  double[] inputs=new double[super.inputNodeCount];
  double[] ideal=new double[super.outputNodeCount];
  if (super.isDry) {
    addDataPairToDataSet(0,new BasicMLDataPair(new BasicMLData(inputs),new BasicMLData(ideal)));
    return;
  }
  long hashcode=0;
  double significance=NNConstants.DEFAULT_SIGNIFICANCE_VALUE;
  int index=0, inputsIndex=0, outputIndex=0;
  for (  String input : DEFAULT_SPLITTER.split(currentValue.getWritable().toString())) {
    double doubleValue=NumberFormatUtils.getDouble(input.trim(),0.0d);
    if (index == super.columnConfigList.size()) {
      significance=NumberFormatUtils.getDouble(input,NNConstants.DEFAULT_SIGNIFICANCE_VALUE);
      break;
    }
 else {
      ColumnConfig columnConfig=super.columnConfigList.get(index);
      if (columnConfig != null && columnConfig.isTarget()) {
        ideal[outputIndex++]=doubleValue;
      }
 else {
        if (super.inputNodeCount == super.candidateCount) {
          if (!columnConfig.isMeta() && !columnConfig.isTarget() && CommonUtils.isGoodCandidate(columnConfig)) {
            inputs[inputsIndex++]=doubleValue;
            hashcode=hashcode * 31 + Double.valueOf(doubleValue).hashCode();
          }
        }
 else {
          if (columnConfig != null && !columnConfig.isMeta() && !columnConfig.isTarget() && columnConfig.isFinalSelect()) {
            inputs[inputsIndex++]=doubleValue;
            hashcode=hashcode * 31 + Double.valueOf(doubleValue).hashCode();
          }
        }
      }
    }
    index+=1;
  }
  long longBaggingSampleRate=Double.valueOf(baggingSampleRate * 100).longValue();
  if (super.modelConfig.isFixInitialInput() && hashcode % 100 >= longBaggingSampleRate) {
    return;
  }
  super.sampleCount+=1;
  MLDataPair pair=new BasicMLDataPair(new BasicMLData(inputs),new BasicMLData(ideal));
  pair.setSignificance(significance);
  addDataPairToDataSet(hashcode,pair);
}",0.9883470004315926
32104,"protected void runDistributedTrain() throws IOException, InterruptedException, ClassNotFoundException {
  LOG.info(""String_Node_Str"",isDryTrain ? ""String_Node_Str"" : ""String_Node_Str"");
  Configuration conf=new Configuration();
  SourceType sourceType=super.getModelConfig().getDataSet().getSource();
  final List<String> args=new ArrayList<String>();
  prepareCommonParams(args,sourceType);
  FileSystem fileSystem=ShifuFileUtils.getFileSystemBySourceType(sourceType);
  Path tmpModelsPath=fileSystem.makeQualified(new Path(super.getPathFinder().getPathBySourceType(new Path(Constants.TMP,Constants.DEFAULT_MODELS_TMP_FOLDER),sourceType)));
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,NNConstants.NN_TMP_MODELS_FOLDER,tmpModelsPath.toString()));
  int baggingNum=isForVarSelect ? 1 : super.getModelConfig().getBaggingNum();
  long start=System.currentTimeMillis();
  LOG.info(""String_Node_Str"",baggingNum);
  boolean isParallel=Boolean.valueOf(Environment.getProperty(SHIFU_DTRAIN_PARALLEL,SHIFU_DEFAULT_DTRAIN_PARALLEL)).booleanValue();
  GuaguaMapReduceClient guaguaClient;
  if (modelConfig.getNormalize().getIsParquet()) {
    guaguaClient=new GuaguaParquetMapReduceClient();
    RequiredFieldList requiredFieldList=new RequiredFieldList();
    int[] inputOutputIndex=NNUtils.getInputOutputCandidateCounts(this.columnConfigList);
    int inputNodeCount=inputOutputIndex[0] == 0 ? inputOutputIndex[2] : inputOutputIndex[0];
    int candidateCount=inputOutputIndex[2];
    for (    ColumnConfig columnConfig : super.columnConfigList) {
      if (inputNodeCount == candidateCount) {
        if (CommonUtils.isGoodCandidate(columnConfig)) {
          requiredFieldList.add(new RequiredField(columnConfig.getColumnName(),columnConfig.getColumnNum(),null,DataType.DOUBLE));
        }
 else         if (columnConfig.isTarget()) {
          requiredFieldList.add(new RequiredField(columnConfig.getColumnName(),columnConfig.getColumnNum(),null,DataType.INTEGER));
        }
      }
 else {
        if (columnConfig.isFinalSelect()) {
          requiredFieldList.add(new RequiredField(columnConfig.getColumnName(),columnConfig.getColumnNum(),null,DataType.DOUBLE));
        }
 else         if (columnConfig.isTarget()) {
          requiredFieldList.add(new RequiredField(columnConfig.getColumnName(),columnConfig.getColumnNum(),null,DataType.INTEGER));
        }
      }
    }
    requiredFieldList.add(new RequiredField(""String_Node_Str"",columnConfigList.size(),null,DataType.DOUBLE));
    args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,""String_Node_Str"",serializeRequiredFieldList(requiredFieldList)));
    args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,""String_Node_Str"",""String_Node_Str""));
  }
 else {
    guaguaClient=new GuaguaMapReduceClient();
  }
  List<String> progressLogList=new ArrayList<String>(baggingNum);
  for (int i=0; i < baggingNum; i++) {
    List<String> localArgs=new ArrayList<String>(args);
    localArgs.add(""String_Node_Str"");
    localArgs.add(String.format(""String_Node_Str"",super.getModelConfig().getModelSetName(),i + 1));
    LOG.info(""String_Node_Str"",(i + 1));
    String modelName=getModelName(i);
    Path modelPath=fileSystem.makeQualified(new Path(super.getPathFinder().getModelsPath(sourceType),modelName));
    checkContinuousTraining(fileSystem,localArgs,modelPath);
    localArgs.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,NNConstants.GUAGUA_NN_OUTPUT,modelPath.toString()));
    localArgs.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,NNConstants.NN_TRAINER_ID,String.valueOf(i + 1)));
    final String progressLogFile=getProgressLogFile(i + 1);
    progressLogList.add(progressLogFile);
    localArgs.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,NNConstants.NN_PROGRESS_FILE,progressLogFile));
    String hdpVersion=HDPUtils.getHdpVersionForHDP224();
    if (StringUtils.isNotBlank(hdpVersion)) {
      localArgs.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,""String_Node_Str"",hdpVersion));
      HDPUtils.addFileToClassPath(HDPUtils.findContainingFile(""String_Node_Str""),conf);
      HDPUtils.addFileToClassPath(HDPUtils.findContainingFile(""String_Node_Str""),conf);
      HDPUtils.addFileToClassPath(HDPUtils.findContainingFile(""String_Node_Str""),conf);
      HDPUtils.addFileToClassPath(HDPUtils.findContainingFile(""String_Node_Str""),conf);
    }
    if (isParallel) {
      guaguaClient.addJob(localArgs.toArray(new String[0]));
    }
 else {
      TailThread tailThread=startTailThread(new String[]{progressLogFile});
      guaguaClient.createJob(localArgs.toArray(new String[0])).waitForCompletion(true);
      stopTailThread(tailThread);
    }
  }
  if (isParallel) {
    TailThread tailThread=startTailThread(progressLogList.toArray(new String[0]));
    guaguaClient.run();
    stopTailThread(tailThread);
  }
  for (int i=0; i < baggingNum; i++) {
    String modelName=getModelName(i);
    Path modelPath=fileSystem.makeQualified(new Path(super.getPathFinder().getModelsPath(sourceType),modelName));
    copyModelToLocal(modelName,modelPath,sourceType);
  }
  copyTmpModelsToLocal(tmpModelsPath,sourceType);
  LOG.info(""String_Node_Str"",System.currentTimeMillis() - start);
}","protected void runDistributedTrain() throws IOException, InterruptedException, ClassNotFoundException {
  LOG.info(""String_Node_Str"",isDryTrain ? ""String_Node_Str"" : ""String_Node_Str"");
  Configuration conf=new Configuration();
  SourceType sourceType=super.getModelConfig().getDataSet().getSource();
  final List<String> args=new ArrayList<String>();
  prepareCommonParams(args,sourceType);
  FileSystem fileSystem=ShifuFileUtils.getFileSystemBySourceType(sourceType);
  Path tmpModelsPath=fileSystem.makeQualified(new Path(super.getPathFinder().getPathBySourceType(new Path(Constants.TMP,Constants.DEFAULT_MODELS_TMP_FOLDER),sourceType)));
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,NNConstants.NN_TMP_MODELS_FOLDER,tmpModelsPath.toString()));
  int baggingNum=isForVarSelect ? 1 : super.getModelConfig().getBaggingNum();
  long start=System.currentTimeMillis();
  LOG.info(""String_Node_Str"",baggingNum);
  boolean isParallel=Boolean.valueOf(Environment.getProperty(SHIFU_DTRAIN_PARALLEL,SHIFU_DEFAULT_DTRAIN_PARALLEL)).booleanValue();
  GuaguaMapReduceClient guaguaClient;
  if (modelConfig.getNormalize().getIsParquet()) {
    guaguaClient=new GuaguaParquetMapReduceClient();
    RequiredFieldList requiredFieldList=new RequiredFieldList();
    int[] inputOutputIndex=NNUtils.getInputOutputCandidateCounts(this.columnConfigList);
    int inputNodeCount=inputOutputIndex[0] == 0 ? inputOutputIndex[2] : inputOutputIndex[0];
    int candidateCount=inputOutputIndex[2];
    for (    ColumnConfig columnConfig : super.columnConfigList) {
      if (columnConfig.isTarget()) {
        requiredFieldList.add(new RequiredField(columnConfig.getColumnName(),columnConfig.getColumnNum(),null,DataType.FLOAT));
      }
 else {
        if (inputNodeCount == candidateCount) {
          if (!columnConfig.isMeta() && !columnConfig.isTarget() && CommonUtils.isGoodCandidate(columnConfig)) {
            requiredFieldList.add(new RequiredField(columnConfig.getColumnName(),columnConfig.getColumnNum(),null,DataType.FLOAT));
          }
        }
 else {
          if (!columnConfig.isMeta() && !columnConfig.isTarget() && columnConfig.isFinalSelect()) {
            requiredFieldList.add(new RequiredField(columnConfig.getColumnName(),columnConfig.getColumnNum(),null,DataType.FLOAT));
          }
        }
      }
    }
    requiredFieldList.add(new RequiredField(""String_Node_Str"",columnConfigList.size(),null,DataType.DOUBLE));
    args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,""String_Node_Str"",serializeRequiredFieldList(requiredFieldList)));
    args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,""String_Node_Str"",""String_Node_Str""));
  }
 else {
    guaguaClient=new GuaguaMapReduceClient();
  }
  List<String> progressLogList=new ArrayList<String>(baggingNum);
  for (int i=0; i < baggingNum; i++) {
    List<String> localArgs=new ArrayList<String>(args);
    localArgs.add(""String_Node_Str"");
    localArgs.add(String.format(""String_Node_Str"",super.getModelConfig().getModelSetName(),i + 1));
    LOG.info(""String_Node_Str"",(i + 1));
    String modelName=getModelName(i);
    Path modelPath=fileSystem.makeQualified(new Path(super.getPathFinder().getModelsPath(sourceType),modelName));
    checkContinuousTraining(fileSystem,localArgs,modelPath);
    localArgs.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,NNConstants.GUAGUA_NN_OUTPUT,modelPath.toString()));
    localArgs.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,NNConstants.NN_TRAINER_ID,String.valueOf(i + 1)));
    final String progressLogFile=getProgressLogFile(i + 1);
    progressLogList.add(progressLogFile);
    localArgs.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,NNConstants.NN_PROGRESS_FILE,progressLogFile));
    String hdpVersion=HDPUtils.getHdpVersionForHDP224();
    if (StringUtils.isNotBlank(hdpVersion)) {
      localArgs.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,""String_Node_Str"",hdpVersion));
      HDPUtils.addFileToClassPath(HDPUtils.findContainingFile(""String_Node_Str""),conf);
      HDPUtils.addFileToClassPath(HDPUtils.findContainingFile(""String_Node_Str""),conf);
      HDPUtils.addFileToClassPath(HDPUtils.findContainingFile(""String_Node_Str""),conf);
      HDPUtils.addFileToClassPath(HDPUtils.findContainingFile(""String_Node_Str""),conf);
    }
    if (isParallel) {
      guaguaClient.addJob(localArgs.toArray(new String[0]));
    }
 else {
      TailThread tailThread=startTailThread(new String[]{progressLogFile});
      guaguaClient.createJob(localArgs.toArray(new String[0])).waitForCompletion(true);
      stopTailThread(tailThread);
    }
  }
  if (isParallel) {
    TailThread tailThread=startTailThread(progressLogList.toArray(new String[0]));
    guaguaClient.run();
    stopTailThread(tailThread);
  }
  for (int i=0; i < baggingNum; i++) {
    String modelName=getModelName(i);
    Path modelPath=fileSystem.makeQualified(new Path(super.getPathFinder().getModelsPath(sourceType),modelName));
    copyModelToLocal(modelName,modelPath,sourceType);
  }
  copyTmpModelsToLocal(tmpModelsPath,sourceType);
  LOG.info(""String_Node_Str"",System.currentTimeMillis() - start);
}",0.8678222136147962
32105,"public Schema outputSchema(Schema input){
  try {
    StringBuilder schemaStr=new StringBuilder();
    schemaStr.append(""String_Node_Str"");
    for (int i=0; i < columnConfigList.size(); i++) {
      ColumnConfig config=this.columnConfigList.get(i);
      if (tagColumnNum == i) {
        schemaStr.append(config.getColumnName() + ""String_Node_Str"" + ""String_Node_Str"");
      }
 else       if (!config.isMeta()) {
        schemaStr.append(config.getColumnName() + ""String_Node_Str"" + ""String_Node_Str"");
      }
 else {
        schemaStr.append(config.getColumnName() + ""String_Node_Str"" + ""String_Node_Str"");
      }
    }
    schemaStr.append(""String_Node_Str"");
    return Utils.getSchemaFromString(schemaStr.toString());
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
    return null;
  }
}","public Schema outputSchema(Schema input){
  try {
    StringBuilder schemaStr=new StringBuilder();
    schemaStr.append(""String_Node_Str"");
    for (int i=0; i < columnConfigList.size(); i++) {
      ColumnConfig config=this.columnConfigList.get(i);
      if (tagColumnNum == i) {
        schemaStr.append(config.getColumnName() + ""String_Node_Str"" + ""String_Node_Str"");
      }
 else {
        schemaStr.append(config.getColumnName() + ""String_Node_Str"" + ""String_Node_Str"");
      }
    }
    schemaStr.append(""String_Node_Str"");
    return Utils.getSchemaFromString(schemaStr.toString());
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
    return null;
  }
}",0.9101876675603218
32106,"private Job createSEMapReduceJob(SourceType source,Configuration conf,String varSelectMSEOutputPath) throws IOException {
  @SuppressWarnings(""String_Node_Str"") Job job=new Job(conf,""String_Node_Str"" + this.modelConfig.getModelSetName());
  job.setJarByClass(getClass());
  boolean isSEVarSelMulti=Boolean.TRUE.toString().equalsIgnoreCase(Environment.getProperty(Constants.SHIFU_VARSEL_SE_MULTI,Constants.SHIFU_DEFAULT_VARSEL_SE_MULTI));
  if (isSEVarSelMulti) {
    job.setMapperClass(MultithreadedMapper.class);
    MultithreadedMapper.setMapperClass(job,VarSelectMapper.class);
    int threads;
    try {
      threads=Integer.parseInt(Environment.getProperty(Constants.SHIFU_VARSEL_SE_MULTI_THREAD,Constants.SHIFU_DEFAULT_VARSEL_SE_MULTI_THREAD + ""String_Node_Str""));
    }
 catch (    Exception e) {
      Log.warn(""String_Node_Str"",Constants.SHIFU_DEFAULT_VARSEL_SE_MULTI_THREAD);
      threads=Constants.SHIFU_DEFAULT_VARSEL_SE_MULTI_THREAD;
    }
    MultithreadedMapper.setNumberOfThreads(job,threads);
  }
 else {
    job.setMapperClass(VarSelectMapper.class);
  }
  job.setMapOutputKeyClass(LongWritable.class);
  job.setMapOutputValueClass(ColumnInfo.class);
  job.setInputFormatClass(TextInputFormat.class);
  FileInputFormat.setInputPaths(job,ShifuFileUtils.getFileSystemBySourceType(source).makeQualified(new Path(super.getPathFinder().getNormalizedDataPath())));
  job.setReducerClass(VarSelectReducer.class);
  job.setNumReduceTasks(1);
  job.setOutputKeyClass(Text.class);
  job.setOutputValueClass(Text.class);
  job.setOutputFormatClass(TextOutputFormat.class);
  FileOutputFormat.setOutputPath(job,new Path(varSelectMSEOutputPath));
  MultipleOutputs.addNamedOutput(job,Constants.SHIFU_VARSELECT_SE_OUTPUT_NAME,TextOutputFormat.class,Text.class,Text.class);
  return job;
}","private Job createSEMapReduceJob(SourceType source,Configuration conf,String varSelectMSEOutputPath) throws IOException {
  @SuppressWarnings(""String_Node_Str"") Job job=new Job(conf,""String_Node_Str"" + this.modelConfig.getModelSetName());
  job.setJarByClass(getClass());
  boolean isSEVarSelMulti=Boolean.TRUE.toString().equalsIgnoreCase(Environment.getProperty(Constants.SHIFU_VARSEL_SE_MULTI,Constants.SHIFU_DEFAULT_VARSEL_SE_MULTI));
  if (isSEVarSelMulti) {
    job.setMapperClass(MultithreadedMapper.class);
    MultithreadedMapper.setMapperClass(job,VarSelectMapper.class);
    int threads;
    try {
      threads=Integer.parseInt(Environment.getProperty(Constants.SHIFU_VARSEL_SE_MULTI_THREAD,Constants.SHIFU_DEFAULT_VARSEL_SE_MULTI_THREAD + ""String_Node_Str""));
    }
 catch (    Exception e) {
      log.warn(""String_Node_Str"",Constants.SHIFU_DEFAULT_VARSEL_SE_MULTI_THREAD);
      threads=Constants.SHIFU_DEFAULT_VARSEL_SE_MULTI_THREAD;
    }
    MultithreadedMapper.setNumberOfThreads(job,threads);
  }
 else {
    job.setMapperClass(VarSelectMapper.class);
  }
  job.setMapOutputKeyClass(LongWritable.class);
  job.setMapOutputValueClass(ColumnInfo.class);
  job.setInputFormatClass(TextInputFormat.class);
  FileInputFormat.setInputPaths(job,ShifuFileUtils.getFileSystemBySourceType(source).makeQualified(new Path(super.getPathFinder().getNormalizedDataPath())));
  job.setReducerClass(VarSelectReducer.class);
  job.setNumReduceTasks(1);
  job.setOutputKeyClass(Text.class);
  job.setOutputValueClass(Text.class);
  job.setOutputFormatClass(TextOutputFormat.class);
  FileOutputFormat.setOutputPath(job,new Path(varSelectMSEOutputPath));
  MultipleOutputs.addNamedOutput(job,Constants.SHIFU_VARSELECT_SE_OUTPUT_NAME,TextOutputFormat.class,Text.class,Text.class);
  return job;
}",0.999442586399108
32107,"@Test public void numericalNormalizeTest(){
  ColumnConfig config=new ColumnConfig();
  config.setMean(2.0);
  config.setStdDev(1.0);
  config.setColumnType(ColumnType.N);
  ColumnBinning cbin=new ColumnBinning();
  cbin.setBinCountWoe(Arrays.asList(new Double[]{10.0,11.0,12.0,13.0,6.5}));
  cbin.setBinWeightedWoe(Arrays.asList(new Double[]{20.0,21.0,22.0,23.0,16.5}));
  cbin.setBinBoundary(Arrays.asList(new Double[]{Double.NEGATIVE_INFINITY,2.0,4.0,6.0}));
  config.setColumnBinning(cbin);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",4.0,NormType.ZSCALE),3.0);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",null,NormType.ZSCALE),3.0);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",4.0,NormType.ZSCALE),0.0);
  Assert.assertEquals(Normalizer.normalize(config,null,4.0,NormType.ZSCALE),0.0);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",4.0,NormType.OLD_ZSCALE),3.0);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",null,NormType.OLD_ZSCALE),3.0);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",4.0,NormType.OLD_ZSCALE),0.0);
  Assert.assertEquals(Normalizer.normalize(config,null,4.0,NormType.OLD_ZSCALE),0.0);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",null,NormType.WEIGHT_WOE),21.0);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",null,NormType.WEIGHT_WOE),16.5);
  Assert.assertEquals(Normalizer.normalize(config,null,null,NormType.WEIGHT_WOE),16.5);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",null,NormType.WOE),11.0);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",null,NormType.WOE),6.5);
  Assert.assertEquals(Normalizer.normalize(config,null,null,NormType.WOE),6.5);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",4.0,NormType.HYBRID),3.0);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",null,NormType.HYBRID),3.0);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",4.0,NormType.HYBRID),0.0);
  Assert.assertEquals(Normalizer.normalize(config,null,4.0,NormType.HYBRID),0.0);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",4.0,NormType.WEIGHT_HYBRID),3.0);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",null,NormType.WEIGHT_HYBRID),3.0);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",4.0,NormType.WEIGHT_HYBRID),0.0);
  Assert.assertEquals(Normalizer.normalize(config,null,4.0,NormType.WEIGHT_HYBRID),0.0);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",10.0,NormType.WOE_ZSCORE),0.2);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",12.0,NormType.WOE_ZSCORE),-1.6);
  Assert.assertEquals(Normalizer.normalize(config,null,12.0,NormType.WOE_ZSCORE),-1.6);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",20.0,NormType.WEIGHT_WOE_ZSCORE),0.2);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",22.0,NormType.WEIGHT_WOE_ZSCORE),-1.6);
  Assert.assertEquals(Normalizer.normalize(config,null,22.0,NormType.WEIGHT_WOE_ZSCORE),-1.6);
}","@Test public void numericalNormalizeTest(){
  ColumnConfig config=new ColumnConfig();
  config.setMean(2.0);
  config.setStdDev(1.0);
  config.setColumnType(ColumnType.N);
  ColumnBinning cbin=new ColumnBinning();
  cbin.setBinCountWoe(Arrays.asList(new Double[]{10.0,11.0,12.0,13.0,6.5}));
  cbin.setBinWeightedWoe(Arrays.asList(new Double[]{20.0,21.0,22.0,23.0,16.5}));
  cbin.setBinBoundary(Arrays.asList(new Double[]{Double.NEGATIVE_INFINITY,2.0,4.0,6.0}));
  cbin.setBinCountNeg(Arrays.asList(1,2,3,4,5));
  cbin.setBinCountPos(Arrays.asList(5,4,3,2,1));
  config.setColumnBinning(cbin);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",4.0,NormType.ZSCALE),3.0);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",null,NormType.ZSCALE),3.0);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",4.0,NormType.ZSCALE),0.0);
  Assert.assertEquals(Normalizer.normalize(config,null,4.0,NormType.ZSCALE),0.0);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",4.0,NormType.OLD_ZSCALE),3.0);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",null,NormType.OLD_ZSCALE),3.0);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",4.0,NormType.OLD_ZSCALE),0.0);
  Assert.assertEquals(Normalizer.normalize(config,null,4.0,NormType.OLD_ZSCALE),0.0);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",null,NormType.WEIGHT_WOE),21.0);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",null,NormType.WEIGHT_WOE),16.5);
  Assert.assertEquals(Normalizer.normalize(config,null,null,NormType.WEIGHT_WOE),16.5);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",null,NormType.WOE),11.0);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",null,NormType.WOE),6.5);
  Assert.assertEquals(Normalizer.normalize(config,null,null,NormType.WOE),6.5);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",4.0,NormType.HYBRID),3.0);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",null,NormType.HYBRID),3.0);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",4.0,NormType.HYBRID),0.0);
  Assert.assertEquals(Normalizer.normalize(config,null,4.0,NormType.HYBRID),0.0);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",4.0,NormType.WEIGHT_HYBRID),3.0);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",null,NormType.WEIGHT_HYBRID),3.0);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",4.0,NormType.WEIGHT_HYBRID),0.0);
  Assert.assertEquals(Normalizer.normalize(config,null,4.0,NormType.WEIGHT_HYBRID),0.0);
}",0.8805484147386461
32108,"@Test public void categoricalNormalizeTest(){
  ColumnConfig config=new ColumnConfig();
  config.setMean(0.2);
  config.setStdDev(1.0);
  config.setColumnType(ColumnType.C);
  ColumnBinning cbin=new ColumnBinning();
  cbin.setBinCountWoe(Arrays.asList(new Double[]{10.0,11.0,12.0,13.0,6.5}));
  cbin.setBinWeightedWoe(Arrays.asList(new Double[]{20.0,21.0,22.0,23.0,16.5}));
  cbin.setBinCategory(Arrays.asList(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}));
  cbin.setBinPosRate(Arrays.asList(new Double[]{0.2,0.4,0.8,1.0}));
  config.setColumnBinning(cbin);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",4.0,NormType.ZSCALE),0.2);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",null,NormType.ZSCALE),0.2);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",4.0,NormType.ZSCALE),0.0);
  Assert.assertEquals(Normalizer.normalize(config,null,4.0,NormType.ZSCALE),0.0);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",4.0,NormType.OLD_ZSCALE),0.2);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",null,NormType.OLD_ZSCALE),0.2);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",4.0,NormType.OLD_ZSCALE),0.0);
  Assert.assertEquals(Normalizer.normalize(config,null,4.0,NormType.OLD_ZSCALE),0.0);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",null,NormType.WEIGHT_WOE),22.0);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",null,NormType.WEIGHT_WOE),16.5);
  Assert.assertEquals(Normalizer.normalize(config,null,null,NormType.WEIGHT_WOE),16.5);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",null,NormType.WOE),12.0);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",null,NormType.WOE),6.5);
  Assert.assertEquals(Normalizer.normalize(config,null,null,NormType.WOE),6.5);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",null,NormType.HYBRID),10.0);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",null,NormType.HYBRID),6.5);
  Assert.assertEquals(Normalizer.normalize(config,null,null,NormType.HYBRID),6.5);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",null,NormType.WEIGHT_HYBRID),20.0);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",null,NormType.WEIGHT_HYBRID),16.5);
  Assert.assertEquals(Normalizer.normalize(config,null,null,NormType.WEIGHT_HYBRID),16.5);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",12.0,NormType.WOE_ZSCORE),0.2);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",13.0,NormType.WOE_ZSCORE),-1.6);
  Assert.assertEquals(Normalizer.normalize(config,null,13.0,NormType.WOE_ZSCORE),-1.6);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",22.0,NormType.WEIGHT_WOE_ZSCORE),0.2);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",23.0,NormType.WEIGHT_WOE_ZSCORE),-1.6);
  Assert.assertEquals(Normalizer.normalize(config,null,23.0,NormType.WEIGHT_WOE_ZSCORE),-1.6);
}","@Test public void categoricalNormalizeTest(){
  ColumnConfig config=new ColumnConfig();
  config.setMean(0.2);
  config.setStdDev(1.0);
  config.setColumnType(ColumnType.C);
  ColumnBinning cbin=new ColumnBinning();
  cbin.setBinCountWoe(Arrays.asList(new Double[]{10.0,11.0,12.0,13.0,6.5}));
  cbin.setBinWeightedWoe(Arrays.asList(new Double[]{20.0,21.0,22.0,23.0,16.5}));
  cbin.setBinCategory(Arrays.asList(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}));
  cbin.setBinPosRate(Arrays.asList(new Double[]{0.2,0.4,0.8,1.0}));
  cbin.setBinCountNeg(Arrays.asList(1,2,3,4,5));
  cbin.setBinCountPos(Arrays.asList(5,4,3,2,1));
  config.setColumnBinning(cbin);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",4.0,NormType.ZSCALE),0.2);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",null,NormType.ZSCALE),0.2);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",4.0,NormType.ZSCALE),0.0);
  Assert.assertEquals(Normalizer.normalize(config,null,4.0,NormType.ZSCALE),0.0);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",4.0,NormType.OLD_ZSCALE),0.2);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",null,NormType.OLD_ZSCALE),0.2);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",4.0,NormType.OLD_ZSCALE),0.0);
  Assert.assertEquals(Normalizer.normalize(config,null,4.0,NormType.OLD_ZSCALE),0.0);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",null,NormType.WEIGHT_WOE),22.0);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",null,NormType.WEIGHT_WOE),16.5);
  Assert.assertEquals(Normalizer.normalize(config,null,null,NormType.WEIGHT_WOE),16.5);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",null,NormType.WOE),12.0);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",null,NormType.WOE),6.5);
  Assert.assertEquals(Normalizer.normalize(config,null,null,NormType.WOE),6.5);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",null,NormType.HYBRID),10.0);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",null,NormType.HYBRID),6.5);
  Assert.assertEquals(Normalizer.normalize(config,null,null,NormType.HYBRID),6.5);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",null,NormType.WEIGHT_HYBRID),20.0);
  Assert.assertEquals(Normalizer.normalize(config,""String_Node_Str"",null,NormType.WEIGHT_HYBRID),16.5);
  Assert.assertEquals(Normalizer.normalize(config,null,null,NormType.WEIGHT_HYBRID),16.5);
}",0.8770072348685372
32109,"/** 
 * Compute the normalized data for @NormalizeMethod.MaxMin
 * @param config @ColumnConfig info
 * @param raw input column value
 * @return normalized value for MaxMin method
 */
private static Double getMaxMinScore(ColumnConfig config,String raw){
  if (config.isCategorical()) {
  }
 else {
    Double value=Double.parseDouble(raw);
    return (value - config.getColumnStats().getMin()) / (config.getColumnStats().getMax() - config.getColumnStats().getMin());
  }
  return null;
}","/** 
 * Compute the normalized data for @NormalizeMethod.MaxMin
 * @param config
 * @ColumnConfig info
 * @param raw input column value
 * @return normalized value for MaxMin method
 */
private static Double getMaxMinScore(ColumnConfig config,String raw){
  if (config.isCategorical()) {
  }
 else {
    Double value=Double.parseDouble(raw);
    return (value - config.getColumnStats().getMin()) / (config.getColumnStats().getMax() - config.getColumnStats().getMin());
  }
  return null;
}",0.9969230769230768
32110,"/** 
 * Parse raw value based on ColumnConfig.
 * @param config @ColumnConfig info
 * @param raw input column value
 * @return parsed raw value. For categorical type, return BinPosRate. For numerical type, returncorresponding double value. For missing data, return default value using {@link Normalizer#defaultMissingValue}.
 */
private static double parseRawValue(ColumnConfig config,String raw){
  double value=0.0;
  if (config.isCategorical()) {
    int index=config.getBinCategory().indexOf(raw);
    if (index == -1) {
      value=defaultMissingValue(config);
    }
 else {
      Double binPosRate=config.getBinPosRate().get(index);
      value=binPosRate == null ? defaultMissingValue(config) : binPosRate.doubleValue();
    }
  }
 else {
    try {
      value=Double.parseDouble(raw);
    }
 catch (    Exception e) {
      log.debug(""String_Node_Str"" + raw + ""String_Node_Str"");
      value=defaultMissingValue(config);
    }
  }
  return value;
}","/** 
 * Parse raw value based on ColumnConfig.
 * @param config
 * @ColumnConfig info
 * @param raw input column value
 * @return parsed raw value. For categorical type, return BinPosRate. For numerical type, returncorresponding double value. For missing data, return default value using {@link Normalizer#defaultMissingValue}.
 */
private static double parseRawValue(ColumnConfig config,String raw){
  double value=0.0;
  if (config.isCategorical()) {
    int index=config.getBinCategory().indexOf(raw);
    if (index == -1) {
      value=defaultMissingValue(config);
    }
 else {
      Double binPosRate=config.getBinPosRate().get(index);
      value=binPosRate == null ? defaultMissingValue(config) : binPosRate.doubleValue();
    }
  }
 else {
    try {
      value=Double.parseDouble(raw);
    }
 catch (    Exception e) {
      log.debug(""String_Node_Str"" + raw + ""String_Node_Str"");
      value=defaultMissingValue(config);
    }
  }
  return value;
}",0.9984334203655352
32111,"/** 
 * Compute the normalized data for Woe Score.
 * @param config @ColumnConfig info
 * @param raw input column value
 * @param isWeightedNorm if use weighted woe
 * @return normalized value for Woe method. For missing value, we return the value in last bin. Since the lastbin refers to the missing value bin.
 */
private static Double woeNormalize(ColumnConfig config,String raw,boolean isWeightedNorm){
  List<Double> woeBins=isWeightedNorm ? config.getBinWeightedWoe() : config.getBinCountWoe();
  int binIndex=CommonUtils.getBinNum(config,raw);
  if (binIndex == -1) {
    return woeBins.get(woeBins.size() - 1);
  }
 else {
    return woeBins.get(binIndex);
  }
}","/** 
 * Compute the normalized data for Woe Score.
 * @param config
 * @ColumnConfig info
 * @param raw input column value
 * @param isWeightedNorm if use weighted woe
 * @return normalized value for Woe method. For missing value, we return the value in last bin. Since the lastbin refers to the missing value bin.
 */
private static Double woeNormalize(ColumnConfig config,String raw,boolean isWeightedNorm){
  List<Double> woeBins=isWeightedNorm ? config.getBinWeightedWoe() : config.getBinCountWoe();
  int binIndex=CommonUtils.getBinNum(config,raw);
  if (binIndex == -1) {
    return woeBins.get(woeBins.size() - 1);
  }
 else {
    return woeBins.get(binIndex);
  }
}",0.9977661950856292
32112,"/** 
 * Compute the normalized data for hbrid normalize. Use zscore noramlize for numerical data. Use woe normalize for categorical data while use weight woe normalize when isWeightedNorm is true.
 * @param config @ColumnConfig info
 * @param raw input column value
 * @param cutoff standard deviation cut off
 * @param isWeightedNorm if use weighted woe
 * @return normalized value for hybrid method.
 */
private static Double hybridNormalize(ColumnConfig config,String raw,Double cutoff,boolean isWeightedNorm){
  Double normValue;
  if (config.isNumerical()) {
    normValue=zScoreNormalize(config,raw,cutoff);
  }
 else {
    normValue=woeNormalize(config,raw,isWeightedNorm);
  }
  return normValue;
}","/** 
 * Compute the normalized data for hbrid normalize. Use zscore noramlize for numerical data. Use woe normalize for categorical data while use weight woe normalize when isWeightedNorm is true.
 * @param config
 * @ColumnConfig info
 * @param raw input column value
 * @param cutoff standard deviation cut off
 * @param isWeightedNorm if use weighted woe
 * @return normalized value for hybrid method.
 */
private static Double hybridNormalize(ColumnConfig config,String raw,Double cutoff,boolean isWeightedNorm){
  Double normValue;
  if (config.isNumerical()) {
    normValue=zScoreNormalize(config,raw,cutoff);
  }
 else {
    normValue=woeNormalize(config,raw,isWeightedNorm);
  }
  return normValue;
}",0.9978798586572438
32113,"/** 
 * Create @Normalizer, according @ColumnConfig and NormalizeMethod NormalizeMethod method will be NormalizeMethod.ZScore
 * @param config @ColumnConfig to create normalizer
 * @param method NormalizMethod to use
 * @param cutoff stand_dev_cutoff to use
 */
public Normalizer(ColumnConfig config,NormalizeMethod method,Double cutoff){
  this.config=config;
  this.method=method;
  this.stdDevCutOff=cutoff;
}","/** 
 * Create @Normalizer, according @ColumnConfig and NormalizeMethod NormalizeMethod method will be NormalizeMethod.ZScore
 * @param config
 * @ColumnConfig to create normalizer
 * @param method NormalizMethod to use
 * @param cutoff stand_dev_cutoff to use
 */
public Normalizer(ColumnConfig config,NormalizeMethod method,Double cutoff){
  this.config=config;
  this.method=method;
  this.stdDevCutOff=cutoff;
}",0.996372430471584
32114,"/** 
 * Normalize the raw data, according the ColumnConfig infomation and normalization type. Currently, the cutoff value doesn't affect the computation of WOE or WEIGHT_WOE type. <p> Noticd: currently OLD_ZSCALE and ZSCALE is implemented with the same process method. </p>
 * @param config ColumnConfig to normalize data
 * @param raw raw input data
 * @param cutoff standard deviation cut off
 * @param type normalization type. {@link ModelNormalizeConf.NormType}
 * @return normalized value. If normType parameter is invalid, then the ZSCALE will be used as default.
 */
public static Double normalize(ColumnConfig config,String raw,Double cutoff,ModelNormalizeConf.NormType type){
switch (type) {
case WOE:
    return woeNormalize(config,raw,false);
case WEIGHT_WOE:
  return woeNormalize(config,raw,true);
case HYBRID:
return hybridNormalize(config,raw,cutoff,false);
case WEIGHT_HYBRID:
return hybridNormalize(config,raw,cutoff,true);
case WOE_ZSCORE:
return woeZScoreNormalize(config,raw,cutoff,false);
case WEIGHT_WOE_ZSCORE:
return woeZScoreNormalize(config,raw,cutoff,true);
case OLD_ZSCALE:
case ZSCALE:
default :
return zScoreNormalize(config,raw,cutoff);
}
}","/** 
 * Normalize the raw data, according the ColumnConfig infomation and normalization type. Currently, the cutoff value doesn't affect the computation of WOE or WEIGHT_WOE type. <p> Noticd: currently OLD_ZSCALE and ZSCALE is implemented with the same process method. </p>
 * @param config ColumnConfig to normalize data
 * @param raw raw input data
 * @param cutoff standard deviation cut off
 * @param type normalization type.  {@link ModelNormalizeConf.NormType}
 * @return normalized value. If normType parameter is invalid, then the ZSCALE will be used as default.
 */
public static Double normalize(ColumnConfig config,String raw,Double cutoff,ModelNormalizeConf.NormType type){
switch (type) {
case WOE:
    return woeNormalize(config,raw,false);
case WEIGHT_WOE:
  return woeNormalize(config,raw,true);
case HYBRID:
return hybridNormalize(config,raw,cutoff,false);
case WEIGHT_HYBRID:
return hybridNormalize(config,raw,cutoff,true);
case WOE_ZSCORE:
return woeZScoreNormalize(config,raw,cutoff,false);
case WEIGHT_WOE_ZSCORE:
return woeZScoreNormalize(config,raw,cutoff,true);
case OLD_ZSCALE:
case ZSCALE:
default :
return zScoreNormalize(config,raw,cutoff);
}
}",0.9995731967562952
32115,"/** 
 * Compute the normalized value for woe zscore normalize.Take woe as variable value and using zscore normalizing  to compute zscore of woe.
 * @param config @ColumnConfig info
 * @param raw input column value
 * @param cutoff standard deviation cut off
 * @param isWeightedNorm if use weighted woe
 * @return normalized value for woe zscore method.
 */
private static Double woeZScoreNormalize(ColumnConfig config,String raw,Double cutoff,boolean isWeightedNorm){
  double stdDevCutOff=checkCutOff(cutoff);
  double woe=woeNormalize(config,raw,isWeightedNorm);
  double[] meanAndStdDev=calculateWoeMeanAndStdDev(config,isWeightedNorm);
  return computeZScore(woe,meanAndStdDev[0],meanAndStdDev[1],stdDevCutOff);
}","/** 
 * Compute the normalized value for woe zscore normalize.Take woe as variable value and using zscore normalizing to compute zscore of woe.
 * @param config
 * @ColumnConfig info
 * @param raw input column value
 * @param cutoff standard deviation cut off
 * @param isWeightedNorm if use weighted woe
 * @return normalized value for woe zscore method.
 */
private static Double woeZScoreNormalize(ColumnConfig config,String raw,Double cutoff,boolean isWeightedNorm){
  double stdDevCutOff=checkCutOff(cutoff);
  double woe=woeNormalize(config,raw,isWeightedNorm);
  double[] meanAndStdDev=calculateWoeMeanAndStdDev(config,isWeightedNorm);
  return computeZScore(woe,meanAndStdDev[0],meanAndStdDev[1],stdDevCutOff);
}",0.9972183588317108
32116,"/** 
 * Get the default value for missing data.
 * @param config @ColumnConfig info
 * @return default value for missing data. Now simply return Mean value. If mean is null then return 0.
 */
private static double defaultMissingValue(ColumnConfig config){
  return config.getMean() == null ? 0 : config.getMean().doubleValue();
}","/** 
 * Get the default value for missing data.
 * @param config
 * @ColumnConfig info
 * @return default value for missing data. Now simply return Mean value. If mean is null then return 0.
 */
private static double defaultMissingValue(ColumnConfig config){
  return config.getMean() == null ? 0 : config.getMean().doubleValue();
}",0.9954614220877458
32117,"/** 
 * Calculate woe mean and woe standard deviation.
 * @param config @ColumnConfig info
 * @param isWeightedNorm if use weighted woe
 * @return an double array contains woe mean and woe standard deviation as order {mean, stdDev}
 */
private static double[] calculateWoeMeanAndStdDev(ColumnConfig config,boolean isWeightedNorm){
  List<Double> woeList=isWeightedNorm ? config.getBinWeightedWoe() : config.getBinCountWoe();
  if (woeList == null || woeList.size() < 2) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int size=woeList.size();
  Double sum=0.0;
  Double squaredSum=0.0;
  for (int i=0; i < size; i++) {
    Double x=woeList.get(i);
    sum+=x;
    squaredSum+=x * x;
  }
  double woeMean=sum / size;
  double woeStdDev=Math.sqrt(Math.abs((squaredSum - (sum * sum) / size) / (size - 1)));
  return new double[]{woeMean,woeStdDev};
}","/** 
 * Calculate woe mean and woe standard deviation.
 * @param config ColumnConfig info
 * @param isWeightedNorm if use weighted woe
 * @return an double array contains woe mean and woe standard deviation as order {mean, stdDev}
 */
private static double[] calculateWoeMeanAndStdDev(ColumnConfig config,boolean isWeightedNorm){
  List<Double> woeList=isWeightedNorm ? config.getBinWeightedWoe() : config.getBinCountWoe();
  if (woeList == null || woeList.size() < 2) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  List<Integer> negCountList=config.getBinCountNeg();
  List<Integer> posCountList=config.getBinCountPos();
  int size=woeList.size();
  double sum=0.0;
  double squaredSum=0.0;
  long totalCount=0;
  for (int i=0; i < size; i++) {
    int count=negCountList.get(i) + posCountList.get(i);
    totalCount+=count;
    double x=woeList.get(i);
    sum+=x * count;
    squaredSum+=x * x * count;
  }
  double woeMean=sum / totalCount;
  double woeStdDev=Math.sqrt(Math.abs((squaredSum - (sum * sum) / totalCount) / (totalCount - 1)));
  return new double[]{woeMean,woeStdDev};
}",0.7223910840932117
32118,"/** 
 * Compute the normalized data for @NormalizeMethod.Zscore
 * @param config @ColumnConfig info
 * @param raw input column value
 * @param cutoff standard deviation cut off
 * @return normalized value for ZScore method.
 */
private static Double zScoreNormalize(ColumnConfig config,String raw,Double cutoff){
  double stdDevCutOff=checkCutOff(cutoff);
  double value=parseRawValue(config,raw);
  return computeZScore(value,config.getMean(),config.getStdDev(),stdDevCutOff);
}","/** 
 * Compute the normalized data for @NormalizeMethod.Zscore
 * @param config
 * @ColumnConfig info
 * @param raw input column value
 * @param cutoff standard deviation cut off
 * @return normalized value for ZScore method.
 */
private static Double zScoreNormalize(ColumnConfig config,String raw,Double cutoff){
  double stdDevCutOff=checkCutOff(cutoff);
  double value=parseRawValue(config,raw);
  return computeZScore(value,config.getMean(),config.getStdDev(),stdDevCutOff);
}",0.9968782518210196
32119,"@Test public void testIsFileExists() throws IOException {
  Assert.assertTrue(ShifuFileUtils.isFileExists(""String_Node_Str"",SourceType.LOCAL));
  Assert.assertTrue(ShifuFileUtils.isFileExists(""String_Node_Str"",SourceType.LOCAL));
  Assert.assertTrue(ShifuFileUtils.isFileExists(""String_Node_Str"",SourceType.LOCAL));
  Assert.assertTrue(ShifuFileUtils.isFileExists(""String_Node_Str"",SourceType.LOCAL));
  Assert.assertFalse(ShifuFileUtils.isFileExists(""String_Node_Str"",SourceType.LOCAL));
}","public void testIsFileExists() throws IOException {
  Assert.assertTrue(ShifuFileUtils.isFileExists(""String_Node_Str"",SourceType.LOCAL));
  Assert.assertTrue(ShifuFileUtils.isFileExists(""String_Node_Str"",SourceType.LOCAL));
  Assert.assertTrue(ShifuFileUtils.isFileExists(""String_Node_Str"",SourceType.LOCAL));
  Assert.assertTrue(ShifuFileUtils.isFileExists(""String_Node_Str"",SourceType.LOCAL));
  Assert.assertFalse(ShifuFileUtils.isFileExists(""String_Node_Str"",SourceType.LOCAL));
}",0.9938398357289528
32120,"@Test public void testExpandPath() throws IOException {
  File testDir=new File(""String_Node_Str"");
  FileUtils.forceMkdir(testDir);
  File tmp0=new File(""String_Node_Str"");
  File tmp1=new File(""String_Node_Str"");
  File tmp2=new File(""String_Node_Str"");
  FileUtils.touch(tmp0);
  FileUtils.touch(tmp1);
  FileUtils.touch(tmp2);
  List<String> filePathList=ShifuFileUtils.expandPath(""String_Node_Str"",SourceType.LOCAL);
  Assert.assertEquals(3,filePathList.size());
  filePathList=ShifuFileUtils.expandPath(""String_Node_Str"",SourceType.LOCAL);
  Assert.assertEquals(2,filePathList.size());
  Assert.assertTrue(filePathList.get(0).contains(""String_Node_Str""));
  filePathList=ShifuFileUtils.expandPath(""String_Node_Str"",SourceType.LOCAL);
  Assert.assertEquals(3,filePathList.size());
  Assert.assertTrue(filePathList.get(0).contains(""String_Node_Str""));
  filePathList=ShifuFileUtils.expandPath(""String_Node_Str"",SourceType.LOCAL);
  Assert.assertEquals(0,filePathList.size());
  FileUtils.deleteDirectory(testDir);
}","public void testExpandPath() throws IOException {
  File testDir=new File(""String_Node_Str"");
  FileUtils.forceMkdir(testDir);
  File tmp0=new File(""String_Node_Str"");
  File tmp1=new File(""String_Node_Str"");
  File tmp2=new File(""String_Node_Str"");
  FileUtils.touch(tmp0);
  FileUtils.touch(tmp1);
  FileUtils.touch(tmp2);
  List<String> filePathList=ShifuFileUtils.expandPath(""String_Node_Str"",SourceType.LOCAL);
  Assert.assertEquals(3,filePathList.size());
  filePathList=ShifuFileUtils.expandPath(""String_Node_Str"",SourceType.LOCAL);
  Assert.assertEquals(2,filePathList.size());
  Assert.assertTrue(filePathList.get(0).contains(""String_Node_Str""));
  filePathList=ShifuFileUtils.expandPath(""String_Node_Str"",SourceType.LOCAL);
  Assert.assertEquals(3,filePathList.size());
  Assert.assertTrue(filePathList.get(0).contains(""String_Node_Str""));
  filePathList=ShifuFileUtils.expandPath(""String_Node_Str"",SourceType.LOCAL);
  Assert.assertEquals(0,filePathList.size());
  FileUtils.deleteDirectory(testDir);
}",0.9970472440944882
32121,"@Override protected void reduce(IntWritable key,Iterable<BinningInfoWritable> values,Context context) throws IOException, InterruptedException {
  long start=System.currentTimeMillis();
  double sum=0d;
  double squaredSum=0d;
  long count=0L, missingCount=0L;
  double min=Double.MAX_VALUE, max=Double.MIN_VALUE;
  List<Double> binBoundaryList=null;
  List<String> binCategories=null;
  long[] binCountPos=null;
  long[] binCountNeg=null;
  double[] binWeightPos=null;
  double[] binWeightNeg=null;
  ColumnConfig columnConfig=this.columnConfigList.get(key.get());
  int binSize=0;
  for (  BinningInfoWritable info : values) {
    if (info.isNumeric() && binBoundaryList == null) {
      binBoundaryList=info.getBinBoundaries();
      binSize=binBoundaryList.size();
      binCountPos=new long[binSize + 1];
      binCountNeg=new long[binSize + 1];
      binWeightPos=new double[binSize + 1];
      binWeightNeg=new double[binSize + 1];
    }
    if (!info.isNumeric() && binCategories == null) {
      binCategories=info.getBinCategories();
      binSize=binCategories.size();
      binCountPos=new long[binSize + 1];
      binCountNeg=new long[binSize + 1];
      binWeightPos=new double[binSize + 1];
      binWeightNeg=new double[binSize + 1];
    }
    count+=info.getTotalCount();
    missingCount+=info.getMissingCount();
    sum+=info.getSum();
    squaredSum+=info.getSquaredSum();
    if (Double.compare(max,info.getMax()) < 0) {
      max=info.getMax();
    }
    if (Double.compare(min,info.getMin()) > 0) {
      min=info.getMin();
    }
    for (int i=0; i < (binSize + 1); i++) {
      binCountPos[i]+=info.getBinCountPos()[i];
      binCountNeg[i]+=info.getBinCountNeg()[i];
      binWeightPos[i]+=info.getBinWeightPos()[i];
      binWeightNeg[i]+=info.getBinWeightNeg()[i];
    }
  }
  double[] binPosRate=computePosRate(binCountPos,binCountNeg);
  String binBounString=null;
  if (columnConfig.isCategorical()) {
    if (binCategories.size() == 0 || binCategories.size() > MAX_CATEGORICAL_BINC_COUNT) {
      LOG.warn(""String_Node_Str"",key.get(),columnConfig.getColumnName(),binCategories.size());
      return;
    }
    binBounString=Base64Utils.base64Encode(""String_Node_Str"" + StringUtils.join(binCategories,CalculateStatsUDF.CATEGORY_VAL_SEPARATOR) + ""String_Node_Str"");
    min=Double.MAX_VALUE;
    max=Double.MIN_VALUE;
    sum=0d;
    squaredSum=0d;
    for (int i=0; i < binPosRate.length; i++) {
      if (Double.compare(max,binPosRate[i]) < 0) {
        max=binPosRate[i];
      }
      if (Double.compare(min,binPosRate[i]) > 0) {
        min=binPosRate[i];
      }
      sum+=binPosRate[i] * (binCountPos[i] + binCountNeg[i]);
      squaredSum+=binPosRate[i] * binPosRate[i] * (binCountPos[i] + binCountNeg[i]);
    }
  }
 else {
    if (binBoundaryList.size() == 0) {
      LOG.warn(""String_Node_Str"",key.get(),columnConfig.getColumnName(),binBoundaryList.size());
      return;
    }
    binBounString=binBoundaryList.toString();
  }
  ColumnMetrics columnCountMetrics=ColumnStatsCalculator.calculateColumnMetrics(binCountNeg,binCountPos);
  ColumnMetrics columnWeightMetrics=ColumnStatsCalculator.calculateColumnMetrics(binWeightNeg,binWeightPos);
  sb.append(key.get()).append(Constants.DEFAULT_DELIMITER).append(binBounString).append(Constants.DEFAULT_DELIMITER).append(Arrays.toString(binCountNeg)).append(Constants.DEFAULT_DELIMITER).append(Arrays.toString(binCountPos)).append(Constants.DEFAULT_DELIMITER).append(Arrays.toString(new double[0])).append(Constants.DEFAULT_DELIMITER).append(Arrays.toString(binPosRate)).append(Constants.DEFAULT_DELIMITER).append(df.format(columnCountMetrics.getKs())).append(Constants.DEFAULT_DELIMITER).append(df.format(columnWeightMetrics.getIv())).append(Constants.DEFAULT_DELIMITER).append(df.format(max)).append(Constants.DEFAULT_DELIMITER).append(df.format(min)).append(Constants.DEFAULT_DELIMITER).append(df.format(sum / count)).append(Constants.DEFAULT_DELIMITER).append(df.format(Math.sqrt(Math.abs((squaredSum - (sum * sum) / count + EPS) / (count - 1))))).append(Constants.DEFAULT_DELIMITER).append(columnConfig.isCategorical() ? ""String_Node_Str"" : ""String_Node_Str"").append(Constants.DEFAULT_DELIMITER).append(df.format(sum / count)).append(Constants.DEFAULT_DELIMITER).append(missingCount).append(Constants.DEFAULT_DELIMITER).append(count).append(Constants.DEFAULT_DELIMITER).append(missingCount * 1.0d / count).append(Constants.DEFAULT_DELIMITER).append(Arrays.toString(binWeightNeg)).append(Constants.DEFAULT_DELIMITER).append(Arrays.toString(binWeightPos)).append(Constants.DEFAULT_DELIMITER).append(columnCountMetrics.getWoe()).append(Constants.DEFAULT_DELIMITER).append(columnWeightMetrics.getWoe()).append(Constants.DEFAULT_DELIMITER).append(columnWeightMetrics.getKs()).append(Constants.DEFAULT_DELIMITER).append(columnCountMetrics.getIv()).append(Constants.DEFAULT_DELIMITER).append(columnCountMetrics.getBinningWoe().toString()).append(Constants.DEFAULT_DELIMITER).append(columnWeightMetrics.getBinningWoe().toString());
  outputValue.set(sb.toString());
  context.write(NullWritable.get(),outputValue);
  sb.delete(0,sb.length());
  LOG.debug(""String_Node_Str"",(System.currentTimeMillis() - start));
}","@Override protected void reduce(IntWritable key,Iterable<BinningInfoWritable> values,Context context) throws IOException, InterruptedException {
  long start=System.currentTimeMillis();
  double sum=0d;
  double squaredSum=0d;
  long count=0L, missingCount=0L;
  double min=Double.MAX_VALUE, max=Double.MIN_VALUE;
  List<Double> binBoundaryList=null;
  List<String> binCategories=null;
  long[] binCountPos=null;
  long[] binCountNeg=null;
  double[] binWeightPos=null;
  double[] binWeightNeg=null;
  ColumnConfig columnConfig=this.columnConfigList.get(key.get());
  int binSize=0;
  for (  BinningInfoWritable info : values) {
    if (info.isNumeric() && binBoundaryList == null) {
      binBoundaryList=info.getBinBoundaries();
      binSize=binBoundaryList.size();
      binCountPos=new long[binSize + 1];
      binCountNeg=new long[binSize + 1];
      binWeightPos=new double[binSize + 1];
      binWeightNeg=new double[binSize + 1];
    }
    if (!info.isNumeric() && binCategories == null) {
      binCategories=info.getBinCategories();
      binSize=binCategories.size();
      binCountPos=new long[binSize + 1];
      binCountNeg=new long[binSize + 1];
      binWeightPos=new double[binSize + 1];
      binWeightNeg=new double[binSize + 1];
    }
    count+=info.getTotalCount();
    missingCount+=info.getMissingCount();
    sum+=info.getSum();
    squaredSum+=info.getSquaredSum();
    if (Double.compare(max,info.getMax()) < 0) {
      max=info.getMax();
    }
    if (Double.compare(min,info.getMin()) > 0) {
      min=info.getMin();
    }
    for (int i=0; i < (binSize + 1); i++) {
      binCountPos[i]+=info.getBinCountPos()[i];
      binCountNeg[i]+=info.getBinCountNeg()[i];
      binWeightPos[i]+=info.getBinWeightPos()[i];
      binWeightNeg[i]+=info.getBinWeightNeg()[i];
    }
  }
  double[] binPosRate=computePosRate(binCountPos,binCountNeg);
  String binBounString=null;
  if (columnConfig.isCategorical()) {
    if (binCategories.size() == 0 || binCategories.size() > MAX_CATEGORICAL_BINC_COUNT) {
      LOG.warn(""String_Node_Str"",key.get(),columnConfig.getColumnName(),binCategories.size());
      return;
    }
    binBounString=Base64Utils.base64Encode(""String_Node_Str"" + StringUtils.join(binCategories,CalculateStatsUDF.CATEGORY_VAL_SEPARATOR) + ""String_Node_Str"");
    min=Double.MAX_VALUE;
    max=Double.MIN_VALUE;
    sum=0d;
    squaredSum=0d;
    for (int i=0; i < binPosRate.length; i++) {
      if (!Double.isNaN(binPosRate[i])) {
        if (Double.compare(max,binPosRate[i]) < 0) {
          max=binPosRate[i];
        }
        if (Double.compare(min,binPosRate[i]) > 0) {
          min=binPosRate[i];
        }
        sum+=binPosRate[i] * (binCountPos[i] + binCountNeg[i]);
        squaredSum+=binPosRate[i] * binPosRate[i] * (binCountPos[i] + binCountNeg[i]);
      }
    }
  }
 else {
    if (binBoundaryList.size() == 0) {
      LOG.warn(""String_Node_Str"",key.get(),columnConfig.getColumnName(),binBoundaryList.size());
      return;
    }
    binBounString=binBoundaryList.toString();
  }
  ColumnMetrics columnCountMetrics=ColumnStatsCalculator.calculateColumnMetrics(binCountNeg,binCountPos);
  ColumnMetrics columnWeightMetrics=ColumnStatsCalculator.calculateColumnMetrics(binWeightNeg,binWeightPos);
  sb.append(key.get()).append(Constants.DEFAULT_DELIMITER).append(binBounString).append(Constants.DEFAULT_DELIMITER).append(Arrays.toString(binCountNeg)).append(Constants.DEFAULT_DELIMITER).append(Arrays.toString(binCountPos)).append(Constants.DEFAULT_DELIMITER).append(Arrays.toString(new double[0])).append(Constants.DEFAULT_DELIMITER).append(Arrays.toString(binPosRate)).append(Constants.DEFAULT_DELIMITER).append(df.format(columnCountMetrics.getKs())).append(Constants.DEFAULT_DELIMITER).append(df.format(columnWeightMetrics.getIv())).append(Constants.DEFAULT_DELIMITER).append(df.format(max)).append(Constants.DEFAULT_DELIMITER).append(df.format(min)).append(Constants.DEFAULT_DELIMITER).append(df.format(sum / count)).append(Constants.DEFAULT_DELIMITER).append(df.format(Math.sqrt(Math.abs((squaredSum - (sum * sum) / count + EPS) / (count - 1))))).append(Constants.DEFAULT_DELIMITER).append(columnConfig.isCategorical() ? ""String_Node_Str"" : ""String_Node_Str"").append(Constants.DEFAULT_DELIMITER).append(df.format(sum / count)).append(Constants.DEFAULT_DELIMITER).append(missingCount).append(Constants.DEFAULT_DELIMITER).append(count).append(Constants.DEFAULT_DELIMITER).append(missingCount * 1.0d / count).append(Constants.DEFAULT_DELIMITER).append(Arrays.toString(binWeightNeg)).append(Constants.DEFAULT_DELIMITER).append(Arrays.toString(binWeightPos)).append(Constants.DEFAULT_DELIMITER).append(columnCountMetrics.getWoe()).append(Constants.DEFAULT_DELIMITER).append(columnWeightMetrics.getWoe()).append(Constants.DEFAULT_DELIMITER).append(columnWeightMetrics.getKs()).append(Constants.DEFAULT_DELIMITER).append(columnCountMetrics.getIv()).append(Constants.DEFAULT_DELIMITER).append(columnCountMetrics.getBinningWoe().toString()).append(Constants.DEFAULT_DELIMITER).append(columnWeightMetrics.getBinningWoe().toString());
  outputValue.set(sb.toString());
  context.write(NullWritable.get(),outputValue);
  sb.delete(0,sb.length());
  LOG.debug(""String_Node_Str"",(System.currentTimeMillis() - start));
}",0.9936914547887592
32122,"/** 
 * @return normalize missing value filling type
 */
@JsonIgnore public MissValueFillType getNormalizeMissValueFillType(){
  return normalize.getFillType();
}","/** 
 * @return normalize missing value filling type
 */
@JsonIgnore public MissValueFillType getNormalizeMissValueFillType(){
  return normalize.getMissValueFillType();
}",0.972972972972973
32123,"@Override protected boolean isSplitable(JobContext context,Path file){
  if (file.getName().endsWith(GuaguaMapReduceConstants.BZ2)) {
    return true;
  }
  if (file.getName().endsWith(GZ)) {
    return false;
  }
  CompressionCodec codec=new CompressionCodecFactory(context.getConfiguration()).getCodec(file);
  return codec == null;
}","@Override protected boolean isSplitable(JobContext context,Path file){
  CompressionCodec codec=new CompressionCodecFactory(context.getConfiguration()).getCodec(file);
  return codec == null;
}",0.7296786389413988
32124,"/** 
 * Get the progress within the split TODO should be rewrite
 */
public float getProgress(){
  if (start == end) {
    return 0.0f;
  }
 else {
    return Math.min(1.0f,(comsumedSplitSize + (pos - start)) / (float)(this.wholeSize));
  }
}","/** 
 * Get the progress within the split
 */
public float getProgress(){
  if (start == end) {
    return 0.0f;
  }
 else {
    return Math.min(1.0f,(comsumedSplitSize + (pos - start)) / (this.wholeSize));
  }
}",0.933920704845815
32125,"/** 
 * Return header column array from header file.
 * @throws IOException if any IO exception in reading file.
 * @throws IllegalArgumentException if sourceType is null, if pathHeader is null or empty, if delimiter is null or empty.
 * @throws RuntimeException if first line of pathHeader is null or empty.
 */
public static String[] getHeaders(String pathHeader,String delimiter,SourceType sourceType,boolean isFull) throws IOException {
  if (StringUtils.isEmpty(pathHeader) || StringUtils.isEmpty(delimiter) || sourceType == null) {
    throw new IllegalArgumentException(String.format(""String_Node_Str"",pathHeader,delimiter,sourceType));
  }
  BufferedReader reader=null;
  String pigHeaderStr=null;
  try {
    reader=ShifuFileUtils.getReader(pathHeader,sourceType);
    pigHeaderStr=reader.readLine();
    if (StringUtils.isEmpty(pigHeaderStr)) {
      throw new RuntimeException(String.format(""String_Node_Str"",pathHeader));
    }
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
    throw new ShifuException(ShifuErrorCode.ERROR_HEADER_NOT_FOUND);
  }
 finally {
    IOUtils.closeQuietly(reader);
  }
  List<String> headerList=new ArrayList<String>();
  for (  String str : Splitter.on(delimiter).split(pigHeaderStr)) {
    if (isFull) {
      headerList.add(getFullPigHeaderColumnName(str));
    }
 else {
      headerList.add(getRelativePigHeaderColumnName(str));
    }
  }
  return headerList.toArray(new String[0]);
}","/** 
 * Return header column array from header file.
 * @throws IOException if any IO exception in reading file.
 * @throws IllegalArgumentException if sourceType is null, if pathHeader is null or empty, if delimiter is null or empty.
 * @throws RuntimeException if first line of pathHeader is null or empty.
 */
public static String[] getHeaders(String pathHeader,String delimiter,SourceType sourceType,boolean isFull) throws IOException {
  if (StringUtils.isEmpty(pathHeader) || StringUtils.isEmpty(delimiter) || sourceType == null) {
    throw new IllegalArgumentException(String.format(""String_Node_Str"",pathHeader,delimiter,sourceType));
  }
  BufferedReader reader=null;
  String pigHeaderStr=null;
  try {
    reader=ShifuFileUtils.getReader(pathHeader,sourceType);
    pigHeaderStr=reader.readLine();
    if (StringUtils.isEmpty(pigHeaderStr)) {
      throw new RuntimeException(String.format(""String_Node_Str"",pathHeader));
    }
  }
 catch (  Exception e) {
    log.error(""String_Node_Str"",e);
    throw new ShifuException(ShifuErrorCode.ERROR_HEADER_NOT_FOUND);
  }
 finally {
    IOUtils.closeQuietly(reader);
  }
  List<String> headerList=new ArrayList<String>();
  Set<String> headerSet=new HashSet<String>();
  int index=0;
  for (  String str : Splitter.on(delimiter).split(pigHeaderStr)) {
    String columnName;
    if (isFull) {
      columnName=getFullPigHeaderColumnName(str);
    }
 else {
      columnName=getRelativePigHeaderColumnName(str);
    }
    if (headerSet.contains(columnName)) {
      columnName=columnName + ""String_Node_Str"" + index;
    }
    headerSet.add(columnName);
    index++;
    headerList.add(columnName);
  }
  return headerList.toArray(new String[0]);
}",0.8533333333333334
32126,"@Override public String toString(){
  return ""String_Node_Str"" + ""String_Node_Str"" + id + ""String_Node_Str""+ columnIdList+ '}';
}","@Override public String toString(){
  return ""String_Node_Str"" + ""String_Node_Str"" + id + ""String_Node_Str""+ columnIdList+ ""String_Node_Str"";
}",0.9264705882352942
32127,"/** 
 * Scan the stats result and save them into column configure
 * @param scanner
 */
private void scanStatsResult(Scanner scanner){
  while (scanner.hasNextLine()) {
    String[] raw=scanner.nextLine().trim().split(""String_Node_Str"");
    if (raw.length == 1) {
      continue;
    }
    if (raw.length != 25) {
      log.info(""String_Node_Str"" + raw.length + ""String_Node_Str"");
      log.info(""String_Node_Str"" + Arrays.toString(raw));
    }
    int columnNum=Integer.parseInt(raw[0]);
    try {
      ColumnConfig config=this.columnConfigList.get(columnNum);
      if (config.isCategorical()) {
        String binCategory=Base64Utils.base64Decode(raw[1]);
        config.setBinCategory(CommonUtils.stringToStringList(binCategory,CalculateStatsUDF.CATEGORY_VAL_SEPARATOR));
      }
 else {
        config.setBinBoundary(CommonUtils.stringToDoubleList(raw[1]));
      }
      config.setBinCountNeg(CommonUtils.stringToIntegerList(raw[2]));
      config.setBinCountPos(CommonUtils.stringToIntegerList(raw[3]));
      config.setBinPosCaseRate(CommonUtils.stringToDoubleList(raw[5]));
      config.setBinLength(config.getBinCountNeg().size());
      config.setKs(Double.valueOf(raw[6]));
      config.setIv(Double.valueOf(raw[7]));
      config.setMax(Double.valueOf(raw[8]));
      config.setMin(Double.valueOf(raw[9]));
      config.setMean(Double.valueOf(raw[10]));
      config.setStdDev(Double.valueOf(raw[11]));
      if (raw[12].equals(""String_Node_Str"")) {
        config.setColumnType(ColumnType.N);
      }
 else {
        config.setColumnType(ColumnType.C);
      }
      config.setMedian(Double.valueOf(raw[13]));
      config.setMissingCnt(Long.valueOf(raw[14]));
      config.setTotalCount(Long.valueOf(raw[15]));
      config.setMissingPercentage(Double.valueOf(raw[16]));
      config.setBinWeightedNeg(CommonUtils.stringToDoubleList(raw[17]));
      config.setBinWeightedPos(CommonUtils.stringToDoubleList(raw[18]));
      config.getColumnStats().setWoe(Double.valueOf(raw[19]));
      config.getColumnStats().setWeightedWoe(Double.valueOf(raw[20]));
      config.getColumnStats().setWeightedKs(Double.valueOf(raw[21]));
      config.getColumnStats().setWeightedIv(Double.valueOf(raw[22]));
      config.getColumnBinning().setBinCountWoe(CommonUtils.stringToDoubleList(raw[23]));
      config.getColumnBinning().setBinWeightedWoe(CommonUtils.stringToDoubleList(raw[24]));
    }
 catch (    Exception e) {
      log.error(""String_Node_Str"",columnNum,this.columnConfigList.get(columnNum).getColumnName(),e.getMessage());
      continue;
    }
  }
}","/** 
 * Scan the stats result and save them into column configure
 * @param scanner
 */
private void scanStatsResult(Scanner scanner){
  while (scanner.hasNextLine()) {
    String[] raw=scanner.nextLine().trim().split(""String_Node_Str"");
    if (raw.length == 1) {
      continue;
    }
    if (raw.length != 25) {
      log.info(""String_Node_Str"" + raw.length + ""String_Node_Str"");
      log.info(""String_Node_Str"" + Arrays.toString(raw));
    }
    int columnNum=Integer.parseInt(raw[0]);
    try {
      ColumnConfig config=this.columnConfigList.get(columnNum);
      if (config.isCategorical()) {
        String binCategory=Base64Utils.base64Decode(raw[1]);
        config.setBinCategory(CommonUtils.stringToStringList(binCategory,CalculateStatsUDF.CATEGORY_VAL_SEPARATOR));
      }
 else {
        config.setBinBoundary(CommonUtils.stringToDoubleList(raw[1]));
      }
      config.setBinCountNeg(CommonUtils.stringToIntegerList(raw[2]));
      config.setBinCountPos(CommonUtils.stringToIntegerList(raw[3]));
      config.setBinPosCaseRate(CommonUtils.stringToDoubleList(raw[5]));
      config.setBinLength(config.getBinCountNeg().size());
      config.setKs(parseDouble(raw[6]));
      config.setIv(parseDouble(raw[7]));
      config.setMax(parseDouble(raw[8]));
      config.setMin(parseDouble(raw[9]));
      config.setMean(parseDouble(raw[10]));
      config.setStdDev(parseDouble(raw[11],Double.NaN));
      if (raw[12].equals(""String_Node_Str"")) {
        config.setColumnType(ColumnType.N);
      }
 else {
        config.setColumnType(ColumnType.C);
      }
      config.setMedian(parseDouble(raw[13]));
      config.setMissingCnt(parseLong(raw[14]));
      config.setTotalCount(parseLong(raw[15]));
      config.setMissingPercentage(parseDouble(raw[16]));
      config.setBinWeightedNeg(CommonUtils.stringToDoubleList(raw[17]));
      config.setBinWeightedPos(CommonUtils.stringToDoubleList(raw[18]));
      config.getColumnStats().setWoe(parseDouble(raw[19]));
      config.getColumnStats().setWeightedWoe(parseDouble(raw[20]));
      config.getColumnStats().setWeightedKs(parseDouble(raw[21]));
      config.getColumnStats().setWeightedIv(parseDouble(raw[22]));
      config.getColumnBinning().setBinCountWoe(CommonUtils.stringToDoubleList(raw[23]));
      config.getColumnBinning().setBinWeightedWoe(CommonUtils.stringToDoubleList(raw[24]));
    }
 catch (    Exception e) {
      log.error(""String_Node_Str"",columnNum,this.columnConfigList.get(columnNum).getColumnName(),e.getMessage());
      continue;
    }
  }
}",0.9621345889739062
32128,"@Override public void doWrite(DataOutput out) throws IOException {
  out.writeInt(this.seedList.size());
  for (  CandidateSeed seed : this.seedList) {
    out.write(seed.getId());
    List<Integer> columnIdList=seed.getColumnIdList();
    out.write(columnIdList.size());
    for (    Integer columnId : columnIdList) {
      out.write(columnId);
    }
  }
}","@Override public void doWrite(DataOutput out) throws IOException {
  out.writeInt(this.seedList.size());
  for (  CandidateSeed seed : this.seedList) {
    out.writeInt(seed.getId());
    List<Integer> columnIdList=seed.getColumnIdList();
    out.writeInt(columnIdList.size());
    for (    Integer columnId : columnIdList) {
      out.writeInt(columnId);
    }
  }
}",0.9875862068965516
32129,"/** 
 * Get the method-style name of the property. (UPPER the first character:))
 * @param fildeName
 * @return first character Upper style
 */
private static String getMethodName(String fildeName){
  byte[] items=fildeName.getBytes();
  items[0]=(byte)((char)items[0] - 'a' + 'A');
  return new String(items);
}","/** 
 * Get the method-style name of the property. (UPPER the first character:))
 * @param fieldName
 * @return first character Upper style
 */
private static String getMethodName(String fieldName){
  return StringUtils.capitalize(fieldName);
}",0.7230215827338129
32130,"@Override public MetaGroup clone(){
  MetaGroup metaGroup=new MetaGroup();
  metaGroup.setGroup(group);
  if (CollectionUtils.isNotEmpty(metaList)) {
    List<MetaItem> metas=new ArrayList<MetaItem>();
    for (    MetaItem metaItem : metaList) {
      metas.add(metaItem.clone());
    }
    metaGroup.setMetaList(metas);
  }
  return metaGroup;
}","@Override public MetaGroup clone(){
  MetaGroup metaGroup=null;
  try {
    metaGroup=(MetaGroup)super.clone();
  }
 catch (  CloneNotSupportedException e) {
    throw new InternalError(e.toString());
  }
  metaGroup.setGroup(group);
  if (CollectionUtils.isNotEmpty(metaList)) {
    List<MetaItem> metas=new ArrayList<MetaItem>();
    for (    MetaItem metaItem : metaList) {
      metas.add(metaItem.clone());
    }
    metaGroup.setMetaList(metas);
  }
  return metaGroup;
}",0.8106796116504854
32131,"@Override public MetaItem clone(){
  MetaItem copy=new MetaItem();
  copy.setName(name);
  copy.setType(type);
  copy.setDefval(defval);
  copy.setMaxLength(maxLength);
  copy.setMinLength(minLength);
  copy.setOptions(options);
  copy.setElementType(elementType);
  if (CollectionUtils.isNotEmpty(element)) {
    List<MetaItem> elementList=new ArrayList<MetaItem>();
    for (    MetaItem meta : element) {
      elementList.add(meta.clone());
    }
    copy.setElement(elementList);
  }
  return copy;
}","@Override public MetaItem clone(){
  MetaItem copy=null;
  try {
    copy=(MetaItem)super.clone();
  }
 catch (  CloneNotSupportedException e) {
    throw new InternalError(e.toString());
  }
  copy.setName(name);
  copy.setType(type);
  copy.setDefval(defval);
  copy.setMaxLength(maxLength);
  copy.setMinLength(minLength);
  copy.setOptions(options);
  copy.setElementType(elementType);
  if (CollectionUtils.isNotEmpty(element)) {
    List<MetaItem> elementList=new ArrayList<MetaItem>();
    for (    MetaItem meta : element) {
      elementList.add(meta.clone());
    }
    copy.setElement(elementList);
  }
  return copy;
}",0.8704845814977974
32132,"/** 
 * categorical binning
 */
private void doCategoricalBinning(){
  Map<String,Integer> categoryHistNeg=new HashMap<String,Integer>();
  Map<String,Integer> categoryHistPos=new HashMap<String,Integer>();
  Map<String,Double> categoryWeightedNeg=new HashMap<String,Double>();
  Map<String,Double> categoryWeightedPos=new HashMap<String,Double>();
  Set<String> categorySet=new HashSet<String>();
  for (int i=0; i < voSize; i++) {
    String category=voList.get(i).getRaw();
    categorySet.add(category);
    if (negTags.contains(voList.get(i).getTag())) {
      incMapCnt(categoryHistNeg,category);
      incMapWithValue(categoryWeightedNeg,category,voList.get(i).getWeight());
    }
 else {
      incMapCnt(categoryHistPos,category);
      incMapWithValue(categoryWeightedPos,category,voList.get(i).getWeight());
    }
  }
  Map<String,Double> categoryFraudRateMap=new HashMap<String,Double>();
  for (  String key : categorySet) {
    double cnt0=categoryHistNeg.containsKey(key) ? categoryHistNeg.get(key) : 0;
    double cnt1=categoryHistPos.containsKey(key) ? categoryHistPos.get(key) : 0;
    double rate;
    if (cnt0 + cnt1 == 0) {
      rate=0;
    }
 else {
      rate=cnt1 / (cnt0 + cnt1);
    }
    categoryFraudRateMap.put(key,rate);
  }
  MapComparator cmp=new MapComparator(categoryFraudRateMap);
  Map<String,Double> sortedCategoryFraudRateMap=new TreeMap<String,Double>(cmp);
  sortedCategoryFraudRateMap.putAll(categoryFraudRateMap);
  for (  Map.Entry<String,Double> entry : sortedCategoryFraudRateMap.entrySet()) {
    String key=entry.getKey();
    Integer countNeg=categoryHistNeg.containsKey(key) ? categoryHistNeg.get(key) : 0;
    binCountNeg.add(countNeg);
    Integer countPos=categoryHistPos.containsKey(key) ? categoryHistPos.get(key) : 0;
    binCountPos.add(countPos);
    Double weightedNeg=categoryWeightedNeg.containsKey(key) ? categoryWeightedNeg.get(key) : 0.0;
    this.binWeightedNeg.add(weightedNeg);
    Double weightedPos=categoryWeightedPos.containsKey(key) ? categoryWeightedPos.get(key) : 0.0;
    this.binWeightedPos.add(weightedPos);
    binAvgScore.add(0);
    binCategory.add(key);
    binPosCaseRate.add(entry.getValue());
  }
  this.actualNumBins=binCategory.size();
  for (  ValueObject vo : voList) {
    String key=vo.getRaw();
    if (binCategory.indexOf(key) == -1) {
      vo.setValue(0.0);
    }
 else {
      vo.setValue(binPosCaseRate.get(binCategory.indexOf(key)));
    }
  }
}","/** 
 * categorical binning
 */
private void doCategoricalBinning(){
  Map<String,Integer> categoryHistNeg=new HashMap<String,Integer>();
  Map<String,Integer> categoryHistPos=new HashMap<String,Integer>();
  Map<String,Double> categoryWeightedNeg=new HashMap<String,Double>();
  Map<String,Double> categoryWeightedPos=new HashMap<String,Double>();
  Set<String> categorySet=new HashSet<String>();
  for (int i=0; i < voSize; i++) {
    String category=voList.get(i).getRaw();
    categorySet.add(category);
    if (negTags.contains(voList.get(i).getTag())) {
      incMapCnt(categoryHistNeg,category);
      incMapWithValue(categoryWeightedNeg,category,voList.get(i).getWeight());
    }
 else {
      incMapCnt(categoryHistPos,category);
      incMapWithValue(categoryWeightedPos,category,voList.get(i).getWeight());
    }
  }
  Map<String,Double> categoryFraudRateMap=new HashMap<String,Double>();
  for (  String key : categorySet) {
    double cnt0=categoryHistNeg.containsKey(key) ? categoryHistNeg.get(key) : 0;
    double cnt1=categoryHistPos.containsKey(key) ? categoryHistPos.get(key) : 0;
    double rate;
    if (Double.compare(cnt0 + cnt1,0) == 0) {
      rate=0;
    }
 else {
      rate=cnt1 / (cnt0 + cnt1);
    }
    categoryFraudRateMap.put(key,rate);
  }
  MapComparator cmp=new MapComparator(categoryFraudRateMap);
  Map<String,Double> sortedCategoryFraudRateMap=new TreeMap<String,Double>(cmp);
  sortedCategoryFraudRateMap.putAll(categoryFraudRateMap);
  for (  Map.Entry<String,Double> entry : sortedCategoryFraudRateMap.entrySet()) {
    String key=entry.getKey();
    Integer countNeg=categoryHistNeg.containsKey(key) ? categoryHistNeg.get(key) : 0;
    binCountNeg.add(countNeg);
    Integer countPos=categoryHistPos.containsKey(key) ? categoryHistPos.get(key) : 0;
    binCountPos.add(countPos);
    Double weightedNeg=categoryWeightedNeg.containsKey(key) ? categoryWeightedNeg.get(key) : 0.0;
    this.binWeightedNeg.add(weightedNeg);
    Double weightedPos=categoryWeightedPos.containsKey(key) ? categoryWeightedPos.get(key) : 0.0;
    this.binWeightedPos.add(weightedPos);
    binAvgScore.add(0);
    binCategory.add(key);
    binPosCaseRate.add(entry.getValue());
  }
  this.actualNumBins=binCategory.size();
  for (  ValueObject vo : voList) {
    String key=vo.getRaw();
    if (binCategory.indexOf(key) == -1) {
      vo.setValue(0.0);
    }
 else {
      vo.setValue(binPosCaseRate.get(binCategory.indexOf(key)));
    }
  }
}",0.9963265306122449
32133,"@Override public void postApplication(MasterContext<VarSelMasterResult,VarSelWorkerResult> context){
  VarSelMasterResult varSelMasterResult=context.getMasterResult();
  List<Integer> results=varSelMasterResult.getColumnIdList();
  LOG.info(""String_Node_Str"" + results);
  Path out=new Path(context.getProps().getProperty(Constants.VAR_SEL_COLUMN_IDS_OUPUT));
  writeColumnIdsIntoHDFS(out,results);
}","@Override public void postApplication(MasterContext<VarSelMasterResult,VarSelWorkerResult> context){
  VarSelMasterResult varSelMasterResult=context.getMasterResult();
  List<Integer> results=varSelMasterResult.getColumnIdList();
  LOG.info(""String_Node_Str"" + results);
  String out=context.getProps().getProperty(Constants.VAR_SEL_COLUMN_IDS_OUPUT);
  writeColumnIdsIntoHDFS(out,results);
}",0.9747474747474748
32134,"private void writeColumnIdsIntoHDFS(Path path,List<Integer> columnIds){
  PrintWriter pw=null;
  try {
    FSDataOutputStream fos=FileSystem.get(new Configuration()).create(path);
    pw=new PrintWriter(fos);
    pw.println(Integer.toString(columnIds.size()) + ""String_Node_Str"" + columnIds.toString());
    pw.flush();
  }
 catch (  IOException e) {
    e.printStackTrace();
    LOG.error(""String_Node_Str"",e);
  }
 finally {
    IOUtils.closeStream(pw);
  }
}","private void writeColumnIdsIntoHDFS(String path,List<Integer> columnIds){
  BufferedWriter bw=null;
  try {
    bw=ShifuFileUtils.getWriter(path,SourceType.HDFS);
    bw.write(String.format(""String_Node_Str"",Integer.toString(columnIds.size()),columnIds.toString()));
    bw.newLine();
    bw.flush();
  }
 catch (  IOException e) {
    e.printStackTrace();
    LOG.error(""String_Node_Str"",e);
  }
 finally {
    IOUtils.closeStream(bw);
  }
}",0.593576965669989
32135,"/** 
 * create HEAD file contain the workspace
 * @param modelName
 * @throws IOException
 */
protected void createHead(String modelName) throws IOException {
  File header=new File(modelName == null ? ""String_Node_Str"" : modelName + ""String_Node_Str"");
  if (header.exists())   return;
  BufferedWriter writer=null;
  try {
    header.createNewFile();
    writer=new BufferedWriter(new FileWriter(header));
    writer.write(""String_Node_Str"");
  }
 catch (  IOException e) {
    log.error(""String_Node_Str"");
  }
 finally {
    if (writer != null) {
      writer.close();
    }
  }
}","/** 
 * create HEAD file contain the workspace
 * @param modelName
 * @throws IOException
 */
protected void createHead(String modelName) throws IOException {
  File header=new File(modelName == null ? ""String_Node_Str"" : modelName + ""String_Node_Str"");
  if (header.exists())   return;
  BufferedWriter writer=null;
  try {
    if (!header.createNewFile()) {
      log.error(""String_Node_Str"",header.getAbsolutePath());
    }
 else {
      writer=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(header),Constants.DEFAULT_CHARSET));
      writer.write(""String_Node_Str"");
    }
  }
 catch (  IOException e) {
    log.error(""String_Node_Str"");
  }
 finally {
    if (writer != null) {
      writer.close();
    }
  }
}",0.8677811550151976
32136,"/** 
 * Create expressions for multi weight settings
 * @param weightExprList
 * @return weight expression map
 */
protected Map<Expression,Double> createExpressionMap(List<WeightAmplifier> weightExprList){
  Map<Expression,Double> ewMap=new HashMap<Expression,Double>();
  if (CollectionUtils.isNotEmpty(weightExprList)) {
    JexlEngine jexl=new JexlEngine();
    for (    WeightAmplifier we : weightExprList) {
      ewMap.put(jexl.createExpression(we.getTargetExpression()),Double.valueOf(we.getTargetWeight()));
    }
  }
  return ewMap;
}","/** 
 * Create expressions for multi weight settings
 * @param weightExprList
 * @return weight expression map
 */
protected Map<Expression,Double> createExpressionMap(List<WeightAmplifier> weightExprList){
  Map<Expression,Double> ewMap=new HashMap<Expression,Double>();
  if (CollectionUtils.isNotEmpty(weightExprList)) {
    JexlEngine jexl=new JexlEngine();
    for (    WeightAmplifier we : weightExprList) {
      ewMap.put(jexl.createExpression(we.getTargetExpression()),we.getTargetWeight());
    }
  }
  return ewMap;
}",0.9832089552238806
32137,"@Override public void load(GuaguaWritableAdapter<LongWritable> currentKey,GuaguaWritableAdapter<Text> currentValue,WorkerContext<NNParams,NNParams> workerContext){
  ++this.count;
  if ((this.count) % 100000 == 0) {
    LOG.info(""String_Node_Str"",this.count);
  }
  double baggingSampleRate=this.modelConfig.getBaggingSampleRate();
  if (!this.modelConfig.isFixInitialInput() && Double.valueOf(Math.random()).compareTo(baggingSampleRate) >= 0) {
    return;
  }
  double[] inputs=new double[this.inputNodeCount];
  double[] ideal=new double[this.outputNodeCount];
  if (this.isDry) {
    addDataPairToDataSet(0,new BasicMLDataPair(new BasicMLData(inputs),new BasicMLData(ideal)));
    return;
  }
  long hashcode=0;
  double significance=NNConstants.DEFAULT_SIGNIFICANCE_VALUE;
  int index=0, inputsIndex=0, outputIndex=0;
  for (  String input : DEFAULT_SPLITTER.split(currentValue.getWritable().toString())) {
    double doubleValue=NumberFormatUtils.getDouble(input.trim(),0.0d);
    if (index == this.columnConfigList.size()) {
      significance=NumberFormatUtils.getDouble(input,NNConstants.DEFAULT_SIGNIFICANCE_VALUE);
      break;
    }
 else {
      ColumnConfig columnConfig=this.columnConfigList.get(index);
      if (columnConfig != null && columnConfig.isTarget()) {
        ideal[outputIndex++]=doubleValue;
      }
 else {
        if (this.inputNodeCount == this.candidateCount) {
          if (CommonUtils.isGoodCandidate(columnConfig)) {
            inputs[inputsIndex++]=doubleValue;
            hashcode=hashcode * 31 + Double.valueOf(doubleValue).hashCode();
          }
        }
 else {
          if (columnConfig != null && !columnConfig.isMeta() && !columnConfig.isTarget() && columnConfig.isFinalSelect()) {
            inputs[inputsIndex++]=doubleValue;
            hashcode=hashcode * 31 + Double.valueOf(doubleValue).hashCode();
          }
        }
      }
    }
    index++;
  }
  long longBaggingSampleRate=Double.valueOf(baggingSampleRate * 100).longValue();
  if (this.modelConfig.isFixInitialInput() && hashcode % 100 >= longBaggingSampleRate) {
    return;
  }
  ++this.sampleCount;
  MLDataPair pair=new BasicMLDataPair(new BasicMLData(inputs),new BasicMLData(ideal));
  pair.setSignificance(significance);
  addDataPairToDataSet(hashcode,pair);
}","@Override public void load(GuaguaWritableAdapter<LongWritable> currentKey,GuaguaWritableAdapter<Text> currentValue,WorkerContext<NNParams,NNParams> workerContext){
  ++this.count;
  if ((this.count) % 100000 == 0) {
    LOG.info(""String_Node_Str"",this.count);
  }
  double baggingSampleRate=this.modelConfig.getBaggingSampleRate();
  if (!this.modelConfig.isFixInitialInput() && Double.compare(Math.random(),baggingSampleRate) >= 0) {
    return;
  }
  double[] inputs=new double[this.inputNodeCount];
  double[] ideal=new double[this.outputNodeCount];
  if (this.isDry) {
    addDataPairToDataSet(0,new BasicMLDataPair(new BasicMLData(inputs),new BasicMLData(ideal)));
    return;
  }
  long hashcode=0;
  double significance=NNConstants.DEFAULT_SIGNIFICANCE_VALUE;
  int index=0, inputsIndex=0, outputIndex=0;
  for (  String input : DEFAULT_SPLITTER.split(currentValue.getWritable().toString())) {
    double doubleValue=NumberFormatUtils.getDouble(input.trim(),0.0d);
    if (index == this.columnConfigList.size()) {
      significance=NumberFormatUtils.getDouble(input,NNConstants.DEFAULT_SIGNIFICANCE_VALUE);
      break;
    }
 else {
      ColumnConfig columnConfig=this.columnConfigList.get(index);
      if (columnConfig != null && columnConfig.isTarget()) {
        ideal[outputIndex++]=doubleValue;
      }
 else {
        if (this.inputNodeCount == this.candidateCount) {
          if (CommonUtils.isGoodCandidate(columnConfig)) {
            inputs[inputsIndex++]=doubleValue;
            hashcode=hashcode * 31 + Double.valueOf(doubleValue).hashCode();
          }
        }
 else {
          if (columnConfig != null && !columnConfig.isMeta() && !columnConfig.isTarget() && columnConfig.isFinalSelect()) {
            inputs[inputsIndex++]=doubleValue;
            hashcode=hashcode * 31 + Double.valueOf(doubleValue).hashCode();
          }
        }
      }
    }
    index++;
  }
  long longBaggingSampleRate=Double.valueOf(baggingSampleRate * 100).longValue();
  if (this.modelConfig.isFixInitialInput() && hashcode % 100 >= longBaggingSampleRate) {
    return;
  }
  ++this.sampleCount;
  MLDataPair pair=new BasicMLDataPair(new BasicMLData(inputs),new BasicMLData(ideal));
  pair.setSignificance(significance);
  addDataPairToDataSet(hashcode,pair);
}",0.9940750493745886
32138,"/** 
 * From Trainer, the logic is to random choose items in master dataset, but I don't want to load data twice for saving memory. Use this to mock raw random repeat logic. This should be some logic difference because of data are not loaded into data set, not random.
 */
private void mockRandomRepeatData(double crossValidationRate,double random){
  long trainingSize=this.trainingData.getRecordCount();
  long testingSize=this.testingData.getRecordCount();
  long size=trainingSize + testingSize;
  int next=RandomUtils.nextInt((int)size);
  MLDataPair dataPair=new BasicMLDataPair(new BasicMLData(new double[this.inputNodeCount]),new BasicMLData(new double[this.outputNodeCount]));
  if (next >= trainingSize) {
    this.testingData.getRecord(next - trainingSize,dataPair);
  }
 else {
    this.trainingData.getRecord(next,dataPair);
  }
  if (Double.valueOf(random).compareTo(Double.valueOf(crossValidationRate)) < 0) {
    this.testingData.add(dataPair);
  }
 else {
    this.trainingData.add(dataPair);
  }
}","/** 
 * From Trainer, the logic is to random choose items in master dataset, but I don't want to load data twice for saving memory. Use this to mock raw random repeat logic. This should be some logic difference because of data are not loaded into data set, not random.
 */
private void mockRandomRepeatData(double crossValidationRate,double random){
  long trainingSize=this.trainingData.getRecordCount();
  long testingSize=this.testingData.getRecordCount();
  long size=trainingSize + testingSize;
  int next=RandomUtils.nextInt((int)size);
  MLDataPair dataPair=new BasicMLDataPair(new BasicMLData(new double[this.inputNodeCount]),new BasicMLData(new double[this.outputNodeCount]));
  if (next >= trainingSize) {
    this.testingData.getRecord(next - trainingSize,dataPair);
  }
 else {
    this.trainingData.getRecord(next,dataPair);
  }
  if (Double.compare(random,crossValidationRate) < 0) {
    this.testingData.add(dataPair);
  }
 else {
    this.trainingData.add(dataPair);
  }
}",0.9785322016974538
32139,"/** 
 * Only baggingWithReplacement is set and size over NNConstants.NN_BAGGING_THRESHOLD, and random value <= 1/size. We choose use existing data to add training data set and testing data set.
 */
private boolean isBaggingReplacementTrigged(double random){
  long trainingSize=this.trainingData.getRecordCount();
  long testingSize=this.testingData.getRecordCount();
  long size=trainingSize + testingSize;
  return this.modelConfig.isBaggingWithReplacement() && (testingSize > 0) && (trainingSize > 0)&& (size > NNConstants.NN_BAGGING_THRESHOLD)&& (Double.valueOf(random).compareTo(Double.valueOf(0.5d)) < 0);
}","/** 
 * Only baggingWithReplacement is set and size over NNConstants.NN_BAGGING_THRESHOLD, and random value <= 1/size. We choose use existing data to add training data set and testing data set.
 */
private boolean isBaggingReplacementTrigged(double random){
  long trainingSize=this.trainingData.getRecordCount();
  long testingSize=this.testingData.getRecordCount();
  long size=trainingSize + testingSize;
  return this.modelConfig.isBaggingWithReplacement() && (testingSize > 0) && (trainingSize > 0)&& (size > NNConstants.NN_BAGGING_THRESHOLD)&& (Double.compare(random,0.5d) < 0);
}",0.964136780650542
32140,"/** 
 * Add data pair to data set according to random number compare with crossValidationRate.
 */
private void addDataPairToDataSet(MLDataPair pair,double crossValidationRate,double random){
  if (Double.valueOf(random).compareTo(Double.valueOf(crossValidationRate)) < 0) {
    this.testingData.add(pair);
  }
 else {
    this.trainingData.add(pair);
  }
}","/** 
 * Add data pair to data set according to random number compare with crossValidationRate.
 */
private void addDataPairToDataSet(MLDataPair pair,double crossValidationRate,double random){
  if (Double.compare(random,crossValidationRate) < 0) {
    this.testingData.add(pair);
  }
 else {
    this.trainingData.add(pair);
  }
}",0.9170305676855895
32141,"/** 
 * read the binary average score and update them into column list
 * @param columnConfigList
 * @return
 * @throws IOException
 */
private List<ColumnConfig> updateColumnConfigWithBinAvgScore(List<ColumnConfig> columnConfigList) throws IOException {
  List<Scanner> scanners=ShifuFileUtils.getDataScanners(pathFinder.getBinAvgScorePath(),modelConfig.getDataSet().getSource());
  for (  Scanner scanner : scanners) {
    while (scanner.hasNextLine()) {
      List<Integer> scores=new ArrayList<Integer>();
      String[] raw=scanner.nextLine().split(""String_Node_Str"");
      int columnNum=Integer.valueOf(raw[0]);
      for (int i=1; i < raw.length; i++) {
        scores.add(Integer.valueOf(raw[i]));
      }
      ColumnConfig config=columnConfigList.get(columnNum);
      config.setBinAvgScore(scores);
    }
  }
  closeScanners(scanners);
  return columnConfigList;
}","/** 
 * read the binary average score and update them into column list
 * @param columnConfigList
 * @return
 * @throws IOException
 */
private List<ColumnConfig> updateColumnConfigWithBinAvgScore(List<ColumnConfig> columnConfigList) throws IOException {
  List<Scanner> scanners=ShifuFileUtils.getDataScanners(pathFinder.getBinAvgScorePath(),modelConfig.getDataSet().getSource());
  for (  Scanner scanner : scanners) {
    while (scanner.hasNextLine()) {
      List<Integer> scores=new ArrayList<Integer>();
      String[] raw=scanner.nextLine().split(""String_Node_Str"");
      int columnNum=Integer.parseInt(raw[0]);
      for (int i=1; i < raw.length; i++) {
        scores.add(Integer.valueOf(raw[i]));
      }
      ColumnConfig config=columnConfigList.get(columnNum);
      config.setBinAvgScore(scores);
    }
  }
  closeScanners(scanners);
  return columnConfigList;
}",0.9914432401597262
32142,"private int persistColumnIds(Path path){
  try {
    List<Scanner> scanners=ShifuFileUtils.getDataScanners(path.toString(),modelConfig.getDataSet().getSource());
    List<Integer> ids=null;
    for (    Scanner scanner : scanners) {
      while (scanner.hasNextLine()) {
        String[] raw=scanner.nextLine().trim().split(""String_Node_Str"");
        @SuppressWarnings(""String_Node_Str"") int idSize=Integer.valueOf(raw[0]);
        ids=CommonUtils.stringToIntegerList(raw[1]);
      }
    }
    for (    ColumnConfig config : columnConfigList) {
      if (!config.isForceSelect()) {
        config.setFinalSelect(Boolean.FALSE);
      }
    }
    for (    Integer id : ids) {
      this.columnConfigList.get(id).setFinalSelect(Boolean.TRUE);
    }
    super.saveColumnConfigList();
  }
 catch (  IOException e) {
    e.printStackTrace();
    return -1;
  }
catch (  IllegalArgumentException e) {
    e.printStackTrace();
    return -1;
  }
  return 0;
}","private int persistColumnIds(Path path){
  try {
    List<Scanner> scanners=ShifuFileUtils.getDataScanners(path.toString(),modelConfig.getDataSet().getSource());
    List<Integer> ids=null;
    for (    Scanner scanner : scanners) {
      while (scanner.hasNextLine()) {
        String[] raw=scanner.nextLine().trim().split(""String_Node_Str"");
        @SuppressWarnings(""String_Node_Str"") int idSize=Integer.parseInt(raw[0]);
        ids=CommonUtils.stringToIntegerList(raw[1]);
      }
    }
    for (    ColumnConfig config : columnConfigList) {
      if (!config.isForceSelect()) {
        config.setFinalSelect(Boolean.FALSE);
      }
    }
    for (    Integer id : ids) {
      this.columnConfigList.get(id).setFinalSelect(Boolean.TRUE);
    }
    super.saveColumnConfigList();
  }
 catch (  IOException e) {
    e.printStackTrace();
    return -1;
  }
catch (  IllegalArgumentException e) {
    e.printStackTrace();
    return -1;
  }
  return 0;
}",0.9921424829753798
32143,"@Override public int compare(Pair o1,Pair o2){
  return Double.valueOf(o2.value.getRms()).compareTo(Double.valueOf(o1.value.getRms()));
}","@Override public int compare(Pair o1,Pair o2){
  return Double.compare(o2.value.getRms(),o1.value.getRms());
}",0.8421052631578947
32144,"@Override protected void cleanup(Context context) throws IOException, InterruptedException {
  Collections.sort(this.results,new Comparator<Pair>(){
    @Override public int compare(    Pair o1,    Pair o2){
      return Double.valueOf(o2.value.getRms()).compareTo(Double.valueOf(o1.value.getRms()));
    }
  }
);
  LOG.debug(""String_Node_Str"",this.results);
  int candidates=0;
  if (Constants.WRAPPER_BY_REMOVE.equalsIgnoreCase(this.wrapperBy) || Constants.WRAPPER_BY_SE.equalsIgnoreCase(this.wrapperBy)) {
    candidates=(int)(this.inputNodeCount * (1.0f - this.wrapperRatio));
  }
 else {
    candidates=(int)(this.inputNodeCount * (this.wrapperRatio));
  }
  for (int i=0; i < this.results.size(); i++) {
    Pair pair=this.results.get(i);
    this.outputKey.set(pair.key + ""String_Node_Str"");
    if (i < candidates) {
      context.write(this.outputKey,OUTPUT_VALUE);
    }
    StringBuilder sb=new StringBuilder(100);
    sb.append(this.columnConfigList.get((int)pair.key).getColumnName()).append(""String_Node_Str"").append(pair.value.getMean()).append(""String_Node_Str"").append(pair.value.getRms()).append(""String_Node_Str"").append(pair.value.getVariance());
    this.outputValue.set(sb.toString());
    this.mos.write(Constants.SHIFU_VARSELECT_SE_OUTPUT_NAME,this.outputKey,this.outputValue);
  }
  this.mos.close();
}","@Override protected void cleanup(Context context) throws IOException, InterruptedException {
  Collections.sort(this.results,new Comparator<Pair>(){
    @Override public int compare(    Pair o1,    Pair o2){
      return Double.compare(o2.value.getRms(),o1.value.getRms());
    }
  }
);
  LOG.debug(""String_Node_Str"",this.results);
  int candidates=0;
  if (Constants.WRAPPER_BY_REMOVE.equalsIgnoreCase(this.wrapperBy) || Constants.WRAPPER_BY_SE.equalsIgnoreCase(this.wrapperBy)) {
    candidates=(int)(this.inputNodeCount * (1.0f - this.wrapperRatio));
  }
 else {
    candidates=(int)(this.inputNodeCount * (this.wrapperRatio));
  }
  for (int i=0; i < this.results.size(); i++) {
    Pair pair=this.results.get(i);
    this.outputKey.set(pair.key + ""String_Node_Str"");
    if (i < candidates) {
      context.write(this.outputKey,OUTPUT_VALUE);
    }
    StringBuilder sb=new StringBuilder(100);
    sb.append(this.columnConfigList.get((int)pair.key).getColumnName()).append(""String_Node_Str"").append(pair.value.getMean()).append(""String_Node_Str"").append(pair.value.getRms()).append(""String_Node_Str"").append(pair.value.getVariance());
    this.outputValue.set(sb.toString());
    this.mos.write(Constants.SHIFU_VARSELECT_SE_OUTPUT_NAME,this.outputKey,this.outputValue);
  }
  this.mos.close();
}",0.9836315188427864
32145,"/** 
 * Create expressions for multi weight settings
 * @param weightExprList
 * @return weight expression map
 */
protected Map<Expression,Double> createExpressionMap(List<WeightAmplifier> weightExprList){
  Map<Expression,Double> ewMap=new HashMap<Expression,Double>();
  if (CollectionUtils.isNotEmpty(weightExprList)) {
    JexlEngine jexl=new JexlEngine();
    for (    WeightAmplifier we : weightExprList) {
      ewMap.put(jexl.createExpression(we.getTargetExpression()),Double.valueOf(we.getTargetWeight()));
    }
  }
  return ewMap;
}","/** 
 * Create expressions for multi weight settings
 * @param weightExprList
 * @return weight expression map
 */
protected Map<Expression,Double> createExpressionMap(List<WeightAmplifier> weightExprList){
  Map<Expression,Double> ewMap=new HashMap<Expression,Double>();
  if (CollectionUtils.isNotEmpty(weightExprList)) {
    JexlEngine jexl=new JexlEngine();
    for (    WeightAmplifier we : weightExprList) {
      ewMap.put(jexl.createExpression(we.getTargetExpression()),we.getTargetWeight());
    }
  }
  return ewMap;
}",0.9832089552238806
32146,"@Test public void testFilter(){
  modelConfig.getVarSelect().setFilterBy(""String_Node_Str"");
  VariableSelector selector=new VariableSelector(modelConfig,columnConfigList);
  List<ColumnConfig> selected=selector.selectByFilter();
  Integer i=0;
  for (  ColumnConfig config : selected) {
    if (config.isFinalSelect())     i++;
  }
  Assert.assertEquals(i,Integer.valueOf(modelConfig.getVarSelectFilterNum()));
  modelConfig.getVarSelect().setFilterBy(""String_Node_Str"");
  selector=new VariableSelector(modelConfig,columnConfigList);
  selector.selectByFilter();
  Assert.assertEquals(i,Integer.valueOf(modelConfig.getVarSelectFilterNum()));
  modelConfig.getVarSelect().setFilterBy(""String_Node_Str"");
  selector=new VariableSelector(modelConfig,columnConfigList);
  selector.selectByFilter();
  Assert.assertEquals(i,Integer.valueOf(modelConfig.getVarSelectFilterNum()));
}","@Test public void testFilter(){
  modelConfig.getVarSelect().setFilterBy(""String_Node_Str"");
  VariableSelector selector=new VariableSelector(modelConfig,columnConfigList);
  List<ColumnConfig> selected=selector.selectByFilter();
  Integer i=0;
  for (  ColumnConfig config : selected) {
    if (config.isFinalSelect())     i++;
  }
  Assert.assertEquals(i,modelConfig.getVarSelectFilterNum());
  modelConfig.getVarSelect().setFilterBy(""String_Node_Str"");
  selector=new VariableSelector(modelConfig,columnConfigList);
  selector.selectByFilter();
  Assert.assertEquals(i,Integer.valueOf(modelConfig.getVarSelectFilterNum()));
  modelConfig.getVarSelect().setFilterBy(""String_Node_Str"");
  selector=new VariableSelector(modelConfig,columnConfigList);
  selector.selectByFilter();
  Assert.assertEquals(i,Integer.valueOf(modelConfig.getVarSelectFilterNum()));
}",0.9902130109383996
32147,"/** 
 * Constructor for Integration API, if user use this constructor to construct @ModelRunner, only compute(Map<String, String> rawDataMap) is supported to call. That means client is responsible for preparing the input data map.
 * @param columnConfigList - @ColumnConfig list for Model
 * @param models           - models
 * @param stdDevCutoff     - the standard deviation cutoff to normalize data
 */
public ModelRunner(List<ColumnConfig> columnConfigList,List<BasicML> models,double stdDevCutoff){
  this.columnConfigList=columnConfigList;
  this.scorer=new Scorer(models,columnConfigList,ALGORITHM.NN.name(),stdDevCutoff);
}","/** 
 * Constructor for Integration API, if user use this constructor to construct @ModelRunner, only compute(Map<String, String> rawDataMap) is supported to call. That means client is responsible for preparing the input data map.
 * @param columnConfigList - @ColumnConfig list for Model
 * @param models - models
 * @param stdDevCutoff - the standard deviation cutoff to normalize data
 */
public ModelRunner(ModelConfig modelConfig,List<ColumnConfig> columnConfigList,List<BasicML> models,double stdDevCutoff){
  this.columnConfigList=columnConfigList;
  this.modelConfig=modelConfig;
  this.scorer=new Scorer(models,columnConfigList,ALGORITHM.NN.name(),modelConfig,stdDevCutoff);
}",0.9376899696048632
32148,"public Scorer(List<BasicML> models,List<ColumnConfig> columnConfigList,String algorithm,Double cutoff){
  this.models=models;
  this.columnConfigList=columnConfigList;
  this.cutoff=cutoff;
  this.alg=algorithm;
}","public Scorer(List<BasicML> models,List<ColumnConfig> columnConfigList,String algorithm,ModelConfig modelConfig,Double cutoff){
  this.models=models;
  this.columnConfigList=columnConfigList;
  this.cutoff=cutoff;
  this.alg=algorithm;
  this.modelConfig=modelConfig;
}",0.8838174273858921
32149,"public Tuple exec(Tuple input) throws IOException {
  if (input == null || input.size() == 0) {
    return null;
  }
  int size=input.size();
  JexlContext jc=new MapContext();
  Tuple tuple=TupleFactory.getInstance().newTuple();
  String tag=input.get(tagColumnNum).toString();
  if (!(posTags.contains(tag) || negTags.contains(tag))) {
    if (System.currentTimeMillis() % 100 == 0) {
      log.warn(""String_Node_Str"" + tag);
    }
    return null;
  }
  boolean isNotSampled=DataSampler.isNotSampled(modelConfig.getPosTags(),modelConfig.getNegTags(),modelConfig.getNormalizeSampleRate(),modelConfig.isNormalizeSampleNegOnly(),tag);
  if (isNotSampled) {
    return null;
  }
  Double cutoff=modelConfig.getNormalizeStdDevCutOff();
  for (int i=0; i < size; i++) {
    ColumnConfig config=columnConfigList.get(i);
    if (weightExpr != null) {
      jc.set(config.getColumnName(),((input.get(i) == null) ? ""String_Node_Str"" : input.get(i).toString()));
    }
    if (super.tagColumnNum == i) {
      if (modelConfig.getPosTags().contains(tag)) {
        tuple.append(df.format(Double.valueOf(1)));
      }
 else       if (modelConfig.getNegTags().contains(tag)) {
        tuple.append(df.format(Double.valueOf(0)));
      }
 else {
        log.error(""String_Node_Str"" + tag);
        return null;
      }
      continue;
    }
    if (!CommonUtils.isGoodCandidate(config)) {
      tuple.append(null);
    }
 else {
      String val=((input.get(i) == null) ? ""String_Node_Str"" : input.get(i).toString());
switch (super.modelConfig.getNormalize().getNormType()) {
case WOE:
        List<Double> binWoe;
      if (super.modelConfig.getNormalize().getIsWeightNorm()) {
        binWoe=config.getColumnBinning().getBinWeightedWoe();
      }
 else {
        binWoe=config.getColumnBinning().getBinCountWoe();
      }
    if (StringUtils.isEmpty(val)) {
      tuple.append(binWoe.get(binWoe.size() - 1));
    }
 else {
      try {
        int binNum=CommonUtils.getBinNum(config,val);
        binNum=binNum == -1 ? binWoe.size() - 1 : binNum;
        tuple.append(binWoe.get(binNum));
      }
 catch (      NumberFormatException e) {
        tuple.append(binWoe.get(binWoe.size() - 1));
      }
    }
  break;
case ZSCALE:
Double z=Normalizer.normalize(config,val,cutoff);
tuple.append(df.format(z));
default :
break;
}
}
}
double weight=1.0d;
if (weightExpr != null) {
Object result=weightExpr.evaluate(jc);
if (result instanceof Integer) {
weight=((Integer)result).doubleValue();
}
 else if (result instanceof Double) {
weight=((Double)result).doubleValue();
}
 else if (result instanceof String) {
try {
weight=Double.parseDouble((String)result);
}
 catch (NumberFormatException e) {
if (System.currentTimeMillis() % 100 == 0) {
log.warn(""String_Node_Str"" + result + ""String_Node_Str"");
}
weight=1.0d;
}
}
}
tuple.append(weight);
return tuple;
}","public Tuple exec(Tuple input) throws IOException {
  if (input == null || input.size() == 0) {
    return null;
  }
  int size=input.size();
  JexlContext jc=new MapContext();
  Tuple tuple=TupleFactory.getInstance().newTuple();
  String tag=input.get(tagColumnNum).toString();
  if (!(posTags.contains(tag) || negTags.contains(tag))) {
    if (System.currentTimeMillis() % 100 == 0) {
      log.warn(""String_Node_Str"" + tag);
    }
    return null;
  }
  boolean isNotSampled=DataSampler.isNotSampled(modelConfig.getPosTags(),modelConfig.getNegTags(),modelConfig.getNormalizeSampleRate(),modelConfig.isNormalizeSampleNegOnly(),tag);
  if (isNotSampled) {
    return null;
  }
  Double cutoff=modelConfig.getNormalizeStdDevCutOff();
  for (int i=0; i < size; i++) {
    ColumnConfig config=columnConfigList.get(i);
    if (weightExpr != null) {
      jc.set(config.getColumnName(),((input.get(i) == null) ? ""String_Node_Str"" : input.get(i).toString()));
    }
    if (super.tagColumnNum == i) {
      if (modelConfig.getPosTags().contains(tag)) {
        tuple.append(df.format(Double.valueOf(1)));
      }
 else       if (modelConfig.getNegTags().contains(tag)) {
        tuple.append(df.format(Double.valueOf(0)));
      }
 else {
        log.error(""String_Node_Str"" + tag);
        return null;
      }
      continue;
    }
    if (!CommonUtils.isGoodCandidate(config)) {
      tuple.append(null);
    }
 else {
      String val=((input.get(i) == null) ? ""String_Node_Str"" : input.get(i).toString());
switch (super.modelConfig.getNormalize().getNormType()) {
case WOE:
        List<Double> binWoe;
      if (super.modelConfig.getNormalize().getIsWeightNorm()) {
        binWoe=config.getColumnBinning().getBinWeightedWoe();
      }
 else {
        binWoe=config.getColumnBinning().getBinCountWoe();
      }
    if (StringUtils.isEmpty(val)) {
      tuple.append(df.format(binWoe.get(binWoe.size() - 1)));
    }
 else {
      try {
        int binNum=CommonUtils.getBinNum(config,val);
        binNum=binNum == -1 ? binWoe.size() - 1 : binNum;
        tuple.append(df.format(binWoe.get(binNum)));
      }
 catch (      NumberFormatException e) {
        tuple.append(df.format(binWoe.get(binWoe.size() - 1)));
      }
    }
  break;
case ZSCALE:
default :
Double z=Normalizer.normalize(config,val,cutoff);
tuple.append(df.format(z));
break;
}
}
}
double weight=1.0d;
if (weightExpr != null) {
Object result=weightExpr.evaluate(jc);
if (result instanceof Integer) {
weight=((Integer)result).doubleValue();
}
 else if (result instanceof Double) {
weight=((Double)result).doubleValue();
}
 else if (result instanceof String) {
try {
weight=Double.parseDouble((String)result);
}
 catch (NumberFormatException e) {
if (System.currentTimeMillis() % 100 == 0) {
log.warn(""String_Node_Str"" + result + ""String_Node_Str"");
}
weight=1.0d;
}
}
}
tuple.append(weight);
return tuple;
}",0.9907294035333216
32150,"/** 
 * @param databag
 * @param columnConfig
 * @throws ExecException
 */
private void statsNumericalColumnInfo(DataBag databag,ColumnConfig columnConfig) throws ExecException {
  Integer[] binCountPos=new Integer[columnConfig.getBinBoundary().size() + 1];
  Integer[] binCountNeg=new Integer[columnConfig.getBinBoundary().size() + 1];
  Double[] binWeightCountPos=new Double[columnConfig.getBinBoundary().size() + 1];
  Double[] binWeightCountNeg=new Double[columnConfig.getBinBoundary().size() + 1];
  int lastBinIndex=columnConfig.getBinBoundary().size();
  initializeZeroArr(binCountPos);
  initializeZeroArr(binCountNeg);
  initializeZeroArr(binWeightCountPos);
  initializeZeroArr(binWeightCountNeg);
  boolean isMissingValue=false;
  boolean isInvalidValue=false;
  Iterator<Tuple> iterator=databag.iterator();
  while (iterator.hasNext()) {
    isMissingValue=false;
    isInvalidValue=false;
    Tuple element=iterator.next();
    if (element.size() < 4) {
      continue;
    }
    Object value=element.get(1);
    String tag=(String)element.get(2);
    Double weight=(Double)element.get(3);
    double colVal=0.0;
    String str=null;
    if (value == null || StringUtils.isBlank(value.toString())) {
      missingValueCnt++;
      isMissingValue=true;
    }
 else {
      str=StringUtils.trim(value.toString());
      try {
        colVal=Double.parseDouble(str);
      }
 catch (      Exception e) {
        invalidValueCnt++;
        isInvalidValue=true;
      }
    }
    if (isInvalidValue || isMissingValue) {
      if (modelConfig.getPosTags().contains(tag)) {
        increaseInstCnt(binCountPos,lastBinIndex);
        increaseInstCnt(binWeightCountPos,lastBinIndex,weight);
      }
 else       if (modelConfig.getNegTags().contains(tag)) {
        increaseInstCnt(binCountNeg,lastBinIndex);
        increaseInstCnt(binWeightCountNeg,lastBinIndex,weight);
      }
    }
 else {
      streamStatsCalculator.addData(colVal);
      int binNum=CommonUtils.getBinNum(columnConfig,str);
      if (modelConfig.getPosTags().contains(tag)) {
        increaseInstCnt(binCountPos,binNum);
        increaseInstCnt(binWeightCountPos,binNum,weight);
      }
 else       if (modelConfig.getNegTags().contains(tag)) {
        increaseInstCnt(binCountNeg,binNum);
        increaseInstCnt(binWeightCountNeg,binNum,weight);
      }
    }
  }
  columnConfig.setBinCountPos(Arrays.asList(binCountPos));
  columnConfig.setBinCountNeg(Arrays.asList(binCountNeg));
  columnConfig.setBinWeightedPos(Arrays.asList(binWeightCountPos));
  columnConfig.setBinWeightedNeg(Arrays.asList(binWeightCountNeg));
  columnConfig.setMax(streamStatsCalculator.getMax());
  columnConfig.setMean(streamStatsCalculator.getMean());
  columnConfig.setMin(streamStatsCalculator.getMin());
  columnConfig.setMedian(streamStatsCalculator.getMedian());
  columnConfig.setStdDev(streamStatsCalculator.getStdDev());
  columnConfig.setMissingCnt(missingValueCnt + invalidValueCnt);
  columnConfig.setTotalCount(databag.size());
  columnConfig.setMissingPercentage(((double)columnConfig.getMissingCount()) / columnConfig.getTotalCount());
  calculateBinPosRateAndAvgScore();
}","/** 
 * @param databag
 * @param columnConfig
 * @throws ExecException
 */
private void statsNumericalColumnInfo(DataBag databag,ColumnConfig columnConfig) throws ExecException {
  Integer[] binCountPos=new Integer[columnConfig.getBinBoundary().size() + 1];
  Integer[] binCountNeg=new Integer[columnConfig.getBinBoundary().size() + 1];
  Double[] binWeightCountPos=new Double[columnConfig.getBinBoundary().size() + 1];
  Double[] binWeightCountNeg=new Double[columnConfig.getBinBoundary().size() + 1];
  int lastBinIndex=columnConfig.getBinBoundary().size();
  initializeZeroArr(binCountPos);
  initializeZeroArr(binCountNeg);
  initializeZeroArr(binWeightCountPos);
  initializeZeroArr(binWeightCountNeg);
  boolean isMissingValue=false;
  boolean isInvalidValue=false;
  Iterator<Tuple> iterator=databag.iterator();
  while (iterator.hasNext()) {
    isMissingValue=false;
    isInvalidValue=false;
    Tuple element=iterator.next();
    if (element.size() < 4) {
      continue;
    }
    Object value=element.get(1);
    String tag=(String)element.get(2);
    Double weight=(Double)element.get(3);
    double colVal=0.0;
    String str=null;
    if (value == null || StringUtils.isBlank(value.toString())) {
      missingValueCnt++;
      isMissingValue=true;
    }
 else {
      str=StringUtils.trim(value.toString());
      try {
        colVal=Double.parseDouble(str);
      }
 catch (      Exception e) {
        invalidValueCnt++;
        isInvalidValue=true;
      }
    }
    if (isInvalidValue || isMissingValue) {
      if (modelConfig.getPosTags().contains(tag)) {
        increaseInstCnt(binCountPos,lastBinIndex);
        increaseInstCnt(binWeightCountPos,lastBinIndex,weight);
      }
 else       if (modelConfig.getNegTags().contains(tag)) {
        increaseInstCnt(binCountNeg,lastBinIndex);
        increaseInstCnt(binWeightCountNeg,lastBinIndex,weight);
      }
    }
 else {
      streamStatsCalculator.addData(colVal);
      int binNum=CommonUtils.getBinNum(columnConfig,str);
      if (binNum == -1) {
        throw new RuntimeException(""String_Node_Str"");
      }
      if (modelConfig.getPosTags().contains(tag)) {
        increaseInstCnt(binCountPos,binNum);
        increaseInstCnt(binWeightCountPos,binNum,weight);
      }
 else       if (modelConfig.getNegTags().contains(tag)) {
        increaseInstCnt(binCountNeg,binNum);
        increaseInstCnt(binWeightCountNeg,binNum,weight);
      }
    }
  }
  columnConfig.setBinCountPos(Arrays.asList(binCountPos));
  columnConfig.setBinCountNeg(Arrays.asList(binCountNeg));
  columnConfig.setBinWeightedPos(Arrays.asList(binWeightCountPos));
  columnConfig.setBinWeightedNeg(Arrays.asList(binWeightCountNeg));
  columnConfig.setMax(streamStatsCalculator.getMax());
  columnConfig.setMean(streamStatsCalculator.getMean());
  columnConfig.setMin(streamStatsCalculator.getMin());
  columnConfig.setMedian(streamStatsCalculator.getMedian());
  columnConfig.setStdDev(streamStatsCalculator.getStdDev());
  columnConfig.setMissingCnt(missingValueCnt + invalidValueCnt);
  columnConfig.setTotalCount(databag.size());
  columnConfig.setMissingPercentage(((double)columnConfig.getMissingCount()) / columnConfig.getTotalCount());
  calculateBinPosRateAndAvgScore();
}",0.986043594166536
32151,"/** 
 * Assemble map data to Encog standard input format.
 * @throws NullPointerException if input is null
 * @throws NumberFormatException if column value is not number format.
 */
public static MLDataPair assembleDataPair(List<ColumnConfig> columnConfigList,Map<String,? extends Object> rawDataMap,double cutoff){
  double[] ideal={Constants.DEFAULT_IDEAL_VALUE};
  List<Double> inputList=new ArrayList<Double>();
  for (  ColumnConfig config : columnConfigList) {
    String key=config.getColumnName();
    if (config.isFinalSelect() && !rawDataMap.containsKey(key)) {
      throw new IllegalStateException(String.format(""String_Node_Str"",key));
    }
    if (config.isTarget()) {
      continue;
    }
 else     if (config.isFinalSelect()) {
      inputList.add(Normalizer.normalize(config,rawDataMap.get(key).toString(),cutoff));
    }
  }
  int size=inputList.size();
  double[] input=new double[size];
  for (int i=0; i < size; i++) {
    input[i]=inputList.get(i);
  }
  return new BasicMLDataPair(new BasicMLData(input),new BasicMLData(ideal));
}","/** 
 * Assemble map data to Encog standard input format.
 * @throws NullPointerException if input is null
 * @throws NumberFormatException if column value is not number format.
 */
public static MLDataPair assembleDataPair(ModelConfig modelConfig,List<ColumnConfig> columnConfigList,Map<String,? extends Object> rawDataMap,double cutoff){
  double[] ideal={Constants.DEFAULT_IDEAL_VALUE};
  List<Double> inputList=new ArrayList<Double>();
  for (  ColumnConfig config : columnConfigList) {
    String key=config.getColumnName();
    if (config.isFinalSelect() && !rawDataMap.containsKey(key)) {
      throw new IllegalStateException(String.format(""String_Node_Str"",key));
    }
    if (config.isTarget()) {
      continue;
    }
 else     if (config.isFinalSelect()) {
      String val=rawDataMap.get(key) == null ? null : rawDataMap.get(key).toString();
      Double normalizeValue=null;
switch (modelConfig.getNormalize().getNormType()) {
case WOE:
        List<Double> binWoe;
      if (modelConfig.getNormalize().getIsWeightNorm()) {
        binWoe=config.getColumnBinning().getBinWeightedWoe();
      }
 else {
        binWoe=config.getColumnBinning().getBinCountWoe();
      }
    if (StringUtils.isEmpty(val)) {
      normalizeValue=binWoe.get(binWoe.size() - 1);
    }
 else {
      try {
        int binNum=CommonUtils.getBinNum(config,val);
        binNum=binNum == -1 ? binWoe.size() - 1 : binNum;
        normalizeValue=binWoe.get(binNum);
      }
 catch (      NumberFormatException e) {
        normalizeValue=binWoe.get(binWoe.size() - 1);
      }
    }
  break;
case ZSCALE:
default :
normalizeValue=Normalizer.normalize(config,val,cutoff);
break;
}
inputList.add(normalizeValue);
}
}
int size=inputList.size();
double[] input=new double[size];
for (int i=0; i < size; i++) {
input[i]=inputList.get(i);
}
return new BasicMLDataPair(new BasicMLData(input),new BasicMLData(ideal));
}",0.6434134778191669
32152,"/** 
 * Copy src file to dst file in the same FileSystem. Such as copy local source to local destination, copy hdfs source to hdfs dest.
 * @param srcPath    - source file to copy
 * @param destPath   - destination file
 * @param sourceType - local/hdfs
 * @throws IOException -  if any I/O exception in processing
 */
public static void copy(String srcPath,String destPath,SourceType sourceType) throws IOException {
  if (StringUtils.isEmpty(destPath) || StringUtils.isEmpty(destPath) || sourceType == null) {
    throw new IllegalArgumentException(String.format(""String_Node_Str"",srcPath,destPath,sourceType));
  }
  FileSystem fs=getFileSystemBySourceType(sourceType);
  if (!fs.delete(new Path(destPath),true)) {
  }
  FileUtil.copy(fs,new Path(srcPath),fs,new Path(destPath),false,new Configuration());
}","/** 
 * Copy src file to dst file in the same FileSystem. Such as copy local source to local destination, copy hdfs source to hdfs dest.
 * @param srcPath    - source file to copy
 * @param destPath   - destination file
 * @param sourceType - local/hdfs
 * @throws IOException -  if any I/O exception in processing
 */
public static void copy(String srcPath,String destPath,SourceType sourceType) throws IOException {
  if (StringUtils.isEmpty(srcPath) || StringUtils.isEmpty(destPath) || sourceType == null) {
    throw new IllegalArgumentException(String.format(""String_Node_Str"",srcPath,destPath,sourceType));
  }
  FileSystem fs=getFileSystemBySourceType(sourceType);
  if (!fs.delete(new Path(destPath),true)) {
  }
  FileUtil.copy(fs,new Path(srcPath),fs,new Path(destPath),false,new Configuration());
}",0.9956763434218654
32153,"/** 
 * @return
 * @throws IOException
 */
private String[] getEvalScoreHeader() throws IOException {
  PathFinder pathFinder=new PathFinder(modelConfig);
  SourceType sourceType=evalConfig.getDataSet().getSource();
  String pathHeader=null;
  boolean isDir=ShifuFileUtils.isDir(pathFinder.getEvalScorePath(evalConfig,sourceType),sourceType);
  if (isDir) {
    pathHeader=pathFinder.getEvalScoreHeaderPath(evalConfig,sourceType);
  }
 else {
    pathHeader=pathFinder.getEvalScorePath(evalConfig,sourceType);
  }
  return CommonUtils.getHeaders(pathHeader,""String_Node_Str"",sourceType);
}","/** 
 * @return
 * @throws IOException
 */
private String[] getEvalScoreHeader() throws IOException {
  PathFinder pathFinder=new PathFinder(modelConfig);
  SourceType sourceType=evalConfig.getDataSet().getSource();
  String pathHeader=null;
  boolean isDir=ShifuFileUtils.isDir(pathFinder.getEvalScorePath(evalConfig,sourceType),sourceType);
  if (isDir) {
    pathHeader=pathFinder.getEvalScoreHeaderPath(evalConfig,sourceType);
  }
 else {
    pathHeader=pathFinder.getEvalScorePath(evalConfig,sourceType);
  }
  return CommonUtils.getHeaders(pathHeader,""String_Node_Str"",sourceType,false);
}",0.9949324324324323
32154,"public EvalScoreUDF(String source,String pathModelConfig,String pathColumnConfig,String evalSetName) throws IOException {
  super(source,pathModelConfig,pathColumnConfig);
  evalConfig=modelConfig.getEvalConfigByName(evalSetName);
  negTags=modelConfig.getNegTags();
  log.debug(""String_Node_Str"" + negTags);
  posTags=modelConfig.getPosTags();
  log.debug(""String_Node_Str"" + posTags);
  if (evalConfig.getModelsPath() != null) {
    this.columnConfigList=ShifuFileUtils.searchColumnConfig(evalConfig,columnConfigList);
  }
  this.header=CommonUtils.getHeaders(evalConfig.getDataSet().getHeaderPath(),evalConfig.getDataSet().getHeaderDelimiter(),evalConfig.getDataSet().getSource());
  List<BasicML> models=CommonUtils.loadBasicModels(modelConfig,evalConfig,evalConfig.getDataSet().getSource());
  modelRunner=new ModelRunner(modelConfig,columnConfigList,this.header,evalConfig.getDataSet().getDataDelimiter(),models);
  modelCnt=models.size();
}","public EvalScoreUDF(String source,String pathModelConfig,String pathColumnConfig,String evalSetName) throws IOException {
  super(source,pathModelConfig,pathColumnConfig);
  evalConfig=modelConfig.getEvalConfigByName(evalSetName);
  negTags=modelConfig.getNegTags();
  log.debug(""String_Node_Str"" + negTags);
  posTags=modelConfig.getPosTags();
  log.debug(""String_Node_Str"" + posTags);
  if (evalConfig.getModelsPath() != null) {
    this.columnConfigList=ShifuFileUtils.searchColumnConfig(evalConfig,columnConfigList);
  }
  this.headers=CommonUtils.getHeaders(evalConfig.getDataSet().getHeaderPath(),evalConfig.getDataSet().getHeaderDelimiter(),evalConfig.getDataSet().getSource());
  List<BasicML> models=CommonUtils.loadBasicModels(modelConfig,evalConfig,evalConfig.getDataSet().getSource());
  modelRunner=new ModelRunner(modelConfig,columnConfigList,this.headers,evalConfig.getDataSet().getDataDelimiter(),models);
  modelCnt=models.size();
}",0.9989451476793249
32155,"public Tuple exec(Tuple input) throws IOException {
  Map<String,String> rawDataMap=CommonUtils.convertDataIntoMap(input,this.header);
  if (MapUtils.isEmpty(rawDataMap)) {
    return null;
  }
  CaseScoreResult cs=modelRunner.compute(rawDataMap);
  if (cs == null) {
    log.error(""String_Node_Str"" + input.toDelimitedString(""String_Node_Str""));
    return null;
  }
  Tuple tuple=TupleFactory.getInstance().newTuple();
  String tag=rawDataMap.get(modelConfig.getTargetColumnName(evalConfig));
  tuple.append(StringUtils.trimToEmpty(tag));
  String weight=null;
  if (StringUtils.isNotBlank(evalConfig.getDataSet().getWeightColumnName())) {
    weight=rawDataMap.get(evalConfig.getDataSet().getWeightColumnName());
  }
 else {
    weight=""String_Node_Str"";
  }
  incrementTagCounters(tag,weight);
  tuple.append(weight);
  tuple.append(cs.getAvgScore());
  tuple.append(cs.getMaxScore());
  tuple.append(cs.getMinScore());
  tuple.append(cs.getMedianScore());
  for (  Integer score : cs.getScores()) {
    tuple.append(score);
  }
  List<String> metaColumns=evalConfig.getScoreMetaColumns(modelConfig);
  if (CollectionUtils.isNotEmpty(metaColumns)) {
    for (    String meta : metaColumns) {
      tuple.append(rawDataMap.get(meta));
    }
  }
  return tuple;
}","public Tuple exec(Tuple input) throws IOException {
  Map<String,String> rawDataMap=CommonUtils.convertDataIntoMap(input,this.headers);
  if (MapUtils.isEmpty(rawDataMap)) {
    return null;
  }
  CaseScoreResult cs=modelRunner.compute(rawDataMap);
  if (cs == null) {
    log.error(""String_Node_Str"" + input.toDelimitedString(""String_Node_Str""));
    return null;
  }
  Tuple tuple=TupleFactory.getInstance().newTuple();
  String tag=rawDataMap.get(modelConfig.getTargetColumnName(evalConfig));
  tuple.append(StringUtils.trimToEmpty(tag));
  String weight=null;
  if (StringUtils.isNotBlank(evalConfig.getDataSet().getWeightColumnName())) {
    weight=rawDataMap.get(evalConfig.getDataSet().getWeightColumnName());
  }
 else {
    weight=""String_Node_Str"";
  }
  incrementTagCounters(tag,weight);
  tuple.append(weight);
  tuple.append(cs.getAvgScore());
  tuple.append(cs.getMaxScore());
  tuple.append(cs.getMinScore());
  tuple.append(cs.getMedianScore());
  for (  Integer score : cs.getScores()) {
    tuple.append(score);
  }
  List<String> metaColumns=evalConfig.getScoreMetaColumns(modelConfig);
  if (CollectionUtils.isNotEmpty(metaColumns)) {
    for (    String meta : metaColumns) {
      tuple.append(rawDataMap.get(meta));
    }
  }
  return tuple;
}",0.9996048992493086
32156,"@Test public void testIsConverged(){
  double train_err=1.0;
  double test_err=3.0;
  double threshold1=1.0;
  double threshold2=2.0;
  double threshold3=3.0;
  Assert.assertTrue(ConvergeJudger.isConverged(train_err,test_err,threshold1));
  Assert.assertTrue(ConvergeJudger.isConverged(train_err,test_err,threshold2));
  Assert.assertFalse(ConvergeJudger.isConverged(train_err,test_err,threshold3));
}","@Test public void testIsConverged(){
  double train_err=1.0;
  double test_err=3.0;
  double threshold1=1.0;
  double threshold2=2.0;
  double threshold3=3.0;
  Assert.assertFalse(ConvergeJudger.isConverged(train_err,test_err,threshold1));
  Assert.assertTrue(ConvergeJudger.isConverged(train_err,test_err,threshold2));
  Assert.assertTrue(ConvergeJudger.isConverged(train_err,test_err,threshold3));
}",0.7955112219451371
32157,"public List<ColumnConfig> selectByFilter(){
  log.info(""String_Node_Str"");
  for (  ColumnConfig config : this.columnConfigList) {
    config.setFinalSelect(false);
  }
  int ptrKs=0, ptrIv=0, cntByForce=0;
  log.info(""String_Node_Str"");
  log.info(""String_Node_Str"" + modelConfig.getVarSelectFilterEnabled());
  log.info(""String_Node_Str"" + modelConfig.getVarSelectFilterBy());
  log.info(""String_Node_Str"" + modelConfig.getVarSelectFilterNum());
  List<Integer> selectedColumnNumList=new ArrayList<Integer>();
  List<ColumnConfig> ksList=new ArrayList<ColumnConfig>();
  List<ColumnConfig> ivList=new ArrayList<ColumnConfig>();
  int cntSelected=0;
  for (  ColumnConfig config : this.columnConfigList) {
    if (config.isForceRemove()) {
      log.info(""String_Node_Str"" + config.getColumnName());
    }
 else     if (config.isForceSelect()) {
      log.info(""String_Node_Str"" + config.getColumnName());
      if (config.getMean() == null || config.getStdDev() == null) {
        log.info(""String_Node_Str"");
      }
 else {
        selectedColumnNumList.add(config.getColumnNum());
        cntSelected++;
        cntByForce++;
      }
    }
 else     if (config.isMeta() || config.isTarget()) {
      log.info(""String_Node_Str"" + config.getColumnName());
    }
 else     if (config.getKs() == null || config.getIv() == null) {
      log.info(""String_Node_Str"" + config.getColumnName());
    }
 else     if ((config.isCategorical() && !modelConfig.isCategoricalDisabled()) || config.isNumerical()) {
      ksList.add(config);
      ivList.add(config);
    }
  }
  if (!this.modelConfig.getVarSelectFilterEnabled()) {
    log.info(""String_Node_Str"");
    log.info(""String_Node_Str"" + cntSelected);
    if (cntByForce != 0) {
      log.info(""String_Node_Str"" + cntByForce);
    }
    for (    int n : selectedColumnNumList) {
      this.columnConfigList.get(n).setFinalSelect(true);
    }
    return columnConfigList;
  }
  Collections.sort(ksList,new ColumnConfigComparator(""String_Node_Str""));
  Collections.sort(ivList,new ColumnConfigComparator(""String_Node_Str""));
  int expectedVarNum=Math.min(ksList.size(),this.modelConfig.getVarSelectFilterNum());
  String key=this.modelConfig.getVarSelectFilterBy();
  ColumnConfig config;
  while (cntSelected < expectedVarNum) {
    if (key.equalsIgnoreCase(""String_Node_Str"")) {
      config=ksList.get(ptrKs);
      selectedColumnNumList.add(config.getColumnNum());
      ptrKs++;
      log.info(""String_Node_Str"" + config.getKs() + ""String_Node_Str""+ ptrKs+ ""String_Node_Str""+ config.getColumnName());
      cntSelected++;
    }
 else     if (key.equalsIgnoreCase(""String_Node_Str"")) {
      config=ivList.get(ptrIv);
      selectedColumnNumList.add(config.getColumnNum());
      ptrIv++;
      log.info(""String_Node_Str"" + config.getIv() + ""String_Node_Str""+ ptrIv+ ""String_Node_Str""+ config.getColumnName());
      cntSelected++;
    }
 else     if (key.equalsIgnoreCase(""String_Node_Str"")) {
      config=ksList.get(ptrKs);
      if (selectedColumnNumList.contains(config.getColumnNum())) {
        log.info(""String_Node_Str"" + config.getColumnName());
        ptrKs++;
      }
 else {
        selectedColumnNumList.add(config.getColumnNum());
        ptrKs++;
        log.info(""String_Node_Str"" + config.getKs() + ""String_Node_Str""+ ptrKs+ ""String_Node_Str""+ config.getColumnName());
        cntSelected++;
      }
      if (cntSelected == expectedVarNum) {
        break;
      }
      config=ivList.get(ptrIv);
      if (selectedColumnNumList.contains(config.getColumnNum())) {
        log.info(""String_Node_Str"" + config.getColumnName());
        ptrIv++;
      }
 else {
        selectedColumnNumList.add(config.getColumnNum());
        ptrIv++;
        log.info(""String_Node_Str"" + config.getIv() + ""String_Node_Str""+ ptrIv+ ""String_Node_Str""+ config.getColumnName());
        cntSelected++;
      }
    }
  }
  log.info(""String_Node_Str"");
  log.info(""String_Node_Str"" + cntSelected);
  if (cntByForce != 0) {
    log.info(""String_Node_Str"" + cntByForce);
  }
  if (ptrKs != 0) {
    log.info(""String_Node_Str"" + ptrKs);
  }
  if (ptrIv != 0) {
    log.info(""String_Node_Str"" + ptrIv);
  }
  for (  int n : selectedColumnNumList) {
    this.columnConfigList.get(n).setFinalSelect(true);
  }
  return columnConfigList;
}","public List<ColumnConfig> selectByFilter(){
  log.info(""String_Node_Str"");
  for (  ColumnConfig config : this.columnConfigList) {
    config.setFinalSelect(false);
  }
  int ptrKs=0, ptrIv=0, cntByForce=0;
  log.info(""String_Node_Str"");
  log.info(""String_Node_Str"" + modelConfig.getVarSelectFilterEnabled());
  log.info(""String_Node_Str"" + modelConfig.getVarSelectFilterBy());
  log.info(""String_Node_Str"" + modelConfig.getVarSelectFilterNum());
  List<Integer> selectedColumnNumList=new ArrayList<Integer>();
  List<ColumnConfig> ksList=new ArrayList<ColumnConfig>();
  List<ColumnConfig> ivList=new ArrayList<ColumnConfig>();
  int cntSelected=0;
  for (  ColumnConfig config : this.columnConfigList) {
    if (config.isForceRemove()) {
      log.info(""String_Node_Str"" + config.getColumnName());
    }
 else     if (config.isForceSelect()) {
      log.info(""String_Node_Str"" + config.getColumnName());
      if (config.getMean() == null || config.getStdDev() == null) {
        log.info(""String_Node_Str"");
      }
 else {
        selectedColumnNumList.add(config.getColumnNum());
        cntSelected++;
        cntByForce++;
      }
    }
 else     if (config.isMeta() || config.isTarget()) {
      log.info(""String_Node_Str"" + config.getColumnName());
    }
 else     if (!CommonUtils.isGoodCandidate(config)) {
      log.info(""String_Node_Str"" + config.getColumnName());
    }
 else     if ((config.isCategorical() && !modelConfig.isCategoricalDisabled()) || config.isNumerical()) {
      ksList.add(config);
      ivList.add(config);
    }
  }
  if (!this.modelConfig.getVarSelectFilterEnabled()) {
    log.info(""String_Node_Str"");
    log.info(""String_Node_Str"" + cntSelected);
    if (cntByForce != 0) {
      log.info(""String_Node_Str"" + cntByForce);
    }
    for (    int n : selectedColumnNumList) {
      this.columnConfigList.get(n).setFinalSelect(true);
    }
    return columnConfigList;
  }
  Collections.sort(ksList,new ColumnConfigComparator(""String_Node_Str""));
  Collections.sort(ivList,new ColumnConfigComparator(""String_Node_Str""));
  int expectedVarNum=Math.min(ksList.size(),this.modelConfig.getVarSelectFilterNum());
  String key=this.modelConfig.getVarSelectFilterBy();
  ColumnConfig config;
  while (cntSelected < expectedVarNum) {
    if (key.equalsIgnoreCase(""String_Node_Str"")) {
      config=ksList.get(ptrKs);
      selectedColumnNumList.add(config.getColumnNum());
      ptrKs++;
      log.info(""String_Node_Str"" + config.getKs() + ""String_Node_Str""+ ptrKs+ ""String_Node_Str""+ config.getColumnName());
      cntSelected++;
    }
 else     if (key.equalsIgnoreCase(""String_Node_Str"")) {
      config=ivList.get(ptrIv);
      selectedColumnNumList.add(config.getColumnNum());
      ptrIv++;
      log.info(""String_Node_Str"" + config.getIv() + ""String_Node_Str""+ ptrIv+ ""String_Node_Str""+ config.getColumnName());
      cntSelected++;
    }
 else     if (key.equalsIgnoreCase(""String_Node_Str"")) {
      config=ksList.get(ptrKs);
      if (selectedColumnNumList.contains(config.getColumnNum())) {
        log.info(""String_Node_Str"" + config.getColumnName());
        ptrKs++;
      }
 else {
        selectedColumnNumList.add(config.getColumnNum());
        ptrKs++;
        log.info(""String_Node_Str"" + config.getKs() + ""String_Node_Str""+ ptrKs+ ""String_Node_Str""+ config.getColumnName());
        cntSelected++;
      }
      if (cntSelected == expectedVarNum) {
        break;
      }
      config=ivList.get(ptrIv);
      if (selectedColumnNumList.contains(config.getColumnNum())) {
        log.info(""String_Node_Str"" + config.getColumnName());
        ptrIv++;
      }
 else {
        selectedColumnNumList.add(config.getColumnNum());
        ptrIv++;
        log.info(""String_Node_Str"" + config.getIv() + ""String_Node_Str""+ ptrIv+ ""String_Node_Str""+ config.getColumnName());
        cntSelected++;
      }
    }
  }
  log.info(""String_Node_Str"");
  log.info(""String_Node_Str"" + cntSelected);
  if (cntByForce != 0) {
    log.info(""String_Node_Str"" + cntByForce);
  }
  if (ptrKs != 0) {
    log.info(""String_Node_Str"" + ptrKs);
  }
  if (ptrIv != 0) {
    log.info(""String_Node_Str"" + ptrIv);
  }
  for (  int n : selectedColumnNumList) {
    this.columnConfigList.get(n).setFinalSelect(true);
  }
  return columnConfigList;
}",0.9901708401591388
32158,"public static boolean isGoodCandidate(ColumnConfig columnConfig){
  if (columnConfig == null) {
    return false;
  }
  return columnConfig.isCandidate() && (columnConfig.getKs() != null && columnConfig.getKs() > 0 && columnConfig.getIv() != null && columnConfig.getIv() > 0 && ((columnConfig.isCategorical() && columnConfig.getBinCategory() != null && columnConfig.getBinCategory().size() > 1) || (columnConfig.isNumerical() && columnConfig.getBinBoundary() != null && columnConfig.getBinBoundary().size() > 1)));
}","public static boolean isGoodCandidate(ColumnConfig columnConfig){
  if (columnConfig == null) {
    return false;
  }
  return columnConfig.isCandidate() && (columnConfig.getKs() != null && columnConfig.getKs() > 0 && columnConfig.getIv() != null && columnConfig.getIv() > 0 && columnConfig.getMean() != null && columnConfig.getStdDev() != null && ((columnConfig.isCategorical() && columnConfig.getBinCategory() != null && columnConfig.getBinCategory().size() > 1) || (columnConfig.isNumerical() && columnConfig.getBinBoundary() != null && columnConfig.getBinBoundary().size() > 1)));
}",0.9364791288566244
32159,"@Override public void handleMsg(Object message){
  if (message instanceof StatsPartRawDataMessage) {
    StatsPartRawDataMessage partData=(StatsPartRawDataMessage)message;
    Map<Integer,List<ValueObject>> columnVoListMap=buildColumnVoListMap(partData.getRawDataList().size());
    DataPrepareStatsResult rt=convertRawDataIntoValueObject(partData.getRawDataList(),columnVoListMap);
    int totalMsgCnt=partData.getTotalMsgCnt();
    for (    Integer columnNum : columnVoListMap.keySet()) {
      columnNumToActorMap.get(columnNum).tell(new StatsValueObjectMessage(totalMsgCnt,columnNum,columnVoListMap.get(columnNum),rt.getMissingMap().containsKey(columnNum) ? rt.getMissingMap().get(columnNum) : 0,rt.getTotal()),getSelf());
    }
  }
 else   if (message instanceof RunModelResultMessage) {
    RunModelResultMessage msg=(RunModelResultMessage)message;
    Map<Integer,List<ColumnScoreObject>> columnScoreListMap=buildColumnScoreListMap();
    convertModelResultIntoColScore(msg.getScoreResultList(),columnScoreListMap);
    int totalMsgCnt=msg.getTotalStreamCnt();
    for (    Entry<Integer,List<ColumnScoreObject>> column : columnScoreListMap.entrySet()) {
      columnNumToActorMap.get(column.getKey()).tell(new ColumnScoreMessage(totalMsgCnt,column.getKey(),column.getValue()),getSelf());
    }
  }
 else {
    unhandled(message);
  }
}","@Override public void handleMsg(Object message){
  if (message instanceof StatsPartRawDataMessage) {
    StatsPartRawDataMessage partData=(StatsPartRawDataMessage)message;
    Map<Integer,List<ValueObject>> columnVoListMap=buildColumnVoListMap(partData.getRawDataList().size());
    DataPrepareStatsResult rt=convertRawDataIntoValueObject(partData.getRawDataList(),columnVoListMap);
    int totalMsgCnt=partData.getTotalMsgCnt();
    for (    Map.Entry<Integer,List<ValueObject>> entry : columnVoListMap.entrySet()) {
      Integer columnNum=entry.getKey();
      columnNumToActorMap.get(columnNum).tell(new StatsValueObjectMessage(totalMsgCnt,columnNum,entry.getValue(),rt.getMissingMap().containsKey(columnNum) ? rt.getMissingMap().get(columnNum) : 0,rt.getTotal()),getSelf());
    }
  }
 else   if (message instanceof RunModelResultMessage) {
    RunModelResultMessage msg=(RunModelResultMessage)message;
    Map<Integer,List<ColumnScoreObject>> columnScoreListMap=buildColumnScoreListMap();
    convertModelResultIntoColScore(msg.getScoreResultList(),columnScoreListMap);
    int totalMsgCnt=msg.getTotalStreamCnt();
    for (    Entry<Integer,List<ColumnScoreObject>> column : columnScoreListMap.entrySet()) {
      columnNumToActorMap.get(column.getKey()).tell(new ColumnScoreMessage(totalMsgCnt,column.getKey(),column.getValue()),getSelf());
    }
  }
 else {
    unhandled(message);
  }
}",0.6776195691858342
32160,"/** 
 * categorical binning
 */
private void doCategoricalBinning(){
  Map<String,Integer> categoryHistNeg=new HashMap<String,Integer>();
  Map<String,Integer> categoryHistPos=new HashMap<String,Integer>();
  Map<String,Double> categoryWeightedNeg=new HashMap<String,Double>();
  Map<String,Double> categoryWeightedPos=new HashMap<String,Double>();
  Set<String> categorySet=new HashSet<String>();
  for (int i=0; i < voSize; i++) {
    String category=voList.get(i).getRaw();
    categorySet.add(category);
    if (negTags.contains(voList.get(i).getTag())) {
      incMapCnt(categoryHistNeg,category);
      incMapWithValue(categoryWeightedNeg,category,voList.get(i).getWeight());
    }
 else {
      incMapCnt(categoryHistPos,category);
      incMapWithValue(categoryWeightedPos,category,voList.get(i).getWeight());
    }
  }
  Map<String,Double> categoryFraudRateMap=new HashMap<String,Double>();
  for (  String key : categorySet) {
    double cnt0=categoryHistNeg.containsKey(key) ? categoryHistNeg.get(key) : 0;
    double cnt1=categoryHistPos.containsKey(key) ? categoryHistPos.get(key) : 0;
    double rate;
    if (cnt0 + cnt1 == 0) {
      rate=0;
    }
 else {
      rate=cnt1 / (cnt0 + cnt1);
    }
    categoryFraudRateMap.put(key,rate);
  }
  MapComparator cmp=new MapComparator(categoryFraudRateMap);
  Map<String,Double> sortedCategoryFraudRateMap=new TreeMap<String,Double>(cmp);
  sortedCategoryFraudRateMap.putAll(categoryFraudRateMap);
  for (  String key : sortedCategoryFraudRateMap.keySet()) {
    Integer countNeg=categoryHistNeg.containsKey(key) ? categoryHistNeg.get(key) : 0;
    binCountNeg.add(countNeg);
    Integer countPos=categoryHistPos.containsKey(key) ? categoryHistPos.get(key) : 0;
    binCountPos.add(countPos);
    Double weightedNeg=categoryWeightedNeg.containsKey(key) ? categoryWeightedNeg.get(key) : 0.0;
    this.binWeightedNeg.add(weightedNeg);
    Double weightedPos=categoryWeightedPos.containsKey(key) ? categoryWeightedPos.get(key) : 0.0;
    this.binWeightedPos.add(weightedPos);
    binAvgScore.add(0);
    binCategory.add(key);
    binPosCaseRate.add(sortedCategoryFraudRateMap.get(key));
  }
  this.actualNumBins=binCategory.size();
  for (  ValueObject vo : voList) {
    String key=vo.getRaw();
    if (binCategory.indexOf(key) == -1) {
      vo.setValue(0.0);
    }
 else {
      vo.setValue(binPosCaseRate.get(binCategory.indexOf(key)));
    }
  }
}","/** 
 * categorical binning
 */
private void doCategoricalBinning(){
  Map<String,Integer> categoryHistNeg=new HashMap<String,Integer>();
  Map<String,Integer> categoryHistPos=new HashMap<String,Integer>();
  Map<String,Double> categoryWeightedNeg=new HashMap<String,Double>();
  Map<String,Double> categoryWeightedPos=new HashMap<String,Double>();
  Set<String> categorySet=new HashSet<String>();
  for (int i=0; i < voSize; i++) {
    String category=voList.get(i).getRaw();
    categorySet.add(category);
    if (negTags.contains(voList.get(i).getTag())) {
      incMapCnt(categoryHistNeg,category);
      incMapWithValue(categoryWeightedNeg,category,voList.get(i).getWeight());
    }
 else {
      incMapCnt(categoryHistPos,category);
      incMapWithValue(categoryWeightedPos,category,voList.get(i).getWeight());
    }
  }
  Map<String,Double> categoryFraudRateMap=new HashMap<String,Double>();
  for (  String key : categorySet) {
    double cnt0=categoryHistNeg.containsKey(key) ? categoryHistNeg.get(key) : 0;
    double cnt1=categoryHistPos.containsKey(key) ? categoryHistPos.get(key) : 0;
    double rate;
    if (cnt0 + cnt1 == 0) {
      rate=0;
    }
 else {
      rate=cnt1 / (cnt0 + cnt1);
    }
    categoryFraudRateMap.put(key,rate);
  }
  MapComparator cmp=new MapComparator(categoryFraudRateMap);
  Map<String,Double> sortedCategoryFraudRateMap=new TreeMap<String,Double>(cmp);
  sortedCategoryFraudRateMap.putAll(categoryFraudRateMap);
  for (  Map.Entry<String,Double> entry : sortedCategoryFraudRateMap.entrySet()) {
    String key=entry.getKey();
    Integer countNeg=categoryHistNeg.containsKey(key) ? categoryHistNeg.get(key) : 0;
    binCountNeg.add(countNeg);
    Integer countPos=categoryHistPos.containsKey(key) ? categoryHistPos.get(key) : 0;
    binCountPos.add(countPos);
    Double weightedNeg=categoryWeightedNeg.containsKey(key) ? categoryWeightedNeg.get(key) : 0.0;
    this.binWeightedNeg.add(weightedNeg);
    Double weightedPos=categoryWeightedPos.containsKey(key) ? categoryWeightedPos.get(key) : 0.0;
    this.binWeightedPos.add(weightedPos);
    binAvgScore.add(0);
    binCategory.add(key);
    binPosCaseRate.add(entry.getValue());
  }
  this.actualNumBins=binCategory.size();
  for (  ValueObject vo : voList) {
    String key=vo.getRaw();
    if (binCategory.indexOf(key) == -1) {
      vo.setValue(0.0);
    }
 else {
      vo.setValue(binPosCaseRate.get(binCategory.indexOf(key)));
    }
  }
}",0.962046204620462
32161,"/** 
 * Sum the histogram's frequency whose value less than or equal some value 
 * @param hval
 * @return
 */
private double sum(double hval){
  LinkNode<HistogramUnit> posHistogramUnit=null;
  LinkNode<HistogramUnit> tmp=this.header;
  while (tmp != this.tail) {
    HistogramUnit chu=tmp.data();
    HistogramUnit nhu=tmp.next().data();
    if (chu.getHval() <= hval && hval < nhu.getHval()) {
      posHistogramUnit=tmp;
      break;
    }
    tmp=tmp.next();
  }
  if (posHistogramUnit != null) {
    HistogramUnit chu=posHistogramUnit.data();
    HistogramUnit nhu=posHistogramUnit.next().data();
    double mb=chu.getHcnt() + (nhu.getHcnt() - nhu.getHcnt()) * (hval - chu.getHval()) / (nhu.getHval() - chu.getHval());
    double s=(chu.getHcnt() + mb) * (hval - chu.getHval()) / (nhu.getHval() - chu.getHval());
    s=s / 2;
    tmp=this.header;
    while (tmp != posHistogramUnit) {
      HistogramUnit hu=tmp.data();
      s=s + hu.getHcnt();
      tmp=tmp.next();
    }
    return s + chu.getHcnt() / 2;
  }
 else   if (tmp == this.tail) {
    double sum=0.0;
    tmp=this.header;
    while (tmp != null) {
      sum+=tmp.data().getHcnt();
      tmp=tmp.next();
    }
    return sum;
  }
  return -1.0;
}","/** 
 * Sum the histogram's frequency whose value less than or equal some value 
 * @param hval
 * @return
 */
private double sum(double hval){
  LinkNode<HistogramUnit> posHistogramUnit=null;
  LinkNode<HistogramUnit> tmp=this.header;
  while (tmp != this.tail) {
    HistogramUnit chu=tmp.data();
    HistogramUnit nhu=tmp.next().data();
    if (chu.getHval() <= hval && hval < nhu.getHval()) {
      posHistogramUnit=tmp;
      break;
    }
    tmp=tmp.next();
  }
  if (posHistogramUnit != null) {
    HistogramUnit chu=posHistogramUnit.data();
    HistogramUnit nhu=posHistogramUnit.next().data();
    double mb=chu.getHcnt() + (nhu.getHcnt() - nhu.getHcnt()) * (hval - chu.getHval()) / (nhu.getHval() - chu.getHval());
    double s=(chu.getHcnt() + mb) * (hval - chu.getHval()) / (nhu.getHval() - chu.getHval());
    s=s / 2;
    tmp=this.header;
    while (tmp != posHistogramUnit) {
      HistogramUnit hu=tmp.data();
      s=s + hu.getHcnt();
      tmp=tmp.next();
    }
    return s + chu.getHcnt() / 2d;
  }
 else   if (tmp == this.tail) {
    double sum=0.0;
    tmp=this.header;
    while (tmp != null) {
      sum+=tmp.data().getHcnt();
      tmp=tmp.next();
    }
    return sum;
  }
  return -1.0;
}",0.9995883079456568
32162,"public TrainDataPrepWorker(ModelConfig modelConfig,List<ColumnConfig> columnConfigList,ActorRef parentActorRef,ActorRef nextActorRef,List<AbstractTrainer> trainers) throws IOException {
  super(modelConfig,columnConfigList,parentActorRef,nextActorRef);
  this.trainers=trainers;
  if (modelConfig.isTrainOnDisk()) {
    log.info(""String_Node_Str"");
    ShifuFileUtils.createDirIfNotExists(Constants.TMP,SourceType.LOCAL);
    masterDataSet=new BufferedMLDataSet(new File(Constants.TMP,""String_Node_Str""));
  }
 else {
    log.info(""String_Node_Str"");
    masterDataSet=new BasicMLDataSet();
  }
  headers=CommonUtils.getHeaders(modelConfig.getHeaderPath(),modelConfig.getHeaderDelimiter(),modelConfig.getDataSet().getSource());
}","public TrainDataPrepWorker(ModelConfig modelConfig,List<ColumnConfig> columnConfigList,ActorRef parentActorRef,ActorRef nextActorRef,List<AbstractTrainer> trainers) throws IOException {
  super(modelConfig,columnConfigList,parentActorRef,nextActorRef);
  this.trainers=trainers;
  if (modelConfig.isTrainOnDisk()) {
    log.info(""String_Node_Str"");
    ShifuFileUtils.createDirIfNotExists(Constants.TMP,SourceType.LOCAL);
    masterDataSet=new BufferedMLDataSet(new File(Constants.TMP,""String_Node_Str""));
  }
 else {
    log.info(""String_Node_Str"");
    masterDataSet=new BasicMLDataSet();
  }
}",0.8996226415094339
32163,"/** 
 * Scan the stats result and save them into column configure
 * @param scanner
 */
private void scanStatsResult(Scanner scanner){
  while (scanner.hasNextLine()) {
    String[] raw=scanner.nextLine().trim().split(""String_Node_Str"");
    if (raw.length == 1) {
      continue;
    }
    if (raw.length != 19) {
      log.info(""String_Node_Str"" + raw.length + ""String_Node_Str"");
      log.info(""String_Node_Str"" + raw);
    }
    int columnNum=Integer.parseInt(raw[0]);
    try {
      ColumnConfig config=this.columnConfigList.get(columnNum);
      if (config.isCategorical()) {
        String binCategory=Base64Utils.base64Decode(raw[1]);
        config.setBinCategory(CommonUtils.stringToStringList(binCategory,CalculateStatsUDF.CATEGORY_VAL_SEPARATOR));
      }
 else {
        config.setBinBoundary(CommonUtils.stringToDoubleList(raw[1]));
      }
      config.setBinCountNeg(CommonUtils.stringToIntegerList(raw[2]));
      config.setBinCountPos(CommonUtils.stringToIntegerList(raw[3]));
      config.setBinPosCaseRate(CommonUtils.stringToDoubleList(raw[5]));
      config.setBinLength(config.getBinCountNeg().size());
      config.setKs(Double.valueOf(raw[6]));
      config.setIv(Double.valueOf(raw[7]));
      config.setMax(Double.valueOf(raw[8]));
      config.setMin(Double.valueOf(raw[9]));
      config.setMean(Double.valueOf(raw[10]));
      config.setStdDev(Double.valueOf(raw[11]));
      if (raw[12].equals(""String_Node_Str"")) {
        config.setColumnType(ColumnType.N);
      }
 else {
        config.setColumnType(ColumnType.C);
      }
      config.setMedian(Double.valueOf(raw[13]));
      config.setMissingCnt(Long.valueOf(raw[14]));
      config.setTotalCount(Long.valueOf(raw[15]));
      config.setMissingPercentage(Double.valueOf(raw[16]));
      config.setBinWeightedNeg(CommonUtils.stringToDoubleList(raw[17]));
      config.setBinWeightedPos(CommonUtils.stringToDoubleList(raw[18]));
    }
 catch (    Exception e) {
      log.error(""String_Node_Str"",columnNum,this.columnConfigList.get(columnNum).getColumnName(),e.getMessage());
      continue;
    }
  }
}","/** 
 * Scan the stats result and save them into column configure
 * @param scanner
 */
private void scanStatsResult(Scanner scanner){
  while (scanner.hasNextLine()) {
    String[] raw=scanner.nextLine().trim().split(""String_Node_Str"");
    if (raw.length == 1) {
      continue;
    }
    if (raw.length != 19) {
      log.info(""String_Node_Str"" + raw.length + ""String_Node_Str"");
      log.info(""String_Node_Str"" + Arrays.toString(raw));
    }
    int columnNum=Integer.parseInt(raw[0]);
    try {
      ColumnConfig config=this.columnConfigList.get(columnNum);
      if (config.isCategorical()) {
        String binCategory=Base64Utils.base64Decode(raw[1]);
        config.setBinCategory(CommonUtils.stringToStringList(binCategory,CalculateStatsUDF.CATEGORY_VAL_SEPARATOR));
      }
 else {
        config.setBinBoundary(CommonUtils.stringToDoubleList(raw[1]));
      }
      config.setBinCountNeg(CommonUtils.stringToIntegerList(raw[2]));
      config.setBinCountPos(CommonUtils.stringToIntegerList(raw[3]));
      config.setBinPosCaseRate(CommonUtils.stringToDoubleList(raw[5]));
      config.setBinLength(config.getBinCountNeg().size());
      config.setKs(Double.valueOf(raw[6]));
      config.setIv(Double.valueOf(raw[7]));
      config.setMax(Double.valueOf(raw[8]));
      config.setMin(Double.valueOf(raw[9]));
      config.setMean(Double.valueOf(raw[10]));
      config.setStdDev(Double.valueOf(raw[11]));
      if (raw[12].equals(""String_Node_Str"")) {
        config.setColumnType(ColumnType.N);
      }
 else {
        config.setColumnType(ColumnType.C);
      }
      config.setMedian(Double.valueOf(raw[13]));
      config.setMissingCnt(Long.valueOf(raw[14]));
      config.setTotalCount(Long.valueOf(raw[15]));
      config.setMissingPercentage(Double.valueOf(raw[16]));
      config.setBinWeightedNeg(CommonUtils.stringToDoubleList(raw[17]));
      config.setBinWeightedPos(CommonUtils.stringToDoubleList(raw[18]));
    }
 catch (    Exception e) {
      log.error(""String_Node_Str"",columnNum,this.columnConfigList.get(columnNum).getColumnName(),e.getMessage());
      continue;
    }
  }
}",0.994525113068317
32164,"/** 
 * Wrapper through   {@link TrainModelProcessor} and a MapReduce job to analyze biggest sensitivity MSE.
 */
private void distributedSEWrapper() throws Exception {
  TrainModelProcessor trainModelProcessor=new TrainModelProcessor();
  trainModelProcessor.setForVarSelect(true);
  trainModelProcessor.run();
  SourceType source=this.modelConfig.getDataSet().getSource();
  Configuration conf=new Configuration();
  new GenericOptionsParser(conf,new String[]{""String_Node_Str"",addRuntimeJars()});
  conf.setBoolean(GuaguaMapReduceConstants.MAPRED_MAP_TASKS_SPECULATIVE_EXECUTION,true);
  conf.setBoolean(GuaguaMapReduceConstants.MAPRED_REDUCE_TASKS_SPECULATIVE_EXECUTION,true);
  conf.set(Constants.SHIFU_MODEL_CONFIG,ShifuFileUtils.getFileSystemBySourceType(source).makeQualified(new Path(super.getPathFinder().getModelConfigPath(source))).toString());
  conf.set(Constants.SHIFU_COLUMN_CONFIG,ShifuFileUtils.getFileSystemBySourceType(source).makeQualified(new Path(super.getPathFinder().getColumnConfigPath(source))).toString());
  conf.set(NNConstants.MAPRED_JOB_QUEUE_NAME,Environment.getProperty(Environment.HADOOP_JOB_QUEUE,""String_Node_Str""));
  conf.set(Constants.SHIFU_MODELSET_SOURCE_TYPE,source.toString());
  Float wrapperRatio=this.modelConfig.getVarSelect().getWrapperRatio();
  if (wrapperRatio == null) {
    log.warn(""String_Node_Str"");
    wrapperRatio=0.05f;
  }
  if (wrapperRatio.compareTo(Float.valueOf(1.0f)) >= 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  conf.setFloat(Constants.SHIFU_VARSELECT_WRAPPER_RATIO,wrapperRatio);
  Job job=new Job(conf,""String_Node_Str"" + this.modelConfig.getModelSetName());
  job.setJarByClass(getClass());
  boolean isSEVarSelMulti=Boolean.TRUE.toString().equalsIgnoreCase(Environment.getProperty(Constants.SHIFU_VARSEL_SE_MULTI,Constants.SHIFU_DEFAULT_VARSEL_SE_MULTI));
  if (isSEVarSelMulti) {
    job.setMapperClass(MultithreadedMapper.class);
    MultithreadedMapper.setMapperClass(job,VarSelectMapper.class);
    MultithreadedMapper.setNumberOfThreads(job,6);
  }
 else {
    job.setMapperClass(VarSelectMapper.class);
  }
  job.setMapOutputKeyClass(LongWritable.class);
  job.setMapOutputValueClass(DoubleWritable.class);
  job.setInputFormatClass(TextInputFormat.class);
  FileInputFormat.setInputPaths(job,ShifuFileUtils.getFileSystemBySourceType(source).makeQualified(new Path(super.getPathFinder().getNormalizedDataPath())));
  job.setReducerClass(VarSelectReducer.class);
  job.setNumReduceTasks(1);
  job.setOutputKeyClass(LongWritable.class);
  job.setOutputValueClass(NullWritable.class);
  job.setOutputFormatClass(TextOutputFormat.class);
  String varSelectMSEOutputPath=super.getPathFinder().getVarSelectMSEOutputPath(source);
  FileOutputFormat.setOutputPath(job,new Path(varSelectMSEOutputPath));
  ShifuFileUtils.deleteFile(varSelectMSEOutputPath,source);
  if (job.waitForCompletion(true)) {
    if (!ShifuFileUtils.isFileExists(varSelectMSEOutputPath + Path.SEPARATOR + ""String_Node_Str"",source)) {
      throw new RuntimeException(""String_Node_Str"");
    }
    for (    ColumnConfig config : super.columnConfigList) {
      if (config.isFinalSelect()) {
        config.setFinalSelect(false);
      }
    }
    List<Scanner> scanners=null;
    try {
      FileStatus[] globStatus=ShifuFileUtils.getFileSystemBySourceType(source).globStatus(new Path(varSelectMSEOutputPath + Path.SEPARATOR + ""String_Node_Str""));
      if (globStatus == null || globStatus.length == 0) {
        throw new RuntimeException(""String_Node_Str"");
      }
      scanners=ShifuFileUtils.getDataScanners(globStatus[0].getPath().toString(),source);
      String str=null;
      int count=0;
      while (scanners.get(0).hasNext()) {
        ++count;
        str=scanners.get(0).nextLine();
        ColumnConfig columnConfig=this.columnConfigList.get(Integer.parseInt(str));
        columnConfig.setFinalSelect(true);
        log.info(""String_Node_Str"",columnConfig.getColumnName());
      }
      log.info(""String_Node_Str"",count);
    }
  finally {
      for (      Scanner scanner : scanners) {
        scanner.close();
      }
    }
    this.saveColumnConfigList();
    this.syncDataToHdfs(this.modelConfig.getDataSet().getSource());
  }
}","/** 
 * Wrapper through   {@link TrainModelProcessor} and a MapReduce job to analyze biggest sensitivity MSE.
 */
private void distributedSEWrapper() throws Exception {
  TrainModelProcessor trainModelProcessor=new TrainModelProcessor();
  trainModelProcessor.setForVarSelect(true);
  trainModelProcessor.run();
  SourceType source=this.modelConfig.getDataSet().getSource();
  Configuration conf=new Configuration();
  new GenericOptionsParser(conf,new String[]{""String_Node_Str"",addRuntimeJars()});
  conf.setBoolean(GuaguaMapReduceConstants.MAPRED_MAP_TASKS_SPECULATIVE_EXECUTION,true);
  conf.setBoolean(GuaguaMapReduceConstants.MAPRED_REDUCE_TASKS_SPECULATIVE_EXECUTION,true);
  conf.set(Constants.SHIFU_MODEL_CONFIG,ShifuFileUtils.getFileSystemBySourceType(source).makeQualified(new Path(super.getPathFinder().getModelConfigPath(source))).toString());
  conf.set(Constants.SHIFU_COLUMN_CONFIG,ShifuFileUtils.getFileSystemBySourceType(source).makeQualified(new Path(super.getPathFinder().getColumnConfigPath(source))).toString());
  conf.set(NNConstants.MAPRED_JOB_QUEUE_NAME,Environment.getProperty(Environment.HADOOP_JOB_QUEUE,""String_Node_Str""));
  conf.set(Constants.SHIFU_MODELSET_SOURCE_TYPE,source.toString());
  Float wrapperRatio=this.modelConfig.getVarSelect().getWrapperRatio();
  if (wrapperRatio == null) {
    log.warn(""String_Node_Str"");
    wrapperRatio=0.05f;
  }
  if (wrapperRatio.compareTo(Float.valueOf(1.0f)) >= 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  conf.setFloat(Constants.SHIFU_VARSELECT_WRAPPER_RATIO,wrapperRatio);
  Job job=new Job(conf,""String_Node_Str"" + this.modelConfig.getModelSetName());
  job.setJarByClass(getClass());
  boolean isSEVarSelMulti=Boolean.TRUE.toString().equalsIgnoreCase(Environment.getProperty(Constants.SHIFU_VARSEL_SE_MULTI,Constants.SHIFU_DEFAULT_VARSEL_SE_MULTI));
  if (isSEVarSelMulti) {
    job.setMapperClass(MultithreadedMapper.class);
    MultithreadedMapper.setMapperClass(job,VarSelectMapper.class);
    MultithreadedMapper.setNumberOfThreads(job,6);
  }
 else {
    job.setMapperClass(VarSelectMapper.class);
  }
  job.setMapOutputKeyClass(LongWritable.class);
  job.setMapOutputValueClass(DoubleWritable.class);
  job.setInputFormatClass(TextInputFormat.class);
  FileInputFormat.setInputPaths(job,ShifuFileUtils.getFileSystemBySourceType(source).makeQualified(new Path(super.getPathFinder().getNormalizedDataPath())));
  job.setReducerClass(VarSelectReducer.class);
  job.setNumReduceTasks(1);
  job.setOutputKeyClass(LongWritable.class);
  job.setOutputValueClass(NullWritable.class);
  job.setOutputFormatClass(TextOutputFormat.class);
  String varSelectMSEOutputPath=super.getPathFinder().getVarSelectMSEOutputPath(source);
  FileOutputFormat.setOutputPath(job,new Path(varSelectMSEOutputPath));
  ShifuFileUtils.deleteFile(varSelectMSEOutputPath,source);
  if (job.waitForCompletion(true)) {
    if (!ShifuFileUtils.isFileExists(varSelectMSEOutputPath + Path.SEPARATOR + ""String_Node_Str"",source)) {
      throw new RuntimeException(""String_Node_Str"");
    }
    for (    ColumnConfig config : super.columnConfigList) {
      if (config.isFinalSelect()) {
        config.setFinalSelect(false);
      }
    }
    List<Scanner> scanners=null;
    try {
      FileStatus[] globStatus=ShifuFileUtils.getFileSystemBySourceType(source).globStatus(new Path(varSelectMSEOutputPath + Path.SEPARATOR + ""String_Node_Str""));
      if (globStatus == null || globStatus.length == 0) {
        throw new RuntimeException(""String_Node_Str"");
      }
      scanners=ShifuFileUtils.getDataScanners(globStatus[0].getPath().toString(),source);
      String str=null;
      int count=0;
      while (scanners.get(0).hasNext()) {
        ++count;
        str=scanners.get(0).nextLine();
        ColumnConfig columnConfig=this.columnConfigList.get(Integer.parseInt(str));
        columnConfig.setFinalSelect(true);
        log.info(""String_Node_Str"",columnConfig.getColumnName());
      }
      log.info(""String_Node_Str"",count);
    }
  finally {
      if (scanners != null) {
        for (        Scanner scanner : scanners) {
          if (scanner != null) {
            scanner.close();
          }
        }
      }
    }
    this.saveColumnConfigList();
    this.syncDataToHdfs(this.modelConfig.getDataSet().getSource());
  }
}",0.9839559667408362
32165,"/** 
 * Load shifuconfig into properties
 * @param props
 * @param fileName
 * @throws IOException
 */
private static void loadProperties(Properties props,String fileName) throws IOException {
  File configFile=new File(fileName);
  if (!configFile.exists()) {
    return;
  }
  FileInputStream inStream=new FileInputStream(configFile);
  try {
    props.load(inStream);
  }
  finally {
    IOUtils.closeQuietly(inStream);
  }
}","/** 
 * Load shifuconfig into properties
 * @param props
 * @param fileName
 * @throws IOException
 */
private static void loadProperties(Properties props,String fileName) throws IOException {
  File configFile=new File(fileName);
  if (!configFile.exists()) {
    return;
  }
  FileInputStream inStream=null;
  try {
    inStream=new FileInputStream(configFile);
    props.load(inStream);
  }
  finally {
    IOUtils.closeQuietly(inStream);
  }
}",0.96
32166,"/** 
 * set min/max, merge same bins
 * @param bins
 * @return
 */
private List<Double> binMerge(List<Double> bins){
  List<Double> newBins=new ArrayList<Double>();
  if (bins.size() == 0) {
    bins.add(Double.NaN);
    return bins;
  }
  Double cur=bins.get(0);
  newBins.add(cur);
  int i=1;
  while (i < bins.size()) {
    if (Math.abs(cur - bins.get(i)) > 1e-4) {
      newBins.add(bins.get(i));
    }
    cur=bins.get(i);
    i++;
  }
  if (newBins.size() == 1) {
    double val=newBins.get(0);
    newBins=Arrays.asList(new Double[]{Double.NEGATIVE_INFINITY,val});
  }
 else   if (newBins.size() == 2) {
    newBins.set(0,Double.NEGATIVE_INFINITY);
  }
 else {
    newBins.set(0,Double.NEGATIVE_INFINITY);
    newBins.remove(newBins.size() - 1);
  }
  return newBins;
}","/** 
 * set min/max, merge same bins
 * @param bins
 * @return
 */
private List<Double> binMerge(List<Double> bins){
  List<Double> newBins=new ArrayList<Double>();
  if (bins.size() == 0) {
    bins.add(Double.NaN);
    return bins;
  }
  Double cur=bins.get(0);
  newBins.add(cur);
  int i=1;
  while (i < bins.size()) {
    if (Math.abs(cur - bins.get(i)) > 1e-10) {
      newBins.add(bins.get(i));
    }
    cur=bins.get(i);
    i++;
  }
  if (newBins.size() == 1) {
    double val=newBins.get(0);
    newBins=Arrays.asList(new Double[]{Double.NEGATIVE_INFINITY,val});
  }
 else   if (newBins.size() == 2) {
    newBins.set(0,Double.NEGATIVE_INFINITY);
  }
 else {
    newBins.set(0,Double.NEGATIVE_INFINITY);
    newBins.remove(newBins.size() - 1);
  }
  return newBins;
}",0.9980682549903412
32167,"/** 
 * run pig stats
 * @throws IOException
 */
private void runPigStats() throws IOException {
  log.info(""String_Node_Str"");
  ShifuFileUtils.deleteFile(pathFinder.getPreTrainingStatsPath(),modelConfig.getDataSet().getSource());
  Map<String,String> paramsMap=new HashMap<String,String>();
  paramsMap.put(""String_Node_Str"",CommonUtils.escapePigString(modelConfig.getDataSetDelimiter()));
  paramsMap.put(""String_Node_Str"",Integer.toString(columnConfigList.size() / 3));
  try {
    if (modelConfig.getBinningAlgorithm().equals(ModelStatsConf.BinningAlgorithm.MunroPat)) {
      PigExecutor.getExecutor().submitJob(modelConfig,pathFinder.getAbsolutePath(""String_Node_Str""),paramsMap);
    }
 else {
      PigExecutor.getExecutor().submitJob(modelConfig,pathFinder.getAbsolutePath(""String_Node_Str""),paramsMap);
    }
  }
 catch (  IOException e) {
    throw new ShifuException(ShifuErrorCode.ERROR_RUNNING_PIG_JOB,e);
  }
catch (  Throwable e) {
    throw new RuntimeException(e);
  }
  log.info(""String_Node_Str"");
  updateColumnConfigWithPreTrainingStats();
  saveColumnConfigList();
}","/** 
 * run pig stats
 * @throws IOException
 */
private void runPigStats() throws IOException {
  log.info(""String_Node_Str"");
  ShifuFileUtils.deleteFile(pathFinder.getPreTrainingStatsPath(),modelConfig.getDataSet().getSource());
  Map<String,String> paramsMap=new HashMap<String,String>();
  paramsMap.put(""String_Node_Str"",CommonUtils.escapePigString(modelConfig.getDataSetDelimiter()));
  paramsMap.put(""String_Node_Str"",Integer.toString(columnConfigList.size() / 3));
  try {
    log.info(""String_Node_Str"",modelConfig.getBinningAlgorithm().toString());
    if (modelConfig.getBinningAlgorithm().equals(ModelStatsConf.BinningAlgorithm.MunroPat)) {
      PigExecutor.getExecutor().submitJob(modelConfig,pathFinder.getAbsolutePath(""String_Node_Str""),paramsMap);
    }
 else {
      PigExecutor.getExecutor().submitJob(modelConfig,pathFinder.getAbsolutePath(""String_Node_Str""),paramsMap);
    }
  }
 catch (  IOException e) {
    throw new ShifuException(ShifuErrorCode.ERROR_RUNNING_PIG_JOB,e);
  }
catch (  Throwable e) {
    throw new RuntimeException(e);
  }
  log.info(""String_Node_Str"");
  updateColumnConfigWithPreTrainingStats();
  saveColumnConfigList();
}",0.9654561558901684
32168,"@Override public Tuple exec(Tuple input) throws IOException {
  this.accumulate(input);
  Tuple output=TupleFactory.getInstance().newTuple(2);
  output.set(0,columnId);
  output.set(1,StringUtils.join(binning.getDataBin(),CalculateStatsUDF.CATEGORY_VAL_SEPARATOR));
  return output;
}","@Override public Tuple exec(Tuple input) throws IOException {
  if (input == null && input.size() < 2) {
    return null;
  }
  Integer columnId=(Integer)input.get(0);
  DataBag databag=(DataBag)input.get(1);
  ColumnConfig columnConfig=super.columnConfigList.get(columnId);
  AbstractBinning<?> binning=null;
  if (columnConfig.isCategorical()) {
    binning=new CategoricalBinning(-1);
  }
 else {
    if (super.modelConfig.getBinningMethod().equals(BinningMethod.EqualInterval)) {
      binning=new EqualIntervalBinning(modelConfig.getStats().getMaxNumBin());
    }
 else {
switch (this.modelConfig.getBinningAlgorithm()) {
case Native:
        log.info(""String_Node_Str"");
      binning=new NativeBinning(modelConfig.getStats().getMaxNumBin(),true);
    break;
case SPDT:
  log.info(""String_Node_Str"");
binning=new EqualPopulationBinning(modelConfig.getStats().getMaxNumBin());
break;
case MunroPat:
log.info(""String_Node_Str"");
binning=new MunroPatBinning(modelConfig.getStats().getMaxNumBin());
break;
default :
log.info(""String_Node_Str"");
binning=new MunroPatBinning(modelConfig.getStats().getMaxNumBin());
break;
}
}
}
Iterator<Tuple> iterator=databag.iterator();
while (iterator.hasNext()) {
Tuple element=iterator.next();
if (element == null || element.size() < 2) {
continue;
}
Object value=element.get(1);
if (value != null) {
binning.addData(value.toString());
}
}
Tuple output=TupleFactory.getInstance().newTuple(2);
output.set(0,columnId);
output.set(1,StringUtils.join(binning.getDataBin(),CalculateStatsUDF.CATEGORY_VAL_SEPARATOR));
return output;
}",0.2744462452728255
32169,"@Override public void mergeBin(AbstractBinning<?> another){
  CategoricalBinning binning=(CategoricalBinning)another;
  super.mergeBin(another);
  this.categoricalVals.addAll(binning.categoricalVals);
}","@Override public void mergeBin(AbstractBinning<?> another){
  CategoricalBinning binning=(CategoricalBinning)another;
  super.mergeBin(another);
  this.isValid=(this.isValid && binning.isValid);
  if (this.isValid) {
    this.categoricalVals.addAll(binning.categoricalVals);
  }
 else {
    this.categoricalVals.clear();
  }
}",0.7651515151515151
32170,"/** 
 * convert @CategoricalBinning to String
 * @return
 */
protected void stringToObj(String objValStr){
  super.stringToObj(objValStr);
  if (categoricalVals == null) {
    categoricalVals=new HashSet<String>();
  }
 else {
    categoricalVals.clear();
  }
  String[] objStrArr=objValStr.split(Character.toString(FIELD_SEPARATOR),-1);
  if (objStrArr.length > 4 && StringUtils.isNotBlank(objStrArr[4])) {
    String[] elements=objStrArr[4].split(Character.toString(SETLIST_SEPARATOR),-1);
    for (    String element : elements) {
      categoricalVals.add(element);
    }
  }
 else {
    log.warn(""String_Node_Str"" + objValStr);
  }
}","/** 
 * convert @CategoricalBinning to String
 * @return
 */
protected void stringToObj(String objValStr){
  super.stringToObj(objValStr);
  if (categoricalVals == null) {
    categoricalVals=new HashSet<String>();
  }
 else {
    categoricalVals.clear();
  }
  String[] objStrArr=objValStr.split(Character.toString(FIELD_SEPARATOR),-1);
  this.isValid=Boolean.valueOf(objStrArr[4]);
  if (objStrArr.length > 5 && StringUtils.isNotBlank(objStrArr[5])) {
    String[] elements=objStrArr[5].split(Character.toString(SETLIST_SEPARATOR),-1);
    for (    String element : elements) {
      categoricalVals.add(element);
    }
  }
 else {
    log.warn(""String_Node_Str"" + objValStr);
  }
}",0.8895612708018155
32171,"@Override public void addData(String val){
  String fval=StringUtils.trimToEmpty(val);
  if (!isMissingVal(fval)) {
    categoricalVals.add(fval);
  }
 else {
    super.incMissingValCnt();
  }
}","@Override public void addData(String val){
  String fval=StringUtils.trimToEmpty(val);
  if (!isMissingVal(fval)) {
    if (isValid) {
      categoricalVals.add(fval);
    }
    if (categoricalVals.size() > CalculateNewStatsUDF.MAX_CATEGORICAL_BINC_COUNT) {
      isValid=false;
      categoricalVals.clear();
    }
  }
 else {
    super.incMissingValCnt();
  }
}",0.6032315978456014
32172,"/** 
 * convert @CategoricalBinning to String
 * @return
 */
public String objToString(){
  return super.objToString() + Character.toString(FIELD_SEPARATOR) + StringUtils.join(categoricalVals,SETLIST_SEPARATOR);
}","/** 
 * convert @CategoricalBinning to String
 * @return
 */
public String objToString(){
  return super.objToString() + Character.toString(FIELD_SEPARATOR) + Boolean.toString(isValid)+ Character.toString(FIELD_SEPARATOR)+ StringUtils.join(categoricalVals,SETLIST_SEPARATOR);
}",0.8693877551020408
32173,"/** 
 * Locate histogram unit with just less than s, from some histogram unit
 * @param s
 * @param startPos
 * @return
 */
private LinkNode<HistogramUnit> locateHistogram(double s,LinkNode<HistogramUnit> startPos){
  while (startPos != this.tail) {
    HistogramUnit chu=startPos.data();
    HistogramUnit nhu=startPos.next().data();
    double sc=sum(chu.getHval());
    double sn=sum(nhu.getHval());
    if (sc < s && s <= sn) {
      return startPos;
    }
    startPos=startPos.next();
  }
  return null;
}","/** 
 * Locate histogram unit with just less than s, from some histogram unit
 * @param s
 * @param startPos
 * @return
 */
private LinkNode<HistogramUnit> locateHistogram(double s,LinkNode<HistogramUnit> startPos){
  while (startPos != this.tail) {
    if (startPos == null) {
      startPos=this.header;
    }
    HistogramUnit chu=startPos.data();
    HistogramUnit nhu=startPos.next().data();
    double sc=sum(chu.getHval());
    double sn=sum(nhu.getHval());
    if (sc >= s || (sc < s && s <= sn)) {
      return startPos;
    }
    startPos=startPos.next();
  }
  return null;
}",0.9316317228805834
32174,"/** 
 * Sum the histogram's frequency whose value less than or equal some value 
 * @param hval
 * @return
 */
private double sum(double hval){
  LinkNode<HistogramUnit> posHistogramUnit=null;
  LinkNode<HistogramUnit> tmp=this.header;
  while (tmp != this.tail) {
    HistogramUnit chu=tmp.data();
    HistogramUnit nhu=tmp.next().data();
    if (chu.getHval() <= hval && hval < nhu.getHval()) {
      posHistogramUnit=tmp;
      break;
    }
    tmp=tmp.next();
  }
  if (posHistogramUnit != null) {
    HistogramUnit chu=posHistogramUnit.data();
    HistogramUnit nhu=posHistogramUnit.next().data();
    double mb=chu.getHcnt() + (nhu.getHcnt() - nhu.getHcnt()) * (hval - chu.getHval()) / (nhu.getHval() - chu.getHval());
    double s=(chu.getHcnt() + mb) * (hval - chu.getHval()) / (nhu.getHval() - chu.getHval());
    s=s / 2;
    tmp=this.header;
    while (tmp != posHistogramUnit) {
      HistogramUnit hu=tmp.data();
      s=s + hu.getHcnt();
      tmp=tmp.next();
    }
    return s + chu.getHcnt() / 2;
  }
  return -1.0;
}","/** 
 * Sum the histogram's frequency whose value less than or equal some value 
 * @param hval
 * @return
 */
private double sum(double hval){
  LinkNode<HistogramUnit> posHistogramUnit=null;
  LinkNode<HistogramUnit> tmp=this.header;
  while (tmp != this.tail) {
    HistogramUnit chu=tmp.data();
    HistogramUnit nhu=tmp.next().data();
    if (chu.getHval() <= hval && hval < nhu.getHval()) {
      posHistogramUnit=tmp;
      break;
    }
    tmp=tmp.next();
  }
  if (posHistogramUnit != null) {
    HistogramUnit chu=posHistogramUnit.data();
    HistogramUnit nhu=posHistogramUnit.next().data();
    double mb=chu.getHcnt() + (nhu.getHcnt() - nhu.getHcnt()) * (hval - chu.getHval()) / (nhu.getHval() - chu.getHval());
    double s=(chu.getHcnt() + mb) * (hval - chu.getHval()) / (nhu.getHval() - chu.getHval());
    s=s / 2;
    tmp=this.header;
    while (tmp != posHistogramUnit) {
      HistogramUnit hu=tmp.data();
      s=s + hu.getHcnt();
      tmp=tmp.next();
    }
    return s + chu.getHcnt() / 2;
  }
 else   if (tmp == this.tail) {
    double sum=0.0;
    tmp=this.header;
    while (tmp != null) {
      sum+=tmp.data().getHcnt();
      tmp=tmp.next();
    }
    return sum;
  }
  return -1.0;
}",0.9199288256227758
32175,"/** 
 * Generate data bin by expected bin number
 * @param toBinningNum
 * @return
 */
private List<Double> getDataBin(int toBinningNum){
  List<Double> binBorders=new ArrayList<Double>();
  binBorders.add(Double.NEGATIVE_INFINITY);
  if (this.currentHistogramUnitCnt <= toBinningNum) {
    convertHistogramUnitIntoBin(binBorders);
    return binBorders;
  }
  int totalCnt=getTotalInHistogram();
  LinkNode<HistogramUnit> currStartPos=this.header;
  for (int j=1; j < toBinningNum; j++) {
    double s=(double)(j * totalCnt) / toBinningNum;
    LinkNode<HistogramUnit> pos=locateHistogram(s,currStartPos);
    if (pos == null || pos == currStartPos) {
      continue;
    }
 else {
      HistogramUnit chu=pos.data();
      HistogramUnit nhu=pos.next().data();
      double d=s - sum(chu.getHval());
      double a=nhu.getHcnt() - chu.getHcnt();
      double b=2 * chu.getHcnt();
      double c=-2 * d;
      double z=0.0;
      if (Double.compare(a,0) == 0) {
        z=-1 * c / b;
      }
 else {
        z=(-1 * b + Math.sqrt(b * b - 4 * a * c)) / (2 * a);
      }
      double u=chu.getHval() + (nhu.getHval() - chu.getHval()) * z;
      binBorders.add(u);
      currStartPos=pos;
    }
  }
  return binBorders;
}","/** 
 * Generate data bin by expected bin number
 * @param toBinningNum
 * @return
 */
private List<Double> getDataBin(int toBinningNum){
  List<Double> binBorders=new ArrayList<Double>();
  binBorders.add(Double.NEGATIVE_INFINITY);
  if (this.currentHistogramUnitCnt <= toBinningNum) {
    convertHistogramUnitIntoBin(binBorders);
    return binBorders;
  }
  int totalCnt=getTotalInHistogram();
  LinkNode<HistogramUnit> currStartPos=null;
  for (int j=1; j < toBinningNum; j++) {
    double s=(double)(j * totalCnt) / toBinningNum;
    LinkNode<HistogramUnit> pos=locateHistogram(s,currStartPos);
    if (pos == null || pos == currStartPos) {
      continue;
    }
 else {
      HistogramUnit chu=pos.data();
      HistogramUnit nhu=pos.next().data();
      double d=s - sum(chu.getHval());
      if (d < 0) {
        double u=(chu.getHval() + nhu.getHval()) / 2;
        binBorders.add(u);
        currStartPos=pos;
        continue;
      }
      double a=nhu.getHcnt() - chu.getHcnt();
      double b=2 * chu.getHcnt();
      double c=-2 * d;
      double z=0.0;
      if (Double.compare(a,0) == 0) {
        z=-1 * c / b;
      }
 else {
        z=(-1 * b + Math.sqrt(b * b - 4 * a * c)) / (2 * a);
      }
      double u=chu.getHval() + (nhu.getHval() - chu.getHval()) * z;
      binBorders.add(u);
      currStartPos=pos;
    }
  }
  return binBorders;
}",0.9352963967454476
32176,"/** 
 * @param minIntervalOpsUnit
 */
private void removeCurrentNode(LinkNode<HistogramUnit> currNode,LinkNode<HistogramUnit> nextNode){
  if (currNode == this.header) {
    nextNode.setPrev(null);
    this.header=nextNode;
  }
 else {
    LinkNode<HistogramUnit> prev=currNode.prev();
    prev.setNext(nextNode);
    nextNode.setPrev(prev);
  }
}","/** 
 * @param currNode
 * @param nextNode
 */
private void removeCurrentNode(LinkNode<HistogramUnit> currNode,LinkNode<HistogramUnit> nextNode){
  if (currNode == this.header) {
    nextNode.setPrev(null);
    this.header=nextNode;
  }
 else {
    LinkNode<HistogramUnit> prev=currNode.prev();
    prev.setNext(nextNode);
    nextNode.setPrev(prev);
  }
}",0.9359886201991464
32177,"@Override public void consumeWorkerResults(Iterable<VarSelWorkerResult> workerResults){
  int[] voteStats=new int[columnConfigList.size() + 1];
  for (  VarSelWorkerResult workerResult : workerResults) {
    for (    Integer columnId : workerResult.getColumnIdList()) {
      voteStats[columnId + 1]++;
    }
  }
  int maxVotedColumnId=-1;
  int maxVoteCount=Integer.MIN_VALUE;
  for (int i=0; i < voteStats.length; i++) {
    if (voteStats[i] > maxVoteCount) {
      maxVoteCount=voteStats[i];
      maxVotedColumnId=i;
    }
  }
  LOG.info(""String_Node_Str"",maxVotedColumnId,maxVoteCount);
  if (maxVotedColumnId > 0) {
    workingSet.add(maxVotedColumnId - 1);
  }
}","@Override public void consumeWorkerResults(Iterable<VarSelWorkerResult> workerResults){
  int[] voteStats=new int[columnConfigList.size() + 1];
  for (  VarSelWorkerResult workerResult : workerResults) {
    for (    Integer columnId : workerResult.getColumnIdList()) {
      voteStats[columnId + 1]++;
    }
  }
  int maxVotedColumnId=-1;
  int maxVoteCount=Integer.MIN_VALUE;
  for (int i=0; i < voteStats.length; i++) {
    if (voteStats[i] > maxVoteCount) {
      maxVoteCount=voteStats[i];
      maxVotedColumnId=i;
    }
  }
  LOG.info(""String_Node_Str"",(maxVotedColumnId - 1),maxVoteCount);
  if (maxVotedColumnId > 0) {
    workingSet.add(maxVotedColumnId - 1);
  }
}",0.9717261904761904
32178,"/** 
 * Create @DerivedField for categorical variable
 * @param config - ColumnConfig for categorical variable
 * @param cutoff - cutoff for normalization
 * @return DerivedField for variable
 */
private DerivedField createCategoricalDerivedField(ColumnConfig config,double cutoff){
  InlineTable inlineTable=new InlineTable();
  for (int i=0; i < config.getBinCategory().size(); i++) {
    String cval=config.getBinCategory().get(i);
    String dval=Normalizer.normalize(config,cval,cutoff).toString();
    Document document=null;
    try {
      document=DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();
    }
 catch (    ParserConfigurationException e) {
      e.printStackTrace();
    }
    Element out=document.createElementNS(NAME_SPACE_URI,ELEMENT_OUT);
    out.setTextContent(dval);
    Element origin=document.createElementNS(NAME_SPACE_URI,ELEMENT_ORIGIN);
    origin.setTextContent(cval);
    inlineTable.withRows(new Row().withContent(origin).withContent(out));
  }
  MapValues mapValues=new MapValues(""String_Node_Str"").withDataType(DataType.DOUBLE).withDefaultValue(""String_Node_Str"").withFieldColumnPairs(new FieldColumnPair(new FieldName(config.getColumnName()),""String_Node_Str"")).withInlineTable(inlineTable);
  mapValues.setMapMissingTo(""String_Node_Str"");
  return new DerivedField(OpType.CONTINUOUS,DataType.DOUBLE).withName(FieldName.create(config.getColumnName() + ZSCORE_POSTFIX)).withExpression(mapValues);
}","/** 
 * Create @DerivedField for categorical variable
 * @param config - ColumnConfig for categorical variable
 * @param cutoff - cutoff for normalization
 * @return DerivedField for variable
 */
private DerivedField createCategoricalDerivedField(ColumnConfig config,double cutoff){
  Document document=null;
  try {
    document=DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();
  }
 catch (  ParserConfigurationException e) {
    LOG.error(""String_Node_Str"",e);
    throw new RuntimeException(""String_Node_Str"",e);
  }
  String defaultValue=""String_Node_Str"";
  String missingValue=""String_Node_Str"";
  InlineTable inlineTable=new InlineTable();
  for (int i=0; i < config.getBinCategory().size(); i++) {
    String cval=config.getBinCategory().get(i);
    String dval=Normalizer.normalize(config,cval,cutoff).toString();
    Element out=document.createElementNS(NAME_SPACE_URI,ELEMENT_OUT);
    out.setTextContent(dval);
    Element origin=document.createElementNS(NAME_SPACE_URI,ELEMENT_ORIGIN);
    origin.setTextContent(cval);
    inlineTable.withRows(new Row().withContent(origin).withContent(out));
    if (StringUtils.isBlank(cval)) {
      missingValue=dval;
    }
  }
  MapValues mapValues=new MapValues(""String_Node_Str"").withDataType(DataType.DOUBLE).withDefaultValue(defaultValue).withFieldColumnPairs(new FieldColumnPair(new FieldName(config.getColumnName()),ELEMENT_ORIGIN)).withInlineTable(inlineTable).withMapMissingTo(missingValue);
  return new DerivedField(OpType.CONTINUOUS,DataType.DOUBLE).withName(FieldName.create(config.getColumnName() + ZSCORE_POSTFIX)).withExpression(mapValues);
}",0.7627063774684364
32179,"@Override public Tuple exec(Tuple input) throws IOException {
  if (input == null) {
    return null;
  }
  Integer columnId=(Integer)input.get(0);
  DataBag databag=(DataBag)input.get(1);
  ColumnConfig columnConfig=super.columnConfigList.get(columnId);
  AbstractBinning<?> binning=null;
  log.info(""String_Node_Str"" + columnId + ""String_Node_Str""+ databag.size());
  Iterator<Tuple> iterator=databag.iterator();
  while (iterator.hasNext()) {
    Tuple element=iterator.next();
    if (element == null || element.size() < 2) {
      continue;
    }
    String objValStr=(String)element.get(1);
    AbstractBinning<?> partialBinning=AbstractBinning.constructBinningFromStr(modelConfig,columnConfig,objValStr);
    if (binning == null) {
      binning=partialBinning;
    }
 else {
      binning.mergeBin(partialBinning);
    }
  }
  Tuple output=TupleFactory.getInstance().newTuple(2);
  output.set(0,columnId);
  output.set(1,StringUtils.join(binning.getDataBin(),CalculateStatsUDF.CATEGORY_VAL_SEPARATOR));
  log.info(""String_Node_Str"" + columnId);
  return output;
}","@Override public Tuple exec(Tuple input) throws IOException {
  if (input == null) {
    return null;
  }
  Integer columnId=(Integer)input.get(0);
  DataBag databag=(DataBag)input.get(1);
  ColumnConfig columnConfig=super.columnConfigList.get(columnId);
  AbstractBinning<?> binning=null;
  log.info(""String_Node_Str"" + columnId + ""String_Node_Str""+ databag.size());
  Iterator<Tuple> iterator=databag.iterator();
  while (iterator.hasNext()) {
    Tuple element=iterator.next();
    if (element == null || element.size() < 2) {
      continue;
    }
    String objValStr=(String)element.get(1);
    AbstractBinning<?> partialBinning=AbstractBinning.constructBinningFromStr(modelConfig,columnConfig,objValStr);
    if (binning == null) {
      binning=partialBinning;
    }
 else {
      binning.mergeBin(partialBinning);
    }
  }
  Tuple output=TupleFactory.getInstance().newTuple(2);
  output.set(0,columnId);
  List<?> binFields=binning.getDataBin();
  if (binFields.size() > CalculateNewStatsUDF.MAX_CATEGORICAL_BINC_COUNT) {
    output.set(1,""String_Node_Str"");
  }
 else {
    output.set(1,StringUtils.join(binning.getDataBin(),CalculateStatsUDF.CATEGORY_VAL_SEPARATOR));
  }
  log.info(""String_Node_Str"" + columnId);
  return output;
}",0.925269978401728
32180,"@Override public Tuple exec(Tuple input) throws IOException {
  if (input == null) {
    return null;
  }
  Integer columnId=(Integer)input.get(0);
  DataBag databag=(DataBag)input.get(1);
  String binningDataInfo=(String)input.get(3);
  log.info(""String_Node_Str"" + columnId.toString());
  ColumnConfig columnConfig=super.columnConfigList.get(columnId);
  AbstractVarStats varstats=AbstractVarStats.getVarStatsInst(modelConfig,columnConfig,valueThreshold);
  varstats.runVarStats(binningDataInfo,databag);
  log.info(""String_Node_Str"" + columnId.toString());
  KSIVCalculator ksivCalculator=new KSIVCalculator();
  ksivCalculator.calculateKSIV(columnConfig.getBinCountNeg(),columnConfig.getBinCountPos());
  DecimalFormat df=new DecimalFormat(""String_Node_Str"");
  Tuple tuple=TupleFactory.getInstance().newTuple();
  tuple.append(columnId);
  if (columnConfig.isCategorical()) {
    if (columnConfig.getBinCategory().size() == 0 || columnConfig.getBinCategory().size() > MAX_CATEGORICAL_BINC_COUNT) {
      return null;
    }
    String binCategory=""String_Node_Str"" + StringUtils.join(columnConfig.getBinCategory(),CalculateStatsUDF.CATEGORY_VAL_SEPARATOR) + ""String_Node_Str"";
    tuple.append(Base64Utils.base64Encode(binCategory));
  }
 else {
    if (columnConfig.getBinBoundary().size() == 1) {
      return null;
    }
    tuple.append(columnConfig.getBinBoundary().toString());
  }
  tuple.append(columnConfig.getBinCountNeg().toString());
  tuple.append(columnConfig.getBinCountPos().toString());
  tuple.append(columnConfig.getBinAvgScore().toString());
  tuple.append(columnConfig.getBinPosRate().toString());
  tuple.append(df.format(ksivCalculator.getKS()));
  tuple.append(df.format(ksivCalculator.getIV()));
  tuple.append(df.format(columnConfig.getColumnStats().getMax()));
  tuple.append(df.format(columnConfig.getColumnStats().getMin()));
  tuple.append(df.format(columnConfig.getColumnStats().getMean()));
  tuple.append(df.format(columnConfig.getColumnStats().getStdDev()));
  if (columnConfig.isCategorical()) {
    tuple.append(""String_Node_Str"");
  }
 else {
    tuple.append(""String_Node_Str"");
  }
  tuple.append((columnConfig.getColumnStats().getMedian()));
  tuple.append(columnConfig.getMissingCount());
  tuple.append(columnConfig.getTotalCount());
  tuple.append(df.format(columnConfig.getMissingPercentage()));
  tuple.append(columnConfig.getBinWeightedNeg().toString());
  tuple.append(columnConfig.getBinWeightedPos().toString());
  return tuple;
}","@Override public Tuple exec(Tuple input) throws IOException {
  if (input == null) {
    return null;
  }
  Integer columnId=(Integer)input.get(0);
  DataBag databag=(DataBag)input.get(1);
  String binningDataInfo=(String)input.get(3);
  log.info(""String_Node_Str"" + columnId.toString());
  ColumnConfig columnConfig=super.columnConfigList.get(columnId);
  AbstractVarStats varstats=AbstractVarStats.getVarStatsInst(modelConfig,columnConfig,valueThreshold);
  varstats.runVarStats(binningDataInfo,databag);
  log.info(""String_Node_Str"" + columnId.toString());
  KSIVCalculator ksivCalculator=new KSIVCalculator();
  ksivCalculator.calculateKSIV(columnConfig.getBinCountNeg(),columnConfig.getBinCountPos());
  DecimalFormat df=new DecimalFormat(""String_Node_Str"");
  Tuple tuple=TupleFactory.getInstance().newTuple();
  tuple.append(columnId);
  if (columnConfig.isCategorical()) {
    if (columnConfig.getBinCategory().size() == 0 || columnConfig.getBinCategory().size() > MAX_CATEGORICAL_BINC_COUNT) {
      return null;
    }
    String binCategory=""String_Node_Str"" + StringUtils.join(columnConfig.getBinCategory(),CalculateStatsUDF.CATEGORY_VAL_SEPARATOR) + ""String_Node_Str"";
    tuple.append(Base64Utils.base64Encode(binCategory));
  }
 else {
    if (columnConfig.getBinBoundary().size() == 1) {
      return null;
    }
    tuple.append(columnConfig.getBinBoundary().toString());
  }
  tuple.append(columnConfig.getBinCountNeg().toString());
  tuple.append(columnConfig.getBinCountPos().toString());
  tuple.append(columnConfig.getBinAvgScore().toString());
  tuple.append(columnConfig.getBinPosRate().toString());
  tuple.append(df.format(ksivCalculator.getKS()));
  tuple.append(df.format(ksivCalculator.getIV()));
  tuple.append(df.format(columnConfig.getColumnStats().getMax()));
  tuple.append(df.format(columnConfig.getColumnStats().getMin()));
  tuple.append(df.format(columnConfig.getColumnStats().getMean()));
  tuple.append(df.format(columnConfig.getColumnStats().getStdDev()));
  if (columnConfig.isCategorical()) {
    tuple.append(""String_Node_Str"");
  }
 else {
    tuple.append(""String_Node_Str"");
  }
  tuple.append(df.format(columnConfig.getColumnStats().getMedian()));
  tuple.append(columnConfig.getMissingCount());
  tuple.append(columnConfig.getTotalCount());
  tuple.append(df.format(columnConfig.getMissingPercentage()));
  tuple.append(columnConfig.getBinWeightedNeg().toString());
  tuple.append(columnConfig.getBinWeightedPos().toString());
  return tuple;
}",0.9981909547738692
32181,"/** 
 * Given a column value, return bin list index. Return 0 for Category because of index 0 is started from NEGATIVE_INFINITY.
 * @throws IllegalArgumentException if input is null or empty.
 * @throws NumberFormatException    if columnVal does not contain a parsable number.
 */
public static int getBinNum(ColumnConfig columnConfig,String columnVal){
  if (StringUtils.isEmpty(columnVal) || columnConfig == null) {
    throw new IllegalArgumentException(String.format(""String_Node_Str"",columnVal,columnConfig));
  }
  if (columnConfig.isCategorical()) {
    List<String> binCategories=columnConfig.getBinCategory();
    for (int i=0; i < binCategories.size(); i++) {
      if (binCategories.get(i).equals(columnVal)) {
        return i;
      }
    }
    return 0;
  }
 else {
    return getNumericBinNum(columnConfig.getBinBoundary(),Double.valueOf(columnVal));
  }
}","/** 
 * Given a column value, return bin list index. Return 0 for Category because of index 0 is started from NEGATIVE_INFINITY.
 * @throws IllegalArgumentException if input is null or empty.
 * @throws NumberFormatException    if columnVal does not contain a parsable number.
 */
public static int getBinNum(ColumnConfig columnConfig,String columnVal){
  if (columnConfig.isCategorical()) {
    List<String> binCategories=columnConfig.getBinCategory();
    for (int i=0; i < binCategories.size(); i++) {
      if (binCategories.get(i).equals(columnVal)) {
        return i;
      }
    }
    return -1;
  }
 else {
    if (StringUtils.isBlank(columnVal)) {
      return -1;
    }
    double dval=0.0;
    try {
      dval=Double.parseDouble(columnVal);
    }
 catch (    Exception e) {
      return -1;
    }
    return getNumericBinNum(columnConfig.getBinBoundary(),dval);
  }
}",0.4648772130211308
32182,"@Test public void testSerialObject(){
  CategoricalBinning binning=new CategoricalBinning(10);
  String binStr=binning.objToString();
  String[] fieldArr=binStr.split(Character.toString(AbstractBinning.FIELD_SEPARATOR),-1);
  Assert.assertTrue(fieldArr.length == 5);
}","@Test public void testSerialObject(){
  CategoricalBinning binning=new CategoricalBinning(10);
  String binStr=binning.objToString();
  String[] fieldArr=binStr.split(Character.toString(AbstractBinning.FIELD_SEPARATOR),-1);
  Assert.assertTrue(fieldArr.length == 6);
}",0.996268656716418
32183,"protected void runDistributedTrain() throws IOException, InterruptedException, ClassNotFoundException {
  LOG.info(""String_Node_Str"",isDryTrain ? ""String_Node_Str"" : ""String_Node_Str"");
  SourceType sourceType=super.getModelConfig().getDataSet().getSource();
  final List<String> args=new ArrayList<String>();
  prepareCommonParams(args,sourceType);
  Path tmpModelsPath=ShifuFileUtils.getFileSystemBySourceType(sourceType).makeQualified(new Path(super.getPathFinder().getPathBySourceType(new Path(Constants.TMP,Constants.DEFAULT_MODELS_TMP_FOLDER),sourceType)));
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,NNConstants.NN_TMP_MODELS_FOLDER,tmpModelsPath.toString()));
  int baggingNum=isForVarSelect ? 1 : super.getModelConfig().getBaggingNum();
  long start=System.currentTimeMillis();
  LOG.info(""String_Node_Str"",baggingNum);
  boolean isParallel=Boolean.valueOf(Environment.getProperty(SHIFU_DTRAIN_PARALLEL,SHIFU_DEFAULT_DTRAIN_PARALLEL)).booleanValue();
  GuaguaMapReduceClient guaguaClient=new GuaguaMapReduceClient();
  List<String> progressLogList=new ArrayList<String>(baggingNum);
  for (int i=0; i < baggingNum; i++) {
    args.add(""String_Node_Str"");
    args.add(String.format(""String_Node_Str"",super.getModelConfig().getModelSetName(),i + 1));
    LOG.info(""String_Node_Str"",(i + 1));
    String modelName=getModelName(i + 1);
    Path modelPath=ShifuFileUtils.getFileSystemBySourceType(sourceType).makeQualified(new Path(super.getPathFinder().getModelsPath(sourceType),modelName));
    args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,NNConstants.GUAGUA_NN_OUTPUT,modelPath.toString()));
    args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,NNConstants.NN_TRAINER_ID,String.valueOf(i + 1)));
    final String progressLogFile=getProgressLogFile(i + 1);
    progressLogList.add(progressLogFile);
    args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,NNConstants.NN_PROGRESS_FILE,progressLogFile));
    if (isParallel) {
      guaguaClient.addJob(args.toArray(new String[0]));
    }
 else {
      TailThread tailThread=startTailThread(new String[]{progressLogFile});
      guaguaClient.creatJob(args.toArray(new String[0])).waitForCompletion(true);
      stopTailThread(tailThread);
    }
  }
  if (isParallel) {
    TailThread tailThread=startTailThread(progressLogList.toArray(new String[0]));
    guaguaClient.run();
    stopTailThread(tailThread);
  }
  for (int i=0; i < baggingNum; i++) {
    String modelName=getModelName(i + 1);
    Path modelPath=ShifuFileUtils.getFileSystemBySourceType(sourceType).makeQualified(new Path(super.getPathFinder().getModelsPath(sourceType),modelName));
    copyModelToLocal(modelName,modelPath,sourceType);
  }
  copyTmpModelsToLocal(tmpModelsPath,sourceType);
  LOG.info(""String_Node_Str"",System.currentTimeMillis() - start);
}","protected void runDistributedTrain() throws IOException, InterruptedException, ClassNotFoundException {
  LOG.info(""String_Node_Str"",isDryTrain ? ""String_Node_Str"" : ""String_Node_Str"");
  SourceType sourceType=super.getModelConfig().getDataSet().getSource();
  final List<String> args=new ArrayList<String>();
  prepareCommonParams(args,sourceType);
  Path tmpModelsPath=ShifuFileUtils.getFileSystemBySourceType(sourceType).makeQualified(new Path(super.getPathFinder().getPathBySourceType(new Path(Constants.TMP,Constants.DEFAULT_MODELS_TMP_FOLDER),sourceType)));
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,NNConstants.NN_TMP_MODELS_FOLDER,tmpModelsPath.toString()));
  int baggingNum=isForVarSelect ? 1 : super.getModelConfig().getBaggingNum();
  long start=System.currentTimeMillis();
  LOG.info(""String_Node_Str"",baggingNum);
  boolean isParallel=Boolean.valueOf(Environment.getProperty(SHIFU_DTRAIN_PARALLEL,SHIFU_DEFAULT_DTRAIN_PARALLEL)).booleanValue();
  GuaguaMapReduceClient guaguaClient=new GuaguaMapReduceClient();
  List<String> progressLogList=new ArrayList<String>(baggingNum);
  for (int i=0; i < baggingNum; i++) {
    List<String> localArgs=new ArrayList<String>(args);
    localArgs.add(""String_Node_Str"");
    localArgs.add(String.format(""String_Node_Str"",super.getModelConfig().getModelSetName(),i + 1));
    LOG.info(""String_Node_Str"",(i + 1));
    String modelName=getModelName(i + 1);
    Path modelPath=ShifuFileUtils.getFileSystemBySourceType(sourceType).makeQualified(new Path(super.getPathFinder().getModelsPath(sourceType),modelName));
    localArgs.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,NNConstants.GUAGUA_NN_OUTPUT,modelPath.toString()));
    localArgs.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,NNConstants.NN_TRAINER_ID,String.valueOf(i + 1)));
    final String progressLogFile=getProgressLogFile(i + 1);
    progressLogList.add(progressLogFile);
    localArgs.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,NNConstants.NN_PROGRESS_FILE,progressLogFile));
    if (isParallel) {
      guaguaClient.addJob(localArgs.toArray(new String[0]));
    }
 else {
      TailThread tailThread=startTailThread(new String[]{progressLogFile});
      guaguaClient.creatJob(localArgs.toArray(new String[0])).waitForCompletion(true);
      stopTailThread(tailThread);
    }
  }
  if (isParallel) {
    TailThread tailThread=startTailThread(progressLogList.toArray(new String[0]));
    guaguaClient.run();
    stopTailThread(tailThread);
  }
  for (int i=0; i < baggingNum; i++) {
    String modelName=getModelName(i + 1);
    Path modelPath=ShifuFileUtils.getFileSystemBySourceType(sourceType).makeQualified(new Path(super.getPathFinder().getModelsPath(sourceType),modelName));
    copyModelToLocal(modelName,modelPath,sourceType);
  }
  copyTmpModelsToLocal(tmpModelsPath,sourceType);
  LOG.info(""String_Node_Str"",System.currentTimeMillis() - start);
}",0.98170412963931
32184,"private void writeColumnIdsIntoHDFS(Path path,List<Integer> columnIds){
  PrintWriter pw=null;
  try {
    FSDataOutputStream fos=FileSystem.get(new Configuration()).create(path);
    pw=new PrintWriter(fos);
    pw.println(Integer.toString(columnIds.size()) + ""String_Node_Str"" + columnIds.toString());
    pw.flush();
  }
 catch (  IOException e) {
    LOG.error(""String_Node_Str"",e);
  }
 finally {
    IOUtils.closeStream(pw);
  }
}","private void writeColumnIdsIntoHDFS(Path path,List<Integer> columnIds){
  PrintWriter pw=null;
  try {
    FSDataOutputStream fos=FileSystem.get(new Configuration()).create(path);
    pw=new PrintWriter(fos);
    pw.println(Integer.toString(columnIds.size()) + ""String_Node_Str"" + columnIds.toString());
    pw.flush();
  }
 catch (  IOException e) {
    e.printStackTrace();
    LOG.error(""String_Node_Str"",e);
  }
 finally {
    IOUtils.closeStream(pw);
  }
}",0.9721293199554067
32185,"private void votedVariablesSelection() throws ClassNotFoundException, IOException, InterruptedException {
  log.info(""String_Node_Str"");
  SourceType sourceType=super.getModelConfig().getDataSet().getSource();
  final List<String> args=new ArrayList<String>();
  prepareVarSelParams(args,sourceType);
  Path columnIdsPath=getVotedSelectionPath(sourceType);
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,Constants.VAR_SEL_COLUMN_IDS_OUPUT,columnIdsPath.toString()));
  System.out.println(args);
  long start=System.currentTimeMillis();
  GuaguaMapReduceClient guaguaClient=new GuaguaMapReduceClient();
  guaguaClient.creatJob(args.toArray(new String[0])).waitForCompletion(true);
  log.info(""String_Node_Str"",System.currentTimeMillis() - start);
}","private void votedVariablesSelection() throws ClassNotFoundException, IOException, InterruptedException {
  log.info(""String_Node_Str"");
  SourceType sourceType=super.getModelConfig().getDataSet().getSource();
  final List<String> args=new ArrayList<String>();
  prepareVarSelParams(args,sourceType);
  Path columnIdsPath=getVotedSelectionPath(sourceType);
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,Constants.VAR_SEL_COLUMN_IDS_OUPUT,columnIdsPath.toString()));
  System.out.println(args);
  long start=System.currentTimeMillis();
  GuaguaMapReduceClient guaguaClient=new GuaguaMapReduceClient();
  guaguaClient.creatJob(args.toArray(new String[0])).waitForCompletion(true);
  log.info(""String_Node_Str"",System.currentTimeMillis() - start);
  persistColumnIds(columnIdsPath);
}",0.977491961414791
32186,"@Test public void resilientPropagationTest(){
  double[] gradientError=new double[NUM_EPOCHS];
  double[] ecogError=new double[NUM_EPOCHS];
  network.reset();
  weights=network.getFlat().getWeights();
  MLDataSet[] subsets=splitDataSet(training);
  Gradient[] workers=new Gradient[numSplit];
  Weight weightCalculator=null;
  for (int i=0; i < workers.length; i++) {
    workers[i]=initGradient(subsets[i]);
    workers[i].setWeights(weights);
  }
  log.info(""String_Node_Str"");
  NNParams globalParams=new NNParams();
  globalParams.setWeights(weights);
  for (int i=0; i < NUM_EPOCHS; i++) {
    double error=0.0;
    for (int j=0; j < workers.length; j++) {
      workers[j].run();
      error+=workers[j].getError();
    }
    gradientError[i]=error / workers.length;
    log.info(""String_Node_Str"" + i + ""String_Node_Str""+ gradientError[i]);
    globalParams.reset();
    for (int j=0; j < workers.length; j++) {
      globalParams.accumulateGradients(workers[j].getGradients());
      globalParams.accumulateTrainSize(subsets[j].getRecordCount());
    }
    if (weightCalculator == null) {
      weightCalculator=new Weight(globalParams.getGradients().length,globalParams.getTrainSize(),this.rate,NNUtils.RESILIENTPROPAGATION);
    }
    double[] interWeight=weightCalculator.calculateWeights(globalParams.getWeights(),globalParams.getGradients());
    globalParams.setWeights(interWeight);
    for (int j=0; j < workers.length; j++) {
      workers[j].setWeights(interWeight);
    }
  }
  network.reset();
  network.getFlat().setWeights(weights);
  Propagation p=null;
  p=new ResilientPropagation(network,training);
  p.setThreadCount(numSplit);
  for (int i=0; i < NUM_EPOCHS; i++) {
    p.iteration(1);
    ecogError[i]=p.getError();
  }
  double diff=0.0;
  for (int i=0; i < NUM_EPOCHS; i++) {
    diff+=Math.abs(ecogError[i] - gradientError[i]);
  }
  Assert.assertTrue(diff / NUM_EPOCHS < 0.5);
}","@Test public void resilientPropagationTest(){
  double[] gradientError=new double[NUM_EPOCHS];
  double[] ecogError=new double[NUM_EPOCHS];
  network.reset();
  weights=network.getFlat().getWeights();
  MLDataSet[] subsets=splitDataSet(training);
  Gradient[] workers=new Gradient[numSplit];
  Weight weightCalculator=null;
  for (int i=0; i < workers.length; i++) {
    workers[i]=initGradient(subsets[i]);
    workers[i].setWeights(weights);
  }
  log.info(""String_Node_Str"");
  NNParams globalParams=new NNParams();
  globalParams.setWeights(weights);
  for (int i=0; i < NUM_EPOCHS; i++) {
    double error=0.0;
    for (int j=0; j < workers.length; j++) {
      workers[j].run();
      error+=workers[j].getError();
    }
    gradientError[i]=error / workers.length;
    log.info(""String_Node_Str"" + i + ""String_Node_Str""+ gradientError[i]);
    globalParams.reset();
    for (int j=0; j < workers.length; j++) {
      globalParams.accumulateGradients(workers[j].getGradients());
      globalParams.accumulateTrainSize(subsets[j].getRecordCount());
    }
    if (weightCalculator == null) {
      weightCalculator=new Weight(globalParams.getGradients().length,globalParams.getTrainSize(),this.rate,NNUtils.RESILIENTPROPAGATION);
    }
    double[] interWeight=weightCalculator.calculateWeights(globalParams.getWeights(),globalParams.getGradients());
    globalParams.setWeights(interWeight);
    for (int j=0; j < workers.length; j++) {
      workers[j].setWeights(interWeight);
    }
  }
  network.reset();
  network.getFlat().setWeights(weights);
  Propagation p=null;
  p=new ResilientPropagation(network,training);
  p.setThreadCount(numSplit);
  for (int i=0; i < NUM_EPOCHS; i++) {
    p.iteration(1);
    ecogError[i]=p.getError();
  }
  double diff=0.0;
  for (int i=0; i < NUM_EPOCHS; i++) {
    diff+=Math.abs(ecogError[i] - gradientError[i]);
  }
  Assert.assertTrue(diff / NUM_EPOCHS < 0.2);
}",0.999476439790576
32187,"@Override public Tuple exec(Tuple input) throws IOException {
  if (input == null || input.size() != 2) {
    return null;
  }
  Integer columnId=(Integer)input.get(0);
  DataBag databag=(DataBag)input.get(1);
  ColumnConfig columnConfig=super.columnConfigList.get(columnId);
  AbstractBinning<?> binning=null;
  if (columnConfig.isCategorical()) {
    binning=new CategoricalBinning(-1);
  }
 else {
    if (super.modelConfig.getBinningMethod().equals(BinningMethod.EqualInterval)) {
      binning=new EqualIntervalBinning(modelConfig.getStats().getMaxNumBin());
    }
 else {
      binning=new EqualPopulationBinning(modelConfig.getStats().getMaxNumBin());
    }
  }
  Iterator<Tuple> iterator=databag.iterator();
  while (iterator.hasNext()) {
    Tuple element=iterator.next();
    if (element == null || element.size() != 4) {
      continue;
    }
    Object value=element.get(1);
    if (value != null) {
      binning.addData(value.toString());
    }
  }
  Tuple output=TupleFactory.getInstance().newTuple(2);
  output.set(0,columnId);
  output.set(1,StringUtils.join(binning.getDataBin(),CalculateStatsUDF.CATEGORY_VAL_SEPARATOR));
  return output;
}","@Override public Tuple exec(Tuple input) throws IOException {
  if (input == null || input.size() != 2) {
    return null;
  }
  Integer columnId=(Integer)input.get(0);
  DataBag databag=(DataBag)input.get(1);
  ColumnConfig columnConfig=super.columnConfigList.get(columnId);
  AbstractBinning<?> binning=null;
  if (columnConfig.isCategorical()) {
    binning=new CategoricalBinning(-1);
  }
 else {
    if (super.modelConfig.getBinningMethod().equals(BinningMethod.EqualInterval)) {
      binning=new EqualIntervalBinning(modelConfig.getStats().getMaxNumBin());
    }
 else {
      binning=new MunroPatBinning(modelConfig.getStats().getMaxNumBin());
    }
  }
  Iterator<Tuple> iterator=databag.iterator();
  while (iterator.hasNext()) {
    Tuple element=iterator.next();
    if (element == null || element.size() != 4) {
      continue;
    }
    Object value=element.get(1);
    if (value != null) {
      binning.addData(value.toString());
    }
  }
  Tuple output=TupleFactory.getInstance().newTuple(2);
  output.set(0,columnId);
  output.set(1,StringUtils.join(binning.getDataBin(),CalculateStatsUDF.CATEGORY_VAL_SEPARATOR));
  return output;
}",0.9909130246646474
32188,"public MSEWorker(BasicNetwork network,AbstractTrainer owner,MLDataSet dataSet,int low,int high){
  this.network=network;
  this.owner=owner;
  this.dataSet=dataSet;
  this.low=low;
  this.high=high;
  this.pair=BasicMLDataPair.createPair(network.getInputCount(),network.getOutputCount());
}","public MSEWorker(BasicNetwork network,MLDataSet dataSet,int low,int high){
  this.network=network;
  this.dataSet=dataSet;
  this.low=low;
  this.high=high;
  this.pair=BasicMLDataPair.createPair(network.getInputCount(),network.getOutputCount());
  this.totalError=0.0;
}",0.8841354723707665
32189,"public void run(){
  for (int i=this.low; i <= this.high; i++) {
    this.dataSet.getRecord(i,pair);
    MLData result=this.network.compute(this.pair.getInput());
    double tmp=result.getData()[0] - this.pair.getIdeal().getData()[0];
    double mse=tmp * tmp;
    owner.report(mse);
  }
}","public void run(){
  for (int i=this.low; i <= this.high; i++) {
    this.dataSet.getRecord(i,pair);
    MLData result=this.network.compute(this.pair.getInput());
    double tmp=result.getData()[0] - this.pair.getIdeal().getData()[0];
    double mse=tmp * tmp;
    this.totalError+=mse;
  }
}",0.93631669535284
32190,"@Override public void load(GuaguaWritableAdapter<LongWritable> currentKey,GuaguaWritableAdapter<Text> currentValue,WorkerContext<VarSelMasterResult,VarSelWorkerResult> workerContext){
  if ((++this.count) % 100000 == 0) {
    LOG.info(""String_Node_Str"",this.count);
  }
  String record=currentValue.getWritable().toString();
  String[] fields=CommonUtils.split(record,modelConfig.getDataSetDelimiter());
  int targetColumnId=CommonUtils.getTargetColumnNum(columnConfigList);
  String tag=StringUtils.trim(fields[targetColumnId]);
  if (this.dataPurifier.isFilterOut(record) && isPosOrNegTag(modelConfig,tag)) {
    double[] inputs=new double[this.inputNodeCount];
    double[] ideal=new double[this.outputNodeCount];
    double significance=NNConstants.DEFAULT_SIGNIFICANCE_VALUE;
    if (this.weightColumnId >= 0) {
      try {
        significance=Double.parseDouble(fields[this.weightColumnId]);
      }
 catch (      Exception e) {
      }
    }
    ideal[0]=(this.modelConfig.getPosTags().contains(tag) ? 1.0d : 0.0d);
    int i=0;
    for (    Integer columnId : this.trainingDataSet.getDataColumnIdList()) {
      inputs[i++]=Normalizer.normalize(columnConfigList.get(columnId),fields[columnId]);
    }
    trainingDataSet.addTrainingRecord(new TrainingRecord(inputs,ideal,significance));
  }
}","@Override public void load(GuaguaWritableAdapter<LongWritable> currentKey,GuaguaWritableAdapter<Text> currentValue,WorkerContext<VarSelMasterResult,VarSelWorkerResult> workerContext){
  if ((++this.count) % 100000 == 0) {
    LOG.info(""String_Node_Str"",this.count);
  }
  String record=currentValue.getWritable().toString();
  String[] fields=CommonUtils.split(record,modelConfig.getDataSetDelimiter());
  int targetColumnId=CommonUtils.getTargetColumnNum(columnConfigList);
  String tag=StringUtils.trim(fields[targetColumnId]);
  long posRecordCount=0;
  long totalRecordCount=0;
  if (this.dataPurifier.isFilterOut(record) && isPosOrNegTag(modelConfig,tag)) {
    totalRecordCount++;
    if (modelConfig.getPosTags().contains(tag)) {
      posRecordCount++;
    }
    double[] inputs=new double[this.inputNodeCount];
    double[] ideal=new double[this.outputNodeCount];
    double significance=NNConstants.DEFAULT_SIGNIFICANCE_VALUE;
    if (this.weightColumnId >= 0) {
      try {
        significance=Double.parseDouble(fields[this.weightColumnId]);
      }
 catch (      Exception e) {
      }
    }
    ideal[0]=(this.modelConfig.getPosTags().contains(tag) ? 1.0d : 0.0d);
    int i=0;
    for (    Integer columnId : this.trainingDataSet.getDataColumnIdList()) {
      inputs[i++]=Normalizer.normalize(columnConfigList.get(columnId),fields[columnId]);
    }
    trainingDataSet.addTrainingRecord(new TrainingRecord(inputs,ideal,significance));
  }
  LOG.info(""String_Node_Str"",totalRecordCount,posRecordCount);
}",0.9223679546260192
32191,"public void generateValidateData(Set<Integer> workingColumnIdSet,double validationRate,MLDataSet trainingData,MLDataSet testingData){
  for (  TrainingRecord trainingRecord : trainingRecords) {
    MLDataPair pair=trainingRecord.toMLDataPair(dataColumnIdList,workingColumnIdSet);
    double seed=rd.nextDouble();
    if (seed > validationRate) {
      trainingData.add(pair);
    }
 else {
      testingData.add(pair);
    }
  }
}","public void generateValidateData(Set<Integer> workingColumnIdSet,double validationRate,MLDataSet trainingData,MLDataSet testingData){
  for (  TrainingRecord trainingRecord : trainingRecords) {
    MLDataPair pair=trainingRecord.toMLDataPair(dataColumnIdList,workingColumnIdSet);
    trainingData.add(pair);
  }
}",0.7913862718707941
32192,"@Override public void consumeWorkerResults(Iterable<VarSelWorkerResult> workerResults){
  int[] voteStats=new int[columnConfigList.size() + 1];
  for (  VarSelWorkerResult workerResult : workerResults) {
    for (    Integer columnId : workerResult.getColumnIdList()) {
      voteStats[columnId + 1]++;
    }
  }
  int maxVotedColumnId=-1;
  int maxVoteCount=Integer.MIN_VALUE;
  for (int i=0; i < voteStats.length; i++) {
    if (voteStats[i] > maxVoteCount) {
      maxVoteCount=voteStats[i];
      maxVotedColumnId=i;
    }
  }
  if (maxVotedColumnId > 0) {
    workingSet.add(maxVotedColumnId - 1);
  }
}","@Override public void consumeWorkerResults(Iterable<VarSelWorkerResult> workerResults){
  int[] voteStats=new int[columnConfigList.size() + 1];
  for (  VarSelWorkerResult workerResult : workerResults) {
    for (    Integer columnId : workerResult.getColumnIdList()) {
      voteStats[columnId + 1]++;
    }
  }
  int maxVotedColumnId=-1;
  int maxVoteCount=Integer.MIN_VALUE;
  for (int i=0; i < voteStats.length; i++) {
    if (voteStats[i] > maxVoteCount) {
      maxVoteCount=voteStats[i];
      maxVotedColumnId=i;
    }
  }
  LOG.info(""String_Node_Str"",maxVotedColumnId,maxVoteCount);
  if (maxVotedColumnId > 0) {
    workingSet.add(maxVotedColumnId - 1);
  }
}",0.9506656225528582
32193,"public WrapperMasterConductor(ModelConfig modelConfig,List<ColumnConfig> columnConfigList){
  super(modelConfig,columnConfigList);
  this.workingSet=new HashSet<Integer>();
  this.expectVarCount=this.modelConfig.getVarSelectFilterNum();
  for (  ColumnConfig columnConfig : columnConfigList) {
    if (columnConfig.isCandidate() && columnConfig.isForceSelect()) {
      workingSet.add(columnConfig.getColumnNum());
    }
  }
}","public WrapperMasterConductor(ModelConfig modelConfig,List<ColumnConfig> columnConfigList){
  super(modelConfig,columnConfigList);
  this.workingSet=new HashSet<Integer>();
  this.expectVarCount=this.modelConfig.getVarSelectFilterNum();
  for (  ColumnConfig columnConfig : columnConfigList) {
    if (columnConfig.isCandidate() && columnConfig.isForceSelect()) {
      workingSet.add(columnConfig.getColumnNum());
    }
  }
  LOG.info(""String_Node_Str"",expectVarCount,workingSet.size());
}",0.9301310043668122
32194,"@Override public VarSelWorkerResult generateVarSelResult(){
  Set<Integer> workingColumnSet=new HashSet<Integer>();
  double minValidateError=Double.MAX_VALUE;
  ColumnConfig bestCandidate=null;
  for (  ColumnConfig columnConfig : candidates) {
    if (!baseColumnSet.contains(columnConfig.getColumnNum())) {
      workingColumnSet.clear();
      workingColumnSet.addAll(baseColumnSet);
      workingColumnSet.add(columnConfig.getColumnNum());
      ValidationConductor validationConductor=new ValidationConductor(modelConfig,columnConfigList,workingColumnSet,trainingDataSet);
      double validateError=validationConductor.runValidate();
      if (validateError < minValidateError) {
        minValidateError=validateError;
        bestCandidate=columnConfig;
      }
    }
  }
  System.out.println(""String_Node_Str"" + bestCandidate.getColumnName() + ""String_Node_Str""+ minValidateError);
  return ((bestCandidate == null) ? getDefaultWorkerResult() : getWorkerResult(bestCandidate.getColumnNum()));
}","@Override public VarSelWorkerResult generateVarSelResult(){
  Set<Integer> workingColumnSet=new HashSet<Integer>();
  double minValidateError=Double.MAX_VALUE;
  ColumnConfig bestCandidate=null;
  for (  ColumnConfig columnConfig : candidates) {
    if (!baseColumnSet.contains(columnConfig.getColumnNum())) {
      workingColumnSet.clear();
      workingColumnSet.addAll(baseColumnSet);
      workingColumnSet.add(columnConfig.getColumnNum());
      ValidationConductor validationConductor=new ValidationConductor(modelConfig,columnConfigList,workingColumnSet,trainingDataSet);
      double validateError=validationConductor.runValidate();
      if (validateError < minValidateError) {
        minValidateError=validateError;
        bestCandidate=columnConfig;
      }
    }
  }
  LOG.info(""String_Node_Str"" + bestCandidate.getColumnName() + ""String_Node_Str""+ minValidateError);
  return ((bestCandidate == null) ? getDefaultWorkerResult() : getWorkerResult(bestCandidate.getColumnNum()));
}",0.986986986986987
32195,"public MSEWorker(BasicNetwork network,AbstractTrainer owner,MLDataSet dataSet,int low,int high){
  this.network=network;
  this.owner=owner;
  this.dataSet=dataSet;
  this.low=low;
  this.high=high;
  this.pair=BasicMLDataPair.createPair(network.getInputCount(),network.getOutputCount());
}","public MSEWorker(BasicNetwork network,MLDataSet dataSet,int low,int high){
  this.network=network;
  this.dataSet=dataSet;
  this.low=low;
  this.high=high;
  this.pair=BasicMLDataPair.createPair(network.getInputCount(),network.getOutputCount());
  this.totalError=0.0;
}",0.8841354723707665
32196,"public void run(){
  for (int i=this.low; i <= this.high; i++) {
    this.dataSet.getRecord(i,pair);
    MLData result=this.network.compute(this.pair.getInput());
    double tmp=result.getData()[0] - this.pair.getIdeal().getData()[0];
    double mse=tmp * tmp;
    owner.report(mse);
  }
}","public void run(){
  for (int i=this.low; i <= this.high; i++) {
    this.dataSet.getRecord(i,pair);
    MLData result=this.network.compute(this.pair.getInput());
    double tmp=result.getData()[0] - this.pair.getIdeal().getData()[0];
    double mse=tmp * tmp;
    this.totalError+=mse;
  }
}",0.93631669535284
32197,"@Override public void load(GuaguaWritableAdapter<LongWritable> currentKey,GuaguaWritableAdapter<Text> currentValue,WorkerContext<VarSelMasterResult,VarSelWorkerResult> workerContext){
  if ((++this.count) % 100000 == 0) {
    LOG.info(""String_Node_Str"",this.count);
  }
  String record=currentValue.getWritable().toString();
  String[] fields=CommonUtils.split(record,modelConfig.getDataSetDelimiter());
  int targetColumnId=CommonUtils.getTargetColumnNum(columnConfigList);
  String tag=StringUtils.trim(fields[targetColumnId]);
  if (this.dataPurifier.isFilterOut(record) && isPosOrNegTag(modelConfig,tag)) {
    double[] inputs=new double[this.inputNodeCount];
    double[] ideal=new double[this.outputNodeCount];
    double significance=NNConstants.DEFAULT_SIGNIFICANCE_VALUE;
    if (this.weightColumnId >= 0) {
      try {
        significance=Double.parseDouble(fields[this.weightColumnId]);
      }
 catch (      Exception e) {
      }
    }
    ideal[0]=(this.modelConfig.getPosTags().contains(tag) ? 1.0d : 0.0d);
    int i=0;
    for (    Integer columnId : this.trainingDataSet.getDataColumnIdList()) {
      inputs[i++]=Normalizer.normalize(columnConfigList.get(columnId),fields[columnId]);
    }
    trainingDataSet.addTrainingRecord(new TrainingRecord(inputs,ideal,significance));
  }
}","@Override public void load(GuaguaWritableAdapter<LongWritable> currentKey,GuaguaWritableAdapter<Text> currentValue,WorkerContext<VarSelMasterResult,VarSelWorkerResult> workerContext){
  if ((++this.count) % 100000 == 0) {
    LOG.info(""String_Node_Str"",this.count);
  }
  String record=currentValue.getWritable().toString();
  String[] fields=CommonUtils.split(record,modelConfig.getDataSetDelimiter());
  int targetColumnId=CommonUtils.getTargetColumnNum(columnConfigList);
  String tag=StringUtils.trim(fields[targetColumnId]);
  long posRecordCount=0;
  long totalRecordCount=0;
  if (this.dataPurifier.isFilterOut(record) && isPosOrNegTag(modelConfig,tag)) {
    totalRecordCount++;
    if (modelConfig.getPosTags().contains(tag)) {
      posRecordCount++;
    }
    double[] inputs=new double[this.inputNodeCount];
    double[] ideal=new double[this.outputNodeCount];
    double significance=NNConstants.DEFAULT_SIGNIFICANCE_VALUE;
    if (this.weightColumnId >= 0) {
      try {
        significance=Double.parseDouble(fields[this.weightColumnId]);
      }
 catch (      Exception e) {
      }
    }
    ideal[0]=(this.modelConfig.getPosTags().contains(tag) ? 1.0d : 0.0d);
    int i=0;
    for (    Integer columnId : this.trainingDataSet.getDataColumnIdList()) {
      inputs[i++]=Normalizer.normalize(columnConfigList.get(columnId),fields[columnId]);
    }
    trainingDataSet.addTrainingRecord(new TrainingRecord(inputs,ideal,significance));
  }
  LOG.info(""String_Node_Str"",totalRecordCount,posRecordCount);
}",0.9223679546260192
32198,"public void generateValidateData(Set<Integer> workingColumnIdSet,double validationRate,MLDataSet trainingData,MLDataSet testingData){
  for (  TrainingRecord trainingRecord : trainingRecords) {
    MLDataPair pair=trainingRecord.toMLDataPair(dataColumnIdList,workingColumnIdSet);
    double seed=rd.nextDouble();
    if (seed > validationRate) {
      trainingData.add(pair);
    }
 else {
      testingData.add(pair);
    }
  }
}","public void generateValidateData(Set<Integer> workingColumnIdSet,double validationRate,MLDataSet trainingData,MLDataSet testingData){
  for (  TrainingRecord trainingRecord : trainingRecords) {
    MLDataPair pair=trainingRecord.toMLDataPair(dataColumnIdList,workingColumnIdSet);
    trainingData.add(pair);
  }
}",0.7913862718707941
32199,"@Override public void consumeWorkerResults(Iterable<VarSelWorkerResult> workerResults){
  int[] voteStats=new int[columnConfigList.size() + 1];
  for (  VarSelWorkerResult workerResult : workerResults) {
    for (    Integer columnId : workerResult.getColumnIdList()) {
      voteStats[columnId + 1]++;
    }
  }
  int maxVotedColumnId=-1;
  int maxVoteCount=Integer.MIN_VALUE;
  for (int i=0; i < voteStats.length; i++) {
    if (voteStats[i] > maxVoteCount) {
      maxVoteCount=voteStats[i];
      maxVotedColumnId=i;
    }
  }
  if (maxVotedColumnId > 0) {
    workingSet.add(maxVotedColumnId - 1);
  }
}","@Override public void consumeWorkerResults(Iterable<VarSelWorkerResult> workerResults){
  int[] voteStats=new int[columnConfigList.size() + 1];
  for (  VarSelWorkerResult workerResult : workerResults) {
    for (    Integer columnId : workerResult.getColumnIdList()) {
      voteStats[columnId + 1]++;
    }
  }
  int maxVotedColumnId=-1;
  int maxVoteCount=Integer.MIN_VALUE;
  for (int i=0; i < voteStats.length; i++) {
    if (voteStats[i] > maxVoteCount) {
      maxVoteCount=voteStats[i];
      maxVotedColumnId=i;
    }
  }
  LOG.info(""String_Node_Str"",maxVotedColumnId,maxVoteCount);
  if (maxVotedColumnId > 0) {
    workingSet.add(maxVotedColumnId - 1);
  }
}",0.9506656225528582
32200,"public WrapperMasterConductor(ModelConfig modelConfig,List<ColumnConfig> columnConfigList){
  super(modelConfig,columnConfigList);
  this.workingSet=new HashSet<Integer>();
  this.expectVarCount=this.modelConfig.getVarSelectFilterNum();
  for (  ColumnConfig columnConfig : columnConfigList) {
    if (columnConfig.isCandidate() && columnConfig.isForceSelect()) {
      workingSet.add(columnConfig.getColumnNum());
    }
  }
}","public WrapperMasterConductor(ModelConfig modelConfig,List<ColumnConfig> columnConfigList){
  super(modelConfig,columnConfigList);
  this.workingSet=new HashSet<Integer>();
  this.expectVarCount=this.modelConfig.getVarSelectFilterNum();
  for (  ColumnConfig columnConfig : columnConfigList) {
    if (columnConfig.isCandidate() && columnConfig.isForceSelect()) {
      workingSet.add(columnConfig.getColumnNum());
    }
  }
  LOG.info(""String_Node_Str"",expectVarCount,workingSet.size());
}",0.9301310043668122
32201,"@Override public VarSelWorkerResult generateVarSelResult(){
  Set<Integer> workingColumnSet=new HashSet<Integer>();
  double minValidateError=Double.MAX_VALUE;
  ColumnConfig bestCandidate=null;
  for (  ColumnConfig columnConfig : candidates) {
    if (!baseColumnSet.contains(columnConfig.getColumnNum())) {
      workingColumnSet.clear();
      workingColumnSet.addAll(baseColumnSet);
      workingColumnSet.add(columnConfig.getColumnNum());
      ValidationConductor validationConductor=new ValidationConductor(modelConfig,columnConfigList,workingColumnSet,trainingDataSet);
      double validateError=validationConductor.runValidate();
      if (validateError < minValidateError) {
        minValidateError=validateError;
        bestCandidate=columnConfig;
      }
    }
  }
  System.out.println(""String_Node_Str"" + bestCandidate.getColumnName() + ""String_Node_Str""+ minValidateError);
  return ((bestCandidate == null) ? getDefaultWorkerResult() : getWorkerResult(bestCandidate.getColumnNum()));
}","@Override public VarSelWorkerResult generateVarSelResult(){
  Set<Integer> workingColumnSet=new HashSet<Integer>();
  double minValidateError=Double.MAX_VALUE;
  ColumnConfig bestCandidate=null;
  for (  ColumnConfig columnConfig : candidates) {
    if (!baseColumnSet.contains(columnConfig.getColumnNum())) {
      workingColumnSet.clear();
      workingColumnSet.addAll(baseColumnSet);
      workingColumnSet.add(columnConfig.getColumnNum());
      ValidationConductor validationConductor=new ValidationConductor(modelConfig,columnConfigList,workingColumnSet,trainingDataSet);
      double validateError=validationConductor.runValidate();
      if (validateError < minValidateError) {
        minValidateError=validateError;
        bestCandidate=columnConfig;
      }
    }
  }
  LOG.info(""String_Node_Str"" + bestCandidate.getColumnName() + ""String_Node_Str""+ minValidateError);
  return ((bestCandidate == null) ? getDefaultWorkerResult() : getWorkerResult(bestCandidate.getColumnNum()));
}",0.986986986986987
32202,"private void prepareVarSelParams(final List<String> args,final SourceType sourceType){
  args.add(""String_Node_Str"");
  addRuntimeJars(args);
  args.add(""String_Node_Str"");
  args.add(ShifuFileUtils.getFileSystemBySourceType(sourceType).makeQualified(new Path(modelConfig.getDataSetRawPath())).toString());
  String zkServers=Environment.getProperty(Environment.ZOO_KEEPER_SERVERS);
  if (StringUtils.isEmpty(zkServers)) {
    log.warn(""String_Node_Str"");
  }
 else {
    args.add(""String_Node_Str"");
    args.add(zkServers);
  }
  args.add(""String_Node_Str"");
  args.add(VarSelWorker.class.getName());
  args.add(""String_Node_Str"");
  args.add(VarSelMaster.class.getName());
  args.add(""String_Node_Str"");
  int expectVarCount=this.modelConfig.getVarSelectFilterNum();
  int forceSelectCount=0;
  int candidateCount=0;
  for (  ColumnConfig columnConfig : columnConfigList) {
    if (columnConfig.isForceSelect()) {
      forceSelectCount++;
    }
    if (CommonUtils.isGoodCandidate(columnConfig)) {
      candidateCount++;
    }
  }
  args.add(String.valueOf(Math.min(expectVarCount,candidateCount) - forceSelectCount + 1));
  args.add(""String_Node_Str"");
  args.add(VarSelMasterResult.class.getName());
  args.add(""String_Node_Str"");
  args.add(VarSelWorkerResult.class.getName());
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,Constants.VAR_SEL_MASTER_CONDUCTOR,Environment.getProperty(Environment.VAR_SEL_MASTER_CONDUCTOR,WrapperMasterConductor.class.getName())));
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,Constants.VAR_SEL_WORKER_CONDUCTOR,Environment.getProperty(Environment.VAR_SEL_MASTER_CONDUCTOR,WrapperWorkerConductor.class.getName())));
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,NNConstants.MAPRED_JOB_QUEUE_NAME,Environment.getProperty(Environment.HADOOP_JOB_QUEUE,Constants.DEFAULT_JOB_QUEUE)));
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,GuaguaConstants.GUAGUA_MASTER_INTERCEPTERS,VarSelOutput.class.getName()));
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,NNConstants.SHIFU_NN_MODEL_CONFIG,ShifuFileUtils.getFileSystemBySourceType(sourceType).makeQualified(new Path(super.getPathFinder().getModelConfigPath(sourceType)))));
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,NNConstants.SHIFU_NN_COLUMN_CONFIG,ShifuFileUtils.getFileSystemBySourceType(sourceType).makeQualified(new Path(super.getPathFinder().getColumnConfigPath(sourceType)))));
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,NNConstants.NN_MODELSET_SOURCE_TYPE,sourceType));
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,GuaguaConstants.GUAGUA_COMPUTATION_TIME_THRESHOLD,60 * 1000l));
  setHeapSizeAndSplitSize(args);
  for (  Map.Entry<Object,Object> entry : Environment.getProperties().entrySet()) {
    if (entry.getKey().toString().startsWith(""String_Node_Str"") || entry.getKey().toString().startsWith(""String_Node_Str"") || entry.getKey().toString().startsWith(""String_Node_Str"")) {
      args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,entry.getKey().toString(),entry.getValue().toString()));
    }
  }
}","private void prepareVarSelParams(final List<String> args,final SourceType sourceType){
  args.add(""String_Node_Str"");
  addRuntimeJars(args);
  args.add(""String_Node_Str"");
  args.add(ShifuFileUtils.getFileSystemBySourceType(sourceType).makeQualified(new Path(modelConfig.getDataSetRawPath())).toString());
  String zkServers=Environment.getProperty(Environment.ZOO_KEEPER_SERVERS);
  if (StringUtils.isEmpty(zkServers)) {
    log.warn(""String_Node_Str"");
  }
 else {
    args.add(""String_Node_Str"");
    args.add(zkServers);
  }
  args.add(""String_Node_Str"");
  args.add(VarSelWorker.class.getName());
  args.add(""String_Node_Str"");
  args.add(VarSelMaster.class.getName());
  args.add(""String_Node_Str"");
  int expectVarCount=this.modelConfig.getVarSelectFilterNum();
  int forceSelectCount=0;
  int candidateCount=0;
  for (  ColumnConfig columnConfig : columnConfigList) {
    if (columnConfig.isForceSelect()) {
      forceSelectCount++;
    }
    if (CommonUtils.isGoodCandidate(columnConfig)) {
      candidateCount++;
    }
  }
  args.add(String.valueOf(Math.min(expectVarCount,candidateCount) - forceSelectCount + 1));
  args.add(""String_Node_Str"");
  args.add(VarSelMasterResult.class.getName());
  args.add(""String_Node_Str"");
  args.add(VarSelWorkerResult.class.getName());
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,Constants.VAR_SEL_MASTER_CONDUCTOR,Environment.getProperty(Environment.VAR_SEL_MASTER_CONDUCTOR,WrapperMasterConductor.class.getName())));
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,Constants.VAR_SEL_WORKER_CONDUCTOR,Environment.getProperty(Environment.VAR_SEL_MASTER_CONDUCTOR,WrapperWorkerConductor.class.getName())));
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,NNConstants.MAPRED_JOB_QUEUE_NAME,Environment.getProperty(Environment.HADOOP_JOB_QUEUE,Constants.DEFAULT_JOB_QUEUE)));
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,GuaguaConstants.GUAGUA_MASTER_INTERCEPTERS,VarSelOutput.class.getName()));
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,NNConstants.SHIFU_NN_MODEL_CONFIG,ShifuFileUtils.getFileSystemBySourceType(sourceType).makeQualified(new Path(super.getPathFinder().getModelConfigPath(sourceType)))));
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,NNConstants.SHIFU_NN_COLUMN_CONFIG,ShifuFileUtils.getFileSystemBySourceType(sourceType).makeQualified(new Path(super.getPathFinder().getColumnConfigPath(sourceType)))));
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,NNConstants.NN_MODELSET_SOURCE_TYPE,sourceType));
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,GuaguaConstants.GUAGUA_COMPUTATION_TIME_THRESHOLD,60 * 60 * 1000l));
  setHeapSizeAndSplitSize(args);
  for (  Map.Entry<Object,Object> entry : Environment.getProperties().entrySet()) {
    if (entry.getKey().toString().startsWith(""String_Node_Str"") || entry.getKey().toString().startsWith(""String_Node_Str"") || entry.getKey().toString().startsWith(""String_Node_Str"")) {
      args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,entry.getKey().toString(),entry.getValue().toString()));
    }
  }
}",0.9992003838157684
32203,"private void votedVariablesSelection() throws ClassNotFoundException, IOException, InterruptedException {
  log.info(""String_Node_Str"");
  SourceType sourceType=super.getModelConfig().getDataSet().getSource();
  final List<String> args=new ArrayList<String>();
  prepareVarSelParams(args,sourceType);
  Path columnIdsPath=getVotedSelectionPath(sourceType);
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,Constants.VAR_SEL_COLUMN_IDS_OUPUT,columnIdsPath.toString()));
  long start=System.currentTimeMillis();
  GuaguaMapReduceClient guaguaClient=new GuaguaMapReduceClient();
  guaguaClient.creatJob(args.toArray(new String[0])).waitForCompletion(true);
  log.info(""String_Node_Str"",System.currentTimeMillis() - start);
  persistColumnIds(columnIdsPath);
  super.syncDataToHdfs(sourceType);
}","private void votedVariablesSelection() throws ClassNotFoundException, IOException, InterruptedException {
  log.info(""String_Node_Str"");
  super.syncDataToHdfs(modelConfig.getDataSet().getSource());
  SourceType sourceType=super.getModelConfig().getDataSet().getSource();
  final List<String> args=new ArrayList<String>();
  prepareVarSelParams(args,sourceType);
  Path columnIdsPath=getVotedSelectionPath(sourceType);
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,Constants.VAR_SEL_COLUMN_IDS_OUPUT,columnIdsPath.toString()));
  long start=System.currentTimeMillis();
  GuaguaMapReduceClient guaguaClient=new GuaguaMapReduceClient();
  guaguaClient.creatJob(args.toArray(new String[0])).waitForCompletion(true);
  log.info(""String_Node_Str"",System.currentTimeMillis() - start);
  persistColumnIds(columnIdsPath);
  super.syncDataToHdfs(sourceType);
}",0.9628297362110312
32204,"private Propagation getMLTrain(){
  String alg=(String)modelConfig.getParams().get(PROPAGATION);
  if (!(defaultLearningRate.containsKey(alg))) {
    throw new RuntimeException(""String_Node_Str"" + alg);
  }
  double rate=defaultLearningRate.get(alg);
  Object rateObj=modelConfig.getParams().get(LEARNING_RATE);
  if (rateObj instanceof Double) {
    rate=(Double)rateObj;
  }
 else   if (rateObj instanceof Integer) {
    rate=((Integer)rateObj).doubleValue();
  }
 else   if (rateObj instanceof Float) {
    rate=((Float)rateObj).doubleValue();
  }
  log.info(""String_Node_Str"" + learningAlgMap.get(alg));
  if (alg.equals(""String_Node_Str"") || alg.equals(""String_Node_Str"") || alg.equals(""String_Node_Str"")) {
    log.info(""String_Node_Str"" + rate);
  }
  if (alg.equals(""String_Node_Str"")) {
    return new Backpropagation(network,trainSet,rate,0);
  }
 else   if (alg.equals(""String_Node_Str"")) {
    return new QuickPropagation(network,trainSet,rate);
  }
 else   if (alg.equals(""String_Node_Str"")) {
    return new ManhattanPropagation(network,trainSet,rate);
  }
 else   if (alg.equals(""String_Node_Str"")) {
    return new ResilientPropagation(network,trainSet);
  }
 else   if (alg.equals(""String_Node_Str"")) {
    return new ScaledConjugateGradient(network,trainSet);
  }
 else {
    return null;
  }
}","private Propagation getMLTrain(){
  String alg=(String)modelConfig.getParams().get(PROPAGATION);
  if (!(defaultLearningRate.containsKey(alg))) {
    throw new RuntimeException(""String_Node_Str"" + alg);
  }
  double rate=defaultLearningRate.get(alg);
  Object rateObj=modelConfig.getParams().get(LEARNING_RATE);
  if (rateObj instanceof Double) {
    rate=(Double)rateObj;
  }
 else   if (rateObj instanceof Integer) {
    rate=((Integer)rateObj).doubleValue();
  }
 else   if (rateObj instanceof Float) {
    rate=((Float)rateObj).doubleValue();
  }
  if (toLoggingProcess)   log.info(""String_Node_Str"" + learningAlgMap.get(alg));
  if (alg.equals(""String_Node_Str"") || alg.equals(""String_Node_Str"") || alg.equals(""String_Node_Str"")) {
    if (toLoggingProcess)     log.info(""String_Node_Str"" + rate);
  }
  if (alg.equals(""String_Node_Str"")) {
    return new Backpropagation(network,trainSet,rate,0);
  }
 else   if (alg.equals(""String_Node_Str"")) {
    return new QuickPropagation(network,trainSet,rate);
  }
 else   if (alg.equals(""String_Node_Str"")) {
    return new ManhattanPropagation(network,trainSet,rate);
  }
 else   if (alg.equals(""String_Node_Str"")) {
    return new ResilientPropagation(network,trainSet);
  }
 else   if (alg.equals(""String_Node_Str"")) {
    return new ScaledConjugateGradient(network,trainSet);
  }
 else {
    return null;
  }
}",0.981301421091997
32205,"@SuppressWarnings(""String_Node_Str"") public void buildNetwork(){
  network=new BasicNetwork();
  network.addLayer(new BasicLayer(new ActivationLinear(),true,trainSet.getInputSize()));
  int numLayers=(Integer)modelConfig.getParams().get(NUM_HIDDEN_LAYERS);
  List<String> actFunc=(List<String>)modelConfig.getParams().get(ACTIVATION_FUNC);
  List<Integer> hiddenNodeList=(List<Integer>)modelConfig.getParams().get(NUM_HIDDEN_NODES);
  if (numLayers != 0 && (numLayers != actFunc.size() || numLayers != hiddenNodeList.size())) {
    throw new RuntimeException(""String_Node_Str"");
  }
  log.info(""String_Node_Str"" + numLayers + ""String_Node_Str""+ Arrays.toString(hiddenNodeList.toArray())+ ""String_Node_Str""+ Arrays.toString(actFunc.toArray()));
  for (int i=0; i < numLayers; i++) {
    String func=actFunc.get(i);
    Integer numHiddenNode=hiddenNodeList.get(i);
    if (""String_Node_Str"".equalsIgnoreCase(func)) {
      network.addLayer(new BasicLayer(new ActivationLinear(),true,numHiddenNode));
    }
 else     if (func.equalsIgnoreCase(""String_Node_Str"")) {
      network.addLayer(new BasicLayer(new ActivationSigmoid(),true,numHiddenNode));
    }
 else     if (func.equalsIgnoreCase(""String_Node_Str"")) {
      network.addLayer(new BasicLayer(new ActivationTANH(),true,numHiddenNode));
    }
 else     if (func.equalsIgnoreCase(""String_Node_Str"")) {
      network.addLayer(new BasicLayer(new ActivationLOG(),true,numHiddenNode));
    }
 else     if (func.equalsIgnoreCase(""String_Node_Str"")) {
      network.addLayer(new BasicLayer(new ActivationSIN(),true,numHiddenNode));
    }
 else {
      log.info(""String_Node_Str"" + func + ""String_Node_Str"");
      network.addLayer(new BasicLayer(new ActivationSigmoid(),true,numHiddenNode));
    }
  }
  network.addLayer(new BasicLayer(new ActivationSigmoid(),false,trainSet.getIdealSize()));
  network.getStructure().finalizeStructure();
  if (!modelConfig.isFixInitialInput()) {
    network.reset();
  }
 else {
    int numWeight=0;
    for (int i=0; i < network.getLayerCount() - 1; i++) {
      numWeight=numWeight + network.getLayerTotalNeuronCount(i) * network.getLayerNeuronCount(i + 1);
    }
    log.info(""String_Node_Str"" + numWeight + ""String_Node_Str"");
    loadWeightsInput(numWeight);
  }
}","@SuppressWarnings(""String_Node_Str"") public void buildNetwork(){
  network=new BasicNetwork();
  network.addLayer(new BasicLayer(new ActivationLinear(),true,trainSet.getInputSize()));
  int numLayers=(Integer)modelConfig.getParams().get(NUM_HIDDEN_LAYERS);
  List<String> actFunc=(List<String>)modelConfig.getParams().get(ACTIVATION_FUNC);
  List<Integer> hiddenNodeList=(List<Integer>)modelConfig.getParams().get(NUM_HIDDEN_NODES);
  if (numLayers != 0 && (numLayers != actFunc.size() || numLayers != hiddenNodeList.size())) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (toLoggingProcess)   log.info(""String_Node_Str"" + numLayers + ""String_Node_Str""+ Arrays.toString(hiddenNodeList.toArray())+ ""String_Node_Str""+ Arrays.toString(actFunc.toArray()));
  for (int i=0; i < numLayers; i++) {
    String func=actFunc.get(i);
    Integer numHiddenNode=hiddenNodeList.get(i);
    if (""String_Node_Str"".equalsIgnoreCase(func)) {
      network.addLayer(new BasicLayer(new ActivationLinear(),true,numHiddenNode));
    }
 else     if (func.equalsIgnoreCase(""String_Node_Str"")) {
      network.addLayer(new BasicLayer(new ActivationSigmoid(),true,numHiddenNode));
    }
 else     if (func.equalsIgnoreCase(""String_Node_Str"")) {
      network.addLayer(new BasicLayer(new ActivationTANH(),true,numHiddenNode));
    }
 else     if (func.equalsIgnoreCase(""String_Node_Str"")) {
      network.addLayer(new BasicLayer(new ActivationLOG(),true,numHiddenNode));
    }
 else     if (func.equalsIgnoreCase(""String_Node_Str"")) {
      network.addLayer(new BasicLayer(new ActivationSIN(),true,numHiddenNode));
    }
 else {
      log.info(""String_Node_Str"" + func + ""String_Node_Str"");
      network.addLayer(new BasicLayer(new ActivationSigmoid(),true,numHiddenNode));
    }
  }
  network.addLayer(new BasicLayer(new ActivationSigmoid(),false,trainSet.getIdealSize()));
  network.getStructure().finalizeStructure();
  if (!modelConfig.isFixInitialInput()) {
    network.reset();
  }
 else {
    int numWeight=0;
    for (int i=0; i < network.getLayerCount() - 1; i++) {
      numWeight=numWeight + network.getLayerTotalNeuronCount(i) * network.getLayerNeuronCount(i + 1);
    }
    log.info(""String_Node_Str"" + numWeight + ""String_Node_Str"");
    loadWeightsInput(numWeight);
  }
}",0.994697304463102
32206,"@Override public double train() throws IOException {
  log.info(""String_Node_Str"");
  if (this.dryRun) {
    log.info(""String_Node_Str"" + this.trainerID);
  }
 else {
    log.info(""String_Node_Str"" + this.trainerID);
  }
  log.info(""String_Node_Str"" + trainSet.getInputSize());
  log.info(""String_Node_Str"" + trainSet.getIdealSize());
  buildNetwork();
  Propagation mlTrain=getMLTrain();
  mlTrain.setThreadCount(0);
  if (this.dryRun) {
    return 0.0;
  }
  int epochs=this.modelConfig.getNumTrainEpochs();
  int factor=Math.max(epochs / 50,10);
  setBaseMSE(Double.MAX_VALUE);
  for (int i=0; i < epochs; i++) {
    mlTrain.iteration();
    if (i % factor == 0) {
      this.saveTmpNN(i);
    }
    double validMSE=(this.validSet.getRecordCount() > 0) ? getValidSetError() : mlTrain.getError();
    String extra=""String_Node_Str"";
    if (validMSE < getBaseMSE()) {
      setBaseMSE(validMSE);
      saveNN();
      extra=""String_Node_Str"" + this.trainerID + ""String_Node_Str"";
    }
    log.info(""String_Node_Str"" + trainerID + ""String_Node_Str""+ (i + 1)+ ""String_Node_Str""+ df.format(mlTrain.getError())+ ""String_Node_Str""+ ((this.validSet.getRecordCount() > 0) ? df.format(validMSE) : ""String_Node_Str"")+ ""String_Node_Str""+ extra);
  }
  mlTrain.finishTraining();
  log.info(""String_Node_Str"" + this.trainerID + ""String_Node_Str"");
  return getBaseMSE();
}","@Override public double train() throws IOException {
  if (toLoggingProcess)   log.info(""String_Node_Str"");
  if (toLoggingProcess) {
    if (this.dryRun) {
      log.info(""String_Node_Str"" + this.trainerID);
    }
 else {
      log.info(""String_Node_Str"" + this.trainerID);
    }
    log.info(""String_Node_Str"" + trainSet.getInputSize());
    log.info(""String_Node_Str"" + trainSet.getIdealSize());
  }
  buildNetwork();
  Propagation mlTrain=getMLTrain();
  mlTrain.setThreadCount(0);
  if (this.dryRun) {
    return 0.0;
  }
  int epochs=this.modelConfig.getNumTrainEpochs();
  int factor=Math.max(epochs / 50,10);
  setBaseMSE(Double.MAX_VALUE);
  for (int i=0; i < epochs; i++) {
    mlTrain.iteration();
    if (i % factor == 0) {
      this.saveTmpNN(i);
    }
    double validMSE=(this.validSet.getRecordCount() > 0) ? getValidSetError() : mlTrain.getError();
    String extra=""String_Node_Str"";
    if (validMSE < getBaseMSE()) {
      setBaseMSE(validMSE);
      saveNN();
      extra=""String_Node_Str"" + this.trainerID + ""String_Node_Str"";
    }
    if (toLoggingProcess)     log.info(""String_Node_Str"" + trainerID + ""String_Node_Str""+ (i + 1)+ ""String_Node_Str""+ df.format(mlTrain.getError())+ ""String_Node_Str""+ ((this.validSet.getRecordCount() > 0) ? df.format(validMSE) : ""String_Node_Str"")+ ""String_Node_Str""+ extra);
  }
  mlTrain.finishTraining();
  if (toLoggingProcess)   log.info(""String_Node_Str"" + this.trainerID + ""String_Node_Str"");
  return getBaseMSE();
}",0.938115330520394
32207,"@Override public void init(WorkerContext<VarSelMasterResult,VarSelWorkerResult> workerContext){
  Properties props=workerContext.getProps();
  try {
    RawSourceData.SourceType sourceType=RawSourceData.SourceType.valueOf(props.getProperty(NNConstants.NN_MODELSET_SOURCE_TYPE,RawSourceData.SourceType.HDFS.toString()));
    this.modelConfig=CommonUtils.loadModelConfig(props.getProperty(NNConstants.SHIFU_NN_MODEL_CONFIG),sourceType);
    this.columnConfigList=CommonUtils.loadColumnConfigList(NNConstants.SHIFU_NN_COLUMN_CONFIG,sourceType);
    String conductorClsName=props.getProperty(Constants.VAR_SEL_WORKER_CONDUCTOR);
    this.workerConductor=(AbstractWorkerConductor)Class.forName(conductorClsName).getDeclaredConstructor(ModelConfig.class,List.class).newInstance(this.modelConfig,this.columnConfigList);
  }
 catch (  IOException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
catch (  ClassNotFoundException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
catch (  InstantiationException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
catch (  IllegalAccessException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
catch (  NoSuchMethodException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
catch (  InvocationTargetException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
  List<Integer> normalizedColumnIdList=this.getNormalizedColumnIdList();
  this.inputNodeCount=normalizedColumnIdList.size();
  this.outputNodeCount=this.getTargetColumnCount();
  trainingDataSet=new TrainingDataSet(normalizedColumnIdList);
}","@Override public void init(WorkerContext<VarSelMasterResult,VarSelWorkerResult> workerContext){
  Properties props=workerContext.getProps();
  try {
    RawSourceData.SourceType sourceType=RawSourceData.SourceType.valueOf(props.getProperty(NNConstants.NN_MODELSET_SOURCE_TYPE,RawSourceData.SourceType.HDFS.toString()));
    this.modelConfig=CommonUtils.loadModelConfig(props.getProperty(NNConstants.SHIFU_NN_MODEL_CONFIG),sourceType);
    this.columnConfigList=CommonUtils.loadColumnConfigList(NNConstants.SHIFU_NN_COLUMN_CONFIG,sourceType);
    String conductorClsName=props.getProperty(Constants.VAR_SEL_WORKER_CONDUCTOR);
    this.workerConductor=(AbstractWorkerConductor)Class.forName(conductorClsName).getDeclaredConstructor(ModelConfig.class,List.class).newInstance(this.modelConfig,this.columnConfigList);
  }
 catch (  IOException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
catch (  ClassNotFoundException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
catch (  InstantiationException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
catch (  IllegalAccessException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
catch (  NoSuchMethodException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
catch (  InvocationTargetException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
  List<Integer> normalizedColumnIdList=this.getNormalizedColumnIdList();
  this.inputNodeCount=normalizedColumnIdList.size();
  this.outputNodeCount=this.getTargetColumnCount();
  trainingDataSet=new TrainingDataSet(normalizedColumnIdList);
  try {
    dataPurifier=new DataPurifier(modelConfig);
  }
 catch (  IOException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
  if (StringUtils.isNotBlank(modelConfig.getWeightColumnName())) {
    for (    ColumnConfig columnConfig : columnConfigList) {
      if (columnConfig.getColumnName().equalsIgnoreCase(modelConfig.getWeightColumnName().trim())) {
        this.weightColumnId=columnConfig.getColumnNum();
        break;
      }
    }
  }
}",0.8746276739777958
32208,"@Override public void load(GuaguaWritableAdapter<LongWritable> currentKey,GuaguaWritableAdapter<Text> currentValue,WorkerContext<VarSelMasterResult,VarSelWorkerResult> workerContext){
  if ((++this.count) % 100000 == 0) {
    LOG.info(""String_Node_Str"",this.count);
  }
  double[] inputs=new double[this.inputNodeCount];
  double[] ideal=new double[this.outputNodeCount];
  double significance=NNConstants.DEFAULT_SIGNIFICANCE_VALUE;
  int elementCnt=0;
  for (  String input : Splitter.on(NNConstants.NN_DEFAULT_COLUMN_SEPARATOR).split(currentValue.getWritable().toString())) {
    double dval=NumberFormatUtils.getDouble(input.trim(),0.0d);
    if (elementCnt < this.outputNodeCount) {
      ideal[elementCnt++]=dval;
    }
 else {
      int inputsIndex=(elementCnt++) - this.outputNodeCount;
      if (inputsIndex < this.inputNodeCount) {
        inputs[inputsIndex]=dval;
      }
 else       if (inputsIndex == this.inputNodeCount) {
        significance=dval;
      }
 else {
        break;
      }
    }
  }
  if (elementCnt != this.inputNodeCount + this.outputNodeCount + 1) {
    LOG.warn(""String_Node_Str"",(this.inputNodeCount + this.outputNodeCount + 1),elementCnt);
  }
 else {
    trainingDataSet.addTrainingRecord(new TrainingRecord(inputs,ideal,significance));
  }
}","@Override public void load(GuaguaWritableAdapter<LongWritable> currentKey,GuaguaWritableAdapter<Text> currentValue,WorkerContext<VarSelMasterResult,VarSelWorkerResult> workerContext){
  if ((++this.count) % 100000 == 0) {
    LOG.info(""String_Node_Str"",this.count);
  }
  String record=currentValue.getWritable().toString();
  String[] fields=CommonUtils.split(record,modelConfig.getDataSetDelimiter());
  int targetColumnId=CommonUtils.getTargetColumnNum(columnConfigList);
  String tag=StringUtils.trim(fields[targetColumnId]);
  if (this.dataPurifier.isFilterOut(record) && isPosOrNegTag(modelConfig,tag)) {
    double[] inputs=new double[this.inputNodeCount];
    double[] ideal=new double[this.outputNodeCount];
    double significance=NNConstants.DEFAULT_SIGNIFICANCE_VALUE;
    if (this.weightColumnId >= 0) {
      try {
        significance=Double.parseDouble(fields[this.weightColumnId]);
      }
 catch (      Exception e) {
      }
    }
    ideal[0]=(this.modelConfig.getPosTags().contains(tag) ? 1.0d : 0.0d);
    int i=0;
    for (    Integer columnId : this.trainingDataSet.getDataColumnIdList()) {
      inputs[i++]=Normalizer.normalize(columnConfigList.get(columnId),fields[columnId]);
    }
    trainingDataSet.addTrainingRecord(new TrainingRecord(inputs,ideal,significance));
  }
}",0.3665246028671057
32209,"private List<Integer> getNormalizedColumnIdList(){
  List<Integer> normalizedColumnIdList=new ArrayList<Integer>();
  for (  ColumnConfig config : columnConfigList) {
    if (config.isCandidate()) {
      normalizedColumnIdList.add(config.getColumnNum());
    }
  }
  return normalizedColumnIdList;
}","private List<Integer> getNormalizedColumnIdList(){
  List<Integer> normalizedColumnIdList=new ArrayList<Integer>();
  for (  ColumnConfig config : columnConfigList) {
    if (config.isCandidate() && isGoodVarSelCandidate(config)) {
      normalizedColumnIdList.add(config.getColumnNum());
    }
  }
  return normalizedColumnIdList;
}",0.9478672985781992
32210,"public MLDataPair toMLDataPair(List<Integer> dataColumnIdList,Set<Integer> workingColumnSet){
  return null;
}","public MLDataPair toMLDataPair(List<Integer> dataColumnIdList,Set<Integer> workingColumnSet){
  double[] params=new double[workingColumnSet.size()];
  int pos=0;
  for (int i=0; i < dataColumnIdList.size(); i++) {
    if (workingColumnSet.contains(dataColumnIdList.get(i))) {
      params[pos++]=inputs[i];
    }
  }
  return new BasicMLDataPair(new BasicMLData(params),new BasicMLData(this.ideal));
}",0.3796477495107632
32211,"public double runValidate(){
  MLDataSet trainingData=new BasicMLDataSet();
  MLDataSet testingData=new BasicMLDataSet();
  this.trainingDataSet.generateValidateData(this.workingColumnSet,this.modelConfig.getCrossValidationRate(),trainingData,testingData);
  NNTrainer trainer=new NNTrainer(this.modelConfig,1,false);
  trainer.setTrainSet(trainingData);
  trainer.setValidSet(testingData);
  trainer.disableModelPersistence();
  double validateError=Double.MAX_VALUE;
  try {
    validateError=trainer.train();
  }
 catch (  IOException e) {
    validateError=trainer.getBaseMSE();
  }
  return validateError;
}","public double runValidate(){
  MLDataSet trainingData=new BasicMLDataSet();
  MLDataSet testingData=new BasicMLDataSet();
  this.trainingDataSet.generateValidateData(this.workingColumnSet,this.modelConfig.getCrossValidationRate(),trainingData,testingData);
  NNTrainer trainer=new NNTrainer(this.modelConfig,1,false);
  trainer.setTrainSet(trainingData);
  trainer.setValidSet(testingData);
  trainer.disableModelPersistence();
  trainer.disableLogging();
  double validateError=Double.MAX_VALUE;
  try {
    validateError=trainer.train();
  }
 catch (  IOException e) {
    validateError=trainer.getBaseMSE();
  }
  return validateError;
}",0.977635782747604
32212,"@Override public VarSelWorkerResult generateVarSelResult(){
  Set<Integer> workingColumnSet=new HashSet<Integer>();
  double minValidateError=Double.MAX_VALUE;
  ColumnConfig bestCandidate=null;
  for (  ColumnConfig columnConfig : candidates) {
    if (!baseColumnSet.contains(columnConfig.getColumnNum())) {
      workingColumnSet.clear();
      workingColumnSet.addAll(baseColumnSet);
      workingColumnSet.add(columnConfig.getColumnNum());
      ValidationConductor validationConductor=new ValidationConductor(modelConfig,columnConfigList,workingColumnSet,trainingDataSet);
      double validateError=validationConductor.runValidate();
      if (validateError < minValidateError) {
        minValidateError=validateError;
        bestCandidate=columnConfig;
      }
    }
  }
  return ((bestCandidate == null) ? getDefaultWorkerResult() : getWorkerResult(bestCandidate.getColumnNum()));
}","@Override public VarSelWorkerResult generateVarSelResult(){
  Set<Integer> workingColumnSet=new HashSet<Integer>();
  double minValidateError=Double.MAX_VALUE;
  ColumnConfig bestCandidate=null;
  for (  ColumnConfig columnConfig : candidates) {
    if (!baseColumnSet.contains(columnConfig.getColumnNum())) {
      workingColumnSet.clear();
      workingColumnSet.addAll(baseColumnSet);
      workingColumnSet.add(columnConfig.getColumnNum());
      ValidationConductor validationConductor=new ValidationConductor(modelConfig,columnConfigList,workingColumnSet,trainingDataSet);
      double validateError=validationConductor.runValidate();
      if (validateError < minValidateError) {
        minValidateError=validateError;
        bestCandidate=columnConfig;
      }
    }
  }
  System.out.println(""String_Node_Str"" + bestCandidate.getColumnName() + ""String_Node_Str""+ minValidateError);
  return ((bestCandidate == null) ? getDefaultWorkerResult() : getWorkerResult(bestCandidate.getColumnNum()));
}",0.94148655772272
32213,"public WrapperWorkerConductor(ModelConfig modelConfig,List<ColumnConfig> columnConfigList){
  super(modelConfig,columnConfigList);
  this.candidates=new ArrayList<ColumnConfig>();
  for (  ColumnConfig columnConfig : columnConfigList) {
    if (columnConfig.isCandidate() && !columnConfig.isFinalSelect()) {
      candidates.add(columnConfig);
    }
  }
}","public WrapperWorkerConductor(ModelConfig modelConfig,List<ColumnConfig> columnConfigList){
  super(modelConfig,columnConfigList);
  this.candidates=new ArrayList<ColumnConfig>();
  for (  ColumnConfig columnConfig : columnConfigList) {
    if (columnConfig.isCandidate() && !columnConfig.isForceSelect()) {
      candidates.add(columnConfig);
    }
  }
}",0.9887323943661972
32214,"private void prepareVarSelParams(final List<String> args,final SourceType sourceType){
  args.add(""String_Node_Str"");
  addRuntimeJars(args);
  args.add(""String_Node_Str"");
  args.add(ShifuFileUtils.getFileSystemBySourceType(sourceType).makeQualified(new Path(modelConfig.getDataSetRawPath())).toString());
  String zkServers=Environment.getProperty(Environment.ZOO_KEEPER_SERVERS);
  if (StringUtils.isEmpty(zkServers)) {
    log.warn(""String_Node_Str"");
  }
 else {
    args.add(""String_Node_Str"");
    args.add(zkServers);
  }
  args.add(""String_Node_Str"");
  args.add(VarSelWorker.class.getName());
  args.add(""String_Node_Str"");
  args.add(VarSelMaster.class.getName());
  args.add(""String_Node_Str"");
  int expectVarCount=this.modelConfig.getVarSelectFilterNum();
  int forceSelectCount=0;
  int candidateCount=0;
  for (  ColumnConfig columnConfig : columnConfigList) {
    if (columnConfig.isForceSelect()) {
      forceSelectCount++;
    }
    if (columnConfig.isCandidate()) {
      candidateCount++;
    }
  }
  args.add(String.valueOf(Math.min(expectVarCount,candidateCount) - forceSelectCount));
  args.add(""String_Node_Str"");
  args.add(VarSelMasterResult.class.getName());
  args.add(""String_Node_Str"");
  args.add(VarSelWorkerResult.class.getName());
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,Constants.VAR_SEL_MASTER_CONDUCTOR,Environment.getProperty(Environment.VAR_SEL_MASTER_CONDUCTOR,WrapperMasterConductor.class.getName())));
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,Constants.VAR_SEL_WORKER_CONDUCTOR,Environment.getProperty(Environment.VAR_SEL_MASTER_CONDUCTOR,WrapperWorkerConductor.class.getName())));
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,NNConstants.MAPRED_JOB_QUEUE_NAME,Environment.getProperty(Environment.HADOOP_JOB_QUEUE,Constants.DEFAULT_JOB_QUEUE)));
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,GuaguaConstants.GUAGUA_MASTER_INTERCEPTERS,VarSelOutput.class.getName()));
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,NNConstants.SHIFU_NN_MODEL_CONFIG,ShifuFileUtils.getFileSystemBySourceType(sourceType).makeQualified(new Path(super.getPathFinder().getModelConfigPath(sourceType)))));
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,NNConstants.SHIFU_NN_COLUMN_CONFIG,ShifuFileUtils.getFileSystemBySourceType(sourceType).makeQualified(new Path(super.getPathFinder().getColumnConfigPath(sourceType)))));
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,NNConstants.NN_MODELSET_SOURCE_TYPE,sourceType));
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,GuaguaConstants.GUAGUA_COMPUTATION_TIME_THRESHOLD,60 * 1000l));
  setHeapSizeAndSplitSize(args);
  for (  Map.Entry<Object,Object> entry : Environment.getProperties().entrySet()) {
    if (entry.getKey().toString().startsWith(""String_Node_Str"") || entry.getKey().toString().startsWith(""String_Node_Str"") || entry.getKey().toString().startsWith(""String_Node_Str"")) {
      args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,entry.getKey().toString(),entry.getValue().toString()));
    }
  }
}","private void prepareVarSelParams(final List<String> args,final SourceType sourceType){
  args.add(""String_Node_Str"");
  addRuntimeJars(args);
  args.add(""String_Node_Str"");
  args.add(ShifuFileUtils.getFileSystemBySourceType(sourceType).makeQualified(new Path(modelConfig.getDataSetRawPath())).toString());
  String zkServers=Environment.getProperty(Environment.ZOO_KEEPER_SERVERS);
  if (StringUtils.isEmpty(zkServers)) {
    log.warn(""String_Node_Str"");
  }
 else {
    args.add(""String_Node_Str"");
    args.add(zkServers);
  }
  args.add(""String_Node_Str"");
  args.add(VarSelWorker.class.getName());
  args.add(""String_Node_Str"");
  args.add(VarSelMaster.class.getName());
  args.add(""String_Node_Str"");
  int expectVarCount=this.modelConfig.getVarSelectFilterNum();
  int forceSelectCount=0;
  int candidateCount=0;
  for (  ColumnConfig columnConfig : columnConfigList) {
    if (columnConfig.isForceSelect()) {
      forceSelectCount++;
    }
    if (CommonUtils.isGoodCandidate(columnConfig)) {
      candidateCount++;
    }
  }
  args.add(String.valueOf(Math.min(expectVarCount,candidateCount) - forceSelectCount + 1));
  args.add(""String_Node_Str"");
  args.add(VarSelMasterResult.class.getName());
  args.add(""String_Node_Str"");
  args.add(VarSelWorkerResult.class.getName());
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,Constants.VAR_SEL_MASTER_CONDUCTOR,Environment.getProperty(Environment.VAR_SEL_MASTER_CONDUCTOR,WrapperMasterConductor.class.getName())));
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,Constants.VAR_SEL_WORKER_CONDUCTOR,Environment.getProperty(Environment.VAR_SEL_MASTER_CONDUCTOR,WrapperWorkerConductor.class.getName())));
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,NNConstants.MAPRED_JOB_QUEUE_NAME,Environment.getProperty(Environment.HADOOP_JOB_QUEUE,Constants.DEFAULT_JOB_QUEUE)));
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,GuaguaConstants.GUAGUA_MASTER_INTERCEPTERS,VarSelOutput.class.getName()));
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,NNConstants.SHIFU_NN_MODEL_CONFIG,ShifuFileUtils.getFileSystemBySourceType(sourceType).makeQualified(new Path(super.getPathFinder().getModelConfigPath(sourceType)))));
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,NNConstants.SHIFU_NN_COLUMN_CONFIG,ShifuFileUtils.getFileSystemBySourceType(sourceType).makeQualified(new Path(super.getPathFinder().getColumnConfigPath(sourceType)))));
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,NNConstants.NN_MODELSET_SOURCE_TYPE,sourceType));
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,GuaguaConstants.GUAGUA_COMPUTATION_TIME_THRESHOLD,60 * 1000l));
  setHeapSizeAndSplitSize(args);
  for (  Map.Entry<Object,Object> entry : Environment.getProperties().entrySet()) {
    if (entry.getKey().toString().startsWith(""String_Node_Str"") || entry.getKey().toString().startsWith(""String_Node_Str"") || entry.getKey().toString().startsWith(""String_Node_Str"")) {
      args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,entry.getKey().toString(),entry.getValue().toString()));
    }
  }
}",0.9889227805426232
32215,"/** 
 * @param alg
 * @param modelSetPath
 * @param description
 * @return
 * @throws IOException
 */
public static ModelConfig createInitModelConfig(String modelName,ALGORITHM alg,String description) throws IOException {
  ModelConfig modelConfig=new ModelConfig();
  DateFormat df=new SimpleDateFormat(""String_Node_Str"");
  ModelBasicConf basic=new ModelBasicConf();
  basic.setName(modelName);
  basic.setAuthor(Environment.getProperty(Environment.SYSTEM_USER));
  basic.setDescription(""String_Node_Str"" + df.format(new Date()));
  modelConfig.setBasic(basic);
  ModelSourceDataConf dataSet=new ModelSourceDataConf();
  dataSet.setSource(SourceType.LOCAL);
  dataSet.setDataDelimiter(""String_Node_Str"");
  dataSet.setDataPath(new File(Environment.getProperty(Environment.SHIFU_HOME),File.separator + ""String_Node_Str"" + File.separator+ ""String_Node_Str""+ File.separator+ ""String_Node_Str""+ File.separator+ ""String_Node_Str"").toString());
  dataSet.setHeaderPath(new File(Environment.getProperty(Environment.SHIFU_HOME),File.separator + ""String_Node_Str"" + File.separator+ ""String_Node_Str""+ File.separator+ ""String_Node_Str""+ File.separator+ ""String_Node_Str""+ File.separator+ ""String_Node_Str"").toString());
  dataSet.setTargetColumnName(""String_Node_Str"");
  List<String> posTags=new ArrayList<String>();
  posTags.add(""String_Node_Str"");
  List<String> negTags=new ArrayList<String>();
  negTags.add(""String_Node_Str"");
  dataSet.setPosTags(posTags);
  dataSet.setNegTags(negTags);
  ShifuFileUtils.createFileIfNotExists(new Path(modelName,Constants.DEFAULT_META_COLUMN_FILE).toString(),SourceType.LOCAL);
  dataSet.setMetaColumnNameFile(Constants.DEFAULT_META_COLUMN_FILE);
  ShifuFileUtils.createFileIfNotExists(new Path(modelName,Constants.DEFAULT_CATEGORICAL_COLUMN_FILE).toString(),SourceType.LOCAL);
  dataSet.setCategoricalColumnNameFile(Constants.DEFAULT_CATEGORICAL_COLUMN_FILE);
  modelConfig.setDataSet(dataSet);
  modelConfig.setStats(new ModelStatsConf());
  ModelVarSelectConf varselect=new ModelVarSelectConf();
  ShifuFileUtils.createFileIfNotExists(new Path(modelName,Constants.DEFAULT_FORCESELECT_COLUMN_FILE).toString(),SourceType.LOCAL);
  varselect.setForceSelectColumnNameFile(Constants.DEFAULT_FORCESELECT_COLUMN_FILE);
  ShifuFileUtils.createFileIfNotExists(new Path(modelName,Constants.DEFAULT_FORCEREMOVE_COLUMN_FILE).toString(),SourceType.LOCAL);
  varselect.setForceRemoveColumnNameFile(Constants.DEFAULT_FORCEREMOVE_COLUMN_FILE);
  modelConfig.setVarSelect(varselect);
  modelConfig.setNormalize(new ModelNormalizeConf());
  ModelTrainConf trainConf=new ModelTrainConf();
  trainConf.setAlgorithm(alg.name());
  trainConf.setNumTrainEpochs(100);
  trainConf.setParams(ModelTrainConf.createParamsByAlg(alg));
  modelConfig.setTrain(trainConf);
  EvalConfig evalConfig=new EvalConfig();
  evalConfig.setName(""String_Node_Str"");
  RawSourceData evalSet=modelConfig.getDataSet().cloneRawSourceData();
  evalSet.setSource(SourceType.LOCAL);
  evalSet.setDataDelimiter(""String_Node_Str"");
  evalSet.setDataPath(new File(Environment.getProperty(Environment.SHIFU_HOME),File.separator + ""String_Node_Str"" + File.separator+ ""String_Node_Str""+ File.separator+ ""String_Node_Str""+ File.separator+ ""String_Node_Str"").toString());
  evalSet.setHeaderPath(new File(Environment.getProperty(Environment.SHIFU_HOME),File.separator + ""String_Node_Str"" + File.separator+ ""String_Node_Str""+ File.separator+ ""String_Node_Str""+ File.separator+ ""String_Node_Str""+ File.separator+ ""String_Node_Str"").toString());
  evalConfig.setDataSet(evalSet);
  ShifuFileUtils.createFileIfNotExists(new Path(modelName,evalConfig.getName() + Constants.DEFAULT_EVALSCORE_META_COLUMN_FILE).toString(),SourceType.LOCAL);
  evalConfig.setScoreMetaColumnNameFile(evalConfig.getName() + Constants.DEFAULT_EVALSCORE_META_COLUMN_FILE);
  modelConfig.getEvals().add(evalConfig);
  return modelConfig;
}","/** 
 * @param alg
 * @param modelSetPath
 * @param description
 * @return
 * @throws IOException
 */
public static ModelConfig createInitModelConfig(String modelName,ALGORITHM alg,String description) throws IOException {
  ModelConfig modelConfig=new ModelConfig();
  DateFormat df=new SimpleDateFormat(""String_Node_Str"");
  ModelBasicConf basic=new ModelBasicConf();
  basic.setName(modelName);
  basic.setAuthor(Environment.getProperty(Environment.SYSTEM_USER));
  basic.setDescription(""String_Node_Str"" + df.format(new Date()));
  modelConfig.setBasic(basic);
  ModelSourceDataConf dataSet=new ModelSourceDataConf();
  dataSet.setSource(SourceType.LOCAL);
  dataSet.setDataDelimiter(""String_Node_Str"");
  dataSet.setDataPath(new File(Environment.getProperty(Environment.SHIFU_HOME),File.separator + ""String_Node_Str"" + File.separator+ ""String_Node_Str""+ File.separator+ ""String_Node_Str""+ File.separator+ ""String_Node_Str"").toString());
  dataSet.setHeaderPath(new File(Environment.getProperty(Environment.SHIFU_HOME),File.separator + ""String_Node_Str"" + File.separator+ ""String_Node_Str""+ File.separator+ ""String_Node_Str""+ File.separator+ ""String_Node_Str""+ File.separator+ ""String_Node_Str"").toString());
  dataSet.setTargetColumnName(""String_Node_Str"");
  List<String> posTags=new ArrayList<String>();
  posTags.add(""String_Node_Str"");
  List<String> negTags=new ArrayList<String>();
  negTags.add(""String_Node_Str"");
  dataSet.setPosTags(posTags);
  dataSet.setNegTags(negTags);
  ShifuFileUtils.createFileIfNotExists(new Path(modelName,Constants.DEFAULT_META_COLUMN_FILE).toString(),SourceType.LOCAL);
  dataSet.setMetaColumnNameFile(Constants.DEFAULT_META_COLUMN_FILE);
  ShifuFileUtils.createFileIfNotExists(new Path(modelName,Constants.DEFAULT_CATEGORICAL_COLUMN_FILE).toString(),SourceType.LOCAL);
  dataSet.setCategoricalColumnNameFile(Constants.DEFAULT_CATEGORICAL_COLUMN_FILE);
  modelConfig.setDataSet(dataSet);
  modelConfig.setStats(new ModelStatsConf());
  modelConfig.setBinningAlgorithm(BinningAlgorithm.SPDT);
  ModelVarSelectConf varselect=new ModelVarSelectConf();
  ShifuFileUtils.createFileIfNotExists(new Path(modelName,Constants.DEFAULT_FORCESELECT_COLUMN_FILE).toString(),SourceType.LOCAL);
  varselect.setForceSelectColumnNameFile(Constants.DEFAULT_FORCESELECT_COLUMN_FILE);
  ShifuFileUtils.createFileIfNotExists(new Path(modelName,Constants.DEFAULT_FORCEREMOVE_COLUMN_FILE).toString(),SourceType.LOCAL);
  varselect.setForceRemoveColumnNameFile(Constants.DEFAULT_FORCEREMOVE_COLUMN_FILE);
  modelConfig.setVarSelect(varselect);
  modelConfig.setNormalize(new ModelNormalizeConf());
  ModelTrainConf trainConf=new ModelTrainConf();
  trainConf.setAlgorithm(alg.name());
  trainConf.setNumTrainEpochs(100);
  trainConf.setParams(ModelTrainConf.createParamsByAlg(alg));
  modelConfig.setTrain(trainConf);
  EvalConfig evalConfig=new EvalConfig();
  evalConfig.setName(""String_Node_Str"");
  RawSourceData evalSet=modelConfig.getDataSet().cloneRawSourceData();
  evalSet.setSource(SourceType.LOCAL);
  evalSet.setDataDelimiter(""String_Node_Str"");
  evalSet.setDataPath(new File(Environment.getProperty(Environment.SHIFU_HOME),File.separator + ""String_Node_Str"" + File.separator+ ""String_Node_Str""+ File.separator+ ""String_Node_Str""+ File.separator+ ""String_Node_Str"").toString());
  evalSet.setHeaderPath(new File(Environment.getProperty(Environment.SHIFU_HOME),File.separator + ""String_Node_Str"" + File.separator+ ""String_Node_Str""+ File.separator+ ""String_Node_Str""+ File.separator+ ""String_Node_Str""+ File.separator+ ""String_Node_Str"").toString());
  evalConfig.setDataSet(evalSet);
  ShifuFileUtils.createFileIfNotExists(new Path(modelName,evalConfig.getName() + Constants.DEFAULT_EVALSCORE_META_COLUMN_FILE).toString(),SourceType.LOCAL);
  evalConfig.setScoreMetaColumnNameFile(evalConfig.getName() + Constants.DEFAULT_EVALSCORE_META_COLUMN_FILE);
  modelConfig.getEvals().add(evalConfig);
  return modelConfig;
}",0.9925982644206228
32216,"public void addData(double data,int frequency){
  if (frequency <= 0) {
    log.warn(""String_Node_Str"" + frequency);
    return;
  }
  if (Double.isInfinite(data) || Double.isNaN(data) || Math.abs(data) > threshold) {
    log.warn(""String_Node_Str"" + data);
    return;
  }
  validElementCnt+=frequency;
  max=Math.max(max,data);
  min=Math.min(min,data);
  sum+=data * frequency;
  squaredSum+=data * data * frequency;
}","public void addData(double data,int frequency){
  if (frequency <= 0) {
    log.warn(""String_Node_Str"" + frequency);
    return;
  }
  if (Double.isInfinite(data) || Double.isNaN(data) || Math.abs(data) > threshold) {
    log.warn(""String_Node_Str"" + data);
    return;
  }
  validElementCnt+=frequency;
  max=Math.max(max,data);
  min=Math.min(min,data);
  sum+=data * frequency;
  squaredSum+=data * data * frequency;
  for (int i=0; i < frequency; i++) {
    estimator.add(data);
  }
}",0.9262926292629264
32217,"/** 
 * add negative infinity and positive infinity, merge same bins
 * @param bins
 * @return
 */
private List<Double> binMerge(List<Double> bins){
  List<Double> newBins=new ArrayList<Double>();
  if (bins.size() == 0) {
    bins.add(Double.NaN);
    return bins;
  }
  newBins.add(Double.NEGATIVE_INFINITY);
  Double cur=bins.get(0);
  newBins.add(cur);
  int i=1;
  while (i < bins.size()) {
    if (Math.abs(cur - bins.get(i)) > 1e-4) {
      newBins.add(bins.get(i));
    }
    cur=bins.get(i);
    i++;
  }
  newBins.add(Double.POSITIVE_INFINITY);
  return newBins;
}","/** 
 * set min/max, merge same bins
 * @param bins
 * @return
 */
private List<Double> binMerge(List<Double> bins){
  List<Double> newBins=new ArrayList<Double>();
  if (bins.size() == 0) {
    bins.add(Double.NaN);
    return bins;
  }
  Double cur=bins.get(0);
  newBins.add(cur);
  int i=1;
  while (i < bins.size()) {
    if (Math.abs(cur - bins.get(i)) > 1e-4) {
      newBins.add(bins.get(i));
    }
    cur=bins.get(i);
    i++;
  }
  if (newBins.size() == 1) {
    double val=newBins.get(0);
    newBins=Arrays.asList(new Double[]{Double.NEGATIVE_INFINITY,val});
  }
 else   if (newBins.size() == 2) {
    newBins.set(0,Double.NEGATIVE_INFINITY);
  }
 else {
    newBins.set(0,Double.NEGATIVE_INFINITY);
    newBins.remove(newBins.size() - 1);
  }
  return newBins;
}",0.1229629629629629
32218,"@Override public void addData(String val){
  String fval=StringUtils.trimToEmpty(val);
  Double dval=Double.valueOf(0.0);
  try {
    dval=Double.parseDouble(fval);
    estimator.add(dval);
  }
 catch (  NumberFormatException e) {
    super.incInvalidValCnt();
  }
}","@Override public void addData(String val){
  String fval=StringUtils.trimToEmpty(val);
  try {
    Double dval=Double.valueOf(0.0);
    dval=Double.parseDouble(fval);
    estimator.add(dval);
  }
 catch (  NumberFormatException e) {
    super.incInvalidValCnt();
  }
}",0.9662921348314608
32219,"@Override public Tuple exec(Tuple input) throws IOException {
  if (input == null || input.size() != 2) {
    return null;
  }
  Integer columnId=(Integer)input.get(0);
  DataBag databag=(DataBag)input.get(1);
  ColumnConfig columnConfig=super.columnConfigList.get(columnId);
  AbstractBinning<?> binning=null;
  if (columnConfig.isCategorical()) {
    binning=new CategoricalBinning(-1);
  }
 else {
    if (super.modelConfig.getBinningMethod().equals(BinningMethod.EqualInterval)) {
      binning=new EqualIntervalBinning(modelConfig.getStats().getMaxNumBin());
    }
 else {
      binning=new MunroPatBinning(modelConfig.getStats().getMaxNumBin());
    }
  }
  Iterator<Tuple> iterator=databag.iterator();
  while (iterator.hasNext()) {
    Tuple element=iterator.next();
    if (element == null || element.size() != 4) {
      continue;
    }
    Object value=element.get(1);
    if (value != null) {
      binning.addData(value.toString());
    }
  }
  Tuple output=TupleFactory.getInstance().newTuple(2);
  output.set(0,columnId);
  output.set(1,StringUtils.join(binning.getDataBin(),CalculateStatsUDF.CATEGORY_VAL_SEPARATOR));
  return output;
}","@Override public Tuple exec(Tuple input) throws IOException {
  if (input == null || input.size() != 2) {
    return null;
  }
  Integer columnId=(Integer)input.get(0);
  DataBag databag=(DataBag)input.get(1);
  ColumnConfig columnConfig=super.columnConfigList.get(columnId);
  AbstractBinning<?> binning=null;
  if (columnConfig.isCategorical()) {
    binning=new CategoricalBinning(-1);
  }
 else {
    if (super.modelConfig.getBinningMethod().equals(BinningMethod.EqualInterval)) {
      binning=new EqualIntervalBinning(modelConfig.getStats().getMaxNumBin());
    }
 else {
switch (this.modelConfig.getBinningAlgorithm()) {
case Native:
        log.info(""String_Node_Str"");
      binning=new NativeBinning(modelConfig.getStats().getMaxNumBin(),true);
    break;
case SPDT:
  log.info(""String_Node_Str"");
binning=new EqualPopulationBinning(modelConfig.getStats().getMaxNumBin());
break;
case MunroPat:
log.info(""String_Node_Str"");
binning=new MunroPatBinning(modelConfig.getStats().getMaxNumBin());
break;
}
}
}
Iterator<Tuple> iterator=databag.iterator();
while (iterator.hasNext()) {
Tuple element=iterator.next();
if (element == null || element.size() != 4) {
continue;
}
Object value=element.get(1);
if (value != null) {
binning.addData(value.toString());
}
}
Tuple output=TupleFactory.getInstance().newTuple(2);
output.set(0,columnId);
output.set(1,StringUtils.join(binning.getDataBin(),CalculateStatsUDF.CATEGORY_VAL_SEPARATOR));
return output;
}",0.8116609129267357
32220,"/** 
 * Return the real bin number for one value. As the first bin value is NEGATIVE_INFINITY, invalid index is 0, not -1.
 * @param binBoundary bin boundary list which should be sorted.
 * @throws IllegalArgumentException if binBoundary is null or empty.
 */
private static int getNumericBinNum(List<Double> binBoundary,double value){
  if (CollectionUtils.isEmpty(binBoundary)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int n=binBoundary.size() - 1;
  while (n > 0 && value <= binBoundary.get(n)) {
    n--;
  }
  return n;
}","/** 
 * Return the real bin number for one value. As the first bin value is NEGATIVE_INFINITY, invalid index is 0, not -1.
 * @param binBoundary bin boundary list which should be sorted.
 * @throws IllegalArgumentException if binBoundary is null or empty.
 */
private static int getNumericBinNum(List<Double> binBoundary,double value){
  if (CollectionUtils.isEmpty(binBoundary)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int n=binBoundary.size() - 1;
  while (n > 0 && value < binBoundary.get(n)) {
    n--;
  }
  return n;
}",0.99909338168631
32221,"public WrapperWorkerConductor(ModelConfig modelConfig,List<ColumnConfig> columnConfigList){
  super(modelConfig,columnConfigList);
  this.candidates=new ArrayList<ColumnConfig>();
  for (  ColumnConfig columnConfig : columnConfigList) {
    if (columnConfig.isCandidate() && !columnConfig.isForceSelect()) {
      candidates.add(columnConfig);
    }
  }
}","public WrapperWorkerConductor(ModelConfig modelConfig,List<ColumnConfig> columnConfigList){
  super(modelConfig,columnConfigList);
  this.candidates=new ArrayList<ColumnConfig>();
  for (  ColumnConfig columnConfig : columnConfigList) {
    if (columnConfig.isCandidate() && !columnConfig.isForceSelect()) {
      candidates.add(columnConfig);
    }
  }
  LOG.info(""String_Node_Str"",candidates.size());
}",0.9354413702239788
32222,"private void prepareVarSelParams(final List<String> args,final SourceType sourceType){
  args.add(""String_Node_Str"");
  addRuntimeJars(args);
  args.add(""String_Node_Str"");
  args.add(ShifuFileUtils.getFileSystemBySourceType(sourceType).makeQualified(new Path(modelConfig.getDataSetRawPath())).toString());
  String zkServers=Environment.getProperty(Environment.ZOO_KEEPER_SERVERS);
  if (StringUtils.isEmpty(zkServers)) {
    log.warn(""String_Node_Str"");
  }
 else {
    args.add(""String_Node_Str"");
    args.add(zkServers);
  }
  args.add(""String_Node_Str"");
  args.add(VarSelWorker.class.getName());
  args.add(""String_Node_Str"");
  args.add(VarSelMaster.class.getName());
  args.add(""String_Node_Str"");
  int numTrainEpochs=super.getModelConfig().getTrain().getNumTrainEpochs() + 1;
  args.add(String.valueOf(numTrainEpochs));
  args.add(""String_Node_Str"");
  args.add(VarSelMasterResult.class.getName());
  args.add(""String_Node_Str"");
  args.add(VarSelWorkerResult.class.getName());
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,Constants.VAR_SEL_MASTER_CONDUCTOR,Environment.getProperty(Environment.VAR_SEL_MASTER_CONDUCTOR,WrapperMasterConductor.class.getName())));
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,Constants.VAR_SEL_WORKER_CONDUCTOR,Environment.getProperty(Environment.VAR_SEL_MASTER_CONDUCTOR,WrapperWorkerConductor.class.getName())));
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,NNConstants.MAPRED_JOB_QUEUE_NAME,Environment.getProperty(Environment.HADOOP_JOB_QUEUE,Constants.DEFAULT_JOB_QUEUE)));
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,GuaguaConstants.GUAGUA_MASTER_INTERCEPTERS,VarSelOutput.class.getName()));
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,NNConstants.SHIFU_NN_MODEL_CONFIG,ShifuFileUtils.getFileSystemBySourceType(sourceType).makeQualified(new Path(super.getPathFinder().getModelConfigPath(sourceType)))));
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,NNConstants.SHIFU_NN_COLUMN_CONFIG,ShifuFileUtils.getFileSystemBySourceType(sourceType).makeQualified(new Path(super.getPathFinder().getColumnConfigPath(sourceType)))));
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,NNConstants.NN_MODELSET_SOURCE_TYPE,sourceType));
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,GuaguaConstants.GUAGUA_COMPUTATION_TIME_THRESHOLD,60 * 1000l));
  setHeapSizeAndSplitSize(args);
  for (  Map.Entry<Object,Object> entry : Environment.getProperties().entrySet()) {
    if (entry.getKey().toString().startsWith(""String_Node_Str"") || entry.getKey().toString().startsWith(""String_Node_Str"") || entry.getKey().toString().startsWith(""String_Node_Str"")) {
      args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,entry.getKey().toString(),entry.getValue().toString()));
    }
  }
}","private void prepareVarSelParams(final List<String> args,final SourceType sourceType){
  args.add(""String_Node_Str"");
  addRuntimeJars(args);
  args.add(""String_Node_Str"");
  args.add(ShifuFileUtils.getFileSystemBySourceType(sourceType).makeQualified(new Path(modelConfig.getDataSetRawPath())).toString());
  String zkServers=Environment.getProperty(Environment.ZOO_KEEPER_SERVERS);
  if (StringUtils.isEmpty(zkServers)) {
    log.warn(""String_Node_Str"");
  }
 else {
    args.add(""String_Node_Str"");
    args.add(zkServers);
  }
  args.add(""String_Node_Str"");
  args.add(VarSelWorker.class.getName());
  args.add(""String_Node_Str"");
  args.add(VarSelMaster.class.getName());
  args.add(""String_Node_Str"");
  int expectVarCount=this.modelConfig.getVarSelectFilterNum();
  int forceSelectCount=0;
  int candidateCount=0;
  for (  ColumnConfig columnConfig : columnConfigList) {
    if (columnConfig.isForceSelect()) {
      forceSelectCount++;
    }
    if (columnConfig.isCandidate()) {
      candidateCount++;
    }
  }
  args.add(String.valueOf(Math.min(expectVarCount,candidateCount) - forceSelectCount));
  args.add(""String_Node_Str"");
  args.add(VarSelMasterResult.class.getName());
  args.add(""String_Node_Str"");
  args.add(VarSelWorkerResult.class.getName());
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,Constants.VAR_SEL_MASTER_CONDUCTOR,Environment.getProperty(Environment.VAR_SEL_MASTER_CONDUCTOR,WrapperMasterConductor.class.getName())));
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,Constants.VAR_SEL_WORKER_CONDUCTOR,Environment.getProperty(Environment.VAR_SEL_MASTER_CONDUCTOR,WrapperWorkerConductor.class.getName())));
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,NNConstants.MAPRED_JOB_QUEUE_NAME,Environment.getProperty(Environment.HADOOP_JOB_QUEUE,Constants.DEFAULT_JOB_QUEUE)));
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,GuaguaConstants.GUAGUA_MASTER_INTERCEPTERS,VarSelOutput.class.getName()));
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,NNConstants.SHIFU_NN_MODEL_CONFIG,ShifuFileUtils.getFileSystemBySourceType(sourceType).makeQualified(new Path(super.getPathFinder().getModelConfigPath(sourceType)))));
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,NNConstants.SHIFU_NN_COLUMN_CONFIG,ShifuFileUtils.getFileSystemBySourceType(sourceType).makeQualified(new Path(super.getPathFinder().getColumnConfigPath(sourceType)))));
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,NNConstants.NN_MODELSET_SOURCE_TYPE,sourceType));
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,GuaguaConstants.GUAGUA_COMPUTATION_TIME_THRESHOLD,60 * 1000l));
  setHeapSizeAndSplitSize(args);
  for (  Map.Entry<Object,Object> entry : Environment.getProperties().entrySet()) {
    if (entry.getKey().toString().startsWith(""String_Node_Str"") || entry.getKey().toString().startsWith(""String_Node_Str"") || entry.getKey().toString().startsWith(""String_Node_Str"")) {
      args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,entry.getKey().toString(),entry.getValue().toString()));
    }
  }
}",0.916385704652731
32223,"private void votedVariablesSelection() throws ClassNotFoundException, IOException, InterruptedException {
  log.info(""String_Node_Str"");
  SourceType sourceType=super.getModelConfig().getDataSet().getSource();
  final List<String> args=new ArrayList<String>();
  prepareVarSelParams(args,sourceType);
  Path columnIdsPath=getVotedSelectionPath(sourceType);
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,Constants.VAR_SEL_COLUMN_IDS_OUPUT,columnIdsPath.toString()));
  System.out.println(args);
  long start=System.currentTimeMillis();
  GuaguaMapReduceClient guaguaClient=new GuaguaMapReduceClient();
  guaguaClient.creatJob(args.toArray(new String[0])).waitForCompletion(true);
  log.info(""String_Node_Str"",System.currentTimeMillis() - start);
  persistColumnIds(columnIdsPath);
}","private void votedVariablesSelection() throws ClassNotFoundException, IOException, InterruptedException {
  log.info(""String_Node_Str"");
  SourceType sourceType=super.getModelConfig().getDataSet().getSource();
  final List<String> args=new ArrayList<String>();
  prepareVarSelParams(args,sourceType);
  Path columnIdsPath=getVotedSelectionPath(sourceType);
  args.add(String.format(NNConstants.MAPREDUCE_PARAM_FORMAT,Constants.VAR_SEL_COLUMN_IDS_OUPUT,columnIdsPath.toString()));
  long start=System.currentTimeMillis();
  GuaguaMapReduceClient guaguaClient=new GuaguaMapReduceClient();
  guaguaClient.creatJob(args.toArray(new String[0])).waitForCompletion(true);
  log.info(""String_Node_Str"",System.currentTimeMillis() - start);
  persistColumnIds(columnIdsPath);
  super.syncDataToHdfs(sourceType);
}",0.9599499374217773
32224,"/** 
 * check algorithm parameter
 * @throws Exception </p>modelConfig is not loaded or</p> save ModelConfig.json file error </p>
 */
public void checkAlgorithmParam() throws Exception {
  String alg=modelConfig.getAlgorithm();
  Map<String,Object> param=modelConfig.getParams();
  log.info(""String_Node_Str"");
  if (alg.equalsIgnoreCase(""String_Node_Str"")) {
    if (!param.containsKey(""String_Node_Str"")) {
      param=new LinkedHashMap<String,Object>();
      param.put(""String_Node_Str"",0.1);
      modelConfig.setParams(param);
      saveModelConfig();
    }
  }
 else   if (alg.equalsIgnoreCase(""String_Node_Str"")) {
    if (!param.containsKey(""String_Node_Str"")) {
      param=new LinkedHashMap<String,Object>();
      param.put(""String_Node_Str"",""String_Node_Str"");
      param.put(""String_Node_Str"",0.1);
      param.put(""String_Node_Str"",2);
      List<Integer> nodes=new ArrayList<Integer>();
      nodes.add(20);
      nodes.add(10);
      param.put(""String_Node_Str"",nodes);
      List<String> func=new ArrayList<String>();
      func.add(""String_Node_Str"");
      func.add(""String_Node_Str"");
      param.put(""String_Node_Str"",func);
      modelConfig.setParams(param);
      saveModelConfig();
    }
  }
 else   if (alg.equalsIgnoreCase(""String_Node_Str"")) {
    if (!param.containsKey(""String_Node_Str"")) {
      param=new LinkedHashMap<String,Object>();
      param.put(""String_Node_Str"",""String_Node_Str"");
      param.put(""String_Node_Str"",1.);
      param.put(""String_Node_Str"",1.);
      modelConfig.setParams(param);
      saveModelConfig();
    }
  }
 else   if (alg.equalsIgnoreCase(""String_Node_Str"")) {
  }
 else {
    throw new ShifuException(ShifuErrorCode.ERROR_UNSUPPORT_ALG);
  }
  log.info(""String_Node_Str"");
}","/** 
 * check algorithm parameter
 * @throws Exception </p>modelConfig is not loaded or</p> save ModelConfig.json file error </p>
 */
public void checkAlgorithmParam() throws Exception {
  String alg=modelConfig.getAlgorithm();
  Map<String,Object> param=modelConfig.getParams();
  log.info(""String_Node_Str"");
  if (alg.equalsIgnoreCase(""String_Node_Str"")) {
    if (!param.containsKey(""String_Node_Str"")) {
      param=new LinkedHashMap<String,Object>();
      param.put(""String_Node_Str"",0.1);
      modelConfig.setParams(param);
      saveModelConfig();
    }
  }
 else   if (alg.equalsIgnoreCase(""String_Node_Str"")) {
    if (!param.containsKey(""String_Node_Str"")) {
      param=new LinkedHashMap<String,Object>();
      param.put(""String_Node_Str"",""String_Node_Str"");
      param.put(""String_Node_Str"",0.1);
      param.put(""String_Node_Str"",2);
      List<Integer> nodes=new ArrayList<Integer>();
      nodes.add(20);
      nodes.add(10);
      param.put(""String_Node_Str"",nodes);
      List<String> func=new ArrayList<String>();
      func.add(""String_Node_Str"");
      func.add(""String_Node_Str"");
      param.put(""String_Node_Str"",func);
      modelConfig.setParams(param);
      saveModelConfig();
    }
  }
 else   if (alg.equalsIgnoreCase(""String_Node_Str"")) {
    if (!param.containsKey(""String_Node_Str"")) {
      param=new LinkedHashMap<String,Object>();
      param.put(""String_Node_Str"",""String_Node_Str"");
      param.put(""String_Node_Str"",1.);
      param.put(""String_Node_Str"",1.);
      modelConfig.setParams(param);
      saveModelConfig();
    }
  }
 else   if (alg.equalsIgnoreCase(""String_Node_Str"")) {
  }
 else {
    throw new ShifuException(ShifuErrorCode.ERROR_UNSUPPORT_ALG);
  }
}",0.991027496382055
32225,"/** 
 * Insert one @HistogramUnit node into the histogram. Meanwhile it will try to keep the histogram as most @maxHistogramUnitCnt So when inserting one node in, the method will try to find the place to insert as well as minimum interval
 * @param node
 */
private void insertWithTrim(LinkNode<HistogramUnit> node){
  LinkNode<HistogramUnit> insertOpsUnit=null;
  LinkNode<HistogramUnit> minIntervalOpsUnit=null;
  Double minInterval=Double.MAX_VALUE;
  LinkNode<HistogramUnit> tmp=this.tail;
  while (tmp != null) {
    if (insertOpsUnit == null) {
      int res=Double.compare(tmp.data().getHval(),node.data().getHval());
      if (res > 0) {
      }
 else       if (res == 0) {
        tmp.data().setHcnt(tmp.data().getHcnt() + node.data().getHcnt());
        return;
      }
 else       if (res < 0) {
        insertOpsUnit=tmp;
        double interval=node.data().getHval() - tmp.data().getHval();
        if (interval < minInterval) {
          minInterval=interval;
          minIntervalOpsUnit=tmp;
        }
        if (tmp.next() != null) {
          interval=tmp.next().data().getHval() - node.data().getHval();
          if (interval < minInterval) {
            minInterval=interval;
            minIntervalOpsUnit=node;
          }
        }
      }
    }
    if (tmp.next() != null) {
      LinkNode<HistogramUnit> next=tmp.next();
      double interval=next.data().getHval() - tmp.data().getHval();
      if (interval < minInterval) {
        minInterval=interval;
        minIntervalOpsUnit=tmp;
      }
    }
    tmp=tmp.prev();
  }
  if (insertOpsUnit == null) {
    this.header.setPrev(node);
    node.setNext(this.header);
    this.header=node;
  }
 else   if (insertOpsUnit == this.tail) {
    node.setPrev(insertOpsUnit);
    insertOpsUnit.setNext(node);
    this.tail=node;
  }
 else {
    node.setNext(insertOpsUnit.next());
    node.setPrev(insertOpsUnit);
    insertOpsUnit.next().setPrev(node);
    insertOpsUnit.setNext(node);
  }
  if (this.currentHistogramUnitCnt == this.maxHistogramUnitCnt) {
    LinkNode<HistogramUnit> nextNode=minIntervalOpsUnit.next();
    HistogramUnit chu=minIntervalOpsUnit.data();
    HistogramUnit nhu=nextNode.data();
    nhu.setHval((chu.getHval() * chu.getHcnt() + nhu.getHval() * nhu.getHcnt()) / (chu.getHcnt() + nhu.getHcnt()));
    nhu.setHcnt(chu.getHcnt() + nhu.getHcnt());
    removeCurrentNode(minIntervalOpsUnit,nextNode);
  }
 else {
    this.currentHistogramUnitCnt++;
  }
}","/** 
 * Insert one @HistogramUnit node into the histogram. Meanwhile it will try to keep the histogram as most @maxHistogramUnitCnt So when inserting one node in, the method will try to find the place to insert as well as minimum interval
 * @param node
 */
private void insertWithTrim(LinkNode<HistogramUnit> node){
  LinkNode<HistogramUnit> insertOpsUnit=null;
  LinkNode<HistogramUnit> minIntervalOpsUnit=null;
  Double minInterval=Double.MAX_VALUE;
  LinkNode<HistogramUnit> tmp=this.tail;
  while (tmp != null) {
    if (insertOpsUnit == null) {
      int res=Double.compare(tmp.data().getHval(),node.data().getHval());
      if (res > 0) {
      }
 else       if (res == 0) {
        tmp.data().setHcnt(tmp.data().getHcnt() + node.data().getHcnt());
        return;
      }
 else       if (res < 0) {
        insertOpsUnit=tmp;
        double interval=node.data().getHval() - tmp.data().getHval();
        if (interval < minInterval) {
          minInterval=interval;
          minIntervalOpsUnit=tmp;
        }
        if (tmp.next() != null) {
          interval=tmp.next().data().getHval() - node.data().getHval();
          if (interval < minInterval) {
            minInterval=interval;
            minIntervalOpsUnit=node;
          }
        }
      }
    }
    if (tmp.next() != null) {
      LinkNode<HistogramUnit> next=tmp.next();
      double interval=next.data().getHval() - tmp.data().getHval();
      if (interval < minInterval) {
        minInterval=interval;
        minIntervalOpsUnit=tmp;
      }
    }
    tmp=tmp.prev();
  }
  if (insertOpsUnit == null) {
    if (this.header != null) {
      this.header.setPrev(node);
    }
    node.setNext(this.header);
    this.header=node;
    if (this.tail == null) {
      this.tail=node;
    }
  }
 else   if (insertOpsUnit == this.tail) {
    node.setPrev(insertOpsUnit);
    insertOpsUnit.setNext(node);
    this.tail=node;
  }
 else {
    node.setNext(insertOpsUnit.next());
    node.setPrev(insertOpsUnit);
    insertOpsUnit.next().setPrev(node);
    insertOpsUnit.setNext(node);
  }
  if (this.currentHistogramUnitCnt == this.maxHistogramUnitCnt) {
    LinkNode<HistogramUnit> nextNode=minIntervalOpsUnit.next();
    HistogramUnit chu=minIntervalOpsUnit.data();
    HistogramUnit nhu=nextNode.data();
    nhu.setHval((chu.getHval() * chu.getHcnt() + nhu.getHval() * nhu.getHcnt()) / (chu.getHcnt() + nhu.getHcnt()));
    nhu.setHcnt(chu.getHcnt() + nhu.getHcnt());
    removeCurrentNode(minIntervalOpsUnit,nextNode);
  }
 else {
    this.currentHistogramUnitCnt++;
  }
}",0.9807692307692308
32226,"public void addData(double data){
  if (Double.isInfinite(data) || Double.isNaN(data) || Math.abs(data) > threshold) {
    log.warn(""String_Node_Str"" + data);
    return;
  }
  validElementCnt++;
  max=Math.max(max,data);
  min=Math.min(min,data);
  sum+=data;
  squaredSum+=data * data;
}","public void addData(double data,int frequency){
  if (frequency <= 0) {
    log.warn(""String_Node_Str"" + frequency);
    return;
  }
  if (Double.isInfinite(data) || Double.isNaN(data) || Math.abs(data) > threshold) {
    log.warn(""String_Node_Str"" + data);
    return;
  }
  validElementCnt+=frequency;
  max=Math.max(max,data);
  min=Math.min(min,data);
  sum+=data * frequency;
  squaredSum+=data * data * frequency;
}",0.5887323943661972
32227,"/** 
 * @param dval
 */
private void process(double dval){
  HistogramUnit hu=getHistogramUnitIndex(dval);
  if (hu != null) {
    hu.setHcnt(hu.getHcnt() + 1);
  }
 else {
    hu=new HistogramUnit(dval,1);
    histogram.add(hu);
    Collections.sort(histogram);
    if (histogram.size() > this.maxHistogramUnitCnt) {
      mergeHistogram();
    }
  }
}","/** 
 * @param dval
 */
private void process(double dval,int frequency){
  HistogramUnit hu=getHistogramUnitIndex(dval);
  if (hu != null) {
    hu.setHcnt(hu.getHcnt() + frequency);
  }
 else {
    hu=new HistogramUnit(dval,frequency);
    histogram.add(hu);
    Collections.sort(histogram);
    if (histogram.size() > this.maxHistogramUnitCnt) {
      mergeHistogram();
    }
  }
}",0.9538043478260868
32228,"/** 
 * @param s
 * @return
 */
private int locateHistogram(double s){
  for (int i=0; i < histogram.size() - 1; i++) {
    HistogramUnit chu=histogram.get(i);
    HistogramUnit nhu=histogram.get(i + 1);
    double sc=sum(chu.getHval());
    double sn=sum(nhu.getHval());
    if (sc < s && s <= sn) {
      return i;
    }
  }
  return -1;
}","/** 
 * @param s
 * @return
 */
private int locateHistogram(double s,int startPos){
  for (int i=startPos; i < histogram.size() - 1; i++) {
    HistogramUnit chu=histogram.get(i);
    HistogramUnit nhu=histogram.get(i + 1);
    double sc=sum(chu.getHval());
    double sn=sum(nhu.getHval());
    if (sc < s && s <= sn) {
      return i;
    }
  }
  return -1;
}",0.9686609686609686
32229,"public void addData(double val){
  process(val);
}","public void addData(double val,int frequency){
  process(val,frequency);
}",0.8064516129032258
32230,"private List<Double> getDataBin(int toBinningNum){
  int totalCnt=0;
  for (  HistogramUnit hu : this.histogram) {
    totalCnt+=hu.getHcnt();
  }
  List<Double> binBorders=new ArrayList<Double>();
  binBorders.add(Double.NEGATIVE_INFINITY);
  for (int j=1; j < toBinningNum; j++) {
    double s=(double)(j * totalCnt) / toBinningNum;
    int pos=locateHistogram(s);
    if (pos < 0) {
      break;
    }
    HistogramUnit chu=histogram.get(pos);
    HistogramUnit nhu=histogram.get(pos + 1);
    double d=s - sum(histogram.get(pos).getHval());
    double a=nhu.getHcnt() - chu.getHcnt();
    double b=2 * chu.getHcnt();
    double c=-2 * d;
    double z=0.0;
    if (Double.compare(a,0) == 0) {
      z=-1 * c / b;
    }
 else {
      z=(-1 * b + Math.sqrt(b * b - 4 * a * c)) / (2 * a);
    }
    double u=chu.getHval() + (nhu.getHval() - chu.getHval()) * z;
    binBorders.add(u);
  }
  return binBorders;
}","private List<Double> getDataBin(int toBinningNum){
  List<Double> binBorders=new ArrayList<Double>();
  binBorders.add(Double.NEGATIVE_INFINITY);
  if (histogram.size() <= toBinningNum) {
    for (int i=0; i < histogram.size() - 1; i++) {
      HistogramUnit chu=histogram.get(i);
      HistogramUnit nhu=histogram.get(i + 1);
      binBorders.add((chu.getHval() + nhu.getHval()) / 2);
    }
    return binBorders;
  }
  int totalCnt=0;
  for (  HistogramUnit hu : this.histogram) {
    totalCnt+=hu.getHcnt();
  }
  int currentPos=0;
  for (int j=1; j < toBinningNum; j++) {
    double s=(double)(j * totalCnt) / toBinningNum;
    int pos=locateHistogram(s,currentPos);
    if (pos < 0 || pos == currentPos) {
      continue;
    }
 else {
      HistogramUnit chu=histogram.get(pos);
      HistogramUnit nhu=histogram.get(pos + 1);
      double d=s - sum(histogram.get(pos).getHval());
      double a=nhu.getHcnt() - chu.getHcnt();
      double b=2 * chu.getHcnt();
      double c=-2 * d;
      double z=0.0;
      if (Double.compare(a,0) == 0) {
        z=-1 * c / b;
      }
 else {
        z=(-1 * b + Math.sqrt(b * b - 4 * a * c)) / (2 * a);
      }
      double u=chu.getHval() + (nhu.getHval() - chu.getHval()) * z;
      binBorders.add(u);
      currentPos=pos;
    }
  }
  return binBorders;
}",0.7314647377938517
32231,"@Override public void runVarStats(String binningInfo,DataBag databag) throws ExecException {
  String[] binningDataArr=StringUtils.split(binningInfo,CalculateStatsUDF.CATEGORY_VAL_SEPARATOR);
  log.info(""String_Node_Str"" + this.columnConfig.getColumnName() + ""String_Node_Str""+ binningDataArr.length);
  columnConfig.setBinCategory(Arrays.asList(binningDataArr));
  statsCategoricalColumnInfo(databag,columnConfig);
}","@Override public void runVarStats(String binningInfo,DataBag databag) throws ExecException {
  String[] binningDataArr=StringUtils.split(binningInfo,CalculateStatsUDF.CATEGORY_VAL_SEPARATOR);
  log.info(""String_Node_Str"" + this.columnConfig.getColumnName() + ""String_Node_Str""+ binningDataArr.length);
  columnConfig.setBinCategory(Arrays.asList(binningDataArr));
  categoricalBinMap=new HashMap<String,Integer>(columnConfig.getBinCategory().size());
  for (int i=0; i < columnConfig.getBinCategory().size(); i++) {
    categoricalBinMap.put(columnConfig.getBinCategory().get(i),Integer.valueOf(i));
  }
  statsCategoricalColumnInfo(databag,columnConfig);
}",0.7355679702048417
32232,"/** 
 * @param databag
 * @param columnConfig
 * @throws ExecException 
 */
private void statsCategoricalColumnInfo(DataBag databag,ColumnConfig columnConfig) throws ExecException {
  Integer[] binCountPos=new Integer[columnConfig.getBinCategory().size()];
  Integer[] binCountNeg=new Integer[columnConfig.getBinCategory().size()];
  Double[] binWeightCountPos=new Double[columnConfig.getBinCategory().size()];
  Double[] binWeightCountNeg=new Double[columnConfig.getBinCategory().size()];
  initializeZeroArr(binCountPos);
  initializeZeroArr(binCountNeg);
  initializeZeroArr(binWeightCountPos);
  initializeZeroArr(binWeightCountNeg);
  Iterator<Tuple> iterator=databag.iterator();
  while (iterator.hasNext()) {
    Tuple element=iterator.next();
    if (element.size() != 4) {
      continue;
    }
    Object value=element.get(1);
    String tag=(String)element.get(2);
    Double weight=(Double)element.get(3);
    if (value == null || StringUtils.isBlank(value.toString())) {
      missingValueCnt++;
      continue;
    }
    String str=StringUtils.trim(value.toString());
    int binNum=CommonUtils.getBinNum(columnConfig,str);
    if (modelConfig.getPosTags().contains(tag)) {
      increaseInstCnt(binCountPos,binNum);
      increaseInstCnt(binWeightCountPos,binNum,weight);
    }
 else     if (modelConfig.getNegTags().contains(tag)) {
      increaseInstCnt(binCountNeg,binNum);
      increaseInstCnt(binWeightCountNeg,binNum,weight);
    }
  }
  columnConfig.setBinCountPos(Arrays.asList(binCountPos));
  columnConfig.setBinCountNeg(Arrays.asList(binCountNeg));
  columnConfig.setBinWeightedPos(Arrays.asList(binWeightCountPos));
  columnConfig.setBinWeightedNeg(Arrays.asList(binWeightCountNeg));
  calculateBinPosRateAndAvgScore();
  for (int i=0; i < columnConfig.getBinCountPos().size(); i++) {
    int posCount=columnConfig.getBinCountPos().get(i);
    int negCount=columnConfig.getBinCountNeg().get(i);
    for (int j=0; j < posCount; j++) {
      streamStatsCalculator.addData(columnConfig.getBinPosRate().get(i));
    }
    for (int j=0; j < negCount; j++) {
      streamStatsCalculator.addData(columnConfig.getBinPosRate().get(i));
    }
  }
  columnConfig.setMax(streamStatsCalculator.getMax());
  columnConfig.setMean(streamStatsCalculator.getMean());
  columnConfig.setMin(streamStatsCalculator.getMin());
  columnConfig.setMedian(streamStatsCalculator.getMean());
  columnConfig.setStdDev(streamStatsCalculator.getStdDev());
  columnConfig.setMissingCnt(missingValueCnt + invalidValueCnt);
  columnConfig.setTotalCount(databag.size());
  columnConfig.setMissingPercentage(((double)columnConfig.getMissingCount()) / columnConfig.getTotalCount());
}","/** 
 * @param databag
 * @param columnConfig
 * @throws ExecException 
 */
private void statsCategoricalColumnInfo(DataBag databag,ColumnConfig columnConfig) throws ExecException {
  Integer[] binCountPos=new Integer[columnConfig.getBinCategory().size()];
  Integer[] binCountNeg=new Integer[columnConfig.getBinCategory().size()];
  Double[] binWeightCountPos=new Double[columnConfig.getBinCategory().size()];
  Double[] binWeightCountNeg=new Double[columnConfig.getBinCategory().size()];
  initializeZeroArr(binCountPos);
  initializeZeroArr(binCountNeg);
  initializeZeroArr(binWeightCountPos);
  initializeZeroArr(binWeightCountNeg);
  Iterator<Tuple> iterator=databag.iterator();
  while (iterator.hasNext()) {
    Tuple element=iterator.next();
    if (element.size() != 4) {
      continue;
    }
    Object value=element.get(1);
    String tag=(String)element.get(2);
    Double weight=(Double)element.get(3);
    if (value == null || StringUtils.isBlank(value.toString())) {
      missingValueCnt++;
      continue;
    }
    String str=StringUtils.trim(value.toString());
    int binNum=quickLocateCategorialBin(str);
    if (binNum < 0) {
      continue;
    }
    if (modelConfig.getPosTags().contains(tag)) {
      increaseInstCnt(binCountPos,binNum);
      increaseInstCnt(binWeightCountPos,binNum,weight);
    }
 else     if (modelConfig.getNegTags().contains(tag)) {
      increaseInstCnt(binCountNeg,binNum);
      increaseInstCnt(binWeightCountNeg,binNum,weight);
    }
  }
  columnConfig.setBinCountPos(Arrays.asList(binCountPos));
  columnConfig.setBinCountNeg(Arrays.asList(binCountNeg));
  columnConfig.setBinWeightedPos(Arrays.asList(binWeightCountPos));
  columnConfig.setBinWeightedNeg(Arrays.asList(binWeightCountNeg));
  calculateBinPosRateAndAvgScore();
  for (int i=0; i < columnConfig.getBinCountPos().size(); i++) {
    int posCount=columnConfig.getBinCountPos().get(i);
    int negCount=columnConfig.getBinCountNeg().get(i);
    binning.addData(columnConfig.getBinPosRate().get(i),posCount);
    binning.addData(columnConfig.getBinPosRate().get(i),negCount);
    streamStatsCalculator.addData(columnConfig.getBinPosRate().get(i),posCount);
    streamStatsCalculator.addData(columnConfig.getBinPosRate().get(i),negCount);
  }
  columnConfig.setMax(streamStatsCalculator.getMax());
  columnConfig.setMean(streamStatsCalculator.getMean());
  columnConfig.setMin(streamStatsCalculator.getMin());
  if (binning.getMedian() == null) {
    columnConfig.setMedian(streamStatsCalculator.getMean());
  }
 else {
    columnConfig.setMedian(binning.getMedian());
  }
  columnConfig.setStdDev(streamStatsCalculator.getStdDev());
  columnConfig.setMissingCnt(missingValueCnt + invalidValueCnt);
  columnConfig.setTotalCount(databag.size());
  columnConfig.setMissingPercentage(((double)columnConfig.getMissingCount()) / columnConfig.getTotalCount());
}",0.814935064935065
32233,"private String promptBranchName() throws MojoFailureException, CommandLineException {
  final String featureBranches=gitFindBranches(gitFlowConfig.getFeatureBranchPrefix(),false);
  if (StringUtils.isBlank(featureBranches)) {
    throw new MojoFailureException(""String_Node_Str"");
  }
  final String[] branches=featureBranches.split(""String_Node_Str"");
  List<String> numberedList=new ArrayList<String>();
  StringBuilder str=new StringBuilder(""String_Node_Str"").append(LS);
  for (int i=0; i < branches.length; i++) {
    str.append((i + 1) + ""String_Node_Str"" + branches[i]+ LS);
    numberedList.add(String.valueOf(i + 1));
  }
  str.append(""String_Node_Str"");
  String featureNumber=null;
  try {
    while (StringUtils.isBlank(featureNumber)) {
      featureNumber=prompter.prompt(str.toString(),numberedList);
    }
  }
 catch (  PrompterException e) {
    getLog().error(e);
  }
  String featureBranchName=null;
  if (featureNumber != null) {
    int num=Integer.parseInt(featureNumber);
    featureBranchName=branches[num - 1];
  }
  return featureBranchName;
}","private String promptBranchName() throws MojoFailureException, CommandLineException {
  final String featureBranches=gitFindBranches(gitFlowConfig.getFeatureBranchPrefix(),false);
  if (StringUtils.isBlank(featureBranches)) {
    throw new MojoFailureException(""String_Node_Str"");
  }
  final String[] branches=featureBranches.split(""String_Node_Str"");
  List<String> numberedList=new ArrayList<String>();
  StringBuilder str=new StringBuilder(""String_Node_Str"").append(LS);
  for (int i=0; i < branches.length; i++) {
    str.append((i + 1) + ""String_Node_Str"" + branches[i]+ LS);
    numberedList.add(String.valueOf(i + 1));
  }
  str.append(""String_Node_Str"");
  String featureNumber=null;
  try {
    while (StringUtils.isBlank(featureNumber)) {
      featureNumber=prompter.prompt(str.toString(),numberedList);
    }
  }
 catch (  PrompterException e) {
    throw new MojoFailureException(""String_Node_Str"",e);
  }
  String featureBranchName=null;
  if (featureNumber != null) {
    int num=Integer.parseInt(featureNumber);
    featureBranchName=branches[num - 1];
  }
  return featureBranchName;
}",0.9705340699815838
32234,"/** 
 * {@inheritDoc} 
 */
@Override public void execute() throws MojoExecutionException, MojoFailureException {
  validateConfiguration();
  try {
    checkUncommittedChanges();
    String featureBranchName=null;
    if (settings.isInteractiveMode()) {
      featureBranchName=promptBranchName();
    }
 else     if (StringUtils.isNotBlank(featureName)) {
      final String branch=gitFlowConfig.getFeatureBranchPrefix() + featureName;
      if (!gitCheckBranchExists(branch)) {
        throw new MojoFailureException(""String_Node_Str"" + branch + ""String_Node_Str"");
      }
      featureBranchName=branch;
    }
    if (StringUtils.isBlank(featureBranchName)) {
      throw new MojoFailureException(""String_Node_Str"");
    }
    if (fetchRemote) {
      gitFetchRemoteAndCompare(featureBranchName);
      gitFetchRemoteAndCompare(gitFlowConfig.getDevelopmentBranch());
    }
    if (!skipTestProject) {
      gitCheckout(featureBranchName);
      mvnCleanTest();
    }
    gitCheckout(gitFlowConfig.getDevelopmentBranch());
    if (featureSquash) {
      gitMergeSquash(featureBranchName);
      gitCommit(featureBranchName);
    }
 else {
      gitMergeNoff(featureBranchName);
    }
    final String currentVersion=getCurrentProjectVersion();
    final String featName=featureBranchName.replaceFirst(gitFlowConfig.getFeatureBranchPrefix(),""String_Node_Str"");
    if (currentVersion.contains(""String_Node_Str"" + featName)) {
      final String version=currentVersion.replaceFirst(""String_Node_Str"" + featName,""String_Node_Str"");
      mvnSetVersions(version);
      Map<String,String> properties=new HashMap<String,String>();
      properties.put(""String_Node_Str"",version);
      properties.put(""String_Node_Str"",featName);
      gitCommit(commitMessages.getFeatureFinishMessage(),properties);
    }
    if (installProject) {
      mvnCleanInstall();
    }
    if (!keepBranch) {
      if (featureSquash) {
        gitBranchDeleteForce(featureBranchName);
      }
 else {
        gitBranchDelete(featureBranchName);
      }
    }
    if (pushRemote) {
      gitPush(gitFlowConfig.getDevelopmentBranch(),false);
      if (!keepBranch) {
        gitPushDelete(featureBranchName);
      }
    }
  }
 catch (  CommandLineException e) {
    getLog().error(e);
  }
}","/** 
 * {@inheritDoc} 
 */
@Override public void execute() throws MojoExecutionException, MojoFailureException {
  validateConfiguration();
  try {
    checkUncommittedChanges();
    String featureBranchName=null;
    if (settings.isInteractiveMode()) {
      featureBranchName=promptBranchName();
    }
 else     if (StringUtils.isNotBlank(featureName)) {
      final String branch=gitFlowConfig.getFeatureBranchPrefix() + featureName;
      if (!gitCheckBranchExists(branch)) {
        throw new MojoFailureException(""String_Node_Str"" + branch + ""String_Node_Str"");
      }
      featureBranchName=branch;
    }
    if (StringUtils.isBlank(featureBranchName)) {
      throw new MojoFailureException(""String_Node_Str"");
    }
    if (fetchRemote) {
      gitFetchRemoteAndCompare(featureBranchName);
      gitFetchRemoteAndCompare(gitFlowConfig.getDevelopmentBranch());
    }
    if (!skipTestProject) {
      gitCheckout(featureBranchName);
      mvnCleanTest();
    }
    gitCheckout(gitFlowConfig.getDevelopmentBranch());
    if (featureSquash) {
      gitMergeSquash(featureBranchName);
      gitCommit(featureBranchName);
    }
 else {
      gitMergeNoff(featureBranchName);
    }
    final String currentVersion=getCurrentProjectVersion();
    final String featName=featureBranchName.replaceFirst(gitFlowConfig.getFeatureBranchPrefix(),""String_Node_Str"");
    if (currentVersion.contains(""String_Node_Str"" + featName)) {
      final String version=currentVersion.replaceFirst(""String_Node_Str"" + featName,""String_Node_Str"");
      mvnSetVersions(version);
      Map<String,String> properties=new HashMap<String,String>();
      properties.put(""String_Node_Str"",version);
      properties.put(""String_Node_Str"",featName);
      gitCommit(commitMessages.getFeatureFinishMessage(),properties);
    }
    if (installProject) {
      mvnCleanInstall();
    }
    if (!keepBranch) {
      if (featureSquash) {
        gitBranchDeleteForce(featureBranchName);
      }
 else {
        gitBranchDelete(featureBranchName);
      }
    }
    if (pushRemote) {
      gitPush(gitFlowConfig.getDevelopmentBranch(),false);
      if (!keepBranch) {
        gitPushDelete(featureBranchName);
      }
    }
  }
 catch (  CommandLineException e) {
    throw new MojoFailureException(""String_Node_Str"",e);
  }
}",0.9859710653222272
32235,"/** 
 * {@inheritDoc} 
 */
@Override public void execute() throws MojoExecutionException, MojoFailureException {
  validateConfiguration();
  try {
    initGitFlowConfig();
    checkUncommittedChanges();
    if (fetchRemote) {
      gitFetchRemoteAndCompare(gitFlowConfig.getDevelopmentBranch());
    }
    String featureBranchName=null;
    if (settings.isInteractiveMode()) {
      try {
        while (StringUtils.isBlank(featureBranchName)) {
          featureBranchName=prompter.prompt(""String_Node_Str"" + gitFlowConfig.getFeatureBranchPrefix());
          if (!validateBranchName(featureBranchName,featureNamePattern)) {
            featureBranchName=null;
          }
        }
      }
 catch (      PrompterException e) {
        getLog().error(e);
      }
    }
 else     if (validateBranchName(featureName,featureNamePattern)) {
      featureBranchName=featureName;
    }
    if (StringUtils.isBlank(featureBranchName)) {
      throw new MojoFailureException(""String_Node_Str"");
    }
    featureBranchName=StringUtils.deleteWhitespace(featureBranchName);
    final boolean featureBranchExists=gitCheckBranchExists(gitFlowConfig.getFeatureBranchPrefix() + featureBranchName);
    if (featureBranchExists) {
      throw new MojoFailureException(""String_Node_Str"");
    }
    gitCreateAndCheckout(gitFlowConfig.getFeatureBranchPrefix() + featureBranchName,gitFlowConfig.getDevelopmentBranch());
    if (!skipFeatureVersion && !tychoBuild) {
      final String currentVersion=getCurrentProjectVersion();
      final String version=new GitFlowVersionInfo(currentVersion).featureVersion(featureBranchName);
      if (StringUtils.isNotBlank(version)) {
        mvnSetVersions(version);
        Map<String,String> properties=new HashMap<String,String>();
        properties.put(""String_Node_Str"",version);
        properties.put(""String_Node_Str"",featureBranchName);
        gitCommit(commitMessages.getFeatureStartMessage(),properties);
      }
    }
    if (installProject) {
      mvnCleanInstall();
    }
    if (pushRemote) {
      gitPush(gitFlowConfig.getFeatureBranchPrefix() + featureBranchName,false);
    }
  }
 catch (  CommandLineException e) {
    getLog().error(e);
  }
catch (  VersionParseException e) {
    getLog().error(e);
  }
}","/** 
 * {@inheritDoc} 
 */
@Override public void execute() throws MojoExecutionException, MojoFailureException {
  validateConfiguration();
  try {
    initGitFlowConfig();
    checkUncommittedChanges();
    if (fetchRemote) {
      gitFetchRemoteAndCompare(gitFlowConfig.getDevelopmentBranch());
    }
    String featureBranchName=null;
    if (settings.isInteractiveMode()) {
      try {
        while (StringUtils.isBlank(featureBranchName)) {
          featureBranchName=prompter.prompt(""String_Node_Str"" + gitFlowConfig.getFeatureBranchPrefix());
          if (!validateBranchName(featureBranchName,featureNamePattern)) {
            featureBranchName=null;
          }
        }
      }
 catch (      PrompterException e) {
        throw new MojoFailureException(""String_Node_Str"",e);
      }
    }
 else     if (validateBranchName(featureName,featureNamePattern)) {
      featureBranchName=featureName;
    }
    if (StringUtils.isBlank(featureBranchName)) {
      throw new MojoFailureException(""String_Node_Str"");
    }
    featureBranchName=StringUtils.deleteWhitespace(featureBranchName);
    final boolean featureBranchExists=gitCheckBranchExists(gitFlowConfig.getFeatureBranchPrefix() + featureBranchName);
    if (featureBranchExists) {
      throw new MojoFailureException(""String_Node_Str"");
    }
    gitCreateAndCheckout(gitFlowConfig.getFeatureBranchPrefix() + featureBranchName,gitFlowConfig.getDevelopmentBranch());
    if (!skipFeatureVersion && !tychoBuild) {
      final String currentVersion=getCurrentProjectVersion();
      final String version=new GitFlowVersionInfo(currentVersion).featureVersion(featureBranchName);
      if (StringUtils.isNotBlank(version)) {
        mvnSetVersions(version);
        Map<String,String> properties=new HashMap<String,String>();
        properties.put(""String_Node_Str"",version);
        properties.put(""String_Node_Str"",featureBranchName);
        gitCommit(commitMessages.getFeatureStartMessage(),properties);
      }
    }
    if (installProject) {
      mvnCleanInstall();
    }
    if (pushRemote) {
      gitPush(gitFlowConfig.getFeatureBranchPrefix() + featureBranchName,false);
    }
  }
 catch (  CommandLineException e) {
    throw new MojoFailureException(""String_Node_Str"",e);
  }
catch (  VersionParseException e) {
    throw new MojoFailureException(""String_Node_Str"",e);
  }
}",0.9461571862787668
32236,"private String promptBranchName() throws MojoFailureException, CommandLineException {
  final String hotfixBranches=gitFindBranches(gitFlowConfig.getHotfixBranchPrefix(),false);
  if (StringUtils.isBlank(hotfixBranches)) {
    throw new MojoFailureException(""String_Node_Str"");
  }
  String[] branches=hotfixBranches.split(""String_Node_Str"");
  List<String> numberedList=new ArrayList<String>();
  StringBuilder str=new StringBuilder(""String_Node_Str"").append(LS);
  for (int i=0; i < branches.length; i++) {
    str.append((i + 1) + ""String_Node_Str"" + branches[i]+ LS);
    numberedList.add(String.valueOf(i + 1));
  }
  str.append(""String_Node_Str"");
  String hotfixNumber=null;
  try {
    while (StringUtils.isBlank(hotfixNumber)) {
      hotfixNumber=prompter.prompt(str.toString(),numberedList);
    }
  }
 catch (  PrompterException e) {
    getLog().error(e);
  }
  String hotfixBranchName=null;
  if (hotfixNumber != null) {
    int num=Integer.parseInt(hotfixNumber);
    hotfixBranchName=branches[num - 1];
  }
  return hotfixBranchName;
}","private String promptBranchName() throws MojoFailureException, CommandLineException {
  final String hotfixBranches=gitFindBranches(gitFlowConfig.getHotfixBranchPrefix(),false);
  if (StringUtils.isBlank(hotfixBranches)) {
    throw new MojoFailureException(""String_Node_Str"");
  }
  String[] branches=hotfixBranches.split(""String_Node_Str"");
  List<String> numberedList=new ArrayList<String>();
  StringBuilder str=new StringBuilder(""String_Node_Str"").append(LS);
  for (int i=0; i < branches.length; i++) {
    str.append((i + 1) + ""String_Node_Str"" + branches[i]+ LS);
    numberedList.add(String.valueOf(i + 1));
  }
  str.append(""String_Node_Str"");
  String hotfixNumber=null;
  try {
    while (StringUtils.isBlank(hotfixNumber)) {
      hotfixNumber=prompter.prompt(str.toString(),numberedList);
    }
  }
 catch (  PrompterException e) {
    throw new MojoFailureException(""String_Node_Str"",e);
  }
  String hotfixBranchName=null;
  if (hotfixNumber != null) {
    int num=Integer.parseInt(hotfixNumber);
    hotfixBranchName=branches[num - 1];
  }
  return hotfixBranchName;
}",0.9700374531835206
32237,"/** 
 * {@inheritDoc} 
 */
@Override public void execute() throws MojoExecutionException, MojoFailureException {
  validateConfiguration(preHotfixGoals,postHotfixGoals);
  try {
    checkUncommittedChanges();
    String hotfixBranchName=null;
    if (settings.isInteractiveMode()) {
      hotfixBranchName=promptBranchName();
    }
 else     if (StringUtils.isNotBlank(hotfixVersion)) {
      final String branch=gitFlowConfig.getHotfixBranchPrefix() + hotfixVersion;
      if (!gitCheckBranchExists(branch)) {
        throw new MojoFailureException(""String_Node_Str"" + branch + ""String_Node_Str"");
      }
      hotfixBranchName=branch;
    }
    if (StringUtils.isBlank(hotfixBranchName)) {
      throw new MojoFailureException(""String_Node_Str"");
    }
    String supportBranchName=null;
    boolean supportHotfix=hotfixBranchName.startsWith(gitFlowConfig.getHotfixBranchPrefix() + gitFlowConfig.getSupportBranchPrefix());
    if (supportHotfix) {
      supportBranchName=hotfixBranchName.substring(gitFlowConfig.getHotfixBranchPrefix().length());
      supportBranchName=supportBranchName.substring(0,supportBranchName.lastIndexOf('/'));
    }
    if (fetchRemote) {
      gitFetchRemoteAndCompare(hotfixBranchName);
      if (supportBranchName != null) {
        gitFetchRemoteAndCompare(supportBranchName);
      }
 else {
        if (notSameProdDevName()) {
          gitFetchRemoteAndCompare(gitFlowConfig.getDevelopmentBranch());
        }
        gitFetchRemoteAndCompare(gitFlowConfig.getProductionBranch());
      }
    }
    if (!skipTestProject) {
      gitCheckout(hotfixBranchName);
      mvnCleanTest();
    }
    if (StringUtils.isNotBlank(preHotfixGoals)) {
      gitCheckout(hotfixBranchName);
      mvnRun(preHotfixGoals);
    }
    if (supportBranchName != null) {
      gitCheckout(supportBranchName);
    }
 else {
      gitCheckout(gitFlowConfig.getProductionBranch());
    }
    gitMergeNoff(hotfixBranchName);
    final String currentVersion=getCurrentProjectVersion();
    if (!skipTag) {
      String tagVersion=currentVersion;
      if (tychoBuild && ArtifactUtils.isSnapshot(tagVersion)) {
        tagVersion=tagVersion.replace(""String_Node_Str"" + Artifact.SNAPSHOT_VERSION,""String_Node_Str"");
      }
      gitTag(gitFlowConfig.getVersionTagPrefix() + tagVersion,commitMessages.getTagHotfixMessage());
    }
    if (StringUtils.isNotBlank(postHotfixGoals)) {
      mvnRun(postHotfixGoals);
    }
    final String releaseBranch=gitFindBranches(gitFlowConfig.getReleaseBranchPrefix(),true);
    if (supportBranchName == null) {
      if (StringUtils.isNotBlank(releaseBranch)) {
        gitCheckout(releaseBranch);
        gitMergeNoff(hotfixBranchName);
      }
 else {
        GitFlowVersionInfo developVersionInfo=new GitFlowVersionInfo(currentVersion);
        if (notSameProdDevName()) {
          gitCheckout(gitFlowConfig.getDevelopmentBranch());
          developVersionInfo=new GitFlowVersionInfo(getCurrentProjectVersion());
          mvnSetVersions(currentVersion);
          gitCommit(""String_Node_Str"");
          gitMergeNoff(hotfixBranchName);
          GitFlowVersionInfo hotfixVersionInfo=new GitFlowVersionInfo(currentVersion);
          if (developVersionInfo.compareTo(hotfixVersionInfo) < 0) {
            developVersionInfo=hotfixVersionInfo;
          }
        }
        final String nextSnapshotVersion=developVersionInfo.nextSnapshotVersion();
        if (StringUtils.isBlank(nextSnapshotVersion)) {
          throw new MojoFailureException(""String_Node_Str"");
        }
        mvnSetVersions(nextSnapshotVersion);
        Map<String,String> properties=new HashMap<String,String>();
        properties.put(""String_Node_Str"",nextSnapshotVersion);
        gitCommit(commitMessages.getHotfixFinishMessage(),properties);
      }
    }
    if (installProject) {
      mvnCleanInstall();
    }
    if (!keepBranch) {
      gitBranchDelete(hotfixBranchName);
    }
    if (pushRemote) {
      if (supportBranchName != null) {
        gitPush(supportBranchName,!skipTag);
      }
 else {
        gitPush(gitFlowConfig.getProductionBranch(),!skipTag);
        if (StringUtils.isBlank(releaseBranch) && notSameProdDevName()) {
          gitPush(gitFlowConfig.getDevelopmentBranch(),!skipTag);
        }
      }
      if (!keepBranch) {
        gitPushDelete(hotfixBranchName);
      }
    }
  }
 catch (  Exception e) {
    getLog().error(e);
  }
}","/** 
 * {@inheritDoc} 
 */
@Override public void execute() throws MojoExecutionException, MojoFailureException {
  validateConfiguration(preHotfixGoals,postHotfixGoals);
  try {
    checkUncommittedChanges();
    String hotfixBranchName=null;
    if (settings.isInteractiveMode()) {
      hotfixBranchName=promptBranchName();
    }
 else     if (StringUtils.isNotBlank(hotfixVersion)) {
      final String branch=gitFlowConfig.getHotfixBranchPrefix() + hotfixVersion;
      if (!gitCheckBranchExists(branch)) {
        throw new MojoFailureException(""String_Node_Str"" + branch + ""String_Node_Str"");
      }
      hotfixBranchName=branch;
    }
    if (StringUtils.isBlank(hotfixBranchName)) {
      throw new MojoFailureException(""String_Node_Str"");
    }
    String supportBranchName=null;
    boolean supportHotfix=hotfixBranchName.startsWith(gitFlowConfig.getHotfixBranchPrefix() + gitFlowConfig.getSupportBranchPrefix());
    if (supportHotfix) {
      supportBranchName=hotfixBranchName.substring(gitFlowConfig.getHotfixBranchPrefix().length());
      supportBranchName=supportBranchName.substring(0,supportBranchName.lastIndexOf('/'));
    }
    if (fetchRemote) {
      gitFetchRemoteAndCompare(hotfixBranchName);
      if (supportBranchName != null) {
        gitFetchRemoteAndCompare(supportBranchName);
      }
 else {
        if (notSameProdDevName()) {
          gitFetchRemoteAndCompare(gitFlowConfig.getDevelopmentBranch());
        }
        gitFetchRemoteAndCompare(gitFlowConfig.getProductionBranch());
      }
    }
    if (!skipTestProject) {
      gitCheckout(hotfixBranchName);
      mvnCleanTest();
    }
    if (StringUtils.isNotBlank(preHotfixGoals)) {
      gitCheckout(hotfixBranchName);
      mvnRun(preHotfixGoals);
    }
    if (supportBranchName != null) {
      gitCheckout(supportBranchName);
    }
 else {
      gitCheckout(gitFlowConfig.getProductionBranch());
    }
    gitMergeNoff(hotfixBranchName);
    final String currentVersion=getCurrentProjectVersion();
    if (!skipTag) {
      String tagVersion=currentVersion;
      if (tychoBuild && ArtifactUtils.isSnapshot(tagVersion)) {
        tagVersion=tagVersion.replace(""String_Node_Str"" + Artifact.SNAPSHOT_VERSION,""String_Node_Str"");
      }
      gitTag(gitFlowConfig.getVersionTagPrefix() + tagVersion,commitMessages.getTagHotfixMessage());
    }
    if (StringUtils.isNotBlank(postHotfixGoals)) {
      mvnRun(postHotfixGoals);
    }
    final String releaseBranch=gitFindBranches(gitFlowConfig.getReleaseBranchPrefix(),true);
    if (supportBranchName == null) {
      if (StringUtils.isNotBlank(releaseBranch)) {
        gitCheckout(releaseBranch);
        gitMergeNoff(hotfixBranchName);
      }
 else {
        GitFlowVersionInfo developVersionInfo=new GitFlowVersionInfo(currentVersion);
        if (notSameProdDevName()) {
          gitCheckout(gitFlowConfig.getDevelopmentBranch());
          developVersionInfo=new GitFlowVersionInfo(getCurrentProjectVersion());
          mvnSetVersions(currentVersion);
          gitCommit(""String_Node_Str"");
          gitMergeNoff(hotfixBranchName);
          GitFlowVersionInfo hotfixVersionInfo=new GitFlowVersionInfo(currentVersion);
          if (developVersionInfo.compareTo(hotfixVersionInfo) < 0) {
            developVersionInfo=hotfixVersionInfo;
          }
        }
        final String nextSnapshotVersion=developVersionInfo.nextSnapshotVersion();
        if (StringUtils.isBlank(nextSnapshotVersion)) {
          throw new MojoFailureException(""String_Node_Str"");
        }
        mvnSetVersions(nextSnapshotVersion);
        Map<String,String> properties=new HashMap<String,String>();
        properties.put(""String_Node_Str"",nextSnapshotVersion);
        gitCommit(commitMessages.getHotfixFinishMessage(),properties);
      }
    }
    if (installProject) {
      mvnCleanInstall();
    }
    if (!keepBranch) {
      gitBranchDelete(hotfixBranchName);
    }
    if (pushRemote) {
      if (supportBranchName != null) {
        gitPush(supportBranchName,!skipTag);
      }
 else {
        gitPush(gitFlowConfig.getProductionBranch(),!skipTag);
        if (StringUtils.isBlank(releaseBranch) && notSameProdDevName()) {
          gitPush(gitFlowConfig.getDevelopmentBranch(),!skipTag);
        }
      }
      if (!keepBranch) {
        gitPushDelete(hotfixBranchName);
      }
    }
  }
 catch (  Exception e) {
    throw new MojoFailureException(""String_Node_Str"",e);
  }
}",0.9927470534904804
32238,"/** 
 * {@inheritDoc} 
 */
@Override public void execute() throws MojoExecutionException, MojoFailureException {
  validateConfiguration();
  try {
    initGitFlowConfig();
    checkUncommittedChanges();
    String branchName=gitFlowConfig.getProductionBranch();
    if (settings.isInteractiveMode()) {
      final String supportBranches=gitFindBranches(gitFlowConfig.getSupportBranchPrefix(),false);
      if (StringUtils.isNotBlank(supportBranches)) {
        final String[] tmpBranches=supportBranches.split(""String_Node_Str"");
        String[] branches=new String[tmpBranches.length + 1];
        for (int i=0; i < tmpBranches.length; i++) {
          branches[i]=tmpBranches[i];
        }
        branches[tmpBranches.length]=gitFlowConfig.getProductionBranch();
        List<String> numberedList=new ArrayList<String>();
        StringBuilder str=new StringBuilder(""String_Node_Str"").append(LS);
        for (int i=0; i < branches.length; i++) {
          str.append((i + 1) + ""String_Node_Str"" + branches[i]+ LS);
          numberedList.add(String.valueOf(i + 1));
        }
        str.append(""String_Node_Str"");
        String branchNumber=null;
        try {
          while (StringUtils.isBlank(branchNumber)) {
            branchNumber=prompter.prompt(str.toString(),numberedList);
          }
        }
 catch (        PrompterException e) {
          getLog().error(e);
        }
        if (branchNumber != null) {
          int num=Integer.parseInt(branchNumber);
          branchName=branches[num - 1];
        }
        if (StringUtils.isBlank(branchName)) {
          throw new MojoFailureException(""String_Node_Str"");
        }
      }
    }
    gitCheckout(branchName);
    if (fetchRemote) {
      gitFetchRemoteAndCompare(branchName);
    }
    final String currentVersion=getCurrentProjectVersion();
    final String defaultVersion=new GitFlowVersionInfo(currentVersion).hotfixVersion(tychoBuild);
    if (defaultVersion == null) {
      throw new MojoFailureException(""String_Node_Str"");
    }
    String version=null;
    if (settings.isInteractiveMode()) {
      try {
        while (version == null) {
          version=prompter.prompt(""String_Node_Str"" + defaultVersion + ""String_Node_Str"");
          if (!""String_Node_Str"".equals(version) && (!GitFlowVersionInfo.isValidVersion(version) || !validBranchName(version))) {
            getLog().info(""String_Node_Str"");
            version=null;
          }
        }
      }
 catch (      PrompterException e) {
        getLog().error(e);
      }
    }
 else {
      if (StringUtils.isNotBlank(hotfixVersion) && (!GitFlowVersionInfo.isValidVersion(hotfixVersion) || !validBranchName(hotfixVersion))) {
        throw new MojoFailureException(""String_Node_Str"" + hotfixVersion + ""String_Node_Str"");
      }
 else {
        version=hotfixVersion;
      }
    }
    if (StringUtils.isBlank(version)) {
      version=defaultVersion;
    }
    String branchVersionPart=version.replace('/','_');
    String hotfixBranchName=gitFlowConfig.getHotfixBranchPrefix() + branchVersionPart;
    if (!gitFlowConfig.getProductionBranch().equals(branchName)) {
      hotfixBranchName=gitFlowConfig.getHotfixBranchPrefix() + branchName + ""String_Node_Str""+ branchVersionPart;
    }
    final boolean hotfixBranchExists=gitCheckBranchExists(hotfixBranchName);
    if (hotfixBranchExists) {
      throw new MojoFailureException(""String_Node_Str"");
    }
    gitCreateAndCheckout(hotfixBranchName,branchName);
    if (!version.equals(currentVersion)) {
      mvnSetVersions(version);
      Map<String,String> properties=new HashMap<String,String>();
      properties.put(""String_Node_Str"",version);
      gitCommit(commitMessages.getHotfixStartMessage(),properties);
    }
    if (installProject) {
      mvnCleanInstall();
    }
    if (pushRemote) {
      gitPush(hotfixBranchName,false);
    }
  }
 catch (  CommandLineException e) {
    getLog().error(e);
  }
catch (  VersionParseException e) {
    getLog().error(e);
  }
}","/** 
 * {@inheritDoc} 
 */
@Override public void execute() throws MojoExecutionException, MojoFailureException {
  validateConfiguration();
  try {
    initGitFlowConfig();
    checkUncommittedChanges();
    String branchName=gitFlowConfig.getProductionBranch();
    if (settings.isInteractiveMode()) {
      final String supportBranches=gitFindBranches(gitFlowConfig.getSupportBranchPrefix(),false);
      if (StringUtils.isNotBlank(supportBranches)) {
        final String[] tmpBranches=supportBranches.split(""String_Node_Str"");
        String[] branches=new String[tmpBranches.length + 1];
        for (int i=0; i < tmpBranches.length; i++) {
          branches[i]=tmpBranches[i];
        }
        branches[tmpBranches.length]=gitFlowConfig.getProductionBranch();
        List<String> numberedList=new ArrayList<String>();
        StringBuilder str=new StringBuilder(""String_Node_Str"").append(LS);
        for (int i=0; i < branches.length; i++) {
          str.append((i + 1) + ""String_Node_Str"" + branches[i]+ LS);
          numberedList.add(String.valueOf(i + 1));
        }
        str.append(""String_Node_Str"");
        String branchNumber=null;
        try {
          while (StringUtils.isBlank(branchNumber)) {
            branchNumber=prompter.prompt(str.toString(),numberedList);
          }
        }
 catch (        PrompterException e) {
          throw new MojoFailureException(""String_Node_Str"",e);
        }
        if (branchNumber != null) {
          int num=Integer.parseInt(branchNumber);
          branchName=branches[num - 1];
        }
        if (StringUtils.isBlank(branchName)) {
          throw new MojoFailureException(""String_Node_Str"");
        }
      }
    }
    gitCheckout(branchName);
    if (fetchRemote) {
      gitFetchRemoteAndCompare(branchName);
    }
    final String currentVersion=getCurrentProjectVersion();
    final String defaultVersion=new GitFlowVersionInfo(currentVersion).hotfixVersion(tychoBuild);
    if (defaultVersion == null) {
      throw new MojoFailureException(""String_Node_Str"");
    }
    String version=null;
    if (settings.isInteractiveMode()) {
      try {
        while (version == null) {
          version=prompter.prompt(""String_Node_Str"" + defaultVersion + ""String_Node_Str"");
          if (!""String_Node_Str"".equals(version) && (!GitFlowVersionInfo.isValidVersion(version) || !validBranchName(version))) {
            getLog().info(""String_Node_Str"");
            version=null;
          }
        }
      }
 catch (      PrompterException e) {
        throw new MojoFailureException(""String_Node_Str"",e);
      }
    }
 else {
      if (StringUtils.isNotBlank(hotfixVersion) && (!GitFlowVersionInfo.isValidVersion(hotfixVersion) || !validBranchName(hotfixVersion))) {
        throw new MojoFailureException(""String_Node_Str"" + hotfixVersion + ""String_Node_Str"");
      }
 else {
        version=hotfixVersion;
      }
    }
    if (StringUtils.isBlank(version)) {
      version=defaultVersion;
    }
    String branchVersionPart=version.replace('/','_');
    String hotfixBranchName=gitFlowConfig.getHotfixBranchPrefix() + branchVersionPart;
    if (!gitFlowConfig.getProductionBranch().equals(branchName)) {
      hotfixBranchName=gitFlowConfig.getHotfixBranchPrefix() + branchName + ""String_Node_Str""+ branchVersionPart;
    }
    final boolean hotfixBranchExists=gitCheckBranchExists(hotfixBranchName);
    if (hotfixBranchExists) {
      throw new MojoFailureException(""String_Node_Str"");
    }
    gitCreateAndCheckout(hotfixBranchName,branchName);
    if (!version.equals(currentVersion)) {
      mvnSetVersions(version);
      Map<String,String> properties=new HashMap<String,String>();
      properties.put(""String_Node_Str"",version);
      gitCommit(commitMessages.getHotfixStartMessage(),properties);
    }
    if (installProject) {
      mvnCleanInstall();
    }
    if (pushRemote) {
      gitPush(hotfixBranchName,false);
    }
  }
 catch (  CommandLineException e) {
    throw new MojoFailureException(""String_Node_Str"",e);
  }
catch (  VersionParseException e) {
    throw new MojoFailureException(""String_Node_Str"",e);
  }
}",0.9615004935834156
32239,"/** 
 * {@inheritDoc} 
 */
@Override public void execute() throws MojoExecutionException, MojoFailureException {
  validateConfiguration(preReleaseGoals,postReleaseGoals);
  try {
    checkUncommittedChanges();
    final String releaseBranch=gitFindBranches(gitFlowConfig.getReleaseBranchPrefix(),false).trim();
    if (StringUtils.isBlank(releaseBranch)) {
      throw new MojoFailureException(""String_Node_Str"");
    }
 else     if (StringUtils.countMatches(releaseBranch,gitFlowConfig.getReleaseBranchPrefix()) > 1) {
      throw new MojoFailureException(""String_Node_Str"");
    }
    if (!allowSnapshots) {
      gitCheckout(releaseBranch);
      checkSnapshotDependencies();
    }
    if (fetchRemote) {
      gitFetchRemoteAndCompare(releaseBranch);
      gitFetchRemoteAndCreate(gitFlowConfig.getDevelopmentBranch());
      gitFetchRemoteAndCompare(gitFlowConfig.getDevelopmentBranch());
      if (notSameProdDevName()) {
        gitFetchRemoteAndCreate(gitFlowConfig.getProductionBranch());
        gitFetchRemoteAndCompare(gitFlowConfig.getProductionBranch());
      }
    }
    if (!skipTestProject) {
      gitCheckout(releaseBranch);
      mvnCleanTest();
    }
    if (StringUtils.isNotBlank(preReleaseGoals)) {
      gitCheckout(releaseBranch);
      mvnRun(preReleaseGoals);
    }
    gitCheckout(gitFlowConfig.getProductionBranch());
    gitMerge(releaseBranch,releaseRebase,releaseMergeNoFF,releaseMergeFFOnly);
    final String currentVersion=getCurrentProjectVersion();
    if (!skipTag) {
      String tagVersion=currentVersion;
      if (tychoBuild && ArtifactUtils.isSnapshot(currentVersion)) {
        tagVersion=currentVersion.replace(""String_Node_Str"" + Artifact.SNAPSHOT_VERSION,""String_Node_Str"");
      }
      gitTag(gitFlowConfig.getVersionTagPrefix() + tagVersion,commitMessages.getTagReleaseMessage());
    }
    if (StringUtils.isNotBlank(postReleaseGoals)) {
      mvnRun(postReleaseGoals);
    }
    if (notSameProdDevName()) {
      gitCheckout(gitFlowConfig.getDevelopmentBranch());
      gitMerge(releaseBranch,releaseRebase,releaseMergeNoFF,false);
    }
    if (commitDevelopmentVersionAtStart && !notSameProdDevName()) {
      getLog().warn(""String_Node_Str"");
      commitDevelopmentVersionAtStart=false;
    }
    if (!commitDevelopmentVersionAtStart) {
      final String nextSnapshotVersion;
      if (!settings.isInteractiveMode() && StringUtils.isNotBlank(developmentVersion)) {
        nextSnapshotVersion=developmentVersion;
      }
 else {
        GitFlowVersionInfo versionInfo=new GitFlowVersionInfo(currentVersion);
        if (digitsOnlyDevVersion) {
          versionInfo=versionInfo.digitsVersionInfo();
        }
        nextSnapshotVersion=versionInfo.nextSnapshotVersion(versionDigitToIncrement);
      }
      if (StringUtils.isBlank(nextSnapshotVersion)) {
        throw new MojoFailureException(""String_Node_Str"");
      }
      mvnSetVersions(nextSnapshotVersion);
      Map<String,String> properties=new HashMap<String,String>();
      properties.put(""String_Node_Str"",nextSnapshotVersion);
      gitCommit(commitMessages.getReleaseFinishMessage(),properties);
    }
    if (installProject) {
      mvnCleanInstall();
    }
    if (!keepBranch) {
      gitBranchDelete(releaseBranch);
    }
    if (pushRemote) {
      gitPush(gitFlowConfig.getProductionBranch(),!skipTag);
      if (notSameProdDevName()) {
        gitPush(gitFlowConfig.getDevelopmentBranch(),!skipTag);
      }
      if (!keepBranch) {
        gitPushDelete(releaseBranch);
      }
    }
  }
 catch (  Exception e) {
    getLog().error(e);
  }
}","/** 
 * {@inheritDoc} 
 */
@Override public void execute() throws MojoExecutionException, MojoFailureException {
  validateConfiguration(preReleaseGoals,postReleaseGoals);
  try {
    checkUncommittedChanges();
    final String releaseBranch=gitFindBranches(gitFlowConfig.getReleaseBranchPrefix(),false).trim();
    if (StringUtils.isBlank(releaseBranch)) {
      throw new MojoFailureException(""String_Node_Str"");
    }
 else     if (StringUtils.countMatches(releaseBranch,gitFlowConfig.getReleaseBranchPrefix()) > 1) {
      throw new MojoFailureException(""String_Node_Str"");
    }
    if (!allowSnapshots) {
      gitCheckout(releaseBranch);
      checkSnapshotDependencies();
    }
    if (fetchRemote) {
      gitFetchRemoteAndCompare(releaseBranch);
      gitFetchRemoteAndCreate(gitFlowConfig.getDevelopmentBranch());
      gitFetchRemoteAndCompare(gitFlowConfig.getDevelopmentBranch());
      if (notSameProdDevName()) {
        gitFetchRemoteAndCreate(gitFlowConfig.getProductionBranch());
        gitFetchRemoteAndCompare(gitFlowConfig.getProductionBranch());
      }
    }
    if (!skipTestProject) {
      gitCheckout(releaseBranch);
      mvnCleanTest();
    }
    if (StringUtils.isNotBlank(preReleaseGoals)) {
      gitCheckout(releaseBranch);
      mvnRun(preReleaseGoals);
    }
    gitCheckout(gitFlowConfig.getProductionBranch());
    gitMerge(releaseBranch,releaseRebase,releaseMergeNoFF,releaseMergeFFOnly);
    final String currentVersion=getCurrentProjectVersion();
    if (!skipTag) {
      String tagVersion=currentVersion;
      if (tychoBuild && ArtifactUtils.isSnapshot(currentVersion)) {
        tagVersion=currentVersion.replace(""String_Node_Str"" + Artifact.SNAPSHOT_VERSION,""String_Node_Str"");
      }
      gitTag(gitFlowConfig.getVersionTagPrefix() + tagVersion,commitMessages.getTagReleaseMessage());
    }
    if (StringUtils.isNotBlank(postReleaseGoals)) {
      mvnRun(postReleaseGoals);
    }
    if (notSameProdDevName()) {
      gitCheckout(gitFlowConfig.getDevelopmentBranch());
      gitMerge(releaseBranch,releaseRebase,releaseMergeNoFF,false);
    }
    if (commitDevelopmentVersionAtStart && !notSameProdDevName()) {
      getLog().warn(""String_Node_Str"");
      commitDevelopmentVersionAtStart=false;
    }
    if (!commitDevelopmentVersionAtStart) {
      final String nextSnapshotVersion;
      if (!settings.isInteractiveMode() && StringUtils.isNotBlank(developmentVersion)) {
        nextSnapshotVersion=developmentVersion;
      }
 else {
        GitFlowVersionInfo versionInfo=new GitFlowVersionInfo(currentVersion);
        if (digitsOnlyDevVersion) {
          versionInfo=versionInfo.digitsVersionInfo();
        }
        nextSnapshotVersion=versionInfo.nextSnapshotVersion(versionDigitToIncrement);
      }
      if (StringUtils.isBlank(nextSnapshotVersion)) {
        throw new MojoFailureException(""String_Node_Str"");
      }
      mvnSetVersions(nextSnapshotVersion);
      Map<String,String> properties=new HashMap<String,String>();
      properties.put(""String_Node_Str"",nextSnapshotVersion);
      gitCommit(commitMessages.getReleaseFinishMessage(),properties);
    }
    if (installProject) {
      mvnCleanInstall();
    }
    if (!keepBranch) {
      gitBranchDelete(releaseBranch);
    }
    if (pushRemote) {
      gitPush(gitFlowConfig.getProductionBranch(),!skipTag);
      if (notSameProdDevName()) {
        gitPush(gitFlowConfig.getDevelopmentBranch(),!skipTag);
      }
      if (!keepBranch) {
        gitPushDelete(releaseBranch);
      }
    }
  }
 catch (  Exception e) {
    throw new MojoFailureException(""String_Node_Str"",e);
  }
}",0.9910987482614744
32240,"/** 
 * {@inheritDoc} 
 */
@Override public void execute() throws MojoExecutionException, MojoFailureException {
  validateConfiguration(preReleaseGoals,postReleaseGoals);
  try {
    initGitFlowConfig();
    checkUncommittedChanges();
    final String releaseBranch=gitFindBranches(gitFlowConfig.getReleaseBranchPrefix(),true);
    if (StringUtils.isNotBlank(releaseBranch)) {
      throw new MojoFailureException(""String_Node_Str"");
    }
    if (fetchRemote) {
      gitFetchRemoteAndCreate(gitFlowConfig.getDevelopmentBranch());
      gitFetchRemoteAndCompare(gitFlowConfig.getDevelopmentBranch());
      if (notSameProdDevName()) {
        gitFetchRemoteAndCreate(gitFlowConfig.getProductionBranch());
        gitFetchRemoteAndCompare(gitFlowConfig.getProductionBranch());
      }
    }
    gitCheckout(gitFlowConfig.getDevelopmentBranch());
    if (!allowSnapshots) {
      checkSnapshotDependencies();
    }
    if (!skipTestProject) {
      mvnCleanTest();
    }
    final String currentVersion=getCurrentProjectVersion();
    String defaultVersion=null;
    if (tychoBuild) {
      defaultVersion=currentVersion;
    }
 else {
      defaultVersion=new GitFlowVersionInfo(currentVersion).getReleaseVersionString();
    }
    if (defaultVersion == null) {
      throw new MojoFailureException(""String_Node_Str"");
    }
    String version=null;
    if (settings.isInteractiveMode()) {
      try {
        while (version == null) {
          version=prompter.prompt(""String_Node_Str"" + defaultVersion + ""String_Node_Str"");
          if (!""String_Node_Str"".equals(version) && (!GitFlowVersionInfo.isValidVersion(version) || !validBranchName(version))) {
            getLog().info(""String_Node_Str"");
            version=null;
          }
        }
      }
 catch (      PrompterException e) {
        getLog().error(e);
      }
    }
 else {
      version=releaseVersion;
    }
    if (StringUtils.isBlank(version)) {
      version=defaultVersion;
    }
    if (StringUtils.isNotBlank(preReleaseGoals)) {
      mvnRun(preReleaseGoals);
    }
    if (!version.equals(currentVersion)) {
      mvnSetVersions(version);
      Map<String,String> properties=new HashMap<String,String>();
      properties.put(""String_Node_Str"",version);
      gitCommit(commitMessages.getReleaseStartMessage(),properties);
    }
    if (notSameProdDevName()) {
      gitCheckout(gitFlowConfig.getProductionBranch());
      gitMerge(gitFlowConfig.getDevelopmentBranch(),releaseRebase,releaseMergeNoFF,releaseMergeFFOnly);
    }
    if (!skipTag) {
      if (tychoBuild && ArtifactUtils.isSnapshot(version)) {
        version=version.replace(""String_Node_Str"" + Artifact.SNAPSHOT_VERSION,""String_Node_Str"");
      }
      gitTag(gitFlowConfig.getVersionTagPrefix() + version,commitMessages.getTagReleaseMessage());
    }
    if (StringUtils.isNotBlank(postReleaseGoals)) {
      mvnRun(postReleaseGoals);
    }
    if (notSameProdDevName()) {
      gitCheckout(gitFlowConfig.getDevelopmentBranch());
    }
    final String nextSnapshotVersion;
    if (!settings.isInteractiveMode() && StringUtils.isNotBlank(developmentVersion)) {
      nextSnapshotVersion=developmentVersion;
    }
 else {
      GitFlowVersionInfo versionInfo=new GitFlowVersionInfo(version);
      if (digitsOnlyDevVersion) {
        versionInfo=versionInfo.digitsVersionInfo();
      }
      nextSnapshotVersion=versionInfo.nextSnapshotVersion(versionDigitToIncrement);
    }
    if (StringUtils.isBlank(nextSnapshotVersion)) {
      throw new MojoFailureException(""String_Node_Str"");
    }
    mvnSetVersions(nextSnapshotVersion);
    Map<String,String> properties=new HashMap<String,String>();
    properties.put(""String_Node_Str"",nextSnapshotVersion);
    gitCommit(commitMessages.getReleaseFinishMessage(),properties);
    if (installProject) {
      mvnCleanInstall();
    }
    if (pushRemote) {
      gitPush(gitFlowConfig.getProductionBranch(),!skipTag);
      if (notSameProdDevName()) {
        gitPush(gitFlowConfig.getDevelopmentBranch(),!skipTag);
      }
    }
  }
 catch (  Exception e) {
    getLog().error(e);
  }
}","/** 
 * {@inheritDoc} 
 */
@Override public void execute() throws MojoExecutionException, MojoFailureException {
  validateConfiguration(preReleaseGoals,postReleaseGoals);
  try {
    initGitFlowConfig();
    checkUncommittedChanges();
    final String releaseBranch=gitFindBranches(gitFlowConfig.getReleaseBranchPrefix(),true);
    if (StringUtils.isNotBlank(releaseBranch)) {
      throw new MojoFailureException(""String_Node_Str"");
    }
    if (fetchRemote) {
      gitFetchRemoteAndCreate(gitFlowConfig.getDevelopmentBranch());
      gitFetchRemoteAndCompare(gitFlowConfig.getDevelopmentBranch());
      if (notSameProdDevName()) {
        gitFetchRemoteAndCreate(gitFlowConfig.getProductionBranch());
        gitFetchRemoteAndCompare(gitFlowConfig.getProductionBranch());
      }
    }
    gitCheckout(gitFlowConfig.getDevelopmentBranch());
    if (!allowSnapshots) {
      checkSnapshotDependencies();
    }
    if (!skipTestProject) {
      mvnCleanTest();
    }
    final String currentVersion=getCurrentProjectVersion();
    String defaultVersion=null;
    if (tychoBuild) {
      defaultVersion=currentVersion;
    }
 else {
      defaultVersion=new GitFlowVersionInfo(currentVersion).getReleaseVersionString();
    }
    if (defaultVersion == null) {
      throw new MojoFailureException(""String_Node_Str"");
    }
    String version=null;
    if (settings.isInteractiveMode()) {
      try {
        while (version == null) {
          version=prompter.prompt(""String_Node_Str"" + defaultVersion + ""String_Node_Str"");
          if (!""String_Node_Str"".equals(version) && (!GitFlowVersionInfo.isValidVersion(version) || !validBranchName(version))) {
            getLog().info(""String_Node_Str"");
            version=null;
          }
        }
      }
 catch (      PrompterException e) {
        throw new MojoFailureException(""String_Node_Str"",e);
      }
    }
 else {
      version=releaseVersion;
    }
    if (StringUtils.isBlank(version)) {
      version=defaultVersion;
    }
    if (StringUtils.isNotBlank(preReleaseGoals)) {
      mvnRun(preReleaseGoals);
    }
    if (!version.equals(currentVersion)) {
      mvnSetVersions(version);
      Map<String,String> properties=new HashMap<String,String>();
      properties.put(""String_Node_Str"",version);
      gitCommit(commitMessages.getReleaseStartMessage(),properties);
    }
    if (notSameProdDevName()) {
      gitCheckout(gitFlowConfig.getProductionBranch());
      gitMerge(gitFlowConfig.getDevelopmentBranch(),releaseRebase,releaseMergeNoFF,releaseMergeFFOnly);
    }
    if (!skipTag) {
      if (tychoBuild && ArtifactUtils.isSnapshot(version)) {
        version=version.replace(""String_Node_Str"" + Artifact.SNAPSHOT_VERSION,""String_Node_Str"");
      }
      gitTag(gitFlowConfig.getVersionTagPrefix() + version,commitMessages.getTagReleaseMessage());
    }
    if (StringUtils.isNotBlank(postReleaseGoals)) {
      mvnRun(postReleaseGoals);
    }
    if (notSameProdDevName()) {
      gitCheckout(gitFlowConfig.getDevelopmentBranch());
    }
    final String nextSnapshotVersion;
    if (!settings.isInteractiveMode() && StringUtils.isNotBlank(developmentVersion)) {
      nextSnapshotVersion=developmentVersion;
    }
 else {
      GitFlowVersionInfo versionInfo=new GitFlowVersionInfo(version);
      if (digitsOnlyDevVersion) {
        versionInfo=versionInfo.digitsVersionInfo();
      }
      nextSnapshotVersion=versionInfo.nextSnapshotVersion(versionDigitToIncrement);
    }
    if (StringUtils.isBlank(nextSnapshotVersion)) {
      throw new MojoFailureException(""String_Node_Str"");
    }
    mvnSetVersions(nextSnapshotVersion);
    Map<String,String> properties=new HashMap<String,String>();
    properties.put(""String_Node_Str"",nextSnapshotVersion);
    gitCommit(commitMessages.getReleaseFinishMessage(),properties);
    if (installProject) {
      mvnCleanInstall();
    }
    if (pushRemote) {
      gitPush(gitFlowConfig.getProductionBranch(),!skipTag);
      if (notSameProdDevName()) {
        gitPush(gitFlowConfig.getDevelopmentBranch(),!skipTag);
      }
    }
  }
 catch (  Exception e) {
    throw new MojoFailureException(""String_Node_Str"",e);
  }
}",0.9844471445929526
32241,"private String getReleaseVersion() throws MojoFailureException, VersionParseException, CommandLineException {
  final String currentVersion=getCurrentProjectVersion();
  String defaultVersion=null;
  if (tychoBuild) {
    defaultVersion=currentVersion;
  }
 else {
    defaultVersion=new GitFlowVersionInfo(currentVersion).getReleaseVersionString();
  }
  if (defaultVersion == null) {
    throw new MojoFailureException(""String_Node_Str"");
  }
  String version=null;
  if (settings.isInteractiveMode()) {
    try {
      while (version == null) {
        version=prompter.prompt(""String_Node_Str"" + defaultVersion + ""String_Node_Str"");
        if (!""String_Node_Str"".equals(version) && (!GitFlowVersionInfo.isValidVersion(version) || !validBranchName(version))) {
          getLog().info(""String_Node_Str"");
          version=null;
        }
      }
    }
 catch (    PrompterException e) {
      getLog().error(e);
    }
  }
 else {
    version=releaseVersion;
  }
  if (StringUtils.isBlank(version)) {
    version=defaultVersion;
  }
  return version;
}","private String getReleaseVersion() throws MojoFailureException, VersionParseException, CommandLineException {
  final String currentVersion=getCurrentProjectVersion();
  String defaultVersion=null;
  if (tychoBuild) {
    defaultVersion=currentVersion;
  }
 else {
    defaultVersion=new GitFlowVersionInfo(currentVersion).getReleaseVersionString();
  }
  if (defaultVersion == null) {
    throw new MojoFailureException(""String_Node_Str"");
  }
  String version=null;
  if (settings.isInteractiveMode()) {
    try {
      while (version == null) {
        version=prompter.prompt(""String_Node_Str"" + defaultVersion + ""String_Node_Str"");
        if (!""String_Node_Str"".equals(version) && (!GitFlowVersionInfo.isValidVersion(version) || !validBranchName(version))) {
          getLog().info(""String_Node_Str"");
          version=null;
        }
      }
    }
 catch (    PrompterException e) {
      throw new MojoFailureException(""String_Node_Str"",e);
    }
  }
 else {
    version=releaseVersion;
  }
  if (StringUtils.isBlank(version)) {
    version=defaultVersion;
  }
  return version;
}",0.8443616029822927
32242,"/** 
 * {@inheritDoc} 
 */
@Override public void execute() throws MojoExecutionException, MojoFailureException {
  validateConfiguration();
  try {
    initGitFlowConfig();
    checkUncommittedChanges();
    final String releaseBranch=gitFindBranches(gitFlowConfig.getReleaseBranchPrefix(),true);
    if (StringUtils.isNotBlank(releaseBranch)) {
      throw new MojoFailureException(""String_Node_Str"");
    }
    if (fetchRemote) {
      gitFetchRemoteAndCreate(gitFlowConfig.getDevelopmentBranch());
      gitFetchRemoteAndCompare(gitFlowConfig.getDevelopmentBranch());
    }
    final String startPoint;
    if (StringUtils.isNotBlank(fromCommit) && notSameProdDevName()) {
      startPoint=fromCommit;
    }
 else {
      startPoint=gitFlowConfig.getDevelopmentBranch();
    }
    gitCheckout(startPoint);
    if (!allowSnapshots) {
      checkSnapshotDependencies();
    }
    if (commitDevelopmentVersionAtStart && !notSameProdDevName()) {
      getLog().warn(""String_Node_Str"");
      commitDevelopmentVersionAtStart=false;
    }
    final String releaseVersion=getReleaseVersion();
    String branchName=gitFlowConfig.getReleaseBranchPrefix();
    if (!sameBranchName) {
      branchName+=releaseVersion;
    }
    if (commitDevelopmentVersionAtStart) {
      commitProjectVersion(releaseVersion,commitMessages.getReleaseStartMessage());
      gitCreateBranch(branchName,startPoint);
      final String nextSnapshotVersion=getNextSnapshotVersion(releaseVersion);
      commitProjectVersion(nextSnapshotVersion,commitMessages.getReleaseFinishMessage());
      gitCheckout(branchName);
    }
 else {
      gitCreateAndCheckout(branchName,startPoint);
      commitProjectVersion(releaseVersion,commitMessages.getReleaseStartMessage());
    }
    if (installProject) {
      mvnCleanInstall();
    }
    if (pushRemote) {
      if (commitDevelopmentVersionAtStart) {
        gitPush(gitFlowConfig.getDevelopmentBranch(),false);
      }
      gitPush(branchName,false);
    }
  }
 catch (  CommandLineException e) {
    getLog().error(e);
  }
catch (  VersionParseException e) {
    getLog().error(e);
  }
}","/** 
 * {@inheritDoc} 
 */
@Override public void execute() throws MojoExecutionException, MojoFailureException {
  validateConfiguration();
  try {
    initGitFlowConfig();
    checkUncommittedChanges();
    final String releaseBranch=gitFindBranches(gitFlowConfig.getReleaseBranchPrefix(),true);
    if (StringUtils.isNotBlank(releaseBranch)) {
      throw new MojoFailureException(""String_Node_Str"");
    }
    if (fetchRemote) {
      gitFetchRemoteAndCreate(gitFlowConfig.getDevelopmentBranch());
      gitFetchRemoteAndCompare(gitFlowConfig.getDevelopmentBranch());
    }
    final String startPoint;
    if (StringUtils.isNotBlank(fromCommit) && notSameProdDevName()) {
      startPoint=fromCommit;
    }
 else {
      startPoint=gitFlowConfig.getDevelopmentBranch();
    }
    gitCheckout(startPoint);
    if (!allowSnapshots) {
      checkSnapshotDependencies();
    }
    if (commitDevelopmentVersionAtStart && !notSameProdDevName()) {
      getLog().warn(""String_Node_Str"");
      commitDevelopmentVersionAtStart=false;
    }
    final String releaseVersion=getReleaseVersion();
    String branchName=gitFlowConfig.getReleaseBranchPrefix();
    if (!sameBranchName) {
      branchName+=releaseVersion;
    }
    if (commitDevelopmentVersionAtStart) {
      commitProjectVersion(releaseVersion,commitMessages.getReleaseStartMessage());
      gitCreateBranch(branchName,startPoint);
      final String nextSnapshotVersion=getNextSnapshotVersion(releaseVersion);
      commitProjectVersion(nextSnapshotVersion,commitMessages.getReleaseFinishMessage());
      gitCheckout(branchName);
    }
 else {
      gitCreateAndCheckout(branchName,startPoint);
      commitProjectVersion(releaseVersion,commitMessages.getReleaseStartMessage());
    }
    if (installProject) {
      mvnCleanInstall();
    }
    if (pushRemote) {
      if (commitDevelopmentVersionAtStart) {
        gitPush(gitFlowConfig.getDevelopmentBranch(),false);
      }
      gitPush(branchName,false);
    }
  }
 catch (  CommandLineException e) {
    throw new MojoFailureException(""String_Node_Str"",e);
  }
catch (  VersionParseException e) {
    throw new MojoFailureException(""String_Node_Str"",e);
  }
}",0.9570695286980868
32243,"/** 
 * {@inheritDoc} 
 */
@Override public void execute() throws MojoExecutionException, MojoFailureException {
  validateConfiguration();
  try {
    initGitFlowConfig();
    checkUncommittedChanges();
    String tagsStr=gitFindTags();
    if (StringUtils.isBlank(tagsStr)) {
      throw new MojoFailureException(""String_Node_Str"");
    }
    String tagName=null;
    try {
      tagName=prompter.prompt(""String_Node_Str"",Arrays.asList(tagsStr.split(""String_Node_Str"")));
    }
 catch (    PrompterException e) {
      getLog().error(e);
    }
    final boolean supportBranchExists=gitCheckBranchExists(gitFlowConfig.getSupportBranchPrefix() + tagName);
    if (supportBranchExists) {
      throw new MojoFailureException(""String_Node_Str"");
    }
    gitCreateAndCheckout(gitFlowConfig.getSupportBranchPrefix() + tagName,tagName);
    if (installProject) {
      mvnCleanInstall();
    }
    if (pushRemote) {
      gitPush(gitFlowConfig.getSupportBranchPrefix() + tagName,false);
    }
  }
 catch (  CommandLineException e) {
    getLog().error(e);
  }
}","/** 
 * {@inheritDoc} 
 */
@Override public void execute() throws MojoExecutionException, MojoFailureException {
  validateConfiguration();
  try {
    initGitFlowConfig();
    checkUncommittedChanges();
    String tagsStr=gitFindTags();
    if (StringUtils.isBlank(tagsStr)) {
      throw new MojoFailureException(""String_Node_Str"");
    }
    String tagName=null;
    try {
      tagName=prompter.prompt(""String_Node_Str"",Arrays.asList(tagsStr.split(""String_Node_Str"")));
    }
 catch (    PrompterException e) {
      throw new MojoFailureException(""String_Node_Str"",e);
    }
    final boolean supportBranchExists=gitCheckBranchExists(gitFlowConfig.getSupportBranchPrefix() + tagName);
    if (supportBranchExists) {
      throw new MojoFailureException(""String_Node_Str"");
    }
    gitCreateAndCheckout(gitFlowConfig.getSupportBranchPrefix() + tagName,tagName);
    if (installProject) {
      mvnCleanInstall();
    }
    if (pushRemote) {
      gitPush(gitFlowConfig.getSupportBranchPrefix() + tagName,false);
    }
  }
 catch (  CommandLineException e) {
    throw new MojoFailureException(""String_Node_Str"",e);
  }
}",0.9413919413919414
32244,"/** 
 * {@inheritDoc} 
 */
@Override public void execute() throws MojoExecutionException, MojoFailureException {
  try {
    checkUncommittedChanges();
    final String featureBranches=executeGitCommandReturn(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + gitFlowConfig.getFeatureBranchPrefix() + ""String_Node_Str"");
    if (StringUtils.isBlank(featureBranches)) {
      throw new MojoFailureException(""String_Node_Str"");
    }
    final String[] branches=featureBranches.split(""String_Node_Str"");
    List<String> numberedList=new ArrayList<String>();
    StringBuilder str=new StringBuilder(""String_Node_Str"").append(LS);
    for (int i=0; i < branches.length; i++) {
      str.append((i + 1) + ""String_Node_Str"" + branches[i]+ LS);
      numberedList.add(""String_Node_Str"" + (i + 1));
    }
    str.append(""String_Node_Str"");
    String featureNumber=null;
    try {
      while (StringUtils.isBlank(featureNumber)) {
        featureNumber=prompter.prompt(str.toString(),numberedList);
      }
    }
 catch (    PrompterException e) {
      getLog().error(e);
    }
    String featureBranchName=null;
    if (featureNumber != null) {
      int num=Integer.parseInt(featureNumber);
      featureBranchName=branches[num - 1];
    }
    if (StringUtils.isBlank(featureBranchName)) {
      throw new MojoFailureException(""String_Node_Str"");
    }
    gitCheckout(featureBranchName);
    if (!skipTestProject) {
      mvnCleanTest();
    }
    gitCheckout(gitFlowConfig.getDevelopmentBranch());
    gitMergeNoff(featureBranchName);
    final String currentVersion=getCurrentProjectVersion();
    final String featureName=featureBranchName.replaceFirst(gitFlowConfig.getFeatureBranchPrefix(),""String_Node_Str"");
    if (currentVersion.contains(""String_Node_Str"" + featureName)) {
      final String version=currentVersion.replaceFirst(""String_Node_Str"" + featureName,""String_Node_Str"");
      mvnSetVersions(version);
      gitCommit(""String_Node_Str"");
    }
    if (installProject) {
      mvnCleanInstall();
    }
    if (!keepBranch) {
      gitBranchDelete(featureBranchName);
    }
  }
 catch (  CommandLineException e) {
    getLog().error(e);
  }
}","/** 
 * {@inheritDoc} 
 */
@Override public void execute() throws MojoExecutionException, MojoFailureException {
  try {
    checkUncommittedChanges();
    final String featureBranches=gitFindBranches(gitFlowConfig.getFeatureBranchPrefix());
    if (StringUtils.isBlank(featureBranches)) {
      throw new MojoFailureException(""String_Node_Str"");
    }
    final String[] branches=featureBranches.split(""String_Node_Str"");
    List<String> numberedList=new ArrayList<String>();
    StringBuilder str=new StringBuilder(""String_Node_Str"").append(LS);
    for (int i=0; i < branches.length; i++) {
      str.append((i + 1) + ""String_Node_Str"" + branches[i]+ LS);
      numberedList.add(""String_Node_Str"" + (i + 1));
    }
    str.append(""String_Node_Str"");
    String featureNumber=null;
    try {
      while (StringUtils.isBlank(featureNumber)) {
        featureNumber=prompter.prompt(str.toString(),numberedList);
      }
    }
 catch (    PrompterException e) {
      getLog().error(e);
    }
    String featureBranchName=null;
    if (featureNumber != null) {
      int num=Integer.parseInt(featureNumber);
      featureBranchName=branches[num - 1];
    }
    if (StringUtils.isBlank(featureBranchName)) {
      throw new MojoFailureException(""String_Node_Str"");
    }
    gitCheckout(featureBranchName);
    if (!skipTestProject) {
      mvnCleanTest();
    }
    gitCheckout(gitFlowConfig.getDevelopmentBranch());
    gitMergeNoff(featureBranchName);
    final String currentVersion=getCurrentProjectVersion();
    final String featureName=featureBranchName.replaceFirst(gitFlowConfig.getFeatureBranchPrefix(),""String_Node_Str"");
    if (currentVersion.contains(""String_Node_Str"" + featureName)) {
      final String version=currentVersion.replaceFirst(""String_Node_Str"" + featureName,""String_Node_Str"");
      mvnSetVersions(version);
      gitCommit(""String_Node_Str"");
    }
    if (installProject) {
      mvnCleanInstall();
    }
    if (!keepBranch) {
      gitBranchDelete(featureBranchName);
    }
  }
 catch (  CommandLineException e) {
    getLog().error(e);
  }
}",0.9726415094339622
32245,"/** 
 * {@inheritDoc} 
 */
@Override public void execute() throws MojoExecutionException, MojoFailureException {
  try {
    checkUncommittedChanges();
    final String hotfixBranches=executeGitCommandReturn(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + gitFlowConfig.getHotfixBranchPrefix() + ""String_Node_Str"");
    if (StringUtils.isBlank(hotfixBranches)) {
      throw new MojoFailureException(""String_Node_Str"");
    }
    String[] branches=hotfixBranches.split(""String_Node_Str"");
    List<String> numberedList=new ArrayList<String>();
    StringBuilder str=new StringBuilder(""String_Node_Str"").append(LS);
    for (int i=0; i < branches.length; i++) {
      str.append((i + 1) + ""String_Node_Str"" + branches[i]+ LS);
      numberedList.add(""String_Node_Str"" + (i + 1));
    }
    str.append(""String_Node_Str"");
    String hotfixNumber=null;
    try {
      while (StringUtils.isBlank(hotfixNumber)) {
        hotfixNumber=prompter.prompt(str.toString(),numberedList);
      }
    }
 catch (    PrompterException e) {
      getLog().error(e);
    }
    String hotfixBranchName=null;
    if (hotfixNumber != null) {
      int num=Integer.parseInt(hotfixNumber);
      hotfixBranchName=branches[num - 1];
    }
    if (StringUtils.isBlank(hotfixBranchName)) {
      throw new MojoFailureException(""String_Node_Str"");
    }
    gitCheckout(hotfixBranchName);
    if (!skipTestProject) {
      mvnCleanTest();
    }
    gitCheckout(gitFlowConfig.getProductionBranch());
    gitMergeNoff(hotfixBranchName);
    if (!skipTag) {
      gitTag(gitFlowConfig.getVersionTagPrefix() + hotfixBranchName.replaceFirst(gitFlowConfig.getHotfixBranchPrefix(),""String_Node_Str""),""String_Node_Str"");
    }
    final String releaseBranch=executeGitCommandReturn(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + gitFlowConfig.getReleaseBranchPrefix() + ""String_Node_Str"");
    if (StringUtils.isNotBlank(releaseBranch)) {
      gitCheckout(releaseBranch);
      gitMergeNoff(hotfixBranchName);
    }
 else {
      gitCheckout(gitFlowConfig.getDevelopmentBranch());
      gitMergeNoff(hotfixBranchName);
      final String currentVersion=getCurrentProjectVersion();
      String nextSnapshotVersion=null;
      try {
        final DefaultVersionInfo versionInfo=new DefaultVersionInfo(currentVersion);
        nextSnapshotVersion=versionInfo.getNextVersion().getSnapshotVersionString();
      }
 catch (      VersionParseException e) {
        if (getLog().isDebugEnabled()) {
          getLog().debug(e);
        }
      }
      if (StringUtils.isBlank(nextSnapshotVersion)) {
        throw new MojoFailureException(""String_Node_Str"");
      }
      mvnSetVersions(nextSnapshotVersion);
      gitCommit(""String_Node_Str"");
    }
    if (installProject) {
      mvnCleanInstall();
    }
    if (!keepBranch) {
      gitBranchDelete(hotfixBranchName);
    }
  }
 catch (  CommandLineException e) {
    getLog().error(e);
  }
}","/** 
 * {@inheritDoc} 
 */
@Override public void execute() throws MojoExecutionException, MojoFailureException {
  try {
    checkUncommittedChanges();
    final String hotfixBranches=gitFindBranches(gitFlowConfig.getHotfixBranchPrefix());
    if (StringUtils.isBlank(hotfixBranches)) {
      throw new MojoFailureException(""String_Node_Str"");
    }
    String[] branches=hotfixBranches.split(""String_Node_Str"");
    List<String> numberedList=new ArrayList<String>();
    StringBuilder str=new StringBuilder(""String_Node_Str"").append(LS);
    for (int i=0; i < branches.length; i++) {
      str.append((i + 1) + ""String_Node_Str"" + branches[i]+ LS);
      numberedList.add(""String_Node_Str"" + (i + 1));
    }
    str.append(""String_Node_Str"");
    String hotfixNumber=null;
    try {
      while (StringUtils.isBlank(hotfixNumber)) {
        hotfixNumber=prompter.prompt(str.toString(),numberedList);
      }
    }
 catch (    PrompterException e) {
      getLog().error(e);
    }
    String hotfixBranchName=null;
    if (hotfixNumber != null) {
      int num=Integer.parseInt(hotfixNumber);
      hotfixBranchName=branches[num - 1];
    }
    if (StringUtils.isBlank(hotfixBranchName)) {
      throw new MojoFailureException(""String_Node_Str"");
    }
    gitCheckout(hotfixBranchName);
    if (!skipTestProject) {
      mvnCleanTest();
    }
    gitCheckout(gitFlowConfig.getProductionBranch());
    gitMergeNoff(hotfixBranchName);
    if (!skipTag) {
      gitTag(gitFlowConfig.getVersionTagPrefix() + hotfixBranchName.replaceFirst(gitFlowConfig.getHotfixBranchPrefix(),""String_Node_Str""),""String_Node_Str"");
    }
    final String releaseBranch=executeGitCommandReturn(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + gitFlowConfig.getReleaseBranchPrefix() + ""String_Node_Str"");
    if (StringUtils.isNotBlank(releaseBranch)) {
      gitCheckout(releaseBranch);
      gitMergeNoff(hotfixBranchName);
    }
 else {
      gitCheckout(gitFlowConfig.getDevelopmentBranch());
      gitMergeNoff(hotfixBranchName);
      final String currentVersion=getCurrentProjectVersion();
      String nextSnapshotVersion=null;
      try {
        final DefaultVersionInfo versionInfo=new DefaultVersionInfo(currentVersion);
        nextSnapshotVersion=versionInfo.getNextVersion().getSnapshotVersionString();
      }
 catch (      VersionParseException e) {
        if (getLog().isDebugEnabled()) {
          getLog().debug(e);
        }
      }
      if (StringUtils.isBlank(nextSnapshotVersion)) {
        throw new MojoFailureException(""String_Node_Str"");
      }
      mvnSetVersions(nextSnapshotVersion);
      gitCommit(""String_Node_Str"");
    }
    if (installProject) {
      mvnCleanInstall();
    }
    if (!keepBranch) {
      gitBranchDelete(hotfixBranchName);
    }
  }
 catch (  CommandLineException e) {
    getLog().error(e);
  }
}",0.9800068941744228
32246,"/** 
 * {@inheritDoc} 
 */
@Override public void execute() throws MojoExecutionException, MojoFailureException {
  try {
    checkUncommittedChanges();
    final String releaseBranches=executeGitCommandReturn(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + gitFlowConfig.getReleaseBranchPrefix() + ""String_Node_Str"");
    String releaseVersion=null;
    if (StringUtils.isBlank(releaseBranches)) {
      throw new MojoFailureException(""String_Node_Str"");
    }
 else     if (StringUtils.countMatches(releaseBranches,gitFlowConfig.getReleaseBranchPrefix()) > 1) {
      throw new MojoFailureException(""String_Node_Str"");
    }
 else {
      releaseVersion=releaseBranches.trim().substring(releaseBranches.lastIndexOf(gitFlowConfig.getReleaseBranchPrefix()) + gitFlowConfig.getReleaseBranchPrefix().length());
    }
    if (StringUtils.isBlank(releaseVersion)) {
      throw new MojoFailureException(""String_Node_Str"");
    }
    gitCheckout(releaseBranches.trim());
    if (!skipTestProject) {
      mvnCleanTest();
    }
    gitCheckout(gitFlowConfig.getProductionBranch());
    gitMergeNoff(gitFlowConfig.getReleaseBranchPrefix() + releaseVersion);
    if (!skipTag) {
      gitTag(gitFlowConfig.getVersionTagPrefix() + releaseVersion,""String_Node_Str"");
    }
    gitCheckout(gitFlowConfig.getDevelopmentBranch());
    gitMergeNoff(gitFlowConfig.getReleaseBranchPrefix() + releaseVersion);
    final String currentVersion=getCurrentProjectVersion();
    String nextSnapshotVersion=null;
    try {
      final DefaultVersionInfo versionInfo=new DefaultVersionInfo(currentVersion);
      nextSnapshotVersion=versionInfo.getNextVersion().getSnapshotVersionString();
    }
 catch (    VersionParseException e) {
      if (getLog().isDebugEnabled()) {
        getLog().debug(e);
      }
    }
    if (StringUtils.isBlank(nextSnapshotVersion)) {
      throw new MojoFailureException(""String_Node_Str"");
    }
    mvnSetVersions(nextSnapshotVersion);
    gitCommit(""String_Node_Str"");
    if (installProject) {
      mvnCleanInstall();
    }
    if (!keepBranch) {
      gitBranchDelete(gitFlowConfig.getReleaseBranchPrefix() + releaseVersion);
    }
  }
 catch (  CommandLineException e) {
    getLog().error(e);
  }
}","/** 
 * {@inheritDoc} 
 */
@Override public void execute() throws MojoExecutionException, MojoFailureException {
  try {
    checkUncommittedChanges();
    final String releaseBranches=gitFindBranches(gitFlowConfig.getReleaseBranchPrefix());
    String releaseVersion=null;
    if (StringUtils.isBlank(releaseBranches)) {
      throw new MojoFailureException(""String_Node_Str"");
    }
 else     if (StringUtils.countMatches(releaseBranches,gitFlowConfig.getReleaseBranchPrefix()) > 1) {
      throw new MojoFailureException(""String_Node_Str"");
    }
 else {
      releaseVersion=releaseBranches.trim().substring(releaseBranches.lastIndexOf(gitFlowConfig.getReleaseBranchPrefix()) + gitFlowConfig.getReleaseBranchPrefix().length());
    }
    if (StringUtils.isBlank(releaseVersion)) {
      throw new MojoFailureException(""String_Node_Str"");
    }
    gitCheckout(releaseBranches.trim());
    if (!skipTestProject) {
      mvnCleanTest();
    }
    gitCheckout(gitFlowConfig.getProductionBranch());
    gitMergeNoff(gitFlowConfig.getReleaseBranchPrefix() + releaseVersion);
    if (!skipTag) {
      gitTag(gitFlowConfig.getVersionTagPrefix() + releaseVersion,""String_Node_Str"");
    }
    gitCheckout(gitFlowConfig.getDevelopmentBranch());
    gitMergeNoff(gitFlowConfig.getReleaseBranchPrefix() + releaseVersion);
    final String currentVersion=getCurrentProjectVersion();
    String nextSnapshotVersion=null;
    try {
      final DefaultVersionInfo versionInfo=new DefaultVersionInfo(currentVersion);
      nextSnapshotVersion=versionInfo.getNextVersion().getSnapshotVersionString();
    }
 catch (    VersionParseException e) {
      if (getLog().isDebugEnabled()) {
        getLog().debug(e);
      }
    }
    if (StringUtils.isBlank(nextSnapshotVersion)) {
      throw new MojoFailureException(""String_Node_Str"");
    }
    mvnSetVersions(nextSnapshotVersion);
    gitCommit(""String_Node_Str"");
    if (installProject) {
      mvnCleanInstall();
    }
    if (!keepBranch) {
      gitBranchDelete(gitFlowConfig.getReleaseBranchPrefix() + releaseVersion);
    }
  }
 catch (  CommandLineException e) {
    getLog().error(e);
  }
}",0.1522935779816513
32247,"/** 
 * Checks uncommitted changes.
 * @throws MojoFailureException
 */
protected void checkUncommittedChanges() throws MojoFailureException {
  if (executeGitHasUncommitted()) {
    throw new MojoFailureException(""String_Node_Str"");
  }
}","/** 
 * Checks uncommitted changes.
 * @throws MojoFailureException
 * @throws CommandLineException
 */
protected void checkUncommittedChanges() throws MojoFailureException, CommandLineException {
  if (executeGitHasUncommitted()) {
    throw new MojoFailureException(""String_Node_Str"");
  }
}",0.8984962406015038
32248,"/** 
 * Executes Git command.
 * @param args Git command line arguments.
 * @throws CommandLineException
 * @throws MojoFailureException
 */
protected void executeGitCommand(final String... args) throws CommandLineException, MojoFailureException {
  executeCommand(cmdGit,false,args);
}","/** 
 * Executes Git command.
 * @param args Git command line arguments.
 * @throws CommandLineException
 * @throws MojoFailureException
 */
protected void executeGitCommand(final String... args) throws CommandLineException, MojoFailureException {
  executeCommand(cmdGit,false,false,args);
}",0.9896193771626296
32249,"/** 
 * Executes Git command and returns output.
 * @param args Git command line arguments.
 * @return Command output.
 * @throws CommandLineException
 * @throws MojoFailureException
 */
protected String executeGitCommandReturn(final String... args) throws CommandLineException, MojoFailureException {
  return executeCommand(cmdGit,true,args);
}","/** 
 * Executes Git command and returns output.
 * @param args Git command line arguments.
 * @return Command output.
 * @throws CommandLineException
 * @throws MojoFailureException
 */
protected String executeGitCommandReturn(final String... args) throws CommandLineException, MojoFailureException {
  return executeCommand(cmdGit,true,false,args);
}",0.991404011461318
32250,"/** 
 * Executes Git commands to check for uncommitted changes.
 * @return <code>true</code> when there are uncommitted changes,<code>false</code> otherwise.
 */
protected boolean executeGitHasUncommitted(){
  try {
    executeGitCommand(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    final String untracked=executeGitCommandReturn(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    if (StringUtils.isNotBlank(untracked)) {
      return true;
    }
  }
 catch (  Exception e) {
    return true;
  }
  return false;
}","/** 
 * Executes Git commands to check for uncommitted changes.
 * @return <code>true</code> when there are uncommitted changes,<code>false</code> otherwise.
 * @throws CommandLineException
 * @throws MojoFailureException
 */
protected boolean executeGitHasUncommitted() throws MojoFailureException, CommandLineException {
  boolean uncommited=false;
  final String diffExitCode=executeGitCommandExitCode(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  if (""String_Node_Str"".equals(diffExitCode)) {
    final String diffIndexExitCode=executeGitCommandExitCode(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    if (!""String_Node_Str"".equals(diffIndexExitCode)) {
      uncommited=true;
    }
  }
 else {
    uncommited=true;
  }
  return uncommited;
}",0.6299435028248588
32251,"/** 
 * Executes Maven command.
 * @param args Maven command line arguments.
 * @throws CommandLineException
 * @throws MojoFailureException
 */
protected void executeMvnCommand(final String... args) throws CommandLineException, MojoFailureException {
  executeCommand(cmdMvn,false,args);
}","/** 
 * Executes Maven command.
 * @param args Maven command line arguments.
 * @throws CommandLineException
 * @throws MojoFailureException
 */
protected void executeMvnCommand(final String... args) throws CommandLineException, MojoFailureException {
  executeCommand(cmdMvn,false,false,args);
}",0.9897610921501706
32252,"/** 
 * Executes command line.
 * @param cmd Command line.
 * @param returnOut Whether to return output. When <code>true</code> the output will not be printed into the console and will be returned from this method.
 * @param args Command line arguments.
 * @return Output of the command or empty String depending on the @paramreturnOut value.
 * @throws CommandLineException
 * @throws MojoFailureException
 */
private String executeCommand(final Commandline cmd,final boolean returnOut,final String... args) throws CommandLineException, MojoFailureException {
  initExecutables();
  if (getLog().isDebugEnabled()) {
    getLog().debug(cmd.getExecutable() + ""String_Node_Str"" + StringUtils.join(args,""String_Node_Str""));
  }
  cmd.clearArgs();
  cmd.addArguments(args);
  StreamConsumer out=null;
  if (returnOut) {
    out=new CommandLineUtils.StringStreamConsumer();
  }
 else {
    out=new DefaultConsumer();
  }
  CommandLineUtils.StringStreamConsumer err=new CommandLineUtils.StringStreamConsumer();
  final int exitCode=CommandLineUtils.executeCommandLine(cmd,out,err);
  if (exitCode != 0) {
    throw new MojoFailureException(err.getOutput());
  }
  String ret=""String_Node_Str"";
  if (returnOut && out instanceof StringStreamConsumer) {
    ret=((StringStreamConsumer)out).getOutput();
  }
  return ret;
}","/** 
 * Executes command line.
 * @param cmd Command line.
 * @param returnOut Whether to return output. When <code>true</code> the output will not be printed into the console and will be returned from this method.
 * @param returnExitCode If <code>true</code> the exit code of the command will be returned, if <code>false</code> the output of the command will be returned. Will not have effect if the <code>returnOut</code> parameter is set to <code>false</code>.
 * @param args Command line arguments.
 * @return Output of the command or exit code or empty String depending onthe parameters values.
 * @throws CommandLineException
 * @throws MojoFailureException If <code>returnExitCode</code> is <code>false</code> and command exit code is NOT equals to 0.
 */
private String executeCommand(final Commandline cmd,final boolean returnOut,final boolean returnExitCode,final String... args) throws CommandLineException, MojoFailureException {
  initExecutables();
  if (getLog().isDebugEnabled()) {
    getLog().debug(cmd.getExecutable() + ""String_Node_Str"" + StringUtils.join(args,""String_Node_Str""));
  }
  cmd.clearArgs();
  cmd.addArguments(args);
  StreamConsumer out=null;
  if (returnOut) {
    out=new CommandLineUtils.StringStreamConsumer();
  }
 else {
    out=new DefaultConsumer();
  }
  CommandLineUtils.StringStreamConsumer err=new CommandLineUtils.StringStreamConsumer();
  final int exitCode=CommandLineUtils.executeCommandLine(cmd,out,err);
  if (!returnExitCode && exitCode != 0) {
    throw new MojoFailureException(err.getOutput());
  }
  String ret=""String_Node_Str"";
  if (returnOut) {
    if (returnExitCode) {
      ret=""String_Node_Str"" + exitCode;
    }
 else     if (out instanceof StringStreamConsumer) {
      ret=((StringStreamConsumer)out).getOutput();
    }
  }
  return ret;
}",0.744796669868716
32253,"@Override public void onSend(Device device,CommandType type,int frequency,int timezone,int radius,String phoneNumber,String message,String rawCommand){
  Command command=new Command();
  command.setType(type);
  command.setDeviceId((int)device.getId());
  command.setAttributes(new HashMap<String,Object>());
switch (type) {
case positionPeriodic:
    command.getAttributes().put(CommandType.KEY_FREQUENCY,frequency);
  break;
case setTimezone:
command.getAttributes().put(CommandType.KEY_TIMEZONE,timezone);
break;
case movementAlarm:
command.getAttributes().put(CommandType.KEY_RADIUS,radius);
break;
case sendSms:
command.getAttributes().put(CommandType.KEY_PHONE_NUMBER,phoneNumber);
command.getAttributes().put(CommandType.KEY_MESSAGE,message);
break;
case CUSTOM:
command.setCommand(rawCommand);
break;
}
final Messages i18n=GWT.create(Messages.class);
RequestBuilder builder=new RequestBuilder(RequestBuilder.POST,""String_Node_Str"");
try {
builder.sendRequest(""String_Node_Str"" + commandMapper.write(command) + ""String_Node_Str"",new RequestCallback(){
@Override public void onResponseReceived(Request request,Response response){
new LogViewDialog(""String_Node_Str"" + response.getText() + ""String_Node_Str"").show();
}
@Override public void onError(Request request,Throwable exception){
new AlertMessageBox(i18n.error(),i18n.errRemoteCall());
}
}
);
}
 catch (RequestException e) {
new AlertMessageBox(i18n.error(),e.getLocalizedMessage());
e.printStackTrace();
}
}","@Override public void onSend(Device device,CommandType type,int frequency,int timezone,int radius,String phoneNumber,String message,String rawCommand){
  Command command=new Command();
  command.setType(type);
  command.setDeviceId((int)device.getId());
  command.setAttributes(new HashMap<String,Object>());
switch (type) {
case positionPeriodic:
    command.getAttributes().put(CommandType.KEY_FREQUENCY,frequency);
  break;
case setTimezone:
command.getAttributes().put(CommandType.KEY_TIMEZONE,timezone);
break;
case movementAlarm:
command.getAttributes().put(CommandType.KEY_RADIUS,radius);
break;
case sendSms:
command.getAttributes().put(CommandType.KEY_PHONE_NUMBER,phoneNumber);
command.getAttributes().put(CommandType.KEY_MESSAGE,message);
break;
case custom:
command.setCommand(rawCommand);
break;
}
final Messages i18n=GWT.create(Messages.class);
RequestBuilder builder=new RequestBuilder(RequestBuilder.POST,""String_Node_Str"");
try {
builder.sendRequest(""String_Node_Str"" + commandMapper.write(command) + ""String_Node_Str"",new RequestCallback(){
@Override public void onResponseReceived(Request request,Response response){
new LogViewDialog(""String_Node_Str"" + response.getText() + ""String_Node_Str"").show();
}
@Override public void onError(Request request,Throwable exception){
new AlertMessageBox(i18n.error(),i18n.errRemoteCall());
}
}
);
}
 catch (RequestException e) {
new AlertMessageBox(i18n.error(),e.getLocalizedMessage());
e.printStackTrace();
}
}",0.9959183673469388
32254,"private void toggleUI(CommandType type){
  lblFrequency.setVisible(type == CommandType.positionPeriodic);
  frequency.setVisible(type == CommandType.positionPeriodic);
  frequencyUnit.setVisible(type == CommandType.positionPeriodic);
  lblCustomMessage.setVisible(type == CommandType.CUSTOM);
  customMessage.setVisible(type == CommandType.CUSTOM);
  lblTimeZone.setVisible(type == CommandType.setTimezone);
  timeZone.setVisible(type == CommandType.setTimezone);
  lblRadius.setVisible(type == CommandType.movementAlarm);
  radius.setVisible(type == CommandType.movementAlarm);
  lblPhoneNumber.setVisible(type == CommandType.sendSms);
  phoneNumber.setVisible(type == CommandType.sendSms);
  lblMessage.setVisible(type == CommandType.sendSms);
  message.setVisible(type == CommandType.sendSms);
  window.forceLayout();
}","private void toggleUI(CommandType type){
  lblFrequency.setVisible(type == CommandType.positionPeriodic);
  frequency.setVisible(type == CommandType.positionPeriodic);
  frequencyUnit.setVisible(type == CommandType.positionPeriodic);
  lblCustomMessage.setVisible(type == CommandType.custom);
  customMessage.setVisible(type == CommandType.custom);
  lblTimeZone.setVisible(type == CommandType.setTimezone);
  timeZone.setVisible(type == CommandType.setTimezone);
  lblRadius.setVisible(type == CommandType.movementAlarm);
  radius.setVisible(type == CommandType.movementAlarm);
  lblPhoneNumber.setVisible(type == CommandType.sendSms);
  phoneNumber.setVisible(type == CommandType.sendSms);
  lblMessage.setVisible(type == CommandType.sendSms);
  message.setVisible(type == CommandType.sendSms);
  window.forceLayout();
}",0.9720194647201946
32255,"private void initMapLayers(Map map){
  for (  UserSettings.MapType mapType : UserSettings.MapType.values()) {
    if (mapType.isBing() && (ApplicationContext.getInstance().getApplicationSettings().getBingMapsKey() == null || ApplicationContext.getInstance().getApplicationSettings().getBingMapsKey().trim().isEmpty())) {
      continue;
    }
    map.addLayer(createMap(mapType));
  }
}","private void initMapLayers(Map map){
  for (  UserSettings.MapType mapType : UserSettings.MapType.values()) {
    if (mapType.isBing() && (ApplicationContext.getInstance().getApplicationSettings().getBingMapsKey() == null || ApplicationContext.getInstance().getApplicationSettings().getBingMapsKey().trim().isEmpty())) {
      continue;
    }
    Layer mapLayer=createMap(mapType);
    try {
      map.addLayer(mapLayer);
    }
 catch (    Exception ex) {
      GWT.log(""String_Node_Str"" + mapType,ex);
      map.removeLayer(mapLayer);
    }
  }
}",0.7888531618435155
32256,"@Override public void serialize(DeviceIconType deviceIcon,JsonGenerator json,SerializerProvider serializerProvider) throws IOException {
  json.writeStartObject();
  for (  Position.Status status : Position.Status.values()) {
    json.writeObjectFieldStart(status.name());
    PositionIconType positionIcon=deviceIcon.getPositionIconType(status);
    json.writeNumberField(""String_Node_Str"",positionIcon.getWidth());
    json.writeNumberField(""String_Node_Str"",positionIcon.getHeight());
    json.writeArrayFieldStart(""String_Node_Str"");
    json.writeString(positionIcon.getURL(false));
    json.writeString(positionIcon.getURL(true));
    json.writeEndArray();
    json.writeEndObject();
  }
  json.writeEndObject();
}","@Override public void serialize(DeviceIconType deviceIcon,JsonGenerator json,SerializerProvider serializerProvider) throws IOException {
  json.writeStartObject();
  json.writeStringField(""String_Node_Str"",deviceIcon.name());
  for (  Position.Status status : Position.Status.values()) {
    json.writeObjectFieldStart(status.name());
    PositionIconType positionIcon=deviceIcon.getPositionIconType(status);
    json.writeNumberField(""String_Node_Str"",positionIcon.getWidth());
    json.writeNumberField(""String_Node_Str"",positionIcon.getHeight());
    json.writeArrayFieldStart(""String_Node_Str"");
    json.writeString(positionIcon.getURL(false));
    json.writeString(positionIcon.getURL(true));
    json.writeEndArray();
    json.writeEndObject();
  }
  json.writeEndObject();
}",0.9587217043941412
32257,"static ObjectMapper create(){
  ObjectMapper mapper=new ObjectMapper();
  mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
  mapper.enable(SerializationFeature.INDENT_OUTPUT);
  mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
  SimpleDateFormat dateFormat=new SimpleDateFormat(""String_Node_Str"");
  mapper.setDateFormat(dateFormat);
  mapper.getDeserializationConfig().with(dateFormat);
  SimpleModule module=new SimpleModule();
  module.addSerializer(DeviceIconType.class,new DeviceIconTypeSerializer());
  mapper.registerModule(module);
  return mapper;
}","static ObjectMapper create(){
  ObjectMapper mapper=new ObjectMapper();
  mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
  mapper.enable(SerializationFeature.INDENT_OUTPUT);
  mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
  SimpleDateFormat dateFormat=new SimpleDateFormat(""String_Node_Str"");
  mapper.setDateFormat(dateFormat);
  mapper.getDeserializationConfig().with(dateFormat);
  SimpleModule module=new SimpleModule();
  module.addSerializer(DeviceIconType.class,new DeviceIconTypeSerializer());
  module.addDeserializer(DeviceIconType.class,new DeviceIconTypeDeserializer());
  mapper.registerModule(module);
  return mapper;
}",0.935560859188544
32258,"private void makeRestCall(ObjectMapper gson,HttpServletResponse response,String methodName,Object[] args) throws IOException {
  try {
    Class<?>[] argClasses=new Class<?>[args == null ? 0 : args.length];
    if (args != null) {
      for (int i=0; i < args.length; i++) {
        argClasses[i]=args[i] == null ? null : args[i].getClass();
      }
    }
    Method method=null;
    try {
      method=dataService.getClass().getDeclaredMethod(methodName,argClasses);
    }
 catch (    NoSuchMethodException nsme) {
      for (      Method declaredMethod : dataService.getClass().getDeclaredMethods()) {
        if (declaredMethod.getName().equals(methodName) && declaredMethod.getParameterTypes().length == args.length) {
          for (int i=0; i < args.length; i++) {
            Class<?> expectedType=declaredMethod.getParameterTypes()[i];
            if (argClasses[i] != null && argClasses[i] != expectedType) {
              if (argClasses[i] == String.class) {
                if (args[i].toString().equals(""String_Node_Str"")) {
                  args[i]=null;
                }
 else                 if (Date.class.isAssignableFrom(expectedType)) {
                  args[i]=requestDateFormat.get().parse(args[i].toString());
                }
 else {
                  args[i]=gson.readValue(""String_Node_Str"" + args[i].toString() + ""String_Node_Str"",expectedType);
                }
              }
 else {
                args[i]=gson.readValue(gson.writeValueAsString(args[i]),expectedType);
              }
            }
          }
          method=declaredMethod;
          break;
        }
      }
      if (method == null) {
        throw new NoSuchMethodException();
      }
    }
    Object result=method.invoke(dataService,args);
    if (result != null) {
      if (!response.containsHeader(""String_Node_Str"")) {
        response.setHeader(""String_Node_Str"",""String_Node_Str"");
      }
      response.setCharacterEncoding(""String_Node_Str"");
      String s=gson.writeValueAsString(result);
      response.getWriter().write(s);
    }
  }
 catch (  ParseException pe) {
    log(""String_Node_Str"" + pe.getLocalizedMessage());
    try {
      response.sendError(HttpServletResponse.SC_BAD_REQUEST);
    }
 catch (    Exception ex) {
    }
  }
catch (  NoSuchMethodException nsme) {
    log(""String_Node_Str"" + methodName);
    try {
      response.sendError(HttpServletResponse.SC_NOT_FOUND);
    }
 catch (    Exception ex) {
    }
  }
catch (  IllegalArgumentException iae) {
    log(""String_Node_Str"" + methodName + ""String_Node_Str""+ iae.getLocalizedMessage());
    try {
      response.sendError(HttpServletResponse.SC_NOT_FOUND);
    }
 catch (    Exception ex) {
    }
  }
catch (  InvocationTargetException ite) {
    log(""String_Node_Str"" + methodName + ""String_Node_Str""+ ite.getLocalizedMessage(),ite);
    int errorCode=0;
    if (ite.getCause() instanceof SecurityException) {
      errorCode=HttpServletResponse.SC_UNAUTHORIZED;
    }
 else {
      errorCode=HttpServletResponse.SC_INTERNAL_SERVER_ERROR;
    }
    try {
      response.sendError(errorCode);
    }
 catch (    Exception ex) {
    }
  }
catch (  IllegalAccessException iae) {
    log(""String_Node_Str"" + methodName + ""String_Node_Str"");
    try {
      response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
    }
 catch (    Exception ex) {
    }
  }
catch (  Exception ex) {
    log(""String_Node_Str"" + methodName + ""String_Node_Str"",ex);
  }
}","private void makeRestCall(ObjectMapper gson,HttpServletResponse response,String methodName,Object[] args) throws IOException {
  try {
    Class<?>[] argClasses=new Class<?>[args == null ? 0 : args.length];
    if (args != null) {
      for (int i=0; i < args.length; i++) {
        argClasses[i]=args[i] == null ? null : args[i].getClass();
      }
    }
    Method method=null;
    try {
      method=dataService.getClass().getDeclaredMethod(methodName,argClasses);
    }
 catch (    NoSuchMethodException nsme) {
      for (      Method declaredMethod : dataService.getClass().getDeclaredMethods()) {
        if (declaredMethod.getName().equals(methodName) && declaredMethod.getParameterTypes().length == args.length) {
          for (int i=0; i < args.length; i++) {
            Class<?> expectedType=declaredMethod.getParameterTypes()[i];
            if (argClasses[i] != null && argClasses[i] != expectedType) {
              if (argClasses[i] == String.class) {
                if (args[i].toString().equals(""String_Node_Str"")) {
                  args[i]=null;
                }
 else                 if (Date.class.isAssignableFrom(expectedType)) {
                  args[i]=requestDateFormat.get().parse(args[i].toString());
                }
 else {
                  args[i]=gson.readValue(""String_Node_Str"" + args[i].toString() + ""String_Node_Str"",expectedType);
                }
              }
 else {
                args[i]=gson.readValue(gson.writeValueAsString(args[i]),expectedType);
              }
            }
          }
          method=declaredMethod;
          break;
        }
      }
      if (method == null) {
        throw new NoSuchMethodException();
      }
    }
    Object result=method.invoke(dataService,args);
    if (result != null) {
      if (!response.containsHeader(""String_Node_Str"")) {
        response.setHeader(""String_Node_Str"",""String_Node_Str"");
      }
      response.setCharacterEncoding(""String_Node_Str"");
      String s=gson.writeValueAsString(result);
      response.getWriter().write(s);
    }
  }
 catch (  ParseException pe) {
    log(""String_Node_Str"" + pe.getLocalizedMessage());
    try {
      response.sendError(HttpServletResponse.SC_BAD_REQUEST);
    }
 catch (    Exception ex) {
    }
  }
catch (  NoSuchMethodException nsme) {
    log(""String_Node_Str"" + methodName);
    try {
      response.sendError(HttpServletResponse.SC_NOT_FOUND);
    }
 catch (    Exception ex) {
    }
  }
catch (  IllegalArgumentException iae) {
    log(""String_Node_Str"" + methodName + ""String_Node_Str""+ iae.getLocalizedMessage());
    try {
      response.sendError(HttpServletResponse.SC_NOT_FOUND);
    }
 catch (    Exception ex) {
    }
  }
catch (  InvocationTargetException ite) {
    log(""String_Node_Str"" + methodName + ""String_Node_Str""+ ite.getLocalizedMessage(),ite);
    int errorCode=0;
    if (ite.getCause() instanceof SecurityException) {
      errorCode=HttpServletResponse.SC_UNAUTHORIZED;
    }
 else {
      errorCode=HttpServletResponse.SC_INTERNAL_SERVER_ERROR;
    }
    try {
      response.sendError(errorCode);
    }
 catch (    Exception ex) {
    }
  }
catch (  IllegalAccessException iae) {
    log(""String_Node_Str"" + methodName + ""String_Node_Str"");
    try {
      response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
    }
 catch (    Exception ex) {
    }
  }
catch (  Exception ex) {
    log(""String_Node_Str"" + methodName + ""String_Node_Str"",ex);
    try {
      response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
    }
 catch (    Exception e) {
    }
  }
}",0.9819268535648216
32259,"private void testDefaultPositionIconType(JsonNode jsonDeviceIconType,Position.Status status,String iconTypeString){
  PositionIconType positionIconType=DeviceIconType.DEFAULT.getPositionIconType(status);
  JsonNode jsonPositionIconType=jsonDeviceIconType.get(iconTypeString);
  assertEquals(positionIconType.getWidth(),jsonPositionIconType.get(""String_Node_Str"").asInt());
  assertEquals(positionIconType.getHeight(),jsonPositionIconType.get(""String_Node_Str"").asInt());
  Iterator<JsonNode> urls=jsonPositionIconType.get(""String_Node_Str"").elements();
  assertEquals(positionIconType.getURL(false),urls.next().asText());
  assertEquals(positionIconType.getURL(true),urls.next().asText());
}","private void testDefaultPositionIconType(JsonNode jsonDeviceIconType,Position.Status status,String iconTypeString){
  PositionIconType positionIconType=DeviceIconType.DEFAULT.getPositionIconType(status);
  JsonNode jsonPositionIconType=jsonDeviceIconType.get(iconTypeString);
  assertEquals(positionIconType.getWidth(),jsonPositionIconType.get(""String_Node_Str"").asInt());
  assertEquals(positionIconType.getHeight(),jsonPositionIconType.get(""String_Node_Str"").asInt());
  Iterator<JsonNode> urls=jsonPositionIconType.get(""String_Node_Str"").elements();
  assertEquals(positionIconType.getURL(false),urls.next().asText());
  assertEquals(positionIconType.getURL(true),urls.next().asText());
  assertEquals(DeviceIconType.DEFAULT.name(),jsonDeviceIconType.get(""String_Node_Str"").asText());
}",0.9337837837837838
32260,"public void update(){
  updateTimer.cancel();
  Application.getDataService().getLatestPositions(new AsyncCallback<List<Position>>(){
    @Override public void onSuccess(    List<Position> result){
      updateFailureCount=0;
      alertsMap.clear();
      long currentTime=System.currentTimeMillis();
      int selectedIndex=-1;
      for (int i=0; i < result.size(); i++) {
        Position position=result.get(i);
        Device device=position.getDevice();
        if (device.equals(selectedDevice)) {
          selectedIndex=i;
        }
        long timeout=(long)position.getDevice().getTimeout() * 1000;
        boolean isOffline=currentTime - position.getTime().getTime() > timeout;
        position.setStatus(isOffline ? Position.Status.OFFLINE : Position.Status.LATEST);
        position.setIcon(MarkerIcon.create(position).setName(device.isShowName()));
        deviceVisibilityHandler.offlineStatusChanged(device,isOffline);
        if (position.getIdleStatus() == Position.IdleStatus.MOVING) {
          deviceVisibilityHandler.moving(device);
        }
 else         if (position.getIdleStatus() == Position.IdleStatus.IDLE) {
          deviceVisibilityHandler.idle(device);
        }
        device=deviceStore.findModelWithKey(Long.toString(device.getId()));
        device.setOdometer(position.getDistance());
        for (        Maintenance maintenance : device.getMaintenances()) {
          if (device.getOdometer() >= maintenance.getLastService() + maintenance.getServiceInterval()) {
            alertsMap.put(device.getId(),position);
            break;
          }
        }
      }
      if (selectedIndex >= 0) {
        result.add(result.remove(selectedIndex));
      }
      mapView.clearLatestPositions();
      mapView.showLatestPositions(result,alertsMap.values());
      for (      Position position : result) {
        Device device=position.getDevice();
        Position prevPosition=latestPositionMap.get(device.getId());
        if (prevPosition != null && prevPosition.getId() != position.getId()) {
          if (ApplicationContext.getInstance().isFollowing(device)) {
            mapView.catchPosition(position);
            mapView.zoomIn(device);
          }
          if (ApplicationContext.getInstance().isRecordingTrace(device)) {
            mapView.showLatestTrackPositions(Collections.singletonList(prevPosition));
            mapView.showLatestTrack(new Track(Arrays.asList(prevPosition,position)));
            Short traceInterval=ApplicationContext.getInstance().getUserSettings().getTraceInterval();
            if (traceInterval != null) {
              mapView.clearLatestTrackPositions(device,new Date(position.getTime().getTime() - traceInterval * 60 * 1000));
            }
          }
        }
        if (ApplicationContext.getInstance().isRecordingTrace(device)) {
          Position prevTimestampPosition=timestampMap.get(device.getId());
          if (prevTimestampPosition == null || (position.getTime().getTime() - prevTimestampPosition.getTime().getTime() >= ApplicationContext.getInstance().getUserSettings().getTimePrintInterval() * 60 * 1000)) {
            mapView.showLatestTime(Collections.singletonList(position));
            timestampMap.put(device.getId(),position);
          }
        }
        latestPositionMap.put(device.getId(),position);
      }
      updateTimer.schedule(ApplicationContext.getInstance().getApplicationSettings().getUpdateInterval());
    }
    @Override public void onFailure(    Throwable caught){
      if (++updateFailureCount == 3) {
        updateTimer.cancel();
        String msg=i18n.errUserDisconnected();
        if (caught instanceof StatusCodeException) {
          StatusCodeException e=(StatusCodeException)caught;
          if (e.getStatusCode() == 500) {
            msg=i18n.errUserSessionExpired();
          }
        }
        AlertMessageBox msgBox=new AlertMessageBox(i18n.error(),msg);
        msgBox.addDialogHideHandler(new DialogHideEvent.DialogHideHandler(){
          @Override public void onDialogHide(          DialogHideEvent event){
            Window.Location.reload();
          }
        }
);
        msgBox.show();
      }
 else {
        updateTimer.schedule(ApplicationContext.getInstance().getApplicationSettings().getUpdateInterval());
      }
    }
  }
);
}","public void update(){
  updateTimer.cancel();
  Application.getDataService().getLatestPositions(new AsyncCallback<List<Position>>(){
    @Override public void onSuccess(    List<Position> result){
      updateFailureCount=0;
      alertsMap.clear();
      long currentTime=System.currentTimeMillis();
      int selectedIndex=-1;
      for (int i=0; i < result.size(); i++) {
        Position position=result.get(i);
        Device device=position.getDevice();
        if (device.equals(selectedDevice)) {
          selectedIndex=i;
        }
        long timeout=(long)position.getDevice().getTimeout() * 1000;
        boolean isOffline=currentTime - position.getTime().getTime() > timeout;
        position.setStatus(isOffline ? Position.Status.OFFLINE : Position.Status.LATEST);
        position.setIcon(MarkerIcon.create(position).setName(device.isShowName()));
        deviceVisibilityHandler.offlineStatusChanged(device,isOffline);
        if (position.getIdleStatus() == Position.IdleStatus.MOVING) {
          deviceVisibilityHandler.moving(device);
        }
 else         if (position.getIdleStatus() == Position.IdleStatus.IDLE) {
          deviceVisibilityHandler.idle(device);
        }
        Device storedDevice=deviceStore.findModelWithKey(Long.toString(device.getId()));
        if (storedDevice != null) {
          storedDevice.setOdometer(position.getDistance());
          for (          Maintenance maintenance : storedDevice.getMaintenances()) {
            if (storedDevice.getOdometer() >= maintenance.getLastService() + maintenance.getServiceInterval()) {
              alertsMap.put(device.getId(),position);
              break;
            }
          }
        }
      }
      if (selectedIndex >= 0) {
        result.add(result.remove(selectedIndex));
      }
      mapView.clearLatestPositions();
      mapView.showLatestPositions(result,alertsMap.values());
      for (      Position position : result) {
        Device device=position.getDevice();
        Position prevPosition=latestPositionMap.get(device.getId());
        if (prevPosition != null && prevPosition.getId() != position.getId()) {
          if (ApplicationContext.getInstance().isFollowing(device)) {
            mapView.catchPosition(position);
            mapView.zoomIn(device);
          }
          if (ApplicationContext.getInstance().isRecordingTrace(device)) {
            mapView.showLatestTrackPositions(Collections.singletonList(prevPosition));
            mapView.showLatestTrack(new Track(Arrays.asList(prevPosition,position)));
            Short traceInterval=ApplicationContext.getInstance().getUserSettings().getTraceInterval();
            if (traceInterval != null) {
              mapView.clearLatestTrackPositions(device,new Date(position.getTime().getTime() - traceInterval * 60 * 1000));
            }
          }
        }
        if (ApplicationContext.getInstance().isRecordingTrace(device)) {
          Position prevTimestampPosition=timestampMap.get(device.getId());
          if (prevTimestampPosition == null || (position.getTime().getTime() - prevTimestampPosition.getTime().getTime() >= ApplicationContext.getInstance().getUserSettings().getTimePrintInterval() * 60 * 1000)) {
            mapView.showLatestTime(Collections.singletonList(position));
            timestampMap.put(device.getId(),position);
          }
        }
        latestPositionMap.put(device.getId(),position);
      }
      updateTimer.schedule(ApplicationContext.getInstance().getApplicationSettings().getUpdateInterval());
    }
    @Override public void onFailure(    Throwable caught){
      if (++updateFailureCount == 3) {
        updateTimer.cancel();
        String msg=i18n.errUserDisconnected();
        if (caught instanceof StatusCodeException) {
          StatusCodeException e=(StatusCodeException)caught;
          if (e.getStatusCode() == 500) {
            msg=i18n.errUserSessionExpired();
          }
        }
        AlertMessageBox msgBox=new AlertMessageBox(i18n.error(),msg);
        msgBox.addDialogHideHandler(new DialogHideEvent.DialogHideHandler(){
          @Override public void onDialogHide(          DialogHideEvent event){
            Window.Location.reload();
          }
        }
);
        msgBox.show();
      }
 else {
        updateTimer.schedule(ApplicationContext.getInstance().getApplicationSettings().getUpdateInterval());
      }
    }
  }
);
}",0.988381456344185
32261,"@Override public void onSuccess(List<Position> result){
  updateFailureCount=0;
  alertsMap.clear();
  long currentTime=System.currentTimeMillis();
  int selectedIndex=-1;
  for (int i=0; i < result.size(); i++) {
    Position position=result.get(i);
    Device device=position.getDevice();
    if (device.equals(selectedDevice)) {
      selectedIndex=i;
    }
    long timeout=(long)position.getDevice().getTimeout() * 1000;
    boolean isOffline=currentTime - position.getTime().getTime() > timeout;
    position.setStatus(isOffline ? Position.Status.OFFLINE : Position.Status.LATEST);
    position.setIcon(MarkerIcon.create(position).setName(device.isShowName()));
    deviceVisibilityHandler.offlineStatusChanged(device,isOffline);
    if (position.getIdleStatus() == Position.IdleStatus.MOVING) {
      deviceVisibilityHandler.moving(device);
    }
 else     if (position.getIdleStatus() == Position.IdleStatus.IDLE) {
      deviceVisibilityHandler.idle(device);
    }
    device=deviceStore.findModelWithKey(Long.toString(device.getId()));
    device.setOdometer(position.getDistance());
    for (    Maintenance maintenance : device.getMaintenances()) {
      if (device.getOdometer() >= maintenance.getLastService() + maintenance.getServiceInterval()) {
        alertsMap.put(device.getId(),position);
        break;
      }
    }
  }
  if (selectedIndex >= 0) {
    result.add(result.remove(selectedIndex));
  }
  mapView.clearLatestPositions();
  mapView.showLatestPositions(result,alertsMap.values());
  for (  Position position : result) {
    Device device=position.getDevice();
    Position prevPosition=latestPositionMap.get(device.getId());
    if (prevPosition != null && prevPosition.getId() != position.getId()) {
      if (ApplicationContext.getInstance().isFollowing(device)) {
        mapView.catchPosition(position);
        mapView.zoomIn(device);
      }
      if (ApplicationContext.getInstance().isRecordingTrace(device)) {
        mapView.showLatestTrackPositions(Collections.singletonList(prevPosition));
        mapView.showLatestTrack(new Track(Arrays.asList(prevPosition,position)));
        Short traceInterval=ApplicationContext.getInstance().getUserSettings().getTraceInterval();
        if (traceInterval != null) {
          mapView.clearLatestTrackPositions(device,new Date(position.getTime().getTime() - traceInterval * 60 * 1000));
        }
      }
    }
    if (ApplicationContext.getInstance().isRecordingTrace(device)) {
      Position prevTimestampPosition=timestampMap.get(device.getId());
      if (prevTimestampPosition == null || (position.getTime().getTime() - prevTimestampPosition.getTime().getTime() >= ApplicationContext.getInstance().getUserSettings().getTimePrintInterval() * 60 * 1000)) {
        mapView.showLatestTime(Collections.singletonList(position));
        timestampMap.put(device.getId(),position);
      }
    }
    latestPositionMap.put(device.getId(),position);
  }
  updateTimer.schedule(ApplicationContext.getInstance().getApplicationSettings().getUpdateInterval());
}","@Override public void onSuccess(List<Position> result){
  updateFailureCount=0;
  alertsMap.clear();
  long currentTime=System.currentTimeMillis();
  int selectedIndex=-1;
  for (int i=0; i < result.size(); i++) {
    Position position=result.get(i);
    Device device=position.getDevice();
    if (device.equals(selectedDevice)) {
      selectedIndex=i;
    }
    long timeout=(long)position.getDevice().getTimeout() * 1000;
    boolean isOffline=currentTime - position.getTime().getTime() > timeout;
    position.setStatus(isOffline ? Position.Status.OFFLINE : Position.Status.LATEST);
    position.setIcon(MarkerIcon.create(position).setName(device.isShowName()));
    deviceVisibilityHandler.offlineStatusChanged(device,isOffline);
    if (position.getIdleStatus() == Position.IdleStatus.MOVING) {
      deviceVisibilityHandler.moving(device);
    }
 else     if (position.getIdleStatus() == Position.IdleStatus.IDLE) {
      deviceVisibilityHandler.idle(device);
    }
    Device storedDevice=deviceStore.findModelWithKey(Long.toString(device.getId()));
    if (storedDevice != null) {
      storedDevice.setOdometer(position.getDistance());
      for (      Maintenance maintenance : storedDevice.getMaintenances()) {
        if (storedDevice.getOdometer() >= maintenance.getLastService() + maintenance.getServiceInterval()) {
          alertsMap.put(device.getId(),position);
          break;
        }
      }
    }
  }
  if (selectedIndex >= 0) {
    result.add(result.remove(selectedIndex));
  }
  mapView.clearLatestPositions();
  mapView.showLatestPositions(result,alertsMap.values());
  for (  Position position : result) {
    Device device=position.getDevice();
    Position prevPosition=latestPositionMap.get(device.getId());
    if (prevPosition != null && prevPosition.getId() != position.getId()) {
      if (ApplicationContext.getInstance().isFollowing(device)) {
        mapView.catchPosition(position);
        mapView.zoomIn(device);
      }
      if (ApplicationContext.getInstance().isRecordingTrace(device)) {
        mapView.showLatestTrackPositions(Collections.singletonList(prevPosition));
        mapView.showLatestTrack(new Track(Arrays.asList(prevPosition,position)));
        Short traceInterval=ApplicationContext.getInstance().getUserSettings().getTraceInterval();
        if (traceInterval != null) {
          mapView.clearLatestTrackPositions(device,new Date(position.getTime().getTime() - traceInterval * 60 * 1000));
        }
      }
    }
    if (ApplicationContext.getInstance().isRecordingTrace(device)) {
      Position prevTimestampPosition=timestampMap.get(device.getId());
      if (prevTimestampPosition == null || (position.getTime().getTime() - prevTimestampPosition.getTime().getTime() >= ApplicationContext.getInstance().getUserSettings().getTimePrintInterval() * 60 * 1000)) {
        mapView.showLatestTime(Collections.singletonList(position));
        timestampMap.put(device.getId(),position);
      }
    }
    latestPositionMap.put(device.getId(),position);
  }
  updateTimer.schedule(ApplicationContext.getInstance().getApplicationSettings().getUpdateInterval());
}",0.9849148418491483
32262,"public void flush(){
  if (iconModeIcon.getValue()) {
    device.setIconMode(DeviceIconMode.ICON);
  }
 else   if (iconModeArrow.getValue()) {
    device.setIconMode(DeviceIconMode.ARROW);
  }
  device.setIconRotation(iconRotation.getValue());
  device.setShowName(showName.getValue());
  for (  ColorSelector colorSelector : arrowColors) {
    colorSelector.flush(device);
  }
  selected=view.getSelectionModel().getSelectedItem();
  device.setIconType(selected.getBuiltInIcon());
  device.setIcon(selected.getDatabaseIcon());
}","public void flush(){
  if (iconModeIcon.getValue()) {
    device.setIconMode(DeviceIconMode.ICON);
  }
 else   if (iconModeArrow.getValue()) {
    device.setIconMode(DeviceIconMode.ARROW);
  }
  device.setIconRotation(iconRotation.getValue());
  device.setShowName(showName.getValue());
  for (  ColorSelector colorSelector : arrowColors) {
    colorSelector.flush(device);
  }
  selected=view.getSelectionModel().getSelectedItem();
  if (selected != null) {
    device.setIconType(selected.getBuiltInIcon());
    device.setIcon(selected.getDatabaseIcon());
  }
}",0.9688644688644688
32263,"List<Device> devices(GroupedDevice node){
  List<Device> result=new ArrayList<>();
  for (  GroupedDevice child : deviceStore.getAllChildren(node)) {
    if (child instanceof Device) {
      result.add((Device)child);
    }
  }
  return result;
}","List<Device> devices(GroupedDevice node){
  if (deviceStore.contains(node)) {
    List<Device> result=new ArrayList<>();
    for (    GroupedDevice child : deviceStore.getAllChildren(node)) {
      if (child instanceof Device) {
        result.add((Device)child);
      }
    }
    return result;
  }
 else {
    return Collections.emptyList();
  }
}",0.802013422818792
32264,"@Override public void onRemove(StoreRemoveEvent event){
  pendingDevices.addAll(devices((GroupedDevice)event.getItem()));
  Group parent=(Group)deviceStore.getParent((GroupedDevice)event.getItem());
  deviceStore.remove((GroupedDevice)event.getItem());
  if (parent != null) {
    removeGroupsIfEmpty(parent);
  }
}","@Override public void onRemove(StoreRemoveEvent event){
  GroupedDevice node=(GroupedDevice)event.getItem();
  if (deviceStore.contains(node)) {
    pendingDevices.addAll(devices(node));
    Group parent=(Group)deviceStore.getParent(node);
    deviceStore.remove(node);
    if (parent != null) {
      removeGroupsIfEmpty(parent);
    }
  }
}",0.5053272450532724
32265,"public void setDescription(String description){
  this.description=description;
}","@JsonProperty public void setDescription(String description){
  this.description=description;
}",0.9204545454545454
32266,"public String getDescription(){
  return description;
}","@JsonIgnore public String getDescription(){
  return description;
}",0.9016393442622952
32267,"public void setRadius(float radius){
  this.radius=radius;
}","@JsonProperty public void setRadius(float radius){
  this.radius=radius;
}",0.8955223880597015
32268,"public String getPoints(){
  return points;
}","@JsonIgnore public String getPoints(){
  return points;
}",0.8823529411764706
32269,"public void setPoints(String points){
  this.points=points;
}","@JsonProperty public void setPoints(String points){
  this.points=points;
}",0.8970588235294118
32270,"public void setType(GeoFenceType type){
  this.type=type;
}","@JsonProperty public void setType(GeoFenceType type){
  this.type=type;
}",0.8939393939393939
32271,"public float getRadius(){
  return radius;
}","@JsonIgnore public float getRadius(){
  return radius;
}",0.88
32272,"public GeoFenceType getType(){
  return type;
}","@JsonIgnore public GeoFenceType getType(){
  return type;
}",0.8867924528301887
32273,"@Override void before(){
  previousIdlePositions=new HashMap<>();
}","@Override void before(){
  if (previousIdlePositions == null) {
    previousIdlePositions=new HashMap<>();
  }
}",0.7486033519553073
32274,"@Transactional @Override public void doWork() throws Exception {
  if (lastScannedPositionId == null) {
    List<Long> latestPositionId=entityManager.get().createQuery(""String_Node_Str"",Long.class).getResultList();
    if (latestPositionId.isEmpty() || latestPositionId.get(0) == null) {
      return;
    }
 else {
      lastScannedPositionId=latestPositionId.get(0);
    }
  }
  List<Position> positions=entityManager.get().createQuery(""String_Node_Str"",Position.class).setParameter(""String_Node_Str"",lastScannedPositionId).getResultList();
  Date currentDate=new Date();
  for (  EventProducer eventProducer : eventProducers) {
    eventProducer.setCurrentDate(currentDate);
    eventProducer.before();
  }
  Position prevPosition=null;
  Device device=null;
  DeviceState state=null;
  for (  Position position : positions) {
    if (device == null || device.getId() != position.getDevice().getId()) {
      device=position.getDevice();
      state=deviceState.get(device.getId());
      if (state == null || state.latestPositionId == null) {
        state=new DeviceState();
        deviceState.put(device.getId(),state);
        prevPosition=null;
      }
 else {
        prevPosition=entityManager.get().find(Position.class,state.latestPositionId);
      }
    }
    for (int i=0; i < eventProducers.size(); i++) {
      eventProducers.get(i).positionScanned(prevPosition,position);
    }
    state.latestPositionId=position.getId();
    prevPosition=position;
    lastScannedPositionId=Math.max(lastScannedPositionId,position.getId());
  }
  for (  EventProducer eventProducer : eventProducers) {
    eventProducer.after();
  }
}","@Transactional @Override public void doWork() throws Exception {
  List<Position> positions=positionProvider.getPositions();
  Date currentDate=new Date();
  for (  EventProducer eventProducer : eventProducers) {
    eventProducer.setCurrentDate(currentDate);
    eventProducer.before();
  }
  Position prevPosition=null;
  Device device=null;
  DeviceState state=null;
  for (  Position position : positions) {
    if (device == null || device.getId() != position.getDevice().getId()) {
      device=position.getDevice();
      state=deviceState.get(device.getId());
      if (state == null || state.latestPositionId == null) {
        state=new DeviceState();
        deviceState.put(device.getId(),state);
        prevPosition=null;
      }
 else {
        prevPosition=entityManager.get().find(Position.class,state.latestPositionId);
      }
    }
    for (int i=0; i < eventProducers.size(); i++) {
      eventProducers.get(i).positionScanned(prevPosition,position);
    }
    state.latestPositionId=position.getId();
    prevPosition=position;
    positionProvider.setLastScannedPositionId(Math.max(positionProvider.getLastScannedPositionId(),position.getId()));
  }
  for (  EventProducer eventProducer : eventProducers) {
    eventProducer.after();
  }
}",0.3621938599517075
32275,"@Override void after(){
  previousIdlePositions=null;
}","@Override void after(){
}",0.625
32276,"public User(User user){
  id=user.id;
  admin=user.admin;
  login=user.login;
  password=user.password;
  password_hash_method=user.password_hash_method;
  manager=user.manager;
  email=user.email;
  userSettings=user.userSettings;
  notifications=user.notifications;
  if (user.notificationEvents != null) {
    transferNotificationEvents=new HashSet<DeviceEventType>(user.notificationEvents);
  }
  maxNumOfDevices=user.maxNumOfDevices;
  readOnly=user.readOnly;
  archive=user.archive;
  companyName=user.companyName;
  firstName=user.firstName;
  lastName=user.lastName;
  phoneNumber=user.phoneNumber;
}","public User(User user){
  id=user.id;
  admin=user.admin;
  login=user.login;
  password=user.password;
  password_hash_method=user.password_hash_method;
  manager=user.manager;
  email=user.email;
  userSettings=user.userSettings;
  notifications=user.notifications;
  if (user.notificationEvents != null) {
    transferNotificationEvents=new HashSet<DeviceEventType>(user.notificationEvents);
  }
  maxNumOfDevices=user.maxNumOfDevices;
  expirationDate=user.expirationDate;
  blocked=user.blocked;
  readOnly=user.readOnly;
  archive=user.archive;
  companyName=user.companyName;
  firstName=user.firstName;
  lastName=user.lastName;
  phoneNumber=user.phoneNumber;
}",0.9514866979655712
32277,"public ReportsDialog(ListStore<Report> reportStore,ListStore<Device> deviceStore,ListStore<GeoFence> geoFenceStore,ReportHandler reportHandler){
  ReportProperties reportProperties=GWT.create(ReportProperties.class);
  this.reportStore=reportStore;
  this.reportHandler=reportHandler;
  List<ColumnConfig<Report,?>> columnConfigList=new LinkedList<ColumnConfig<Report,?>>();
  columnConfigList.add(new ColumnConfig<Report,String>(reportProperties.name(),25,i18n.name()));
  columnConfigList.add(new ColumnConfig<Report,String>(new ReportProperties.ReportTypeLabelProvider(),25,i18n.type()));
  columnModel=new ColumnModel<Report>(columnConfigList);
  DeviceProperties deviceProperties=GWT.create(DeviceProperties.class);
  this.deviceStore=deviceStore;
  this.devicesList=new ListView<Device,String>(deviceStore,deviceProperties.name());
  GeoFenceProperties geoFenceProperties=GWT.create(GeoFenceProperties.class);
  this.geoFenceStore=geoFenceStore;
  this.geoFencesList=new ListView<GeoFence,String>(geoFenceStore,geoFenceProperties.name());
  ListStore<ReportType> geoFenceTypeStore=new ListStore<ReportType>(new EnumKeyProvider<ReportType>());
  geoFenceTypeStore.addAll(Arrays.asList(ReportType.values()));
  type=new ComboBox<ReportType>(geoFenceTypeStore,new ReportProperties.ReportTypeLabelProvider());
  type.setForceSelection(true);
  type.setTriggerAction(ComboBoxCell.TriggerAction.ALL);
  period=new PeriodComboBox();
  uiBinder.createAndBindUi(this);
  grid.getSelectionModel().setSelectionMode(Style.SelectionMode.SINGLE);
  grid.getSelectionModel().addSelectionChangedHandler(new SelectionChangedEvent.SelectionChangedHandler<Report>(){
    @Override public void onSelectionChanged(    SelectionChangedEvent<Report> event){
      if (event.getSelection().isEmpty()) {
        driver.edit(new Report());
      }
 else {
        driver.edit(event.getSelection().get(0));
      }
      removeButton.setEnabled(!event.getSelection().isEmpty());
    }
  }
);
  period.init(fromDateField,fromTimeField,toDateField,toTimeField);
  geoFences=new ListViewEditor<GeoFence>(geoFencesList);
  devices=new ListViewEditor<Device>(devicesList);
  fromDate=new DateTimeEditor(fromDateField,fromTimeField);
  toDate=new DateTimeEditor(toDateField,toTimeField);
  driver.initialize(this);
  driver.edit(new Report());
  period.selectFirst();
}","public ReportsDialog(ListStore<Report> reportStore,ListStore<Device> deviceStore,ListStore<GeoFence> geoFenceStore,ReportHandler reportHandler){
  ReportProperties reportProperties=GWT.create(ReportProperties.class);
  this.reportStore=reportStore;
  this.reportHandler=reportHandler;
  List<ColumnConfig<Report,?>> columnConfigList=new LinkedList<ColumnConfig<Report,?>>();
  columnConfigList.add(new ColumnConfig<Report,String>(reportProperties.name(),25,i18n.name()));
  columnConfigList.add(new ColumnConfig<Report,String>(new ReportProperties.ReportTypeLabelProvider(),25,i18n.type()));
  columnModel=new ColumnModel<Report>(columnConfigList);
  DeviceProperties deviceProperties=GWT.create(DeviceProperties.class);
  this.deviceStore=deviceStore;
  this.devicesList=new ListView<Device,String>(deviceStore,deviceProperties.name());
  GeoFenceProperties geoFenceProperties=GWT.create(GeoFenceProperties.class);
  this.geoFenceStore=geoFenceStore;
  this.geoFencesList=new ListView<GeoFence,String>(geoFenceStore,geoFenceProperties.name());
  ListStore<ReportType> geoFenceTypeStore=new ListStore<ReportType>(new EnumKeyProvider<ReportType>());
  geoFenceTypeStore.addAll(Arrays.asList(ReportType.values()));
  type=new ComboBox<ReportType>(geoFenceTypeStore,new ReportProperties.ReportTypeLabelProvider());
  type.setForceSelection(true);
  type.setTriggerAction(ComboBoxCell.TriggerAction.ALL);
  period=new PeriodComboBox();
  uiBinder.createAndBindUi(this);
  grid.getSelectionModel().setSelectionMode(Style.SelectionMode.SINGLE);
  grid.getSelectionModel().addSelectionChangedHandler(new SelectionChangedEvent.SelectionChangedHandler<Report>(){
    @Override public void onSelectionChanged(    SelectionChangedEvent<Report> event){
      Report report=event.getSelection().isEmpty() ? new Report() : event.getSelection().get(0);
      driver.edit(report);
      if (event.getSelection().isEmpty()) {
        period.selectFirst();
      }
 else {
        period.update();
      }
      updateGeoFencesListState();
      removeButton.setEnabled(!event.getSelection().isEmpty());
    }
  }
);
  type.addSelectionHandler(new SelectionHandler<ReportType>(){
    @Override public void onSelection(    SelectionEvent<ReportType> event){
      updateGeoFencesListState();
    }
  }
);
  period.init(fromDateField,fromTimeField,toDateField,toTimeField);
  geoFencesPanel.setHeadingText(i18n.overlayType(UserSettings.OverlayType.GEO_FENCES));
  geoFences=new ListViewEditor<GeoFence>(geoFencesList);
  devices=new ListViewEditor<Device>(devicesList);
  fromDate=new DateTimeEditor(fromDateField,fromTimeField);
  toDate=new DateTimeEditor(toDateField,toTimeField);
  driver.initialize(this);
  driver.edit(new Report());
  period.selectFirst();
}",0.8960094358167879
32278,"@Override public void onSelectionChanged(SelectionChangedEvent<Report> event){
  if (event.getSelection().isEmpty()) {
    driver.edit(new Report());
  }
 else {
    driver.edit(event.getSelection().get(0));
  }
  removeButton.setEnabled(!event.getSelection().isEmpty());
}","@Override public void onSelectionChanged(SelectionChangedEvent<Report> event){
  Report report=event.getSelection().isEmpty() ? new Report() : event.getSelection().get(0);
  driver.edit(report);
  if (event.getSelection().isEmpty()) {
    period.selectFirst();
  }
 else {
    period.update();
  }
  updateGeoFencesListState();
  removeButton.setEnabled(!event.getSelection().isEmpty());
}",0.6344410876132931
32279,"@UiHandler(""String_Node_Str"") public void onGenerateClicked(SelectEvent event){
  reportHandler.onGenerate(driver.flush());
}","@UiHandler(""String_Node_Str"") public void onGenerateClicked(SelectEvent event){
  Report report=driver.flush();
  if (!driver.hasErrors()) {
    reportHandler.onGenerate(report);
  }
}",0.7378640776699029
32280,"private List<Device> getDevices(boolean full){
  User user=getSessionUser();
  List<Device> devices;
  if (user.getAdmin()) {
    devices=getSessionEntityManager().createQuery(""String_Node_Str"",Device.class).getResultList();
  }
 else {
    devices=new LinkedList<Device>(user.getAllAvailableDevices());
  }
  if (full) {
    List<Maintenance> maintenaces=getSessionEntityManager().createQuery(""String_Node_Str"",Maintenance.class).setParameter(""String_Node_Str"",devices).getResultList();
    for (    Maintenance maintenance : maintenaces) {
      Device device=maintenance.getDevice();
      if (device.getMaintenances() == null) {
        device.setMaintenances(new ArrayList<Maintenance>());
      }
      device.getMaintenances().add(maintenance);
    }
    List<Sensor> sensors=getSessionEntityManager().createQuery(""String_Node_Str"",Sensor.class).setParameter(""String_Node_Str"",devices).getResultList();
    for (    Sensor sensor : sensors) {
      Device device=sensor.getDevice();
      if (device.getSensors() == null) {
        device.setSensors(new ArrayList<Sensor>());
      }
      device.getSensors().add(sensor);
    }
    for (    Device device : devices) {
      if (device.getMaintenances() == null) {
        device.setMaintenances(Collections.<Maintenance>emptyList());
      }
      if (device.getSensors() == null) {
        device.setSensors(Collections.<Sensor>emptyList());
      }
    }
  }
  return devices;
}","private List<Device> getDevices(boolean full){
  User user=getSessionUser();
  List<Device> devices;
  if (user.getAdmin()) {
    devices=getSessionEntityManager().createQuery(""String_Node_Str"",Device.class).getResultList();
  }
 else {
    devices=new LinkedList<Device>(user.getAllAvailableDevices());
  }
  if (full && !devices.isEmpty()) {
    List<Maintenance> maintenaces=getSessionEntityManager().createQuery(""String_Node_Str"",Maintenance.class).setParameter(""String_Node_Str"",devices).getResultList();
    for (    Maintenance maintenance : maintenaces) {
      Device device=maintenance.getDevice();
      if (device.getMaintenances() == null) {
        device.setMaintenances(new ArrayList<Maintenance>());
      }
      device.getMaintenances().add(maintenance);
    }
    List<Sensor> sensors=getSessionEntityManager().createQuery(""String_Node_Str"",Sensor.class).setParameter(""String_Node_Str"",devices).getResultList();
    for (    Sensor sensor : sensors) {
      Device device=sensor.getDevice();
      if (device.getSensors() == null) {
        device.setSensors(new ArrayList<Sensor>());
      }
      device.getSensors().add(sensor);
    }
    for (    Device device : devices) {
      if (device.getMaintenances() == null) {
        device.setMaintenances(Collections.<Maintenance>emptyList());
      }
      if (device.getSensors() == null) {
        device.setSensors(Collections.<Sensor>emptyList());
      }
    }
  }
  return devices;
}",0.9924085576259488
32281,"private User fillUserSettings(User user){
  if (user.getUserSettings() instanceof HibernateProxy) {
    UserSettings settings=(UserSettings)((HibernateProxy)user.getUserSettings()).getHibernateLazyInitializer().getImplementation();
    user.setUserSettings(settings);
  }
  return user;
}","private User fillUserSettings(User user){
  if (user.getUserSettings() instanceof HibernateProxy) {
    user.setUserSettings(unproxy(user.getUserSettings()));
  }
  return user;
}",0.715203426124197
32282,"@Transactional @RequireUser(roles={Role.ADMIN,Role.MANAGER}) @Override public List<User> getUsers(){
  User currentUser=getSessionUser();
  List<User> users=new LinkedList<User>();
  if (currentUser.getAdmin()) {
    users.addAll(getSessionEntityManager().createQuery(""String_Node_Str"",User.class).getResultList());
  }
 else {
    users.addAll(currentUser.getAllManagedUsers());
  }
  for (  User user : users) {
    fillUserSettings(user);
  }
  return users;
}","@Transactional @RequireUser(roles={Role.ADMIN,Role.MANAGER}) @Override public List<User> getUsers(){
  User currentUser=getSessionUser();
  List<User> users=new LinkedList<User>();
  if (currentUser.getAdmin()) {
    users.addAll(getSessionEntityManager().createQuery(""String_Node_Str"",User.class).getResultList());
  }
 else {
    users.addAll(currentUser.getAllManagedUsers());
  }
  List<User> result=new ArrayList<User>(users.size());
  for (  User user : users) {
    result.add(fillUserSettings(unproxy(user)));
  }
  return result;
}",0.9072781655034896
32283,"public void showAlerts(List<Position> positions){
  for (  VectorFeature alert : alertMap.values()) {
    getVectorLayer().removeFeature(alert);
    alert.destroy();
  }
  alertMap.clear();
  if (positions != null) {
    for (    Position position : positions) {
      drawAlert(position);
    }
  }
}","public void showAlerts(List<Position> positions){
  if (positions != null) {
    for (    Position position : positions) {
      drawAlert(position);
    }
  }
}",0.696969696969697
32284,"private void drawAlert(Position position){
  int iconWidthHalf=position.getIconType().getWidth() / 2;
  int iconHeight=position.getIconType().getHeight();
  Style alertCircleStyle=new org.gwtopenmaps.openlayers.client.Style();
  alertCircleStyle.setPointRadius(Math.sqrt(iconWidthHalf * iconWidthHalf + iconHeight * iconHeight) + 1);
  alertCircleStyle.setFillOpacity(0d);
  alertCircleStyle.setStrokeWidth(2d);
  alertCircleStyle.setStrokeColor(""String_Node_Str"");
  VectorFeature alertCircle=new VectorFeature(mapView.createPoint(position.getLongitude(),position.getLatitude()),alertCircleStyle);
  getVectorLayer().addFeature(alertCircle);
  alertMap.put(position.getDevice().getId(),alertCircle);
}","private void drawAlert(Position position){
  DeviceData deviceData=getDeviceData(position.getDevice());
  int iconWidthHalf=position.getIcon().getWidth() / 2;
  int iconHeight=position.getIcon().getHeight();
  Style alertCircleStyle=new org.gwtopenmaps.openlayers.client.Style();
  alertCircleStyle.setPointRadius(Math.sqrt(iconWidthHalf * iconWidthHalf + iconHeight * iconHeight) + 1);
  alertCircleStyle.setFillOpacity(0d);
  alertCircleStyle.setStrokeWidth(2d);
  alertCircleStyle.setStrokeColor(""String_Node_Str"");
  VectorFeature alertCircle=new VectorFeature(mapView.createPoint(position.getLongitude(),position.getLatitude()),alertCircleStyle);
  getVectorLayer().addFeature(alertCircle);
  deviceData.alert=alertCircle;
}",0.8958770090845563
32285,"public void updateAlert(Device device,boolean show){
  VectorFeature alert=alertMap.remove(device.getId());
  if (alert != null) {
    getVectorLayer().removeFeature(alert);
    alert.destroy();
  }
  if (show) {
    Long latestPositionId=deviceMap.get(device.getId());
    Position latestPosition=positionMap.get(latestPositionId);
    if (latestPosition != null) {
      drawAlert(latestPosition);
    }
  }
}","public void updateAlert(Device device,boolean show){
  DeviceData deviceData=getDeviceData(device);
  if (deviceData.alert != null) {
    getVectorLayer().removeFeature(deviceData.alert);
    deviceData.alert.destroy();
  }
  if (show) {
    Position latestPosition=deviceData.getLatestPosition();
    if (latestPosition != null) {
      drawAlert(latestPosition);
    }
  }
}",0.6124523506988564
32286,"public void clearLatestPositions(){
  latestPositionRenderer.clearPositionsAndTitles();
}","public void clearLatestPositions(){
  latestPositionRenderer.clearPositionsAndTitlesAndAlerts();
}",0.9518716577540108
32287,"public UserDialog(User user,UserHandler userHandler){
  this.userHandler=userHandler;
  IdentityValueProvider<DeviceEventType> identity=new IdentityValueProvider<DeviceEventType>();
  final CheckBoxSelectionModel<DeviceEventType> selectionModel=new CheckBoxSelectionModel<DeviceEventType>(identity);
  ColumnConfig<DeviceEventType,String> nameCol=new ColumnConfig<DeviceEventType,String>(new ToStringValueProvider<DeviceEventType>(){
    @Override public String getValue(    DeviceEventType object){
      return i18n.deviceEventType(object);
    }
  }
,200,i18n.event());
  List<ColumnConfig<DeviceEventType,?>> columns=new ArrayList<ColumnConfig<DeviceEventType,?>>();
  columns.add(selectionModel.getColumn());
  columns.add(nameCol);
  columnModel=new ColumnModel<DeviceEventType>(columns);
  notificationEventStore=new ListStore<DeviceEventType>(new EnumKeyProvider<DeviceEventType>());
  notificationEventStore.addAll(Arrays.asList(DeviceEventType.values()));
  uiBinder.createAndBindUi(this);
  grid.setSelectionModel(selectionModel);
  grid.getView().setForceFit(true);
  grid.getView().setAutoFill(true);
  for (  DeviceEventType deviceEventType : user.getTransferNotificationEvents()) {
    grid.getSelectionModel().select(deviceEventType,true);
  }
  if (ApplicationContext.getInstance().getUser().getAdmin()) {
    admin.setEnabled(true);
  }
  if (ApplicationContext.getInstance().getUser().getAdmin() || ApplicationContext.getInstance().getUser().getManager()) {
    manager.setEnabled(true);
  }
  email.addValidator(new RegExValidator(""String_Node_Str"",i18n.invalidEmail()));
  driver.initialize(this);
  driver.edit(user);
}","public UserDialog(User user,UserHandler userHandler){
  this.userHandler=userHandler;
  IdentityValueProvider<DeviceEventType> identity=new IdentityValueProvider<DeviceEventType>();
  final CheckBoxSelectionModel<DeviceEventType> selectionModel=new CheckBoxSelectionModel<DeviceEventType>(identity);
  ColumnConfig<DeviceEventType,String> nameCol=new ColumnConfig<DeviceEventType,String>(new ToStringValueProvider<DeviceEventType>(){
    @Override public String getValue(    DeviceEventType object){
      return i18n.deviceEventType(object);
    }
  }
,200,i18n.event());
  List<ColumnConfig<DeviceEventType,?>> columns=new ArrayList<ColumnConfig<DeviceEventType,?>>();
  columns.add(selectionModel.getColumn());
  columns.add(nameCol);
  columnModel=new ColumnModel<DeviceEventType>(columns);
  view=new NoScrollbarGridView<DeviceEventType>();
  view.setAutoFill(true);
  view.setStripeRows(true);
  notificationEventStore=new ListStore<DeviceEventType>(new EnumKeyProvider<DeviceEventType>());
  notificationEventStore.addAll(Arrays.asList(DeviceEventType.values()));
  uiBinder.createAndBindUi(this);
  grid.setSelectionModel(selectionModel);
  grid.getView().setForceFit(true);
  grid.getView().setAutoFill(true);
  for (  DeviceEventType deviceEventType : user.getTransferNotificationEvents()) {
    grid.getSelectionModel().select(deviceEventType,true);
  }
  if (ApplicationContext.getInstance().getUser().getAdmin()) {
    admin.setEnabled(true);
  }
  if (ApplicationContext.getInstance().getUser().getAdmin() || ApplicationContext.getInstance().getUser().getManager()) {
    manager.setEnabled(true);
  }
  email.addValidator(new RegExValidator(""String_Node_Str"",i18n.invalidEmail()));
  driver.initialize(this);
  driver.edit(user);
}",0.9394744611750812
32288,"@Transactional @RequireUser @RequireWrite @ManagesDevices @Override public Device removeDevice(Device device){
  EntityManager entityManager=getSessionEntityManager();
  User user=getSessionUser();
  device=entityManager.find(Device.class,device.getId());
  if (user.getAdmin() || user.getManager()) {
    device.getUsers().removeAll(getUsers());
  }
  device.getUsers().remove(user);
  if (device.getUsers().isEmpty()) {
    device.setLatestPosition(null);
    entityManager.flush();
    Query query=entityManager.createQuery(""String_Node_Str"");
    query.setParameter(""String_Node_Str"",device);
    query.executeUpdate();
    query=entityManager.createQuery(""String_Node_Str"");
    query.setParameter(""String_Node_Str"",device);
    query.executeUpdate();
    entityManager.remove(device);
  }
  return device;
}","@Transactional @RequireUser @RequireWrite @ManagesDevices @Override public Device removeDevice(Device device){
  EntityManager entityManager=getSessionEntityManager();
  User user=getSessionUser();
  device=entityManager.find(Device.class,device.getId());
  if (user.getAdmin() || user.getManager()) {
    device.getUsers().removeAll(getUsers());
  }
  device.getUsers().remove(user);
  if (device.getUsers().isEmpty()) {
    device.setLatestPosition(null);
    entityManager.flush();
    Query query=entityManager.createQuery(""String_Node_Str"");
    query.setParameter(""String_Node_Str"",device);
    query.executeUpdate();
    query=entityManager.createQuery(""String_Node_Str"");
    query.setParameter(""String_Node_Str"",device);
    query.executeUpdate();
    query=entityManager.createQuery(""String_Node_Str"");
    query.setParameter(""String_Node_Str"",device);
    for (    GeoFence geoFence : (List<GeoFence>)query.getResultList()) {
      geoFence.getDevices().remove(device);
    }
    entityManager.remove(device);
  }
  return device;
}",0.84375
32289,"public DeviceController(MapController mapController,DeviceView.SettingsHandler settingsHandler,ListStore<GeoFence> geoFenceStore,StoreHandlers<Device> deviceStoreHandler,Application application){
  this.application=application;
  this.mapController=mapController;
  this.deviceStoreHandler=deviceStoreHandler;
  DeviceProperties deviceProperties=GWT.create(DeviceProperties.class);
  deviceStore=new ListStore<Device>(deviceProperties.id());
  deviceStore.addStoreRecordChangeHandler(new StoreRecordChangeEvent.StoreRecordChangeHandler<Device>(){
    @Override public void onRecordChange(    StoreRecordChangeEvent<Device> event){
      if (event.getProperty().getPath().equals(""String_Node_Str"")) {
        boolean follow=(Boolean)event.getRecord().getValue(event.getProperty());
        Device device=event.getRecord().getModel();
        if (follow) {
          ApplicationContext.getInstance().follow(device);
        }
 else {
          ApplicationContext.getInstance().stopFollowing(device);
        }
      }
 else       if (event.getProperty().getPath().equals(""String_Node_Str"")) {
        boolean recordTrace=(Boolean)event.getRecord().getValue(event.getProperty());
        Device device=event.getRecord().getModel();
        if (recordTrace) {
          ApplicationContext.getInstance().recordTrace(device);
        }
 else {
          ApplicationContext.getInstance().stopRecordingTrace(device);
        }
      }
    }
  }
);
  deviceView=new DeviceView(this,geoFenceHandler,settingsHandler,deviceStore,geoFenceStore);
}","public DeviceController(MapController mapController,DeviceView.GeoFenceHandler geoFenceHandler,DeviceView.SettingsHandler settingsHandler,ListStore<GeoFence> geoFenceStore,StoreHandlers<Device> deviceStoreHandler,Application application){
  this.application=application;
  this.mapController=mapController;
  this.deviceStoreHandler=deviceStoreHandler;
  DeviceProperties deviceProperties=GWT.create(DeviceProperties.class);
  deviceStore=new ListStore<Device>(deviceProperties.id());
  deviceStore.addStoreRecordChangeHandler(new StoreRecordChangeEvent.StoreRecordChangeHandler<Device>(){
    @Override public void onRecordChange(    StoreRecordChangeEvent<Device> event){
      if (event.getProperty().getPath().equals(""String_Node_Str"")) {
        boolean follow=(Boolean)event.getRecord().getValue(event.getProperty());
        Device device=event.getRecord().getModel();
        if (follow) {
          ApplicationContext.getInstance().follow(device);
        }
 else {
          ApplicationContext.getInstance().stopFollowing(device);
        }
      }
 else       if (event.getProperty().getPath().equals(""String_Node_Str"")) {
        boolean recordTrace=(Boolean)event.getRecord().getValue(event.getProperty());
        Device device=event.getRecord().getModel();
        if (recordTrace) {
          ApplicationContext.getInstance().recordTrace(device);
        }
 else {
          ApplicationContext.getInstance().stopRecordingTrace(device);
        }
      }
    }
  }
);
  deviceView=new DeviceView(this,geoFenceHandler,settingsHandler,deviceStore,geoFenceStore);
}",0.9861780777884924
32290,"@Override protected void configureServlets(){
  String persistenceUnit;
  try {
    Context context=new InitialContext();
    context.lookup(PERSISTENCE_DATASTORE);
    persistenceUnit=PERSISTENCE_UNIT_RELEASE;
  }
 catch (  NamingException e) {
    persistenceUnit=PERSISTENCE_UNIT_DEBUG;
  }
  install(new JpaPersistModule(persistenceUnit));
  filter(""String_Node_Str"").through(PersistFilter.class);
  serve(""String_Node_Str"").with(DataServiceImpl.class);
  serve(""String_Node_Str"").with(UIStateServiceImpl.class);
  serve(""String_Node_Str"").with(EventServiceImpl.class);
  serve(""String_Node_Str"").with(NotificationServiceImpl.class);
  serve(""String_Node_Str"").with(RESTApiServlet.class);
  serve(""String_Node_Str"").with(ExportServlet.class);
  serve(""String_Node_Str"").with(ImportServlet.class);
  serve(""String_Node_Str"").with(LoginServlet.class);
  UserCheck userCheck=new UserCheck();
  requestInjection(userCheck);
  bindInterceptor(Matchers.any(),Matchers.annotatedWith(RequireUser.class),userCheck);
  bindInterceptor(Matchers.any(),Matchers.annotatedWith(ManagesDevices.class),userCheck);
  bind(User.class).toProvider(CurrentUserProvider.class);
  bind(ApplicationSettings.class).toProvider(ApplicationSettingsProvider.class);
  bind(DataService.class).to(DataServiceImpl.class);
  bind(EventService.class).to(EventServiceImpl.class);
}","@Override protected void configureServlets(){
  String persistenceUnit;
  try {
    Context context=new InitialContext();
    context.lookup(PERSISTENCE_DATASTORE);
    persistenceUnit=PERSISTENCE_UNIT_RELEASE;
  }
 catch (  NamingException e) {
    persistenceUnit=PERSISTENCE_UNIT_DEBUG;
  }
  install(new JpaPersistModule(persistenceUnit));
  filter(""String_Node_Str"").through(PersistFilter.class);
  serve(""String_Node_Str"").with(DataServiceImpl.class);
  serve(""String_Node_Str"").with(UIStateServiceImpl.class);
  serve(""String_Node_Str"").with(EventServiceImpl.class);
  serve(""String_Node_Str"").with(NotificationServiceImpl.class);
  serve(""String_Node_Str"").with(RESTApiServlet.class);
  serve(""String_Node_Str"").with(ExportServlet.class);
  serve(""String_Node_Str"").with(ImportServlet.class);
  serve(""String_Node_Str"").with(LoginServlet.class);
  UserCheck userCheck=new UserCheck();
  requestInjection(userCheck);
  bindInterceptor(Matchers.any(),Matchers.annotatedWith(RequireUser.class),userCheck);
  bindInterceptor(Matchers.any(),Matchers.annotatedWith(ManagesDevices.class),userCheck);
  bindInterceptor(Matchers.any(),Matchers.annotatedWith(RequireWrite.class),userCheck);
  bind(User.class).toProvider(CurrentUserProvider.class);
  bind(ApplicationSettings.class).toProvider(ApplicationSettingsProvider.class);
  bind(DataService.class).to(DataServiceImpl.class);
  bind(EventService.class).to(EventServiceImpl.class);
}",0.968413496051687
32291,"@Override protected Injector getInjector(){
  return Guice.createInjector(new ServletModule(){
    @Override protected void configureServlets(){
      String persistenceUnit;
      try {
        Context context=new InitialContext();
        context.lookup(PERSISTENCE_DATASTORE);
        persistenceUnit=PERSISTENCE_UNIT_RELEASE;
      }
 catch (      NamingException e) {
        persistenceUnit=PERSISTENCE_UNIT_DEBUG;
      }
      install(new JpaPersistModule(persistenceUnit));
      filter(""String_Node_Str"").through(PersistFilter.class);
      serve(""String_Node_Str"").with(DataServiceImpl.class);
      serve(""String_Node_Str"").with(UIStateServiceImpl.class);
      serve(""String_Node_Str"").with(EventServiceImpl.class);
      serve(""String_Node_Str"").with(NotificationServiceImpl.class);
      serve(""String_Node_Str"").with(RESTApiServlet.class);
      serve(""String_Node_Str"").with(ExportServlet.class);
      serve(""String_Node_Str"").with(ImportServlet.class);
      serve(""String_Node_Str"").with(LoginServlet.class);
      UserCheck userCheck=new UserCheck();
      requestInjection(userCheck);
      bindInterceptor(Matchers.any(),Matchers.annotatedWith(RequireUser.class),userCheck);
      bindInterceptor(Matchers.any(),Matchers.annotatedWith(ManagesDevices.class),userCheck);
      bind(User.class).toProvider(CurrentUserProvider.class);
      bind(ApplicationSettings.class).toProvider(ApplicationSettingsProvider.class);
      bind(DataService.class).to(DataServiceImpl.class);
      bind(EventService.class).to(EventServiceImpl.class);
    }
  }
);
}","@Override protected Injector getInjector(){
  return Guice.createInjector(getModule());
}",0.106151990349819
32292,"void checkRequireUser(RequireUser requireUser){
  User user=sessionUser.get();
  if (user == null) {
    throw new SecurityException(""String_Node_Str"");
  }
  if (requireUser.roles().length > 0) {
    StringBuilder roles=new StringBuilder();
    for (    Role role : requireUser.roles()) {
      if (roles.length() > 0) {
        roles.append(""String_Node_Str"");
      }
      roles.append(role.toString());
      if (role.has(user)) {
        return;
      }
    }
    throw new SecurityException(""String_Node_Str"" + roles + ""String_Node_Str"");
  }
}","void checkRequireUser(RequireUser requireUser){
  if (rolesChecked.get() != null) {
    if (requireUser.roles().length == 0) {
      return;
    }
    Role[] checkedRoles=rolesChecked.get();
    for (    Role role : requireUser.roles()) {
      for (int i=0; i < checkedRoles.length; i++) {
        if (role == checkedRoles[i]) {
          return;
        }
      }
    }
  }
  User user=sessionUser.get();
  if (user == null) {
    throw new SecurityException(""String_Node_Str"");
  }
  if (requireUser.roles().length > 0) {
    StringBuilder roles=new StringBuilder();
    for (    Role role : requireUser.roles()) {
      if (roles.length() > 0) {
        roles.append(""String_Node_Str"");
      }
      roles.append(role.toString());
      if (role.has(user)) {
        rolesChecked.set(requireUser.roles());
        return;
      }
    }
    throw new SecurityException(""String_Node_Str"" + roles + ""String_Node_Str"");
  }
 else {
    rolesChecked.set(requireUser.roles());
  }
}",0.7180156657963447
32293,"void checkRequireWrite(RequireWrite requireWrite){
  User user=sessionUser.get();
  if (user == null) {
    throw new SecurityException(""String_Node_Str"");
  }
  if (user.getReadOnly()) {
    throw new SecurityException(""String_Node_Str"");
  }
}","void checkRequireWrite(RequireWrite requireWrite){
  if (checkedRequireWrite.get() != null) {
    return;
  }
  User user=sessionUser.get();
  if (user == null) {
    throw new SecurityException(""String_Node_Str"");
  }
  if (user.getReadOnly()) {
    throw new SecurityException(""String_Node_Str"");
  }
  checkedRequireWrite.set(Boolean.TRUE);
}",0.8305084745762712
32294,"@Override public Object invoke(MethodInvocation methodInvocation) throws Throwable {
  RequireUser requireUser=methodInvocation.getMethod().getAnnotation(RequireUser.class);
  if (requireUser != null)   checkRequireUser(requireUser);
  ManagesDevices managesDevices=methodInvocation.getMethod().getAnnotation(ManagesDevices.class);
  if (managesDevices != null)   checkDeviceManagementAccess(managesDevices);
  RequireWrite requireWrite=methodInvocation.getMethod().getAnnotation(RequireWrite.class);
  if (requireWrite != null)   checkRequireWrite(requireWrite);
  return methodInvocation.proceed();
}","@Override public Object invoke(MethodInvocation methodInvocation) throws Throwable {
  RequireUser requireUser=methodInvocation.getMethod().getAnnotation(RequireUser.class);
  if (requireUser != null)   checkRequireUser(requireUser);
  ManagesDevices managesDevices=methodInvocation.getMethod().getAnnotation(ManagesDevices.class);
  if (managesDevices != null)   checkDeviceManagementAccess(managesDevices);
  RequireWrite requireWrite=methodInvocation.getMethod().getAnnotation(RequireWrite.class);
  if (requireWrite != null)   checkRequireWrite(requireWrite);
  try {
    return methodInvocation.proceed();
  }
  finally {
    cleanUp();
  }
}",0.9639711769415532
32295,"void checkDeviceManagementAccess(ManagesDevices managesDevices) throws Throwable {
  User user=sessionUser.get();
  if (user == null) {
    throw new SecurityException(""String_Node_Str"");
  }
  if (!user.getAdmin() && !user.getManager()) {
    ApplicationSettings applicationSettings=entityManager.get().createQuery(""String_Node_Str"",ApplicationSettings.class).getSingleResult();
    if (applicationSettings.isDisallowDeviceManagementByUsers()) {
      throw new SecurityException(""String_Node_Str"");
    }
  }
}","void checkDeviceManagementAccess(ManagesDevices managesDevices) throws Throwable {
  if (checkedDeviceManagement.get() != null) {
    return;
  }
  User user=sessionUser.get();
  if (user == null) {
    throw new SecurityException(""String_Node_Str"");
  }
  if (!user.getAdmin() && !user.getManager()) {
    if (applicationSettings.get().isDisallowDeviceManagementByUsers()) {
      throw new SecurityException(""String_Node_Str"");
    }
    checkedDeviceManagement.set(Boolean.TRUE);
  }
}",0.734
32296,"void gpx(HttpServletResponse response,Device device,Date from,Date to,boolean filter) throws IOException, XMLStreamException {
  response.setContentType(""String_Node_Str"");
  response.setHeader(""String_Node_Str"",""String_Node_Str"");
  TimeZone tz=TimeZone.getTimeZone(""String_Node_Str"");
  DateFormat dateFormat=new SimpleDateFormat(""String_Node_Str"");
  dateFormat.setTimeZone(tz);
  XMLStreamWriter xsw=XMLOutputFactory.newFactory().createXMLStreamWriter(response.getOutputStream());
  xsw.writeStartDocument(""String_Node_Str"",""String_Node_Str"");
  xsw.writeStartElement(""String_Node_Str"");
  xsw.writeAttribute(""String_Node_Str"",""String_Node_Str"");
  xsw.writeAttribute(""String_Node_Str"",""String_Node_Str"");
  xsw.writeAttribute(""String_Node_Str"",""String_Node_Str"");
  xsw.writeAttribute(""String_Node_Str"",""String_Node_Str"");
  xsw.writeAttribute(""String_Node_Str"",""String_Node_Str"");
  xsw.writeStartElement(""String_Node_Str"");
  xsw.writeStartElement(""String_Node_Str"");
  xsw.writeAttribute(""String_Node_Str"",""String_Node_Str"");
  xsw.writeStartElement(""String_Node_Str"");
  xsw.writeCharacters(""String_Node_Str"");
  xsw.writeEndElement();
  xsw.writeEndElement();
  xsw.writeStartElement(""String_Node_Str"");
  xsw.writeCharacters(dateFormat.format(new Date()));
  xsw.writeEndElement();
  xsw.writeEndElement();
  xsw.writeStartElement(""String_Node_Str"");
  xsw.writeStartElement(""String_Node_Str"");
  xsw.writeCharacters(device.getName());
  xsw.writeEndElement();
  xsw.writeStartElement(""String_Node_Str"");
  xsw.writeCharacters(""String_Node_Str"" + device.getName() + ""String_Node_Str""+ dateFormat.format(from)+ ""String_Node_Str""+ dateFormat.format(to));
  xsw.writeEndElement();
  xsw.writeStartElement(""String_Node_Str"");
  xsw.writeCharacters(""String_Node_Str"");
  xsw.writeEndElement();
  xsw.writeStartElement(""String_Node_Str"");
  for (  Position p : dataService.getPositions(device,from,to,filter)) {
    xsw.writeStartElement(""String_Node_Str"");
    xsw.writeAttribute(""String_Node_Str"",p.getLatitude().toString());
    xsw.writeAttribute(""String_Node_Str"",p.getLongitude().toString());
    if (p.getAltitude() != null && p.getAltitude() != 0) {
      xsw.writeStartElement(""String_Node_Str"");
      xsw.writeCharacters(p.getAltitude().toString());
      xsw.writeEndElement();
    }
    xsw.writeStartElement(""String_Node_Str"");
    xsw.writeCharacters(dateFormat.format(p.getTime()));
    xsw.writeEndElement();
    xsw.writeStartElement(""String_Node_Str"");
    if (p.getAddress() != null && !p.getAddress().trim().isEmpty()) {
      xsw.writeStartElement(""String_Node_Str"");
      xsw.writeCharacters(StringEscapeUtils.escapeXml(p.getAddress()));
      xsw.writeEndElement();
    }
    if (p.getSpeed() != null) {
      xsw.writeStartElement(""String_Node_Str"");
      xsw.writeCharacters(p.getSpeed().toString());
      xsw.writeEndElement();
    }
    if (p.getCourse() != null) {
      xsw.writeStartElement(""String_Node_Str"");
      xsw.writeCharacters(p.getCourse().toString());
      xsw.writeEndElement();
    }
    if (p.getPower() != null) {
      xsw.writeStartElement(""String_Node_Str"");
      xsw.writeCharacters(p.getPower().toString());
      xsw.writeEndElement();
    }
    if (p.getOther() != null && !p.getOther().trim().isEmpty()) {
      xsw.writeStartElement(""String_Node_Str"");
      xsw.writeCharacters(StringEscapeUtils.escapeXml(p.getOther()));
      xsw.writeEndElement();
    }
    xsw.writeEndElement();
    xsw.writeEndElement();
  }
  xsw.writeEndElement();
  xsw.writeEndElement();
  xsw.writeEndElement();
  xsw.writeEndDocument();
  xsw.flush();
}","void gpx(HttpServletResponse response,Device device,Date from,Date to,boolean filter) throws IOException, XMLStreamException {
  response.setContentType(""String_Node_Str"");
  response.setHeader(""String_Node_Str"",""String_Node_Str"");
  TimeZone tz=TimeZone.getTimeZone(""String_Node_Str"");
  DateFormat dateFormat=new SimpleDateFormat(""String_Node_Str"");
  dateFormat.setTimeZone(tz);
  XMLStreamWriter xsw=XMLOutputFactory.newFactory().createXMLStreamWriter(response.getOutputStream(),""String_Node_Str"");
  xsw.writeStartDocument(""String_Node_Str"",""String_Node_Str"");
  xsw.writeStartElement(""String_Node_Str"");
  xsw.writeAttribute(""String_Node_Str"",""String_Node_Str"");
  xsw.writeAttribute(""String_Node_Str"",""String_Node_Str"");
  xsw.writeAttribute(""String_Node_Str"",""String_Node_Str"");
  xsw.writeAttribute(""String_Node_Str"",""String_Node_Str"");
  xsw.writeAttribute(""String_Node_Str"",""String_Node_Str"");
  xsw.writeStartElement(""String_Node_Str"");
  xsw.writeStartElement(""String_Node_Str"");
  xsw.writeAttribute(""String_Node_Str"",""String_Node_Str"");
  xsw.writeStartElement(""String_Node_Str"");
  xsw.writeCharacters(""String_Node_Str"");
  xsw.writeEndElement();
  xsw.writeEndElement();
  xsw.writeStartElement(""String_Node_Str"");
  xsw.writeCharacters(dateFormat.format(new Date()));
  xsw.writeEndElement();
  xsw.writeEndElement();
  xsw.writeStartElement(""String_Node_Str"");
  xsw.writeStartElement(""String_Node_Str"");
  xsw.writeCharacters(device.getName());
  xsw.writeEndElement();
  xsw.writeStartElement(""String_Node_Str"");
  xsw.writeCharacters(""String_Node_Str"" + device.getName() + ""String_Node_Str""+ dateFormat.format(from)+ ""String_Node_Str""+ dateFormat.format(to));
  xsw.writeEndElement();
  xsw.writeStartElement(""String_Node_Str"");
  xsw.writeCharacters(""String_Node_Str"");
  xsw.writeEndElement();
  xsw.writeStartElement(""String_Node_Str"");
  for (  Position p : dataService.getPositions(device,from,to,filter)) {
    xsw.writeStartElement(""String_Node_Str"");
    xsw.writeAttribute(""String_Node_Str"",p.getLatitude().toString());
    xsw.writeAttribute(""String_Node_Str"",p.getLongitude().toString());
    if (p.getAltitude() != null && p.getAltitude() != 0) {
      xsw.writeStartElement(""String_Node_Str"");
      xsw.writeCharacters(p.getAltitude().toString());
      xsw.writeEndElement();
    }
    xsw.writeStartElement(""String_Node_Str"");
    xsw.writeCharacters(dateFormat.format(p.getTime()));
    xsw.writeEndElement();
    xsw.writeStartElement(""String_Node_Str"");
    if (p.getAddress() != null && !p.getAddress().trim().isEmpty()) {
      xsw.writeStartElement(""String_Node_Str"");
      xsw.writeCharacters(StringEscapeUtils.escapeXml(p.getAddress()));
      xsw.writeEndElement();
    }
    if (p.getSpeed() != null) {
      xsw.writeStartElement(""String_Node_Str"");
      xsw.writeCharacters(p.getSpeed().toString());
      xsw.writeEndElement();
    }
    if (p.getCourse() != null) {
      xsw.writeStartElement(""String_Node_Str"");
      xsw.writeCharacters(p.getCourse().toString());
      xsw.writeEndElement();
    }
    if (p.getPower() != null) {
      xsw.writeStartElement(""String_Node_Str"");
      xsw.writeCharacters(p.getPower().toString());
      xsw.writeEndElement();
    }
    if (p.getOther() != null && !p.getOther().trim().isEmpty()) {
      xsw.writeStartElement(""String_Node_Str"");
      xsw.writeCharacters(StringEscapeUtils.escapeXml(p.getOther()));
      xsw.writeEndElement();
    }
    xsw.writeEndElement();
    xsw.writeEndElement();
  }
  xsw.writeEndElement();
  xsw.writeEndElement();
  xsw.writeEndElement();
  xsw.writeEndDocument();
  xsw.flush();
}",0.9975055432372506
32297,"@Transactional @RequireUser(roles={Role.ADMIN,Role.MANAGER}) @Override public User removeUser(User user){
  EntityManager entityManager=getSessionEntityManager();
  user=entityManager.merge(user);
  for (  Device device : user.getDevices()) {
    device.getUsers().remove(user);
  }
  entityManager.remove(user);
  return user;
}","@Transactional @RequireUser(roles={Role.ADMIN,Role.MANAGER}) @Override public User removeUser(User user){
  EntityManager entityManager=getSessionEntityManager();
  user=entityManager.merge(user);
  if (user.equals(getSessionUser())) {
    throw new IllegalArgumentException();
  }
  if (!user.getAdmin() && !user.getAllManagedUsers().contains(user)) {
    throw new SecurityException();
  }
  entityManager.createQuery(""String_Node_Str"").setParameter(""String_Node_Str"",user).executeUpdate();
  for (  Device device : user.getDevices()) {
    device.getUsers().remove(user);
  }
  entityManager.remove(user);
  return user;
}",0.689727463312369
32298,"void gpx(Device device,InputStream inputStream,HttpServletResponse response) throws IOException {
  TimeZone tz=TimeZone.getTimeZone(""String_Node_Str"");
  DateFormat dateFormat=new SimpleDateFormat(""String_Node_Str"");
  DateFormat dateFormatWithMS=new SimpleDateFormat(""String_Node_Str"");
  dateFormatWithMS.setTimeZone(tz);
  try {
    XMLStreamReader xsr=XMLInputFactory.newFactory().createXMLStreamReader(inputStream);
    List<Position> parsedPositions=new LinkedList<Position>();
    Position position=null;
    response.getWriter().println(""String_Node_Str"");
    int imported=0;
    while (xsr.hasNext()) {
      xsr.next();
      if (xsr.getEventType() == XMLStreamReader.START_ELEMENT) {
        if (xsr.getLocalName().equalsIgnoreCase(""String_Node_Str"")) {
          position=new Position();
          position.setLongitude(Double.parseDouble(xsr.getAttributeValue(null,""String_Node_Str"")));
          position.setLatitude(Double.parseDouble(xsr.getAttributeValue(null,""String_Node_Str"")));
          position.setValid(Boolean.TRUE);
          position.setDevice(device);
        }
 else         if (xsr.getLocalName().equalsIgnoreCase(""String_Node_Str"")) {
          if (position != null) {
            String strTime=xsr.getElementText();
            if (strTime.length() == 20) {
              position.setTime(dateFormat.parse(strTime));
            }
 else {
              position.setTime(dateFormatWithMS.parse(strTime));
            }
          }
        }
 else         if (xsr.getLocalName().equalsIgnoreCase(""String_Node_Str"")) {
          if (position != null) {
            position.setAltitude(Double.parseDouble(xsr.getElementText()));
          }
        }
 else         if (position != null) {
          position.setOther((position.getOther() == null ? ""String_Node_Str"" : position.getOther()) + ""String_Node_Str"" + xsr.getLocalName()+ ""String_Node_Str""+ xsr.getElementText()+ ""String_Node_Str""+ xsr.getLocalName()+ ""String_Node_Str"");
        }
      }
 else       if (xsr.getEventType() == XMLStreamReader.END_ELEMENT && xsr.getLocalName().equalsIgnoreCase(""String_Node_Str"")) {
        parsedPositions.add(position);
        position=null;
      }
    }
    for (int i=0; i < parsedPositions.size(); i++) {
      position=parsedPositions.get(i);
      StringBuilder other=new StringBuilder(""String_Node_Str"");
      other.append(""String_Node_Str"");
      if (i == 0) {
        other.append(""String_Node_Str"");
      }
 else       if (i == parsedPositions.size() - 1) {
        other.append(""String_Node_Str"");
      }
 else {
        other.append(""String_Node_Str"");
      }
      other.append(""String_Node_Str"");
      if (position.getOther() != null) {
        other.append(position.getOther());
      }
      other.append(""String_Node_Str"");
      position.setOther(other.toString());
      boolean exist=false;
      for (      Position existing : entityManager.get().createQuery(""String_Node_Str"",Position.class).setParameter(""String_Node_Str"",device).setParameter(""String_Node_Str"",position.getTime()).getResultList()) {
        if (equals(existing.getLongitude(),position.getLongitude(),0.0000000001d) && equals(existing.getLatitude(),position.getLatitude(),0.0000000001d) && equals(existing.getAltitude(),position.getAltitude(),0.00001d)&& existing.getOther().equals(position.getOther())) {
          exist=true;
          break;
        }
      }
      if (!exist) {
        entityManager.get().persist(position);
        imported++;
      }
    }
    response.getWriter().println(""String_Node_Str"" + (parsedPositions.size() - imported));
    response.getWriter().println(""String_Node_Str"" + imported);
    response.getWriter().println(""String_Node_Str"");
  }
 catch (  XMLStreamException xse) {
    throw new IOException(xse);
  }
catch (  ParseException pe) {
    throw new IOException(pe);
  }
}","void gpx(Device device,InputStream inputStream,HttpServletResponse response) throws IOException {
  TimeZone tz=TimeZone.getTimeZone(""String_Node_Str"");
  DateFormat dateFormat=new SimpleDateFormat(""String_Node_Str"");
  DateFormat dateFormatWithMS=new SimpleDateFormat(""String_Node_Str"");
  dateFormat.setTimeZone(tz);
  dateFormatWithMS.setTimeZone(tz);
  try {
    XMLStreamReader xsr=XMLInputFactory.newFactory().createXMLStreamReader(inputStream);
    List<Position> parsedPositions=new LinkedList<Position>();
    Position position=null;
    response.getWriter().println(""String_Node_Str"");
    int imported=0;
    while (xsr.hasNext()) {
      xsr.next();
      if (xsr.getEventType() == XMLStreamReader.START_ELEMENT) {
        if (xsr.getLocalName().equalsIgnoreCase(""String_Node_Str"")) {
          position=new Position();
          position.setLongitude(Double.parseDouble(xsr.getAttributeValue(null,""String_Node_Str"")));
          position.setLatitude(Double.parseDouble(xsr.getAttributeValue(null,""String_Node_Str"")));
          position.setValid(Boolean.TRUE);
          position.setDevice(device);
        }
 else         if (xsr.getLocalName().equalsIgnoreCase(""String_Node_Str"")) {
          if (position != null) {
            String strTime=xsr.getElementText();
            if (strTime.length() == 20) {
              position.setTime(dateFormat.parse(strTime));
            }
 else {
              position.setTime(dateFormatWithMS.parse(strTime));
            }
          }
        }
 else         if (xsr.getLocalName().equalsIgnoreCase(""String_Node_Str"")) {
          if (position != null) {
            position.setAltitude(Double.parseDouble(xsr.getElementText()));
          }
        }
 else         if (position != null) {
          position.setOther((position.getOther() == null ? ""String_Node_Str"" : position.getOther()) + ""String_Node_Str"" + xsr.getLocalName()+ ""String_Node_Str""+ xsr.getElementText()+ ""String_Node_Str""+ xsr.getLocalName()+ ""String_Node_Str"");
        }
      }
 else       if (xsr.getEventType() == XMLStreamReader.END_ELEMENT && xsr.getLocalName().equalsIgnoreCase(""String_Node_Str"")) {
        parsedPositions.add(position);
        position=null;
      }
    }
    for (int i=0; i < parsedPositions.size(); i++) {
      position=parsedPositions.get(i);
      StringBuilder other=new StringBuilder(""String_Node_Str"");
      other.append(""String_Node_Str"");
      if (i == 0) {
        other.append(""String_Node_Str"");
      }
 else       if (i == parsedPositions.size() - 1) {
        other.append(""String_Node_Str"");
      }
 else {
        other.append(""String_Node_Str"");
      }
      other.append(""String_Node_Str"");
      if (position.getOther() != null) {
        other.append(position.getOther());
      }
      other.append(""String_Node_Str"");
      position.setOther(other.toString());
      boolean exist=false;
      for (      Position existing : entityManager.get().createQuery(""String_Node_Str"",Position.class).setParameter(""String_Node_Str"",device).setParameter(""String_Node_Str"",position.getTime()).getResultList()) {
        if (equals(existing.getLongitude(),position.getLongitude(),0.0000000001d) && equals(existing.getLatitude(),position.getLatitude(),0.0000000001d) && equals(existing.getAltitude(),position.getAltitude(),0.00001d)&& existing.getOther().equals(position.getOther())) {
          exist=true;
          break;
        }
      }
      if (!exist) {
        entityManager.get().persist(position);
        imported++;
      }
    }
    response.getWriter().println(""String_Node_Str"" + (parsedPositions.size() - imported));
    response.getWriter().println(""String_Node_Str"" + imported);
    response.getWriter().println(""String_Node_Str"");
  }
 catch (  XMLStreamException xse) {
    throw new IOException(xse);
  }
catch (  ParseException pe) {
    throw new IOException(pe);
  }
}",0.9961059190031152
32299,"@UiHandler(""String_Node_Str"") public void onSaveClicked(SelectEvent event){
  window.hide();
  Device device=driver.flush();
  device.setIdleSpeedThreshold(ApplicationContext.getInstance().getUserSettings().getSpeedUnit().toKnots(device.getIdleSpeedThreshold()));
  device.setIconType(DeviceIconType.valueOf(((Radio)iconRadioGroup.getValue()).getId()));
  deviceHandler.onSave(device);
}","@UiHandler(""String_Node_Str"") public void onSaveClicked(SelectEvent event){
  window.hide();
  Device device=driver.flush();
  device.setIdleSpeedThreshold(ApplicationContext.getInstance().getUserSettings().getSpeedUnit().toKnots(device.getIdleSpeedThreshold()));
  if (iconRadioGroup.getValue() != null) {
    device.setIconType(DeviceIconType.valueOf(((Radio)iconRadioGroup.getValue()).getId()));
  }
  deviceHandler.onSave(device);
}",0.9404617253948968
32300,"@RequireUser @Transactional @Override public List<Position> getLatestNonIdlePositions(){
  List<Position> positions=new LinkedList<Position>();
  List<Device> devices=getDevices();
  if (devices != null && !devices.isEmpty()) {
    EntityManager entityManager=getSessionEntityManager();
    for (    Device device : devices) {
      Position position=(Position)entityManager.createQuery(""String_Node_Str"").setParameter(""String_Node_Str"",device).setMaxResults(1).getSingleResult();
      if (position != null) {
        positions.add(position);
      }
    }
  }
  return positions;
}","@RequireUser @Transactional @Override public List<Position> getLatestNonIdlePositions(){
  List<Position> positions=new LinkedList<Position>();
  List<Device> devices=getDevices();
  if (devices != null && !devices.isEmpty()) {
    EntityManager entityManager=getSessionEntityManager();
    for (    Device device : devices) {
      List<Position> position=entityManager.createQuery(""String_Node_Str"",Position.class).setParameter(""String_Node_Str"",device).setMaxResults(1).getResultList();
      if (position.isEmpty()) {
        position=entityManager.createQuery(""String_Node_Str"",Position.class).setParameter(""String_Node_Str"",device).setMaxResults(1).getResultList();
      }
      if (!position.isEmpty()) {
        positions.add(position.get(0));
      }
    }
  }
  return positions;
}",0.8029090909090909
32301,"@Override protected void doGet(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {
  if (perThreadRequest == null) {
    getThreadLocalRequest();
  }
  if (perThreadResponse == null) {
    getThreadLocalResponse();
  }
  perThreadRequest.set(req);
  perThreadResponse.set(resp);
  try {
    String payload=RPCServletUtils.readContent(req,null,null);
    String result=makeRestCall(payload);
    if (result != null) {
      resp.getWriter().write(result);
      if (resp.getStatus() != HttpServletResponse.SC_INTERNAL_SERVER_ERROR && resp.getStatus() != HttpServletResponse.SC_UNAUTHORIZED && resp.getStatus() != HttpServletResponse.SC_NOT_FOUND) {
        resp.setStatus(HttpServletResponse.SC_OK);
      }
    }
  }
  finally {
    perThreadRequest.set(null);
    perThreadResponse.set(null);
  }
}","@Override protected void doGet(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {
  if (perThreadRequest == null) {
    getThreadLocalRequest();
  }
  if (perThreadResponse == null) {
    getThreadLocalResponse();
  }
  perThreadRequest.set(req);
  perThreadResponse.set(resp);
  try {
    String payload=RPCServletUtils.readContent(req,null,null);
    String result=makeRestCall(payload);
    if (result != null) {
      resp.setHeader(""String_Node_Str"",""String_Node_Str"");
      resp.setCharacterEncoding(""String_Node_Str"");
      resp.getWriter().write(result);
      if (resp.getStatus() != HttpServletResponse.SC_INTERNAL_SERVER_ERROR && resp.getStatus() != HttpServletResponse.SC_UNAUTHORIZED && resp.getStatus() != HttpServletResponse.SC_NOT_FOUND) {
        resp.setStatus(HttpServletResponse.SC_OK);
      }
    }
  }
  finally {
    perThreadRequest.set(null);
    perThreadResponse.set(null);
  }
}",0.9376754632229084
32302,"@Override public void migrate(EntityManager em) throws Exception {
  em.createQuery(""String_Node_Str"" + Device.class.getSimpleName() + ""String_Node_Str"").setParameter(""String_Node_Str"",Integer.valueOf(Device.DEFAULT_TIMEOUT)).executeUpdate();
}","@Override public void migrate(EntityManager em) throws Exception {
  em.createQuery(""String_Node_Str"" + ApplicationSettings.class.getName() + ""String_Node_Str"").setParameter(""String_Node_Str"",Boolean.FALSE).executeUpdate();
}",0.7974413646055437
32303,"private void initMapLayers(Map map){
  map.addLayer(OSM.Mapnik(""String_Node_Str""));
  TMSOptions seamarkOptions=new TMSOptions();
  seamarkOptions.setType(""String_Node_Str"");
  seamarkOptions.setGetURL(getTileURL());
  seamarkOptions.setNumZoomLevels(18);
  seamarkOptions.setIsBaseLayer(false);
  seamarkOptions.setDisplayOutsideMaxExtent(true);
  map.addLayer(new TMS(i18n.seamark(),""String_Node_Str"",seamarkOptions));
  GoogleV3Options gHybridOptions=new GoogleV3Options();
  gHybridOptions.setNumZoomLevels(20);
  gHybridOptions.setType(GoogleV3MapType.G_HYBRID_MAP);
  map.addLayer(new GoogleV3(""String_Node_Str"",gHybridOptions));
  GoogleV3Options gNormalOptions=new GoogleV3Options();
  gNormalOptions.setNumZoomLevels(22);
  gNormalOptions.setType(GoogleV3MapType.G_NORMAL_MAP);
  map.addLayer(new GoogleV3(""String_Node_Str"",gNormalOptions));
  GoogleV3Options gSatelliteOptions=new GoogleV3Options();
  gSatelliteOptions.setNumZoomLevels(20);
  gSatelliteOptions.setType(GoogleV3MapType.G_SATELLITE_MAP);
  map.addLayer(new GoogleV3(""String_Node_Str"",gSatelliteOptions));
  GoogleV3Options gTerrainOptions=new GoogleV3Options();
  gTerrainOptions.setNumZoomLevels(16);
  gTerrainOptions.setType(GoogleV3MapType.G_TERRAIN_MAP);
  map.addLayer(new GoogleV3(""String_Node_Str"",gTerrainOptions));
  final String bingKey=""String_Node_Str"";
  map.addLayer(new Bing(new BingOptions(""String_Node_Str"",bingKey,BingType.ROAD)));
  map.addLayer(new Bing(new BingOptions(""String_Node_Str"",bingKey,BingType.HYBRID)));
  map.addLayer(new Bing(new BingOptions(""String_Node_Str"",bingKey,BingType.AERIAL)));
}","private void initMapLayers(Map map){
  map.addLayer(OSM.Mapnik(""String_Node_Str""));
  TMSOptions seamarkOptions=new TMSOptions();
  seamarkOptions.setType(""String_Node_Str"");
  seamarkOptions.setGetURL(getTileURL());
  seamarkOptions.setNumZoomLevels(20);
  seamarkOptions.setIsBaseLayer(false);
  seamarkOptions.setDisplayOutsideMaxExtent(true);
  map.addLayer(new TMS(i18n.seamark(),""String_Node_Str"",seamarkOptions));
  GoogleV3Options gHybridOptions=new GoogleV3Options();
  gHybridOptions.setNumZoomLevels(20);
  gHybridOptions.setType(GoogleV3MapType.G_HYBRID_MAP);
  map.addLayer(new GoogleV3(""String_Node_Str"",gHybridOptions));
  GoogleV3Options gNormalOptions=new GoogleV3Options();
  gNormalOptions.setNumZoomLevels(22);
  gNormalOptions.setType(GoogleV3MapType.G_NORMAL_MAP);
  map.addLayer(new GoogleV3(""String_Node_Str"",gNormalOptions));
  GoogleV3Options gSatelliteOptions=new GoogleV3Options();
  gSatelliteOptions.setNumZoomLevels(20);
  gSatelliteOptions.setType(GoogleV3MapType.G_SATELLITE_MAP);
  map.addLayer(new GoogleV3(""String_Node_Str"",gSatelliteOptions));
  GoogleV3Options gTerrainOptions=new GoogleV3Options();
  gTerrainOptions.setNumZoomLevels(16);
  gTerrainOptions.setType(GoogleV3MapType.G_TERRAIN_MAP);
  map.addLayer(new GoogleV3(""String_Node_Str"",gTerrainOptions));
  final String bingKey=""String_Node_Str"";
  map.addLayer(new Bing(new BingOptions(""String_Node_Str"",bingKey,BingType.ROAD)));
  map.addLayer(new Bing(new BingOptions(""String_Node_Str"",bingKey,BingType.HYBRID)));
  map.addLayer(new Bing(new BingOptions(""String_Node_Str"",bingKey,BingType.AERIAL)));
}",0.99875
32304,"@Override public boolean logout(){
  setSessionUser(null);
  return true;
}","@Override public boolean logout(){
  setSessionUser(null);
  HttpSession session=getThreadLocalRequest().getSession();
  EntityManager entityManager=(EntityManager)session.getAttribute(ATTRIBUTE_ENTITYMANAGER);
  if (entityManager != null) {
    entityManager.close();
    session.removeAttribute(ATTRIBUTE_ENTITYMANAGER);
  }
  return true;
}",0.2966507177033493
32305,"public ApiServer(String ip,int port,IBurpExtenderCallbacks callbacks){
  IExtensionHelpers helpers=callbacks.getHelpers();
  PrintWriter stdout=new PrintWriter(callbacks.getStdout());
  PrintWriter stderr=new PrintWriter(callbacks.getStderr());
  setPort(port);
  setIpAddress(ip);
  BScanQueue scanQueue=BScanQueueFactory.create();
  Gson gson=new Gson();
  before((request,response) -> {
    String contentType=request.headers(""String_Node_Str"");
    if (!request.requestMethod().equals(""String_Node_Str"") && (contentType == null || !contentType.contains(""String_Node_Str""))) {
      halt(400);
    }
  }
);
  get(""String_Node_Str"",(request,response) -> {
    try {
      URL url=new URL(new String(Base64.decodeBase64(request.params(""String_Node_Str""))));
      if (callbacks.isInScope(url)) {
        response.status(200);
        return ""String_Node_Str"";
      }
 else {
        response.status(404);
        return ""String_Node_Str"";
      }
    }
 catch (    MalformedURLException e) {
      response.status(400);
      return e.getMessage();
    }
  }
);
  post(""String_Node_Str"",(request,response) -> {
    try {
      BURLMessage message=gson.fromJson(request.body(),BURLMessage.class);
      callbacks.includeInScope(new URL(message.url));
      response.status(201);
      return gson.toJson(message);
    }
 catch (    MalformedURLException e) {
      response.status(400);
      return e.getMessage();
    }
  }
);
  delete(""String_Node_Str"",(request,response) -> {
    try {
      URL url=new URL(new String(Base64.decodeBase64(request.params(""String_Node_Str""))));
      callbacks.excludeFromScope(url);
      response.status(200);
      return ""String_Node_Str"";
    }
 catch (    MalformedURLException e) {
      response.status(400);
      return e.getMessage();
    }
  }
);
  get(""String_Node_Str"",(request,response) -> {
    IScanIssue[] rawIssues=callbacks.getScanIssues(""String_Node_Str"");
    List<BScanIssue> issues=new ArrayList<>();
    for (    IScanIssue issue : rawIssues) {
      issues.add(BScanIssueFactory.create(issue,callbacks));
    }
    return gson.toJson(new BArrayWrapper(issues));
  }
);
  get(""String_Node_Str"",(request,response) -> {
    byte[] encodedBytes=Base64.decodeBase64(request.params(""String_Node_Str""));
    IScanIssue[] rawIssues=callbacks.getScanIssues(new String(encodedBytes));
    List<BScanIssue> issues=new ArrayList<>();
    for (    IScanIssue issue : rawIssues) {
      issues.add(BScanIssueFactory.create(issue,callbacks));
    }
    return gson.toJson(issues);
  }
);
  post(""String_Node_Str"",(request,response) -> {
    BScanIssue issue=gson.fromJson(request.body(),BScanIssue.class);
    callbacks.addScanIssue(issue);
    response.status(201);
    return gson.toJson(issue);
  }
);
  post(""String_Node_Str"",(request,response) -> {
    BURLMessage message=gson.fromJson(request.body(),BURLMessage.class);
    try {
      callbacks.sendToSpider(new URL(message.url));
      response.status(200);
      return ""String_Node_Str"";
    }
 catch (    MalformedURLException e) {
      response.status(400);
      return e.getMessage();
    }
  }
);
  get(""String_Node_Str"",(request,response) -> {
    List<BCookie> cookies=new ArrayList<>();
    for (    ICookie burpCookie : callbacks.getCookieJarContents()) {
      BCookie cookie=new BCookie();
      cookie.expiration=burpCookie.getExpiration();
      cookie.domain=burpCookie.getDomain();
      cookie.name=burpCookie.getName();
      cookie.value=burpCookie.getValue();
      cookies.add(cookie);
    }
    return gson.toJson(new BArrayWrapper(cookies));
  }
);
  post(""String_Node_Str"",(request,response) -> {
    BCookie cookie=gson.fromJson(request.body(),BCookie.class);
    callbacks.updateCookieJar(new ICookie(){
      @Override public String getDomain(){
        return cookie.domain;
      }
      @Override public Date getExpiration(){
        return cookie.expiration;
      }
      @Override public String getName(){
        return cookie.name;
      }
      @Override public String getValue(){
        return cookie.value;
      }
    }
);
    response.status(201);
    return gson.toJson(cookie);
  }
);
  post(""String_Node_Str"",(request,response) -> {
    BScanMessage message=gson.fromJson(request.body(),BScanMessage.class);
    IScanQueueItem item=callbacks.doActiveScan(message.host,message.port,message.useHttps,message.request);
    BScanQueueID id=scanQueue.addToQueue(item);
    response.status(201);
    return gson.toJson(id);
  }
);
  get(""String_Node_Str"",(request,response) -> {
    int id=Integer.parseInt(request.params(""String_Node_Str""));
    IScanQueueItem item=scanQueue.getItem(id);
    if (item == null) {
      response.status(404);
      return ""String_Node_Str"";
    }
    response.status(200);
    BScanQueueItem bScanQueueItem=BScanQueueItemFactory.create(id,item,callbacks);
    return gson.toJson(bScanQueueItem);
  }
);
  delete(""String_Node_Str"",(request,response) -> {
    int id=Integer.parseInt(request.params(""String_Node_Str""));
    IScanQueueItem item=scanQueue.getItem(id);
    if (item == null) {
      response.status(404);
      return ""String_Node_Str"";
    }
    response.status(200);
    item.cancel();
    scanQueue.removeFromQueue(id);
    return ""String_Node_Str"";
  }
);
  post(""String_Node_Str"",(request,response) -> {
    BScanMessage message=gson.fromJson(request.body(),BScanMessage.class);
    callbacks.doPassiveScan(message.host,message.port,message.useHttps,message.request,message.response);
    response.status(201);
    return ""String_Node_Str"";
  }
);
  post(""String_Node_Str"",(request,response) -> {
    String tool=request.params(""String_Node_Str"");
    BScanMessage message=gson.fromJson(request.body(),BScanMessage.class);
switch (tool) {
case ""String_Node_Str"":
      callbacks.sendToIntruder(message.host,message.port,message.useHttps,message.request);
    response.status(201);
  break;
case ""String_Node_Str"":
callbacks.sendToRepeater(message.host,message.port,message.useHttps,message.request,""String_Node_Str"");
response.status(201);
break;
default :
response.status(404);
break;
}
return ""String_Node_Str"";
}
);
post(""String_Node_Str"",(request,response) -> {
callbacks.issueAlert(gson.fromJson(request.body(),BMessage.class).message);
response.status(201);
return ""String_Node_Str"";
}
);
post(""String_Node_Str"",(request,response) -> {
stdout.println(gson.fromJson(request.body(),BMessage.class).message);
response.status(201);
return ""String_Node_Str"";
}
);
post(""String_Node_Str"",(request,response) -> {
stderr.println(gson.fromJson(request.body(),BMessage.class).message);
response.status(201);
return ""String_Node_Str"";
}
);
get(""String_Node_Str"",(request,response) -> {
List<BHttpRequestResponse> pairs=new ArrayList<>();
for (IHttpRequestResponse requestResponse : callbacks.getSiteMap(""String_Node_Str"")) {
pairs.add(BHttpRequestResponseFactory.create(requestResponse,callbacks,helpers));
}
return gson.toJson(new BArrayWrapper(pairs));
}
);
get(""String_Node_Str"",(request,response) -> {
byte[] encodedBytes=Base64.decodeBase64(request.params(""String_Node_Str""));
List<BHttpRequestResponse> pairs=new ArrayList<>();
for (IHttpRequestResponse requestResponse : callbacks.getSiteMap(new String(encodedBytes))) {
pairs.add(BHttpRequestResponseFactory.create(requestResponse,callbacks,helpers));
}
return gson.toJson(new BArrayWrapper(pairs));
}
);
post(""String_Node_Str"",(request,response) -> {
BHttpRequestResponse bHttpRequestResponse=gson.fromJson(request.body(),BHttpRequestResponse.class);
callbacks.addToSiteMap(bHttpRequestResponse);
response.status(201);
return gson.toJson(bHttpRequestResponse);
}
);
get(""String_Node_Str"",(request,response) -> {
List<BHttpRequestResponse> pairs=new ArrayList<>();
for (IHttpRequestResponse requestResponse : callbacks.getProxyHistory()) {
pairs.add(BHttpRequestResponseFactory.create(requestResponse,callbacks,helpers));
}
return gson.toJson(new BArrayWrapper(pairs));
}
);
}","public ApiServer(String ip,int port,IBurpExtenderCallbacks callbacks){
  IExtensionHelpers helpers=callbacks.getHelpers();
  PrintWriter stdout=new PrintWriter(callbacks.getStdout());
  PrintWriter stderr=new PrintWriter(callbacks.getStderr());
  setPort(port);
  setIpAddress(ip);
  BScanQueue scanQueue=BScanQueueFactory.create();
  Gson gson=new Gson();
  before((request,response) -> {
    String contentType=request.headers(""String_Node_Str"");
    if (!request.requestMethod().equals(""String_Node_Str"") && (contentType == null || !contentType.contains(""String_Node_Str""))) {
      halt(400);
    }
  }
);
  get(""String_Node_Str"",(request,response) -> {
    try {
      URL url=new URL(new String(Base64.decodeBase64(request.params(""String_Node_Str""))));
      if (callbacks.isInScope(url)) {
        response.status(200);
        return ""String_Node_Str"";
      }
 else {
        response.status(404);
        return ""String_Node_Str"";
      }
    }
 catch (    MalformedURLException e) {
      response.status(400);
      return e.getMessage();
    }
  }
);
  post(""String_Node_Str"",(request,response) -> {
    try {
      BURLMessage message=gson.fromJson(request.body(),BURLMessage.class);
      callbacks.includeInScope(new URL(message.url));
      response.status(201);
      return gson.toJson(message);
    }
 catch (    MalformedURLException e) {
      response.status(400);
      return e.getMessage();
    }
  }
);
  delete(""String_Node_Str"",(request,response) -> {
    try {
      URL url=new URL(new String(Base64.decodeBase64(request.params(""String_Node_Str""))));
      callbacks.excludeFromScope(url);
      response.status(200);
      return ""String_Node_Str"";
    }
 catch (    MalformedURLException e) {
      response.status(400);
      return e.getMessage();
    }
  }
);
  get(""String_Node_Str"",(request,response) -> {
    IScanIssue[] rawIssues=callbacks.getScanIssues(""String_Node_Str"");
    List<BScanIssue> issues=new ArrayList<>();
    for (    IScanIssue issue : rawIssues) {
      issues.add(BScanIssueFactory.create(issue,callbacks));
    }
    return gson.toJson(new BArrayWrapper(issues));
  }
);
  get(""String_Node_Str"",(request,response) -> {
    byte[] encodedBytes=Base64.decodeBase64(request.params(""String_Node_Str""));
    IScanIssue[] rawIssues=callbacks.getScanIssues(new String(encodedBytes));
    List<BScanIssue> issues=new ArrayList<>();
    for (    IScanIssue issue : rawIssues) {
      issues.add(BScanIssueFactory.create(issue,callbacks));
    }
    return gson.toJson(issues);
  }
);
  post(""String_Node_Str"",(request,response) -> {
    BScanIssue issue=gson.fromJson(request.body(),BScanIssue.class);
    callbacks.addScanIssue(issue);
    response.status(201);
    return gson.toJson(issue);
  }
);
  post(""String_Node_Str"",(request,response) -> {
    BURLMessage message=gson.fromJson(request.body(),BURLMessage.class);
    try {
      callbacks.sendToSpider(new URL(message.url));
      response.status(200);
      return ""String_Node_Str"";
    }
 catch (    MalformedURLException e) {
      response.status(400);
      return e.getMessage();
    }
  }
);
  get(""String_Node_Str"",(request,response) -> {
    List<BCookie> cookies=new ArrayList<>();
    for (    ICookie burpCookie : callbacks.getCookieJarContents()) {
      BCookie cookie=new BCookie();
      cookie.expiration=burpCookie.getExpiration();
      cookie.domain=burpCookie.getDomain();
      cookie.name=burpCookie.getName();
      cookie.value=burpCookie.getValue();
      cookies.add(cookie);
    }
    return gson.toJson(new BArrayWrapper(cookies));
  }
);
  post(""String_Node_Str"",(request,response) -> {
    BCookie cookie=gson.fromJson(request.body(),BCookie.class);
    callbacks.updateCookieJar(new ICookie(){
      @Override public String getDomain(){
        return cookie.domain;
      }
      @Override public Date getExpiration(){
        return cookie.expiration;
      }
      @Override public String getName(){
        return cookie.name;
      }
      @Override public String getValue(){
        return cookie.value;
      }
    }
);
    response.status(201);
    return gson.toJson(cookie);
  }
);
  post(""String_Node_Str"",(request,response) -> {
    BScanMessage message=gson.fromJson(request.body(),BScanMessage.class);
    IScanQueueItem item=callbacks.doActiveScan(message.host,message.port,message.useHttps,Base64.decodeBase64(message.request));
    BScanQueueID id=scanQueue.addToQueue(item);
    response.status(201);
    return gson.toJson(id);
  }
);
  get(""String_Node_Str"",(request,response) -> {
    int id=Integer.parseInt(request.params(""String_Node_Str""));
    IScanQueueItem item=scanQueue.getItem(id);
    if (item == null) {
      response.status(404);
      return ""String_Node_Str"";
    }
    response.status(200);
    BScanQueueItem bScanQueueItem=BScanQueueItemFactory.create(id,item,callbacks);
    return gson.toJson(bScanQueueItem);
  }
);
  delete(""String_Node_Str"",(request,response) -> {
    int id=Integer.parseInt(request.params(""String_Node_Str""));
    IScanQueueItem item=scanQueue.getItem(id);
    if (item == null) {
      response.status(404);
      return ""String_Node_Str"";
    }
    response.status(200);
    item.cancel();
    scanQueue.removeFromQueue(id);
    return ""String_Node_Str"";
  }
);
  post(""String_Node_Str"",(request,response) -> {
    BScanMessage message=gson.fromJson(request.body(),BScanMessage.class);
    callbacks.doPassiveScan(message.host,message.port,message.useHttps,Base64.decodeBase64(message.request),Base64.decodeBase64(message.response));
    response.status(201);
    return ""String_Node_Str"";
  }
);
  post(""String_Node_Str"",(request,response) -> {
    String tool=request.params(""String_Node_Str"");
    BScanMessage message=gson.fromJson(request.body(),BScanMessage.class);
switch (tool) {
case ""String_Node_Str"":
      callbacks.sendToIntruder(message.host,message.port,message.useHttps,Base64.decodeBase64(message.request));
    response.status(201);
  break;
case ""String_Node_Str"":
callbacks.sendToRepeater(message.host,message.port,message.useHttps,Base64.decodeBase64(message.request),""String_Node_Str"");
response.status(201);
break;
default :
response.status(404);
break;
}
return ""String_Node_Str"";
}
);
post(""String_Node_Str"",(request,response) -> {
callbacks.issueAlert(gson.fromJson(request.body(),BMessage.class).message);
response.status(201);
return ""String_Node_Str"";
}
);
post(""String_Node_Str"",(request,response) -> {
stdout.println(gson.fromJson(request.body(),BMessage.class).message);
response.status(201);
return ""String_Node_Str"";
}
);
post(""String_Node_Str"",(request,response) -> {
stderr.println(gson.fromJson(request.body(),BMessage.class).message);
response.status(201);
return ""String_Node_Str"";
}
);
get(""String_Node_Str"",(request,response) -> {
List<BHttpRequestResponse> pairs=new ArrayList<>();
for (IHttpRequestResponse requestResponse : callbacks.getSiteMap(""String_Node_Str"")) {
pairs.add(BHttpRequestResponseFactory.create(requestResponse,callbacks,helpers));
}
return gson.toJson(new BArrayWrapper(pairs));
}
);
get(""String_Node_Str"",(request,response) -> {
byte[] encodedBytes=Base64.decodeBase64(request.params(""String_Node_Str""));
List<BHttpRequestResponse> pairs=new ArrayList<>();
for (IHttpRequestResponse requestResponse : callbacks.getSiteMap(new String(encodedBytes))) {
pairs.add(BHttpRequestResponseFactory.create(requestResponse,callbacks,helpers));
}
return gson.toJson(new BArrayWrapper(pairs));
}
);
post(""String_Node_Str"",(request,response) -> {
BHttpRequestResponse bHttpRequestResponse=gson.fromJson(request.body(),BHttpRequestResponse.class);
callbacks.addToSiteMap(bHttpRequestResponse);
response.status(201);
return gson.toJson(bHttpRequestResponse);
}
);
get(""String_Node_Str"",(request,response) -> {
List<BHttpRequestResponse> pairs=new ArrayList<>();
for (IHttpRequestResponse requestResponse : callbacks.getProxyHistory()) {
pairs.add(BHttpRequestResponseFactory.create(requestResponse,callbacks,helpers));
}
return gson.toJson(new BArrayWrapper(pairs));
}
);
}",0.9934198157548412
32306,"public static BHttpRequestResponse create(IHttpRequestResponse requestResponse,IBurpExtenderCallbacks callbacks,IExtensionHelpers helpers){
  BHttpRequestResponse bHttpRequestResponse=new BHttpRequestResponse();
  bHttpRequestResponse.request=BHttpRequestFactory.create(0x00004242,requestResponse,helpers.analyzeRequest(requestResponse),callbacks);
  bHttpRequestResponse.response=BHttpResponseFactory.create(0x00004242,requestResponse,helpers.analyzeResponse(requestResponse.getResponse()),callbacks);
  bHttpRequestResponse.messageType=""String_Node_Str"";
  return bHttpRequestResponse;
}","public static BHttpRequestResponse create(IHttpRequestResponse requestResponse,IBurpExtenderCallbacks callbacks,IExtensionHelpers helpers){
  BHttpRequestResponse bHttpRequestResponse=new BHttpRequestResponse();
  if (requestResponse.getRequest() != null && requestResponse.getRequest().length > 0) {
    bHttpRequestResponse.request=BHttpRequestFactory.create(0x00004242,requestResponse,helpers.analyzeRequest(requestResponse),callbacks);
  }
  if (requestResponse.getResponse() != null && requestResponse.getResponse().length > 0) {
    bHttpRequestResponse.response=BHttpResponseFactory.create(0x00004242,requestResponse,helpers.analyzeResponse(requestResponse.getResponse()),callbacks);
  }
  bHttpRequestResponse.messageType=""String_Node_Str"";
  return bHttpRequestResponse;
}",0.8598540145985402
32307,"@Override public void run(){
  panel=new JPanel();
  scroll=new JScrollPane(panel,JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
  scroll.setBorder(BorderFactory.createEmptyBorder());
  JLabel shLabel=new JLabel(""String_Node_Str"");
  JLabel portLabel=new JLabel(""String_Node_Str"");
  JLabel interfaceLabel=new JLabel(""String_Node_Str"");
  portField=new JTextField(Integer.toString(port));
  interfaceField=new JTextField(ip);
  requestHookURLField=new JTextField(requestHookURL);
  JButton saveButton=new JButton(""String_Node_Str"");
  saveButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      stdout.println(""String_Node_Str"");
      saveConfig();
    }
  }
);
  GroupLayout layout=new GroupLayout(panel);
  panel.setLayout(layout);
  layout.setAutoCreateGaps(true);
  layout.setAutoCreateContainerGaps(true);
  GroupLayout.SequentialGroup hGroup=layout.createSequentialGroup();
  hGroup.addGroup(layout.createParallelGroup().addComponent(interfaceLabel).addComponent(portLabel).addComponent(shLabel).addComponent(saveButton));
  hGroup.addGroup(layout.createParallelGroup().addComponent(interfaceField).addComponent(portField).addComponent(requestHookURLField));
  layout.setHorizontalGroup(hGroup);
  GroupLayout.SequentialGroup vGroup=layout.createSequentialGroup();
  vGroup.addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE).addComponent(interfaceLabel).addComponent(interfaceField));
  vGroup.addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE).addComponent(portLabel).addComponent(portField));
  vGroup.addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE).addComponent(shLabel).addComponent(requestHookURLField));
  vGroup.addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE).addComponent(saveButton));
  layout.setVerticalGroup(vGroup);
  restoreConfig();
  callbacks.customizeUiComponent(scroll);
  callbacks.addSuiteTab(BurpExtender.this);
}","@Override public void run(){
  panel=new JPanel();
  scroll=new JScrollPane(panel,JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
  scroll.setBorder(BorderFactory.createEmptyBorder());
  JLabel shLabel=new JLabel(""String_Node_Str"");
  JLabel portLabel=new JLabel(""String_Node_Str"");
  JLabel interfaceLabel=new JLabel(""String_Node_Str"");
  portField=new JTextField(Integer.toString(DEFAULT_PORT));
  interfaceField=new JTextField(DEFAULT_IP);
  requestHookURLField=new JTextField(DEFAULT_REQUEST_HOOK_URL);
  JButton saveButton=new JButton(""String_Node_Str"");
  saveButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      stdout.println(""String_Node_Str"");
      saveConfig();
    }
  }
);
  GroupLayout layout=new GroupLayout(panel);
  panel.setLayout(layout);
  layout.setAutoCreateGaps(true);
  layout.setAutoCreateContainerGaps(true);
  GroupLayout.SequentialGroup hGroup=layout.createSequentialGroup();
  hGroup.addGroup(layout.createParallelGroup().addComponent(interfaceLabel).addComponent(portLabel).addComponent(shLabel).addComponent(saveButton));
  hGroup.addGroup(layout.createParallelGroup().addComponent(interfaceField).addComponent(portField).addComponent(requestHookURLField));
  layout.setHorizontalGroup(hGroup);
  GroupLayout.SequentialGroup vGroup=layout.createSequentialGroup();
  vGroup.addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE).addComponent(interfaceLabel).addComponent(interfaceField));
  vGroup.addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE).addComponent(portLabel).addComponent(portField));
  vGroup.addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE).addComponent(shLabel).addComponent(requestHookURLField));
  vGroup.addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE).addComponent(saveButton));
  layout.setVerticalGroup(vGroup);
  restoreConfig();
  callbacks.customizeUiComponent(scroll);
  callbacks.addSuiteTab(BurpExtender.this);
}",0.3226443019240256
32308,"@Override public void registerExtenderCallbacks(final IBurpExtenderCallbacks callbacks){
  this.callbacks=callbacks;
  callbacks.setExtensionName(NAME);
  stdout=new PrintWriter(callbacks.getStdout(),true);
  stderr=new PrintWriter(callbacks.getStderr(),true);
  helpers=callbacks.getHelpers();
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      panel=new JPanel();
      scroll=new JScrollPane(panel,JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
      scroll.setBorder(BorderFactory.createEmptyBorder());
      JLabel shLabel=new JLabel(""String_Node_Str"");
      JLabel portLabel=new JLabel(""String_Node_Str"");
      JLabel interfaceLabel=new JLabel(""String_Node_Str"");
      portField=new JTextField(Integer.toString(port));
      interfaceField=new JTextField(ip);
      requestHookURLField=new JTextField(requestHookURL);
      JButton saveButton=new JButton(""String_Node_Str"");
      saveButton.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent e){
          stdout.println(""String_Node_Str"");
          saveConfig();
        }
      }
);
      GroupLayout layout=new GroupLayout(panel);
      panel.setLayout(layout);
      layout.setAutoCreateGaps(true);
      layout.setAutoCreateContainerGaps(true);
      GroupLayout.SequentialGroup hGroup=layout.createSequentialGroup();
      hGroup.addGroup(layout.createParallelGroup().addComponent(interfaceLabel).addComponent(portLabel).addComponent(shLabel).addComponent(saveButton));
      hGroup.addGroup(layout.createParallelGroup().addComponent(interfaceField).addComponent(portField).addComponent(requestHookURLField));
      layout.setHorizontalGroup(hGroup);
      GroupLayout.SequentialGroup vGroup=layout.createSequentialGroup();
      vGroup.addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE).addComponent(interfaceLabel).addComponent(interfaceField));
      vGroup.addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE).addComponent(portLabel).addComponent(portField));
      vGroup.addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE).addComponent(shLabel).addComponent(requestHookURLField));
      vGroup.addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE).addComponent(saveButton));
      layout.setVerticalGroup(vGroup);
      restoreConfig();
      callbacks.customizeUiComponent(scroll);
      callbacks.addSuiteTab(BurpExtender.this);
    }
  }
);
}","@Override public void registerExtenderCallbacks(final IBurpExtenderCallbacks callbacks){
  this.callbacks=callbacks;
  callbacks.setExtensionName(NAME);
  stdout=new PrintWriter(callbacks.getStdout(),true);
  stderr=new PrintWriter(callbacks.getStderr(),true);
  helpers=callbacks.getHelpers();
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      panel=new JPanel();
      scroll=new JScrollPane(panel,JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
      scroll.setBorder(BorderFactory.createEmptyBorder());
      JLabel shLabel=new JLabel(""String_Node_Str"");
      JLabel portLabel=new JLabel(""String_Node_Str"");
      JLabel interfaceLabel=new JLabel(""String_Node_Str"");
      portField=new JTextField(Integer.toString(DEFAULT_PORT));
      interfaceField=new JTextField(DEFAULT_IP);
      requestHookURLField=new JTextField(DEFAULT_REQUEST_HOOK_URL);
      JButton saveButton=new JButton(""String_Node_Str"");
      saveButton.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent e){
          stdout.println(""String_Node_Str"");
          saveConfig();
        }
      }
);
      GroupLayout layout=new GroupLayout(panel);
      panel.setLayout(layout);
      layout.setAutoCreateGaps(true);
      layout.setAutoCreateContainerGaps(true);
      GroupLayout.SequentialGroup hGroup=layout.createSequentialGroup();
      hGroup.addGroup(layout.createParallelGroup().addComponent(interfaceLabel).addComponent(portLabel).addComponent(shLabel).addComponent(saveButton));
      hGroup.addGroup(layout.createParallelGroup().addComponent(interfaceField).addComponent(portField).addComponent(requestHookURLField));
      layout.setHorizontalGroup(hGroup);
      GroupLayout.SequentialGroup vGroup=layout.createSequentialGroup();
      vGroup.addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE).addComponent(interfaceLabel).addComponent(interfaceField));
      vGroup.addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE).addComponent(portLabel).addComponent(portField));
      vGroup.addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE).addComponent(shLabel).addComponent(requestHookURLField));
      vGroup.addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE).addComponent(saveButton));
      layout.setVerticalGroup(vGroup);
      restoreConfig();
      callbacks.customizeUiComponent(scroll);
      callbacks.addSuiteTab(BurpExtender.this);
    }
  }
);
}",0.421031746031746
32309,"public ApiServer(String ip,int port,IBurpExtenderCallbacks callbacks){
  setPort(port);
  setIpAddress(ip);
  Gson gson=new Gson();
  get(""String_Node_Str"",(request,response) -> {
    IScanIssue[] rawIssues=callbacks.getScanIssues(""String_Node_Str"");
    List<BScanIssue> issues=new ArrayList<>();
    for (    IScanIssue issue : rawIssues) {
      issues.add(BScanIssueFactory.create(issue,callbacks));
    }
    return gson.toJson(issues);
  }
);
  post(""String_Node_Str"",(request,response) -> {
    BScanIssue issue=gson.fromJson(request.body(),BScanIssue.class);
    callbacks.addScanIssue(issue);
    response.status(201);
    return gson.toJson(issue);
  }
);
}","public ApiServer(String ip,int port,IBurpExtenderCallbacks callbacks){
  setPort(port);
  setIpAddress(ip);
  Gson gson=new Gson();
  get(""String_Node_Str"",(request,response) -> {
    IScanIssue[] rawIssues=callbacks.getScanIssues(""String_Node_Str"");
    List<BScanIssue> issues=new ArrayList<>();
    for (    IScanIssue issue : rawIssues) {
      issues.add(BScanIssueFactory.create(issue,callbacks));
    }
    return gson.toJson(issues);
  }
);
  get(""String_Node_Str"",(request,response) -> {
    byte[] encodedBytes=Base64.decodeBase64(request.params(""String_Node_Str""));
    IScanIssue[] rawIssues=callbacks.getScanIssues(new String(encodedBytes));
    List<BScanIssue> issues=new ArrayList<>();
    for (    IScanIssue issue : rawIssues) {
      issues.add(BScanIssueFactory.create(issue,callbacks));
    }
    return gson.toJson(issues);
  }
);
  post(""String_Node_Str"",(request,response) -> {
    BScanIssue issue=gson.fromJson(request.body(),BScanIssue.class);
    callbacks.addScanIssue(issue);
    response.status(201);
    return gson.toJson(issue);
  }
);
}",0.7675489067894131
32310,"public void setYFraction(float fraction){
  this.yFraction=fraction;
  if (getHeight() == 0) {
    if (preDrawListener == null) {
      preDrawListener=new ViewTreeObserver.OnPreDrawListener(){
        @Override public boolean onPreDraw(){
          getViewTreeObserver().removeOnPreDrawListener(preDrawListener);
          setYFraction(yFraction);
          return true;
        }
      }
;
    }
    getViewTreeObserver().addOnPreDrawListener(preDrawListener);
    return;
  }
  float translationY=getHeight() * fraction;
  setTranslationY(translationY);
}","public void setYFraction(float fraction){
  this.yFraction=fraction;
  if (getHeight() == 0) {
    if (preDrawListener == null) {
      preDrawListener=new ViewTreeObserver.OnPreDrawListener(){
        @Override public boolean onPreDraw(){
          getViewTreeObserver().removeOnPreDrawListener(preDrawListener);
          setYFraction(yFraction);
          return true;
        }
      }
;
      getViewTreeObserver().addOnPreDrawListener(preDrawListener);
    }
    return;
  }
  float translationY=getHeight() * fraction;
  setTranslationY(translationY);
}",0.9910554561717352
32311,"public VocabularyIndexAnalyzer() throws IOException, URISyntaxException {
  super(PER_FIELD_REUSE_STRATEGY);
  Map<String,Analyzer> fieldAnalyzers=new HashMap<>();
  fieldAnalyzers.put(NodeProperties.LABEL,new TermAnalyzer());
  fieldAnalyzers.put(NodeProperties.LABEL + LuceneUtils.EXACT_SUFFIX,new ExactAnalyzer());
  fieldAnalyzers.put(Concept.SYNONYM,new TermAnalyzer());
  fieldAnalyzers.put(Concept.SYNONYM + LuceneUtils.EXACT_SUFFIX,new ExactAnalyzer());
  fieldAnalyzers.put(Concept.ABREVIATION,new TermAnalyzer());
  fieldAnalyzers.put(Concept.ABREVIATION + LuceneUtils.EXACT_SUFFIX,new ExactAnalyzer());
  fieldAnalyzers.put(Concept.ACRONYM,new TermAnalyzer());
  fieldAnalyzers.put(Concept.ACRONYM + LuceneUtils.EXACT_SUFFIX,new ExactAnalyzer());
  analyzer=new PerFieldAnalyzerWrapper(new KeywordAnalyzer(),fieldAnalyzers);
}","public VocabularyIndexAnalyzer() throws IOException, URISyntaxException {
  super(NO_REUSE_STRATEGY);
  Map<String,Analyzer> fieldAnalyzers=new HashMap<>();
  fieldAnalyzers.put(NodeProperties.LABEL,new TermAnalyzer());
  fieldAnalyzers.put(NodeProperties.LABEL + LuceneUtils.EXACT_SUFFIX,new ExactAnalyzer());
  fieldAnalyzers.put(Concept.SYNONYM,new TermAnalyzer());
  fieldAnalyzers.put(Concept.SYNONYM + LuceneUtils.EXACT_SUFFIX,new ExactAnalyzer());
  fieldAnalyzers.put(Concept.ABREVIATION,new TermAnalyzer());
  fieldAnalyzers.put(Concept.ABREVIATION + LuceneUtils.EXACT_SUFFIX,new ExactAnalyzer());
  fieldAnalyzers.put(Concept.ACRONYM,new TermAnalyzer());
  fieldAnalyzers.put(Concept.ACRONYM + LuceneUtils.EXACT_SUFFIX,new ExactAnalyzer());
  analyzer=new PerFieldAnalyzerWrapper(new KeywordAnalyzer(),fieldAnalyzers);
}",0.9934013197360528
32312,"public VocabularyQueryAnalyzer(){
  super(PER_FIELD_REUSE_STRATEGY);
  Map<String,Analyzer> fieldAnalyzers=new HashMap<>();
  fieldAnalyzers.put(NodeProperties.LABEL,new TermAnalyzer());
  fieldAnalyzers.put(NodeProperties.LABEL + LuceneUtils.EXACT_SUFFIX,new ExactAnalyzer());
  fieldAnalyzers.put(Concept.SYNONYM,new TermAnalyzer());
  fieldAnalyzers.put(Concept.SYNONYM + LuceneUtils.EXACT_SUFFIX,new ExactAnalyzer());
  fieldAnalyzers.put(Concept.ABREVIATION,new TermAnalyzer());
  fieldAnalyzers.put(Concept.ABREVIATION + LuceneUtils.EXACT_SUFFIX,new ExactAnalyzer());
  fieldAnalyzers.put(Concept.ACRONYM,new TermAnalyzer());
  fieldAnalyzers.put(Concept.ACRONYM + LuceneUtils.EXACT_SUFFIX,new ExactAnalyzer());
  analyzer=new PerFieldAnalyzerWrapper(new KeywordAnalyzer(),fieldAnalyzers);
}","public VocabularyQueryAnalyzer(){
  Map<String,Analyzer> fieldAnalyzers=new HashMap<>();
  fieldAnalyzers.put(NodeProperties.LABEL,new TermAnalyzer());
  fieldAnalyzers.put(NodeProperties.LABEL + LuceneUtils.EXACT_SUFFIX,new ExactAnalyzer());
  fieldAnalyzers.put(Concept.SYNONYM,new TermAnalyzer());
  fieldAnalyzers.put(Concept.SYNONYM + LuceneUtils.EXACT_SUFFIX,new ExactAnalyzer());
  fieldAnalyzers.put(Concept.ABREVIATION,new TermAnalyzer());
  fieldAnalyzers.put(Concept.ABREVIATION + LuceneUtils.EXACT_SUFFIX,new ExactAnalyzer());
  fieldAnalyzers.put(Concept.ACRONYM,new TermAnalyzer());
  fieldAnalyzers.put(Concept.ACRONYM + LuceneUtils.EXACT_SUFFIX,new ExactAnalyzer());
  analyzer=new PerFieldAnalyzerWrapper(new KeywordAnalyzer(),fieldAnalyzers);
}",0.9775497113534316
32313,"@Override public List<Concept> searchConcepts(Query query){
  QueryParser parser=getQueryParser();
  Builder finalQueryBuilder=new BooleanQuery.Builder();
  try {
    if (query.isIncludeSynonyms() || query.isIncludeAbbreviations() || query.isIncludeAcronyms()) {
      Builder subQueryBuilder=new BooleanQuery.Builder();
      subQueryBuilder.add(LuceneUtils.getBoostedQuery(parser,query.getInput(),10.0f),Occur.SHOULD);
      String escapedQuery=QueryParser.escape(query.getInput());
      if (query.isIncludeSynonyms()) {
        subQueryBuilder.add(parser.parse(Concept.SYNONYM + ""String_Node_Str"" + escapedQuery),Occur.SHOULD);
      }
      if (query.isIncludeAbbreviations()) {
        subQueryBuilder.add(parser.parse(Concept.ABREVIATION + ""String_Node_Str"" + escapedQuery),Occur.SHOULD);
      }
      if (query.isIncludeAcronyms()) {
        subQueryBuilder.add(parser.parse(Concept.ACRONYM + ""String_Node_Str"" + escapedQuery),Occur.SHOULD);
      }
      finalQueryBuilder.add(subQueryBuilder.build(),Occur.MUST);
    }
 else {
      finalQueryBuilder.add(parser.parse(query.getInput()),Occur.MUST);
    }
  }
 catch (  ParseException e) {
    logger.log(Level.WARNING,""String_Node_Str"",e);
  }
  addCommonConstraints(finalQueryBuilder,query);
  IndexHits<Node> hits=null;
  BooleanQuery finalQuery=finalQueryBuilder.build();
  System.out.println(finalQuery);
  try {
    System.out.println(""String_Node_Str"");
    MatchAllDocsQuery matchAll=new MatchAllDocsQuery();
    TermQuery termQuery=new TermQuery(new Term(NodeProperties.LABEL,""String_Node_Str""));
    Builder b=new BooleanQuery.Builder();
    AnalyzingQueryParser myparser=new AnalyzingQueryParser(NodeProperties.LABEL,new VocabularyQueryAnalyzer());
    Builder b2=new BooleanQuery.Builder();
    org.apache.lucene.search.Query boosted=myparser.parse(""String_Node_Str"");
    boosted.setBoost(10.0f);
    b2.add(boosted,Occur.SHOULD);
    b2.add(myparser.parse(Concept.SYNONYM + ""String_Node_Str"" + ""String_Node_Str""),Occur.SHOULD);
    b.add(b2.build(),Occur.MUST);
    System.out.println(b.build());
    try (Transaction tx=graph.beginTx()){
      IndexHits<Node> hh=graph.index().getNodeAutoIndexer().getAutoIndex().query(b.build());
      tx.success();
      while (hh.hasNext()) {
        System.out.println(GraphUtil.getProperty(hh.next(),NodeProperties.LABEL,String.class));
      }
    }
     System.out.println(""String_Node_Str"");
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  try (Transaction tx=graph.beginTx()){
    hits=graph.index().getNodeAutoIndexer().getAutoIndex().query(finalQuery);
    tx.success();
  }
   return limitHits(hits,query);
}","@Override public List<Concept> searchConcepts(Query query){
  QueryParser parser=getQueryParser();
  Builder finalQueryBuilder=new BooleanQuery.Builder();
  try {
    if (query.isIncludeSynonyms() || query.isIncludeAbbreviations() || query.isIncludeAcronyms()) {
      Builder subQueryBuilder=new BooleanQuery.Builder();
      subQueryBuilder.add(LuceneUtils.getBoostedQuery(parser,query.getInput(),10.0f),Occur.SHOULD);
      String escapedQuery=QueryParser.escape(query.getInput());
      if (query.isIncludeSynonyms()) {
        subQueryBuilder.add(parser.parse(Concept.SYNONYM + ""String_Node_Str"" + escapedQuery),Occur.SHOULD);
      }
      if (query.isIncludeAbbreviations()) {
        subQueryBuilder.add(parser.parse(Concept.ABREVIATION + ""String_Node_Str"" + escapedQuery),Occur.SHOULD);
      }
      if (query.isIncludeAcronyms()) {
        subQueryBuilder.add(parser.parse(Concept.ACRONYM + ""String_Node_Str"" + escapedQuery),Occur.SHOULD);
      }
      finalQueryBuilder.add(subQueryBuilder.build(),Occur.MUST);
    }
 else {
      finalQueryBuilder.add(parser.parse(query.getInput()),Occur.MUST);
    }
  }
 catch (  ParseException e) {
    logger.log(Level.WARNING,""String_Node_Str"",e);
  }
  addCommonConstraints(finalQueryBuilder,query);
  IndexHits<Node> hits=null;
  BooleanQuery finalQuery=finalQueryBuilder.build();
  try (Transaction tx=graph.beginTx()){
    hits=graph.index().getNodeAutoIndexer().getAutoIndex().query(finalQuery);
    tx.success();
  }
   return limitHits(hits,query);
}",0.7275355336063599
32314,"public void processCategories(Map<String,String> categories) throws InterruptedException, ExecutionException {
  logger.info(""String_Node_Str"");
  final ExecutorService pool=Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
  List<Future<Map<String,List<Long>>>> contentsFutures=new ArrayList<>();
  Transaction tx=graphDb.beginTx();
  for (  Entry<String,String> category : categories.entrySet()) {
    ReadableIndex<Node> nodeIndex=graphDb.index().getNodeAutoIndexer().getAutoIndex();
    Node root=nodeIndex.get(CommonProperties.IRI,category.getKey()).getSingle();
    final Future<Map<String,List<Long>>> contentFuture=pool.submit(new CategoryProcessor(graphDb,root,category.getValue()));
    contentsFutures.add(contentFuture);
  }
  Map<String,List<Long>> toTag=new HashMap<String,List<Long>>();
  for (  Future<Map<String,List<Long>>> contentFuture : contentsFutures) {
    final Map<String,List<Long>> resolved=contentFuture.get();
    toTag.putAll(resolved);
  }
  pool.shutdown();
  pool.awaitTermination(10,TimeUnit.DAYS);
  tx.success();
  tx.close();
  tx=graphDb.beginTx();
  for (  Entry<String,List<Long>> t : toTag.entrySet()) {
    String category=t.getKey();
    logger.info(""String_Node_Str"" + t.getValue().size() + ""String_Node_Str""+ category);
    final ExecutorService taggingPool=Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
    List<Future<Boolean>> taggedFutures=new ArrayList<>();
    int partitionSize=1000;
    List<List<Long>> partitions=new LinkedList<List<Long>>();
    for (int i=0; i < t.getValue().size(); i+=partitionSize) {
      partitions.add(t.getValue().subList(i,Math.min(i + partitionSize,t.getValue().size())));
    }
    for (    List<Long> ids : partitions) {
      final Future<Boolean> contentFuture=taggingPool.submit(new CategoryLabeler(graphDb,ids,category));
      taggedFutures.add(contentFuture);
    }
    for (    Future<Boolean> taggedFuture : taggedFutures) {
      taggedFuture.get();
    }
    taggingPool.shutdown();
    taggingPool.awaitTermination(10,TimeUnit.DAYS);
  }
  tx.success();
  tx.close();
}","public void processCategories(Map<String,String> categories) throws InterruptedException, ExecutionException {
  logger.info(""String_Node_Str"");
  final ExecutorService pool=Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
  List<Future<Map<String,List<Long>>>> contentsFutures=new ArrayList<>();
  Transaction tx=graphDb.beginTx();
  for (  Entry<String,String> category : categories.entrySet()) {
    ReadableIndex<Node> nodeIndex=graphDb.index().getNodeAutoIndexer().getAutoIndex();
    Node root=nodeIndex.get(CommonProperties.IRI,category.getKey()).getSingle();
    final Future<Map<String,List<Long>>> contentFuture=pool.submit(new CategoryProcessor(graphDb,root,category.getValue()));
    contentsFutures.add(contentFuture);
  }
  Map<String,List<Long>> toTag=new HashMap<String,List<Long>>();
  for (  Future<Map<String,List<Long>>> contentFuture : contentsFutures) {
    final Map<String,List<Long>> resolved=contentFuture.get();
    String key=resolved.keySet().iterator().next();
    if (toTag.containsKey(key)) {
      List<Long> acc=toTag.get(key);
      acc.addAll(resolved.get(key));
      toTag.put(key,acc);
    }
 else {
      toTag.putAll(resolved);
    }
  }
  pool.shutdown();
  pool.awaitTermination(10,TimeUnit.DAYS);
  tx.success();
  tx.close();
  tx=graphDb.beginTx();
  for (  Entry<String,List<Long>> t : toTag.entrySet()) {
    String category=t.getKey();
    logger.info(""String_Node_Str"" + t.getValue().size() + ""String_Node_Str""+ category);
    final ExecutorService taggingPool=Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
    List<Future<Boolean>> taggedFutures=new ArrayList<>();
    int partitionSize=1000;
    List<List<Long>> partitions=new LinkedList<List<Long>>();
    for (int i=0; i < t.getValue().size(); i+=partitionSize) {
      partitions.add(t.getValue().subList(i,Math.min(i + partitionSize,t.getValue().size())));
    }
    for (    List<Long> ids : partitions) {
      final Future<Boolean> contentFuture=taggingPool.submit(new CategoryLabeler(graphDb,ids,category));
      taggedFutures.add(contentFuture);
    }
    for (    Future<Boolean> taggedFuture : taggedFutures) {
      taggedFuture.get();
    }
    taggingPool.shutdown();
    taggingPool.awaitTermination(10,TimeUnit.DAYS);
  }
  tx.success();
  tx.close();
}",0.950945094509451
32315,"@Override public Map<String,Set<Long>> call() throws Exception {
  logger.info(""String_Node_Str"" + category);
  Map<String,Set<Long>> map=new HashMap<String,Set<Long>>();
  Set<Long> nodeSet=new HashSet<Long>();
  Transaction tx=graphDb.beginTx();
  for (  Path position : graphDb.traversalDescription().uniqueness(Uniqueness.NODE_GLOBAL).depthFirst().relationships(OwlRelationships.RDFS_SUBCLASS_OF,Direction.INCOMING).relationships(OwlRelationships.RDF_TYPE,Direction.INCOMING).relationships(OwlRelationships.OWL_EQUIVALENT_CLASS,Direction.BOTH).relationships(OwlRelationships.OWL_SAME_AS,Direction.BOTH).traverse(root)) {
    Node end=position.endNode();
    nodeSet.add(end.getId());
  }
  tx.success();
  tx.close();
  logger.info(""String_Node_Str"" + nodeSet.size() + ""String_Node_Str""+ category);
  map.put(category,nodeSet);
  return map;
}","@Override public Map<String,Set<Long>> call() throws Exception {
  logger.info(""String_Node_Str"" + category);
  Map<String,Set<Long>> map=new HashMap<String,Set<Long>>();
  Set<Long> nodeSet=new HashSet<Long>();
  Transaction tx=graphDb.beginTx();
  try {
    for (    Path position : graphDb.traversalDescription().uniqueness(Uniqueness.NODE_GLOBAL).depthFirst().relationships(OwlRelationships.RDFS_SUBCLASS_OF,Direction.INCOMING).relationships(OwlRelationships.RDF_TYPE,Direction.INCOMING).relationships(OwlRelationships.OWL_EQUIVALENT_CLASS,Direction.BOTH).relationships(OwlRelationships.OWL_SAME_AS,Direction.BOTH).traverse(root)) {
      Node end=position.endNode();
      nodeSet.add(end.getId());
    }
    logger.info(""String_Node_Str"" + nodeSet.size() + ""String_Node_Str""+ category);
    map.put(category,nodeSet);
  }
 catch (  Exception e) {
    logger.warning(""String_Node_Str"" + category);
  }
 finally {
    tx.success();
    tx.close();
  }
  return map;
}",0.8976897689768977
32316,"public void processCategories(Map<String,String> categories) throws InterruptedException, ExecutionException {
  logger.info(""String_Node_Str"");
  final ExecutorService pool=Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
  List<Future<Map<String,Set<Long>>>> contentsFutures=new ArrayList<>();
  Transaction tx=graphDb.beginTx();
  for (  Entry<String,String> category : categories.entrySet()) {
    ReadableIndex<Node> nodeIndex=graphDb.index().getNodeAutoIndexer().getAutoIndex();
    Node root=nodeIndex.get(CommonProperties.IRI,category.getKey()).getSingle();
    final Future<Map<String,Set<Long>>> contentFuture=pool.submit(new CategoryProcessor(graphDb,root,category.getValue()));
    contentsFutures.add(contentFuture);
  }
  Map<String,Set<Long>> toTag=new HashMap<String,Set<Long>>();
  for (  Future<Map<String,Set<Long>>> contentFuture : contentsFutures) {
    final Map<String,Set<Long>> resolved=contentFuture.get();
    String key=resolved.keySet().iterator().next();
    if (toTag.containsKey(key)) {
      Set<Long> acc=toTag.get(key);
      acc.addAll(resolved.get(key));
      toTag.put(key,acc);
    }
 else {
      toTag.putAll(resolved);
    }
  }
  pool.shutdown();
  pool.awaitTermination(10,TimeUnit.DAYS);
  tx.success();
  tx.close();
  tx=graphDb.beginTx();
  for (  Entry<String,Set<Long>> t : toTag.entrySet()) {
    String category=t.getKey();
    logger.info(""String_Node_Str"" + t.getValue().size() + ""String_Node_Str""+ category);
    final ExecutorService taggingPool=Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
    List<Future<Boolean>> taggedFutures=new ArrayList<>();
    for (    List<Long> ids : Iterables.partition(t.getValue(),1000)) {
      final Future<Boolean> contentFuture=taggingPool.submit(new CategoryLabeler(graphDb,ids,category));
      taggedFutures.add(contentFuture);
    }
    for (    Future<Boolean> taggedFuture : taggedFutures) {
      taggedFuture.get();
    }
    taggingPool.shutdown();
    taggingPool.awaitTermination(10,TimeUnit.DAYS);
  }
  tx.success();
  tx.close();
}","public void processCategories(Map<String,String> categories) throws InterruptedException, ExecutionException {
  logger.info(""String_Node_Str"");
  final ExecutorService pool=Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
  List<Future<Map<String,Set<Long>>>> contentsFutures=new ArrayList<>();
  Transaction tx=graphDb.beginTx();
  for (  Entry<String,String> category : categories.entrySet()) {
    ReadableIndex<Node> nodeIndex=graphDb.index().getNodeAutoIndexer().getAutoIndex();
    Node root=nodeIndex.get(CommonProperties.IRI,category.getKey()).getSingle();
    final Future<Map<String,Set<Long>>> contentFuture=pool.submit(new CategoryProcessor(graphDb,root,category.getValue()));
    contentsFutures.add(contentFuture);
  }
  Map<String,Set<Long>> toTag=new HashMap<String,Set<Long>>();
  for (  Future<Map<String,Set<Long>>> contentFuture : contentsFutures) {
    final Map<String,Set<Long>> resolved=contentFuture.get();
    Iterator<String> iter=resolved.keySet().iterator();
    if (iter.hasNext()) {
      String key=resolved.keySet().iterator().next();
      if (toTag.containsKey(key)) {
        Set<Long> acc=toTag.get(key);
        acc.addAll(resolved.get(key));
        toTag.put(key,acc);
      }
 else {
        toTag.putAll(resolved);
      }
    }
  }
  pool.shutdown();
  pool.awaitTermination(10,TimeUnit.DAYS);
  tx.success();
  tx.close();
  tx=graphDb.beginTx();
  for (  Entry<String,Set<Long>> t : toTag.entrySet()) {
    String category=t.getKey();
    logger.info(""String_Node_Str"" + t.getValue().size() + ""String_Node_Str""+ category);
    final ExecutorService taggingPool=Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
    List<Future<Boolean>> taggedFutures=new ArrayList<>();
    for (    List<Long> ids : Iterables.partition(t.getValue(),1000)) {
      final Future<Boolean> contentFuture=taggingPool.submit(new CategoryLabeler(graphDb,ids,category));
      taggedFutures.add(contentFuture);
    }
    for (    Future<Boolean> taggedFuture : taggedFutures) {
      taggedFuture.get();
    }
    taggingPool.shutdown();
    taggingPool.awaitTermination(10,TimeUnit.DAYS);
  }
  tx.success();
  tx.close();
}",0.972481343283582
32317,"private void moveEdgesToLeader(Node leader,List<Node> clique,Transaction tx){
  for (  Node n : clique) {
    logger.fine(""String_Node_Str"" + n.getProperty(NodeProperties.IRI));
    int edgesMoved=0;
    Iterable<Relationship> rels=n.getRelationships();
    for (    Relationship rel : rels) {
      if ((isOneOfType(rel,relationships)) && (rel.getStartNode().getId() == leader.getId() || rel.getEndNode().getId() == leader.getId())) {
        logger.fine(""String_Node_Str"");
      }
 else {
        if ((rel.getEndNode().getId() == n.getId())) {
          logger.fine(""String_Node_Str"" + rel.getId() + ""String_Node_Str""+ n.getProperty(NodeProperties.IRI)+ ""String_Node_Str""+ leader.getProperty(NodeProperties.IRI));
          moveRelationship(n,leader,rel,ORIGINAL_REFERENCE_KEY_TARGET);
        }
 else         if ((rel.getStartNode().getId() == n.getId())) {
          logger.fine(""String_Node_Str"" + rel.getId() + ""String_Node_Str""+ n.getProperty(NodeProperties.IRI)+ ""String_Node_Str""+ leader.getProperty(NodeProperties.IRI));
          moveRelationship(n,leader,rel,ORIGINAL_REFERENCE_KEY_SOURCE);
        }
      }
      edgesMoved+=1;
      if (edgesMoved >= 100) {
        tx.success();
        tx.close();
        tx=graphDb.beginTx();
        edgesMoved=0;
      }
    }
  }
}","private void moveEdgesToLeader(Node leader,List<Node> clique,Transaction tx){
  for (  Node n : clique) {
    logger.fine(""String_Node_Str"" + n.getProperty(NodeProperties.IRI));
    int edgesMoved=0;
    Iterable<Relationship> rels=n.getRelationships();
    for (    Relationship rel : rels) {
      if ((isOneOfType(rel,relationships)) && (rel.getStartNode().getId() == leader.getId() || rel.getEndNode().getId() == leader.getId())) {
        logger.fine(""String_Node_Str"");
      }
 else {
        if ((rel.getEndNode().getId() == n.getId())) {
          logger.fine(""String_Node_Str"" + rel.getId() + ""String_Node_Str""+ n.getProperty(NodeProperties.IRI)+ ""String_Node_Str""+ leader.getProperty(NodeProperties.IRI));
          moveRelationship(n,leader,rel,ORIGINAL_REFERENCE_KEY_TARGET);
        }
 else         if ((rel.getStartNode().getId() == n.getId())) {
          logger.fine(""String_Node_Str"" + rel.getId() + ""String_Node_Str""+ n.getProperty(NodeProperties.IRI)+ ""String_Node_Str""+ leader.getProperty(NodeProperties.IRI));
          moveRelationship(n,leader,rel,ORIGINAL_REFERENCE_KEY_SOURCE);
        }
      }
      edgesMoved+=1;
      if (edgesMoved >= 100) {
        logger.fine(""String_Node_Str"" + leader.getProperty(NodeProperties.IRI) + ""String_Node_Str""+ n.getProperty(NodeProperties.IRI));
        tx.success();
        tx.close();
        tx=graphDb.beginTx();
        edgesMoved=0;
      }
    }
    deleteEdges(n,tx);
  }
}",0.9418221734357848
32318,"@Override public void run(){
  logger.info(""String_Node_Str"");
  GlobalGraphOperations globalGraphOperations=GlobalGraphOperations.at(graphDb);
  Transaction tx=graphDb.beginTx();
  ResourceIterable<Node> allNodes=globalGraphOperations.getAllNodes();
  int size=Iterators.size(allNodes.iterator());
  tx.success();
  tx.close();
  logger.info(size + ""String_Node_Str"");
  tx=graphDb.beginTx();
  TraversalDescription traversalDescription=graphDb.traversalDescription().breadthFirst().uniqueness(Uniqueness.NODE_GLOBAL);
  for (  RelationshipType rel : relationships) {
    traversalDescription=traversalDescription.relationships(rel,Direction.BOTH);
  }
  Set<Long> processedNodes=new HashSet<Long>();
  for (  Node baseNode : allNodes) {
    size-=1;
    if (size % 100000 == 0) {
      logger.info(size + ""String_Node_Str"");
    }
    if (size % 10 == 0) {
      tx.success();
      tx.close();
      tx=graphDb.beginTx();
    }
    logger.fine(""String_Node_Str"" + baseNode.getProperty(NodeProperties.IRI));
    if (!processedNodes.contains(baseNode.getId())) {
      List<Node> clique=new ArrayList<Node>();
      for (      Node node : traversalDescription.traverse(baseNode).nodes()) {
        logger.fine(""String_Node_Str"" + node.getProperty(NodeProperties.IRI));
        clique.add(node);
        processedNodes.add(node.getId());
      }
      logger.fine(""String_Node_Str"" + clique.size());
      if (clique.size() == 1) {
        Node defactoLeader=clique.get(0);
        markAsCliqueLeader(defactoLeader);
      }
 else {
        Node leader=electCliqueLeader(clique,prefixLeaderPriority);
        markAsCliqueLeader(leader);
        clique.remove(leader);
        ensureLabel(leader,clique);
        moveEdgesToLeader(leader,clique,tx);
      }
    }
  }
  tx.success();
  tx.close();
}","@Override public void run(){
  logger.info(""String_Node_Str"");
  GlobalGraphOperations globalGraphOperations=GlobalGraphOperations.at(graphDb);
  Transaction tx=graphDb.beginTx();
  ResourceIterable<Node> allNodes=globalGraphOperations.getAllNodes();
  int size=Iterators.size(allNodes.iterator());
  tx.success();
  tx.close();
  logger.info(size + ""String_Node_Str"");
  tx=graphDb.beginTx();
  TraversalDescription traversalDescription=graphDb.traversalDescription().breadthFirst().uniqueness(Uniqueness.NODE_GLOBAL);
  for (  RelationshipType rel : relationships) {
    traversalDescription=traversalDescription.relationships(rel,Direction.BOTH);
  }
  Set<Long> processedNodes=new HashSet<Long>();
  for (  Node baseNode : allNodes) {
    size-=1;
    if (size % 100000 == 0) {
      logger.info(size + ""String_Node_Str"");
    }
    if (size % 10 == 0) {
      logger.fine(""String_Node_Str"");
      tx.success();
      tx.close();
      tx=graphDb.beginTx();
    }
    logger.fine(""String_Node_Str"" + baseNode.getProperty(NodeProperties.IRI));
    if (!processedNodes.contains(baseNode.getId())) {
      List<Node> clique=new ArrayList<Node>();
      for (      Node node : traversalDescription.traverse(baseNode).nodes()) {
        logger.fine(""String_Node_Str"" + node.getProperty(NodeProperties.IRI));
        clique.add(node);
        processedNodes.add(node.getId());
      }
      logger.fine(""String_Node_Str"" + clique.size());
      if (clique.size() == 1) {
        Node defactoLeader=clique.get(0);
        markAsCliqueLeader(defactoLeader);
      }
 else {
        Node leader=electCliqueLeader(clique,prefixLeaderPriority);
        markAsCliqueLeader(leader);
        clique.remove(leader);
        moveEdgesToLeader(leader,clique,tx);
        ensureLabel(leader,clique);
      }
    }
  }
  tx.success();
  tx.close();
}",0.9405613648871768
32319,"private void moveRelationship(Node from,Node to,Relationship rel,String property){
  Relationship newRel=null;
  if (property == ORIGINAL_REFERENCE_KEY_TARGET) {
    newRel=rel.getOtherNode(from).createRelationshipTo(to,rel.getType());
  }
 else {
    newRel=to.createRelationshipTo(rel.getOtherNode(from),rel.getType());
  }
  copyProperties(rel,newRel);
  rel.delete();
  newRel.setProperty(property,from.getProperty(NodeProperties.IRI));
}","private void moveRelationship(Node from,Node to,Relationship rel,String property){
  Relationship newRel=null;
  logger.fine(""String_Node_Str"" + rel.getOtherNode(from).getId() + ""String_Node_Str""+ to.getId());
  if (property == ORIGINAL_REFERENCE_KEY_TARGET) {
    newRel=rel.getOtherNode(from).createRelationshipTo(to,rel.getType());
  }
 else {
    newRel=to.createRelationshipTo(rel.getOtherNode(from),rel.getType());
  }
  copyProperties(rel,newRel);
  rel.setProperty(REL_TO_REMOVE,true);
  newRel.setProperty(property,from.getProperty(NodeProperties.IRI));
}",0.8648111332007953
32320,"private void moveEdgesToLeader(Node leader,List<Node> clique,Transaction tx){
  for (  Node n : clique) {
    logger.fine(""String_Node_Str"" + n.getProperty(NodeProperties.IRI));
    int edgesMoved=0;
    Iterable<Relationship> rels=n.getRelationships();
    for (    Relationship rel : rels) {
      if ((isOneOfType(rel,relationships)) && (rel.getStartNode().getId() == leader.getId() || rel.getEndNode().getId() == leader.getId())) {
        logger.fine(""String_Node_Str"");
      }
 else {
        if ((rel.getEndNode().getId() == n.getId())) {
          logger.fine(""String_Node_Str"" + rel.getId() + ""String_Node_Str""+ n.getProperty(NodeProperties.IRI)+ ""String_Node_Str""+ leader.getProperty(NodeProperties.IRI));
          moveRelationship(n,leader,rel,ORIGINAL_REFERENCE_KEY_TARGET);
        }
 else         if ((rel.getStartNode().getId() == n.getId())) {
          logger.fine(""String_Node_Str"" + rel.getId() + ""String_Node_Str""+ n.getProperty(NodeProperties.IRI)+ ""String_Node_Str""+ leader.getProperty(NodeProperties.IRI));
          moveRelationship(n,leader,rel,ORIGINAL_REFERENCE_KEY_SOURCE);
        }
      }
      edgesMoved+=1;
      if (edgesMoved > 1000) {
        tx.success();
        tx.close();
        tx=graphDb.beginTx();
        edgesMoved=0;
      }
    }
  }
}","private void moveEdgesToLeader(Node leader,List<Node> clique,Transaction tx){
  for (  Node n : clique) {
    logger.fine(""String_Node_Str"" + n.getProperty(NodeProperties.IRI));
    int edgesMoved=0;
    Iterable<Relationship> rels=n.getRelationships();
    for (    Relationship rel : rels) {
      if ((isOneOfType(rel,relationships)) && (rel.getStartNode().getId() == leader.getId() || rel.getEndNode().getId() == leader.getId())) {
        logger.fine(""String_Node_Str"");
      }
 else {
        if ((rel.getEndNode().getId() == n.getId())) {
          logger.fine(""String_Node_Str"" + rel.getId() + ""String_Node_Str""+ n.getProperty(NodeProperties.IRI)+ ""String_Node_Str""+ leader.getProperty(NodeProperties.IRI));
          moveRelationship(n,leader,rel,ORIGINAL_REFERENCE_KEY_TARGET);
        }
 else         if ((rel.getStartNode().getId() == n.getId())) {
          logger.fine(""String_Node_Str"" + rel.getId() + ""String_Node_Str""+ n.getProperty(NodeProperties.IRI)+ ""String_Node_Str""+ leader.getProperty(NodeProperties.IRI));
          moveRelationship(n,leader,rel,ORIGINAL_REFERENCE_KEY_SOURCE);
        }
      }
      edgesMoved+=1;
      if (edgesMoved >= 100) {
        tx.success();
        tx.close();
        tx=graphDb.beginTx();
        edgesMoved=0;
      }
    }
  }
}",0.9992229992229992
32321,"private Node filterByPrefix(List<Node> clique,List<String> leaderPriorityIri){
  List<Node> filteredByPrefix=new ArrayList<Node>();
  if (!leaderPriorityIri.isEmpty()) {
    String iriPriority=leaderPriorityIri.get(0);
    for (    Node n : clique) {
      Optional<String> iri=GraphUtil.getProperty(n,NodeProperties.IRI,String.class);
      if (iri.isPresent() && iri.get().contains(iriPriority)) {
        filteredByPrefix.add(n);
      }
    }
    if (filteredByPrefix.isEmpty()) {
      filterByPrefix(clique,leaderPriorityIri.subList(1,leaderPriorityIri.size()));
    }
  }
  if (filteredByPrefix.isEmpty()) {
    filteredByPrefix=clique;
  }
  Collections.sort(filteredByPrefix,new Comparator<Node>(){
    @Override public int compare(    Node node1,    Node node2){
      Optional<String> iri1=GraphUtil.getProperty(node1,NodeProperties.IRI,String.class);
      Optional<String> iri2=GraphUtil.getProperty(node2,NodeProperties.IRI,String.class);
      return iri1.get().compareTo(iri2.get());
    }
  }
);
  List<Node> filteredByPrefixAndForbiddenLabels=new ArrayList<Node>();
  for (  Node n : filteredByPrefix) {
    if (!containsOneLabel(n,forbiddenLabels)) {
      filteredByPrefixAndForbiddenLabels.add(n);
    }
  }
  if (filteredByPrefixAndForbiddenLabels.isEmpty()) {
    return filteredByPrefix.get(0);
  }
 else {
    return filteredByPrefixAndForbiddenLabels.get(0);
  }
}","private Node filterByPrefix(List<Node> clique,List<String> leaderPriorityIri){
  List<Node> filteredByPrefix=new ArrayList<Node>();
  if (!leaderPriorityIri.isEmpty()) {
    String iriPriority=leaderPriorityIri.get(0);
    for (    Node n : clique) {
      Optional<String> iri=GraphUtil.getProperty(n,NodeProperties.IRI,String.class);
      if (iri.isPresent() && iri.get().contains(iriPriority)) {
        filteredByPrefix.add(n);
      }
    }
    if (filteredByPrefix.isEmpty()) {
      filteredByPrefix.add(filterByPrefix(clique,leaderPriorityIri.subList(1,leaderPriorityIri.size())));
    }
  }
  if (filteredByPrefix.isEmpty()) {
    filteredByPrefix=clique;
  }
  Collections.sort(filteredByPrefix,new Comparator<Node>(){
    @Override public int compare(    Node node1,    Node node2){
      Optional<String> iri1=GraphUtil.getProperty(node1,NodeProperties.IRI,String.class);
      Optional<String> iri2=GraphUtil.getProperty(node2,NodeProperties.IRI,String.class);
      return iri1.get().compareTo(iri2.get());
    }
  }
);
  List<Node> filteredByPrefixAndForbiddenLabels=new ArrayList<Node>();
  for (  Node n : filteredByPrefix) {
    if (!containsOneLabel(n,forbiddenLabels)) {
      filteredByPrefixAndForbiddenLabels.add(n);
    }
  }
  if (filteredByPrefixAndForbiddenLabels.isEmpty()) {
    return filteredByPrefix.get(0);
  }
 else {
    return filteredByPrefixAndForbiddenLabels.get(0);
  }
}",0.99214846538187
32322,"@Override public void invoke(Graph graph){
  GlobalGraphOperations globalGraphOperations=GlobalGraphOperations.at(graphDb);
  Transaction tx=graphDb.beginTx();
  ResourceIterable<Node> allNodes=globalGraphOperations.getAllNodes();
  int size=Iterators.size(allNodes.iterator());
  tx.success();
  logger.fine(size + ""String_Node_Str"");
  for (  Node baseNode : allNodes) {
    size-=1;
    if (size % 10 == 0) {
      tx.success();
      tx.close();
      tx=graphDb.beginTx();
    }
    if (size % 100000 == 0) {
      logger.info(size + ""String_Node_Str"");
    }
    if (!baseNode.hasLabel(OwlLabels.OWL_ANONYMOUS)) {
      logger.fine(""String_Node_Str"" + baseNode.getProperty(NodeProperties.IRI));
      if (!baseNode.hasRelationship(IS_EQUIVALENT) && !baseNode.hasRelationship(SAME_AS)) {
        markAsCliqueLeader(baseNode);
      }
 else {
        List<Node> clique=new ArrayList<Node>();
        for (        Node currentNode : graphDb.traversalDescription().relationships(IS_EQUIVALENT,Direction.BOTH).relationships(SAME_AS,Direction.BOTH).uniqueness(Uniqueness.NODE_GLOBAL).traverse(baseNode).nodes()) {
          clique.add(currentNode);
        }
        if (!hasLeader(clique)) {
          Node leader=electCliqueLeader(clique,prefixLeaderPriority);
          markAsCliqueLeader(leader);
          clique.remove(leader);
          markLeaderEdges(leader);
          moveEdgesToLeader(leader,clique);
          ensureLabel(leader,clique);
        }
      }
    }
  }
  tx.success();
}","@Override public void invoke(Graph graph){
  GlobalGraphOperations globalGraphOperations=GlobalGraphOperations.at(graphDb);
  Transaction tx=graphDb.beginTx();
  ResourceIterable<Node> allNodes=globalGraphOperations.getAllNodes();
  int size=Iterators.size(allNodes.iterator());
  tx.success();
  logger.fine(size + ""String_Node_Str"");
  for (  Node baseNode : allNodes) {
    size-=1;
    if (size % 10 == 0) {
      tx.success();
      tx.close();
      tx=graphDb.beginTx();
    }
    if (size % 100000 == 0) {
      logger.info(size + ""String_Node_Str"");
    }
    logger.fine(""String_Node_Str"" + baseNode.getProperty(NodeProperties.IRI));
    if (!baseNode.hasRelationship(IS_EQUIVALENT) && !baseNode.hasRelationship(SAME_AS)) {
      markAsCliqueLeader(baseNode);
    }
 else {
      List<Node> clique=new ArrayList<Node>();
      for (      Node currentNode : graphDb.traversalDescription().relationships(IS_EQUIVALENT,Direction.BOTH).relationships(SAME_AS,Direction.BOTH).uniqueness(Uniqueness.NODE_GLOBAL).traverse(baseNode).nodes()) {
        clique.add(currentNode);
      }
      if (!hasLeader(clique)) {
        Node leader=electCliqueLeader(clique,prefixLeaderPriority);
        markAsCliqueLeader(leader);
        clique.remove(leader);
        markLeaderEdges(leader);
        moveEdgesToLeader(leader,clique);
        ensureLabel(leader,clique);
      }
    }
  }
  tx.success();
}",0.9568221070811744
32323,"private Node filterByIri(List<Node> clique,List<String> leaderPriorityIri){
  List<Node> filteredByIriNodes=new ArrayList<Node>();
  if (!leaderPriorityIri.isEmpty()) {
    String iriPriority=leaderPriorityIri.get(0);
    for (    Node n : clique) {
      Optional<String> iri=GraphUtil.getProperty(n,NodeProperties.IRI,String.class);
      if (iri.isPresent() && iri.get().contains(iriPriority)) {
        filteredByIriNodes.add(n);
      }
    }
    if (filteredByIriNodes.isEmpty()) {
      filterByIri(clique,leaderPriorityIri.subList(1,leaderPriorityIri.size()));
    }
  }
  if (filteredByIriNodes.isEmpty()) {
    filteredByIriNodes=clique;
  }
  Collections.sort(filteredByIriNodes,new Comparator<Node>(){
    @Override public int compare(    Node node1,    Node node2){
      Optional<String> iri1=GraphUtil.getProperty(node1,NodeProperties.IRI,String.class);
      Optional<String> iri2=GraphUtil.getProperty(node2,NodeProperties.IRI,String.class);
      return iri1.get().compareTo(iri2.get());
    }
  }
);
  return filteredByIriNodes.get(0);
}","private Node filterByIri(List<Node> clique,List<String> leaderPriorityIri){
  List<Node> filteredByIriNodes=new ArrayList<Node>();
  if (!leaderPriorityIri.isEmpty()) {
    String iriPriority=leaderPriorityIri.get(0);
    for (    Node n : clique) {
      Optional<String> iri=GraphUtil.getProperty(n,NodeProperties.IRI,String.class);
      if (iri.isPresent() && iri.get().contains(iriPriority)) {
        filteredByIriNodes.add(n);
      }
    }
    if (filteredByIriNodes.isEmpty()) {
      filterByIri(clique,leaderPriorityIri.subList(1,leaderPriorityIri.size()));
    }
  }
  if (filteredByIriNodes.isEmpty()) {
    filteredByIriNodes=clique;
  }
  Collections.sort(filteredByIriNodes,new Comparator<Node>(){
    @Override public int compare(    Node node1,    Node node2){
      Optional<String> iri1=GraphUtil.getProperty(node1,NodeProperties.IRI,String.class);
      Optional<String> iri2=GraphUtil.getProperty(node2,NodeProperties.IRI,String.class);
      return iri1.get().compareTo(iri2.get());
    }
  }
);
  List<Node> filteredByIriNodesWithoutAnonymousNodes=new ArrayList<Node>();
  for (  Node n : filteredByIriNodes) {
    if (!n.hasLabel(OwlLabels.OWL_ANONYMOUS)) {
      filteredByIriNodesWithoutAnonymousNodes.add(n);
    }
  }
  if (filteredByIriNodesWithoutAnonymousNodes.isEmpty()) {
    return filteredByIriNodes.get(0);
  }
 else {
    return filteredByIriNodesWithoutAnonymousNodes.get(0);
  }
}",0.8481421647819063
32324,"@Override public String lookup(String key){
  Collection<String> resolvedRelationshipTypes=transform(valueMap.get(key),new Function<Object,String>(){
    @Override public String apply(    Object input){
      Optional<String> iri=curieUtil.getIri(input.toString());
      if (iri.isPresent()) {
        return GraphUtil.getFragment(iri.get());
      }
 else {
        return input.toString();
      }
    }
  }
);
  return on('|').join(resolvedRelationshipTypes);
}","@Override public String lookup(String key){
  Collection<String> resolvedRelationshipTypes=transform(valueMap.get(key),new Function<Object,String>(){
    @Override public String apply(    Object input){
      if (input.toString().matches(""String_Node_Str"")) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      Optional<String> iri=curieUtil.getIri(input.toString());
      if (iri.isPresent()) {
        return GraphUtil.getFragment(iri.get());
      }
 else {
        return input.toString();
      }
    }
  }
);
  return on('|').join(resolvedRelationshipTypes);
}",0.8790170132325141
32325,"@Override public String apply(Object input){
  Optional<String> iri=curieUtil.getIri(input.toString());
  if (iri.isPresent()) {
    return GraphUtil.getFragment(iri.get());
  }
 else {
    return input.toString();
  }
}","@Override public String apply(Object input){
  if (input.toString().matches(""String_Node_Str"")) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Optional<String> iri=curieUtil.getIri(input.toString());
  if (iri.isPresent()) {
    return GraphUtil.getFragment(iri.get());
  }
 else {
    return input.toString();
  }
}",0.7913669064748201
32326,"String substituteRelationships(String query,final Multimap<String,Object> valueMap){
  StrSubstitutor substitutor=new StrSubstitutor(new StrLookup<String>(){
    @Override public String lookup(    String key){
      Collection<String> resolvedRelationshipTypes=transform(valueMap.get(key),new Function<Object,String>(){
        @Override public String apply(        Object input){
          Optional<String> iri=curieUtil.getIri(input.toString());
          if (iri.isPresent()) {
            return GraphUtil.getFragment(iri.get());
          }
 else {
            return input.toString();
          }
        }
      }
);
      return on('|').join(resolvedRelationshipTypes);
    }
  }
);
  return substitutor.replace(query);
}","String substituteRelationships(String query,final Multimap<String,Object> valueMap){
  StrSubstitutor substitutor=new StrSubstitutor(new StrLookup<String>(){
    @Override public String lookup(    String key){
      Collection<String> resolvedRelationshipTypes=transform(valueMap.get(key),new Function<Object,String>(){
        @Override public String apply(        Object input){
          if (input.toString().matches(""String_Node_Str"")) {
            throw new IllegalArgumentException(""String_Node_Str"");
          }
          Optional<String> iri=curieUtil.getIri(input.toString());
          if (iri.isPresent()) {
            return GraphUtil.getFragment(iri.get());
          }
 else {
            return input.toString();
          }
        }
      }
);
      return on('|').join(resolvedRelationshipTypes);
    }
  }
);
  return substitutor.replace(query);
}",0.9123904881101376
32327,"Set<String> getEntailedRelationshipTypes(Set<String> parents){
  Set<String> entailedTypes=new HashSet<>();
  for (  String parent : parents) {
    if (curieUtil.getIri(parent).isPresent()) {
      parent=GraphUtil.getFragment(curieUtil.getIri(parent).get());
    }
    entailedTypes.add(parent);
    Map<String,Object> params=new HashMap<>();
    params.put(""String_Node_Str"",parent);
    try (Transaction tx=graphDb.beginTx()){
      Result result=graphDb.execute(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",params);
      while (result.hasNext()) {
        Map<String,Object> map=result.next();
        entailedTypes.add((String)map.get(""String_Node_Str""));
      }
      tx.success();
    }
   }
  return entailedTypes;
}","Set<String> getEntailedRelationshipTypes(Collection<String> parents){
  Set<String> entailedTypes=new HashSet<>();
  for (  String parent : parents) {
    entailedTypes.add(parent);
    Map<String,Object> params=new HashMap<>();
    params.put(""String_Node_Str"",parent);
    try (Transaction tx=graphDb.beginTx()){
      Result result=graphDb.execute(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",params);
      while (result.hasNext()) {
        Map<String,Object> map=result.next();
        entailedTypes.add((String)map.get(""String_Node_Str""));
      }
      tx.success();
    }
   }
  return entailedTypes;
}",0.900953778429934
32328,"@Test public void curiesAreEntailed(){
  String result=util.entailRelationships(""String_Node_Str"");
  assertThat(result,is(""String_Node_Str""));
}","@Test public void curiesAreEntailed(){
  String result=util.resolveRelationships(""String_Node_Str"");
  assertThat(result,is(""String_Node_Str""));
}",0.9690721649484536
32329,"@Test public void entailmentRegex(){
  String result=util.entailRelationships(""String_Node_Str"");
  assertThat(result,is(""String_Node_Str""));
}","@Test public void entailmentRegex(){
  String result=util.resolveRelationships(""String_Node_Str"");
  assertThat(result,is(""String_Node_Str""));
}",0.9686411149825784
32330,"public Collection<String> getFullUri(final String curie){
  Preconditions.checkNotNull(curie);
  Preconditions.checkState(curie.contains(""String_Node_Str""),""String_Node_Str"");
  String prefix=curie.split(""String_Node_Str"")[0];
  if (uriMap.containsKey(prefix)) {
    return transform(uriMap.get(prefix),new Function<String,String>(){
      @Override public String apply(      String uriPrefix){
        return String.format(""String_Node_Str"",uriPrefix,curie.substring(curie.indexOf(':') + 1));
      }
    }
);
  }
  return Collections.emptySet();
}","public Collection<String> getFullUri(final String curie){
  Preconditions.checkNotNull(curie);
  String[] parts=curie.split(""String_Node_Str"");
  if (1 == parts.length) {
    return Collections.emptySet();
  }
  String prefix=parts[0];
  if (uriMap.containsKey(prefix)) {
    return transform(uriMap.get(prefix),new Function<String,String>(){
      @Override public String apply(      String uriPrefix){
        return String.format(""String_Node_Str"",uriPrefix,curie.substring(curie.indexOf(':') + 1));
      }
    }
);
  }
  return Collections.emptySet();
}",0.8310749774164409
32331,"@Override public int hashCode(){
  return new Long(getId()).hashCode();
}","@Override public int hashCode(){
  return Long.valueOf(getId()).hashCode();
}",0.92
32332,"@Override protected ConcurrentMap<String,Long> delegate(){
  return delegate();
}","@Override protected ConcurrentMap<String,Long> delegate(){
  return delegate;
}",0.9875
32333,"@Override protected ConcurrentMap<BatchEdge,Long> delegate(){
  return delegate();
}","@Override protected ConcurrentMap<BatchEdge,Long> delegate(){
  return delegate;
}",0.9879518072289156
32334,"public void setNodeProperty(long batchId,String property,Object value){
  if (!ignoreProperty(value)) {
    inserter.setNodeProperty(batchId,property,value);
    Map<String,Object> indexProperties=collectIndexProperties(inserter.getNodeProperties(batchId));
    if (!indexProperties.isEmpty()) {
      logger.fine(""String_Node_Str"" + indexProperties);
      nodeIndex.updateOrAdd(batchId,indexProperties);
    }
  }
}","public void setNodeProperty(long batchId,String property,Object value){
  try {
    if (!ignoreProperty(value)) {
      inserter.setNodeProperty(batchId,property,value);
      Map<String,Object> indexProperties=collectIndexProperties(inserter.getNodeProperties(batchId));
      if (!indexProperties.isEmpty()) {
        logger.fine(""String_Node_Str"" + indexProperties);
        nodeIndex.updateOrAdd(batchId,indexProperties);
      }
    }
  }
 catch (  Exception e) {
    logger.log(Level.WARNING,""String_Node_Str"" + property + ""String_Node_Str""+ value+ ""String_Node_Str""+ batchId,e);
  }
}",0.8273809523809523
32335,"void loadOntology(){
  Stopwatch timer=Stopwatch.createStarted();
  logger.info(""String_Node_Str"");
  walker.walkStructure(visitor);
  logger.info(format(""String_Node_Str"",timer.elapsed(TimeUnit.SECONDS)));
  timer.reset();
  timer.start();
  logger.info(""String_Node_Str"");
  postprocessor.processSomeValuesFrom();
  logger.info(format(""String_Node_Str"",timer.elapsed(TimeUnit.SECONDS)));
  timer.reset();
  timer.start();
  logger.info(""String_Node_Str"");
  logger.info(format(""String_Node_Str"",timer.elapsed(TimeUnit.SECONDS)));
  postprocessor.processSomeValuesFrom();
}","void loadOntology(){
  Stopwatch timer=Stopwatch.createStarted();
  logger.info(""String_Node_Str"");
  walker.walkStructure(visitor);
  visitor.shutdown();
  logger.info(format(""String_Node_Str"",timer.elapsed(TimeUnit.SECONDS)));
  timer.reset();
  timer.start();
  logger.info(""String_Node_Str"");
  postprocessorProvider.get().postprocess();
  logger.info(format(""String_Node_Str"",timer.elapsed(TimeUnit.SECONDS)));
  postprocessorProvider.shutdown();
}",0.7322297955209348
32336,"public static void load(OwlLoadConfiguration config){
  Injector i=Guice.createInjector(new Neo4jModule(config.getOntologyConfiguration()),new OwlLoaderModule(config));
  BatchOwlLoader loader=i.getInstance(BatchOwlLoader.class);
  logger.info(""String_Node_Str"");
  Stopwatch timer=Stopwatch.createStarted();
  loader.loadOntology();
  logger.info(format(""String_Node_Str"",timer.elapsed(TimeUnit.MINUTES)));
}","public static void load(OwlLoadConfiguration config){
  Injector i=Guice.createInjector(new OwlLoaderModule(config));
  BatchOwlLoader loader=i.getInstance(BatchOwlLoader.class);
  logger.info(""String_Node_Str"");
  Stopwatch timer=Stopwatch.createStarted();
  loader.loadOntology();
  logger.info(format(""String_Node_Str"",timer.elapsed(TimeUnit.MINUTES)));
}",0.9335071707953064
32337,"@Provides BatchInserter getInserter(){
  return BatchInserters.inserter(config.getOntologyConfiguration().getGraphLocation());
}","@Provides @Singleton BatchInserter getInserter(){
  logger.info(""String_Node_Str"");
  return BatchInserters.inserter(config.getOntologyConfiguration().getGraphLocation());
}",0.8504983388704319
32338,"@Override protected void configure(){
  bindConstant().annotatedWith(Names.named(""String_Node_Str"")).to(CommonProperties.URI);
  bind(new TypeLiteral<Set<String>>(){
  }
).annotatedWith(Names.named(""String_Node_Str"")).toInstance(config.getIndexedNodeProperties());
  bind(new TypeLiteral<Set<String>>(){
  }
).annotatedWith(Names.named(""String_Node_Str"")).toInstance(config.getExactNodeProperties());
}","@Override protected void configure(){
  bind(OwlLoadConfiguration.class).toInstance(config);
  bindConstant().annotatedWith(Names.named(""String_Node_Str"")).to(CommonProperties.URI);
  bind(new TypeLiteral<Set<String>>(){
  }
).annotatedWith(Names.named(""String_Node_Str"")).toInstance(config.getIndexedNodeProperties());
  bind(new TypeLiteral<Set<String>>(){
  }
).annotatedWith(Names.named(""String_Node_Str"")).toInstance(config.getExactNodeProperties());
  bind(new TypeLiteral<Map<String,String>>(){
  }
).annotatedWith(Names.named(""String_Node_Str"")).toInstance(config.getCategories());
}",0.8096676737160121
32339,"public Collection<Entity> getEntities(String token,EntityFormatConfiguration config){
  Query query=new Vocabulary.Query.Builder(token).build();
  List<Concept> terms=vocabulary.getConceptsFromTerm(query);
  Set<Entity> entities=Sets.newHashSet();
  for (  Concept term : terms) {
    if (shouldAnnotate(term,config)) {
      entities.add(new Entity(term));
    }
  }
  return entities;
}","public Collection<Entity> getEntities(String token,EntityFormatConfiguration config){
  Query query=new Vocabulary.Query.Builder(token).build();
  List<Concept> terms=vocabulary.getConceptsFromTerm(query);
  Set<Entity> entities=newHashSet();
  for (  Concept term : terms) {
    if (shouldAnnotate(term,config)) {
      entities.add(new Entity(term));
    }
  }
  return entities;
}",0.993514915693904
32340,"public Set<Long> getOutList(){
  return outList;
}","Set<Long> getOutList(){
  return outList;
}",0.9247311827956988
32341,"private boolean nodesAreConnectedInIndex(long nodeIdOut,long nodeIdIn){
  Set<Long> outList=inMemoryIdx.get(nodeIdOut).getOutList();
  Set<Long> inList=inMemoryIdx.get(nodeIdIn).getInList();
  return !Collections.disjoint(outList,inList);
}","boolean nodesAreConnectedInIndex(long nodeIdOut,long nodeIdIn){
  Set<Long> outList=inMemoryIdx.get(nodeIdOut).getOutList();
  Set<Long> inList=inMemoryIdx.get(nodeIdIn).getInList();
  return !Collections.disjoint(outList,inList);
}",0.9830508474576272
32342,"/** 
 * Create a reachability index on a graph.
 * @throws InterruptedException 
 */
public void createIndex(){
  if (indexExists()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  long startTime=System.currentTimeMillis();
  Set<Entry<Long,Integer>> hopCoverages=getHopCoverages();
  long endTime=System.currentTimeMillis();
  logger.fine(format(""String_Node_Str"",TimeUnit.MILLISECONDS.toSeconds(endTime - startTime)));
  MemoryReachabilityIndex inMemoryIndex=new MemoryReachabilityIndex();
  TraversalDescription incomingTraversal=Traversal.description().breadthFirst().uniqueness(Uniqueness.NODE_GLOBAL).expand(new DirectionalPathExpander(Direction.INCOMING)).evaluator(new ReachabilityEvaluator(inMemoryIndex,Direction.INCOMING,forbiddenNodes));
  TraversalDescription outgoingTraversal=Traversal.description().breadthFirst().uniqueness(Uniqueness.NODE_GLOBAL).expand(new DirectionalPathExpander(Direction.OUTGOING)).evaluator(new ReachabilityEvaluator(inMemoryIndex,Direction.OUTGOING,forbiddenNodes));
  long bfsTime=0, rbfsTime=0;
  for (  Entry<Long,Integer> coverage : hopCoverages) {
    Node workingNode=graphDb.getNodeById(coverage.getKey());
    startTime=System.currentTimeMillis();
    InOutListTraverser incomingListTaverser=new InOutListTraverser(incomingTraversal,workingNode);
    incomingListTaverser.start();
    InOutListTraverser outgoingListTaverser=new InOutListTraverser(outgoingTraversal,workingNode);
    outgoingListTaverser.start();
    try {
      incomingListTaverser.join();
      outgoingListTaverser.join();
    }
 catch (    InterruptedException e) {
      throw new RuntimeException(""String_Node_Str"");
    }
    endTime=System.currentTimeMillis();
    rbfsTime+=endTime - startTime;
    for (    Path p : outgoingTraversal.traverse(workingNode)) {
      logger.finest(p.toString());
    }
    bfsTime+=System.currentTimeMillis() - endTime;
  }
  logger.fine(""String_Node_Str"" + (bfsTime / 1000) + ""String_Node_Str""+ (rbfsTime / 1000)+ ""String_Node_Str"");
  commitIndexToGraph(inMemoryIndex);
  logger.info(""String_Node_Str"");
}","/** 
 * Create a reachability index on a graph.
 * @throws InterruptedException 
 */
public void createIndex(){
  if (indexExists()) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  long startTime=System.currentTimeMillis();
  Set<Entry<Long,Integer>> hopCoverages=getHopCoverages();
  long endTime=System.currentTimeMillis();
  logger.fine(format(""String_Node_Str"",TimeUnit.MILLISECONDS.toSeconds(endTime - startTime)));
  MemoryReachabilityIndex inMemoryIndex=new MemoryReachabilityIndex();
  TraversalDescription incomingTraversal=Traversal.description().breadthFirst().uniqueness(Uniqueness.NODE_GLOBAL).expand(new DirectionalPathExpander(Direction.INCOMING)).evaluator(new ReachabilityEvaluator(inMemoryIndex,Direction.INCOMING,forbiddenNodes));
  TraversalDescription outgoingTraversal=Traversal.description().breadthFirst().uniqueness(Uniqueness.NODE_GLOBAL).expand(new DirectionalPathExpander(Direction.OUTGOING)).evaluator(new ReachabilityEvaluator(inMemoryIndex,Direction.OUTGOING,forbiddenNodes));
  for (  Entry<Long,Integer> coverage : hopCoverages) {
    Node workingNode=graphDb.getNodeById(coverage.getKey());
    startTime=System.currentTimeMillis();
    InOutListTraverser incomingListTaverser=new InOutListTraverser(incomingTraversal,workingNode);
    incomingListTaverser.start();
    InOutListTraverser outgoingListTaverser=new InOutListTraverser(outgoingTraversal,workingNode);
    outgoingListTaverser.start();
    try {
      incomingListTaverser.join();
      outgoingListTaverser.join();
    }
 catch (    InterruptedException e) {
      throw new RuntimeException(""String_Node_Str"");
    }
    endTime=System.currentTimeMillis();
  }
  logger.fine(""String_Node_Str"" + ((endTime - startTime) / 1000) + ""String_Node_Str"");
  commitIndexToGraph(inMemoryIndex);
  logger.info(""String_Node_Str"");
}",0.8912155260469867
32343,"@Test public void embeddedCollectionTest(){
  entityManager.getTransaction().begin();
  Hike hike=new Hike(""String_Node_Str"",""String_Node_Str"");
  hike.sections.add(new Section(""String_Node_Str"",""String_Node_Str""));
  hike.sections.add(new Section(""String_Node_Str"",""String_Node_Str""));
  entityManager.persist(hike);
  entityManager.getTransaction().commit();
  entityManager.getTransaction().begin();
  hike=entityManager.find(Hike.class,hike.id);
  assertThat(hike.sections).hasSize(2);
  assertThat(hike.sections.get(0).from).isEqualTo(""String_Node_Str"");
  assertThat(hike.sections.get(1).from).isEqualTo(""String_Node_Str"");
  entityManager.getTransaction().commit();
}","@Test public void embeddedCollectionTest(){
  entityManager.getTransaction().begin();
  Hike hike=new Hike(""String_Node_Str"",""String_Node_Str"");
  hike.sections.add(new Section(""String_Node_Str"",""String_Node_Str""));
  hike.sections.add(new Section(""String_Node_Str"",""String_Node_Str""));
  entityManager.persist(hike);
  entityManager.flush();
  entityManager.clear();
  hike=entityManager.find(Hike.class,hike.id);
  assertThat(hike.sections).hasSize(2);
  assertThat(hike.sections.get(0).from).isEqualTo(""String_Node_Str"");
  assertThat(hike.sections.get(1).from).isEqualTo(""String_Node_Str"");
  entityManager.getTransaction().commit();
}",0.958111195734958
32344,"@Test public void associationTest(){
  entityManager.getTransaction().begin();
  Hike hike=new Hike(""String_Node_Str"",""String_Node_Str"");
  Trip trip=new Trip();
  trip.name=""String_Node_Str"";
  hike.recommendedTrip=trip;
  trip.availableHikes.add(hike);
  entityManager.persist(trip);
  entityManager.persist(hike);
  entityManager.getTransaction().commit();
  entityManager.getTransaction().begin();
  hike=entityManager.find(Hike.class,hike.id);
  assertThat(hike.recommendedTrip).isNotNull();
  assertThat(hike.recommendedTrip.name).isEqualTo(""String_Node_Str"");
  entityManager.getTransaction().commit();
}","@Test public void associationTest(){
  entityManager.getTransaction().begin();
  Hike hike=new Hike(""String_Node_Str"",""String_Node_Str"");
  Trip trip=new Trip();
  trip.name=""String_Node_Str"";
  hike.recommendedTrip=trip;
  trip.availableHikes.add(hike);
  entityManager.persist(trip);
  entityManager.persist(hike);
  entityManager.flush();
  entityManager.clear();
  hike=entityManager.find(Hike.class,hike.id);
  assertThat(hike.recommendedTrip).isNotNull();
  assertThat(hike.recommendedTrip.name).isEqualTo(""String_Node_Str"");
  entityManager.getTransaction().commit();
}",0.919966301600674
32345,"@GET @Path(""String_Node_Str"") public void populate() throws Exception {
  clearDatabase(businessEm);
  clearDatabase(hikeEm);
  Trip corsica=new Trip();
  corsica.name=""String_Node_Str"";
  corsica.price=254.9;
  corsica.organizer=new Person(""String_Node_Str"");
  SimpleDateFormat dateFormat=new SimpleDateFormat(""String_Node_Str"");
  corsica.startDate=dateFormat.parse(""String_Node_Str"");
  corsica.endDate=dateFormat.parse(""String_Node_Str"");
  hikeEm.persist(corsica);
  Hike gr20North=new Hike(""String_Node_Str"",""String_Node_Str"");
  gr20North.recommendedTrip=corsica;
  gr20North.sections.add(new Section(""String_Node_Str"",""String_Node_Str""));
  gr20North.sections.add(new Section(""String_Node_Str"",""String_Node_Str""));
  Hike gr20South=new Hike(""String_Node_Str"",""String_Node_Str"");
  gr20South.recommendedTrip=corsica;
  gr20South.sections.add(new Section(""String_Node_Str"",""String_Node_Str""));
  gr20South.sections.add(new Section(""String_Node_Str"",""String_Node_Str""));
  hikeEm.persist(gr20North);
  hikeEm.persist(gr20South);
  Trip briceCanyon=new Trip();
  briceCanyon.name=""String_Node_Str"";
  briceCanyon.price=254.9;
  briceCanyon.organizer=new Person(""String_Node_Str"");
  briceCanyon.startDate=dateFormat.parse(""String_Node_Str"");
  briceCanyon.endDate=dateFormat.parse(""String_Node_Str"");
  hikeEm.persist(briceCanyon);
  Hike fairyLandTrail=new Hike(""String_Node_Str"",""String_Node_Str"");
  fairyLandTrail.recommendedTrip=briceCanyon;
  fairyLandTrail.sections.add(new Section(""String_Node_Str"",""String_Node_Str""));
  fairyLandTrail.sections.add(new Section(""String_Node_Str"",""String_Node_Str""));
  fairyLandTrail.sections.add(new Section(""String_Node_Str"",""String_Node_Str""));
  Hike riggsSpringTrail=new Hike(""String_Node_Str"",""String_Node_Str"");
  riggsSpringTrail.recommendedTrip=briceCanyon;
  riggsSpringTrail.sections.add(new Section(""String_Node_Str"",""String_Node_Str""));
  riggsSpringTrail.sections.add(new Section(""String_Node_Str"",""String_Node_Str""));
  hikeEm.persist(fairyLandTrail);
  hikeEm.persist(riggsSpringTrail);
  Trip semiMarathon=new Trip();
  semiMarathon.name=""String_Node_Str"";
  semiMarathon.startDate=dateFormat.parse(""String_Node_Str"");
  semiMarathon.endDate=dateFormat.parse(""String_Node_Str"");
  semiMarathon.organizer=new Person(""String_Node_Str"");
  semiMarathon.price=5;
  hikeEm.persist(semiMarathon);
}","@GET @Path(""String_Node_Str"") public void populate() throws Exception {
  clearDatabase(businessEm);
  clearHikeAndTrips(hikeEm);
  Trip corsica=new Trip();
  corsica.name=""String_Node_Str"";
  corsica.price=254.9;
  corsica.organizer=new Person(""String_Node_Str"");
  SimpleDateFormat dateFormat=new SimpleDateFormat(""String_Node_Str"");
  corsica.startDate=dateFormat.parse(""String_Node_Str"");
  corsica.endDate=dateFormat.parse(""String_Node_Str"");
  hikeEm.persist(corsica);
  Hike gr20North=new Hike(""String_Node_Str"",""String_Node_Str"");
  gr20North.recommendedTrip=corsica;
  gr20North.sections.add(new Section(""String_Node_Str"",""String_Node_Str""));
  gr20North.sections.add(new Section(""String_Node_Str"",""String_Node_Str""));
  Hike gr20South=new Hike(""String_Node_Str"",""String_Node_Str"");
  gr20South.recommendedTrip=corsica;
  gr20South.sections.add(new Section(""String_Node_Str"",""String_Node_Str""));
  gr20South.sections.add(new Section(""String_Node_Str"",""String_Node_Str""));
  hikeEm.persist(gr20North);
  hikeEm.persist(gr20South);
  Trip briceCanyon=new Trip();
  briceCanyon.name=""String_Node_Str"";
  briceCanyon.price=254.9;
  briceCanyon.organizer=new Person(""String_Node_Str"");
  briceCanyon.startDate=dateFormat.parse(""String_Node_Str"");
  briceCanyon.endDate=dateFormat.parse(""String_Node_Str"");
  hikeEm.persist(briceCanyon);
  Hike fairyLandTrail=new Hike(""String_Node_Str"",""String_Node_Str"");
  fairyLandTrail.recommendedTrip=briceCanyon;
  fairyLandTrail.sections.add(new Section(""String_Node_Str"",""String_Node_Str""));
  fairyLandTrail.sections.add(new Section(""String_Node_Str"",""String_Node_Str""));
  fairyLandTrail.sections.add(new Section(""String_Node_Str"",""String_Node_Str""));
  Hike riggsSpringTrail=new Hike(""String_Node_Str"",""String_Node_Str"");
  riggsSpringTrail.recommendedTrip=briceCanyon;
  riggsSpringTrail.sections.add(new Section(""String_Node_Str"",""String_Node_Str""));
  riggsSpringTrail.sections.add(new Section(""String_Node_Str"",""String_Node_Str""));
  hikeEm.persist(fairyLandTrail);
  hikeEm.persist(riggsSpringTrail);
  Trip semiMarathon=new Trip();
  semiMarathon.name=""String_Node_Str"";
  semiMarathon.startDate=dateFormat.parse(""String_Node_Str"");
  semiMarathon.endDate=dateFormat.parse(""String_Node_Str"");
  semiMarathon.organizer=new Person(""String_Node_Str"");
  semiMarathon.price=5;
  hikeEm.persist(semiMarathon);
}",0.9957591178965224
32346,"private static void loadBannedItems(){
  bannedItems.clear();
  File file=new File(saveDir,""String_Node_Str"");
  if (!file.exists()) {
    bannedItems.put(new ItemStack(Blocks.command_block),new HashSet<String>(Arrays.asList(""String_Node_Str"")));
    saveBannedItems();
    return;
  }
  try {
    FileReader r=new FileReader(file);
    int line=0;
    for (    String s : IOUtils.readLines(r)) {
      if (s.charAt(0) == '#' || s.trim().length() == 0)       continue;
      int delim=s.lastIndexOf('=');
      if (delim < 0) {
        logger.error(""String_Node_Str"" + line + ""String_Node_Str"");
        continue;
      }
      try {
        NBTTagCompound key=JsonToNBT.func_180713_a(s.substring(0,delim));
        Set<String> values=new HashSet<String>();
        for (        String s2 : s.substring(delim + 1).split(""String_Node_Str""))         values.add(s2.trim());
        bannedItems.put(InventoryUtils.loadPersistant(key),values);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"" + line + ""String_Node_Str""+ e.getMessage());
      }
    }
    r.close();
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","private static void loadBannedItems(){
  bannedItems.clear();
  File file=new File(saveDir,""String_Node_Str"");
  if (!file.exists()) {
    bannedItems.put(new ItemStack(Blocks.command_block),new HashSet<String>(Arrays.asList(""String_Node_Str"")));
    saveBannedItems();
    return;
  }
  try {
    FileReader r=new FileReader(file);
    int line=0;
    for (    String s : IOUtils.readLines(r)) {
      if (s.charAt(0) == '#' || s.trim().length() == 0)       continue;
      int delim=s.lastIndexOf('=');
      if (delim < 0) {
        logger.error(""String_Node_Str"" + line + ""String_Node_Str"");
        continue;
      }
      try {
        NBTTagCompound key=JsonToNBT.getTagFromJson(s.substring(0,delim));
        Set<String> values=new HashSet<String>();
        for (        String s2 : s.substring(delim + 1).split(""String_Node_Str""))         values.add(s2.trim());
        bannedItems.put(InventoryUtils.loadPersistant(key),values);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"" + line + ""String_Node_Str""+ e.getMessage());
      }
    }
    r.close();
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}",0.9883470004315926
32347,"protected boolean setField(Object effect,String key,ConfigurationSection section,ConfigurationSection parameterMap){
  try {
    String stringValue=section.getString(key);
    if (key.contains(""String_Node_Str"")) {
      key=key.replace(""String_Node_Str"",""String_Node_Str"");
    }
    if (key.contains(""String_Node_Str"")) {
      key=CaseFormat.LOWER_UNDERSCORE.to(CaseFormat.LOWER_CAMEL,key);
    }
    String fieldKey=key;
    ConfigurationSection fieldSection=section;
    if (parameterMap != null && stringValue.startsWith(""String_Node_Str"") && parameterMap.contains(stringValue)) {
      fieldKey=stringValue;
      fieldSection=parameterMap;
    }
    Field field=effect.getClass().getField(key);
    if (field.getType().equals(Integer.TYPE) || field.getType().equals(Integer.class)) {
      field.set(effect,fieldSection.getInt(fieldKey));
    }
 else     if (field.getType().equals(Float.TYPE) || field.getType().equals(Float.class)) {
      field.set(effect,(float)fieldSection.getDouble(fieldKey));
    }
 else     if (field.getType().equals(Double.TYPE) || field.getType().equals(Double.class)) {
      field.set(effect,fieldSection.getDouble(fieldKey));
    }
 else     if (field.getType().equals(Boolean.TYPE) || field.getType().equals(Boolean.class)) {
      field.set(effect,fieldSection.getBoolean(fieldKey));
    }
 else     if (field.getType().equals(Long.TYPE) || field.getType().equals(Long.class)) {
      field.set(effect,fieldSection.getLong(fieldKey));
    }
 else     if (field.getType().equals(Short.TYPE) || field.getType().equals(Short.class)) {
      field.set(effect,(short)fieldSection.getInt(fieldKey));
    }
 else     if (field.getType().equals(Byte.TYPE) || field.getType().equals(Byte.class)) {
      field.set(effect,(byte)fieldSection.getInt(fieldKey));
    }
 else     if (field.getType().equals(String.class)) {
      String value=fieldSection.getString(fieldKey);
      field.set(effect,value);
    }
 else     if (field.getType().equals(Color.class)) {
      try {
        String value=fieldSection.getString(fieldKey);
        Integer rgb=Integer.parseInt(value,16);
        Color color=Color.fromRGB(rgb);
        field.set(effect,color);
      }
 catch (      Exception ex) {
        onError(ex);
      }
    }
 else     if (Map.class.isAssignableFrom(field.getType()) && section.isConfigurationSection(key)) {
      Map<String,Object> map=(Map<String,Object>)field.get(effect);
      ConfigurationSection subSection=section.getConfigurationSection(key);
      Set<String> keys=subSection.getKeys(false);
      for (      String mapKey : keys) {
        map.put(mapKey,subSection.get(mapKey));
      }
    }
 else     if (Map.class.isAssignableFrom(field.getType()) && Map.class.isAssignableFrom(section.get(key).getClass())) {
      field.set(effect,section.get(key));
    }
 else     if (ConfigurationSection.class.isAssignableFrom(field.getType())) {
      ConfigurationSection configSection=ConfigUtils.getConfigurationSection(section,key);
      if (parameterMap != null) {
        ConfigurationSection baseConfiguration=configSection;
        configSection=new MemoryConfiguration();
        Set<String> keys=baseConfiguration.getKeys(false);
        for (        String baseKey : keys) {
          String baseValue=baseConfiguration.getString(baseKey);
          if (baseValue.startsWith(""String_Node_Str"")) {
            String parameterValue=parameterMap.getString(baseValue);
            baseValue=parameterValue == null ? baseValue : parameterValue;
          }
          configSection.set(baseKey,baseValue);
        }
      }
      field.set(effect,configSection);
    }
 else     if (field.getType().equals(Vector.class)) {
      double x=0;
      double y=0;
      double z=0;
      try {
        String value=fieldSection.getString(fieldKey);
        String[] pieces=value.split(""String_Node_Str"");
        x=pieces.length > 0 ? Double.parseDouble(pieces[0]) : 0;
        y=pieces.length > 1 ? Double.parseDouble(pieces[1]) : 0;
        z=pieces.length > 2 ? Double.parseDouble(pieces[2]) : 0;
      }
 catch (      Exception ex) {
        onError(ex);
      }
      field.set(effect,new Vector(x,y,z));
    }
 else     if (field.getType().isEnum()) {
      Class<Enum> enumType=(Class<Enum>)field.getType();
      try {
        String value=fieldSection.getString(fieldKey);
        Enum enumValue=Enum.valueOf(enumType,value.toUpperCase());
        field.set(effect,enumValue);
      }
 catch (      Exception ex) {
        onError(ex);
      }
    }
 else     if (field.getType().equals(Font.class)) {
      try {
        String value=fieldSection.getString(fieldKey);
        Font font=Font.decode(value);
        field.set(effect,font);
      }
 catch (      Exception ex) {
        onError(ex);
      }
    }
 else {
      return false;
    }
    return true;
  }
 catch (  Exception ex) {
    this.onError(ex);
  }
  return false;
}","protected boolean setField(Object effect,String key,ConfigurationSection section,ConfigurationSection parameterMap){
  try {
    String stringValue=section.getString(key);
    String fieldKey=key;
    if (key.contains(""String_Node_Str"")) {
      key=key.replace(""String_Node_Str"",""String_Node_Str"");
    }
    if (key.contains(""String_Node_Str"")) {
      key=CaseFormat.LOWER_UNDERSCORE.to(CaseFormat.LOWER_CAMEL,key);
    }
    ConfigurationSection fieldSection=section;
    if (parameterMap != null && stringValue.startsWith(""String_Node_Str"") && parameterMap.contains(stringValue)) {
      fieldKey=stringValue;
      fieldSection=parameterMap;
    }
    Field field=effect.getClass().getField(key);
    if (field.getType().equals(Integer.TYPE) || field.getType().equals(Integer.class)) {
      field.set(effect,fieldSection.getInt(fieldKey));
    }
 else     if (field.getType().equals(Float.TYPE) || field.getType().equals(Float.class)) {
      field.set(effect,(float)fieldSection.getDouble(fieldKey));
    }
 else     if (field.getType().equals(Double.TYPE) || field.getType().equals(Double.class)) {
      field.set(effect,fieldSection.getDouble(fieldKey));
    }
 else     if (field.getType().equals(Boolean.TYPE) || field.getType().equals(Boolean.class)) {
      field.set(effect,fieldSection.getBoolean(fieldKey));
    }
 else     if (field.getType().equals(Long.TYPE) || field.getType().equals(Long.class)) {
      field.set(effect,fieldSection.getLong(fieldKey));
    }
 else     if (field.getType().equals(Short.TYPE) || field.getType().equals(Short.class)) {
      field.set(effect,(short)fieldSection.getInt(fieldKey));
    }
 else     if (field.getType().equals(Byte.TYPE) || field.getType().equals(Byte.class)) {
      field.set(effect,(byte)fieldSection.getInt(fieldKey));
    }
 else     if (field.getType().equals(String.class)) {
      String value=fieldSection.getString(fieldKey);
      field.set(effect,value);
    }
 else     if (field.getType().equals(Color.class)) {
      try {
        String value=fieldSection.getString(fieldKey);
        Integer rgb=Integer.parseInt(value,16);
        Color color=Color.fromRGB(rgb);
        field.set(effect,color);
      }
 catch (      Exception ex) {
        onError(ex);
      }
    }
 else     if (Map.class.isAssignableFrom(field.getType()) && section.isConfigurationSection(key)) {
      Map<String,Object> map=(Map<String,Object>)field.get(effect);
      ConfigurationSection subSection=section.getConfigurationSection(key);
      Set<String> keys=subSection.getKeys(false);
      for (      String mapKey : keys) {
        map.put(mapKey,subSection.get(mapKey));
      }
    }
 else     if (Map.class.isAssignableFrom(field.getType()) && Map.class.isAssignableFrom(section.get(key).getClass())) {
      field.set(effect,section.get(key));
    }
 else     if (ConfigurationSection.class.isAssignableFrom(field.getType())) {
      ConfigurationSection configSection=ConfigUtils.getConfigurationSection(section,key);
      if (parameterMap != null) {
        ConfigurationSection baseConfiguration=configSection;
        configSection=new MemoryConfiguration();
        Set<String> keys=baseConfiguration.getKeys(false);
        for (        String baseKey : keys) {
          Object baseValue=baseConfiguration.get(baseKey);
          if (baseValue instanceof String && ((String)baseValue).startsWith(""String_Node_Str"")) {
            String parameterValue=parameterMap.getString((String)baseValue);
            baseValue=parameterValue == null ? baseValue : parameterValue;
          }
          configSection.set(baseKey,baseValue);
        }
      }
      field.set(effect,configSection);
    }
 else     if (field.getType().equals(Vector.class)) {
      double x=0;
      double y=0;
      double z=0;
      try {
        String value=fieldSection.getString(fieldKey);
        String[] pieces=value.split(""String_Node_Str"");
        x=pieces.length > 0 ? Double.parseDouble(pieces[0]) : 0;
        y=pieces.length > 1 ? Double.parseDouble(pieces[1]) : 0;
        z=pieces.length > 2 ? Double.parseDouble(pieces[2]) : 0;
      }
 catch (      Exception ex) {
        onError(ex);
      }
      field.set(effect,new Vector(x,y,z));
    }
 else     if (field.getType().isEnum()) {
      Class<Enum> enumType=(Class<Enum>)field.getType();
      try {
        String value=fieldSection.getString(fieldKey);
        Enum enumValue=Enum.valueOf(enumType,value.toUpperCase());
        field.set(effect,enumValue);
      }
 catch (      Exception ex) {
        onError(ex);
      }
    }
 else     if (field.getType().equals(Font.class)) {
      try {
        String value=fieldSection.getString(fieldKey);
        Font font=Font.decode(value);
        field.set(effect,font);
      }
 catch (      Exception ex) {
        onError(ex);
      }
    }
 else {
      return false;
    }
    return true;
  }
 catch (  Exception ex) {
    this.onError(ex);
  }
  return false;
}",0.9881133800670528
32348,"/** 
 * Extending Effect classes should use this method to obtain the current ""root"" Location of the effect. This method will not return null when called from onRun. Effects with invalid locations will be cancelled.
 */
public Location getLocation(){
  Entity entityReference=entity.get();
  if (entityReference != null) {
    long now=System.currentTimeMillis();
    if (locationUpdateInterval == 0 || lastLocationUpdate == 0 || lastLocationUpdate + locationUpdateInterval > now) {
      if (entityReference instanceof LivingEntity) {
        setLocation(((LivingEntity)entityReference).getEyeLocation());
      }
 else {
        setLocation(entityReference.getLocation());
      }
    }
  }
  return location;
}","/** 
 * Extending Effect classes should use this method to obtain the current ""root"" Location of the effect. This method will not return null when called from onRun. Effects with invalid locations will be cancelled.
 */
public final Location getLocation(){
  Entity entityReference=entity.get();
  if (entityReference != null) {
    long now=System.currentTimeMillis();
    if (locationUpdateInterval == 0 || lastLocationUpdate == 0 || lastLocationUpdate + locationUpdateInterval > now) {
      if (entityReference instanceof LivingEntity) {
        setLocation(((LivingEntity)entityReference).getEyeLocation());
      }
 else {
        setLocation(entityReference.getLocation());
      }
    }
  }
  return location;
}",0.9958100558659218
32349,"/** 
 * Extending Effect classes should use this method to obtain the current ""target"" Location of the effect. Unlike getLocation, this may return null.
 */
public Location getTarget(){
  Entity entityReference=targetEntity.get();
  if (entityReference != null) {
    long now=System.currentTimeMillis();
    if (locationUpdateInterval == 0 || lastTargetUpdate == 0 || lastTargetUpdate + locationUpdateInterval > now) {
      if (entityReference instanceof LivingEntity) {
        setTarget(((LivingEntity)entityReference).getEyeLocation());
      }
 else {
        setTarget(entityReference.getLocation());
      }
    }
  }
  return target;
}","/** 
 * Extending Effect classes should use this method to obtain the current ""target"" Location of the effect. Unlike getLocation, this may return null.
 */
public final Location getTarget(){
  Entity entityReference=targetEntity.get();
  if (entityReference != null) {
    long now=System.currentTimeMillis();
    if (locationUpdateInterval == 0 || lastTargetUpdate == 0 || lastTargetUpdate + locationUpdateInterval > now) {
      if (entityReference instanceof LivingEntity) {
        setTarget(((LivingEntity)entityReference).getEyeLocation());
      }
 else {
        setTarget(entityReference.getLocation());
      }
    }
  }
  return target;
}",0.9953632148377124
32350,"/** 
 * Set the Location this Effect is centered on.
 */
public void setLocation(Location location){
  this.location=location == null ? null : location.clone();
  if (this.offset != null) {
    this.location=this.location.add(this.offset);
  }
}","/** 
 * Set the Location this Effect is centered on.
 */
public void setLocation(Location location){
  Validate.notNull(location,""String_Node_Str"");
  this.location=location == null ? null : location.clone();
  if (offset != null && location != null) {
    this.location=location.add(offset);
    lastLocationUpdate=System.currentTimeMillis();
  }
}",0.6262626262626263
32351,"/** 
 * Set the Location this Effect is targeting.
 */
public void setTarget(Location location){
  this.target=location == null ? null : location.clone();
  if (this.targetOffset != null) {
    this.target=this.target.add(this.targetOffset);
  }
}","/** 
 * Set the Location this Effect is targeting.
 */
public void setTarget(Location location){
  Validate.notNull(location,""String_Node_Str"");
  target=location == null ? null : location.clone();
  if (targetOffset != null && target != null) {
    target.add(targetOffset);
    lastTargetUpdate=System.currentTimeMillis();
  }
}",0.7105719237435009
32352,"protected boolean validate(){
  Location location=getLocation();
  if (location == null)   return false;
  if (autoOrient) {
    Location target=getTarget();
    if (target != null) {
      Vector direction=target.toVector().subtract(location.toVector());
      location.setDirection(direction);
      target.setDirection(direction.multiply(-1));
    }
  }
  return true;
}","protected final boolean validate(){
  Location location=getLocation();
  if (location == null)   return false;
  if (autoOrient) {
    Location target=getTarget();
    if (target != null) {
      Vector direction=target.toVector().subtract(location.toVector());
      location.setDirection(direction);
      target.setDirection(direction.multiply(-1));
    }
  }
  return true;
}",0.9920212765957448
32353,"@SuppressWarnings(""String_Node_Str"") private void readData(NamingEnumeration ldapContents) throws Exception {
  SearchResult result=null;
  NamingEnumeration<? extends Attribute> atts=null;
  Attribute a=null;
  while (ldapContents.hasMore()) {
    String name=null;
    String password=null;
    result=(SearchResult)ldapContents.next();
    name=result.getName();
    name=name.split(""String_Node_Str"")[1];
    if (fMasterUser != null) {
      name+=MASTER_SEP + fMasterUser;
    }
    atts=result.getAttributes().getAll();
    while (atts.hasMore()) {
      a=atts.next();
      if (fPasswordField.equals(a.getID()) && a.get() != null) {
        Object val=a.get();
        if (val instanceof byte[]) {
          password=new String((byte[])val);
        }
 else {
          password=val.toString();
        }
        break;
      }
    }
    if (fMasterPassword != null) {
      password=fMasterPassword;
    }
    fUserNames.add(name);
    fUserPasswords.add(password);
  }
}","@SuppressWarnings(""String_Node_Str"") private void readData(NamingEnumeration ldapContents) throws Exception {
  SearchResult result=null;
  NamingEnumeration<? extends Attribute> atts=null;
  Attribute a=null;
  while (ldapContents.hasMore()) {
    String name=null;
    String password=null;
    result=(SearchResult)ldapContents.next();
    name=result.getName();
    if (name.indexOf(',') > 0) {
      name=name.split(""String_Node_Str"")[0];
    }
    name=name.split(""String_Node_Str"")[1];
    if (fMasterUser != null) {
      name+=MASTER_SEP + fMasterUser;
    }
    atts=result.getAttributes().getAll();
    while (atts.hasMore()) {
      a=atts.next();
      if (fPasswordField.equals(a.getID()) && a.get() != null) {
        Object val=a.get();
        if (val instanceof byte[]) {
          password=new String((byte[])val);
        }
 else {
          password=val.toString();
        }
        break;
      }
    }
    if (fMasterPassword != null) {
      password=fMasterPassword;
    }
    fUserNames.add(name);
    fUserPasswords.add(password);
  }
}",0.958904109589041
32354,"@SuppressWarnings(""String_Node_Str"") private void readData(NamingEnumeration ldapContents) throws Exception {
  SearchResult result=null;
  NamingEnumeration<? extends Attribute> atts=null;
  Attribute a=null;
  while (ldapContents.hasMore()) {
    String name=null;
    String password=null;
    result=(SearchResult)ldapContents.next();
    name=result.getName();
    name=name.split(""String_Node_Str"")[1];
    if (fMasterUser != null) {
      name+=MASTER_SEP + fMasterUser;
    }
    atts=result.getAttributes().getAll();
    while (atts.hasMore()) {
      a=atts.next();
      if (fPasswordField.equals(a.getID()) && a.get() != null) {
        Object val=a.get();
        if (val instanceof byte[]) {
          password=new String((byte[])val);
        }
 else {
          password=val.toString();
        }
        break;
      }
    }
    if (fMasterPassword != null) {
      password=fMasterPassword;
    }
    fUserNames.add(name);
    fUserPasswords.add(password);
  }
}","@SuppressWarnings(""String_Node_Str"") private void readData(NamingEnumeration ldapContents) throws Exception {
  SearchResult result=null;
  NamingEnumeration<? extends Attribute> atts=null;
  Attribute a=null;
  while (ldapContents.hasMore()) {
    String name=null;
    String password=null;
    result=(SearchResult)ldapContents.next();
    name=result.getName();
    if (name.indexOf(',') > 0) {
      name=name.split(""String_Node_Str"")[0];
    }
    name=name.split(""String_Node_Str"")[1];
    if (fMasterUser != null) {
      name+=MASTER_SEP + fMasterUser;
    }
    atts=result.getAttributes().getAll();
    while (atts.hasMore()) {
      a=atts.next();
      if (fPasswordField.equals(a.getID()) && a.get() != null) {
        Object val=a.get();
        if (val instanceof byte[]) {
          password=new String((byte[])val);
        }
 else {
          password=val.toString();
        }
        break;
      }
    }
    if (fMasterPassword != null) {
      password=fMasterPassword;
    }
    fUserNames.add(name);
    fUserPasswords.add(password);
  }
}",0.958904109589041
32355,"@Override public void start(){
  logger.info(""String_Node_Str"");
  try {
    mailDestination.startup();
    sched=StdSchedulerFactory.getDefaultScheduler();
    if (sched.isShutdown()) {
      logger.error(""String_Node_Str"");
    }
    if (sched.isStarted()) {
      logger.error(""String_Node_Str"");
    }
    final JobDataMap jdm=new JobDataMap();
    jdm.put(""String_Node_Str"",mailSource);
    try {
      if (folderPattern != null) {
        jdm.put(""String_Node_Str"",Pattern.compile(folderPattern));
      }
    }
 catch (    final PatternSyntaxException e) {
      logger.error(""String_Node_Str"",e,e.toString());
    }
    final JobDetail job=newJob(MailFlowJob.class).withIdentity(riverName + ""String_Node_Str"" + props.hashCode(),""String_Node_Str"").usingJobData(jdm).build();
    Trigger trigger=null;
    if (StringUtils.isEmpty(schedule)) {
      logger.info(""String_Node_Str"",interval.seconds());
      trigger=newTrigger().withIdentity(""String_Node_Str"",""String_Node_Str"").startNow().withSchedule(simpleSchedule().withIntervalInSeconds((int)interval.seconds()).repeatForever()).build();
    }
 else {
      logger.info(""String_Node_Str"",schedule);
      trigger=newTrigger().withIdentity(""String_Node_Str"",""String_Node_Str"").withSchedule(cronSchedule(schedule)).build();
    }
    sched.scheduleJob(job,trigger);
    sched.start();
    logger.info(""String_Node_Str"");
  }
 catch (  final Exception e) {
    logger.error(""String_Node_Str"" + e,e);
  }
}","@Override public void start(){
  logger.info(""String_Node_Str"");
  try {
    mailDestination.startup();
    sched=StdSchedulerFactory.getDefaultScheduler();
    if (sched.isShutdown()) {
      logger.error(""String_Node_Str"");
    }
    if (sched.isStarted()) {
      logger.error(""String_Node_Str"");
    }
    final JobDataMap jdm=new JobDataMap();
    jdm.put(""String_Node_Str"",mailSource);
    try {
      if (folderPattern != null) {
        jdm.put(""String_Node_Str"",Pattern.compile(folderPattern));
      }
    }
 catch (    final PatternSyntaxException e) {
      logger.error(""String_Node_Str"",e,e.toString());
    }
    final String group=""String_Node_Str"" + riverName + ""String_Node_Str""+ props.hashCode();
    final JobDetail job=newJob(MailFlowJob.class).withIdentity(riverName + ""String_Node_Str"" + props.hashCode(),group).usingJobData(jdm).build();
    Trigger trigger=null;
    if (StringUtils.isEmpty(schedule)) {
      logger.info(""String_Node_Str"",interval.seconds());
      trigger=newTrigger().withIdentity(""String_Node_Str"",group).startNow().withSchedule(simpleSchedule().withIntervalInSeconds((int)interval.seconds()).repeatForever()).build();
    }
 else {
      logger.info(""String_Node_Str"",schedule);
      trigger=newTrigger().withIdentity(""String_Node_Str"",group).withSchedule(cronSchedule(schedule)).build();
    }
    sched.scheduleJob(job,trigger);
    sched.start();
    logger.info(""String_Node_Str"");
  }
 catch (  final Exception e) {
    logger.error(""String_Node_Str"" + e,e);
  }
}",0.9469442578912022
32356,"public void run(){
  int bugID=1;
  Program program=Program.g();
  Hashtable<String,Integer> warningMap=new Hashtable<String,Integer>();
  printer=new CodePrinting();
  for (  jq_Method m : program.getMethods()) {
    if (!m.isAbstract()) {
      System.out.println(""String_Node_Str"" + m);
      String srcFile=m.getDeclaringClass().getSourceFileName();
      ControlFlowGraph cfg=null;
      try {
        cfg=m.getCFG();
      }
 catch (      Throwable e) {
        System.out.println(""String_Node_Str"" + m + ""String_Node_Str""+ e);
        continue;
      }
      if (cfg == null) {
        System.out.println(""String_Node_Str"" + m + ""String_Node_Str"");
        continue;
      }
      for (      BasicBlock bb : cfg.reversePostOrder()) {
        boolean throws_exception=false;
        startingLine=100000;
        Hashtable<jq_Class,List<String>> exceptionsThrown=new Hashtable<jq_Class,List<String>>();
        if (Config.verbose > 1) {
          System.out.println(""String_Node_Str"" + bb);
        }
        for (int i=0; i < bb.size(); i++) {
          Quad q=bb.getQuad(i);
          try {
            if (Config.verbose > 1) {
              System.out.println(""String_Node_Str"" + q.getLineNumber() + ""String_Node_Str""+ q);
            }
            if (q.getLineNumber() < startingLine && q.getLineNumber() != 0) {
              startingLine=q.getLineNumber();
            }
          }
 catch (          Throwable e) {
          }
          for (          jq_Class exc : q.getThrownExceptions()) {
            String excStr=exc.getName();
            if (excStr.equals(""String_Node_Str"") || excStr.equals(""String_Node_Str"")) {
              continue;
            }
            throws_exception=true;
            if (!exceptionsThrown.containsKey(exc)) {
              exceptionsThrown.put(exc,new ArrayList<String>());
            }
            exceptionsThrown.get(exc).add(""String_Node_Str"" + q.getLineNumber() + ""String_Node_Str""+ q);
            System.out.println(""String_Node_Str"" + q + ""String_Node_Str""+ q.getLineNumber()+ ""String_Node_Str""+ excStr);
          }
        }
        if (throws_exception == false) {
          continue;
        }
        for (        ExceptionHandler eh : bb.getExceptionHandlers()) {
          jq_Class handledEx=eh.getExceptionType();
          System.out.println(""String_Node_Str"" + handledEx.toString() + ""String_Node_Str""+ bb+ ""String_Node_Str""+ bb.getLastQuad().getLineNumber()+ ""String_Node_Str""+ srcFile);
          if (checkTerminatingHandler(eh) == true) {
            String bugInfo=eh.toString() + m.toString() + m.getDeclaringClass().toString();
            if (warningMap.containsKey(bugInfo)) {
              continue;
            }
            warningMap.put(bugInfo,1);
            System.out.println(""String_Node_Str"");
            System.out.println(""String_Node_Str"" + bugID + ""String_Node_Str""+ handledEx.getName());
            System.out.println(""String_Node_Str"" + eh.getEntry().getLastQuad().getLineNumber() + ""String_Node_Str""+ srcFile+ ""String_Node_Str"");
            System.out.println(""String_Node_Str"");
            int numHandledEx=0;
            Iterator<jq_Class> exIterator=exceptionsThrown.keySet().iterator();
            while (exIterator.hasNext()) {
              jq_Class thrownEx=exIterator.next();
              if (isSubClass(thrownEx,handledEx) >= 0) {
                numHandledEx++;
                System.out.println(""String_Node_Str"" + thrownEx.getName());
                List<String> thrownExes=exceptionsThrown.get(thrownEx);
                for (                String throwInfo : thrownExes) {
                  System.out.println(""String_Node_Str"" + throwInfo);
                }
              }
            }
            if (numHandledEx > 1) {
              System.out.println(""String_Node_Str"");
            }
 else {
              System.out.println(""String_Node_Str"");
            }
            try {
              printer.printCode(startingLine,endingLine,srcFile);
            }
 catch (            IOException ioe) {
              System.out.println(""String_Node_Str"" + srcFile + ""String_Node_Str""+ startingLine+ ""String_Node_Str""+ endingLine);
            }
            System.out.println(""String_Node_Str"");
            bugID++;
          }
        }
      }
    }
  }
}","public void run(){
  int bugID=1;
  Program program=Program.g();
  Hashtable<String,Integer> warningMap=new Hashtable<String,Integer>();
  printer=new CodePrinting();
  for (  jq_Method m : program.getMethods()) {
    if (!m.isAbstract()) {
      System.out.println(""String_Node_Str"" + m);
      String srcFile=m.getDeclaringClass().getSourceFileName();
      ControlFlowGraph cfg=null;
      try {
        cfg=m.getCFG();
      }
 catch (      Throwable e) {
        System.out.println(""String_Node_Str"" + m + ""String_Node_Str""+ e);
        continue;
      }
      if (cfg == null) {
        System.out.println(""String_Node_Str"" + m + ""String_Node_Str"");
        continue;
      }
      for (      BasicBlock bb : cfg.reversePostOrder()) {
        boolean throws_exception=false;
        startingLine=100000;
        Hashtable<jq_Class,List<String>> exceptionsThrown=new Hashtable<jq_Class,List<String>>();
        if (Config.verbose > 1) {
          System.out.println(""String_Node_Str"" + bb);
        }
        for (int i=0; i < bb.size(); i++) {
          Quad q=bb.getQuad(i);
          try {
            if (Config.verbose > 1) {
              System.out.println(""String_Node_Str"" + q.getLineNumber() + ""String_Node_Str""+ q);
            }
            if (q.getLineNumber() < startingLine && q.getLineNumber() != 0) {
              startingLine=q.getLineNumber();
            }
          }
 catch (          Throwable e) {
          }
          for (          jq_Class exc : q.getThrownExceptions()) {
            String excStr=exc.getName();
            if (excStr.equals(""String_Node_Str"") || excStr.equals(""String_Node_Str"")) {
              continue;
            }
            throws_exception=true;
            if (!exceptionsThrown.containsKey(exc)) {
              exceptionsThrown.put(exc,new ArrayList<String>());
            }
            exceptionsThrown.get(exc).add(""String_Node_Str"" + q.getLineNumber() + ""String_Node_Str""+ q);
            System.out.println(""String_Node_Str"" + q + ""String_Node_Str""+ q.getLineNumber()+ ""String_Node_Str""+ excStr);
          }
        }
        if (throws_exception == false) {
          continue;
        }
        for (        ExceptionHandler eh : bb.getExceptionHandlers()) {
          jq_Class handledEx=eh.getExceptionType();
          System.out.println(""String_Node_Str"" + handledEx.toString() + ""String_Node_Str""+ bb+ ""String_Node_Str""+ bb.getLastQuad().getLineNumber()+ ""String_Node_Str""+ srcFile);
          if (checkTerminatingHandler(eh) == true) {
            String bugInfo=eh.toString() + m.toString() + m.getDeclaringClass().toString();
            if (warningMap.containsKey(bugInfo)) {
              continue;
            }
            warningMap.put(bugInfo,1);
            System.out.println(""String_Node_Str"");
            System.out.println(""String_Node_Str"" + bugID + ""String_Node_Str""+ handledEx.getName());
            System.out.println(""String_Node_Str"" + eh.getEntry().getLastQuad().getLineNumber() + ""String_Node_Str""+ srcFile+ ""String_Node_Str"");
            System.out.println(""String_Node_Str"");
            int numHandledEx=0;
            Iterator<jq_Class> exIterator=exceptionsThrown.keySet().iterator();
            while (exIterator.hasNext()) {
              jq_Class thrownEx=exIterator.next();
              if (isSubClass(thrownEx,handledEx) >= 0) {
                numHandledEx++;
                System.out.println(""String_Node_Str"" + thrownEx.getName());
                List<String> thrownExes=exceptionsThrown.get(thrownEx);
                for (                String throwInfo : thrownExes) {
                  System.out.println(""String_Node_Str"" + throwInfo);
                }
              }
            }
            if (numHandledEx > 1) {
              System.out.println(""String_Node_Str"");
            }
 else {
              System.out.println(""String_Node_Str"");
            }
            try {
              printer.printCode(startingLine,endingLine,srcFile,true);
            }
 catch (            IOException ioe) {
              System.out.println(""String_Node_Str"" + srcFile + ""String_Node_Str""+ startingLine+ ""String_Node_Str""+ endingLine);
            }
            System.out.println(""String_Node_Str"");
            bugID++;
          }
        }
      }
    }
  }
}",0.9994166374985416
32357,"public void run(){
  int bugID=0;
  int startingLine;
  int endingLine;
  Program program=Program.g();
  CodePrinting printer=new CodePrinting();
  Hashtable<String,Integer> warningMap=new Hashtable<String,Integer>();
  for (  jq_Method m : program.getMethods()) {
    if (!m.isAbstract()) {
      if (m.toString().startsWith(""String_Node_Str"")) {
        continue;
      }
      System.out.println(""String_Node_Str"" + m);
      ControlFlowGraph cfg=null;
      try {
        cfg=m.getCFG();
      }
 catch (      Throwable e) {
        System.out.println(""String_Node_Str"" + m + ""String_Node_Str""+ e);
        continue;
      }
      if (cfg == null) {
        System.out.println(""String_Node_Str"" + m + ""String_Node_Str"");
        continue;
      }
      for (      BasicBlock bb : cfg.reversePostOrder()) {
        startingLine=100000;
        endingLine=0;
        System.out.println(""String_Node_Str"" + bb);
        List<jq_Class> thrownExList=new ArrayList<jq_Class>();
        List<jq_Class> unhandledExList=new ArrayList<jq_Class>();
        Map<jq_Class,List<Quad>> exQuadMap=new HashMap<jq_Class,List<Quad>>();
        boolean throws_exception=false;
        boolean has_handler=false;
        for (int i=0; i < bb.size(); i++) {
          Quad q=bb.getQuad(i);
          try {
            if ((q.getLineNumber() < startingLine) && (q.getLineNumber() > 0)) {
              startingLine=q.getLineNumber();
            }
          }
 catch (          Throwable e) {
          }
          for (          jq_Class exc : q.getThrownExceptions()) {
            String excStr=exc.getName();
            if (excStr.equals(""String_Node_Str"") || excStr.equals(""String_Node_Str"") || excStr.equals(""String_Node_Str"")|| excStr.equals(""String_Node_Str"")|| excStr.equals(""String_Node_Str"")|| excStr.equals(""String_Node_Str"")|| excStr.equals(""String_Node_Str"")|| excStr.equals(""String_Node_Str"")) {
              continue;
            }
            throws_exception=true;
            thrownExList.add(exc);
            unhandledExList.add(exc);
            if (!exQuadMap.containsKey(exc)) {
              exQuadMap.put(exc,new ArrayList<Quad>());
            }
            exQuadMap.get(exc).add(q);
            System.out.println(""String_Node_Str"" + q + ""String_Node_Str""+ q.getLineNumber()+ ""String_Node_Str""+ excStr);
          }
        }
        if (throws_exception == true) {
          for (          ExceptionHandler eh : bb.getExceptionHandlers()) {
            has_handler=true;
            jq_Class handledEx=eh.getExceptionType();
            for (            jq_Class thrownEx : thrownExList) {
              if (thrownEx.equals(handledEx)) {
                System.out.println(""String_Node_Str"" + thrownEx + ""String_Node_Str"");
                unhandledExList.remove(thrownEx);
              }
              if (isSubClass(thrownEx,handledEx)) {
                System.out.println(""String_Node_Str"" + thrownEx + ""String_Node_Str""+ handledEx);
                unhandledExList.remove(thrownEx);
              }
            }
            try {
              int exhandlerLineNum=eh.getEntry().getLastQuad().getLineNumber();
              if (exhandlerLineNum > endingLine) {
                endingLine=exhandlerLineNum;
              }
            }
 catch (            Throwable e) {
            }
          }
          for (          jq_Class unhandledEx : unhandledExList) {
            boolean ignore=false;
            if (has_handler == false) {
              if (m.getThrownExceptionsTable() != null) {
                for (                jq_Class tex : m.getThrownExceptionsTable()) {
                  if (tex.equals(unhandledEx) || isSubClass(unhandledEx,tex)) {
                    System.out.println(""String_Node_Str"" + unhandledEx + ""String_Node_Str""+ ""String_Node_Str""+ tex);
                    ignore=true;
                    break;
                  }
                }
              }
            }
            if (ignore == true) {
              continue;
            }
            jq_Class superclass=null;
            try {
              superclass=unhandledEx.getSuperclass();
            }
 catch (            RuntimeException e) {
              ignore=true;
            }
            while (superclass != null) {
              if (superclass.toString().equals(""String_Node_Str"")) {
                ignore=true;
                break;
              }
              try {
                superclass=superclass.getSuperclass();
              }
 catch (              RuntimeException e) {
                ignore=true;
                break;
              }
            }
            if (ignore == true) {
              continue;
            }
            String bugInfo=unhandledEx.toString() + bb.toString() + m.toString()+ m.getDeclaringClass().toString();
            if (warningMap.containsKey(bugInfo)) {
              continue;
            }
            warningMap.put(bugInfo,1);
            bugID++;
            System.out.println(""String_Node_Str"");
            System.out.println(""String_Node_Str"" + bugID + ""String_Node_Str""+ unhandledEx+ ""String_Node_Str"");
            System.out.print(""String_Node_Str"");
            for (            Quad tq : exQuadMap.get(unhandledEx)) {
              System.out.println(""String_Node_Str"" + tq.getLineNumber() + ""String_Node_Str""+ m.getDeclaringClass().getSourceFileName()+ ""String_Node_Str"");
              System.out.println(""String_Node_Str"" + tq);
            }
            System.out.println(""String_Node_Str"" + m);
            if (has_handler == false) {
              System.out.println(""String_Node_Str"");
            }
 else {
              System.out.print(""String_Node_Str"");
              for (              ExceptionHandler eh : bb.getExceptionHandlers()) {
                jq_Class handledEx=eh.getExceptionType();
                System.out.print(handledEx.getName());
                if (isSubClass(handledEx,unhandledEx)) {
                  System.out.println(""String_Node_Str"" + unhandledEx.getName());
                }
 else {
                  System.out.println(""String_Node_Str"" + unhandledEx.getName());
                }
              }
            }
            try {
              if (endingLine == 0) {
                endingLine=startingLine;
              }
              printer.printCode(startingLine,endingLine,m.getDeclaringClass().getSourceFileName());
            }
 catch (            IOException ioe) {
              System.out.println(""String_Node_Str"" + m.getDeclaringClass().getSourceFileName() + ""String_Node_Str""+ startingLine+ ""String_Node_Str""+ endingLine);
            }
            System.out.println(""String_Node_Str"");
            System.out.println();
          }
        }
      }
    }
  }
}","public void run(){
  int bugID=0;
  int startingLine;
  int endingLine;
  Program program=Program.g();
  CodePrinting printer=new CodePrinting();
  Hashtable<String,Integer> warningMap=new Hashtable<String,Integer>();
  for (  jq_Method m : program.getMethods()) {
    if (!m.isAbstract()) {
      if (m.toString().startsWith(""String_Node_Str"")) {
        continue;
      }
      System.out.println(""String_Node_Str"" + m);
      ControlFlowGraph cfg=null;
      try {
        cfg=m.getCFG();
      }
 catch (      Throwable e) {
        System.out.println(""String_Node_Str"" + m + ""String_Node_Str""+ e);
        continue;
      }
      if (cfg == null) {
        System.out.println(""String_Node_Str"" + m + ""String_Node_Str"");
        continue;
      }
      for (      BasicBlock bb : cfg.reversePostOrder()) {
        startingLine=100000;
        endingLine=0;
        System.out.println(""String_Node_Str"" + bb);
        List<jq_Class> thrownExList=new ArrayList<jq_Class>();
        List<jq_Class> unhandledExList=new ArrayList<jq_Class>();
        Map<jq_Class,List<Quad>> exQuadMap=new HashMap<jq_Class,List<Quad>>();
        boolean throws_exception=false;
        boolean has_handler=false;
        for (int i=0; i < bb.size(); i++) {
          Quad q=bb.getQuad(i);
          try {
            if ((q.getLineNumber() < startingLine) && (q.getLineNumber() > 0)) {
              startingLine=q.getLineNumber();
            }
          }
 catch (          Throwable e) {
          }
          for (          jq_Class exc : q.getThrownExceptions()) {
            String excStr=exc.getName();
            if (excStr.equals(""String_Node_Str"") || excStr.equals(""String_Node_Str"") || excStr.equals(""String_Node_Str"")|| excStr.equals(""String_Node_Str"")|| excStr.equals(""String_Node_Str"")|| excStr.equals(""String_Node_Str"")|| excStr.equals(""String_Node_Str"")|| excStr.equals(""String_Node_Str"")) {
              continue;
            }
            throws_exception=true;
            thrownExList.add(exc);
            unhandledExList.add(exc);
            if (!exQuadMap.containsKey(exc)) {
              exQuadMap.put(exc,new ArrayList<Quad>());
            }
            exQuadMap.get(exc).add(q);
            System.out.println(""String_Node_Str"" + q + ""String_Node_Str""+ q.getLineNumber()+ ""String_Node_Str""+ excStr);
          }
        }
        if (throws_exception == true) {
          for (          ExceptionHandler eh : bb.getExceptionHandlers()) {
            has_handler=true;
            jq_Class handledEx=eh.getExceptionType();
            for (            jq_Class thrownEx : thrownExList) {
              if (thrownEx.equals(handledEx)) {
                System.out.println(""String_Node_Str"" + thrownEx + ""String_Node_Str"");
                unhandledExList.remove(thrownEx);
              }
              if (isSubClass(thrownEx,handledEx)) {
                System.out.println(""String_Node_Str"" + thrownEx + ""String_Node_Str""+ handledEx);
                unhandledExList.remove(thrownEx);
              }
            }
            try {
              int exhandlerLineNum=eh.getEntry().getLastQuad().getLineNumber();
              if (exhandlerLineNum > endingLine) {
                endingLine=exhandlerLineNum;
              }
            }
 catch (            Throwable e) {
            }
          }
          for (          jq_Class unhandledEx : unhandledExList) {
            boolean ignore=false;
            if (has_handler == false) {
              if (m.getThrownExceptionsTable() != null) {
                for (                jq_Class tex : m.getThrownExceptionsTable()) {
                  if (tex.equals(unhandledEx) || isSubClass(unhandledEx,tex)) {
                    System.out.println(""String_Node_Str"" + unhandledEx + ""String_Node_Str""+ ""String_Node_Str""+ tex);
                    ignore=true;
                    break;
                  }
                }
              }
            }
            if (ignore == true) {
              continue;
            }
            jq_Class superclass=null;
            try {
              superclass=unhandledEx.getSuperclass();
            }
 catch (            RuntimeException e) {
              ignore=true;
            }
            while (superclass != null) {
              if (superclass.toString().equals(""String_Node_Str"")) {
                ignore=true;
                break;
              }
              try {
                superclass=superclass.getSuperclass();
              }
 catch (              RuntimeException e) {
                ignore=true;
                break;
              }
            }
            if (ignore == true) {
              continue;
            }
            String bugInfo=unhandledEx.toString() + bb.toString() + m.toString()+ m.getDeclaringClass().toString();
            if (warningMap.containsKey(bugInfo)) {
              continue;
            }
            warningMap.put(bugInfo,1);
            bugID++;
            System.out.println(""String_Node_Str"");
            System.out.println(""String_Node_Str"" + bugID + ""String_Node_Str""+ unhandledEx+ ""String_Node_Str"");
            System.out.print(""String_Node_Str"");
            for (            Quad tq : exQuadMap.get(unhandledEx)) {
              System.out.println(""String_Node_Str"" + tq.getLineNumber() + ""String_Node_Str""+ m.getDeclaringClass().getSourceFileName()+ ""String_Node_Str"");
              System.out.println(""String_Node_Str"" + tq);
            }
            System.out.println(""String_Node_Str"" + m);
            if (has_handler == false) {
              System.out.println(""String_Node_Str"");
            }
 else {
              System.out.print(""String_Node_Str"");
              for (              ExceptionHandler eh : bb.getExceptionHandlers()) {
                jq_Class handledEx=eh.getExceptionType();
                System.out.print(handledEx.getName());
                if (isSubClass(handledEx,unhandledEx)) {
                  System.out.println(""String_Node_Str"" + unhandledEx.getName());
                }
 else {
                  System.out.println(""String_Node_Str"" + unhandledEx.getName());
                }
              }
            }
            try {
              if (endingLine == 0) {
                endingLine=startingLine;
              }
              printer.printCode(startingLine,endingLine,m.getDeclaringClass().getSourceFileName(),true);
            }
 catch (            IOException ioe) {
              System.out.println(""String_Node_Str"" + m.getDeclaringClass().getSourceFileName() + ""String_Node_Str""+ startingLine+ ""String_Node_Str""+ endingLine);
            }
            System.out.println(""String_Node_Str"");
            System.out.println();
          }
        }
      }
    }
  }
}",0.999628225146851
32358,"public static List<Integer> tableSendPos(Rule r,Map<String,Table> tableMap){
  List<Predicate> bodyP=r.getBodyP();
  List<Integer> sendPos=new ArrayList<Integer>();
  Predicate prevp=null;
  for (  Predicate p : bodyP) {
    if (prevp == null || prevp instanceof PrivPredicate) {
      prevp=p;
      continue;
    }
    if (requireTransfer(prevp,p,tableMap)) {
      if (collectLiveVarsAt(r,p.getPos()).isEmpty()) {
        Assert.impossible();
        continue;
      }
      sendPos.add(p.getPos());
    }
    prevp=p;
  }
  return sendPos;
}","public static List<Integer> tableSendPos(Rule r,Map<String,Table> tableMap){
  List<Predicate> bodyP=r.getBodyP();
  List<Integer> sendPos=new ArrayList<Integer>();
  Predicate prevp=null;
  for (  Predicate p : bodyP) {
    if (prevp == null || prevp instanceof PrivPredicate) {
      prevp=p;
      continue;
    }
    if (requireTransfer(prevp,p,tableMap)) {
      if (collectLiveVarsAt(r,p.getPos()).isEmpty()) {
        continue;
      }
      sendPos.add(p.getPos());
    }
    prevp=p;
  }
  return sendPos;
}",0.8350612629594723
32359,"void processRemoteRules(){
  if (!conf.isDistributed())   return;
  List<Rule> toAdd=new ArrayList<Rule>();
  for (  RuleComp rc : ruleComps) {
    for (    Rule r : rc.getRules()) {
      if (hasRemoteRuleHead(r))       processRemoteRuleHead(r,toAdd);
    }
    rc.addAll(toAdd);
    toAdd.clear();
    for (    Rule r : rc.getRules()) {
      if (hasRemoteRuleBody(r))       processRemoteRuleBody(r,toAdd);
    }
    rc.addAll(toAdd);
    while (!toAdd.isEmpty()) {
      List<Rule> toAdd2=new ArrayList<Rule>();
      for (      Rule r : toAdd) {
        if (hasRemoteRuleHead(r))         processRemoteRuleHead(r,toAdd2);
        if (hasRemoteRuleBody(r))         processRemoteRuleBody(r,toAdd2);
      }
      rc.addAll(toAdd2);
      toAdd=toAdd2;
    }
  }
}","void processRemoteRules(){
  if (!conf.isDistributed())   return;
  List<Rule> toAdd=new ArrayList<Rule>();
  for (  RuleComp rc : ruleComps) {
    for (    Rule r : rc.getRules()) {
      if (hasRemoteRuleHead(r,tableMap))       processRemoteRuleHead(r,toAdd);
    }
    rc.addAll(toAdd);
    toAdd.clear();
    for (    Rule r : rc.getRules()) {
      if (hasRemoteRuleBody(r,tableMap))       processRemoteRuleBody(r,toAdd);
    }
    rc.addAll(toAdd);
    while (!toAdd.isEmpty()) {
      List<Rule> toAdd2=new ArrayList<Rule>();
      for (      Rule r : toAdd) {
        if (hasRemoteRuleHead(r,tableMap))         processRemoteRuleHead(r,toAdd2);
        if (hasRemoteRuleBody(r,tableMap))         processRemoteRuleBody(r,toAdd2);
      }
      rc.addAll(toAdd2);
      toAdd=toAdd2;
    }
  }
}",0.9769820971867008
32360,"public static boolean hasRemoteRuleHead(Rule r){
  Predicate h=r.getHead();
  if (r.isSimpleArrayInit())   return false;
  if (r.getBodyP().size() == 0)   return true;
  List<Predicate> body=r.getBodyP();
  Predicate p=body.get(body.size() - 1);
  if (p.first().equals(h.first()))   return false;
 else   return true;
}","public static boolean hasRemoteRuleHead(Rule r,Map<String,Table> tableMap){
  Predicate h=r.getHead();
  if (r.isSimpleArrayInit())   return false;
  if (r.getBodyP().size() == 0)   return true;
  List<Predicate> body=r.getBodyP();
  Predicate p=body.get(body.size() - 1);
  return requireTransfer(p,h,tableMap);
}",0.7993680884676145
32361,"public static boolean hasRemoteRuleBody(Rule r){
  List<Predicate> bodyP=r.getBodyP();
  if (bodyP.size() <= 1)   return false;
  List<Integer> sendPos=tableSendPos(r);
  if (sendPos.isEmpty())   return false;
  return true;
}","public static boolean hasRemoteRuleBody(Rule r,Map<String,Table> tableMap){
  List<Predicate> bodyP=r.getBodyP();
  if (bodyP.size() <= 1)   return false;
  List<Integer> sendPos=tableSendPos(r,tableMap);
  if (sendPos.isEmpty())   return false;
  return true;
}",0.9262295081967212
32362,"public static List<Integer> tableSendPos(List<Predicate> bodyP){
  List<Integer> sendPos=new ArrayList<Integer>();
  Predicate prevp=null;
  for (  Predicate p : bodyP) {
    if (prevp != null) {
      if (!prevp.first().equals(p.first())) {
        sendPos.add(p.getPos());
      }
    }
    prevp=p;
  }
  return sendPos;
}","public static List<Integer> tableSendPos(Rule r,Map<String,Table> tableMap){
  List<Predicate> bodyP=r.getBodyP();
  List<Integer> sendPos=new ArrayList<Integer>();
  Predicate prevp=null;
  for (  Predicate p : bodyP) {
    if (prevp == null || prevp instanceof PrivPredicate) {
      prevp=p;
      continue;
    }
    if (requireTransfer(prevp,p,tableMap)) {
      if (collectLiveVarsAt(r,p.getPos()).isEmpty()) {
        Assert.impossible();
        continue;
      }
      sendPos.add(p.getPos());
    }
    prevp=p;
  }
  return sendPos;
}",0.5701149425287356
32363,"boolean hasRemoteRuleHead(){
  if (!conf.isDistributed())   return false;
  return Analysis.hasRemoteRuleHead(rule);
}","boolean hasRemoteRuleHead(){
  if (!conf.isDistributed())   return false;
  return Analysis.hasRemoteRuleHead(rule,tableMap);
}",0.963265306122449
32364,"boolean hasRemoteRuleBody(){
  if (!conf.isDistributed())   return false;
  return Analysis.hasRemoteRuleBody(rule);
}","boolean hasRemoteRuleBody(){
  if (!conf.isDistributed())   return false;
  return Analysis.hasRemoteRuleBody(rule,tableMap);
}",0.963265306122449
32365,"List<Integer> tableSendPos(){
  if (tableSendPos == null)   tableSendPos=Analysis.tableSendPos(rule);
  return tableSendPos;
}","List<Integer> tableSendPos(){
  if (tableSendPos == null)   tableSendPos=Analysis.tableSendPos(rule,tableMap);
  return tableSendPos;
}",0.9655172413793104
32366,"public void waitUntilReady(int id) throws InterruptedException {
  if (ready.containsKey(id))   return;
  Object o=new Object();
synchronized (o) {
    Object prev=ready.putIfAbsent(id,o);
    if (prev != null) {
      return;
    }
    o.wait();
  }
}","public void waitUntilReady(int id) throws InterruptedException {
  if (ready.containsKey(id)) {
    ready.get(id);
    return;
  }
  Object o=new Object();
synchronized (o) {
    Object prev=ready.putIfAbsent(id,o);
    if (prev != null) {
      return;
    }
    o.wait();
  }
}",0.9152542372881356
32367,"public synchronized SocketChannel next(){
  selected++;
  return channels[selected % channelNum];
}","public synchronized SocketChannel next(){
  int s=selected.incrementAndGet();
  return channels[s % channelNum];
}",0.8450704225352113
32368,"public ChannelMux(){
  channels=new SocketChannel[channelNum];
  _pos=0;
  selected=0;
}","public ChannelMux(){
  channels=new SocketChannel[channelNum];
  _pos=0;
  selected=new AtomicInteger(0);
}",0.9025641025641026
32369,"public static String[] split(String str,String delim,int maxsplit){
  int delimLength=delim.length();
  if (delimLength == 1) {
    return split(str,delim.charAt(0),maxsplit);
  }
  ArrayList<String> splitted=new ArrayList<String>();
  int idx=0, newIdx=-1;
  int splitnum=0;
  while ((newIdx=str.indexOf(delim,idx)) != -1) {
    if (newIdx > idx)     splitted.add(str.substring(idx,newIdx));
    idx=newIdx + delimLength;
    splitnum++;
    if (maxsplit > 0 && splitnum + 1 >= maxsplit)     break;
  }
  if (idx < str.length())   splitted.add(str.substring(idx));
  return splitted.toArray(new String[splitted.size()]);
}","public static String[] split(String str,String delim,int maxsplit){
  int delimLength=delim.length();
  if (delimLength == 1) {
    return split(str,delim.charAt(0),maxsplit);
  }
  ArrayList<String> splitted=new ArrayList<String>();
  int idx=0, newIdx=-1;
  int splitnum=0;
  while ((newIdx=str.indexOf(delim,idx)) != -1) {
    if (newIdx == idx)     splitted.add(""String_Node_Str"");
    if (newIdx > idx)     splitted.add(str.substring(idx,newIdx));
    idx=newIdx + delimLength;
    splitnum++;
    if (maxsplit > 0 && splitnum + 1 >= maxsplit)     break;
  }
  if (idx < str.length())   splitted.add(str.substring(idx));
  return splitted.toArray(new String[splitted.size()]);
}",0.9540581929555896
32370,"public static List<PyFunction> getFunctions(){
  PyDictionary locals=(PyDictionary)interp.getLocals();
  List<PyFunction> funcs=new ArrayList<PyFunction>(locals.size());
  PyIterator it=(PyIterator)locals.itervalues();
  while (true) {
    PyObject p=it.__iternext__();
    if (p == null)     break;
    if (p instanceof PyFunction && !isInternal(p)) {
      funcs.add((PyFunction)p);
    }
  }
  return funcs;
}","public static List<PyFunction> getFunctions(){
  PyObject _locals=interp.getLocals();
  List<PyFunction> funcs=new ArrayList<PyFunction>(_locals.__len__());
  PyIterator it=null;
  if (_locals instanceof PyDictionary) {
    it=(PyIterator)((PyDictionary)_locals).itervalues();
  }
 else {
    it=(PyIterator)((PyStringMap)_locals).itervalues();
  }
  while (true) {
    PyObject p=it.__iternext__();
    if (p == null)     break;
    if (p instanceof PyFunction && !isInternal(p)) {
      funcs.add((PyFunction)p);
    }
  }
  return funcs;
}",0.4633123689727463
32371,"ST genFunctionAssign(ST stmts){
  Function f=(Function)arg2;
  if (multiRows()) {
    ST withIter=CodeGen.getVisitorST(""String_Node_Str"");
    stmts.add(""String_Node_Str"",withIter);
    if (f.isPython())     withIter.add(""String_Node_Str"",""String_Node_Str"" + f.codegen().render());
 else     withIter.add(""String_Node_Str"",f.codegen().render());
    withIter.add(""String_Node_Str"",CodeGen.uniqueVar(""String_Node_Str""));
    String funcRet=CodeGen.uniqueVar(""String_Node_Str"");
    withIter.add(""String_Node_Str"",funcRet);
    if (isMultipleAssign() && f.isArrayType()) {
      @SuppressWarnings(""String_Node_Str"") List<Variable> lhs=(List<Variable>)arg1;
      withIter.add(""String_Node_Str"",""String_Node_Str"");
      for (int i=0; i < lhs.size(); i++) {
        Variable v=lhs.get(i);
        String varType=MyType.javaObjectTypeName(v);
        withIter.add(""String_Node_Str"",v + ""String_Node_Str"" + varType+ ""String_Node_Str""+ funcRet+ ""String_Node_Str""+ i+ ""String_Node_Str"");
      }
    }
 else     if (f.isPython()) {
      Variable lhs=(Variable)arg1;
      String pyToJava=MyType.javaObjectTypeName(lhs);
      if (MyType.isPrimNumberType(lhs.type)) {
        withIter.add(""String_Node_Str"",""String_Node_Str"");
        String valueGetter=valueGetter(lhs.type);
        withIter.add(""String_Node_Str"",lhs + ""String_Node_Str"" + pyToJava+ ""String_Node_Str""+ funcRet+ ""String_Node_Str""+ valueGetter);
      }
 else {
        withIter.add(""String_Node_Str"",MyType.javaObjectTypeName(lhs));
        withIter.add(""String_Node_Str"",lhs + ""String_Node_Str"" + pyToJava+ ""String_Node_Str""+ funcRet);
      }
    }
 else {
      Variable lhs=(Variable)arg1;
      String lhsType=MyType.javaType(lhs).getName();
      withIter.add(""String_Node_Str"",lhsType);
      withIter.add(""String_Node_Str"",lhs + ""String_Node_Str"" + lhsType+ ""String_Node_Str""+ funcRet);
    }
    return withIter;
  }
 else {
    if (isMultipleAssign() && f.isArrayType()) {
      String arrayVar=CodeGen.uniqueVar(""String_Node_Str"");
      @SuppressWarnings(""String_Node_Str"") List<Variable> lhs=(List<Variable>)arg1;
      stmts.add(""String_Node_Str"",""String_Node_Str"" + arrayVar + ""String_Node_Str""+ f.codegen().render());
      for (int i=0; i < lhs.size(); i++) {
        Variable v=lhs.get(i);
        String varType=MyType.javaObjectTypeName(v);
        stmts.add(""String_Node_Str"",v + ""String_Node_Str"" + varType+ ""String_Node_Str""+ arrayVar+ ""String_Node_Str""+ i+ ""String_Node_Str"");
      }
    }
 else     if (f.isPython()) {
      Variable lhs=(Variable)arg1;
      String pyToJava=MyType.javaObjectTypeName(lhs);
      if (MyType.isPrimNumberType(lhs.type)) {
        String valueGetter=valueGetter(lhs.type);
        stmts.add(""String_Node_Str"",arg1 + ""String_Node_Str"" + pyToJava+ ""String_Node_Str""+ f.codegen().render()+ ""String_Node_Str""+ valueGetter);
      }
 else {
        stmts.add(""String_Node_Str"",arg1 + ""String_Node_Str"" + pyToJava+ ""String_Node_Str""+ f.codegen().render()+ ""String_Node_Str"");
      }
    }
 else {
      stmts.add(""String_Node_Str"",arg1 + ""String_Node_Str"" + f.codegen().render());
    }
    return stmts;
  }
}","ST genFunctionAssign(ST stmts){
  Function f=(Function)arg2;
  if (multiRows()) {
    ST withIter=CodeGen.getVisitorST(""String_Node_Str"");
    stmts.add(""String_Node_Str"",withIter);
    if (f.isPython())     withIter.add(""String_Node_Str"",""String_Node_Str"" + f.codegen().render());
 else     withIter.add(""String_Node_Str"",f.codegen().render());
    withIter.add(""String_Node_Str"",CodeGen.uniqueVar(""String_Node_Str""));
    String funcRet=CodeGen.uniqueVar(""String_Node_Str"");
    withIter.add(""String_Node_Str"",funcRet);
    if (isMultipleAssign() && f.isArrayType()) {
      @SuppressWarnings(""String_Node_Str"") List<Variable> lhs=(List<Variable>)arg1;
      if (f.isPrimArrayType())       withIter.add(""String_Node_Str"",MyType.javaType(lhs.get(0)) + ""String_Node_Str"");
 else       withIter.add(""String_Node_Str"",""String_Node_Str"");
      for (int i=0; i < lhs.size(); i++) {
        Variable v=lhs.get(i);
        String varType=MyType.javaObjectTypeName(v);
        withIter.add(""String_Node_Str"",v + ""String_Node_Str"" + varType+ ""String_Node_Str""+ funcRet+ ""String_Node_Str""+ i+ ""String_Node_Str"");
      }
    }
 else     if (f.isPython()) {
      Variable lhs=(Variable)arg1;
      String pyToJava=MyType.javaObjectTypeName(lhs);
      if (MyType.isPrimNumberType(lhs.type)) {
        withIter.add(""String_Node_Str"",""String_Node_Str"");
        String valueGetter=valueGetter(lhs.type);
        withIter.add(""String_Node_Str"",lhs + ""String_Node_Str"" + pyToJava+ ""String_Node_Str""+ funcRet+ ""String_Node_Str""+ valueGetter);
      }
 else {
        withIter.add(""String_Node_Str"",MyType.javaObjectTypeName(lhs));
        withIter.add(""String_Node_Str"",lhs + ""String_Node_Str"" + pyToJava+ ""String_Node_Str""+ funcRet);
      }
    }
 else {
      Variable lhs=(Variable)arg1;
      String lhsType=MyType.javaType(lhs).getName();
      withIter.add(""String_Node_Str"",lhsType);
      withIter.add(""String_Node_Str"",lhs + ""String_Node_Str"" + lhsType+ ""String_Node_Str""+ funcRet);
    }
    return withIter;
  }
 else {
    if (isMultipleAssign() && f.isArrayType()) {
      String arrayVar=CodeGen.uniqueVar(""String_Node_Str"");
      @SuppressWarnings(""String_Node_Str"") List<Variable> lhs=(List<Variable>)arg1;
      String arrType=""String_Node_Str"";
      if (f.isPrimArrayType())       arrType=MyType.javaType(lhs.get(0)) + ""String_Node_Str"";
      stmts.add(""String_Node_Str"",arrType + ""String_Node_Str"" + arrayVar+ ""String_Node_Str""+ arrType+ ""String_Node_Str""+ f.codegen().render());
      for (int i=0; i < lhs.size(); i++) {
        Variable v=lhs.get(i);
        String varType=MyType.javaObjectTypeName(v);
        stmts.add(""String_Node_Str"",v + ""String_Node_Str"" + varType+ ""String_Node_Str""+ arrayVar+ ""String_Node_Str""+ i+ ""String_Node_Str"");
      }
    }
 else     if (f.isPython()) {
      Variable lhs=(Variable)arg1;
      String pyToJava=MyType.javaObjectTypeName(lhs);
      if (MyType.isPrimNumberType(lhs.type)) {
        String valueGetter=valueGetter(lhs.type);
        stmts.add(""String_Node_Str"",arg1 + ""String_Node_Str"" + pyToJava+ ""String_Node_Str""+ f.codegen().render()+ ""String_Node_Str""+ valueGetter);
      }
 else {
        stmts.add(""String_Node_Str"",arg1 + ""String_Node_Str"" + pyToJava+ ""String_Node_Str""+ f.codegen().render()+ ""String_Node_Str"");
      }
    }
 else {
      stmts.add(""String_Node_Str"",arg1 + ""String_Node_Str"" + f.codegen().render());
    }
    return stmts;
  }
}",0.9539966376279994
32372,"void loadPyFunc() throws InternalException {
  if (name.startsWith(""String_Node_Str""))   pyname=name.substring(""String_Node_Str"".length());
 else   pyname=name;
  if (pyname.indexOf('.') >= 0)   throw new InternalException(""String_Node_Str"");
  pyfunc=PyInterp.load(pyname);
  if (pyfunc == null)   throw new InternalException(""String_Node_Str"" + name);
  if (pyfunc.func_defaults != null && pyfunc.func_defaults.length > 0)   throw new InternalException(""String_Node_Str"" + pyname);
  CompilerFlags f=((PyBaseCode)pyfunc.func_code).co_flags;
  if (f.isFlagSet(CodeFlag.CO_VARARGS) || f.isFlagSet(CodeFlag.CO_VARKEYWORDS)) {
    throw new InternalException(""String_Node_Str"" + pyname);
  }
  if (!(pyfunc.func_code instanceof PyBaseCode)) {
    throw new InternalException(""String_Node_Str"" + pyfunc.func_code.getClass().getSimpleName() + ""String_Node_Str""+ pyname);
  }
  int idx=PyInvoke.getRegisteredIdx(pyfunc);
  if (idx < 0) {
    if (pyfuncIdx < 0)     pyfuncIdx=IdFactory.nextPyFuncId();
    PyInvoke.register(pyfuncIdx,pyfunc);
  }
 else {
    pyfuncIdx=idx;
  }
}","void loadPyFunc() throws InternalException {
  if (name.startsWith(""String_Node_Str""))   pyname=name.substring(""String_Node_Str"".length());
 else   pyname=name;
  if (pyname.indexOf('.') >= 0)   throw new InternalException(""String_Node_Str"" + pyname);
  pyfunc=PyInterp.load(pyname);
  if (pyfunc == null)   throw new InternalException(""String_Node_Str"" + name);
  if (pyfunc.func_defaults != null && pyfunc.func_defaults.length > 0)   throw new InternalException(""String_Node_Str"" + pyname);
  CompilerFlags f=((PyBaseCode)pyfunc.func_code).co_flags;
  if (f.isFlagSet(CodeFlag.CO_VARARGS) || f.isFlagSet(CodeFlag.CO_VARKEYWORDS)) {
    throw new InternalException(""String_Node_Str"" + pyname);
  }
  if (!(pyfunc.func_code instanceof PyBaseCode)) {
    throw new InternalException(""String_Node_Str"" + pyfunc.func_code.getClass().getSimpleName() + ""String_Node_Str""+ pyname);
  }
  int idx=PyInvoke.getRegisteredIdx(pyfunc);
  if (idx < 0) {
    if (pyfuncIdx < 0)     pyfuncIdx=IdFactory.nextPyFuncId();
    PyInvoke.register(pyfuncIdx,pyfunc);
  }
 else {
    pyfuncIdx=idx;
  }
}",0.9958236658932714
32373,"void computeJavaReturnVarTypes(TypeCast cast) throws InternalException {
  Class<?> retType=getMethodReturnType();
  if (retType.equals(Iterator.class)) {
    Type genRetType=method.getGenericReturnType();
    if (!(genRetType instanceof ParameterizedType)) {
      String msg=""String_Node_Str"";
      throw new InternalException(msg);
    }
    Type paramType=((ParameterizedType)genRetType).getActualTypeArguments()[0];
    if (paramType instanceof GenericArrayType) {
      Type compType=((GenericArrayType)paramType).getGenericComponentType();
      retType=(Class<?>)compType;
      computeJavaArrayReturnVarTypes(cast,retType);
    }
 else {
      retType=(Class<?>)paramType;
      retType=doTypeCast(cast,retType);
      Variable v=getReturns().get(0);
      v.setType(retType);
    }
  }
 else   if (TIterator.class.isAssignableFrom(retType)) {
    String msg=""String_Node_Str"" + name;
    if (getReturns().size() != 1)     throw new InternalException(msg);
    Variable v=(Variable)getReturns().get(0);
    if (retType.equals(TIntIterator.class))     v.setType(doTypeCast(cast,int.class));
 else     if (retType.equals(TLongIterator.class))     v.setType(doTypeCast(cast,long.class));
 else     if (retType.equals(TFloatIterator.class))     v.setType(doTypeCast(cast,float.class));
 else     if (retType.equals(TDoubleIterator.class))     v.setType(doTypeCast(cast,double.class));
 else     throw new InternalException(msg);
  }
 else   if (retType.isArray()) {
    computeJavaArrayReturnVarTypes(cast,retType);
  }
 else {
    if (getReturns().size() != 1)     throw new InternalException(""String_Node_Str"" + name);
    Variable v=(Variable)getReturns().get(0);
    retType=doTypeCast(cast,retType);
    v.setType(retType);
  }
}","void computeJavaReturnVarTypes(TypeCast cast) throws InternalException {
  Class<?> retType=getMethodReturnType();
  if (retType.equals(Iterator.class)) {
    Type genRetType=method.getGenericReturnType();
    if (!(genRetType instanceof ParameterizedType)) {
      String msg=""String_Node_Str"";
      throw new InternalException(msg);
    }
    Type paramType=((ParameterizedType)genRetType).getActualTypeArguments()[0];
    if (paramType instanceof GenericArrayType) {
      Type compType=((GenericArrayType)paramType).getGenericComponentType();
      retType=(Class<?>)compType;
      computeJavaArrayReturnVarTypes(cast,retType);
    }
 else {
      retType=(Class<?>)paramType;
      if (retType.isArray() && getReturns().size() >= 2) {
        computeJavaArrayReturnVarTypes(cast,retType);
      }
 else {
        retType=doTypeCast(cast,retType);
        Variable v=getReturns().get(0);
        v.setType(retType);
      }
    }
  }
 else   if (TIterator.class.isAssignableFrom(retType)) {
    String msg=""String_Node_Str"" + name;
    if (getReturns().size() != 1)     throw new InternalException(msg);
    Variable v=(Variable)getReturns().get(0);
    if (retType.equals(TIntIterator.class))     v.setType(doTypeCast(cast,int.class));
 else     if (retType.equals(TLongIterator.class))     v.setType(doTypeCast(cast,long.class));
 else     if (retType.equals(TFloatIterator.class))     v.setType(doTypeCast(cast,float.class));
 else     if (retType.equals(TDoubleIterator.class))     v.setType(doTypeCast(cast,double.class));
 else     throw new InternalException(msg);
  }
 else   if (retType.isArray()) {
    computeJavaArrayReturnVarTypes(cast,retType);
  }
 else {
    if (getReturns().size() != 1)     throw new InternalException(""String_Node_Str"" + name);
    Variable v=(Variable)getReturns().get(0);
    retType=doTypeCast(cast,retType);
    v.setType(retType);
  }
}",0.960529947557273
32374,"void computeJavaArrayReturnVarTypes(TypeCast cast,Class<?> methodRetType) throws InternalException {
  if (getReturns().size() == 1) {
    methodRetType=doTypeCast(cast,methodRetType);
    Variable v=getReturns().get(0);
    v.setType(methodRetType);
  }
 else {
    Class<?>[] types=getTypesFromJavaAnnotation();
    isArrayType=true;
    if (types == null) {
      Class<?> arrType=getMethodReturnType();
      if (!arrType.isArray()) {
        String msg=""String_Node_Str"" + name;
        throw new InternalException(msg);
      }
      Class<?> elemType=arrType.getComponentType();
      elemType=doTypeCast(cast,elemType);
      for (int i=0; i < getReturns().size(); i++) {
        getReturns().get(i).setType(elemType);
      }
      return;
    }
 else {
      if (cast != null)       throw new InternalException(""String_Node_Str"" + cast.type.getSimpleName());
      if (types.length != getReturns().size()) {
        String msg=""String_Node_Str"" + name;
        throw new InternalException(msg);
      }
      for (int i=0; i < types.length; i++) {
        getReturns().get(i).setType(types[i]);
      }
    }
  }
}","void computeJavaArrayReturnVarTypes(TypeCast cast,Class<?> methodRetType) throws InternalException {
  if (getReturns().size() == 1) {
    methodRetType=doTypeCast(cast,methodRetType);
    Variable v=getReturns().get(0);
    v.setType(methodRetType);
  }
 else {
    Class<?>[] types=getTypesFromJavaAnnotation();
    isArrayType=true;
    if (types == null) {
      Class<?> arrType=methodRetType;
      if (methodRetType.getComponentType().isPrimitive()) {
        isPrimArrayType=true;
      }
      if (!arrType.isArray()) {
        String msg=""String_Node_Str"" + name;
        throw new InternalException(msg);
      }
      Class<?> elemType=arrType.getComponentType();
      elemType=doTypeCast(cast,elemType);
      for (int i=0; i < getReturns().size(); i++) {
        getReturns().get(i).setType(elemType);
      }
      return;
    }
 else {
      if (cast != null)       throw new InternalException(""String_Node_Str"" + cast.type.getSimpleName());
      if (types.length != getReturns().size()) {
        String msg=""String_Node_Str"" + name;
        throw new InternalException(msg);
      }
      for (int i=0; i < types.length; i++) {
        getReturns().get(i).setType(types[i]);
      }
    }
  }
}",0.9503849443969205
32375,"public void dropTable(String name){
  TableDecl decl=tableDeclMap.get(name);
  if (decl.hasIterColumn()) {
    for (int i=0; i < decl.maxIter(); i++) {
      tableMap.remove(IterTable.name(decl.name(),i));
    }
    tableDeclMap.remove(name);
  }
 else {
    tableMap.remove(name);
    tableDeclMap.remove(name);
  }
}","public void dropTable(String name){
  TableDecl decl=tableDeclMap.get(name);
  if (decl == null)   return;
  if (decl.hasIterColumn()) {
    for (int i=0; i < decl.maxIter(); i++) {
      tableMap.remove(IterTable.name(decl.name(),i));
    }
    tableDeclMap.remove(name);
  }
 else {
    tableMap.remove(name);
    tableDeclMap.remove(name);
  }
}",0.954954954954955
32376,"public String signature(Map<String,Table> tableMap){
  String sig=""String_Node_Str"";
  Predicate p=getHead();
  Table t=tableMap.get(p.name());
  sig+=p.signature(p.name());
  sig+=""String_Node_Str"";
  boolean first=true;
  for (  Object o : getBody()) {
    if (!first)     sig+=""String_Node_Str"";
    if (o instanceof Predicate) {
      Predicate p2=(Predicate)o;
      t=tableMap.get(((Predicate)o).name());
      sig+=p2.signature(p2.name());
    }
 else {
      Expr e=(Expr)o;
      sig+=e.sig();
    }
    first=false;
  }
  sig+=""String_Node_Str"";
  return sig;
}","public String signature(Map<String,Table> tableMap){
  String sig=""String_Node_Str"";
  Predicate p=getHead();
  Table t=tableMap.get(p.name());
  sig+=p.signature(t.signature());
  sig+=""String_Node_Str"";
  boolean first=true;
  for (  Object o : getBody()) {
    if (!first)     sig+=""String_Node_Str"";
    if (o instanceof Predicate) {
      Predicate p2=(Predicate)o;
      t=tableMap.get(((Predicate)o).name());
      sig+=p2.signature(p2.name());
    }
 else {
      Expr e=(Expr)o;
      sig+=e.sig();
    }
    first=false;
  }
  sig+=""String_Node_Str"";
  return sig;
}",0.986922406277245
32377,"MergeTableMap(Map<String,Table> old,Map<String,Table> newMap){
  if (old.keySet().equals(newMap.keySet())) {
    map=old;
  }
 else {
    map=new HashMap<String,Table>(old);
    map.putAll(newMap);
  }
}","MergeTableMap(Map<String,Table> old,Map<String,Table> newMap){
  if (old.keySet().equals(newMap.keySet())) {
    map=newMap;
  }
 else {
    map=new HashMap<String,Table>(old);
    map.putAll(newMap);
  }
}",0.9779951100244498
32378,"public boolean add(int v){
  if (set.isFull()) {
    if (prevSets == null)     prevSets=new ArrayList<BloomFilter>(2);
    prevSets.add(set);
    int expandby=4;
    int expectedSize=set.size() * expandby;
    double bitsPerElm=set.getExpectedBitsPerElement() + 0.25;
    if (bitsPerElm > 10)     bitsPerElm=10;
    int numHash=(int)(bitsPerElm * 0.7f);
    set=new BloomFilter(bitsPerElm,expectedSize,numHash);
  }
  return set.add(v);
}","public boolean add(long v){
  if (set.isFull())   expand();
  return set.add(v);
}",0.3038461538461538
32379,"public ApproxSet(double bitsPerElem,int expectedSize,int numHash){
  set=new BloomFilter(bitsPerElem,expectedSize,numHash);
}","public ApproxSet(double bitsPerElem,int expectedSize){
  int numHash=getOptimalNumHash(bitsPerElem);
  set=new BloomFilter(bitsPerElem,expectedSize,numHash);
}",0.8661971830985915
32380,"public boolean contains(int v){
  if (set.contains(v))   return true;
  if (prevSets != null) {
    for (    BloomFilter prevSet : prevSets) {
      if (prevSet.contains(v))       return true;
    }
  }
  return false;
}","public boolean contains(long v){
  if (set.contains(v))   return true;
  if (prevSets != null) {
    for (    BloomFilter prevSet : prevSets) {
      if (prevSet.contains(v))       return true;
    }
  }
  return false;
}",0.984126984126984
32381,"public static void main(String[] args){
  ApproxSet set=new ApproxSet(5.0,500,3);
  for (int i=-5000; i < 5000; i++) {
    set.add(i);
  }
  int cnt=0;
  for (int i=5001; i < 105000; i++) {
    if (set.contains(i))     cnt++;
  }
  System.out.println(""String_Node_Str"" + cnt + ""String_Node_Str""+ (cnt / 100000.0));
}","public static void main(String[] args){
  ApproxSet set=new ApproxSet(10,1024);
  for (int i=-5000; i < 5000; i++) {
    boolean added=set.add(i);
    if (!added) {
      System.out.println(""String_Node_Str"" + added);
    }
  }
  int cnt=0;
  for (int i=5001; i < 1005000; i++) {
    if (set.contains(i))     cnt++;
  }
  System.out.println(""String_Node_Str"" + cnt + ""String_Node_Str""+ (cnt / 1000000.0));
}",0.8243430152143845
32382,"public void writeExternal(ObjectOutput out) throws IOException {
  out.writeObject(bitset);
  out.writeInt(bitSetSize);
  out.writeFloat(bitsPerElement);
  out.writeInt(numOfElements);
  out.writeShort(k);
}","public void writeExternal(ObjectOutput out) throws IOException {
  out.writeObject(bitset);
  out.writeFloat(bitsPerElement);
  out.writeInt(numElements);
  out.writeShort(k);
}",0.921875
32383,"public void clear(){
  bitset.clear();
  numOfElements=0;
}","public void clear(){
  bitset.clear();
  numElements=0;
}",0.9827586206896552
32384,"public int count(){
  return this.numOfElements;
}","public int count(){
  return this.numElements;
}",0.979591836734694
32385,"/** 
 * @param bitSetSize defines how many bits should be used in total for the filter.
 * @param expectedNum defines the maximum number of elements the filter is expected to contain.
 */
public BloomFilter(int bitSetSize,int expectedNum){
  this(bitSetSize / (float)expectedNum,expectedNum,(int)Math.round((bitSetSize / (float)expectedNum) * Math.log(2.0)));
}","public BloomFilter(double c,int n,int k){
  this((float)c,n,k);
}",0.2347417840375587
32386,"public int size(){
  return this.bitSetSize;
}","public int size(){
  return this.numElements;
}",0.7956989247311828
32387,"@Override public int hashCode(){
  int hash=7;
  hash=61 * hash + (this.bitset != null ? this.bitset.hashCode() : 0);
  hash=61 * hash + this.bitSetSize;
  hash=61 * hash + this.k;
  return hash;
}","@Override public int hashCode(){
  int hash=7;
  hash=61 * hash + (this.bitset != null ? this.bitset.hashCode() : 0);
  hash=61 * hash + this.getBitSetSize();
  hash=61 * hash + this.k;
  hash=61 * hash + HashCode.get(bitsPerElement);
  hash=61 * hash + HashCode.get(numElements);
  return hash;
}",0.7935222672064778
32388,"/** 
 * Compares the contents of two instances to see if they are equal.
 * @param obj is the object to compare to.
 * @return True if the contents of the objects are equal.
 */
@Override public boolean equals(Object obj){
  if (obj == null) {
    return false;
  }
  if (getClass() != obj.getClass()) {
    return false;
  }
  final BloomFilter other=(BloomFilter)obj;
  if (this.k != other.k)   return false;
  if (this.bitSetSize != other.bitSetSize)   return false;
  if (this.bitset != other.bitset && (this.bitset == null || !this.bitset.equals(other.bitset))) {
    return false;
  }
  return true;
}","/** 
 * Compares the contents of two instances to see if they are equal.
 * @param obj is the object to compare to.
 * @return True if the contents of the objects are equal.
 */
@Override public boolean equals(Object obj){
  if (obj == null) {
    return false;
  }
  if (getClass() != obj.getClass()) {
    return false;
  }
  final BloomFilter other=(BloomFilter)obj;
  if (this.k != other.k)   return false;
  if (this.bitsPerElement != other.bitsPerElement)   return false;
  if (this.numElements != other.numElements)   return false;
  return this.bitset.equals(other.bitset);
}",0.8084033613445378
32389,"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
  bitset=(BitSet)in.readObject();
  bitSetSize=in.readInt();
  bitsPerElement=in.readFloat();
  numOfElements=in.readInt();
  k=in.readShort();
}","public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
  bitset=(BitSet)in.readObject();
  bitsPerElement=in.readFloat();
  numElements=in.readInt();
  k=in.readShort();
}",0.9330254041570438
32390,"public boolean isFull(){
  if (bitset.cardinality() * 2 > bitSetSize)   return true;
  return false;
}","public boolean isFull(){
  if (bitset.cardinality() * 2 + 1 >= getBitSetSize())   return true;
  return false;
}",0.9439252336448598
32391,"int[] hash(long val){
  int[] h=new int[k];
  long h0=hash0(val);
  long h1=hash1(val);
  for (int i=0; i < k; i++) {
    long x=h0 + i * h1;
    h[i]=Math.abs((int)(x % bitSetSize));
  }
  return h;
}","int[] hash(long val){
  int[] h=new int[k];
  long h0=hash0(val);
  long h1=hash1(val);
  for (int i=0; i < k; i++) {
    long x=h0 + i * h1;
    if (x < 0)     x=-x;
    h[i]=(int)(x % getBitSetSize());
  }
  return h;
}",0.8815165876777251
32392,"ST genFunctionAssign(ST stmts){
  Function f=(Function)arg2;
  if (multiRows()) {
    ST withIter=CodeGen.getVisitorST(""String_Node_Str"");
    stmts.add(""String_Node_Str"",withIter);
    if (f.isPython())     withIter.add(""String_Node_Str"",""String_Node_Str"" + f.codegen().render());
 else     withIter.add(""String_Node_Str"",f.codegen().render());
    withIter.add(""String_Node_Str"",CodeGen.uniqueVar(""String_Node_Str""));
    String funcRet=CodeGen.uniqueVar(""String_Node_Str"");
    withIter.add(""String_Node_Str"",funcRet);
    if (isMultipleAssign() && f.isArrayType()) {
      @SuppressWarnings(""String_Node_Str"") List<Variable> lhs=(List<Variable>)arg1;
      if (f.isPrimArrayType())       withIter.add(""String_Node_Str"",MyType.javaType(lhs.get(0)) + ""String_Node_Str"");
 else       withIter.add(""String_Node_Str"",""String_Node_Str"");
      for (int i=0; i < lhs.size(); i++) {
        Variable v=lhs.get(i);
        String varType=MyType.javaObjectTypeName(v);
        withIter.add(""String_Node_Str"",v + ""String_Node_Str"" + varType+ ""String_Node_Str""+ funcRet+ ""String_Node_Str""+ i+ ""String_Node_Str"");
      }
    }
 else     if (f.isPython()) {
      Variable lhs=(Variable)arg1;
      String pyToJava=MyType.javaObjectTypeName(lhs);
      if (MyType.isPrimNumberType(lhs.type)) {
        withIter.add(""String_Node_Str"",""String_Node_Str"");
        String valueGetter=valueGetter(lhs.type);
        withIter.add(""String_Node_Str"",lhs + ""String_Node_Str"" + pyToJava+ ""String_Node_Str""+ funcRet+ ""String_Node_Str""+ valueGetter);
      }
 else {
        withIter.add(""String_Node_Str"",MyType.javaObjectTypeName(lhs));
        withIter.add(""String_Node_Str"",lhs + ""String_Node_Str"" + pyToJava+ ""String_Node_Str""+ funcRet);
      }
    }
 else {
      Variable lhs=(Variable)arg1;
      String lhsType=MyType.javaType(lhs).getName();
      withIter.add(""String_Node_Str"",lhsType);
      withIter.add(""String_Node_Str"",lhs + ""String_Node_Str"" + lhsType+ ""String_Node_Str""+ funcRet);
    }
    return withIter;
  }
 else {
    if (isMultipleAssign() && f.isArrayType()) {
      String arrayVar=CodeGen.uniqueVar(""String_Node_Str"");
      @SuppressWarnings(""String_Node_Str"") List<Variable> lhs=(List<Variable>)arg1;
      String arrType=""String_Node_Str"";
      if (f.isPrimArrayType())       arrType=MyType.javaType(lhs.get(0)) + ""String_Node_Str"";
      stmts.add(""String_Node_Str"",arrType + ""String_Node_Str"" + arrayVar+ ""String_Node_Str""+ arrType+ ""String_Node_Str""+ f.codegen().render());
      for (int i=0; i < lhs.size(); i++) {
        Variable v=lhs.get(i);
        String varType=MyType.javaObjectTypeName(v);
        stmts.add(""String_Node_Str"",v + ""String_Node_Str"" + varType+ ""String_Node_Str""+ arrayVar+ ""String_Node_Str""+ i+ ""String_Node_Str"");
      }
    }
 else     if (f.isPython()) {
      Variable lhs=(Variable)arg1;
      String pyToJava=MyType.javaObjectTypeName(lhs);
      if (MyType.isPrimNumberType(lhs.type)) {
        String valueGetter=valueGetter(lhs.type);
        stmts.add(""String_Node_Str"",arg1 + ""String_Node_Str"" + pyToJava+ ""String_Node_Str""+ f.codegen().render()+ ""String_Node_Str""+ valueGetter);
      }
 else {
        stmts.add(""String_Node_Str"",arg1 + ""String_Node_Str"" + pyToJava+ ""String_Node_Str""+ f.codegen().render()+ ""String_Node_Str"");
      }
    }
 else {
      stmts.add(""String_Node_Str"",arg1 + ""String_Node_Str"" + f.codegen().render());
    }
    return stmts;
  }
}","ST genFunctionAssign(ST stmts){
  Function f=(Function)arg2;
  if (multiRows()) {
    ST withIter=CodeGen.getVisitorST(""String_Node_Str"");
    stmts.add(""String_Node_Str"",withIter);
    if (f.isPython())     withIter.add(""String_Node_Str"",""String_Node_Str"" + f.codegen().render());
 else     withIter.add(""String_Node_Str"",f.codegen().render());
    withIter.add(""String_Node_Str"",CodeGen.uniqueVar(""String_Node_Str""));
    String funcRet=CodeGen.uniqueVar(""String_Node_Str"");
    withIter.add(""String_Node_Str"",funcRet);
    if (isMultipleAssign() && f.isArrayType()) {
      @SuppressWarnings(""String_Node_Str"") List<Variable> lhs=(List<Variable>)arg1;
      if (f.isPrimArrayType())       withIter.add(""String_Node_Str"",MyType.javaType(lhs.get(0)) + ""String_Node_Str"");
 else       withIter.add(""String_Node_Str"",""String_Node_Str"");
      for (int i=0; i < lhs.size(); i++) {
        Variable v=lhs.get(i);
        String varType=MyType.javaObjectTypeName(v);
        withIter.add(""String_Node_Str"",v + ""String_Node_Str"" + varType+ ""String_Node_Str""+ funcRet+ ""String_Node_Str""+ i+ ""String_Node_Str"");
      }
    }
 else     if (f.isPython()) {
      Variable lhs=(Variable)arg1;
      String pyToJava=MyType.javaObjectTypeName(lhs);
      if (MyType.isPrimNumberType(lhs.type)) {
        withIter.add(""String_Node_Str"",""String_Node_Str"");
        String valueGetter=valueGetter(lhs.type);
        withIter.add(""String_Node_Str"",lhs + ""String_Node_Str"" + pyToJava+ ""String_Node_Str""+ funcRet+ ""String_Node_Str""+ valueGetter);
      }
 else {
        withIter.add(""String_Node_Str"",MyType.javaObjectTypeName(lhs));
        withIter.add(""String_Node_Str"",lhs + ""String_Node_Str"" + pyToJava+ ""String_Node_Str""+ funcRet);
      }
    }
 else {
      Variable lhs=(Variable)arg1;
      String lhsType;
      if (MyType.javaType(lhs).isArray()) {
        lhsType=MyType.javaType(lhs).getComponentType().getName() + ""String_Node_Str"";
      }
 else {
        lhsType=MyType.javaType(lhs).getName();
      }
      withIter.add(""String_Node_Str"",lhsType);
      withIter.add(""String_Node_Str"",lhs + ""String_Node_Str"" + lhsType+ ""String_Node_Str""+ funcRet);
    }
    return withIter;
  }
 else {
    if (isMultipleAssign() && f.isArrayType()) {
      String arrayVar=CodeGen.uniqueVar(""String_Node_Str"");
      @SuppressWarnings(""String_Node_Str"") List<Variable> lhs=(List<Variable>)arg1;
      String arrType=""String_Node_Str"";
      if (f.isPrimArrayType())       arrType=MyType.javaType(lhs.get(0)) + ""String_Node_Str"";
      stmts.add(""String_Node_Str"",arrType + ""String_Node_Str"" + arrayVar+ ""String_Node_Str""+ arrType+ ""String_Node_Str""+ f.codegen().render());
      for (int i=0; i < lhs.size(); i++) {
        Variable v=lhs.get(i);
        String varType=MyType.javaObjectTypeName(v);
        stmts.add(""String_Node_Str"",v + ""String_Node_Str"" + varType+ ""String_Node_Str""+ arrayVar+ ""String_Node_Str""+ i+ ""String_Node_Str"");
      }
    }
 else     if (f.isPython()) {
      Variable lhs=(Variable)arg1;
      String pyToJava=MyType.javaObjectTypeName(lhs);
      if (MyType.isPrimNumberType(lhs.type)) {
        String valueGetter=valueGetter(lhs.type);
        stmts.add(""String_Node_Str"",arg1 + ""String_Node_Str"" + pyToJava+ ""String_Node_Str""+ f.codegen().render()+ ""String_Node_Str""+ valueGetter);
      }
 else {
        stmts.add(""String_Node_Str"",arg1 + ""String_Node_Str"" + pyToJava+ ""String_Node_Str""+ f.codegen().render()+ ""String_Node_Str"");
      }
    }
 else {
      stmts.add(""String_Node_Str"",arg1 + ""String_Node_Str"" + f.codegen().render());
    }
    return stmts;
  }
}",0.9737517831669044
32393,"public void initSocialite(SocialiteCommandLineOptions opt){
  mod=new SocialiteMod(opt.threadNum,opt.dist,true);
  getLocals().__setitem__(new PyString(mod.modName()),mod.getModule());
  getLocals().__setitem__(new PyString(mod.modUniqueName()),mod.getModule());
  PyList all=(PyList)mod.__all__();
  for (int i=0; i < all.size(); i++) {
    String k=(String)all.get(i);
    PyObject attr=mod.getAttr(k);
    getLocals().__setitem__(k,attr);
  }
}","public void initSocialite(SocialiteCommandLineOptions opt){
  mod=new SocialiteMod(opt.threadNum,opt.dist,opt.interactive);
  getLocals().__setitem__(new PyString(mod.modName()),mod.getModule());
  getLocals().__setitem__(new PyString(mod.modUniqueName()),mod.getModule());
  PyList all=(PyList)mod.__all__();
  for (int i=0; i < all.size(); i++) {
    String k=(String)all.get(i);
    PyObject attr=mod.getAttr(k);
    getLocals().__setitem__(k,attr);
  }
}",0.9812154696132596
32394,"@Override public boolean push(String line){
  if (inQuery) {
    if (hasDeclEnd(line)) {
      inQuery=false;
      return super.push(line);
    }
 else {
      if (line.trim().length() > 0)       buffer.append(""String_Node_Str"" + line);
      return true;
    }
  }
 else {
    if (hasDeclBegin(line) && !hasDeclEnd(line)) {
      inQuery=true;
      buffer.append(""String_Node_Str"" + line);
      return true;
    }
  }
  return super.push(line);
}","@Override public boolean push(String line){
  return super.push(line);
}",0.2758620689655172
32395,"/** 
 * Returns a new python interpreter using the InteractiveConsole subclass from the <tt>python.console</tt> registry key. <p> When stdin is interactive the default is   {@link JLineConsole}. Otherwise the featureless   {@link InteractiveConsole} is always used as alternative consoles causeunexpected behavior with the std file streams.
 */
private static InteractiveConsole newInterpreter(SocialiteCommandLineOptions opts){
  if (opts.interactive) {
    return new JLineSociaLiteConsole(opts);
  }
 else {
    return new SocialiteConsole(opts);
  }
}","/** 
 * Returns a new python interpreter using the InteractiveConsole subclass from the <tt>python.console</tt> registry key. <p> When stdin is interactive the default is   {@link JLineConsole}. Otherwise the featureless   {@link InteractiveConsole} is always used as alternative consoles causeunexpected behavior with the std file streams.
 */
private static InteractiveConsole newInterpreter(SocialiteCommandLineOptions opts){
  if (opts.interactive) {
    return new JLineSociaLiteConsole(opts);
  }
 else {
    return new JLineSociaLiteConsole(opts);
  }
}",0.9937219730941704
32396,"void tableStatus(Status summary){
  Parser p=getEngine().getParser();
  Map<String,Table> tableMap=p.getTableMap();
  String tableInfo=""String_Node_Str"";
  boolean first=true;
  for (  String name : tableMap.keySet()) {
    if (!first)     tableInfo+=""String_Node_Str"";
    tableInfo+=name;
    first=false;
  }
  summary.putTableStatus(tableInfo);
}","void tableStatus(Status summary){
  if (!engineExists())   return;
  DistEngine engine=getEngine();
  Parser p=getEngine().getParser();
  Map<String,Table> tableMap=p.getTableMap();
  String tableInfo=""String_Node_Str"";
  boolean first=true;
  for (  String name : tableMap.keySet()) {
    if (!first)     tableInfo+=""String_Node_Str"";
    tableInfo+=name;
    first=false;
  }
  summary.putTableStatus(tableInfo);
}",0.9138381201044388
32397,"QuerySignature getQuerySig(Predicate p,Map<String,Table> tableMap){
  sig$.name=tableMap.get(p.name()).className();
  sig$.constIdx.resetQuick();
  int i=0;
  for (  Object o : p.getAllParamsExpanded()) {
    if (o instanceof Const)     sig$.constIdx.add(i);
    i++;
  }
  return sig$;
}","QuerySignature getQuerySig(Predicate p,Map<String,Table> tableMap){
  sig$.name=tableMap.get(p.name()).className();
  sig$.constIdx.resetQuick();
  sig$.dontcareIdx.resetQuick();
  int i=0;
  for (  Object o : p.getAllParamsExpanded()) {
    if (o instanceof Const)     sig$.constIdx.add(i);
    if (isDontCare(o))     sig$.dontcareIdx.add(i);
    i++;
  }
  return sig$;
}",0.8714069591527988
32398,"public QuerySignature(String _name,TIntArrayList _constIdx){
  name=_name;
  constIdx=_constIdx;
}","public QuerySignature(String _name,TIntArrayList _constIdx,TIntArrayList _dontcareIdx){
  name=_name;
  constIdx=_constIdx;
  dontcareIdx=_dontcareIdx;
}",0.7808764940239044
32399,"public boolean equals(Object o){
  if (!(o instanceof QuerySignature))   return false;
  QuerySignature sig=(QuerySignature)o;
  return name.equals(sig.name) && constIdx.equals(sig.constIdx);
}","public boolean equals(Object o){
  if (!(o instanceof QuerySignature))   return false;
  QuerySignature sig=(QuerySignature)o;
  return name.equals(sig.name) && constIdx.equals(sig.constIdx) && dontcareIdx.equals(sig.dontcareIdx);
}",0.908235294117647
32400,"public QuerySignature clone(){
  return new QuerySignature(name,new TIntArrayList(constIdx));
}","public QuerySignature clone(){
  return new QuerySignature(name,new TIntArrayList(constIdx),new TIntArrayList(dontcareIdx));
}",0.8597285067873304
32401,"void generateVisitMethod(){
  List<ColumnGroup> columnGroups=table.getColumnGroups();
  int arity=table.numColumns();
  Collection<Variable> resolved=constVars.valueCollection();
  ST method=null;
  Predicate p=queryP;
  for (  ColumnGroup g : columnGroups) {
    int startCol=g.startIdx();
    int endCol=g.endIdx();
    method=getVisitMethod(startCol,endCol,arity);
    CodeGen.fillVisitMethodBody(method,p,startCol,endCol,resolved,getIndexByCols());
  }
  ST code=CodeGen.findCodeBlockFor(method,p);
  invokeQueryVisitor(code);
}","void generateVisitMethod(){
  List<ColumnGroup> columnGroups=table.getColumnGroups();
  int arity=table.numColumns();
  Collection<Variable> resolved=constVars.valueCollection();
  ST method=null;
  Predicate p=queryP;
  for (  ColumnGroup g : columnGroups) {
    int startCol=g.startIdx();
    int endCol=g.endIdx();
    if (allDontCares(startCol)) {
      method.add(""String_Node_Str"",""String_Node_Str"");
      break;
    }
    method=getVisitMethod(startCol,endCol,arity);
    CodeGen.fillVisitMethodBody(method,p,startCol,endCol,resolved,getIndexByCols());
  }
  ST code=CodeGen.findCodeBlockFor(method,p);
  invokeQueryVisitor(code);
}",0.9078498293515358
32402,"public static int nextId(){
  return NextId.invoke();
}","public static int nextId(int prevId,int ignored){
  return prevId;
}",0.6991869918699187
32403,"public static PythonInterpreter get(){
  return interp;
}","public static PythonInterpreter get(){
}",0.8247422680412371
32404,"public static String[] split(String str,String delim,int maxsplit){
  int delimLength=delim.length();
  if (delimLength == 1) {
    return split(str,delim.charAt(0),maxsplit);
  }
  ArrayList<String> splitted=new ArrayList<String>();
  str=str.trim();
  int idx=0, newIdx=-1;
  int splitnum=0;
  while ((newIdx=str.indexOf(delim,idx)) != -1) {
    if (newIdx > idx)     splitted.add(str.substring(idx,newIdx));
    idx=newIdx + delimLength;
    splitnum++;
    if (maxsplit > 0 && splitnum >= maxsplit)     break;
  }
  if (idx < str.length())   splitted.add(str.substring(idx));
  return splitted.toArray(new String[splitted.size()]);
}","public static String[] split(String str,String delim,int maxsplit){
  int delimLength=delim.length();
  if (delimLength == 1) {
    return split(str,delim.charAt(0),maxsplit);
  }
  ArrayList<String> splitted=new ArrayList<String>();
  int idx=0, newIdx=-1;
  int splitnum=0;
  while ((newIdx=str.indexOf(delim,idx)) != -1) {
    if (newIdx > idx)     splitted.add(str.substring(idx,newIdx));
    idx=newIdx + delimLength;
    splitnum++;
    if (maxsplit > 0 && splitnum >= maxsplit)     break;
  }
  if (idx < str.length())   splitted.add(str.substring(idx));
  return splitted.toArray(new String[splitted.size()]);
}",0.9856687898089171
32405,"public ST codegen(){
  ST expr=CodeGen.expr();
  expr.add(""String_Node_Str"",codeStr(arg));
  return expr;
}","public ST codegen(){
  ST expr=CodeGen.expr();
  expr.add(""String_Node_Str"",""String_Node_Str"" + codeStr(arg) + ""String_Node_Str"");
  return expr;
}",0.84251968503937
32406,"void adjustIterColumn(Rule r){
  for (  Predicate p : r.getAllP()) {
    TableDecl tdecl=tableDeclMap.get(p.name());
    if (!tdecl.hasIterColumn())     continue;
    int iterCol=tdecl.iterColumn();
    if (iterCol == 0 && tdecl.locationColDecl() != null) {
      throw new AnalysisException(""String_Node_Str"",r);
    }
    Object iterParam=p.getAllInputParams()[iterCol];
    if (!isIntConst(iterParam)) {
      String msg=""String_Node_Str"" + iterCol + ""String_Node_Str""+ p.name();
      throw new AnalysisException(msg,r);
    }
    p.setName(IterTable.name(p.name(),iterColumnVal(iterParam) % tdecl.maxIter()));
    p.removeParamAt(tdecl.iterColumn());
  }
}","void adjustIterColumn(Rule r){
  for (  Predicate p : r.getAllP()) {
    TableDecl tdecl=tableDeclMap.get(p.name());
    if (tdecl == null) {
      throw new AnalysisException(""String_Node_Str"" + p.name() + ""String_Node_Str"");
    }
    if (!tdecl.hasIterColumn())     continue;
    int iterCol=tdecl.iterColumn();
    if (iterCol == 0 && tdecl.locationColDecl() != null) {
      throw new AnalysisException(""String_Node_Str"",r);
    }
    Object iterParam=p.getAllInputParams()[iterCol];
    if (!isIntConst(iterParam)) {
      String msg=""String_Node_Str"" + iterCol + ""String_Node_Str""+ p.name();
      throw new AnalysisException(msg,r);
    }
    p.setName(IterTable.name(p.name(),iterColumnVal(iterParam) % tdecl.maxIter()));
    p.removeParamAt(tdecl.iterColumn());
  }
}",0.9193324061196104
32407,"static void _findTuplesToGen(Table t,TupleDecls required){
  if (t.numColumns() <= PREGEN_WIDTH)   return;
  Class<?>[] types=new Class[t.numColumns()];
  for (int i=0; i < t.numColumns(); i++)   types[i]=t.getColumn(i).type();
  required.add(types);
  if (t.groupbyColNum() > PREGEN_WIDTH) {
    types=new Class[t.groupbyColNum()];
    for (int i=0; i < t.groupbyColNum(); i++)     types[i]=t.getColumn(i).type();
    required.add(types);
  }
  if (t.groupbyRestColNum() > PREGEN_WIDTH) {
    types=new Class[t.groupbyRestColNum()];
    for (int i=t.groupbyColNum(); i < t.numColumns(); i++)     types[i - t.groupbyColNum()]=t.getColumn(i).type();
    required.add(types);
  }
}","static void _findTuplesToGen(Table t,TupleDecls required){
  if (t.numColumns() <= PREGEN_WIDTH) {
    _findTuplesToGenForIterTable(t,required);
    return;
  }
  Class<?>[] types=new Class[t.numColumns()];
  for (int i=0; i < t.numColumns(); i++)   types[i]=t.getColumn(i).type();
  required.add(types);
  _findTuplesToGenForIterTable(t,required);
  if (t.groupbyColNum() > PREGEN_WIDTH) {
    types=new Class[t.groupbyColNum()];
    for (int i=0; i < t.groupbyColNum(); i++)     types[i]=t.getColumn(i).type();
    required.add(types);
  }
  if (t.groupbyRestColNum() > PREGEN_WIDTH) {
    types=new Class[t.groupbyRestColNum()];
    for (int i=t.groupbyColNum(); i < t.numColumns(); i++)     types[i - t.groupbyColNum()]=t.getColumn(i).type();
    required.add(types);
  }
}",0.9203296703296704
32408,"void genAggrUpdateCode(ST code,String headTable,ST ifUpdated){
  AggrFunction f=headP.getAggrF();
  boolean aggrPrimType=MyType.javaType(f.getArgs().get(0)).isPrimitive();
  String groupbyRetType=MyType.javaTypeName(f.getAggrColumnType());
  code.add(""String_Node_Str"",groupbyRetType + ""String_Node_Str"");
  String groupby=invokeGroupby(headTable,headP);
  code.add(""String_Node_Str"",""String_Node_Str"" + groupby);
  String eq=aggrPrimType ? ""String_Node_Str"" : ""String_Node_Str"";
  String contIfOldAns=""String_Node_Str"" + aggrVar() + eq+ ""String_Node_Str"";
  if (f.isSimpleAggr()) {
    code.add(""String_Node_Str"",aggrVar() + ""String_Node_Str"" + f.codegen(""String_Node_Str"").render());
    boolean hasNestingAfterAggr=headT.numColumns() > f.getIdx() + 1 && headT.nestingBeginsAfter(f.getIdx() + 1);
    if (hasNestingAfterAggr) {
      Object aggrParam=f.getArgs().get(0);
      code.add(""String_Node_Str"",""String_Node_Str"" + aggrVar() + eq+ ""String_Node_Str""+ aggrParam+ ""String_Node_Str"");
    }
 else {
      code.add(""String_Node_Str"",contIfOldAns);
    }
    code.add(""String_Node_Str"",isUpdatedVar() + ""String_Node_Str"" + updateHeadParamsTo(headTable));
  }
 else {
    code.add(""String_Node_Str"",aggrVar() + ""String_Node_Str"");
    code.add(""String_Node_Str"",isUpdatedVar() + ""String_Node_Str"" + f.codegen(""String_Node_Str"").render());
  }
}","void genAggrUpdateCode(ST code,String headTable){
  AggrFunction f=headP.getAggrF();
  boolean aggrPrimType=MyType.javaType(f.getArgs().get(0)).isPrimitive();
  String groupbyRetType=MyType.javaTypeName(f.getAggrColumnType());
  code.add(""String_Node_Str"",groupbyRetType + ""String_Node_Str"");
  String groupby=invokeGroupby(headTable,headP);
  code.add(""String_Node_Str"",""String_Node_Str"" + groupby);
  String eq=aggrPrimType ? ""String_Node_Str"" : ""String_Node_Str"";
  String contIfOldAns=""String_Node_Str"" + aggrVar() + eq+ ""String_Node_Str"";
  if (f.isSimpleAggr()) {
    code.add(""String_Node_Str"",aggrVar() + ""String_Node_Str"" + f.codegen(""String_Node_Str"").render());
    boolean hasNestingAfterAggr=headT.numColumns() > f.getIdx() + 1 && headT.nestingBeginsAfter(f.getIdx() + 1);
    if (hasNestingAfterAggr) {
      Object aggrParam=f.getArgs().get(0);
      code.add(""String_Node_Str"",""String_Node_Str"" + aggrVar() + eq+ ""String_Node_Str""+ aggrParam+ ""String_Node_Str"");
    }
 else {
      code.add(""String_Node_Str"",contIfOldAns);
    }
    code.add(""String_Node_Str"",isUpdatedVar() + ""String_Node_Str"" + updateHeadParamsTo(headTable));
  }
 else {
    code.add(""String_Node_Str"",aggrVar() + ""String_Node_Str"");
    code.add(""String_Node_Str"",isUpdatedVar() + ""String_Node_Str"" + f.codegen(""String_Node_Str"").render());
  }
}",0.9951546775997018
32409,"ST genUpdateCode(ST code){
  ST ifUpdated=tmplGroup.getInstanceOf(""String_Node_Str"");
  if (headT instanceof DeltaTable) {
    code.add(""String_Node_Str"",isUpdatedVar() + ""String_Node_Str"");
    return code;
  }
  String headTableSlice=headTableVar();
  if (isTableSliced(headT)) {
    String sliceIdx;
    if (updateFromRemoteHeadT()) {
      sliceIdx=sliceIdxGetter(headT,headP.first());
    }
 else     if (Analysis.updateParallelShard(rule,tableMap)) {
      sliceIdx=firstTableIdx();
    }
 else {
      sliceIdx=sliceIdxGetter(headT,headP.first());
    }
    if (headT instanceof PrivateTable)     headTableSlice=privateHeadTableGetter(headT,sliceIdx);
 else     headTableSlice+=""String_Node_Str"" + sliceIdx + ""String_Node_Str"";
  }
  String _headTable=""String_Node_Str"";
  code.add(""String_Node_Str"",headT.className() + ""String_Node_Str"" + _headTable+ ""String_Node_Str""+ headTableSlice);
  if (priorTestForMinMax())   genPriorTestForMinMax(code,_headTable);
  if (headTableLockAtEnd()) {
    int column=headTableWriteLockColumn();
    Object param=headP.getAllParamsExpanded()[column];
    ST if_=tmplGroup.getInstanceOf(""String_Node_Str"");
    if_.add(""String_Node_Str"",isUpdatedVar());
    if_.add(""String_Node_Str"",ifUpdated);
    ST withLock, withLock2;
    if (useArrayTableLock()) {
      String arrayIndex=""String_Node_Str"" + param + ""String_Node_Str""+ sliceMapVar()+ ""String_Node_Str""+ headT.id()+ ""String_Node_Str"";
      withLock=CodeGen.withArrayLock(lockMapVar(),headT.id(),arrayIndex);
      withLock2=CodeGen.withArrayLock(lockMapVar(),headT.id(),arrayIndex);
      withLock.add(""String_Node_Str"",if_);
      withLock2.add(""String_Node_Str"",if_);
    }
 else {
      withLock=CodeGen.withLock(lockMapVar(),headT.id(),sliceIdxGetter(headT,column,param));
      withLock2=CodeGen.withLock(lockMapVar(),headT.id(),sliceIdxGetter(headT,column,param));
      withLock.add(""String_Node_Str"",if_);
      withLock2.add(""String_Node_Str"",if_);
    }
    code.add(""String_Node_Str"",withLock);
    code=withLock;
  }
  if (headP.hasFunctionParam()) {
    genAggrCode(code,_headTable,ifUpdated);
  }
 else   genInsertCode(code,_headTable,ifUpdated);
  return ifUpdated;
}","ST genUpdateCode(ST code){
  ST ifUpdated=tmplGroup.getInstanceOf(""String_Node_Str"");
  if (headT instanceof DeltaTable) {
    code.add(""String_Node_Str"",isUpdatedVar() + ""String_Node_Str"");
    return code;
  }
  String headTableSlice=headTableVar();
  if (isTableSliced(headT)) {
    String sliceIdx;
    if (updateFromRemoteHeadT()) {
      sliceIdx=sliceIdxGetter(headT,headP.first());
    }
 else     if (Analysis.updateParallelShard(rule,tableMap)) {
      sliceIdx=firstTableIdx();
    }
 else {
      sliceIdx=sliceIdxGetter(headT,headP.first());
    }
    if (headT instanceof PrivateTable)     headTableSlice=privateHeadTableGetter(headT,sliceIdx);
 else     headTableSlice+=""String_Node_Str"" + sliceIdx + ""String_Node_Str"";
  }
  String _headTable=""String_Node_Str"";
  code.add(""String_Node_Str"",headT.className() + ""String_Node_Str"" + _headTable+ ""String_Node_Str""+ headTableSlice);
  if (priorTestForMinMax())   genPriorTestForMinMax(code,_headTable);
  ST prevCode=code;
  if (headTableLockAtEnd()) {
    int column=headTableWriteLockColumn();
    Object param=headP.getAllParamsExpanded()[column];
    ST withLock, withLock2;
    if (useArrayTableLock()) {
      String arrayIndex=""String_Node_Str"" + param + ""String_Node_Str""+ sliceMapVar()+ ""String_Node_Str""+ headT.id()+ ""String_Node_Str"";
      withLock=CodeGen.withArrayLock(lockMapVar(),headT.id(),arrayIndex);
      withLock2=CodeGen.withArrayLock(lockMapVar(),headT.id(),arrayIndex);
    }
 else {
      withLock=CodeGen.withLock(lockMapVar(),headT.id(),sliceIdxGetter(headT,column,param));
      withLock2=CodeGen.withLock(lockMapVar(),headT.id(),sliceIdxGetter(headT,column,param));
    }
    code.add(""String_Node_Str"",withLock);
    code=withLock;
  }
  if (headP.hasFunctionParam()) {
    genAggrCode(code,_headTable,ifUpdated);
  }
 else   genInsertCode(code,_headTable,ifUpdated);
  ST if_=tmplGroup.getInstanceOf(""String_Node_Str"");
  if_.add(""String_Node_Str"",isUpdatedVar());
  if_.add(""String_Node_Str"",ifUpdated);
  prevCode.add(""String_Node_Str"",if_);
  return ifUpdated;
}",0.8747346072186837
32410,"void genAggrCode(ST code,String headTable,ST ifUpdated){
  AggrFunction f=headP.getAggrF();
  String contains=containsGroupbyPrefix(headTable,f);
  ST if_=tmplGroup.getInstanceOf(""String_Node_Str"");
  if (f.isSimpleAggr()) {
    if_.add(""String_Node_Str"",""String_Node_Str"" + contains);
    if_.add(""String_Node_Str"",assignVars(Arrays.asList(new Object[]{aggrVar()}),f.getArgs()));
    if_.add(""String_Node_Str"",insertHeadParamsTo(headTable));
    if_.add(""String_Node_Str"",isUpdatedVar() + ""String_Node_Str"");
    if_.add(""String_Node_Str"",ifUpdated);
    if_.add(""String_Node_Str"",""String_Node_Str"");
    code.add(""String_Node_Str"",if_);
  }
 else {
    if_.add(""String_Node_Str"",""String_Node_Str"" + contains);
    if (f.getAggrColumnType().isArray()) {
      String aggrValType=f.getAggrColumnType().getComponentType().getSimpleName();
      Variable v=(Variable)f.getArgs().get(0);
      if_.add(""String_Node_Str"",aggrValType + ""String_Node_Str"" + aggrVar()+ ""String_Node_Str""+ aggrValType+ ""String_Node_Str""+ v+ ""String_Node_Str"");
      if_.add(""String_Node_Str"",""String_Node_Str"" + aggrVar() + ""String_Node_Str""+ aggrVar()+ ""String_Node_Str""+ aggrValType+ ""String_Node_Str"");
    }
 else {
      String aggrValType=f.getAggrColumnType().getSimpleName();
      if_.add(""String_Node_Str"",aggrValType + ""String_Node_Str"" + aggrVar()+ ""String_Node_Str""+ aggrValType+ ""String_Node_Str""+ ""String_Node_Str"");
    }
    if_.add(""String_Node_Str"",isUpdatedVar() + ""String_Node_Str"" + f.codegen(aggrVar()).render());
    if_.add(""String_Node_Str"",insertHeadParamsTo(headTable));
    if_.add(""String_Node_Str"",""String_Node_Str"");
    code.add(""String_Node_Str"",if_);
  }
  genAggrUpdateCode(code,headTable,ifUpdated);
  if (useChoice()) {
    ifUpdated.add(""String_Node_Str"",choiceMadeVar() + ""String_Node_Str"");
    if (hasOnlyChoiceVar(rule.getHead())) {
      ifUpdated.add(""String_Node_Str"",""String_Node_Str"");
    }
  }
}","void genAggrCode(ST code,String headTable,ST ifUpdated){
  AggrFunction f=headP.getAggrF();
  String contains=containsGroupbyPrefix(headTable,f);
  ST ifElse=tmplGroup.getInstanceOf(""String_Node_Str"");
  if (f.isSimpleAggr()) {
    ifElse.add(""String_Node_Str"",""String_Node_Str"" + contains);
    if (isNextId(f)) {
      String nextId=""String_Node_Str"" + f.getArgs().get(0) + ""String_Node_Str"";
      ifElse.add(""String_Node_Str"",assignVars(Arrays.asList(new Object[]{aggrVar()}),Arrays.asList(new Object[]{nextId})));
    }
 else {
      ifElse.add(""String_Node_Str"",assignVars(Arrays.asList(new Object[]{aggrVar()}),f.getArgs()));
    }
    ifElse.add(""String_Node_Str"",insertHeadParamsTo(headTable));
    ifElse.add(""String_Node_Str"",isUpdatedVar() + ""String_Node_Str"");
    code.add(""String_Node_Str"",ifElse);
  }
 else {
    ifElse.add(""String_Node_Str"",""String_Node_Str"" + contains);
    if (f.getAggrColumnType().isArray()) {
      String aggrValType=f.getAggrColumnType().getComponentType().getSimpleName();
      Variable v=(Variable)f.getArgs().get(0);
      ifElse.add(""String_Node_Str"",aggrValType + ""String_Node_Str"" + aggrVar()+ ""String_Node_Str""+ aggrValType+ ""String_Node_Str""+ v+ ""String_Node_Str"");
      ifElse.add(""String_Node_Str"",""String_Node_Str"" + aggrVar() + ""String_Node_Str""+ aggrVar()+ ""String_Node_Str""+ aggrValType+ ""String_Node_Str"");
    }
 else {
      String aggrValType=f.getAggrColumnType().getSimpleName();
      ifElse.add(""String_Node_Str"",aggrValType + ""String_Node_Str"" + aggrVar()+ ""String_Node_Str""+ aggrValType+ ""String_Node_Str""+ ""String_Node_Str"");
    }
    ifElse.add(""String_Node_Str"",isUpdatedVar() + ""String_Node_Str"" + f.codegen(aggrVar()).render());
    ifElse.add(""String_Node_Str"",insertHeadParamsTo(headTable));
    ifElse.add(""String_Node_Str"",""String_Node_Str"");
    code.add(""String_Node_Str"",ifElse);
  }
  ST elseStmts=tmplGroup.getInstanceOf(""String_Node_Str"");
  ifElse.add(""String_Node_Str"",elseStmts);
  genAggrUpdateCode(elseStmts,headTable);
  if (useChoice()) {
    ifUpdated.add(""String_Node_Str"",choiceMadeVar() + ""String_Node_Str"");
    if (hasOnlyChoiceVar(rule.getHead())) {
      ifUpdated.add(""String_Node_Str"",""String_Node_Str"");
    }
  }
}",0.8593523441275979
32411,"int findSlicingColumn(Rule r){
}","int findSlicingColumn(Rule r){
  if (!isParallel)   return 0;
  if (!Analysis.isParallelRule(r,tableMap))   return -1;
  Predicate firstP=(Predicate)r.getBody().get(0);
  Object f=firstP.getAllInputParams()[0];
  Table firstT=tableMap.get(firstP.name());
  if (firstT.getColumn(0).isIndexed() && f instanceof Const)   return -1;
  int column=Analysis.firstShardedColumnWithVar(firstP,firstT);
  if (column >= 0) {
    return column;
  }
 else {
    return 0;
  }
}",0.1290322580645161
32412,"public static String[] split(String str,String delim,int maxsplit){
  int delimLength=delim.length();
  if (delimLength == 1) {
    return split(str,delim.charAt(0),maxsplit);
  }
  ArrayList<String> splitted=new ArrayList<String>();
  str=str.trim();
  int idx=0, newIdx=-1;
  int splitnum=0;
  while ((newIdx=str.indexOf(delim,idx)) != -1) {
    if (newIdx > idx)     splitted.add(str.substring(idx,newIdx));
    idx=newIdx + delimLength;
    splitnum++;
    if (maxsplit > 0 && splitnum >= maxsplit)     break;
  }
  if (idx < str.length())   splitted.add(str.substring(idx));
  return splitted.toArray(new String[splitted.size()]);
}","public static String[] split(String str,String delim,int maxsplit){
  int delimLength=delim.length();
  if (delimLength == 1) {
    return split(str,delim.charAt(0),maxsplit);
  }
  ArrayList<String> splitted=new ArrayList<String>();
  str=str.trim();
  int idx=0, newIdx=-1;
  int splitnum=0;
  while ((newIdx=str.indexOf(delim,idx)) != -1) {
    if (newIdx > idx)     splitted.add(str.substring(idx,newIdx));
    idx=newIdx + delimLength;
    splitnum++;
    if (maxsplit > 0 && splitnum + 1 >= maxsplit)     break;
  }
  if (idx < str.length())   splitted.add(str.substring(idx));
  return splitted.toArray(new String[splitted.size()]);
}",0.9968701095461658
32413,"private Dimension getPrototypeSize(E prototypeValue){
  ListCellRenderer<? super E> renderer=comboBox.getRenderer();
  if (renderer == null)   renderer=new DefaultListCellRenderer();
  final Component comp=renderer.getListCellRendererComponent(popup.getList(),prototypeValue,-1,false,false);
  comp.setFont(comboBox.getFont());
  return comp.getPreferredSize();
}","private Dimension getPrototypeSize(E prototypeValue){
  ListCellRenderer<? super E> renderer=comboBox.getRenderer();
  if (renderer == null)   renderer=new DefaultListCellRenderer();
  final Component comp=renderer.getListCellRendererComponent((JList<E>)popup.getList(),prototypeValue,-1,false,false);
  comp.setFont(comboBox.getFont());
  return comp.getPreferredSize();
}",0.9864130434782608
32414,"/** 
 * Although   {@link EventList}s are not in general,   {@link BasicEventList} is{@link Serializable}. All of the   {@link ListEventListener}s that are themselves  {@link Serializable} will be serialized, but others will not. Note that thereis <strong>no</strong> easy way to access the  {@link ListEventListener}s of an   {@link EventList}, particularly after it has been serialized. <p>As of October 3, 2005, this is the wire format of serialized  {@link BasicEventList}s: <li>An <code>Object[]</code> containing each of the list's elements <li>A <code>ListEventListener[]</code> containing <strong>only</strong> the listeners that themselves implement   {@link Serializable}. Those that do not will not be serialized. Note that   {@link TransformedList}s such as   {@link FilterList} are not {@link Serializable} and will notbe serialized. <p>As of March 4, 2007, the wire format was extended to include: <li>the ListEventPublisher <li>the ReadWriteLock represented as a  {@link SerializedReadWriteLock}<p>The motivation for this is documented <a href=""https://glazedlists.dev.java.net/issues/show_bug.cgi?id=398"">here</a>. Serialization streams with the old format are still readable. Serialization streams with the new format are not downwards-compatible.
 */
private void writeObject(ObjectOutputStream out) throws IOException {
  E[] elements=(E[])data.toArray(new Object[data.size()]);
  List<ListEventListener<E>> serializableListeners=new ArrayList<ListEventListener<E>>(1);
  for (  ListEventListener<E> listener : updates.getListEventListeners()) {
    if (!(listener instanceof Serializable))     continue;
    serializableListeners.add(listener);
  }
  ListEventListener[] listeners=serializableListeners.toArray(new ListEventListener[serializableListeners.size()]);
  out.writeObject(elements);
  out.writeObject(listeners);
  out.writeObject(getPublisher());
  out.writeObject(getReadWriteLock());
}","/** 
 * Although   {@link EventList}s are not in general,   {@link BasicEventList} is{@link Serializable}. All of the   {@link ListEventListener}s that are themselves  {@link Serializable} will be serialized, but others will not. Note that thereis <strong>no</strong> easy way to access the  {@link ListEventListener}s of an   {@link EventList}, particularly after it has been serialized. <p>As of October 3, 2005, this is the wire format of serialized  {@link BasicEventList}s: <li>An <code>Object[]</code> containing each of the list's elements <li>A <code>ListEventListener[]</code> containing <strong>only</strong> the listeners that themselves implement   {@link Serializable}. Those that do not will not be serialized. Note that   {@link TransformedList}s such as   {@link FilterList} are not {@link Serializable} and will notbe serialized. <p>As of March 4, 2007, the wire format was extended to include: <li>the ListEventPublisher <li>the ReadWriteLock represented as a  {@link SerializedReadWriteLock}<p>The motivation for this is documented <a href=""https://glazedlists.dev.java.net/issues/show_bug.cgi?id=398"">here</a>. Serialization streams with the old format are still readable. Serialization streams with the new format are not downwards-compatible.
 */
private void writeObject(ObjectOutputStream out) throws IOException {
  E[] elements=(E[])data.toArray(new Object[data.size()]);
  List<ListEventListener<E>> serializableListeners=new ArrayList<>(1);
  for (  ListEventListener<E> listener : updates.getListEventListeners()) {
    if (!(listener instanceof Serializable))     continue;
    serializableListeners.add(listener);
  }
  ListEventListener[] listeners=serializableListeners.toArray(new ListEventListener[serializableListeners.size()]);
  out.writeObject(elements);
  out.writeObject(listeners);
  out.writeObject(getPublisher());
  out.writeObject(getReadWriteLock());
}",0.9947616553169198
32415,"/** 
 * Peer method to   {@link #writeObject(ObjectOutputStream)}. Note that this is functionally equivalent to a constructor and should validate that everything is in place including locks, etc.
 */
private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
  final E[] elements=(E[])in.readObject();
  final ListEventListener<E>[] listeners=(ListEventListener<E>[])in.readObject();
  try {
    this.publisher=(ListEventPublisher)in.readObject();
    this.updates=new ListEventAssembler<E>(this,publisher);
    this.readWriteLock=(ReadWriteLock)in.readObject();
  }
 catch (  OptionalDataException e) {
    if (e.eof)     this.readWriteLock=LockFactory.DEFAULT.createReadWriteLock();
 else     throw e;
  }
  this.data=new ArrayList<E>(elements.length);
  this.data.addAll(Arrays.asList(elements));
  for (  ListEventListener<E> listener : listeners) {
    this.updates.addListEventListener(listener);
  }
}","/** 
 * Peer method to   {@link #writeObject(ObjectOutputStream)}. Note that this is functionally equivalent to a constructor and should validate that everything is in place including locks, etc.
 */
private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
  final E[] elements=(E[])in.readObject();
  final ListEventListener<E>[] listeners=(ListEventListener<E>[])in.readObject();
  try {
    this.publisher=(ListEventPublisher)in.readObject();
    this.updates=new ListEventAssembler<>(this,publisher);
    this.readWriteLock=(ReadWriteLock)in.readObject();
  }
 catch (  OptionalDataException e) {
    if (e.eof)     this.readWriteLock=LockFactory.DEFAULT.createReadWriteLock();
 else     throw e;
  }
  this.data=new ArrayList<>(elements.length);
  this.data.addAll(Arrays.asList(elements));
  for (  ListEventListener<E> listener : listeners) {
    this.updates.addListEventListener(listener);
  }
}",0.9989350372736954
32416,"/** 
 * Creates a new   {@link EventList} that shares its {@link ReadWriteLock} and{@link ListEventPublisher} with this {@link CompositeList}. This is necessary when this   {@link CompositeList} will be used by multiplethreads. <p>Note that the created  {@link EventList} must be explicitly added as a memberto this  {@link CompositeList} using {@link #addMemberList(EventList)}.
 * @return a new EventList appropriate for use as a{#link #addMemberList member list} of this CompositeList
 */
public <E>EventList<E> createMemberList(){
  return new BasicEventList<E>(getPublisher(),getReadWriteLock());
}","/** 
 * Creates a new   {@link EventList} that shares its {@link ReadWriteLock} and{@link ListEventPublisher} with this {@link CompositeList}. This is necessary when this   {@link CompositeList} will be used by multiplethreads. <p>Note that the created  {@link EventList} must be explicitly added as a memberto this  {@link CompositeList} using {@link #addMemberList(EventList)}.
 * @return a new EventList appropriate for use as a{#link #addMemberList member list} of this CompositeList
 */
public <E>EventList<E> createMemberList(){
  return new BasicEventList<>(getPublisher(),getReadWriteLock());
}",0.9991701244813278
32417,"/** 
 * Returns a new empty   {@link DebugList} which shares the same{@link ListEventListener} and {@link ReadWriteLock} with this DebugList.This method is particularly useful when debugging a  {@link CompositeList}where some member lists are DebugLists and thus must share an identical publisher and locks in order to participate in the CompositeList.
 */
public <E>DebugList<E> createNewDebugList(){
  return new DebugList<E>(getPublisher(),debugReadWriteLock);
}","/** 
 * Returns a new empty   {@link DebugList} which shares the same{@link ListEventListener} and {@link ReadWriteLock} with this DebugList.This method is particularly useful when debugging a  {@link CompositeList}where some member lists are DebugLists and thus must share an identical publisher and locks in order to participate in the CompositeList.
 */
public <E>DebugList<E> createNewDebugList(){
  return new DebugList<>(getPublisher(),debugReadWriteLock);
}",0.9989235737351992
32418,"/** 
 * Creates a   {@link DebugList} using the specified{@link ListEventPublisher} and {@link ReadWriteLock}. This is particularly useful when multiple   {@link DebugList}s are used within a  {@link CompositeList} and must share the same lock and publisher.
 */
private DebugList(ListEventPublisher publisher,DebugReadWriteLock debugReadWriteLock){
  this.debugReadWriteLock=debugReadWriteLock;
  this.delegate=new BasicEventList<E>(publisher,this.debugReadWriteLock);
  this.delegate.addListEventListener(delegateWatcher);
}","/** 
 * Creates a   {@link DebugList} using the specified{@link ListEventPublisher} and {@link ReadWriteLock}. This is particularly useful when multiple   {@link DebugList}s are used within a  {@link CompositeList} and must share the same lock and publisher.
 */
private DebugList(ListEventPublisher publisher,DebugReadWriteLock debugReadWriteLock){
  this.debugReadWriteLock=debugReadWriteLock;
  this.delegate=new BasicEventList<>(publisher,this.debugReadWriteLock);
  this.delegate.addListEventListener(delegateWatcher);
}",0.9990485252140818
32419,"/** 
 * Validates that containsAll() works with null.
 */
@Test public void testContainsAllNull(){
  List<List<String>> listTypes=new ArrayList<>();
  listTypes.add(new ArrayList<>());
  listTypes.add(new BasicEventList<>());
  listTypes.add(SortedList.create(new BasicEventList<>()));
  for (  List<String> list : listTypes) {
    list.clear();
    list.addAll(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    assertEquals(true,list.containsAll(Arrays.asList(""String_Node_Str"",""String_Node_Str"")));
    assertEquals(false,list.containsAll(Arrays.asList(""String_Node_Str"",null)));
    assertEquals(false,list.containsAll(Arrays.asList(""String_Node_Str"",""String_Node_Str"")));
    list.clear();
    list.addAll(Arrays.asList(null,""String_Node_Str"",null,""String_Node_Str""));
    assertEquals(false,list.containsAll(Arrays.asList(""String_Node_Str"",""String_Node_Str"")));
    assertEquals(true,list.containsAll(Arrays.asList(""String_Node_Str"",""String_Node_Str"")));
    assertEquals(true,list.containsAll(Arrays.asList(""String_Node_Str"",null)));
    assertEquals(true,list.containsAll(Arrays.asList(null,null)));
  }
}","/** 
 * Validates that containsAll() works with null.
 */
@Test public void testContainsAllNull(){
  List<List<String>> listTypes=new ArrayList<>();
  listTypes.add(new ArrayList<>());
  listTypes.add(new BasicEventList<>());
  listTypes.add(SortedList.create(new BasicEventList<String>()));
  for (  List<String> list : listTypes) {
    list.clear();
    list.addAll(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    assertEquals(true,list.containsAll(Arrays.asList(""String_Node_Str"",""String_Node_Str"")));
    assertEquals(false,list.containsAll(Arrays.asList(""String_Node_Str"",null)));
    assertEquals(false,list.containsAll(Arrays.asList(""String_Node_Str"",""String_Node_Str"")));
    list.clear();
    list.addAll(Arrays.asList(null,""String_Node_Str"",null,""String_Node_Str""));
    assertEquals(false,list.containsAll(Arrays.asList(""String_Node_Str"",""String_Node_Str"")));
    assertEquals(true,list.containsAll(Arrays.asList(""String_Node_Str"",""String_Node_Str"")));
    assertEquals(true,list.containsAll(Arrays.asList(""String_Node_Str"",null)));
    assertEquals(true,list.containsAll(Arrays.asList(null,null)));
  }
}",0.9974093264248703
32420,"/** 
 * Validates that lastIndexOf() works with null.
 */
@Test public void testLastIndexOfNull(){
  List<List<String>> listTypes=new ArrayList<>();
  listTypes.add(new ArrayList<>());
  listTypes.add(new BasicEventList<>());
  listTypes.add(SortedList.create(new BasicEventList<>()));
  for (  List<String> list : listTypes) {
    list.clear();
    list.addAll(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    assertTrue(-1 == list.lastIndexOf(null));
    assertTrue(-1 != list.lastIndexOf(""String_Node_Str""));
    list.clear();
    list.addAll(Arrays.asList(null,""String_Node_Str"",null,""String_Node_Str""));
    assertTrue(-1 != list.lastIndexOf(null));
    assertTrue(-1 != list.lastIndexOf(""String_Node_Str""));
    assertTrue(-1 == list.lastIndexOf(""String_Node_Str""));
  }
}","/** 
 * Validates that lastIndexOf() works with null.
 */
@Test public void testLastIndexOfNull(){
  List<List<String>> listTypes=new ArrayList<>();
  listTypes.add(new ArrayList<>());
  listTypes.add(new BasicEventList<>());
  listTypes.add(SortedList.create(new BasicEventList<String>()));
  for (  List<String> list : listTypes) {
    list.clear();
    list.addAll(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    assertTrue(-1 == list.lastIndexOf(null));
    assertTrue(-1 != list.lastIndexOf(""String_Node_Str""));
    list.clear();
    list.addAll(Arrays.asList(null,""String_Node_Str"",null,""String_Node_Str""));
    assertTrue(-1 != list.lastIndexOf(null));
    assertTrue(-1 != list.lastIndexOf(""String_Node_Str""));
    assertTrue(-1 == list.lastIndexOf(""String_Node_Str""));
  }
}",0.9963636363636365
32421,"/** 
 * Validates that retainAll() works with null.
 */
@Test public void testRetainAllNull(){
  List<List<String>> listTypes=new ArrayList<>();
  listTypes.add(new ArrayList<>());
  listTypes.add(new BasicEventList<>());
  listTypes.add(SortedList.create(new BasicEventList<>()));
  for (  List<String> list : listTypes) {
    list.clear();
    list.addAll(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    assertEquals(true,list.retainAll(Arrays.asList(""String_Node_Str"",null)));
    assertEquals(true,list.retainAll(Arrays.asList(""String_Node_Str"",null)));
    list.clear();
    list.addAll(Arrays.asList(null,""String_Node_Str"",null,""String_Node_Str""));
    assertEquals(true,list.retainAll(Arrays.asList(""String_Node_Str"",null)));
    assertEquals(true,list.retainAll(Arrays.asList(""String_Node_Str"",null)));
  }
}","/** 
 * Validates that retainAll() works with null.
 */
@Test public void testRetainAllNull(){
  List<List<String>> listTypes=new ArrayList<>();
  listTypes.add(new ArrayList<>());
  listTypes.add(new BasicEventList<>());
  listTypes.add(SortedList.create(new BasicEventList<String>()));
  for (  List<String> list : listTypes) {
    list.clear();
    list.addAll(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    assertEquals(true,list.retainAll(Arrays.asList(""String_Node_Str"",null)));
    assertEquals(true,list.retainAll(Arrays.asList(""String_Node_Str"",null)));
    list.clear();
    list.addAll(Arrays.asList(null,""String_Node_Str"",null,""String_Node_Str""));
    assertEquals(true,list.retainAll(Arrays.asList(""String_Node_Str"",null)));
    assertEquals(true,list.retainAll(Arrays.asList(""String_Node_Str"",null)));
  }
}",0.9965277777777778
32422,"/** 
 * Validates that hashCode() works with null.
 */
@Test public void testHashCodeNull(){
  List<List<String>> listTypes=new ArrayList<>();
  listTypes.add(new ArrayList<>());
  listTypes.add(new BasicEventList<>());
  listTypes.add(SortedList.create(new BasicEventList<>()));
  for (  List<String> list : listTypes) {
    List<String> copy=new ArrayList<>();
    list.clear();
    copy.clear();
    list.addAll(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    copy.addAll(list);
    assertEquals(copy.hashCode(),list.hashCode());
    assertTrue(list.equals(copy));
    copy.set(0,""String_Node_Str"");
    assertFalse(list.equals(copy));
    list.clear();
    copy.clear();
    list.addAll(Arrays.asList(null,""String_Node_Str"",null,""String_Node_Str""));
    copy.addAll(list);
    assertEquals(copy.hashCode(),list.hashCode());
    assertTrue(list.equals(copy));
    copy.set(0,""String_Node_Str"");
    assertFalse(list.equals(copy));
  }
}","/** 
 * Validates that hashCode() works with null.
 */
@Test public void testHashCodeNull(){
  List<List<String>> listTypes=new ArrayList<>();
  listTypes.add(new ArrayList<>());
  listTypes.add(new BasicEventList<>());
  listTypes.add(SortedList.create(new BasicEventList<String>()));
  for (  List<String> list : listTypes) {
    List<String> copy=new ArrayList<>();
    list.clear();
    copy.clear();
    list.addAll(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    copy.addAll(list);
    assertEquals(copy.hashCode(),list.hashCode());
    assertTrue(list.equals(copy));
    copy.set(0,""String_Node_Str"");
    assertFalse(list.equals(copy));
    list.clear();
    copy.clear();
    list.addAll(Arrays.asList(null,""String_Node_Str"",null,""String_Node_Str""));
    copy.addAll(list);
    assertEquals(copy.hashCode(),list.hashCode());
    assertTrue(list.equals(copy));
    copy.set(0,""String_Node_Str"");
    assertFalse(list.equals(copy));
  }
}",0.9969604863221884
32423,"/** 
 * Validates that indexOf() works with null.
 */
@Test public void testIndexOfNull(){
  List<List<String>> listTypes=new ArrayList<>();
  listTypes.add(new ArrayList<>());
  listTypes.add(new BasicEventList<>());
  listTypes.add(SortedList.create(new BasicEventList<>()));
  for (  List<String> list : listTypes) {
    list.clear();
    list.addAll(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    assertTrue(-1 == list.indexOf(null));
    assertTrue(-1 != list.indexOf(""String_Node_Str""));
    list.clear();
    list.addAll(Arrays.asList(null,""String_Node_Str"",null,""String_Node_Str""));
    assertTrue(-1 != list.indexOf(null));
    assertTrue(-1 != list.indexOf(""String_Node_Str""));
    assertTrue(-1 == list.indexOf(""String_Node_Str""));
  }
}","/** 
 * Validates that indexOf() works with null.
 */
@Test public void testIndexOfNull(){
  List<List<String>> listTypes=new ArrayList<>();
  listTypes.add(new ArrayList<>());
  listTypes.add(new BasicEventList<>());
  listTypes.add(SortedList.create(new BasicEventList<String>()));
  for (  List<String> list : listTypes) {
    list.clear();
    list.addAll(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    assertTrue(-1 == list.indexOf(null));
    assertTrue(-1 != list.indexOf(""String_Node_Str""));
    list.clear();
    list.addAll(Arrays.asList(null,""String_Node_Str"",null,""String_Node_Str""));
    assertTrue(-1 != list.indexOf(null));
    assertTrue(-1 != list.indexOf(""String_Node_Str""));
    assertTrue(-1 == list.indexOf(""String_Node_Str""));
  }
}",0.9962358845671268
32424,"/** 
 * Validates that removeAll() works with null.
 */
@Test public void testRemoveAllNull(){
  List<List<String>> listTypes=new ArrayList<>();
  listTypes.add(new ArrayList<>());
  listTypes.add(new BasicEventList<>());
  listTypes.add(SortedList.create(new BasicEventList<>()));
  for (  List<String> list : listTypes) {
    list.clear();
    list.addAll(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    assertEquals(true,list.removeAll(Arrays.asList(""String_Node_Str"",null)));
    assertEquals(false,list.removeAll(Arrays.asList(null,""String_Node_Str"")));
    list.clear();
    list.addAll(Arrays.asList(null,""String_Node_Str"",null,""String_Node_Str""));
    assertEquals(true,list.removeAll(Arrays.asList(""String_Node_Str"",""String_Node_Str"")));
    assertEquals(true,list.removeAll(Arrays.asList(""String_Node_Str"",null)));
    assertEquals(false,list.removeAll(Arrays.asList(""String_Node_Str"",null)));
  }
}","/** 
 * Validates that removeAll() works with null.
 */
@Test public void testRemoveAllNull(){
  List<List<String>> listTypes=new ArrayList<>();
  listTypes.add(new ArrayList<>());
  listTypes.add(new BasicEventList<>());
  listTypes.add(SortedList.create(new BasicEventList<String>()));
  for (  List<String> list : listTypes) {
    list.clear();
    list.addAll(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    assertEquals(true,list.removeAll(Arrays.asList(""String_Node_Str"",null)));
    assertEquals(false,list.removeAll(Arrays.asList(null,""String_Node_Str"")));
    list.clear();
    list.addAll(Arrays.asList(null,""String_Node_Str"",null,""String_Node_Str""));
    assertEquals(true,list.removeAll(Arrays.asList(""String_Node_Str"",""String_Node_Str"")));
    assertEquals(true,list.removeAll(Arrays.asList(""String_Node_Str"",null)));
    assertEquals(false,list.removeAll(Arrays.asList(""String_Node_Str"",null)));
  }
}",0.9968652037617556
32425,"/** 
 * Validates that contains() works with null.
 */
@Test public void testContainsNull(){
  List<List<String>> listTypes=new ArrayList<>();
  listTypes.add(new ArrayList<>());
  listTypes.add(new BasicEventList<>());
  listTypes.add(SortedList.create(new BasicEventList<>()));
  for (  List<String> list : listTypes) {
    list.clear();
    list.addAll(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    assertEquals(false,list.contains(null));
    assertEquals(true,list.contains(""String_Node_Str""));
    list.clear();
    list.addAll(Arrays.asList(null,""String_Node_Str"",null,""String_Node_Str""));
    assertEquals(true,list.contains(null));
    assertEquals(true,list.contains(""String_Node_Str""));
    assertEquals(false,list.contains(""String_Node_Str""));
  }
}","/** 
 * Validates that contains() works with null.
 */
@Test public void testContainsNull(){
  List<List<String>> listTypes=new ArrayList<>();
  listTypes.add(new ArrayList<>());
  listTypes.add(new BasicEventList<>());
  listTypes.add(SortedList.create(new BasicEventList<String>()));
  for (  List<String> list : listTypes) {
    list.clear();
    list.addAll(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    assertEquals(false,list.contains(null));
    assertEquals(true,list.contains(""String_Node_Str""));
    list.clear();
    list.addAll(Arrays.asList(null,""String_Node_Str"",null,""String_Node_Str""));
    assertEquals(true,list.contains(null));
    assertEquals(true,list.contains(""String_Node_Str""));
    assertEquals(false,list.contains(""String_Node_Str""));
  }
}",0.996300863131936
32426,"/** 
 * Validates that remove() works with null.
 */
@Test public void testRemoveNull(){
  List<List<String>> listTypes=new ArrayList<>();
  listTypes.add(new ArrayList<>());
  listTypes.add(new BasicEventList<>());
  listTypes.add(SortedList.create(new BasicEventList<>()));
  for (  List<String> list : listTypes) {
    installConsistencyListener(list);
    list.clear();
    list.addAll(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    assertEquals(false,list.remove(null));
    assertEquals(true,list.remove(""String_Node_Str""));
    list.clear();
    list.addAll(Arrays.asList(null,""String_Node_Str"",null,""String_Node_Str""));
    assertEquals(true,list.remove(null));
    assertEquals(true,list.remove(""String_Node_Str""));
    assertEquals(false,list.remove(""String_Node_Str""));
  }
}","/** 
 * Validates that remove() works with null.
 */
@Test public void testRemoveNull(){
  List<List<String>> listTypes=new ArrayList<>();
  listTypes.add(new ArrayList<>());
  listTypes.add(new BasicEventList<>());
  listTypes.add(SortedList.create(new BasicEventList<String>()));
  for (  List<String> list : listTypes) {
    installConsistencyListener(list);
    list.clear();
    list.addAll(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    assertEquals(false,list.remove(null));
    assertEquals(true,list.remove(""String_Node_Str""));
    list.clear();
    list.addAll(Arrays.asList(null,""String_Node_Str"",null,""String_Node_Str""));
    assertEquals(true,list.remove(null));
    assertEquals(true,list.remove(""String_Node_Str""));
    assertEquals(false,list.remove(""String_Node_Str""));
  }
}",0.9964071856287424
32427,"/** 
 * Handle changes from the   {@link SortedList} by modifying the grouping state.During this method, callbacks will be made to the  {@link Client} who isresponsible for firing the appropriate change events to its listeners.
 */
public void listChanged(ListEvent<E> listChanges){
  final Barcode toDoList=new Barcode();
  toDoList.addWhite(0,barcode.size());
  final LinkedList removedValues=new LinkedList();
  int lastFakedUniqueChangeIndex=-1;
  while (listChanges.next()) {
    final int changeIndex=listChanges.getIndex();
    final int changeType=listChanges.getType();
    if (changeType == ListEvent.INSERT) {
      barcode.add(changeIndex,UNIQUE,1);
      toDoList.add(changeIndex,TODO,1);
    }
 else     if (changeType == ListEvent.UPDATE) {
      if (barcode.get(changeIndex) == UNIQUE) {
        if (changeIndex + 1 < barcode.size() && barcode.get(changeIndex + 1) == DUPLICATE) {
          if (changeIndex != lastFakedUniqueChangeIndex) {
            barcode.set(changeIndex,UNIQUE,2);
            toDoList.set(changeIndex,TODO,1);
            lastFakedUniqueChangeIndex=changeIndex + 1;
          }
        }
      }
    }
 else     if (changeType == ListEvent.DELETE) {
      Object deleted=barcode.get(changeIndex);
      barcode.remove(changeIndex,1);
      toDoList.remove(changeIndex,1);
      if (deleted == UNIQUE) {
        if (changeIndex < barcode.size() && barcode.get(changeIndex) == DUPLICATE) {
          barcode.set(changeIndex,UNIQUE,1);
          deleted=UNIQUE_WITH_DUPLICATE;
        }
      }
      removedValues.addLast(deleted);
    }
  }
  TryJoinResult<E> tryJoinResult=new TryJoinResult<E>();
  listChanges.reset();
  while (listChanges.next()) {
    final int changeIndex=listChanges.getIndex();
    final int changeType=listChanges.getType();
    E newValue=listChanges.getNewValue();
    E oldValue=listChanges.getOldValue();
    if (changeType == ListEvent.INSERT) {
      tryJoinExistingGroup(changeIndex,toDoList,tryJoinResult);
      if (tryJoinResult.group == NO_GROUP) {
        client.groupChanged(changeIndex,tryJoinResult.groupIndex,ListEvent.INSERT,true,changeType,ListEvent.<E>unknownValue(),tryJoinResult.newFirstInGroup);
      }
 else {
        client.groupChanged(changeIndex,tryJoinResult.groupIndex,ListEvent.UPDATE,true,changeType,tryJoinResult.oldFirstInGroup,tryJoinResult.newFirstInGroup);
      }
    }
 else     if (changeType == ListEvent.UPDATE) {
      int oldGroup=0;
      if (toDoList.get(changeIndex) == TODO) {
        if (changeIndex + 1 < barcode.size()) {
          oldGroup=RIGHT_GROUP;
        }
 else {
          oldGroup=NO_GROUP;
        }
      }
 else       if (barcode.get(changeIndex) == DUPLICATE)       oldGroup=LEFT_GROUP;
 else       if (barcode.get(changeIndex) == UNIQUE)       oldGroup=NO_GROUP;
      tryJoinExistingGroup(changeIndex,toDoList,tryJoinResult);
      int successor=changeIndex + 1;
      if (tryJoinResult.group == LEFT_GROUP) {
        if (successor < barcode.size() && barcode.get(successor) == UNIQUE && toDoList.get(successor) == DONE && groupTogether(changeIndex,successor)) {
          barcode.set(successor,DUPLICATE,1);
          oldGroup=NO_GROUP;
        }
      }
 else       if (tryJoinResult.group == NO_GROUP) {
        if (successor < barcode.size() && barcode.get(successor) == DUPLICATE) {
          barcode.set(successor,UNIQUE,1);
          oldGroup=RIGHT_GROUP;
        }
      }
      int groupIndex=tryJoinResult.groupIndex;
      if (tryJoinResult.group == NO_GROUP) {
        if (oldGroup == NO_GROUP) {
          client.groupChanged(changeIndex,groupIndex,ListEvent.UPDATE,true,changeType,oldValue,tryJoinResult.newFirstInGroup);
        }
 else         if (oldGroup == LEFT_GROUP) {
          E firstFromPreviousGroup=sortedList.get(barcode.getIndex(groupIndex - 1,UNIQUE));
          client.groupChanged(changeIndex,groupIndex - 1,ListEvent.UPDATE,false,changeType,firstFromPreviousGroup,firstFromPreviousGroup);
          client.groupChanged(changeIndex,groupIndex,ListEvent.INSERT,true,changeType,ListEvent.<E>unknownValue(),tryJoinResult.newFirstInGroup);
        }
 else         if (oldGroup == RIGHT_GROUP) {
          E firstFromNextGroup=sortedList.get(barcode.getIndex(groupIndex + 1,UNIQUE));
          client.groupChanged(changeIndex,groupIndex,ListEvent.INSERT,true,changeType,ListEvent.<E>unknownValue(),tryJoinResult.newFirstInGroup);
          client.groupChanged(changeIndex,groupIndex + 1,ListEvent.UPDATE,false,changeType,oldValue,firstFromNextGroup);
        }
      }
 else       if (tryJoinResult.group == LEFT_GROUP) {
        if (oldGroup == NO_GROUP) {
          client.groupChanged(changeIndex,groupIndex,ListEvent.UPDATE,true,changeType,tryJoinResult.oldFirstInGroup,tryJoinResult.newFirstInGroup);
          client.groupChanged(changeIndex,groupIndex + 1,ListEvent.DELETE,false,changeType,oldValue,ListEvent.<E>unknownValue());
        }
 else         if (oldGroup == LEFT_GROUP) {
          client.groupChanged(changeIndex,groupIndex,ListEvent.UPDATE,true,changeType,tryJoinResult.oldFirstInGroup,tryJoinResult.newFirstInGroup);
        }
 else         if (oldGroup == RIGHT_GROUP) {
          client.groupChanged(changeIndex,groupIndex,ListEvent.UPDATE,true,changeType,tryJoinResult.oldFirstInGroup,tryJoinResult.newFirstInGroup);
          if (groupIndex + 1 < barcode.blackSize()) {
            E firstFromNextGroup=sortedList.get(barcode.getIndex(groupIndex + 1,UNIQUE));
            client.groupChanged(changeIndex,groupIndex + 1,ListEvent.UPDATE,false,changeType,oldValue,firstFromNextGroup);
          }
        }
      }
 else       if (tryJoinResult.group == RIGHT_GROUP) {
        if (oldGroup == NO_GROUP) {
          client.groupChanged(changeIndex,groupIndex,ListEvent.DELETE,false,changeType,oldValue,ListEvent.<E>unknownValue());
          client.groupChanged(changeIndex,groupIndex,ListEvent.UPDATE,true,changeType,tryJoinResult.oldFirstInGroup,tryJoinResult.newFirstInGroup);
        }
 else         if (oldGroup == LEFT_GROUP) {
          if (groupIndex - 1 >= 0) {
            E firstFromPreviousGroup=sortedList.get(barcode.getIndex(groupIndex - 1,UNIQUE));
            client.groupChanged(changeIndex,groupIndex - 1,ListEvent.UPDATE,false,changeType,firstFromPreviousGroup,firstFromPreviousGroup);
          }
          client.groupChanged(changeIndex,groupIndex,ListEvent.UPDATE,true,changeType,tryJoinResult.oldFirstInGroup,tryJoinResult.newFirstInGroup);
        }
 else         if (oldGroup == RIGHT_GROUP) {
          client.groupChanged(changeIndex,groupIndex,ListEvent.UPDATE,true,changeType,tryJoinResult.oldFirstInGroup,tryJoinResult.newFirstInGroup);
        }
      }
    }
 else     if (changeType == ListEvent.DELETE) {
      final Object deleted=removedValues.removeFirst();
      final int sourceDeletedIndex=deleted == DUPLICATE ? changeIndex - 1 : changeIndex;
      final int groupDeletedIndex=sourceDeletedIndex < barcode.size() ? barcode.getBlackIndex(sourceDeletedIndex,true) : barcode.blackSize();
      if (deleted == UNIQUE) {
        if (changeIndex == lastFakedUniqueChangeIndex) {
        }
 else {
          client.groupChanged(changeIndex,groupDeletedIndex,ListEvent.DELETE,true,changeType,oldValue,ListEvent.<E>unknownValue());
        }
      }
 else {
        E oldValueInGroup;
        E newValueInGroup;
        if (groupDeletedIndex < barcode.blackSize()) {
          int firstInGroupIndex=barcode.getIndex(groupDeletedIndex,UNIQUE);
          newValueInGroup=sortedList.get(firstInGroupIndex);
        }
 else {
          newValueInGroup=ListEvent.<E>unknownValue();
        }
        if (deleted == UNIQUE_WITH_DUPLICATE) {
          oldValueInGroup=oldValue;
        }
 else {
          oldValueInGroup=newValueInGroup;
        }
        client.groupChanged(changeIndex,groupDeletedIndex,ListEvent.UPDATE,true,changeType,oldValueInGroup,newValueInGroup);
      }
    }
  }
}","/** 
 * Handle changes from the   {@link SortedList} by modifying the grouping state.During this method, callbacks will be made to the  {@link Client} who isresponsible for firing the appropriate change events to its listeners.
 */
public void listChanged(ListEvent<E> listChanges){
  final Barcode toDoList=new Barcode();
  toDoList.addWhite(0,barcode.size());
  final LinkedList removedValues=new LinkedList();
  int lastFakedUniqueChangeIndex=-1;
  while (listChanges.next()) {
    final int changeIndex=listChanges.getIndex();
    final int changeType=listChanges.getType();
    if (changeType == ListEvent.INSERT) {
      barcode.add(changeIndex,UNIQUE,1);
      toDoList.add(changeIndex,TODO,1);
    }
 else     if (changeType == ListEvent.UPDATE) {
      if (barcode.get(changeIndex) == UNIQUE) {
        if (changeIndex + 1 < barcode.size() && barcode.get(changeIndex + 1) == DUPLICATE && (changeIndex == 0 || !uniqueElementAddedToLeftInSameGroup(toDoList,changeIndex))) {
          if (changeIndex != lastFakedUniqueChangeIndex) {
            barcode.set(changeIndex,UNIQUE,2);
            toDoList.set(changeIndex,TODO,1);
            lastFakedUniqueChangeIndex=changeIndex + 1;
          }
        }
      }
    }
 else     if (changeType == ListEvent.DELETE) {
      Object deleted=barcode.get(changeIndex);
      barcode.remove(changeIndex,1);
      toDoList.remove(changeIndex,1);
      if (deleted == UNIQUE) {
        if (changeIndex < barcode.size() && barcode.get(changeIndex) == DUPLICATE) {
          barcode.set(changeIndex,UNIQUE,1);
          deleted=UNIQUE_WITH_DUPLICATE;
        }
      }
      removedValues.addLast(deleted);
    }
  }
  TryJoinResult<E> tryJoinResult=new TryJoinResult<E>();
  listChanges.reset();
  while (listChanges.next()) {
    final int changeIndex=listChanges.getIndex();
    final int changeType=listChanges.getType();
    E newValue=listChanges.getNewValue();
    E oldValue=listChanges.getOldValue();
    if (changeType == ListEvent.INSERT) {
      tryJoinExistingGroup(changeIndex,toDoList,tryJoinResult);
      if (tryJoinResult.group == NO_GROUP) {
        client.groupChanged(changeIndex,tryJoinResult.groupIndex,ListEvent.INSERT,true,changeType,ListEvent.<E>unknownValue(),tryJoinResult.newFirstInGroup);
      }
 else {
        client.groupChanged(changeIndex,tryJoinResult.groupIndex,ListEvent.UPDATE,true,changeType,tryJoinResult.oldFirstInGroup,tryJoinResult.newFirstInGroup);
      }
    }
 else     if (changeType == ListEvent.UPDATE) {
      int oldGroup=0;
      if (toDoList.get(changeIndex) == TODO) {
        if (changeIndex + 1 < barcode.size()) {
          oldGroup=RIGHT_GROUP;
        }
 else {
          oldGroup=NO_GROUP;
        }
      }
 else       if (barcode.get(changeIndex) == DUPLICATE)       oldGroup=LEFT_GROUP;
 else       if (barcode.get(changeIndex) == UNIQUE)       oldGroup=NO_GROUP;
      tryJoinExistingGroup(changeIndex,toDoList,tryJoinResult);
      int successor=changeIndex + 1;
      if (tryJoinResult.group == LEFT_GROUP) {
        if (successor < barcode.size() && barcode.get(successor) == UNIQUE && toDoList.get(successor) == DONE && groupTogether(changeIndex,successor)) {
          barcode.set(successor,DUPLICATE,1);
          oldGroup=NO_GROUP;
        }
      }
 else       if (tryJoinResult.group == NO_GROUP) {
        if (successor < barcode.size() && barcode.get(successor) == DUPLICATE) {
          barcode.set(successor,UNIQUE,1);
          oldGroup=RIGHT_GROUP;
        }
      }
      int groupIndex=tryJoinResult.groupIndex;
      if (tryJoinResult.group == NO_GROUP) {
        if (oldGroup == NO_GROUP) {
          client.groupChanged(changeIndex,groupIndex,ListEvent.UPDATE,true,changeType,oldValue,tryJoinResult.newFirstInGroup);
        }
 else         if (oldGroup == LEFT_GROUP) {
          E firstFromPreviousGroup=sortedList.get(barcode.getIndex(groupIndex - 1,UNIQUE));
          client.groupChanged(changeIndex,groupIndex - 1,ListEvent.UPDATE,false,changeType,firstFromPreviousGroup,firstFromPreviousGroup);
          client.groupChanged(changeIndex,groupIndex,ListEvent.INSERT,true,changeType,ListEvent.<E>unknownValue(),tryJoinResult.newFirstInGroup);
        }
 else         if (oldGroup == RIGHT_GROUP) {
          E firstFromNextGroup=sortedList.get(barcode.getIndex(groupIndex + 1,UNIQUE));
          client.groupChanged(changeIndex,groupIndex,ListEvent.INSERT,true,changeType,ListEvent.<E>unknownValue(),tryJoinResult.newFirstInGroup);
          client.groupChanged(changeIndex,groupIndex + 1,ListEvent.UPDATE,false,changeType,oldValue,firstFromNextGroup);
        }
      }
 else       if (tryJoinResult.group == LEFT_GROUP) {
        if (oldGroup == NO_GROUP) {
          client.groupChanged(changeIndex,groupIndex,ListEvent.UPDATE,true,changeType,tryJoinResult.oldFirstInGroup,tryJoinResult.newFirstInGroup);
          client.groupChanged(changeIndex,groupIndex + 1,ListEvent.DELETE,false,changeType,oldValue,ListEvent.<E>unknownValue());
        }
 else         if (oldGroup == LEFT_GROUP) {
          client.groupChanged(changeIndex,groupIndex,ListEvent.UPDATE,true,changeType,tryJoinResult.oldFirstInGroup,tryJoinResult.newFirstInGroup);
        }
 else         if (oldGroup == RIGHT_GROUP) {
          client.groupChanged(changeIndex,groupIndex,ListEvent.UPDATE,true,changeType,tryJoinResult.oldFirstInGroup,tryJoinResult.newFirstInGroup);
          if (groupIndex + 1 < barcode.blackSize()) {
            E firstFromNextGroup=sortedList.get(barcode.getIndex(groupIndex + 1,UNIQUE));
            client.groupChanged(changeIndex,groupIndex + 1,ListEvent.UPDATE,false,changeType,oldValue,firstFromNextGroup);
          }
        }
      }
 else       if (tryJoinResult.group == RIGHT_GROUP) {
        if (oldGroup == NO_GROUP) {
          client.groupChanged(changeIndex,groupIndex,ListEvent.DELETE,false,changeType,oldValue,ListEvent.<E>unknownValue());
          client.groupChanged(changeIndex,groupIndex,ListEvent.UPDATE,true,changeType,tryJoinResult.oldFirstInGroup,tryJoinResult.newFirstInGroup);
        }
 else         if (oldGroup == LEFT_GROUP) {
          if (groupIndex - 1 >= 0) {
            E firstFromPreviousGroup=sortedList.get(barcode.getIndex(groupIndex - 1,UNIQUE));
            client.groupChanged(changeIndex,groupIndex - 1,ListEvent.UPDATE,false,changeType,firstFromPreviousGroup,firstFromPreviousGroup);
          }
          client.groupChanged(changeIndex,groupIndex,ListEvent.UPDATE,true,changeType,tryJoinResult.oldFirstInGroup,tryJoinResult.newFirstInGroup);
        }
 else         if (oldGroup == RIGHT_GROUP) {
          client.groupChanged(changeIndex,groupIndex,ListEvent.UPDATE,true,changeType,tryJoinResult.oldFirstInGroup,tryJoinResult.newFirstInGroup);
        }
      }
    }
 else     if (changeType == ListEvent.DELETE) {
      final Object deleted=removedValues.removeFirst();
      final int sourceDeletedIndex=deleted == DUPLICATE ? changeIndex - 1 : changeIndex;
      final int groupDeletedIndex=sourceDeletedIndex < barcode.size() ? barcode.getBlackIndex(sourceDeletedIndex,true) : barcode.blackSize();
      if (deleted == UNIQUE) {
        if (changeIndex == lastFakedUniqueChangeIndex) {
        }
 else {
          client.groupChanged(changeIndex,groupDeletedIndex,ListEvent.DELETE,true,changeType,oldValue,ListEvent.<E>unknownValue());
        }
      }
 else {
        E oldValueInGroup;
        E newValueInGroup;
        if (groupDeletedIndex < barcode.blackSize()) {
          int firstInGroupIndex=barcode.getIndex(groupDeletedIndex,UNIQUE);
          newValueInGroup=sortedList.get(firstInGroupIndex);
        }
 else {
          newValueInGroup=ListEvent.<E>unknownValue();
        }
        if (deleted == UNIQUE_WITH_DUPLICATE) {
          oldValueInGroup=oldValue;
        }
 else {
          oldValueInGroup=newValueInGroup;
        }
        client.groupChanged(changeIndex,groupDeletedIndex,ListEvent.UPDATE,true,changeType,oldValueInGroup,newValueInGroup);
      }
    }
  }
}",0.9947103274559194
32428,"/** 
 * Set the   {@link Comparator} used to determine how elements are splitinto groups. <p>Performance Note: sorting will take <code>O(N * Log N)</code> time. <p><strong><font color=""#FF0000"">Warning:</font></strong> This method is thread ready but not thread safe. See  {@link EventList} for an exampleof thread safe code.
 */
public void setComparator(Comparator<E> comparator){
  final boolean isEmpty=isEmpty();
  if (!isEmpty) {
    updates.beginEvent();
    updates.addDelete(0,size() - 1);
  }
  SortedList<E> sortedList=(SortedList<E>)separatorSource.source;
  sortedList.setComparator(comparator);
  if (!isEmpty) {
    rebuildCollapsedElements();
    updates.addInsert(0,size() - 1);
    updates.commitEvent();
  }
}","/** 
 * Set the   {@link Comparator} used to determine how elements are splitinto groups. <p>Performance Note: sorting will take <code>O(N * Log N)</code> time. <p><strong><font color=""#FF0000"">Warning:</font></strong> This method is thread ready but not thread safe. See  {@link EventList} for an exampleof thread safe code.
 */
public void setComparator(Comparator<E> comparator){
  final boolean isEmpty=isEmpty();
  if (!isEmpty) {
    updates.beginEvent();
    updates.addDelete(0,size() - 1);
  }
  SortedList<E> sortedList=(SortedList<E>)separatorSource.source;
  sortedList.setComparator(comparator);
  if (!isEmpty) {
    rebuildCollapsedElements();
    updates.addInsert(0,size() - 1);
    updates.commitEvent();
  }
 else {
    separatorSource.grouper.setComparator(comparator);
  }
}",0.9560078791858174
32429,"/** 
 * Set the match mode for this   {@link CompositeMatcherEditor}.
 * @param mode either <code>CompositeMatcherEditor.AND</code> to match all<code>CompositeMatcherEditor.OR</code> to match any.
 */
public void setMode(int mode){
  if (this.mode == mode)   return;
  int oldMode=this.mode;
  this.mode=mode;
  if (matcherEditors.isEmpty()) {
    return;
  }
 else   if (oldMode == AND && mode == OR) {
    fireRelaxed(rebuildMatcher());
  }
 else   if (oldMode == OR && mode == AND) {
    fireConstrained(rebuildMatcher());
  }
 else {
    throw new IllegalArgumentException();
  }
}","/** 
 * Set the match mode for this   {@link CompositeMatcherEditor}.
 * @param mode either <code>CompositeMatcherEditor.AND</code> to match all<code>CompositeMatcherEditor.OR</code> to match any.
 */
public void setMode(int mode){
  if (this.mode == mode)   return;
  int oldMode=this.mode;
  this.mode=mode;
  if (oldMode == AND && mode == OR) {
    if (matcherEditors.isEmpty()) {
      fireMatchNone();
    }
 else     if (matcherEditors.size() > 1) {
      fireRelaxed(rebuildMatcher());
    }
  }
 else   if (oldMode == OR && mode == AND) {
    if (matcherEditors.isEmpty()) {
      fireMatchAll();
    }
 else     if (matcherEditors.size() > 1) {
      fireConstrained(rebuildMatcher());
    }
  }
 else {
    throw new IllegalArgumentException();
  }
}",0.7866171003717473
32430,"/** 
 * Test that the   {@link CompositeMatcherEditor} matches only if eithermatchers match in OR mode.
 */
@Test public void testCompositeMatcherEditorMatchesOr(){
  compositeMatcherEditor.setMode(CompositeMatcherEditor.OR);
  assertEquals(true,compositeMatcherEditor.getMatcher().matches(null));
  assertEquals(true,compositeMatcherEditor.getMatcher().matches(""String_Node_Str""));
  assertEquals(true,compositeMatcherEditor.getMatcher().matches(""String_Node_Str""));
  compositeMatcherEditor.getMatcherEditors().add(textMatcherEditor);
  assertEquals(true,compositeMatcherEditor.getMatcher().matches(""String_Node_Str""));
  assertEquals(true,compositeMatcherEditor.getMatcher().matches(""String_Node_Str""));
  textMatcherEditor.setFilterText(new String[]{""String_Node_Str"",""String_Node_Str""});
  assertEquals(true,compositeMatcherEditor.getMatcher().matches(""String_Node_Str""));
  assertEquals(false,compositeMatcherEditor.getMatcher().matches(""String_Node_Str""));
  compositeMatcherEditor.getMatcherEditors().add(anotherTextMatcherEditor);
  assertEquals(true,compositeMatcherEditor.getMatcher().matches(""String_Node_Str""));
  assertEquals(true,compositeMatcherEditor.getMatcher().matches(""String_Node_Str""));
  anotherTextMatcherEditor.setFilterText(new String[]{""String_Node_Str""});
  assertEquals(true,compositeMatcherEditor.getMatcher().matches(""String_Node_Str""));
  assertEquals(true,compositeMatcherEditor.getMatcher().matches(""String_Node_Str""));
  assertEquals(false,compositeMatcherEditor.getMatcher().matches(""String_Node_Str""));
  compositeMatcherEditor.getMatcherEditors().remove(0);
  assertEquals(true,compositeMatcherEditor.getMatcher().matches(""String_Node_Str""));
  assertEquals(false,compositeMatcherEditor.getMatcher().matches(""String_Node_Str""));
  anotherTextMatcherEditor.setFilterText(new String[]{""String_Node_Str""});
  assertEquals(true,compositeMatcherEditor.getMatcher().matches(""String_Node_Str""));
  assertEquals(false,compositeMatcherEditor.getMatcher().matches(""String_Node_Str""));
  compositeMatcherEditor.getMatcherEditors().remove(0);
  assertEquals(true,compositeMatcherEditor.getMatcher().matches(""String_Node_Str""));
  assertEquals(true,compositeMatcherEditor.getMatcher().matches(""String_Node_Str""));
}","/** 
 * Test that the   {@link CompositeMatcherEditor} matches only if eithermatcher matches in OR mode.
 */
@Test public void testCompositeMatcherEditorMatchesOr(){
  compositeMatcherEditor.setMode(CompositeMatcherEditor.OR);
  assertEquals(false,compositeMatcherEditor.getMatcher().matches(null));
  assertEquals(false,compositeMatcherEditor.getMatcher().matches(""String_Node_Str""));
  assertEquals(false,compositeMatcherEditor.getMatcher().matches(""String_Node_Str""));
  compositeMatcherEditor.getMatcherEditors().add(textMatcherEditor);
  assertEquals(true,compositeMatcherEditor.getMatcher().matches(""String_Node_Str""));
  assertEquals(true,compositeMatcherEditor.getMatcher().matches(""String_Node_Str""));
  textMatcherEditor.setFilterText(new String[]{""String_Node_Str"",""String_Node_Str""});
  assertEquals(true,compositeMatcherEditor.getMatcher().matches(""String_Node_Str""));
  assertEquals(false,compositeMatcherEditor.getMatcher().matches(""String_Node_Str""));
  compositeMatcherEditor.getMatcherEditors().add(anotherTextMatcherEditor);
  assertEquals(true,compositeMatcherEditor.getMatcher().matches(""String_Node_Str""));
  assertEquals(true,compositeMatcherEditor.getMatcher().matches(""String_Node_Str""));
  anotherTextMatcherEditor.setFilterText(new String[]{""String_Node_Str""});
  assertEquals(true,compositeMatcherEditor.getMatcher().matches(""String_Node_Str""));
  assertEquals(true,compositeMatcherEditor.getMatcher().matches(""String_Node_Str""));
  assertEquals(false,compositeMatcherEditor.getMatcher().matches(""String_Node_Str""));
  compositeMatcherEditor.getMatcherEditors().remove(0);
  assertEquals(true,compositeMatcherEditor.getMatcher().matches(""String_Node_Str""));
  assertEquals(false,compositeMatcherEditor.getMatcher().matches(""String_Node_Str""));
  anotherTextMatcherEditor.setFilterText(new String[]{""String_Node_Str""});
  assertEquals(true,compositeMatcherEditor.getMatcher().matches(""String_Node_Str""));
  assertEquals(false,compositeMatcherEditor.getMatcher().matches(""String_Node_Str""));
  compositeMatcherEditor.getMatcherEditors().remove(0);
  assertEquals(true,compositeMatcherEditor.getMatcher().matches(""String_Node_Str""));
  assertEquals(true,compositeMatcherEditor.getMatcher().matches(""String_Node_Str""));
}",0.9919750334373608
32431,"/** 
 * Test that the   {@link CompositeMatcherEditor} fires the right events in OR mode.
 */
@Test public void testCompositeMatcherEditorOrEvents(){
  SimpleMatcherEditorListener listener=new SimpleMatcherEditorListener();
  compositeMatcherEditor.addMatcherEditorListener(listener);
  compositeMatcherEditor.setMode(CompositeMatcherEditor.OR);
  listener.assertNoEvents(0);
  compositeMatcherEditor.getMatcherEditors().add(textMatcherEditor);
  textMatcherEditor.setFilterText(new String[]{""String_Node_Str""});
  textMatcherEditor.setFilterText(new String[]{""String_Node_Str""});
  textMatcherEditor.setFilterText(new String[]{""String_Node_Str""});
  listener.assertConstrained(4);
  textMatcherEditor.setFilterText(new String[]{""String_Node_Str""});
  textMatcherEditor.setFilterText(new String[]{""String_Node_Str""});
  listener.assertRelaxed(6);
  compositeMatcherEditor.getMatcherEditors().add(anotherTextMatcherEditor);
  listener.assertRelaxed(7);
  anotherTextMatcherEditor.setFilterText(new String[]{""String_Node_Str""});
  listener.assertConstrained(8);
  anotherTextMatcherEditor.setFilterText(new String[]{""String_Node_Str"",""String_Node_Str""});
  anotherTextMatcherEditor.setFilterText(new String[]{""String_Node_Str""});
  listener.assertRelaxed(10);
  anotherTextMatcherEditor.setFilterText(new String[0]);
  listener.assertRelaxed(11);
  compositeMatcherEditor.getMatcherEditors().remove(1);
  listener.assertConstrained(12);
  compositeMatcherEditor.getMatcherEditors().remove(0);
  listener.assertMatchAll(13);
}","/** 
 * Test that the   {@link CompositeMatcherEditor} fires the right events in OR mode.
 */
@Test public void testCompositeMatcherEditorOrEvents(){
  SimpleMatcherEditorListener listener=new SimpleMatcherEditorListener();
  compositeMatcherEditor.addMatcherEditorListener(listener);
  compositeMatcherEditor.setMode(CompositeMatcherEditor.OR);
  listener.assertMatchNone(1);
  compositeMatcherEditor.getMatcherEditors().add(textMatcherEditor);
  textMatcherEditor.setFilterText(new String[]{""String_Node_Str""});
  textMatcherEditor.setFilterText(new String[]{""String_Node_Str""});
  textMatcherEditor.setFilterText(new String[]{""String_Node_Str""});
  listener.assertConstrained(5);
  textMatcherEditor.setFilterText(new String[]{""String_Node_Str""});
  textMatcherEditor.setFilterText(new String[]{""String_Node_Str""});
  listener.assertRelaxed(7);
  compositeMatcherEditor.getMatcherEditors().add(anotherTextMatcherEditor);
  listener.assertRelaxed(8);
  anotherTextMatcherEditor.setFilterText(new String[]{""String_Node_Str""});
  listener.assertConstrained(9);
  anotherTextMatcherEditor.setFilterText(new String[]{""String_Node_Str"",""String_Node_Str""});
  anotherTextMatcherEditor.setFilterText(new String[]{""String_Node_Str""});
  listener.assertRelaxed(11);
  anotherTextMatcherEditor.setFilterText(new String[0]);
  listener.assertRelaxed(12);
  compositeMatcherEditor.getMatcherEditors().remove(1);
  listener.assertConstrained(13);
  compositeMatcherEditor.getMatcherEditors().remove(0);
  listener.assertMatchAll(14);
}",0.9891696750902528
32432,"/** 
 * Get the publisher used to distribute   {@link ListEvent}s.
 */
public ListEventPublisher getPublisher();","/** 
 * Get the publisher used to distribute   {@link ListEvent}s. It's always defined.
 */
public ListEventPublisher getPublisher();",0.9142857142857144
32433,"/** 
 * Removes the specified listener from receiving change updates for this list.
 */
public void removeListEventListener(ListEventListener<? super E> listChangeListener);","/** 
 * Removes the specified listener from receiving change updates for this list.
 * @param listChangeListener event listener != null
 * @throws NullPointerException if the specified listener is null
 * @throws IllegalArgumentException if the specified listener wasn't added before
 */
public void removeListEventListener(ListEventListener<? super E> listChangeListener);",0.6336996336996337
32434,"/** 
 * Registers the specified listener to receive change updates for this list.
 */
public void addListEventListener(ListEventListener<? super E> listChangeListener);","/** 
 * Registers the specified listener to receive change updates for this list.
 * @param listChangeListener event listener != null
 * @throws NullPointerException if the specified listener is null
 */
public void addListEventListener(ListEventListener<? super E> listChangeListener);",0.7400881057268722
32435,"/** 
 * Gets the lock required to share this list between multiple threads.
 * @return a re-entrant {@link ReadWriteLock} that guarantees thread safeaccess to this list.
 */
public ReadWriteLock getReadWriteLock();","/** 
 * Gets the lock required to share this list between multiple threads. It's always defined.
 * @return a re-entrant {@link ReadWriteLock} that guarantees thread safeaccess to this list.
 */
public ReadWriteLock getReadWriteLock();",0.9532293986636972
32436,"/** 
 * Registers the specified listener to be notified whenever new changes are appended to this list change sequence. <p>For each listener, a ListEvent is created, which provides a read-only view to the list changes in the list. The same ListChangeView object is used for all notifications to the specified listener, so if a listener does not process a set of changes, those changes will persist in the next notification.
 */
public synchronized void addListEventListener(ListEventListener<? super E> listChangeListener){
  publisher.addListener(sourceList,listChangeListener,eventFormat);
}","/** 
 * Registers the specified listener to be notified whenever new changes are appended to this list change sequence. <p>For each listener, a ListEvent is created, which provides a read-only view to the list changes in the list. The same ListChangeView object is used for all notifications to the specified listener, so if a listener does not process a set of changes, those changes will persist in the next notification.
 * @param listChangeListener event listener != null
 * @throws NullPointerException if the specified listener is null
 */
public synchronized void addListEventListener(ListEventListener<? super E> listChangeListener){
  Preconditions.checkNotNull(listChangeListener,""String_Node_Str"");
  publisher.addListener(sourceList,listChangeListener,eventFormat);
}",0.8644314868804664
32437,"/** 
 * Removes the specified listener from receiving notification when new changes are appended to this list change sequence. <p>This uses the <code>==</code> identity comparison to find the listener instead of <code>equals()</code>. This is because multiple Lists may be listening and therefore <code>equals()</code> may be ambiguous.
 */
public synchronized void removeListEventListener(ListEventListener<? super E> listChangeListener){
  publisher.removeListener(sourceList,listChangeListener);
}","/** 
 * Removes the specified listener from receiving notification when new changes are appended to this list change sequence. <p>This uses the <code>==</code> identity comparison to find the listener instead of <code>equals()</code>. This is because multiple Lists may be listening and therefore <code>equals()</code> may be ambiguous.
 * @param listChangeListener event listener != null
 * @throws NullPointerException if the specified listener is null
 * @throws IllegalArgumentException if the specified listener wasn't added before
 */
public synchronized void removeListEventListener(ListEventListener<? super E> listChangeListener){
  Preconditions.checkNotNull(listChangeListener,""String_Node_Str"");
  publisher.removeListener(sourceList,listChangeListener);
}",0.7082018927444795
32438,"/** 
 * Wraps the source in an   {@link EventList} that does not allow writing operations.<p>The returned  {@link EventList} is useful for programming defensively. A{@link EventList} is useful to supply an unknown class read-only accessto your  {@link EventList}. <p>The returned   {@link EventList} will provides an up-to-date view of its source{@link EventList} so changes to the source {@link EventList} will still bereflected. For a static copy of any  {@link EventList} it is necessary to copythe contents of that  {@link EventList} into an {@link ArrayList}. <p><strong><font color=""#FF0000"">Warning:</font></strong> This returned EventList is thread ready but not thread safe. See   {@link EventList} for an exampleof thread safe code.
 */
public static <E>TransformedList<E,E> readOnlyList(EventList<E> source){
  return new ReadOnlyList<E>(source);
}","/** 
 * Wraps the source in an   {@link EventList} that does not allow writing operations.<p>The returned  {@link EventList} is useful for programming defensively. A{@link EventList} is useful to supply an unknown class read-only accessto your  {@link EventList}. <p>The returned   {@link EventList} will provides an up-to-date view of its source{@link EventList} so changes to the source {@link EventList} will still bereflected. For a static copy of any  {@link EventList} it is necessary to copythe contents of that  {@link EventList} into an {@link ArrayList}. <p><strong><font color=""#FF0000"">Warning:</font></strong> This returned EventList is thread ready but not thread safe. See   {@link EventList} for an exampleof thread safe code.
 */
public static <E>TransformedList<E,E> readOnlyList(EventList<? extends E> source){
  return new ReadOnlyList<E>((EventList<E>)source);
}",0.9862227324913893
32439,"/** 
 * Wraps the source in an   {@link EventList} that obtains a{@link ca.odell.glazedlists.util.concurrent.ReadWriteLock ReadWritLock} for alloperations. <p>This provides some support for sharing  {@link EventList}s between multiple threads. <p>Using a   {@link ThreadSafeList} for concurrent access to lists can be expensivebecause a  {@link ca.odell.glazedlists.util.concurrent.ReadWriteLock ReadWriteLock}is aquired and released for every operation. <p><strong><font color=""#FF0000"">Warning:</font></strong> Although this class provides thread safe access, it does not provide any guarantees that changes will not happen between method calls. For example, the following code is unsafe because the source   {@link EventList} may change between calls to{@link TransformedList#size() size()} and {@link TransformedList#get(int) get()}: <pre> EventList source = ... ThreadSafeList myList = new ThreadSafeList(source); if(myList.size() > 3) { System.out.println(myList.get(3)); }</pre> <p><strong><font color=""#FF0000"">Warning:</font></strong> The objects returned by   {@link TransformedList#iterator() iterator()},  {@link TransformedList#subList(int,int) subList()}, etc. are not thread safe.
 * @see ca.odell.glazedlists.util.concurrent
 */
public static <E>TransformedList<E,E> threadSafeList(EventList<E> source){
  return new ThreadSafeList<E>(source);
}","/** 
 * Wraps the source in an   {@link EventList} that obtains a{@link ca.odell.glazedlists.util.concurrent.ReadWriteLock ReadWritLock} for alloperations. <p>This provides some support for sharing  {@link EventList}s between multiple threads. <p>Using a   {@link ThreadSafeList} for concurrent access to lists can be expensivebecause a  {@link ca.odell.glazedlists.util.concurrent.ReadWriteLock ReadWriteLock}is aquired and released for every operation. <p><strong><font color=""#FF0000"">Warning:</font></strong> Although this class provides thread safe access, it does not provide any guarantees that changes will not happen between method calls. For example, the following code is unsafe because the source   {@link EventList} may change between calls to{@link TransformedList#size() size()} and {@link TransformedList#get(int) get()}: <pre> EventList source = ... ThreadSafeList myList = new ThreadSafeList(source); if(myList.size() > 3) { System.out.println(myList.get(3)); }</pre> <p><strong><font color=""#FF0000"">Warning:</font></strong> The objects returned by   {@link TransformedList#iterator() iterator()},  {@link TransformedList#subList(int,int) subList()}, etc. are not thread safe.
 * @see ca.odell.glazedlists.util.concurrent
 */
public static <E>TransformedList<E,E> threadSafeList(EventList<? extends E> source){
  return new ThreadSafeList<E>((EventList<E>)source);
}",0.9912600145666424
32440,"/** 
 * Test for <a href=""https://glazedlists.dev.java.net/issues/show_bug.cgi?id=489"">bug 489</a> 
 */
public void testDeletionIssues_FixMe(){
  EventList<String> source=new BasicEventList<String>();
  TreeList<String> treeList=new TreeList<String>(source,COMPRESSED_CHARACTER_TREE_FORMAT,TreeList.NODES_START_EXPANDED);
  ListConsistencyListener<String> listConsistencyListener=ListConsistencyListener.install(treeList);
  listConsistencyListener.setPreviousElementTracked(false);
  source.add(""String_Node_Str"");
  source.add(""String_Node_Str"");
  assertTreeStructure(treeList,new String[]{""String_Node_Str"",""String_Node_Str""});
  source.add(0,""String_Node_Str"");
  assertTreeStructure(treeList,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  source.remove(0);
  assertTreeStructure(treeList,new String[]{""String_Node_Str"",""String_Node_Str""});
  source.set(1,""String_Node_Str"");
  assertTreeStructure(treeList,new String[]{""String_Node_Str"",""String_Node_Str""});
}","/** 
 * Test for <a href=""https://glazedlists.dev.java.net/issues/show_bug.cgi?id=489"">bug 489</a> 
 */
public void testDeletionIssues_FixMe(){
  EventList<String> source=new BasicEventList<String>();
  TreeList<String> treeList=new TreeList<String>(source,COMPRESSED_CHARACTER_TREE_FORMAT,TreeList.NODES_START_EXPANDED);
  ListConsistencyListener<String> listConsistencyListener=ListConsistencyListener.install(treeList);
  listConsistencyListener.setPreviousElementTracked(false);
  source.add(""String_Node_Str"");
  source.add(""String_Node_Str"");
  assertTreeStructure(treeList,new String[]{""String_Node_Str"",""String_Node_Str""});
  source.add(0,""String_Node_Str"");
  assertTreeStructure(treeList,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  source.remove(1);
  assertTreeStructure(treeList,new String[]{""String_Node_Str"",""String_Node_Str""});
  source.set(1,""String_Node_Str"");
  assertTreeStructure(treeList,new String[]{""String_Node_Str"",""String_Node_Str""});
}",0.998989898989899
32441,"/** 
 * {@inheritDoc} 
 */
@Override public Rectangle getCellRect(int row,int column,boolean includeSpacing){
  final AdvancedTableModel eventTableModel=getEventTableModel();
  if (row >= eventTableModel.getRowCount()) {
    return new Rectangle();
  }
  Object rowValue=eventTableModel.getElementAt(row);
  if (rowValue instanceof SeparatorList.Separator) {
    Rectangle firstColumn=super.getCellRect(row,0,includeSpacing);
    Rectangle lastColumn=super.getCellRect(row,getColumnCount() - 1,includeSpacing);
    return firstColumn.union(lastColumn);
  }
 else {
    return super.getCellRect(row,column,includeSpacing);
  }
}","/** 
 * {@inheritDoc} 
 */
@Override public Rectangle getCellRect(int row,int column,boolean includeSpacing){
  final AdvancedTableModel eventTableModel=getEventTableModel();
  if (row >= eventTableModel.getRowCount()) {
    return new Rectangle();
  }
  if (row >= 0) {
    final Object rowValue=eventTableModel.getElementAt(row);
    if (rowValue instanceof SeparatorList.Separator) {
      final Rectangle firstColumn=super.getCellRect(row,0,includeSpacing);
      final Rectangle lastColumn=super.getCellRect(row,getColumnCount() - 1,includeSpacing);
      return firstColumn.union(lastColumn);
    }
  }
  return super.getCellRect(row,column,includeSpacing);
}",0.9504643962848296
32442,"/** 
 * {@inheritDoc} 
 */
@Override public int indexOf(Object object){
  if (mode != STRICT_SORT_ORDER || comparator == null)   return source.indexOf(object);
  int index=((SimpleTree)sorted).indexOfValue(object,true,false,ALL_COLORS);
  if (index == -1)   return -1;
  for (; index < size(); index++) {
    E objectAtIndex=get(index);
    if (comparator.compare((E)object,objectAtIndex) != 0)     return -1;
    if (GlazedListsImpl.equal(object,objectAtIndex))     return index;
  }
  return -1;
}","/** 
 * {@inheritDoc} 
 */
@Override public int indexOf(Object object){
  if (mode != STRICT_SORT_ORDER || comparator == null)   return super.indexOf(object);
  int index=((SimpleTree)sorted).indexOfValue(object,true,false,ALL_COLORS);
  if (index == -1)   return -1;
  for (; index < size(); index++) {
    E objectAtIndex=get(index);
    if (comparator.compare((E)object,objectAtIndex) != 0)     return -1;
    if (GlazedListsImpl.equal(object,objectAtIndex))     return index;
  }
  return -1;
}",0.9909729187562688
32443,"public void testRemovedValueInListEvent(){
  EventList<String> original=new BasicEventList<String>();
  original.addAll(GlazedListsTests.stringToList(""String_Node_Str""));
  SortedList<String> sorted=SortedList.create(original);
  ListConsistencyListener<String> listConsistencyListener=ListConsistencyListener.install(sorted);
  listConsistencyListener.setPreviousElementTracked(true);
  original.removeAll(GlazedListsTests.stringToList(""String_Node_Str""));
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sorted);
  original.set(1,""String_Node_Str"");
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),original);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sorted);
  original.set(2,""String_Node_Str"");
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),original);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sorted);
  sorted.setMode(SortedList.AVOID_MOVING_ELEMENTS);
  original.set(1,""String_Node_Str"");
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),original);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sorted);
}","public void testRemovedValueInListEvent(){
  EventList<String> original=new BasicEventList<String>();
  original.addAll(GlazedListsTests.stringToList(""String_Node_Str""));
  SortedList<String> sorted=SortedList.create(original);
  ListConsistencyListener<String> listConsistencyListener=ListConsistencyListener.install(sorted);
  listConsistencyListener.setPreviousElementTracked(true);
  original.removeAll(GlazedListsTests.stringToList(""String_Node_Str""));
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),original);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sorted);
  assertEquals(1,original.indexOf(""String_Node_Str""));
  assertEquals(3,sorted.indexOf(""String_Node_Str""));
  original.set(1,""String_Node_Str"");
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),original);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sorted);
  assertEquals(1,original.indexOf(""String_Node_Str""));
  assertEquals(3,sorted.indexOf(""String_Node_Str""));
  assertEquals(-1,original.indexOf(""String_Node_Str""));
  assertEquals(-1,sorted.indexOf(""String_Node_Str""));
  original.set(2,""String_Node_Str"");
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),original);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sorted);
  assertEquals(2,original.indexOf(""String_Node_Str""));
  assertEquals(3,sorted.indexOf(""String_Node_Str""));
  sorted.setMode(SortedList.AVOID_MOVING_ELEMENTS);
  original.set(1,""String_Node_Str"");
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),original);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sorted);
  assertEquals(1,original.indexOf(""String_Node_Str""));
  assertEquals(0,sorted.indexOf(""String_Node_Str""));
  assertEquals(1,sorted.indexOf(""String_Node_Str""));
  assertEquals(2,sorted.indexOf(""String_Node_Str""));
}",0.7437520826391203
32444,"/** 
 * Tests that elements are properly moved when value changes require that if sort order is not enforced on the list.
 */
public void testSimpleMovesSortNotEnforced(){
  unsortedList=new BasicEventList<Comparable>();
  sortedList=SortedList.create(unsortedList);
  sortedList.setMode(SortedList.AVOID_MOVING_ELEMENTS);
  ListConsistencyListener.install(sortedList);
  unsortedList.addAll(GlazedListsTests.stringToList(""String_Node_Str""));
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  unsortedList.set(3,""String_Node_Str"");
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  unsortedList.addAll(3,GlazedListsTests.stringToList(""String_Node_Str""));
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  unsortedList.removeAll(GlazedListsTests.stringToList(""String_Node_Str""));
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  unsortedList.addAll(8,GlazedListsTests.stringToList(""String_Node_Str""));
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  unsortedList.set(0,""String_Node_Str"");
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  unsortedList.set(7,""String_Node_Str"");
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  unsortedList.addAll(0,GlazedListsTests.stringToList(""String_Node_Str""));
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  unsortedList.addAll(5,GlazedListsTests.stringToList(""String_Node_Str""));
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  sortedList.set(1,""String_Node_Str"");
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  sortedList.clear();
  assertEquals(Collections.EMPTY_LIST,unsortedList);
  assertEquals(Collections.EMPTY_LIST,sortedList);
  sortedList.addAll(GlazedListsTests.stringToList(""String_Node_Str""));
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  sortedList.set(0,""String_Node_Str"");
  sortedList.set(2,""String_Node_Str"");
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  sortedList.add(""String_Node_Str"");
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  sortedList.add(""String_Node_Str"");
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
}","/** 
 * Tests that elements are properly moved when value changes require that if sort order is not enforced on the list.
 */
public void testSimpleMovesSortNotEnforced(){
  unsortedList=new BasicEventList<Comparable>();
  sortedList=SortedList.create(unsortedList);
  sortedList.setMode(SortedList.AVOID_MOVING_ELEMENTS);
  ListConsistencyListener.install(sortedList);
  unsortedList.addAll(GlazedListsTests.stringToList(""String_Node_Str""));
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  unsortedList.set(3,""String_Node_Str"");
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  assertEquals(3,unsortedList.indexOf(""String_Node_Str""));
  assertEquals(3,sortedList.indexOf(""String_Node_Str""));
  unsortedList.addAll(3,GlazedListsTests.stringToList(""String_Node_Str""));
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  assertEquals(10,unsortedList.indexOf(""String_Node_Str""));
  assertEquals(3,sortedList.indexOf(""String_Node_Str""));
  unsortedList.removeAll(GlazedListsTests.stringToList(""String_Node_Str""));
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  assertEquals(7,unsortedList.indexOf(""String_Node_Str""));
  assertEquals(2,sortedList.indexOf(""String_Node_Str""));
  unsortedList.addAll(8,GlazedListsTests.stringToList(""String_Node_Str""));
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  assertEquals(7,unsortedList.indexOf(""String_Node_Str""));
  assertEquals(4,sortedList.indexOf(""String_Node_Str""));
  unsortedList.set(0,""String_Node_Str"");
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  assertEquals(7,unsortedList.indexOf(""String_Node_Str""));
  assertEquals(4,sortedList.indexOf(""String_Node_Str""));
  assertEquals(0,unsortedList.indexOf(""String_Node_Str""));
  assertEquals(1,sortedList.indexOf(""String_Node_Str""));
  unsortedList.set(7,""String_Node_Str"");
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  assertEquals(-1,unsortedList.indexOf(""String_Node_Str""));
  assertEquals(-1,sortedList.indexOf(""String_Node_Str""));
  assertEquals(7,unsortedList.indexOf(""String_Node_Str""));
  assertEquals(4,sortedList.indexOf(""String_Node_Str""));
  unsortedList.addAll(0,GlazedListsTests.stringToList(""String_Node_Str""));
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  unsortedList.addAll(5,GlazedListsTests.stringToList(""String_Node_Str""));
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  sortedList.set(1,""String_Node_Str"");
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  assertEquals(4,unsortedList.indexOf(""String_Node_Str""));
  assertEquals(1,sortedList.indexOf(""String_Node_Str""));
  sortedList.clear();
  assertEquals(Collections.EMPTY_LIST,unsortedList);
  assertEquals(Collections.EMPTY_LIST,sortedList);
  sortedList.addAll(GlazedListsTests.stringToList(""String_Node_Str""));
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  sortedList.set(0,""String_Node_Str"");
  sortedList.set(2,""String_Node_Str"");
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  sortedList.add(""String_Node_Str"");
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  assertEquals(2,unsortedList.indexOf(""String_Node_Str""));
  assertEquals(0,unsortedList.indexOf(""String_Node_Str""));
  assertEquals(0,sortedList.indexOf(""String_Node_Str""));
  assertEquals(1,sortedList.indexOf(""String_Node_Str""));
  sortedList.add(""String_Node_Str"");
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
}",0.7849906191369606
32445,"public void testChangingSortMode(){
  SortedList<String> names=SortedList.create(new BasicEventList<String>());
  names.setMode(SortedList.AVOID_MOVING_ELEMENTS);
  names.add(""String_Node_Str"");
  names.add(""String_Node_Str"");
  names.add(""String_Node_Str"");
  names.add(""String_Node_Str"");
  names.set(0,""String_Node_Str"");
  names.set(1,""String_Node_Str"");
  names.set(2,""String_Node_Str"");
  names.set(3,""String_Node_Str"");
  assertEquals(""String_Node_Str"",names.get(0));
  assertEquals(""String_Node_Str"",names.get(1));
  assertEquals(""String_Node_Str"",names.get(2));
  assertEquals(""String_Node_Str"",names.get(3));
  names.setMode(SortedList.STRICT_SORT_ORDER);
  assertEquals(""String_Node_Str"",names.get(0));
  assertEquals(""String_Node_Str"",names.get(1));
  assertEquals(""String_Node_Str"",names.get(2));
  assertEquals(""String_Node_Str"",names.get(3));
  names.setMode(SortedList.AVOID_MOVING_ELEMENTS);
  names.add(""String_Node_Str"");
  assertEquals(""String_Node_Str"",names.get(0));
  assertEquals(""String_Node_Str"",names.get(1));
  assertEquals(""String_Node_Str"",names.get(2));
  assertEquals(""String_Node_Str"",names.get(3));
  assertEquals(""String_Node_Str"",names.get(4));
  names.set(1,""String_Node_Str"");
  assertEquals(""String_Node_Str"",names.get(0));
  assertEquals(""String_Node_Str"",names.get(1));
  assertEquals(""String_Node_Str"",names.get(2));
  assertEquals(""String_Node_Str"",names.get(3));
  assertEquals(""String_Node_Str"",names.get(4));
}","public void testChangingSortMode(){
  SortedList<String> names=SortedList.create(new BasicEventList<String>());
  names.setMode(SortedList.AVOID_MOVING_ELEMENTS);
  names.add(""String_Node_Str"");
  names.add(""String_Node_Str"");
  names.add(""String_Node_Str"");
  names.add(""String_Node_Str"");
  names.set(0,""String_Node_Str"");
  names.set(1,""String_Node_Str"");
  names.set(2,""String_Node_Str"");
  names.set(3,""String_Node_Str"");
  assertEquals(""String_Node_Str"",names.get(0));
  assertEquals(""String_Node_Str"",names.get(1));
  assertEquals(""String_Node_Str"",names.get(2));
  assertEquals(""String_Node_Str"",names.get(3));
  assertEquals(0,names.indexOf(""String_Node_Str""));
  assertEquals(1,names.indexOf(""String_Node_Str""));
  assertEquals(2,names.indexOf(""String_Node_Str""));
  assertEquals(3,names.indexOf(""String_Node_Str""));
  names.setMode(SortedList.STRICT_SORT_ORDER);
  assertEquals(""String_Node_Str"",names.get(0));
  assertEquals(""String_Node_Str"",names.get(1));
  assertEquals(""String_Node_Str"",names.get(2));
  assertEquals(""String_Node_Str"",names.get(3));
  assertEquals(0,names.indexOf(""String_Node_Str""));
  assertEquals(1,names.indexOf(""String_Node_Str""));
  assertEquals(2,names.indexOf(""String_Node_Str""));
  assertEquals(3,names.indexOf(""String_Node_Str""));
  names.setMode(SortedList.AVOID_MOVING_ELEMENTS);
  names.add(""String_Node_Str"");
  assertEquals(""String_Node_Str"",names.get(0));
  assertEquals(""String_Node_Str"",names.get(1));
  assertEquals(""String_Node_Str"",names.get(2));
  assertEquals(""String_Node_Str"",names.get(3));
  assertEquals(""String_Node_Str"",names.get(4));
  assertEquals(0,names.indexOf(""String_Node_Str""));
  assertEquals(1,names.indexOf(""String_Node_Str""));
  assertEquals(2,names.indexOf(""String_Node_Str""));
  assertEquals(3,names.indexOf(""String_Node_Str""));
  assertEquals(4,names.indexOf(""String_Node_Str""));
  names.set(1,""String_Node_Str"");
  assertEquals(""String_Node_Str"",names.get(0));
  assertEquals(""String_Node_Str"",names.get(1));
  assertEquals(""String_Node_Str"",names.get(2));
  assertEquals(""String_Node_Str"",names.get(3));
  assertEquals(""String_Node_Str"",names.get(4));
  assertEquals(0,names.indexOf(""String_Node_Str""));
  assertEquals(1,names.indexOf(""String_Node_Str""));
  assertEquals(2,names.indexOf(""String_Node_Str""));
  assertEquals(3,names.indexOf(""String_Node_Str""));
  assertEquals(4,names.indexOf(""String_Node_Str""));
}",0.752079002079002
32446,"/** 
 * Handle a listener being notified for the specified <code>listElement</code>. This method causes a ListEvent to be fired from this EventList indicating an update occurred at all locations of the given <code>listElement</code>. <p>Note that listElement must be the exact object located within this list (i.e. <code>listElement == get(i) for some i >= 0</code>). <p>This method acquires the write lock for this list before locating the <code>listElement</code> and broadcasting its update. It is assumed that this method may be called on any Thread, so to decrease the burdens of the caller in achieving multi-threaded correctness, this method is Thread ready.
 * @param listElement the list element which has been modified
 */
public void elementChanged(E listElement){
  if (this.observedElements == null)   throw new IllegalStateException(""String_Node_Str"");
  getReadWriteLock().writeLock().lock();
  try {
    this.updates.beginEvent();
    for (int i=0, n=size(); i < n; i++) {
      if (listElement == get(i))       this.updates.elementUpdated(i,listElement);
    }
    this.updates.commitEvent();
  }
  finally {
    getReadWriteLock().writeLock().unlock();
  }
}","/** 
 * Handle a listener being notified for the specified <code>listElement</code>. This method causes a ListEvent to be fired from this EventList indicating an update occurred at all locations of the given <code>listElement</code>. <p>Note that listElement must be the exact object located within this list (i.e. <code>listElement == get(i) for some i >= 0</code>). <p>This method acquires the write lock for this list before locating the <code>listElement</code> and broadcasting its update. It is assumed that this method may be called on any Thread, so to decrease the burdens of the caller in achieving multi-threaded correctness, this method is Thread ready.
 * @param listElement the list element which has been modified
 */
public void elementChanged(Object listElement){
  if (this.observedElements == null)   throw new IllegalStateException(""String_Node_Str"");
  getReadWriteLock().writeLock().lock();
  try {
    this.updates.beginEvent();
    for (int i=0, n=size(); i < n; i++) {
      final E currentElement=get(i);
      if (listElement == currentElement) {
        this.updates.elementUpdated(i,currentElement);
      }
    }
    this.updates.commitEvent();
  }
  finally {
    getReadWriteLock().writeLock().unlock();
  }
}",0.9640049648324368
32447,"/** 
 * This method is called whenever the observed object is changed. It responds by notifying the associated ObservableElementList that the given  {@link Observable} has been changed.
 * @param o the Observable that has been updated
 * @param arg an argument passed to observers which is ignored here
 */
public void update(Observable o,Object arg){
  ((ObservableElementList)list).elementChanged(o);
}","/** 
 * This method is called whenever the observed object is changed. It responds by notifying the associated ObservableElementList that the given  {@link Observable} has been changed.
 * @param o the Observable that has been updated
 * @param arg an argument passed to observers which is ignored here
 */
public void update(Observable o,Object arg){
  list.elementChanged(o);
}",0.9578544061302682
32448,"public void propertyChange(PropertyChangeEvent event){
  if (getEventMatcher().matches(event))   ((ObservableElementList)list).elementChanged(event.getSource());
}","public void propertyChange(PropertyChangeEvent event){
  if (getEventMatcher().matches(event)) {
    list.elementChanged(event.getSource());
  }
}",0.8932038834951457
32449,"@Override public void elementChanged(E element){
  this.elementChangeCount++;
  super.elementChanged(element);
}","@Override public void elementChanged(Object element){
  this.elementChangeCount++;
  super.elementChanged(element);
}",0.9694323144104804
32450,"/** 
 * {@inheritDoc} 
 */
public void setLimit(int limit){
  if (this.limit == limit)   return;
  if (node == null) {
    return;
  }
  this.limit=limit;
  updates.beginEvent();
  int groupIndex=separators.indexOfNode(node,(byte)1);
  int separatorIndex=insertedSeparators.getIndex(groupIndex,SEPARATOR);
  updates.addUpdate(separatorIndex);
  updates.commitEvent();
}","/** 
 * {@inheritDoc} 
 */
public void setLimit(int limit){
  applyLimit(limit,true);
}",0.3333333333333333
32451,"/** 
 * Statically build the separators data structures.
 */
private void rebuildSeparators(){
  insertedSeparators=new Barcode();
  separators=new SimpleTree<GroupSeparator>();
  insertedSeparators.add(0,SOURCE_ELEMENT,source.size());
  for (BarcodeIterator i=grouper.getBarcode().iterator(); i.hasNextColour(Grouper.UNIQUE); ) {
    i.nextColour(Grouper.UNIQUE);
    int groupIndex=i.getColourIndex(Grouper.UNIQUE);
    int sourceIndex=i.getIndex();
    insertedSeparators.add(groupIndex + sourceIndex,SEPARATOR,1);
    Element<GroupSeparator> node=separators.add(groupIndex,new GroupSeparator(),1);
    node.get().setNode(node);
    node.get().setLimit(defaultLimit);
  }
  for (int i=0; i < separators.size(); i++) {
    separators.get(i).get().updateCachedValues();
  }
}","/** 
 * Statically build the separators data structures.
 */
private void rebuildSeparators(){
  insertedSeparators=new Barcode();
  separators=new SimpleTree<GroupSeparator>();
  insertedSeparators.add(0,SOURCE_ELEMENT,source.size());
  for (BarcodeIterator i=grouper.getBarcode().iterator(); i.hasNextColour(Grouper.UNIQUE); ) {
    i.nextColour(Grouper.UNIQUE);
    int groupIndex=i.getColourIndex(Grouper.UNIQUE);
    int sourceIndex=i.getIndex();
    insertedSeparators.add(groupIndex + sourceIndex,SEPARATOR,1);
    Element<GroupSeparator> node=separators.add(groupIndex,new GroupSeparator(),1);
    node.get().setNode(node);
    node.get().applyLimit(defaultLimit,false);
  }
  for (int i=0; i < separators.size(); i++) {
    separators.get(i).get().updateCachedValues();
  }
}",0.9910256410256412
32452,"/** 
 * Validate that this list is as expected.
 */
public void assertConsistent(){
  assertTrue(expected.size() == source.size());
  for (int i=0; i < expected.size(); i++) {
    assertTrue(""String_Node_Str"" + i,expected.get(i) == source.get(i));
  }
}","/** 
 * Validate that this list is as expected.
 */
public void assertConsistent(){
  assertTrue(expected.size() == source.size());
  for (int i=0; i < expected.size(); i++) {
    assertTrue(""String_Node_Str"" + i + ""String_Node_Str""+ expected.get(i)+ ""String_Node_Str""+ source.get(i),expected.get(i) == source.get(i));
  }
}",0.8769497400346621
32453,"/** 
 * Returns the current Matcher specified by the source   {@link MatcherEditor}.
 * @return the current Matcher specified by the source {@link MatcherEditor}
 */
@Override public Matcher<E> getMatcher(){
  return this.source.getMatcher();
}","/** 
 * Returns the current Matcher specified by the source   {@link MatcherEditor}.
 * @return the current Matcher specified by the source {@link MatcherEditor}
 */
public Matcher<E> getMatcher(){
  return this.source.getMatcher();
}",0.9790794979079498
32454,"/** 
 * This method selects an appropriate delegate method to perform the correct work for each of the possible <code>changeType</code>s. This method does <strong>NOT</strong> acquire any locks and is thus used during initialization of FilterList.
 */
private void changeMatcher(MatcherEditor<? super E> matcherEditor,Matcher<? super E> matcher,int changeType){
  if (currentEditor != matcherEditor)   throw new IllegalStateException();
switch (changeType) {
case MatcherEditor.Event.CONSTRAINED:
    currentMatcher=matcher;
  this.constrained();
break;
case MatcherEditor.Event.RELAXED:
currentMatcher=matcher;
this.relaxed();
break;
case MatcherEditor.Event.CHANGED:
currentMatcher=matcher;
this.changed();
break;
case MatcherEditor.Event.MATCH_ALL:
currentMatcher=Matchers.trueMatcher();
this.matchAll();
break;
case MatcherEditor.Event.MATCH_NONE:
currentMatcher=Matchers.falseMatcher();
this.matchNone();
break;
}
}","/** 
 * This method selects an appropriate delegate method to perform the correct work for each of the possible <code>changeType</code>s. This method does <strong>NOT</strong> acquire any locks and is thus used during initialization of FilterList.
 */
private void changeMatcher(MatcherEditor<? super E> matcherEditor,Matcher<? super E> matcher,int changeType){
  if (!disposed) {
    if (currentEditor != matcherEditor)     throw new IllegalStateException();
switch (changeType) {
case MatcherEditor.Event.CONSTRAINED:
      currentMatcher=matcher;
    this.constrained();
  break;
case MatcherEditor.Event.RELAXED:
currentMatcher=matcher;
this.relaxed();
break;
case MatcherEditor.Event.CHANGED:
currentMatcher=matcher;
this.changed();
break;
case MatcherEditor.Event.MATCH_ALL:
currentMatcher=Matchers.trueMatcher();
this.matchAll();
break;
case MatcherEditor.Event.MATCH_NONE:
currentMatcher=Matchers.falseMatcher();
this.matchNone();
break;
}
}
}",0.9620523784072688
32455,"/** 
 * @inheritDoc 
 */
@Override public void dispose(){
  super.dispose();
  if (currentEditor != null) {
    currentEditor.removeMatcherEditorListener(listener);
    currentEditor=null;
  }
  currentMatcher=null;
}","/** 
 * @inheritDoc 
 */
@Override public void dispose(){
  super.dispose();
  if (currentEditor != null) {
    currentEditor.removeMatcherEditorListener(listener);
  }
  disposed=true;
  currentEditor=null;
  currentMatcher=null;
}",0.8596881959910914
32456,"/** 
 * Handle changes from the   {@link SortedList} by modifying the grouping state.During this method, callbacks will be made to the  {@link Client} who isresponsible for firing the appropriate change events to its listeners.
 */
public void listChanged(ListEvent<E> listChanges){
  final Barcode toDoList=new Barcode();
  toDoList.addWhite(0,barcode.size());
  final LinkedList removedValues=new LinkedList();
  int lastFakedUniqueChangeIndex=-1;
  while (listChanges.next()) {
    final int changeIndex=listChanges.getIndex();
    final int changeType=listChanges.getType();
    if (changeType == ListEvent.INSERT) {
      barcode.add(changeIndex,UNIQUE,1);
      toDoList.add(changeIndex,TODO,1);
    }
 else     if (changeType == ListEvent.UPDATE) {
      if (barcode.get(changeIndex) == UNIQUE) {
        if (changeIndex + 1 < barcode.size() && barcode.get(changeIndex + 1) == DUPLICATE) {
          if (changeIndex != lastFakedUniqueChangeIndex) {
            barcode.set(changeIndex,UNIQUE,2);
            toDoList.set(changeIndex,TODO,1);
            lastFakedUniqueChangeIndex=changeIndex + 1;
          }
        }
      }
    }
 else     if (changeType == ListEvent.DELETE) {
      Object deleted=barcode.get(changeIndex);
      barcode.remove(changeIndex,1);
      toDoList.remove(changeIndex,1);
      if (deleted == UNIQUE) {
        if (changeIndex < barcode.size() && barcode.get(changeIndex) == DUPLICATE) {
          barcode.set(changeIndex,UNIQUE,1);
          deleted=UNIQUE_WITH_DUPLICATE;
        }
      }
      removedValues.addLast(deleted);
    }
  }
  TryJoinResult<E> tryJoinResult=new TryJoinResult<E>();
  listChanges.reset();
  while (listChanges.next()) {
    final int changeIndex=listChanges.getIndex();
    final int changeType=listChanges.getType();
    E newValue=listChanges.getNewValue();
    E oldValue=listChanges.getOldValue();
    if (changeType == ListEvent.INSERT) {
      tryJoinExistingGroup(changeIndex,toDoList,tryJoinResult);
      if (tryJoinResult.group == NO_GROUP) {
        client.groupChanged(changeIndex,tryJoinResult.groupIndex,ListEvent.INSERT,true,changeType,ListEvent.<E>unknownValue(),tryJoinResult.newFirstInGroup);
      }
 else {
        client.groupChanged(changeIndex,tryJoinResult.groupIndex,ListEvent.UPDATE,true,changeType,tryJoinResult.oldFirstInGroup,tryJoinResult.newFirstInGroup);
      }
    }
 else     if (changeType == ListEvent.UPDATE) {
      int oldGroup=0;
      if (toDoList.get(changeIndex) == TODO)       oldGroup=RIGHT_GROUP;
 else       if (barcode.get(changeIndex) == DUPLICATE)       oldGroup=LEFT_GROUP;
 else       if (barcode.get(changeIndex) == UNIQUE)       oldGroup=NO_GROUP;
      tryJoinExistingGroup(changeIndex,toDoList,tryJoinResult);
      int groupIndex=tryJoinResult.groupIndex;
      if (tryJoinResult.group == NO_GROUP) {
        if (oldGroup == NO_GROUP) {
          client.groupChanged(changeIndex,groupIndex,ListEvent.UPDATE,true,changeType,oldValue,tryJoinResult.newFirstInGroup);
        }
 else         if (oldGroup == LEFT_GROUP) {
          E firstFromPreviousGroup=sortedList.get(barcode.getIndex(groupIndex - 1,UNIQUE));
          client.groupChanged(changeIndex,groupIndex - 1,ListEvent.UPDATE,false,changeType,firstFromPreviousGroup,firstFromPreviousGroup);
          client.groupChanged(changeIndex,groupIndex,ListEvent.INSERT,true,changeType,ListEvent.<E>unknownValue(),tryJoinResult.newFirstInGroup);
        }
 else         if (oldGroup == RIGHT_GROUP) {
          E firstFromNextGroup=sortedList.get(barcode.getIndex(groupIndex + 1,UNIQUE));
          client.groupChanged(changeIndex,groupIndex,ListEvent.INSERT,true,changeType,ListEvent.<E>unknownValue(),tryJoinResult.newFirstInGroup);
          client.groupChanged(changeIndex,groupIndex + 1,ListEvent.UPDATE,false,changeType,oldValue,firstFromNextGroup);
        }
      }
 else       if (tryJoinResult.group == LEFT_GROUP) {
        if (oldGroup == NO_GROUP) {
          client.groupChanged(changeIndex,groupIndex,ListEvent.UPDATE,true,changeType,tryJoinResult.oldFirstInGroup,tryJoinResult.newFirstInGroup);
          client.groupChanged(changeIndex,groupIndex + 1,ListEvent.DELETE,false,changeType,oldValue,ListEvent.<E>unknownValue());
        }
 else         if (oldGroup == LEFT_GROUP) {
          client.groupChanged(changeIndex,groupIndex,ListEvent.UPDATE,true,changeType,tryJoinResult.oldFirstInGroup,tryJoinResult.newFirstInGroup);
        }
 else         if (oldGroup == RIGHT_GROUP) {
          client.groupChanged(changeIndex,groupIndex,ListEvent.UPDATE,true,changeType,tryJoinResult.oldFirstInGroup,tryJoinResult.newFirstInGroup);
          if (groupIndex + 1 < barcode.blackSize()) {
            E firstFromNextGroup=sortedList.get(barcode.getIndex(groupIndex + 1,UNIQUE));
            client.groupChanged(changeIndex,groupIndex + 1,ListEvent.UPDATE,false,changeType,oldValue,firstFromNextGroup);
          }
        }
      }
 else       if (tryJoinResult.group == RIGHT_GROUP) {
        if (oldGroup == NO_GROUP) {
          client.groupChanged(changeIndex,groupIndex,ListEvent.DELETE,false,changeType,oldValue,ListEvent.<E>unknownValue());
          client.groupChanged(changeIndex,groupIndex,ListEvent.UPDATE,true,changeType,tryJoinResult.oldFirstInGroup,tryJoinResult.newFirstInGroup);
        }
 else         if (oldGroup == LEFT_GROUP) {
          if (groupIndex - 1 >= 0) {
            E firstFromPreviousGroup=sortedList.get(barcode.getIndex(groupIndex - 1,UNIQUE));
            client.groupChanged(changeIndex,groupIndex - 1,ListEvent.UPDATE,false,changeType,firstFromPreviousGroup,firstFromPreviousGroup);
          }
          client.groupChanged(changeIndex,groupIndex,ListEvent.UPDATE,true,changeType,tryJoinResult.oldFirstInGroup,tryJoinResult.newFirstInGroup);
        }
 else         if (oldGroup == RIGHT_GROUP) {
          client.groupChanged(changeIndex,groupIndex,ListEvent.UPDATE,true,changeType,tryJoinResult.oldFirstInGroup,tryJoinResult.newFirstInGroup);
        }
      }
    }
 else     if (changeType == ListEvent.DELETE) {
      final Object deleted=removedValues.removeFirst();
      final int sourceDeletedIndex=deleted == DUPLICATE ? changeIndex - 1 : changeIndex;
      final int groupDeletedIndex=sourceDeletedIndex < barcode.size() ? barcode.getBlackIndex(sourceDeletedIndex,true) : barcode.blackSize();
      if (deleted == UNIQUE) {
        client.groupChanged(changeIndex,groupDeletedIndex,ListEvent.DELETE,true,changeType,oldValue,ListEvent.<E>unknownValue());
      }
 else {
        E oldValueInGroup;
        E newValueInGroup;
        if (groupDeletedIndex < barcode.blackSize()) {
          int firstInGroupIndex=barcode.getIndex(groupDeletedIndex,UNIQUE);
          newValueInGroup=sortedList.get(firstInGroupIndex);
        }
 else {
          newValueInGroup=ListEvent.<E>unknownValue();
        }
        if (deleted == UNIQUE_WITH_DUPLICATE) {
          oldValueInGroup=oldValue;
        }
 else {
          oldValueInGroup=newValueInGroup;
        }
        client.groupChanged(changeIndex,groupDeletedIndex,ListEvent.UPDATE,true,changeType,oldValueInGroup,newValueInGroup);
      }
    }
  }
}","/** 
 * Handle changes from the   {@link SortedList} by modifying the grouping state.During this method, callbacks will be made to the  {@link Client} who isresponsible for firing the appropriate change events to its listeners.
 */
public void listChanged(ListEvent<E> listChanges){
  final Barcode toDoList=new Barcode();
  toDoList.addWhite(0,barcode.size());
  final LinkedList removedValues=new LinkedList();
  int lastFakedUniqueChangeIndex=-1;
  while (listChanges.next()) {
    final int changeIndex=listChanges.getIndex();
    final int changeType=listChanges.getType();
    if (changeType == ListEvent.INSERT) {
      barcode.add(changeIndex,UNIQUE,1);
      toDoList.add(changeIndex,TODO,1);
    }
 else     if (changeType == ListEvent.UPDATE) {
      if (barcode.get(changeIndex) == UNIQUE) {
        if (changeIndex + 1 < barcode.size() && barcode.get(changeIndex + 1) == DUPLICATE) {
          if (changeIndex != lastFakedUniqueChangeIndex) {
            barcode.set(changeIndex,UNIQUE,2);
            toDoList.set(changeIndex,TODO,1);
            lastFakedUniqueChangeIndex=changeIndex + 1;
          }
        }
      }
    }
 else     if (changeType == ListEvent.DELETE) {
      Object deleted=barcode.get(changeIndex);
      barcode.remove(changeIndex,1);
      toDoList.remove(changeIndex,1);
      if (deleted == UNIQUE) {
        if (changeIndex < barcode.size() && barcode.get(changeIndex) == DUPLICATE) {
          barcode.set(changeIndex,UNIQUE,1);
          deleted=UNIQUE_WITH_DUPLICATE;
        }
      }
      removedValues.addLast(deleted);
    }
  }
  TryJoinResult<E> tryJoinResult=new TryJoinResult<E>();
  listChanges.reset();
  while (listChanges.next()) {
    final int changeIndex=listChanges.getIndex();
    final int changeType=listChanges.getType();
    E newValue=listChanges.getNewValue();
    E oldValue=listChanges.getOldValue();
    if (changeType == ListEvent.INSERT) {
      tryJoinExistingGroup(changeIndex,toDoList,tryJoinResult);
      if (tryJoinResult.group == NO_GROUP) {
        client.groupChanged(changeIndex,tryJoinResult.groupIndex,ListEvent.INSERT,true,changeType,ListEvent.<E>unknownValue(),tryJoinResult.newFirstInGroup);
      }
 else {
        client.groupChanged(changeIndex,tryJoinResult.groupIndex,ListEvent.UPDATE,true,changeType,tryJoinResult.oldFirstInGroup,tryJoinResult.newFirstInGroup);
      }
    }
 else     if (changeType == ListEvent.UPDATE) {
      int oldGroup=0;
      if (toDoList.get(changeIndex) == TODO) {
        if (changeIndex + 1 < barcode.size()) {
          oldGroup=RIGHT_GROUP;
        }
 else {
          oldGroup=NO_GROUP;
        }
      }
 else       if (barcode.get(changeIndex) == DUPLICATE)       oldGroup=LEFT_GROUP;
 else       if (barcode.get(changeIndex) == UNIQUE)       oldGroup=NO_GROUP;
      tryJoinExistingGroup(changeIndex,toDoList,tryJoinResult);
      int groupIndex=tryJoinResult.groupIndex;
      if (tryJoinResult.group == NO_GROUP) {
        if (oldGroup == NO_GROUP) {
          client.groupChanged(changeIndex,groupIndex,ListEvent.UPDATE,true,changeType,oldValue,tryJoinResult.newFirstInGroup);
        }
 else         if (oldGroup == LEFT_GROUP) {
          E firstFromPreviousGroup=sortedList.get(barcode.getIndex(groupIndex - 1,UNIQUE));
          client.groupChanged(changeIndex,groupIndex - 1,ListEvent.UPDATE,false,changeType,firstFromPreviousGroup,firstFromPreviousGroup);
          client.groupChanged(changeIndex,groupIndex,ListEvent.INSERT,true,changeType,ListEvent.<E>unknownValue(),tryJoinResult.newFirstInGroup);
        }
 else         if (oldGroup == RIGHT_GROUP) {
          E firstFromNextGroup=sortedList.get(barcode.getIndex(groupIndex + 1,UNIQUE));
          client.groupChanged(changeIndex,groupIndex,ListEvent.INSERT,true,changeType,ListEvent.<E>unknownValue(),tryJoinResult.newFirstInGroup);
          client.groupChanged(changeIndex,groupIndex + 1,ListEvent.UPDATE,false,changeType,oldValue,firstFromNextGroup);
        }
      }
 else       if (tryJoinResult.group == LEFT_GROUP) {
        if (oldGroup == NO_GROUP) {
          client.groupChanged(changeIndex,groupIndex,ListEvent.UPDATE,true,changeType,tryJoinResult.oldFirstInGroup,tryJoinResult.newFirstInGroup);
          client.groupChanged(changeIndex,groupIndex + 1,ListEvent.DELETE,false,changeType,oldValue,ListEvent.<E>unknownValue());
        }
 else         if (oldGroup == LEFT_GROUP) {
          client.groupChanged(changeIndex,groupIndex,ListEvent.UPDATE,true,changeType,tryJoinResult.oldFirstInGroup,tryJoinResult.newFirstInGroup);
        }
 else         if (oldGroup == RIGHT_GROUP) {
          client.groupChanged(changeIndex,groupIndex,ListEvent.UPDATE,true,changeType,tryJoinResult.oldFirstInGroup,tryJoinResult.newFirstInGroup);
          if (groupIndex + 1 < barcode.blackSize()) {
            E firstFromNextGroup=sortedList.get(barcode.getIndex(groupIndex + 1,UNIQUE));
            client.groupChanged(changeIndex,groupIndex + 1,ListEvent.UPDATE,false,changeType,oldValue,firstFromNextGroup);
          }
        }
      }
 else       if (tryJoinResult.group == RIGHT_GROUP) {
        if (oldGroup == NO_GROUP) {
          client.groupChanged(changeIndex,groupIndex,ListEvent.DELETE,false,changeType,oldValue,ListEvent.<E>unknownValue());
          client.groupChanged(changeIndex,groupIndex,ListEvent.UPDATE,true,changeType,tryJoinResult.oldFirstInGroup,tryJoinResult.newFirstInGroup);
        }
 else         if (oldGroup == LEFT_GROUP) {
          if (groupIndex - 1 >= 0) {
            E firstFromPreviousGroup=sortedList.get(barcode.getIndex(groupIndex - 1,UNIQUE));
            client.groupChanged(changeIndex,groupIndex - 1,ListEvent.UPDATE,false,changeType,firstFromPreviousGroup,firstFromPreviousGroup);
          }
          client.groupChanged(changeIndex,groupIndex,ListEvent.UPDATE,true,changeType,tryJoinResult.oldFirstInGroup,tryJoinResult.newFirstInGroup);
        }
 else         if (oldGroup == RIGHT_GROUP) {
          client.groupChanged(changeIndex,groupIndex,ListEvent.UPDATE,true,changeType,tryJoinResult.oldFirstInGroup,tryJoinResult.newFirstInGroup);
        }
      }
    }
 else     if (changeType == ListEvent.DELETE) {
      final Object deleted=removedValues.removeFirst();
      final int sourceDeletedIndex=deleted == DUPLICATE ? changeIndex - 1 : changeIndex;
      final int groupDeletedIndex=sourceDeletedIndex < barcode.size() ? barcode.getBlackIndex(sourceDeletedIndex,true) : barcode.blackSize();
      if (deleted == UNIQUE) {
        if (changeIndex == lastFakedUniqueChangeIndex) {
        }
 else {
          client.groupChanged(changeIndex,groupDeletedIndex,ListEvent.DELETE,true,changeType,oldValue,ListEvent.<E>unknownValue());
        }
      }
 else {
        E oldValueInGroup;
        E newValueInGroup;
        if (groupDeletedIndex < barcode.blackSize()) {
          int firstInGroupIndex=barcode.getIndex(groupDeletedIndex,UNIQUE);
          newValueInGroup=sortedList.get(firstInGroupIndex);
        }
 else {
          newValueInGroup=ListEvent.<E>unknownValue();
        }
        if (deleted == UNIQUE_WITH_DUPLICATE) {
          oldValueInGroup=oldValue;
        }
 else {
          oldValueInGroup=newValueInGroup;
        }
        client.groupChanged(changeIndex,groupDeletedIndex,ListEvent.UPDATE,true,changeType,oldValueInGroup,newValueInGroup);
      }
    }
  }
}",0.9509668508287292
32457,"/** 
 * This tests a corner case that arose from the first attempt at fixing issue <a href=""https://glazedlists.dev.java.net/issues/show_bug.cgi?id=491"">491</a>
 */
public void testAddOnFirstAndUpdateOnSecondElement(){
  TransactionList<String> source=new TransactionList<String>(new BasicEventList<String>());
  GroupingList<String> grouped=new GroupingList<String>(source,GlazedListsTests.getFirstLetterComparator());
  source.add(""String_Node_Str"");
  source.add(""String_Node_Str"");
  source.add(""String_Node_Str"");
  assertEquals(""String_Node_Str"",grouped.toString());
  System.out.println(""String_Node_Str"");
  source.beginEvent();
  source.add(1,""String_Node_Str"");
  source.set(2,source.get(2));
  source.commitEvent();
  assertEquals(""String_Node_Str"",grouped.toString());
}","/** 
 * This tests a corner case that arose from the first attempt at fixing issue <a href=""https://glazedlists.dev.java.net/issues/show_bug.cgi?id=491"">491</a>
 */
public void testAddOnFirstAndUpdateOnSecondElement(){
  TransactionList<String> source=new TransactionList<String>(new BasicEventList<String>());
  GroupingList<String> grouped=new GroupingList<String>(source,GlazedListsTests.getFirstLetterComparator());
  source.add(""String_Node_Str"");
  source.add(""String_Node_Str"");
  source.add(""String_Node_Str"");
  assertEquals(""String_Node_Str"",grouped.toString());
  source.beginEvent();
  source.add(1,""String_Node_Str"");
  source.set(2,source.get(2));
  source.commitEvent();
  assertEquals(""String_Node_Str"",grouped.toString());
}",0.9730794484569928
32458,"/** 
 * Testcase from issue <a href=""https://glazedlists.dev.java.net/issues/show_bug.cgi?id=486"">486</a>
 */
public void testIssue486(){
  TransactionList<String> txList=new TransactionList<String>(new BasicEventList<String>());
  new GroupingList<String>(txList);
  txList.beginEvent();
  txList.add(""String_Node_Str"");
  txList.add(""String_Node_Str"");
  txList.add(""String_Node_Str"");
  txList.add(""String_Node_Str"");
  txList.commitEvent();
  txList.beginEvent();
  txList.set(0,txList.get(0));
  txList.set(1,txList.get(1));
  txList.set(2,txList.get(2));
  txList.set(3,txList.get(3));
  txList.commitEvent();
}","/** 
 * Testcase from issue <a href=""https://glazedlists.dev.java.net/issues/show_bug.cgi?id=486"">486</a>
 */
public void testIssue486(){
  TransactionList<String> txList=new TransactionList<String>(new BasicEventList<String>());
  GroupingList<String> grouped=new GroupingList<String>(txList);
  txList.beginEvent();
  txList.add(""String_Node_Str"");
  txList.add(""String_Node_Str"");
  txList.add(""String_Node_Str"");
  txList.add(""String_Node_Str"");
  txList.commitEvent();
  assertEquals(""String_Node_Str"",grouped.toString());
  txList.beginEvent();
  txList.set(0,txList.get(0));
  txList.set(1,txList.get(1));
  txList.set(2,txList.get(2));
  txList.set(3,txList.get(3));
  txList.commitEvent();
  assertEquals(""String_Node_Str"",grouped.toString());
}",0.900072939460248
32459,"/** 
 * Check list elements for type safety after they are added to an EventList using a   {@link ListEventListener}. The   {@link ListEventListener} whichis installed and returned to the caller (which they may uninstall at their leisure) will throw an  {@link IllegalArgumentException} if itdetects the addition of an element with an unsupported type. <p> This  {@link ListEventListener} is typically used as a tool tocheck invariants of the elements of  {@link EventList}s during software development and testing phases.
 * @param source the {@link EventList} on which to provide type safety
 * @param types the set of types to which each list element must beassignable - note <tt>null</tt> is an acceptable type and indicates the  {@link EventList} expects to contain <tt>null</tt>elements
 * @return the {@link ListEventListener} providing the which provides typesafety checking on the given <code>source</code>. To stop the type safety checking, use {@link EventList#removeListEventListener(ListEventListener)}.
 */
public static <E>ListEventListener<E> typeSafetyListener(EventList<E> source,Set<Class> types){
  return new TypeSafetyListener<E>(source,types);
}","/** 
 * Check list elements for type safety after they are added to an EventList using a   {@link ListEventListener}. The   {@link ListEventListener} which isinstalled and returned to the caller (which they may uninstall at their leisure) will throw an  {@link IllegalArgumentException} if it detects theaddition of an element with an unsupported type. <p> This  {@link ListEventListener} is typically used as a tool to checkinvariants of the elements of  {@link EventList}s during software development and testing phases.
 * @param source the  {@link EventList} on which to provide type safety
 * @param types the set of types to which each list element must be assignable - the set itself must not be <tt>null</tt>, but <tt>null</tt> is an acceptable type within the set and indicates the {@link EventList} expects to contain <tt>null</tt> elements
 * @return the {@link ListEventListener} providing the safety checking onthe given <code>source</code>. To stop the type safety checking, use  {@link EventList#removeListEventListener(ListEventListener)}.
 */
public static <E>ListEventListener<E> typeSafetyListener(EventList<E> source,Set<Class> types){
  return new TypeSafetyListener<E>(source,types);
}",0.9170526315789472
32460,"public void run(){
  final String currentText=comboBoxEditorComponent.getText();
  final Object item=findAutoCompleteTerm(currentText);
  String itemText=convertToString(item);
  if (!currentText.equals(itemText)) {
    if (item == NOT_FOUND && !allItemsUnfiltered.isEmpty())     itemText=convertToString(allItemsUnfiltered.get(0));
    comboBoxEditorComponent.setText(itemText);
  }
}","public void run(){
  final JTextField editor=comboBoxEditorComponent;
  if (editor != null) {
    final String currentText=editor.getText();
    final Object item=findAutoCompleteTerm(currentText);
    String itemText=convertToString(item);
    if (!currentText.equals(itemText)) {
      if (item == NOT_FOUND && !allItemsUnfiltered.isEmpty())       itemText=convertToString(allItemsUnfiltered.get(0));
      editor.setText(itemText);
    }
  }
}",0.8158844765342961
32461,"public AtLeastMatcherEditor(int minimum){
  this.minimum=minimum;
  currentMatcher=GlazedListsTests.matchAtLeast(minimum);
}","public AtLeastMatcherEditor(int minimum){
  this.minimum=minimum;
  fireChanged(GlazedListsTests.matchAtLeast(minimum));
}",0.91869918699187
32462,"/** 
 * Returns <tt>true</tt> if the current matcher will match nothing.
 */
protected final boolean isCurrentlyMatchingNone(){
  return this.currentMatcher == Matchers.falseMatcher();
}","/** 
 * Returns <tt>true</tt> if the current matcher will match nothing.
 */
protected final boolean isCurrentlyMatchingNone(){
  return currentMatcher == Matchers.falseMatcher();
}",0.9863760217983653
32463,"/** 
 * Returns <tt>true</tt> if the current matcher will match everything.
 */
protected final boolean isCurrentlyMatchingAll(){
  return this.currentMatcher == Matchers.trueMatcher();
}","/** 
 * Returns <tt>true</tt> if the current matcher will match everything.
 */
protected final boolean isCurrentlyMatchingAll(){
  return currentMatcher == Matchers.trueMatcher();
}",0.986449864498645
32464,"/** 
 * {@inheritDoc} 
 */
public Matcher<E> getMatcher(){
  return currentMatcher;
}","/** 
 * {@inheritDoc} 
 */
public final Matcher<E> getMatcher(){
  return currentMatcher;
}",0.9659090909090908
32465,"/** 
 * Indicates that the filter matches all.
 */
protected final void fireMatchAll(){
  this.currentMatcher=Matchers.trueMatcher();
  this.fireChangedMatcher(new MatcherEditor.Event<E>(this,Event.MATCH_ALL,this.currentMatcher));
}","/** 
 * Indicates that the filter matches all.
 */
protected final void fireMatchAll(){
  currentMatcher=Matchers.trueMatcher();
  fireChangedMatcher(createMatchAllEvent(currentMatcher));
}",0.8598574821852731
32466,"/** 
 * Indicates that the filter has changed to be more restrictive. This should only be called if all currently filtered items will remain filtered.
 */
protected final void fireConstrained(Matcher<E> matcher){
  if (matcher == null)   throw new NullPointerException();
  this.currentMatcher=matcher;
  this.fireChangedMatcher(new MatcherEditor.Event<E>(this,Event.CONSTRAINED,this.currentMatcher));
}","/** 
 * Indicates that the filter has changed to be more restrictive. This should only be called if all currently filtered items will remain filtered.
 */
protected final void fireConstrained(Matcher<E> matcher){
  if (matcher == null)   throw new NullPointerException();
  currentMatcher=matcher;
  fireChangedMatcher(createConstrainedEvent(currentMatcher));
}",0.8979057591623036
32467,"/** 
 * Indicates that the filter has changed in an indeterminate way.
 */
protected final void fireChanged(Matcher<E> matcher){
  if (matcher == null)   throw new NullPointerException();
  this.currentMatcher=matcher;
  this.fireChangedMatcher(new MatcherEditor.Event<E>(this,Event.CHANGED,this.currentMatcher));
}","/** 
 * Indicates that the filter has changed in an indeterminate way.
 */
protected final void fireChanged(Matcher<E> matcher){
  if (matcher == null)   throw new NullPointerException();
  currentMatcher=matcher;
  fireChangedMatcher(createChangedEvent(currentMatcher));
}",0.8809523809523809
32468,"/** 
 * Indicates that the filter matches none.
 */
protected final void fireMatchNone(){
  this.currentMatcher=Matchers.falseMatcher();
  this.fireChangedMatcher(new MatcherEditor.Event<E>(this,Event.MATCH_NONE,this.currentMatcher));
}","/** 
 * Indicates that the filter matches none.
 */
protected final void fireMatchNone(){
  currentMatcher=Matchers.falseMatcher();
  fireChangedMatcher(createMatchNoneEvent(currentMatcher));
}",0.8624708624708625
32469,"/** 
 * Indicates that the filter has changed to be less restrictive. This should only be called if all currently unfiltered items will remain unfiltered.
 */
protected final void fireRelaxed(Matcher<E> matcher){
  if (matcher == null)   throw new NullPointerException();
  this.currentMatcher=matcher;
  this.fireChangedMatcher(new MatcherEditor.Event<E>(this,Event.RELAXED,this.currentMatcher));
}","/** 
 * Indicates that the filter has changed to be less restrictive. This should only be called if all currently unfiltered items will remain unfiltered.
 */
protected final void fireRelaxed(Matcher<E> matcher){
  if (matcher == null)   throw new NullPointerException();
  currentMatcher=matcher;
  fireChangedMatcher(createRelaxedEvent(currentMatcher));
}",0.9074074074074074
32470,"public void fireChanged(){
  super.fireChanged(this);
}","public void fireChanged(){
  fireChanged(this);
}",0.9423076923076924
32471,"public void fireCleared(){
  super.fireMatchAll();
}","public void fireCleared(){
  fireMatchAll();
}",0.9387755102040816
32472,"public void fireConstrained(){
  super.fireConstrained(this);
}","public void fireConstrained(){
  fireConstrained(this);
}",0.95
32473,"/** 
 * This MatcherEditor's Matcher is itself.
 */
public PrivateMatcherEditor(){
  this.currentMatcher=this;
}","/** 
 * This MatcherEditor's Matcher is itself.
 */
public PrivateMatcherEditor(){
  fireChanged();
}",0.8732394366197183
32474,"public void fireRelaxed(){
  super.fireRelaxed(this);
}","public void fireRelaxed(){
  fireRelaxed(this);
}",0.9423076923076924
32475,"/** 
 * {@inheritDoc} 
 */
@Override public int lastIndexOf(Object object){
  if (mode != STRICT_SORT_ORDER || comparator == null)   return source.lastIndexOf(object);
  int index=((SimpleTree)sorted).indexOfValue(object,false,false,ALL_COLORS);
  if (index == -1)   return -1;
  for (; index > -1; index--) {
    E objectAtIndex=get(index);
    if (comparator.compare((E)object,objectAtIndex) != 0)     return -1;
    if (GlazedListsImpl.equal(object,objectAtIndex))     return index;
  }
  return -1;
}","/** 
 * {@inheritDoc} 
 */
@Override public int lastIndexOf(Object object){
  if (mode != STRICT_SORT_ORDER || comparator == null)   return super.lastIndexOf(object);
  int index=((SimpleTree)sorted).indexOfValue(object,false,false,ALL_COLORS);
  if (index == -1)   return -1;
  for (; index > -1; index--) {
    E objectAtIndex=get(index);
    if (comparator.compare((E)object,objectAtIndex) != 0)     return -1;
    if (GlazedListsImpl.equal(object,objectAtIndex))     return index;
  }
  return -1;
}",0.9910625620655412
32476,"/** 
 * Tests that elements are properly moved when value changes require that if sort order is not enforced on the list.
 */
public void testSimpleMovesSortNotEnforced(){
  unsortedList=new BasicEventList<Comparable>();
  sortedList=SortedList.create(unsortedList);
  sortedList.setMode(SortedList.AVOID_MOVING_ELEMENTS);
  ListConsistencyListener.install(sortedList);
  unsortedList.addAll(GlazedListsTests.stringToList(""String_Node_Str""));
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  unsortedList.set(3,""String_Node_Str"");
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  assertEquals(3,unsortedList.indexOf(""String_Node_Str""));
  assertEquals(3,sortedList.indexOf(""String_Node_Str""));
  unsortedList.addAll(3,GlazedListsTests.stringToList(""String_Node_Str""));
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  assertEquals(10,unsortedList.indexOf(""String_Node_Str""));
  assertEquals(3,sortedList.indexOf(""String_Node_Str""));
  unsortedList.removeAll(GlazedListsTests.stringToList(""String_Node_Str""));
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  assertEquals(7,unsortedList.indexOf(""String_Node_Str""));
  assertEquals(2,sortedList.indexOf(""String_Node_Str""));
  unsortedList.addAll(8,GlazedListsTests.stringToList(""String_Node_Str""));
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  assertEquals(7,unsortedList.indexOf(""String_Node_Str""));
  assertEquals(4,sortedList.indexOf(""String_Node_Str""));
  unsortedList.set(0,""String_Node_Str"");
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  assertEquals(7,unsortedList.indexOf(""String_Node_Str""));
  assertEquals(4,sortedList.indexOf(""String_Node_Str""));
  assertEquals(0,unsortedList.indexOf(""String_Node_Str""));
  assertEquals(1,sortedList.indexOf(""String_Node_Str""));
  unsortedList.set(7,""String_Node_Str"");
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  assertEquals(-1,unsortedList.indexOf(""String_Node_Str""));
  assertEquals(-1,sortedList.indexOf(""String_Node_Str""));
  assertEquals(7,unsortedList.indexOf(""String_Node_Str""));
  assertEquals(4,sortedList.indexOf(""String_Node_Str""));
  unsortedList.addAll(0,GlazedListsTests.stringToList(""String_Node_Str""));
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  unsortedList.addAll(5,GlazedListsTests.stringToList(""String_Node_Str""));
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  sortedList.set(1,""String_Node_Str"");
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  assertEquals(4,unsortedList.indexOf(""String_Node_Str""));
  assertEquals(1,sortedList.indexOf(""String_Node_Str""));
  sortedList.clear();
  assertEquals(Collections.EMPTY_LIST,unsortedList);
  assertEquals(Collections.EMPTY_LIST,sortedList);
  sortedList.addAll(GlazedListsTests.stringToList(""String_Node_Str""));
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  sortedList.set(0,""String_Node_Str"");
  sortedList.set(2,""String_Node_Str"");
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  sortedList.add(""String_Node_Str"");
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  assertEquals(2,unsortedList.indexOf(""String_Node_Str""));
  assertEquals(0,unsortedList.indexOf(""String_Node_Str""));
  assertEquals(0,sortedList.indexOf(""String_Node_Str""));
  assertEquals(1,sortedList.indexOf(""String_Node_Str""));
  sortedList.add(""String_Node_Str"");
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
}","/** 
 * Tests that elements are properly moved when value changes require that if sort order is not enforced on the list.
 */
public void testSimpleMovesSortNotEnforced(){
  unsortedList=new BasicEventList<Comparable>();
  sortedList=SortedList.create(unsortedList);
  sortedList.setMode(SortedList.AVOID_MOVING_ELEMENTS);
  ListConsistencyListener.install(sortedList);
  unsortedList.addAll(GlazedListsTests.stringToList(""String_Node_Str""));
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  unsortedList.set(3,""String_Node_Str"");
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  assertEquals(3,unsortedList.indexOf(""String_Node_Str""));
  assertEquals(3,sortedList.indexOf(""String_Node_Str""));
  unsortedList.addAll(3,GlazedListsTests.stringToList(""String_Node_Str""));
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  assertEquals(10,unsortedList.indexOf(""String_Node_Str""));
  assertEquals(3,sortedList.indexOf(""String_Node_Str""));
  assertEquals(12,unsortedList.lastIndexOf(""String_Node_Str""));
  assertEquals(5,sortedList.lastIndexOf(""String_Node_Str""));
  unsortedList.removeAll(GlazedListsTests.stringToList(""String_Node_Str""));
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  assertEquals(7,unsortedList.indexOf(""String_Node_Str""));
  assertEquals(2,sortedList.indexOf(""String_Node_Str""));
  assertEquals(8,unsortedList.lastIndexOf(""String_Node_Str""));
  assertEquals(3,sortedList.lastIndexOf(""String_Node_Str""));
  unsortedList.addAll(8,GlazedListsTests.stringToList(""String_Node_Str""));
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  assertEquals(7,unsortedList.indexOf(""String_Node_Str""));
  assertEquals(4,sortedList.indexOf(""String_Node_Str""));
  unsortedList.set(0,""String_Node_Str"");
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  assertEquals(7,unsortedList.indexOf(""String_Node_Str""));
  assertEquals(4,sortedList.indexOf(""String_Node_Str""));
  assertEquals(0,unsortedList.indexOf(""String_Node_Str""));
  assertEquals(1,sortedList.indexOf(""String_Node_Str""));
  unsortedList.set(7,""String_Node_Str"");
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  assertEquals(-1,unsortedList.indexOf(""String_Node_Str""));
  assertEquals(-1,sortedList.indexOf(""String_Node_Str""));
  assertEquals(7,unsortedList.indexOf(""String_Node_Str""));
  assertEquals(4,sortedList.indexOf(""String_Node_Str""));
  assertEquals(12,unsortedList.lastIndexOf(""String_Node_Str""));
  assertEquals(5,sortedList.lastIndexOf(""String_Node_Str""));
  unsortedList.addAll(0,GlazedListsTests.stringToList(""String_Node_Str""));
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  assertEquals(2,unsortedList.indexOf(""String_Node_Str""));
  assertEquals(6,sortedList.indexOf(""String_Node_Str""));
  assertEquals(16,unsortedList.lastIndexOf(""String_Node_Str""));
  assertEquals(9,sortedList.lastIndexOf(""String_Node_Str""));
  unsortedList.addAll(5,GlazedListsTests.stringToList(""String_Node_Str""));
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  sortedList.set(1,""String_Node_Str"");
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  assertEquals(4,unsortedList.indexOf(""String_Node_Str""));
  assertEquals(1,sortedList.indexOf(""String_Node_Str""));
  sortedList.clear();
  assertEquals(Collections.EMPTY_LIST,unsortedList);
  assertEquals(Collections.EMPTY_LIST,sortedList);
  sortedList.addAll(GlazedListsTests.stringToList(""String_Node_Str""));
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  sortedList.set(0,""String_Node_Str"");
  sortedList.set(2,""String_Node_Str"");
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  sortedList.add(""String_Node_Str"");
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
  assertEquals(2,unsortedList.indexOf(""String_Node_Str""));
  assertEquals(0,unsortedList.indexOf(""String_Node_Str""));
  assertEquals(0,sortedList.indexOf(""String_Node_Str""));
  assertEquals(1,sortedList.indexOf(""String_Node_Str""));
  sortedList.add(""String_Node_Str"");
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),unsortedList);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),sortedList);
}",0.5153386258943448
32477,"public void testChangingSortMode(){
  SortedList<String> names=SortedList.create(new BasicEventList<String>());
  names.setMode(SortedList.AVOID_MOVING_ELEMENTS);
  names.add(""String_Node_Str"");
  names.add(""String_Node_Str"");
  names.add(""String_Node_Str"");
  names.add(""String_Node_Str"");
  names.set(0,""String_Node_Str"");
  names.set(1,""String_Node_Str"");
  names.set(2,""String_Node_Str"");
  names.set(3,""String_Node_Str"");
  assertEquals(""String_Node_Str"",names.get(0));
  assertEquals(""String_Node_Str"",names.get(1));
  assertEquals(""String_Node_Str"",names.get(2));
  assertEquals(""String_Node_Str"",names.get(3));
  assertEquals(0,names.indexOf(""String_Node_Str""));
  assertEquals(1,names.indexOf(""String_Node_Str""));
  assertEquals(2,names.indexOf(""String_Node_Str""));
  assertEquals(3,names.indexOf(""String_Node_Str""));
  names.setMode(SortedList.STRICT_SORT_ORDER);
  assertEquals(""String_Node_Str"",names.get(0));
  assertEquals(""String_Node_Str"",names.get(1));
  assertEquals(""String_Node_Str"",names.get(2));
  assertEquals(""String_Node_Str"",names.get(3));
  assertEquals(0,names.indexOf(""String_Node_Str""));
  assertEquals(1,names.indexOf(""String_Node_Str""));
  assertEquals(2,names.indexOf(""String_Node_Str""));
  assertEquals(3,names.indexOf(""String_Node_Str""));
  names.setMode(SortedList.AVOID_MOVING_ELEMENTS);
  names.add(""String_Node_Str"");
  assertEquals(""String_Node_Str"",names.get(0));
  assertEquals(""String_Node_Str"",names.get(1));
  assertEquals(""String_Node_Str"",names.get(2));
  assertEquals(""String_Node_Str"",names.get(3));
  assertEquals(""String_Node_Str"",names.get(4));
  assertEquals(0,names.indexOf(""String_Node_Str""));
  assertEquals(1,names.indexOf(""String_Node_Str""));
  assertEquals(2,names.indexOf(""String_Node_Str""));
  assertEquals(3,names.indexOf(""String_Node_Str""));
  assertEquals(4,names.indexOf(""String_Node_Str""));
  names.set(1,""String_Node_Str"");
  assertEquals(""String_Node_Str"",names.get(0));
  assertEquals(""String_Node_Str"",names.get(1));
  assertEquals(""String_Node_Str"",names.get(2));
  assertEquals(""String_Node_Str"",names.get(3));
  assertEquals(""String_Node_Str"",names.get(4));
  assertEquals(0,names.indexOf(""String_Node_Str""));
  assertEquals(1,names.indexOf(""String_Node_Str""));
  assertEquals(2,names.indexOf(""String_Node_Str""));
  assertEquals(3,names.indexOf(""String_Node_Str""));
  assertEquals(4,names.indexOf(""String_Node_Str""));
}","public void testChangingSortMode(){
  SortedList<String> names=SortedList.create(new BasicEventList<String>());
  names.setMode(SortedList.AVOID_MOVING_ELEMENTS);
  names.add(""String_Node_Str"");
  names.add(""String_Node_Str"");
  names.add(""String_Node_Str"");
  names.add(""String_Node_Str"");
  names.set(0,""String_Node_Str"");
  names.set(1,""String_Node_Str"");
  names.set(2,""String_Node_Str"");
  names.set(3,""String_Node_Str"");
  assertEquals(""String_Node_Str"",names.get(0));
  assertEquals(""String_Node_Str"",names.get(1));
  assertEquals(""String_Node_Str"",names.get(2));
  assertEquals(""String_Node_Str"",names.get(3));
  assertEquals(0,names.indexOf(""String_Node_Str""));
  assertEquals(1,names.indexOf(""String_Node_Str""));
  assertEquals(2,names.indexOf(""String_Node_Str""));
  assertEquals(3,names.indexOf(""String_Node_Str""));
  assertEquals(0,names.lastIndexOf(""String_Node_Str""));
  assertEquals(1,names.lastIndexOf(""String_Node_Str""));
  assertEquals(2,names.lastIndexOf(""String_Node_Str""));
  assertEquals(3,names.lastIndexOf(""String_Node_Str""));
  names.setMode(SortedList.STRICT_SORT_ORDER);
  assertEquals(""String_Node_Str"",names.get(0));
  assertEquals(""String_Node_Str"",names.get(1));
  assertEquals(""String_Node_Str"",names.get(2));
  assertEquals(""String_Node_Str"",names.get(3));
  assertEquals(0,names.indexOf(""String_Node_Str""));
  assertEquals(1,names.indexOf(""String_Node_Str""));
  assertEquals(2,names.indexOf(""String_Node_Str""));
  assertEquals(3,names.indexOf(""String_Node_Str""));
  assertEquals(0,names.lastIndexOf(""String_Node_Str""));
  assertEquals(1,names.lastIndexOf(""String_Node_Str""));
  assertEquals(2,names.lastIndexOf(""String_Node_Str""));
  assertEquals(3,names.lastIndexOf(""String_Node_Str""));
  names.setMode(SortedList.AVOID_MOVING_ELEMENTS);
  names.add(""String_Node_Str"");
  assertEquals(""String_Node_Str"",names.get(0));
  assertEquals(""String_Node_Str"",names.get(1));
  assertEquals(""String_Node_Str"",names.get(2));
  assertEquals(""String_Node_Str"",names.get(3));
  assertEquals(""String_Node_Str"",names.get(4));
  assertEquals(0,names.indexOf(""String_Node_Str""));
  assertEquals(1,names.indexOf(""String_Node_Str""));
  assertEquals(2,names.indexOf(""String_Node_Str""));
  assertEquals(3,names.indexOf(""String_Node_Str""));
  assertEquals(4,names.indexOf(""String_Node_Str""));
  assertEquals(0,names.lastIndexOf(""String_Node_Str""));
  assertEquals(1,names.lastIndexOf(""String_Node_Str""));
  assertEquals(2,names.lastIndexOf(""String_Node_Str""));
  assertEquals(3,names.lastIndexOf(""String_Node_Str""));
  assertEquals(4,names.lastIndexOf(""String_Node_Str""));
  names.set(1,""String_Node_Str"");
  assertEquals(""String_Node_Str"",names.get(0));
  assertEquals(""String_Node_Str"",names.get(1));
  assertEquals(""String_Node_Str"",names.get(2));
  assertEquals(""String_Node_Str"",names.get(3));
  assertEquals(""String_Node_Str"",names.get(4));
  assertEquals(0,names.indexOf(""String_Node_Str""));
  assertEquals(1,names.indexOf(""String_Node_Str""));
  assertEquals(2,names.indexOf(""String_Node_Str""));
  assertEquals(3,names.indexOf(""String_Node_Str""));
  assertEquals(4,names.indexOf(""String_Node_Str""));
  assertEquals(0,names.lastIndexOf(""String_Node_Str""));
  assertEquals(1,names.lastIndexOf(""String_Node_Str""));
  assertEquals(2,names.lastIndexOf(""String_Node_Str""));
  assertEquals(3,names.lastIndexOf(""String_Node_Str""));
  assertEquals(4,names.lastIndexOf(""String_Node_Str""));
}",0.8228591160220995
32478,"/** 
 * Cleanup all temporary variables necessary while events are being fired.
 */
private void cleanup(){
  eventThread=null;
  blockSequence.reset();
  listDeltas.reset(sourceList.size());
  reorderMap=null;
  listDeltas.setAllowContradictingEvents(false);
}","/** 
 * Cleanup all temporary variables necessary while events are being fired.
 */
private void cleanup(){
  eventThread=null;
  blockSequence.reset();
  listDeltas.reset(sourceList.size());
  reorderMap=null;
  listDeltas.setAllowContradictingEvents(false);
  listEvent.reset();
}",0.9613259668508288
32479,"/** 
 * When the components list changes, this updates the panel.
 */
public void listChanged(ListEvent listChanges){
  while (listChanges.next()) {
    int type=listChanges.getType();
    int index=listChanges.getIndex();
    if (type == ListEvent.INSERT) {
      insert(index);
    }
 else     if (type == ListEvent.DELETE) {
      delete(index);
    }
 else     if (type == ListEvent.UPDATE) {
      update(index);
    }
  }
  revalidate();
  repaint();
}","/** 
 * When the components list changes, this updates the panel.
 */
public void listChanged(ListEvent<E> listChanges){
  while (listChanges.next()) {
    int type=listChanges.getType();
    int index=listChanges.getIndex();
    if (type == ListEvent.INSERT) {
      insert(index);
    }
 else     if (type == ListEvent.DELETE) {
      delete(index);
    }
 else     if (type == ListEvent.UPDATE) {
      update(index);
    }
  }
  revalidate();
  repaint();
}",0.9967355821545156
32480,"/** 
 * Releases the resources consumed by this   {@link JEventListPanel} so that itmay eventually be garbage collected. <p><strong><font color=""#FF0000"">Warning:</font></strong> It is an error to call any method on a  {@link JEventListPanel} after it has been disposed.
 */
public void dispose(){
  swingSource.dispose();
}","/** 
 * Releases the resources consumed by this   {@link JEventListPanel} so that itmay eventually be garbage collected. <p><strong><font color=""#FF0000"">Warning:</font></strong> It is an error to call any method on a  {@link JEventListPanel} after it has been disposed.
 */
public void dispose(){
  swingSource.removeListEventListener(sourceChangeHandler);
  swingSource.dispose();
}",0.9152542372881356
32481,"public void start(){
  sillyObjects.add(""String_Node_Str"");
  sillyObjects.add(""String_Node_Str"");
  sillyObjects.add(""String_Node_Str"");
  JEventListPanel panel=new JEventListPanel(sillyObjects,new SillyObjectFormat());
  panel.setBorder(BorderFactory.createMatteBorder(5,5,5,5,Color.RED));
  panel.setElementColumns(1);
  JButton addButton=new JButton(""String_Node_Str"");
  addButton.addActionListener(new AddAction(sillyObjects));
  JFrame frame=new JFrame(""String_Node_Str"");
  frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
  frame.getContentPane().setLayout(new BorderLayout());
  frame.getContentPane().add(panel,BorderLayout.NORTH);
  frame.getContentPane().add(addButton,BorderLayout.SOUTH);
  frame.pack();
  frame.setVisible(true);
}","public void start(){
  sillyObjects.add(""String_Node_Str"");
  sillyObjects.add(""String_Node_Str"");
  sillyObjects.add(""String_Node_Str"");
  JEventListPanel<String> panel=new JEventListPanel<String>(sillyObjects,new SillyObjectFormat());
  panel.setBorder(BorderFactory.createMatteBorder(5,5,5,5,Color.RED));
  panel.setElementColumns(1);
  JButton addButton=new JButton(""String_Node_Str"");
  addButton.addActionListener(new AddAction(sillyObjects));
  JFrame frame=new JFrame(""String_Node_Str"");
  frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
  frame.getContentPane().setLayout(new BorderLayout());
  frame.getContentPane().add(panel,BorderLayout.NORTH);
  frame.getContentPane().add(addButton,BorderLayout.SOUTH);
  frame.pack();
  frame.setVisible(true);
}",0.9895833333333334
32482,"public JComponent getComponent(Object element,int component){
  final String sillyObject=(String)element;
  if (component == 0) {
    JButton button=new JButton(sillyObject);
    button.addActionListener(new ButtonActionListener(sillyObject));
    return button;
  }
 else   if (component == 1) {
    return new JSlider();
  }
 else   if (component == 2) {
    return new JTextField();
  }
 else {
    throw new IllegalStateException();
  }
}","public JComponent getComponent(String element,int component){
  final String sillyObject=element;
  if (component == 0) {
    JButton button=new JButton(sillyObject);
    button.addActionListener(new ButtonActionListener(sillyObject));
    return button;
  }
 else   if (component == 1) {
    return new JSlider();
  }
 else   if (component == 2) {
    return new JTextField();
  }
 else {
    throw new IllegalStateException();
  }
}",0.9771689497716894
32483,"public AddAction(EventList target){
  this.target=target;
}","public AddAction(EventList<String> target){
  this.target=target;
}",0.9365079365079364
32484,"public void run(){
  final String currentText=comboBoxEditorComponent.getText();
  final Object item=findAutoCompleteTerm(currentText);
  String itemText=convertToString(item);
  if (!currentText.equals(itemText)) {
    if (item == null && !allItemsUnfiltered.isEmpty())     itemText=convertToString(allItemsUnfiltered.get(0));
    comboBoxEditorComponent.setText(itemText);
  }
}","public void run(){
  final String currentText=comboBoxEditorComponent.getText();
  final Object item=findAutoCompleteTerm(currentText);
  String itemText=convertToString(item);
  if (!currentText.equals(itemText)) {
    if (item == NOT_FOUND && !allItemsUnfiltered.isEmpty())     itemText=convertToString(allItemsUnfiltered.get(0));
    comboBoxEditorComponent.setText(itemText);
  }
}",0.9830065359477124
32485,"/** 
 * Performs a linear scan of ALL ITEMS, regardless of the filtering state of the ComboBoxModel, to locate the autocomplete term. If an exact match of the given <code>value</code> can be found, then the item is returned. If an exact match cannot be found, the first term that <strong>starts with</strong> the given <code>value</code> is returned. <p>If no exact or partial match can be located, <code>null</code> is returned.
 */
private Object findAutoCompleteTerm(String value){
  final boolean prefixIsEmpty=""String_Node_Str"".equals(value);
  final Matcher<String> valueMatcher=new TextMatcher<String>(new SearchTerm[]{new SearchTerm(value)},GlazedLists.toStringTextFilterator(),TextMatcherEditor.STARTS_WITH,getTextMatchingStrategy());
  Object partialMatchItem=null;
  for (int i=0, n=allItemsUnfiltered.size(); i < n; i++) {
    final E item=allItemsUnfiltered.get(i);
    final String itemString=convertToString(item);
    if (value.equals(itemString))     return item;
    if (partialMatchItem == null) {
      if (prefixIsEmpty ? ""String_Node_Str"".equals(itemString) : valueMatcher.matches(itemString))       partialMatchItem=item;
    }
  }
  return partialMatchItem;
}","/** 
 * Performs a linear scan of ALL ITEMS, regardless of the filtering state of the ComboBoxModel, to locate the autocomplete term. If an exact match of the given <code>value</code> can be found, then the item is returned. If an exact match cannot be found, the first term that <strong>starts with</strong> the given <code>value</code> is returned. <p>If no exact or partial match can be located, <code>null</code> is returned.
 */
private Object findAutoCompleteTerm(String value){
  final boolean prefixIsEmpty=""String_Node_Str"".equals(value);
  final Matcher<String> valueMatcher=new TextMatcher<String>(new SearchTerm[]{new SearchTerm(value)},GlazedLists.toStringTextFilterator(),TextMatcherEditor.STARTS_WITH,getTextMatchingStrategy());
  Object partialMatchItem=NOT_FOUND;
  for (int i=0, n=allItemsUnfiltered.size(); i < n; i++) {
    final E item=allItemsUnfiltered.get(i);
    final String itemString=convertToString(item);
    if (value.equals(itemString))     return item;
    if (partialMatchItem == NOT_FOUND) {
      if (prefixIsEmpty ? ""String_Node_Str"".equals(itemString) : valueMatcher.matches(itemString))       partialMatchItem=item;
    }
  }
  return partialMatchItem;
}",0.9890572390572392
32486,"/** 
 * A convenience method to produce a String from the given <code>comboBoxElement</code>.
 */
private String convertToString(Object comboBoxElement){
  if (format != null)   return format.format(comboBoxElement);
  return comboBoxElement == null ? ""String_Node_Str"" : comboBoxElement.toString();
}","/** 
 * A convenience method to produce a String from the given <code>comboBoxElement</code>.
 */
private String convertToString(Object comboBoxElement){
  if (comboBoxElement == NOT_FOUND)   return ""String_Node_Str"";
  if (format != null)   return format.format(comboBoxElement);
  return comboBoxElement == null ? ""String_Node_Str"" : comboBoxElement.toString();
}",0.9039039039039038
32487,"/** 
 * This method generically post processes changes to the ComboBox editor's Document. The generic algorithm, regardless of the type of change, is as follows: <ol> <li> save the prefix as the user has entered it <li> filter the combo box items against the prefix <li> update the text in the combo box editor with an autocomplete suggestion <li> try to show the popup, if possible </ol>
 */
private void postProcessDocumentChange(FilterBypass filterBypass,AttributeSet attributeSet,String valueBeforeEdit,int selectionStart,int selectionEnd,boolean allowPartialAutoCompletionTerm) throws BadLocationException {
  if (doNotPostProcessDocumentChanges)   return;
  final String valueAfterEdit=comboBoxEditorComponent.getText();
  if (isStrict() && findAutoCompleteTerm(valueAfterEdit) == null && !allItemsUnfiltered.isEmpty()) {
    if (getBeepOnStrictViolation())     UIManager.getLookAndFeel().provideErrorFeedback(comboBoxEditorComponent);
    doNotPostProcessDocumentChanges=true;
    try {
      comboBoxEditorComponent.setText(valueBeforeEdit);
    }
  finally {
      doNotPostProcessDocumentChanges=false;
    }
    comboBoxEditorComponent.select(selectionStart,selectionEnd);
    return;
  }
  final Object selectedItemBeforeEdit=comboBox.getSelectedItem();
  updateFilter();
  applyFilter(prefix);
  selectAutoCompleteTerm(filterBypass,attributeSet,selectedItemBeforeEdit,allowPartialAutoCompletionTerm);
  togglePopup();
}","/** 
 * This method generically post processes changes to the ComboBox editor's Document. The generic algorithm, regardless of the type of change, is as follows: <ol> <li> save the prefix as the user has entered it <li> filter the combo box items against the prefix <li> update the text in the combo box editor with an autocomplete suggestion <li> try to show the popup, if possible </ol>
 */
private void postProcessDocumentChange(FilterBypass filterBypass,AttributeSet attributeSet,String valueBeforeEdit,int selectionStart,int selectionEnd,boolean allowPartialAutoCompletionTerm) throws BadLocationException {
  if (doNotPostProcessDocumentChanges)   return;
  final String valueAfterEdit=comboBoxEditorComponent.getText();
  if (isStrict() && (findAutoCompleteTerm(valueAfterEdit) == NOT_FOUND) && !allItemsUnfiltered.isEmpty()) {
    if (getBeepOnStrictViolation())     UIManager.getLookAndFeel().provideErrorFeedback(comboBoxEditorComponent);
    doNotPostProcessDocumentChanges=true;
    try {
      comboBoxEditorComponent.setText(valueBeforeEdit);
    }
  finally {
      doNotPostProcessDocumentChanges=false;
    }
    comboBoxEditorComponent.select(selectionStart,selectionEnd);
    return;
  }
  final Object selectedItemBeforeEdit=comboBox.getSelectedItem();
  updateFilter();
  applyFilter(prefix);
  selectAutoCompleteTerm(filterBypass,attributeSet,selectedItemBeforeEdit,allowPartialAutoCompletionTerm);
  togglePopup();
}",0.994775339602926
32488,"/** 
 * If <code>strict</code> is <tt>false</tt>, the user can specify values not appearing within the ComboBoxModel. If it is <tt>true</tt> each keystroke must continue to match some value in the ComboBoxModel or it will be discarded. <p>Note: When strict mode is enabled, all user input is corrected to the case of the autocompletion term, regardless of the correctsCase setting.
 * @see #setCorrectsCase(boolean)
 * @throws IllegalStateException if this method is called from any Threadother than the Swing Event Dispatch Thread
 */
public void setStrict(boolean strict){
  checkAccessThread();
  if (this.strict == strict)   return;
  this.strict=strict;
  if (strict) {
    final String currentText=comboBoxEditorComponent.getText();
    Object currentItem=findAutoCompleteTerm(currentText);
    String currentItemText=convertToString(currentItem);
    boolean itemMatches=currentItem == comboBox.getSelectedItem();
    boolean textMatches=GlazedListsImpl.equal(currentItemText,currentText);
    if (currentItem == null && !allItemsUnfiltered.isEmpty()) {
      currentItem=allItemsUnfiltered.get(0);
      currentItemText=convertToString(currentItem);
      itemMatches=currentItem == comboBox.getSelectedItem();
      textMatches=GlazedListsImpl.equal(currentItemText,currentText);
    }
    applyFilter(""String_Node_Str"");
    doNotPostProcessDocumentChanges=true;
    try {
      if (!textMatches)       comboBoxEditorComponent.setText(currentItemText);
      if (!itemMatches)       comboBox.setSelectedItem(currentItem);
    }
  finally {
      doNotPostProcessDocumentChanges=false;
    }
  }
}","/** 
 * If <code>strict</code> is <tt>false</tt>, the user can specify values not appearing within the ComboBoxModel. If it is <tt>true</tt> each keystroke must continue to match some value in the ComboBoxModel or it will be discarded. <p>Note: When strict mode is enabled, all user input is corrected to the case of the autocompletion term, regardless of the correctsCase setting.
 * @see #setCorrectsCase(boolean)
 * @throws IllegalStateException if this method is called from any Threadother than the Swing Event Dispatch Thread
 */
public void setStrict(boolean strict){
  checkAccessThread();
  if (this.strict == strict)   return;
  this.strict=strict;
  if (strict) {
    final String currentText=comboBoxEditorComponent.getText();
    Object currentItem=findAutoCompleteTerm(currentText);
    String currentItemText=convertToString(currentItem);
    boolean itemMatches=currentItem == comboBox.getSelectedItem();
    boolean textMatches=GlazedListsImpl.equal(currentItemText,currentText);
    if (currentItem == NOT_FOUND && !allItemsUnfiltered.isEmpty()) {
      currentItem=allItemsUnfiltered.get(0);
      currentItemText=convertToString(currentItem);
      itemMatches=currentItem == comboBox.getSelectedItem();
      textMatches=GlazedListsImpl.equal(currentItemText,currentText);
    }
    applyFilter(""String_Node_Str"");
    doNotPostProcessDocumentChanges=true;
    try {
      if (!textMatches)       comboBoxEditorComponent.setText(currentItemText);
      if (!itemMatches || comboBox.getSelectedIndex() == -1)       comboBox.setSelectedItem(currentItem);
    }
  finally {
      doNotPostProcessDocumentChanges=false;
    }
  }
}",0.979717271051014
32489,"/** 
 * When the data under a strict-mode AutoCompleting JComboBox is changed we must recheck the strict-mode invariant that the filter text matches (at least partially) an element in the ComboBoxModel. This test case verifies that the invariant is maintained while data changes underneath.
 */
public void testOnMainThreadChangingComboBoxDataRetainsStrictModeInvariant() throws Exception {
  final JComboBox combo=new JComboBox();
  final JTextField textField=(JTextField)combo.getEditor().getEditorComponent();
  final EventList<String> items=new BasicEventList<String>();
  items.add(""String_Node_Str"");
  SwingUtilities.invokeAndWait(new Runnable(){
    public void run(){
      final AutoCompleteSupport support=AutoCompleteSupport.install(combo,items);
      support.setStrict(true);
    }
  }
);
  assertEquals(""String_Node_Str"",textField.getText());
  assertEquals(""String_Node_Str"",combo.getSelectedItem());
  items.add(""String_Node_Str"");
  Thread.sleep(250);
  assertEquals(""String_Node_Str"",textField.getText());
  assertEquals(""String_Node_Str"",combo.getSelectedItem());
  items.set(1,""String_Node_Str"");
  Thread.sleep(250);
  assertEquals(""String_Node_Str"",textField.getText());
  assertEquals(""String_Node_Str"",combo.getSelectedItem());
  items.remove(1);
  Thread.sleep(250);
  assertEquals(""String_Node_Str"",textField.getText());
  assertEquals(""String_Node_Str"",combo.getSelectedItem());
  items.set(0,""String_Node_Str"");
  Thread.sleep(250);
  assertEquals(""String_Node_Str"",textField.getText());
  assertEquals(""String_Node_Str"",combo.getSelectedItem());
}","/** 
 * When the data under a strict-mode AutoCompleting JComboBox is changed we must recheck the strict-mode invariant that the filter text matches (at least partially) an element in the ComboBoxModel. This test case verifies that the invariant is maintained while data changes underneath.
 */
public void testOnMainThreadChangingComboBoxDataRetainsStrictModeInvariant() throws Exception {
  final JComboBox combo=new JComboBox();
  final JTextField textField=(JTextField)combo.getEditor().getEditorComponent();
  final EventList<String> basicItems=new BasicEventList<String>();
  final EventList<String> items=GlazedLists.threadSafeList(basicItems);
  items.add(""String_Node_Str"");
  SwingUtilities.invokeAndWait(new Runnable(){
    public void run(){
      final AutoCompleteSupport support=AutoCompleteSupport.install(combo,items);
      support.setStrict(true);
    }
  }
);
  assertEquals(""String_Node_Str"",textField.getText());
  assertEquals(""String_Node_Str"",combo.getSelectedItem());
  items.add(""String_Node_Str"");
  Thread.sleep(250);
  assertEquals(""String_Node_Str"",textField.getText());
  assertEquals(""String_Node_Str"",combo.getSelectedItem());
  items.set(1,""String_Node_Str"");
  Thread.sleep(250);
  assertEquals(""String_Node_Str"",textField.getText());
  assertEquals(""String_Node_Str"",combo.getSelectedItem());
  items.remove(1);
  Thread.sleep(250);
  assertEquals(""String_Node_Str"",textField.getText());
  assertEquals(""String_Node_Str"",combo.getSelectedItem());
  items.set(0,""String_Node_Str"");
  Thread.sleep(250);
  assertEquals(""String_Node_Str"",textField.getText());
  assertEquals(""String_Node_Str"",combo.getSelectedItem());
}",0.9755493655215104
32490,"public void guiTestStrictModeAndFirstItem() throws BadLocationException {
  final JComboBox combo=new JComboBox();
  final EventList<String> items=new BasicEventList<String>();
  items.add(""String_Node_Str"");
  items.add(""String_Node_Str"");
  items.add(""String_Node_Str"");
  items.add(""String_Node_Str"");
  AutoCompleteSupport support=AutoCompleteSupport.install(combo,items);
  final JTextField textField=(JTextField)combo.getEditor().getEditorComponent();
  assertNull(combo.getSelectedItem());
  support.setStrict(true);
  assertEquals(""String_Node_Str"",textField.getText());
  support.setStrict(false);
  support.setFirstItem(""String_Node_Str"");
  combo.setSelectedItem(null);
  assertNull(combo.getSelectedItem());
  support.setStrict(true);
  assertEquals(""String_Node_Str"",combo.getSelectedItem());
  assertEquals(0,combo.getSelectedIndex());
  support.setStrict(false);
  support.setFirstItem(null);
  combo.setSelectedItem(null);
  assertNull(combo.getSelectedItem());
  assertEquals(-1,combo.getSelectedIndex());
  support.setStrict(true);
  assertNull(combo.getSelectedItem());
  assertEquals(-1,combo.getSelectedIndex());
}","public void guiTestStrictModeAndFirstItem() throws BadLocationException {
  final JComboBox combo=new JComboBox();
  final EventList<String> items=new BasicEventList<String>();
  items.add(""String_Node_Str"");
  items.add(""String_Node_Str"");
  items.add(""String_Node_Str"");
  items.add(""String_Node_Str"");
  AutoCompleteSupport support=AutoCompleteSupport.install(combo,items);
  final JTextField textField=(JTextField)combo.getEditor().getEditorComponent();
  assertNull(combo.getSelectedItem());
  support.setStrict(true);
  assertEquals(""String_Node_Str"",textField.getText());
  support.setStrict(false);
  support.setFirstItem(""String_Node_Str"");
  combo.setSelectedItem(null);
  assertNull(combo.getSelectedItem());
  assertEquals(""String_Node_Str"",textField.getText());
  support.setStrict(true);
  assertEquals(""String_Node_Str"",combo.getSelectedItem());
  assertEquals(0,combo.getSelectedIndex());
  assertEquals(""String_Node_Str"",textField.getText());
  support.setStrict(false);
  support.setFirstItem(null);
  combo.setSelectedItem(null);
  assertNull(combo.getSelectedItem());
  assertEquals(-1,combo.getSelectedIndex());
  support.setStrict(true);
  assertNull(combo.getSelectedItem());
  assertEquals(-1,combo.getSelectedIndex());
  assertEquals(""String_Node_Str"",textField.getText());
}",0.891170431211499
32491,"/** 
 * This private constructor creates an AutoCompleteSupport object which adds autocompletion functionality to the given <code>comboBox</code>. In particular, a custom   {@link ComboBoxModel} is installed behind the<code>comboBox</code> containing the given <code>items</code>. The <code>filterator</code> is consulted in order to extract searchable text from each of the <code>items</code>. Non-null <code>format</code> objects are used to convert ComboBoxModel elements to Strings and back again for various functions like filtering, editing, and rendering.
 * @param comboBox the {@link JComboBox} to decorate with autocompletion
 * @param items the objects to display in the <code>comboBox</code>
 * @param filterator extracts searchable text strings from each item
 * @param format converts combobox elements into strings and vice versa
 */
private AutoCompleteSupport(JComboBox comboBox,EventList<E> items,TextFilterator<? super E> filterator,Format format){
  this.comboBox=comboBox;
  this.originalComboBoxEditable=comboBox.isEditable();
  this.originalModel=comboBox.getModel();
  this.items=items;
  this.format=format;
  final boolean defaultRendererInstalled=comboBox.getEditor() instanceof UIResource;
  this.renderer=format != null && defaultRendererInstalled ? new StringFunctionRenderer() : null;
  this.isTableCellEditor=Boolean.TRUE.equals(comboBox.getClientProperty(""String_Node_Str""));
  this.doNotTogglePopup=!isTableCellEditor;
  items.getReadWriteLock().readLock().lock();
  try {
    this.filterMatcherEditor=new TextMatcherEditor(filterator == null ? new DefaultTextFilterator() : filterator);
    this.filterMatcherEditor.setMode(TextMatcherEditor.STARTS_WITH);
    this.filteredItems=new FilterList<E>(items,this.filterMatcherEditor);
    this.firstItem=new BasicEventList<E>(items.getPublisher(),items.getReadWriteLock());
    this.allItemsFiltered=new CompositeList<E>(items.getPublisher(),items.getReadWriteLock());
    this.allItemsFiltered.addMemberList(this.firstItem);
    this.allItemsFiltered.addMemberList(this.filteredItems);
    this.comboBoxModel=new AutoCompleteComboBoxModel(this.allItemsFiltered);
    this.allItemsUnfiltered=new CompositeList<E>(items.getPublisher(),items.getReadWriteLock());
    this.allItemsUnfiltered.addMemberList(this.firstItem);
    this.allItemsUnfiltered.addMemberList(this.items);
  }
  finally {
    items.getReadWriteLock().readLock().unlock();
  }
  this.comboBox.setModel(this.comboBoxModel);
  this.comboBox.setEditable(true);
  decorateCurrentUI();
  this.comboBox.addPropertyChangeListener(""String_Node_Str"",this.uiWatcher);
  this.comboBox.addPropertyChangeListener(""String_Node_Str"",this.modelWatcher);
  this.comboBoxEditorComponent.addPropertyChangeListener(""String_Node_Str"",this.documentWatcher);
}","/** 
 * This private constructor creates an AutoCompleteSupport object which adds autocompletion functionality to the given <code>comboBox</code>. In particular, a custom   {@link ComboBoxModel} is installed behind the<code>comboBox</code> containing the given <code>items</code>. The <code>filterator</code> is consulted in order to extract searchable text from each of the <code>items</code>. Non-null <code>format</code> objects are used to convert ComboBoxModel elements to Strings and back again for various functions like filtering, editing, and rendering.
 * @param comboBox the {@link JComboBox} to decorate with autocompletion
 * @param items the objects to display in the <code>comboBox</code>
 * @param filterator extracts searchable text strings from each item
 * @param format converts combobox elements into strings and vice versa
 */
private AutoCompleteSupport(JComboBox comboBox,EventList<E> items,TextFilterator<? super E> filterator,Format format){
  this.comboBox=comboBox;
  this.originalComboBoxEditable=comboBox.isEditable();
  this.originalModel=comboBox.getModel();
  this.items=items;
  this.format=format;
  final boolean defaultRendererInstalled=comboBox.getRenderer() instanceof UIResource;
  this.renderer=format != null && defaultRendererInstalled ? new StringFunctionRenderer() : null;
  this.isTableCellEditor=Boolean.TRUE.equals(comboBox.getClientProperty(""String_Node_Str""));
  this.doNotTogglePopup=!isTableCellEditor;
  items.getReadWriteLock().readLock().lock();
  try {
    this.filterMatcherEditor=new TextMatcherEditor(filterator == null ? new DefaultTextFilterator() : filterator);
    this.filterMatcherEditor.setMode(TextMatcherEditor.STARTS_WITH);
    this.filteredItems=new FilterList<E>(items,this.filterMatcherEditor);
    this.firstItem=new BasicEventList<E>(items.getPublisher(),items.getReadWriteLock());
    this.allItemsFiltered=new CompositeList<E>(items.getPublisher(),items.getReadWriteLock());
    this.allItemsFiltered.addMemberList(this.firstItem);
    this.allItemsFiltered.addMemberList(this.filteredItems);
    this.comboBoxModel=new AutoCompleteComboBoxModel(this.allItemsFiltered);
    this.allItemsUnfiltered=new CompositeList<E>(items.getPublisher(),items.getReadWriteLock());
    this.allItemsUnfiltered.addMemberList(this.firstItem);
    this.allItemsUnfiltered.addMemberList(this.items);
  }
  finally {
    items.getReadWriteLock().readLock().unlock();
  }
  this.comboBox.setModel(this.comboBoxModel);
  this.comboBox.setEditable(true);
  decorateCurrentUI();
  this.comboBox.addPropertyChangeListener(""String_Node_Str"",this.uiWatcher);
  this.comboBox.addPropertyChangeListener(""String_Node_Str"",this.modelWatcher);
  this.comboBoxEditorComponent.addPropertyChangeListener(""String_Node_Str"",this.documentWatcher);
}",0.9978463747307968
32492,"public AutoCompleteSupportComplexTestApp(){
  final EventList<Location> locations=new BasicEventList<Location>();
  locations.addAll(Arrays.asList(AutoCompleteSupportComplexTestApp.STATE_CAPITALS_DATA));
  final EventList<Location> locationProxyList=GlazedListsSwing.swingThreadProxyList(locations);
  final String[] propertyNames={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  final String[] columnLabels={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  final boolean[] writable={true,true,true};
  final TableFormat<Location> tableFormat=GlazedLists.tableFormat(propertyNames,columnLabels,writable);
  table.setModel(new DefaultEventTableModel<AutoCompleteSupportComplexTestApp.Location>(locationProxyList,tableFormat));
  for (int i=0; i < propertyNames.length; i++) {
    final DefaultCellEditor cellEditor=AutoCompleteSupport.createTableCellEditor(tableFormat,locations,i);
    table.getColumnModel().getColumn(i).setCellEditor(cellEditor);
  }
  autocompleteActionList.setPrototypeCellValue(""String_Node_Str"");
  autocompleteActionList.setPreferredSize(new Dimension(autocompleteActionList.getPreferredSize().width,600));
  autoCompleteComboBox.addActionListener(new AutoCompleteSupportComplexTestApp.RecordActionHandler(autocompleteActionListModel));
  autocompleteActionPanel=createActionPanel(""String_Node_Str"",autocompleteActionList);
  regularActionList.setPrototypeCellValue(""String_Node_Str"");
  regularActionList.setPreferredSize(new Dimension(regularActionList.getPreferredSize().width,600));
  regularComboBox.addActionListener(new AutoCompleteSupportComplexTestApp.RecordActionHandler(regularActionListModel));
  regularActionPanel=createActionPanel(""String_Node_Str"",regularActionList);
  tweakerPanel=createTweakerPanel();
  frame=new JFrame(""String_Node_Str"");
  frame.setJMenuBar(createLafMenuBar());
  frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  frame.getContentPane().setLayout(new BorderLayout());
  rebuildContentPane();
  correctsCaseCheckBox.addActionListener(new CorrectCaseActionHandler());
  correctsCaseCheckBox.setSelected(autoCompleteSupport.getCorrectsCase());
  strictModeCheckBox.addActionListener(new StrictModeActionHandler());
  strictModeCheckBox.setSelected(autoCompleteSupport.isStrict());
  selectTextOnFocusGainCheckBox.addActionListener(new SelectTextOnFocusGainActionHandler());
  selectTextOnFocusGainCheckBox.setSelected(autoCompleteSupport.getSelectsTextOnFocusGain());
  hidesPopupOnFocusLostCheckBox.addActionListener(new HidePopupOnFocusLostActionHandler());
  hidesPopupOnFocusLostCheckBox.setSelected(autoCompleteSupport.getHidesPopupOnFocusLost());
  frame.pack();
  frame.setLocationRelativeTo(null);
  frame.setVisible(true);
}","public AutoCompleteSupportComplexTestApp(){
  final EventList<Location> locations=new BasicEventList<Location>();
  locations.addAll(Arrays.asList(AutoCompleteSupportComplexTestApp.STATE_CAPITALS_DATA));
  final EventList<Location> locationProxyList=GlazedListsSwing.swingThreadProxyList(locations);
  final String[] propertyNames={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  final String[] columnLabels={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  final boolean[] writable={true,true,true};
  final TableFormat<Location> tableFormat=GlazedLists.tableFormat(propertyNames,columnLabels,writable);
  table.setModel(new DefaultEventTableModel<AutoCompleteSupportComplexTestApp.Location>(locationProxyList,tableFormat));
  for (int i=0; i < propertyNames.length; i++) {
    final DefaultCellEditor cellEditor=AutoCompleteSupport.createTableCellEditor(tableFormat,locations,i);
    table.getColumnModel().getColumn(i).setCellEditor(cellEditor);
  }
  autocompleteActionList.setPrototypeCellValue(""String_Node_Str"");
  autocompleteActionList.setPreferredSize(new Dimension(autocompleteActionList.getPreferredSize().width,600));
  autoCompleteComboBox.setRenderer(new UrlListCellRenderer());
  autoCompleteComboBox.addActionListener(new AutoCompleteSupportComplexTestApp.RecordActionHandler(autocompleteActionListModel));
  autocompleteActionPanel=createActionPanel(""String_Node_Str"",autocompleteActionList);
  regularActionList.setPrototypeCellValue(""String_Node_Str"");
  regularActionList.setPreferredSize(new Dimension(regularActionList.getPreferredSize().width,600));
  regularComboBox.setRenderer(new UrlListCellRenderer());
  regularComboBox.addActionListener(new AutoCompleteSupportComplexTestApp.RecordActionHandler(regularActionListModel));
  regularActionPanel=createActionPanel(""String_Node_Str"",regularActionList);
  tweakerPanel=createTweakerPanel();
  frame=new JFrame(""String_Node_Str"");
  frame.setJMenuBar(createLafMenuBar());
  frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  frame.getContentPane().setLayout(new BorderLayout());
  rebuildContentPane();
  correctsCaseCheckBox.addActionListener(new CorrectCaseActionHandler());
  correctsCaseCheckBox.setSelected(autoCompleteSupport.getCorrectsCase());
  strictModeCheckBox.addActionListener(new StrictModeActionHandler());
  strictModeCheckBox.setSelected(autoCompleteSupport.isStrict());
  selectTextOnFocusGainCheckBox.addActionListener(new SelectTextOnFocusGainActionHandler());
  selectTextOnFocusGainCheckBox.setSelected(autoCompleteSupport.getSelectsTextOnFocusGain());
  hidesPopupOnFocusLostCheckBox.addActionListener(new HidePopupOnFocusLostActionHandler());
  hidesPopupOnFocusLostCheckBox.setSelected(autoCompleteSupport.getHidesPopupOnFocusLost());
  frame.pack();
  frame.setLocationRelativeTo(null);
  frame.setVisible(true);
}",0.9782256613280548
32493,"public void guiTestUninstall(){
  final JComboBox combo=new JComboBox();
  final EventList<Object> items=new BasicEventList<Object>();
  items.add(""String_Node_Str"");
  items.add(""String_Node_Str"");
  final ComboBoxUI originalUI=combo.getUI();
  final ComboBoxModel originalModel=combo.getModel();
  final boolean originalEditable=combo.isEditable();
  final ComboBoxEditor originalEditor=combo.getEditor();
  final int originalEditorKeyListenerCount=originalEditor.getEditorComponent().getKeyListeners().length;
  final AbstractDocument originalEditorDocument=(AbstractDocument)((JTextField)combo.getEditor().getEditorComponent()).getDocument();
  final int originalComboBoxPropertyChangeListenerCount=combo.getPropertyChangeListeners().length;
  final int originalComboBoxPopupMouseListenerCount=((ComboPopup)combo.getUI().getAccessibleChild(combo,0)).getList().getMouseListeners().length;
  final int originalMaxRowCount=combo.getMaximumRowCount();
  final int originalComboBoxPopupMenuListenerCount=((JPopupMenu)combo.getUI().getAccessibleChild(combo,0)).getPopupMenuListeners().length;
  final Action originalSelectNextAction=combo.getActionMap().get(""String_Node_Str"");
  final Action originalSelectPreviousAction=combo.getActionMap().get(""String_Node_Str"");
  final Action originalSelectNext2Action=combo.getActionMap().get(""String_Node_Str"");
  final Action originalSelectPrevious2Action=combo.getActionMap().get(""String_Node_Str"");
  final Action originalAquaSelectNextAction=combo.getActionMap().get(""String_Node_Str"");
  final Action originalAquaSelectPreviousAction=combo.getActionMap().get(""String_Node_Str"");
  AutoCompleteSupport support=AutoCompleteSupport.install(combo,items);
  JTextField currentEditor=((JTextField)combo.getEditor().getEditorComponent());
  AbstractDocument currentEditorDocument=(AbstractDocument)currentEditor.getDocument();
  assertSame(originalUI,combo.getUI());
  assertSame(currentEditorDocument,originalEditorDocument);
  assertNotSame(originalEditor,combo.getEditor());
  assertNotSame(originalModel,combo.getModel());
  assertEquals(!originalEditable,combo.isEditable());
  assertNotSame(originalSelectNextAction,combo.getActionMap().get(""String_Node_Str""));
  assertNotSame(originalSelectPreviousAction,combo.getActionMap().get(""String_Node_Str""));
  assertNotSame(originalSelectNext2Action,combo.getActionMap().get(""String_Node_Str""));
  assertNotSame(originalSelectPrevious2Action,combo.getActionMap().get(""String_Node_Str""));
  assertNotSame(originalAquaSelectNextAction,combo.getActionMap().get(""String_Node_Str""));
  assertNotSame(originalAquaSelectPreviousAction,combo.getActionMap().get(""String_Node_Str""));
  assertNotNull(currentEditorDocument.getDocumentFilter());
  assertEquals(originalComboBoxPropertyChangeListenerCount + 2,combo.getPropertyChangeListeners().length);
  assertEquals(originalComboBoxPopupMenuListenerCount + 2,((JPopupMenu)combo.getUI().getAccessibleChild(combo,0)).getPopupMenuListeners().length);
  assertEquals(originalComboBoxPopupMouseListenerCount + 1,((ComboPopup)combo.getUI().getAccessibleChild(combo,0)).getList().getMouseListeners().length);
  assertEquals(originalEditorKeyListenerCount + 1,currentEditor.getKeyListeners().length);
  support.uninstall();
  currentEditor=((JTextField)combo.getEditor().getEditorComponent());
  currentEditorDocument=(AbstractDocument)currentEditor.getDocument();
  assertSame(originalUI,combo.getUI());
  assertSame(originalModel,combo.getModel());
  assertEquals(originalEditable,combo.isEditable());
  assertSame(originalEditor,combo.getEditor());
  assertSame(originalEditorDocument,currentEditorDocument);
  assertSame(currentEditorDocument.getDocumentFilter(),null);
  assertEquals(originalComboBoxPropertyChangeListenerCount,combo.getPropertyChangeListeners().length);
  assertEquals(originalEditorKeyListenerCount,currentEditor.getKeyListeners().length);
  assertEquals(originalMaxRowCount,combo.getMaximumRowCount());
  assertEquals(originalComboBoxPopupMenuListenerCount,((JPopupMenu)combo.getUI().getAccessibleChild(combo,0)).getPopupMenuListeners().length);
  assertEquals(originalComboBoxPopupMouseListenerCount,((ComboPopup)combo.getUI().getAccessibleChild(combo,0)).getList().getMouseListeners().length);
  assertSame(originalSelectNextAction,combo.getActionMap().get(""String_Node_Str""));
  assertSame(originalSelectPreviousAction,combo.getActionMap().get(""String_Node_Str""));
  assertSame(originalSelectNext2Action,combo.getActionMap().get(""String_Node_Str""));
  assertSame(originalSelectPrevious2Action,combo.getActionMap().get(""String_Node_Str""));
  assertSame(originalAquaSelectNextAction,combo.getActionMap().get(""String_Node_Str""));
  assertSame(originalAquaSelectPreviousAction,combo.getActionMap().get(""String_Node_Str""));
  try {
    support.uninstall();
    fail(""String_Node_Str"");
  }
 catch (  IllegalStateException e) {
  }
}","public void guiTestUninstall(){
  final JComboBox combo=new JComboBox();
  final EventList<Object> items=new BasicEventList<Object>();
  items.add(""String_Node_Str"");
  items.add(""String_Node_Str"");
  final ComboBoxUI originalUI=combo.getUI();
  final ComboBoxModel originalModel=combo.getModel();
  final boolean originalEditable=combo.isEditable();
  final ListCellRenderer originalRenderer=combo.getRenderer();
  final ComboBoxEditor originalEditor=combo.getEditor();
  final int originalEditorKeyListenerCount=originalEditor.getEditorComponent().getKeyListeners().length;
  final AbstractDocument originalEditorDocument=(AbstractDocument)((JTextField)combo.getEditor().getEditorComponent()).getDocument();
  final int originalComboBoxPropertyChangeListenerCount=combo.getPropertyChangeListeners().length;
  final int originalComboBoxPopupMouseListenerCount=((ComboPopup)combo.getUI().getAccessibleChild(combo,0)).getList().getMouseListeners().length;
  final int originalMaxRowCount=combo.getMaximumRowCount();
  final int originalComboBoxPopupMenuListenerCount=((JPopupMenu)combo.getUI().getAccessibleChild(combo,0)).getPopupMenuListeners().length;
  final Action originalSelectNextAction=combo.getActionMap().get(""String_Node_Str"");
  final Action originalSelectPreviousAction=combo.getActionMap().get(""String_Node_Str"");
  final Action originalSelectNext2Action=combo.getActionMap().get(""String_Node_Str"");
  final Action originalSelectPrevious2Action=combo.getActionMap().get(""String_Node_Str"");
  final Action originalAquaSelectNextAction=combo.getActionMap().get(""String_Node_Str"");
  final Action originalAquaSelectPreviousAction=combo.getActionMap().get(""String_Node_Str"");
  AutoCompleteSupport support=AutoCompleteSupport.install(combo,items);
  JTextField currentEditor=((JTextField)combo.getEditor().getEditorComponent());
  AbstractDocument currentEditorDocument=(AbstractDocument)currentEditor.getDocument();
  ListCellRenderer currentRenderer=combo.getRenderer();
  assertSame(originalUI,combo.getUI());
  assertSame(currentEditorDocument,originalEditorDocument);
  assertSame(originalRenderer,currentRenderer);
  assertNotSame(originalEditor,combo.getEditor());
  assertNotSame(originalModel,combo.getModel());
  assertEquals(!originalEditable,combo.isEditable());
  assertNotSame(originalSelectNextAction,combo.getActionMap().get(""String_Node_Str""));
  assertNotSame(originalSelectPreviousAction,combo.getActionMap().get(""String_Node_Str""));
  assertNotSame(originalSelectNext2Action,combo.getActionMap().get(""String_Node_Str""));
  assertNotSame(originalSelectPrevious2Action,combo.getActionMap().get(""String_Node_Str""));
  assertNotSame(originalAquaSelectNextAction,combo.getActionMap().get(""String_Node_Str""));
  assertNotSame(originalAquaSelectPreviousAction,combo.getActionMap().get(""String_Node_Str""));
  assertNotNull(currentEditorDocument.getDocumentFilter());
  assertEquals(originalComboBoxPropertyChangeListenerCount + 2,combo.getPropertyChangeListeners().length);
  assertEquals(originalComboBoxPopupMenuListenerCount + 2,((JPopupMenu)combo.getUI().getAccessibleChild(combo,0)).getPopupMenuListeners().length);
  assertEquals(originalComboBoxPopupMouseListenerCount + 1,((ComboPopup)combo.getUI().getAccessibleChild(combo,0)).getList().getMouseListeners().length);
  assertEquals(originalEditorKeyListenerCount + 1,currentEditor.getKeyListeners().length);
  support.uninstall();
  currentEditor=((JTextField)combo.getEditor().getEditorComponent());
  currentEditorDocument=(AbstractDocument)currentEditor.getDocument();
  currentRenderer=combo.getRenderer();
  assertSame(originalUI,combo.getUI());
  assertSame(originalModel,combo.getModel());
  assertEquals(originalEditable,combo.isEditable());
  assertSame(originalEditor,combo.getEditor());
  assertSame(originalRenderer,currentRenderer);
  assertSame(originalEditorDocument,currentEditorDocument);
  assertSame(currentEditorDocument.getDocumentFilter(),null);
  assertEquals(originalComboBoxPropertyChangeListenerCount,combo.getPropertyChangeListeners().length);
  assertEquals(originalEditorKeyListenerCount,currentEditor.getKeyListeners().length);
  assertEquals(originalMaxRowCount,combo.getMaximumRowCount());
  assertEquals(originalComboBoxPopupMenuListenerCount,((JPopupMenu)combo.getUI().getAccessibleChild(combo,0)).getPopupMenuListeners().length);
  assertEquals(originalComboBoxPopupMouseListenerCount,((ComboPopup)combo.getUI().getAccessibleChild(combo,0)).getList().getMouseListeners().length);
  assertSame(originalSelectNextAction,combo.getActionMap().get(""String_Node_Str""));
  assertSame(originalSelectPreviousAction,combo.getActionMap().get(""String_Node_Str""));
  assertSame(originalSelectNext2Action,combo.getActionMap().get(""String_Node_Str""));
  assertSame(originalSelectPrevious2Action,combo.getActionMap().get(""String_Node_Str""));
  assertSame(originalAquaSelectNextAction,combo.getActionMap().get(""String_Node_Str""));
  assertSame(originalAquaSelectPreviousAction,combo.getActionMap().get(""String_Node_Str""));
  try {
    support.uninstall();
    fail(""String_Node_Str"");
  }
 catch (  IllegalStateException e) {
  }
}",0.9746101559376248
32494,"/** 
 * Creates a new   {@link EventList} which contains the contents of the specified{@link Collection}. The   {@link EventList}'s order will be determined by  {@link Collection#iterator() contents.iterator()}.
 */
public static <E>EventList<E> eventList(Collection<? extends E> contents){
  final EventList<E> result=new BasicEventList<E>(contents == null ? 0 : contents.size());
  if (contents != null)   result.addAll(contents);
  return result;
}","/** 
 * Creates a new   {@link EventList} with the given {@link ListEventPublisher} and{@link ReadWriteLock} which contains the contents of the specified{@link Collection}. The   {@link EventList}'s order will be determined by  {@link Collection#iterator() contents.iterator()}.
 * @param publisher the {@link ListEventPublisher} for the new list, may be <code>null</code>
 * @param lock the {@link ReadWriteLock} for the new list, may be <code>null</code>
 * @param contents the collection with list elements, if <code>null</code> the result will bean empty list
 */
public static <E>EventList<E> eventList(ListEventPublisher publisher,ReadWriteLock lock,Collection<? extends E> contents){
  final EventList<E> result=new BasicEventList<E>(contents == null ? 0 : contents.size(),publisher,lock);
  if (contents != null)   result.addAll(contents);
  return result;
}",0.683371298405467
32495,"/** 
 * Creates a new   {@link EventList} which contains the given elements.
 */
public static <E>EventList<E> eventListOf(E... contents){
  return eventList(contents == null ? Collections.<E>emptyList() : Arrays.asList(contents));
}","/** 
 * Creates a new   {@link EventList} with the given {@link ListEventPublisher} and{@link ReadWriteLock} which contains the given elements.
 * @param publisher the {@link ListEventPublisher} for the new list, may be <code>null</code>
 * @param lock the {@link ReadWriteLock} for the new list, may be <code>null</code>
 * @param contents the list elements, if <code>null</code> the result will be an empty list
 * @return the new {@link EventList}
 */
public static <E>EventList<E> eventListOf(ListEventPublisher publisher,ReadWriteLock lock,E... contents){
  return eventList(publisher,lock,contents == null ? Collections.<E>emptyList() : Arrays.asList(contents));
}",0.4872646733111849
32496,"/** 
 * Test that the   {@link GlazedLists#eventList(java.util.Collection)} factorymethod works.
 * @see <a href=""https://glazedlists.dev.java.net/issues/show_bug.cgi?id=234"">Bug 234</a>
 */
public void testGlazedListsEventList(){
  List<String> list=new ArrayList<String>();
  EventList<String> eventList=GlazedLists.eventList(list);
  assertEquals(list,eventList);
  list.add(""String_Node_Str"");
  assertTrue(!list.equals(eventList));
  eventList.add(""String_Node_Str"");
  assertTrue(!list.equals(eventList));
  EventList<String> empty=GlazedLists.eventList((Collection)null);
  assertEquals(Collections.EMPTY_LIST,empty);
}","/** 
 * Test that the   {@link GlazedLists#eventList(java.util.Collection)} factorymethod works.
 * @see <a href=""https://glazedlists.dev.java.net/issues/show_bug.cgi?id=234"">Bug 234</a>
 */
public void testGlazedListsEventList(){
  final List<String> list=new ArrayList<String>();
  EventList<String> eventList=GlazedLists.eventList(list);
  assertEquals(list,eventList);
  list.add(""String_Node_Str"");
  assertTrue(!list.equals(eventList));
  eventList.add(""String_Node_Str"");
  assertTrue(!list.equals(eventList));
  final EventList<String> empty=GlazedLists.eventList((Collection<String>)null);
  assertEquals(Collections.EMPTY_LIST,empty);
}",0.9842767295597484
32497,"/** 
 * Test that the   {@link GlazedLists#eventListOf(Object[])} factorymethod works.
 */
public void testGlazedListsEventListUsingVarArgs(){
  EventList<String> eventList=GlazedLists.eventListOf(""String_Node_Str"",""String_Node_Str"");
  assertEquals(Arrays.asList(""String_Node_Str"",""String_Node_Str""),eventList);
  EventList<String> empty=GlazedLists.eventListOf((String[])null);
  assertEquals(Collections.EMPTY_LIST,empty);
}","/** 
 * Test that the   {@link GlazedLists#eventListOf(Object)} factorymethod works.
 */
public void testGlazedListsEventListUsingVarArgs(){
  final EventList<String> eventList=GlazedLists.eventListOf(""String_Node_Str"",""String_Node_Str"");
  assertEquals(Arrays.asList(""String_Node_Str"",""String_Node_Str""),eventList);
  final EventList<String> empty=GlazedLists.eventListOf((String[])null);
  assertEquals(Collections.EMPTY_LIST,empty);
}",0.9837962962962964
32498,"/** 
 * Handle changes from the   {@link SortedList} by modifying the grouping state.During this method, callbacks will be made to the  {@link Client} who isresponsible for firing the appropriate change events to its listeners.
 */
public void listChanged(ListEvent<E> listChanges){
  final Barcode toDoList=new Barcode();
  toDoList.addWhite(0,barcode.size());
  final LinkedList removedValues=new LinkedList();
  while (listChanges.next()) {
    final int changeIndex=listChanges.getIndex();
    final int changeType=listChanges.getType();
    if (changeType == ListEvent.INSERT) {
      barcode.add(changeIndex,UNIQUE,1);
      toDoList.add(changeIndex,TODO,1);
    }
 else     if (changeType == ListEvent.UPDATE) {
      if (barcode.get(changeIndex) == UNIQUE) {
        if (changeIndex + 1 < barcode.size() && barcode.get(changeIndex + 1) == DUPLICATE) {
          barcode.set(changeIndex,UNIQUE,2);
          toDoList.set(changeIndex,TODO,1);
        }
      }
    }
 else     if (changeType == ListEvent.DELETE) {
      Object deleted=barcode.get(changeIndex);
      barcode.remove(changeIndex,1);
      toDoList.remove(changeIndex,1);
      if (deleted == UNIQUE) {
        if (changeIndex < barcode.size() && barcode.get(changeIndex) == DUPLICATE) {
          barcode.set(changeIndex,UNIQUE,1);
          deleted=UNIQUE_WITH_DUPLICATE;
        }
      }
      removedValues.addLast(deleted);
    }
  }
  TryJoinResult<E> tryJoinResult=new TryJoinResult<E>();
  listChanges.reset();
  while (listChanges.next()) {
    final int changeIndex=listChanges.getIndex();
    final int changeType=listChanges.getType();
    E newValue=listChanges.getNewValue();
    E oldValue=listChanges.getOldValue();
    if (changeType == ListEvent.INSERT) {
      tryJoinExistingGroup(changeIndex,toDoList,tryJoinResult);
      if (tryJoinResult.group == NO_GROUP) {
        client.groupChanged(changeIndex,tryJoinResult.groupIndex,ListEvent.INSERT,true,changeType,ListEvent.<E>unknownValue(),tryJoinResult.newFirstInGroup);
      }
 else {
        client.groupChanged(changeIndex,tryJoinResult.groupIndex,ListEvent.UPDATE,true,changeType,tryJoinResult.oldFirstInGroup,tryJoinResult.newFirstInGroup);
      }
    }
 else     if (changeType == ListEvent.UPDATE) {
      int oldGroup=0;
      if (toDoList.get(changeIndex) == TODO)       oldGroup=RIGHT_GROUP;
 else       if (barcode.get(changeIndex) == DUPLICATE)       oldGroup=LEFT_GROUP;
 else       if (barcode.get(changeIndex) == UNIQUE)       oldGroup=NO_GROUP;
      tryJoinExistingGroup(changeIndex,toDoList,tryJoinResult);
      int groupIndex=tryJoinResult.groupIndex;
      if (tryJoinResult.group == NO_GROUP) {
        if (oldGroup == NO_GROUP) {
          client.groupChanged(changeIndex,groupIndex,ListEvent.UPDATE,true,changeType,oldValue,tryJoinResult.newFirstInGroup);
        }
 else         if (oldGroup == LEFT_GROUP) {
          E firstFromPreviousGroup=sortedList.get(barcode.getIndex(groupIndex - 1,UNIQUE));
          client.groupChanged(changeIndex,groupIndex - 1,ListEvent.UPDATE,false,changeType,firstFromPreviousGroup,firstFromPreviousGroup);
          client.groupChanged(changeIndex,groupIndex,ListEvent.INSERT,true,changeType,ListEvent.<E>unknownValue(),tryJoinResult.newFirstInGroup);
        }
 else         if (oldGroup == RIGHT_GROUP) {
          E firstFromNextGroup=sortedList.get(barcode.getIndex(groupIndex + 1,UNIQUE));
          client.groupChanged(changeIndex,groupIndex,ListEvent.INSERT,true,changeType,ListEvent.<E>unknownValue(),tryJoinResult.newFirstInGroup);
          client.groupChanged(changeIndex,groupIndex + 1,ListEvent.UPDATE,false,changeType,oldValue,firstFromNextGroup);
        }
      }
 else       if (tryJoinResult.group == LEFT_GROUP) {
        if (oldGroup == NO_GROUP) {
          client.groupChanged(changeIndex,groupIndex,ListEvent.UPDATE,true,changeType,tryJoinResult.oldFirstInGroup,tryJoinResult.newFirstInGroup);
          client.groupChanged(changeIndex,groupIndex + 1,ListEvent.DELETE,false,changeType,oldValue,ListEvent.<E>unknownValue());
        }
 else         if (oldGroup == LEFT_GROUP) {
          client.groupChanged(changeIndex,groupIndex,ListEvent.UPDATE,true,changeType,tryJoinResult.oldFirstInGroup,tryJoinResult.newFirstInGroup);
        }
 else         if (oldGroup == RIGHT_GROUP) {
          client.groupChanged(changeIndex,groupIndex,ListEvent.UPDATE,true,changeType,tryJoinResult.oldFirstInGroup,tryJoinResult.newFirstInGroup);
          if (groupIndex + 1 < barcode.blackSize()) {
            E firstFromNextGroup=sortedList.get(barcode.getIndex(groupIndex + 1,UNIQUE));
            client.groupChanged(changeIndex,groupIndex + 1,ListEvent.UPDATE,false,changeType,oldValue,firstFromNextGroup);
          }
        }
      }
 else       if (tryJoinResult.group == RIGHT_GROUP) {
        if (oldGroup == NO_GROUP) {
          client.groupChanged(changeIndex,groupIndex,ListEvent.DELETE,false,changeType,oldValue,ListEvent.<E>unknownValue());
          client.groupChanged(changeIndex,groupIndex,ListEvent.UPDATE,true,changeType,tryJoinResult.oldFirstInGroup,tryJoinResult.newFirstInGroup);
        }
 else         if (oldGroup == LEFT_GROUP) {
          if (groupIndex - 1 >= 0) {
            E firstFromPreviousGroup=sortedList.get(barcode.getIndex(groupIndex - 1,UNIQUE));
            client.groupChanged(changeIndex,groupIndex - 1,ListEvent.UPDATE,false,changeType,firstFromPreviousGroup,firstFromPreviousGroup);
          }
          client.groupChanged(changeIndex,groupIndex,ListEvent.UPDATE,true,changeType,tryJoinResult.oldFirstInGroup,tryJoinResult.newFirstInGroup);
        }
 else         if (oldGroup == RIGHT_GROUP) {
          client.groupChanged(changeIndex,groupIndex,ListEvent.UPDATE,true,changeType,tryJoinResult.oldFirstInGroup,tryJoinResult.newFirstInGroup);
        }
      }
    }
 else     if (changeType == ListEvent.DELETE) {
      final Object deleted=removedValues.removeFirst();
      final int sourceDeletedIndex=deleted == DUPLICATE ? changeIndex - 1 : changeIndex;
      final int groupDeletedIndex=sourceDeletedIndex < barcode.size() ? barcode.getBlackIndex(sourceDeletedIndex,true) : barcode.blackSize();
      if (deleted == UNIQUE) {
        client.groupChanged(changeIndex,groupDeletedIndex,ListEvent.DELETE,true,changeType,oldValue,ListEvent.<E>unknownValue());
      }
 else {
        E oldValueInGroup;
        E newValueInGroup;
        if (groupDeletedIndex < barcode.blackSize()) {
          int firstInGroupIndex=barcode.getIndex(groupDeletedIndex,UNIQUE);
          newValueInGroup=sortedList.get(firstInGroupIndex);
        }
 else {
          newValueInGroup=ListEvent.<E>unknownValue();
        }
        if (deleted == UNIQUE_WITH_DUPLICATE) {
          oldValueInGroup=oldValue;
        }
 else {
          oldValueInGroup=newValueInGroup;
        }
        client.groupChanged(changeIndex,groupDeletedIndex,ListEvent.UPDATE,true,changeType,oldValueInGroup,newValueInGroup);
      }
    }
  }
}","/** 
 * Handle changes from the   {@link SortedList} by modifying the grouping state.During this method, callbacks will be made to the  {@link Client} who isresponsible for firing the appropriate change events to its listeners.
 */
public void listChanged(ListEvent<E> listChanges){
  final Barcode toDoList=new Barcode();
  toDoList.addWhite(0,barcode.size());
  final LinkedList removedValues=new LinkedList();
  int lastFakedUniqueChangeIndex=-1;
  while (listChanges.next()) {
    final int changeIndex=listChanges.getIndex();
    final int changeType=listChanges.getType();
    if (changeType == ListEvent.INSERT) {
      barcode.add(changeIndex,UNIQUE,1);
      toDoList.add(changeIndex,TODO,1);
    }
 else     if (changeType == ListEvent.UPDATE) {
      if (barcode.get(changeIndex) == UNIQUE) {
        if (changeIndex + 1 < barcode.size() && barcode.get(changeIndex + 1) == DUPLICATE) {
          if (changeIndex != lastFakedUniqueChangeIndex) {
            barcode.set(changeIndex,UNIQUE,2);
            toDoList.set(changeIndex,TODO,1);
            lastFakedUniqueChangeIndex=changeIndex + 1;
          }
        }
      }
    }
 else     if (changeType == ListEvent.DELETE) {
      Object deleted=barcode.get(changeIndex);
      barcode.remove(changeIndex,1);
      toDoList.remove(changeIndex,1);
      if (deleted == UNIQUE) {
        if (changeIndex < barcode.size() && barcode.get(changeIndex) == DUPLICATE) {
          barcode.set(changeIndex,UNIQUE,1);
          deleted=UNIQUE_WITH_DUPLICATE;
        }
      }
      removedValues.addLast(deleted);
    }
  }
  TryJoinResult<E> tryJoinResult=new TryJoinResult<E>();
  listChanges.reset();
  while (listChanges.next()) {
    final int changeIndex=listChanges.getIndex();
    final int changeType=listChanges.getType();
    E newValue=listChanges.getNewValue();
    E oldValue=listChanges.getOldValue();
    if (changeType == ListEvent.INSERT) {
      tryJoinExistingGroup(changeIndex,toDoList,tryJoinResult);
      if (tryJoinResult.group == NO_GROUP) {
        client.groupChanged(changeIndex,tryJoinResult.groupIndex,ListEvent.INSERT,true,changeType,ListEvent.<E>unknownValue(),tryJoinResult.newFirstInGroup);
      }
 else {
        client.groupChanged(changeIndex,tryJoinResult.groupIndex,ListEvent.UPDATE,true,changeType,tryJoinResult.oldFirstInGroup,tryJoinResult.newFirstInGroup);
      }
    }
 else     if (changeType == ListEvent.UPDATE) {
      int oldGroup=0;
      if (toDoList.get(changeIndex) == TODO)       oldGroup=RIGHT_GROUP;
 else       if (barcode.get(changeIndex) == DUPLICATE)       oldGroup=LEFT_GROUP;
 else       if (barcode.get(changeIndex) == UNIQUE)       oldGroup=NO_GROUP;
      tryJoinExistingGroup(changeIndex,toDoList,tryJoinResult);
      int groupIndex=tryJoinResult.groupIndex;
      if (tryJoinResult.group == NO_GROUP) {
        if (oldGroup == NO_GROUP) {
          client.groupChanged(changeIndex,groupIndex,ListEvent.UPDATE,true,changeType,oldValue,tryJoinResult.newFirstInGroup);
        }
 else         if (oldGroup == LEFT_GROUP) {
          E firstFromPreviousGroup=sortedList.get(barcode.getIndex(groupIndex - 1,UNIQUE));
          client.groupChanged(changeIndex,groupIndex - 1,ListEvent.UPDATE,false,changeType,firstFromPreviousGroup,firstFromPreviousGroup);
          client.groupChanged(changeIndex,groupIndex,ListEvent.INSERT,true,changeType,ListEvent.<E>unknownValue(),tryJoinResult.newFirstInGroup);
        }
 else         if (oldGroup == RIGHT_GROUP) {
          E firstFromNextGroup=sortedList.get(barcode.getIndex(groupIndex + 1,UNIQUE));
          client.groupChanged(changeIndex,groupIndex,ListEvent.INSERT,true,changeType,ListEvent.<E>unknownValue(),tryJoinResult.newFirstInGroup);
          client.groupChanged(changeIndex,groupIndex + 1,ListEvent.UPDATE,false,changeType,oldValue,firstFromNextGroup);
        }
      }
 else       if (tryJoinResult.group == LEFT_GROUP) {
        if (oldGroup == NO_GROUP) {
          client.groupChanged(changeIndex,groupIndex,ListEvent.UPDATE,true,changeType,tryJoinResult.oldFirstInGroup,tryJoinResult.newFirstInGroup);
          client.groupChanged(changeIndex,groupIndex + 1,ListEvent.DELETE,false,changeType,oldValue,ListEvent.<E>unknownValue());
        }
 else         if (oldGroup == LEFT_GROUP) {
          client.groupChanged(changeIndex,groupIndex,ListEvent.UPDATE,true,changeType,tryJoinResult.oldFirstInGroup,tryJoinResult.newFirstInGroup);
        }
 else         if (oldGroup == RIGHT_GROUP) {
          client.groupChanged(changeIndex,groupIndex,ListEvent.UPDATE,true,changeType,tryJoinResult.oldFirstInGroup,tryJoinResult.newFirstInGroup);
          if (groupIndex + 1 < barcode.blackSize()) {
            E firstFromNextGroup=sortedList.get(barcode.getIndex(groupIndex + 1,UNIQUE));
            client.groupChanged(changeIndex,groupIndex + 1,ListEvent.UPDATE,false,changeType,oldValue,firstFromNextGroup);
          }
        }
      }
 else       if (tryJoinResult.group == RIGHT_GROUP) {
        if (oldGroup == NO_GROUP) {
          client.groupChanged(changeIndex,groupIndex,ListEvent.DELETE,false,changeType,oldValue,ListEvent.<E>unknownValue());
          client.groupChanged(changeIndex,groupIndex,ListEvent.UPDATE,true,changeType,tryJoinResult.oldFirstInGroup,tryJoinResult.newFirstInGroup);
        }
 else         if (oldGroup == LEFT_GROUP) {
          if (groupIndex - 1 >= 0) {
            E firstFromPreviousGroup=sortedList.get(barcode.getIndex(groupIndex - 1,UNIQUE));
            client.groupChanged(changeIndex,groupIndex - 1,ListEvent.UPDATE,false,changeType,firstFromPreviousGroup,firstFromPreviousGroup);
          }
          client.groupChanged(changeIndex,groupIndex,ListEvent.UPDATE,true,changeType,tryJoinResult.oldFirstInGroup,tryJoinResult.newFirstInGroup);
        }
 else         if (oldGroup == RIGHT_GROUP) {
          client.groupChanged(changeIndex,groupIndex,ListEvent.UPDATE,true,changeType,tryJoinResult.oldFirstInGroup,tryJoinResult.newFirstInGroup);
        }
      }
    }
 else     if (changeType == ListEvent.DELETE) {
      final Object deleted=removedValues.removeFirst();
      final int sourceDeletedIndex=deleted == DUPLICATE ? changeIndex - 1 : changeIndex;
      final int groupDeletedIndex=sourceDeletedIndex < barcode.size() ? barcode.getBlackIndex(sourceDeletedIndex,true) : barcode.blackSize();
      if (deleted == UNIQUE) {
        client.groupChanged(changeIndex,groupDeletedIndex,ListEvent.DELETE,true,changeType,oldValue,ListEvent.<E>unknownValue());
      }
 else {
        E oldValueInGroup;
        E newValueInGroup;
        if (groupDeletedIndex < barcode.blackSize()) {
          int firstInGroupIndex=barcode.getIndex(groupDeletedIndex,UNIQUE);
          newValueInGroup=sortedList.get(firstInGroupIndex);
        }
 else {
          newValueInGroup=ListEvent.<E>unknownValue();
        }
        if (deleted == UNIQUE_WITH_DUPLICATE) {
          oldValueInGroup=oldValue;
        }
 else {
          oldValueInGroup=newValueInGroup;
        }
        client.groupChanged(changeIndex,groupDeletedIndex,ListEvent.UPDATE,true,changeType,oldValueInGroup,newValueInGroup);
      }
    }
  }
}",0.9880901743938748
32499,"private void paintGrid(Graphics g,int rMin,int rMax,int cMin,int cMax){
  g.setColor(table.getGridColor());
  Rectangle minCell=table.getCellRect(rMin,cMin,true);
  Rectangle maxCell=table.getCellRect(rMax,cMax,true);
  Rectangle damagedArea=minCell.union(maxCell);
  if (table.getShowHorizontalLines()) {
    int tableWidth=damagedArea.x + damagedArea.width;
    int y=damagedArea.y;
    for (int row=rMin; row <= rMax; row++) {
      y+=table.getRowHeight(row);
      g.drawLine(damagedArea.x,y - 1,tableWidth - 1,y - 1);
    }
  }
  if (table.getShowVerticalLines()) {
    TableColumnModel cm=table.getColumnModel();
    int tableHeight=damagedArea.y + damagedArea.height;
    int x;
    if (table.getComponentOrientation().isLeftToRight()) {
      x=damagedArea.x;
      for (int column=cMin; column <= cMax; column++) {
        x+=cm.getColumn(column).getWidth();
        g.drawLine(x - 1,0,x - 1,tableHeight - 1);
      }
    }
 else {
      x=damagedArea.x + damagedArea.width;
      for (int column=cMin; column < cMax; column++) {
        x-=cm.getColumn(column).getWidth();
        g.drawLine(x - 1,0,x - 1,tableHeight - 1);
      }
      x-=cm.getColumn(cMax).getWidth();
      g.drawLine(x,0,x,tableHeight - 1);
    }
  }
}","private void paintGrid(Graphics g,int rMin,int rMax,int cMin,int cMax){
  g.setColor(table.getGridColor());
  Rectangle minCell=table.getCellRect(rMin,cMin,true);
  Rectangle maxCell=table.getCellRect(rMax,cMax,true);
  Rectangle damagedArea=minCell.union(maxCell);
  if (table.getShowHorizontalLines()) {
    int tableWidth=damagedArea.x + damagedArea.width;
    int y=damagedArea.y;
    for (int row=rMin; row <= rMax; row++) {
      y+=table.getRowHeight(row);
      g.drawLine(damagedArea.x,y - 1,tableWidth - 1,y - 1);
    }
  }
  if (table.getShowVerticalLines()) {
    TableColumnModel cm=table.getColumnModel();
    int tableHeight=damagedArea.y + damagedArea.height;
    int x;
    if (table.getComponentOrientation().isLeftToRight()) {
      x=damagedArea.x;
      for (int column=0; column <= cMax; column++) {
        x+=cm.getColumn(column).getWidth();
        if (column >= cMin)         g.drawLine(x - 1,0,x - 1,tableHeight - 1);
      }
    }
 else {
      x=damagedArea.x + damagedArea.width;
      for (int column=cMin; column < cMax; column++) {
        x-=cm.getColumn(column).getWidth();
        g.drawLine(x - 1,0,x - 1,tableHeight - 1);
      }
      x-=cm.getColumn(cMax).getWidth();
      g.drawLine(x,0,x,tableHeight - 1);
    }
  }
}",0.9867735470941884
32500,"/** 
 * Usually, constructors shouldn't supposed to have side-effects, but this one changes the table's filter pipeline. Therefore we use this private constructor and call through it from the   {@link #install} method.
 */
private EventListJXTableSorting(JXTable table,SortedList sortedList){
  this.table=table;
  this.sortedList=sortedList;
  this.originalFilterPipeline=table.getFilters();
  this.sortController=new EventListSortController();
  this.filterPipeline=new EventListFilterPipeline();
  table.setFilters(filterPipeline);
}","/** 
 * Usually, constructors shouldn't supposed to have side-effects, but this one changes the table's filter pipeline. Therefore we use this private constructor and call through it from the   {@link #install} method.
 */
private EventListJXTableSorting(JXTable table,SortedList sortedList,Comparator defaultComparator){
  this.table=table;
  this.sortedList=sortedList;
  this.defaultComparator=defaultComparator;
  this.originalFilterPipeline=table.getFilters();
  this.sortController=new EventListSortController();
  this.filterPipeline=new EventListFilterPipeline();
  table.setFilters(filterPipeline);
}",0.936244541484716
32501,"/** 
 * Remove this   {@link EventListJXTableSorting} from the {@link JXTable}.
 */
public void uninstall(){
  table.setFilters(originalFilterPipeline);
}","/** 
 * Remove this   {@link EventListJXTableSorting} from the {@link JXTable} and restores theoriginal filter pipeline.
 */
public void uninstall(){
  table.setFilters(originalFilterPipeline);
}",0.8825214899713467
32502,"/** 
 * Install this   {@link EventListJXTableSorting} to provide the sortingbehaviour for the specified  {@link JXTable}.
 */
public static EventListJXTableSorting install(JXTable table,SortedList sortedList){
  return new EventListJXTableSorting(table,sortedList);
}","/** 
 * Install this   {@link EventListJXTableSorting} to provide the sorting behaviour for thespecified  {@link JXTable}. Optionally, a default comparator can be specified, which is used, when there are no sort keys.
 */
public static EventListJXTableSorting install(JXTable table,SortedList sortedList,Comparator defaultComparator){
  return new EventListJXTableSorting(table,sortedList,defaultComparator);
}",0.7876106194690266
32503,"/** 
 * {@inheritDoc} 
 */
public void setSortKeys(List<? extends SortKey> sortKeys){
  if (sortKeys == sortKeysReadOnly)   return;
  if (sortKeys == null)   sortKeys=Collections.emptyList();
  this.sortKeys.clear();
  this.sortKeys.addAll(sortKeys);
  List<Comparator> comparators=new ArrayList<Comparator>(this.sortKeys.size());
  for (int k=0; k < this.sortKeys.size(); k++) {
    SortKey sortKey=this.sortKeys.get(k);
    if (sortKey.getSortOrder() == SortOrder.UNSORTED)     continue;
    Comparator comparator=getComparator(sortKey.getColumn());
    if (sortKey.getSortOrder() == SortOrder.DESCENDING)     comparator=GlazedLists.reverseComparator(comparator);
    comparators.add(comparator);
  }
  final Comparator comparator;
  if (comparators.isEmpty()) {
    comparator=null;
  }
 else   if (comparators.size() == 1) {
    comparator=comparators.get(0);
  }
 else {
    comparator=GlazedLists.chainComparators((List)comparators);
  }
  sortedList.getReadWriteLock().writeLock().lock();
  try {
    sortedList.setComparator(comparator);
  }
  finally {
    sortedList.getReadWriteLock().writeLock().unlock();
  }
}","/** 
 * {@inheritDoc} 
 */
public void setSortKeys(List<? extends SortKey> sortKeys){
  if (sortKeys == sortKeysReadOnly)   return;
  if (sortKeys == null)   sortKeys=Collections.emptyList();
  this.sortKeys.clear();
  this.sortKeys.addAll(sortKeys);
  List<Comparator> comparators=new ArrayList<Comparator>(this.sortKeys.size());
  for (int k=0; k < this.sortKeys.size(); k++) {
    SortKey sortKey=this.sortKeys.get(k);
    if (sortKey.getSortOrder() == SortOrder.UNSORTED)     continue;
    Comparator comparator=getComparator(sortKey.getColumn());
    if (sortKey.getSortOrder() == SortOrder.DESCENDING)     comparator=GlazedLists.reverseComparator(comparator);
    comparators.add(comparator);
  }
  final Comparator comparator;
  if (comparators.isEmpty()) {
    comparator=defaultComparator;
  }
 else   if (comparators.size() == 1) {
    comparator=comparators.get(0);
  }
 else {
    comparator=GlazedLists.chainComparators((List)comparators);
  }
  sortedList.getReadWriteLock().writeLock().lock();
  try {
    sortedList.setComparator(comparator);
  }
  finally {
    sortedList.getReadWriteLock().writeLock().unlock();
  }
}",0.9924745462594068
32504,"/** 
 * Overridden because AutoCompleteSupport needs absolute control over when a JComboBox's ActionListeners are notified.
 */
public void setSelectedItem(Object selected){
  doNotFilter=true;
  doNotAutoComplete=true;
  final ActionListener[] listeners=unregisterAllActionListeners(comboBox);
  try {
    super.setSelectedItem(selected);
    final int caretPos=comboBoxEditorComponent.getCaretPosition();
    comboBoxEditorComponent.select(caretPos,caretPos);
  }
  finally {
    registerAllActionListeners(comboBox,listeners);
    doNotFilter=false;
    doNotAutoComplete=false;
  }
}","/** 
 * Overridden because AutoCompleteSupport needs absolute control over when a JComboBox's ActionListeners are notified.
 */
public void setSelectedItem(Object selected){
  doNotFilter=true;
  doNotAutoComplete=true;
  final ActionListener[] listeners=unregisterAllActionListeners(comboBox);
  try {
    super.setSelectedItem(selected);
    if (comboBoxEditorComponent != null) {
      final int caretPos=comboBoxEditorComponent.getCaretPosition();
      comboBoxEditorComponent.select(caretPos,caretPos);
    }
  }
  finally {
    registerAllActionListeners(comboBox,listeners);
    doNotFilter=false;
    doNotAutoComplete=false;
  }
}",0.9274653626731868
32505,"/** 
 * Gets whether the source   {@link EventList} is writable via this API.<p>Extending classes must override this method in order to make themselves writable.
 */
protected boolean isWritable(){
  return false;
}","/** 
 * Gets whether the source   {@link EventList} is writable via this API.<p>Extending classes must override this method in order to make themselves writable.
 */
protected abstract boolean isWritable();",0.9358669833729216
32506,"/** 
 * Test that the ListEvent iterator isn't adjusted by calling  {@link ListEventAssembler#forwardEvent}.
 */
public void testEventStateAfterForwardEvent(){
  EventList<String> source=new BasicEventList<String>();
  CountingList<String> counting=new CountingList<String>(source);
  source.add(""String_Node_Str"");
  assertEquals(1,counting.changeCount);
}","/** 
 * Test that the ListEvent iterator isn't adjusted by calling  {@link ListEventAssembler#forwardEvent}.
 */
public void testEventStateAfterForwardEvent(){
  EventList<String> source=new BasicEventList<String>();
  ListConsistencyListener lcl=ListConsistencyListener.install(source);
  source.add(""String_Node_Str"");
  assertEquals(1,lcl.getChangeCount(0));
}",0.8305555555555556
32507,"public void testFireChangesAppropriately(){
  final EventList<Number> numbers=new BasicEventList<Number>();
  final DatasetChangeEventCounter counter=new DatasetChangeEventCounter();
  final CalculationCategoryDataset dataset=new CalculationCategoryDataset();
  dataset.addChangeListener(counter);
  assertEquals(0,dataset.getRowCount());
  assertEquals(0,counter.getCountAndReset());
  final Calculation<Integer> intSum=Calculations.sumIntegers(numbers);
  dataset.getCalculations().add(intSum);
  assertEquals(1,dataset.getRowCount());
  assertNull(dataset.getRowKey(0));
  assertEquals(0,dataset.getValue(0,0).intValue());
  assertEquals(1,counter.getCountAndReset());
  numbers.add(2);
  assertEquals(1,dataset.getRowCount());
  assertNull(dataset.getRowKey(0));
  assertEquals(2,dataset.getValue(0,0).intValue());
  assertEquals(1,counter.getCountAndReset());
  intSum.setName(""String_Node_Str"");
  assertEquals(1,dataset.getRowCount());
  assertEquals(""String_Node_Str"",dataset.getRowKey(0));
  assertEquals(2,dataset.getValue(0,0).intValue());
  assertEquals(1,counter.getCountAndReset());
  dataset.getCalculations().remove(intSum);
  assertEquals(0,dataset.getRowCount());
  assertEquals(1,counter.getCountAndReset());
}","public void testFireChangesAppropriately(){
  final EventList<Number> numbers=new BasicEventList<Number>();
  final DatasetChangeEventCounter counter=new DatasetChangeEventCounter();
  final CalculationCategoryDataset dataset=new CalculationCategoryDataset();
  dataset.addChangeListener(counter);
  assertEquals(0,dataset.getRowCount());
  assertEquals(0,counter.getCountAndReset());
  final Calculation<Integer> intSum=Calculations.sumIntegers(numbers);
  dataset.getCalculations().add(intSum);
  assertEquals(1,dataset.getRowCount());
  assertNull(dataset.getRowKey(0));
  assertEquals(0,dataset.getValue(0,0).intValue());
  assertEquals(1,counter.getCountAndReset());
  numbers.add(new Integer(2));
  assertEquals(1,dataset.getRowCount());
  assertNull(dataset.getRowKey(0));
  assertEquals(2,dataset.getValue(0,0).intValue());
  assertEquals(1,counter.getCountAndReset());
  intSum.setName(""String_Node_Str"");
  assertEquals(1,dataset.getRowCount());
  assertEquals(""String_Node_Str"",dataset.getRowKey(0));
  assertEquals(2,dataset.getValue(0,0).intValue());
  assertEquals(1,counter.getCountAndReset());
  dataset.getCalculations().remove(intSum);
  assertEquals(0,dataset.getRowCount());
  assertEquals(1,counter.getCountAndReset());
}",0.9947389720760824
32508,"/** 
 * For implementing the ListEventListener interface. This sends changes to the table which repaints the table cells. Because this class is backed by   {@link GlazedListsSwing#swingThreadProxyList}, all natural calls to this method are guaranteed to occur on the Swing EDT.
 */
public void listChanged(ListEvent<E> listChanges){
  listChanges.nextBlock();
  final int startIndex=listChanges.getBlockStartIndex();
  final int endIndex=listChanges.getBlockEndIndex();
  final int changeType=listChanges.getType();
  tableModelEvent.setValues(startIndex,endIndex,changeType);
  if (listChanges.nextBlock())   tableModelEvent.setAllDataChanged();
  fireTableChanged(tableModelEvent);
}","/** 
 * For implementing the ListEventListener interface. This sends changes to the table which repaints the table cells. Because this class is backed by   {@link GlazedListsSwing#swingThreadProxyList}, all natural calls to this method are guaranteed to occur on the Swing EDT. <p>The translation from the ListEvent to one or more TableModelEvents is affected by property <code>fireOneTableModelEventOnly</code>.</p>
 * @see #setFireOneTableModelEventOnly(boolean)
 */
public void listChanged(ListEvent<E> listChanges){
  if (isFireOneTableModelEventOnly()) {
    fireOneTableModelEvent(listChanges);
  }
 else {
    while (listChanges.nextBlock()) {
      int startIndex=listChanges.getBlockStartIndex();
      int endIndex=listChanges.getBlockEndIndex();
      int changeType=listChanges.getType();
      tableModelEvent.setValues(startIndex,endIndex,changeType);
      fireTableChanged(tableModelEvent);
    }
  }
}",0.7336244541484717
32509,"/** 
 * Releases the resources consumed by this   {@link EventTableModel} so that itmay eventually be garbage collected. <p>An  {@link EventTableModel} will be garbage collected without a call to{@link #dispose()}, but not before its source   {@link EventList} is garbagecollected. By calling  {@link #dispose()}, you allow the   {@link EventTableModel}to be garbage collected before its source   {@link EventList}. This is  necessary for situations where an   {@link EventTableModel} is short-lived butits source  {@link EventList} is long-lived.<p><strong><font color=""#FF0000"">Warning:</font></strong> It is an error to call any method on an  {@link EventTableModel} after it has been disposed.As such, this  {@link EventTableModel} should be detached from itscorresponding Component <strong>before</strong> it is disposed.
 */
public void dispose(){
  source.removeListEventListener(this);
  if (swingThreadSource != null)   swingThreadSource.dispose();
  swingThreadSource=null;
  source=null;
}","/** 
 * Releases the resources consumed by this   {@link EventTableModel} so that itmay eventually be garbage collected. <p>An  {@link EventTableModel} will be garbage collected without a call to{@link #dispose()}, but not before its source   {@link EventList} is garbagecollected. By calling  {@link #dispose()}, you allow the   {@link EventTableModel}to be garbage collected before its source   {@link EventList}. This is necessary for situations where an   {@link EventTableModel} is short-lived butits source  {@link EventList} is long-lived.<p><strong><font color=""#FF0000"">Warning:</font></strong> It is an error to call any method on an  {@link EventTableModel} after it has been disposed.As such, this  {@link EventTableModel} should be detached from itscorresponding Component <strong>before</strong> it is disposed.
 */
public void dispose(){
  source.removeListEventListener(this);
  if (swingThreadSource != null)   swingThreadSource.dispose();
  swingThreadSource=null;
  source=null;
}",0.9994997498749376
32510,"/** 
 * Retrieves the value at the specified location from the table. <p>This may be used by renderers to paint the cells of a row differently based on the entire value for that row. 
 * @see #getValueAt(int,int)
 */
public E getElementAt(int index){
  source.getReadWriteLock().readLock().lock();
  try {
    return source.get(index);
  }
  finally {
    source.getReadWriteLock().readLock().unlock();
  }
}","/** 
 * Retrieves the value at the specified location from the table. <p>This may be used by renderers to paint the cells of a row differently based on the entire value for that row.
 * @see #getValueAt(int,int)
 */
public E getElementAt(int index){
  source.getReadWriteLock().readLock().lock();
  try {
    return source.get(index);
  }
  finally {
    source.getReadWriteLock().readLock().unlock();
  }
}",0.9987730061349692
32511,"/** 
 * Although   {@link EventList}s are not in general,   {@link BasicEventList} is{@link Serializable}. All of the   {@link ListEventListener}s that are themselves  {@link Serializable} will be serialized, but others will not. Note that thereis <strong>no</strong> easy way to access the  {@link ListEventListener}s of an   {@link EventList}, particularly after it has been serialized. <p>As of October 3, 2005, this is the wire format of serialized  {@link BasicEventList}s: <li>An <code>Object[]</code> containing each of the list's elements <li>A <code>ListEventListener[]</code> containing <strong>only</strong> the listeners that themselves implement   {@link Serializable}. Those that do not will not be serialized. Note that   {@link TransformedList}s such as   {@link FilterList} are not {@link Serializable} and will notbe serialized. <p>As of March 4, 2007, the wire format was extended to include: <li>the ListEventPublisher <li>the ReadWriteLock represented as a  {@link SerializedReadWriteLock}<p>The motivation for this is documented <a href=""https://glazedlists.dev.java.net/issues/show_bug.cgi?id=398"">here</a>. Serialization streams with the old format are still readable. Serialization streams with the new format are not downwards-compatible. 
 */
private void writeObject(ObjectOutputStream out) throws IOException {
  E[] elements=(E[])data.toArray(new Object[data.size()]);
  List<ListEventListener<E>> serializableListeners=new ArrayList<ListEventListener<E>>(1);
  for (Iterator<ListEventListener<E>> i=updates.getListEventListeners().iterator(); i.hasNext(); ) {
    ListEventListener<E> listener=i.next();
    if (!(listener instanceof Serializable))     continue;
    serializableListeners.add(listener);
  }
  ListEventListener[] listeners=serializableListeners.toArray(new ListEventListener[serializableListeners.size()]);
  out.writeObject(elements);
  out.writeObject(listeners);
  out.writeObject(getPublisher());
  out.writeObject(getReadWriteLock());
}","/** 
 * Although   {@link EventList}s are not in general,   {@link BasicEventList} is{@link Serializable}. All of the   {@link ListEventListener}s that are themselves  {@link Serializable} will be serialized, but others will not. Note that thereis <strong>no</strong> easy way to access the  {@link ListEventListener}s of an   {@link EventList}, particularly after it has been serialized. <p>As of October 3, 2005, this is the wire format of serialized  {@link BasicEventList}s: <li>An <code>Object[]</code> containing each of the list's elements <li>A <code>ListEventListener[]</code> containing <strong>only</strong> the listeners that themselves implement   {@link Serializable}. Those that do not will not be serialized. Note that   {@link TransformedList}s such as   {@link FilterList} are not {@link Serializable} and will notbe serialized. <p>As of March 4, 2007, the wire format was extended to include: <li>the ListEventPublisher <li>the ReadWriteLock represented as a  {@link SerializedReadWriteLock}<p>The motivation for this is documented <a href=""https://glazedlists.dev.java.net/issues/show_bug.cgi?id=398"">here</a>. Serialization streams with the old format are still readable. Serialization streams with the new format are not downwards-compatible.
 */
private void writeObject(ObjectOutputStream out) throws IOException {
  E[] elements=(E[])data.toArray(new Object[data.size()]);
  List<ListEventListener<E>> serializableListeners=new ArrayList<ListEventListener<E>>(1);
  for (Iterator<ListEventListener<E>> i=updates.getListEventListeners().iterator(); i.hasNext(); ) {
    ListEventListener<E> listener=i.next();
    if (!(listener instanceof Serializable))     continue;
    serializableListeners.add(listener);
  }
  ListEventListener[] listeners=serializableListeners.toArray(new ListEventListener[serializableListeners.size()]);
  out.writeObject(elements);
  out.writeObject(listeners);
  out.writeObject(getPublisher());
  out.writeObject(getReadWriteLock());
}",0.9997485541865728
32512,"/** 
 * Releases the resources consumed by this   {@link TransformedList} so that itmay eventually be garbage collected. <p>A  {@link TransformedList} will be garbage collected without a call to{@link #dispose()}, but not before its source   {@link EventList} is garbagecollected. By calling  {@link #dispose()}, you allow the   {@link TransformedList}to be garbage collected before its source   {@link EventList}. This is  necessary for situations where a   {@link TransformedList} is short-lived butits source  {@link EventList} is long-lived.<p><strong><font color=""#FF0000"">Warning:</font></strong> It is an error to call any method on a  {@link TransformedList} after it has been disposed.
 */
public void dispose(){
  source.removeListEventListener(this);
}","/** 
 * Releases the resources consumed by this   {@link TransformedList} so that itmay eventually be garbage collected. <p>A  {@link TransformedList} will be garbage collected without a call to{@link #dispose()}, but not before its source   {@link EventList} is garbagecollected. By calling  {@link #dispose()}, you allow the   {@link TransformedList}to be garbage collected before its source   {@link EventList}. This is necessary for situations where a   {@link TransformedList} is short-lived butits source  {@link EventList} is long-lived.<p><strong><font color=""#FF0000"">Warning:</font></strong> It is an error to call any method on a  {@link TransformedList} after it has been disposed.
 */
public void dispose(){
  source.removeListEventListener(this);
}",0.999344262295082
32513,"/** 
 * For implementing the ListEventListener interface. This sends changes to the table which repaints the table cells. Because this class is backed by   {@link GlazedListsSwing#swingThreadProxyList}, all natural calls to this method are guaranteed to occur on the Swing EDT. <p>The translation from the ListEvent to one or more TableModelEvents is affected by property <code>fireOneTableModelEventOnly</code>.</p>
 * @see #setFireOneTableModelEventOnly(boolean)
 */
public void listChanged(ListEvent<E> listChanges){
  if (isFireOneTableModelEventOnly() && !listChanges.isReordering()) {
    fireOneTableModelEvent(listChanges);
  }
 else {
    while (listChanges.nextBlock()) {
      int startIndex=listChanges.getBlockStartIndex();
      int endIndex=listChanges.getBlockEndIndex();
      int changeType=listChanges.getType();
      tableModelEvent.setValues(startIndex,endIndex,changeType);
      fireTableChanged(tableModelEvent);
    }
  }
}","/** 
 * For implementing the ListEventListener interface. This sends changes to the table which repaints the table cells. Because this class is backed by   {@link GlazedListsSwing#swingThreadProxyList}, all natural calls to this method are guaranteed to occur on the Swing EDT.
 */
public void listChanged(ListEvent<E> listChanges){
  handleListChange(listChanges);
}",0.547112462006079
32514,"/** 
 * Create a   {@link ThreadProxyEventList} which delivers changes to thegiven <code>source</code> on a particular  {@link Thread}, called the proxy   {@link Thread} of a subclasses choosing. The {@link Thread} useddepends on the implementation of  {@link #schedule(Runnable)}.
 * @param source the {@link EventList} for which to proxy events
 */
public ThreadProxyEventList(EventList<E> source){
  super(source);
  localCache.addAll(source);
  addListEventListener(updateRunner);
  source.addListEventListener(this);
}","/** 
 * Create a   {@link ThreadProxyEventList} which delivers changes to thegiven <code>source</code> on a particular  {@link Thread}, called the proxy   {@link Thread} of a subclasses choosing. The {@link Thread} useddepends on the implementation of  {@link #schedule(Runnable)}.
 * @param source the {@link EventList} for which to proxy events
 */
public ThreadProxyEventList(EventList<E> source){
  super(source);
  localCache.addAll(source);
  cacheUpdates.addListEventListener(updateRunner);
  source.addListEventListener(this);
}",0.987724268177526
32515,"/** 
 * {@inheritDoc} 
 */
public void dispose(){
  super.dispose();
  removeListEventListener(updateRunner);
}","/** 
 * {@inheritDoc} 
 */
public void dispose(){
  super.dispose();
  cacheUpdates.removeListEventListener(updateRunner);
}",0.9446808510638298
32516,"/** 
 * When run, this combines all events thus far and forwards them. <p>If a reordering event is being forwarded, the reordering may be lost if it arrives simultaneously with another event. This is somewhat of a hack for the time being. Hopefully later we can refine this so that a new event is created with these changes properly.
 */
public void run(){
  getReadWriteLock().writeLock().lock();
  try {
    updates.commitEvent();
    scheduled=false;
  }
  finally {
    getReadWriteLock().writeLock().unlock();
  }
}","/** 
 * When run, this combines all events thus far and forwards them. <p>If a reordering event is being forwarded, the reordering may be lost if it arrives simultaneously with another event. This is somewhat of a hack for the time being. Hopefully later we can refine this so that a new event is created with these changes properly.
 */
public void run(){
  getReadWriteLock().writeLock().lock();
  try {
    cacheUpdates.commitEvent();
    updates.commitEvent();
    scheduled=false;
  }
  finally {
    getReadWriteLock().writeLock().unlock();
  }
}",0.9682835820895522
32517,"/** 
 * Construct a frame for search and browsing items from Amazon.
 */
private JPanel constructView(){
  final JLabel filterFieldLabel=new JLabel(""String_Node_Str"");
  filterFieldLabel.setFont(new Font(""String_Node_Str"",Font.BOLD,14));
  filterFieldLabel.setForeground(Color.WHITE);
  filterField=new JTextField(10);
  final SearchEngineTextMatcherEditor<Item> filterFieldMatcherEditor=new SearchEngineTextMatcherEditor<Item>(filterField,new ItemTextFilterator());
  final Set<SearchEngineTextMatcherEditor.Field<Item>> filterFields=new HashSet<SearchEngineTextMatcherEditor.Field<Item>>();
  filterFields.add(new SearchEngineTextMatcherEditor.Field<Item>(""String_Node_Str"",new TitleTextFilterator()));
  filterFields.add(new SearchEngineTextMatcherEditor.Field<Item>(""String_Node_Str"",new DirectorTextFilterator()));
  filterFieldMatcherEditor.setFields(filterFields);
  final SortedList<Item> sortedItemsList=new SortedList<Item>(itemEventList,null);
  final FilterList<Item> filteredItemsList=new FilterList<Item>(sortedItemsList,filterFieldMatcherEditor);
  final StartNewSearchActionListener startNewSearch=new StartNewSearchActionListener();
  final JLabel searchFieldLabel=new JLabel(""String_Node_Str"");
  searchFieldLabel.setFont(new Font(""String_Node_Str"",Font.BOLD,14));
  searchFieldLabel.setForeground(Color.WHITE);
  searchField=new JTextField(10);
  searchField.addActionListener(startNewSearch);
  final JButton searchButton=new JButton(GO);
  searchButton.setBorder(BorderFactory.createEmptyBorder());
  searchButton.setContentAreaFilled(false);
  searchButton.addActionListener(startNewSearch);
  progressBar=new JProgressBar();
  progressBar.setString(""String_Node_Str"");
  progressBar.setStringPainted(true);
  progressBar.setBorder(BorderFactory.createLineBorder(AMAZON_SEARCH_DARK_BLUE,2));
  final TreeCriteriaEditor treeCriteriaEditor=new TreeCriteriaEditor(TreeCriterion.ALL_CRITERIA);
  treeCriteriaEditor.addPropertyChangeListener(""String_Node_Str"",new ActiveCriteriaPropertyChangeListener());
  treeCriteriaEditor.setOpaque(false);
  treeCriteriaEditor.setBorder(new RoundedBorder(CLEAR,AMAZON_SEARCH_DARK_BLUE,AMAZON_SEARCH_LIGHT_BLUE,8,1));
  final JPanel editorPanel=new JPanel(new GridBagLayout());
  editorPanel.setBackground(AMAZON_SEARCH_DARK_BLUE);
  editorPanel.add(treeCriteriaEditor,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,5,0,5),0,0));
  editorPanel.add(Box.createVerticalStrut(1),new GridBagConstraints(0,1,1,1,0.0,1.0,GridBagConstraints.CENTER,GridBagConstraints.VERTICAL,new Insets(0,0,0,0),0,0));
  final JPanel searchPanel=new GradientPanel(AMAZON_SEARCH_LIGHT_BLUE,AMAZON_SEARCH_DARK_BLUE,true);
  searchPanel.setLayout(new GridBagLayout());
  searchPanel.add(searchFieldLabel,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,10,0,3),0,0));
  searchPanel.add(searchField,new GridBagConstraints(1,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,5),0,0));
  searchPanel.add(searchButton,new GridBagConstraints(2,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,10),0,0));
  searchPanel.add(progressBar,new GridBagConstraints(3,0,1,1,1.0,1.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,10),0,0));
  searchPanel.add(filterFieldLabel,new GridBagConstraints(4,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,5),0,0));
  searchPanel.add(filterField,new GridBagConstraints(5,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,10),0,0));
  searchPanel.add(Box.createVerticalStrut(65),new GridBagConstraints(6,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
  final EventList<Item> swingFilteredItemsList=GlazedListsSwing.swingThreadProxyList(filteredItemsList);
  treeList=new TreeList<Item>(swingFilteredItemsList,new ItemTreeFormat(treeCriteriaEditor.getActiveCriteria()),TreeList.NODES_START_EXPANDED);
  itemTableModel=new EventTableModel<Item>(treeList,new ItemTableFormat());
  itemTableSelectionModel=new EventSelectionModel<Item>(treeList);
  final JTable itemTable=new StripedTable(itemTableModel,null,itemTableSelectionModel);
  JScrollPane itemScrollPane=new JScrollPane(itemTable,JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  itemScrollPane.setBorder(BorderFactory.createEmptyBorder());
  MacCornerScrollPaneLayoutManager.install(itemScrollPane);
  TableComparatorChooser.install(itemTable,sortedItemsList,TableComparatorChooser.MULTIPLE_COLUMN_KEYBOARD);
  ListConsistencyListener<Item> listConsistencyListener=ListConsistencyListener.install(treeList);
  listConsistencyListener.setPreviousElementTracked(false);
  final TreeTableSupport treeTableSupport=TreeTableSupport.install(itemTable,treeList,2);
  treeTableSupport.setDelegateRenderer(new TitleRenderer());
  final JPanel panel=new JPanel(new BorderLayout());
  panel.add(BorderLayout.NORTH,searchPanel);
  panel.add(BorderLayout.WEST,editorPanel);
  panel.add(BorderLayout.CENTER,itemScrollPane);
  return panel;
}","/** 
 * Construct a frame for search and browsing items from Amazon.
 */
private JPanel constructView(){
  final JLabel filterFieldLabel=new JLabel(""String_Node_Str"");
  filterFieldLabel.setFont(new Font(""String_Node_Str"",Font.BOLD,14));
  filterFieldLabel.setForeground(Color.WHITE);
  filterField=new JTextField(10);
  final SearchEngineTextFieldMatcherEditor<Item> filterFieldMatcherEditor=new SearchEngineTextFieldMatcherEditor<Item>(filterField,new ItemTextFilterator());
  final Set<SearchEngineTextMatcherEditor.Field<Item>> filterFields=new HashSet<SearchEngineTextMatcherEditor.Field<Item>>();
  filterFields.add(new SearchEngineTextMatcherEditor.Field<Item>(""String_Node_Str"",new TitleTextFilterator()));
  filterFields.add(new SearchEngineTextMatcherEditor.Field<Item>(""String_Node_Str"",new DirectorTextFilterator()));
  filterFieldMatcherEditor.setFields(filterFields);
  final SortedList<Item> sortedItemsList=new SortedList<Item>(itemEventList,null);
  final FilterList<Item> filteredItemsList=new FilterList<Item>(sortedItemsList,filterFieldMatcherEditor);
  final StartNewSearchActionListener startNewSearch=new StartNewSearchActionListener();
  final JLabel searchFieldLabel=new JLabel(""String_Node_Str"");
  searchFieldLabel.setFont(new Font(""String_Node_Str"",Font.BOLD,14));
  searchFieldLabel.setForeground(Color.WHITE);
  searchField=new JTextField(10);
  searchField.addActionListener(startNewSearch);
  final JButton searchButton=new JButton(GO);
  searchButton.setBorder(BorderFactory.createEmptyBorder());
  searchButton.setContentAreaFilled(false);
  searchButton.addActionListener(startNewSearch);
  progressBar=new JProgressBar();
  progressBar.setString(""String_Node_Str"");
  progressBar.setStringPainted(true);
  progressBar.setBorder(BorderFactory.createLineBorder(AMAZON_SEARCH_DARK_BLUE,2));
  final TreeCriteriaEditor treeCriteriaEditor=new TreeCriteriaEditor(TreeCriterion.ALL_CRITERIA);
  treeCriteriaEditor.addPropertyChangeListener(""String_Node_Str"",new ActiveCriteriaPropertyChangeListener());
  treeCriteriaEditor.setOpaque(false);
  treeCriteriaEditor.setBorder(new RoundedBorder(CLEAR,AMAZON_SEARCH_DARK_BLUE,AMAZON_SEARCH_LIGHT_BLUE,8,1));
  final JPanel editorPanel=new JPanel(new GridBagLayout());
  editorPanel.setBackground(AMAZON_SEARCH_DARK_BLUE);
  editorPanel.add(treeCriteriaEditor,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,5,0,5),0,0));
  editorPanel.add(Box.createVerticalStrut(1),new GridBagConstraints(0,1,1,1,0.0,1.0,GridBagConstraints.CENTER,GridBagConstraints.VERTICAL,new Insets(0,0,0,0),0,0));
  final JPanel searchPanel=new GradientPanel(AMAZON_SEARCH_LIGHT_BLUE,AMAZON_SEARCH_DARK_BLUE,true);
  searchPanel.setLayout(new GridBagLayout());
  searchPanel.add(searchFieldLabel,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,10,0,3),0,0));
  searchPanel.add(searchField,new GridBagConstraints(1,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,5),0,0));
  searchPanel.add(searchButton,new GridBagConstraints(2,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,10),0,0));
  searchPanel.add(progressBar,new GridBagConstraints(3,0,1,1,1.0,1.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,10),0,0));
  searchPanel.add(filterFieldLabel,new GridBagConstraints(4,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,5),0,0));
  searchPanel.add(filterField,new GridBagConstraints(5,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,10),0,0));
  searchPanel.add(Box.createVerticalStrut(65),new GridBagConstraints(6,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
  final EventList<Item> swingFilteredItemsList=GlazedListsSwing.swingThreadProxyList(filteredItemsList);
  treeList=new TreeList<Item>(swingFilteredItemsList,new ItemTreeFormat(treeCriteriaEditor.getActiveCriteria()),TreeList.NODES_START_EXPANDED);
  itemTableModel=new EventTableModel<Item>(treeList,new ItemTableFormat());
  itemTableSelectionModel=new EventSelectionModel<Item>(treeList);
  final JTable itemTable=new StripedTable(itemTableModel,null,itemTableSelectionModel);
  JScrollPane itemScrollPane=new JScrollPane(itemTable,JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  itemScrollPane.setBorder(BorderFactory.createEmptyBorder());
  MacCornerScrollPaneLayoutManager.install(itemScrollPane);
  TableComparatorChooser.install(itemTable,sortedItemsList,TableComparatorChooser.MULTIPLE_COLUMN_KEYBOARD);
  ListConsistencyListener<Item> listConsistencyListener=ListConsistencyListener.install(treeList);
  listConsistencyListener.setPreviousElementTracked(false);
  final TreeTableSupport treeTableSupport=TreeTableSupport.install(itemTable,treeList,2);
  treeTableSupport.setDelegateRenderer(new TitleRenderer());
  final JPanel panel=new JPanel(new BorderLayout());
  panel.add(BorderLayout.NORTH,searchPanel);
  panel.add(BorderLayout.WEST,editorPanel);
  panel.add(BorderLayout.CENTER,itemScrollPane);
  return panel;
}",0.9990345626568836
32518,"public void run(){
  try {
    final Class guiTestClass=testCase.getClass();
    final Method setUp=guiTestClass.getMethod(SET_UP_METHOD,DECLARE_NO_PARAMETERS);
    final Method tearDown=guiTestClass.getMethod(TEAR_DOWN_METHOD,DECLARE_NO_PARAMETERS);
    final Method[] allMethods=guiTestClass.getMethods();
    for (    Method method : allMethods) {
      final String methodName=method.getName();
      if (methodName.startsWith(JUNIT_BAD_PREFIX) && !methodName.equals(JUNIT_OK_METHOD))       throw new IllegalStateException(methodName + ""String_Node_Str"" + methodName.substring(1)+ ""String_Node_Str"");
    }
    for (    Method method : allMethods) {
      if (!method.getName().startsWith(TEST_METHOD_PREFIX))       continue;
      System.out.println(""String_Node_Str"" + method.getName());
      setUp.invoke(testCase,SEND_NO_PARAMETERS);
      method.invoke(testCase,SEND_NO_PARAMETERS);
      tearDown.invoke(testCase,SEND_NO_PARAMETERS);
    }
  }
 catch (  InvocationTargetException e) {
    throw new RuntimeException(e.getCause());
  }
catch (  NoSuchMethodException e) {
    throw new RuntimeException(e);
  }
catch (  IllegalAccessException e) {
    throw new RuntimeException(e);
  }
}","public void run(){
  try {
    final Class guiTestClass=testCase.getClass();
    final Method setUp=guiTestClass.getMethod(SET_UP_METHOD,DECLARE_NO_PARAMETERS);
    final Method tearDown=guiTestClass.getMethod(TEAR_DOWN_METHOD,DECLARE_NO_PARAMETERS);
    final Method[] allMethods=guiTestClass.getMethods();
    for (int i=0; i < allMethods.length; i++) {
      final String methodName=allMethods[i].getName();
      if (methodName.startsWith(JUNIT_BAD_PREFIX) && !methodName.equals(JUNIT_OK_METHOD))       throw new IllegalStateException(methodName + ""String_Node_Str"" + methodName.substring(1)+ ""String_Node_Str"");
    }
    for (int i=0; i < allMethods.length; i++) {
      final String methodName=allMethods[i].getName();
      if (!methodName.startsWith(TEST_METHOD_PREFIX))       continue;
      System.out.println(""String_Node_Str"" + methodName);
      setUp.invoke(testCase,SEND_NO_PARAMETERS);
      allMethods[i].invoke(testCase,SEND_NO_PARAMETERS);
      tearDown.invoke(testCase,SEND_NO_PARAMETERS);
    }
  }
 catch (  InvocationTargetException e) {
    throw new RuntimeException(e.getCause());
  }
catch (  NoSuchMethodException e) {
    throw new RuntimeException(e);
  }
catch (  IllegalAccessException e) {
    throw new RuntimeException(e);
  }
}",0.8972797401542834
32519,"public IssueSummaryChartsComponent(EventList<Issue> issuesList){
  final Comparator<Issue> issuesByStatusGrouper=GlazedLists.beanPropertyComparator(Issue.class,""String_Node_Str"");
  final FunctionList.Function<List<Issue>,Comparable<String>> keyFunction=new StatusFunction();
  final FunctionList.Function<List<Issue>,Number> valueFunction=new ListSizeFunction();
  final EventList<Issue> pieDataSource=GlazedListsSwing.swingThreadProxyList(issuesList);
  final PieDataset issuesByStatusDataset=new EventListPieDataset<Issue,String>(pieDataSource,issuesByStatusGrouper,keyFunction,valueFunction);
  final JFreeChart pieChart_IssuesByStatus=new JFreeChart(""String_Node_Str"",new CustomPiePlot(issuesByStatusDataset));
  pieChart_IssuesByStatus.setBackgroundPaint(CHART_PANEL_BACKGROUND_PAINT);
  pieChart_IssuesByStatus.getLegend().setBorder(CHART_LEGEND_BORDER);
  this.pieChartPanel_IssuesByStatus=new ChartPanel(pieChart_IssuesByStatus,true);
  final JFreeChart lineChart_OpenIssuesOverTime=ChartFactory.createLineChart(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",new OpenIssuesByMonthCategoryDataset(issuesList),PlotOrientation.VERTICAL,true,true,false);
  lineChart_OpenIssuesOverTime.setBackgroundPaint(CHART_PANEL_BACKGROUND_PAINT);
  lineChart_OpenIssuesOverTime.getLegend().setBorder(CHART_LEGEND_BORDER);
  final CategoryPlot categoryPlot=lineChart_OpenIssuesOverTime.getCategoryPlot();
  categoryPlot.setBackgroundPaint(CHART_PLOT_BACKGROUND_PAINT);
  categoryPlot.setDomainAxis(new CustomCategoryAxis());
  categoryPlot.setRenderer(new CustomCategoryItemRenderer(categoryPlot.getDataset()));
  this.lineChartPanel_OpenIssuesOverTime=new ChartPanel(lineChart_OpenIssuesOverTime,true);
  this.allChartsPanel.add(this.pieChartPanel_IssuesByStatus,new GridBagConstraints(0,0,1,1,0.4,1.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
  this.allChartsPanel.add(this.lineChartPanel_OpenIssuesOverTime,new GridBagConstraints(1,0,1,1,0.6,1.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
}","public IssueSummaryChartsComponent(EventList<Issue> issuesList){
  final Comparator<Issue> issuesByStatusGrouper=GlazedLists.beanPropertyComparator(Issue.class,""String_Node_Str"",new String[0]);
  final FunctionList.Function<List<Issue>,Comparable<String>> keyFunction=new StatusFunction();
  final FunctionList.Function<List<Issue>,Number> valueFunction=new ListSizeFunction();
  final EventList<Issue> pieDataSource=GlazedListsSwing.swingThreadProxyList(issuesList);
  final PieDataset issuesByStatusDataset=new EventListPieDataset<Issue,String>(pieDataSource,issuesByStatusGrouper,keyFunction,valueFunction);
  final JFreeChart pieChart_IssuesByStatus=new JFreeChart(""String_Node_Str"",new CustomPiePlot(issuesByStatusDataset));
  pieChart_IssuesByStatus.setBackgroundPaint(CHART_PANEL_BACKGROUND_PAINT);
  pieChart_IssuesByStatus.getLegend().setBorder(CHART_LEGEND_BORDER);
  this.pieChartPanel_IssuesByStatus=new ChartPanel(pieChart_IssuesByStatus,true);
  final JFreeChart lineChart_OpenIssuesOverTime=ChartFactory.createLineChart(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",new OpenIssuesByMonthCategoryDataset(issuesList),PlotOrientation.VERTICAL,true,true,false);
  lineChart_OpenIssuesOverTime.setBackgroundPaint(CHART_PANEL_BACKGROUND_PAINT);
  lineChart_OpenIssuesOverTime.getLegend().setBorder(CHART_LEGEND_BORDER);
  final CategoryPlot categoryPlot=lineChart_OpenIssuesOverTime.getCategoryPlot();
  categoryPlot.setBackgroundPaint(CHART_PLOT_BACKGROUND_PAINT);
  categoryPlot.setDomainAxis(new CustomCategoryAxis());
  categoryPlot.setRenderer(new CustomCategoryItemRenderer(categoryPlot.getDataset()));
  this.lineChartPanel_OpenIssuesOverTime=new ChartPanel(lineChart_OpenIssuesOverTime,true);
  this.allChartsPanel.add(this.pieChartPanel_IssuesByStatus,new GridBagConstraints(0,0,1,1,0.4,1.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
  this.allChartsPanel.add(this.lineChartPanel_OpenIssuesOverTime,new GridBagConstraints(1,0,1,1,0.6,1.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
}",0.9966167230546158
32520,"/** 
 * Display a frame for browsing issues.
 */
private JPanel constructView(){
  final SortedList<Issue> issuesSortedList=new SortedList<Issue>(issuesEventList,null);
  FilterList<Issue> filteredIssues=new FilterList<Issue>(issuesSortedList,filterPanel.getMatcherEditor());
  SeparatorList<Issue> separatedIssues=new SeparatorList<Issue>(filteredIssues,GlazedLists.beanPropertyComparator(Issue.class,""String_Node_Str""),0,Integer.MAX_VALUE);
  issuesTableModel=new EventTableModel<Issue>(separatedIssues,new IssueTableFormat());
  final TableColumnModel issuesTableColumnModel=new EventTableColumnModel(new BasicEventList<TableColumn>());
  JSeparatorTable issuesJTable=new JSeparatorTable(issuesTableModel,issuesTableColumnModel);
  issuesJTable.setAutoCreateColumnsFromModel(true);
  issuesJTable.setSeparatorRenderer(new IssueSeparatorTableCell(separatedIssues));
  issuesJTable.setSeparatorEditor(new IssueSeparatorTableCell(separatedIssues));
  issuesSelectionModel=new EventSelectionModel<Issue>(separatedIssues);
  issuesSelectionModel.setSelectionMode(ListSelection.MULTIPLE_INTERVAL_SELECTION_DEFENSIVE);
  issuesSelectionModel.addListSelectionListener(new IssuesSelectionListener());
  issuesJTable.setSelectionModel(issuesSelectionModel);
  issuesJTable.getColumnModel().getColumn(0).setPreferredWidth(150);
  issuesJTable.getColumnModel().getColumn(1).setPreferredWidth(400);
  issuesJTable.getColumnModel().getColumn(2).setPreferredWidth(300);
  issuesJTable.getColumnModel().getColumn(3).setPreferredWidth(300);
  issuesJTable.getColumnModel().getColumn(4).setPreferredWidth(250);
  issuesJTable.getColumnModel().getColumn(5).setPreferredWidth(300);
  issuesJTable.getColumnModel().getColumn(6).setPreferredWidth(300);
  issuesJTable.getColumnModel().getColumn(7).setPreferredWidth(1000);
  issuesJTable.setDefaultRenderer(String.class,new NoFocusRenderer(issuesJTable.getDefaultRenderer(String.class)));
  issuesJTable.setDefaultRenderer(Integer.class,new NoFocusRenderer(issuesJTable.getDefaultRenderer(Integer.class)));
  issuesJTable.setDefaultRenderer(Priority.class,new NoFocusRenderer(new PriorityTableCellRenderer()));
  LookAndFeelTweaks.tweakTable(issuesJTable);
  TableComparatorChooser.install(issuesJTable,issuesSortedList,TableComparatorChooser.MULTIPLE_COLUMN_KEYBOARD);
  JScrollPane issuesTableScrollPane=new JScrollPane(issuesJTable,JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  issuesTableScrollPane.getViewport().setBackground(UIManager.getColor(""String_Node_Str""));
  issuesTableScrollPane.setBorder(BorderFactory.createEmptyBorder());
  issueDetails=new IssueDetailsComponent(filteredIssues);
  EventList<Project> projects=Project.getProjects();
  EventComboBoxModel projectsComboModel=new EventComboBoxModel<Project>(projects);
  JComboBox projectsCombo=new JComboBox(projectsComboModel);
  projectsCombo.setEditable(false);
  projectsCombo.setOpaque(false);
  projectsCombo.addItemListener(new ProjectChangeListener());
  projectsComboModel.setSelectedItem(new Project(null,""String_Node_Str""));
  issueCounter=new IssueCounterLabel(filteredIssues);
  issueCounter.setHorizontalAlignment(SwingConstants.CENTER);
  issueCounter.setForeground(Color.WHITE);
  throbber=new JLabel(THROBBER_STATIC);
  throbber.setHorizontalAlignment(SwingConstants.RIGHT);
  JPanel iconBar=new GradientPanel(GLAZED_LISTS_MEDIUM_BROWN,GLAZED_LISTS_DARK_BROWN,true);
  iconBar.setLayout(new GridLayout(1,3));
  iconBar.add(projectsCombo);
  iconBar.add(issueCounter);
  iconBar.add(throbber);
  iconBar.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));
  JPanel dataPanel=new JPanel();
  JComponent issueDetailsComponent=issueDetails;
  dataPanel.setLayout(new GridLayout(2,1));
  dataPanel.add(issuesTableScrollPane);
  dataPanel.add(issueDetailsComponent);
  JComponent filtersPanel=filterPanel.getComponent();
  filtersPanel.setBorder(BorderFactory.createEmptyBorder());
  issueDetailsComponent.setBorder(BorderFactory.createMatteBorder(1,0,0,0,GLAZED_LISTS_DARK_BROWN));
  final JPanel mainPanel=new JPanel(new GridBagLayout());
  mainPanel.add(iconBar,new GridBagConstraints(0,0,2,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
  mainPanel.add(filtersPanel,new GridBagConstraints(0,1,1,1,0.0,1.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
  mainPanel.add(Box.createHorizontalStrut(240),new GridBagConstraints(0,1,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
  mainPanel.add(dataPanel,new GridBagConstraints(1,1,1,1,1.0,1.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
  return mainPanel;
}","/** 
 * Display a frame for browsing issues.
 */
private JPanel constructView(){
  final SortedList<Issue> issuesSortedList=new SortedList<Issue>(issuesEventList,null);
  FilterList<Issue> filteredIssues=new FilterList<Issue>(issuesSortedList,filterPanel.getMatcherEditor());
  SeparatorList<Issue> separatedIssues=new SeparatorList<Issue>(filteredIssues,GlazedLists.beanPropertyComparator(Issue.class,""String_Node_Str"",new String[0]),0,Integer.MAX_VALUE);
  issuesTableModel=new EventTableModel<Issue>(separatedIssues,new IssueTableFormat());
  final TableColumnModel issuesTableColumnModel=new EventTableColumnModel(new BasicEventList<TableColumn>());
  JSeparatorTable issuesJTable=new JSeparatorTable(issuesTableModel,issuesTableColumnModel);
  issuesJTable.setAutoCreateColumnsFromModel(true);
  issuesJTable.setSeparatorRenderer(new IssueSeparatorTableCell(separatedIssues));
  issuesJTable.setSeparatorEditor(new IssueSeparatorTableCell(separatedIssues));
  issuesSelectionModel=new EventSelectionModel<Issue>(separatedIssues);
  issuesSelectionModel.setSelectionMode(ListSelection.MULTIPLE_INTERVAL_SELECTION_DEFENSIVE);
  issuesSelectionModel.addListSelectionListener(new IssuesSelectionListener());
  issuesJTable.setSelectionModel(issuesSelectionModel);
  issuesJTable.getColumnModel().getColumn(0).setPreferredWidth(150);
  issuesJTable.getColumnModel().getColumn(1).setPreferredWidth(400);
  issuesJTable.getColumnModel().getColumn(2).setPreferredWidth(300);
  issuesJTable.getColumnModel().getColumn(3).setPreferredWidth(300);
  issuesJTable.getColumnModel().getColumn(4).setPreferredWidth(250);
  issuesJTable.getColumnModel().getColumn(5).setPreferredWidth(300);
  issuesJTable.getColumnModel().getColumn(6).setPreferredWidth(300);
  issuesJTable.getColumnModel().getColumn(7).setPreferredWidth(1000);
  issuesJTable.setDefaultRenderer(String.class,new NoFocusRenderer(issuesJTable.getDefaultRenderer(String.class)));
  issuesJTable.setDefaultRenderer(Integer.class,new NoFocusRenderer(issuesJTable.getDefaultRenderer(Integer.class)));
  issuesJTable.setDefaultRenderer(Priority.class,new NoFocusRenderer(new PriorityTableCellRenderer()));
  LookAndFeelTweaks.tweakTable(issuesJTable);
  TableComparatorChooser.install(issuesJTable,issuesSortedList,TableComparatorChooser.MULTIPLE_COLUMN_KEYBOARD);
  JScrollPane issuesTableScrollPane=new JScrollPane(issuesJTable,JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  issuesTableScrollPane.getViewport().setBackground(UIManager.getColor(""String_Node_Str""));
  issuesTableScrollPane.setBorder(BorderFactory.createEmptyBorder());
  issueDetails=new IssueDetailsComponent(filteredIssues);
  EventList<Project> projects=Project.getProjects();
  EventComboBoxModel projectsComboModel=new EventComboBoxModel<Project>(projects);
  JComboBox projectsCombo=new JComboBox(projectsComboModel);
  projectsCombo.setEditable(false);
  projectsCombo.setOpaque(false);
  projectsCombo.addItemListener(new ProjectChangeListener());
  projectsComboModel.setSelectedItem(new Project(null,""String_Node_Str""));
  issueCounter=new IssueCounterLabel(filteredIssues);
  issueCounter.setHorizontalAlignment(SwingConstants.CENTER);
  issueCounter.setForeground(Color.WHITE);
  throbber=new JLabel(THROBBER_STATIC);
  throbber.setHorizontalAlignment(SwingConstants.RIGHT);
  JPanel iconBar=new GradientPanel(GLAZED_LISTS_MEDIUM_BROWN,GLAZED_LISTS_DARK_BROWN,true);
  iconBar.setLayout(new GridLayout(1,3));
  iconBar.add(projectsCombo);
  iconBar.add(issueCounter);
  iconBar.add(throbber);
  iconBar.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));
  JPanel dataPanel=new JPanel();
  JComponent issueDetailsComponent=issueDetails;
  dataPanel.setLayout(new GridLayout(2,1));
  dataPanel.add(issuesTableScrollPane);
  dataPanel.add(issueDetailsComponent);
  JComponent filtersPanel=filterPanel.getComponent();
  filtersPanel.setBorder(BorderFactory.createEmptyBorder());
  issueDetailsComponent.setBorder(BorderFactory.createMatteBorder(1,0,0,0,GLAZED_LISTS_DARK_BROWN));
  final JPanel mainPanel=new JPanel(new GridBagLayout());
  mainPanel.add(iconBar,new GridBagConstraints(0,0,2,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
  mainPanel.add(filtersPanel,new GridBagConstraints(0,1,1,1,0.0,1.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
  mainPanel.add(Box.createHorizontalStrut(240),new GridBagConstraints(0,1,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
  mainPanel.add(dataPanel,new GridBagConstraints(1,1,1,1,1.0,1.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
  return mainPanel;
}",0.9985119047619048
32521,"public boolean matches(E item){
  if (item == null)   return false;
  final Class target=item.getClass();
  for (  Class clazz : classes)   if (clazz.isAssignableFrom(target))   return true;
  return false;
}","public boolean matches(E item){
  if (item == null)   return false;
  final Class target=item.getClass();
  for (int i=0; i < classes.length; i++)   if (classes[i].isAssignableFrom(target))   return true;
  return false;
}",0.8
32522,"/** 
 * Convert an array of Strings into a List of characters.
 */
public static List<String> stringsToList(CharSequence[] data){
  List<String> result=new ArrayList<String>();
  for (  CharSequence datum : data)   result.addAll(stringToList(datum));
  return result;
}","/** 
 * Convert an array of Strings into a List of characters.
 */
public static List<String> stringsToList(CharSequence[] data){
  List<String> result=new ArrayList<String>();
  for (int i=0; i < data.length; i++)   result.addAll(stringToList(data[i]));
  return result;
}",0.8892988929889298
32523,"/** 
 * Convert the specified int[] array to a List of Integers.
 */
public static List<Integer> intArrayToIntegerCollection(int[] values){
  List<Integer> result=new ArrayList<Integer>();
  for (  int value : values)   result.add(new Integer(value));
  return result;
}","/** 
 * Convert the specified int[] array to a List of Integers.
 */
public static List<Integer> intArrayToIntegerCollection(int[] values){
  List<Integer> result=new ArrayList<Integer>();
  for (int i=0; i < values.length; i++)   result.add(new Integer(values[i]));
  return result;
}",0.9009009009009008
32524,"/** 
 * Convert a String like ""AA,BB,CDE"" into three Lists: { [ A A ], [ B B ], [ C D E ] }
 */
public static List<List<String>> stringToLists(CharSequence chars){
  List<List<String>> result=new ArrayList<List<String>>();
  String[] strings=chars.toString().split(""String_Node_Str"");
  for (  String string : strings)   result.add(stringToList(string));
  return result;
}","/** 
 * Convert a String like ""AA,BB,CDE"" into three Lists: { [ A A ], [ B B ], [ C D E ] }
 */
public static List<List<String>> stringToLists(CharSequence chars){
  List<List<String>> result=new ArrayList<List<String>>();
  String[] strings=chars.toString().split(""String_Node_Str"");
  for (int i=0; i < strings.length; i++)   result.add(stringToList(strings[i]));
  return result;
}",0.9194187582562748
32525,"public void testTypeMatcher(){
  final List<Number> numbers=new ArrayList<Number>();
  numbers.add(new Float(0));
  numbers.add(new Double(1));
  numbers.add(new Short((short)2));
  numbers.add(new Integer(3));
  numbers.add(new Long(4));
  Collection<? super Number> selected;
  final Matcher<Number> intAndLongMatcher=Matchers.types(Long.class,Integer.class);
  selected=Matchers.select(numbers,intAndLongMatcher);
  assertEquals(Arrays.asList(new Integer(3),new Long(4)),selected);
  final Matcher<Number> numberMatcher=Matchers.types(Number.class);
  selected=Matchers.select(numbers,numberMatcher);
  assertEquals(Arrays.asList(new Float(0),new Double(1),new Short((short)2),new Integer(3),new Long(4)),selected);
  final Matcher<Number> stringMatcher=Matchers.types(String.class);
  selected=Matchers.select(numbers,stringMatcher);
  assertEquals(Collections.EMPTY_LIST,selected);
}","public void testTypeMatcher(){
  final List<Number> numbers=new ArrayList<Number>();
  numbers.add(new Float(0));
  numbers.add(new Double(1));
  numbers.add(new Short((short)2));
  numbers.add(new Integer(3));
  numbers.add(new Long(4));
  Collection<? super Number> selected;
  final Matcher<Number> intAndLongMatcher=Matchers.types(new Class[]{Long.class,Integer.class});
  selected=Matchers.select(numbers,intAndLongMatcher);
  assertEquals(Arrays.asList(new Number[]{new Integer(3),new Long(4)}),selected);
  final Matcher<Number> numberMatcher=Matchers.types(new Class[]{Number.class});
  selected=Matchers.select(numbers,numberMatcher);
  assertEquals(Arrays.asList(new Number[]{new Float(0),new Double(1),new Short((short)2),new Integer(3),new Long(4)}),selected);
  final Matcher<Number> stringMatcher=Matchers.types(new Class[]{String.class});
  selected=Matchers.select(numbers,stringMatcher);
  assertEquals(Collections.EMPTY_LIST,selected);
}",0.963646228974498
32526,"/** 
 * Execute a performance test that is specified on the command line.
 */
public static void main(String[] args) throws Exception {
  if (args.length != 1) {
    System.out.println();
    System.out.println(""String_Node_Str"");
    System.out.println();
    System.out.println(""String_Node_Str"");
    return;
  }
  List issues=loadIssues(args[0]);
  Comparator[] comparators=new Comparator[8];
  comparators[0]=GlazedLists.beanPropertyComparator(MozillaEntry.class,""String_Node_Str"");
  comparators[1]=GlazedLists.beanPropertyComparator(MozillaEntry.class,""String_Node_Str"");
  comparators[2]=GlazedLists.beanPropertyComparator(MozillaEntry.class,""String_Node_Str"");
  comparators[3]=GlazedLists.beanPropertyComparator(MozillaEntry.class,""String_Node_Str"");
  comparators[4]=GlazedLists.beanPropertyComparator(MozillaEntry.class,""String_Node_Str"");
  comparators[5]=GlazedLists.beanPropertyComparator(MozillaEntry.class,""String_Node_Str"");
  comparators[6]=GlazedLists.beanPropertyComparator(MozillaEntry.class,""String_Node_Str"");
  comparators[7]=GlazedLists.beanPropertyComparator(MozillaEntry.class,""String_Node_Str"");
  EventList issuesEventList=new BasicEventList();
  SortedList sorted=new SortedList(issuesEventList,comparators[0]);
  System.out.print(""String_Node_Str"");
  long setUpStart=System.currentTimeMillis();
  issuesEventList.addAll(issues);
  long setUpEnd=System.currentTimeMillis();
  long setUpTime=setUpEnd - setUpStart;
  System.out.println(""String_Node_Str"" + setUpTime + ""String_Node_Str"");
  System.out.print(""String_Node_Str"");
  long tearDownStart=System.currentTimeMillis();
  for (int i=0; i < 100; i++) {
    sorted.setComparator(comparators[dice.nextInt(8)]);
  }
  long tearDownEnd=System.currentTimeMillis();
  long tearDownTime=tearDownEnd - tearDownStart;
  System.out.println(""String_Node_Str"" + tearDownTime + ""String_Node_Str"");
}","/** 
 * Execute a performance test that is specified on the command line.
 */
public static void main(String[] args) throws Exception {
  if (args.length != 1) {
    System.out.println();
    System.out.println(""String_Node_Str"");
    System.out.println();
    System.out.println(""String_Node_Str"");
    return;
  }
  List issues=loadIssues(args[0]);
  Comparator[] comparators=new Comparator[8];
  final String[] empty={};
  comparators[0]=GlazedLists.beanPropertyComparator(MozillaEntry.class,""String_Node_Str"",empty);
  comparators[1]=GlazedLists.beanPropertyComparator(MozillaEntry.class,""String_Node_Str"",empty);
  comparators[2]=GlazedLists.beanPropertyComparator(MozillaEntry.class,""String_Node_Str"",empty);
  comparators[3]=GlazedLists.beanPropertyComparator(MozillaEntry.class,""String_Node_Str"",empty);
  comparators[4]=GlazedLists.beanPropertyComparator(MozillaEntry.class,""String_Node_Str"",empty);
  comparators[5]=GlazedLists.beanPropertyComparator(MozillaEntry.class,""String_Node_Str"",empty);
  comparators[6]=GlazedLists.beanPropertyComparator(MozillaEntry.class,""String_Node_Str"",empty);
  comparators[7]=GlazedLists.beanPropertyComparator(MozillaEntry.class,""String_Node_Str"",empty);
  EventList issuesEventList=new BasicEventList();
  SortedList sorted=new SortedList(issuesEventList,comparators[0]);
  System.out.print(""String_Node_Str"");
  long setUpStart=System.currentTimeMillis();
  issuesEventList.addAll(issues);
  long setUpEnd=System.currentTimeMillis();
  long setUpTime=setUpEnd - setUpStart;
  System.out.println(""String_Node_Str"" + setUpTime + ""String_Node_Str"");
  System.out.print(""String_Node_Str"");
  long tearDownStart=System.currentTimeMillis();
  for (int i=0; i < 100; i++) {
    sorted.setComparator(comparators[dice.nextInt(8)]);
  }
  long tearDownEnd=System.currentTimeMillis();
  long tearDownTime=tearDownEnd - tearDownStart;
  System.out.println(""String_Node_Str"" + tearDownTime + ""String_Node_Str"");
}",0.9803613511390415
32527,"/** 
 * This test ensures that the SortedList sorts by its own order, then by the order in the source list.
 */
public void testSortedListHandlesSortEvents(){
  Comparator artistComparator=GlazedLists.beanPropertyComparator(Song.class,""String_Node_Str"");
  Comparator songComparator=GlazedLists.beanPropertyComparator(Song.class,""String_Node_Str"");
  List<Comparable> expectedOrder;
  sortedList.setComparator(null);
  SortedList sortedAgain=new SortedList<Comparable>(sortedList,artistComparator);
  ListConsistencyListener.install(sortedAgain);
  unsortedList.add(new Song(""String_Node_Str"",""String_Node_Str""));
  unsortedList.add(new Song(""String_Node_Str"",""String_Node_Str""));
  unsortedList.add(new Song(""String_Node_Str"",""String_Node_Str""));
  unsortedList.add(new Song(""String_Node_Str"",""String_Node_Str""));
  unsortedList.add(new Song(""String_Node_Str"",""String_Node_Str""));
  unsortedList.add(new Song(""String_Node_Str"",""String_Node_Str""));
  unsortedList.add(new Song(""String_Node_Str"",""String_Node_Str""));
  unsortedList.add(new Song(""String_Node_Str"",""String_Node_Str""));
  unsortedList.add(new Song(""String_Node_Str"",""String_Node_Str""));
  unsortedList.add(new Song(""String_Node_Str"",""String_Node_Str""));
  unsortedList.add(new Song(""String_Node_Str"",""String_Node_Str""));
  expectedOrder=new ArrayList<Comparable>(unsortedList);
  Collections.sort(expectedOrder,artistComparator);
  assertEquals(expectedOrder,sortedAgain);
  sortedList.setComparator(songComparator);
  expectedOrder=new ArrayList<Comparable>(unsortedList);
  Collections.sort(expectedOrder,GlazedLists.chainComparators((List)Arrays.asList(new Comparator[]{artistComparator,songComparator})));
  assertEquals(expectedOrder,sortedAgain);
  sortedList.setComparator(null);
  expectedOrder=new ArrayList<Comparable>(unsortedList);
  Collections.sort(expectedOrder,artistComparator);
  assertEquals(expectedOrder,sortedAgain);
  unsortedList.clear();
  Random dice=new Random(0);
  List<String> artists=GlazedListsTests.stringToList(""String_Node_Str"");
  for (int a=0; a < 200; a++) {
    String randomArtist=artists.get(dice.nextInt(artists.size()));
    String randomSong=artists.get(dice.nextInt(artists.size()));
    unsortedList.add(new Song(randomArtist,randomSong));
  }
  sortedList.setComparator(songComparator);
  expectedOrder=new ArrayList<Comparable>(unsortedList);
  Collections.sort(expectedOrder,GlazedLists.chainComparators((List)Arrays.asList(new Comparator[]{artistComparator,songComparator})));
  assertEquals(expectedOrder,sortedAgain);
  sortedList.setComparator(null);
  expectedOrder=new ArrayList<Comparable>(unsortedList);
  Collections.sort(expectedOrder,artistComparator);
  assertEquals(expectedOrder,sortedAgain);
}","/** 
 * This test ensures that the SortedList sorts by its own order, then by the order in the source list.
 */
public void testSortedListHandlesSortEvents(){
  Comparator artistComparator=GlazedLists.beanPropertyComparator(Song.class,""String_Node_Str"",new String[0]);
  Comparator songComparator=GlazedLists.beanPropertyComparator(Song.class,""String_Node_Str"",new String[0]);
  List<Comparable> expectedOrder;
  sortedList.setComparator(null);
  SortedList sortedAgain=new SortedList<Comparable>(sortedList,artistComparator);
  ListConsistencyListener.install(sortedAgain);
  unsortedList.add(new Song(""String_Node_Str"",""String_Node_Str""));
  unsortedList.add(new Song(""String_Node_Str"",""String_Node_Str""));
  unsortedList.add(new Song(""String_Node_Str"",""String_Node_Str""));
  unsortedList.add(new Song(""String_Node_Str"",""String_Node_Str""));
  unsortedList.add(new Song(""String_Node_Str"",""String_Node_Str""));
  unsortedList.add(new Song(""String_Node_Str"",""String_Node_Str""));
  unsortedList.add(new Song(""String_Node_Str"",""String_Node_Str""));
  unsortedList.add(new Song(""String_Node_Str"",""String_Node_Str""));
  unsortedList.add(new Song(""String_Node_Str"",""String_Node_Str""));
  unsortedList.add(new Song(""String_Node_Str"",""String_Node_Str""));
  unsortedList.add(new Song(""String_Node_Str"",""String_Node_Str""));
  expectedOrder=new ArrayList<Comparable>(unsortedList);
  Collections.sort(expectedOrder,artistComparator);
  assertEquals(expectedOrder,sortedAgain);
  sortedList.setComparator(songComparator);
  expectedOrder=new ArrayList<Comparable>(unsortedList);
  Collections.sort(expectedOrder,GlazedLists.chainComparators((List)Arrays.asList(new Comparator[]{artistComparator,songComparator})));
  assertEquals(expectedOrder,sortedAgain);
  sortedList.setComparator(null);
  expectedOrder=new ArrayList<Comparable>(unsortedList);
  Collections.sort(expectedOrder,artistComparator);
  assertEquals(expectedOrder,sortedAgain);
  unsortedList.clear();
  Random dice=new Random(0);
  List<String> artists=GlazedListsTests.stringToList(""String_Node_Str"");
  for (int a=0; a < 200; a++) {
    String randomArtist=artists.get(dice.nextInt(artists.size()));
    String randomSong=artists.get(dice.nextInt(artists.size()));
    unsortedList.add(new Song(randomArtist,randomSong));
  }
  sortedList.setComparator(songComparator);
  expectedOrder=new ArrayList<Comparable>(unsortedList);
  Collections.sort(expectedOrder,GlazedLists.chainComparators((List)Arrays.asList(new Comparator[]{artistComparator,songComparator})));
  assertEquals(expectedOrder,sortedAgain);
  sortedList.setComparator(null);
  expectedOrder=new ArrayList<Comparable>(unsortedList);
  Collections.sort(expectedOrder,artistComparator);
  assertEquals(expectedOrder,sortedAgain);
}",0.9948792977322604
32528,"/** 
 * This test ensures that the SortedList sorts by its own order, then by the order in the source list.
 */
public void testChainedComparator(){
  sortedList.setComparator(null);
  Song nookie=new Song(""String_Node_Str"",""String_Node_Str"");
  Song eatYouAlive=new Song(""String_Node_Str"",""String_Node_Str"");
  Song rearranged=new Song(""String_Node_Str"",""String_Node_Str"");
  Song theUnquestionableTruth=new Song(""String_Node_Str"",""String_Node_Str"");
  Song welcomeToTheFold=new Song(""String_Node_Str"",""String_Node_Str"");
  Song takeAPicture=new Song(""String_Node_Str"",""String_Node_Str"");
  Song missBlue=new Song(""String_Node_Str"",""String_Node_Str"");
  unsortedList.add(nookie);
  unsortedList.add(eatYouAlive);
  unsortedList.add(takeAPicture);
  unsortedList.add(rearranged);
  unsortedList.add(missBlue);
  unsortedList.add(theUnquestionableTruth);
  unsortedList.add(welcomeToTheFold);
  assertSame(nookie,sortedList.get(0));
  assertSame(eatYouAlive,sortedList.get(1));
  assertSame(takeAPicture,sortedList.get(2));
  assertSame(rearranged,sortedList.get(3));
  assertSame(missBlue,sortedList.get(4));
  assertSame(theUnquestionableTruth,sortedList.get(5));
  assertSame(welcomeToTheFold,sortedList.get(6));
  Comparator songComparator=GlazedLists.beanPropertyComparator(Song.class,""String_Node_Str"",""String_Node_Str"");
  sortedList.setComparator(songComparator);
  assertSame(missBlue,sortedList.get(0));
  assertSame(takeAPicture,sortedList.get(1));
  assertSame(welcomeToTheFold,sortedList.get(2));
  assertSame(eatYouAlive,sortedList.get(3));
  assertSame(nookie,sortedList.get(4));
  assertSame(rearranged,sortedList.get(5));
  assertSame(theUnquestionableTruth,sortedList.get(6));
}","/** 
 * This test ensures that the SortedList sorts by its own order, then by the order in the source list.
 */
public void testChainedComparator(){
  sortedList.setComparator(null);
  Song nookie=new Song(""String_Node_Str"",""String_Node_Str"");
  Song eatYouAlive=new Song(""String_Node_Str"",""String_Node_Str"");
  Song rearranged=new Song(""String_Node_Str"",""String_Node_Str"");
  Song theUnquestionableTruth=new Song(""String_Node_Str"",""String_Node_Str"");
  Song welcomeToTheFold=new Song(""String_Node_Str"",""String_Node_Str"");
  Song takeAPicture=new Song(""String_Node_Str"",""String_Node_Str"");
  Song missBlue=new Song(""String_Node_Str"",""String_Node_Str"");
  unsortedList.add(nookie);
  unsortedList.add(eatYouAlive);
  unsortedList.add(takeAPicture);
  unsortedList.add(rearranged);
  unsortedList.add(missBlue);
  unsortedList.add(theUnquestionableTruth);
  unsortedList.add(welcomeToTheFold);
  assertSame(nookie,sortedList.get(0));
  assertSame(eatYouAlive,sortedList.get(1));
  assertSame(takeAPicture,sortedList.get(2));
  assertSame(rearranged,sortedList.get(3));
  assertSame(missBlue,sortedList.get(4));
  assertSame(theUnquestionableTruth,sortedList.get(5));
  assertSame(welcomeToTheFold,sortedList.get(6));
  Comparator songComparator=GlazedLists.beanPropertyComparator(Song.class,""String_Node_Str"",new String[]{""String_Node_Str""});
  sortedList.setComparator(songComparator);
  assertSame(missBlue,sortedList.get(0));
  assertSame(takeAPicture,sortedList.get(1));
  assertSame(welcomeToTheFold,sortedList.get(2));
  assertSame(eatYouAlive,sortedList.get(3));
  assertSame(nookie,sortedList.get(4));
  assertSame(rearranged,sortedList.get(5));
  assertSame(theUnquestionableTruth,sortedList.get(6));
}",0.9958871915393654
32529,"/** 
 * Execute a performance test that is specified on the command line.
 */
public static void main(String[] args) throws Exception {
  if (args.length != 1) {
    System.out.println();
    System.out.println(""String_Node_Str"");
    System.out.println();
    System.out.println(""String_Node_Str"");
    return;
  }
  List<MozillaEntry> issues=loadIssues(args[0]);
  EventList<MozillaEntry> issuesEventList=new BasicEventList<MozillaEntry>();
  UniqueList<MozillaEntry> uniqueByEmail=new UniqueList<MozillaEntry>(issuesEventList,GlazedLists.beanPropertyComparator(MozillaEntry.class,""String_Node_Str""));
  UniqueList<MozillaEntry> uniqueBySeverity=new UniqueList<MozillaEntry>(issuesEventList,GlazedLists.beanPropertyComparator(MozillaEntry.class,""String_Node_Str""));
  UniqueList<MozillaEntry> uniqueByPriority=new UniqueList<MozillaEntry>(issuesEventList,GlazedLists.beanPropertyComparator(MozillaEntry.class,""String_Node_Str""));
  UniqueList<MozillaEntry> uniqueByOs=new UniqueList<MozillaEntry>(issuesEventList,GlazedLists.beanPropertyComparator(MozillaEntry.class,""String_Node_Str""));
  UniqueList<MozillaEntry> uniqueByResult=new UniqueList<MozillaEntry>(issuesEventList,GlazedLists.beanPropertyComparator(MozillaEntry.class,""String_Node_Str""));
  UniqueList<MozillaEntry> uniqueByStatus=new UniqueList<MozillaEntry>(issuesEventList,GlazedLists.beanPropertyComparator(MozillaEntry.class,""String_Node_Str""));
  System.out.print(""String_Node_Str"");
  long setUpStart=System.currentTimeMillis();
  issuesEventList.addAll(issues);
  long setUpEnd=System.currentTimeMillis();
  long setUpTime=setUpEnd - setUpStart;
  System.out.println(""String_Node_Str"" + setUpTime + ""String_Node_Str"");
  System.out.print(""String_Node_Str"");
  long tearDownStart=System.currentTimeMillis();
  while (!issuesEventList.isEmpty()) {
    int randomIndex=dice.nextInt(issuesEventList.size());
    issuesEventList.remove(randomIndex);
  }
  issuesEventList.addAll(issues);
  long tearDownEnd=System.currentTimeMillis();
  long tearDownTime=tearDownEnd - tearDownStart;
  System.out.println(""String_Node_Str"" + tearDownTime + ""String_Node_Str"");
}","/** 
 * Execute a performance test that is specified on the command line.
 */
public static void main(String[] args) throws Exception {
  if (args.length != 1) {
    System.out.println();
    System.out.println(""String_Node_Str"");
    System.out.println();
    System.out.println(""String_Node_Str"");
    return;
  }
  List<MozillaEntry> issues=loadIssues(args[0]);
  EventList<MozillaEntry> issuesEventList=new BasicEventList<MozillaEntry>();
  final String[] empty={};
  UniqueList<MozillaEntry> uniqueByEmail=new UniqueList<MozillaEntry>(issuesEventList,GlazedLists.beanPropertyComparator(MozillaEntry.class,""String_Node_Str"",empty));
  UniqueList<MozillaEntry> uniqueBySeverity=new UniqueList<MozillaEntry>(issuesEventList,GlazedLists.beanPropertyComparator(MozillaEntry.class,""String_Node_Str"",empty));
  UniqueList<MozillaEntry> uniqueByPriority=new UniqueList<MozillaEntry>(issuesEventList,GlazedLists.beanPropertyComparator(MozillaEntry.class,""String_Node_Str"",empty));
  UniqueList<MozillaEntry> uniqueByOs=new UniqueList<MozillaEntry>(issuesEventList,GlazedLists.beanPropertyComparator(MozillaEntry.class,""String_Node_Str"",empty));
  UniqueList<MozillaEntry> uniqueByResult=new UniqueList<MozillaEntry>(issuesEventList,GlazedLists.beanPropertyComparator(MozillaEntry.class,""String_Node_Str"",empty));
  UniqueList<MozillaEntry> uniqueByStatus=new UniqueList<MozillaEntry>(issuesEventList,GlazedLists.beanPropertyComparator(MozillaEntry.class,""String_Node_Str"",empty));
  System.out.print(""String_Node_Str"");
  long setUpStart=System.currentTimeMillis();
  issuesEventList.addAll(issues);
  long setUpEnd=System.currentTimeMillis();
  long setUpTime=setUpEnd - setUpStart;
  System.out.println(""String_Node_Str"" + setUpTime + ""String_Node_Str"");
  System.out.print(""String_Node_Str"");
  long tearDownStart=System.currentTimeMillis();
  while (!issuesEventList.isEmpty()) {
    int randomIndex=dice.nextInt(issuesEventList.size());
    issuesEventList.remove(randomIndex);
  }
  issuesEventList.addAll(issues);
  long tearDownEnd=System.currentTimeMillis();
  long tearDownTime=tearDownEnd - tearDownStart;
  System.out.println(""String_Node_Str"" + tearDownTime + ""String_Node_Str"");
}",0.985406532314107
32530,"/** 
 * Tests that comparison by property works.
 */
public void testCompare(){
  Comparator comparator=GlazedLists.beanPropertyComparator(Position.class,""String_Node_Str"");
  assertTrue(comparator.compare(new Position(4),new Position(1)) > 0);
  assertTrue(comparator.compare(new Position(1),new Position(4)) < 0);
  assertTrue(comparator.compare(new Position(3),new Position(3)) == 0);
}","/** 
 * Tests that comparison by property works.
 */
public void testCompare(){
  Comparator comparator=GlazedLists.beanPropertyComparator(Position.class,""String_Node_Str"",new String[0]);
  assertTrue(comparator.compare(new Position(4),new Position(1)) > 0);
  assertTrue(comparator.compare(new Position(1),new Position(4)) < 0);
  assertTrue(comparator.compare(new Position(3),new Position(3)) == 0);
}",0.9823232323232324
32531,"/** 
 * Tests that comparison by property works.
 */
public void testSort(){
  List unsorted=new ArrayList();
  unsorted.add(new Position(4));
  unsorted.add(new Position(1));
  unsorted.add(new Position(3));
  List sorted1=new ArrayList();
  sorted1.addAll(unsorted);
  Collections.sort(sorted1);
  List sorted2=new ArrayList();
  sorted2.addAll(unsorted);
  Collections.sort(sorted2,GlazedLists.beanPropertyComparator(Position.class,""String_Node_Str""));
  assertEquals(sorted1,sorted2);
}","/** 
 * Tests that comparison by property works.
 */
public void testSort(){
  List unsorted=new ArrayList();
  unsorted.add(new Position(4));
  unsorted.add(new Position(1));
  unsorted.add(new Position(3));
  List sorted1=new ArrayList();
  sorted1.addAll(unsorted);
  Collections.sort(sorted1);
  List sorted2=new ArrayList();
  sorted2.addAll(unsorted);
  Collections.sort(sorted2,GlazedLists.beanPropertyComparator(Position.class,""String_Node_Str"",new String[0]));
  assertEquals(sorted1,sorted2);
}",0.9859154929577464
32532,"/** 
 * Tests that the equals() method of the comparator works.
 */
public void testEquals(){
  Comparator red=GlazedLists.beanPropertyComparator(Color.class,""String_Node_Str"");
  Comparator blue=GlazedLists.beanPropertyComparator(Color.class,""String_Node_Str"");
  Comparator rouge=GlazedLists.beanPropertyComparator(Color.class,""String_Node_Str"");
  Comparator blueBeer=GlazedLists.beanPropertyComparator(LabattBeer.class,""String_Node_Str"");
  assertTrue(red.equals(rouge));
  assertFalse(blue.equals(blueBeer));
  assertFalse(red.equals(blue));
}","/** 
 * Tests that the equals() method of the comparator works.
 */
public void testEquals(){
  final String[] empty={};
  Comparator red=GlazedLists.beanPropertyComparator(Color.class,""String_Node_Str"",empty);
  Comparator blue=GlazedLists.beanPropertyComparator(Color.class,""String_Node_Str"",empty);
  Comparator rouge=GlazedLists.beanPropertyComparator(Color.class,""String_Node_Str"",empty);
  Comparator blueBeer=GlazedLists.beanPropertyComparator(LabattBeer.class,""String_Node_Str"",empty);
  assertTrue(red.equals(rouge));
  assertFalse(blue.equals(blueBeer));
  assertFalse(red.equals(blue));
}",0.955536181342633
32533,"public void guiTestSetValueAt_SortedList(){
  final EventList<JLabel> labels=new BasicEventList<JLabel>();
  labels.add(new JLabel(""String_Node_Str""));
  labels.add(new JLabel(""String_Node_Str""));
  labels.add(new JLabel(""String_Node_Str""));
  final ObservableElementList<JLabel> observedLabels=new ObservableElementList<JLabel>(labels,GlazedLists.beanConnector(JLabel.class));
  final SortedList<JLabel> sortedLabels=new SortedList<JLabel>(observedLabels,GlazedLists.beanPropertyComparator(JLabel.class,""String_Node_Str""));
  final EventTableModel<JLabel> tableModel=new EventTableModel<JLabel>(sortedLabels,new LabelTableFormat());
  assertEquals(3,tableModel.getRowCount());
  assertEquals(""String_Node_Str"",tableModel.getValueAt(0,0));
  assertEquals(""String_Node_Str"",tableModel.getValueAt(1,0));
  assertEquals(""String_Node_Str"",tableModel.getValueAt(2,0));
  tableModel.setValueAt(""String_Node_Str"",1,0);
  assertEquals(3,tableModel.getRowCount());
  assertEquals(""String_Node_Str"",tableModel.getValueAt(0,0));
  assertEquals(""String_Node_Str"",tableModel.getValueAt(1,0));
  assertEquals(""String_Node_Str"",tableModel.getValueAt(2,0));
}","public void guiTestSetValueAt_SortedList(){
  final EventList<JLabel> labels=new BasicEventList<JLabel>();
  labels.add(new JLabel(""String_Node_Str""));
  labels.add(new JLabel(""String_Node_Str""));
  labels.add(new JLabel(""String_Node_Str""));
  final ObservableElementList<JLabel> observedLabels=new ObservableElementList<JLabel>(labels,GlazedLists.beanConnector(JLabel.class));
  final SortedList<JLabel> sortedLabels=new SortedList<JLabel>(observedLabels,GlazedLists.beanPropertyComparator(JLabel.class,""String_Node_Str"",new String[0]));
  final EventTableModel<JLabel> tableModel=new EventTableModel<JLabel>(sortedLabels,new LabelTableFormat());
  assertEquals(3,tableModel.getRowCount());
  assertEquals(""String_Node_Str"",tableModel.getValueAt(0,0));
  assertEquals(""String_Node_Str"",tableModel.getValueAt(1,0));
  assertEquals(""String_Node_Str"",tableModel.getValueAt(2,0));
  tableModel.setValueAt(""String_Node_Str"",1,0);
  assertEquals(3,tableModel.getRowCount());
  assertEquals(""String_Node_Str"",tableModel.getValueAt(0,0));
  assertEquals(""String_Node_Str"",tableModel.getValueAt(1,0));
  assertEquals(""String_Node_Str"",tableModel.getValueAt(2,0));
}",0.9939130434782608
32534,"/** 
 * Verifies that the selected index is cleared when the selection is cleared.
 */
public void guiTestClear(){
  EventList<String> list=new BasicEventList<String>();
  EventSelectionModel eventSelectionModel=new EventSelectionModel<String>(list);
  list.addAll(GlazedListsTests.delimitedStringToList(""String_Node_Str""));
  eventSelectionModel.addSelectionInterval(1,4);
  assertEquals(list.subList(1,5),eventSelectionModel.getSelected());
  eventSelectionModel.clearSelection();
  assertEquals(Collections.EMPTY_LIST,eventSelectionModel.getSelected());
  assertEquals(-1,eventSelectionModel.getMinSelectionIndex());
  assertEquals(-1,eventSelectionModel.getMaxSelectionIndex());
  assertEquals(true,eventSelectionModel.isSelectionEmpty());
}","/** 
 * Verifies that the selected index is cleared when the selection is cleared.
 */
public void guiTestClear(){
  EventList<String> list=new BasicEventList<String>();
  EventSelectionModel eventSelectionModel=new EventSelectionModel<String>(list);
  list.addAll(GlazedListsTests.delimitedStringToList(""String_Node_Str""));
  eventSelectionModel.addSelectionInterval(1,4);
  assertEquals(list.subList(1,5),eventSelectionModel.getSelected());
  assertEquals(list.subList(1,5),eventSelectionModel.getTogglingSelected());
  assertEquals(GlazedListsTests.delimitedStringToList(""String_Node_Str""),eventSelectionModel.getDeselected());
  assertEquals(GlazedListsTests.delimitedStringToList(""String_Node_Str""),eventSelectionModel.getTogglingDeselected());
  eventSelectionModel.clearSelection();
  assertEquals(Collections.EMPTY_LIST,eventSelectionModel.getSelected());
  assertEquals(Collections.EMPTY_LIST,eventSelectionModel.getTogglingSelected());
  assertEquals(-1,eventSelectionModel.getMinSelectionIndex());
  assertEquals(-1,eventSelectionModel.getMaxSelectionIndex());
  assertEquals(true,eventSelectionModel.isSelectionEmpty());
  assertEquals(list,eventSelectionModel.getDeselected());
  assertEquals(list,eventSelectionModel.getTogglingDeselected());
}",0.7438841737393909
32535,"/** 
 * Tests that selection survives a sorting.
 */
public void guiTestSort(){
  EventList<Comparable> list=new BasicEventList<Comparable>();
  SortedList<Comparable> sorted=new SortedList<Comparable>(list,null);
  EventSelectionModel<Comparable> eventSelectionModel=new EventSelectionModel<Comparable>(sorted);
  list.addAll(GlazedListsTests.delimitedStringToList(""String_Node_Str""));
  assertEquals(Collections.EMPTY_LIST,eventSelectionModel.getSelected());
  eventSelectionModel.addSelectionInterval(0,0);
  eventSelectionModel.addSelectionInterval(4,4);
  assertEquals(GlazedListsTests.delimitedStringToList(""String_Node_Str""),eventSelectionModel.getSelected());
  sorted.setComparator(GlazedLists.comparableComparator());
  assertEquals(GlazedListsTests.delimitedStringToList(""String_Node_Str""),eventSelectionModel.getSelected());
  sorted.setComparator(GlazedLists.reverseComparator());
  assertEquals(GlazedListsTests.delimitedStringToList(""String_Node_Str""),eventSelectionModel.getSelected());
}","/** 
 * Tests that selection survives a sorting.
 */
public void guiTestSort(){
  EventList<Comparable> list=new BasicEventList<Comparable>();
  SortedList<Comparable> sorted=new SortedList<Comparable>(list,null);
  EventSelectionModel<Comparable> eventSelectionModel=new EventSelectionModel<Comparable>(sorted);
  list.addAll(GlazedListsTests.delimitedStringToList(""String_Node_Str""));
  assertEquals(Collections.EMPTY_LIST,eventSelectionModel.getSelected());
  assertEquals(Collections.EMPTY_LIST,eventSelectionModel.getTogglingSelected());
  assertEquals(list,eventSelectionModel.getDeselected());
  assertEquals(list,eventSelectionModel.getTogglingDeselected());
  eventSelectionModel.addSelectionInterval(0,0);
  eventSelectionModel.addSelectionInterval(4,4);
  assertEquals(GlazedListsTests.delimitedStringToList(""String_Node_Str""),eventSelectionModel.getSelected());
  assertEquals(GlazedListsTests.delimitedStringToList(""String_Node_Str""),eventSelectionModel.getTogglingSelected());
  assertEquals(GlazedListsTests.delimitedStringToList(""String_Node_Str""),eventSelectionModel.getDeselected());
  assertEquals(GlazedListsTests.delimitedStringToList(""String_Node_Str""),eventSelectionModel.getTogglingDeselected());
  sorted.setComparator(GlazedLists.comparableComparator());
  assertEquals(GlazedListsTests.delimitedStringToList(""String_Node_Str""),eventSelectionModel.getSelected());
  assertEquals(GlazedListsTests.delimitedStringToList(""String_Node_Str""),eventSelectionModel.getTogglingSelected());
  assertEquals(GlazedListsTests.delimitedStringToList(""String_Node_Str""),eventSelectionModel.getDeselected());
  assertEquals(GlazedListsTests.delimitedStringToList(""String_Node_Str""),eventSelectionModel.getTogglingDeselected());
  sorted.setComparator(GlazedLists.reverseComparator());
  assertEquals(GlazedListsTests.delimitedStringToList(""String_Node_Str""),eventSelectionModel.getSelected());
  assertEquals(GlazedListsTests.delimitedStringToList(""String_Node_Str""),eventSelectionModel.getTogglingSelected());
  assertEquals(GlazedListsTests.delimitedStringToList(""String_Node_Str""),eventSelectionModel.getDeselected());
  assertEquals(GlazedListsTests.delimitedStringToList(""String_Node_Str""),eventSelectionModel.getTogglingDeselected());
}",0.5394777265745008
32536,"/** 
 * Updates the comparator in use and applies it to the table.
 */
protected final void rebuildComparator(){
  super.rebuildComparator();
  Event sortEvent=new Event();
  sortEvent.widget=table;
  for (Iterator<Listener> i=sortListeners.iterator(); i.hasNext(); ) {
    i.next().handleEvent(sortEvent);
  }
}","/** 
 * Updates the comparator in use and applies it to the table. <p>This method is called when the sorting state changed.</p>
 */
protected final void rebuildComparator(){
  super.rebuildComparator();
  updateTableSortColumn();
  Event sortEvent=new Event();
  sortEvent.widget=table;
  for (Iterator<Listener> i=sortListeners.iterator(); i.hasNext(); ) {
    i.next().handleEvent(sortEvent);
  }
}",0.8764044943820225
32537,"/** 
 * {@inheritDoc} 
 */
public boolean matches(E item){
  filterComparables.clear();
  if (filterator == null)   filterComparables.add((D)item);
 else   filterator.getFilterValues(filterComparables,item);
  for (int c=0; c < filterComparables.size(); c++) {
    D filterComparable=filterComparables.get(c);
    if (filterComparable != null) {
      if (start != null && start.compareTo(filterComparable) == 1)       continue;
      if (end != null && end.compareTo(filterComparable) == -1)       continue;
    }
    return true;
  }
  return false;
}","/** 
 * {@inheritDoc} 
 */
public boolean matches(E item){
  filterComparables.clear();
  if (filterator == null)   filterComparables.add((D)item);
 else   filterator.getFilterValues(filterComparables,item);
  for (int c=0; c < filterComparables.size(); c++) {
    D filterComparable=filterComparables.get(c);
    if (filterComparable != null) {
      if (start != null && start.compareTo(filterComparable) > 0)       continue;
      if (end != null && end.compareTo(filterComparable) < 0)       continue;
    }
    return true;
  }
  return false;
}",0.986400725294651
32538,"/** 
 * Respond to requests for values to fill Virtual rows.
 */
public void handleEvent(Event e){
  TableItem item=(TableItem)e.item;
  int whiteIndex=requested.getWhiteIndex(table.getTopIndex(),false);
  int index=requested.getIndex(whiteIndex,Barcode.WHITE);
  requested.setBlack(index,1);
  renderTableItem(item,source.get(index),index);
}","/** 
 * Respond to requests for values to fill Virtual rows.
 */
public void handleEvent(Event e){
  TableItem item=(TableItem)e.item;
  int whiteIndex=requested.getWhiteIndex(table.indexOf(item),false);
  int index=requested.getIndex(whiteIndex,Barcode.WHITE);
  requested.setBlack(index,1);
  renderTableItem(item,source.get(index),index);
}",0.9650145772594751
32539,"/** 
 * Responds to a single click or arrow key based selection.
 */
public void widgetSelected(SelectionEvent event){
  if (!selectionInProgress) {
    selectionInProgress=true;
    selection.setSelection(selectable.getSelectionIndices());
    selectionInProgress=false;
  }
}","/** 
 * Responds to a single click or arrow key based selection.
 */
public void widgetSelected(SelectionEvent event){
  if (!selectionInProgress) {
    selectionInProgress=true;
    selection.getSource().getReadWriteLock().writeLock().lock();
    try {
      selection.setSelection(selectable.getSelectionIndices());
    }
  finally {
      selection.getSource().getReadWriteLock().writeLock().unlock();
    }
    selectionInProgress=false;
  }
}",0.7651933701657458
32540,"private Table formatIssuesTable(Table issuesTable){
  issuesTable.getVerticalBar().setEnabled(true);
  issuesTable.getColumn(0).setWidth(30);
  issuesTable.getColumn(0).setResizable(false);
  issuesTable.getColumn(1).setWidth(50);
  issuesTable.getColumn(2).setWidth(46);
  issuesTable.getColumn(2).setResizable(false);
  issuesTable.getColumn(3).setWidth(50);
  issuesTable.getColumn(4).setWidth(60);
  issuesTable.getColumn(5).setWidth(250);
  return issuesTable;
}","private Table formatIssuesTable(Table issuesTable){
  issuesTable.getVerticalBar().setEnabled(true);
  return issuesTable;
}",0.4196277495769882
32541,"/** 
 * Constructs a new IssuesBrowser in the given window
 */
private IssuesBrowser(Shell shell){
  usersMatcherEditor=new UsersMatcherEditor(issuesEventList);
  FilterList<Issue> issuesUserFiltered=new FilterList<Issue>(issuesEventList,usersMatcherEditor);
  FilterList<Issue> issuesTextFiltered=new FilterList<Issue>(issuesUserFiltered,Matchers.trueMatcher());
  ThresholdList<Issue> priorityList=new ThresholdList<Issue>(issuesTextFiltered,""String_Node_Str"");
  SortedList<Issue> issuesSortedList=SortedList.create(priorityList);
  SashForm demoForm=new SashForm(shell,SWT.HORIZONTAL);
  GridData demoFormLayout=new GridData();
  demoFormLayout.horizontalAlignment=GridData.FILL;
  demoFormLayout.verticalAlignment=GridData.FILL;
  demoFormLayout.grabExcessHorizontalSpace=true;
  demoFormLayout.grabExcessVerticalSpace=true;
  demoForm.setLayoutData(demoFormLayout);
  GridLayout demoFormContentLayout=new GridLayout(2,false);
  demoFormContentLayout.marginHeight=0;
  demoFormContentLayout.marginWidth=0;
  demoForm.setLayout(demoFormContentLayout);
  Canvas filterPanel=new Canvas(demoForm,SWT.BORDER);
  GridData filterPanelLayout=new GridData();
  filterPanelLayout.horizontalAlignment=GridData.FILL;
  filterPanelLayout.verticalAlignment=GridData.FILL;
  filterPanelLayout.grabExcessHorizontalSpace=true;
  filterPanelLayout.grabExcessVerticalSpace=true;
  filterPanel.setLayoutData(filterPanelLayout);
  GridLayout filterPanelContentLayout=new GridLayout(1,false);
  filterPanelContentLayout.marginHeight=10;
  filterPanelContentLayout.marginWidth=10;
  filterPanelContentLayout.verticalSpacing=15;
  filterPanel.setLayout(filterPanelContentLayout);
  Text filterText=createFilterText(filterPanel);
  final MatcherEditor<Issue> matcherEditor=new TextWidgetMatcherEditor<Issue>(filterText,new IssueTextFilterator());
  issuesTextFiltered.setMatcherEditor(new ThreadedMatcherEditor<Issue>(matcherEditor));
  createPrioritySlider(filterPanel,priorityList);
  createUsersList(shell,filterPanel);
  SashForm issuePanel=new SashForm(demoForm,SWT.VERTICAL);
  GridData issuePanelLayout=new GridData();
  issuePanelLayout.horizontalAlignment=GridData.FILL;
  issuePanelLayout.verticalAlignment=GridData.FILL;
  issuePanelLayout.grabExcessHorizontalSpace=true;
  issuePanelLayout.grabExcessVerticalSpace=true;
  issuePanel.setLayoutData(issuePanelLayout);
  GridLayout issuePanelContentLayout=new GridLayout(1,false);
  issuePanelContentLayout.marginHeight=0;
  issuePanelContentLayout.marginWidth=0;
  issuePanel.setLayout(issuePanelContentLayout);
  Table issuesTable=createIssuesTable(issuePanel);
  EventTableViewer<Issue> issuesTableViewer=new EventTableViewer<Issue>(issuesSortedList,issuesTable,new IssueTableFormat());
  issuesTable=formatIssuesTable(issuesTable);
  TableComparatorChooser.install(issuesTableViewer,issuesSortedList,false);
  createDescriptionsTable(issuePanel,issuesTableViewer);
  issuePanel.setWeights(new int[]{50,50});
  demoForm.setWeights(new int[]{30,70});
  issueLoader.start();
  issueLoader.setProject(Project.getProjects().get(0));
}","/** 
 * Constructs a new IssuesBrowser in the given window
 */
private IssuesBrowser(Shell shell){
  usersMatcherEditor=new UsersMatcherEditor(issuesEventList);
  FilterList<Issue> issuesUserFiltered=new FilterList<Issue>(issuesEventList,usersMatcherEditor);
  FilterList<Issue> issuesTextFiltered=new FilterList<Issue>(issuesUserFiltered,Matchers.trueMatcher());
  ThresholdList<Issue> priorityList=new ThresholdList<Issue>(issuesTextFiltered,""String_Node_Str"");
  SortedList<Issue> issuesSortedList=SortedList.create(priorityList);
  SashForm demoForm=new SashForm(shell,SWT.HORIZONTAL);
  GridData demoFormLayout=new GridData();
  demoFormLayout.horizontalAlignment=GridData.FILL;
  demoFormLayout.verticalAlignment=GridData.FILL;
  demoFormLayout.grabExcessHorizontalSpace=true;
  demoFormLayout.grabExcessVerticalSpace=true;
  demoForm.setLayoutData(demoFormLayout);
  GridLayout demoFormContentLayout=new GridLayout(2,false);
  demoFormContentLayout.marginHeight=0;
  demoFormContentLayout.marginWidth=0;
  demoForm.setLayout(demoFormContentLayout);
  Canvas filterPanel=new Canvas(demoForm,SWT.BORDER);
  GridData filterPanelLayout=new GridData();
  filterPanelLayout.horizontalAlignment=GridData.FILL;
  filterPanelLayout.verticalAlignment=GridData.FILL;
  filterPanelLayout.grabExcessHorizontalSpace=true;
  filterPanelLayout.grabExcessVerticalSpace=true;
  filterPanel.setLayoutData(filterPanelLayout);
  GridLayout filterPanelContentLayout=new GridLayout(1,false);
  filterPanelContentLayout.marginHeight=10;
  filterPanelContentLayout.marginWidth=10;
  filterPanelContentLayout.verticalSpacing=15;
  filterPanel.setLayout(filterPanelContentLayout);
  Text filterText=createFilterText(filterPanel);
  final MatcherEditor<Issue> matcherEditor=new TextWidgetMatcherEditor<Issue>(filterText,new IssueTextFilterator());
  issuesTextFiltered.setMatcherEditor(new ThreadedMatcherEditor<Issue>(matcherEditor));
  createPrioritySlider(filterPanel,priorityList);
  createUsersList(shell,filterPanel);
  SashForm issuePanel=new SashForm(demoForm,SWT.VERTICAL);
  GridData issuePanelLayout=new GridData();
  issuePanelLayout.horizontalAlignment=GridData.FILL;
  issuePanelLayout.verticalAlignment=GridData.FILL;
  issuePanelLayout.grabExcessHorizontalSpace=true;
  issuePanelLayout.grabExcessVerticalSpace=true;
  issuePanel.setLayoutData(issuePanelLayout);
  GridLayout issuePanelContentLayout=new GridLayout(1,false);
  issuePanelContentLayout.marginHeight=0;
  issuePanelContentLayout.marginWidth=0;
  issuePanel.setLayout(issuePanelContentLayout);
  Table issuesTable=createIssuesTable(issuePanel);
  EventTableViewer<Issue> issuesTableViewer=new EventTableViewer<Issue>(issuesSortedList,issuesTable,new SwtIssueTableFormat(),new IssueTableItemRenderer());
  issuesTable=formatIssuesTable(issuesTable);
  TableComparatorChooser.install(issuesTableViewer,issuesSortedList,false);
  createDescriptionsTable(issuePanel,issuesTableViewer);
  issuePanel.setWeights(new int[]{50,50});
  demoForm.setWeights(new int[]{30,70});
  issueLoader.start();
  issueLoader.setProject(Project.getProjects().get(0));
}",0.9948186528497408
32542,"/** 
 * Updates a row with the given value.
 */
public void updateRow(int row,E value){
  if (!isVirtual(row)) {
    requested.setBlack(row,1);
    TableItem item=table.getItem(row);
    setItemText(item,value);
  }
}","/** 
 * Updates a row with the given value.
 */
public void updateRow(int row,E value){
  if (!isVirtual(row)) {
    requested.setBlack(row,1);
    TableItem item=table.getItem(row);
    renderTableItem(item,value);
  }
}",0.958904109589041
32543,"/** 
 * Respond to requests for values to fill Virtual rows.
 */
public void handleEvent(Event e){
  TableItem item=(TableItem)e.item;
  int whiteIndex=requested.getWhiteIndex(table.getTopIndex(),false);
  int index=requested.getIndex(whiteIndex,Barcode.WHITE);
  requested.setBlack(index,1);
  setItemText(item,swtThreadSource.get(index));
}","/** 
 * Respond to requests for values to fill Virtual rows.
 */
public void handleEvent(Event e){
  TableItem item=(TableItem)e.item;
  int whiteIndex=requested.getWhiteIndex(table.getTopIndex(),false);
  int index=requested.getIndex(whiteIndex,Barcode.WHITE);
  requested.setBlack(index,1);
  renderTableItem(item,swtThreadSource.get(index));
}",0.9622093023255814
32544,"/** 
 * Adds a row with the given value.
 */
public void addRow(int row,E value){
  if (row <= getLastIndex()) {
    requested.addBlack(row,1);
    TableItem item=new TableItem(table,0,row);
    setItemText(item,value);
  }
 else {
    requested.addWhite(requested.size(),1);
    table.setItemCount(table.getItemCount() + 1);
  }
}","/** 
 * Adds a row with the given value.
 */
public void addRow(int row,E value){
  if (row <= getLastIndex()) {
    requested.addBlack(row,1);
    TableItem item=new TableItem(table,0,row);
    renderTableItem(item,value);
  }
 else {
    requested.addWhite(requested.size(),1);
    table.setItemCount(table.getItemCount() + 1);
  }
}",0.963963963963964
32545,"/** 
 * Builds the columns and headers for the   {@link Table}
 */
private void initTable(){
  table.setHeaderVisible(true);
  for (int c=0; c < tableFormat.getColumnCount(); c++) {
    TableColumn column=new TableColumn(table,SWT.LEFT,c);
    column.setText(tableFormat.getColumnName(c));
    column.setWidth(80);
  }
}","/** 
 * Builds the columns and headers for the   {@link Table}
 */
private void initTable(){
  table.setHeaderVisible(true);
  final TableColumnConfigurer configurer=getTableColumnConfigurer();
  for (int c=0; c < tableFormat.getColumnCount(); c++) {
    TableColumn column=new TableColumn(table,SWT.LEFT,c);
    column.setText(tableFormat.getColumnName(c));
    column.setWidth(80);
    if (configurer != null) {
      configurer.configure(column,c);
    }
  }
}",0.8173690932311622
32546,"/** 
 * Creates a new viewer for the given   {@link Table} that updates the tablecontents in response to changes on the specified  {@link EventList}. The  {@link Table} is formatted with the specified {@link TableFormat}.
 * @param source the EventList that provides the row objects
 * @param table the Table viewing the source objects
 * @param tableFormat the object responsible for extracting column datafrom the row objects
 */
public EventTableViewer(EventList<E> source,Table table,TableFormat<? super E> tableFormat){
  source.getReadWriteLock().readLock().lock();
  try {
    this.source=swtThreadSource=GlazedListsSWT.swtThreadProxyList(source,table.getDisplay());
    if ((table.getStyle() & SWT.CHECK) == SWT.CHECK)     this.source=checkFilterList=new TableCheckFilterList<E,E>(swtThreadSource,table,tableFormat);
    this.table=table;
    this.tableFormat=tableFormat;
    selection=new SelectionManager<E>(this.source,new SelectableTable());
    if ((table.getStyle() & SWT.VIRTUAL) == SWT.VIRTUAL) {
      tableHandler=new VirtualTableHandler();
    }
 else {
      tableHandler=new DefaultTableHandler();
    }
    initTable();
    tableHandler.populateTable();
    this.source.addListEventListener(this);
  }
  finally {
    source.getReadWriteLock().readLock().unlock();
  }
}","/** 
 * Creates a new viewer for the given   {@link Table} that updates the tablecontents in response to changes on the specified  {@link EventList}. The  {@link Table} is formatted with the specified {@link TableFormat}.  The table items, e.g. the cell values, are formatted with the specified   {@link TableItemRenderer}.
 * @param source the EventList that provides the row objects
 * @param table the Table viewing the source objects
 * @param tableFormat the object responsible for extracting column datafrom the row objects
 * @param tableItemRenderer the renderer responsible to configure TableItems for display
 */
public EventTableViewer(EventList<E> source,Table table,TableFormat<? super E> tableFormat,TableItemRenderer tableItemRenderer){
  source.getReadWriteLock().writeLock().lock();
  try {
    this.source=swtThreadSource=GlazedListsSWT.swtThreadProxyList(source,table.getDisplay());
    if ((table.getStyle() & SWT.CHECK) == SWT.CHECK)     this.source=checkFilterList=new TableCheckFilterList<E,E>(swtThreadSource,table,tableFormat);
    this.table=table;
    this.tableFormat=tableFormat;
    this.tableItemRenderer=tableItemRenderer;
    selection=new SelectionManager<E>(this.source,new SelectableTable());
    if ((table.getStyle() & SWT.VIRTUAL) == SWT.VIRTUAL) {
      tableHandler=new VirtualTableHandler();
    }
 else {
      tableHandler=new DefaultTableHandler();
    }
    initTable();
    tableHandler.populateTable();
    this.source.addListEventListener(this);
  }
  finally {
    source.getReadWriteLock().writeLock().unlock();
  }
}",0.8982873121286263
32547,"/** 
 * Returns a new empty   {@link DebugList} which shares the same{@link ListEventListener} and {@link ReadWriteLock} with this DebugList.This method is particularly useful when debugging a  {@link CompositeList}where some member lists are DebugLists and thus must share an identical publisher and locks in order to participate in the CompositeList.
 */
public DebugList<E> createNewDebugList(){
  return new DebugList<E>(getPublisher(),debugReadWriteLock);
}","/** 
 * Returns a new empty   {@link DebugList} which shares the same{@link ListEventListener} and {@link ReadWriteLock} with this DebugList.This method is particularly useful when debugging a  {@link CompositeList}where some member lists are DebugLists and thus must share an identical publisher and locks in order to participate in the CompositeList.
 */
public <E>DebugList<E> createNewDebugList(){
  return new DebugList<E>(getPublisher(),debugReadWriteLock);
}",0.9967637540453076
32548,"public void testCreateNewDebugList(){
  DebugList<String> list1=new DebugList<String>();
  DebugList<String> list2=list1.createNewDebugList();
  assertSame(list1.getPublisher(),list2.getPublisher());
  assertSame(list1.getReadWriteLock(),list2.getReadWriteLock());
  assertSame(list1.getReadWriteLock().readLock(),list2.getReadWriteLock().readLock());
  assertSame(list1.getReadWriteLock().writeLock(),list2.getReadWriteLock().writeLock());
  list1.add(""String_Node_Str"");
  assertEquals(1,list1.size());
  assertEquals(0,list2.size());
}","public void testCreateNewDebugList(){
  DebugList<String> list1=new DebugList<String>();
  DebugList<Integer> list2=list1.createNewDebugList();
  assertSame(list1.getPublisher(),list2.getPublisher());
  assertSame(list1.getReadWriteLock(),list2.getReadWriteLock());
  assertSame(list1.getReadWriteLock().readLock(),list2.getReadWriteLock().readLock());
  assertSame(list1.getReadWriteLock().writeLock(),list2.getReadWriteLock().writeLock());
  list1.add(""String_Node_Str"");
  assertEquals(1,list1.size());
  assertEquals(0,list2.size());
}",0.989786443825441
32549,"public int compare(String a,String b){
  boolean aIsUpperCase=Character.isUpperCase(a.charAt(0));
  boolean bIsUpperCase=Character.isUpperCase(b.charAt(0));
  return Boolean.valueOf(aIsUpperCase).compareTo(Boolean.valueOf(bIsUpperCase));
}","public int compare(String a,String b){
  boolean aIsUpperCase=Character.isUpperCase(a.charAt(0));
  boolean bIsUpperCase=Character.isUpperCase(b.charAt(0));
  return (bIsUpperCase == aIsUpperCase ? 0 : (aIsUpperCase ? 1 : -1));
}",0.7307692307692307
32550,"public int compareTo(final AFirstLetterComparable o){
  return Character.valueOf(contained.getName().charAt(0)).compareTo(new Character(o.contained.getName().charAt(0)));
}","public int compareTo(final AFirstLetterComparable o){
  return new Character(contained.getName().charAt(0)).compareTo(new Character(o.contained.getName().charAt(0)));
}",0.9647058823529412
32551,"public void listChanged(ListEvent<E> listChanges){
  count++;
}","public void listChanged(ListEvent listChanges){
  lastSource=listChanges.getSourceList();
}",0.7402597402597403
32552,"/** 
 * Construct a new node.
 * @param virtual <code>true</code> if this node is initially virtual
 * @param path the tree path from root to value that this node represents. Itis an error to mutate this path once it has been provided to a node.
 */
private Node(boolean virtual,List<E> path){
  reset();
  this.virtual=virtual;
  this.path=path;
}","/** 
 * Construct a new node.
 * @param virtual <code>true</code> if this node is initially virtual
 * @param path the tree path from root to value that this node represents. Itis an error to mutate this path once it has been provided to a node.
 */
private Node(boolean virtual,List<E> path){
  this.virtual=virtual;
  this.path=path;
}",0.9021897810218978
32553,"private void incrementPredecessor(){
  if (predecessor.siblingAfter != null && predecessor.siblingAfter != current) {
    nodesToAttach.addInOrder(predecessor.siblingAfter);
    predecessor.siblingAfter.siblingBefore=null;
    predecessor.siblingAfter=null;
  }
  predecessorAtOurHeight=predecessor;
  predecessor=predecessor.parent;
}","private void incrementPredecessor(){
  if (predecessor.siblingAfter != null && predecessor.siblingAfter != current) {
    nodesToAttach.queueOutOfOrderNodeForAttaching(predecessor.siblingAfter);
    predecessor.siblingAfter.siblingBefore=null;
    predecessor.siblingAfter=null;
  }
  predecessorAtOurHeight=predecessor;
  predecessor=predecessor.parent;
}",0.402315484804631
32554,"/** 
 * Attach the default parent for the specified node, using the node's ability to describe a prototype for its parent object.
 */
private void createAndAttachParent(){
  Node<E> parent=current.describeParent();
  if (parent != null) {
    addNode(parent,HIDDEN_VIRTUAL,expansionModel,index);
  }
  attachParent(parent,null);
}","/** 
 * Attach the default parent for the specified node, using the node's ability to describe a prototype for its parent object.
 */
private void createAndAttachParent(){
  Node<E> parent=current.describeParent();
  if (parent != null) {
    parent.expanded=expansionModel.isExpanded(parent.getElement(),parent.path);
    addNode(parent,HIDDEN_VIRTUAL,index);
  }
  attachParent(parent,null);
}",0.8606896551724138
32555,"public InitializationData(EventList<E> sourceElements,Format<E> format,Comparator<E> comparator,ExpansionModel<E> expansionModel){
  this.format=format;
  this.expansionModel=expansionModel;
  this.sourceElements=sourceElements;
  this.sourceNodes=new FunctionList<E,Node<E>>(sourceElements,new ElementToTreeNodeFunction<E>(format),NO_OP_FUNCTION);
  if (comparator != null) {
    this.nodeComparator=comparatorToNodeComparator(comparator,format);
    this.sortedList=new SortedList<Node<E>>(sourceNodes,nodeComparator);
  }
 else {
    this.nodeComparator=comparatorToNodeComparator((Comparator)GlazedLists.comparableComparator(),format);
    this.sortedList=null;
  }
}","public InitializationData(EventList<E> sourceElements,Format<E> format,Comparator<E> comparator,ExpansionModel<E> expansionModel){
  this.format=format;
  this.expansionModel=expansionModel;
  this.sourceElements=sourceElements;
  this.sourceNodes=new FunctionList<E,Node<E>>(sourceElements,new ElementToTreeNodeFunction<E>(format,expansionModel),NO_OP_FUNCTION);
  if (comparator != null) {
    this.nodeComparator=comparatorToNodeComparator(comparator,format);
    this.sortedList=new SortedList<Node<E>>(sourceNodes,nodeComparator);
  }
 else {
    this.nodeComparator=comparatorToNodeComparator((Comparator)GlazedLists.comparableComparator(),format);
    this.sortedList=null;
  }
}",0.98894620486367
32556,"/** 
 * Prepare the state of the node and insert it into the datastore. It will still be necessary to attach parent and sibling nodes.
 */
private void addNode(Node<E> node,byte nodeColor,ExpansionModel<E> expansionModel,int realIndex){
  node.expanded=expansionModel.isExpanded(node.getElement(),node.path);
  node.element=data.add(realIndex,ALL_NODES,nodeColor,node,1);
}","/** 
 * Prepare the state of the node and insert it into the datastore. It will still be necessary to attach parent and sibling nodes.
 */
private void addNode(Node<E> node,byte nodeColor,int realIndex){
  node.element=data.add(realIndex,ALL_NODES,nodeColor,node,1);
}",0.8361934477379095
32557,"/** 
 * Handle a source insert at the specified index by adding the corresponding real node, or converting a virtual node to a real node. The real node is inserted, marked as real and hidden, and returned.
 * @param sourceIndex the index of the element in the source list that hasbeen inserted
 * @return the new node, prior to any events fired
 */
private Node<E> findOrInsertNode(int sourceIndex){
  Node<E> inserted=source.get(sourceIndex);
  inserted.reset();
  int predecessorIndex=sourceIndex > 0 ? data.convertIndexColor(sourceIndex - 1,REAL_NODES,ALL_NODES) : -1;
  int followerIndex=data.size(REAL_NODES) > sourceIndex ? data.convertIndexColor(sourceIndex,REAL_NODES,ALL_NODES) : data.size(ALL_NODES);
  int indexOfNearestAncestorByValue=predecessorIndex;
  int lengthOfLongestAncestorCommonPath;
  if (predecessorIndex >= 0) {
    Node<E> predecessor=data.get(predecessorIndex,ALL_NODES).get();
    lengthOfLongestAncestorCommonPath=commonPathLength(inserted,predecessor);
  }
 else {
    lengthOfLongestAncestorCommonPath=0;
  }
  for (int i=predecessorIndex + 1; i < followerIndex; i++) {
    Node<E> possibleAncestor=data.get(i,ALL_NODES).get();
    assert(possibleAncestor.virtual);
    if (possibleAncestor.pathLength() > inserted.pathLength())     continue;
    int commonPathLength=commonPathLength(inserted,possibleAncestor);
    if (commonPathLength == inserted.pathLength()) {
      replaceNode(possibleAncestor,inserted,false);
      return inserted;
    }
 else     if (commonPathLength > lengthOfLongestAncestorCommonPath) {
      lengthOfLongestAncestorCommonPath=commonPathLength;
      indexOfNearestAncestorByValue=i;
    }
  }
  addNode(inserted,HIDDEN_REAL,expansionModel,indexOfNearestAncestorByValue + 1);
  return inserted;
}","/** 
 * Handle a source insert at the specified index by adding the corresponding real node, or converting a virtual node to a real node. The real node is inserted, marked as real and hidden, and returned.
 * @param sourceIndex the index of the element in the source list that hasbeen inserted
 * @return the new node, prior to any events fired
 */
private Node<E> findOrInsertNode(int sourceIndex){
  Node<E> inserted=source.get(sourceIndex);
  inserted.resetDerivedState();
  int predecessorIndex=sourceIndex > 0 ? data.convertIndexColor(sourceIndex - 1,REAL_NODES,ALL_NODES) : -1;
  int followerIndex=data.size(REAL_NODES) > sourceIndex ? data.convertIndexColor(sourceIndex,REAL_NODES,ALL_NODES) : data.size(ALL_NODES);
  int indexOfNearestAncestorByValue=predecessorIndex;
  int lengthOfLongestAncestorCommonPath;
  if (predecessorIndex >= 0) {
    Node<E> predecessor=data.get(predecessorIndex,ALL_NODES).get();
    lengthOfLongestAncestorCommonPath=commonPathLength(inserted,predecessor);
  }
 else {
    lengthOfLongestAncestorCommonPath=0;
  }
  for (int i=predecessorIndex + 1; i < followerIndex; i++) {
    Node<E> possibleAncestor=data.get(i,ALL_NODES).get();
    assert(possibleAncestor.virtual);
    if (possibleAncestor.pathLength() > inserted.pathLength())     continue;
    int commonPathLength=commonPathLength(inserted,possibleAncestor);
    if (commonPathLength == inserted.pathLength()) {
      replaceNode(possibleAncestor,inserted,false);
      return inserted;
    }
 else     if (commonPathLength > lengthOfLongestAncestorCommonPath) {
      lengthOfLongestAncestorCommonPath=commonPathLength;
      indexOfNearestAncestorByValue=i;
    }
  }
  addNode(inserted,HIDDEN_REAL,indexOfNearestAncestorByValue + 1);
  return inserted;
}",0.9923098832241528
32558,"/** 
 * Walk up the tree, fixing parents and siblings of the specified changed node. Performing this fix may require: <li>attaching parents <li>attaching siblings <li>firing an 'insert' event for such parents and siblings
 * @param changed the node to attach parents and siblings to
 * @param newlyInserted <code>true</code> if this node is a brand-newnode in the tree, or <code>false</code> if we're reattaching an existing node. This has significant consequences for the logic that manages expanded state and repairing siblings.
 * @return <code>true</code> if changes were made to the tree
 */
private void attach(Node<E> changed,boolean newlyInserted){
  current=changed;
  if (newlyInserted) {
    expansionModel=TreeList.this.expansionModel;
  }
 else {
    expansionModel=new CloneStateNewNodeStateModel<E>(current);
  }
  index=data.indexOfNode(current.element,ALL_NODES);
  predecessor=current.previous();
  predecessorAtOurHeight=null;
  if (newlyInserted) {
    Node<E> follower=current.next();
    if (follower != null) {
      nodesToAttach.prependPotentiallySplit(follower);
    }
  }
  attachParentsAndSiblings();
  fixVisibilityAndFireEvents();
  pathToRoot.clear();
}","/** 
 * Walk up the tree, fixing parents and siblings of the specified changed node. Performing this fix may require: <li>attaching parents <li>attaching siblings <li>firing an 'insert' event for such parents and siblings
 * @param changed the node to attach parents and siblings to
 * @param newlyInserted <code>true</code> if this node is a brand-newnode in the tree, or <code>false</code> if we're reattaching an existing node. This has significant consequences for the logic that manages expanded state and repairing siblings.
 * @return <code>true</code> if changes were made to the tree
 */
private void attach(Node<E> changed,boolean newlyInserted){
  current=changed;
  if (newlyInserted) {
    expansionModel=TreeList.this.expansionModel;
  }
 else {
    expansionModel=new CloneStateNewNodeStateModel<E>(current);
  }
  index=data.indexOfNode(current.element,ALL_NODES);
  predecessor=current.previous();
  predecessorAtOurHeight=null;
  if (newlyInserted) {
    Node<E> follower=current.next();
    if (follower != null) {
      nodesToAttach.queuePrefixForAttaching(follower);
    }
  }
  attachParentsAndSiblings();
  fixVisibilityAndFireEvents();
  pathToRoot.clear();
}",0.981418918918919
32559,"public ElementToTreeNodeFunction(Format<E> format){
  this.format=format;
}","public ElementToTreeNodeFunction(Format<E> format,ExpansionModel<E> expansionModel){
  this.format=format;
  this.expansionModel=expansionModel;
}",0.6787330316742082
32560,"DelegateLockFactory(){
  try {
    Class.forName(""String_Node_Str"");
    this.delegate=(LockFactory)Class.forName(""String_Node_Str"").newInstance();
  }
 catch (  Exception e) {
    this.delegate=new J2SE14LockFactory();
  }
}","DelegateLockFactory(){
  try {
    Class.forName(""String_Node_Str"");
    delegate=(LockFactory)Class.forName(""String_Node_Str"").newInstance();
  }
 catch (  Throwable t) {
    delegate=new J2SE14LockFactory();
  }
}",0.9272727272727272
32561,"public ReadWriteLock createReadWriteLock(){
  return this.delegate.createReadWriteLock();
}","public ReadWriteLock createReadWriteLock(){
  return delegate.createReadWriteLock();
}",0.9717514124293786
32562,"public Lock createLock(){
  return this.delegate.createLock();
}","public Lock createLock(){
  return delegate.createLock();
}",0.959349593495935
32563,"public Node<E> reevaluate(E sourceValue,Node<E> transformedValue){
  transformedValue.path.clear();
  format.getPath(transformedValue.path,sourceValue);
  return transformedValue;
}","public Node<E> reevaluate(E sourceValue,Node<E> transformedValue){
  assert(!transformedValue.virtual);
  Node<E> result=evaluate(sourceValue);
  result.expanded=transformedValue.expanded;
  return result;
}",0.4845360824742268
32564,"public void testUpdatingElementsRetainExpandCollapseState(){
  EventList<String> source=new BasicEventList<String>();
  TreeList<String> treeList=new TreeList<String>(source,new CharacterTreeFormat(),TreeList.NODES_START_EXPANDED,String.CASE_INSENSITIVE_ORDER);
  ListConsistencyListener<String> listConsistencyListener=ListConsistencyListener.install(treeList);
  listConsistencyListener.setPreviousElementTracked(false);
  source.add(0,""String_Node_Str"");
  source.add(1,""String_Node_Str"");
  source.add(2,""String_Node_Str"");
  source.add(3,""String_Node_Str"");
  treeList.setExpanded(1,false);
  source.set(0,""String_Node_Str"");
  assertTreeStructure(treeList,new String[]{""String_Node_Str"",""String_Node_Str""});
}","public void testUpdatingElementsRetainExpandCollapseState(){
  EventList<String> source=new BasicEventList<String>();
  TreeList<String> treeList=new TreeList<String>(source,new CharacterTreeFormat(),TreeList.NODES_START_EXPANDED,String.CASE_INSENSITIVE_ORDER);
  ListConsistencyListener<String> listConsistencyListener=ListConsistencyListener.install(treeList);
  listConsistencyListener.setPreviousElementTracked(false);
  source.add(0,""String_Node_Str"");
  source.add(1,""String_Node_Str"");
  source.add(2,""String_Node_Str"");
  source.add(3,""String_Node_Str"");
  treeList.setExpanded(2,false);
  treeList.setExpanded(1,false);
  source.set(0,""String_Node_Str"");
  source.set(1,""String_Node_Str"");
  assertTreeStructure(treeList,new String[]{""String_Node_Str"",""String_Node_Str""});
  treeList.setExpanded(1,true);
  assertTreeStructure(treeList,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  assertFalse(treeList.isExpanded(2));
}",0.8382180539273154
32565,"/** 
 * This factory method creates and returns a   {@link DefaultCellEditor}which adapts an autocompleting   {@link JComboBox} for use as a TableCell Editor. The values within the <code>source</code> are used as autocompletion terms within the  {@link ComboBoxModel}. <p>If the appearance or function of the autocompleting   {@link JComboBox}is to be customized, it can be retrieved using  {@link DefaultCellEditor#getComponent()}.
 * @param source the source of data for the JComboBox within the table cell editor
 * @return a {@link DefaultCellEditor} which contains an autocompletingcombobox whose model contents are determined by the given <code>source</code>
 */
public static <E>DefaultCellEditor createTableCellEditor(EventList<E> source){
  final DefaultCellEditor cellEditor=new DefaultCellEditor(new TableCellComboBox());
  cellEditor.setClickCountToStart(2);
  AutoCompleteSupport autoCompleteSupport=AutoCompleteSupport.install((JComboBox)cellEditor.getComponent(),source);
  autoCompleteSupport.setSelectsTextOnFocusGain(false);
  return cellEditor;
}","/** 
 * This factory method creates and returns a   {@link AutoCompleteCellEditor}which adapts an autocompleting   {@link JComboBox} for use as a TableCell Editor. The values within the <code>source</code> are used as autocompletion terms within the  {@link ComboBoxModel}. <p>If the appearance or function of the autocompleting   {@link JComboBox}is to be customized, it can be retrieved using  {@link AutoCompleteCellEditor#getComponent()}.
 * @param source the source of data for the JComboBox within the table cell editor
 * @return a {@link AutoCompleteCellEditor} which contains an autocompletingcombobox whose model contents are determined by the given <code>source</code>
 */
public static <E>AutoCompleteCellEditor<E> createTableCellEditor(EventList<E> source){
  final JComboBox comboBox=new TableCellComboBox();
  comboBox.putClientProperty(""String_Node_Str"",Boolean.TRUE);
  final AutoCompleteSupport<E> autoCompleteSupport=AutoCompleteSupport.install(comboBox,source);
  autoCompleteSupport.setSelectsTextOnFocusGain(false);
  final AutoCompleteCellEditor<E> cellEditor=new AutoCompleteCellEditor<E>(autoCompleteSupport);
  cellEditor.setClickCountToStart(2);
  return cellEditor;
}",0.6973451327433628
32566,"public void guiTestCreateTableCellEditor(){
  final EventList<Integer> ints=new BasicEventList<Integer>();
  ints.add(new Integer(0));
  ints.add(new Integer(10));
  ints.add(new Integer(199));
  ints.add(new Integer(199));
  ints.add(new Integer(10));
  ints.add(new Integer(0));
  DefaultCellEditor editor=AutoCompleteSupport.createTableCellEditor(new IntegerTableFormat(),ints,0);
  JComboBox comboBox=(JComboBox)editor.getComponent();
  assertSame(ints.get(0),comboBox.getItemAt(0));
  assertSame(ints.get(1),comboBox.getItemAt(1));
  assertSame(ints.get(2),comboBox.getItemAt(2));
  editor=AutoCompleteSupport.createTableCellEditor(GlazedLists.reverseComparator(),new IntegerTableFormat(),ints,0);
  comboBox=(JComboBox)editor.getComponent();
  assertSame(ints.get(2),comboBox.getItemAt(0));
  assertSame(ints.get(1),comboBox.getItemAt(1));
  assertSame(ints.get(0),comboBox.getItemAt(2));
}","public void guiTestCreateTableCellEditor(){
  final EventList<Integer> ints=new BasicEventList<Integer>();
  ints.add(new Integer(0));
  ints.add(new Integer(10));
  ints.add(new Integer(199));
  ints.add(new Integer(199));
  ints.add(new Integer(10));
  ints.add(new Integer(0));
  AutoCompleteSupport.AutoCompleteCellEditor editor=AutoCompleteSupport.createTableCellEditor(new IntegerTableFormat(),ints,0);
  JComboBox comboBox=(JComboBox)editor.getComponent();
  assertSame(comboBox,editor.getAutoCompleteSupport().getComboBox());
  assertSame(ints.get(0),comboBox.getItemAt(0));
  assertSame(ints.get(1),comboBox.getItemAt(1));
  assertSame(ints.get(2),comboBox.getItemAt(2));
  editor=AutoCompleteSupport.createTableCellEditor(GlazedLists.reverseComparator(),new IntegerTableFormat(),ints,0);
  comboBox=(JComboBox)editor.getComponent();
  assertSame(comboBox,editor.getAutoCompleteSupport().getComboBox());
  assertSame(ints.get(2),comboBox.getItemAt(0));
  assertSame(ints.get(1),comboBox.getItemAt(1));
  assertSame(ints.get(0),comboBox.getItemAt(2));
}",0.9085334695963208
32567,"/** 
 * Create a new Connector for the   {@link ObservableElementList} that works withJavaBeans'  {@link java.beans.PropertyChangeListener}. The methods to add and remove listeners are specified by name. Such methods must take a single  {@link java.beans.PropertyChangeListener} argument.
 * @param beanClass a class with both methods as specified.
 * @param addListener a method name such as ""addPropertyChangeListener""
 * @param removeListener a method name such as ""removePropertyChangeListener""
 * @return an ObservableElementList.Connector for the specified class
 */
public static <E>ObservableElementList.Connector<E> beanConnector(Class<E> beanClass,String addListener,String removeListener){
  return new JavaBeanEventListConnector<E>(beanClass,addListener,removeListener);
}","/** 
 * Create a new Connector for the   {@link ObservableElementList} that works withJavaBeans'  {@link java.beans.PropertyChangeListener}. The methods to add and remove listeners are specified by name. Such methods must take a single  {@link java.beans.PropertyChangeListener} argument.<p> The event matcher allows filtering of  {@link java.beans.PropertyChangeEvent}s.  Only matching events are delivered to the ObservableElementList. To create a matcher that matches PropertyChangeEvents by property names, you can use  {@link Matchers#propertyEventNameMatcher(boolean,String[])}
 * @param beanClass a class with both methods as specified.
 * @param addListener a method name such as ""addPropertyChangeListener""
 * @param removeListener a method name such as ""removePropertyChangeListener""
 * @param eventMatcher for matching PropertyChangeEvents that will be delivered to theObservableElementList
 * @return an ObservableElementList.Connector for the specified class
 */
public static <E>ObservableElementList.Connector<E> beanConnector(Class<E> beanClass,String addListener,String removeListener,Matcher<PropertyChangeEvent> eventMatcher){
  final JavaBeanEventListConnector<E> result=new JavaBeanEventListConnector<E>(beanClass,addListener,removeListener);
  result.setEventMatcher(eventMatcher);
  return result;
}",0.7388414055080722
32568,"/** 
 * Start listening for PropertyChangeEvents from the specified <code>element</code>. The PropertyChangeListener is installed using reflection.
 * @param element the element to be observed
 * @param listener the listener that was installed on the <code>element</code>in  {@link #installListener(Object)}
 * @throws RuntimeException if the reflection call fails to successfullyuninstall the PropertyChangeListener
 */
public void uninstallListener(E element,EventListener listener){
  try {
    this.removeListenerMethod.invoke(element,this.reflectionParameters);
  }
 catch (  IllegalAccessException e) {
    throw new RuntimeException(e);
  }
catch (  InvocationTargetException e) {
    throw new RuntimeException(e.getCause());
  }
}","/** 
 * Stop listening for PropertyChangeEvents from the specified <code>element</code>. The PropertyChangeListener is uninstalled using reflection.
 * @param element the observed element
 * @param listener the listener that was installed on the <code>element</code>in  {@link #installListener(Object)}
 * @throws RuntimeException if the reflection call fails to successfullyuninstall the PropertyChangeListener
 */
public void uninstallListener(E element,EventListener listener){
  try {
    this.removeListenerMethod.invoke(element,this.reflectionParameters);
  }
 catch (  IllegalAccessException e) {
    throw new RuntimeException(e);
  }
catch (  InvocationTargetException e) {
    throw new RuntimeException(e.getCause());
  }
}",0.9789545145960624
32569,"public void propertyChange(PropertyChangeEvent event){
  ((ObservableElementList)list).elementChanged(event.getSource());
}","public void propertyChange(PropertyChangeEvent event){
  if (getEventMatcher().matches(event))   ((ObservableElementList)list).elementChanged(event.getSource());
}",0.8601398601398601
32570,"/** 
 * Attach the specified parent to the specified node.
 * @param parent the parent node, may be <code>null</code>
 * @param siblingBeforeNode the node immediately before the node of interestwho is a child of the same parent. This will be linked in as the new node's sibling. If <code>null</code>, no linking/unlinking will be performed.
 */
private void attachParent(Node<E> parent,Node<E> siblingBeforeNode){
  assert(current != null);
  assert((current.pathLength() == 1 && parent == null) || (current.pathLength() == parent.pathLength() + 1));
  if (siblingBeforeNode != null && siblingBeforeNode.siblingAfter != current) {
    if (siblingBeforeNode.pathLength() != current.pathLength()) {
      throw new IllegalStateException();
    }
    assert(siblingBeforeNode.parent == parent);
    if (siblingBeforeNode.siblingAfter != null) {
      assert(current.siblingAfter == null);
      current.siblingAfter=siblingBeforeNode.siblingAfter;
      siblingBeforeNode.siblingAfter.siblingBefore=current;
    }
    current.siblingBefore=siblingBeforeNode;
    siblingBeforeNode.siblingAfter=current;
    assert(current.siblingBefore != current);
    assert(current.siblingAfter != current);
  }
  for (Node<E> currentSibling=current; currentSibling != null; currentSibling=currentSibling.siblingAfter) {
    currentSibling.parent=parent;
  }
  incrementCurrent();
}","/** 
 * Attach the specified parent to the specified node.
 * @param parent the parent node, may be <code>null</code>
 * @param siblingBeforeNode the node immediately before the node of interestwho is a child of the same parent. This will be linked in as the new node's sibling. If <code>null</code>, no linking/unlinking will be performed.
 */
private void attachParent(Node<E> parent,Node<E> siblingBeforeNode){
  assert(current != null);
  assert((current.pathLength() == 1 && parent == null) || (current.pathLength() == parent.pathLength() + 1));
  if (siblingBeforeNode != null && siblingBeforeNode.siblingAfter != current) {
    if (siblingBeforeNode.pathLength() != current.pathLength()) {
      throw new IllegalStateException();
    }
    assert(siblingBeforeNode.parent == parent);
    if (siblingBeforeNode.siblingAfter != null) {
      assert(current.siblingAfter == null);
      current.siblingAfter=siblingBeforeNode.siblingAfter;
      siblingBeforeNode.siblingAfter.siblingBefore=current;
    }
    current.siblingBefore=siblingBeforeNode;
    siblingBeforeNode.siblingAfter=current;
    assert(current.siblingBefore != current);
    assert(current.siblingAfter != current);
  }
  for (Node<E> currentSibling=current; currentSibling != null; currentSibling=currentSibling.siblingAfter) {
    currentSibling.parent=parent;
  }
  if (parent != null && !parent.expanded && current.isVisible()) {
    parent.expanded=true;
  }
  incrementCurrent();
}",0.9656880084895648
32571,"/** 
 * The number of nodes including the node itself in its subtree.
 */
public int subtreeSize(int visibleIndex,boolean includeCollapsed){
  byte colorsOut=includeCollapsed ? ALL_NODES : VISIBLE_NODES;
  Node<E> node=data.get(visibleIndex,colorsOut).get();
  Node<E> nextNodeNotInSubtree=nextNodeThatsNotAChildOfByStructure(node);
  if (nextNodeNotInSubtree == null) {
    return data.size(colorsOut) - visibleIndex;
  }
  return data.indexOfNode(nextNodeNotInSubtree.element,colorsOut) - visibleIndex;
}","/** 
 * The number of nodes including the node itself in its subtree.
 */
public int subtreeSize(int visibleIndex,boolean includeCollapsed){
  byte colorsOut=includeCollapsed ? ALL_NODES : VISIBLE_NODES;
  Node<E> node=data.get(visibleIndex,VISIBLE_NODES).get();
  Node<E> nextNodeNotInSubtree=nextNodeThatsNotAChildOfByStructure(node);
  if (nextNodeNotInSubtree == null) {
    return data.size(colorsOut) - visibleIndex;
  }
  return data.indexOfNode(nextNodeNotInSubtree.element,colorsOut) - visibleIndex;
}",0.9783464566929134
32572,"public StartUIRunnable(EventList<Tag> eventList){
  this.eventList=eventList;
}","public StartUIRunnable(EventList<Tag> eventList){
  this.eventList=GlazedListsSwing.swingThreadProxyList(eventList);
}",0.8020304568527918
32573,"public void run(){
  try {
    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
  }
 catch (  Exception e) {
  }
  JTextField filterEdit=new JTextField(15);
  TextFilterator<Tag> filterator=GlazedLists.textFilterator(new String[]{""String_Node_Str"",""String_Node_Str""});
  TextComponentMatcherEditor<Tag> matcherEditor=new TextComponentMatcherEditor<Tag>(filterEdit,filterator);
  JPanel filterPanel=new JPanel(new FlowLayout(FlowLayout.RIGHT));
  filterPanel.add(new JLabel(""String_Node_Str""));
  filterPanel.add(filterEdit);
  SortedList<Tag> sortedList=new SortedList<Tag>(eventList,null);
  FilterList<Tag> filteredList=new FilterList<Tag>(sortedList,matcherEditor);
  TreeList<Tag> treeList=new TreeList<Tag>(filteredList,new TagTreeFormat());
  String[] columnFields=new String[]{""String_Node_Str"",""String_Node_Str""};
  String[] columnNames=new String[]{""String_Node_Str"",""String_Node_Str""};
  EventTableModel<TreeList.Node<Tag>> tableModel=new EventTableModel<TreeList.Node<Tag>>(treeList.getNodesList(),new TagElementTableFormat());
  JTable table=new JTable(tableModel);
  TreeTableSupport treeSupport=TreeTableSupport.install(table,treeList,0);
  treeSupport.setArrowKeyExpansionEnabled(true);
  treeSupport.setShowExpanderForEmptyParent(false);
  TableComparatorChooser.install(table,sortedList,TableComparatorChooser.MULTIPLE_COLUMN_KEYBOARD);
  LookAndFeelTweaks.tweakTable(table);
  JScrollPane tableScrollPane=new JScrollPane(table,JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  tableScrollPane.getViewport().setBackground(UIManager.getColor(""String_Node_Str""));
  EventTreeModel<Tag> treeModel=new EventTreeModel<Tag>(treeList);
  JTree tree=new JTree(treeModel);
  tree.setRootVisible(false);
  tree.setCellRenderer(new TreeListNodeRenderer());
  JScrollPane treeScrollPane=new JScrollPane(tree,JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  Color borderColor=new Color(153,153,204);
  treeScrollPane.setBorder(BorderFactory.createMatteBorder(1,0,0,1,borderColor));
  tableScrollPane.setBorder(BorderFactory.createMatteBorder(1,1,0,0,borderColor));
  MacCornerScrollPaneLayoutManager.install(tableScrollPane);
  JSplitPane splitPane=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,treeScrollPane,tableScrollPane);
  splitPane.setBorder(BorderFactory.createEmptyBorder());
  splitPane.setDividerLocation(200);
  JPanel panel=new JPanel(new BorderLayout());
  panel.add(filterPanel,BorderLayout.NORTH);
  panel.add(splitPane,BorderLayout.CENTER);
  JFrame frame=new JFrame(""String_Node_Str"");
  frame.getContentPane().add(panel);
  frame.setSize(640,480);
  frame.setLocationRelativeTo(null);
  frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  frame.setVisible(true);
}","public void run(){
  try {
    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
  }
 catch (  Exception e) {
  }
  JTextField filterEdit=new JTextField(15);
  TextFilterator<Tag> filterator=GlazedLists.textFilterator(new String[]{""String_Node_Str"",""String_Node_Str""});
  TextComponentMatcherEditor<Tag> matcherEditor=new TextComponentMatcherEditor<Tag>(filterEdit,filterator);
  JPanel filterPanel=new JPanel(new FlowLayout(FlowLayout.RIGHT));
  filterPanel.add(new JLabel(""String_Node_Str""));
  filterPanel.add(filterEdit);
  SortedList<Tag> sortedList=new SortedList<Tag>(eventList,null);
  FilterList<Tag> filteredList=new FilterList<Tag>(sortedList,matcherEditor);
  TreeList<Tag> treeList=new TreeList<Tag>(filteredList,new TagTreeFormat());
  String[] columnFields=new String[]{""String_Node_Str"",""String_Node_Str""};
  String[] columnNames=new String[]{""String_Node_Str"",""String_Node_Str""};
  TableFormat<Tag> tableFormat=GlazedLists.tableFormat(Tag.class,columnFields,columnNames);
  EventTableModel<Tag> tableModel=new EventTableModel<Tag>(treeList,tableFormat);
  JTable table=new JTable(tableModel);
  TreeTableSupport treeSupport=TreeTableSupport.install(table,treeList,0);
  treeSupport.setArrowKeyExpansionEnabled(true);
  treeSupport.setShowExpanderForEmptyParent(false);
  TableComparatorChooser.install(table,sortedList,TableComparatorChooser.MULTIPLE_COLUMN_KEYBOARD);
  LookAndFeelTweaks.tweakTable(table);
  JScrollPane tableScrollPane=new JScrollPane(table,JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  tableScrollPane.getViewport().setBackground(UIManager.getColor(""String_Node_Str""));
  EventTreeModel<Tag> treeModel=new EventTreeModel<Tag>(treeList);
  JTree tree=new JTree(treeModel);
  tree.setRootVisible(false);
  tree.setCellRenderer(new TreeListNodeRenderer());
  JScrollPane treeScrollPane=new JScrollPane(tree,JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  Color borderColor=new Color(153,153,204);
  treeScrollPane.setBorder(BorderFactory.createMatteBorder(1,0,0,1,borderColor));
  tableScrollPane.setBorder(BorderFactory.createMatteBorder(1,1,0,0,borderColor));
  MacCornerScrollPaneLayoutManager.install(tableScrollPane);
  JSplitPane splitPane=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,treeScrollPane,tableScrollPane);
  splitPane.setBorder(BorderFactory.createEmptyBorder());
  splitPane.setDividerLocation(200);
  JPanel panel=new JPanel(new BorderLayout());
  panel.add(filterPanel,BorderLayout.NORTH);
  panel.add(splitPane,BorderLayout.CENTER);
  JFrame frame=new JFrame(""String_Node_Str"");
  frame.getContentPane().add(panel);
  frame.setSize(640,480);
  frame.setLocationRelativeTo(null);
  frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  frame.setVisible(true);
}",0.9678923766816144
32574,"public int getColumnCount(){
  return 4;
}","public int getColumnCount(){
  return 2;
}",0.9761904761904762
32575,"/** 
 * @return <code>true</code> if the node at the specified index haschildren, regardless of whether such children are visible.
 */
public boolean hasChildren(int visibleIndex){
  boolean hasChildren=subtreeSize(visibleIndex,true) > 1;
  boolean isLeaf=getTreeNode(visibleIndex).isLeaf();
  if (isLeaf == hasChildren) {
    subtreeSize(visibleIndex,true);
  }
  return hasChildren;
}","/** 
 * @return <code>true</code> if the node at the specified index haschildren, regardless of whether such children are visible.
 */
public boolean hasChildren(int visibleIndex){
  boolean hasChildren=subtreeSize(visibleIndex,true) > 1;
  boolean isLeaf=getTreeNode(visibleIndex).isLeaf();
  if (isLeaf == hasChildren) {
    subtreeSize(visibleIndex,true,true);
  }
  return hasChildren;
}",0.9935649935649936
32576,"private void validateSubtree(Node<E> node){
  int index=data.indexOfNode(node.element,ALL_NODES);
  int size=subtreeSize(index,true);
  Node<E> lastChildSeen=null;
  for (int i=1; i < size; i++) {
    Node<E> descendent=data.get(index + i,ALL_NODES).get();
    if (descendent.pathLength() == node.pathLength() + 1) {
      if (descendent.parent != node) {
        throw new IllegalStateException();
      }
      assert(descendent.parent == node);
      if (lastChildSeen != descendent.siblingBefore) {
        throw new IllegalStateException();
      }
      if (lastChildSeen != null) {
        if (lastChildSeen.siblingAfter != descendent) {
          throw new IllegalStateException();
        }
        if (lastChildSeen.pathLength() != descendent.pathLength()) {
          throw new IllegalStateException();
        }
      }
 else {
        if (descendent.siblingBefore != null) {
          throw new IllegalStateException();
        }
      }
      lastChildSeen=descendent;
      validateSubtree(descendent);
    }
 else     if (descendent.pathLength() > node.pathLength() + 1) {
    }
 else {
      throw new IllegalStateException();
    }
  }
  assert(lastChildSeen == null || lastChildSeen.siblingAfter == null);
}","private void validateSubtree(Node<E> node){
  int index=data.indexOfNode(node.element,ALL_NODES);
  int size=subtreeSize(index,false,true);
  Node<E> lastChildSeen=null;
  for (int i=1; i < size; i++) {
    Node<E> descendent=data.get(index + i,ALL_NODES).get();
    if (descendent.pathLength() == node.pathLength() + 1) {
      if (descendent.parent != node) {
        throw new IllegalStateException();
      }
      assert(descendent.parent == node);
      if (lastChildSeen != descendent.siblingBefore) {
        throw new IllegalStateException();
      }
      if (lastChildSeen != null) {
        if (lastChildSeen.siblingAfter != descendent) {
          throw new IllegalStateException();
        }
        if (lastChildSeen.pathLength() != descendent.pathLength()) {
          throw new IllegalStateException();
        }
      }
 else {
        if (descendent.siblingBefore != null) {
          throw new IllegalStateException();
        }
      }
      lastChildSeen=descendent;
      validateSubtree(descendent);
    }
 else     if (descendent.pathLength() > node.pathLength() + 1) {
    }
 else {
      throw new IllegalStateException();
    }
  }
  assert(lastChildSeen == null || lastChildSeen.siblingAfter == null);
}",0.997558991049634
32577,"/** 
 * The number of nodes including the node itself in its subtree.
 */
public int subtreeSize(int index,boolean includeCollapsed){
  byte colorsOut=includeCollapsed ? ALL_NODES : VISIBLE_NODES;
  Node<E> node=data.get(index,colorsOut).get();
  Node<E> nextNodeNotInSubtree=nextNodeThatsNotAChildOfByStructure(node);
  if (nextNodeNotInSubtree == null) {
    return data.size(colorsOut) - index;
  }
  return data.indexOfNode(nextNodeNotInSubtree.element,colorsOut) - index;
}","/** 
 * The number of nodes including the node itself in its subtree.
 */
public int subtreeSize(int visibleIndex,boolean includeCollapsed){
  return subtreeSize(visibleIndex,true,includeCollapsed);
}",0.4572271386430678
32578,"/** 
 * @return <code>true</code> if the node at the specified index haschildren, regardless of whether such children are visible.
 */
public boolean hasChildren(int visibleIndex){
  return subtreeSize(visibleIndex,true) > 1;
}","/** 
 * @return <code>true</code> if the node at the specified index haschildren, regardless of whether such children are visible.
 */
public boolean hasChildren(int visibleIndex){
  boolean hasChildren=subtreeSize(visibleIndex,true) > 1;
  boolean isLeaf=getTreeNode(visibleIndex).isLeaf();
  if (isLeaf == hasChildren) {
    subtreeSize(visibleIndex,true);
  }
  return hasChildren;
}",0.7177814029363785
32579,"/** 
 * The number of nodes including the node itself in its subtree.
 */
public int subtreeSize(int visibleIndex,boolean includeCollapsed){
  byte colorsOut=includeCollapsed ? ALL_NODES : VISIBLE_NODES;
  Node<E> node=data.get(visibleIndex,VISIBLE_NODES).get();
  Node<E> nextNodeNotInSubtree=nextNodeThatsNotAChildOfByStructure(node);
  if (nextNodeNotInSubtree == null) {
    return data.size(colorsOut) - visibleIndex;
  }
  return data.indexOfNode(nextNodeNotInSubtree.element,colorsOut) - visibleIndex;
}","/** 
 * The number of nodes including the node itself in its subtree.
 */
public int subtreeSize(int index,boolean includeCollapsed){
  byte colorsOut=includeCollapsed ? ALL_NODES : VISIBLE_NODES;
  Node<E> node=data.get(index,colorsOut).get();
  Node<E> nextNodeNotInSubtree=nextNodeThatsNotAChildOfByStructure(node);
  if (nextNodeNotInSubtree == null) {
    return data.size(colorsOut) - index;
  }
  return data.indexOfNode(nextNodeNotInSubtree.element,colorsOut) - index;
}",0.7854251012145749
32580,"/** 
 * {@inheritDoc} 
 */
public void listChanged(ListEvent<S> listChanges){
  updates.beginEvent(true);
  if (listChanges.isReordering()) {
    final int[] reorderMap=listChanges.getReorderMap();
    final List<E> originalMappedElements=new ArrayList<E>(mappedElements);
    for (int i=0; i < reorderMap.length; i++) {
      final int sourceIndex=reorderMap[i];
      final E replaced=mappedElements.set(i,originalMappedElements.get(sourceIndex));
      updates.elementUpdated(i,replaced);
    }
  }
 else {
    while (listChanges.next()) {
      final int changeIndex=listChanges.getIndex();
      final int changeType=listChanges.getType();
      if (changeType == ListEvent.INSERT) {
        final S inserted=source.get(changeIndex);
        sourceElements.add(changeIndex,inserted);
        mappedElements.add(changeIndex,forward(inserted));
        updates.addInsert(changeIndex);
      }
 else       if (changeType == ListEvent.UPDATE) {
        final E replaced=get(changeIndex);
        final S updated=source.get(changeIndex);
        sourceElements.set(changeIndex,updated);
        mappedElements.set(changeIndex,forward(replaced,updated));
        updates.elementUpdated(changeIndex,replaced);
      }
 else       if (changeType == ListEvent.DELETE) {
        final S deletedSource=sourceElements.remove(changeIndex);
        final E deletedTransform=mappedElements.remove(changeIndex);
        forward.dispose(deletedSource,deletedTransform);
        updates.elementDeleted(changeIndex,deletedTransform);
      }
    }
  }
  updates.commitEvent();
}","/** 
 * {@inheritDoc} 
 */
public void listChanged(ListEvent<S> listChanges){
  updates.beginEvent(true);
  if (listChanges.isReordering()) {
    final int[] reorderMap=listChanges.getReorderMap();
    final List<E> originalMappedElements=new ArrayList<E>(mappedElements);
    for (int i=0; i < reorderMap.length; i++) {
      final int sourceIndex=reorderMap[i];
      mappedElements.set(i,originalMappedElements.get(sourceIndex));
    }
    updates.reorder(reorderMap);
  }
 else {
    while (listChanges.next()) {
      final int changeIndex=listChanges.getIndex();
      final int changeType=listChanges.getType();
      if (changeType == ListEvent.INSERT) {
        final S inserted=source.get(changeIndex);
        sourceElements.add(changeIndex,inserted);
        mappedElements.add(changeIndex,forward(inserted));
        updates.addInsert(changeIndex);
      }
 else       if (changeType == ListEvent.UPDATE) {
        final E replaced=get(changeIndex);
        final S updated=source.get(changeIndex);
        sourceElements.set(changeIndex,updated);
        mappedElements.set(changeIndex,forward(replaced,updated));
        updates.elementUpdated(changeIndex,replaced);
      }
 else       if (changeType == ListEvent.DELETE) {
        final S deletedSource=sourceElements.remove(changeIndex);
        final E deletedTransform=mappedElements.remove(changeIndex);
        forward.dispose(deletedSource,deletedTransform);
        updates.elementDeleted(changeIndex,deletedTransform);
      }
    }
  }
  updates.commitEvent();
}",0.970341715022566
32581,"/** 
 * {@inheritDoc} 
 */
public void listChanged(ListEvent<S> listChanges){
  while (listChanges.next()) {
    final int changeIndex=listChanges.getIndex();
    final int changeType=listChanges.getType();
    if (changeType == ListEvent.INSERT) {
      final S inserted=source.get(changeIndex);
      this.sourceElements.add(changeIndex,inserted);
      this.mappedElements.add(changeIndex,this.forward(inserted));
    }
 else     if (changeType == ListEvent.UPDATE) {
      final S updated=source.get(changeIndex);
      this.sourceElements.set(changeIndex,updated);
      this.mappedElements.set(changeIndex,this.forward(this.get(changeIndex),updated));
    }
 else     if (changeType == ListEvent.DELETE) {
      final S deletedSource=this.sourceElements.remove(changeIndex);
      final E deletedTransform=this.mappedElements.remove(changeIndex);
      this.forward.dispose(deletedSource,deletedTransform);
    }
  }
  listChanges.reset();
  updates.forwardEvent(listChanges);
}","/** 
 * {@inheritDoc} 
 */
public void listChanged(ListEvent<S> listChanges){
  if (listChanges.isReordering()) {
    int[] reorderMap=listChanges.getReorderMap();
    List<E> originalMappedElements=new ArrayList(mappedElements);
    for (int i=0; i < reorderMap.length; i++) {
      mappedElements.set(i,originalMappedElements.get(reorderMap[i]));
    }
  }
 else {
    while (listChanges.next()) {
      final int changeIndex=listChanges.getIndex();
      final int changeType=listChanges.getType();
      if (changeType == ListEvent.INSERT) {
        final S inserted=source.get(changeIndex);
        this.sourceElements.add(changeIndex,inserted);
        this.mappedElements.add(changeIndex,this.forward(inserted));
      }
 else       if (changeType == ListEvent.UPDATE) {
        final S updated=source.get(changeIndex);
        this.sourceElements.set(changeIndex,updated);
        this.mappedElements.set(changeIndex,this.forward(this.get(changeIndex),updated));
      }
 else       if (changeType == ListEvent.DELETE) {
        final S deletedSource=this.sourceElements.remove(changeIndex);
        final E deletedTransform=this.mappedElements.remove(changeIndex);
        this.forward.dispose(deletedSource,deletedTransform);
      }
    }
  }
  listChanges.reset();
  updates.forwardEvent(listChanges);
}",0.8560243584167029
32582,"public void listChanged(ListEvent<E> listChanges){
  Assert.assertEquals(source,listChanges.getSource());
  assertEventsInIncreasingOrder(listChanges);
  if (verbose)   System.out.println(name + ""String_Node_Str"" + listChanges+ ""String_Node_Str""+ source.size()+ ""String_Node_Str""+ source);
  List<Integer> changedIndices=new ArrayList<Integer>();
  int highestChangeIndex=0;
  if (listChanges.isReordering()) {
    int[] reorderMap=listChanges.getReorderMap();
    Assert.assertEquals(expected.size(),reorderMap.length);
    List<E> newExpectedValues=new ArrayList<E>(expected.size());
    for (int i=0; i < reorderMap.length; i++) {
      newExpectedValues.add(i,expected.get(reorderMap[i]));
      changedIndices.add(new Integer(i));
    }
    expected=newExpectedValues;
    changeCounts.add(new Integer(2 * reorderMap.length));
    reorderings.add(Boolean.TRUE);
  }
 else {
    int changesForEvent=0;
    while (listChanges.next()) {
      changesForEvent++;
      int changeIndex=listChanges.getIndex();
      int changeType=listChanges.getType();
      changedIndices.add(new Integer(changeIndex));
      Assert.assertTrue(changeIndex >= 0);
      Assert.assertTrue(changeIndex >= highestChangeIndex);
      highestChangeIndex=changeIndex;
      if (changeType == ListEvent.INSERT) {
        expected.add(changeIndex,source.get(changeIndex));
      }
 else       if (changeType == ListEvent.DELETE) {
        Object removed=expected.remove(changeIndex);
        if (previousElementTracked) {
          Object reportedRemoved=listChanges.getPreviousValue();
          Assert.assertSame(removed,reportedRemoved);
        }
      }
 else       if (changeType == ListEvent.UPDATE) {
        Object replaced=expected.set(changeIndex,source.get(changeIndex));
        if (previousElementTracked) {
          Object reportedReplaced=listChanges.getPreviousValue();
          Assert.assertSame(replaced,reportedReplaced);
        }
      }
    }
    changeCounts.add(new Integer(changesForEvent));
    reorderings.add(Boolean.FALSE);
  }
  Assert.assertEquals(expected,source);
}","public void listChanged(ListEvent<E> listChanges){
  Assert.assertEquals(source,listChanges.getSource());
  assertEventsInIncreasingOrder(listChanges);
  if (verbose)   System.out.println(name + ""String_Node_Str"" + listChanges+ ""String_Node_Str""+ source.size()+ ""String_Node_Str""+ source);
  List<Integer> changedIndices=new ArrayList<Integer>();
  int highestChangeIndex=0;
  if (listChanges.isReordering()) {
    int[] reorderMap=listChanges.getReorderMap();
    Assert.assertEquals(expected.size(),reorderMap.length);
    List<E> newExpectedValues=new ArrayList<E>(expected.size());
    for (int i=0; i < reorderMap.length; i++) {
      newExpectedValues.add(i,expected.get(reorderMap[i]));
      changedIndices.add(new Integer(i));
    }
    expected=newExpectedValues;
    changeCounts.add(new Integer(2 * reorderMap.length));
    reorderings.add(Boolean.TRUE);
  }
 else {
    int changesForEvent=0;
    while (listChanges.next()) {
      changesForEvent++;
      int changeIndex=listChanges.getIndex();
      int changeType=listChanges.getType();
      changedIndices.add(new Integer(changeIndex));
      Assert.assertTrue(changeIndex >= 0);
      Assert.assertTrue(changeIndex >= highestChangeIndex);
      highestChangeIndex=changeIndex;
      if (changeType == ListEvent.INSERT) {
        expected.add(changeIndex,source.get(changeIndex));
      }
 else       if (changeType == ListEvent.DELETE) {
        Object removed=expected.remove(changeIndex);
        if (previousElementTracked) {
          Object reportedRemoved=listChanges.getPreviousValue();
          Assert.assertSame(removed,reportedRemoved);
        }
      }
 else       if (changeType == ListEvent.UPDATE) {
        Object replaced=expected.set(changeIndex,source.get(changeIndex));
        if (previousElementTracked) {
          Object reportedReplaced=listChanges.getPreviousValue();
          Assert.assertSame(replaced,reportedReplaced);
        }
      }
    }
    changeCounts.add(new Integer(changesForEvent));
    reorderings.add(Boolean.FALSE);
  }
  Assert.assertEquals(expected.size(),source.size());
  for (int i=0; i < expected.size(); i++) {
    Assert.assertSame(""String_Node_Str"" + i,expected.get(i),source.get(i));
  }
}",0.966464834653004
32583,"public Node<E> reevaluate(E sourceValue,Node<E> transformedValue){
  format.getPath(workingPath,sourceValue);
  transformedValue.path=new ArrayList<E>(workingPath);
  workingPath.clear();
  return transformedValue;
}","public Node<E> reevaluate(E sourceValue,Node<E> transformedValue){
  transformedValue.path.clear();
  format.getPath(transformedValue.path,sourceValue);
  return transformedValue;
}",0.6448362720403022
32584,"/** 
 * Lookup the ancestor of this node whose path length is the length specified. For example, the ancestor of path length 2 of the node <code>/Users/jessewilson/Desktop/yarbo.mp4</code> is the node <code>/Users/jessewilson</code>. <p>If the ancestor path length is the same as this node's path length, then this node will be returned.
 */
public Node<E> ancestorWithPathLength(int ancestorPathLength){
  assert(pathLength() >= ancestorPathLength);
  Node<E> ancestor=this;
  while (ancestor.pathLength() > ancestorPathLength) {
    ancestor=ancestor.parent;
    if (ancestor == null) {
      throw new IllegalStateException();
    }
  }
  return ancestor;
}","/** 
 * Lookup the ancestor of this node whose path length is the length specified. For example, the ancestor of path length 2 of the node <code>/Users/jessewilson/Desktop/yarbo.mp4</code> is the node <code>/Users/jessewilson</code>. <p>If the ancestor path length is the same as this node's path length, then this node will be returned.
 */
private Node<E> ancestorWithPathLength(int ancestorPathLength){
  assert(pathLength() >= ancestorPathLength);
  Node<E> ancestor=this;
  while (ancestor.pathLength() > ancestorPathLength) {
    ancestor=ancestor.parent;
    if (ancestor == null) {
      throw new IllegalStateException();
    }
  }
  return ancestor;
}",0.991672975018925
32585,"/** 
 * Attach the specified parent to the specified node.
 * @param parent the parent node, may be <code>null</code>
 * @param siblingBeforeNode the node immediately before the node of interestwho is a child of the same parent. This will be linked in as the new node's sibling. If <code>null</code>, no linking/unlinking will be performed.
 */
private void attachParent(Node<E> parent,Node<E> siblingBeforeNode){
  assert(current != null);
  assert((current.pathLength() == 1 && parent == null) || (current.pathLength() == parent.pathLength() + 1));
  if (siblingBeforeNode != null && siblingBeforeNode.siblingAfter != current) {
    if (siblingBeforeNode.pathLength() != current.pathLength()) {
      throw new IllegalStateException();
    }
    assert(siblingBeforeNode.parent == parent);
    if (siblingBeforeNode.siblingAfter != null) {
      assert(current.siblingAfter == null);
      current.siblingAfter=siblingBeforeNode.siblingAfter;
      siblingBeforeNode.siblingAfter.siblingBefore=current;
    }
    current.siblingBefore=siblingBeforeNode;
    siblingBeforeNode.siblingAfter=current;
    assert(current.siblingBefore != current);
    assert(current.siblingAfter != current);
  }
  for (Node<E> currentSibling=current; currentSibling != null; currentSibling=currentSibling.siblingAfter) {
    if (currentSibling.parent != parent) {
      currentSibling.parent=parent;
    }
  }
  incrementCurrent();
}","/** 
 * Attach the specified parent to the specified node.
 * @param parent the parent node, may be <code>null</code>
 * @param siblingBeforeNode the node immediately before the node of interestwho is a child of the same parent. This will be linked in as the new node's sibling. If <code>null</code>, no linking/unlinking will be performed.
 */
private void attachParent(Node<E> parent,Node<E> siblingBeforeNode){
  assert(current != null);
  assert((current.pathLength() == 1 && parent == null) || (current.pathLength() == parent.pathLength() + 1));
  if (siblingBeforeNode != null && siblingBeforeNode.siblingAfter != current) {
    if (siblingBeforeNode.pathLength() != current.pathLength()) {
      throw new IllegalStateException();
    }
    assert(siblingBeforeNode.parent == parent);
    if (siblingBeforeNode.siblingAfter != null) {
      assert(current.siblingAfter == null);
      current.siblingAfter=siblingBeforeNode.siblingAfter;
      siblingBeforeNode.siblingAfter.siblingBefore=current;
    }
    current.siblingBefore=siblingBeforeNode;
    siblingBeforeNode.siblingAfter=current;
    assert(current.siblingBefore != current);
    assert(current.siblingAfter != current);
  }
  for (Node<E> currentSibling=current; currentSibling != null; currentSibling=currentSibling.siblingAfter) {
    currentSibling.parent=parent;
  }
  incrementCurrent();
}",0.9608054656598346
32586,"/** 
 * Create a   {@link Node} that resembles the parent of this.
 */
private Node<E> describeParent(){
  int pathLength=pathLength();
  if (pathLength == 1)   return null;
  Node<E> result=new Node<E>();
  result.path=path.subList(0,pathLength - 1);
  result.virtual=true;
  return result;
}","/** 
 * Create a   {@link Node} that resembles the parent of this.
 */
private Node<E> describeParent(){
  int pathLength=pathLength();
  if (pathLength == 1)   return null;
  return new Node<E>(true,path.subList(0,pathLength - 1));
}",0.8197343453510436
32587,"/** 
 * @return the node that follows this one, or <code>null</code> if thereis no such node.
 */
public Node<E> next(){
  Element<Node<E>> next=element.next();
  return (next == null) ? null : next.get();
}","/** 
 * @return the node that follows this one, or <code>null</code> if thereis no such node.
 */
private Node<E> next(){
  Element<Node<E>> next=element.next();
  return (next == null) ? null : next.get();
}",0.9734939759036144
32588,"/** 
 * Handle a source insert at the specified index by adding the corresponding real node, or converting a virtual node to a real node. The real node is inserted, marked as real and hidden, and returned.
 * @param sourceIndex the index of the element in the source list that hasbeen inserted
 * @return the new node, prior to any events fired
 */
private Node<E> findOrInsertNode(int sourceIndex){
  Node<E> inserted=source.get(sourceIndex);
  int predecessorIndex=sourceIndex > 0 ? data.convertIndexColor(sourceIndex - 1,REAL_NODES,ALL_NODES) : -1;
  int followerIndex=data.size(REAL_NODES) > sourceIndex ? data.convertIndexColor(sourceIndex,REAL_NODES,ALL_NODES) : data.size(ALL_NODES);
  int indexOfNearestAncestorByValue=predecessorIndex;
  int lengthOfLongestAncestorCommonPath;
  if (predecessorIndex >= 0) {
    Node<E> predecessor=data.get(predecessorIndex,ALL_NODES).get();
    lengthOfLongestAncestorCommonPath=commonPathLength(inserted,predecessor);
  }
 else {
    lengthOfLongestAncestorCommonPath=0;
  }
  for (int i=predecessorIndex + 1; i < followerIndex; i++) {
    Node<E> possibleAncestor=data.get(i,ALL_NODES).get();
    assert(possibleAncestor.virtual);
    if (possibleAncestor.pathLength() > inserted.pathLength())     continue;
    int commonPathLength=commonPathLength(inserted,possibleAncestor);
    if (commonPathLength == inserted.pathLength()) {
      assert(inserted.pathLength() == possibleAncestor.pathLength());
      inserted.updateFrom(possibleAncestor);
      possibleAncestor.element.set(inserted);
      setVirtual(possibleAncestor,false);
      for (Node<E> child=possibleAncestor.firstChild(); child != null; child=child.siblingAfter) {
        child.parent=inserted;
      }
      possibleAncestor.element=null;
      return inserted;
    }
 else     if (commonPathLength > lengthOfLongestAncestorCommonPath) {
      lengthOfLongestAncestorCommonPath=commonPathLength;
      indexOfNearestAncestorByValue=i;
    }
  }
  inserted.element=data.add(indexOfNearestAncestorByValue + 1,ALL_NODES,HIDDEN_REAL,inserted,1);
  return inserted;
}","/** 
 * Handle a source insert at the specified index by adding the corresponding real node, or converting a virtual node to a real node. The real node is inserted, marked as real and hidden, and returned.
 * @param sourceIndex the index of the element in the source list that hasbeen inserted
 * @return the new node, prior to any events fired
 */
private Node<E> findOrInsertNode(int sourceIndex){
  Node<E> inserted=source.get(sourceIndex);
  inserted.reset();
  int predecessorIndex=sourceIndex > 0 ? data.convertIndexColor(sourceIndex - 1,REAL_NODES,ALL_NODES) : -1;
  int followerIndex=data.size(REAL_NODES) > sourceIndex ? data.convertIndexColor(sourceIndex,REAL_NODES,ALL_NODES) : data.size(ALL_NODES);
  int indexOfNearestAncestorByValue=predecessorIndex;
  int lengthOfLongestAncestorCommonPath;
  if (predecessorIndex >= 0) {
    Node<E> predecessor=data.get(predecessorIndex,ALL_NODES).get();
    lengthOfLongestAncestorCommonPath=commonPathLength(inserted,predecessor);
  }
 else {
    lengthOfLongestAncestorCommonPath=0;
  }
  for (int i=predecessorIndex + 1; i < followerIndex; i++) {
    Node<E> possibleAncestor=data.get(i,ALL_NODES).get();
    assert(possibleAncestor.virtual);
    if (possibleAncestor.pathLength() > inserted.pathLength())     continue;
    int commonPathLength=commonPathLength(inserted,possibleAncestor);
    if (commonPathLength == inserted.pathLength()) {
      assert(inserted.pathLength() == possibleAncestor.pathLength());
      inserted.updateFrom(possibleAncestor);
      possibleAncestor.element.set(inserted);
      setVirtual(possibleAncestor,false);
      for (Node<E> child=possibleAncestor.firstChild(); child != null; child=child.siblingAfter) {
        child.parent=inserted;
      }
      possibleAncestor.element=null;
      return inserted;
    }
 else     if (commonPathLength > lengthOfLongestAncestorCommonPath) {
      lengthOfLongestAncestorCommonPath=commonPathLength;
      indexOfNearestAncestorByValue=i;
    }
  }
  inserted.element=data.add(indexOfNearestAncestorByValue + 1,ALL_NODES,HIDDEN_REAL,inserted,1);
  return inserted;
}",0.9952107279693486
32589,"/** 
 * @return the node that precedes this one, or <code>null</code> if thereis no such node.
 */
public Node<E> previous(){
  Element<Node<E>> previous=element.previous();
  return (previous == null) ? null : previous.get();
}","/** 
 * @return the node that precedes this one, or <code>null</code> if thereis no such node.
 */
private Node<E> previous(){
  Element<Node<E>> previous=element.previous();
  return (previous == null) ? null : previous.get();
}",0.975929978118162
32590,"/** 
 * Sanity check the entire datastructure.
 */
private boolean isValid(){
  assert(source.size() == data.size(REAL_NODES));
  int lastPathLengthSeen=0;
  for (int i=0; i < data.size(ALL_NODES); i++) {
    Node<E> node=data.get(i,ALL_NODES).get();
    assert(node.pathLength() <= lastPathLengthSeen + 1);
    lastPathLengthSeen=node.pathLength();
    assert(isVisibilityValid(node));
    if (node.virtual) {
      assert(node.element.getColor() == HIDDEN_VIRTUAL || node.element.getColor() == VISIBLE_VIRTUAL);
    }
 else {
      assert(source.get(data.convertIndexColor(i,ALL_NODES,REAL_NODES)) == node);
      assert(node.element.getColor() == HIDDEN_REAL || node.element.getColor() == VISIBLE_REAL);
    }
    if (node.pathLength() == 1) {
      validateSubtree(node);
    }
  }
  return true;
}","/** 
 * Sanity check the entire datastructure.
 */
private boolean isValid(){
  assert(source.size() == data.size(REAL_NODES));
  int lastPathLengthSeen=0;
  for (int i=0; i < data.size(ALL_NODES); i++) {
    Node<E> node=data.get(i,ALL_NODES).get();
    assert(node.pathLength() <= lastPathLengthSeen + 1);
    lastPathLengthSeen=node.pathLength();
    assert(isVisibilityValid(node));
    if (node.virtual) {
      assert(node.element.getColor() == HIDDEN_VIRTUAL || node.element.getColor() == VISIBLE_VIRTUAL);
    }
 else {
      if (source.get(data.convertIndexColor(i,ALL_NODES,REAL_NODES)) != node) {
        throw new IllegalStateException();
      }
      assert(node.element.getColor() == HIDDEN_REAL || node.element.getColor() == VISIBLE_REAL);
    }
    if (node.pathLength() == 1) {
      validateSubtree(node);
    }
  }
  return true;
}",0.9522081064730792
32591,"/** 
 * Attach the specified parent to the specified node.
 * @param node the node to be attached as parent
 * @param parent the parent node, may be <code>null</code>
 * @param siblingBeforeNode the node immediately before the node of interestwho is a child of the same parent. This will be linked in as the new node's sibling
 */
private void attachParent(Node<E> node,Node<E> parent,Node<E> siblingBeforeNode){
  assert(node != null);
  assert((node.pathLength() == 1 && parent == null) || (node.pathLength() == parent.pathLength() + 1));
  Node<E> originalParent=node.parent;
  node.parent=parent;
  if (siblingBeforeNode != null) {
    assert(siblingBeforeNode.pathLength() == node.pathLength());
    assert(siblingBeforeNode.parent == parent);
    node.siblingBefore=siblingBeforeNode;
    siblingBeforeNode.siblingAfter=node;
  }
  for (Node<E> siblingAfter=node.siblingAfter; siblingAfter != null; siblingAfter=siblingAfter.siblingAfter) {
    assert(siblingAfter.parent == originalParent);
    siblingAfter.parent=parent;
    assert(isVisibilityValid(siblingAfter));
  }
}","/** 
 * Attach the specified parent to the specified node.
 * @param node the node to be attached as parent
 * @param parent the parent node, may be <code>null</code>
 * @param siblingBeforeNode the node immediately before the node of interestwho is a child of the same parent. This will be linked in as the new node's sibling
 */
private void attachParent(Node<E> node,Node<E> parent,Node<E> siblingBeforeNode){
  assert(node != null);
  assert((node.pathLength() == 1 && parent == null) || (node.pathLength() == parent.pathLength() + 1));
  node.parent=parent;
  if (siblingBeforeNode != null) {
    assert(siblingBeforeNode.pathLength() == node.pathLength());
    assert(siblingBeforeNode.parent == parent);
    if (siblingBeforeNode.siblingAfter != null) {
      assert(node.siblingAfter == null);
      node.siblingAfter=siblingBeforeNode.siblingAfter;
      siblingBeforeNode.siblingAfter.siblingBefore=node;
    }
    node.siblingBefore=siblingBeforeNode;
    siblingBeforeNode.siblingAfter=node;
  }
  for (Node<E> siblingAfter=node.siblingAfter; siblingAfter != null; siblingAfter=siblingAfter.siblingAfter) {
    siblingAfter.parent=parent;
    assert(isVisibilityValid(siblingAfter));
  }
}",0.5655414291977203
32592,"/** 
 * Construct a frame for search and browsing items from Amazon.
 */
private JPanel constructView(){
  final JLabel filterFieldLabel=new JLabel(""String_Node_Str"");
  filterFieldLabel.setFont(new Font(""String_Node_Str"",Font.BOLD,14));
  filterFieldLabel.setForeground(Color.WHITE);
  filterField=new JTextField(10);
  final MatcherEditor<Item> filterFieldMatcherEditor=new TextComponentMatcherEditor<Item>(filterField,new ItemTextFilterator());
  itemEventList=GlazedListsSwing.swingThreadProxyList(itemEventList);
  final SortedList<Item> sortedItemsList=new SortedList<Item>(itemEventList,null);
  final FilterList<Item> filteredItemsList=new FilterList<Item>(sortedItemsList,filterFieldMatcherEditor);
  final StartNewSearchActionListener startNewSearch=new StartNewSearchActionListener();
  final JLabel searchFieldLabel=new JLabel(""String_Node_Str"");
  searchFieldLabel.setFont(new Font(""String_Node_Str"",Font.BOLD,14));
  searchFieldLabel.setForeground(Color.WHITE);
  searchField=new JTextField(10);
  searchField.addActionListener(startNewSearch);
  final JButton searchButton=new JButton(GO);
  searchButton.setBorder(BorderFactory.createEmptyBorder());
  searchButton.setContentAreaFilled(false);
  searchButton.addActionListener(startNewSearch);
  progressBar=new JProgressBar();
  progressBar.setString(""String_Node_Str"");
  progressBar.setStringPainted(true);
  progressBar.setBorder(BorderFactory.createLineBorder(AMAZON_SEARCH_DARK_BLUE,2));
  final TreeCriteriaEditor treeCriteriaEditor=new TreeCriteriaEditor(TreeCriterion.ALL_CRITERIA);
  treeCriteriaEditor.addPropertyChangeListener(""String_Node_Str"",new ActiveCriteriaPropertyChangeListener());
  treeCriteriaEditor.setOpaque(false);
  treeCriteriaEditor.setBorder(new RoundedBorder(CLEAR,AMAZON_SEARCH_DARK_BLUE,AMAZON_SEARCH_LIGHT_BLUE,8,1));
  final JPanel editorPanel=new JPanel(new GridBagLayout());
  editorPanel.setBackground(AMAZON_SEARCH_DARK_BLUE);
  editorPanel.add(treeCriteriaEditor,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,5,0,5),0,0));
  editorPanel.add(Box.createVerticalStrut(1),new GridBagConstraints(0,1,1,1,0.0,1.0,GridBagConstraints.CENTER,GridBagConstraints.VERTICAL,new Insets(0,0,0,0),0,0));
  final JPanel searchPanel=new GradientPanel(AMAZON_SEARCH_LIGHT_BLUE,AMAZON_SEARCH_DARK_BLUE,true);
  searchPanel.setLayout(new GridBagLayout());
  searchPanel.add(searchFieldLabel,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,10,0,3),0,0));
  searchPanel.add(searchField,new GridBagConstraints(1,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,5),0,0));
  searchPanel.add(searchButton,new GridBagConstraints(2,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,10),0,0));
  searchPanel.add(progressBar,new GridBagConstraints(3,0,1,1,1.0,1.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,10),0,0));
  searchPanel.add(filterFieldLabel,new GridBagConstraints(4,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,5),0,0));
  searchPanel.add(filterField,new GridBagConstraints(5,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,10),0,0));
  searchPanel.add(Box.createVerticalStrut(65),new GridBagConstraints(6,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
  treeList=new TreeList<Item>(filteredItemsList,new ItemTreeFormat(treeCriteriaEditor.getActiveCriteria()),(Comparator)GlazedLists.comparableComparator());
  final TableFormat<Item> itemTableFormat=new ItemTableFormat();
  itemTableModel=new EventTableModel<Item>(treeList,itemTableFormat);
  itemTableSelectionModel=new EventSelectionModel<Item>(treeList);
  final JTable itemTable=new JTable(itemTableModel,null,itemTableSelectionModel);
  JScrollPane itemScrollPane=new JScrollPane(itemTable,JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  itemScrollPane.setBorder(BorderFactory.createEmptyBorder());
  MacCornerScrollPaneLayoutManager.install(itemScrollPane);
  TableComparatorChooser.install(itemTable,sortedItemsList,TableComparatorChooser.MULTIPLE_COLUMN_KEYBOARD);
  ListConsistencyListener<Item> listConsistencyListener=ListConsistencyListener.install(treeList);
  listConsistencyListener.setPreviousElementTracked(false);
  TreeTableSupport.install(itemTable,treeList,2);
  final JPanel panel=new JPanel(new BorderLayout());
  panel.add(BorderLayout.NORTH,searchPanel);
  panel.add(BorderLayout.WEST,editorPanel);
  panel.add(BorderLayout.CENTER,itemScrollPane);
  return panel;
}","/** 
 * Construct a frame for search and browsing items from Amazon.
 */
private JPanel constructView(){
  final JLabel filterFieldLabel=new JLabel(""String_Node_Str"");
  filterFieldLabel.setFont(new Font(""String_Node_Str"",Font.BOLD,14));
  filterFieldLabel.setForeground(Color.WHITE);
  filterField=new JTextField(10);
  final MatcherEditor<Item> filterFieldMatcherEditor=new TextComponentMatcherEditor<Item>(filterField,new ItemTextFilterator());
  final EventList<Item> swingThreadProxyList=GlazedListsSwing.swingThreadProxyList(itemEventList);
  final SortedList<Item> sortedItemsList=new SortedList<Item>(swingThreadProxyList,null);
  final FilterList<Item> filteredItemsList=new FilterList<Item>(sortedItemsList,filterFieldMatcherEditor);
  final StartNewSearchActionListener startNewSearch=new StartNewSearchActionListener();
  final JLabel searchFieldLabel=new JLabel(""String_Node_Str"");
  searchFieldLabel.setFont(new Font(""String_Node_Str"",Font.BOLD,14));
  searchFieldLabel.setForeground(Color.WHITE);
  searchField=new JTextField(10);
  searchField.addActionListener(startNewSearch);
  final JButton searchButton=new JButton(GO);
  searchButton.setBorder(BorderFactory.createEmptyBorder());
  searchButton.setContentAreaFilled(false);
  searchButton.addActionListener(startNewSearch);
  progressBar=new JProgressBar();
  progressBar.setString(""String_Node_Str"");
  progressBar.setStringPainted(true);
  progressBar.setBorder(BorderFactory.createLineBorder(AMAZON_SEARCH_DARK_BLUE,2));
  final TreeCriteriaEditor treeCriteriaEditor=new TreeCriteriaEditor(TreeCriterion.ALL_CRITERIA);
  treeCriteriaEditor.addPropertyChangeListener(""String_Node_Str"",new ActiveCriteriaPropertyChangeListener());
  treeCriteriaEditor.setOpaque(false);
  treeCriteriaEditor.setBorder(new RoundedBorder(CLEAR,AMAZON_SEARCH_DARK_BLUE,AMAZON_SEARCH_LIGHT_BLUE,8,1));
  final JPanel editorPanel=new JPanel(new GridBagLayout());
  editorPanel.setBackground(AMAZON_SEARCH_DARK_BLUE);
  editorPanel.add(treeCriteriaEditor,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,5,0,5),0,0));
  editorPanel.add(Box.createVerticalStrut(1),new GridBagConstraints(0,1,1,1,0.0,1.0,GridBagConstraints.CENTER,GridBagConstraints.VERTICAL,new Insets(0,0,0,0),0,0));
  final JPanel searchPanel=new GradientPanel(AMAZON_SEARCH_LIGHT_BLUE,AMAZON_SEARCH_DARK_BLUE,true);
  searchPanel.setLayout(new GridBagLayout());
  searchPanel.add(searchFieldLabel,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,10,0,3),0,0));
  searchPanel.add(searchField,new GridBagConstraints(1,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,5),0,0));
  searchPanel.add(searchButton,new GridBagConstraints(2,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,10),0,0));
  searchPanel.add(progressBar,new GridBagConstraints(3,0,1,1,1.0,1.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,10),0,0));
  searchPanel.add(filterFieldLabel,new GridBagConstraints(4,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,5),0,0));
  searchPanel.add(filterField,new GridBagConstraints(5,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,10),0,0));
  searchPanel.add(Box.createVerticalStrut(65),new GridBagConstraints(6,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
  treeList=new TreeList<Item>(filteredItemsList,new ItemTreeFormat(treeCriteriaEditor.getActiveCriteria()),(Comparator)GlazedLists.comparableComparator());
  final TableFormat<Item> itemTableFormat=new ItemTableFormat();
  itemTableModel=new EventTableModel<Item>(treeList,itemTableFormat);
  itemTableSelectionModel=new EventSelectionModel<Item>(treeList);
  final JTable itemTable=new JTable(itemTableModel,null,itemTableSelectionModel);
  JScrollPane itemScrollPane=new JScrollPane(itemTable,JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  itemScrollPane.setBorder(BorderFactory.createEmptyBorder());
  MacCornerScrollPaneLayoutManager.install(itemScrollPane);
  TableComparatorChooser.install(itemTable,sortedItemsList,TableComparatorChooser.MULTIPLE_COLUMN_KEYBOARD);
  ListConsistencyListener<Item> listConsistencyListener=ListConsistencyListener.install(treeList);
  listConsistencyListener.setPreviousElementTracked(false);
  TreeTableSupport.install(itemTable,treeList,2);
  final JPanel panel=new JPanel(new BorderLayout());
  panel.add(BorderLayout.NORTH,searchPanel);
  panel.add(BorderLayout.WEST,editorPanel);
  panel.add(BorderLayout.CENTER,itemScrollPane);
  return panel;
}",0.9934000425803704
32593,"/** 
 * When the source combo is changed, this forwards the change to the displayed combo.
 */
public void listChanged(ListEvent listChanges){
  swtSource.getReadWriteLock().readLock().lock();
  try {
    while (listChanges.next()) {
      int changeIndex=listChanges.getIndex();
      int changeType=listChanges.getType();
      if (changeType == ListEvent.INSERT) {
        addRow(changeIndex,swtSource.get(changeIndex));
      }
 else       if (changeType == ListEvent.UPDATE) {
        updateRow(changeIndex,swtSource.get(changeIndex));
      }
 else       if (changeType == ListEvent.DELETE) {
        deleteRow(changeIndex);
      }
    }
  }
  finally {
    swtSource.getReadWriteLock().readLock().unlock();
  }
}","/** 
 * When the source combo is changed, this forwards the change to the displayed combo.
 */
public void listChanged(ListEvent listChanges){
  while (listChanges.next()) {
    int changeIndex=listChanges.getIndex();
    int changeType=listChanges.getType();
    if (changeType == ListEvent.INSERT) {
      addRow(changeIndex,swtSource.get(changeIndex));
    }
 else     if (changeType == ListEvent.UPDATE) {
      updateRow(changeIndex,swtSource.get(changeIndex));
    }
 else     if (changeType == ListEvent.DELETE) {
      deleteRow(changeIndex);
    }
  }
}",0.5725429017160687
32594,"/** 
 * Releases the resources consumed by this   {@link EventComboViewer} so that itmay eventually be garbage collected. <p>An  {@link EventComboViewer} will be garbage collected without a call to{@link #dispose()}, but not before its source   {@link EventList} is garbagecollected. By calling  {@link #dispose()}, you allow the   {@link EventComboViewer}to be garbage collected before its source   {@link EventList}. This is necessary for situations where an   {@link EventComboViewer} is short-lived butits source  {@link EventList} is long-lived.<p><strong><font color=""#FF0000"">Warning:</font></strong> It is an error to call any method on a  {@link EventComboViewer} after it has been disposed.
 */
public void dispose(){
  swtSource.dispose();
}","/** 
 * Releases the resources consumed by this   {@link EventComboViewer} so that itmay eventually be garbage collected. <p>An  {@link EventComboViewer} will be garbage collected without a call to{@link #dispose()}, but not before its source   {@link EventList} is garbagecollected. By calling  {@link #dispose()}, you allow the   {@link EventComboViewer}to be garbage collected before its source   {@link EventList}. This is necessary for situations where an   {@link EventComboViewer} is short-lived butits source  {@link EventList} is long-lived.<p><strong><font color=""#FF0000"">Warning:</font></strong> It is an error to call any method on a  {@link EventComboViewer} after it has been disposed.
 */
public void dispose(){
  swtSource.dispose();
  swtSource.removeListEventListener(this);
}",0.9709114414996768
32595,"/** 
 * When the source list is changed, this forwards the change to the displayed List.
 */
public void listChanged(ListEvent listChanges){
  int firstModified=swtSource.size();
  swtSource.getReadWriteLock().readLock().lock();
  try {
    while (listChanges.next()) {
      int changeIndex=listChanges.getIndex();
      int changeType=listChanges.getType();
      if (changeType == ListEvent.INSERT) {
        addRow(changeIndex,swtSource.get(changeIndex));
        firstModified=Math.min(changeIndex,firstModified);
      }
 else       if (changeType == ListEvent.UPDATE) {
        updateRow(changeIndex,swtSource.get(changeIndex));
      }
 else       if (changeType == ListEvent.DELETE) {
        deleteRow(changeIndex);
        firstModified=Math.min(changeIndex,firstModified);
      }
    }
    selection.fireSelectionChanged(firstModified,swtSource.size() - 1);
  }
  finally {
    swtSource.getReadWriteLock().readLock().unlock();
  }
}","/** 
 * When the source list is changed, this forwards the change to the displayed List.
 */
public void listChanged(ListEvent listChanges){
  int firstModified=swtSource.size();
  while (listChanges.next()) {
    int changeIndex=listChanges.getIndex();
    int changeType=listChanges.getType();
    if (changeType == ListEvent.INSERT) {
      addRow(changeIndex,swtSource.get(changeIndex));
      firstModified=Math.min(changeIndex,firstModified);
    }
 else     if (changeType == ListEvent.UPDATE) {
      updateRow(changeIndex,swtSource.get(changeIndex));
    }
 else     if (changeType == ListEvent.DELETE) {
      deleteRow(changeIndex);
      firstModified=Math.min(changeIndex,firstModified);
    }
  }
  selection.fireSelectionChanged(firstModified,swtSource.size() - 1);
}",0.8425925925925926
32596,"/** 
 * Releases the resources consumed by this   {@link EventListViewer} so that itmay eventually be garbage collected. <p>An  {@link EventListViewer} will be garbage collected without a call to{@link #dispose()}, but not before its source   {@link EventList} is garbagecollected. By calling  {@link #dispose()}, you allow the   {@link EventListViewer}to be garbage collected before its source   {@link EventList}. This is necessary for situations where an   {@link EventListViewer} is short-lived butits source  {@link EventList} is long-lived.<p><strong><font color=""#FF0000"">Warning:</font></strong> It is an error to call any method on a  {@link EventListViewer} after it has been disposed.
 */
public void dispose(){
  selection.dispose();
  swtSource.dispose();
}","/** 
 * Releases the resources consumed by this   {@link EventListViewer} so that itmay eventually be garbage collected. <p>An  {@link EventListViewer} will be garbage collected without a call to{@link #dispose()}, but not before its source   {@link EventList} is garbagecollected. By calling  {@link #dispose()}, you allow the   {@link EventListViewer}to be garbage collected before its source   {@link EventList}. This is necessary for situations where an   {@link EventListViewer} is short-lived butits source  {@link EventList} is long-lived.<p><strong><font color=""#FF0000"">Warning:</font></strong> It is an error to call any method on a  {@link EventListViewer} after it has been disposed.
 */
public void dispose(){
  selection.dispose();
  swtSource.dispose();
  swtSource.removeListEventListener(this);
}",0.9715729627289956
32597,"/** 
 * When the source list is changed, this forwards the change to the displayed   {@link Table}.
 */
public void listChanged(ListEvent listChanges){
  swtSource.getReadWriteLock().readLock().lock();
  Barcode deletes=new Barcode();
  deletes.addWhite(0,swtSource.size());
  int firstChange=swtSource.size();
  try {
    table.setRedraw(false);
    while (listChanges.next()) {
      int changeIndex=listChanges.getIndex();
      int adjustedIndex=deletes.getIndex(changeIndex,Barcode.WHITE);
      int changeType=listChanges.getType();
      if (changeType == ListEvent.INSERT) {
        deletes.addWhite(adjustedIndex,1);
        tableHandler.addRow(adjustedIndex,swtSource.get(changeIndex));
        firstChange=Math.min(changeIndex,firstChange);
      }
 else       if (changeType == ListEvent.UPDATE) {
        tableHandler.updateRow(adjustedIndex,swtSource.get(changeIndex));
      }
 else       if (changeType == ListEvent.DELETE) {
        deletes.setBlack(adjustedIndex,1);
        firstChange=Math.min(changeIndex,firstChange);
      }
    }
    if (deletes.blackSize() > 0) {
      int[] deletedIndices=new int[deletes.blackSize()];
      for (BarcodeIterator i=deletes.iterator(); i.hasNextBlack(); ) {
        i.nextBlack();
        deletedIndices[i.getBlackIndex()]=i.getIndex();
      }
      tableHandler.removeAll(deletedIndices);
    }
    table.setRedraw(true);
  }
  finally {
    swtSource.getReadWriteLock().readLock().unlock();
  }
}","/** 
 * When the source list is changed, this forwards the change to the displayed   {@link Table}.
 */
public void listChanged(ListEvent listChanges){
  Barcode deletes=new Barcode();
  deletes.addWhite(0,swtSource.size());
  int firstChange=swtSource.size();
  table.setRedraw(false);
  while (listChanges.next()) {
    int changeIndex=listChanges.getIndex();
    int adjustedIndex=deletes.getIndex(changeIndex,Barcode.WHITE);
    int changeType=listChanges.getType();
    if (changeType == ListEvent.INSERT) {
      deletes.addWhite(adjustedIndex,1);
      tableHandler.addRow(adjustedIndex,swtSource.get(changeIndex));
      firstChange=Math.min(changeIndex,firstChange);
    }
 else     if (changeType == ListEvent.UPDATE) {
      tableHandler.updateRow(adjustedIndex,swtSource.get(changeIndex));
    }
 else     if (changeType == ListEvent.DELETE) {
      deletes.setBlack(adjustedIndex,1);
      firstChange=Math.min(changeIndex,firstChange);
    }
  }
  if (deletes.blackSize() > 0) {
    int[] deletedIndices=new int[deletes.blackSize()];
    for (BarcodeIterator i=deletes.iterator(); i.hasNextBlack(); ) {
      i.nextBlack();
      deletedIndices[i.getBlackIndex()]=i.getIndex();
    }
    tableHandler.removeAll(deletedIndices);
  }
  table.setRedraw(true);
}",0.873992673992674
32598,"/** 
 * For implementing the ListEventListener interface. This sends changes to the table which repaint the table cells. Because this class is backed by   {@link GlazedListsSwing#swingThreadProxyList}, all natural calls to this method are guaranteed to occur on the Swing EDT.
 */
public void listChanged(ListEvent<E> listChanges){
  swingThreadSource.getReadWriteLock().readLock().lock();
  try {
    while (listChanges.nextBlock()) {
      int startIndex=listChanges.getBlockStartIndex();
      int endIndex=listChanges.getBlockEndIndex();
      int changeType=listChanges.getType();
      tableModelEvent.setValues(startIndex,endIndex,changeType);
      fireTableChanged(tableModelEvent);
    }
  }
  finally {
    swingThreadSource.getReadWriteLock().readLock().unlock();
  }
}","/** 
 * For implementing the ListEventListener interface. This sends changes to the table which repaint the table cells. Because this class is backed by   {@link GlazedListsSwing#swingThreadProxyList}, all natural calls to this method are guaranteed to occur on the Swing EDT.
 */
public void listChanged(ListEvent<E> listChanges){
  while (listChanges.nextBlock()) {
    int startIndex=listChanges.getBlockStartIndex();
    int endIndex=listChanges.getBlockEndIndex();
    int changeType=listChanges.getType();
    tableModelEvent.setValues(startIndex,endIndex,changeType);
    fireTableChanged(tableModelEvent);
  }
}",0.8485714285714285
32599,"public void popupMenuWillBecomeVisible(PopupMenuEvent e){
  final Object prototypeValue=comboBox.getPrototypeDisplayValue();
  if (prototypeValue == null)   return;
  final JComponent popupComponent=(JComponent)e.getSource();
  if (popupComponent.getComponent(0) instanceof JScrollPane) {
    final JScrollPane scroller=(JScrollPane)popupComponent.getComponent(0);
    final Dimension scrollerSize=scroller.getPreferredSize();
    final Dimension prototypeSize=getPrototypeSize(prototypeValue);
    prototypeSize.width+=scroller.getVerticalScrollBar().getPreferredSize().width;
    if (prototypeSize.width > scrollerSize.width) {
      scrollerSize.width=prototypeSize.width;
      scroller.setMaximumSize(scrollerSize);
      scroller.setPreferredSize(scrollerSize);
      scroller.setMinimumSize(scrollerSize);
    }
  }
}","public void popupMenuWillBecomeVisible(PopupMenuEvent e){
  final Object prototypeValue=comboBox.getPrototypeDisplayValue();
  if (prototypeValue == null)   return;
  final JComponent popupComponent=(JComponent)e.getSource();
  fixPopupLocation(popupComponent);
  if (popupComponent.getComponent(0) instanceof JScrollPane) {
    final JScrollPane scroller=(JScrollPane)popupComponent.getComponent(0);
    final Dimension scrollerSize=scroller.getPreferredSize();
    final Dimension prototypeSize=getPrototypeSize(prototypeValue);
    prototypeSize.width+=scroller.getVerticalScrollBar().getPreferredSize().width;
    if (prototypeSize.width > scrollerSize.width) {
      scrollerSize.width=prototypeSize.width;
      scroller.setMaximumSize(scrollerSize);
      scroller.setPreferredSize(scrollerSize);
      scroller.setMinimumSize(scrollerSize);
    }
  }
}",0.978622327790974
32600,"/** 
 * Remove all customizations installed to various areas of the current UI in order to uninstall autocompletion support. This method is invoked after the comboBox's UI delegate is changed.
 */
private void undecorateOriginalUI(){
  if (this.arrowButton != null) {
    this.arrowButton.removeMouseListener(arrowButtonMouseListener);
    this.arrowButton.addMouseListener(arrowButtonMouseListener.getDecorated());
  }
  this.comboBox.getModel().removeListDataListener(listDataHandler);
  if (this.comboBox.getEditor() == comboBoxEditor)   this.comboBox.setEditor(comboBoxEditor.getDelegate());
  this.popupMenu.removePopupMenuListener(popupSizerHandler);
  this.popup.getList().removeMouseListener(popupMouseHandler);
  final ActionMap actionMap=comboBox.getActionMap();
  actionMap.put(""String_Node_Str"",originalSelectPreviousAction);
  actionMap.put(""String_Node_Str"",originalSelectNextAction);
  actionMap.put(""String_Node_Str"",originalSelectPrevious2Action);
  actionMap.put(""String_Node_Str"",originalSelectNext2Action);
  actionMap.put(""String_Node_Str"",originalAquaSelectPreviousAction);
  actionMap.put(""String_Node_Str"",originalAquaSelectNextAction);
  this.document.setDocumentFilter(null);
  this.comboBoxEditorComponent.removeKeyListener(strictModeBackspaceHandler);
  this.comboBoxEditorComponent.removeFocusListener(selectTextOnFocusGainHandler);
  if (this.comboBox.getRenderer() == renderer)   this.comboBox.setRenderer(originalRenderer);
  this.originalRenderer=null;
  this.comboBoxEditor=null;
  this.comboBoxEditorComponent=null;
  this.document=null;
  this.popupMenu=null;
  this.popup=null;
  this.arrowButton=null;
}","/** 
 * Remove all customizations installed to various areas of the current UI in order to uninstall autocompletion support. This method is invoked after the comboBox's UI delegate is changed.
 */
private void undecorateOriginalUI(){
  if (this.arrowButton != null) {
    this.arrowButton.removeMouseListener(arrowButtonMouseListener);
    this.arrowButton.addMouseListener(arrowButtonMouseListener.getDecorated());
  }
  this.comboBox.getModel().removeListDataListener(listDataHandler);
  if (this.comboBox.getEditor() == comboBoxEditor)   this.comboBox.setEditor(comboBoxEditor.getDelegate());
  this.popupMenu.removePopupMenuListener(popupSizerHandler);
  this.popupLocationFix.uninstall();
  this.popup.getList().removeMouseListener(popupMouseHandler);
  final ActionMap actionMap=comboBox.getActionMap();
  actionMap.put(""String_Node_Str"",originalSelectPreviousAction);
  actionMap.put(""String_Node_Str"",originalSelectNextAction);
  actionMap.put(""String_Node_Str"",originalSelectPrevious2Action);
  actionMap.put(""String_Node_Str"",originalSelectNext2Action);
  actionMap.put(""String_Node_Str"",originalAquaSelectPreviousAction);
  actionMap.put(""String_Node_Str"",originalAquaSelectNextAction);
  this.document.setDocumentFilter(null);
  this.comboBoxEditorComponent.removeKeyListener(strictModeBackspaceHandler);
  this.comboBoxEditorComponent.removeFocusListener(selectTextOnFocusGainHandler);
  if (this.comboBox.getRenderer() == renderer)   this.comboBox.setRenderer(originalRenderer);
  this.originalRenderer=null;
  this.comboBoxEditor=null;
  this.comboBoxEditorComponent=null;
  this.document=null;
  this.popupMenu=null;
  this.popup=null;
  this.arrowButton=null;
}",0.9888520638746612
32601,"/** 
 * Decorate all necessary areas of the current UI to install autocompletion support. This method is called in the constructor and when the comboBox's UI delegate is changed.
 */
private void decorateCurrentUI(){
  this.originalRenderer=comboBox.getRenderer();
  this.popupMenu=(JPopupMenu)comboBox.getUI().getAccessibleChild(comboBox,0);
  this.popup=(ComboPopup)popupMenu;
  this.arrowButton=findArrowButton(comboBox);
  if (this.arrowButton != null) {
    this.arrowButton.removeMouseListener(popup.getMouseListener());
    this.arrowButtonMouseListener=new ArrowButtonMouseListener(popup.getMouseListener());
    this.arrowButton.addMouseListener(arrowButtonMouseListener);
  }
  this.comboBox.getModel().addListDataListener(listDataHandler);
  this.popupMenu.addPopupMenuListener(popupSizerHandler);
  this.popup.getList().addMouseListener(popupMouseHandler);
  final ActionMap actionMap=comboBox.getActionMap();
  this.originalSelectNextAction=actionMap.get(""String_Node_Str"");
  this.originalSelectPreviousAction=actionMap.get(""String_Node_Str"");
  this.originalSelectNext2Action=actionMap.get(""String_Node_Str"");
  this.originalSelectPrevious2Action=actionMap.get(""String_Node_Str"");
  this.originalAquaSelectNextAction=actionMap.get(""String_Node_Str"");
  this.originalAquaSelectPreviousAction=actionMap.get(""String_Node_Str"");
  final Action upAction=new MoveAction(-1);
  final Action downAction=new MoveAction(1);
  actionMap.put(""String_Node_Str"",upAction);
  actionMap.put(""String_Node_Str"",downAction);
  actionMap.put(""String_Node_Str"",upAction);
  actionMap.put(""String_Node_Str"",downAction);
  actionMap.put(""String_Node_Str"",upAction);
  actionMap.put(""String_Node_Str"",downAction);
  this.comboBoxEditor=new FormatComboBoxEditor(comboBox.getEditor());
  this.comboBox.setEditor(comboBoxEditor);
  this.comboBoxEditorComponent=(JTextField)comboBox.getEditor().getEditorComponent();
  this.document=(AbstractDocument)comboBoxEditorComponent.getDocument();
  this.document.setDocumentFilter(documentFilter);
  if (this.renderer != null)   comboBox.setRenderer(renderer);
  this.comboBoxEditorComponent.addKeyListener(strictModeBackspaceHandler);
  this.comboBoxEditorComponent.addFocusListener(selectTextOnFocusGainHandler);
}","/** 
 * Decorate all necessary areas of the current UI to install autocompletion support. This method is called in the constructor and when the comboBox's UI delegate is changed.
 */
private void decorateCurrentUI(){
  this.originalRenderer=comboBox.getRenderer();
  this.popupMenu=(JPopupMenu)comboBox.getUI().getAccessibleChild(comboBox,0);
  this.popup=(ComboPopup)popupMenu;
  this.arrowButton=findArrowButton(comboBox);
  if (this.arrowButton != null) {
    this.arrowButton.removeMouseListener(popup.getMouseListener());
    this.arrowButtonMouseListener=new ArrowButtonMouseListener(popup.getMouseListener());
    this.arrowButton.addMouseListener(arrowButtonMouseListener);
  }
  this.comboBox.getModel().addListDataListener(listDataHandler);
  this.popupMenu.addPopupMenuListener(popupSizerHandler);
  this.popupLocationFix=ComboBoxPopupLocationFix.install(this.comboBox);
  this.popup.getList().addMouseListener(popupMouseHandler);
  final ActionMap actionMap=comboBox.getActionMap();
  this.originalSelectNextAction=actionMap.get(""String_Node_Str"");
  this.originalSelectPreviousAction=actionMap.get(""String_Node_Str"");
  this.originalSelectNext2Action=actionMap.get(""String_Node_Str"");
  this.originalSelectPrevious2Action=actionMap.get(""String_Node_Str"");
  this.originalAquaSelectNextAction=actionMap.get(""String_Node_Str"");
  this.originalAquaSelectPreviousAction=actionMap.get(""String_Node_Str"");
  final Action upAction=new MoveAction(-1);
  final Action downAction=new MoveAction(1);
  actionMap.put(""String_Node_Str"",upAction);
  actionMap.put(""String_Node_Str"",downAction);
  actionMap.put(""String_Node_Str"",upAction);
  actionMap.put(""String_Node_Str"",downAction);
  actionMap.put(""String_Node_Str"",upAction);
  actionMap.put(""String_Node_Str"",downAction);
  this.comboBoxEditor=new FormatComboBoxEditor(comboBox.getEditor());
  this.comboBox.setEditor(comboBoxEditor);
  this.comboBoxEditorComponent=(JTextField)comboBox.getEditor().getEditorComponent();
  this.document=(AbstractDocument)comboBoxEditorComponent.getDocument();
  this.document.setDocumentFilter(documentFilter);
  if (this.renderer != null)   comboBox.setRenderer(renderer);
  this.comboBoxEditorComponent.addKeyListener(strictModeBackspaceHandler);
  this.comboBoxEditorComponent.addFocusListener(selectTextOnFocusGainHandler);
}",0.9840087623220152
32602,"public void popupMenuWillBecomeVisible(PopupMenuEvent e){
  final Object prototypeValue=comboBox.getPrototypeDisplayValue();
  if (prototypeValue == null)   return;
  final JComponent popupComponent=(JComponent)e.getSource();
  fixPopupLocation(popupComponent);
  if (popupComponent.getComponent(0) instanceof JScrollPane) {
    final JScrollPane scroller=(JScrollPane)popupComponent.getComponent(0);
    final Dimension scrollerSize=scroller.getPreferredSize();
    final Dimension prototypeSize=getPrototypeSize(prototypeValue);
    prototypeSize.width+=scroller.getVerticalScrollBar().getPreferredSize().width;
    if (prototypeSize.width > scrollerSize.width) {
      scrollerSize.width=prototypeSize.width;
      scroller.setMaximumSize(scrollerSize);
      scroller.setPreferredSize(scrollerSize);
      scroller.setMinimumSize(scrollerSize);
    }
  }
}","public void popupMenuWillBecomeVisible(PopupMenuEvent e){
  final Object prototypeValue=comboBox.getPrototypeDisplayValue();
  if (prototypeValue == null)   return;
  final JComponent popupComponent=(JComponent)e.getSource();
  if (popupComponent.getComponent(0) instanceof JScrollPane) {
    final JScrollPane scroller=(JScrollPane)popupComponent.getComponent(0);
    final Dimension scrollerSize=scroller.getPreferredSize();
    final Dimension prototypeSize=getPrototypeSize(prototypeValue);
    prototypeSize.width+=scroller.getVerticalScrollBar().getPreferredSize().width;
    if (prototypeSize.width > scrollerSize.width) {
      scrollerSize.width=prototypeSize.width;
      scroller.setMaximumSize(scrollerSize);
      scroller.setPreferredSize(scrollerSize);
      scroller.setMinimumSize(scrollerSize);
    }
  }
}",0.978622327790974
32603,"/** 
 * Starts a new atomic change to this list change queue.
 */
public final synchronized void beginEvent(boolean allowNestedEvents){
  if (!this.allowNestedEvents) {
    throw new ConcurrentModificationException(""String_Node_Str"" + eventThread.getName());
  }
  this.allowNestedEvents=allowNestedEvents;
  if (allowNestedEvents)   allowContradictingEvents=true;
  if (eventLevel == 0) {
    this.eventThread=Thread.currentThread();
    prepareEvent();
  }
  eventLevel++;
}","/** 
 * Starts a new atomic change to this list change queue.
 */
public final synchronized void beginEvent(boolean allowNestedEvents){
  if (!this.allowNestedEvents) {
    throw new ConcurrentModificationException(""String_Node_Str"" + eventThread.getName());
  }
  this.allowNestedEvents=allowNestedEvents;
  if (allowNestedEvents || (eventLevel == 0 && !isEventEmpty())) {
    allowContradictingEvents=true;
  }
  if (eventLevel == 0) {
    this.eventThread=Thread.currentThread();
    prepareEvent();
  }
  eventLevel++;
}",0.95
32604,"/** 
 * @inheritDoc 
 */
public void dispose(){
  tableModel.dispose();
}","/** 
 * @inheritDoc 
 */
public void dispose(){
  swingThreadSource.removeListEventListener(this);
  tableModel.dispose();
}",0.7411167512690355
32605,"/** 
 * This method removes autocompletion support from the   {@link JComboBox}it was installed on. This method is useful when the   {@link EventList} ofitems that backs the combo box must outlive the combo box itself. Calling this method will return the combo box to its original state before autocompletion was installed, and it will be available for garbage collection independently of the  {@link EventList} of items.
 * @throws IllegalStateException if this method is called from any Threadother than the Swing Event Dispatch Thread
 */
public void uninstall(){
  checkAccessThread();
  if (this.comboBox == null)   throw new IllegalStateException(""String_Node_Str"");
  this.comboBox.removePropertyChangeListener(""String_Node_Str"",this.uiWatcher);
  this.comboBox.removePropertyChangeListener(""String_Node_Str"",this.modelWatcher);
  this.comboBoxEditor.removePropertyChangeListener(""String_Node_Str"",this.documentWatcher);
  this.undecorateOriginalUI();
  this.comboBox.setModel(this.originalModel);
  this.originalModel=null;
  this.comboBox.setEditable(originalComboBoxEditable);
  this.filteredItems.dispose();
  this.comboBox=null;
}","/** 
 * This method removes autocompletion support from the   {@link JComboBox}it was installed on. This method is useful when the   {@link EventList} ofitems that backs the combo box must outlive the combo box itself. Calling this method will return the combo box to its original state before autocompletion was installed, and it will be available for garbage collection independently of the  {@link EventList} of items.
 * @throws IllegalStateException if this method is called from any Threadother than the Swing Event Dispatch Thread
 */
public void uninstall(){
  checkAccessThread();
  if (this.comboBox == null)   throw new IllegalStateException(""String_Node_Str"");
  this.comboBox.removePropertyChangeListener(""String_Node_Str"",this.uiWatcher);
  this.comboBox.removePropertyChangeListener(""String_Node_Str"",this.modelWatcher);
  this.comboBoxEditor.removePropertyChangeListener(""String_Node_Str"",this.documentWatcher);
  this.undecorateOriginalUI();
  this.comboBox.setModel(this.originalModel);
  this.originalModel=null;
  this.comboBox.setEditable(originalComboBoxEditable);
  this.comboBoxModel.dispose();
  this.filteredItems.dispose();
  this.comboBox=null;
}",0.9749568221070812
32606,"/** 
 * Releases the resources consumed by this   {@link EventListModel} so that itmay eventually be garbage collected. <p>An  {@link EventListModel} will be garbage collected without a call to{@link #dispose()}, but not before its source   {@link EventList} is garbagecollected. By calling  {@link #dispose()}, you allow the   {@link EventListModel}to be garbage collected before its source   {@link EventList}. This is  necessary for situations where an   {@link EventListModel} is short-lived butits source  {@link EventList} is long-lived.<p><strong><font color=""#FF0000"">Warning:</font></strong> It is an error to call any method on a  {@link EventListModel} after it has been disposed.
 */
public void dispose(){
  swingSource.dispose();
}","/** 
 * Releases the resources consumed by this   {@link EventListModel} so that itmay eventually be garbage collected. <p>An  {@link EventListModel} will be garbage collected without a call to{@link #dispose()}, but not before its source   {@link EventList} is garbagecollected. By calling  {@link #dispose()}, you allow the   {@link EventListModel}to be garbage collected before its source   {@link EventList}. This is  necessary for situations where an   {@link EventListModel} is short-lived butits source  {@link EventList} is long-lived.<p><strong><font color=""#FF0000"">Warning:</font></strong> It is an error to call any method on a  {@link EventListModel} after it has been disposed.
 */
public void dispose(){
  swingSource.removeListEventListener(this);
  swingSource.dispose();
}",0.970684039087948
32607,"/** 
 * Releases the resources consumed by this   {@link EventTableModel} so that itmay eventually be garbage collected. <p>An  {@link EventTableModel} will be garbage collected without a call to{@link #dispose()}, but not before its source   {@link EventList} is garbagecollected. By calling  {@link #dispose()}, you allow the   {@link EventTableModel}to be garbage collected before its source   {@link EventList}. This is  necessary for situations where an   {@link EventTableModel} is short-lived butits source  {@link EventList} is long-lived.<p><strong><font color=""#FF0000"">Warning:</font></strong> It is an error to call any method on a  {@link EventTableModel} after it has been disposed.
 */
public void dispose(){
  swingThreadSource.dispose();
}","/** 
 * Releases the resources consumed by this   {@link EventTableModel} so that itmay eventually be garbage collected. <p>An  {@link EventTableModel} will be garbage collected without a call to{@link #dispose()}, but not before its source   {@link EventList} is garbagecollected. By calling  {@link #dispose()}, you allow the   {@link EventTableModel}to be garbage collected before its source   {@link EventList}. This is  necessary for situations where an   {@link EventTableModel} is short-lived butits source  {@link EventList} is long-lived.<p><strong><font color=""#FF0000"">Warning:</font></strong> It is an error to call any method on a  {@link EventTableModel} after it has been disposed.
 */
public void dispose(){
  swingThreadSource.removeListEventListener(this);
  swingThreadSource.dispose();
}",0.9673704414587332
32608,"/** 
 * Forward the specified event to listeners.
 */
public final synchronized void forwardEvent(ListEvent<?> listChanges){
  beginEvent(false);
  this.reorderMap=null;
  if (isEventEmpty() && listChanges.isReordering()) {
    reorder(listChanges.getReorderMap());
  }
 else {
    while (listChanges.nextBlock()) {
      addChange(listChanges.getType(),listChanges.getBlockStartIndex(),listChanges.getBlockEndIndex());
    }
  }
  commitEvent();
}","/** 
 * Forward the specified event to listeners.
 */
public final synchronized void forwardEvent(ListEvent<?> listChanges){
  beginEvent(false);
  this.reorderMap=null;
  if (isEventEmpty() && listChanges.isReordering()) {
    reorder(listChanges.getReorderMap());
  }
 else {
    while (listChanges.nextBlock()) {
      addChange(listChanges.getType(),listChanges.getBlockStartIndex(),listChanges.getBlockEndIndex());
    }
    listChanges.reset();
  }
  commitEvent();
}",0.9728555917481
32609,"/** 
 * {@inheritDoc} 
 */
protected void beforeFireEvent(){
  Block.sortListEventBlocks(atomicChangeBlocks,allowContradictingEvents);
}","/** 
 * {@inheritDoc} 
 */
protected void beforeFireEvent(){
  Block.sortListEventBlocks(atomicChangeBlocks,getAllowContradictingEvents());
}",0.9747292418772564
32610,"/** 
 * Commits the current atomic change to this list change queue.
 */
public final synchronized void commitEvent(){
  if (eventLevel == 0)   throw new IllegalStateException(""String_Node_Str"");
  eventLevel--;
  allowNestedEvents=true;
  if (eventLevel == 0) {
    beforeFireEvent();
    if (!isEventEmpty()) {
      publisherAdapter.fireEvent();
    }
 else {
      cleanup();
    }
  }
}","/** 
 * Commits the current atomic change to this list change queue.
 */
public final synchronized void commitEvent(){
  if (eventLevel == 0)   throw new IllegalStateException(""String_Node_Str"");
  eventLevel--;
  allowNestedEvents=true;
  if (eventLevel == 0) {
    beforeFireEvent();
    if (!isEventEmpty()) {
      publisherAdapter.fireEvent();
    }
 else {
      eventPending=false;
      cleanup();
    }
  }
}",0.9678217821782178
32611,"/** 
 * Starts a new atomic change to this list change queue.
 */
public final synchronized void beginEvent(boolean allowNestedEvents){
  if (!this.allowNestedEvents) {
    throw new ConcurrentModificationException(""String_Node_Str"" + eventThread.getName());
  }
  this.allowNestedEvents=allowNestedEvents;
  if (allowNestedEvents || (eventLevel == 0 && !isEventEmpty())) {
    allowContradictingEvents=true;
  }
  if (eventLevel == 0) {
    this.eventThread=Thread.currentThread();
    prepareEvent();
  }
  eventLevel++;
}","/** 
 * Starts a new atomic change to this list change queue.
 */
public final synchronized void beginEvent(boolean allowNestedEvents){
  if (!this.allowNestedEvents) {
    throw new ConcurrentModificationException(""String_Node_Str"" + eventThread.getName());
  }
  this.allowNestedEvents=allowNestedEvents;
  if (allowNestedEvents || (eventLevel == 0 && eventPending)) {
    setAllowContradictingEvents(true);
  }
  if (!eventPending) {
    this.eventPending=true;
    this.eventThread=Thread.currentThread();
    prepareEvent();
  }
  eventLevel++;
}",0.8483720930232558
32612,"public void postEvent(EventList<E> subject){
  assemblerDelegate.cleanup();
  ((ListSequencePublisherAdapter)assemblerDelegate.publisherAdapter).eventEnqueued=false;
}","public void postEvent(EventList<E> subject){
  assemblerDelegate.eventPending=false;
  assemblerDelegate.cleanup();
  ((ListSequencePublisherAdapter)assemblerDelegate.publisherAdapter).eventEnqueued=false;
}",0.4010695187165775
32613,"/** 
 * {@inheritDoc} 
 */
public void cleanup(){
  atomicChangeBlocks=null;
  atomicLatestBlock=null;
  reorderMap=null;
  allowContradictingEvents=false;
}","/** 
 * {@inheritDoc} 
 */
public void cleanup(){
  atomicChangeBlocks=null;
  atomicLatestBlock=null;
  reorderMap=null;
  setAllowContradictingEvents(false);
}",0.9748427672955976
32614,"/** 
 * Creates a   {@link BasicEventList} using the specified{@link ListEventPublisher} and {@link ReadWriteLock}.
 * @since 2006-June-12
 */
BasicEventList(ListEventPublisher publisher,ReadWriteLock readWriteLock){
  super(publisher);
  this.data=new ArrayList<E>();
  this.readWriteLock=readWriteLock;
}","/** 
 * Creates a   {@link BasicEventList} using the specified{@link ListEventPublisher} and {@link ReadWriteLock}.
 * @since 2006-June-12
 */
public BasicEventList(ListEventPublisher publisher,ReadWriteLock readWriteLock){
  super(publisher);
  this.data=new ArrayList<E>();
  this.readWriteLock=readWriteLock;
}",0.988691437802908
32615,"/** 
 * Adds the specified   {@link EventList} as a source to this {@link CompositeList}.
 */
public void addMemberList(EventList<E> list){
  source.add(list);
}","/** 
 * Adds the specified   {@link EventList} as a source to this {@link CompositeList}. <p> To ensure correct behaviour when this   {@link CompositeList} is used by multiple threads, thespecified EventList has to share the same  {@link ReadWriteLock} and{@link ListEventPublisher} with this CompositeList.
 * @throws IllegalArgumentException if the specified EventList uses a different{@link ReadWriteLock} or {@link ListEventPublisher}
 * @see #createMemberList()
 */
public void addMemberList(EventList<E> list){
  if (!getPublisher().equals(list.getPublisher()))   throw new IllegalArgumentException(""String_Node_Str"");
  if (!getReadWriteLock().equals(list.getReadWriteLock()))   throw new IllegalArgumentException(""String_Node_Str"");
  source.add(list);
}",0.3185265438786565
32616,"/** 
 * Create a   {@link CompositeList} that uses the given <code>lock</code>.Note that this lock will also be used when  {@link #createMemberList building new member lists}. <p>This can be a convenient constructor to use when the member lists are prebuilt ahead of time with a common   {@link ReadWriteLock} and itis desirable to compose their union with a  {@link CompositeList}.
 * @param lock the {@link ReadWriteLock} to use within the {@link CompositeList}
 */
public CompositeList(ReadWriteLock lock){
  this();
  readWriteLock=lock;
}","/** 
 * Create a   {@link CompositeList} that uses the given <code>publisher</code> and<code>lock</code>. Note that this publisher and lock will also be used when {@link #createMemberList building new member lists}. <p> This can be a convenient constructor to use when the member lists are prebuilt ahead of time with a common   {@link ListEventPublisher} and {@link ReadWriteLock} and it is desirable tocompose their union with a  {@link CompositeList}.
 * @param publisher the {@link ListEventPublisher} to use within the {@link CompositeList}
 * @param lock the {@link ReadWriteLock} to use within the {@link CompositeList}
 */
public CompositeList(ListEventPublisher publisher,ReadWriteLock lock){
  super(new BasicEventList<EventList<E>>(publisher,lock),(Model)GlazedLists.listCollectionListModel());
}",0.7333333333333333
32617,"/** 
 * Verifies that remove member list does so by reference.
 */
public void testRemoveByReference(){
  EventList<String> wendys=new BasicEventList<String>();
  EventList<String> mcDonalds=new BasicEventList<String>();
  EventList<String> tacoBell=new BasicEventList<String>();
  CompositeList<String> fastFood=new CompositeList<String>();
  ListConsistencyListener.install(fastFood);
  fastFood.addMemberList(wendys);
  fastFood.addMemberList(mcDonalds);
  fastFood.addMemberList(tacoBell);
  fastFood.removeMemberList(tacoBell);
  fastFood.removeMemberList(wendys);
  assertEquals(mcDonalds,fastFood);
  mcDonalds.add(""String_Node_Str"");
  assertEquals(mcDonalds,fastFood);
}","/** 
 * Verifies that remove member list does so by reference.
 */
public void testRemoveByReference(){
  CompositeList<String> fastFood=new CompositeList<String>();
  ListConsistencyListener.install(fastFood);
  EventList<String> wendys=fastFood.createMemberList();
  EventList<String> mcDonalds=fastFood.createMemberList();
  EventList<String> tacoBell=fastFood.createMemberList();
  fastFood.addMemberList(wendys);
  fastFood.addMemberList(mcDonalds);
  fastFood.addMemberList(tacoBell);
  fastFood.removeMemberList(tacoBell);
  fastFood.removeMemberList(wendys);
  assertEquals(mcDonalds,fastFood);
  mcDonalds.add(""String_Node_Str"");
  assertEquals(mcDonalds,fastFood);
}",0.7424354243542436
32618,"/** 
 * Verifies that multiple copies of the same list can be added.
 */
public void testMultipleCopies(){
  List<String> fastFoodVerify=new ArrayList<String>();
  EventList<String> wendys=new BasicEventList<String>();
  wendys.add(""String_Node_Str"");
  EventList<String> mcDonalds=new BasicEventList<String>();
  mcDonalds.add(""String_Node_Str"");
  mcDonalds.add(""String_Node_Str"");
  CompositeList<String> fastFood=new CompositeList<String>();
  fastFood.addMemberList(wendys);
  fastFood.addMemberList(mcDonalds);
  fastFoodVerify.clear();
  fastFoodVerify.addAll(wendys);
  fastFoodVerify.addAll(mcDonalds);
  assertEquals(fastFoodVerify,fastFood);
  fastFood.addMemberList(wendys);
  fastFood.addMemberList(mcDonalds);
  fastFoodVerify.clear();
  fastFoodVerify.addAll(wendys);
  fastFoodVerify.addAll(mcDonalds);
  fastFoodVerify.addAll(wendys);
  fastFoodVerify.addAll(mcDonalds);
  assertEquals(fastFoodVerify,fastFood);
  fastFood.removeMemberList(wendys);
  fastFood.removeMemberList(wendys);
  fastFoodVerify.clear();
  fastFoodVerify.addAll(mcDonalds);
  fastFoodVerify.addAll(mcDonalds);
  assertEquals(fastFoodVerify,fastFood);
}","/** 
 * Verifies that multiple copies of the same list can be added.
 */
public void testMultipleCopies(){
  List<String> fastFoodVerify=new ArrayList<String>();
  CompositeList<String> fastFood=new CompositeList<String>();
  EventList<String> wendys=fastFood.createMemberList();
  wendys.add(""String_Node_Str"");
  EventList<String> mcDonalds=fastFood.createMemberList();
  mcDonalds.add(""String_Node_Str"");
  mcDonalds.add(""String_Node_Str"");
  fastFood.addMemberList(wendys);
  fastFood.addMemberList(mcDonalds);
  fastFoodVerify.clear();
  fastFoodVerify.addAll(wendys);
  fastFoodVerify.addAll(mcDonalds);
  assertEquals(fastFoodVerify,fastFood);
  fastFood.addMemberList(wendys);
  fastFood.addMemberList(mcDonalds);
  fastFoodVerify.clear();
  fastFoodVerify.addAll(wendys);
  fastFoodVerify.addAll(mcDonalds);
  fastFoodVerify.addAll(wendys);
  fastFoodVerify.addAll(mcDonalds);
  assertEquals(fastFoodVerify,fastFood);
  fastFood.removeMemberList(wendys);
  fastFood.removeMemberList(wendys);
  fastFoodVerify.clear();
  fastFoodVerify.addAll(mcDonalds);
  fastFoodVerify.addAll(mcDonalds);
  assertEquals(fastFoodVerify,fastFood);
}",0.9010507880910684
32619,"/** 
 * Verifies that multiple sources work.
 */
public void testMultipleSources(){
  List<String> fastFoodVerify=new ArrayList<String>();
  EventList<String> wendys=new BasicEventList<String>();
  wendys.add(""String_Node_Str"");
  wendys.add(""String_Node_Str"");
  wendys.add(""String_Node_Str"");
  wendys.add(""String_Node_Str"");
  EventList<String> mcDonalds=new BasicEventList<String>();
  mcDonalds.add(""String_Node_Str"");
  mcDonalds.add(""String_Node_Str"");
  mcDonalds.add(""String_Node_Str"");
  mcDonalds.add(""String_Node_Str"");
  EventList<String> tacoBell=new BasicEventList<String>();
  tacoBell.add(""String_Node_Str"");
  tacoBell.add(""String_Node_Str"");
  CompositeList<String> fastFood=new CompositeList<String>();
  ListConsistencyListener.install(fastFood);
  fastFood.addMemberList(wendys);
  fastFood.addMemberList(mcDonalds);
  fastFood.addMemberList(tacoBell);
  fastFoodVerify.clear();
  fastFoodVerify.addAll(wendys);
  fastFoodVerify.addAll(mcDonalds);
  fastFoodVerify.addAll(tacoBell);
  assertEquals(fastFoodVerify,fastFood);
  wendys.add(""String_Node_Str"");
  wendys.add(""String_Node_Str"");
  fastFoodVerify.clear();
  fastFoodVerify.addAll(wendys);
  fastFoodVerify.addAll(mcDonalds);
  fastFoodVerify.addAll(tacoBell);
  assertEquals(fastFoodVerify,fastFood);
  wendys.remove(1);
  fastFood.set(0,""String_Node_Str"");
  fastFood.remove(1);
  fastFoodVerify.clear();
  fastFoodVerify.addAll(wendys);
  fastFoodVerify.addAll(mcDonalds);
  fastFoodVerify.addAll(tacoBell);
  assertEquals(fastFoodVerify,fastFood);
  mcDonalds.add(""String_Node_Str"");
  fastFoodVerify.clear();
  fastFoodVerify.addAll(wendys);
  fastFoodVerify.addAll(mcDonalds);
  fastFoodVerify.addAll(tacoBell);
  assertEquals(fastFoodVerify,fastFood);
  fastFood.removeMemberList(mcDonalds);
  fastFoodVerify.clear();
  fastFoodVerify.addAll(wendys);
  fastFoodVerify.addAll(tacoBell);
  assertEquals(fastFoodVerify,fastFood);
}","/** 
 * Verifies that multiple sources work.
 */
public void testMultipleSources(){
  CompositeList<String> fastFood=new CompositeList<String>();
  ListConsistencyListener.install(fastFood);
  List<String> fastFoodVerify=new ArrayList<String>();
  EventList<String> wendys=fastFood.createMemberList();
  wendys.add(""String_Node_Str"");
  wendys.add(""String_Node_Str"");
  wendys.add(""String_Node_Str"");
  wendys.add(""String_Node_Str"");
  EventList<String> mcDonalds=fastFood.createMemberList();
  mcDonalds.add(""String_Node_Str"");
  mcDonalds.add(""String_Node_Str"");
  mcDonalds.add(""String_Node_Str"");
  mcDonalds.add(""String_Node_Str"");
  EventList<String> tacoBell=fastFood.createMemberList();
  tacoBell.add(""String_Node_Str"");
  tacoBell.add(""String_Node_Str"");
  fastFood.addMemberList(wendys);
  fastFood.addMemberList(mcDonalds);
  fastFood.addMemberList(tacoBell);
  fastFoodVerify.clear();
  fastFoodVerify.addAll(wendys);
  fastFoodVerify.addAll(mcDonalds);
  fastFoodVerify.addAll(tacoBell);
  assertEquals(fastFoodVerify,fastFood);
  wendys.add(""String_Node_Str"");
  wendys.add(""String_Node_Str"");
  fastFoodVerify.clear();
  fastFoodVerify.addAll(wendys);
  fastFoodVerify.addAll(mcDonalds);
  fastFoodVerify.addAll(tacoBell);
  assertEquals(fastFoodVerify,fastFood);
  wendys.remove(1);
  fastFood.set(0,""String_Node_Str"");
  fastFood.remove(1);
  fastFoodVerify.clear();
  fastFoodVerify.addAll(wendys);
  fastFoodVerify.addAll(mcDonalds);
  fastFoodVerify.addAll(tacoBell);
  assertEquals(fastFoodVerify,fastFood);
  mcDonalds.add(""String_Node_Str"");
  fastFoodVerify.clear();
  fastFoodVerify.addAll(wendys);
  fastFoodVerify.addAll(mcDonalds);
  fastFoodVerify.addAll(tacoBell);
  assertEquals(fastFoodVerify,fastFood);
  fastFood.removeMemberList(mcDonalds);
  fastFoodVerify.clear();
  fastFoodVerify.addAll(wendys);
  fastFoodVerify.addAll(tacoBell);
  assertEquals(fastFoodVerify,fastFood);
}",0.7918516583964481
32620,"/** 
 * Tests that after disposing   {@link CompositeList}, all installed ListEventListeners have been removed, e.g. changes to member lists are ignored.
 */
public void testDispose(){
  final EventList<String> memberListOne=new BasicEventList<String>();
  memberListOne.addAll(GlazedListsTests.stringToList(""String_Node_Str""));
  final EventList<String> memberListTwo=new BasicEventList<String>();
  memberListTwo.addAll(GlazedListsTests.stringToList(""String_Node_Str""));
  final CompositeList<String> composite=new CompositeList<String>();
  composite.addMemberList(memberListOne);
  composite.addMemberList(memberListTwo);
  final GlazedListsTests.ListEventCounter<String> eventCounter=new GlazedListsTests.ListEventCounter<String>();
  composite.addListEventListener(eventCounter);
  memberListOne.add(""String_Node_Str"");
  assertEquals(1,eventCounter.getCountAndReset());
  memberListTwo.remove(""String_Node_Str"");
  assertEquals(1,eventCounter.getCountAndReset());
  composite.dispose();
  memberListOne.remove(""String_Node_Str"");
  assertEquals(0,eventCounter.getCountAndReset());
  memberListTwo.add(0,""String_Node_Str"");
  assertEquals(0,eventCounter.getCountAndReset());
}","/** 
 * Tests that after disposing   {@link CompositeList}, all installed ListEventListeners have been removed, e.g. changes to member lists are ignored.
 */
public void testDispose(){
  final CompositeList<String> composite=new CompositeList<String>();
  final EventList<String> memberListOne=composite.createMemberList();
  memberListOne.addAll(GlazedListsTests.stringToList(""String_Node_Str""));
  final EventList<String> memberListTwo=composite.createMemberList();
  memberListTwo.addAll(GlazedListsTests.stringToList(""String_Node_Str""));
  composite.addMemberList(memberListOne);
  composite.addMemberList(memberListTwo);
  final GlazedListsTests.ListEventCounter<String> eventCounter=new GlazedListsTests.ListEventCounter<String>();
  composite.addListEventListener(eventCounter);
  memberListOne.add(""String_Node_Str"");
  assertEquals(1,eventCounter.getCountAndReset());
  memberListTwo.remove(""String_Node_Str"");
  assertEquals(1,eventCounter.getCountAndReset());
  composite.dispose();
  memberListOne.remove(""String_Node_Str"");
  assertEquals(0,eventCounter.getCountAndReset());
  memberListTwo.add(0,""String_Node_Str"");
  assertEquals(0,eventCounter.getCountAndReset());
}",0.8993231810490694
32621,"/** 
 * Verifies that a single source works.
 */
public void testSingleSource(){
  EventList<String> wendys=new BasicEventList<String>();
  wendys.add(""String_Node_Str"");
  wendys.add(""String_Node_Str"");
  wendys.add(""String_Node_Str"");
  wendys.add(""String_Node_Str"");
  CompositeList<String> fastFood=new CompositeList<String>();
  ListConsistencyListener.install(fastFood);
  fastFood.addMemberList(wendys);
  assertEquals(wendys,fastFood);
  wendys.add(""String_Node_Str"");
  wendys.add(""String_Node_Str"");
  assertEquals(wendys,fastFood);
  wendys.remove(1);
  fastFood.set(0,""String_Node_Str"");
  fastFood.remove(1);
  assertEquals(wendys,fastFood);
}","/** 
 * Verifies that a single source works.
 */
public void testSingleSource(){
  CompositeList<String> fastFood=new CompositeList<String>();
  ListConsistencyListener.install(fastFood);
  EventList<String> wendys=fastFood.createMemberList();
  wendys.add(""String_Node_Str"");
  wendys.add(""String_Node_Str"");
  wendys.add(""String_Node_Str"");
  wendys.add(""String_Node_Str"");
  fastFood.addMemberList(wendys);
  assertEquals(wendys,fastFood);
  wendys.add(""String_Node_Str"");
  wendys.add(""String_Node_Str"");
  assertEquals(wendys,fastFood);
  wendys.remove(1);
  fastFood.set(0,""String_Node_Str"");
  fastFood.remove(1);
  assertEquals(wendys,fastFood);
}",0.8054919908466819
32622,"/** 
 * Test that   {@link CompositeList} is well behaved when only a single elementis removed.
 */
public void testSingleElements(){
  EventList<String> alpha=new BasicEventList<String>();
  alpha.add(""String_Node_Str"");
  EventList<String> beta=new BasicEventList<String>();
  beta.add(""String_Node_Str"");
  CompositeList<String> aToB=new CompositeList<String>();
  ListConsistencyListener.install(aToB);
  aToB.addMemberList(alpha);
  aToB.removeMemberList(alpha);
  aToB.addMemberList(beta);
}","/** 
 * Test that   {@link CompositeList} is well behaved when only a single elementis removed.
 */
public void testSingleElements(){
  CompositeList<String> aToB=new CompositeList<String>();
  ListConsistencyListener.install(aToB);
  EventList<String> alpha=aToB.createMemberList();
  alpha.add(""String_Node_Str"");
  EventList<String> beta=aToB.createMemberList();
  beta.add(""String_Node_Str"");
  aToB.addMemberList(alpha);
  aToB.removeMemberList(alpha);
  aToB.addMemberList(beta);
}",0.7073170731707317
32623,"/** 
 * {@inheritDoc} 
 */
public void listChanged(ListEvent<E> listChanges){
  if (listChanges.isReordering()) {
    int[] sourceReorder=listChanges.getReorderMap();
    int[] previousIndexToSortedIndex=new int[sorted.size()];
    int index=0;
    for (SimpleTreeIterator<Element> i=new SimpleTreeIterator<Element>(sorted); i.hasNext(); index++) {
      i.next();
      Element<Element> unsortedNode=i.value();
      int unsortedIndex=unsorted.indexOfNode(unsortedNode,ALL_COLORS);
      previousIndexToSortedIndex[unsortedIndex]=index;
    }
    int[] newIndexToSortedIndex=new int[sorted.size()];
    for (int i=0; i < previousIndexToSortedIndex.length; i++) {
      newIndexToSortedIndex[i]=previousIndexToSortedIndex[sourceReorder[i]];
    }
    Element<Element>[] unsortedNodes=new Element[unsorted.size()];
    index=0;
    for (SimpleTreeIterator<Element> i=new SimpleTreeIterator<Element>(unsorted); i.hasNext(); index++) {
      i.next();
      Element<Element> unsortedNode=i.node();
      unsortedNodes[index]=unsortedNode;
    }
    Arrays.sort(unsortedNodes,sorted.getComparator());
    int[] reorderMap=new int[sorted.size()];
    boolean indexChanged=false;
    index=0;
    for (SimpleTreeIterator<Element> i=new SimpleTreeIterator<Element>(sorted); i.hasNext(); index++) {
      i.next();
      Element<Element> sortedNode=i.node();
      Element<Element> unsortedNode=unsortedNodes[index];
      sortedNode.set(unsortedNode);
      unsortedNode.set(sortedNode);
      int unsortedIndex=unsorted.indexOfNode(unsortedNode,ALL_COLORS);
      reorderMap[index]=newIndexToSortedIndex[unsortedIndex];
      indexChanged=indexChanged || (index != reorderMap[index]);
    }
    if (indexChanged) {
      updates.beginEvent();
      updates.reorder(reorderMap);
      updates.commitEvent();
    }
    return;
  }
  updates.beginEvent();
  LinkedList<Element> insertNodes=new LinkedList<Element>();
  List<Element<Element>> updateNodes=new ArrayList<Element<Element>>();
  while (listChanges.next()) {
    int unsortedIndex=listChanges.getIndex();
    int changeType=listChanges.getType();
    if (changeType == ListEvent.INSERT) {
      Element<Element> unsortedNode=unsorted.add(unsortedIndex,EMPTY_ELEMENT,1);
      insertNodes.addLast(unsortedNode);
    }
 else     if (changeType == ListEvent.UPDATE) {
      Element<Element> unsortedNode=unsorted.get(unsortedIndex);
      Element sortedNode=unsortedNode.get();
      sortedNode.setSorted(false);
      updateNodes.add(sortedNode);
    }
 else     if (changeType == ListEvent.DELETE) {
      Element<Element> unsortedNode=unsorted.get(unsortedIndex);
      unsorted.remove(unsortedNode);
      int deleteSortedIndex=deleteByUnsortedNode(unsortedNode);
      updates.addDelete(deleteSortedIndex);
    }
  }
  for (Iterator<Element<Element>> i=updateNodes.iterator(); i.hasNext(); ) {
    Element<Element> sortedNode=i.next();
    int originalIndex=sorted.indexOfNode(sortedNode,ALL_COLORS);
    if (isNodeInSortedOrder(sortedNode)) {
      sortedNode.setSorted(true);
      updates.addUpdate(originalIndex);
    }
 else     if (mode == AVOID_MOVING_ELEMENTS) {
      updates.addUpdate(originalIndex);
    }
 else {
      sorted.remove(sortedNode);
      updates.addDelete(originalIndex);
      int insertedIndex=insertByUnsortedNode(sortedNode.get());
      updates.addInsert(insertedIndex);
    }
  }
  while (!insertNodes.isEmpty()) {
    Element insertNode=insertNodes.removeFirst();
    int insertedIndex=insertByUnsortedNode(insertNode);
    updates.addInsert(insertedIndex);
  }
  updates.commitEvent();
}","/** 
 * {@inheritDoc} 
 */
public void listChanged(ListEvent<E> listChanges){
  if (listChanges.isReordering()) {
    int[] sourceReorder=listChanges.getReorderMap();
    int[] previousIndexToSortedIndex=new int[sorted.size()];
    int index=0;
    for (SimpleTreeIterator<Element> i=new SimpleTreeIterator<Element>(sorted); i.hasNext(); index++) {
      i.next();
      Element<Element> unsortedNode=i.value();
      int unsortedIndex=unsorted.indexOfNode(unsortedNode,ALL_COLORS);
      previousIndexToSortedIndex[unsortedIndex]=index;
    }
    int[] newIndexToSortedIndex=new int[sorted.size()];
    for (int i=0; i < previousIndexToSortedIndex.length; i++) {
      newIndexToSortedIndex[i]=previousIndexToSortedIndex[sourceReorder[i]];
    }
    Element<Element>[] unsortedNodes=new Element[unsorted.size()];
    index=0;
    for (SimpleTreeIterator<Element> i=new SimpleTreeIterator<Element>(unsorted); i.hasNext(); index++) {
      i.next();
      Element<Element> unsortedNode=i.node();
      unsortedNodes[index]=unsortedNode;
    }
    Arrays.sort(unsortedNodes,sorted.getComparator());
    int[] reorderMap=new int[sorted.size()];
    boolean indexChanged=false;
    index=0;
    for (SimpleTreeIterator<Element> i=new SimpleTreeIterator<Element>(sorted); i.hasNext(); index++) {
      i.next();
      Element<Element> sortedNode=i.node();
      Element<Element> unsortedNode=unsortedNodes[index];
      sortedNode.set(unsortedNode);
      unsortedNode.set(sortedNode);
      int unsortedIndex=unsorted.indexOfNode(unsortedNode,ALL_COLORS);
      reorderMap[index]=newIndexToSortedIndex[unsortedIndex];
      indexChanged=indexChanged || (index != reorderMap[index]);
    }
    if (indexChanged) {
      updates.beginEvent();
      updates.reorder(reorderMap);
      updates.commitEvent();
    }
    return;
  }
  updates.beginEvent();
  LinkedList<Element> insertNodes=new LinkedList<Element>();
  List<Element<Element>> updateNodes=new ArrayList<Element<Element>>();
  while (listChanges.next()) {
    int unsortedIndex=listChanges.getIndex();
    int changeType=listChanges.getType();
    if (changeType == ListEvent.INSERT) {
      Element<Element> unsortedNode=unsorted.add(unsortedIndex,EMPTY_ELEMENT,1);
      insertNodes.addLast(unsortedNode);
    }
 else     if (changeType == ListEvent.UPDATE) {
      Element<Element> unsortedNode=unsorted.get(unsortedIndex);
      Element sortedNode=unsortedNode.get();
      sortedNode.setSorted(Element.PENDING);
      updateNodes.add(sortedNode);
    }
 else     if (changeType == ListEvent.DELETE) {
      Element<Element> unsortedNode=unsorted.get(unsortedIndex);
      unsorted.remove(unsortedNode);
      int deleteSortedIndex=deleteByUnsortedNode(unsortedNode);
      updates.addDelete(deleteSortedIndex);
    }
  }
  for (Iterator<Element<Element>> i=updateNodes.iterator(); i.hasNext(); ) {
    Element<Element> sortedNode=i.next();
    if (sortedNode.getSorted() != Element.PENDING)     continue;
    Element lowerBound=null;
    Element upperBound=null;
    Element firstUnsortedNode=sortedNode;
    for (Element leftNeighbour=sortedNode.previous(); leftNeighbour != null; leftNeighbour=leftNeighbour.previous()) {
      if (leftNeighbour.getSorted() != Element.SORTED) {
        firstUnsortedNode=leftNeighbour;
        continue;
      }
      lowerBound=leftNeighbour;
      break;
    }
    for (Element rightNeighbour=sortedNode.next(); rightNeighbour != null; rightNeighbour=rightNeighbour.next()) {
      if (rightNeighbour.getSorted() != Element.SORTED)       continue;
      upperBound=rightNeighbour;
      break;
    }
    Comparator nodeComparator=sorted.getComparator();
    for (Element current=firstUnsortedNode; current != upperBound; current=current.next()) {
      if (upperBound != null && nodeComparator.compare(current.get(),upperBound.get()) > 0) {
        current.setSorted(Element.UNSORTED);
        continue;
      }
      if (lowerBound != null && nodeComparator.compare(current.get(),lowerBound.get()) < 0) {
        current.setSorted(Element.UNSORTED);
        continue;
      }
      current.setSorted(Element.SORTED);
      lowerBound=current;
    }
  }
  for (Iterator<Element<Element>> i=updateNodes.iterator(); i.hasNext(); ) {
    Element<Element> sortedNode=i.next();
    assert(sortedNode.getSorted() != Element.PENDING);
    int originalIndex=sorted.indexOfNode(sortedNode,ALL_COLORS);
    if (sortedNode.getSorted() == Element.SORTED) {
      updates.addUpdate(originalIndex);
    }
 else     if (mode == AVOID_MOVING_ELEMENTS) {
      updates.addUpdate(originalIndex);
    }
 else {
      sorted.remove(sortedNode);
      updates.addDelete(originalIndex);
      int insertedIndex=insertByUnsortedNode(sortedNode.get());
      updates.addInsert(insertedIndex);
    }
  }
  while (!insertNodes.isEmpty()) {
    Element insertNode=insertNodes.removeFirst();
    int insertedIndex=insertByUnsortedNode(insertNode);
    updates.addInsert(insertedIndex);
  }
  updates.commitEvent();
}",0.8204648989604019
32624,"/** 
 * Toggle whether this node is sorted.
 */
public void setSorted(boolean sorted){
  this.sorted=sorted;
}","/** 
 * Toggle whether this node is sorted.
 */
public void setSorted(int sorted){
  this.sorted=sorted;
}",0.9629629629629628
32625,"/** 
 * @param parent the subtree to insert into, must not be null.
 * @param color a bitmask value such as 1, 2, 4, 8, 16, 32, 64 or 128.
 * @param value the object to hold in the inserted node.
 * @param size the size of the inserted node, with respect to indices.
 * @return the inserted node, or the modified node if this insert simplyincreased the size of an existing node.
 */
private BciiNode<V> insertIntoSubtreeInSortedOrder(BciiNode<V> parent,byte color,V value,int size){
  while (true) {
    assert(parent != null);
    int sortSide;
    for (BciiNode<V> currentFollower=parent; true; currentFollower=next(currentFollower)) {
      if (currentFollower == null) {
        sortSide=-1;
        break;
      }
 else       if (currentFollower.sorted) {
        sortSide=comparator.compare(value,currentFollower.value);
        break;
      }
    }
    if (sortSide == 0 && color == parent.color && value == parent.value && value != null) {
      parent.size+=size;
      fixCountsThruRoot(parent,color,size);
      return parent;
    }
    boolean insertOnLeft=false;
    insertOnLeft=insertOnLeft || sortSide < 0;
    insertOnLeft=insertOnLeft || sortSide == 0 && parent.left == null;
    insertOnLeft=insertOnLeft || sortSide == 0 && parent.right != null && parent.left.height < parent.right.height;
    if (insertOnLeft) {
      BciiNode<V> parentLeft=parent.left;
      if (parentLeft == null) {
        BciiNode<V> inserted=new BciiNode<V>(color,size,value,parent);
        parent.left=inserted;
        fixCountsThruRoot(parent,color,size);
        fixHeightPostChange(parent,false);
        return inserted;
      }
 else {
        parent=parentLeft;
        continue;
      }
    }
 else {
      BciiNode<V> parentRight=parent.right;
      if (parentRight == null) {
        BciiNode<V> inserted=new BciiNode<V>(color,size,value,parent);
        parent.right=inserted;
        fixCountsThruRoot(parent,color,size);
        fixHeightPostChange(parent,false);
        return inserted;
      }
 else {
        parent=parentRight;
      }
    }
  }
}","/** 
 * @param parent the subtree to insert into, must not be null.
 * @param color a bitmask value such as 1, 2, 4, 8, 16, 32, 64 or 128.
 * @param value the object to hold in the inserted node.
 * @param size the size of the inserted node, with respect to indices.
 * @return the inserted node, or the modified node if this insert simplyincreased the size of an existing node.
 */
private BciiNode<V> insertIntoSubtreeInSortedOrder(BciiNode<V> parent,byte color,V value,int size){
  while (true) {
    assert(parent != null);
    int sortSide;
    for (BciiNode<V> currentFollower=parent; true; currentFollower=next(currentFollower)) {
      if (currentFollower == null) {
        sortSide=-1;
        break;
      }
 else       if (currentFollower.sorted == Element.SORTED) {
        sortSide=comparator.compare(value,currentFollower.value);
        break;
      }
    }
    if (sortSide == 0 && color == parent.color && value == parent.value && value != null) {
      parent.size+=size;
      fixCountsThruRoot(parent,color,size);
      return parent;
    }
    boolean insertOnLeft=false;
    insertOnLeft=insertOnLeft || sortSide < 0;
    insertOnLeft=insertOnLeft || sortSide == 0 && parent.left == null;
    insertOnLeft=insertOnLeft || sortSide == 0 && parent.right != null && parent.left.height < parent.right.height;
    if (insertOnLeft) {
      BciiNode<V> parentLeft=parent.left;
      if (parentLeft == null) {
        BciiNode<V> inserted=new BciiNode<V>(color,size,value,parent);
        parent.left=inserted;
        fixCountsThruRoot(parent,color,size);
        fixHeightPostChange(parent,false);
        return inserted;
      }
 else {
        parent=parentLeft;
        continue;
      }
    }
 else {
      BciiNode<V> parentRight=parent.right;
      if (parentRight == null) {
        BciiNode<V> inserted=new BciiNode<V>(color,size,value,parent);
        parent.right=inserted;
        fixCountsThruRoot(parent,color,size);
        fixHeightPostChange(parent,false);
        return inserted;
      }
 else {
        parent=parentRight;
      }
    }
  }
}",0.9956542732979236
32626,void setSorted(boolean sorted);,void setSorted(int sorted);,0.8620689655172413
32627,"/** 
 * Toggle whether this node is sorted.
 */
public void setSorted(boolean sorted){
  this.sorted=sorted;
}","/** 
 * Toggle whether this node is sorted.
 */
public void setSorted(int sorted){
  this.sorted=sorted;
}",0.9629629629629628
32628,"/** 
 * @param parent the subtree to insert into, must not be null.
 * @param color a bitmask value such as 1, 2, 4, 8, 16, 32, 64 or 128.
 * @param value the object to hold in the inserted node.
 * @param size the size of the inserted node, with respect to indices.
 * @return the inserted node, or the modified node if this insert simplyincreased the size of an existing node.
 */
private FourColorNode<V> insertIntoSubtreeInSortedOrder(FourColorNode<V> parent,byte color,V value,int size){
  while (true) {
    assert(parent != null);
    int sortSide;
    for (FourColorNode<V> currentFollower=parent; true; currentFollower=next(currentFollower)) {
      if (currentFollower == null) {
        sortSide=-1;
        break;
      }
 else       if (currentFollower.sorted) {
        sortSide=comparator.compare(value,currentFollower.value);
        break;
      }
    }
    if (sortSide == 0 && color == parent.color && value == parent.value && value != null) {
      parent.size+=size;
      fixCountsThruRoot(parent,color,size);
      return parent;
    }
    boolean insertOnLeft=false;
    insertOnLeft=insertOnLeft || sortSide < 0;
    insertOnLeft=insertOnLeft || sortSide == 0 && parent.left == null;
    insertOnLeft=insertOnLeft || sortSide == 0 && parent.right != null && parent.left.height < parent.right.height;
    if (insertOnLeft) {
      FourColorNode<V> parentLeft=parent.left;
      if (parentLeft == null) {
        FourColorNode<V> inserted=new FourColorNode<V>(color,size,value,parent);
        parent.left=inserted;
        fixCountsThruRoot(parent,color,size);
        fixHeightPostChange(parent,false);
        return inserted;
      }
 else {
        parent=parentLeft;
        continue;
      }
    }
 else {
      FourColorNode<V> parentRight=parent.right;
      if (parentRight == null) {
        FourColorNode<V> inserted=new FourColorNode<V>(color,size,value,parent);
        parent.right=inserted;
        fixCountsThruRoot(parent,color,size);
        fixHeightPostChange(parent,false);
        return inserted;
      }
 else {
        parent=parentRight;
      }
    }
  }
}","/** 
 * @param parent the subtree to insert into, must not be null.
 * @param color a bitmask value such as 1, 2, 4, 8, 16, 32, 64 or 128.
 * @param value the object to hold in the inserted node.
 * @param size the size of the inserted node, with respect to indices.
 * @return the inserted node, or the modified node if this insert simplyincreased the size of an existing node.
 */
private FourColorNode<V> insertIntoSubtreeInSortedOrder(FourColorNode<V> parent,byte color,V value,int size){
  while (true) {
    assert(parent != null);
    int sortSide;
    for (FourColorNode<V> currentFollower=parent; true; currentFollower=next(currentFollower)) {
      if (currentFollower == null) {
        sortSide=-1;
        break;
      }
 else       if (currentFollower.sorted == Element.SORTED) {
        sortSide=comparator.compare(value,currentFollower.value);
        break;
      }
    }
    if (sortSide == 0 && color == parent.color && value == parent.value && value != null) {
      parent.size+=size;
      fixCountsThruRoot(parent,color,size);
      return parent;
    }
    boolean insertOnLeft=false;
    insertOnLeft=insertOnLeft || sortSide < 0;
    insertOnLeft=insertOnLeft || sortSide == 0 && parent.left == null;
    insertOnLeft=insertOnLeft || sortSide == 0 && parent.right != null && parent.left.height < parent.right.height;
    if (insertOnLeft) {
      FourColorNode<V> parentLeft=parent.left;
      if (parentLeft == null) {
        FourColorNode<V> inserted=new FourColorNode<V>(color,size,value,parent);
        parent.left=inserted;
        fixCountsThruRoot(parent,color,size);
        fixHeightPostChange(parent,false);
        return inserted;
      }
 else {
        parent=parentLeft;
        continue;
      }
    }
 else {
      FourColorNode<V> parentRight=parent.right;
      if (parentRight == null) {
        FourColorNode<V> inserted=new FourColorNode<V>(color,size,value,parent);
        parent.right=inserted;
        fixCountsThruRoot(parent,color,size);
        fixHeightPostChange(parent,false);
        return inserted;
      }
 else {
        parent=parentRight;
      }
    }
  }
}",0.9957466918714556
32629,"/** 
 * Toggle whether this node is sorted.
 */
public void setSorted(boolean sorted){
  this.sorted=sorted;
}","/** 
 * Toggle whether this node is sorted.
 */
public void setSorted(int sorted){
  this.sorted=sorted;
}",0.9629629629629628
32630,"/** 
 * @param parent the subtree to insert into, must not be null.
 * @param color a bitmask value such as 1, 2, 4, 8, 16, 32, 64 or 128.
 * @param value the object to hold in the inserted node.
 * @param size the size of the inserted node, with respect to indices.
 * @return the inserted node, or the modified node if this insert simplyincreased the size of an existing node.
 */
private SimpleNode<V> insertIntoSubtreeInSortedOrder(SimpleNode<V> parent,V value,int size){
  while (true) {
    assert(parent != null);
    int sortSide;
    for (SimpleNode<V> currentFollower=parent; true; currentFollower=next(currentFollower)) {
      if (currentFollower == null) {
        sortSide=-1;
        break;
      }
 else       if (currentFollower.sorted) {
        sortSide=comparator.compare(value,currentFollower.value);
        break;
      }
    }
    if (false && sortSide == 0 && value == parent.value && value != null) {
      fixCountsThruRoot(parent,size);
      return parent;
    }
    boolean insertOnLeft=false;
    insertOnLeft=insertOnLeft || sortSide < 0;
    insertOnLeft=insertOnLeft || sortSide == 0 && parent.left == null;
    insertOnLeft=insertOnLeft || sortSide == 0 && parent.right != null && parent.left.height < parent.right.height;
    if (insertOnLeft) {
      SimpleNode<V> parentLeft=parent.left;
      if (parentLeft == null) {
        SimpleNode<V> inserted=new SimpleNode<V>(size,value,parent);
        parent.left=inserted;
        fixCountsThruRoot(parent,size);
        fixHeightPostChange(parent,false);
        return inserted;
      }
 else {
        parent=parentLeft;
        continue;
      }
    }
 else {
      SimpleNode<V> parentRight=parent.right;
      if (parentRight == null) {
        SimpleNode<V> inserted=new SimpleNode<V>(size,value,parent);
        parent.right=inserted;
        fixCountsThruRoot(parent,size);
        fixHeightPostChange(parent,false);
        return inserted;
      }
 else {
        parent=parentRight;
      }
    }
  }
}","/** 
 * @param parent the subtree to insert into, must not be null.
 * @param color a bitmask value such as 1, 2, 4, 8, 16, 32, 64 or 128.
 * @param value the object to hold in the inserted node.
 * @param size the size of the inserted node, with respect to indices.
 * @return the inserted node, or the modified node if this insert simplyincreased the size of an existing node.
 */
private SimpleNode<V> insertIntoSubtreeInSortedOrder(SimpleNode<V> parent,V value,int size){
  while (true) {
    assert(parent != null);
    int sortSide;
    for (SimpleNode<V> currentFollower=parent; true; currentFollower=next(currentFollower)) {
      if (currentFollower == null) {
        sortSide=-1;
        break;
      }
 else       if (currentFollower.sorted == Element.SORTED) {
        sortSide=comparator.compare(value,currentFollower.value);
        break;
      }
    }
    if (false && sortSide == 0 && value == parent.value && value != null) {
      fixCountsThruRoot(parent,size);
      return parent;
    }
    boolean insertOnLeft=false;
    insertOnLeft=insertOnLeft || sortSide < 0;
    insertOnLeft=insertOnLeft || sortSide == 0 && parent.left == null;
    insertOnLeft=insertOnLeft || sortSide == 0 && parent.right != null && parent.left.height < parent.right.height;
    if (insertOnLeft) {
      SimpleNode<V> parentLeft=parent.left;
      if (parentLeft == null) {
        SimpleNode<V> inserted=new SimpleNode<V>(size,value,parent);
        parent.left=inserted;
        fixCountsThruRoot(parent,size);
        fixHeightPostChange(parent,false);
        return inserted;
      }
 else {
        parent=parentLeft;
        continue;
      }
    }
 else {
      SimpleNode<V> parentRight=parent.right;
      if (parentRight == null) {
        SimpleNode<V> inserted=new SimpleNode<V>(size,value,parent);
        parent.right=inserted;
        fixCountsThruRoot(parent,size);
        fixHeightPostChange(parent,false);
        return inserted;
      }
 else {
        parent=parentRight;
      }
    }
  }
}",0.9955156950672646
32631,"/** 
 * Make sure we can have a few unsorted elements in an otherwise ordered tree.
 */
public void testUnsortedElementInSortedTree(){
  SimpleTree<String> tree=new SimpleTree<String>();
  Element<String> e=tree.addInSortedOrder(Tree1Test.allColors,""String_Node_Str"",1);
  Element<String> g=tree.addInSortedOrder(Tree1Test.allColors,""String_Node_Str"",1);
  Element<String> i=tree.addInSortedOrder(Tree1Test.allColors,""String_Node_Str"",1);
  Element<String> k=tree.addInSortedOrder(Tree1Test.allColors,""String_Node_Str"",1);
  Element<String> m=tree.addInSortedOrder(Tree1Test.allColors,""String_Node_Str"",1);
  Element<String> o=tree.addInSortedOrder(Tree1Test.allColors,""String_Node_Str"",1);
  k.setSorted(false);
  k.set(""String_Node_Str"");
  Element<String> h=tree.addInSortedOrder(Tree1Test.allColors,""String_Node_Str"",1);
  Element<String> n=tree.addInSortedOrder(Tree1Test.allColors,""String_Node_Str"",1);
  List<String> asList=new SimpleTreeAsList<String>(tree);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),asList);
}","/** 
 * Make sure we can have a few unsorted elements in an otherwise ordered tree.
 */
public void testUnsortedElementInSortedTree(){
  SimpleTree<String> tree=new SimpleTree<String>();
  Element<String> e=tree.addInSortedOrder(Tree1Test.allColors,""String_Node_Str"",1);
  Element<String> g=tree.addInSortedOrder(Tree1Test.allColors,""String_Node_Str"",1);
  Element<String> i=tree.addInSortedOrder(Tree1Test.allColors,""String_Node_Str"",1);
  Element<String> k=tree.addInSortedOrder(Tree1Test.allColors,""String_Node_Str"",1);
  Element<String> m=tree.addInSortedOrder(Tree1Test.allColors,""String_Node_Str"",1);
  Element<String> o=tree.addInSortedOrder(Tree1Test.allColors,""String_Node_Str"",1);
  k.setSorted(Element.UNSORTED);
  k.set(""String_Node_Str"");
  Element<String> h=tree.addInSortedOrder(Tree1Test.allColors,""String_Node_Str"",1);
  Element<String> n=tree.addInSortedOrder(Tree1Test.allColors,""String_Node_Str"",1);
  List<String> asList=new SimpleTreeAsList<String>(tree);
  assertEquals(GlazedListsTests.stringToList(""String_Node_Str""),asList);
}",0.9899665551839464
32632,"/** 
 * Change the selection to be the set union of the current selection  and the indices between index0 and index1 inclusive
 */
public void addSelectionInterval(int index0,int index1){
  if (!enabled)   return;
  listSelection.select(index0,index1);
}","/** 
 * Change the selection to be the set union of the current selection  and the indices between index0 and index1 inclusive
 */
public void addSelectionInterval(int index0,int index1){
  if (!enabled)   return;
  swingThreadSource.getReadWriteLock().writeLock().lock();
  try {
    listSelection.select(index0,index1);
  }
  finally {
    swingThreadSource.getReadWriteLock().writeLock().unlock();
  }
}",0.7696969696969697
32633,"/** 
 * Change the selection to the empty set.
 */
public void clearSelection(){
  if (!enabled)   return;
  listSelection.deselectAll();
}","/** 
 * Change the selection to the empty set.
 */
public void clearSelection(){
  if (!enabled)   return;
  swingThreadSource.getReadWriteLock().writeLock().lock();
  try {
    listSelection.deselectAll();
  }
  finally {
    swingThreadSource.getReadWriteLock().writeLock().unlock();
  }
}",0.6465116279069767
32634,"/** 
 * Inverts the current selection.
 */
public void invertSelection(){
  listSelection.invertSelection();
}","/** 
 * Inverts the current selection.
 */
public void invertSelection(){
  swingThreadSource.getReadWriteLock().writeLock().lock();
  try {
    listSelection.invertSelection();
  }
  finally {
    swingThreadSource.getReadWriteLock().writeLock().unlock();
  }
}",0.4354838709677419
32635,"/** 
 * Change the selection to be between index0 and index1 inclusive. <p>First this calculates the smallest range where changes occur. This includes the union of the selection range before and the selection range specified. It then walks through the change and sets each index as selected or not based on whether the index is in the new range. Finally it fires events to both the listening lists and selection listeners about what changes happened. <p>If the selection does not change, this will not fire any events.
 */
public void setSelectionInterval(int index0,int index1){
  if (!enabled)   return;
  listSelection.setSelection(index0,index1);
}","/** 
 * Change the selection to be between index0 and index1 inclusive. <p>First this calculates the smallest range where changes occur. This includes the union of the selection range before and the selection range specified. It then walks through the change and sets each index as selected or not based on whether the index is in the new range. Finally it fires events to both the listening lists and selection listeners about what changes happened. <p>If the selection does not change, this will not fire any events.
 */
public void setSelectionInterval(int index0,int index1){
  if (!enabled)   return;
  swingThreadSource.getReadWriteLock().writeLock().lock();
  try {
    listSelection.setSelection(index0,index1);
  }
  finally {
    swingThreadSource.getReadWriteLock().writeLock().unlock();
  }
}",0.8956043956043956
32636,"/** 
 * Set the selection mode.
 */
public void setSelectionMode(int selectionMode){
  listSelection.setSelectionMode(selectionMode);
}","/** 
 * Set the selection mode.
 */
public void setSelectionMode(int selectionMode){
  swingThreadSource.getReadWriteLock().writeLock().lock();
  try {
    listSelection.setSelectionMode(selectionMode);
  }
  finally {
    swingThreadSource.getReadWriteLock().writeLock().unlock();
  }
}",0.4312796208530806
32637,"/** 
 * Set the anchor selection index.
 */
public void setAnchorSelectionIndex(int anchorSelectionIndex){
  if (!enabled)   return;
  listSelection.setAnchorSelectionIndex(anchorSelectionIndex);
}","/** 
 * Set the anchor selection index.
 */
public void setAnchorSelectionIndex(int anchorSelectionIndex){
  if (!enabled)   return;
  swingThreadSource.getReadWriteLock().writeLock().lock();
  try {
    listSelection.setAnchorSelectionIndex(anchorSelectionIndex);
  }
  finally {
    swingThreadSource.getReadWriteLock().writeLock().unlock();
  }
}",0.7216117216117216
32638,"/** 
 * Change the selection to be the set difference of the current selection  and the indices between index0 and index1 inclusive.
 */
public void removeSelectionInterval(int index0,int index1){
  if (!enabled)   return;
  if (index0 == 0 && index1 == 0 && swingThreadSource.isEmpty())   return;
  listSelection.deselect(index0,index1);
}","/** 
 * Change the selection to be the set difference of the current selection  and the indices between index0 and index1 inclusive.
 */
public void removeSelectionInterval(int index0,int index1){
  if (!enabled)   return;
  if (index0 == 0 && index1 == 0 && swingThreadSource.isEmpty())   return;
  swingThreadSource.getReadWriteLock().writeLock().lock();
  try {
    listSelection.deselect(index0,index1);
  }
  finally {
    swingThreadSource.getReadWriteLock().writeLock().unlock();
  }
}",0.8076923076923077
32639,"/** 
 * This property is true if upcoming changes to the value  of the model should be considered a single event.
 */
public void setValueIsAdjusting(boolean valueIsAdjusting){
  this.valueIsAdjusting=valueIsAdjusting;
  if (!valueIsAdjusting) {
    if (fullChangeStart != -1 && fullChangeFinish != -1) {
      fireSelectionChanged(fullChangeStart,fullChangeFinish);
      fullChangeStart=-1;
      fullChangeFinish=-1;
    }
  }
}","/** 
 * This property is true if upcoming changes to the value  of the model should be considered a single event.
 */
public void setValueIsAdjusting(boolean valueIsAdjusting){
  this.valueIsAdjusting=valueIsAdjusting;
  if (!valueIsAdjusting) {
    if (fullChangeStart != -1 && fullChangeFinish != -1) {
      swingThreadSource.getReadWriteLock().writeLock().lock();
      try {
        fireSelectionChanged(fullChangeStart,fullChangeFinish);
        fullChangeStart=-1;
        fullChangeFinish=-1;
      }
  finally {
        swingThreadSource.getReadWriteLock().writeLock().unlock();
      }
    }
  }
}",0.8227360308285164
32640,"/** 
 * Set the lead selection index.
 */
public void setLeadSelectionIndex(int leadSelectionIndex){
  if (!enabled)   return;
  listSelection.setLeadSelectionIndex(leadSelectionIndex);
}","/** 
 * Set the lead selection index.
 */
public void setLeadSelectionIndex(int leadSelectionIndex){
  if (!enabled)   return;
  swingThreadSource.getReadWriteLock().writeLock().lock();
  try {
    listSelection.setLeadSelectionIndex(leadSelectionIndex);
  }
  finally {
    swingThreadSource.getReadWriteLock().writeLock().unlock();
  }
}",0.7110266159695817
32641,"/** 
 * Construct a multimap which maps the keys produced by the <code>keyFunction</code>, to groups of values from <code>source</code> that agree on their keys.
 * @param source the raw data which has not yet been grouped
 * @param keyFunction the function capable of producing the keys of this{@link Map}; the keys themselves are   {@link Comparable} and thusalso determine the content of the  {@link List}s which are the values of this   {@link Map}.
 */
public GroupingListMultiMap(EventList<V> source,FunctionList.Function<V,? extends Comparable<K>> keyFunction){
  this.keyFunction=keyFunction;
  this.groupingList=new GroupingList<V>(source,new FunctionComparator(keyFunction));
  this.valueList=new FunctionList<List<V>,List<V>>(this.groupingList,new ValueListFunction());
  this.valueList.addListEventListener(this);
  this.keyList=new BasicEventList<Comparable<K>>(this.groupingList.size());
  this.delegate=new HashMap<Comparable<K>,List<V>>(this.groupingList.size());
  for (Iterator<List<V>> i=this.groupingList.iterator(); i.hasNext(); ) {
    final List<V> value=i.next();
    final Comparable key=key(value);
    this.keyList.add(key);
    this.delegate.put(key,value);
  }
}","/** 
 * Construct a multimap which maps the keys produced by the <code>keyFunction</code>, to groups of values from <code>source</code> that agree on their keys.
 * @param source the raw data which has not yet been grouped
 * @param keyFunction the function capable of producing the keys of this{@link Map}; the keys themselves are   {@link Comparable} and thusalso determine the content of the  {@link List}s which are the values of this   {@link Map}.
 */
public GroupingListMultiMap(EventList<V> source,FunctionList.Function<V,? extends Comparable<K>> keyFunction){
  this.keyFunction=keyFunction;
  this.groupingList=new GroupingList<V>(source,new FunctionComparator(keyFunction));
  this.valueList=new FunctionList<List<V>,List<V>>(this.groupingList,new ValueListFunction());
  this.valueList.addListEventListener(this);
  this.keyList=new BasicEventList<Comparable<K>>(this.groupingList.size());
  this.delegate=new HashMap<Comparable<K>,List<V>>(this.groupingList.size());
  for (Iterator<List<V>> i=this.valueList.iterator(); i.hasNext(); ) {
    final List<V> value=i.next();
    final Comparable key=key(value);
    this.keyList.add(key);
    this.delegate.put(key,value);
  }
}",0.994535519125683
32642,"/** 
 * {@inheritDoc} 
 */
public String toString(){
  return getKey() + ""String_Node_Str"" + getValue();
}","public String toString(){
  return delegate.toString();
}",0.6012269938650306
32643,"/** 
 * Rebuild the subject and listeners list so that all required invariants are met with respect to notification order. That is, for any listener T, all of the subjects S that T listens to have been updated before T receives a change event from any S. <p>This implementation still has some problems and work left to do: <li>it's big! Can we optimize it? Perhaps shortcutting all the graph work for simple cases (the 99% case) <li>it's complex! Can we simplify it? <li>could we keep the datastructures around? it may be wasteful to reconstruct them every single time a listener is changed
 */
private List<SubjectAndListener> orderSubjectsAndListeners(List<SubjectAndListener> subjectsAndListeners){
  List<SubjectAndListener> result=new ArrayList<SubjectAndListener>();
  IdentityMultimap<Object,SubjectAndListener> sourceToPairs=new IdentityMultimap<Object,SubjectAndListener>();
  IdentityMultimap<Object,SubjectAndListener> targetToPairs=new IdentityMultimap<Object,SubjectAndListener>();
  Map<Object,Boolean> satisfied=new IdentityHashMap<Object,Boolean>();
  List<Object> satisfiedToDo=new ArrayList<Object>();
  for (int i=0, size=subjectsAndListeners.size(); i < size; i++) {
    SubjectAndListener subjectAndListener=subjectsAndListeners.get(i);
    Object source=subjectAndListener.subject;
    Object target=getRelatedSubject(subjectAndListener.listener);
    sourceToPairs.addValue(source,subjectAndListener);
    targetToPairs.addValue(target,subjectAndListener);
    satisfied.remove(target);
    if (targetToPairs.count(source) == 0) {
      satisfied.put(source,Boolean.TRUE);
    }
  }
  satisfiedToDo.addAll(satisfied.keySet());
  while (!satisfiedToDo.isEmpty()) {
    Object subject=satisfiedToDo.remove(0);
    List<SubjectAndListener> sourceTargets=sourceToPairs.get(subject);
    tryEachTarget:     for (int t=0, targetsSize=sourceTargets.size(); t < targetsSize; t++) {
      Object sourceTarget=getRelatedSubject(sourceTargets.get(t).listener);
      List<SubjectAndListener> allSourcesForSourceTarget=targetToPairs.get(sourceTarget);
      if (allSourcesForSourceTarget.size() == 0)       continue;
      for (int s=0, sourcesSize=allSourcesForSourceTarget.size(); s < sourcesSize; s++) {
        SubjectAndListener sourceAndTarget=allSourcesForSourceTarget.get(s);
        if (!satisfied.containsKey(sourceAndTarget.subject)) {
          continue tryEachTarget;
        }
      }
      result.addAll(allSourcesForSourceTarget);
      targetToPairs.remove(sourceTarget);
      satisfiedToDo.add(sourceTarget);
      satisfied.put(sourceTarget,Boolean.TRUE);
    }
  }
  if (!targetToPairs.isEmpty()) {
    throw new IllegalStateException(""String_Node_Str"" + targetToPairs.values());
  }
  return result;
}","/** 
 * Rebuild the subject and listeners list so that all required invariants are met with respect to notification order. That is, for any listener T, all of the subjects S that T listens to have been updated before T receives a change event from any S. <p>This implementation still has some problems and work left to do: <li>it's big! Can we optimize it? Perhaps shortcutting all the graph work for simple cases (the 99% case) <li>it's complex! Can we simplify it? <li>could we keep the datastructures around? it may be wasteful to reconstruct them every single time a listener is changed
 */
private List<SubjectAndListener> orderSubjectsAndListeners(List<SubjectAndListener> subjectsAndListeners){
  List<SubjectAndListener> result=new ArrayList<SubjectAndListener>();
  IdentityMultimap<Object,SubjectAndListener> sourceToPairs=new IdentityMultimap<Object,SubjectAndListener>();
  IdentityMultimap<Object,SubjectAndListener> targetToPairs=new IdentityMultimap<Object,SubjectAndListener>();
  Map<Object,Boolean> satisfied=new IdentityHashMap<Object,Boolean>();
  List<Object> satisfiedToDo=new ArrayList<Object>();
  for (int i=0, size=subjectsAndListeners.size(); i < size; i++) {
    SubjectAndListener subjectAndListener=subjectsAndListeners.get(i);
    Object source=subjectAndListener.subject;
    Object target=getRelatedSubject(subjectAndListener.listener);
    sourceToPairs.addValue(source,subjectAndListener);
    targetToPairs.addValue(target,subjectAndListener);
    satisfied.remove(target);
    if (targetToPairs.count(source) == 0) {
      satisfied.put(source,Boolean.TRUE);
    }
  }
  satisfiedToDo.addAll(satisfied.keySet());
  while (!satisfiedToDo.isEmpty()) {
    Object subject=satisfiedToDo.remove(0);
    List<SubjectAndListener> sourceTargets=(List<SubjectAndListener>)sourceToPairs.get(subject);
    tryEachTarget:     for (int t=0, targetsSize=sourceTargets.size(); t < targetsSize; t++) {
      Object sourceTarget=getRelatedSubject(sourceTargets.get(t).listener);
      List<SubjectAndListener> allSourcesForSourceTarget=(List<SubjectAndListener>)targetToPairs.get(sourceTarget);
      if (allSourcesForSourceTarget.size() == 0)       continue;
      for (int s=0, sourcesSize=allSourcesForSourceTarget.size(); s < sourcesSize; s++) {
        SubjectAndListener sourceAndTarget=allSourcesForSourceTarget.get(s);
        if (!satisfied.containsKey(sourceAndTarget.subject)) {
          continue tryEachTarget;
        }
      }
      result.addAll(allSourcesForSourceTarget);
      targetToPairs.remove(sourceTarget);
      satisfiedToDo.add(sourceTarget);
      satisfied.put(sourceTarget,Boolean.TRUE);
    }
  }
  if (!targetToPairs.isEmpty()) {
    throw new IllegalStateException(""String_Node_Str"" + targetToPairs.values());
  }
  return result;
}",0.9905797101449276
32644,"/** 
 * Toggle between filtering by the keystroke and not.
 * @param live <code>true</code> to filter by the keystroke or <code>false</code>to filter only when  {@link java.awt.event.KeyEvent#VK_ENTER Enter} is pressedwithin the  {@link JTextField}. Note that non-live filtering is only supported if <code>textComponent</code> is a   {@link JTextField}.
 */
public void setLive(boolean live){
  if (live == this.live)   return;
  deregisterListeners(this.live);
  this.live=live;
  registerListeners(this.live);
}","/** 
 * Toggle between filtering by the keystroke and not.
 * @param live <code>true</code> to filter by the keystroke or <code>false</code>to filter only when  {@link java.awt.event.KeyEvent#VK_ENTER Enter} is pressedwithin the  {@link JTextComponent}. Note that non-live filtering is only supported if <code>textComponent</code> is a   {@link JTextField}.
 */
public void setLive(boolean live){
  if (live == this.live)   return;
  deregisterListeners(this.live);
  this.live=live;
  registerListeners(this.live);
}",0.9864077669902912
32645,"/** 
 * Creates a TextMatcherEditor bound to the given <code>document</code> with the given <code>textFilterator</code>.
 * @param document the {@link Document} that is the source of text filtervalues
 * @param textFilterator an object capable of producing Strings from theobjects being filtered. If <code>textFilterator</code> is <code>null</code> then all filtered objects are expected to implement  {@link ca.odell.glazedlists.TextFilterable}.
 */
public TextComponentMatcherEditor(Document document,TextFilterator<E> textFilterator){
  super(textFilterator);
  this.document=document;
  registerListeners(true);
  refilter();
}","/** 
 * This private constructor implements the actual construction work and thus ensures that all public constructors agree on the construction logic.
 */
private TextComponentMatcherEditor(JTextComponent textComponent,Document document,TextFilterator<E> textFilterator,boolean live){
  super(textFilterator);
  this.textComponent=textComponent;
  this.document=document;
  this.live=live;
  registerListeners(live);
  refilter();
}",0.3364661654135338
32646,"/** 
 * Test that this thing works with dispose.
 */
public void guiTestDispose(){
  TextComponentMatcherEditor textMatcherEditor=null;
  eventCounter.assertNoEvents(0);
  boolean[] liveOptions={true,false};
  for (int b=0; b < liveOptions.length; b++) {
    JTextField textField=new JTextField();
    textMatcherEditor=new TextComponentMatcherEditor(textField,GlazedLists.toStringTextFilterator(),liveOptions[b]);
    textField.setText(""String_Node_Str"");
    textField.postActionEvent();
    assertTrue(textMatcherEditor.getMatcher().matches(""String_Node_Str""));
    assertFalse(textMatcherEditor.getMatcher().matches(""String_Node_Str""));
    textMatcherEditor.dispose();
    textField.setText(""String_Node_Str"");
    textField.postActionEvent();
    assertTrue(textMatcherEditor.getMatcher().matches(""String_Node_Str""));
    assertFalse(textMatcherEditor.getMatcher().matches(""String_Node_Str""));
  }
}","/** 
 * Test that this thing works with dispose.
 */
public void guiTestDispose(){
  TextComponentMatcherEditor<String> textMatcherEditor=null;
  eventCounter.assertNoEvents(0);
  boolean[] liveOptions={true,false};
  for (int b=0; b < liveOptions.length; b++) {
    JTextField textField=new JTextField();
    textMatcherEditor=new TextComponentMatcherEditor<String>(textField,GlazedLists.toStringTextFilterator(),liveOptions[b]);
    textField.setText(""String_Node_Str"");
    textField.postActionEvent();
    assertTrue(textMatcherEditor.getMatcher().matches(""String_Node_Str""));
    assertFalse(textMatcherEditor.getMatcher().matches(""String_Node_Str""));
    textMatcherEditor.dispose();
    textField.setText(""String_Node_Str"");
    textField.postActionEvent();
    assertTrue(textMatcherEditor.getMatcher().matches(""String_Node_Str""));
    assertFalse(textMatcherEditor.getMatcher().matches(""String_Node_Str""));
  }
}",0.991237677984666
32647,"/** 
 * Test that this thing works, even if our document is preloaded with data.
 */
public void guiTestPrePopulated(){
  TextComponentMatcherEditor textMatcherEditor=null;
  eventCounter.assertNoEvents(0);
  JTextField prePopulatedTextField=new JTextField();
  prePopulatedTextField.setText(""String_Node_Str"");
  textMatcherEditor=new TextComponentMatcherEditor(prePopulatedTextField,GlazedLists.toStringTextFilterator(),true);
  assertTrue(textMatcherEditor.getMatcher().matches(""String_Node_Str""));
  assertFalse(textMatcherEditor.getMatcher().matches(""String_Node_Str""));
  textMatcherEditor=new TextComponentMatcherEditor(prePopulatedTextField.getDocument(),GlazedLists.toStringTextFilterator());
  assertTrue(textMatcherEditor.getMatcher().matches(""String_Node_Str""));
  assertFalse(textMatcherEditor.getMatcher().matches(""String_Node_Str""));
}","/** 
 * Test that this thing works, even if our document is preloaded with data.
 */
public void guiTestPrePopulated(){
  TextComponentMatcherEditor<String> textMatcherEditor=null;
  eventCounter.assertNoEvents(0);
  JTextField prePopulatedTextField=new JTextField();
  prePopulatedTextField.setText(""String_Node_Str"");
  textMatcherEditor=new TextComponentMatcherEditor<String>(prePopulatedTextField,GlazedLists.toStringTextFilterator(),true);
  assertTrue(textMatcherEditor.getMatcher().matches(""String_Node_Str""));
  assertFalse(textMatcherEditor.getMatcher().matches(""String_Node_Str""));
  textMatcherEditor=new TextComponentMatcherEditor<String>(prePopulatedTextField.getDocument(),GlazedLists.toStringTextFilterator());
  assertTrue(textMatcherEditor.getMatcher().matches(""String_Node_Str""));
  assertFalse(textMatcherEditor.getMatcher().matches(""String_Node_Str""));
}",0.9860788863109048
32648,"/** 
 * Test that this thing works when live is turned off.
 */
public void guiTestNonLive(){
  TextComponentMatcherEditor textMatcherEditor=null;
  eventCounter.assertNoEvents(0);
  JTextField textField=new JTextField();
  textMatcherEditor=new TextComponentMatcherEditor(textField,GlazedLists.toStringTextFilterator(),false);
  assertTrue(textMatcherEditor.getMatcher().matches(""String_Node_Str""));
  textField.setText(""String_Node_Str"");
  assertTrue(textMatcherEditor.getMatcher().matches(""String_Node_Str""));
  assertTrue(textMatcherEditor.getMatcher().matches(""String_Node_Str""));
  textField.postActionEvent();
  assertFalse(textMatcherEditor.getMatcher().matches(""String_Node_Str""));
  assertTrue(textMatcherEditor.getMatcher().matches(""String_Node_Str""));
}","/** 
 * Test that this thing works when live is turned off.
 */
public void guiTestNonLive(){
  TextComponentMatcherEditor<String> textMatcherEditor=null;
  eventCounter.assertNoEvents(0);
  JTextField textField=new JTextField();
  textMatcherEditor=new TextComponentMatcherEditor<String>(textField,GlazedLists.toStringTextFilterator(),false);
  assertTrue(textMatcherEditor.getMatcher().matches(""String_Node_Str""));
  textField.setText(""String_Node_Str"");
  assertTrue(textMatcherEditor.getMatcher().matches(""String_Node_Str""));
  assertTrue(textMatcherEditor.getMatcher().matches(""String_Node_Str""));
  textField.postActionEvent();
  assertFalse(textMatcherEditor.getMatcher().matches(""String_Node_Str""));
  assertTrue(textMatcherEditor.getMatcher().matches(""String_Node_Str""));
}",0.9896640826873384
32649,"/** 
 * Test that this thing works when the document is changed.
 */
public void guiTestChangeDocument(){
  TextComponentMatcherEditor textMatcherEditor=null;
  eventCounter.assertNoEvents(0);
  JTextField textField=new JTextField();
  textMatcherEditor=new TextComponentMatcherEditor(textField,GlazedLists.toStringTextFilterator(),true);
  assertTrue(textMatcherEditor.getMatcher().matches(""String_Node_Str""));
  textField.setText(""String_Node_Str"");
  assertFalse(textMatcherEditor.getMatcher().matches(""String_Node_Str""));
  assertTrue(textMatcherEditor.getMatcher().matches(""String_Node_Str""));
  textField=new JTextField();
  textMatcherEditor=new TextComponentMatcherEditor(textField.getDocument(),GlazedLists.toStringTextFilterator());
  assertTrue(textMatcherEditor.getMatcher().matches(""String_Node_Str""));
  textField.setText(""String_Node_Str"");
  assertFalse(textMatcherEditor.getMatcher().matches(""String_Node_Str""));
  assertTrue(textMatcherEditor.getMatcher().matches(""String_Node_Str""));
}","/** 
 * Test that this thing works when the document is changed.
 */
public void guiTestChangeDocument(){
  TextComponentMatcherEditor<String> textMatcherEditor=null;
  eventCounter.assertNoEvents(0);
  JTextField textField=new JTextField();
  textMatcherEditor=new TextComponentMatcherEditor<String>(textField,GlazedLists.toStringTextFilterator(),true);
  assertTrue(textMatcherEditor.getMatcher().matches(""String_Node_Str""));
  textField.setText(""String_Node_Str"");
  assertFalse(textMatcherEditor.getMatcher().matches(""String_Node_Str""));
  assertTrue(textMatcherEditor.getMatcher().matches(""String_Node_Str""));
  textField=new JTextField();
  textMatcherEditor=new TextComponentMatcherEditor<String>(textField.getDocument(),GlazedLists.toStringTextFilterator());
  assertTrue(textMatcherEditor.getMatcher().matches(""String_Node_Str""));
  textField.setText(""String_Node_Str"");
  assertFalse(textMatcherEditor.getMatcher().matches(""String_Node_Str""));
  assertTrue(textMatcherEditor.getMatcher().matches(""String_Node_Str""));
}",0.9881889763779528
32650,"/** 
 * {@inheritDoc} 
 */
public List<V> put(Comparable<K> key,List<V> value){
  this.checkKeyValueAgreement(key,value);
  final List<V> removed=this.remove(key);
  this.groupingList.add(value);
  return removed;
}","/** 
 * {@inheritDoc} 
 */
public List<V> put(Comparable<K> key,List<V> value){
  this.checkKeyValueAgreement(key,value);
  final List<V> removed=(List<V>)this.remove(key);
  this.groupingList.add(value);
  return removed;
}",0.979498861047836
32651,"/** 
 * {@inheritDoc} 
 */
public void setSortKeys(List<? extends SortKey> sortKeys){
  if (sortKeys == sortKeysReadOnly)   return;
  this.sortKeys.clear();
  this.sortKeys.addAll(sortKeys);
  List<Comparator> comparators=new ArrayList<Comparator>(this.sortKeys.size());
  for (int k=0; k < this.sortKeys.size(); k++) {
    SortKey sortKey=(SortKey)this.sortKeys.get(k);
    if (sortKey.getSortOrder() == SortOrder.UNSORTED)     continue;
    Comparator comparator=getComparator(sortKey.getColumn());
    if (sortKey.getSortOrder() == SortOrder.DESCENDING)     comparator=GlazedLists.reverseComparator(comparator);
    comparators.add(comparator);
  }
  final Comparator comparator;
  if (comparators.isEmpty()) {
    comparator=null;
  }
 else   if (comparators.size() == 1) {
    comparator=comparators.get(0);
  }
 else {
    comparator=GlazedLists.chainComparators((List)comparators);
  }
  sortedList.getReadWriteLock().writeLock().lock();
  try {
    sortedList.setComparator(comparator);
  }
  finally {
    sortedList.getReadWriteLock().writeLock().unlock();
  }
}","/** 
 * {@inheritDoc} 
 */
public void setSortKeys(List<? extends SortKey> sortKeys){
  if (sortKeys == sortKeysReadOnly)   return;
  if (sortKeys == null)   sortKeys=Collections.emptyList();
  this.sortKeys.clear();
  this.sortKeys.addAll(sortKeys);
  List<Comparator> comparators=new ArrayList<Comparator>(this.sortKeys.size());
  for (int k=0; k < this.sortKeys.size(); k++) {
    SortKey sortKey=(SortKey)this.sortKeys.get(k);
    if (sortKey.getSortOrder() == SortOrder.UNSORTED)     continue;
    Comparator comparator=getComparator(sortKey.getColumn());
    if (sortKey.getSortOrder() == SortOrder.DESCENDING)     comparator=GlazedLists.reverseComparator(comparator);
    comparators.add(comparator);
  }
  final Comparator comparator;
  if (comparators.isEmpty()) {
    comparator=null;
  }
 else   if (comparators.size() == 1) {
    comparator=comparators.get(0);
  }
 else {
    comparator=GlazedLists.chainComparators((List)comparators);
  }
  sortedList.getReadWriteLock().writeLock().lock();
  try {
    sortedList.setComparator(comparator);
  }
  finally {
    sortedList.getReadWriteLock().writeLock().unlock();
  }
}",0.9727767695099818
32652,"public void run(){
  try {
    IssuezillaXMLParser.loadIssues(issues,new FileInputStream(project.getFileName()),project);
  }
 catch (  IOException e) {
    e.printStackTrace();
    return;
  }
}","public void run(){
  try {
    IssuezillaXMLParser.loadIssues(GlazedLists.threadSafeList(issues),new FileInputStream(project.getFileName()),project);
  }
 catch (  IOException e) {
    e.printStackTrace();
    return;
  }
}",0.9043062200956936
32653,"/** 
 * Starts a new atomic change to this list change queue.
 */
public synchronized void beginEvent(boolean allowNestedEvents){
  if (!this.allowNestedEvents) {
    throw new ConcurrentModificationException(""String_Node_Str"");
  }
  this.allowNestedEvents=allowNestedEvents;
  if (allowNestedEvents)   allowContradictingEvents=true;
  if (eventLevel == 0) {
    prepareEvent();
  }
  eventLevel++;
}","/** 
 * Starts a new atomic change to this list change queue.
 */
public synchronized void beginEvent(boolean allowNestedEvents){
  if (!this.allowNestedEvents) {
    throw new ConcurrentModificationException(""String_Node_Str"" + eventThread.getName());
  }
  this.allowNestedEvents=allowNestedEvents;
  if (allowNestedEvents)   allowContradictingEvents=true;
  if (eventLevel == 0) {
    this.eventThread=Thread.currentThread();
    prepareEvent();
  }
  eventLevel++;
}",0.920780711825488
32654,"public void actionPerformed(ActionEvent e){
  target.add(""String_Node_Str"" + (dice.nextInt(100)));
}","public void actionPerformed(ActionEvent e){
  target.add(3,""String_Node_Str"" + (dice.nextInt(100)));
}",0.99009900990099
32655,"public void start(){
  sillyObjects.add(""String_Node_Str"");
  sillyObjects.add(""String_Node_Str"");
  sillyObjects.add(""String_Node_Str"");
  JEventListPanel panel=new JEventListPanel(sillyObjects,new SillyObjectFormat());
  panel.setBorder(BorderFactory.createMatteBorder(5,5,5,5,Color.RED));
  JButton addButton=new JButton(""String_Node_Str"");
  addButton.addActionListener(new AddAction(sillyObjects));
  JFrame frame=new JFrame(""String_Node_Str"");
  frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
  frame.getContentPane().setLayout(new BorderLayout());
  frame.getContentPane().add(panel,BorderLayout.NORTH);
  frame.getContentPane().add(addButton,BorderLayout.SOUTH);
  frame.pack();
  frame.setVisible(true);
}","public void start(){
  sillyObjects.add(""String_Node_Str"");
  sillyObjects.add(""String_Node_Str"");
  sillyObjects.add(""String_Node_Str"");
  JEventListPanel panel=new JEventListPanel(sillyObjects,new SillyObjectFormat());
  panel.setBorder(BorderFactory.createMatteBorder(5,5,5,5,Color.RED));
  panel.setElementColumns(1);
  JButton addButton=new JButton(""String_Node_Str"");
  addButton.addActionListener(new AddAction(sillyObjects));
  JFrame frame=new JFrame(""String_Node_Str"");
  frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
  frame.getContentPane().setLayout(new BorderLayout());
  frame.getContentPane().add(panel,BorderLayout.NORTH);
  frame.getContentPane().add(addButton,BorderLayout.SOUTH);
  frame.pack();
  frame.setVisible(true);
}",0.9798657718120806
32656,"/** 
 * Handle a list element being inserted by adjusting the layout.
 */
public void insertIndex(int index){
  int logicalColumnCountBefore=logicalColumnCount();
  int logicalRowCountBefore=logicalRowCount();
  gridComponents.add(new CellComponents());
  fixCellCount(logicalRowCountBefore,logicalColumnCountBefore);
}","/** 
 * Handle a list element being inserted by adjusting the layout.
 */
public void insertIndex(int index){
  int logicalColumnCountBefore=logicalColumnCount();
  int logicalRowCountBefore=logicalRowCount();
  gridComponents.add(index,new CellComponents());
  fixCellCount(logicalRowCountBefore,logicalColumnCountBefore);
}",0.9906832298136646
32657,"/** 
 * Create a filter list that filters the specified source list, which must contain only Issue objects.
 */
public UsersMatcherEditor(EventList<Issue> source){
  allUsers=new UniqueList<String>(new CollectionList<Issue,String>(source,new IssueUserator()));
}","/** 
 * Create a filter list that filters the specified source list, which must contain only Issue objects.
 */
public UsersMatcherEditor(EventList<Issue> source){
  usersForIssues=new CollectionList<Issue,String>(source,new IssueUserator());
  allUsers=new UniqueList<String>(usersForIssues);
}",0.725314183123878
32658,"public CreationDateMatcherEditor(){
  super(ISSUE_DATE_FILTERATOR);
}","public CreationDateMatcherEditor(EventList<Issue> issues){
  super(ISSUE_DATE_FILTERATOR);
}",0.8571428571428571
32659,"public void actionPerformed(ActionEvent actionEvent){
  filterComponents.remove(this);
}","public void actionPerformed(ActionEvent actionEvent){
  if (actionEvent.getSource() == closeButton) {
    getFilterComponent().dispose();
    filterComponents.remove(this);
  }
 else   if (actionEvent.getSource() == newButton) {
    FilterComponent filterComponentCopy=createFilterComponent(getFilterComponent().getClass());
    int index=filterComponents.indexOf(CloseableFilterComponent.this);
    filterComponents.add(index + 1,new CloseableFilterComponent(filterComponentCopy));
  }
 else   if (actionEvent.getSource() == previousButton) {
    adjustFilterComponent(-1);
  }
 else   if (actionEvent.getSource() == nextButton) {
    adjustFilterComponent(1);
  }
 else {
    throw new IllegalStateException();
  }
}",0.2183622828784119
32660,"public MatcherEditor<E> getMatcherEditor(){
  return filterComponent.getMatcherEditor();
}","public MatcherEditor getMatcherEditor(){
  return filterComponent.getMatcherEditor();
}",0.9830508474576272
32661,"public CloseableFilterComponent(FilterComponent<E> filterComponent){
  this.filterComponent=filterComponent;
  this.closeButton=new IssuesBrowser.IconButton(IssuesBrowser.x_icons);
  this.closeButton.addActionListener(this);
  this.closeButton.setOpaque(false);
  this.headerLabel=new JLabel();
  this.headerLabel.setHorizontalAlignment(JLabel.CENTER);
  this.headerLabel.setFont(headerLabel.getFont().deriveFont(10.0f));
  this.headerLabel.setText(filterComponent.getName());
  this.headerLabel.setForeground(Color.WHITE);
  this.headerPanel=new IssuesBrowser.GradientPanel(IssuesBrowser.GLAZED_LISTS_MEDIUM_LIGHT_BROWN,IssuesBrowser.GLAZED_LISTS_MEDIUM_BROWN,true);
  this.headerPanel.setLayout(new BorderLayout());
  this.headerPanel.add(headerLabel,BorderLayout.CENTER);
  this.headerPanel.add(closeButton,BorderLayout.EAST);
}","public CloseableFilterComponent(FilterComponent filterComponent){
  this.closeButton=new IssuesBrowser.IconButton(IssuesBrowser.x_icons);
  this.closeButton.addActionListener(this);
  this.closeButton.setOpaque(false);
  this.previousButton=new IssuesBrowser.IconButton(IssuesBrowser.left_icons);
  this.previousButton.addActionListener(this);
  this.previousButton.setOpaque(false);
  this.nextButton=new IssuesBrowser.IconButton(IssuesBrowser.right_icons);
  this.nextButton.addActionListener(this);
  this.nextButton.setOpaque(false);
  this.newButton=new IssuesBrowser.IconButton(IssuesBrowser.plus_icons);
  this.newButton.addActionListener(this);
  this.newButton.setOpaque(false);
  this.headerLabel=new JLabel();
  this.headerLabel.setHorizontalAlignment(JLabel.CENTER);
  this.headerLabel.setFont(headerLabel.getFont().deriveFont(10.0f));
  this.headerLabel.setForeground(Color.WHITE);
  this.headerPanel=new IssuesBrowser.GradientPanel(IssuesBrowser.GLAZED_LISTS_MEDIUM_LIGHT_BROWN,IssuesBrowser.GLAZED_LISTS_MEDIUM_BROWN,true);
  this.headerPanel.setLayout(new GridBagLayout());
  this.headerPanel.add(newButton,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
  this.headerPanel.add(previousButton,new GridBagConstraints(1,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
  this.headerPanel.add(headerLabel,new GridBagConstraints(2,0,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
  this.headerPanel.add(nextButton,new GridBagConstraints(3,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
  this.headerPanel.add(closeButton,new GridBagConstraints(4,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
  setFilterComponent(filterComponent);
}",0.5066273932253313
32662,"public MatcherEditor<E> evaluate(CloseableFilterComponent<E> sourceValue){
  return sourceValue.getMatcherEditor();
}","public MatcherEditor<E> evaluate(CloseableFilterComponent sourceValue){
  return sourceValue.getMatcherEditor();
}",0.987012987012987
32663,"public FilterPanel(EventList<Issue> issues){
  this.filterComponents.add(new CloseableFilterComponent<Issue>(new StatusMatcherEditor(issues)));
  this.filterComponents.add(new CloseableFilterComponent<Issue>(new TextFilterComponent()));
  this.filterComponents.add(new CloseableFilterComponent<Issue>(new SwingUsersMatcherEditor(issues)));
  this.filterComponents.add(new CloseableFilterComponent<Issue>(new PriorityMatcherEditor()));
  this.filterComponents.add(new CloseableFilterComponent<Issue>(new CreationDateMatcherEditor()));
  EventList<MatcherEditor<Issue>> matcherEditors=new FunctionList<CloseableFilterComponent<Issue>,MatcherEditor<Issue>>(filterComponents,new CloseableFilterComponentToMatcherEditor<Issue>());
  this.matcherEditor=new CompositeMatcherEditor<Issue>(matcherEditors);
  this.filtersPanel=new JEventListPanel<CloseableFilterComponent<Issue>>(filterComponents,new CloseableFilterComponentPanelFormat<Issue>());
  this.filtersPanel.setBackground(IssuesBrowser.GLAZED_LISTS_LIGHT_BROWN);
  this.filtersScrollPane=new JScrollPane(this.filtersPanel,JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
}","public FilterPanel(EventList<Issue> issues){
  this.issues=issues;
  for (Iterator<Class> i=filterClasses.iterator(); i.hasNext(); ) {
    Class filterComponentClass=i.next();
    FilterComponent filterComponent=createFilterComponent(filterComponentClass);
    this.filterComponents.add(new CloseableFilterComponent(filterComponent));
    break;
  }
  EventList<MatcherEditor<Issue>> matcherEditors=new FunctionList<CloseableFilterComponent,MatcherEditor<Issue>>(filterComponents,new CloseableFilterComponentToMatcherEditor<Issue>());
  this.matcherEditor=new CompositeMatcherEditor<Issue>(matcherEditors);
  this.filtersPanel=new JEventListPanel<CloseableFilterComponent>(filterComponents,new CloseableFilterComponentPanelFormat<Issue>());
  this.filtersPanel.setBackground(IssuesBrowser.GLAZED_LISTS_LIGHT_BROWN);
  this.filtersScrollPane=new JScrollPane(this.filtersPanel,JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
}",0.6726584673604541
32664,"private static ImageIcon[] loadIcons(String name){
  String[] iconStates=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  ImageIcon[] icons=new ImageIcon[3];
  for (int i=0; i < icons.length; i++) {
    for (int s=0; s < iconStates.length; s++) {
      String state=iconStates[s];
      icons[s]=loadIcon(""String_Node_Str"" + name + ""String_Node_Str""+ state+ ""String_Node_Str"");
    }
  }
  return icons;
}","private static ImageIcon[] loadIcons(String name){
  ImageIcon icon=loadIcon(""String_Node_Str"" + name + ""String_Node_Str"");
  return new ImageIcon[]{icon,icon,icon};
}",0.4713804713804714
32665,"public PriorityMatcherEditor(){
  slider=new JSlider(new DefaultBoundedRangeModel(0,0,0,100));
  slider.addChangeListener(this);
  rangeMatcherEditor=new RangeMatcherEditor<Integer,Issue>((Filterator)GlazedLists.filterator(new String[]{""String_Node_Str""}));
  slider.setOpaque(false);
  slider.setSnapToTicks(true);
  slider.setPaintLabels(true);
  slider.setPaintTicks(true);
  slider.setMajorTickSpacing(25);
  slider.setForeground(Color.BLACK);
  final Hashtable<Integer,JLabel> prioritySliderLabels=new Hashtable<Integer,JLabel>();
  prioritySliderLabels.put(MIN_PRIORITY,new JLabel(""String_Node_Str""));
  prioritySliderLabels.put(MAX_PRIORITY,new JLabel(""String_Node_Str""));
  slider.setLabelTable(prioritySliderLabels);
}","public PriorityMatcherEditor(EventList<Issue> issues){
  slider=new JSlider(new DefaultBoundedRangeModel(0,0,0,100));
  slider.addChangeListener(this);
  rangeMatcherEditor=new RangeMatcherEditor<Integer,Issue>((Filterator)GlazedLists.filterator(new String[]{""String_Node_Str""}));
  slider.setOpaque(false);
  slider.setSnapToTicks(true);
  slider.setPaintLabels(true);
  slider.setPaintTicks(true);
  slider.setMajorTickSpacing(25);
  slider.setForeground(Color.BLACK);
  final Hashtable<Integer,JLabel> prioritySliderLabels=new Hashtable<Integer,JLabel>();
  prioritySliderLabels.put(MIN_PRIORITY,new JLabel(""String_Node_Str""));
  prioritySliderLabels.put(MAX_PRIORITY,new JLabel(""String_Node_Str""));
  slider.setLabelTable(prioritySliderLabels);
}",0.984427894380501
32666,"public void listChanged(ListEvent<List<Issue>> listChanges){
  while (listChanges.next()) {
    final int type=listChanges.getType();
    final int index=listChanges.getIndex();
    final String status;
    final int count;
    if (type == ListEvent.INSERT) {
      List issuesOfThisStatus=(List)issuesByStatus.get(index);
      status=((Issue)issuesOfThisStatus.get(0)).getStatus();
      statuses.add(index,status);
      count=issuesOfThisStatus.size();
    }
 else     if (type == ListEvent.UPDATE) {
      List issuesOfThisStatus=(List)issuesByStatus.get(index);
      status=(String)statuses.get(index);
      count=issuesOfThisStatus.size();
    }
 else     if (type == ListEvent.DELETE) {
      status=statuses.remove(index);
      count=0;
    }
 else {
      throw new IllegalStateException();
    }
    final JCheckBox checkBox=statusCheckBoxes.get(status);
    checkBox.setText(checkboxFormat.format(new Object[]{checkBox.getName(),new Integer(count)}));
  }
}","public void listChanged(ListEvent<List<Issue>> listChanges){
  while (listChanges.next()) {
    final int type=listChanges.getType();
    final int index=listChanges.getIndex();
    final String status;
    final int count;
    if (type == ListEvent.INSERT) {
      List issuesOfThisStatus=(List)issuesByStatusSwingThread.get(index);
      status=((Issue)issuesOfThisStatus.get(0)).getStatus();
      statuses.add(index,status);
      count=issuesOfThisStatus.size();
    }
 else     if (type == ListEvent.UPDATE) {
      List issuesOfThisStatus=(List)issuesByStatusSwingThread.get(index);
      status=(String)statuses.get(index);
      count=issuesOfThisStatus.size();
    }
 else     if (type == ListEvent.DELETE) {
      status=statuses.remove(index);
      count=0;
    }
 else {
      throw new IllegalStateException();
    }
    final JCheckBox checkBox=statusCheckBoxes.get(status);
    checkBox.setText(checkboxFormat.format(new Object[]{checkBox.getName(),new Integer(count)}));
  }
}",0.9888097660223804
32667,"public StatusMatcherEditor(EventList<Issue> issues){
  this.issuesByStatus=GlazedListsSwing.swingThreadProxyList(new GroupingList<Issue>(issues,new IssueStatusComparator()));
  this.issuesByStatus.addListEventListener(this);
  this.statusCheckBoxes.put(""String_Node_Str"",buildCheckBox(""String_Node_Str""));
  this.statusCheckBoxes.put(""String_Node_Str"",buildCheckBox(""String_Node_Str""));
  this.statusCheckBoxes.put(""String_Node_Str"",buildCheckBox(""String_Node_Str""));
  this.statusCheckBoxes.put(""String_Node_Str"",buildCheckBox(""String_Node_Str""));
  this.statusCheckBoxes.put(""String_Node_Str"",buildCheckBox(""String_Node_Str""));
  this.statusCheckBoxes.put(""String_Node_Str"",buildCheckBox(""String_Node_Str""));
  this.statusCheckBoxes.put(""String_Node_Str"",buildCheckBox(""String_Node_Str""));
  this.checkBoxPanel.setOpaque(false);
  for (Iterator<JCheckBox> iter=statusCheckBoxes.values().iterator(); iter.hasNext(); ) {
    JCheckBox checkBox=iter.next();
    checkBox.addActionListener(this);
    this.checkBoxPanel.add(checkBox);
  }
}","public StatusMatcherEditor(EventList<Issue> issues){
  issuesByStatus=new GroupingList<Issue>(issues,new IssueStatusComparator());
  this.issuesByStatusSwingThread=GlazedListsSwing.swingThreadProxyList(issuesByStatus);
  this.issuesByStatusSwingThread.addListEventListener(this);
  this.statusCheckBoxes.put(""String_Node_Str"",buildCheckBox(""String_Node_Str""));
  this.statusCheckBoxes.put(""String_Node_Str"",buildCheckBox(""String_Node_Str""));
  this.statusCheckBoxes.put(""String_Node_Str"",buildCheckBox(""String_Node_Str""));
  this.statusCheckBoxes.put(""String_Node_Str"",buildCheckBox(""String_Node_Str""));
  this.statusCheckBoxes.put(""String_Node_Str"",buildCheckBox(""String_Node_Str""));
  this.statusCheckBoxes.put(""String_Node_Str"",buildCheckBox(""String_Node_Str""));
  this.statusCheckBoxes.put(""String_Node_Str"",buildCheckBox(""String_Node_Str""));
  this.checkBoxPanel.setOpaque(false);
  for (Iterator<JCheckBox> iter=statusCheckBoxes.values().iterator(); iter.hasNext(); ) {
    JCheckBox checkBox=iter.next();
    checkBox.addActionListener(this);
    this.checkBoxPanel.add(checkBox);
  }
}",0.8925387142186767
32668,"/** 
 * Returns the number of values associated with the given <code>rowKey</code> between the given <code>start</code> and <code>end</code> values.
 */
public int getCount(R rowKey,C start,C end){
  final TreePair treePair=getTreePair(rowKey);
  if (treePair == null)   throw new UnknownKeyException(""String_Node_Str"" + rowKey);
  return new Integer(treePair.getCount(start,end));
}","/** 
 * Returns the number of values associated with the given <code>rowKey</code> between the given <code>start</code> and <code>end</code> values.
 */
public int getCount(R rowKey,C start,C end){
  final TreePair<C> treePair=getTreePair(rowKey);
  if (treePair == null)   throw new UnknownKeyException(""String_Node_Str"" + rowKey);
  return treePair.getCount(start,end);
}",0.9788359788359788
32669,"/** 
 * Sorts the blocks of the specified list of changes. This ensures that the user iterating the list of change blocks can view changes in increasing order. This ensures that indices will not be shifted. <p>This performs a bubble sort, swapping adjacent change blocks if they should be swapped. The bubble sort is used instead of a more efficient sort because it is necessary to adjust offsets when swapping and therefore it is preferred to only swap adjacent elements. Bubble sort is a sort that only swaps adjacent elements.
 * @param allowContradictingEvents whether a pair of contradicting events shallbe allowed. This would typically be an insert that is wiped away with a delete, an update that is wiped away with a delete, or an insert that is later updated.
 */
static void sortListEventBlocks(List<ListEventBlock> changes,boolean allowContradictingEvents){
  for (int i=0; i < changes.size() - 1; i++) {
    if (i < 0)     i=0;
    for (int j=i; j >= 0; ) {
      ListEventBlock first=changes.get(j);
      ListEventBlock second=changes.get(j + 1);
      if (blocksContradict(first,second)) {
        if (!allowContradictingEvents) {
          throw new IllegalStateException(""String_Node_Str"" + first + ""String_Node_Str""+ second+ ""String_Node_Str"");
        }
        List<ListEventBlock> contradictingPair=changes.subList(j,j + 2);
        simplifyContradiction(contradictingPair);
        if (contradictingPair.size() == 0) {
          i-=2;
          break;
        }
 else         if (contradictingPair.size() == 1) {
          i-=1;
          j--;
        }
      }
 else       if (requiresSplit(first,second)) {
        ListEventBlock third=split(first,second);
        changes.add(j + 2,third);
        j++;
      }
 else       if (canBeCombined(first,second)) {
        combine(first,second);
        changes.remove(j + 1);
        i--;
        j--;
      }
 else       if (requiresSwap(first,second)) {
        shift(first,second);
        changes.set(j,second);
        changes.set(j + 1,first);
        j--;
      }
 else {
        break;
      }
    }
  }
}","/** 
 * Sorts the blocks of the specified list of changes. This ensures that the user iterating the list of change blocks can view changes in increasing order. This ensures that indices will not be shifted. <p>This performs a bubble sort, swapping adjacent change blocks if they should be swapped. The bubble sort is used instead of a more efficient sort because it is necessary to adjust offsets when swapping and therefore it is preferred to only swap adjacent elements. Bubble sort is a sort that only swaps adjacent elements.
 * @param allowContradictingEvents whether a pair of contradicting events shallbe allowed. This would typically be an insert that is wiped away with a delete, an update that is wiped away with a delete, or an insert that is later updated.
 */
static void sortListEventBlocks(List<ListEventBlock> changes,boolean allowContradictingEvents){
  for (int i=0; i < changes.size() - 1; i++) {
    if (i < 0)     i=0;
    for (int j=i; j >= 0; ) {
      ListEventBlock first=changes.get(j);
      ListEventBlock second=changes.get(j + 1);
      if (blocksContradict(first,second)) {
        if (!allowContradictingEvents) {
          throw new IllegalStateException(""String_Node_Str"" + first + ""String_Node_Str""+ second+ ""String_Node_Str"");
        }
        List<ListEventBlock> contradictingPair=changes.subList(j,j + 2);
        simplifyContradiction(contradictingPair);
        if (contradictingPair.size() == 0) {
          i-=2;
          break;
        }
 else         if (contradictingPair.size() == 1) {
          i-=1;
          j--;
        }
 else         if (contradictingPair.size() == 2) {
          j--;
        }
      }
 else       if (requiresSplit(first,second)) {
        ListEventBlock third=split(first,second);
        changes.add(j + 2,third);
        j++;
      }
 else       if (canBeCombined(first,second)) {
        combine(first,second);
        changes.remove(j + 1);
        i--;
        j--;
      }
 else       if (requiresSwap(first,second)) {
        shift(first,second);
        changes.set(j,second);
        changes.set(j + 1,first);
        j--;
      }
 else {
        break;
      }
    }
  }
}",0.9820754716981132
32670,"/** 
 * Sorts the blocks of the specified list of changes. This ensures that the user iterating the list of change blocks can view changes in increasing order. This ensures that indices will not be shifted. <p>This performs a bubble sort, swapping adjacent change blocks if they should be swapped. The bubble sort is used instead of a more efficient sort because it is necessary to adjust offsets when swapping and therefore it is preferred to only swap adjacent elements. Bubble sort is a sort that only swaps adjacent elements.
 * @param allowContradictingEvents whether a pair of contradicting events shallbe allowed. This would typically be an insert that is wiped away with a delete, an update that is wiped away with a delete, or an insert that is later updated.
 */
static void sortListEventBlocks(List<ListEventBlock> changes,boolean allowContradictingEvents){
  for (int i=0; i < changes.size() - 1; i++) {
    if (i < 0)     i=0;
    for (int j=i; j >= 0; ) {
      ListEventBlock first=changes.get(j);
      ListEventBlock second=changes.get(j + 1);
      if (blocksContradict(first,second)) {
        if (!allowContradictingEvents) {
          throw new IllegalStateException(""String_Node_Str"" + first + ""String_Node_Str""+ second+ ""String_Node_Str"");
        }
        List<ListEventBlock> contradictingPair=changes.subList(j,j + 2);
        simplifyContradiction(contradictingPair);
        if (contradictingPair.size() == 0) {
          i-=2;
          break;
        }
 else         if (contradictingPair.size() == 1) {
          i-=1;
          j--;
        }
 else         if (contradictingPair.size() == 2) {
          j--;
        }
      }
 else       if (requiresSplit(first,second)) {
        ListEventBlock third=split(first,second);
        changes.add(j + 2,third);
        j++;
      }
 else       if (canBeCombined(first,second)) {
        combine(first,second);
        changes.remove(j + 1);
        i--;
        j--;
      }
 else       if (requiresSwap(first,second)) {
        shift(first,second);
        changes.set(j,second);
        changes.set(j + 1,first);
        j--;
      }
 else {
        break;
      }
    }
  }
}","/** 
 * Sorts the blocks of the specified list of changes. This ensures that the user iterating the list of change blocks can view changes in increasing order. This ensures that indices will not be shifted. <p>This performs a bubble sort, swapping adjacent change blocks if they should be swapped. The bubble sort is used instead of a more efficient sort because it is necessary to adjust offsets when swapping and therefore it is preferred to only swap adjacent elements. Bubble sort is a sort that only swaps adjacent elements.
 * @param allowContradictingEvents whether a pair of contradicting events shallbe allowed. This would typically be an insert that is wiped away with a delete, an update that is wiped away with a delete, or an insert that is later updated.
 */
static void sortListEventBlocks(List<ListEventBlock> changes,boolean allowContradictingEvents){
  for (int i=0; i < changes.size() - 1; i++) {
    if (i < 0)     i=0;
    for (int j=i; j >= 0; ) {
      ListEventBlock first=changes.get(j);
      ListEventBlock second=changes.get(j + 1);
      if (blocksContradict(first,second)) {
        if (!allowContradictingEvents) {
          throw new IllegalStateException(""String_Node_Str"" + first + ""String_Node_Str""+ second+ ""String_Node_Str"");
        }
        List<ListEventBlock> contradictingPair=changes.subList(j,j + 2);
        simplifyContradiction(contradictingPair);
        if (contradictingPair.size() == 0) {
          i-=2;
          break;
        }
 else         if (contradictingPair.size() == 1) {
          i-=1;
          j--;
        }
 else         if (contradictingPair.size() == 2) {
          i-=1;
          j--;
        }
      }
 else       if (requiresSplit(first,second)) {
        ListEventBlock third=split(first,second);
        changes.add(j + 2,third);
        j++;
      }
 else       if (canBeCombined(first,second)) {
        combine(first,second);
        changes.remove(j + 1);
        i--;
        j--;
      }
 else       if (requiresSwap(first,second)) {
        shift(first,second);
        changes.set(j,second);
        changes.set(j + 1,first);
        j--;
      }
 else {
        break;
      }
    }
  }
}",0.9963065558633426
32671,"/** 
 * The list table is not editable. For an editable list table, use the WritableListTable instead.
 */
public void setValueAt(Object editedValue,int row,int column){
  if (tableFormat instanceof WritableTableFormat) {
    swingThreadSource.getReadWriteLock().writeLock().lock();
    try {
      final WritableTableFormat<E> writableTableFormat=(WritableTableFormat<E>)tableFormat;
      final E baseObject=swingThreadSource.get(row);
      final E updatedObject=writableTableFormat.setColumnValue(baseObject,editedValue,column);
      if (updatedObject != null) {
        final boolean baseObjectHasNotMoved=row < this.getRowCount() && swingThreadSource.get(row) == updatedObject;
        if (baseObjectHasNotMoved)         swingThreadSource.set(row,updatedObject);
      }
    }
  finally {
      swingThreadSource.getReadWriteLock().writeLock().unlock();
    }
  }
 else {
    throw new UnsupportedOperationException(""String_Node_Str"");
  }
}","/** 
 * The list table is not editable. For an editable list table, use the WritableListTable instead.
 */
public void setValueAt(Object editedValue,int row,int column){
  if (tableFormat instanceof WritableTableFormat) {
    swingThreadSource.getReadWriteLock().writeLock().lock();
    try {
      final WritableTableFormat<E> writableTableFormat=(WritableTableFormat<E>)tableFormat;
      final E baseObject=swingThreadSource.get(row);
      final E updatedObject=writableTableFormat.setColumnValue(baseObject,editedValue,column);
      if (updatedObject != null) {
        final boolean baseObjectHasNotMoved=row < this.getRowCount() && swingThreadSource.get(row) == baseObject;
        if (baseObjectHasNotMoved)         swingThreadSource.set(row,updatedObject);
      }
    }
  finally {
      swingThreadSource.getReadWriteLock().writeLock().unlock();
    }
  }
 else {
    throw new UnsupportedOperationException(""String_Node_Str"");
  }
}",0.99418911780243
32672,"/** 
 * Creates a new ListEventAssembler that tracks changes for the specified list.
 */
public ListEventAssembler(EventList<E> sourceList,ListEventPublisher publisher){
  if (""String_Node_Str"".equalsIgnoreCase(System.getProperty(""String_Node_Str""))) {
    delegate=new ListDeltasAssembler<E>(sourceList,publisher);
  }
 else {
    delegate=new ListEventBlocksAssembler<E>(sourceList,publisher);
  }
}","/** 
 * Creates a new ListEventAssembler that tracks changes for the specified list.
 */
public ListEventAssembler(EventList<E> sourceList,ListEventPublisher publisher){
  delegate=new ListEventBlocksAssembler<E>(sourceList,publisher);
}",0.6990595611285266
32673,"public IssueSeparatorTableCell(SeparatorList separatorList){
  this.separatorList=separatorList;
  this.nameLabel.setFont(nameLabel.getFont().deriveFont(10.0f));
  this.nameLabel.setBorder(BorderFactory.createEmptyBorder(0,5,0,5));
  this.countLabel.setFont(countLabel.getFont().deriveFont(10.0f));
  this.countLabel.setBorder(BorderFactory.createEmptyBorder(0,5,0,5));
  this.expandButton.setOpaque(false);
  this.expandButton.addActionListener(this);
  this.panel.setLayout(new BorderLayout());
  this.panel.add(expandButton,BorderLayout.WEST);
  this.panel.add(nameLabel,BorderLayout.CENTER);
  this.panel.add(countLabel,BorderLayout.EAST);
}","public IssueSeparatorTableCell(SeparatorList separatorList){
  this.separatorList=separatorList;
  this.nameLabel.setFont(nameLabel.getFont().deriveFont(10.0f));
  this.nameLabel.setBorder(BorderFactory.createEmptyBorder(0,5,0,5));
  this.countLabel.setFont(countLabel.getFont().deriveFont(10.0f));
  this.countLabel.setBorder(BorderFactory.createEmptyBorder(0,5,0,5));
  this.expandButton.addActionListener(this);
  this.panel.setBackground(GLAZED_LISTS_LIGHT_BROWN);
  this.panel.add(expandButton,BorderLayout.WEST);
  this.panel.add(nameLabel,BorderLayout.CENTER);
  this.panel.add(countLabel,BorderLayout.EAST);
}",0.8589540412044374
32674,"/** 
 * When started via a main method, this creates a standalone issues browser.
 */
public static void main(String[] args){
  IssuesBrowser browser=new IssuesBrowser();
  browser.setStartupArgs(args);
  SwingUtilities.invokeLater(browser);
}","/** 
 * When started via a main method, this creates a standalone issues browser.
 */
public static void main(final String[] args){
  SwingUtilities.invokeLater(new Runnable(){
    public void run(){
      try {
        UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
      }
 catch (      Exception e) {
      }
      final IssuesBrowser browser=new IssuesBrowser();
      browser.setStartupArgs(args);
      browser.run();
    }
  }
);
}",0.5945945945945946
32675,"public IconButton(Icon[] icons){
  this.icons=icons;
  super.setBorder(BorderFactory.createEmptyBorder());
  setState(UP);
  addMouseListener(this);
}","public IconButton(Icon[] icons){
  this.icons=icons;
  super.setBorder(null);
  setState(UP);
  setContentAreaFilled(false);
  addMouseListener(this);
}",0.7748344370860927
32676,"/** 
 * {@inheritDoc} 
 */
public void listChanged(ListEvent<E> listChanges){
  if (listChanges.isReordering()) {
    int[] reorderMap=listChanges.getReorderMap();
    IndexedTreeNode[] sortedNodes=new IndexedTreeNode[sorted.size()];
    int index=0;
    for (IndexedTreeIterator<IndexedTreeNode> i=unsorted.iterator(0); i.hasNext(); index++) {
      IndexedTreeNode<IndexedTreeNode> unsortedNode=i.next();
      sortedNodes[index]=unsortedNode.getValue();
    }
    index=0;
    for (IndexedTreeIterator<IndexedTreeNode> i=unsorted.iterator(0); i.hasNext(); index++) {
      IndexedTreeNode<IndexedTreeNode> unsortedNode=i.next();
      unsortedNode.setValue(sortedNodes[reorderMap[index]]);
      sortedNodes[reorderMap[index]].setValue(unsortedNode);
    }
    return;
  }
  updates.beginEvent();
  LinkedList<IndexedTreeNode> insertNodes=new LinkedList<IndexedTreeNode>();
  List<IndexedTreeNode<IndexedTreeNode>> updateNodes=new ArrayList<IndexedTreeNode<IndexedTreeNode>>();
  while (listChanges.next()) {
    int unsortedIndex=listChanges.getIndex();
    int changeType=listChanges.getType();
    if (changeType == ListEvent.INSERT) {
      IndexedTreeNode<IndexedTreeNode> unsortedNode=unsorted.addByNode(unsortedIndex,IndexedTreeNode.EMPTY_NODE);
      insertNodes.addLast(unsortedNode);
    }
 else     if (changeType == ListEvent.UPDATE) {
      IndexedTreeNode<IndexedTreeNode> unsortedNode=unsorted.getNode(unsortedIndex);
      IndexedTreeNode sortedNode=unsortedNode.getValue();
      sortedNode.setSorted(false);
      updateNodes.add(sortedNode);
    }
 else     if (changeType == ListEvent.DELETE) {
      IndexedTreeNode<IndexedTreeNode> unsortedNode=unsorted.getNode(unsortedIndex);
      unsortedNode.removeFromTree(unsorted);
      int deleteSortedIndex=deleteByUnsortedNode(unsortedNode);
      updates.addDelete(deleteSortedIndex);
    }
  }
  for (Iterator<IndexedTreeNode<IndexedTreeNode>> i=updateNodes.iterator(); i.hasNext(); ) {
    IndexedTreeNode<IndexedTreeNode> sortedNode=i.next();
    int originalIndex=sortedNode.getIndex();
    if (isNodeInSortedOrder(sortedNode)) {
      sortedNode.setSorted(true);
      updates.addUpdate(originalIndex);
    }
 else     if (mode == AVOID_MOVING_ELEMENTS) {
      updates.addUpdate(originalIndex);
    }
 else {
      sortedNode.removeFromTree(sorted);
      updates.addDelete(originalIndex);
      int insertedIndex=insertByUnsortedNode(sortedNode.getValue());
      updates.addInsert(insertedIndex);
    }
  }
  while (!insertNodes.isEmpty()) {
    IndexedTreeNode insertNode=insertNodes.removeFirst();
    int insertedIndex=insertByUnsortedNode(insertNode);
    updates.addInsert(insertedIndex);
  }
  updates.commitEvent();
}","/** 
 * {@inheritDoc} 
 */
public void listChanged(ListEvent<E> listChanges){
  if (listChanges.isReordering()) {
    int[] sourceReorder=listChanges.getReorderMap();
    int[] previousIndexToSortedIndex=new int[sorted.size()];
    int index=0;
    for (IndexedTreeIterator<IndexedTreeNode> i=sorted.iterator(0); i.hasNext(); index++) {
      IndexedTreeNode<IndexedTreeNode> sortedNode=i.next();
      int unsortedIndex=sortedNode.getValue().getIndex();
      previousIndexToSortedIndex[unsortedIndex]=index;
    }
    int[] newIndexToSortedIndex=new int[sorted.size()];
    for (int i=0; i < previousIndexToSortedIndex.length; i++) {
      newIndexToSortedIndex[i]=previousIndexToSortedIndex[sourceReorder[i]];
    }
    IndexedTreeNode<IndexedTreeNode>[] unsortedNodes=new IndexedTreeNode[unsorted.size()];
    index=0;
    for (IndexedTreeIterator<IndexedTreeNode> i=unsorted.iterator(0); i.hasNext(); index++) {
      IndexedTreeNode<IndexedTreeNode> unsortedNode=i.next();
      unsortedNodes[index]=unsortedNode;
    }
    Arrays.sort(unsortedNodes,sorted.getComparator());
    int[] reorderMap=new int[sorted.size()];
    boolean indexChanged=false;
    index=0;
    for (IndexedTreeIterator<IndexedTreeNode> i=sorted.iterator(0); i.hasNext(); index++) {
      IndexedTreeNode<IndexedTreeNode> sortedNode=i.next();
      IndexedTreeNode<IndexedTreeNode> unsortedNode=unsortedNodes[index];
      sortedNode.setValue(unsortedNode);
      unsortedNode.setValue(sortedNode);
      int unsortedIndex=unsortedNode.getIndex();
      reorderMap[index]=newIndexToSortedIndex[unsortedIndex];
      indexChanged=indexChanged || (index != reorderMap[index]);
    }
    if (indexChanged) {
      updates.beginEvent();
      updates.reorder(reorderMap);
      updates.commitEvent();
    }
    return;
  }
  updates.beginEvent();
  LinkedList<IndexedTreeNode> insertNodes=new LinkedList<IndexedTreeNode>();
  List<IndexedTreeNode<IndexedTreeNode>> updateNodes=new ArrayList<IndexedTreeNode<IndexedTreeNode>>();
  while (listChanges.next()) {
    int unsortedIndex=listChanges.getIndex();
    int changeType=listChanges.getType();
    if (changeType == ListEvent.INSERT) {
      IndexedTreeNode<IndexedTreeNode> unsortedNode=unsorted.addByNode(unsortedIndex,IndexedTreeNode.EMPTY_NODE);
      insertNodes.addLast(unsortedNode);
    }
 else     if (changeType == ListEvent.UPDATE) {
      IndexedTreeNode<IndexedTreeNode> unsortedNode=unsorted.getNode(unsortedIndex);
      IndexedTreeNode sortedNode=unsortedNode.getValue();
      sortedNode.setSorted(false);
      updateNodes.add(sortedNode);
    }
 else     if (changeType == ListEvent.DELETE) {
      IndexedTreeNode<IndexedTreeNode> unsortedNode=unsorted.getNode(unsortedIndex);
      unsortedNode.removeFromTree(unsorted);
      int deleteSortedIndex=deleteByUnsortedNode(unsortedNode);
      updates.addDelete(deleteSortedIndex);
    }
  }
  for (Iterator<IndexedTreeNode<IndexedTreeNode>> i=updateNodes.iterator(); i.hasNext(); ) {
    IndexedTreeNode<IndexedTreeNode> sortedNode=i.next();
    int originalIndex=sortedNode.getIndex();
    if (isNodeInSortedOrder(sortedNode)) {
      sortedNode.setSorted(true);
      updates.addUpdate(originalIndex);
    }
 else     if (mode == AVOID_MOVING_ELEMENTS) {
      updates.addUpdate(originalIndex);
    }
 else {
      sortedNode.removeFromTree(sorted);
      updates.addDelete(originalIndex);
      int insertedIndex=insertByUnsortedNode(sortedNode.getValue());
      updates.addInsert(insertedIndex);
    }
  }
  while (!insertNodes.isEmpty()) {
    IndexedTreeNode insertNode=insertNodes.removeFirst();
    int insertedIndex=insertByUnsortedNode(insertNode);
    updates.addInsert(insertedIndex);
  }
  updates.commitEvent();
}",0.7438170788614092
32677,"/** 
 * Print the tree by its contents
 */
public String toString(){
  if (root == null)   return ""String_Node_Str"";
  return root.toString();
}","/** 
 * Print the tree by its contents
 */
public String toString(){
  StringBuffer result=new StringBuffer();
  for (IndexedTreeIterator i=iterator(0); i.hasNext(); ) {
    if (result.length() > 0)     result.append(""String_Node_Str"");
    result.append(i.next());
  }
  return result.toString();
}",0.4108352144469526
32678,"/** 
 * Prints the tree by its contents.
 */
public String toString(){
  String leftString=left == null ? ""String_Node_Str"" : left.toString();
  String valueString=value instanceof IndexedTreeNode ? ""String_Node_Str"" + ((IndexedTreeNode)value).getIndex() : value.toString();
  String rightString=right == null ? ""String_Node_Str"" : right.toString();
  return ""String_Node_Str"" + leftString + ""String_Node_Str""+ valueString+ ""String_Node_Str""+ rightString+ ""String_Node_Str"";
}","/** 
 * Prints the tree by its contents.
 */
public String toString(){
  String valueString=value instanceof IndexedTreeNode ? ""String_Node_Str"" + ((IndexedTreeNode)value).getIndex() : value.toString();
  int index=getIndex();
  return ""String_Node_Str"" + index + ""String_Node_Str""+ valueString;
}",0.2354463130659767
32679,"/** 
 * Convert an index from view to source.
 */
protected int getSourceIndex(int mutationIndex){
  for (int i=0; i < source.size(); i++) {
    if (fromSourceIndex(i) == mutationIndex) {
      return i;
    }
  }
  return -1;
}","/** 
 * Convert an index from view to source.
 * @return the index into the source list if this corresponds to aregular element. If this corresponds to a separator, the index of that separator will be returned.
 */
protected int getSourceIndex(int transformedIndex){
  throw new UnsupportedOperationException();
}",0.3622920517560073
32680,"public void groupChanged(int index,int groupIndex,int groupChangeType,boolean primary,int elementChangeType){
  if (primary) {
    updates.addChange(elementChangeType,fromSourceIndex(index));
  }
  updates.addChange(groupChangeType,fromGroupIndex(groupIndex));
}","public void groupChanged(int index,int groupIndex,int groupChangeType,boolean primary,int elementChangeType){
  if (groupChangeType == ListEvent.DELETE) {
    if (primary) {
      int outputIndex=separatorsBarcode.getIndex(index,REGULAR);
      if (elementChangeType == ListEvent.UPDATE) {
        updates.addChange(ListEvent.UPDATE,outputIndex);
      }
 else       if (elementChangeType == ListEvent.DELETE) {
        separatorsBarcode.remove(outputIndex,1);
        updates.addChange(ListEvent.DELETE,outputIndex);
      }
 else {
        throw new IllegalStateException();
      }
    }
    int separatorIndex=separatorsBarcode.getIndex(groupIndex,SEPARATOR);
    separatorsBarcode.remove(separatorIndex,1);
    updates.addChange(ListEvent.DELETE,separatorIndex);
  }
 else   if (groupChangeType == ListEvent.UPDATE) {
    throw new UnsupportedOperationException();
  }
 else   if (groupChangeType == ListEvent.INSERT) {
    throw new UnsupportedOperationException();
  }
}",0.2970137207425343
32681,"private SeparatorList(SortedList<E> source,Comparator comparator,Void dummyParameter){
  super(source);
  GrouperClient grouperClient=new GrouperClient();
  this.grouper=new Grouper<E>(source,grouperClient);
  source.addListEventListener(this);
}","private SeparatorList(SortedList<E> source,Comparator comparator,Void dummyParameter){
  super(source);
  GrouperClient grouperClient=new GrouperClient();
  this.grouper=new Grouper<E>(source,grouperClient);
  separatorsBarcode.add(0,REGULAR,source.size());
  for (BarcodeIterator i=grouper.getBarcode().iterator(); i.hasNextColour(Grouper.UNIQUE); ) {
    i.nextColour(Grouper.UNIQUE);
    separatorsBarcode.add(i.getIndex(),SEPARATOR,1);
  }
  source.addListEventListener(this);
}",0.6510989010989011
32682,"private void insertLogicalRow(int index){
  int baseRow=logicalToLayoutRow(index);
  if (gridComponents.size() > 1 && gapRow != null) {
    insertRow(baseRow,gapRow);
    baseRow+=1;
  }
  for (int r=0; r < rowSpecs.length; r++) {
    insertRow(baseRow + r,rowSpecs[r]);
  }
}","private void insertLogicalRow(int index){
  int baseRow=logicalToLayoutRow(index);
  if (index != 0 && gapRow != null) {
    insertRow(baseRow,gapRow);
    baseRow+=1;
  }
  for (int r=0; r < rowSpecs.length; r++) {
    insertRow(baseRow + r,rowSpecs[r]);
  }
}",0.9348230912476724
32683,"private void removeLogicalColumn(int index){
  int baseColumn=logicalToLayoutColumn(index);
  if (gridComponents.size() > 1 && gapColumn != null) {
    formLayout.removeColumn(baseColumn + 1);
  }
  for (int c=0; c < columnSpecs.length; c++) {
    formLayout.removeColumn(baseColumn + 1);
  }
}","private void removeLogicalColumn(int index){
  int baseColumn=logicalToLayoutColumn(index);
  if (index != 0 && gapColumn != null) {
    formLayout.removeColumn(baseColumn + 1);
  }
  for (int c=0; c < columnSpecs.length; c++) {
    formLayout.removeColumn(baseColumn + 1);
  }
}",0.9389179755671904
32684,"public void removeIndex(int index){
  int logicalColumnCountBefore=logicalColumnCount();
  int logicalRowCountBefore=logicalRowCount();
  gridComponents.remove(index);
  int logicalColumnCountAfter=logicalColumnCount();
  int logicalRowCountAfter=logicalRowCount();
  if (logicalRowCountAfter > logicalRowCountBefore) {
    removeLogicalRow(logicalRowCountAfter);
  }
  if (logicalColumnCountAfter > logicalColumnCountBefore) {
    removeLogicalColumn(logicalColumnCountAfter);
  }
  reassignConstraints();
}","public void removeIndex(int index){
  int logicalColumnCountBefore=logicalColumnCount();
  int logicalRowCountBefore=logicalRowCount();
  gridComponents.remove(index);
  reassignConstraints();
  int logicalColumnCountAfter=logicalColumnCount();
  int logicalRowCountAfter=logicalRowCount();
  if (logicalRowCountAfter < logicalRowCountBefore) {
    removeLogicalRow(logicalRowCountAfter);
  }
  if (logicalColumnCountAfter < logicalColumnCountBefore) {
    removeLogicalColumn(logicalColumnCountAfter);
  }
}",0.3818897637795275
32685,"private void removeLogicalRow(int index){
  int baseRow=logicalToLayoutRow(index);
  if (gridComponents.size() > 1 && gapRow != null) {
    formLayout.removeRow(baseRow + 1);
  }
  for (int r=0; r < rowSpecs.length; r++) {
    formLayout.removeRow(baseRow + 1);
  }
}","private void removeLogicalRow(int index){
  int baseRow=logicalToLayoutRow(index);
  if (index != 0 && gapRow != null) {
    formLayout.removeRow(baseRow + 1);
  }
  for (int r=0; r < rowSpecs.length; r++) {
    formLayout.removeRow(baseRow + 1);
  }
}",0.9325626204238922
32686,"private void insertLogicalColumn(int index){
  int baseColumn=logicalToLayoutColumn(index);
  if (gridComponents.size() > 1 && gapColumn != null) {
    insertColumn(baseColumn,gapColumn);
    baseColumn+=1;
  }
  for (int c=0; c < columnSpecs.length; c++) {
    insertColumn(baseColumn + c,columnSpecs[c]);
  }
}","private void insertLogicalColumn(int index){
  int baseColumn=logicalToLayoutColumn(index);
  if (index != 0 && gapColumn != null) {
    insertColumn(baseColumn,gapColumn);
    baseColumn+=1;
  }
  for (int c=0; c < columnSpecs.length; c++) {
    insertColumn(baseColumn + c,columnSpecs[c]);
  }
}",0.942528735632184
32687,"/** 
 * Creates an   {@link EventList} that provides a view of thedeselected items in a ListSelection.
 */
SelectedList(EventList<E> source){
  super(source);
}","/** 
 * Creates an   {@link EventList} that provides a view of theselected items in a ListSelection.
 */
SelectedList(EventList<E> source){
  super(source);
}",0.9937106918238994
32688,"/** 
 * Workaround method to get the Windows theme, either ""Windows Classic"" or ""Windows XP"". The test for Windows XP is also an ugly hack because Swing's pluggable look-and-feel provides no alternative means for determining if the current theme is XP. For compatibility, the algorithm to determine if the style is XP is derived from similar code in the XPStyle class.
 */
public static String getWindowsTheme(){
  String classic=""String_Node_Str"";
  String xp=""String_Node_Str"";
  String themeActiveKey=""String_Node_Str"";
  Boolean themeActive=(Boolean)java.awt.Toolkit.getDefaultToolkit().getDesktopProperty(themeActiveKey);
  if (themeActive == null)   return classic;
  if (!themeActive.booleanValue())   return classic;
  String noXPProperty=""String_Node_Str"";
  if (System.getProperty(noXPProperty) != null)   return classic;
  String classicLnF=""String_Node_Str"";
  if (UIManager.getLookAndFeel().getClass().getName().equals(classicLnF))   return ""String_Node_Str"";
  return xp;
}","/** 
 * Workaround method to get the Windows theme, either ""Windows Classic"" or ""Windows XP"". The test for Windows XP is also an ugly hack because Swing's pluggable look-and-feel provides no alternative means for determining if the current theme is XP. For compatibility, the algorithm to determine if the style is XP is derived from similar code in the XPStyle class.
 */
public static String getWindowsTheme(){
  String classic=""String_Node_Str"";
  String xp=""String_Node_Str"";
  String themeActiveKey=""String_Node_Str"";
  Boolean themeActive=(Boolean)java.awt.Toolkit.getDefaultToolkit().getDesktopProperty(themeActiveKey);
  if (themeActive == null)   return classic;
  if (!themeActive.booleanValue())   return classic;
  String noXPProperty=""String_Node_Str"";
  try {
    if (System.getProperty(noXPProperty) != null)     return classic;
  }
 catch (  AccessControlException e) {
  }
  String classicLnF=""String_Node_Str"";
  if (UIManager.getLookAndFeel().getClass().getName().equals(classicLnF))   return ""String_Node_Str"";
  return xp;
}",0.971456692913386
32689,"/** 
 * Creates a new issue that uses the specified issue as a template.
 */
public Issue(Project owner,Issue template){
  id=template.id;
  statusCode=template.statusCode;
  status=template.status;
  priority=template.priority;
  resolution=template.resolution;
  component=template.component;
  version=template.version;
  repPlatform=template.repPlatform;
  assignedTo=template.assignedTo;
  deltaTimestamp=template.deltaTimestamp;
  subcomponent=template.subcomponent;
  reporter=template.reporter;
  targetMilestone=template.targetMilestone;
  issueType=template.issueType;
  creationTimestamp=template.creationTimestamp;
  qaContact=template.qaContact;
  statusWhiteboard=template.statusWhiteboard;
  votes=template.votes;
  operatingSystem=template.operatingSystem;
  shortDescription=template.shortDescription;
  keywords.addAll(template.keywords);
  blocks.addAll(template.blocks);
  dependsOn.addAll(template.dependsOn);
  cc.addAll(template.cc);
  descriptions.addAll(template.descriptions);
  attachments.addAll(template.attachments);
  activities.addAll(template.activities);
}","/** 
 * Creates a new issue that uses the specified issue as a template.
 */
public Issue(Project owner,Issue template){
  this.owner=owner;
  id=template.id;
  statusCode=template.statusCode;
  status=template.status;
  priority=template.priority;
  resolution=template.resolution;
  component=template.component;
  version=template.version;
  repPlatform=template.repPlatform;
  assignedTo=template.assignedTo;
  deltaTimestamp=template.deltaTimestamp;
  subcomponent=template.subcomponent;
  reporter=template.reporter;
  targetMilestone=template.targetMilestone;
  issueType=template.issueType;
  creationTimestamp=template.creationTimestamp;
  qaContact=template.qaContact;
  statusWhiteboard=template.statusWhiteboard;
  votes=template.votes;
  operatingSystem=template.operatingSystem;
  shortDescription=template.shortDescription;
  keywords.addAll(template.keywords);
  blocks.addAll(template.blocks);
  dependsOn.addAll(template.dependsOn);
  cc.addAll(template.cc);
  descriptions.addAll(template.descriptions);
  attachments.addAll(template.attachments);
  activities.addAll(template.activities);
}",0.990909090909091
32690,"/** 
 * {@inheritDoc} 
 */
public int getEndIndex(){
  int endIndex=Math.max(sortedSource.indexOfSimulated(upperThreshold),sortedSource.lastIndexOf(new Integer(upperThreshold)) + 1);
  int startIndex=getStartIndex();
  return Math.max(startIndex,endIndex);
}","/** 
 * {@inheritDoc} 
 */
public int getEndIndex(){
  int endIndex=sortedSource.indexOfSimulated(new Integer(upperThreshold));
  while (endIndex < sortedSource.size() && sourceIndexToThreshold(endIndex) == upperThreshold)   endIndex++;
  return Math.max(getStartIndex(),endIndex);
}",0.3068391866913124
32691,"/** 
 * Renders the header in the default way but with the addition of an icon.
 */
public Component getTableCellRendererComponent(JTable table,Object value,boolean isSelected,boolean hasFocus,int row,int column){
  final Icon iconToUse=icons[getSortingStyle(column)];
  final Component rendered;
  if (delegateRenderer instanceof SortableRenderer) {
    ((SortableRenderer)delegateRenderer).setSortIcon(iconToUse);
    rendered=delegateRenderer.getTableCellRendererComponent(table,value,isSelected,hasFocus,row,column);
  }
 else   if (delegateRenderer instanceof DefaultTableCellRenderer) {
    rendered=delegateRenderer.getTableCellRendererComponent(table,value,isSelected,hasFocus,row,column);
    if (rendered == delegateRenderer) {
      final DefaultTableCellRenderer label=(DefaultTableCellRenderer)rendered;
      label.setIcon(iconToUse);
      label.setHorizontalTextPosition(SwingConstants.LEADING);
    }
  }
 else {
    rendered=delegateRenderer.getTableCellRendererComponent(table,value,isSelected,hasFocus,row,column);
  }
  return rendered;
}","/** 
 * Renders the header in the default way but with the addition of an icon.
 */
public Component getTableCellRendererComponent(JTable table,Object value,boolean isSelected,boolean hasFocus,int row,int column){
  final Icon sortIcon=icons[getSortingStyle(column)];
  final Component rendered;
  if (delegateRenderer instanceof SortableRenderer) {
    ((SortableRenderer)delegateRenderer).setSortIcon(sortIcon);
    rendered=delegateRenderer.getTableCellRendererComponent(table,value,isSelected,hasFocus,row,column);
  }
 else   if (delegateRenderer instanceof DefaultTableCellRenderer) {
    rendered=delegateRenderer.getTableCellRendererComponent(table,value,isSelected,hasFocus,row,column);
    if (rendered == delegateRenderer) {
      final DefaultTableCellRenderer label=(DefaultTableCellRenderer)rendered;
      label.setIcon(sortIcon);
      label.setHorizontalTextPosition(SwingConstants.LEADING);
    }
  }
 else {
    rendered=delegateRenderer.getTableCellRendererComponent(table,value,isSelected,hasFocus,row,column);
  }
  return rendered;
}",0.975886524822695
32692,"/** 
 * Creates a new SortArrowHeaderRenderer that delegates most drawing to the given delegate renderer.
 */
public SortArrowHeaderRenderer(TableCellRenderer delegateRenderer){
  this.delegateRenderer=delegateRenderer;
}","/** 
 * Creates a new SortArrowHeaderRenderer that attempts to decorate the given <code>delegateRenderer</code> which a sorting icon.
 */
public SortArrowHeaderRenderer(TableCellRenderer delegateRenderer){
  this.delegateRenderer=delegateRenderer;
}",0.7659574468085106
32693,"/** 
 * Display a frame for browsing issues.
 */
private JPanel constructView(){
  final JTextField filterTextField=new JTextField();
  final MatcherEditor textFilterMatcherEditor=new ThreadedMatcherEditor(new TextComponentMatcherEditor(filterTextField,null));
  StatusMatcherEditor statusMatcherEditor=new StatusMatcherEditor(issuesEventList);
  SwingUsersMatcherEditor userMatcherEditor=new SwingUsersMatcherEditor(issuesEventList);
  FilterList issuesUserFiltered=new FilterList(issuesEventList,userMatcherEditor);
  FilterList issuesStatusFiltered=new FilterList(issuesUserFiltered,statusMatcherEditor);
  FilterList issuesTextFiltered=new FilterList(issuesStatusFiltered,textFilterMatcherEditor);
  ThresholdList priorityList=new ThresholdList(issuesTextFiltered,""String_Node_Str"");
  final SortedList issuesSortedList=new SortedList(priorityList,null);
  issuesSortedList.setMode(SortedList.AVOID_MOVING_ELEMENTS);
  issuesTableModel=new EventTableModel(issuesSortedList,new IssueTableFormat());
  JTable issuesJTable=new JTable(issuesTableModel);
  issuesSelectionModel=new EventSelectionModel(issuesSortedList);
  issuesSelectionModel.setSelectionMode(ListSelection.MULTIPLE_INTERVAL_SELECTION_DEFENSIVE);
  issuesSelectionModel.addListSelectionListener(new IssuesSelectionListener());
  issuesJTable.setSelectionModel(issuesSelectionModel);
  issuesJTable.getColumnModel().getColumn(0).setPreferredWidth(10);
  issuesJTable.getColumnModel().getColumn(1).setPreferredWidth(30);
  issuesJTable.getColumnModel().getColumn(2).setPreferredWidth(10);
  issuesJTable.getColumnModel().getColumn(3).setPreferredWidth(30);
  issuesJTable.getColumnModel().getColumn(4).setPreferredWidth(30);
  issuesJTable.getColumnModel().getColumn(5).setPreferredWidth(200);
  issuesJTable.setDefaultRenderer(Priority.class,new PriorityTableCellRenderer());
  new TableComparatorChooser(issuesJTable,issuesSortedList,true);
  JScrollPane issuesTableScrollPane=new JScrollPane(issuesJTable,JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  JScrollPane usersListScrollPane=new JScrollPane(userMatcherEditor.getUserSelect(),JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  EventTableModel descriptionsTableModel=new EventTableModel(descriptions,new DescriptionTableFormat());
  JTable descriptionsTable=new JTable(descriptionsTableModel);
  descriptionsTable.setRowSelectionAllowed(false);
  descriptionsTable.getColumnModel().getColumn(0).setCellRenderer(new DescriptionRenderer());
  JScrollPane descriptionsTableScrollPane=new JScrollPane(descriptionsTable,JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  BoundedRangeModel priorityRangeModel=GlazedListsSwing.lowerRangeModel(priorityList);
  priorityRangeModel.setRangeProperties(0,0,0,101,false);
  JSlider prioritySlider=new JSlider(priorityRangeModel);
  Hashtable prioritySliderLabels=new Hashtable();
  prioritySliderLabels.put(new Integer(0),new JLabel(""String_Node_Str""));
  prioritySliderLabels.put(new Integer(100),new JLabel(""String_Node_Str""));
  prioritySlider.setOpaque(false);
  prioritySlider.setLabelTable(prioritySliderLabels);
  prioritySlider.setSnapToTicks(true);
  prioritySlider.setPaintLabels(true);
  prioritySlider.setPaintTicks(true);
  prioritySlider.setForeground(UIManager.getColor(""String_Node_Str""));
  prioritySlider.setMajorTickSpacing(25);
  prioritySlider.setForeground(Color.BLACK);
  EventList projects=Project.getProjects();
  EventComboBoxModel projectsComboModel=new EventComboBoxModel(projects);
  JComboBox projectsCombo=new JComboBox(projectsComboModel);
  projectsCombo.setEditable(false);
  projectsCombo.setOpaque(false);
  projectsCombo.addItemListener(new ProjectChangeListener());
  projectsComboModel.setSelectedItem(new Project(null,""String_Node_Str""));
  issueCounter=new IssueCounterLabel(issuesSortedList);
  issueCounter.setHorizontalAlignment(SwingConstants.CENTER);
  issueCounter.setForeground(Color.WHITE);
  ClassLoader jarLoader=IssuesBrowser.class.getClassLoader();
  URL url=jarLoader.getResource(""String_Node_Str"");
  if (url != null)   throbberStatic=new ImageIcon(url);
  url=jarLoader.getResource(""String_Node_Str"");
  if (url != null)   throbberActive=new ImageIcon(url);
  throbber=new JLabel(throbberStatic);
  throbber.setHorizontalAlignment(SwingConstants.RIGHT);
  JPanel iconBar=new GradientPanel(GLAZED_LISTS_MEDIUM_BROWN,GLAZED_LISTS_DARK_BROWN,true);
  iconBar.setLayout(new GridLayout(1,3));
  iconBar.add(projectsCombo);
  iconBar.add(issueCounter);
  iconBar.add(throbber);
  iconBar.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));
  JLabel textFilterLabel=new JLabel(""String_Node_Str"");
  textFilterLabel.setFont(textFilterLabel.getFont().deriveFont(11.0f));
  JLabel priorityLabel=new JLabel(""String_Node_Str"");
  priorityLabel.setFont(priorityLabel.getFont().deriveFont(11.0f));
  JLabel stateLabel=new JLabel(""String_Node_Str"");
  stateLabel.setFont(stateLabel.getFont().deriveFont(11.0f));
  JLabel userLabel=new JLabel(""String_Node_Str"");
  userLabel.setFont(userLabel.getFont().deriveFont(11.0f));
  JPanel filtersPanel=new JPanel();
  filtersPanel.setBackground(GLAZED_LISTS_LIGHT_BROWN);
  filtersPanel.setLayout(new GridBagLayout());
  filtersPanel.add(textFilterLabel,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(5,5,0,5),0,0));
  filtersPanel.add(filterTextField,new GridBagConstraints(0,1,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(2,5,10,5),0,0));
  filtersPanel.add(stateLabel,new GridBagConstraints(0,2,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(5,5,0,5),0,0));
  filtersPanel.add(statusMatcherEditor.getComponent(),new GridBagConstraints(0,3,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(2,5,10,5),0,0));
  filtersPanel.add(priorityLabel,new GridBagConstraints(0,4,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(5,5,0,5),0,0));
  filtersPanel.add(prioritySlider,new GridBagConstraints(0,5,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(2,5,10,5),0,0));
  filtersPanel.add(userLabel,new GridBagConstraints(0,6,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(5,5,0,5),0,0));
  filtersPanel.add(usersListScrollPane,new GridBagConstraints(0,7,1,1,1.0,1.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(2,0,0,0),0,0));
  JPanel dataPanel=new JPanel();
  dataPanel.setLayout(new GridBagLayout());
  dataPanel.add(issuesTableScrollPane,new GridBagConstraints(0,0,1,1,1.0,0.5,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
  dataPanel.add(descriptionsTableScrollPane,new GridBagConstraints(0,1,1,1,1.0,0.5,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
  JPanel mainPanel=new JPanel(new GridBagLayout());
  mainPanel.add(iconBar,new GridBagConstraints(0,0,2,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
  mainPanel.add(filtersPanel,new GridBagConstraints(0,1,1,1,0.0,1.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
  mainPanel.add(dataPanel,new GridBagConstraints(1,1,1,1,1.0,1.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
  return mainPanel;
}","/** 
 * Display a frame for browsing issues.
 */
private JPanel constructView(){
  final JTextField filterTextField=new JTextField();
  final MatcherEditor textFilterMatcherEditor=new ThreadedMatcherEditor(new TextComponentMatcherEditor(filterTextField,null));
  StatusMatcherEditor statusMatcherEditor=new StatusMatcherEditor(issuesEventList);
  SwingUsersMatcherEditor userMatcherEditor=new SwingUsersMatcherEditor(issuesEventList);
  FilterList issuesUserFiltered=new FilterList(issuesEventList,userMatcherEditor);
  FilterList issuesStatusFiltered=new FilterList(issuesUserFiltered,statusMatcherEditor);
  FilterList issuesTextFiltered=new FilterList(issuesStatusFiltered,textFilterMatcherEditor);
  ThresholdList priorityList=new ThresholdList(issuesTextFiltered,""String_Node_Str"");
  final SortedList issuesSortedList=new SortedList(priorityList,null);
  issuesSortedList.setMode(SortedList.AVOID_MOVING_ELEMENTS);
  issuesTableModel=new EventTableModel(issuesSortedList,new IssueTableFormat());
  JTable issuesJTable=new JTable(issuesTableModel);
  issuesSelectionModel=new EventSelectionModel(issuesSortedList);
  issuesSelectionModel.setSelectionMode(ListSelection.MULTIPLE_INTERVAL_SELECTION_DEFENSIVE);
  issuesSelectionModel.addListSelectionListener(new IssuesSelectionListener());
  issuesJTable.setSelectionModel(issuesSelectionModel);
  issuesJTable.getColumnModel().getColumn(0).setPreferredWidth(10);
  issuesJTable.getColumnModel().getColumn(1).setPreferredWidth(30);
  issuesJTable.getColumnModel().getColumn(2).setPreferredWidth(10);
  issuesJTable.getColumnModel().getColumn(3).setPreferredWidth(30);
  issuesJTable.getColumnModel().getColumn(4).setPreferredWidth(30);
  issuesJTable.getColumnModel().getColumn(5).setPreferredWidth(200);
  issuesJTable.setDefaultRenderer(Priority.class,new PriorityTableCellRenderer());
  new TableComparatorChooser(issuesJTable,issuesSortedList,true);
  JScrollPane issuesTableScrollPane=new JScrollPane(issuesJTable,JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  JScrollPane usersListScrollPane=new JScrollPane(userMatcherEditor.getUserSelect(),JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  EventTableModel descriptionsTableModel=new EventTableModel(descriptions,new DescriptionTableFormat());
  JTable descriptionsTable=new JTable(descriptionsTableModel);
  descriptionsTable.setRowSelectionAllowed(false);
  descriptionsTable.getColumnModel().getColumn(0).setCellRenderer(new DescriptionRenderer());
  JScrollPane descriptionsTableScrollPane=new JScrollPane(descriptionsTable,JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  BoundedRangeModel priorityRangeModel=GlazedListsSwing.lowerRangeModel(priorityList);
  priorityRangeModel.setRangeProperties(0,0,0,100,false);
  JSlider prioritySlider=new JSlider(priorityRangeModel);
  Hashtable prioritySliderLabels=new Hashtable();
  prioritySliderLabels.put(new Integer(0),new JLabel(""String_Node_Str""));
  prioritySliderLabels.put(new Integer(100),new JLabel(""String_Node_Str""));
  prioritySlider.setOpaque(false);
  prioritySlider.setLabelTable(prioritySliderLabels);
  prioritySlider.setSnapToTicks(true);
  prioritySlider.setPaintLabels(true);
  prioritySlider.setPaintTicks(true);
  prioritySlider.setForeground(UIManager.getColor(""String_Node_Str""));
  prioritySlider.setMajorTickSpacing(25);
  prioritySlider.setForeground(Color.BLACK);
  EventList projects=Project.getProjects();
  EventComboBoxModel projectsComboModel=new EventComboBoxModel(projects);
  JComboBox projectsCombo=new JComboBox(projectsComboModel);
  projectsCombo.setEditable(false);
  projectsCombo.setOpaque(false);
  projectsCombo.addItemListener(new ProjectChangeListener());
  projectsComboModel.setSelectedItem(new Project(null,""String_Node_Str""));
  issueCounter=new IssueCounterLabel(issuesSortedList);
  issueCounter.setHorizontalAlignment(SwingConstants.CENTER);
  issueCounter.setForeground(Color.WHITE);
  ClassLoader jarLoader=IssuesBrowser.class.getClassLoader();
  URL url=jarLoader.getResource(""String_Node_Str"");
  if (url != null)   throbberStatic=new ImageIcon(url);
  url=jarLoader.getResource(""String_Node_Str"");
  if (url != null)   throbberActive=new ImageIcon(url);
  throbber=new JLabel(throbberStatic);
  throbber.setHorizontalAlignment(SwingConstants.RIGHT);
  JPanel iconBar=new GradientPanel(GLAZED_LISTS_MEDIUM_BROWN,GLAZED_LISTS_DARK_BROWN,true);
  iconBar.setLayout(new GridLayout(1,3));
  iconBar.add(projectsCombo);
  iconBar.add(issueCounter);
  iconBar.add(throbber);
  iconBar.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));
  JLabel textFilterLabel=new JLabel(""String_Node_Str"");
  textFilterLabel.setFont(textFilterLabel.getFont().deriveFont(11.0f));
  JLabel priorityLabel=new JLabel(""String_Node_Str"");
  priorityLabel.setFont(priorityLabel.getFont().deriveFont(11.0f));
  JLabel stateLabel=new JLabel(""String_Node_Str"");
  stateLabel.setFont(stateLabel.getFont().deriveFont(11.0f));
  JLabel userLabel=new JLabel(""String_Node_Str"");
  userLabel.setFont(userLabel.getFont().deriveFont(11.0f));
  JPanel filtersPanel=new JPanel();
  filtersPanel.setBackground(GLAZED_LISTS_LIGHT_BROWN);
  filtersPanel.setLayout(new GridBagLayout());
  filtersPanel.add(textFilterLabel,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(5,5,0,5),0,0));
  filtersPanel.add(filterTextField,new GridBagConstraints(0,1,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(2,5,10,5),0,0));
  filtersPanel.add(stateLabel,new GridBagConstraints(0,2,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(5,5,0,5),0,0));
  filtersPanel.add(statusMatcherEditor.getComponent(),new GridBagConstraints(0,3,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(2,5,10,5),0,0));
  filtersPanel.add(priorityLabel,new GridBagConstraints(0,4,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(5,5,0,5),0,0));
  filtersPanel.add(prioritySlider,new GridBagConstraints(0,5,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(2,5,10,5),0,0));
  filtersPanel.add(userLabel,new GridBagConstraints(0,6,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(5,5,0,5),0,0));
  filtersPanel.add(usersListScrollPane,new GridBagConstraints(0,7,1,1,1.0,1.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(2,0,0,0),0,0));
  JPanel dataPanel=new JPanel();
  dataPanel.setLayout(new GridBagLayout());
  dataPanel.add(issuesTableScrollPane,new GridBagConstraints(0,0,1,1,1.0,0.5,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
  dataPanel.add(descriptionsTableScrollPane,new GridBagConstraints(0,1,1,1,1.0,0.5,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
  JPanel mainPanel=new JPanel(new GridBagLayout());
  mainPanel.add(iconBar,new GridBagConstraints(0,0,2,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
  mainPanel.add(filtersPanel,new GridBagConstraints(0,1,1,1,0.0,1.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
  mainPanel.add(dataPanel,new GridBagConstraints(1,1,1,1,1.0,1.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
  return mainPanel;
}",0.9998646453708716
32694,"/** 
 * A convenience method to paint a gradient between <code>gradientStartColor</code> and <code>gradientEndColor</code> over <code>height</code> pixels.
 */
private static void paintGradient(Graphics2D g2d,Color gradientStartColor,Color gradientEndColor,int length,boolean vertical){
  final Paint oldPainter=g2d.getPaint();
  try {
    if (vertical)     g2d.setPaint(new GradientPaint(0,0,gradientStartColor,0,length,gradientEndColor));
 else     g2d.setPaint(new GradientPaint(0,0,gradientStartColor,length,0,gradientEndColor));
    g2d.fill(g2d.getClip());
  }
  finally {
    g2d.setPaint(oldPainter);
  }
}","/** 
 * A convenience method to paint a gradient between <code>gradientStartColor</code> and <code>gradientEndColor</code> over <code>length</code> pixels.
 */
private static void paintGradient(Graphics2D g2d,Color gradientStartColor,Color gradientEndColor,int length,boolean vertical){
  final Paint oldPainter=g2d.getPaint();
  try {
    if (vertical)     g2d.setPaint(new GradientPaint(0,0,gradientStartColor,0,length,gradientEndColor));
 else     g2d.setPaint(new GradientPaint(0,0,gradientStartColor,length,0,gradientEndColor));
    g2d.fill(g2d.getClip());
  }
  finally {
    g2d.setPaint(oldPainter);
  }
}",0.99185667752443
32695,"/** 
 * Display a frame for browsing issues.
 */
private JPanel constructView(){
  final JTextField filterTextField=new JTextField();
  final MatcherEditor textFilterMatcherEditor=new ThreadedMatcherEditor(new TextComponentMatcherEditor(filterTextField,null));
  StatusMatcherEditor statusMatcherEditor=new StatusMatcherEditor(issuesEventList);
  SwingUsersMatcherEditor userMatcherEditor=new SwingUsersMatcherEditor(issuesEventList);
  FilterList issuesUserFiltered=new FilterList(issuesEventList,userMatcherEditor);
  FilterList issuesStatusFiltered=new FilterList(issuesUserFiltered,statusMatcherEditor);
  FilterList issuesTextFiltered=new FilterList(issuesStatusFiltered,textFilterMatcherEditor);
  ThresholdList priorityList=new ThresholdList(issuesTextFiltered,""String_Node_Str"");
  final SortedList issuesSortedList=new SortedList(priorityList,null);
  issuesSortedList.setMode(SortedList.AVOID_MOVING_ELEMENTS);
  issuesTableModel=new EventTableModel(issuesSortedList,new IssueTableFormat());
  JTable issuesJTable=new JTable(issuesTableModel);
  issuesSelectionModel=new EventSelectionModel(issuesSortedList);
  issuesSelectionModel.setSelectionMode(ListSelection.MULTIPLE_INTERVAL_SELECTION_DEFENSIVE);
  issuesSelectionModel.addListSelectionListener(new IssuesSelectionListener());
  issuesJTable.setSelectionModel(issuesSelectionModel);
  issuesJTable.getColumnModel().getColumn(0).setPreferredWidth(10);
  issuesJTable.getColumnModel().getColumn(1).setPreferredWidth(30);
  issuesJTable.getColumnModel().getColumn(2).setPreferredWidth(10);
  issuesJTable.getColumnModel().getColumn(3).setPreferredWidth(30);
  issuesJTable.getColumnModel().getColumn(4).setPreferredWidth(30);
  issuesJTable.getColumnModel().getColumn(5).setPreferredWidth(200);
  issuesJTable.setDefaultRenderer(Priority.class,new PriorityTableCellRenderer());
  new TableComparatorChooser(issuesJTable,issuesSortedList,true);
  JScrollPane issuesTableScrollPane=new JScrollPane(issuesJTable,JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  JScrollPane usersListScrollPane=new JScrollPane(userMatcherEditor.getUserSelect(),JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  EventTableModel descriptionsTableModel=new EventTableModel(descriptions,new DescriptionTableFormat());
  JTable descriptionsTable=new JTable(descriptionsTableModel);
  descriptionsTable.setRowSelectionAllowed(false);
  descriptionsTable.getColumnModel().getColumn(0).setCellRenderer(new DescriptionRenderer());
  JScrollPane descriptionsTableScrollPane=new JScrollPane(descriptionsTable,JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  BoundedRangeModel priorityRangeModel=GlazedListsSwing.lowerRangeModel(priorityList);
  priorityRangeModel.setRangeProperties(0,0,0,100,false);
  JSlider prioritySlider=new JSlider(priorityRangeModel);
  Hashtable prioritySliderLabels=new Hashtable();
  prioritySliderLabels.put(new Integer(0),new JLabel(""String_Node_Str""));
  prioritySliderLabels.put(new Integer(100),new JLabel(""String_Node_Str""));
  prioritySlider.setOpaque(false);
  prioritySlider.setLabelTable(prioritySliderLabels);
  prioritySlider.setSnapToTicks(true);
  prioritySlider.setPaintLabels(true);
  prioritySlider.setPaintTicks(true);
  prioritySlider.setForeground(UIManager.getColor(""String_Node_Str""));
  prioritySlider.setMajorTickSpacing(25);
  prioritySlider.setForeground(Color.white);
  EventList projects=Project.getProjects();
  EventComboBoxModel projectsComboModel=new EventComboBoxModel(projects);
  JComboBox projectsCombo=new JComboBox(projectsComboModel);
  projectsCombo.setEditable(false);
  projectsCombo.setOpaque(false);
  projectsCombo.addItemListener(new ProjectChangeListener());
  projectsComboModel.setSelectedItem(new Project(null,""String_Node_Str""));
  issueCounter=new IssueCounterLabel(issuesSortedList);
  issueCounter.setHorizontalAlignment(SwingConstants.CENTER);
  issueCounter.setForeground(Color.WHITE);
  ClassLoader jarLoader=IssuesBrowser.class.getClassLoader();
  URL url=jarLoader.getResource(""String_Node_Str"");
  if (url != null)   throbberStatic=new ImageIcon(url);
  url=jarLoader.getResource(""String_Node_Str"");
  if (url != null)   throbberActive=new ImageIcon(url);
  throbber=new JLabel(throbberStatic);
  throbber.setHorizontalAlignment(SwingConstants.RIGHT);
  JPanel iconBar=new GradientPanel(GLAZED_LISTS_MEDIUM_BROWN,GLAZED_LISTS_DARK_BROWN,true);
  iconBar.setLayout(new GridLayout(1,3));
  iconBar.add(projectsCombo);
  iconBar.add(issueCounter);
  iconBar.add(throbber);
  iconBar.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));
  JLabel textFilterLabel=new JLabel(""String_Node_Str"");
  textFilterLabel.setFont(textFilterLabel.getFont().deriveFont(11.0f));
  JLabel priorityLabel=new JLabel(""String_Node_Str"");
  priorityLabel.setFont(priorityLabel.getFont().deriveFont(11.0f));
  JLabel stateLabel=new JLabel(""String_Node_Str"");
  stateLabel.setFont(stateLabel.getFont().deriveFont(11.0f));
  JLabel userLabel=new JLabel(""String_Node_Str"");
  userLabel.setFont(userLabel.getFont().deriveFont(11.0f));
  JPanel filtersPanel=new JPanel();
  filtersPanel.setBackground(GLAZED_LISTS_LIGHT_BROWN);
  filtersPanel.setLayout(new GridBagLayout());
  filtersPanel.add(textFilterLabel,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(5,5,0,5),0,0));
  filtersPanel.add(filterTextField,new GridBagConstraints(0,1,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(2,5,10,5),0,0));
  filtersPanel.add(stateLabel,new GridBagConstraints(0,2,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(5,5,0,5),0,0));
  filtersPanel.add(statusMatcherEditor.getComponent(),new GridBagConstraints(0,3,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(2,5,10,5),0,0));
  filtersPanel.add(priorityLabel,new GridBagConstraints(0,4,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(5,5,0,5),0,0));
  filtersPanel.add(prioritySlider,new GridBagConstraints(0,5,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(2,5,10,5),0,0));
  filtersPanel.add(userLabel,new GridBagConstraints(0,6,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(5,5,0,5),0,0));
  filtersPanel.add(usersListScrollPane,new GridBagConstraints(0,7,1,1,1.0,1.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(2,0,0,0),0,0));
  JPanel dataPanel=new JPanel();
  dataPanel.setLayout(new GridBagLayout());
  dataPanel.add(issuesTableScrollPane,new GridBagConstraints(0,0,1,1,1.0,0.5,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
  dataPanel.add(descriptionsTableScrollPane,new GridBagConstraints(0,1,1,1,1.0,0.5,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
  JPanel mainPanel=new JPanel(new GridBagLayout());
  mainPanel.add(iconBar,new GridBagConstraints(0,0,2,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
  mainPanel.add(filtersPanel,new GridBagConstraints(0,1,1,1,0.0,1.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
  mainPanel.add(dataPanel,new GridBagConstraints(1,1,1,1,1.0,1.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
  return mainPanel;
}","/** 
 * Display a frame for browsing issues.
 */
private JPanel constructView(){
  final JTextField filterTextField=new JTextField();
  final MatcherEditor textFilterMatcherEditor=new ThreadedMatcherEditor(new TextComponentMatcherEditor(filterTextField,null));
  StatusMatcherEditor statusMatcherEditor=new StatusMatcherEditor(issuesEventList);
  SwingUsersMatcherEditor userMatcherEditor=new SwingUsersMatcherEditor(issuesEventList);
  FilterList issuesUserFiltered=new FilterList(issuesEventList,userMatcherEditor);
  FilterList issuesStatusFiltered=new FilterList(issuesUserFiltered,statusMatcherEditor);
  FilterList issuesTextFiltered=new FilterList(issuesStatusFiltered,textFilterMatcherEditor);
  ThresholdList priorityList=new ThresholdList(issuesTextFiltered,""String_Node_Str"");
  final SortedList issuesSortedList=new SortedList(priorityList,null);
  issuesSortedList.setMode(SortedList.AVOID_MOVING_ELEMENTS);
  issuesTableModel=new EventTableModel(issuesSortedList,new IssueTableFormat());
  JTable issuesJTable=new JTable(issuesTableModel);
  issuesSelectionModel=new EventSelectionModel(issuesSortedList);
  issuesSelectionModel.setSelectionMode(ListSelection.MULTIPLE_INTERVAL_SELECTION_DEFENSIVE);
  issuesSelectionModel.addListSelectionListener(new IssuesSelectionListener());
  issuesJTable.setSelectionModel(issuesSelectionModel);
  issuesJTable.getColumnModel().getColumn(0).setPreferredWidth(10);
  issuesJTable.getColumnModel().getColumn(1).setPreferredWidth(30);
  issuesJTable.getColumnModel().getColumn(2).setPreferredWidth(10);
  issuesJTable.getColumnModel().getColumn(3).setPreferredWidth(30);
  issuesJTable.getColumnModel().getColumn(4).setPreferredWidth(30);
  issuesJTable.getColumnModel().getColumn(5).setPreferredWidth(200);
  issuesJTable.setDefaultRenderer(Priority.class,new PriorityTableCellRenderer());
  new TableComparatorChooser(issuesJTable,issuesSortedList,true);
  JScrollPane issuesTableScrollPane=new JScrollPane(issuesJTable,JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  JScrollPane usersListScrollPane=new JScrollPane(userMatcherEditor.getUserSelect(),JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  EventTableModel descriptionsTableModel=new EventTableModel(descriptions,new DescriptionTableFormat());
  JTable descriptionsTable=new JTable(descriptionsTableModel);
  descriptionsTable.setRowSelectionAllowed(false);
  descriptionsTable.getColumnModel().getColumn(0).setCellRenderer(new DescriptionRenderer());
  JScrollPane descriptionsTableScrollPane=new JScrollPane(descriptionsTable,JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  BoundedRangeModel priorityRangeModel=GlazedListsSwing.lowerRangeModel(priorityList);
  priorityRangeModel.setRangeProperties(0,0,0,101,false);
  JSlider prioritySlider=new JSlider(priorityRangeModel);
  Hashtable prioritySliderLabels=new Hashtable();
  prioritySliderLabels.put(new Integer(0),new JLabel(""String_Node_Str""));
  prioritySliderLabels.put(new Integer(100),new JLabel(""String_Node_Str""));
  prioritySlider.setOpaque(false);
  prioritySlider.setLabelTable(prioritySliderLabels);
  prioritySlider.setSnapToTicks(true);
  prioritySlider.setPaintLabels(true);
  prioritySlider.setPaintTicks(true);
  prioritySlider.setForeground(UIManager.getColor(""String_Node_Str""));
  prioritySlider.setMajorTickSpacing(25);
  prioritySlider.setForeground(Color.white);
  EventList projects=Project.getProjects();
  EventComboBoxModel projectsComboModel=new EventComboBoxModel(projects);
  JComboBox projectsCombo=new JComboBox(projectsComboModel);
  projectsCombo.setEditable(false);
  projectsCombo.setOpaque(false);
  projectsCombo.addItemListener(new ProjectChangeListener());
  projectsComboModel.setSelectedItem(new Project(null,""String_Node_Str""));
  issueCounter=new IssueCounterLabel(issuesSortedList);
  issueCounter.setHorizontalAlignment(SwingConstants.CENTER);
  issueCounter.setForeground(Color.WHITE);
  ClassLoader jarLoader=IssuesBrowser.class.getClassLoader();
  URL url=jarLoader.getResource(""String_Node_Str"");
  if (url != null)   throbberStatic=new ImageIcon(url);
  url=jarLoader.getResource(""String_Node_Str"");
  if (url != null)   throbberActive=new ImageIcon(url);
  throbber=new JLabel(throbberStatic);
  throbber.setHorizontalAlignment(SwingConstants.RIGHT);
  JPanel iconBar=new GradientPanel(GLAZED_LISTS_MEDIUM_BROWN,GLAZED_LISTS_DARK_BROWN,true);
  iconBar.setLayout(new GridLayout(1,3));
  iconBar.add(projectsCombo);
  iconBar.add(issueCounter);
  iconBar.add(throbber);
  iconBar.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));
  JLabel textFilterLabel=new JLabel(""String_Node_Str"");
  textFilterLabel.setFont(textFilterLabel.getFont().deriveFont(11.0f));
  JLabel priorityLabel=new JLabel(""String_Node_Str"");
  priorityLabel.setFont(priorityLabel.getFont().deriveFont(11.0f));
  JLabel stateLabel=new JLabel(""String_Node_Str"");
  stateLabel.setFont(stateLabel.getFont().deriveFont(11.0f));
  JLabel userLabel=new JLabel(""String_Node_Str"");
  userLabel.setFont(userLabel.getFont().deriveFont(11.0f));
  JPanel filtersPanel=new JPanel();
  filtersPanel.setBackground(GLAZED_LISTS_LIGHT_BROWN);
  filtersPanel.setLayout(new GridBagLayout());
  filtersPanel.add(textFilterLabel,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(5,5,0,5),0,0));
  filtersPanel.add(filterTextField,new GridBagConstraints(0,1,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(2,5,10,5),0,0));
  filtersPanel.add(stateLabel,new GridBagConstraints(0,2,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(5,5,0,5),0,0));
  filtersPanel.add(statusMatcherEditor.getComponent(),new GridBagConstraints(0,3,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(2,5,10,5),0,0));
  filtersPanel.add(priorityLabel,new GridBagConstraints(0,4,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(5,5,0,5),0,0));
  filtersPanel.add(prioritySlider,new GridBagConstraints(0,5,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(2,5,10,5),0,0));
  filtersPanel.add(userLabel,new GridBagConstraints(0,6,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(5,5,0,5),0,0));
  filtersPanel.add(usersListScrollPane,new GridBagConstraints(0,7,1,1,1.0,1.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(2,0,0,0),0,0));
  JPanel dataPanel=new JPanel();
  dataPanel.setLayout(new GridBagLayout());
  dataPanel.add(issuesTableScrollPane,new GridBagConstraints(0,0,1,1,1.0,0.5,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
  dataPanel.add(descriptionsTableScrollPane,new GridBagConstraints(0,1,1,1,1.0,0.5,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
  JPanel mainPanel=new JPanel(new GridBagLayout());
  mainPanel.add(iconBar,new GridBagConstraints(0,0,2,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
  mainPanel.add(filtersPanel,new GridBagConstraints(0,1,1,1,0.0,1.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
  mainPanel.add(dataPanel,new GridBagConstraints(1,1,1,1,1.0,1.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
  return mainPanel;
}",0.9998646453708716
32696,"/** 
 * Gets the white index of the element with the given real index or the white index of the previous or next WHITE element if that element is BLACK.
 * @param left true for BLACK elements to return the white index of thefirst WHITE element before it in the list. Such values will range from <code>-1</code> through <code>size()-1</code>. False for BLACK elements to return the white index of the first WHITE element after it in the list. Such values will range from <code>0</code> through <code>size()</code>.
 */
public int getWhiteIndex(int index,boolean left){
  if (root == null || index >= treeSize)   return index;
 else   return root.getWhiteIndex(index,left);
}","/** 
 * Gets the white index of the element with the given real index or the white index of the previous or next WHITE element if that element is BLACK.
 * @param left true for BLACK elements to return the white index of thefirst WHITE element before it in the list. Such values will range from <code>-1</code> through <code>size()-1</code>. False for BLACK elements to return the white index of the first WHITE element after it in the list. Such values will range from <code>0</code> through <code>size()</code>.
 */
public int getWhiteIndex(int index,boolean left){
  if (root == null)   return index;
 else   if (index >= treeSize)   return index - treeSize + root.whiteSize();
 else   return root.getWhiteIndex(index,left);
}",0.9543509272467904
32697,"/** 
 * Updates a row with the given value.
 */
public void updateRow(int row,Object value){
  if (!isVirtual(row)) {
    TableItem item=table.getItem(row);
    setItemText(item,value);
  }
}","/** 
 * Updates a row with the given value.
 */
public void updateRow(int row,Object value){
  if (!isVirtual(row)) {
    requested.setBlack(row,1);
    TableItem item=table.getItem(row);
    setItemText(item,value);
  }
}",0.9249394673123488
32698,"/** 
 * Adds a row with the given value.
 */
public void addRow(int row,Object value){
  if (row <= getLastIndex()) {
    TableItem item=new TableItem(table,0,row);
    setItemText(item,value);
  }
 else {
    table.setItemCount(table.getItemCount() + 1);
  }
}","/** 
 * Adds a row with the given value.
 */
public void addRow(int row,Object value){
  if (row <= getLastIndex()) {
    requested.addBlack(row,1);
    TableItem item=new TableItem(table,0,row);
    setItemText(item,value);
  }
 else {
    requested.addWhite(requested.size(),1);
    table.setItemCount(table.getItemCount() + 1);
  }
}",0.8743718592964824
32699,"/** 
 * To update the Barcode as change events come in.
 */
public void listChanged(ListEvent listChanges){
  while (listChanges.next()) {
    int changeType=listChanges.getType();
    int changeIndex=listChanges.getIndex();
    if (changeType == ListEvent.INSERT) {
      if (changeIndex == requested.size()) {
        requested.addWhite(requested.size(),1);
      }
 else {
        requested.addBlack(changeIndex,1);
      }
    }
 else     if (changeType == ListEvent.UPDATE) {
      requested.setBlack(changeIndex,1);
    }
 else     if (changeType == ListEvent.DELETE) {
      requested.remove(changeIndex,1);
    }
  }
}","/** 
 * When the source list is changed, this forwards the change to the displayed   {@link Table}.
 */
public void listChanged(ListEvent listChanges){
  swtSource.getReadWriteLock().readLock().lock();
  Barcode deletes=new Barcode();
  deletes.addWhite(0,swtSource.size());
  int firstChange=swtSource.size();
  try {
    table.setRedraw(false);
    while (listChanges.next()) {
      int changeIndex=listChanges.getIndex();
      int adjustedIndex=deletes.getIndex(changeIndex,Barcode.WHITE);
      int changeType=listChanges.getType();
      if (changeType == ListEvent.INSERT) {
        deletes.addWhite(adjustedIndex,1);
        tableHandler.addRow(adjustedIndex,swtSource.get(changeIndex));
        firstChange=Math.min(changeIndex,firstChange);
      }
 else       if (changeType == ListEvent.UPDATE) {
        tableHandler.updateRow(adjustedIndex,swtSource.get(changeIndex));
      }
 else       if (changeType == ListEvent.DELETE) {
        deletes.setBlack(adjustedIndex,1);
        firstChange=Math.min(changeIndex,firstChange);
      }
    }
    if (deletes.blackSize() > 0) {
      int[] deletedIndices=new int[deletes.blackSize()];
      for (BarcodeIterator i=deletes.iterator(); i.hasNextBlack(); ) {
        i.nextBlack();
        deletedIndices[i.getBlackIndex()]=i.getIndex();
      }
      tableHandler.removeAll(deletedIndices);
    }
    table.setRedraw(true);
  }
  finally {
    swtSource.getReadWriteLock().readLock().unlock();
  }
}",0.3205374280230326
32700,"/** 
 * Create a new VirtualTableHandler.
 */
public VirtualTableHandler(){
  requested=new Barcode();
  requested.addWhite(0,swtSource.size());
  table.addListener(SWT.SetData,this);
  swtSource.addListEventListener(this);
}","/** 
 * Create a new VirtualTableHandler.
 */
public VirtualTableHandler(){
  requested=new Barcode();
  requested.addWhite(0,swtSource.size());
  table.addListener(SWT.SetData,this);
}",0.902439024390244
32701,"/** 
 * Allows this handler to clean up after itself.
 */
public void dispose(){
  table.removeListener(SWT.SetData,this);
  swtSource.removeListEventListener(this);
}","/** 
 * Allows this handler to clean up after itself.
 */
public void dispose(){
  table.removeListener(SWT.SetData,this);
}",0.852233676975945
32702,"/** 
 * Test Matchers that fire matchAll() and matchNone() events.
 */
public void testMatchAllOrNothing(){
  EventList base_list=new BasicEventList();
  base_list.add(new Integer(1));
  base_list.add(new Integer(2));
  base_list.add(new Integer(3));
  base_list.add(new Integer(4));
  base_list.add(new Integer(5));
  AllOrNothingMatcherEditor matcher=new AllOrNothingMatcherEditor();
  FilterList filter_list=new FilterList(base_list,matcher);
  assertEquals(5,filter_list.size());
  matcher.showAll(false);
  assertEquals(0,filter_list.size());
  matcher.showAll(true);
  assertEquals(5,filter_list.size());
}","/** 
 * Test Matchers that fire matchAll() and matchNone() events.
 */
public void testMatchAllOrNothing(){
  EventList base_list=new BasicEventList();
  base_list.add(new Integer(1));
  base_list.add(new Integer(2));
  base_list.add(new Integer(3));
  base_list.add(new Integer(4));
  base_list.add(new Integer(5));
  AllOrNothingMatcherEditor matcher=new AllOrNothingMatcherEditor();
  FilterList filter_list=new FilterList(base_list,matcher);
  filter_list.addListEventListener(new ConsistencyTestList(filter_list,""String_Node_Str""));
  assertEquals(5,filter_list.size());
  matcher.showAll(false);
  assertEquals(0,filter_list.size());
  matcher.showAll(true);
  assertEquals(5,filter_list.size());
}",0.9300911854103344
32703,"/** 
 * Compare this to another   {@link MatchOperation}.
 * @return true if there exists some Object i such that <code>this.matches(i)</code>is <code>false</code> when <code>other.matches(i)<code> is <code>true</code>. Two MatcherOperations can be mutually more strict than each other.
 */
boolean isMoreStrict(MatchOperation other){
  if (other.polarity != this.polarity)   return true;
  if (other.comparator != this.comparator)   return true;
  if (this.threshold == other.threshold) {
    if (this.inclusive && !other.inclusive)     return true;
  }
 else {
    if (this.polarity == 0)     return true;
 else     if (!this.matches(other.threshold))     return true;
  }
  return false;
}","/** 
 * Compare this to another   {@link MatchOperation}.
 * @return true if there exists some Object i such that <code>this.matches(i)</code>is <code>false</code> when <code>other.matches(i)<code> is <code>true</code>. Two MatcherOperations can be mutually more strict than each other.
 */
boolean isMoreStrict(MatchOperation other){
  if (other.polarity != this.polarity)   return true;
  if (other.comparator != this.comparator)   return true;
  if (this.threshold == other.threshold) {
    if (polarity == 0)     return this.inclusive != other.inclusive;
 else     return (!this.inclusive && other.inclusive);
  }
 else {
    if (this.polarity == 0)     return true;
 else     if (!this.matches(other.threshold))     return true;
  }
  return false;
}",0.7532826537664132
32704,"/** 
 * Sets the most recently viewed element to WHITE and returns the white-centric index of the element after the set is complete.
 */
public int setWhite(){
  if (localIndex == -1) {
    throw new NoSuchElementException(""String_Node_Str"");
  }
 else   if (currentNode == null || getIndex() >= barcode.treeSize() || localIndex < currentNode.whiteSpace) {
    return getWhiteIndex();
  }
 else   if (getIndex() != barcode.treeSize() - 1) {
    if (currentNode.rootSize == 1) {
      BarcodeNode affectedNode=currentNode;
      findNextNode();
      affectedNode.setWhite(getIndex(),localIndex,1);
      if (barcode.getRootNode() != null)       barcode.treeSizeChanged();
      if (currentNode.whiteSpace == 0 && currentNode.rootSize == 0)       currentNode=affectedNode;
      return whiteSoFar + localIndex;
    }
 else     if (localIndex == currentNode.whiteSpace) {
      currentNode.setWhite(getIndex(),localIndex,1);
      if (barcode.getRootNode() != null)       barcode.treeSizeChanged();
      return whiteSoFar + localIndex;
    }
 else {
      currentNode.setWhite(getIndex(),localIndex,1);
      if (barcode.getRootNode() != null)       barcode.treeSizeChanged();
      blackSoFar+=currentNode.rootSize;
      whiteSoFar+=currentNode.whiteSpace;
      findNextNode();
      localIndex=0;
      return whiteSoFar;
    }
  }
 else   if (currentNode.rootSize == 1) {
    BarcodeNode affectedNode=currentNode;
    if (currentNode.whiteSpace + 1 == barcode.treeSize()) {
      currentNode=null;
      affectedNode.setWhite(getIndex(),localIndex,1);
      if (barcode.getRootNode() != null)       barcode.treeSizeChanged();
      return localIndex;
    }
 else {
      findPreviousNode();
      int currentLocalIndex=localIndex;
      blackSoFar-=currentNode.rootSize;
      whiteSoFar-=currentNode.whiteSpace;
      localIndex+=currentNode.whiteSpace + currentNode.rootSize;
      affectedNode.setWhite(getIndex(),currentLocalIndex,1);
      if (barcode.getRootNode() != null)       barcode.treeSizeChanged();
      if (currentNode.whiteSpace == 0 && currentNode.rootSize == 0)       currentNode=affectedNode;
      return whiteSoFar + currentNode.whiteSpace;
    }
  }
 else {
    currentNode.setWhite(getIndex(),localIndex,1);
    if (barcode.getRootNode() != null)     barcode.treeSizeChanged();
    return whiteSoFar + localIndex - currentNode.rootSize;
  }
}","/** 
 * Sets the most recently viewed element to WHITE and returns the white-centric index of the element after the set is complete.
 */
public int setWhite(){
  if (localIndex == -1) {
    throw new NoSuchElementException(""String_Node_Str"");
  }
 else   if (currentNode == null || getIndex() >= barcode.treeSize() || localIndex < currentNode.whiteSpace) {
    return getWhiteIndex();
  }
 else   if (getIndex() != barcode.treeSize() - 1) {
    if (currentNode.rootSize == 1) {
      BarcodeNode affectedNode=currentNode;
      findNextNode();
      affectedNode.setWhite(getIndex(),localIndex,1);
      if (barcode.getRootNode() != null)       barcode.treeSizeChanged();
      if (currentNode.whiteSpace == 0 && currentNode.rootSize == 0)       currentNode=affectedNode;
      return whiteSoFar + localIndex;
    }
 else     if (localIndex == currentNode.whiteSpace) {
      currentNode.setWhite(getIndex(),localIndex,1);
      if (barcode.getRootNode() != null)       barcode.treeSizeChanged();
      return whiteSoFar + localIndex;
    }
 else {
      currentNode.setWhite(getIndex(),localIndex,1);
      if (barcode.getRootNode() != null)       barcode.treeSizeChanged();
      blackSoFar+=currentNode.rootSize;
      whiteSoFar+=currentNode.whiteSpace;
      findNextNode();
      localIndex=0;
      return whiteSoFar;
    }
  }
 else   if (currentNode.rootSize == 1) {
    BarcodeNode affectedNode=currentNode;
    if (currentNode.whiteSpace + 1 == barcode.treeSize()) {
      currentNode=null;
      affectedNode.setWhite(getIndex(),localIndex,1);
      if (barcode.getRootNode() != null)       barcode.treeSizeChanged();
      return localIndex;
    }
 else {
      findPreviousNode();
      int currentLocalIndex=localIndex;
      blackSoFar-=currentNode.rootSize;
      whiteSoFar-=currentNode.whiteSpace;
      localIndex+=currentNode.whiteSpace + currentNode.rootSize;
      affectedNode.setWhite(getIndex(),currentLocalIndex,1);
      if (barcode.getRootNode() != null)       barcode.treeSizeChanged();
      if (currentNode.whiteSpace == 0 && currentNode.rootSize == 0)       currentNode=affectedNode;
      return whiteSoFar + localIndex - currentNode.rootSize;
    }
  }
 else {
    currentNode.setWhite(getIndex(),localIndex,1);
    if (barcode.getRootNode() != null)     barcode.treeSizeChanged();
    return whiteSoFar + localIndex - currentNode.rootSize;
  }
}",0.9888444537992002
32705,"/** 
 * Forwards the event. This is a convenience method that does the following: <br>1. beginEvent() <br>2. For all changes in sourceEvent, apply those changes to this <br>3. commitEvent() <p>Note that this method should be preferred to manually forwarding events because it is heavily optimized.
 */
public void forwardEvent(ListEvent listChanges){
  if (eventLevel == 0) {
    atomicChangeBlocks=listChanges.getBlocks();
    reorderMap=listChanges.isReordering() ? listChanges.getReorderMap() : null;
    fireEvent();
  }
 else {
    beginEvent();
    while (listChanges.nextBlock()) {
      addChange(listChanges.getType(),listChanges.getBlockStartIndex(),listChanges.getBlockEndIndex());
    }
    commitEvent();
  }
}","/** 
 * Forwards the event. This is a convenience method that does the following: <br>1. beginEvent() <br>2. For all changes in sourceEvent, apply those changes to this <br>3. commitEvent() <p>Note that this method should be preferred to manually forwarding events because it is heavily optimized. <p>Note that currently this implementation does a best effort to preserve reorderings. This means that a reordering is lost if it is combined with any other ListEvent.
 */
public void forwardEvent(ListEvent listChanges){
  if (eventLevel == 0) {
    atomicChangeBlocks=listChanges.getBlocks();
    reorderMap=listChanges.isReordering() ? listChanges.getReorderMap() : null;
    fireEvent();
  }
 else {
    beginEvent();
    this.reorderMap=null;
    if (atomicChangeBlocks.isEmpty() && listChanges.isReordering()) {
      reorder(listChanges.getReorderMap());
    }
 else {
      while (listChanges.nextBlock()) {
        addChange(listChanges.getType(),listChanges.getBlockStartIndex(),listChanges.getBlockEndIndex());
      }
    }
    commitEvent();
  }
}",0.8123595505617978
32706,"public void listChanged(ListEvent listChanges){
  boolean inserts=false;
  boolean deletes=false;
  boolean wasEmpty=matcherEditorListeners.isEmpty();
  while (listChanges.next()) {
    int index=listChanges.getIndex();
    int type=listChanges.getType();
    if (type == ListEvent.INSERT) {
      MatcherEditor inserted=(MatcherEditor)matcherEditors.get(index);
      matcherEditorListeners.add(new DelegateMatcherEditorListener(inserted));
      inserts=true;
    }
 else     if (type == ListEvent.DELETE) {
      DelegateMatcherEditorListener listener=(DelegateMatcherEditorListener)matcherEditorListeners.remove(index);
      listener.stopListening();
      deletes=true;
    }
 else     if (type == ListEvent.UPDATE) {
      MatcherEditor updated=(MatcherEditor)matcherEditors.get(index);
      DelegateMatcherEditorListener listener=(DelegateMatcherEditorListener)matcherEditorListeners.remove(index);
      listener.setMatcherEditor(updated);
      inserts=true;
      deletes=true;
    }
  }
  boolean isEmpty=matcherEditorListeners.isEmpty();
  if (mode == AND) {
    if (inserts && deletes) {
      fireChanged(rebuildMatcher());
    }
 else     if (inserts) {
      fireConstrained(rebuildMatcher());
    }
 else     if (deletes) {
      if (isEmpty)       fireMatchAll();
 else       fireRelaxed(rebuildMatcher());
    }
  }
 else   if (mode == OR) {
    if (inserts && deletes) {
      fireChanged(rebuildMatcher());
    }
 else     if (inserts) {
      if (wasEmpty)       fireConstrained(rebuildMatcher());
 else       fireRelaxed(rebuildMatcher());
    }
 else     if (deletes) {
      if (isEmpty)       fireMatchAll();
 else       fireConstrained(rebuildMatcher());
    }
  }
 else {
    throw new IllegalStateException();
  }
}","public void listChanged(ListEvent listChanges){
  boolean inserts=false;
  boolean deletes=false;
  boolean wasEmpty=matcherEditorListeners.isEmpty();
  while (listChanges.next()) {
    int index=listChanges.getIndex();
    int type=listChanges.getType();
    if (type == ListEvent.INSERT) {
      MatcherEditor inserted=(MatcherEditor)matcherEditors.get(index);
      matcherEditorListeners.add(new DelegateMatcherEditorListener(inserted));
      inserts=true;
    }
 else     if (type == ListEvent.DELETE) {
      DelegateMatcherEditorListener listener=(DelegateMatcherEditorListener)matcherEditorListeners.remove(index);
      listener.stopListening();
      deletes=true;
    }
 else     if (type == ListEvent.UPDATE) {
      MatcherEditor updated=(MatcherEditor)matcherEditors.get(index);
      DelegateMatcherEditorListener listener=(DelegateMatcherEditorListener)matcherEditorListeners.get(index);
      listener.setMatcherEditor(updated);
      inserts=true;
      deletes=true;
    }
  }
  boolean isEmpty=matcherEditorListeners.isEmpty();
  if (mode == AND) {
    if (inserts && deletes) {
      fireChanged(rebuildMatcher());
    }
 else     if (inserts) {
      fireConstrained(rebuildMatcher());
    }
 else     if (deletes) {
      if (isEmpty)       fireMatchAll();
 else       fireRelaxed(rebuildMatcher());
    }
  }
 else   if (mode == OR) {
    if (inserts && deletes) {
      fireChanged(rebuildMatcher());
    }
 else     if (inserts) {
      if (wasEmpty)       fireConstrained(rebuildMatcher());
 else       fireRelaxed(rebuildMatcher());
    }
 else     if (deletes) {
      if (isEmpty)       fireMatchAll();
 else       fireConstrained(rebuildMatcher());
    }
  }
 else {
    throw new IllegalStateException();
  }
}",0.9974204643164232
32707,"/** 
 * {@inheritDoc} 
 */
public final void removeMatcherEditorListener(MatcherEditorListener listener){
  for (Iterator i=listeners.iterator(); i.hasNext(); ) {
    if (i.next() == listener) {
      i.remove();
      break;
    }
  }
  throw new IllegalStateException(""String_Node_Str"" + listener);
}","/** 
 * {@inheritDoc} 
 */
public final void removeMatcherEditorListener(MatcherEditorListener listener){
  for (Iterator i=listeners.iterator(); i.hasNext(); ) {
    if (i.next() == listener) {
      i.remove();
      return;
    }
  }
  throw new IllegalStateException(""String_Node_Str"" + listener);
}",0.9818181818181818
32708,"/** 
 * {@inheritDoc} 
 */
public void listChanged(ListEvent listChanges){
  updates.beginEvent();
  if (listChanges.isReordering() && size() == 1) {
    int[] reorderMap=listChanges.getReorderMap();
    for (int r=0; r < reorderMap.length; r++) {
      if (reorderMap[r] == startIndex) {
        startIndex=r;
        endIndex=startIndex + 1;
        break;
      }
    }
  }
 else {
    while (listChanges.next()) {
      int changeIndex=listChanges.getIndex();
      int changeType=listChanges.getType();
      if (changeIndex < startIndex || (changeType == ListEvent.INSERT && changeIndex == startIndex)) {
        if (changeType == ListEvent.INSERT) {
          startIndex++;
          endIndex++;
        }
 else         if (changeType == ListEvent.DELETE) {
          startIndex--;
          endIndex--;
        }
      }
 else       if (changeIndex < endIndex) {
        if (changeType == ListEvent.INSERT) {
          endIndex++;
          updates.addInsert(changeIndex - startIndex);
        }
 else         if (changeType == ListEvent.UPDATE) {
          updates.addInsert(changeIndex - startIndex);
        }
 else         if (changeType == ListEvent.DELETE) {
          endIndex--;
          updates.addDelete(changeIndex - startIndex);
        }
      }
 else {
      }
    }
  }
  assert(startIndex <= endIndex);
  updates.commitEvent();
}","/** 
 * {@inheritDoc} 
 */
public void listChanged(ListEvent listChanges){
  updates.beginEvent();
  if (listChanges.isReordering() && size() == 1) {
    int[] reorderMap=listChanges.getReorderMap();
    for (int r=0; r < reorderMap.length; r++) {
      if (reorderMap[r] == startIndex) {
        startIndex=r;
        endIndex=startIndex + 1;
        break;
      }
    }
  }
 else {
    while (listChanges.next()) {
      int changeIndex=listChanges.getIndex();
      int changeType=listChanges.getType();
      if (changeIndex < startIndex || (changeType == ListEvent.INSERT && changeIndex == startIndex)) {
        if (changeType == ListEvent.INSERT) {
          startIndex++;
          endIndex++;
        }
 else         if (changeType == ListEvent.DELETE) {
          startIndex--;
          endIndex--;
        }
      }
 else       if (changeIndex < endIndex) {
        if (changeType == ListEvent.INSERT) {
          endIndex++;
          updates.addInsert(changeIndex - startIndex);
        }
 else         if (changeType == ListEvent.UPDATE) {
          updates.addUpdate(changeIndex - startIndex);
        }
 else         if (changeType == ListEvent.DELETE) {
          endIndex--;
          updates.addDelete(changeIndex - startIndex);
        }
      }
 else {
      }
    }
  }
  assert(startIndex <= endIndex);
  updates.commitEvent();
}",0.9955686853766618
32709,"/** 
 * {@inheritDoc}
 */
public final void relaxed(Matcher source){
  handleFilterRelaxed();
}","/** 
 * {@inheritDoc}
 */
public final void relaxed(Matcher matcher,MatcherSource source){
  handleFilterRelaxed();
}",0.8962264150943396
32710,"/** 
 * Update the matcher used by the list.
 */
public synchronized void setMatcher(Matcher matcher){
  Matcher old_matcher=this.matcher;
  if (old_matcher != null)   old_matcher.removeMatcherListener(this);
  this.matcher=matcher;
  if (matcher != null) {
    matcher.addMatcherListener(this);
    handleFilterChanged();
  }
 else   handleFilterCleared();
}","/** 
 * Update the matcher used by the list.
 */
public synchronized void setMatcher(Matcher matcher){
}",0.4492440604751619
32711,"/** 
 * {@inheritDoc}
 */
public final void cleared(Matcher source){
  handleFilterCleared();
}","/** 
 * {@inheritDoc}
 */
public final void cleared(MatcherSource source){
  handleFilterCleared();
}",0.9693877551020408
32712,"/** 
 * {@inheritDoc}
 */
public final void constrained(Matcher source){
  handleFilterConstrained();
}","/** 
 * {@inheritDoc}
 */
public final void constrained(Matcher matcher,MatcherSource source){
  handleFilterConstrained();
}",0.9035087719298246
32713,"/** 
 * {@inheritDoc}
 */
public final void changed(Matcher source){
  handleFilterChanged();
}","/** 
 * {@inheritDoc}
 */
public final void changed(Matcher matcher,MatcherSource source){
  handleFilterChanged();
}",0.8962264150943396
32714,"/** 
 * Gets the specified block from the current set of change blocks. Note that not blocks may be cleaned up after they are viewed by all monitoring sequences. Such blocks may not be available.
 */
ListEventBlock getBlock(int atomicCount,int block){
  List atomicChange=(List)atomicChanges.get(atomicCount);
  return (ListEventBlock)atomicChange.get(block);
}","/** 
 * Gets the specified block from the current set of change blocks. Note that not blocks may be cleaned up after they are viewed by all monitoring sequences. Such blocks may not be available.
 */
ListEventBlock getBlock(int atomicCount,int block){
  List atomicChange=(List)atomicChanges.get(atomicCount - atomicListOffset);
  return (ListEventBlock)atomicChange.get(block);
}",0.9743589743589745
32715,"/** 
 * Gets the reorder map for the specified atomic change or null if that change is not a reordering.
 */
int[] getReorderMap(int atomicCount){
  return (int[])reorderMaps.get(atomicCount);
}","/** 
 * Gets the reorder map for the specified atomic change or null if that change is not a reordering.
 */
int[] getReorderMap(int atomicCount){
  return (int[])reorderMaps.get(atomicCount - atomicListOffset);
}",0.9533169533169532
32716,"/** 
 * Gets the total number of blocks in the specified atomic change.
 */
int getBlockCount(int atomicCount){
  List atomicChange=(List)atomicChanges.get(atomicCount);
  return atomicChange.size();
}","/** 
 * Gets the total number of blocks in the specified atomic change.
 */
int getBlockCount(int atomicCount){
  List atomicChange=(List)atomicChanges.get(atomicCount - atomicListOffset);
  return atomicChange.size();
}",0.9548693586698336
32717,"/** 
 * Prepares to receive event parts. This needs to be called for each fired event exactly once, even if that event includes some nested events. <p>To prevent two simultaneous atomic changes, the atomicChangeBlocks arraylist is used as a flag. If it is null, there is no change taking place. Otherwise there is a conflicting change and a ConcurrentModificationException is thrown.
 */
private void prepareEvent(){
  atomicChangeBlocks=new ArrayList();
  atomicLatestBlock=null;
  reorderMap=null;
  int oldestRequiredChange=atomicChanges.size();
  for (int e=0; e < listenerEvents.size(); e++) {
    ListEvent listChangeEvent=(ListEvent)listenerEvents.get(e);
    int mark=listChangeEvent.getMark();
    if (mark == -1)     continue;
 else     if (mark < oldestRequiredChange)     oldestRequiredChange=mark;
  }
  for (int i=oldestChange; i < oldestRequiredChange; i++) {
    List recycledChanges=(List)atomicChanges.get(i);
    changePool.addAll(recycledChanges);
    atomicChanges.set(i,null);
  }
  oldestChange=oldestRequiredChange;
}","/** 
 * Prepares to receive event parts. This needs to be called for each fired event exactly once, even if that event includes some nested events. <p>To prevent two simultaneous atomic changes, the atomicChangeBlocks arraylist is used as a flag. If it is null, there is no change taking place. Otherwise there is a conflicting change and a ConcurrentModificationException is thrown.
 */
private void prepareEvent(){
  atomicChangeBlocks=new ArrayList();
  atomicLatestBlock=null;
  reorderMap=null;
  int oldestRequiredChange=atomicChanges.size() + atomicListOffset;
  for (int e=0; e < listenerEvents.size(); e++) {
    ListEvent listChangeEvent=(ListEvent)listenerEvents.get(e);
    int mark=listChangeEvent.getMark();
    if (mark == -1)     continue;
 else     if (mark < oldestRequiredChange)     oldestRequiredChange=mark;
  }
  for (int i=oldestChange; i < oldestRequiredChange; i++) {
    List recycledChanges=(List)atomicChanges.get(0);
    changePool.addAll(recycledChanges);
    atomicChanges.remove(0);
    reorderMaps.remove(0);
    atomicListOffset++;
  }
  oldestChange=oldestRequiredChange;
}",0.9572093023255814
32718,"/** 
 * Gets the total number of atomic changes so far.
 */
int getAtomicCount(){
  return atomicChanges.size();
}","/** 
 * Gets the total number of atomic changes so far.
 */
int getAtomicCount(){
  return atomicChanges.size() + atomicListOffset;
}",0.9230769230769232
32719,"/** 
 * Returns the previous element in the list.
 */
public Object previous(){
  if (nextIndex < 0) {
    if (previous != null) {
      Object result=previous;
      previous=null;
      nextIndex--;
      lastIndex=nextIndex;
      return result;
    }
 else {
      throw new NoSuchElementException(""String_Node_Str"" + nextIndex + ""String_Node_Str""+ source.size());
    }
  }
 else {
    nextIndex--;
    lastIndex=nextIndex;
    Object result=source.get(nextIndex);
    return result;
  }
}","/** 
 * Returns the previous element in the list.
 */
public Object previous(){
  if (nextIndex <= 0) {
    if (previous != null) {
      Object result=previous;
      previous=null;
      nextIndex--;
      lastIndex=nextIndex;
      return result;
    }
 else {
      throw new NoSuchElementException(""String_Node_Str"" + nextIndex + ""String_Node_Str""+ source.size());
    }
  }
 else {
    nextIndex--;
    lastIndex=nextIndex;
    Object result=source.get(nextIndex);
    return result;
  }
}",0.9989888776541962
32720,"/** 
 * Mark the current location in the sequence of list events so that it may be returned to later. Note that this will cause the components of this  {@link ListEvent} to persist in memory until {@link clearMark()} is called.Therefore be sure to call  {@link clearMark()} whenever you call{@link mark()}.
 */
public void mark(){
  atomicCountMark=atomicCount;
}","/** 
 * Mark the current location in the sequence of list events so that it may be returned to later. Note that this will cause the components of this  {@link ListEvent} to persist in memory until {@link #clearMark()} is called.Therefore be sure to call  {@link #clearMark()} whenever you call{@link #mark()}.
 */
public void mark(){
  atomicCountMark=atomicCount;
}",0.9958847736625516
32721,"/** 
 * Binds the contents of a   {@link Combo} component to an {@link EventList}source.  This allows the selection choices in a   {@link Combo} to changedynamically to reflect chances to the source  {@link EventList}.  The  {@link String} values displayed in the {@link Combo} compoment will beformatted using the provided  {@link LabelFormat}.
 * @see LabelFormat
 * @see GlazedLists#beanLabelProvider(String)
 */
public EventComboViewer(EventList source,Combo combo,ILabelProvider labelProvider){
  swtSource=GlazedListsSWT.swtThreadProxyList(source,combo.getDisplay());
  this.combo=combo;
  this.labelProvider=labelProvider;
  for (int i=0; i < source.size(); i++) {
    addRow(i,source.get(i));
  }
  swtSource.addListEventListener(this);
}","/** 
 * Binds the contents of a   {@link Combo} component to an {@link EventList}source.  This allows the selection choices in a   {@link Combo} to changedynamically to reflect chances to the source  {@link EventList}.  The  {@link String} values displayed in the {@link Combo} compoment will beformatted using the provided  {@link ILabelProvider}.
 * @see ILabelProvider
 * @see GlazedListsSWT#beanLabelProvider(String)
 */
public EventComboViewer(EventList source,Combo combo,ILabelProvider labelProvider){
  swtSource=GlazedListsSWT.swtThreadProxyList(source,combo.getDisplay());
  this.combo=combo;
  this.labelProvider=labelProvider;
  for (int i=0; i < source.size(); i++) {
    addRow(i,source.get(i));
  }
  swtSource.addListEventListener(this);
}",0.7808127914723517
32722,"/** 
 * Creates a new List that displays and responds to changes in source. List elements are formatted using the provided   {@link LabelFormat}.
 */
public EventListViewer(EventList source,List list,ILabelProvider labelProvider){
  swtSource=GlazedListsSWT.swtThreadProxyList(source,list.getDisplay());
  this.list=list;
  this.labelProvider=labelProvider;
  selectionList=new SelectionList(swtSource,this);
  populateList();
  swtSource.addListEventListener(this);
}","/** 
 * Creates a new List that displays and responds to changes in source. List elements are formatted using the provided   {@link ILabelProvider}.
 */
public EventListViewer(EventList source,List list,ILabelProvider labelProvider){
  swtSource=GlazedListsSWT.swtThreadProxyList(source,list.getDisplay());
  this.list=list;
  this.labelProvider=labelProvider;
  selectionList=new SelectionList(swtSource,this);
  populateList();
  swtSource.addListEventListener(this);
}",0.9733759318423856
32723,"/** 
 * Tests that BeanTableFormat works as a TableFormat.
 */
public void testTableFormat(){
  assertEquals(4,footballFormat.getColumnCount());
  assertEquals(""String_Node_Str"",footballFormat.getColumnName(0));
  assertEquals(""String_Node_Str"",footballFormat.getColumnName(1));
  assertEquals(""String_Node_Str"",footballFormat.getColumnName(2));
  assertEquals(""String_Node_Str"",footballFormat.getColumnName(3));
  assertEquals(""String_Node_Str"",footballFormat.getColumnValue(riders,0));
  assertEquals(""String_Node_Str"",footballFormat.getColumnValue(riders,1));
  assertEquals(Color.green,footballFormat.getColumnValue(riders,2));
  assertEquals(Color.white,footballFormat.getColumnValue(riders,3));
  assertEquals(""String_Node_Str"",footballFormat.getColumnValue(ticats,0));
  assertEquals(""String_Node_Str"",footballFormat.getColumnValue(ticats,1));
  assertEquals(Color.yellow,footballFormat.getColumnValue(ticats,2));
  assertEquals(Color.black,footballFormat.getColumnValue(ticats,3));
}","/** 
 * Tests that BeanTableFormat works as a TableFormat.
 */
public void testTableFormat(){
  assertEquals(6,footballFormat.getColumnCount());
  assertEquals(""String_Node_Str"",footballFormat.getColumnName(0));
  assertEquals(""String_Node_Str"",footballFormat.getColumnName(1));
  assertEquals(""String_Node_Str"",footballFormat.getColumnName(2));
  assertEquals(""String_Node_Str"",footballFormat.getColumnName(3));
  assertEquals(""String_Node_Str"",footballFormat.getColumnValue(riders,0));
  assertEquals(""String_Node_Str"",footballFormat.getColumnValue(riders,1));
  assertEquals(Color.green,footballFormat.getColumnValue(riders,2));
  assertEquals(Color.white,footballFormat.getColumnValue(riders,3));
  assertEquals(""String_Node_Str"",footballFormat.getColumnValue(ticats,0));
  assertEquals(""String_Node_Str"",footballFormat.getColumnValue(ticats,1));
  assertEquals(Color.yellow,footballFormat.getColumnValue(ticats,2));
  assertEquals(Color.black,footballFormat.getColumnValue(ticats,3));
}",0.9989909182643796
32724,"/** 
 * Tests that BeanTableFormat works as an AdvancedTableFormat.
 */
public void testAdvancedTableFormat(){
  AdvancedTableFormat emptyAdvancedFootballFormat=(AdvancedTableFormat)footballFormat;
  assertEquals(Object.class,emptyAdvancedFootballFormat.getColumnClass(0));
  assertEquals(Object.class,emptyAdvancedFootballFormat.getColumnClass(1));
  assertEquals(Object.class,emptyAdvancedFootballFormat.getColumnClass(2));
  assertEquals(Object.class,emptyAdvancedFootballFormat.getColumnClass(3));
  assertEquals(GlazedLists.comparableComparator(),emptyAdvancedFootballFormat.getColumnComparator(0));
  assertEquals(GlazedLists.comparableComparator(),emptyAdvancedFootballFormat.getColumnComparator(1));
  assertEquals(GlazedLists.comparableComparator(),emptyAdvancedFootballFormat.getColumnComparator(2));
  assertEquals(GlazedLists.comparableComparator(),emptyAdvancedFootballFormat.getColumnComparator(3));
  AdvancedTableFormat fullAdvancedFootballFormat=(AdvancedTableFormat)classedFootballFormat;
  assertEquals(String.class,fullAdvancedFootballFormat.getColumnClass(0));
  assertEquals(String.class,fullAdvancedFootballFormat.getColumnClass(1));
  assertEquals(Color.class,fullAdvancedFootballFormat.getColumnClass(2));
  assertEquals(Color.class,fullAdvancedFootballFormat.getColumnClass(3));
  assertEquals(GlazedLists.comparableComparator(),fullAdvancedFootballFormat.getColumnComparator(0));
  assertEquals(GlazedLists.comparableComparator(),fullAdvancedFootballFormat.getColumnComparator(1));
  assertEquals(null,fullAdvancedFootballFormat.getColumnComparator(2));
  assertEquals(null,fullAdvancedFootballFormat.getColumnComparator(3));
}","/** 
 * Tests that BeanTableFormat works as an AdvancedTableFormat.
 */
public void testAdvancedTableFormat(){
  AdvancedTableFormat emptyAdvancedFootballFormat=(AdvancedTableFormat)footballFormat;
  assertEquals(Object.class,emptyAdvancedFootballFormat.getColumnClass(0));
  assertEquals(Object.class,emptyAdvancedFootballFormat.getColumnClass(1));
  assertEquals(Object.class,emptyAdvancedFootballFormat.getColumnClass(2));
  assertEquals(Object.class,emptyAdvancedFootballFormat.getColumnClass(3));
  assertEquals(Object.class,emptyAdvancedFootballFormat.getColumnClass(4));
  assertEquals(Object.class,emptyAdvancedFootballFormat.getColumnClass(5));
  assertEquals(GlazedLists.comparableComparator(),emptyAdvancedFootballFormat.getColumnComparator(0));
  assertEquals(GlazedLists.comparableComparator(),emptyAdvancedFootballFormat.getColumnComparator(1));
  assertEquals(GlazedLists.comparableComparator(),emptyAdvancedFootballFormat.getColumnComparator(2));
  assertEquals(GlazedLists.comparableComparator(),emptyAdvancedFootballFormat.getColumnComparator(3));
  assertEquals(GlazedLists.comparableComparator(),emptyAdvancedFootballFormat.getColumnComparator(4));
  assertEquals(GlazedLists.comparableComparator(),emptyAdvancedFootballFormat.getColumnComparator(5));
  AdvancedTableFormat fullAdvancedFootballFormat=(AdvancedTableFormat)classedFootballFormat;
  assertEquals(String.class,fullAdvancedFootballFormat.getColumnClass(0));
  assertEquals(String.class,fullAdvancedFootballFormat.getColumnClass(1));
  assertEquals(Color.class,fullAdvancedFootballFormat.getColumnClass(2));
  assertEquals(Color.class,fullAdvancedFootballFormat.getColumnClass(3));
  assertEquals(Boolean.class,fullAdvancedFootballFormat.getColumnClass(4));
  assertEquals(Integer.class,fullAdvancedFootballFormat.getColumnClass(5));
  assertEquals(GlazedLists.comparableComparator(),fullAdvancedFootballFormat.getColumnComparator(0));
  assertEquals(GlazedLists.comparableComparator(),fullAdvancedFootballFormat.getColumnComparator(1));
  assertEquals(null,fullAdvancedFootballFormat.getColumnComparator(2));
  assertEquals(null,fullAdvancedFootballFormat.getColumnComparator(3));
  assertEquals(null,fullAdvancedFootballFormat.getColumnComparator(4));
  assertEquals(GlazedLists.comparableComparator(),fullAdvancedFootballFormat.getColumnComparator(5));
}",0.7820641282565131
32725,"/** 
 * Prepare for the test.
 */
public void setUp(){
  String[] propertyNames=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  String[] columnNames=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  boolean[] writable=new boolean[]{false,true,false,false};
  footballFormat=GlazedLists.tableFormat(propertyNames,columnNames,writable);
  classedFootballFormat=GlazedLists.tableFormat(FootballTeam.class,propertyNames,columnNames,writable);
}","/** 
 * Prepare for the test.
 */
public void setUp(){
  String[] propertyNames=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  String[] columnNames=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  boolean[] writable=new boolean[]{false,true,false,false,false,false};
  footballFormat=GlazedLists.tableFormat(propertyNames,columnNames,writable);
  classedFootballFormat=GlazedLists.tableFormat(FootballTeam.class,propertyNames,columnNames,writable);
}",0.9252669039145908
32726,"/** 
 * Compares the specified objects by the JavaBean property.
 */
public int compare(Object alpha,Object beta){
  Object alphaProperty=null;
  if (alpha != null)   alphaProperty=beanProperty.get(alpha);
  Object betaProperty=null;
  if (beta != null)   alphaProperty=beanProperty.get(beta);
  return propertyComparator.compare(alphaProperty,betaProperty);
}","/** 
 * Compares the specified objects by the JavaBean property.
 */
public int compare(Object alpha,Object beta){
  Object alphaProperty=null;
  if (alpha != null)   alphaProperty=beanProperty.get(alpha);
  Object betaProperty=null;
  if (beta != null)   betaProperty=beanProperty.get(beta);
  return propertyComparator.compare(alphaProperty,betaProperty);
}",0.9902642559109874
32727,"/** 
 * {@inheritDoc} 
 */
public void listChanged(ListEvent listChanges){
  if (listChanges.isReordering())   return;
  boolean constrained=false;
  boolean relaxed=false;
  while (listChanges.next()) {
    int type=listChanges.getType();
    if (type == ListEvent.UPDATE || type == ListEvent.DELETE)     relaxed=true;
    if (type == ListEvent.UPDATE || type == ListEvent.INSERT)     constrained=true;
  }
  getReadWriteLock().writeLock().lock();
  try {
    if (contrained && relaxed)     handleFilterChanged();
 else     if (relaxed)     handleFilterRelaxed();
 else     if (constrained)     handleFilterConstrained();
  }
  finally {
    getReadWriteLock().writeLock().unlock();
  }
}","/** 
 * {@inheritDoc} 
 */
public void listChanged(ListEvent listChanges){
  if (listChanges.isReordering()) {
    listChanges.getReorderMap();
    return;
  }
  boolean constrained=false;
  boolean relaxed=false;
  while (listChanges.next()) {
    int type=listChanges.getType();
    if (type == ListEvent.UPDATE || type == ListEvent.DELETE)     relaxed=true;
    if (type == ListEvent.UPDATE || type == ListEvent.INSERT)     constrained=true;
  }
  getReadWriteLock().writeLock().lock();
  try {
    if (contrained && relaxed)     handleFilterChanged();
 else     if (relaxed)     handleFilterRelaxed();
 else     if (constrained)     handleFilterConstrained();
  }
  finally {
    getReadWriteLock().writeLock().unlock();
  }
}",0.971106412966878
32728,"/** 
 * {@inheritDoc} 
 */
public void listChanged(ListEvent listChanges){
  int stateMask=0;
  final int FILTER_RELAXED=1;
  final int FILTER_CONSTRAINED=2;
  final int FILTER_CHANGED=3;
  while (listChanges.next()) {
    int type=listChanges.getType();
    if (listChanges.isReordering()) {
    }
 else     if (type == ListEvent.UPDATE) {
      stateMask=FILTER_CHANGED;
    }
 else     if (type == ListEvent.DELETE) {
      stateMask=stateMask | FILTER_RELAXED;
    }
 else     if (type == ListEvent.INSERT) {
      stateMask=stateMask | FILTER_CONSTRAINED;
    }
  }
  if ((stateMask & FILTER_CHANGED) != 0) {
    handleFilterChanged();
  }
 else   if ((stateMask & FILTER_RELAXED) != 0) {
    handleFilterRelaxed();
  }
 else   if ((stateMask & FILTER_CONSTRAINED) != 0) {
    handleFilterConstrained();
  }
}","/** 
 * {@inheritDoc} 
 */
public void listChanged(ListEvent listChanges){
  int stateMask=0;
  final int FILTER_RELAXED=1;
  final int FILTER_CONSTRAINED=2;
  final int FILTER_CHANGED=3;
  while (listChanges.next()) {
    int type=listChanges.getType();
    if (listChanges.isReordering()) {
    }
 else     if (type == ListEvent.UPDATE) {
      stateMask=FILTER_CHANGED;
    }
 else     if (type == ListEvent.DELETE) {
      stateMask=stateMask | FILTER_RELAXED;
    }
 else     if (type == ListEvent.INSERT) {
      stateMask=stateMask | FILTER_CONSTRAINED;
    }
  }
  if (stateMask == 0)   return;
  getReadWriteLock().writeLock().lock();
  try {
    if ((stateMask & FILTER_CHANGED) != 0) {
      handleFilterChanged();
    }
 else     if ((stateMask & FILTER_RELAXED) != 0) {
      handleFilterRelaxed();
    }
 else     if ((stateMask & FILTER_CONSTRAINED) != 0) {
      handleFilterConstrained();
    }
  }
  finally {
    getReadWriteLock().writeLock().unlock();
  }
}",0.8895089285714286
32729,"/** 
 * Notifies this SelectionList about changes to its underlying list store. <p>This changes the flag list. Changes to the source list may cause simultaneous changes to the corresponding selection list.
 */
public void listChanged(ListEvent listChanges){
  ((InternalReadWriteLock)eventList.getReadWriteLock()).internalLock().lock();
  try {
    int minSelectionIndexBefore=getMinSelectionIndex();
    int maxSelectionIndexBefore=getMaxSelectionIndex();
    updates.beginEvent();
    if (listChanges.isReordering()) {
      int[] sourceReorderMap=listChanges.getReorderMap();
      int[] selectReorderMap=new int[flagList.blackSize()];
      Barcode previousFlagList=flagList;
      flagList=new Barcode();
      for (int c=0; c < sourceReorderMap.length; c++) {
        Object flag=previousFlagList.get(sourceReorderMap[c]);
        boolean wasSelected=(flag != Barcode.WHITE);
        flagList.add(c,flag,1);
        if (wasSelected) {
          int previousIndex=previousFlagList.getBlackIndex(sourceReorderMap[c]);
          int currentIndex=flagList.getBlackIndex(c);
          selectReorderMap[currentIndex]=previousIndex;
        }
      }
      anchorSelectionIndex=-1;
      leadSelectionIndex=-1;
      updates.reorder(selectReorderMap);
    }
 else {
      while (listChanges.next()) {
        int index=listChanges.getIndex();
        int changeType=listChanges.getType();
        int previousSelectionIndex=flagList.getBlackIndex(index);
        boolean previouslySelected=previousSelectionIndex != -1;
        if (changeType == ListEvent.DELETE) {
          flagList.remove(index,1);
          if (previouslySelected) {
            updates.addDelete(previousSelectionIndex);
          }
        }
 else         if (changeType == ListEvent.INSERT) {
          if (previouslySelected) {
            if (selectionMode == SINGLE_INTERVAL_SELECTION || selectionMode == MULTIPLE_INTERVAL_SELECTION) {
              flagList.addBlack(index,1);
              updates.addInsert(previousSelectionIndex);
            }
 else {
              flagList.addWhite(index,1);
            }
          }
 else {
            flagList.addWhite(index,1);
          }
        }
 else         if (changeType == ListEvent.UPDATE) {
          if (previouslySelected) {
            updates.addUpdate(previousSelectionIndex);
          }
        }
        anchorSelectionIndex=adjustIndex(anchorSelectionIndex,changeType,index);
        leadSelectionIndex=adjustIndex(leadSelectionIndex,changeType,index);
      }
    }
    updates.commitEvent();
    if (minSelectionIndexBefore != 0 && maxSelectionIndexBefore != 0) {
      int minSelectionIndexAfter=getMinSelectionIndex();
      int maxSelectionIndexAfter=getMaxSelectionIndex();
      int changeStart=minSelectionIndexBefore;
      int changeFinish=maxSelectionIndexBefore;
      if (minSelectionIndexAfter != -1 && minSelectionIndexAfter < changeStart)       changeStart=minSelectionIndexAfter;
      if (maxSelectionIndexAfter != -1 && maxSelectionIndexAfter > changeFinish)       changeFinish=maxSelectionIndexAfter;
      valueIsAdjusting=false;
      fireSelectionChanged(changeStart,changeFinish);
    }
  }
  finally {
    ((InternalReadWriteLock)eventList.getReadWriteLock()).internalLock().unlock();
  }
}","/** 
 * Notifies this SelectionList about changes to its underlying list store. <p>This changes the flag list. Changes to the source list may cause simultaneous changes to the corresponding selection list.
 */
public void listChanged(ListEvent listChanges){
  ((InternalReadWriteLock)eventList.getReadWriteLock()).internalLock().lock();
  try {
    int minSelectionIndexBefore=getMinSelectionIndex();
    int maxSelectionIndexBefore=getMaxSelectionIndex();
    updates.beginEvent();
    if (listChanges.isReordering()) {
      int[] sourceReorderMap=listChanges.getReorderMap();
      int[] selectReorderMap=new int[flagList.blackSize()];
      Barcode previousFlagList=flagList;
      flagList=new Barcode();
      for (int c=0; c < sourceReorderMap.length; c++) {
        Object flag=previousFlagList.get(sourceReorderMap[c]);
        boolean wasSelected=(flag != Barcode.WHITE);
        flagList.add(c,flag,1);
        if (wasSelected) {
          int previousIndex=previousFlagList.getBlackIndex(sourceReorderMap[c]);
          int currentIndex=flagList.getBlackIndex(c);
          selectReorderMap[currentIndex]=previousIndex;
        }
      }
      anchorSelectionIndex=-1;
      leadSelectionIndex=-1;
      updates.reorder(selectReorderMap);
    }
 else {
      while (listChanges.next()) {
        int index=listChanges.getIndex();
        int changeType=listChanges.getType();
        int previousSelectionIndex=flagList.getBlackIndex(index);
        boolean previouslySelected=previousSelectionIndex != -1;
        if (changeType == ListEvent.DELETE) {
          flagList.remove(index,1);
          if (previouslySelected) {
            updates.addDelete(previousSelectionIndex);
          }
        }
 else         if (changeType == ListEvent.INSERT) {
          if (previouslySelected) {
            if (selectionMode == SINGLE_INTERVAL_SELECTION || selectionMode == MULTIPLE_INTERVAL_SELECTION) {
              flagList.addBlack(index,1);
              updates.addInsert(previousSelectionIndex);
            }
 else {
              flagList.addWhite(index,1);
            }
          }
 else {
            flagList.addWhite(index,1);
          }
        }
 else         if (changeType == ListEvent.UPDATE) {
          if (previouslySelected) {
            updates.addUpdate(previousSelectionIndex);
          }
        }
        anchorSelectionIndex=adjustIndex(anchorSelectionIndex,changeType,index);
        leadSelectionIndex=adjustIndex(leadSelectionIndex,changeType,index);
      }
    }
    updates.commitEvent();
    if (minSelectionIndexBefore != -1 && maxSelectionIndexBefore != -1) {
      int minSelectionIndexAfter=getMinSelectionIndex();
      int maxSelectionIndexAfter=getMaxSelectionIndex();
      int changeStart=minSelectionIndexBefore;
      int changeFinish=maxSelectionIndexBefore;
      if (minSelectionIndexAfter != -1 && minSelectionIndexAfter < changeStart)       changeStart=minSelectionIndexAfter;
      if (maxSelectionIndexAfter != -1 && maxSelectionIndexAfter > changeFinish)       changeFinish=maxSelectionIndexAfter;
      valueIsAdjusting=false;
      fireSelectionChanged(changeStart,changeFinish);
    }
  }
  finally {
    ((InternalReadWriteLock)eventList.getReadWriteLock()).internalLock().unlock();
  }
}",0.92262818544673
32730,"/** 
 * {@inheritDoc} 
 */
public void listChanged(ListEvent listChanges){
  int stateMask=0;
  final int FILTER_RELAXED=1;
  final int FILTER_CONSTRAINED=2;
  final int FILTER_CHANGED=3;
  while (listChanges.next()) {
    int type=listChanges.getType();
    if (listChanges.isReordering()) {
    }
 else     if (type == ListEvent.UPDATE) {
      stateMask=FILTER_CHANGED;
    }
 else     if (type == ListEvent.DELETE) {
      stateMask=stateMask | FILTER_RELAXED;
    }
 else     if (type == ListEvent.INSERT) {
      stateMask=stateMask | FILTER_CONSTRAINED;
    }
  }
  if (stateMask == 0)   return;
  getReadWriteLock().writeLock().lock();
  try {
    if ((stateMask & FILTER_CHANGED) != 0) {
      handleFilterChanged();
    }
 else     if ((stateMask & FILTER_RELAXED) != 0) {
      handleFilterRelaxed();
    }
 else     if ((stateMask & FILTER_CONSTRAINED) != 0) {
      handleFilterConstrained();
    }
  }
  finally {
    getReadWriteLock().writeLock().unlock();
  }
}","/** 
 * {@inheritDoc} 
 */
public void listChanged(ListEvent listChanges){
  if (listChanges.isReordering())   return;
  boolean constrained=false;
  boolean relaxed=false;
  while (listChanges.next()) {
    int type=listChanges.getType();
    if (type == ListEvent.UPDATE || type == ListEvent.DELETE)     relaxed=true;
    if (type == ListEvent.UPDATE || type == ListEvent.INSERT)     constrained=true;
  }
  getReadWriteLock().writeLock().lock();
  try {
    if (contrained && relaxed)     handleFilterChanged();
 else     if (relaxed)     handleFilterRelaxed();
 else     if (constrained)     handleFilterConstrained();
  }
  finally {
    getReadWriteLock().writeLock().unlock();
  }
}",0.1919616076784643
32731,"/** 
 * Handle a column being clicked by sorting that column.
 */
protected void columnClicked(int column,int clicks){
  ColumnClickTracker currentTracker=columnClickTrackers[column];
  if (clicks == 2) {
    for (Iterator i=recentlyClickedColumns.iterator(); i.hasNext(); ) {
      ColumnClickTracker columnClickTracker=(ColumnClickTracker)i.next();
      columnClickTracker.resetClickCount();
    }
    primaryColumn=-1;
    recentlyClickedColumns.clear();
  }
 else   if (!multipleColumnSort) {
    for (Iterator i=recentlyClickedColumns.iterator(); i.hasNext(); ) {
      ColumnClickTracker columnClickTracker=(ColumnClickTracker)i.next();
      if (columnClickTracker != currentTracker) {
        columnClickTracker.resetClickCount();
      }
    }
    primaryColumn=-1;
    recentlyClickedColumns.clear();
  }
  if (!currentTracker.getComparators().isEmpty()) {
    currentTracker.addClick();
    if (recentlyClickedColumns.isEmpty()) {
      recentlyClickedColumns.add(currentTracker);
      primaryColumn=column;
    }
 else     if (!recentlyClickedColumns.contains(currentTracker)) {
      recentlyClickedColumns.add(currentTracker);
    }
  }
  rebuildComparator();
}","/** 
 * Handle a column being clicked by sorting that column.
 */
protected void columnClicked(int column,int clicks){
  ColumnClickTracker currentTracker=columnClickTrackers[column];
  if (currentTracker.getComparators().isEmpty())   return;
  if (clicks == 2) {
    for (Iterator i=recentlyClickedColumns.iterator(); i.hasNext(); ) {
      ColumnClickTracker columnClickTracker=(ColumnClickTracker)i.next();
      columnClickTracker.resetClickCount();
    }
    primaryColumn=-1;
    recentlyClickedColumns.clear();
  }
 else   if (!multipleColumnSort) {
    for (Iterator i=recentlyClickedColumns.iterator(); i.hasNext(); ) {
      ColumnClickTracker columnClickTracker=(ColumnClickTracker)i.next();
      if (columnClickTracker != currentTracker) {
        columnClickTracker.resetClickCount();
      }
    }
    primaryColumn=-1;
    recentlyClickedColumns.clear();
  }
  currentTracker.addClick();
  if (recentlyClickedColumns.isEmpty()) {
    recentlyClickedColumns.add(currentTracker);
    primaryColumn=column;
  }
 else   if (!recentlyClickedColumns.contains(currentTracker)) {
    recentlyClickedColumns.add(currentTracker);
  }
  rebuildComparator();
}",0.7125160187953866
32732,"/** 
 * {@inheritDoc} 
 */
public int lastIndexOf(Object object){
  if (comparator != null)   return sorted.lastIndexOf(object);
 else   return source.indexOf(object);
}","/** 
 * {@inheritDoc} 
 */
public int lastIndexOf(Object object){
  if (comparator != null)   return sorted.lastIndexOf(object);
 else   return source.lastIndexOf(object);
}",0.9824561403508772
32733,"/** 
 * {@inheritDoc} 
 */
public boolean removeAll(Collection collection){
  boolean changed=false;
  updates.beginEvent();
  for (Iterator i=collection.iterator(); i.hasNext(); ) {
    int index=-1;
    if ((index=data.indexOf(i.next())) != -1) {
      updates.addDelete(index);
      data.remove(index);
      changed=true;
    }
  }
  updates.commitEvent();
  return changed;
}","/** 
 * {@inheritDoc} 
 */
public boolean removeAll(Collection collection){
  boolean changed=false;
  updates.beginEvent();
  for (Iterator i=collection.iterator(); i.hasNext(); ) {
    Object value=i.next();
    int index=-1;
    while ((index=indexOf(value)) != -1) {
      updates.addDelete(index);
      data.remove(index);
      changed=true;
    }
  }
  updates.commitEvent();
  return changed;
}",0.9107142857142856
32734,"/** 
 * {@inheritDoc} 
 */
public int lastIndexOf(Object object){
  return sorted.lastIndexOf(object);
}","/** 
 * {@inheritDoc} 
 */
public int lastIndexOf(Object object){
  if (comparator != null)   return sorted.lastIndexOf(object);
 else   return source.indexOf(object);
}",0.7619047619047619
32735,"/** 
 * Returns the index in this list of the first occurrence of the specified element, or the index where that element would be in the list if it were inserted.
 * @return the index in this list of the first occurrence of the specifiedelement, or the index where that element would be in the list if it were inserted. This will return a value in <tt>[0, size()]</tt>, inclusive.
 */
public int indexOfSimulated(Object object){
  return sorted.indexOfSimulated(object);
}","/** 
 * Returns the index in this list of the first occurrence of the specified element, or the index where that element would be in the list if it were inserted.
 * @return the index in this list of the first occurrence of the specifiedelement, or the index where that element would be in the list if it were inserted. This will return a value in <tt>[0, size()]</tt>, inclusive.
 */
public int indexOfSimulated(Object object){
  if (comparator != null)   return sorted.indexOfSimulated(object);
 else   return size();
}",0.9506545820745216
32736,"/** 
 * {@inheritDoc} 
 */
public int indexOf(Object object){
  return sorted.indexOf(object);
}","/** 
 * {@inheritDoc} 
 */
public int indexOf(Object object){
  if (comparator != null)   return sorted.indexOf(object);
 else   return source.indexOf(object);
}",0.7470817120622568
32737,"/** 
 * {@inheritDoc} 
 */
public boolean removeAll(Collection values){
  if (!isWritable())   throw new IllegalStateException(""String_Node_Str"");
  updates.beginEvent(true);
  boolean overallChanged=false;
  for (Iterator i=values.iterator(); i.hasNext(); ) {
    boolean removeChanged=remove(i.next());
    if (removeChanged)     overallChanged=true;
  }
  updates.commitEvent();
  return overallChanged;
}","/** 
 * {@inheritDoc} 
 */
public boolean removeAll(Collection collection){
  if (!isWritable())   throw new IllegalStateException(""String_Node_Str"");
  boolean changed=false;
  updates.beginEvent(true);
  for (Iterator i=collection.iterator(); i.hasNext(); ) {
    Object value=i.next();
    int index=-1;
    while ((index=indexOf(value)) != -1) {
      remove(index);
      changed=true;
    }
  }
  updates.commitEvent();
  return changed;
}",0.492379835873388
32738,"/** 
 * Fires the current event. This needs to be called for each fired event exactly once, even if that event includes nested events.
 */
private void fireEvent(){
  if (atomicChangeBlocks.size() == 0) {
    atomicChangeBlocks=null;
    atomicLatestBlock=null;
    reorderMap=null;
    allowContradictingEvents=false;
    return;
  }
  ListEventBlock.sortListEventBlocks(atomicChangeBlocks,allowContradictingEvents);
  atomicChanges.add(atomicChangeBlocks);
  if (reorderMap != null && atomicChangeBlocks.size() == 2) {
    reorderMaps.add(reorderMap);
  }
 else {
    reorderMaps.add(null);
  }
  try {
    List listenersToNotify=new ArrayList();
    List listenerEventsToNotify=new ArrayList();
    listenersToNotify.addAll(listeners);
    listenerEventsToNotify.addAll(listenerEvents);
    publisher.fireEvent(sourceList,listenersToNotify,listenerEventsToNotify);
  }
  finally {
    atomicChangeBlocks=null;
    atomicLatestBlock=null;
    reorderMap=null;
    allowContradictingEvents=false;
  }
}","/** 
 * Fires the current event. This needs to be called for each fired event exactly once, even if that event includes nested events.
 */
private void fireEvent(){
  ListEventBlock.sortListEventBlocks(atomicChangeBlocks,allowContradictingEvents);
  if (atomicChangeBlocks.size() == 0) {
    atomicChangeBlocks=null;
    atomicLatestBlock=null;
    reorderMap=null;
    allowContradictingEvents=false;
    return;
  }
  atomicChanges.add(atomicChangeBlocks);
  if (reorderMap != null && atomicChangeBlocks.size() == 2) {
    reorderMaps.add(reorderMap);
  }
 else {
    reorderMaps.add(null);
  }
  try {
    List listenersToNotify=new ArrayList();
    List listenerEventsToNotify=new ArrayList();
    listenersToNotify.addAll(listeners);
    listenerEventsToNotify.addAll(listenerEvents);
    publisher.fireEvent(sourceList,listenersToNotify,listenerEventsToNotify);
  }
  finally {
    atomicChangeBlocks=null;
    atomicLatestBlock=null;
    reorderMap=null;
    allowContradictingEvents=false;
  }
}",0.8245264207377866
32739,"/** 
 * Sorts the blocks of the specified list of changes. This ensures that the user iterating the list of change blocks can view changes in increasing order. This ensures that indicies will not be shifted. <p>This performs a bubble sort, swapping adjacent change blocks if they should be swapped. The bubble sort is used instead of a more efficient sort because it is necessary to adjust offsets when swapping and therefore it is preferred to only swap adjacent elements. Bubble sort is a sort that only swaps adjacent elements.
 * @param allowContradictingEvents whether a pair of contradicting events shallbe allowed. This would typically be an insert that is wiped away with a delete, an update that is wiped away with a delete, or an insert that is later updated.
 */
static void sortListEventBlocks(List changes,boolean allowContradictingEvents){
  while (true) {
    int swapCount=0;
    int j=0;
    while (j < changes.size() - 1) {
      ListEventBlock first=(ListEventBlock)changes.get(j);
      ListEventBlock second=(ListEventBlock)changes.get(j + 1);
      if (requiresSplit(first,second)) {
        ListEventBlock third=split(first,second);
        changes.add(j + 2,third);
      }
 else       if (canBeCombined(first,second)) {
        combine(first,second);
        changes.remove(j + 1);
        if (j > 0)         j--;
      }
 else       if (requiresSwap(first,second)) {
        swapCount++;
        shift(first,second);
        changes.set(j,second);
        changes.set(j + 1,first);
        j++;
      }
 else {
        j++;
      }
    }
    if (swapCount == 0)     break;
  }
}","/** 
 * Sorts the blocks of the specified list of changes. This ensures that the user iterating the list of change blocks can view changes in increasing order. This ensures that indicies will not be shifted. <p>This performs a bubble sort, swapping adjacent change blocks if they should be swapped. The bubble sort is used instead of a more efficient sort because it is necessary to adjust offsets when swapping and therefore it is preferred to only swap adjacent elements. Bubble sort is a sort that only swaps adjacent elements.
 * @param allowContradictingEvents whether a pair of contradicting events shallbe allowed. This would typically be an insert that is wiped away with a delete, an update that is wiped away with a delete, or an insert that is later updated.
 */
static void sortListEventBlocks(List changes,boolean allowContradictingEvents){
  while (true) {
    int swapCount=0;
    int j=0;
    while (j < changes.size() - 1) {
      ListEventBlock first=(ListEventBlock)changes.get(j);
      ListEventBlock second=(ListEventBlock)changes.get(j + 1);
      if (blocksContradict(first,second)) {
        if (!allowContradictingEvents)         throw new IllegalStateException(""String_Node_Str"" + first + ""String_Node_Str""+ second+ ""String_Node_Str"");
        simplifyContradiction(changes.subList(j,j + 2));
      }
 else       if (requiresSplit(first,second)) {
        ListEventBlock third=split(first,second);
        changes.add(j + 2,third);
      }
 else       if (canBeCombined(first,second)) {
        combine(first,second);
        changes.remove(j + 1);
        if (j > 0)         j--;
      }
 else       if (requiresSwap(first,second)) {
        swapCount++;
        shift(first,second);
        changes.set(j,second);
        changes.set(j + 1,first);
        j++;
      }
 else {
        j++;
      }
    }
    if (swapCount == 0)     break;
  }
}",0.922634454989934
32740,"/** 
 * When there is a sequence of list changes, sometimes these changes are not created in increasing order. Users usually need to receive changes in increasing order, so it becomes necessary to reorder list change blocks.
 * @return true if two adjacent blocks are out of order.
 */
private static boolean requiresSwap(ListEventBlock first,ListEventBlock second){
  if (first.type == ListEvent.INSERT && second.type != ListEvent.INSERT) {
    if (first.endIndex >= second.startIndex && first.startIndex <= second.endIndex) {
      throw new IllegalStateException(""String_Node_Str"" + first + ""String_Node_Str""+ second+ ""String_Node_Str"");
    }
  }
  if (second.type == ListEvent.INSERT && first.type != ListEvent.DELETE) {
    return second.startIndex <= first.startIndex;
  }
 else {
    return second.startIndex < first.startIndex;
  }
}","/** 
 * When there is a sequence of list changes, sometimes these changes are not created in increasing order. Users usually need to receive changes in increasing order, so it becomes necessary to reorder list change blocks.
 * @return true if two adjacent blocks are out of order.
 */
private static boolean requiresSwap(ListEventBlock first,ListEventBlock second){
  if (second.type == ListEvent.INSERT && first.type != ListEvent.DELETE) {
    return second.startIndex <= first.startIndex;
  }
 else {
    return second.startIndex < first.startIndex;
  }
}",0.7557142857142857
32741,"/** 
 * Validates that complex contradicting events can be nested.
 */
public void testComplexContradictingEventsAllowed(){
  List jesse=Arrays.asList(new Character[]{new Character('J'),new Character('E'),new Character('S'),new Character('S'),new Character('E')});
  List wilson=Arrays.asList(new Character[]{new Character('W'),new Character('I'),new Character('L'),new Character('S'),new Character('O'),new Character('N')});
  boolean contradictionsAllowed=true;
  nestingList.beginEvent(contradictionsAllowed);
  source.addAll(jesse);
  source.removeAll(wilson);
  nestingList.commitEvent();
  assertEquals(3,nestingList.size());
  assertEquals(3,counter.getEventCount());
}","/** 
 * Validates that complex contradicting events can be nested.
 */
public void testComplexContradictingEventsAllowed(){
  List jesse=Arrays.asList(new Character[]{new Character('J'),new Character('E'),new Character('S'),new Character('S'),new Character('E')});
  List wilson=Arrays.asList(new Character[]{new Character('W'),new Character('I'),new Character('L'),new Character('S'),new Character('O'),new Character('N')});
  boolean contradictionsAllowed=true;
  nestingList.beginEvent(contradictionsAllowed);
  source.addAll(jesse);
  source.removeAll(wilson);
  nestingList.commitEvent();
  System.out.println(nestingList);
  assertEquals(3,nestingList.size());
  assertEquals(3,counter.getEventCount());
}",0.974765681326604
32742,"public void listChanged(ListEvent listChanges){
  updates.forwardEvent(listChanges);
}","public void listChanged(ListEvent listChanges){
  if (listChanges.isReordering()) {
    int[] reorderMap=listChanges.getReorderMap();
    updates.reorder(reorderMap);
  }
 else {
    while (listChanges.next()) {
      updates.addChange(listChanges.getType(),listChanges.getIndex());
    }
  }
}",0.3263157894736842
32743,"/** 
 * Validates that simple contradicting events can be nested.
 */
public void testSimpleContradictingEventsAllowed(){
  boolean contradictionsAllowed=true;
  nestingList.beginEvent(contradictionsAllowed);
  source.add(""String_Node_Str"");
  source.remove(0);
  nestingList.commitEvent();
  assertEquals(0,nestingList.size());
  assertEquals(0,counter.getEventCount());
}","/** 
 * Validates that simple contradicting events can be nested.
 */
public void testSimpleContradictingEventsAllowed(){
  boolean contradictionsAllowed=true;
  nestingList.beginEvent(false);
  source.addAll(Arrays.asList(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}));
  nestingList.commitEvent();
  nestingList.beginEvent(contradictionsAllowed);
  source.add(2,""String_Node_Str"");
  source.add(3,""String_Node_Str"");
  source.add(4,""String_Node_Str"");
  source.remove(1);
  source.remove(1);
  source.remove(1);
  nestingList.commitEvent();
  assertEquals(nestingList,Arrays.asList(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}));
  assertEquals(2,counter.getEventCount());
  assertEquals(2,counter.getChangeCount(1));
}",0.5
32744,"/** 
 * Validates that simple contradicting events throw an exception if not allowed.
 */
public void testSimpleContradictingEventsFail(){
  boolean contradictionsAllowed=false;
  try {
    nestingList.beginEvent(contradictionsAllowed);
    source.add(""String_Node_Str"");
    source.remove(0);
    nestingList.commitEvent();
    fail(""String_Node_Str"");
  }
 catch (  ConcurrentModificationException e) {
  }
}","/** 
 * Validates that simple contradicting events throw an exception if not allowed.
 */
public void testSimpleContradictingEventsFail(){
  boolean contradictionsAllowed=false;
  try {
    nestingList.beginEvent(contradictionsAllowed);
    source.add(""String_Node_Str"");
    source.remove(0);
    nestingList.commitEvent();
    fail(""String_Node_Str"");
  }
 catch (  IllegalStateException e) {
  }
}",0.9580246913580248
32745,"/** 
 * Validates that complex contradicting events throw an exception if not allowed.
 */
public void testComplexContradictingEventsFail(){
  List jesse=Arrays.asList(new Character[]{new Character('J'),new Character('E'),new Character('S'),new Character('S'),new Character('E')});
  List wilson=Arrays.asList(new Character[]{new Character('W'),new Character('I'),new Character('L'),new Character('S'),new Character('O'),new Character('N')});
  boolean contradictionsAllowed=false;
  try {
    nestingList.beginEvent(contradictionsAllowed);
    source.addAll(jesse);
    source.removeAll(wilson);
    nestingList.commitEvent();
    fail(""String_Node_Str"");
  }
 catch (  ConcurrentModificationException e) {
  }
}","/** 
 * Validates that complex contradicting events throw an exception if not allowed.
 */
public void testComplexContradictingEventsFail(){
  List jesse=Arrays.asList(new Character[]{new Character('J'),new Character('E'),new Character('S'),new Character('S'),new Character('E')});
  List wilson=Arrays.asList(new Character[]{new Character('W'),new Character('I'),new Character('L'),new Character('S'),new Character('O'),new Character('N')});
  boolean contradictionsAllowed=false;
  try {
    nestingList.beginEvent(contradictionsAllowed);
    source.addAll(jesse);
    source.removeAll(wilson);
    nestingList.commitEvent();
    fail(""String_Node_Str"");
  }
 catch (  IllegalStateException e) {
  }
}",0.9759887005649718
32746,"/** 
 * Test that the indexOf() and lastIndexOf() methods work if the SortedList is not actually sorted.
 */
public void testIndexOfUnsorted(){
  sortedList.setComparator(null);
  sortedList.add(""String_Node_Str"");
  sortedList.add(""String_Node_Str"");
  sortedList.add(""String_Node_Str"");
  sortedList.add(""String_Node_Str"");
  sortedList.add(""String_Node_Str"");
  sortedList.add(""String_Node_Str"");
  sortedList.add(""String_Node_Str"");
  sortedList.add(""String_Node_Str"");
  assertEquals(0,sortedList.indexOf(""String_Node_Str""));
  assertEquals(6,sortedList.lastIndexOf(""String_Node_Str""));
  assertEquals(8,sortedList.indexOfSimulated(""String_Node_Str""));
}","/** 
 * Test that the indexOf() and lastIndexOf() methods work if the SortedList is not actually sorted.
 * @see <a href=""https://glazedlists.dev.java.net/issues/show_bug.cgi?id=170"">Bug 170</a>
 */
public void testIndexOfUnsorted(){
  sortedList.setComparator(null);
  sortedList.add(""String_Node_Str"");
  sortedList.add(""String_Node_Str"");
  sortedList.add(""String_Node_Str"");
  sortedList.add(""String_Node_Str"");
  sortedList.add(""String_Node_Str"");
  sortedList.add(""String_Node_Str"");
  sortedList.add(""String_Node_Str"");
  sortedList.add(""String_Node_Str"");
  assertEquals(0,sortedList.indexOf(""String_Node_Str""));
  assertEquals(6,sortedList.lastIndexOf(""String_Node_Str""));
  assertEquals(8,sortedList.indexOfSimulated(""String_Node_Str""));
}",0.9360795454545454
32747,"/** 
 * Display a frame for browsing issues.
 */
private JPanel constructView(){
  IssuesUserFilter issuesUserFiltered=new IssuesUserFilter(issuesEventList);
  TextFilterList issuesTextFiltered=new TextFilterList(issuesUserFiltered);
  ThresholdList priorityList=new ThresholdList(issuesTextFiltered,""String_Node_Str"");
  SortedList issuesSortedList=new SortedList(priorityList);
  EventTableModel issuesTableModel=new EventTableModel(issuesSortedList,new IssueTableFormat());
  JTable issuesJTable=new JTable(issuesTableModel);
  issuesSelectionModel=new EventSelectionModel(issuesTextFiltered);
  issuesSelectionModel.addListSelectionListener(new IssuesSelectionListener());
  issuesJTable.setSelectionModel(issuesSelectionModel);
  issuesJTable.getColumnModel().getColumn(0).setPreferredWidth(10);
  issuesJTable.getColumnModel().getColumn(1).setPreferredWidth(30);
  issuesJTable.getColumnModel().getColumn(2).setPreferredWidth(10);
  issuesJTable.getColumnModel().getColumn(3).setPreferredWidth(30);
  issuesJTable.getColumnModel().getColumn(4).setPreferredWidth(30);
  issuesJTable.getColumnModel().getColumn(5).setPreferredWidth(200);
  issuesJTable.setDefaultRenderer(Priority.class,new PriorityTableCellRenderer());
  TableComparatorChooser tableSorter=new TableComparatorChooser(issuesJTable,issuesSortedList,true);
  JScrollPane issuesTableScrollPane=new JScrollPane(issuesJTable,JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  JScrollPane usersListScrollPane=new JScrollPane(issuesUserFiltered.getUserSelect(),JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  EventTableModel descriptionsTableModel=new EventTableModel(descriptions,new DescriptionTableFormat());
  JTable descriptionsTable=new JTable(descriptionsTableModel);
  descriptionsTable.getColumnModel().getColumn(0).setCellRenderer(new DescriptionRenderer());
  JScrollPane descriptionsTableScrollPane=new JScrollPane(descriptionsTable,JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  BoundedRangeModel priorityRangeModel=ThresholdRangeModelFactory.createLower(priorityList);
  priorityRangeModel.setRangeProperties(0,0,0,100,false);
  JSlider prioritySlider=new JSlider(priorityRangeModel);
  Hashtable prioritySliderLabels=new Hashtable();
  prioritySliderLabels.put(new Integer(0),new JLabel(""String_Node_Str""));
  prioritySliderLabels.put(new Integer(100),new JLabel(""String_Node_Str""));
  prioritySlider.setLabelTable(prioritySliderLabels);
  prioritySlider.setSnapToTicks(true);
  prioritySlider.setPaintLabels(true);
  prioritySlider.setPaintTicks(true);
  prioritySlider.setMajorTickSpacing(25);
  EventList projects=Project.getProjects();
  EventComboBoxModel projectsComboModel=new EventComboBoxModel(projects);
  JComboBox projectsCombo=new JComboBox(projectsComboModel);
  projectsCombo.setEditable(false);
  projectsCombo.setBackground(GLAZED_LISTS_ORANGE);
  projectsCombo.addItemListener(new ProjectChangeListener());
  projectsComboModel.setSelectedItem(new Project(null,""String_Node_Str""));
  JPanel iconBar=new JPanel();
  iconBar.setBackground(GLAZED_LISTS_ORANGE);
  iconBar.setLayout(new GridBagLayout());
  ClassLoader jarLoader=IssuesBrowser.class.getClassLoader();
  URL url=jarLoader.getResource(""String_Node_Str"");
  if (url != null)   throbberStatic=new ImageIcon(url);
  url=jarLoader.getResource(""String_Node_Str"");
  if (url != null)   throbberActive=new ImageIcon(url);
  throbber=new JLabel(throbberStatic);
  iconBar.add(projectsCombo,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(5,5,5,5),0,0));
  iconBar.add(throbber,new GridBagConstraints(1,0,1,1,1.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(5,5,5,5),0,0));
  JPanel filtersPanel=new JPanel();
  filtersPanel.setLayout(new GridBagLayout());
  filtersPanel.setBorder(BorderFactory.createLineBorder(Color.white));
  filtersPanel.add(new JLabel(""String_Node_Str""),new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(10,10,5,10),0,0));
  filtersPanel.add(issuesTextFiltered.getFilterEdit(),new GridBagConstraints(0,1,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,10,15,10),0,0));
  filtersPanel.add(new JLabel(""String_Node_Str""),new GridBagConstraints(0,2,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(5,10,5,10),0,0));
  filtersPanel.add(prioritySlider,new GridBagConstraints(0,3,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,10,15,10),0,0));
  filtersPanel.add(new JLabel(""String_Node_Str""),new GridBagConstraints(0,4,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(5,10,5,10),0,0));
  filtersPanel.add(usersListScrollPane,new GridBagConstraints(0,5,1,1,1.0,1.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,10,10,10),0,0));
  JPanel panel=new JPanel();
  panel.setLayout(new GridBagLayout());
  panel.add(iconBar,new GridBagConstraints(0,0,2,1,1.00,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,5,0),0,0));
  panel.add(filtersPanel,new GridBagConstraints(0,1,1,2,0.15,1.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(5,5,5,5),0,0));
  panel.add(issuesTableScrollPane,new GridBagConstraints(1,1,1,1,0.85,0.5,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(5,5,5,5),0,0));
  panel.add(descriptionsTableScrollPane,new GridBagConstraints(1,2,1,1,0.85,0.5,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(5,5,5,5),0,0));
  return panel;
}","/** 
 * Display a frame for browsing issues.
 */
private JPanel constructView(){
  IssuesUserFilter issuesUserFiltered=new IssuesUserFilter(issuesEventList);
  TextFilterList issuesTextFiltered=new TextFilterList(issuesUserFiltered);
  ThresholdList priorityList=new ThresholdList(issuesTextFiltered,""String_Node_Str"");
  SortedList issuesSortedList=new SortedList(priorityList);
  EventTableModel issuesTableModel=new EventTableModel(issuesSortedList,new IssueTableFormat());
  JTable issuesJTable=new JTable(issuesTableModel);
  issuesSelectionModel=new EventSelectionModel(issuesSortedList);
  issuesSelectionModel.addListSelectionListener(new IssuesSelectionListener());
  issuesJTable.setSelectionModel(issuesSelectionModel);
  issuesJTable.getColumnModel().getColumn(0).setPreferredWidth(10);
  issuesJTable.getColumnModel().getColumn(1).setPreferredWidth(30);
  issuesJTable.getColumnModel().getColumn(2).setPreferredWidth(10);
  issuesJTable.getColumnModel().getColumn(3).setPreferredWidth(30);
  issuesJTable.getColumnModel().getColumn(4).setPreferredWidth(30);
  issuesJTable.getColumnModel().getColumn(5).setPreferredWidth(200);
  issuesJTable.setDefaultRenderer(Priority.class,new PriorityTableCellRenderer());
  TableComparatorChooser tableSorter=new TableComparatorChooser(issuesJTable,issuesSortedList,true);
  JScrollPane issuesTableScrollPane=new JScrollPane(issuesJTable,JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  JScrollPane usersListScrollPane=new JScrollPane(issuesUserFiltered.getUserSelect(),JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  EventTableModel descriptionsTableModel=new EventTableModel(descriptions,new DescriptionTableFormat());
  JTable descriptionsTable=new JTable(descriptionsTableModel);
  descriptionsTable.getColumnModel().getColumn(0).setCellRenderer(new DescriptionRenderer());
  JScrollPane descriptionsTableScrollPane=new JScrollPane(descriptionsTable,JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  BoundedRangeModel priorityRangeModel=ThresholdRangeModelFactory.createLower(priorityList);
  priorityRangeModel.setRangeProperties(0,0,0,100,false);
  JSlider prioritySlider=new JSlider(priorityRangeModel);
  Hashtable prioritySliderLabels=new Hashtable();
  prioritySliderLabels.put(new Integer(0),new JLabel(""String_Node_Str""));
  prioritySliderLabels.put(new Integer(100),new JLabel(""String_Node_Str""));
  prioritySlider.setLabelTable(prioritySliderLabels);
  prioritySlider.setSnapToTicks(true);
  prioritySlider.setPaintLabels(true);
  prioritySlider.setPaintTicks(true);
  prioritySlider.setMajorTickSpacing(25);
  EventList projects=Project.getProjects();
  EventComboBoxModel projectsComboModel=new EventComboBoxModel(projects);
  JComboBox projectsCombo=new JComboBox(projectsComboModel);
  projectsCombo.setEditable(false);
  projectsCombo.setBackground(GLAZED_LISTS_ORANGE);
  projectsCombo.addItemListener(new ProjectChangeListener());
  projectsComboModel.setSelectedItem(new Project(null,""String_Node_Str""));
  JPanel iconBar=new JPanel();
  iconBar.setBackground(GLAZED_LISTS_ORANGE);
  iconBar.setLayout(new GridBagLayout());
  ClassLoader jarLoader=IssuesBrowser.class.getClassLoader();
  URL url=jarLoader.getResource(""String_Node_Str"");
  if (url != null)   throbberStatic=new ImageIcon(url);
  url=jarLoader.getResource(""String_Node_Str"");
  if (url != null)   throbberActive=new ImageIcon(url);
  throbber=new JLabel(throbberStatic);
  iconBar.add(projectsCombo,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(5,5,5,5),0,0));
  iconBar.add(throbber,new GridBagConstraints(1,0,1,1,1.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(5,5,5,5),0,0));
  JPanel filtersPanel=new JPanel();
  filtersPanel.setLayout(new GridBagLayout());
  filtersPanel.setBorder(BorderFactory.createLineBorder(Color.white));
  filtersPanel.add(new JLabel(""String_Node_Str""),new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(10,10,5,10),0,0));
  filtersPanel.add(issuesTextFiltered.getFilterEdit(),new GridBagConstraints(0,1,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,10,15,10),0,0));
  filtersPanel.add(new JLabel(""String_Node_Str""),new GridBagConstraints(0,2,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(5,10,5,10),0,0));
  filtersPanel.add(prioritySlider,new GridBagConstraints(0,3,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,10,15,10),0,0));
  filtersPanel.add(new JLabel(""String_Node_Str""),new GridBagConstraints(0,4,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(5,10,5,10),0,0));
  filtersPanel.add(usersListScrollPane,new GridBagConstraints(0,5,1,1,1.0,1.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,10,10,10),0,0));
  JPanel panel=new JPanel();
  panel.setLayout(new GridBagLayout());
  panel.add(iconBar,new GridBagConstraints(0,0,2,1,1.00,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,5,0),0,0));
  panel.add(filtersPanel,new GridBagConstraints(0,1,1,2,0.15,1.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(5,5,5,5),0,0));
  panel.add(issuesTableScrollPane,new GridBagConstraints(1,1,1,1,0.85,0.5,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(5,5,5,5),0,0));
  panel.add(descriptionsTableScrollPane,new GridBagConstraints(1,2,1,1,0.85,0.5,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(5,5,5,5),0,0));
  return panel;
}",0.9980374665477252
32748,"/** 
 * Get this DependentList for debugging.
 */
public String toString(){
  StringBuffer result=new StringBuffer();
  result.append(listener.getClass().getName());
  result.append(""String_Node_Str"");
  for (Iterator i=dependencies.iterator(); i.hasNext(); ) {
    EventList dependency=(EventList)i.next();
    result.append(dependency.getClass().getName());
    if (i.hasNext())     result.append(""String_Node_Str"");
  }
  result.append(""String_Node_Str"");
  return result.toString();
}","/** 
 * Get this DependentList for debugging.
 */
public String toString(){
  StringBuffer result=new StringBuffer();
  result.append(listener.getClass().getName());
  result.append(""String_Node_Str"");
  for (Iterator i=dependencies.iterator(); i.hasNext(); ) {
    EventList dependency=(EventList)i.next();
    result.append(""String_Node_Str"").append(dependency.getClass().getName()).append(""String_Node_Str"");
  }
  return result.toString();
}",0.8981779206859593
32749,"/** 
 * Sets the lower threshold for this list. <p>This list can be used programmatically rather than hooking it up to a UI component. <strong>Calling this method directly while this list is connected to a particular widget could result in errors.</strong> <p><strong><font color=""#FF0000"">Warning:</font></strong> This method is thread ready but not thread safe. See   {@link EventList} for an exampleof thread safe code.
 */
public void setLowerThreshold(int threshold){
  int newListIndex=0;
  if (sourceSize == 0) {
    lowerThreshold=threshold;
    lowerThresholdIndex=-1;
    return;
  }
 else   if (threshold == lowerThreshold) {
    return;
  }
 else {
    newListIndex=((SortedList)source).indexOfSimulated(new Integer(threshold));
    if (newListIndex == 0)     newListIndex=source.indexOf(new Integer(threshold));
  }
  lowerThreshold=threshold;
  if (newListIndex == lowerThresholdIndex) {
    return;
  }
  if ((newListIndex == -1 && lowerThresholdIndex == 0) || (newListIndex == 0 && lowerThresholdIndex == -1) || (newListIndex == size() && lowerThresholdIndex == size() - 1)|| (newListIndex == size() - 1 && lowerThresholdIndex == size())) {
    lowerThresholdIndex=newListIndex;
    return;
  }
  updates.beginEvent();
  if (newListIndex < lowerThresholdIndex) {
    updates.addInsert(0,Math.max(lowerThresholdIndex,0) - newListIndex - 1);
  }
 else   if (newListIndex > lowerThresholdIndex) {
    updates.addDelete(0,newListIndex - Math.max(lowerThresholdIndex,0) - 1);
  }
  lowerThresholdIndex=newListIndex;
  updates.commitEvent();
}","/** 
 * Sets the lower threshold for this list. <p>This list can be used programmatically rather than hooking it up to a UI component. <strong>Calling this method directly while this list is connected to a particular widget could result in errors.</strong> <p><strong><font color=""#FF0000"">Warning:</font></strong> This method is thread ready but not thread safe. See   {@link EventList} for an exampleof thread safe code.
 */
public void setLowerThreshold(int threshold){
  int newListIndex=0;
  if (sourceSize == 0) {
    lowerThreshold=threshold;
    lowerThresholdIndex=-1;
    return;
  }
 else   if (threshold == lowerThreshold) {
    return;
  }
 else {
    newListIndex=((SortedList)source).indexOfSimulated(new Integer(threshold));
    if (newListIndex == 0)     newListIndex=source.indexOf(new Integer(threshold));
  }
  lowerThreshold=threshold;
  if (newListIndex == lowerThresholdIndex) {
    return;
  }
  if ((newListIndex == -1 && lowerThresholdIndex == 0) || (newListIndex == 0 && lowerThresholdIndex == -1)) {
    lowerThresholdIndex=newListIndex;
    return;
  }
  updates.beginEvent();
  if (newListIndex < lowerThresholdIndex) {
    updates.addInsert(0,Math.max(lowerThresholdIndex,0) - newListIndex - 1);
  }
 else   if (newListIndex > lowerThresholdIndex) {
    updates.addDelete(0,newListIndex - Math.max(lowerThresholdIndex,0) - 1);
  }
  lowerThresholdIndex=newListIndex;
  updates.commitEvent();
}",0.9566677863621096
32750,"/** 
 * {@inheritDoc} 
 */
public void listChanged(ListEvent listChanges){
  sourceSize=source.size();
  updates.beginEvent();
  while (listChanges.next()) {
    int sortedIndex=listChanges.getIndex();
    int type=listChanges.getType();
    int value=Integer.MIN_VALUE;
    if (type != ListEvent.DELETE && sourceSize > 0) {
      value=evaluator.evaluate(source.get(sortedIndex));
    }
    if (sortedIndex < lowerThresholdIndex - 1) {
      if (type == ListEvent.INSERT) {
        lowerThresholdIndex++;
        upperThresholdIndex++;
      }
 else       if (type == ListEvent.DELETE) {
        lowerThresholdIndex--;
        upperThresholdIndex--;
      }
 else       if (type == ListEvent.UPDATE) {
      }
    }
 else     if (sortedIndex == lowerThresholdIndex - 1) {
      int transformedIndex=sortedIndex - Math.max(lowerThresholdIndex,0);
      if (type == ListEvent.INSERT) {
        if (value < lowerThreshold) {
          lowerThresholdIndex++;
          upperThresholdIndex++;
        }
 else {
          upperThresholdIndex++;
          updates.addInsert(transformedIndex);
        }
      }
 else       if (type == ListEvent.DELETE) {
        lowerThresholdIndex--;
        upperThresholdIndex--;
      }
 else       if (type == ListEvent.UPDATE) {
        if (value >= lowerThreshold) {
          lowerThresholdIndex--;
          updates.addInsert(0);
        }
      }
    }
 else     if (sortedIndex >= lowerThresholdIndex && sortedIndex <= upperThresholdIndex) {
      int transformedIndex=sortedIndex - Math.max(lowerThresholdIndex,0);
      if (type == ListEvent.INSERT) {
        upperThresholdIndex++;
        if (value < lowerThreshold) {
          lowerThresholdIndex++;
        }
 else         if (value > upperThreshold) {
          throw new IllegalStateException();
        }
 else {
          updates.addInsert(transformedIndex);
        }
      }
 else       if (type == ListEvent.DELETE) {
        upperThresholdIndex--;
        updates.addDelete(transformedIndex);
      }
 else       if (type == ListEvent.UPDATE) {
        if (value < lowerThreshold) {
          lowerThresholdIndex++;
          updates.addDelete(transformedIndex);
        }
 else         if (value > upperThreshold) {
          upperThresholdIndex--;
          updates.addDelete(transformedIndex);
        }
 else {
          updates.addUpdate(transformedIndex);
        }
      }
    }
 else     if (sortedIndex == upperThresholdIndex + 1) {
      int transformedIndex=sortedIndex - Math.max(lowerThresholdIndex,0);
      if (type == ListEvent.INSERT) {
        if (value <= upperThreshold) {
          upperThresholdIndex++;
          updates.addInsert(transformedIndex);
        }
      }
 else       if (type == ListEvent.DELETE) {
      }
 else       if (type == ListEvent.UPDATE) {
        if (value <= upperThreshold) {
          upperThresholdIndex++;
          updates.addInsert(transformedIndex);
        }
      }
    }
 else     if (sortedIndex > upperThresholdIndex + 1) {
    }
 else {
      throw new IllegalStateException();
    }
  }
  updates.commitEvent();
}","/** 
 * {@inheritDoc} 
 */
public void listChanged(ListEvent listChanges){
  sourceSize=source.size();
  updates.beginEvent();
  while (listChanges.next()) {
    int sortedIndex=listChanges.getIndex();
    int type=listChanges.getType();
    int value=Integer.MIN_VALUE;
    if (type != ListEvent.DELETE && sourceSize > 0) {
      value=evaluator.evaluate(source.get(sortedIndex));
    }
    if (sortedIndex < lowerThresholdIndex - 1) {
      if (type == ListEvent.INSERT) {
        lowerThresholdIndex++;
        upperThresholdIndex++;
      }
 else       if (type == ListEvent.DELETE) {
        lowerThresholdIndex--;
        upperThresholdIndex--;
      }
 else       if (type == ListEvent.UPDATE) {
      }
    }
 else     if (sortedIndex == lowerThresholdIndex - 1) {
      int transformedIndex=sortedIndex - Math.max(lowerThresholdIndex,0);
      if (type == ListEvent.INSERT) {
        if (value < lowerThreshold) {
          lowerThresholdIndex++;
          upperThresholdIndex++;
        }
 else         if (value > upperThreshold) {
        }
 else {
          upperThresholdIndex++;
          updates.addInsert(transformedIndex);
        }
      }
 else       if (type == ListEvent.DELETE) {
        lowerThresholdIndex--;
        upperThresholdIndex--;
      }
 else       if (type == ListEvent.UPDATE) {
        if (value >= lowerThreshold) {
          lowerThresholdIndex--;
          updates.addInsert(0);
        }
      }
    }
 else     if (sortedIndex >= lowerThresholdIndex && sortedIndex <= upperThresholdIndex) {
      int transformedIndex=sortedIndex - Math.max(lowerThresholdIndex,0);
      if (type == ListEvent.INSERT) {
        upperThresholdIndex++;
        if (value < lowerThreshold) {
          lowerThresholdIndex++;
        }
 else         if (value > upperThreshold) {
          throw new IllegalStateException();
        }
 else {
          updates.addInsert(transformedIndex);
        }
      }
 else       if (type == ListEvent.DELETE) {
        upperThresholdIndex--;
        updates.addDelete(transformedIndex);
      }
 else       if (type == ListEvent.UPDATE) {
        if (value < lowerThreshold) {
          lowerThresholdIndex++;
          updates.addDelete(transformedIndex);
        }
 else         if (value > upperThreshold) {
          upperThresholdIndex--;
          updates.addDelete(transformedIndex);
        }
 else {
          updates.addUpdate(transformedIndex);
        }
      }
    }
 else     if (sortedIndex == upperThresholdIndex + 1) {
      int transformedIndex=sortedIndex - Math.max(lowerThresholdIndex,0);
      if (type == ListEvent.INSERT) {
        if (value >= lowerThreshold && value <= upperThreshold) {
          upperThresholdIndex++;
          updates.addInsert(transformedIndex);
        }
 else         if (sortedIndex == lowerThresholdIndex) {
          lowerThresholdIndex++;
          upperThresholdIndex++;
        }
      }
 else       if (type == ListEvent.DELETE) {
      }
 else       if (type == ListEvent.UPDATE) {
        if (value <= upperThreshold) {
          upperThresholdIndex++;
          updates.addInsert(transformedIndex);
        }
      }
    }
 else     if (sortedIndex > upperThresholdIndex + 1) {
    }
 else {
      throw new IllegalStateException();
    }
  }
  updates.commitEvent();
}",0.966577749882316
32751,"/** 
 * Sets the upper threshold for this list. <p><strong><font color=""#FF0000"">Warning:</font></strong> This method is thread ready but not thread safe. See   {@link EventList} for an exampleof thread safe code.
 */
public void setUpperThreshold(int threshold){
  int newListIndex=0;
  if (sourceSize == 0) {
    upperThreshold=threshold;
    upperThresholdIndex=-1;
    return;
  }
 else   if (threshold == upperThreshold) {
    return;
  }
 else {
    if (threshold == Integer.MAX_VALUE) {
      newListIndex=sourceSize - 1;
    }
 else {
      newListIndex=((SortedList)source).indexOfSimulated(new Integer(threshold + 1)) - 1;
    }
  }
  upperThreshold=threshold;
  if (newListIndex == upperThresholdIndex) {
    return;
  }
  if ((newListIndex == -1 && upperThresholdIndex == 0) || (newListIndex == 0 && upperThresholdIndex == -1) || (newListIndex == size() && upperThresholdIndex == size() - 1)|| (newListIndex == size() - 1 && upperThresholdIndex == size())) {
    upperThresholdIndex=newListIndex;
    return;
  }
  updates.beginEvent();
  if (newListIndex < upperThresholdIndex) {
    updates.addDelete(newListIndex + 1,upperThresholdIndex - Math.max(lowerThresholdIndex,0));
  }
 else   if (newListIndex > upperThresholdIndex) {
    updates.addInsert(upperThresholdIndex - Math.max(lowerThresholdIndex,0) + 1,newListIndex);
  }
  upperThresholdIndex=newListIndex;
  updates.commitEvent();
}","/** 
 * Sets the upper threshold for this list. <p><strong><font color=""#FF0000"">Warning:</font></strong> This method is thread ready but not thread safe. See   {@link EventList} for an exampleof thread safe code.
 */
public void setUpperThreshold(int threshold){
  int newListIndex=0;
  if (sourceSize == 0) {
    upperThreshold=threshold;
    upperThresholdIndex=-1;
    return;
  }
 else   if (threshold == upperThreshold) {
    return;
  }
 else {
    if (threshold == Integer.MAX_VALUE) {
      newListIndex=sourceSize - 1;
    }
 else {
      newListIndex=((SortedList)source).indexOfSimulated(new Integer(threshold + 1)) - 1;
    }
  }
  upperThreshold=threshold;
  if (newListIndex == upperThresholdIndex) {
    return;
  }
  if ((newListIndex == size() && upperThresholdIndex == size() - 1) || (newListIndex == size() - 1 && upperThresholdIndex == size())) {
    upperThresholdIndex=newListIndex;
    return;
  }
  updates.beginEvent();
  if (newListIndex < upperThresholdIndex) {
    updates.addDelete(newListIndex + 1,upperThresholdIndex - Math.max(lowerThresholdIndex,0));
  }
 else   if (newListIndex > upperThresholdIndex) {
    updates.addInsert(upperThresholdIndex - Math.max(lowerThresholdIndex,0) + 1,newListIndex);
  }
  upperThresholdIndex=newListIndex;
  updates.commitEvent();
}",0.9426563078061412
32752,"private void remoteSubscribeConfirm(ResourceConnection publisher,PeerBlock block){
  resource.getReadWriteLock().writeLock().lock();
  try {
    System.out.print(""String_Node_Str"" + (block.getUpdateId()) + ""String_Node_Str"");
    resource.fromSnapshot(block.getPayload());
    resourceUpdateId=block.getUpdateId() - 1;
    resourceListener.resourceUpdated(resource,block.getPayload());
  }
  finally {
    resource.getReadWriteLock().writeLock().unlock();
  }
  sessionId=block.getSessionId();
  resourceStatus.setConnected(true,null);
}","private void remoteSubscribeConfirm(ResourceConnection publisher,PeerBlock block){
  resource.getReadWriteLock().writeLock().lock();
  try {
    resource.fromSnapshot(block.getPayload());
    resourceUpdateId=block.getUpdateId();
    System.err.println(""String_Node_Str"" + (block.getUpdateId()) + ""String_Node_Str""+ resourceUpdateId+ ""String_Node_Str""+ resource);
  }
  finally {
    resource.getReadWriteLock().writeLock().unlock();
  }
  sessionId=block.getSessionId();
  resourceStatus.setConnected(true,null);
}",0.4448669201520912
32753,"private void remoteUpdate(ResourceConnection publisher,PeerBlock block){
  if (block.getSessionId() != sessionId)   throw new IllegalStateException();
  resource.getReadWriteLock().writeLock().lock();
  try {
    if (block.getUpdateId() != (resourceUpdateId + 1))     throw new IllegalStateException(""String_Node_Str"" + (resourceUpdateId + 1) + ""String_Node_Str""+ block.getUpdateId());
    resource.update(block.getPayload());
    resourceListener.resourceUpdated(resource,block.getPayload());
  }
  finally {
    resource.getReadWriteLock().writeLock().unlock();
  }
}","private void remoteUpdate(ResourceConnection publisher,PeerBlock block){
  if (block.getSessionId() != sessionId)   throw new IllegalStateException();
  resource.getReadWriteLock().writeLock().lock();
  try {
    if (block.getUpdateId() != (resourceUpdateId + 1)) {
      if (block.getUpdateId() < (resourceUpdateId + 1)) {
        logger.warning(""String_Node_Str"" + (resourceUpdateId + 1) + ""String_Node_Str""+ block.getUpdateId());
        return;
      }
 else {
        throw new IllegalStateException(""String_Node_Str"" + (resourceUpdateId + 1) + ""String_Node_Str""+ block.getUpdateId());
      }
    }
    resource.update(block.getPayload());
    resourceListener.resourceUpdated(resource,block.getPayload());
  }
  finally {
    resource.getReadWriteLock().writeLock().unlock();
  }
}",0.8386145910095799
32754,"private void remoteSubscribe(ResourceConnection subscriber,PeerBlock block){
  if (resourceStatus.isConnected()) {
    int updateId=-1;
    Bufferlo snapshot=null;
    resource.getReadWriteLock().writeLock().lock();
    try {
      updateId=resourceUpdateId;
      snapshot=resource.toSnapshot();
    }
  finally {
      resource.getReadWriteLock().writeLock().unlock();
    }
    subscriber.setUpdateId(updateId);
    subscriber.getConnection().outgoingPublications.put(resourceUri,subscriber);
    subscribers.add(subscriber);
    PeerBlock subscribeConfirm=PeerBlock.subscribeConfirm(resourceUri,sessionId,updateId,snapshot);
    subscriber.getConnection().writeBlock(this,subscribeConfirm);
  }
 else {
    PeerBlock unpublish=PeerBlock.unpublish(resourceUri);
    subscriber.getConnection().writeBlock(this,unpublish);
    if (subscriber.getConnection().isIdle())     subscriber.getConnection().close();
  }
}","private void remoteSubscribe(ResourceConnection subscriber,PeerBlock block){
  if (resourceStatus.isConnected()) {
    int updateId=-1;
    Bufferlo snapshot=null;
    resource.getReadWriteLock().writeLock().lock();
    try {
      System.out.println(""String_Node_Str"" + resourceUpdateId + ""String_Node_Str""+ resource);
      updateId=resourceUpdateId;
      snapshot=resource.toSnapshot();
    }
  finally {
      resource.getReadWriteLock().writeLock().unlock();
    }
    subscriber.setUpdateId(updateId);
    subscriber.getConnection().outgoingPublications.put(resourceUri,subscriber);
    subscribers.add(subscriber);
    PeerBlock subscribeConfirm=PeerBlock.subscribeConfirm(resourceUri,sessionId,updateId,snapshot);
    subscriber.getConnection().writeBlock(this,subscribeConfirm);
  }
 else {
    PeerBlock unpublish=PeerBlock.unpublish(resourceUri);
    subscriber.getConnection().writeBlock(this,unpublish);
    if (subscriber.getConnection().isIdle())     subscriber.getConnection().close();
  }
}",0.951092611862643
32755,"/** 
 * Handles a change in a resource contained by the specified delta. This method will be called while holding the Resource's write lock.
 */
public void resourceUpdated(Resource resource,Bufferlo delta){
  resourceUpdateId++;
  peer.invokeLater(new UpdatedRunnable(delta,resourceUpdateId));
}","/** 
 * Handles a change in a resource contained by the specified delta. This method will be called while holding the Resource's write lock.
 */
public void resourceUpdated(Resource resource,Bufferlo delta){
  resourceUpdateId++;
  if (resourceUri.isLocal())   System.out.println(""String_Node_Str"" + resourceUpdateId + ""String_Node_Str""+ resource);
 else   System.err.println(""String_Node_Str"" + resourceUpdateId + ""String_Node_Str""+ resource);
  peer.invokeLater(new UpdatedRunnable(delta,resourceUpdateId));
}",0.7335811648079306
32756,"/** 
 * Verifies that nothing breaks when a client subscribes during a flurry of updates.
 */
public void testFrequentUpdates(){
  try {
    String path=""String_Node_Str"";
    NetworkList sourceList=peer.publish(new BasicEventList(),path,ByteCoderFactory.serializable());
    NetworkList targetList=peer.subscribe(""String_Node_Str"",serverPort,path,ByteCoderFactory.serializable());
    targetList.disconnect();
    for (int j=0; j < 5; j++) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      waitFor(1000);
      sourceList.clear();
      targetList.connect();
      for (int i=0; i < 25; i++) {
        sourceList.add(new Integer(i));
      }
      waitFor(1000);
      assertEquals(sourceList,targetList);
      targetList.disconnect();
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(e.getMessage());
  }
}","/** 
 * Verifies that nothing breaks when a client subscribes during a flurry of updates.
 */
public void testFrequentUpdates(){
  try {
    String path=""String_Node_Str"";
    EventList sourceListTS=new ThreadSafeList(new BasicEventList());
    NetworkList sourceList=peer.publish(sourceListTS,path,ByteCoderFactory.serializable());
    NetworkList targetList=peer.subscribe(""String_Node_Str"",serverPort,path,ByteCoderFactory.serializable());
    targetList.disconnect();
    for (int j=0; j < 5; j++) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      waitFor(1000);
      sourceListTS.clear();
      targetList.connect();
      for (int i=0; i < 25; i++) {
        sourceListTS.add(new Integer(i));
      }
      waitFor(1000);
      assertEquals(sourceList,targetList);
      targetList.disconnect();
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(e.getMessage());
  }
}",0.9125893347993403
32757,"/** 
 * Creates a   {@link ThreadSafeList} that provides thread safe access to allmethods in the source  {@link EventList}.
 */
public ThreadSafeList(EventList source){
  super(source);
  source.addListEventListener(this);
  System.out.println(""String_Node_Str"");
}","/** 
 * Creates a   {@link ThreadSafeList} that provides thread safe access to allmethods in the source  {@link EventList}.
 */
public ThreadSafeList(EventList source){
  super(source);
  source.addListEventListener(this);
}",0.916155419222904
32758,"/** 
 * {@inheritDoc} 
 */
public String toString(){
  getReadWriteLock().readLock().lock();
  try {
    StringBuffer result=new StringBuffer();
    result.append(""String_Node_Str"");
    for (int i=0; i < size(); i++) {
      if (i != 0)       result.append(""String_Node_Str"");
      result.append(get(i));
    }
    result.append(""String_Node_Str"");
    return result.toString();
  }
  finally {
    getReadWriteLock().readLock().unlock();
  }
}","/** 
 * {@inheritDoc} 
 */
public String toString(){
  getReadWriteLock().readLock().lock();
  try {
    return source.toString();
  }
  finally {
    getReadWriteLock().readLock().unlock();
  }
}",0.5981308411214953
32759,"/** 
 * Apply the specified list event to the specified target list. The write lock for this list must already be acquired if the list is shared between threads.
 */
public static void toListEvent(Bufferlo listEvent,EventList target,ByteCoder byteCoder) throws IOException {
  List parts=bytesToParts(listEvent,byteCoder);
  for (Iterator i=parts.iterator(); i.hasNext(); ) {
    ListEventPart part=(ListEventPart)i.next();
    System.out.print(""String_Node_Str"");
    if (part.isDelete()) {
      System.out.print(""String_Node_Str"" + part.getIndex());
      target.remove(part.getIndex());
    }
 else     if (part.isUpdate()) {
      System.out.print(""String_Node_Str"" + part.getIndex());
      target.set(part.getIndex(),part.getValue());
    }
 else     if (part.isInsert()) {
      System.out.print(""String_Node_Str"" + part.getIndex() + ""String_Node_Str""+ part.getValue()+ ""String_Node_Str"");
      target.add(part.getIndex(),part.getValue());
    }
 else     if (part.isClear()) {
      System.out.print(""String_Node_Str"");
      target.clear();
    }
    System.out.println(""String_Node_Str"");
  }
}","/** 
 * Apply the specified list event to the specified target list. The write lock for this list must already be acquired if the list is shared between threads.
 */
public static void toListEvent(Bufferlo listEvent,EventList target,ByteCoder byteCoder) throws IOException {
  List parts=bytesToParts(listEvent,byteCoder);
  for (Iterator i=parts.iterator(); i.hasNext(); ) {
    ListEventPart part=(ListEventPart)i.next();
    if (part.isDelete()) {
      target.remove(part.getIndex());
    }
 else     if (part.isUpdate()) {
      target.set(part.getIndex(),part.getValue());
    }
 else     if (part.isInsert()) {
      target.add(part.getIndex(),part.getValue());
    }
 else     if (part.isClear()) {
      target.clear();
    }
  }
}",0.5135427952329361
32760,"private void remoteSubscribeConfirm(ResourceConnection publisher,PeerBlock block){
  resource.getReadWriteLock().writeLock().lock();
  try {
    resource.fromSnapshot(block.getPayload());
    resourceUpdateId=block.getUpdateId();
    System.err.println(""String_Node_Str"" + (block.getUpdateId()) + ""String_Node_Str""+ resourceUpdateId+ ""String_Node_Str""+ resource);
  }
  finally {
    resource.getReadWriteLock().writeLock().unlock();
  }
  sessionId=block.getSessionId();
  resourceStatus.setConnected(true,null);
}","private void remoteSubscribeConfirm(ResourceConnection publisher,PeerBlock block){
  resource.getReadWriteLock().writeLock().lock();
  try {
    resource.fromSnapshot(block.getPayload());
    resourceUpdateId=block.getUpdateId();
  }
  finally {
    resource.getReadWriteLock().writeLock().unlock();
  }
  sessionId=block.getSessionId();
  resourceStatus.setConnected(true,null);
}",0.5267857142857143
32761,"private void remoteSubscribe(ResourceConnection subscriber,PeerBlock block){
  if (resourceStatus.isConnected()) {
    int updateId=-1;
    Bufferlo snapshot=null;
    resource.getReadWriteLock().writeLock().lock();
    try {
      System.out.println(""String_Node_Str"" + resourceUpdateId + ""String_Node_Str""+ resource);
      updateId=resourceUpdateId;
      snapshot=resource.toSnapshot();
    }
  finally {
      resource.getReadWriteLock().writeLock().unlock();
    }
    subscriber.setUpdateId(updateId);
    subscriber.getConnection().outgoingPublications.put(resourceUri,subscriber);
    subscribers.add(subscriber);
    PeerBlock subscribeConfirm=PeerBlock.subscribeConfirm(resourceUri,sessionId,updateId,snapshot);
    subscriber.getConnection().writeBlock(this,subscribeConfirm);
  }
 else {
    PeerBlock unpublish=PeerBlock.unpublish(resourceUri);
    subscriber.getConnection().writeBlock(this,unpublish);
    if (subscriber.getConnection().isIdle())     subscriber.getConnection().close();
  }
}","private void remoteSubscribe(ResourceConnection subscriber,PeerBlock block){
  if (resourceStatus.isConnected()) {
    int updateId=-1;
    Bufferlo snapshot=null;
    resource.getReadWriteLock().writeLock().lock();
    try {
      updateId=resourceUpdateId;
      snapshot=resource.toSnapshot();
    }
  finally {
      resource.getReadWriteLock().writeLock().unlock();
    }
    subscriber.setUpdateId(updateId);
    subscriber.getConnection().outgoingPublications.put(resourceUri,subscriber);
    subscribers.add(subscriber);
    PeerBlock subscribeConfirm=PeerBlock.subscribeConfirm(resourceUri,sessionId,updateId,snapshot);
    subscriber.getConnection().writeBlock(this,subscribeConfirm);
  }
 else {
    PeerBlock unpublish=PeerBlock.unpublish(resourceUri);
    subscriber.getConnection().writeBlock(this,unpublish);
    if (subscriber.getConnection().isIdle())     subscriber.getConnection().close();
  }
}",0.951092611862643
32762,"/** 
 * Handles a change in a resource contained by the specified delta. This method will be called while holding the Resource's write lock.
 */
public void resourceUpdated(Resource resource,Bufferlo delta){
  resourceUpdateId++;
  if (resourceUri.isLocal())   System.out.println(""String_Node_Str"" + resourceUpdateId + ""String_Node_Str""+ resource);
 else   System.err.println(""String_Node_Str"" + resourceUpdateId + ""String_Node_Str""+ resource);
  peer.invokeLater(new UpdatedRunnable(delta,resourceUpdateId));
}","/** 
 * Handles a change in a resource contained by the specified delta. This method will be called while holding the Resource's write lock.
 */
public void resourceUpdated(Resource resource,Bufferlo delta){
  resourceUpdateId++;
  peer.invokeLater(new UpdatedRunnable(delta,resourceUpdateId));
}",0.7335811648079306
32763,"/** 
 * Verifies that nothing breaks when a client subscribes during a flurry of updates.
 */
public void testFrequentUpdates(){
  try {
    String path=""String_Node_Str"";
    EventList sourceListTS=new ThreadSafeList(new BasicEventList());
    NetworkList sourceList=peer.publish(sourceListTS,path,ByteCoderFactory.serializable());
    NetworkList targetList=peer.subscribe(""String_Node_Str"",serverPort,path,ByteCoderFactory.serializable());
    targetList.disconnect();
    for (int j=0; j < 5; j++) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      waitFor(1000);
      sourceListTS.clear();
      targetList.connect();
      for (int i=0; i < 25; i++) {
        sourceListTS.add(new Integer(i));
      }
      waitFor(1000);
      assertEquals(sourceList,targetList);
      targetList.disconnect();
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(e.getMessage());
  }
}","/** 
 * Verifies that nothing breaks when a client subscribes during a flurry of updates.
 */
public void testFrequentUpdates(){
  try {
    String path=""String_Node_Str"";
    EventList sourceListTS=new ThreadSafeList(new BasicEventList());
    NetworkList sourceList=peer.publish(sourceListTS,path,ByteCoderFactory.serializable());
    NetworkList targetList=peer.subscribe(""String_Node_Str"",serverPort,path,ByteCoderFactory.serializable());
    targetList.disconnect();
    for (int j=0; j < 5; j++) {
      waitFor(1000);
      sourceListTS.clear();
      targetList.connect();
      for (int i=0; i < 25; i++) {
        sourceListTS.add(new Integer(i));
      }
      waitFor(1000);
      assertEquals(sourceList,targetList);
      targetList.disconnect();
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(e.getMessage());
  }
}",0.9498327759197324
32764,"/** 
 * Gets the black index of the element with the given real index or the black index of the previous or next BLACK element if that element is WHITE.
 * @param left true for WHITE elements to return the black index of thefirst BLACK element before it in the list. Such values will range from <code>-1</code> through <code>size()-1</code>. False for WHITE elements to return the black index of the first BLACK element after it in the list. Such values will range from <code>0</code> through <code>size()</code>.
 */
public int getBlackIndex(int index,boolean left){
  if (root == null) {
    if (left)     return -1;
 else     return 0;
  }
 else   if (index >= treeSize) {
    if (left)     return treeSize - 1;
    return treeSize;
  }
 else {
    return root.getBlackIndex(index,left);
  }
}","/** 
 * Gets the black index of the element with the given real index or the black index of the previous or next BLACK element if that element is WHITE.
 * @param left true for WHITE elements to return the black index of thefirst BLACK element before it in the list. Such values will range from <code>-1</code> through <code>size()-1</code>. False for WHITE elements to return the black index of the first BLACK element after it in the list. Such values will range from <code>0</code> through <code>size()</code>.
 */
public int getBlackIndex(int index,boolean left){
  if (root == null) {
    if (left)     return -1;
 else     return 0;
  }
 else   if (index >= treeSize) {
    if (left)     return root.blackSize() - 1;
    return root.blackSize();
  }
 else {
    return root.getBlackIndex(index,left);
  }
}",0.9800995024875622
32765,"/** 
 * Get the bytes for this block.
 */
public Bufferlo getBytes(){
  Bufferlo writer=new Bufferlo();
  Map headers=new TreeMap();
  if (resourceName != null)   headers.put(RESOURCE_NAME,resourceName);
  if (sessionId != -1)   headers.put(SESSION_ID,new Integer(sessionId));
  if (action != null)   headers.put(ACTION,action);
  if (updateId != -1)   headers.put(UPDATE_ID,new Integer(updateId));
  for (Iterator i=headers.entrySet().iterator(); i.hasNext(); ) {
    Map.Entry mapEntry=(Map.Entry)i.next();
    writer.write(mapEntry.getKey().toString());
    writer.write(""String_Node_Str"");
    writer.write(mapEntry.getValue().toString());
    writer.write(""String_Node_Str"");
  }
  writer.write(""String_Node_Str"");
  if (payload != null) {
    writer.append(payload);
  }
  Bufferlo writerWithSize=new Bufferlo();
  writerWithSize.write(""String_Node_Str"" + writer.length());
  writerWithSize.write(""String_Node_Str"");
  writerWithSize.append(writer);
  writerWithSize.write(""String_Node_Str"");
  return writerWithSize;
}","/** 
 * Get the bytes for this block.
 */
public Bufferlo getBytes(){
  Bufferlo writer=new Bufferlo();
  Map headers=new TreeMap();
  if (resourceName != null)   headers.put(RESOURCE_NAME,resourceName);
  if (sessionId != -1)   headers.put(SESSION_ID,new Integer(sessionId));
  if (action != null)   headers.put(ACTION,action);
  if (updateId != -1)   headers.put(UPDATE_ID,new Integer(updateId));
  for (Iterator i=headers.entrySet().iterator(); i.hasNext(); ) {
    Map.Entry mapEntry=(Map.Entry)i.next();
    writer.write(mapEntry.getKey().toString());
    writer.write(""String_Node_Str"");
    writer.write(mapEntry.getValue().toString());
    writer.write(""String_Node_Str"");
  }
  writer.write(""String_Node_Str"");
  if (payload != null) {
    writer.append(payload.duplicate());
  }
  Bufferlo writerWithSize=new Bufferlo();
  writerWithSize.write(""String_Node_Str"" + writer.length());
  writerWithSize.write(""String_Node_Str"");
  writerWithSize.append(writer);
  writerWithSize.write(""String_Node_Str"");
  return writerWithSize;
}",0.994180407371484
32766,"/** 
 * Starts the CTPConnectionManager listening to incoming connections and managing outgoing connections.
 * @return true if the server successfully binds to the listen port.
 */
public synchronized boolean start() throws IOException {
  if (networkThread != null)   throw new IllegalStateException();
  ServerSocketChannel serverChannel=ServerSocketChannel.open();
  ServerSocket serverSocket=serverChannel.socket();
  InetSocketAddress listenAddress=new InetSocketAddress(listenPort);
  serverSocket.bind(listenAddress);
  logger.info(""String_Node_Str"" + listenAddress);
  selector=Selector.open();
  serverChannel.configureBlocking(false);
  serverChannel.register(selector,SelectionKey.OP_ACCEPT);
  keepRunning=true;
  networkThread=new Thread(this,""String_Node_Str"");
  networkThread.start();
  return true;
}","/** 
 * Starts the CTPConnectionManager listening to incoming connections and managing outgoing connections.
 * @return true if the server successfully binds to the listen port.
 */
public synchronized boolean start() throws IOException {
  if (networkThread != null)   throw new IllegalStateException();
  ServerSocketChannel serverChannel=ServerSocketChannel.open();
  ServerSocket serverSocket=serverChannel.socket();
  serverSocket.setReuseAddress(false);
  InetSocketAddress listenAddress=new InetSocketAddress(listenPort);
  serverSocket.bind(listenAddress);
  logger.info(""String_Node_Str"" + listenAddress);
  selector=Selector.open();
  serverChannel.configureBlocking(false);
  serverChannel.register(selector,SelectionKey.OP_ACCEPT);
  keepRunning=true;
  networkThread=new Thread(this,""String_Node_Str"");
  networkThread.start();
  return true;
}",0.9767164179104476
32767,"/** 
 * Handles a change in a local resource contained by the specified delta.
 */
public void resourceUpdated(Resource resource,Bufferlo delta){
  updateId++;
  if (subscribers.isEmpty())   return;
  PeerBlock block=peerBlockFactory.update(updateId,delta);
  for (int s=0; s < subscribers.size(); s++) {
    PeerConnection subscriber=(PeerConnection)subscribers.get(s);
    subscriber.writeBlock(this,block);
  }
}","/** 
 * Handles a change in a local resource contained by the specified delta.
 */
public void resourceUpdated(Resource resource,Bufferlo delta){
  if (publisher == null)   updateId++;
  if (subscribers.isEmpty())   return;
  PeerBlock block=peerBlockFactory.update(updateId,delta);
  for (int s=0; s < subscribers.size(); s++) {
    PeerConnection subscriber=(PeerConnection)subscribers.get(s);
    subscriber.writeBlock(this,block);
  }
}",0.9707602339181286
32768,"/** 
 * Handles a change in a remote resource.
 */
public void remoteUpdate(PeerConnection publisher,PeerBlock block){
  if (block.getUpdateId() != (updateId + 1))   throw new IllegalStateException();
  if (block.getSessionId() != peerBlockFactory.getSessionId())   throw new IllegalStateException();
  resource.update(block.getPayload());
}","/** 
 * Handles a change in a remote resource.
 */
public void remoteUpdate(PeerConnection publisher,PeerBlock block){
  if (publisher != null)   updateId++;
  if (block.getUpdateId() != updateId)   throw new IllegalStateException(""String_Node_Str"" + updateId + ""String_Node_Str""+ block.getUpdateId());
  if (block.getSessionId() != peerBlockFactory.getSessionId())   throw new IllegalStateException();
  resource.update(block.getPayload());
}",0.7882653061224489
32769,"public int read(){
  ByteBuffer readBuffer=getReadFromBuffer();
  if (readBuffer == null)   return -1;
  byte result=readBuffer.get();
  doneReading();
  return result;
}","public int read(){
  ByteBuffer readBuffer=getReadFromBuffer();
  if (readBuffer == null)   return -1;
  int result=0xFF & readBuffer.get();
  doneReading();
  return result;
}",0.9653179190751444
32770,"/** 
 * Gets a new buffer by creating it or removing it from the pool.
 */
private ByteBuffer getNewBuffer(){
  int BUFFER_SIZE=8 * 1024;
  return ByteBuffer.allocateDirect(BUFFER_SIZE);
}","/** 
 * Gets a new buffer by creating it or removing it from the pool.
 */
private ByteBuffer getNewBuffer(){
  int BUFFER_SIZE=8196;
  return ByteBuffer.allocateDirect(BUFFER_SIZE);
}",0.978494623655914
32771,"/** 
 * Tests that a snapshot can be decoded.
 */
public void testSnapshotDecode() throws IOException {
  EventList toEncode=new BasicEventList();
  EventEncoderListener encoder=new EventEncoderListener(intCoder);
  toEncode.addListEventListener(encoder);
  EventList toDecode=new BasicEventList();
  toDecode.add(new Integer(1));
  toDecode.add(new Integer(2));
  toDecode.add(new Integer(4));
  List entireList=Arrays.asList(new Object[]{new Integer(8),new Integer(6),new Integer(7),new Integer(5),new Integer(3),new Integer(0),new Integer(9)});
  toEncode.addAll(entireList);
  Bufferlo entireListEncoding=(Bufferlo)encoder.getEncodings().remove(0);
  ListEventCoder.bytesToListEvent(entireListEncoding,toDecode,intCoder);
  assertEquals(toEncode,toDecode);
}","/** 
 * Tests that a snapshot can be decoded.
 */
public void testSnapshotDecode() throws IOException {
  EventList toEncode=new BasicEventList();
  EventList toDecode=new BasicEventList();
  toDecode.add(new Integer(1));
  toDecode.add(new Integer(2));
  toDecode.add(new Integer(4));
  List entireList=Arrays.asList(new Object[]{new Integer(8),new Integer(6),new Integer(7),new Integer(5),new Integer(3),new Integer(0),new Integer(9)});
  toEncode.addAll(entireList);
  Bufferlo entireListEncoding=ListEventCoder.listToBytes(toEncode,intCoder);
  ListEventCoder.bytesToListEvent(entireListEncoding,toDecode,intCoder);
  assertEquals(toEncode,toDecode);
}",0.8645980253878702
32772,"/** 
 * Compares two <code>Object</code>s, and compares them using the result given when each <code>Object</code> is evaluated using the underlying <code>ThresholdEvaluator</code>. <p>This method is dual-mode as in the case of the Objects passed being <code>Integer</code>s, it returns the value of <code>((Integer)alpha).intValue() - ((Integer)beta).intValue()</code>. This is necessary so that a threshold value can be compared against an <code>Object</code>, and vice versa.  This can cause problems however if the underlying <code>ThresholdEvaluator</code> were to return the negation of an <code>Integer</code>.
 */
public int compare(Object alpha,Object beta){
  int alphaValue=0;
  if (alpha instanceof Integer)   alphaValue=((Integer)alpha).intValue();
 else   alphaValue=evaluator.evaluate(alpha);
  int betaValue=0;
  if (beta instanceof Integer)   betaValue=((Integer)beta).intValue();
 else   betaValue=evaluator.evaluate(beta);
  return alphaValue - betaValue;
}","/** 
 * Compares two <code>Object</code>s, and compares them using the result given when each <code>Object</code> is evaluated using the underlying <code>ThresholdEvaluator</code>. <p>This method is dual-mode as in the case of the Objects passed being <code>Integer</code>s, it returns the value of <code>((Integer)alpha).intValue() - ((Integer)beta).intValue()</code>. This is necessary so that a threshold value can be compared against an <code>Object</code>, and vice versa.  This can cause problems however if the underlying <code>ThresholdEvaluator</code> were to return the negation of an <code>Integer</code>.
 */
public int compare(Object alpha,Object beta){
  int alphaValue=0;
  if (alpha instanceof Integer)   alphaValue=((Integer)alpha).intValue();
 else   alphaValue=evaluator.evaluate(alpha);
  int betaValue=0;
  if (beta instanceof Integer)   betaValue=((Integer)beta).intValue();
 else   betaValue=evaluator.evaluate(beta);
  if (alphaValue > betaValue)   return 1;
 else   if (alphaValue < betaValue)   return -1;
 else   return 0;
}",0.9358341559723592
32773,"/** 
 * Sets the upper threshold for this list. <p><strong><font color=""#FF0000"">Warning:</font></strong> This method is thread ready but not thread safe. See   {@link EventList} for an exampleof thread safe code.
 */
public void setUpperThreshold(int threshold){
  int newListIndex=0;
  if (sourceSize == 0) {
    upperThreshold=threshold;
    upperThresholdIndex=-1;
    return;
  }
 else   if (threshold == upperThreshold) {
    return;
  }
 else {
    newListIndex=((SortedList)source).indexOfSimulated(new Integer(threshold + 1)) - 1;
  }
  upperThreshold=threshold;
  if (newListIndex == upperThresholdIndex) {
    return;
  }
  if ((newListIndex == -1 && upperThresholdIndex == 0) || (newListIndex == 0 && upperThresholdIndex == -1) || (newListIndex == size() && upperThresholdIndex == size() - 1)|| (newListIndex == size() - 1 && upperThresholdIndex == size())) {
    upperThresholdIndex=newListIndex;
    return;
  }
  updates.beginEvent();
  if (newListIndex < upperThresholdIndex) {
    updates.addDelete(newListIndex + 1,upperThresholdIndex - Math.max(lowerThresholdIndex,0));
  }
 else   if (newListIndex > upperThresholdIndex) {
    updates.addInsert(upperThresholdIndex - Math.max(lowerThresholdIndex,0) + 1,newListIndex);
  }
  upperThresholdIndex=newListIndex;
  updates.commitEvent();
}","/** 
 * Sets the upper threshold for this list. <p><strong><font color=""#FF0000"">Warning:</font></strong> This method is thread ready but not thread safe. See   {@link EventList} for an exampleof thread safe code.
 */
public void setUpperThreshold(int threshold){
  int newListIndex=0;
  if (sourceSize == 0) {
    upperThreshold=threshold;
    upperThresholdIndex=-1;
    return;
  }
 else   if (threshold == upperThreshold) {
    return;
  }
 else {
    if (threshold == Integer.MAX_VALUE) {
      newListIndex=sourceSize - 1;
    }
 else {
      newListIndex=((SortedList)source).indexOfSimulated(new Integer(threshold + 1)) - 1;
    }
  }
  upperThreshold=threshold;
  if (newListIndex == upperThresholdIndex) {
    return;
  }
  if ((newListIndex == -1 && upperThresholdIndex == 0) || (newListIndex == 0 && upperThresholdIndex == -1) || (newListIndex == size() && upperThresholdIndex == size() - 1)|| (newListIndex == size() - 1 && upperThresholdIndex == size())) {
    upperThresholdIndex=newListIndex;
    return;
  }
  updates.beginEvent();
  if (newListIndex < upperThresholdIndex) {
    updates.addDelete(newListIndex + 1,upperThresholdIndex - Math.max(lowerThresholdIndex,0));
  }
 else   if (newListIndex > upperThresholdIndex) {
    updates.addInsert(upperThresholdIndex - Math.max(lowerThresholdIndex,0) + 1,newListIndex);
  }
  upperThresholdIndex=newListIndex;
  updates.commitEvent();
}",0.963428149242704
32774,"/** 
 * Compares two <code>Object</code>s, and compares them using the result given when each <code>Object</code> is evaluated using the underlying <code>ThresholdEvaluator</code>.
 */
public int compare(Object alpha,Object beta){
  int alphaValue=0;
  if (alpha instanceof Integer)   alphaValue=((Integer)alpha).intValue();
 else   alphaValue=evaluator.evaluate(alpha);
  int betaValue=0;
  if (beta instanceof Integer)   betaValue=((Integer)beta).intValue();
 else   betaValue=evaluator.evaluate(beta);
  return alphaValue - betaValue;
}","/** 
 * Compares two <code>Object</code>s, and compares them using the result given when each <code>Object</code> is evaluated using the underlying <code>ThresholdEvaluator</code>.
 */
public int compare(Object alpha,Object beta){
  int alphaValue=0;
  if (alpha instanceof Integer)   alphaValue=((Integer)alpha).intValue();
 else   alphaValue=evaluator.evaluate(alpha);
  int betaValue=0;
  if (beta instanceof Integer)   betaValue=((Integer)beta).intValue();
 else   betaValue=evaluator.evaluate(beta);
  if (alphaValue > betaValue)   return 1;
 else   if (alphaValue < betaValue)   return -1;
 else   return 0;
}",0.8873483535528596
32775,"/** 
 * Handle a chunk by parsing the contents of the input buffer. If the input buffer does not contain a complete chunk, this will return. If it does contain a chunk: <li>the chunk will be processed <li>if the chunk is empty, the connection will be closed <p>It is possible that the source stream is not chunked, as a consequence of an interfering proxy server. In this case, we arbitrarily form our own chunks which are as large as possible.
 * @return whether the expected data was read fully. This returns false if therewas an insufficient amount of data to satisfy the request.
 */
private boolean handleChunk(){
  try {
    if (sourceChunked) {
      int chunkEndIndex=parser.indexOf(""String_Node_Str"");
      if (chunkEndIndex == -1)       return false;
      String chunkSizeInHex=parser.readUntil(""String_Node_Str"",false);
      int chunkSize=Integer.parseInt(chunkSizeInHex,16);
      int bytesRequired=chunkEndIndex + 2 + chunkSize+ 2;
      if (bytesRequired > parser.bytesAvailable()) {
        return false;
      }
      parser.consume(""String_Node_Str"");
      ByteBuffer chunkBuffer=parser.readBytes(chunkSize);
      parser.consume(""String_Node_Str"");
      if (chunkSize != 0) {
        handler.receiveChunk(this,chunkBuffer);
        return true;
      }
 else {
        return close();
      }
    }
 else {
      int bytesAvailable=parser.bytesAvailable();
      ByteBuffer chunkBuffer=parser.readBytes(bytesAvailable);
      if (bytesAvailable != 0) {
        handler.receiveChunk(this,chunkBuffer);
        return true;
      }
 else {
        return false;
      }
    }
  }
 catch (  NumberFormatException e) {
    return close(e);
  }
catch (  ParseException e) {
    return close(e);
  }
catch (  IOException e) {
    return close(e);
  }
}","/** 
 * Handle a chunk by parsing the contents of the input buffer. If the input buffer does not contain a complete chunk, this will return. If it does contain a chunk: <li>the chunk will be processed <li>if the chunk is empty, the connection will be closed <p>It is possible that the source stream is not chunked, as a consequence of an interfering proxy server. In this case, we arbitrarily form our own chunks which are as large as possible.
 * @return whether the expected data was read fully. This returns false if therewas an insufficient amount of data to satisfy the request.
 */
private boolean handleChunk(){
  try {
    if (sourceChunked) {
      int chunkEndIndex=parser.indexOf(""String_Node_Str"");
      if (chunkEndIndex == -1)       return false;
      String chunkSizeInHex=parser.readUntil(""String_Node_Str"",false);
      int chunkSize=Integer.parseInt(chunkSizeInHex,16);
      int bytesRequired=chunkEndIndex + 2 + chunkSize+ 2;
      if (bytesRequired > parser.bytesAvailable()) {
        return false;
      }
      parser.consume(""String_Node_Str"");
      ByteBuffer chunkBuffer=parser.readBytes(chunkSize);
      parser.consume(""String_Node_Str"");
      if (chunkSize != 0) {
        handler.receiveChunk(this,chunkBuffer);
        return true;
      }
 else {
        return close();
      }
    }
 else {
      int bytesAvailable=parser.bytesAvailable();
      ByteBuffer chunkBuffer=parser.readBytes(bytesAvailable);
      if (bytesAvailable != 0) {
        handler.receiveChunk(this,chunkBuffer);
        return true;
      }
 else {
        return false;
      }
    }
  }
 catch (  NumberFormatException e) {
    return close(e);
  }
catch (  ParseException e) {
    return close(e);
  }
catch (  IOException e) {
    e.printStackTrace();
    return close(e);
  }
}",0.9929834409205726
32776,"/** 
 * Close the connection to the client.  <p>The closing behaviour is dictated by the current state of the connection and the reason for closing. <li>If the reason is an IOException, the socket is closed immediately <li>Otherwise a ""goodbye"" message is sent to notify the other party of the close <li>If the state is READY, the goodbye is a single 0-byte chunk <li>If the state is SERVER_AWAITING_REQUEST, the goodbye is a request error <li>If the state is RECEIVED_CLOSE, no goodbye message is sent
 * @return This method returns false because the connection is always in anunreadable and unwritable state after a close.
 */
boolean close(Exception reason){
  manager.invokeAndWait(new CTPConnectionToClose(this,reason));
  return false;
}","/** 
 * Close the connection to the client.  <p>The closing behaviour is dictated by the current state of the connection and the reason for closing. <li>If the reason is an IOException, the socket is closed immediately <li>Otherwise a ""goodbye"" message is sent to notify the other party of the close <li>If the state is READY, the goodbye is a single 0-byte chunk <li>If the state is SERVER_AWAITING_REQUEST, the goodbye is a request error <li>If the state is RECEIVED_CLOSE, no goodbye message is sent
 * @return This method returns false because the connection is always in anunreadable and unwritable state after a close.
 */
boolean close(Exception reason){
  manager.invokeLater(new CTPConnectionToClose(this,reason));
  return false;
}",0.9919137466307276
32777,"/** 
 * Fills the buffer with the contents of the channel. <p>This temporarily flips the buffer from read mode into write mode in order to add more bytes from the channel.
 * @return the number of bytes read, possibly 0 if there is nothing to read immediately
 * @throws IOException if the input buffer is full or if the end of the stream is reached
 */
private int suck() throws IOException {
  if (buffer.remaining() == buffer.capacity())   throw new IOException(""String_Node_Str"");
  buffer.compact();
  int bytesRead=channel.read(buffer);
  buffer.flip();
  if (bytesRead < 0)   throw new EOFException(""String_Node_Str"");
  return bytesRead;
}","/** 
 * Fills the buffer with the contents of the channel. <p>This temporarily flips the buffer from read mode into write mode in order to add more bytes from the channel.
 * @return the number of bytes read, possibly 0 if there is nothing to read immediately
 * @throws IOException if the input buffer is full or if the end of the stream is reached
 */
private int suck() throws IOException {
  if (buffer.remaining() == buffer.capacity())   throw new IOException(""String_Node_Str"");
  int bytesRead=suckle();
  if (bytesRead < 0)   throw new EOFException(""String_Node_Str"");
  return bytesRead;
}",0.951004016064257
32778,"/** 
 * Calculate how many bytes are ready to be read immediately.
 */
public int bytesAvailable() throws IOException {
  while (buffer.remaining() < buffer.capacity()) {
    int bytesRead=suck();
    if (bytesRead == 0)     break;
  }
  return buffer.remaining();
}","/** 
 * Calculate how many bytes are ready to be read immediately.
 */
public int bytesAvailable() throws IOException {
  suckle();
  return buffer.remaining();
}",0.7476635514018691
32779,"private void sendEnqueued(CTPConnection connection){
  while (tasks.size() > 0 && tasks.get(0) instanceof Enqueued) {
    Enqueued enqueued=(Enqueued)tasks.remove(0);
    connection.sendChunk(enqueued.getData());
  }
}","private void sendEnqueued(CTPConnection connection){
  while (tasks.size() > 0 && tasks.get(0) instanceof Enqueued) {
    Enqueued enqueued=(Enqueued)tasks.remove(0);
    connection.sendChunk(enqueued.getData());
  }
  if (tasks.isEmpty()) {
    connection.close();
  }
}",0.8916155419222904
32780,"public void connectionClosed(CTPConnection source,Exception reason){
  if (!tasks.isEmpty())   throw new IllegalStateException();
}","public void connectionClosed(CTPConnection source,Exception reason){
  if (!tasks.isEmpty())   throw new IllegalStateException(""String_Node_Str"" + this + ""String_Node_Str""+ tasks.size()+ ""String_Node_Str""+ tasks);
}",0.7572254335260116
32781,"/** 
 * {@inheritDoc} 
 */
public void listChanged(ListEvent listChanges){
  ListEvent firstPass=new ListEvent(listChanges);
  ListEvent secondPass=listChanges;
  LinkedList removedValues=new LinkedList();
  while (firstPass.next()) {
    int changeIndex=firstPass.getIndex();
    int changeType=firstPass.getType();
    if (changeType == ListEvent.INSERT) {
      duplicatesList.add(changeIndex,TEMP_UNIQUE);
    }
 else     if (changeType == ListEvent.UPDATE) {
      Object replaced=duplicatesList.get(changeIndex);
      if (replaced == UNIQUE) {
        if (changeIndex + 1 < duplicatesList.size() && duplicatesList.get(changeIndex + 1) == DUPLICATE) {
          duplicatesList.set(changeIndex,TEMP_UNIQUE);
          duplicatesList.set(changeIndex + 1,UNIQUE);
          replaced=null;
        }
      }
    }
 else     if (changeType == ListEvent.DELETE) {
      Object deleted=duplicatesList.remove(changeIndex);
      if (deleted == UNIQUE) {
        if (changeIndex < duplicatesList.size() && duplicatesList.get(changeIndex) == DUPLICATE) {
          duplicatesList.set(changeIndex,UNIQUE);
          deleted=TEMP_UNIQUE;
        }
      }
      removedValues.addLast(deleted);
    }
  }
  updates.beginEvent();
  while (secondPass.next()) {
    int changeIndex=secondPass.getIndex();
    int changeType=secondPass.getType();
    if (changeType == ListEvent.INSERT) {
      boolean hasNeighbour=handleOldNeighbour(changeIndex);
      if (hasNeighbour) {
        enqueueEvent(ListEvent.UPDATE,duplicatesList.getCompressedIndex(changeIndex,true),false);
      }
 else {
        enqueueEvent(ListEvent.INSERT,duplicatesList.getCompressedIndex(changeIndex),true);
      }
    }
 else     if (changeType == ListEvent.UPDATE) {
      Object updated=duplicatesList.get(changeIndex);
      boolean wasDuplicate=(updated == DUPLICATE);
      boolean hadDuplicate=(updated == TEMP_UNIQUE);
      boolean wasUnique=(updated == UNIQUE);
      boolean isUnique=!handleOldNeighbour(changeIndex);
      int compressedIndex=duplicatesList.getCompressedIndex(changeIndex,true);
      if (isUnique) {
        if (wasUnique) {
          enqueueEvent(ListEvent.UPDATE,compressedIndex,true);
        }
 else {
          if (wasDuplicate)           enqueueEvent(ListEvent.UPDATE,compressedIndex - 1,false);
          enqueueEvent(ListEvent.INSERT,compressedIndex,true);
          if (hadDuplicate)           enqueueEvent(ListEvent.UPDATE,compressedIndex + 1,false);
        }
      }
 else {
        if (wasUnique) {
          enqueueEvent(ListEvent.DELETE,compressedIndex,true);
          enqueueEvent(ListEvent.UPDATE,compressedIndex,false);
        }
 else {
          enqueueEvent(ListEvent.UPDATE,compressedIndex,false);
          if (compressedIndex + 1 < duplicatesList.getCompressedList().size())           enqueueEvent(ListEvent.UPDATE,compressedIndex + 1,false);
        }
      }
    }
 else     if (changeType == ListEvent.DELETE) {
      Object deleted=removedValues.removeFirst();
      int uncompressedIndex=-1;
      if (deleted == DUPLICATE)       uncompressedIndex=changeIndex - 1;
 else       uncompressedIndex=changeIndex;
      int deletedIndex=-1;
      if (uncompressedIndex < duplicatesList.size())       deletedIndex=duplicatesList.getCompressedIndex(uncompressedIndex,true);
 else       deletedIndex=duplicatesList.getCompressedList().size();
      if (deleted == UNIQUE) {
        enqueueEvent(ListEvent.DELETE,deletedIndex,true);
      }
 else {
        enqueueEvent(ListEvent.UPDATE,deletedIndex,false);
      }
    }
  }
  flushEnqueuedEvents();
  updates.commitEvent();
}","/** 
 * {@inheritDoc} 
 */
public void listChanged(ListEvent listChanges){
  ListEvent firstPass=new ListEvent(listChanges);
  ListEvent secondPass=listChanges;
  LinkedList removedValues=new LinkedList();
  while (firstPass.next()) {
    int changeIndex=firstPass.getIndex();
    int changeType=firstPass.getType();
    if (changeType == ListEvent.INSERT) {
      duplicatesList.add(changeIndex,TEMP_UNIQUE);
    }
 else     if (changeType == ListEvent.UPDATE) {
      Object replaced=duplicatesList.get(changeIndex);
      if (replaced == UNIQUE) {
        if (changeIndex + 1 < duplicatesList.size() && duplicatesList.get(changeIndex + 1) == DUPLICATE) {
          duplicatesList.set(changeIndex,TEMP_UNIQUE);
          duplicatesList.set(changeIndex + 1,UNIQUE);
          replaced=null;
        }
      }
    }
 else     if (changeType == ListEvent.DELETE) {
      Object deleted=duplicatesList.remove(changeIndex);
      if (deleted == UNIQUE) {
        if (changeIndex < duplicatesList.size() && duplicatesList.get(changeIndex) == DUPLICATE) {
          duplicatesList.set(changeIndex,UNIQUE);
          deleted=TEMP_UNIQUE;
        }
      }
      removedValues.addLast(deleted);
    }
  }
  updates.beginEvent();
  while (secondPass.next()) {
    int changeIndex=secondPass.getIndex();
    int changeType=secondPass.getType();
    if (changeType == ListEvent.INSERT) {
      int neighbourSide=handleOldNeighbour(changeIndex);
      if (neighbourSide != NEIGHBOUR_NONE) {
        enqueueEvent(ListEvent.UPDATE,duplicatesList.getCompressedIndex(changeIndex,true),false);
      }
 else {
        enqueueEvent(ListEvent.INSERT,duplicatesList.getCompressedIndex(changeIndex),true);
      }
    }
 else     if (changeType == ListEvent.UPDATE) {
      int oldNeighbourSide=0;
      Object updated=duplicatesList.get(changeIndex);
      if (updated == DUPLICATE)       oldNeighbourSide=NEIGHBOUR_LEFT;
 else       if (updated == TEMP_UNIQUE)       oldNeighbourSide=NEIGHBOUR_RIGHT;
 else       if (updated == UNIQUE)       oldNeighbourSide=NEIGHBOUR_NONE;
      int newNeighbourSide=handleOldNeighbour(changeIndex);
      int compressedIndex=duplicatesList.getCompressedIndex(changeIndex,true);
      if (newNeighbourSide == NEIGHBOUR_NONE) {
        if (oldNeighbourSide == NEIGHBOUR_NONE) {
          enqueueEvent(ListEvent.UPDATE,compressedIndex,true);
        }
 else         if (oldNeighbourSide == NEIGHBOUR_LEFT) {
          enqueueEvent(ListEvent.UPDATE,compressedIndex - 1,false);
          enqueueEvent(ListEvent.INSERT,compressedIndex,true);
        }
 else         if (oldNeighbourSide == NEIGHBOUR_RIGHT) {
          enqueueEvent(ListEvent.INSERT,compressedIndex,true);
          enqueueEvent(ListEvent.UPDATE,compressedIndex + 1,false);
        }
      }
 else       if (newNeighbourSide == NEIGHBOUR_LEFT) {
        if (oldNeighbourSide == NEIGHBOUR_NONE) {
          enqueueEvent(ListEvent.UPDATE,compressedIndex,false);
          enqueueEvent(ListEvent.DELETE,compressedIndex + 1,true);
        }
 else         if (oldNeighbourSide == NEIGHBOUR_LEFT) {
          enqueueEvent(ListEvent.UPDATE,compressedIndex,false);
        }
 else         if (oldNeighbourSide == NEIGHBOUR_RIGHT) {
          enqueueEvent(ListEvent.UPDATE,compressedIndex,false);
          if (compressedIndex + 1 < duplicatesList.getCompressedList().size())           enqueueEvent(ListEvent.UPDATE,compressedIndex + 1,false);
        }
      }
 else       if (newNeighbourSide == NEIGHBOUR_RIGHT) {
        if (oldNeighbourSide == NEIGHBOUR_NONE) {
          enqueueEvent(ListEvent.DELETE,compressedIndex,true);
          enqueueEvent(ListEvent.UPDATE,compressedIndex,false);
        }
 else         if (oldNeighbourSide == NEIGHBOUR_LEFT) {
          enqueueEvent(ListEvent.UPDATE,compressedIndex,false);
        }
 else         if (oldNeighbourSide == NEIGHBOUR_RIGHT) {
          enqueueEvent(ListEvent.UPDATE,compressedIndex,false);
        }
      }
    }
 else     if (changeType == ListEvent.DELETE) {
      Object deleted=removedValues.removeFirst();
      int uncompressedIndex=-1;
      if (deleted == DUPLICATE)       uncompressedIndex=changeIndex - 1;
 else       uncompressedIndex=changeIndex;
      int deletedIndex=-1;
      if (uncompressedIndex < duplicatesList.size())       deletedIndex=duplicatesList.getCompressedIndex(uncompressedIndex,true);
 else       deletedIndex=duplicatesList.getCompressedList().size();
      if (deleted == UNIQUE) {
        enqueueEvent(ListEvent.DELETE,deletedIndex,true);
      }
 else {
        enqueueEvent(ListEvent.UPDATE,deletedIndex,false);
      }
    }
  }
  flushEnqueuedEvents();
  updates.commitEvent();
}",0.780298435035788
32782,"/** 
 * Handles whether this change index has a neighbour that existed prior to a current change and that the values are equal. This adjusts the duplicates list a found pair of such changes if they exist.
 * @return true if a neighbour was found and the duplicates list has beenupdated in response. returns false if the specified index has no such neighbour. In this case the value at the specified index will be marked as unique (but not temporarily so).
 */
private boolean handleOldNeighbour(int changeIndex){
  if (valuesEqual(changeIndex - 1,changeIndex)) {
    duplicatesList.set(changeIndex,DUPLICATE);
    return true;
  }
  int followerIndex=changeIndex + 1;
  while (true) {
    if (valuesEqual(changeIndex,followerIndex)) {
      Object followerType=duplicatesList.get(followerIndex);
      if (followerType == TEMP_UNIQUE) {
        followerIndex++;
      }
 else {
        duplicatesList.set(changeIndex,UNIQUE);
        duplicatesList.set(followerIndex,null);
        return true;
      }
    }
 else {
      duplicatesList.set(changeIndex,UNIQUE);
      return false;
    }
  }
}","/** 
 * Handles whether this change index has a neighbour that existed prior to a current change and that the values are equal. This adjusts the duplicates list a found pair of such changes if they exist.
 * @return NEIGHBOUR_NONE if no neighbour was found. In this case the value at the specifiedindex will be marked as unique, but not temporarily so. Returns NEIGHBOUR_LEFT if a neighbour was found on the left, and NEIGHBOUR_RIGHT if a neighbour was found on the right. In non-zero cases the duplicates list is updated.
 */
private int handleOldNeighbour(int changeIndex){
  if (valuesEqual(changeIndex - 1,changeIndex)) {
    duplicatesList.set(changeIndex,DUPLICATE);
    return NEIGHBOUR_LEFT;
  }
  int followerIndex=changeIndex + 1;
  while (true) {
    if (valuesEqual(changeIndex,followerIndex)) {
      Object followerType=duplicatesList.get(followerIndex);
      if (followerType == TEMP_UNIQUE) {
        followerIndex++;
      }
 else {
        duplicatesList.set(changeIndex,UNIQUE);
        duplicatesList.set(followerIndex,null);
        return NEIGHBOUR_RIGHT;
      }
    }
 else {
      duplicatesList.set(changeIndex,UNIQUE);
      return NEIGHBOUR_NONE;
    }
  }
}",0.7680841736080667
32783,"/** 
 * For implementing the ListEventListener interface.
 */
public void listChanged(ListEvent listChanges){
  if (verbose) {
    System.out.println(name + ""String_Node_Str"" + listChanges);
  }
  int highestChangeIndex=0;
  while (listChanges.next()) {
    int changeIndex=listChanges.getIndex();
    int changeType=listChanges.getType();
    if (changeIndex < highestChangeIndex) {
      new Exception(name + ""String_Node_Str"" + changeCount+ ""String_Node_Str""+ changeIndex+ ""String_Node_Str""+ highestChangeIndex+ ""String_Node_Str""+ listChanges).printStackTrace();
    }
    highestChangeIndex=changeIndex;
    if (changeIndex < 0)     new Exception(name + ""String_Node_Str"" + changeCount+ ""String_Node_Str""+ changeIndex+ ""String_Node_Str""+ listChanges).printStackTrace();
    if (changeType == ListEvent.INSERT) {
      if (changeIndex > size)       new Exception(name + ""String_Node_Str"" + changeCount+ ""String_Node_Str""+ changeIndex+ ""String_Node_Str""+ size+ ""String_Node_Str""+ listChanges).printStackTrace();
      size++;
    }
 else     if (changeType == ListEvent.DELETE) {
      if (changeIndex >= size)       new Exception(name + ""String_Node_Str"" + changeCount+ ""String_Node_Str""+ changeIndex+ ""String_Node_Str""+ size+ ""String_Node_Str""+ listChanges).printStackTrace();
      size--;
    }
 else     if (changeType == ListEvent.UPDATE) {
      if (changeIndex >= size)       new Exception(name + ""String_Node_Str"" + changeCount+ ""String_Node_Str""+ changeIndex+ ""String_Node_Str""+ size+ ""String_Node_Str""+ listChanges).printStackTrace();
    }
  }
  if (size != source.size()) {
    new Exception(name + ""String_Node_Str"" + changeCount+ ""String_Node_Str""+ size+ ""String_Node_Str""+ source.size()+ ""String_Node_Str""+ listChanges).printStackTrace();
  }
  changeCount++;
}","/** 
 * For implementing the ListEventListener interface.
 */
public void listChanged(ListEvent listChanges){
  if (verbose)   System.out.println(name + ""String_Node_Str"" + listChanges);
  List changedIndices=new ArrayList();
  int highestChangeIndex=0;
  while (listChanges.next()) {
    int changeIndex=listChanges.getIndex();
    int changeType=listChanges.getType();
    changedIndices.add(new Integer(changeIndex));
    Assert.assertTrue(changeIndex >= 0);
    Assert.assertTrue(changeIndex >= highestChangeIndex);
    highestChangeIndex=changeIndex;
    if (changeType == ListEvent.INSERT) {
      expected.add(changeIndex,source.get(changeIndex));
    }
 else     if (changeType == ListEvent.DELETE) {
      expected.remove(changeIndex);
    }
 else     if (changeType == ListEvent.UPDATE) {
      expected.set(changeIndex,source.get(changeIndex));
    }
  }
  Assert.assertEquals(expected.size(),source.size());
  for (Iterator c=changedIndices.iterator(); c.hasNext(); ) {
    int changeIndex=((Integer)c.next()).intValue();
    for (int i=Math.max(changeIndex - 1,0); i < Math.min(changeIndex + 2,expected.size()); i++) {
      Assert.assertEquals(expected.get(i),source.get(i));
    }
  }
}",0.3657718120805369
32784,"/** 
 * Creates a new filter list that uses a TextFilterator. A TextFilterator is something that I made up. It is basically a class that knows how to take an arbitrary object and get an array of strings for that object.
 */
public TextFilterList(EventList source,Text filterEdit,TextFilterator filterator){
  super(source);
  this.filterEdit=filterEdit;
  this.filterator=filterator;
  filterModifyListener=new FilterModifyListener();
  filterEdit.addModifyListener(filterModifyListener);
  reFilter();
}","/** 
 * Creates a new filter list that uses a TextFilterator. A TextFilterator is something that I made up. It is basically a class that knows how to take an arbitrary object and get an array of strings for that object.
 */
public TextFilterList(EventList source,Text filterEdit,TextFilterator filterator){
  super(source,filterator);
  this.filterEdit=filterEdit;
  filterModifyListener=new FilterModifyListener();
  filterEdit.addModifyListener(filterModifyListener);
  reFilter();
}",0.9585439838220424
32785,"private PopularityList(EventList source,UniqueList uniqueList){
  super(new SortedList(uniqueList,new PopularityComparator(uniqueList)));
  uniqueList.setFireCountChangeEvents(true);
}","private PopularityList(EventList source,UniqueList uniqueList){
  super(new SortedList(uniqueList,new PopularityComparator(uniqueList)));
  this.uniqueList=uniqueList;
  uniqueList.setFireCountChangeEvents(true);
  ((SortedList)super.source).addListEventListener(this);
}",0.8087912087912088
32786,"/** 
 * {@inheritDoc} 
 */
public void dispose(){
  ((TransformedList)source).dispose();
  super.dispose();
}","/** 
 * {@inheritDoc} 
 */
public void dispose(){
  SortedList sortedSource=(SortedList)source;
  super.dispose();
  sortedSource.dispose();
  uniqueList.dispose();
}",0.6472727272727272
32787,"/** 
 * For implementing the ListEventListener interface. When the underlying list changes, this notification allows the object to repaint itself or update itself as necessary.
 */
public void listChanged(ListEvent listChanges){
  if (listChanges.isReordering()) {
    int[] reorderMap=listChanges.getReorderMap();
    IndexedTreeNode[] sortedNodes=new IndexedTreeNode[sorted.size()];
    int index=0;
    for (Iterator i=unsorted.iterator(); i.hasNext(); index++) {
      IndexedTreeNode unsortedNode=(IndexedTreeNode)i.next();
      IndexedTreeNode sortedNode=(IndexedTreeNode)unsortedNode.getValue();
      sortedNodes[index]=sortedNode;
    }
    index=0;
    for (Iterator i=unsorted.iterator(); i.hasNext(); index++) {
      IndexedTreeNode unsortedNode=(IndexedTreeNode)i.next();
      unsortedNode.setValue(sortedNodes[reorderMap[index]]);
      sortedNodes[reorderMap[index]].setValue(unsortedNode);
    }
    return;
  }
  updates.beginEvent();
  LinkedList insertNodes=new LinkedList();
  ListEvent firstPass=new ListEvent(listChanges);
  while (firstPass.next()) {
    int unsortedIndex=firstPass.getIndex();
    int changeType=firstPass.getType();
    if (changeType == ListEvent.INSERT) {
      IndexedTreeNode unsortedNode=unsorted.addByNode(unsortedIndex,this);
      insertNodes.addLast(unsortedNode);
    }
 else     if (changeType == ListEvent.DELETE) {
      IndexedTreeNode unsortedNode=unsorted.getNode(unsortedIndex);
      unsortedNode.removeFromTree();
      int deleteSortedIndex=deleteByUnsortedNode(unsortedNode);
      updates.addDelete(deleteSortedIndex);
    }
 else     if (changeType == ListEvent.UPDATE) {
    }
  }
  IndicesPendingDeletion indicesPendingDeletion=new IndicesPendingDeletion();
  ListEvent secondPass=new ListEvent(listChanges);
  while (secondPass.next()) {
    int unsortedIndex=secondPass.getIndex();
    int changeType=secondPass.getType();
    if (changeType == ListEvent.UPDATE) {
      IndexedTreeNode unsortedNode=unsorted.getNode(unsortedIndex);
      IndexedTreeNode sortedNode=(IndexedTreeNode)unsortedNode.getValue();
      int originalIndex=sortedNode.getIndex();
      indicesPendingDeletion.addPair(new IndexNodePair(originalIndex,unsortedNode));
    }
  }
  ListEvent thirdPass=listChanges;
  while (thirdPass.next()) {
    int unsortedIndex=thirdPass.getIndex();
    int changeType=thirdPass.getType();
    if (changeType == ListEvent.UPDATE) {
      IndexedTreeNode unsortedNode=unsorted.getNode(unsortedIndex);
      int deleteSortedIndex=deleteByUnsortedNode(unsortedNode);
    }
  }
  while (indicesPendingDeletion.hasPair()) {
    IndexNodePair indexNodePair=indicesPendingDeletion.removePair();
    int insertedIndex=insertByUnsortedNode(indexNodePair.node);
    int deletedIndex=indexNodePair.index;
    insertedIndex=indicesPendingDeletion.adjustDeleteAndInsert(deletedIndex,insertedIndex);
    if (deletedIndex == insertedIndex) {
      updates.addUpdate(insertedIndex);
    }
 else {
      updates.addDelete(deletedIndex);
      updates.addInsert(insertedIndex);
    }
  }
  while (!insertNodes.isEmpty()) {
    IndexedTreeNode insertNode=(IndexedTreeNode)insertNodes.removeFirst();
    int insertedIndex=insertByUnsortedNode(insertNode);
    updates.addInsert(insertedIndex);
  }
  updates.commitEvent();
}","/** 
 * {@inheritDoc} 
 */
public void listChanged(ListEvent listChanges){
  if (listChanges.isReordering()) {
    int[] reorderMap=listChanges.getReorderMap();
    IndexedTreeNode[] sortedNodes=new IndexedTreeNode[sorted.size()];
    int index=0;
    for (Iterator i=unsorted.iterator(); i.hasNext(); index++) {
      IndexedTreeNode unsortedNode=(IndexedTreeNode)i.next();
      IndexedTreeNode sortedNode=(IndexedTreeNode)unsortedNode.getValue();
      sortedNodes[index]=sortedNode;
    }
    index=0;
    for (Iterator i=unsorted.iterator(); i.hasNext(); index++) {
      IndexedTreeNode unsortedNode=(IndexedTreeNode)i.next();
      unsortedNode.setValue(sortedNodes[reorderMap[index]]);
      sortedNodes[reorderMap[index]].setValue(unsortedNode);
    }
    return;
  }
  updates.beginEvent();
  LinkedList insertNodes=new LinkedList();
  ListEvent firstPass=new ListEvent(listChanges);
  while (firstPass.next()) {
    int unsortedIndex=firstPass.getIndex();
    int changeType=firstPass.getType();
    if (changeType == ListEvent.INSERT) {
      IndexedTreeNode unsortedNode=unsorted.addByNode(unsortedIndex,this);
      insertNodes.addLast(unsortedNode);
    }
 else     if (changeType == ListEvent.DELETE) {
      IndexedTreeNode unsortedNode=unsorted.getNode(unsortedIndex);
      unsortedNode.removeFromTree();
      int deleteSortedIndex=deleteByUnsortedNode(unsortedNode);
      updates.addDelete(deleteSortedIndex);
    }
 else     if (changeType == ListEvent.UPDATE) {
    }
  }
  IndicesPendingDeletion indicesPendingDeletion=new IndicesPendingDeletion();
  ListEvent secondPass=new ListEvent(listChanges);
  while (secondPass.next()) {
    int unsortedIndex=secondPass.getIndex();
    int changeType=secondPass.getType();
    if (changeType == ListEvent.UPDATE) {
      IndexedTreeNode unsortedNode=unsorted.getNode(unsortedIndex);
      IndexedTreeNode sortedNode=(IndexedTreeNode)unsortedNode.getValue();
      int originalIndex=sortedNode.getIndex();
      indicesPendingDeletion.addPair(new IndexNodePair(originalIndex,unsortedNode));
    }
  }
  ListEvent thirdPass=listChanges;
  while (thirdPass.next()) {
    int unsortedIndex=thirdPass.getIndex();
    int changeType=thirdPass.getType();
    if (changeType == ListEvent.UPDATE) {
      IndexedTreeNode unsortedNode=unsorted.getNode(unsortedIndex);
      int deleteSortedIndex=deleteByUnsortedNode(unsortedNode);
    }
  }
  while (indicesPendingDeletion.hasPair()) {
    IndexNodePair indexNodePair=indicesPendingDeletion.removePair();
    int insertedIndex=insertByUnsortedNode(indexNodePair.node);
    int deletedIndex=indexNodePair.index;
    insertedIndex=indicesPendingDeletion.adjustDeleteAndInsert(deletedIndex,insertedIndex);
    if (deletedIndex == insertedIndex) {
      updates.addUpdate(insertedIndex);
    }
 else {
      updates.addDelete(deletedIndex);
      updates.addInsert(insertedIndex);
    }
  }
  while (!insertNodes.isEmpty()) {
    IndexedTreeNode insertNode=(IndexedTreeNode)insertNodes.removeFirst();
    int insertedIndex=insertByUnsortedNode(insertNode);
    updates.addInsert(insertedIndex);
  }
  updates.commitEvent();
}",0.972560024945432
32788,"/** 
 * {@inheritDoc} 
 */
public void dispose(){
  ((TransformedList)source).dispose();
  super.dispose();
}","/** 
 * {@inheritDoc} 
 */
public void dispose(){
  SortedList sortedSource=(SortedList)source;
  super.dispose();
  sortedSource.dispose();
}",0.7091633466135459
32789,"/** 
 * Respond to a change in the source   {@link EventList} by updating the internalstate of this  {@link TransformedList}. If the state of this   {@link TransformedList}changes as a consequence, all interested   {@link ListEventListener}s will be notified in turn.
 */
public abstract void listChanged(ListEvent listChanges);","/** 
 * {@inheritDoc} 
 */
public abstract void listChanged(ListEvent listChanges);",0.3746958637469586
32790,"/** 
 * Releases the resources consumed by this   {@link TransformedList} so that itmay eventually be garbage collected. <p>A  {@link TransformedList} will be garbage collected without a call to{@link #dispose()}, but not before its source   {@link EventList} is garbagecollected. By calling  {@link #dispose()}, you allow the   {@link TransformedList}to be garbage collected before its source   {@link EventList}. This is  necessary for situations where a   {@link TransformedList} is short-lived butits source  {@link EventList} is long-lived.<p><strong><font color=""#FF0000"">Warning:</font></strong> It is an error to call any method on a  {@link TransformedList} after it has been disposed.
 */
public void dispose(){
  source.removeListEventListener(this);
  source=null;
  readWriteLock=null;
}","/** 
 * Releases the resources consumed by this   {@link TransformedList} so that itmay eventually be garbage collected. <p>A  {@link TransformedList} will be garbage collected without a call to{@link #dispose()}, but not before its source   {@link EventList} is garbagecollected. By calling  {@link #dispose()}, you allow the   {@link TransformedList}to be garbage collected before its source   {@link EventList}. This is  necessary for situations where a   {@link TransformedList} is short-lived butits source  {@link EventList} is long-lived.<p><strong><font color=""#FF0000"">Warning:</font></strong> It is an error to call any method on a  {@link TransformedList} after it has been disposed.
 */
public void dispose(){
  source.removeListEventListener(this);
  source=null;
  readWriteLock=null;
  updates=null;
  publisher=null;
}",0.97796817625459
32791,"/** 
 * {@inheritDoc} 
 */
public void listChanged(ListEvent listChanges){
  ListEvent firstPass=new ListEvent(listChanges);
  ListEvent secondPass=listChanges;
  LinkedList removedValues=new LinkedList();
  while (firstPass.next()) {
    int changeIndex=firstPass.getIndex();
    int changeType=firstPass.getType();
    if (changeType == ListEvent.INSERT) {
      duplicatesList.add(changeIndex,TEMP_UNIQUE);
    }
 else     if (changeType == ListEvent.UPDATE) {
      Object replaced=duplicatesList.get(changeIndex);
      if (replaced == UNIQUE) {
        if (changeIndex + 1 < duplicatesList.size() && duplicatesList.get(changeIndex + 1) == DUPLICATE) {
          duplicatesList.set(changeIndex,TEMP_UNIQUE);
          duplicatesList.set(changeIndex + 1,UNIQUE);
          replaced=null;
        }
      }
    }
 else     if (changeType == ListEvent.DELETE) {
      Object deleted=duplicatesList.remove(changeIndex);
      if (deleted == UNIQUE) {
        if (changeIndex < duplicatesList.size() && duplicatesList.get(changeIndex) == DUPLICATE) {
          duplicatesList.set(changeIndex,UNIQUE);
          deleted=null;
        }
      }
      removedValues.addLast(deleted);
    }
  }
  updates.beginEvent();
  while (secondPass.next()) {
    int changeIndex=secondPass.getIndex();
    int changeType=secondPass.getType();
    if (changeType == ListEvent.INSERT) {
      boolean hasNeighbour=handleOldNeighbour(changeIndex);
      if (hasNeighbour) {
        enqueueEvent(ListEvent.UPDATE,duplicatesList.getCompressedIndex(changeIndex,true),false);
      }
 else {
        enqueueEvent(ListEvent.INSERT,duplicatesList.getCompressedIndex(changeIndex),true);
      }
    }
 else     if (changeType == ListEvent.UPDATE) {
      boolean wasUnique=(duplicatesList.get(changeIndex) == UNIQUE);
      boolean hasNeighbour=handleOldNeighbour(changeIndex);
      if (hasNeighbour) {
        if (wasUnique) {
          enqueueEvent(ListEvent.DELETE,duplicatesList.getCompressedIndex(changeIndex,true),true);
        }
 else {
          enqueueEvent(ListEvent.UPDATE,duplicatesList.getCompressedIndex(changeIndex,true),false);
        }
      }
 else {
        if (wasUnique) {
          enqueueEvent(ListEvent.UPDATE,duplicatesList.getCompressedIndex(changeIndex),true);
        }
 else {
          enqueueEvent(ListEvent.INSERT,duplicatesList.getCompressedIndex(changeIndex),true);
        }
      }
    }
 else     if (changeType == ListEvent.DELETE) {
      boolean wasUnique=(removedValues.removeFirst() == UNIQUE);
      int deletedIndex=-1;
      if (changeIndex < duplicatesList.size())       deletedIndex=duplicatesList.getCompressedIndex(changeIndex,true);
 else       deletedIndex=duplicatesList.getCompressedList().size();
      if (wasUnique) {
        enqueueEvent(ListEvent.DELETE,deletedIndex,true);
      }
 else {
        enqueueEvent(ListEvent.UPDATE,deletedIndex,false);
      }
    }
  }
  flushEnqueuedEvents();
  updates.commitEvent();
}","/** 
 * {@inheritDoc} 
 */
public void listChanged(ListEvent listChanges){
  ListEvent firstPass=new ListEvent(listChanges);
  ListEvent secondPass=listChanges;
  LinkedList removedValues=new LinkedList();
  while (firstPass.next()) {
    int changeIndex=firstPass.getIndex();
    int changeType=firstPass.getType();
    if (changeType == ListEvent.INSERT) {
      duplicatesList.add(changeIndex,TEMP_UNIQUE);
    }
 else     if (changeType == ListEvent.UPDATE) {
      Object replaced=duplicatesList.get(changeIndex);
      if (replaced == UNIQUE) {
        if (changeIndex + 1 < duplicatesList.size() && duplicatesList.get(changeIndex + 1) == DUPLICATE) {
          duplicatesList.set(changeIndex,TEMP_UNIQUE);
          duplicatesList.set(changeIndex + 1,UNIQUE);
          replaced=null;
        }
      }
    }
 else     if (changeType == ListEvent.DELETE) {
      Object deleted=duplicatesList.remove(changeIndex);
      if (deleted == UNIQUE) {
        if (changeIndex < duplicatesList.size() && duplicatesList.get(changeIndex) == DUPLICATE) {
          duplicatesList.set(changeIndex,UNIQUE);
          deleted=TEMP_UNIQUE;
        }
      }
      removedValues.addLast(deleted);
    }
  }
  updates.beginEvent();
  while (secondPass.next()) {
    int changeIndex=secondPass.getIndex();
    int changeType=secondPass.getType();
    if (changeType == ListEvent.INSERT) {
      int hasNeighbour=handleOldNeighbour(changeIndex);
      if (hasNeighbour != 0) {
        enqueueEvent(ListEvent.UPDATE,duplicatesList.getCompressedIndex(changeIndex,true),false);
      }
 else {
        enqueueEvent(ListEvent.INSERT,duplicatesList.getCompressedIndex(changeIndex),true);
      }
    }
 else     if (changeType == ListEvent.UPDATE) {
      Object updated=duplicatesList.get(changeIndex);
      boolean hadDuplicateOnRight=(updated == TEMP_UNIQUE);
      boolean hadDuplicateOnLeft=(updated == DUPLICATE);
      boolean hadNoDuplicate=(updated == DUPLICATE);
      int hasNeighbour=handleOldNeighbour(changeIndex);
      boolean duplicateOnRight=(hasNeighbour == 1);
      boolean duplicateOnLeft=(hasNeighbour == -1);
      boolean noDuplicate=(hasNeighbour == 0);
      int compressedIndex=duplicatesList.getCompressedIndex(changeIndex,true);
      int rightNeighbourIndex=compressedIndex + 1;
      if (hadDuplicateOnLeft)       enqueueEvent(ListEvent.UPDATE,compressedIndex - 1,false);
      if (hasNeighbour != 0) {
        if (updated == UNIQUE) {
          enqueueEvent(ListEvent.DELETE,compressedIndex,true);
          rightNeighbourIndex--;
        }
 else {
          enqueueEvent(ListEvent.UPDATE,compressedIndex,false);
        }
      }
 else {
        if (updated == UNIQUE) {
          enqueueEvent(ListEvent.UPDATE,compressedIndex,true);
        }
 else {
          enqueueEvent(ListEvent.INSERT,compressedIndex,true);
        }
      }
      if (rightNeighbourIndex < duplicatesList.getCompressedList().size())       enqueueEvent(ListEvent.UPDATE,rightNeighbourIndex,false);
    }
 else     if (changeType == ListEvent.DELETE) {
      Object deleted=removedValues.removeFirst();
      int uncompressedIndex=-1;
      if (deleted == DUPLICATE)       uncompressedIndex=changeIndex - 1;
 else       uncompressedIndex=changeIndex;
      int deletedIndex=-1;
      if (uncompressedIndex < duplicatesList.size())       deletedIndex=duplicatesList.getCompressedIndex(uncompressedIndex,true);
 else       deletedIndex=duplicatesList.getCompressedList().size();
      if (deleted == UNIQUE) {
        enqueueEvent(ListEvent.DELETE,deletedIndex,true);
      }
 else {
        enqueueEvent(ListEvent.UPDATE,deletedIndex,false);
      }
    }
  }
  flushEnqueuedEvents();
  updates.commitEvent();
}",0.6222956730769231
32792,"/** 
 * Handles whether this change index has a neighbour that existed prior to a current change and that the values are equal. This adjusts the duplicates list a found pair of such changes if they exist.
 * @return true if a neighbour was found and the duplicates list has beenupdated in response. returns false if the specified index has no such neighbour. In this case the value at the specified index will be marked as unique (but not temporarily so).
 */
private boolean handleOldNeighbour(int changeIndex){
  if (valuesEqual(changeIndex - 1,changeIndex)) {
    duplicatesList.set(changeIndex,DUPLICATE);
    return true;
  }
  int followerIndex=changeIndex + 1;
  while (true) {
    if (valuesEqual(changeIndex,followerIndex)) {
      Object followerType=duplicatesList.get(followerIndex);
      if (followerType == TEMP_UNIQUE) {
        followerIndex++;
      }
 else {
        duplicatesList.set(changeIndex,UNIQUE);
        duplicatesList.set(followerIndex,null);
        return true;
      }
    }
 else {
      duplicatesList.set(changeIndex,UNIQUE);
      return false;
    }
  }
}","/** 
 * Handles whether this change index has a neighbour that existed prior to a current change and that the values are equal. This adjusts the duplicates list a found pair of such changes if they exist.
 * @return true if a neighbour was found and the duplicates list has beenupdated in response. returns false if the specified index has no such neighbour. In this case the value at the specified index will be marked as unique (but not temporarily so).
 * @return -1 if a neighbour was found on the left and the duplicates listhas been updated in response. Returns 1 if a neighbour was found on the right. Returns 0 if the specified index has no such neighbour. In this case the value at the specified index will be marked as unique (but not temporarily so).
 */
private int handleOldNeighbour(int changeIndex){
  if (valuesEqual(changeIndex - 1,changeIndex)) {
    duplicatesList.set(changeIndex,DUPLICATE);
    return -1;
  }
  int followerIndex=changeIndex + 1;
  while (true) {
    if (valuesEqual(changeIndex,followerIndex)) {
      Object followerType=duplicatesList.get(followerIndex);
      if (followerType == TEMP_UNIQUE) {
        followerIndex++;
      }
 else {
        duplicatesList.set(changeIndex,UNIQUE);
        duplicatesList.set(followerIndex,null);
        return 1;
      }
    }
 else {
      duplicatesList.set(changeIndex,UNIQUE);
      return 0;
    }
  }
}",0.8657799274486094
32793,"/** 
 * {@inheritDoc} 
 */
public void dispose(){
  ((TransformedList)source).dispose();
  super.dispose();
}","/** 
 * {@inheritDoc} 
 */
public void dispose(){
  SortedList sortedSource=(SortedList)source;
  super.dispose();
  sortedSource.dispose();
}",0.7091633466135459
32794,"/** 
 * Test that the Popularity List works with simple data.
 */
public void testSimpleData(){
  EventList source=new BasicEventList();
  PopularityList popularityList=new PopularityList(source);
  source.add(""String_Node_Str"");
  source.add(""String_Node_Str"");
  source.add(""String_Node_Str"");
  source.add(""String_Node_Str"");
  source.add(""String_Node_Str"");
  source.add(""String_Node_Str"");
  source.add(""String_Node_Str"");
  source.add(""String_Node_Str"");
  source.add(""String_Node_Str"");
  source.add(""String_Node_Str"");
  assertEquals(""String_Node_Str"",popularityList.get(0));
  assertEquals(""String_Node_Str"",popularityList.get(1));
  source.add(""String_Node_Str"");
  source.add(""String_Node_Str"");
  source.remove(""String_Node_Str"");
  source.remove(""String_Node_Str"");
  assertEquals(""String_Node_Str"",popularityList.get(0));
  assertEquals(""String_Node_Str"",popularityList.get(1));
  source.add(""String_Node_Str"");
  source.add(""String_Node_Str"");
  source.add(""String_Node_Str"");
  assertEquals(""String_Node_Str"",popularityList.get(0));
  assertEquals(""String_Node_Str"",popularityList.get(1));
  assertEquals(""String_Node_Str"",popularityList.get(2));
  source.clear();
}","/** 
 * Test that the Popularity List works with simple data.
 */
public void testSimpleData(){
  EventList source=new BasicEventList();
  PopularityList popularityList=new PopularityList(source);
  source.add(""String_Node_Str"");
  source.add(""String_Node_Str"");
  source.add(""String_Node_Str"");
  source.add(""String_Node_Str"");
  source.add(""String_Node_Str"");
  source.add(""String_Node_Str"");
  source.add(""String_Node_Str"");
  source.add(""String_Node_Str"");
  source.add(""String_Node_Str"");
  source.add(""String_Node_Str"");
  assertEquals(""String_Node_Str"",popularityList.get(0));
  assertEquals(""String_Node_Str"",popularityList.get(1));
  validateRanked(popularityList,source);
  source.add(""String_Node_Str"");
  source.add(""String_Node_Str"");
  source.remove(""String_Node_Str"");
  source.remove(""String_Node_Str"");
  assertEquals(""String_Node_Str"",popularityList.get(0));
  assertEquals(""String_Node_Str"",popularityList.get(1));
  validateRanked(popularityList,source);
  source.add(""String_Node_Str"");
  source.add(""String_Node_Str"");
  source.add(""String_Node_Str"");
  assertEquals(""String_Node_Str"",popularityList.get(0));
  assertEquals(""String_Node_Str"",popularityList.get(1));
  assertEquals(""String_Node_Str"",popularityList.get(2));
  validateRanked(popularityList,source);
  source.clear();
}",0.9505428226779252
32795,"/** 
 * Display a frame for browsing issues.
 */
private JPanel constructView(){
  JPanel panel=new JPanel();
  panel.setLayout(new GridBagLayout());
  IssuesUserFilter issuesUserFiltered=new IssuesUserFilter(issuesEventList);
  SortedList issuesSortedList=new SortedList(issuesUserFiltered);
  TextFilterList issuesTextFiltered=new TextFilterList(issuesSortedList);
  EventTableModel issuesTableModel=new EventTableModel(issuesTextFiltered,new IssueTableFormat());
  JTable issuesJTable=new JTable(issuesTableModel);
  issuesSelectionModel=new EventSelectionModel(issuesTextFiltered);
  issuesSelectionModel.getListSelectionModel().addListSelectionListener(new IssuesSelectionListener());
  issuesJTable.setSelectionModel(issuesSelectionModel.getListSelectionModel());
  issuesJTable.getColumnModel().getColumn(0).setPreferredWidth(10);
  issuesJTable.getColumnModel().getColumn(1).setPreferredWidth(30);
  issuesJTable.getColumnModel().getColumn(2).setPreferredWidth(10);
  issuesJTable.getColumnModel().getColumn(3).setPreferredWidth(30);
  issuesJTable.getColumnModel().getColumn(4).setPreferredWidth(30);
  issuesJTable.getColumnModel().getColumn(5).setPreferredWidth(200);
  TableComparatorChooser tableSorter=new TableComparatorChooser(issuesJTable,issuesSortedList,true);
  JScrollPane issuesTableScrollPane=new JScrollPane(issuesJTable);
  JScrollPane usersListScrollPane=new JScrollPane(issuesUserFiltered.getUserSelect());
  EventTableModel descriptionsTableModel=new EventTableModel(descriptions,new DescriptionTableFormat());
  JTable descriptionsTable=new JTable(descriptionsTableModel);
  descriptionsTable.getColumnModel().getColumn(0).setCellRenderer(new DescriptionRenderer());
  JScrollPane descriptionsTableScrollPane=new JScrollPane(descriptionsTable);
  panel.add(usersListScrollPane,new GridBagConstraints(0,0,1,2,0.3,0.5,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(5,5,5,5),0,0));
  panel.add(new JLabel(""String_Node_Str""),new GridBagConstraints(1,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(5,0,5,5),0,0));
  panel.add(issuesTextFiltered.getFilterEdit(),new GridBagConstraints(2,0,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(5,0,5,5),0,0));
  panel.add(issuesTableScrollPane,new GridBagConstraints(1,1,2,1,0.7,0.5,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,5,5),0,0));
  panel.add(descriptionsTableScrollPane,new GridBagConstraints(0,2,3,1,1.0,0.5,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,5,5,5),0,0));
  return panel;
}","/** 
 * Display a frame for browsing issues.
 */
private JPanel constructView(){
  JPanel panel=new JPanel();
  panel.setLayout(new GridBagLayout());
  IssuesUserFilter issuesUserFiltered=new IssuesUserFilter(issuesEventList);
  SortedList issuesSortedList=new SortedList(issuesUserFiltered);
  TextFilterList issuesTextFiltered=new TextFilterList(issuesSortedList);
  EventTableModel issuesTableModel=new EventTableModel(issuesTextFiltered,new IssueTableFormat());
  JTable issuesJTable=new JTable(issuesTableModel);
  issuesSelectionModel=new EventSelectionModel(issuesTextFiltered);
  issuesSelectionModel.getListSelectionModel().addListSelectionListener(new IssuesSelectionListener());
  issuesJTable.setSelectionModel(issuesSelectionModel.getListSelectionModel());
  issuesJTable.getColumnModel().getColumn(0).setPreferredWidth(10);
  issuesJTable.getColumnModel().getColumn(1).setPreferredWidth(30);
  issuesJTable.getColumnModel().getColumn(2).setPreferredWidth(10);
  issuesJTable.getColumnModel().getColumn(3).setPreferredWidth(30);
  issuesJTable.getColumnModel().getColumn(4).setPreferredWidth(30);
  issuesJTable.getColumnModel().getColumn(5).setPreferredWidth(200);
  TableComparatorChooser tableSorter=new TableComparatorChooser(issuesJTable,issuesSortedList,true);
  JScrollPane issuesTableScrollPane=new JScrollPane(issuesJTable,JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  JScrollPane usersListScrollPane=new JScrollPane(issuesUserFiltered.getUserSelect(),JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  EventTableModel descriptionsTableModel=new EventTableModel(descriptions,new DescriptionTableFormat());
  JTable descriptionsTable=new JTable(descriptionsTableModel);
  descriptionsTable.getColumnModel().getColumn(0).setCellRenderer(new DescriptionRenderer());
  JScrollPane descriptionsTableScrollPane=new JScrollPane(descriptionsTable,JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  panel.add(usersListScrollPane,new GridBagConstraints(0,0,1,2,0.3,0.5,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(5,5,5,5),0,0));
  panel.add(new JLabel(""String_Node_Str""),new GridBagConstraints(1,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(5,0,5,5),0,0));
  panel.add(issuesTextFiltered.getFilterEdit(),new GridBagConstraints(2,0,1,1,1.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(5,0,5,5),0,0));
  panel.add(issuesTableScrollPane,new GridBagConstraints(1,1,2,1,0.7,0.5,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,5,5),0,0));
  panel.add(descriptionsTableScrollPane,new GridBagConstraints(0,2,3,1,1.0,0.5,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,5,5,5),0,0));
  return panel;
}",0.9513332090247996
32796,"/** 
 * Fetches a particular element. <p>This might seem redundant with the existence of   {@link #get(int)}. However, the goals of the methods are different.  This method exists to be called by   {@link #get(int)} or {@link #preFetch(int)}. This distinction allows users overriding this class a means of entry retrieval which does not implicitly execute a pre-fetch.  This is particularly key for users overriding   {@link #preFetch(int)}
 * @param index The index of the value to retrieve
 * @param recordHitsOrMisses Whether to increment the hit/miss counters(this should always be <code>false</code> when called from {@link #preFetch(int)}).
 * @return The value associated with the given index,or null if the index is not found.
 */
protected final Object fetch(int index,boolean recordHitsOrMisses){
  getReadWriteLock().writeLock().lock();
  try {
    Object value=null;
    IndexedTreeNode treeNode=indexTree.getNode(index);
    Object nodeValue=treeNode.getValue();
    if (EMPTY_INDEX_NODE != nodeValue && nodeValue != null) {
      if (recordHitsOrMisses)       cacheHits++;
      Object agedTreeNodeObject=treeNode.getValue();
      IndexedTreeNode agedTreeNode=(IndexedTreeNode)agedTreeNodeObject;
      Object agedNodeObject=agedTreeNode.getValue();
      AgedNode agedNode=(AgedNode)agedNodeObject;
      value=agedNode.getValue();
      agedTreeNode.removeFromTree();
      treeNode.setValue(cache.addByNode(agedNode));
    }
 else {
      if (recordHitsOrMisses)       cacheMisses++;
      value=source.get(index);
      if (currentSize < maxSize) {
        currentSize++;
        IndexedTreeNode cachedValue=cache.addByNode(new AgedNode(treeNode,value));
        treeNode.setValue(cachedValue);
      }
 else {
        IndexedTreeNode oldValue=cache.getNode(currentSize - 1);
        oldValue.removeFromTree();
        AgedNode oldNode=(AgedNode)oldValue.getValue();
        IndexedTreeNode oldTreeNode=oldNode.getIndexNode();
        oldTreeNode.setValue(EMPTY_INDEX_NODE);
        IndexedTreeNode cachedValue=cache.addByNode(new AgedNode(treeNode,value));
        treeNode.setValue(cachedValue);
      }
    }
    return value;
  }
  finally {
    getReadWriteLock().writeLock().unlock();
  }
}","/** 
 * Fetches a particular element. <p>This might seem redundant with the existence of   {@link #get(int)}. However, the goals of the methods are different.  This method exists to be called by   {@link #get(int)} or {@link #preFetch(int)}. This distinction allows users overriding this class a means of entry retrieval which does not implicitly execute a pre-fetch.  This is particularly key for users overriding   {@link #preFetch(int)}
 * @param index The index of the value to retrieve
 * @param recordHitsOrMisses Whether to increment the hit/miss counters(this should always be <code>false</code> when called from {@link #preFetch(int)}).
 * @return The value associated with the given index,or null if the index is not found.
 */
protected final Object fetch(int index,boolean recordHitsOrMisses){
  getReadWriteLock().writeLock().lock();
  try {
    Object value=null;
    IndexedTreeNode treeNode=indexTree.getNode(index);
    Object nodeValue=treeNode.getValue();
    if (EMPTY_INDEX_NODE != nodeValue && nodeValue != null) {
      if (recordHitsOrMisses)       cacheHits++;
      Object agedTreeNodeObject=treeNode.getValue();
      IndexedTreeNode agedTreeNode=(IndexedTreeNode)agedTreeNodeObject;
      Object agedNodeObject=agedTreeNode.getValue();
      AgedNode agedNode=(AgedNode)agedNodeObject;
      value=agedNode.getValue();
      agedTreeNode.removeFromTree();
      treeNode.setValue(cache.addByNode(agedNode));
    }
 else {
      if (recordHitsOrMisses)       cacheMisses++;
      value=source.get(index);
      if (currentSize < maxSize) {
        currentSize++;
        IndexedTreeNode cachedValue=cache.addByNode(new AgedNode(treeNode,value));
        treeNode.setValue(cachedValue);
      }
 else {
        IndexedTreeNode oldValue=cache.getNode(0);
        oldValue.removeFromTree();
        AgedNode oldNode=(AgedNode)oldValue.getValue();
        IndexedTreeNode oldTreeNode=oldNode.getIndexNode();
        oldTreeNode.setValue(EMPTY_INDEX_NODE);
        IndexedTreeNode cachedValue=cache.addByNode(new AgedNode(treeNode,value));
        treeNode.setValue(cachedValue);
      }
    }
    return value;
  }
  finally {
    getReadWriteLock().writeLock().unlock();
  }
}",0.9963751699139104
32797,"/** 
 * Increments the change sequence to view the next change. This will return true if such a change exists and false when there is no change to view.
 */
public boolean next(){
  if (listChange == null || rowIndex == listChange.getEndIndex()) {
    return nextBlock();
  }
 else {
    rowIndex++;
    return true;
  }
}","/** 
 * Increments the change sequence to view the next change. This will return true if such a change exists and false when there is no change to view.
 */
public boolean next(){
  if (currentBlock == null || rowIndex == currentBlock.getEndIndex()) {
    return nextBlock();
  }
 else {
    assert(rowIndex < currentBlock.getEndIndex());
    rowIndex++;
    return true;
  }
}",0.8640915593705293
32798,"/** 
 * Gets the current row index. If the listChange type is delete, this will always return the startIndex of the current list change.
 */
public int getIndex(){
  if (listChange.getType() == DELETE)   return listChange.getStartIndex();
  return rowIndex;
}","/** 
 * Gets the current row index. If the block type is delete, this will always return the startIndex of the current list change.
 */
public int getIndex(){
  if (currentBlock.getType() == DELETE)   return currentBlock.getStartIndex();
  return rowIndex;
}",0.8858800773694391
32799,"/** 
 * Gets the number of blocks currently remaining in this atomic change.
 */
public int getBlocksRemaining(){
  if (listChange != null && rowIndex < listChange.getEndIndex()) {
    return masterSequence.getBlockCount(atomicCount) - blockCount + 1;
  }
 else {
    return masterSequence.getBlockCount(atomicCount) - blockCount;
  }
}","/** 
 * Gets the number of blocks currently remaining in this atomic change.
 */
public int getBlocksRemaining(){
  if (currentBlock != null && rowIndex < currentBlock.getEndIndex()) {
    return masterSequence.getBlockCount(atomicCount) - blockCount + 1;
  }
 else {
    return masterSequence.getBlockCount(atomicCount) - blockCount;
  }
}",0.9349112426035504
32800,"/** 
 * Without incrementing the implicit iterator, this tests if there is another change to view. The user will still need to call next() to view such a change.
 */
public boolean hasNext(){
  if (listChange == null || rowIndex == listChange.getEndIndex()) {
    if (atomicCount == masterSequence.getAtomicCount()) {
      return false;
    }
 else     if (blockCount == masterSequence.getBlockCount(atomicCount)) {
      return false;
    }
 else {
      return true;
    }
  }
 else {
    return true;
  }
}","/** 
 * Without incrementing the implicit iterator, this tests if there is another change to view. The user will still need to call next() to view such a change.
 */
public boolean hasNext(){
  if (currentBlock == null || rowIndex == currentBlock.getEndIndex()) {
    if (atomicCount == masterSequence.getAtomicCount()) {
      return false;
    }
 else     if (blockCount == masterSequence.getBlockCount(atomicCount)) {
      return false;
    }
 else {
      return true;
    }
  }
 else {
    return true;
  }
}",0.95703125
32801,"/** 
 * Increments the change sequence to view the next change block.
 */
public boolean nextBlock(){
  if (blockCount == masterSequence.getBlockCount(atomicCount)) {
    listChange=null;
    rowIndex=-5;
    blockCount=0;
    if (atomicCount >= masterSequence.getAtomicCount()) {
      throw new NoSuchElementException(""String_Node_Str"");
    }
    atomicCount++;
    return false;
  }
 else {
    listChange=masterSequence.getBlock(atomicCount,blockCount);
    blockCount++;
    rowIndex=listChange.getStartIndex();
    return true;
  }
}","/** 
 * Increments the change sequence to view the next change block.
 */
public boolean nextBlock(){
  if (blockCount == masterSequence.getBlockCount(atomicCount)) {
    currentBlock=null;
    rowIndex=-5;
    blockCount=0;
    if (atomicCount >= masterSequence.getAtomicCount()) {
      throw new NoSuchElementException(""String_Node_Str"");
    }
    atomicCount++;
    return false;
  }
 else {
    currentBlock=masterSequence.getBlock(atomicCount,blockCount);
    blockCount++;
    rowIndex=currentBlock.getStartIndex();
    return true;
  }
}",0.9392265193370166
32802,"/** 
 * Gets the last row of the current block of changes. Inclusive.
 */
public int getBlockEndIndex(){
  return listChange.getEndIndex();
}","/** 
 * Gets the last row of the current block of changes. Inclusive.
 */
public int getBlockEndIndex(){
  return currentBlock.getEndIndex();
}",0.9295774647887324
32803,"/** 
 * Gets the reorder map of this list. This will also increment the change sequence to the next change.
 * @return an array of integers where the the previous index of a value isstored at the current index of that value.
 */
public int[] getReorderMap(){
  int[] reorderMap=masterSequence.getReorderMap(atomicCount);
  if (reorderMap == null)   throw new IllegalStateException(""String_Node_Str"");
  listChange=null;
  rowIndex=-5;
  blockCount=0;
  if (atomicCount >= masterSequence.getAtomicCount()) {
    throw new NoSuchElementException(""String_Node_Str"");
  }
  atomicCount++;
  return reorderMap;
}","/** 
 * Gets the reorder map of this list. This will also increment the change sequence to the next change.
 * @return an array of integers where the the previous index of a value isstored at the current index of that value.
 */
public int[] getReorderMap(){
  int[] reorderMap=masterSequence.getReorderMap(atomicCount);
  if (reorderMap == null)   throw new IllegalStateException(""String_Node_Str"");
  currentBlock=null;
  rowIndex=-5;
  blockCount=0;
  if (atomicCount >= masterSequence.getAtomicCount()) {
    throw new NoSuchElementException(""String_Node_Str"");
  }
  atomicCount++;
  return reorderMap;
}",0.981907894736842
32804,"/** 
 * Creates a clone of this ListEvent, in order to iterate through the changes multiple times. You should always be sure to iterate through <strong>all</strong> values in the original instance in order to reach the freshest changes. <p>Because the master change sequence does not know about clones, it is possible that the change information stored in the master list will be cleaned up without notifying the clone. In order to prevent this, you should always use the clone list before using the original list - this way the existance of values in the original list guarantees that such values will be visible to the clone.
 */
public ListEvent(ListEvent original){
  super(original.sourceList);
  this.blockCount=original.blockCount;
  this.listChange=original.listChange;
  this.rowIndex=original.rowIndex;
  this.masterSequence=original.masterSequence;
  this.sourceList=original.sourceList;
  this.atomicCount=original.atomicCount;
}","/** 
 * Creates a clone of this ListEvent, in order to iterate through the changes multiple times. You should always be sure to iterate through <strong>all</strong> values in the original instance in order to reach the freshest changes. <p>Because the master change sequence does not know about clones, it is possible that the change information stored in the master list will be cleaned up without notifying the clone. In order to prevent this, you should always use the clone list before using the original list - this way the existance of values in the original list guarantees that such values will be visible to the clone.
 */
public ListEvent(ListEvent original){
  super(original.sourceList);
  this.blockCount=original.blockCount;
  this.currentBlock=original.currentBlock;
  this.rowIndex=original.rowIndex;
  this.masterSequence=original.masterSequence;
  this.sourceList=original.sourceList;
  this.atomicCount=original.atomicCount;
}",0.9766702014846236
32805,"/** 
 * Gets the type of the current change, which should be one of ListEvent.INSERT, UPDATE, or DELETE.
 */
public int getType(){
  return listChange.getType();
}","/** 
 * Gets the type of the current change, which should be one of ListEvent.INSERT, UPDATE, or DELETE.
 */
public int getType(){
  return currentBlock.getType();
}",0.9390243902439024
32806,"/** 
 * Gets the first row of the current block of changes. Inclusive.
 */
public int getBlockStartIndex(){
  return listChange.getStartIndex();
}","/** 
 * Gets the first row of the current block of changes. Inclusive.
 */
public int getBlockStartIndex(){
  return currentBlock.getStartIndex();
}",0.9319727891156464
32807,"/** 
 * Clears the queue of all unprocessed changes. This is used when a listener reloads the source list rather than modifying it by differences. <p>If the user is manually clearing the event queue with this method, it is also necessary to call hasNext() before calling next() when receiving new events. This is because it is possible that pending events will be cleared before they are processed. Otherwise the call to next() may fail.
 */
public void clearEventQueue(){
  atomicCount=masterSequence.getAtomicCount();
  listChange=null;
  blockCount=0;
}","/** 
 * Clears the queue of all unprocessed changes. This is used when a listener reloads the source list rather than modifying it by differences. <p>If the user is manually clearing the event queue with this method, it is also necessary to call hasNext() before calling next() when receiving new events. This is because it is possible that pending events will be cleared before they are processed. Otherwise the call to next() may fail.
 */
public void clearEventQueue(){
  atomicCount=masterSequence.getAtomicCount();
  currentBlock=null;
  blockCount=0;
}",0.9802513464991024
32808,"/** 
 * Sets the current event as a reordering. Reordering events cannot be combined with other events.
 */
public void reorder(int[] reorderMap){
  if (atomicChangeBlocks.size() > 0)   throw new IllegalStateException(""String_Node_Str"");
  addChange(ListEvent.DELETE,0,reorderMap.length - 1);
  addChange(ListEvent.INSERT,0,reorderMap.length - 1);
  this.reorderMap=reorderMap;
}","/** 
 * Sets the current event as a reordering. Reordering events cannot be combined with other events.
 */
public void reorder(int[] reorderMap){
  if (atomicChangeBlocks.size() > 0)   throw new IllegalStateException(""String_Node_Str"");
  if (reorderMap.length == 0)   return;
  addChange(ListEvent.DELETE,0,reorderMap.length - 1);
  addChange(ListEvent.INSERT,0,reorderMap.length - 1);
  this.reorderMap=reorderMap;
}",0.949874686716792
32809,"/** 
 * Gets the object with the specified index in the tree, given the specified compressed index.
 */
public int getIndexByCompressedIndex(int compressedIndex){
  assert(compressedIndex >= treeLeftSize + treeRightSize + treeRootSize);
  if (compressedIndex < treeLeftSize) {
    return left.getIndexByCompressedIndex(compressedIndex);
  }
 else   if (compressedIndex < treeLeftSize + treeRootSize) {
    return totalLeftSize + virtualRootSize;
  }
 else {
    return right.getIndexByCompressedIndex(compressedIndex - (treeLeftSize + treeRootSize)) + totalLeftSize + treeRootSize+ virtualRootSize;
  }
}","/** 
 * Gets the object with the specified index in the tree, given the specified compressed index.
 */
public int getIndexByCompressedIndex(int compressedIndex){
  assert(compressedIndex <= treeLeftSize + treeRightSize + treeRootSize);
  if (compressedIndex < treeLeftSize) {
    return left.getIndexByCompressedIndex(compressedIndex);
  }
 else   if (compressedIndex < treeLeftSize + treeRootSize) {
    return totalLeftSize + virtualRootSize;
  }
 else {
    return right.getIndexByCompressedIndex(compressedIndex - (treeLeftSize + treeRootSize)) + totalLeftSize + treeRootSize+ virtualRootSize;
  }
}",0.9983443708609272
32810,"/** 
 * When there is a sequence of list changes, sometimes these changes are not created in increasing order. Users usually need to receive changes in increasing order, so it becomes necessary to reorder list change blocks. This returns true if two adjacent blocks are out of order.
 */
private static boolean requiresSwap(ListEventBlock first,ListEventBlock second){
  if (first.type == ListEvent.INSERT && second.type != ListEvent.INSERT) {
    if (first.endIndex >= second.startIndex && first.startIndex <= second.endIndex) {
      throw new IllegalStateException(""String_Node_Str"" + first + ""String_Node_Str""+ second+ ""String_Node_Str"");
    }
  }
  if (second.type == ListEvent.INSERT) {
    return second.startIndex <= first.startIndex;
  }
 else {
    return second.startIndex < first.startIndex;
  }
}","/** 
 * When there is a sequence of list changes, sometimes these changes are not created in increasing order. Users usually need to receive changes in increasing order, so it becomes necessary to reorder list change blocks. This returns true if two adjacent blocks are out of order.
 */
private static boolean requiresSwap(ListEventBlock first,ListEventBlock second){
  if (first.type == ListEvent.INSERT && second.type != ListEvent.INSERT) {
    if (first.endIndex >= second.startIndex && first.startIndex <= second.endIndex) {
      throw new IllegalStateException(""String_Node_Str"" + first + ""String_Node_Str""+ second+ ""String_Node_Str"");
    }
  }
  if (second.type == ListEvent.INSERT && first.type != ListEvent.DELETE) {
    return second.startIndex <= first.startIndex;
  }
 else {
    return second.startIndex < first.startIndex;
  }
}",0.9794437726723096
32811,"/** 
 * Fetches a particular element. <p>This might seem redundant with the existence of   {@link #get(int)}. However, the goals of the methods are different.  This method exists to be called by   {@link #get(int)} or {@link #preFetch(int)}. This distinction allows users overriding this class a means of entry retrieval which does not implicitly execute a pre-fetch.  This is particularly key for users overriding   {@link #preFetch(int)}
 * @param index The index of the value to retrieve
 * @param recordHitsOrMisses Whether to increment the hit/miss counters(this should always be <code>false</code> when called from {@link #preFetch(int)}).
 * @return The value associated with the given index,or null if the index is not found.
 */
protected final Object fetch(int index,boolean recordHitsOrMisses){
  getReadWriteLock().writeLock().lock();
  try {
    Object value=null;
    IndexedTreeNode indexNode=indexTree.getNode(index);
    Object nodeValue=indexNode.getValue();
    if (EMPTY_INDEX_NODE != nodeValue && nodeValue != null) {
      if (recordHitsOrMisses)       cacheHits++;
      IndexedTreeNode cacheNode=(IndexedTreeNode)indexNode.getValue();
      AgedNode agedNode=(AgedNode)cacheNode.getValue();
      value=agedNode.getValue();
      cacheNode.removeFromTree();
      indexNode.setValue(cache.addByNode(agedNode));
    }
 else {
      if (recordHitsOrMisses)       cacheMisses++;
      value=source.get(index);
      if (currentSize < maxSize) {
        currentSize++;
        IndexedTreeNode cacheNode=cache.addByNode(new AgedNode(indexNode,value));
        indexNode.setValue(cacheNode);
      }
 else {
        IndexedTreeNode oldestInCache=cache.getNode(0);
        oldestInCache.removeFromTree();
        AgedNode oldAgedNode=(AgedNode)oldestInCache.getValue();
        IndexedTreeNode oldIndexNode=oldAgedNode.getIndexNode();
        oldIndexNode.setValue(EMPTY_INDEX_NODE);
        IndexedTreeNode cacheNode=cache.addByNode(new AgedNode(indexNode,value));
        indexNode.setValue(cacheNode);
      }
    }
    return value;
  }
  finally {
    getReadWriteLock().writeLock().unlock();
  }
}","/** 
 * Fetches a particular element. <p>This might seem redundant with the existence of   {@link #get(int)}. However, the goals of the methods are different.  This method exists to be called by   {@link #get(int)} or {@link #preFetch(int)}. This distinction allows users overriding this class a means of entry retrieval which does not implicitly execute a pre-fetch.  This is particularly key for users overriding   {@link #preFetch(int)}
 * @param index The index of the value to retrieve
 * @param recordHitsOrMisses Whether to increment the hit/miss counters(this should always be <code>false</code> when called from {@link #preFetch(int)}).
 * @return The value associated with the given index,or null if the index is not found.
 */
protected final Object fetch(int index,boolean recordHitsOrMisses){
  Object value=null;
  IndexedTreeNode indexNode=indexTree.getNode(index);
  Object nodeValue=indexNode.getValue();
  if (EMPTY_INDEX_NODE != nodeValue && nodeValue != null) {
    if (recordHitsOrMisses)     cacheHits++;
    IndexedTreeNode cacheNode=(IndexedTreeNode)indexNode.getValue();
    AgedNode agedNode=(AgedNode)cacheNode.getValue();
    value=agedNode.getValue();
    cacheNode.removeFromTree();
    indexNode.setValue(cache.addByNode(agedNode));
  }
 else {
    if (recordHitsOrMisses)     cacheMisses++;
    value=source.get(index);
    if (currentSize < maxSize) {
      currentSize++;
      IndexedTreeNode cacheNode=cache.addByNode(new AgedNode(indexNode,value));
      indexNode.setValue(cacheNode);
    }
 else {
      IndexedTreeNode oldestInCache=cache.getNode(0);
      oldestInCache.removeFromTree();
      AgedNode oldAgedNode=(AgedNode)oldestInCache.getValue();
      IndexedTreeNode oldIndexNode=oldAgedNode.getIndexNode();
      oldIndexNode.setValue(EMPTY_INDEX_NODE);
      IndexedTreeNode cacheNode=cache.addByNode(new AgedNode(indexNode,value));
      indexNode.setValue(cacheNode);
    }
  }
  return value;
}",0.9572060993605508
32812,"/** 
 * Gets the offset of the specified member list.
 */
private int getListOffset(MemberList memberList){
  int listOffset=0;
  for (int i=0; i < memberLists.size(); i++) {
    MemberList current=(MemberList)memberLists.get(i);
    if (current == memberList)     return listOffset;
 else     listOffset=listOffset + current.size();
  }
  throw new RuntimeException(""String_Node_Str"" + memberList);
}","/** 
 * Gets the offset of the specified member list.
 */
private int getListOffset(MemberList memberList){
  int listOffset=0;
  for (int i=0; i < memberLists.size(); i++) {
    MemberList current=(MemberList)memberLists.get(i);
    if (current == memberList)     return listOffset;
 else     listOffset=listOffset + current.size();
  }
  throw new IllegalStateException(""String_Node_Str"" + memberList);
}",0.9789343246592316
32813,"/** 
 * Creates a new WeakReferenceProxy that listens for events from the specified list and forwards them to the specified listener.
 */
public WeakReferenceProxy(EventList source,ListEventListener proxyTarget){
  if (source == null || proxyTarget == null)   throw new IllegalArgumentException();
  this.source=source;
  proxyTargetReference=new WeakReference(proxyTarget);
}","/** 
 * Creates a new WeakReferenceProxy that listens for events from the specified list and forwards them to the specified listener.
 */
public WeakReferenceProxy(EventList source,ListEventListener proxyTarget){
  if (source == null || proxyTarget == null)   throw new NullPointerException();
  this.source=source;
  proxyTargetReference=new WeakReference(proxyTarget);
}",0.96524064171123
32814,"/** 
 * Walks through the union of the specified ranges. All values in the first range are given the specified selection value. All values in the second range but not in the first range are given the opposite selection value. In effect, the first range and the intersection of the two ranges are given the specified value. The parts that are in the second range but not in the first range (ie. everything else) is given the opposite selection value.
 * @param select true to set values in the first range as selected andthe other values in the second range as not selected. false to set values in the first range as not selected and the other values in the second range as selected.
 * @param changeIndex0 one end of the first range, inclusive.
 * @param changeIndex1 the opposite end of the first range, inclusive.This may be lower than changeIndex0.
 * @param invertIndex0 one end of the second range, inclusive. Tospecify an empty second range, specify -1 for this value.
 * @param invertIndex1 the opposite end of the second range, inclusive.This may be lower than invertIndex0. To specify an empty second range, specify -1 for this value.
 */
private void setSubRangeOfRange(boolean select,int changeIndex0,int changeIndex1,int invertIndex0,int invertIndex1){
  if (changeIndex0 >= flagList.size() || changeIndex1 >= flagList.size() || ((changeIndex0 == -1 || changeIndex1 == -1) && changeIndex0 != changeIndex1)) {
    throw new ArrayIndexOutOfBoundsException(""String_Node_Str"" + changeIndex0 + ""String_Node_Str""+ changeIndex1+ ""String_Node_Str""+ flagList.size());
  }
  if (invertIndex0 >= flagList.size() || invertIndex1 >= flagList.size() || ((invertIndex0 == -1 || invertIndex1 == -1) && invertIndex0 != invertIndex1)) {
    throw new ArrayIndexOutOfBoundsException(""String_Node_Str"" + invertIndex0 + ""String_Node_Str""+ invertIndex1+ ""String_Node_Str""+ flagList.size());
  }
  if (changeIndex0 == -1 && changeIndex1 == -1) {
    if (invertIndex0 == -1 && invertIndex1 == -1)     return;
    changeIndex0=invertIndex0;
    changeIndex1=invertIndex1;
    select=!select;
  }
  if (invertIndex0 == -1 && invertIndex1 == -1) {
    invertIndex0=changeIndex0;
    invertIndex1=changeIndex1;
  }
  int minChangeIndex=Math.min(changeIndex0,changeIndex1);
  int maxChangeIndex=Math.max(changeIndex0,changeIndex1);
  int minInvertIndex=Math.min(invertIndex0,invertIndex1);
  int maxInvertIndex=Math.max(invertIndex0,invertIndex1);
  int minUnionIndex=Math.min(minChangeIndex,minInvertIndex);
  int maxUnionIndex=Math.max(maxChangeIndex,maxInvertIndex);
  int minChangedIndex=maxUnionIndex + 1;
  int maxChangedIndex=minUnionIndex - 1;
  updates.beginEvent();
  for (int i=minUnionIndex; i <= maxUnionIndex; i++) {
    boolean selectedBefore=(flagList.get(i) != null);
    boolean inChangeRange=(i >= minChangeIndex && i <= maxChangeIndex);
    boolean selectedAfter=(inChangeRange == select);
    if (selectedBefore != selectedAfter) {
      if (i < minChangedIndex)       minChangedIndex=i;
      if (i > maxChangedIndex)       maxChangedIndex=i;
      if (selectedBefore) {
        int selectionIndex=flagList.getCompressedIndex(i);
        flagList.set(i,null);
        updates.addDelete(selectionIndex);
      }
 else {
        flagList.set(i,Boolean.TRUE);
        int selectionIndex=flagList.getCompressedIndex(i);
        updates.addInsert(selectionIndex);
      }
    }
  }
  updates.commitEvent();
  if (minChangedIndex <= maxChangedIndex)   fireSelectionChanged(minChangedIndex,maxChangedIndex);
}","/** 
 * Walks through the union of the specified ranges. All values in the first range are given the specified selection value. All values in the second range but not in the first range are given the opposite selection value. In effect, the first range and the intersection of the two ranges are given the specified value. The parts that are in the second range but not in the first range (ie. everything else) is given the opposite selection value.
 * @param select true to set values in the first range as selected andthe other values in the second range as not selected. false to set values in the first range as not selected and the other values in the second range as selected.
 * @param changeIndex0 one end of the first range, inclusive.
 * @param changeIndex1 the opposite end of the first range, inclusive.This may be lower than changeIndex0.
 * @param invertIndex0 one end of the second range, inclusive. Tospecify an empty second range, specify -1 for this value.
 * @param invertIndex1 the opposite end of the second range, inclusive.This may be lower than invertIndex0. To specify an empty second range, specify -1 for this value.
 */
private void setSubRangeOfRange(boolean select,int changeIndex0,int changeIndex1,int invertIndex0,int invertIndex1){
  if (changeIndex0 >= flagList.size() || changeIndex1 >= flagList.size() || ((changeIndex0 == -1 || changeIndex1 == -1) && changeIndex0 != changeIndex1)) {
    throw new IndexOutOfBoundsException(""String_Node_Str"" + changeIndex0 + ""String_Node_Str""+ changeIndex1+ ""String_Node_Str""+ flagList.size());
  }
  if (invertIndex0 >= flagList.size() || invertIndex1 >= flagList.size() || ((invertIndex0 == -1 || invertIndex1 == -1) && invertIndex0 != invertIndex1)) {
    throw new IndexOutOfBoundsException(""String_Node_Str"" + invertIndex0 + ""String_Node_Str""+ invertIndex1+ ""String_Node_Str""+ flagList.size());
  }
  if (changeIndex0 == -1 && changeIndex1 == -1) {
    if (invertIndex0 == -1 && invertIndex1 == -1)     return;
    changeIndex0=invertIndex0;
    changeIndex1=invertIndex1;
    select=!select;
  }
  if (invertIndex0 == -1 && invertIndex1 == -1) {
    invertIndex0=changeIndex0;
    invertIndex1=changeIndex1;
  }
  int minChangeIndex=Math.min(changeIndex0,changeIndex1);
  int maxChangeIndex=Math.max(changeIndex0,changeIndex1);
  int minInvertIndex=Math.min(invertIndex0,invertIndex1);
  int maxInvertIndex=Math.max(invertIndex0,invertIndex1);
  int minUnionIndex=Math.min(minChangeIndex,minInvertIndex);
  int maxUnionIndex=Math.max(maxChangeIndex,maxInvertIndex);
  int minChangedIndex=maxUnionIndex + 1;
  int maxChangedIndex=minUnionIndex - 1;
  updates.beginEvent();
  for (int i=minUnionIndex; i <= maxUnionIndex; i++) {
    boolean selectedBefore=(flagList.get(i) != null);
    boolean inChangeRange=(i >= minChangeIndex && i <= maxChangeIndex);
    boolean selectedAfter=(inChangeRange == select);
    if (selectedBefore != selectedAfter) {
      if (i < minChangedIndex)       minChangedIndex=i;
      if (i > maxChangedIndex)       maxChangedIndex=i;
      if (selectedBefore) {
        int selectionIndex=flagList.getCompressedIndex(i);
        flagList.set(i,null);
        updates.addDelete(selectionIndex);
      }
 else {
        flagList.set(i,Boolean.TRUE);
        int selectionIndex=flagList.getCompressedIndex(i);
        updates.addInsert(selectionIndex);
      }
    }
  }
  updates.commitEvent();
  if (minChangedIndex <= maxChangedIndex)   fireSelectionChanged(minChangedIndex,maxChangedIndex);
}",0.9985722444317532
32815,"/** 
 * Validate the proper response to requested an index beyond <code>source.size() - 1</code>.  This test is included as a result of CachingList overriding get() from TransformedList.
 */
public void testBoundsErrorBehaviour(){
  boolean exceptionThrown=false;
  try {
    cache.get(26);
  }
 catch (  IndexOutOfBoundsException e) {
    exceptionThrown=true;
  }
catch (  Exception e) {
    exceptionThrown=true;
    fail(""String_Node_Str"" + e.getClass());
  }
 finally {
    if (exceptionThrown == false) {
      fail(""String_Node_Str"");
    }
  }
  for (int i=0; i < 25; i++) {
    source.add(new Integer(i));
  }
  exceptionThrown=false;
  try {
    cache.get(26);
  }
 catch (  IndexOutOfBoundsException e) {
    exceptionThrown=true;
  }
catch (  Exception e) {
    exceptionThrown=true;
    fail(""String_Node_Str"" + e.getClass());
  }
 finally {
    if (exceptionThrown == false) {
      fail(""String_Node_Str"");
    }
  }
  for (int i=9; i < 15; i++) {
    Object result=cache.get(i);
    assertEquals(new Integer(i),(Integer)result);
  }
  exceptionThrown=false;
  try {
    cache.get(26);
  }
 catch (  IndexOutOfBoundsException e) {
    exceptionThrown=true;
  }
catch (  Exception e) {
    exceptionThrown=true;
    fail(""String_Node_Str"" + e.getClass());
  }
 finally {
    if (exceptionThrown == false) {
      fail(""String_Node_Str"");
    }
  }
  for (int i=9; i < 15; i++) {
    Object result=cache.get(i);
    assertEquals(new Integer(i),(Integer)result);
  }
  exceptionThrown=false;
  try {
    cache.get(26);
  }
 catch (  IndexOutOfBoundsException e) {
    exceptionThrown=true;
  }
catch (  Exception e) {
    exceptionThrown=true;
    fail(""String_Node_Str"" + e.getClass());
  }
 finally {
    if (exceptionThrown == false) {
      fail(""String_Node_Str"");
    }
  }
}","/** 
 * Validate the proper response to requested an index beyond <code>source.size() - 1</code>.  This test is included as a result of CachingList overriding get() from TransformedList.
 */
public void testBoundsErrorBehaviour(){
  boolean exceptionThrown=false;
  try {
    cache.get(26);
  }
 catch (  IndexOutOfBoundsException e) {
    exceptionThrown=true;
  }
  if (exceptionThrown == false) {
    fail(""String_Node_Str"");
  }
  for (int i=0; i < 25; i++) {
    source.add(new Integer(i));
  }
  exceptionThrown=false;
  try {
    cache.get(26);
  }
 catch (  IndexOutOfBoundsException e) {
    exceptionThrown=true;
  }
  if (exceptionThrown == false) {
    fail(""String_Node_Str"");
  }
  for (int i=9; i < 15; i++) {
    Object result=cache.get(i);
    assertEquals(new Integer(i),(Integer)result);
  }
  exceptionThrown=false;
  try {
    cache.get(26);
  }
 catch (  IndexOutOfBoundsException e) {
    exceptionThrown=true;
  }
  if (exceptionThrown == false) {
    fail(""String_Node_Str"");
  }
  for (int i=9; i < 15; i++) {
    Object result=cache.get(i);
    assertEquals(new Integer(i),(Integer)result);
  }
  exceptionThrown=false;
  try {
    cache.get(26);
  }
 catch (  IndexOutOfBoundsException e) {
    exceptionThrown=true;
  }
  if (exceptionThrown == false) {
    fail(""String_Node_Str"");
  }
}",0.6713826366559486
32816,"private int getIndex(IndexedTreeNode child){
  if (child == left) {
    if (parent != null)     return parent.getIndex(this);
    return 0;
  }
  if (child == null) {
    if (parent != null)     return parent.getIndex(this) + leftSize;
    return leftSize;
  }
  if (child == right) {
    if (parent != null)     return parent.getIndex(this) + leftSize + rootSize;
    return leftSize + rootSize;
  }
  throw new IllegalArgumentException(this + ""String_Node_Str"");
}","private int getIndex(IndexedTreeNode child){
  if (child == left) {
    if (parent != null)     return parent.getIndex(this);
    return 0;
  }
  if (child == null) {
    if (parent != null)     return parent.getIndex(this) + leftSize;
    return leftSize;
  }
  if (child == right) {
    if (parent != null)     return parent.getIndex(this) + leftSize + rootSize;
    return leftSize + rootSize;
  }
  throw new IndexOutOfBoundsException(this + ""String_Node_Str"");
}",0.9689174705251876
32817,"/** 
 * Fetches a particular element. <p>This might seem redundant with the existence of   {@link #get(int)}. However, the goals of the methods are different.  This method exists to be called by   {@link #get(int)} or {@link #preFetch(int)}. This distinction allows users overriding this class a means of entry retrieval which does not implicitly execute a pre-fetch.  This is particularly key for users overriding   {@link #preFetch(int)}
 * @param index The index of the value to retrieve
 * @param recordHitsOrMisses Whether to increment the hit/miss counters(this should always be <code>false</code> when called from {@link #preFetch(int)}).
 * @return The value associated with the given index,or null if the index is not found.
 */
protected final Object fetch(int index,boolean recordHitsOrMisses){
  getReadWriteLock().writeLock().lock();
  try {
    Object value=null;
    IndexedTreeNode treeNode=indexTree.getNode(index);
    Object nodeValue=treeNode.getValue();
    if (EMPTY_INDEX_NODE != nodeValue && nodeValue != null) {
      cacheHits++;
      Object agedTreeNodeObject=treeNode.getValue();
      IndexedTreeNode agedTreeNode=(IndexedTreeNode)agedTreeNodeObject;
      Object agedNodeObject=agedTreeNode.getValue();
      AgedNode agedNode=(AgedNode)agedNodeObject;
      value=agedNode.getValue();
      agedTreeNode.removeFromTree();
      treeNode.setValue(cache.addByNode(agedNode));
    }
 else {
      cacheMisses++;
      value=source.get(index);
      if (currentSize < maxSize) {
        currentSize++;
        IndexedTreeNode cachedValue=cache.addByNode(new AgedNode(treeNode,value));
        treeNode.setValue(cachedValue);
      }
 else {
        IndexedTreeNode oldValue=cache.getNode(currentSize - 1);
        oldValue.removeFromTree();
        AgedNode oldNode=(AgedNode)oldValue.getValue();
        IndexedTreeNode oldTreeNode=oldNode.getIndexNode();
        oldTreeNode.setValue(EMPTY_INDEX_NODE);
        IndexedTreeNode cachedValue=cache.addByNode(new AgedNode(treeNode,value));
        treeNode.setValue(cachedValue);
      }
    }
    return value;
  }
  finally {
    getReadWriteLock().writeLock().unlock();
  }
}","/** 
 * Fetches a particular element. <p>This might seem redundant with the existence of   {@link #get(int)}. However, the goals of the methods are different.  This method exists to be called by   {@link #get(int)} or {@link #preFetch(int)}. This distinction allows users overriding this class a means of entry retrieval which does not implicitly execute a pre-fetch.  This is particularly key for users overriding   {@link #preFetch(int)}
 * @param index The index of the value to retrieve
 * @param recordHitsOrMisses Whether to increment the hit/miss counters(this should always be <code>false</code> when called from {@link #preFetch(int)}).
 * @return The value associated with the given index,or null if the index is not found.
 */
protected final Object fetch(int index,boolean recordHitsOrMisses){
  getReadWriteLock().writeLock().lock();
  try {
    Object value=null;
    IndexedTreeNode treeNode=indexTree.getNode(index);
    Object nodeValue=treeNode.getValue();
    if (EMPTY_INDEX_NODE != nodeValue && nodeValue != null) {
      if (recordHitsOrMisses)       cacheHits++;
      Object agedTreeNodeObject=treeNode.getValue();
      IndexedTreeNode agedTreeNode=(IndexedTreeNode)agedTreeNodeObject;
      Object agedNodeObject=agedTreeNode.getValue();
      AgedNode agedNode=(AgedNode)agedNodeObject;
      value=agedNode.getValue();
      agedTreeNode.removeFromTree();
      treeNode.setValue(cache.addByNode(agedNode));
    }
 else {
      if (recordHitsOrMisses)       cacheMisses++;
      value=source.get(index);
      if (currentSize < maxSize) {
        currentSize++;
        IndexedTreeNode cachedValue=cache.addByNode(new AgedNode(treeNode,value));
        treeNode.setValue(cachedValue);
      }
 else {
        IndexedTreeNode oldValue=cache.getNode(currentSize - 1);
        oldValue.removeFromTree();
        AgedNode oldNode=(AgedNode)oldValue.getValue();
        IndexedTreeNode oldTreeNode=oldNode.getIndexNode();
        oldTreeNode.setValue(EMPTY_INDEX_NODE);
        IndexedTreeNode cachedValue=cache.addByNode(new AgedNode(treeNode,value));
        treeNode.setValue(cachedValue);
      }
    }
    return value;
  }
  finally {
    getReadWriteLock().writeLock().unlock();
  }
}",0.9862637362637364
32818,"/** 
 * Index node pairs are compared first by their Object's values, and then by their indices.
 */
public int compareTo(Object other){
  IndexNodePair otherIndexNodePair=(IndexNodePair)other;
  Object myObject=source.get(node.getIndex());
  Object otherObject=source.get(otherIndexNodePair.node.getIndex());
  int compareResult=comparator.compare(myObject,otherObject);
  if (compareResult != 0)   return compareResult;
  return index - otherIndexNodePair.index;
}","/** 
 * Index node pairs are compared first by their Object's values, and then by their indices.
 */
public int compareTo(Object other){
  IndexNodePair otherIndexNodePair=(IndexNodePair)other;
  if (comparator != null) {
    Object myObject=source.get(node.getIndex());
    Object otherObject=source.get(otherIndexNodePair.node.getIndex());
    int compareResult=comparator.compare(myObject,otherObject);
    if (compareResult != 0)     return compareResult;
  }
  return index - otherIndexNodePair.index;
}",0.5770020533880903
32819,"/** 
 * Change the selection to be the set union of the current selection  and the indices between index0 and index1 inclusive
 */
public void addSelectionInterval(int index0,int index1){
  ((InternalReadWriteLock)eventList.getReadWriteLock()).internalLock().lock();
  try {
    if (!enabled)     return;
    anchorSelectionIndex=index0;
    leadSelectionIndex=index1;
    if (selectionMode == SINGLE_SELECTION) {
      setSubRangeOfRange(true,index0,index0,getMinSelectionIndex(),getMaxSelectionIndex());
    }
 else     if (selectionMode == SINGLE_INTERVAL_SELECTION) {
      boolean overlap=false;
      int minSelectedIndex=getMinSelectionIndex();
      int maxSelectedIndex=getMaxSelectionIndex();
      if (minSelectedIndex - 1 <= index0 && index0 <= maxSelectedIndex + 1)       overlap=true;
      if (minSelectedIndex - 1 <= index1 && index1 <= maxSelectedIndex + 1)       overlap=true;
      if (overlap) {
        setSubRangeOfRange(true,index0,index1,-1,-1);
      }
 else {
        setSubRangeOfRange(true,index0,index1,minSelectedIndex,maxSelectedIndex);
      }
    }
 else {
      setSubRangeOfRange(true,index0,index1,-1,-1);
    }
  }
  finally {
    ((InternalReadWriteLock)eventList.getReadWriteLock()).internalLock().unlock();
  }
}","/** 
 * Change the selection to be the set union of the current selection  and the indices between index0 and index1 inclusive
 */
public void addSelectionInterval(int index0,int index1){
  ((InternalReadWriteLock)eventList.getReadWriteLock()).internalLock().lock();
  try {
    if (!enabled)     return;
    if (index0 < 0 || index1 < 0) {
      return;
    }
    anchorSelectionIndex=index0;
    leadSelectionIndex=index1;
    if (selectionMode == SINGLE_SELECTION) {
      setSubRangeOfRange(true,index0,index0,getMinSelectionIndex(),getMaxSelectionIndex());
    }
 else     if (selectionMode == SINGLE_INTERVAL_SELECTION) {
      boolean overlap=false;
      int minSelectedIndex=getMinSelectionIndex();
      int maxSelectedIndex=getMaxSelectionIndex();
      if (minSelectedIndex - 1 <= index0 && index0 <= maxSelectedIndex + 1)       overlap=true;
      if (minSelectedIndex - 1 <= index1 && index1 <= maxSelectedIndex + 1)       overlap=true;
      if (overlap) {
        setSubRangeOfRange(true,index0,index1,-1,-1);
      }
 else {
        setSubRangeOfRange(true,index0,index1,minSelectedIndex,maxSelectedIndex);
      }
    }
 else {
      setSubRangeOfRange(true,index0,index1,-1,-1);
    }
  }
  finally {
    ((InternalReadWriteLock)eventList.getReadWriteLock()).internalLock().unlock();
  }
}",0.978125
32820,"/** 
 * Notifies this SelectionList about changes to its underlying list store. This changes the flag list. Changes to the source list may cause simultaneous changes to the corresponding selection list.
 */
public void listChanged(ListEvent listChanges){
  int minSelectionIndexBefore=selectionModel.getMinSelectionIndex();
  int maxSelectionIndexBefore=selectionModel.getMaxSelectionIndex();
  updates.beginEvent();
  if (listChanges.isReordering()) {
    int[] sourceReorderMap=listChanges.getReorderMap();
    int[] selectReorderMap=new int[flagList.getCompressedList().size()];
    SparseList previousFlagList=flagList;
    flagList=new SparseList();
    for (int c=0; c < sourceReorderMap.length; c++) {
      Object flag=previousFlagList.get(sourceReorderMap[c]);
      boolean wasSelected=(flag != null);
      flagList.add(c,flag);
      if (wasSelected) {
        int previousIndex=previousFlagList.getCompressedIndex(sourceReorderMap[c]);
        int currentIndex=flagList.getCompressedIndex(c);
        selectReorderMap[currentIndex]=previousIndex;
      }
    }
    updates.reorder(selectReorderMap);
  }
 else {
    while (listChanges.next()) {
      int index=listChanges.getIndex();
      int changeType=listChanges.getType();
      boolean previouslySelected=(flagList.size() > index) && (flagList.get(index) != null);
      int previousSelectionIndex=-1;
      if (previouslySelected)       previousSelectionIndex=flagList.getCompressedIndex(index);
      if (changeType == ListEvent.DELETE) {
        flagList.remove(index);
        if (previouslySelected) {
          updates.addDelete(previousSelectionIndex);
        }
      }
 else       if (changeType == ListEvent.INSERT) {
        if (previouslySelected) {
          if (selectionModel.selectionMode == selectionModel.SINGLE_INTERVAL_SELECTION || selectionModel.selectionMode == selectionModel.MULTIPLE_INTERVAL_SELECTION) {
            flagList.add(index,Boolean.TRUE);
            updates.addInsert(previousSelectionIndex);
          }
 else {
            flagList.add(index,null);
          }
        }
 else {
          flagList.add(index,null);
        }
      }
 else       if (changeType == ListEvent.UPDATE) {
        if (previouslySelected) {
          updates.addUpdate(previousSelectionIndex);
        }
      }
    }
  }
  updates.commitEvent();
  if (minSelectionIndexBefore != 0 && maxSelectionIndexBefore != 0) {
    int minSelectionIndexAfter=selectionModel.getMinSelectionIndex();
    int maxSelectionIndexAfter=selectionModel.getMaxSelectionIndex();
    int changeStart=minSelectionIndexBefore;
    int changeFinish=maxSelectionIndexBefore;
    if (minSelectionIndexAfter != -1 && minSelectionIndexAfter < changeStart)     changeStart=minSelectionIndexAfter;
    if (maxSelectionIndexAfter != -1 && maxSelectionIndexAfter > changeFinish)     changeFinish=maxSelectionIndexAfter;
    selectionModel.fireSelectionChanged(changeStart,changeFinish);
  }
}","/** 
 * Notifies this SelectionList about changes to its underlying list store. <p>This changes the flag list. Changes to the source list may cause simultaneous changes to the corresponding selection list.
 */
public void listChanged(ListEvent listChanges){
  int minSelectionIndexBefore=selectionModel.getMinSelectionIndex();
  int maxSelectionIndexBefore=selectionModel.getMaxSelectionIndex();
  updates.beginEvent();
  if (listChanges.isReordering()) {
    int[] sourceReorderMap=listChanges.getReorderMap();
    int[] selectReorderMap=new int[flagList.getCompressedList().size()];
    SparseList previousFlagList=flagList;
    flagList=new SparseList();
    for (int c=0; c < sourceReorderMap.length; c++) {
      Object flag=previousFlagList.get(sourceReorderMap[c]);
      boolean wasSelected=(flag != null);
      flagList.add(c,flag);
      if (wasSelected) {
        int previousIndex=previousFlagList.getCompressedIndex(sourceReorderMap[c]);
        int currentIndex=flagList.getCompressedIndex(c);
        selectReorderMap[currentIndex]=previousIndex;
      }
    }
    updates.reorder(selectReorderMap);
  }
 else {
    while (listChanges.next()) {
      int index=listChanges.getIndex();
      int changeType=listChanges.getType();
      boolean previouslySelected=(flagList.size() > index) && (flagList.get(index) != null);
      int previousSelectionIndex=-1;
      if (previouslySelected)       previousSelectionIndex=flagList.getCompressedIndex(index);
      if (changeType == ListEvent.DELETE) {
        flagList.remove(index);
        if (previouslySelected) {
          updates.addDelete(previousSelectionIndex);
        }
      }
 else       if (changeType == ListEvent.INSERT) {
        if (previouslySelected) {
          if (selectionModel.selectionMode == selectionModel.SINGLE_INTERVAL_SELECTION || selectionModel.selectionMode == selectionModel.MULTIPLE_INTERVAL_SELECTION) {
            flagList.add(index,Boolean.TRUE);
            updates.addInsert(previousSelectionIndex);
          }
 else {
            flagList.add(index,null);
          }
        }
 else {
          flagList.add(index,null);
        }
      }
 else       if (changeType == ListEvent.UPDATE) {
        if (previouslySelected) {
          updates.addUpdate(previousSelectionIndex);
        }
      }
    }
  }
  updates.commitEvent();
  if (minSelectionIndexBefore != 0 && maxSelectionIndexBefore != 0) {
    int minSelectionIndexAfter=selectionModel.getMinSelectionIndex();
    int maxSelectionIndexAfter=selectionModel.getMaxSelectionIndex();
    int changeStart=minSelectionIndexBefore;
    int changeFinish=maxSelectionIndexBefore;
    if (minSelectionIndexAfter != -1 && minSelectionIndexAfter < changeStart)     changeStart=minSelectionIndexAfter;
    if (maxSelectionIndexAfter != -1 && maxSelectionIndexAfter > changeFinish)     changeFinish=maxSelectionIndexAfter;
    selectionModel.fireSelectionChanged(changeStart,changeFinish);
  }
}",0.9994907485995588
32821,"/** 
 * Change the selection to be between index0 and index1 inclusive. First this calculates the smallest range where changes occur. This includes the union of the selection range before and the selection range specified. It then walks through the change and sets each index as selected or not based on whether the index is in the  new range. Finally it fires events to both the listening lists and selection listeners about what changes happened. If the selection does not change, this will not fire any events.
 */
public void setSelectionInterval(int index0,int index1){
  ((InternalReadWriteLock)eventList.getReadWriteLock()).internalLock().lock();
  try {
    if (!enabled)     return;
    anchorSelectionIndex=index0;
    leadSelectionIndex=index1;
    if (selectionMode == SINGLE_SELECTION) {
      setSubRangeOfRange(true,index0,index0,getMinSelectionIndex(),getMaxSelectionIndex());
    }
 else {
      setSubRangeOfRange(true,index0,index1,getMinSelectionIndex(),getMaxSelectionIndex());
    }
  }
  finally {
    ((InternalReadWriteLock)eventList.getReadWriteLock()).internalLock().unlock();
  }
}","/** 
 * Change the selection to be between index0 and index1 inclusive. <p>First this calculates the smallest range where changes occur. This includes the union of the selection range before and the selection range specified. It then walks through the change and sets each index as selected or not based on whether the index is in the  new range. Finally it fires events to both the listening lists and selection listeners about what changes happened. <p>If the selection does not change, this will not fire any events.
 */
public void setSelectionInterval(int index0,int index1){
  ((InternalReadWriteLock)eventList.getReadWriteLock()).internalLock().lock();
  try {
    if (!enabled)     return;
    if (index0 < 0 || index1 < 0) {
      clearSelection();
      return;
    }
    anchorSelectionIndex=index0;
    leadSelectionIndex=index1;
    if (selectionMode == SINGLE_SELECTION) {
      setSubRangeOfRange(true,index0,index0,getMinSelectionIndex(),getMaxSelectionIndex());
    }
 else {
      setSubRangeOfRange(true,index0,index1,getMinSelectionIndex(),getMaxSelectionIndex());
    }
  }
  finally {
    ((InternalReadWriteLock)eventList.getReadWriteLock()).internalLock().unlock();
  }
}",0.9626736111111112
32822,"/** 
 * Change the selection to be the set difference of the current selection  and the indices between index0 and index1 inclusive.
 */
public void removeSelectionInterval(int index0,int index1){
  ((InternalReadWriteLock)eventList.getReadWriteLock()).internalLock().lock();
  try {
    if (!enabled)     return;
    anchorSelectionIndex=index0;
    leadSelectionIndex=index1;
    if (selectionMode == SINGLE_SELECTION) {
      setSubRangeOfRange(false,getMinSelectionIndex(),getMaxSelectionIndex(),-1,-1);
    }
 else     if (selectionMode == SINGLE_INTERVAL_SELECTION) {
      setSubRangeOfRange(false,index0,getMaxSelectionIndex(),-1,-1);
    }
 else {
      setSubRangeOfRange(false,index0,index1,-1,-1);
    }
  }
  finally {
    ((InternalReadWriteLock)eventList.getReadWriteLock()).internalLock().unlock();
  }
}","/** 
 * Change the selection to be the set difference of the current selection  and the indices between index0 and index1 inclusive.
 */
public void removeSelectionInterval(int index0,int index1){
  ((InternalReadWriteLock)eventList.getReadWriteLock()).internalLock().lock();
  try {
    if (!enabled)     return;
    if (index0 < 0 || index1 < 0) {
      return;
    }
    anchorSelectionIndex=index0;
    leadSelectionIndex=index1;
    if (selectionMode == SINGLE_SELECTION) {
      setSubRangeOfRange(false,getMinSelectionIndex(),getMaxSelectionIndex(),-1,-1);
    }
 else     if (selectionMode == SINGLE_INTERVAL_SELECTION) {
      setSubRangeOfRange(false,index0,getMaxSelectionIndex(),-1,-1);
    }
 else {
      setSubRangeOfRange(false,index0,index1,-1,-1);
    }
  }
  finally {
    ((InternalReadWriteLock)eventList.getReadWriteLock()).internalLock().unlock();
  }
}",0.9669811320754716
32823,"/** 
 * Returns the number of elements in this list. This is the number of elements currently selected.
 */
public int size(){
  return flagList.getCompressedList().size();
}","/** 
 * Returns the number of elements in this list.
 * @return the number of elements currently selected.
 */
public int size(){
  return flagList.getCompressedList().size();
}",0.9572649572649572
32824,"/** 
 * Gets the index of the node with the specified compressedIndex. Compressed index is defined as the index of that element in the compressed list. This is the index of the node if all nulls were to be removed from the list.
 */
public int getIndex(int compressedIndex){
  if (root == null)   throw new IndexOutOfBoundsException(""String_Node_Str"" + compressedIndex);
  SparseListNode node=root.getNodeByCompressedIndex(compressedIndex);
  return node.getIndex();
}","/** 
 * Gets the index of the node with the specified compressedIndex. Compressed index is defined as the index of that element in the compressed list. This is the index of the node if all nulls were to be removed from the list.
 */
public int getIndex(int compressedIndex){
  if (root == null)   throw new IndexOutOfBoundsException(""String_Node_Str"" + compressedIndex);
  return root.getIndexByCompressedIndex(compressedIndex);
}",0.930957683741648
32825,"/** 
 * Gets the sorting style for this column.
 */
public int getSortingStyle(){
  if (clickCount == 0)   return COLUMN_UNSORTED;
  if (column == primaryColumn) {
    if (isReverse()) {
      if (getComparatorIndex() == 0)       return COLUMN_PRIMARY_SORTED;
 else       return COLUMN_PRIMARY_SORTED_ALTERNATE;
    }
 else {
      if (getComparatorIndex() == 0)       return COLUMN_PRIMARY_SORTED_REVERSE;
 else       return COLUMN_PRIMARY_SORTED_ALTERNATE_REVERSE;
    }
  }
 else {
    if (isReverse()) {
      if (getComparatorIndex() == 0)       return COLUMN_SECONDARY_SORTED;
 else       return COLUMN_SECONDARY_SORTED_ALTERNATE;
    }
 else {
      if (getComparatorIndex() == 0)       return COLUMN_SECONDARY_SORTED_REVERSE;
 else       return COLUMN_SECONDARY_SORTED_ALTERNATE_REVERSE;
    }
  }
}","/** 
 * Gets the sorting style for this column.
 */
public int getSortingStyle(){
  if (clickCount == 0)   return COLUMN_UNSORTED;
  if (column == primaryColumn) {
    if (!isReverse()) {
      if (getComparatorIndex() == 0)       return COLUMN_PRIMARY_SORTED;
 else       return COLUMN_PRIMARY_SORTED_ALTERNATE;
    }
 else {
      if (getComparatorIndex() == 0)       return COLUMN_PRIMARY_SORTED_REVERSE;
 else       return COLUMN_PRIMARY_SORTED_ALTERNATE_REVERSE;
    }
  }
 else {
    if (!isReverse()) {
      if (getComparatorIndex() == 0)       return COLUMN_SECONDARY_SORTED;
 else       return COLUMN_SECONDARY_SORTED_ALTERNATE;
    }
 else {
      if (getComparatorIndex() == 0)       return COLUMN_SECONDARY_SORTED_REVERSE;
 else       return COLUMN_SECONDARY_SORTED_ALTERNATE_REVERSE;
    }
  }
}",0.9987623762376238
32826,"/** 
 * For implementing the ListEventListener interface. When the underlying list changes, this notification allows the object to repaint itself or update itself as necessary. <p>This is implemented in two phases. First, the unsorted index tree is updated so that it maches the source list. This is necessary so that when sorted operations are performed, the comparisons are done with respect to the correct unsorted index. In the second phase, the sorted list is updated with the changes.
 */
public void listChanged(ListEvent listChanges){
  if (debug)   System.out.println(""String_Node_Str"");
  if (debug)   System.out.println(""String_Node_Str"" + listChanges);
  updates.beginEvent();
  LinkedList insertNodes=new LinkedList();
  LinkedList updateNodes=new LinkedList();
  LinkedList deleteIndices=new LinkedList();
  ListEvent firstPass=new ListEvent(listChanges);
  while (firstPass.next()) {
    int unsortedIndex=firstPass.getIndex();
    int changeType=firstPass.getType();
    if (changeType == ListEvent.INSERT) {
      IndexedTreeNode unsortedNode=unsorted.addByNode(unsortedIndex,this);
      insertNodes.addLast(unsortedNode);
    }
 else     if (changeType == ListEvent.DELETE) {
      IndexedTreeNode unsortedNode=unsorted.getNode(unsortedIndex);
      unsortedNode.removeFromTree();
      int deleteSortedIndex=deleteByUnsortedNode(unsortedNode);
      updates.addDelete(deleteSortedIndex);
    }
 else     if (changeType == ListEvent.UPDATE) {
    }
  }
  ListEvent secondPass=listChanges;
  while (secondPass.next()) {
    int unsortedIndex=secondPass.getIndex();
    int changeType=secondPass.getType();
    if (changeType == ListEvent.UPDATE) {
      IndexedTreeNode unsortedNode=unsorted.getNode(unsortedIndex);
      int deleteSortedIndex=deleteByUnsortedNode(unsortedNode);
      updateNodes.addLast(unsortedNode);
      deleteIndices.addLast(new Integer(deleteSortedIndex));
    }
  }
  if (debug)   System.out.println(deleteIndices);
  while (!updateNodes.isEmpty()) {
    IndexedTreeNode updateNode=(IndexedTreeNode)updateNodes.removeFirst();
    int deletedIndex=((Integer)deleteIndices.removeFirst()).intValue();
    int insertedIndex=insertByUnsortedNode(updateNode);
    if (debug)     System.out.println(""String_Node_Str"" + deletedIndex + ""String_Node_Str""+ insertedIndex+ ""String_Node_Str""+ deleteIndices);
    for (ListIterator i=deleteIndices.listIterator(deleteIndices.size()); i.hasPrevious(); ) {
      int currentDeletedIndex=((Integer)i.previous()).intValue();
      if (currentDeletedIndex <= insertedIndex) {
        insertedIndex++;
      }
 else {
        currentDeletedIndex++;
        i.set(new Integer(currentDeletedIndex));
      }
    }
    if (deletedIndex == insertedIndex) {
      if (debug == true)       System.out.println(""String_Node_Str"" + insertedIndex);
      updates.addUpdate(insertedIndex);
    }
 else {
      if (debug == true)       System.out.println(""String_Node_Str"" + deletedIndex + ""String_Node_Str""+ insertedIndex);
      updates.addDelete(deletedIndex);
      updates.addInsert(insertedIndex);
    }
  }
  while (!insertNodes.isEmpty()) {
    IndexedTreeNode insertNode=(IndexedTreeNode)insertNodes.removeFirst();
    int insertedIndex=insertByUnsortedNode(insertNode);
    updates.addInsert(insertedIndex);
  }
  updates.commitEvent();
  if (debug)   System.out.println(""String_Node_Str"");
}","/** 
 * For implementing the ListEventListener interface. When the underlying list changes, this notification allows the object to repaint itself or update itself as necessary. <p>This is implemented in two phases. First, the unsorted index tree is updated so that it maches the source list. This is necessary so that when sorted operations are performed, the comparisons are done with respect to the correct unsorted index. In the second phase, the sorted list is updated with the changes.
 */
public void listChanged(ListEvent listChanges){
  if (debug)   System.out.println(""String_Node_Str"");
  if (debug)   System.out.println(""String_Node_Str"" + listChanges);
  updates.beginEvent();
  LinkedList insertNodes=new LinkedList();
  ListEvent firstPass=new ListEvent(listChanges);
  while (firstPass.next()) {
    int unsortedIndex=firstPass.getIndex();
    int changeType=firstPass.getType();
    if (changeType == ListEvent.INSERT) {
      IndexedTreeNode unsortedNode=unsorted.addByNode(unsortedIndex,this);
      insertNodes.addLast(unsortedNode);
    }
 else     if (changeType == ListEvent.DELETE) {
      IndexedTreeNode unsortedNode=unsorted.getNode(unsortedIndex);
      unsortedNode.removeFromTree();
      int deleteSortedIndex=deleteByUnsortedNode(unsortedNode);
      updates.addDelete(deleteSortedIndex);
    }
 else     if (changeType == ListEvent.UPDATE) {
    }
  }
  if (debug) {
    System.out.print(""String_Node_Str"");
    for (int i=0; i < sorted.size(); i++) {
      System.out.print(""String_Node_Str"" + i);
      int unsortedIndex=((IndexedTreeNode)sorted.getNode(i).getValue()).getIndex();
      System.out.print(""String_Node_Str"" + unsortedIndex);
      System.out.print(""String_Node_Str"" + source.get(unsortedIndex) + ""String_Node_Str"");
    }
    System.out.print(""String_Node_Str"");
  }
  IndicesPendingDeletion indicesPendingDeletion=new IndicesPendingDeletion();
  ListEvent secondPass=new ListEvent(listChanges);
  while (secondPass.next()) {
    int unsortedIndex=secondPass.getIndex();
    int changeType=secondPass.getType();
    if (changeType == ListEvent.UPDATE) {
      IndexedTreeNode unsortedNode=unsorted.getNode(unsortedIndex);
      IndexedTreeNode sortedNode=(IndexedTreeNode)unsortedNode.getValue();
      int originalIndex=sortedNode.getIndex();
      indicesPendingDeletion.addPair(new IndexNodePair(originalIndex,unsortedNode));
    }
  }
  if (debug)   System.out.println(""String_Node_Str"" + indicesPendingDeletion);
  ListEvent thirdPass=listChanges;
  while (thirdPass.next()) {
    int unsortedIndex=thirdPass.getIndex();
    int changeType=thirdPass.getType();
    if (changeType == ListEvent.UPDATE) {
      IndexedTreeNode unsortedNode=unsorted.getNode(unsortedIndex);
      int deleteSortedIndex=deleteByUnsortedNode(unsortedNode);
    }
  }
  while (indicesPendingDeletion.hasPair()) {
    IndexNodePair indexNodePair=indicesPendingDeletion.removePair();
    int insertedIndex=insertByUnsortedNode(indexNodePair.node);
    int deletedIndex=indexNodePair.index;
    insertedIndex=indicesPendingDeletion.adjustDeleteAndInsert(deletedIndex,insertedIndex);
    if (debug)     System.out.println(""String_Node_Str"" + deletedIndex + ""String_Node_Str""+ insertedIndex+ ""String_Node_Str""+ indicesPendingDeletion);
    if (deletedIndex == insertedIndex) {
      if (debug == true)       System.out.println(""String_Node_Str"" + insertedIndex);
      updates.addUpdate(insertedIndex);
    }
 else {
      if (debug == true)       System.out.println(""String_Node_Str"" + deletedIndex + ""String_Node_Str""+ insertedIndex);
      updates.addDelete(deletedIndex);
      updates.addInsert(insertedIndex);
    }
  }
  while (!insertNodes.isEmpty()) {
    IndexedTreeNode insertNode=(IndexedTreeNode)insertNodes.removeFirst();
    int insertedIndex=insertByUnsortedNode(insertNode);
    updates.addInsert(insertedIndex);
  }
  updates.commitEvent();
  if (debug)   System.out.println(""String_Node_Str"");
}",0.7097480832420592
32827,"public int compare(Object a,Object b){
  int number1=((Integer)a).intValue();
  int number2=((Integer)b).intValue();
  int number1Flipped=flip(number1);
  int number2Flipped=flip(number2);
  return number1Flipped - number2Flipped;
}","public int compare(Object a,Object b){
  String aString=(String)a;
  String bString=(String)b;
  return delegate.compare(flip(aString),flip(bString));
}",0.4583333333333333
32828,"/** 
 * Test if the SortedList fires update events rather than delete/insert pairs, when using a ReverseComparator. <p>The source list uses a totally different comparator than the sorted list in order to guarantee the indicies have no pattern.
 */
public void testUpdateEventsFiredRigorous(){
  Comparator uniqueComparator=new ReverseStringComparator();
  UniqueList uniqueSource=new UniqueList(unsortedList,uniqueComparator);
  sortedList=new SortedList(uniqueSource);
  for (int i=0; i < 500; i++) {
    uniqueSource.add(new Integer(random.nextInt(200)));
  }
  SortedSet data=new TreeSet(uniqueComparator);
  for (int i=0; i < 500; i++) {
    data.add(new Integer(random.nextInt(200)));
  }
  List intersection=new ArrayList();
  intersection.addAll(uniqueSource);
  intersection.retainAll(data);
  int expectedUpdateCount=intersection.size();
  int expectedDeleteCount=uniqueSource.size() - expectedUpdateCount;
  int expectedInsertCount=data.size() - expectedUpdateCount;
  int expectedChangeCount=expectedUpdateCount + expectedDeleteCount + expectedInsertCount;
  ListEventCounter uniqueCounter=new ListEventCounter();
  uniqueSource.addListEventListener(uniqueCounter);
  ListEventCounter sortedCounter=new ListEventCounter();
  sortedList.addListEventListener(sortedCounter);
  uniqueSource.addListEventListener(new ConsistencyTestList(uniqueSource,""String_Node_Str"",true));
  sortedList.addListEventListener(new ConsistencyTestList(sortedList,""String_Node_Str"",true));
  uniqueSource.replaceAll(data);
  assertEquals(1,uniqueCounter.getEventCount());
  assertEquals(1,sortedCounter.getEventCount());
  assertEquals(expectedChangeCount,uniqueCounter.getChangeCount(0));
  assertEquals(expectedChangeCount,sortedCounter.getChangeCount(0));
}","/** 
 * Test if the SortedList fires update events rather than delete/insert pairs, when using a ReverseComparator. <p>The source list uses a totally different comparator than the sorted list in order to guarantee the indicies have no pattern.
 */
public void testUpdateEventsFiredRigorous(){
  Comparator uniqueComparator=new ReverseStringComparator();
  UniqueList uniqueSource=new UniqueList(unsortedList,uniqueComparator);
  sortedList=new SortedList(uniqueSource);
  for (int i=0; i < 500; i++) {
    uniqueSource.add(""String_Node_Str"" + random.nextInt(200));
  }
  SortedSet data=new TreeSet(uniqueComparator);
  for (int i=0; i < 500; i++) {
    data.add(""String_Node_Str"" + random.nextInt(200));
  }
  List intersection=new ArrayList();
  intersection.addAll(uniqueSource);
  intersection.retainAll(data);
  int expectedUpdateCount=intersection.size();
  int expectedDeleteCount=uniqueSource.size() - expectedUpdateCount;
  int expectedInsertCount=data.size() - expectedUpdateCount;
  int expectedChangeCount=expectedUpdateCount + expectedDeleteCount + expectedInsertCount;
  ListEventCounter uniqueCounter=new ListEventCounter();
  uniqueSource.addListEventListener(uniqueCounter);
  ListEventCounter sortedCounter=new ListEventCounter();
  sortedList.addListEventListener(sortedCounter);
  uniqueSource.addListEventListener(new ConsistencyTestList(uniqueSource,""String_Node_Str"",true));
  sortedList.addListEventListener(new ConsistencyTestList(sortedList,""String_Node_Str"",true));
  uniqueSource.replaceAll(data);
  assertEquals(1,uniqueCounter.getEventCount());
  assertEquals(1,sortedCounter.getEventCount());
  assertEquals(expectedChangeCount,uniqueCounter.getChangeCount(0));
  assertEquals(expectedChangeCount,sortedCounter.getChangeCount(0));
}",0.9823361823361824
32829,"/** 
 * For implementing the ListEventListener interface. When the underlying list changes, this notification allows the object to repaint itself or update itself as necessary. <li>When a list item is updated, it may become visible or become filtered. <li>When a list item is inserted, it may be visible or filtered. <li>When a list item is deleted, it must be filtered if it is not visible.
 */
public final void listChanged(ListEvent listChanges){
  updates.beginEvent();
  if (listChanges.isReordering()) {
    int[] sourceReorderMap=listChanges.getReorderMap();
    int[] filterReorderMap=new int[flagList.getCompressedList().size()];
    SparseList previousFlagList=flagList;
    flagList=new SparseList();
    for (int i=0; i < sourceReorderMap.length; i++) {
      Object flag=previousFlagList.get(sourceReorderMap[i]);
      flagList.add(flag);
      if (flag != null)       filterReorderMap[flagList.getCompressedIndex(i)]=previousFlagList.getCompressedIndex(sourceReorderMap[i]);
    }
    updates.reorder(filterReorderMap);
  }
 else {
    while (listChanges.next()) {
      int sourceIndex=listChanges.getIndex();
      int changeType=listChanges.getType();
      if (changeType == ListEvent.DELETE) {
        boolean wasIncluded=flagList.get(sourceIndex) != null;
        if (wasIncluded) {
          int filteredIndex=flagList.getCompressedIndex(sourceIndex);
          updates.addDelete(filteredIndex);
        }
        flagList.remove(sourceIndex);
      }
 else       if (changeType == ListEvent.INSERT) {
        boolean include=filterMatches(source.get(sourceIndex));
        if (include) {
          flagList.add(sourceIndex,Boolean.TRUE);
          int filteredIndex=flagList.getCompressedIndex(sourceIndex);
          updates.addInsert(filteredIndex);
        }
 else {
          flagList.add(sourceIndex,null);
        }
      }
 else       if (changeType == ListEvent.UPDATE) {
        boolean wasIncluded=flagList.get(sourceIndex) != null;
        boolean include=filterMatches(source.get(sourceIndex));
        if (wasIncluded && !include) {
          int filteredIndex=flagList.getCompressedIndex(sourceIndex);
          flagList.set(sourceIndex,null);
          updates.addDelete(filteredIndex);
        }
 else         if (!wasIncluded && include) {
          flagList.set(sourceIndex,Boolean.TRUE);
          int filteredIndex=flagList.getCompressedIndex(sourceIndex);
          updates.addInsert(filteredIndex);
        }
      }
    }
  }
  updates.commitEvent();
}","/** 
 * For implementing the ListEventListener interface. When the underlying list changes, this notification allows the object to repaint itself or update itself as necessary. <li>When a list item is updated, it may become visible or become filtered. <li>When a list item is inserted, it may be visible or filtered. <li>When a list item is deleted, it must be filtered if it is not visible.
 */
public final void listChanged(ListEvent listChanges){
  updates.beginEvent();
  if (listChanges.isReordering()) {
    int[] sourceReorderMap=listChanges.getReorderMap();
    int[] filterReorderMap=new int[flagList.getCompressedList().size()];
    SparseList previousFlagList=flagList;
    flagList=new SparseList();
    for (int i=0; i < sourceReorderMap.length; i++) {
      Object flag=previousFlagList.get(sourceReorderMap[i]);
      flagList.add(flag);
      if (flag != null)       filterReorderMap[flagList.getCompressedIndex(i)]=previousFlagList.getCompressedIndex(sourceReorderMap[i]);
    }
    updates.reorder(filterReorderMap);
  }
 else {
    while (listChanges.next()) {
      int sourceIndex=listChanges.getIndex();
      int changeType=listChanges.getType();
      if (changeType == ListEvent.DELETE) {
        boolean wasIncluded=flagList.get(sourceIndex) != null;
        if (wasIncluded) {
          int filteredIndex=flagList.getCompressedIndex(sourceIndex);
          updates.addDelete(filteredIndex);
        }
        flagList.remove(sourceIndex);
      }
 else       if (changeType == ListEvent.INSERT) {
        boolean include=filterMatches(source.get(sourceIndex));
        if (include) {
          flagList.add(sourceIndex,Boolean.TRUE);
          int filteredIndex=flagList.getCompressedIndex(sourceIndex);
          updates.addInsert(filteredIndex);
        }
 else {
          flagList.add(sourceIndex,null);
        }
      }
 else       if (changeType == ListEvent.UPDATE) {
        boolean wasIncluded=flagList.get(sourceIndex) != null;
        boolean include=filterMatches(source.get(sourceIndex));
        if (wasIncluded && !include) {
          int filteredIndex=flagList.getCompressedIndex(sourceIndex);
          flagList.set(sourceIndex,null);
          updates.addDelete(filteredIndex);
        }
 else         if (!wasIncluded && include) {
          flagList.set(sourceIndex,Boolean.TRUE);
          int filteredIndex=flagList.getCompressedIndex(sourceIndex);
          updates.addInsert(filteredIndex);
        }
 else         if (wasIncluded && include) {
          int filteredIndex=flagList.getCompressedIndex(sourceIndex);
          updates.addUpdate(filteredIndex);
        }
      }
    }
  }
  updates.commitEvent();
}",0.967467079783114
32830,"/** 
 * Create a filter list that filters the specified source list, which must contain only Issue objects.
 */
public IssuesUserFilter(EventList source){
  super(source);
  source.addListEventListener(new ConsistencyTestList(source,""String_Node_Str"",true));
  SortedList sortedSource=new SortedList(new IssuesToUserList(source));
  sortedSource.addListEventListener(new ConsistencyTestList(sortedSource,""String_Node_Str"",true));
  usersEventList=new UniqueList(new IssuesToUserList(source));
  usersEventList.addListEventListener(new ConsistencyTestList(usersEventList,""String_Node_Str"",true));
  EventListModel usersListModel=new EventListModel(usersEventList);
  userSelect=new JList(usersListModel);
  EventSelectionModel userSelectionModel=new EventSelectionModel(usersEventList);
  userSelect.setSelectionModel(userSelectionModel.getListSelectionModel());
  usersSelectedList=userSelectionModel.getEventList();
  userSelect.addListSelectionListener(this);
  handleFilterChanged();
}","/** 
 * Create a filter list that filters the specified source list, which must contain only Issue objects.
 */
public IssuesUserFilter(EventList source){
  super(source);
  usersEventList=new UniqueList(new IssuesToUserList(source));
  EventListModel usersListModel=new EventListModel(usersEventList);
  userSelect=new JList(usersListModel);
  EventSelectionModel userSelectionModel=new EventSelectionModel(usersEventList);
  userSelect.setSelectionModel(userSelectionModel.getListSelectionModel());
  usersSelectedList=userSelectionModel.getEventList();
  userSelect.addListSelectionListener(this);
  handleFilterChanged();
  this.addListEventListener(new ConsistencyTestList(this,""String_Node_Str"",true));
  source.addListEventListener(new ConsistencyTestList(source,""String_Node_Str"",true));
}",0.3742296918767507
32831,"/** 
 * Set the comparator used to sort this list. This will resort the list and will take <code>O(N * Log N)</code> time. For large lists, it may be worthwhile to create multiple SortedList views, each of which uses a different Comparator to specify the ordering.
 * @param comparator the comparator to specify how to sort the list. Ifthe list elements implement <code>Comparable</code>, you may use a <code>ComparableComparator</code> instance to sort them in their natural order. You may also specify <code>null</code>, which will leave the list in the same order as the source list.
 */
public void setComparator(Comparator comparator){
  ((InternalReadWriteLock)getReadWriteLock()).internalLock().lock();
  try {
    this.comparator=comparator;
    IndexedTree previousSorted=sorted;
    IndexedTree previousUnsorted=unsorted;
    Comparator treeComparator=null;
    if (comparator != null)     treeComparator=new IndexedTreeNodeComparator(comparator);
 else     treeComparator=new IndexedTreeNodeRawOrderComparator();
    sorted=new IndexedTree(treeComparator);
    unsorted=new IndexedTree();
    for (int i=0; i < source.size(); i++) {
      IndexedTreeNode unsortedNode=unsorted.addByNode(i,this);
      insertByUnsortedNode(unsortedNode);
    }
    if (previousSorted == null && previousUnsorted == null)     return;
    int[] reorderMap=new int[size()];
    for (int i=0; i < reorderMap.length; i++) {
      IndexedTreeNode sortedNode=sorted.getNode(i);
      IndexedTreeNode unsortedNode=(IndexedTreeNode)sortedNode.getValue();
      int unsortedIndex=unsortedNode.getIndex();
      IndexedTreeNode previousUnsortedNode=previousUnsorted.getNode(unsortedIndex);
      IndexedTreeNode previousSortedNode=(IndexedTreeNode)previousUnsortedNode.getValue();
      int previousIndex=previousSortedNode.getIndex();
      reorderMap[i]=previousIndex;
    }
    updates.beginEvent();
    updates.reorder(reorderMap);
    updates.commitEvent();
  }
  finally {
    ((InternalReadWriteLock)getReadWriteLock()).internalLock().unlock();
  }
}","/** 
 * Set the comparator used to sort this list. This will resort the list and will take <code>O(N * Log N)</code> time. For large lists, it may be worthwhile to create multiple SortedList views, each of which uses a different Comparator to specify the ordering.
 * @param comparator the comparator to specify how to sort the list. Ifthe list elements implement <code>Comparable</code>, you may use a <code>ComparableComparator</code> instance to sort them in their natural order. You may also specify <code>null</code>, which will leave the list in the same order as the source list.
 */
public void setComparator(Comparator comparator){
  ((InternalReadWriteLock)getReadWriteLock()).internalLock().lock();
  try {
    this.comparator=comparator;
    IndexedTree previousSorted=sorted;
    IndexedTree previousUnsorted=unsorted;
    Comparator treeComparator=null;
    if (comparator != null)     treeComparator=new IndexedTreeNodeComparator(comparator);
 else     treeComparator=new IndexedTreeNodeRawOrderComparator();
    sorted=new IndexedTree(treeComparator);
    unsorted=new IndexedTree();
    if (source.size() == 0)     return;
    for (int i=0; i < source.size(); i++) {
      IndexedTreeNode unsortedNode=unsorted.addByNode(i,this);
      insertByUnsortedNode(unsortedNode);
    }
    if (previousSorted == null && previousUnsorted == null)     return;
    int[] reorderMap=new int[size()];
    for (int i=0; i < reorderMap.length; i++) {
      IndexedTreeNode sortedNode=sorted.getNode(i);
      IndexedTreeNode unsortedNode=(IndexedTreeNode)sortedNode.getValue();
      int unsortedIndex=unsortedNode.getIndex();
      IndexedTreeNode previousUnsortedNode=previousUnsorted.getNode(unsortedIndex);
      IndexedTreeNode previousSortedNode=(IndexedTreeNode)previousUnsortedNode.getValue();
      int previousIndex=previousSortedNode.getIndex();
      reorderMap[i]=previousIndex;
    }
    updates.beginEvent();
    updates.reorder(reorderMap);
    updates.commitEvent();
  }
  finally {
    ((InternalReadWriteLock)getReadWriteLock()).internalLock().unlock();
  }
}",0.9902912621359224
32832,"/** 
 * Change the selection to be the set union of the current selection  and the indices between index0 and index1 inclusive
 */
public void addSelectionInterval(int index0,int index1){
  ((InternalReadWriteLock)eventList.getReadWriteLock()).internalLock().lock();
  try {
    anchorSelectionIndex=index0;
    leadSelectionIndex=index1;
    if (selectionMode == SINGLE_SELECTION) {
      setSubRangeOfRange(true,index0,index0,getMinSelectionIndex(),getMaxSelectionIndex());
    }
 else     if (selectionMode == SINGLE_INTERVAL_SELECTION) {
      boolean overlap=false;
      int minSelectedIndex=getMinSelectionIndex();
      int maxSelectedIndex=getMaxSelectionIndex();
      if (minSelectedIndex - 1 <= index0 && index0 <= maxSelectedIndex + 1)       overlap=true;
      if (minSelectedIndex - 1 <= index1 && index1 <= maxSelectedIndex + 1)       overlap=true;
      if (overlap) {
        setSubRangeOfRange(true,index0,index1,-1,-1);
      }
 else {
        setSubRangeOfRange(true,index0,index1,minSelectedIndex,maxSelectedIndex);
      }
    }
 else {
      setSubRangeOfRange(true,index0,index1,-1,-1);
    }
  }
  finally {
    ((InternalReadWriteLock)eventList.getReadWriteLock()).internalLock().unlock();
  }
}","/** 
 * Change the selection to be the set union of the current selection  and the indices between index0 and index1 inclusive
 */
public void addSelectionInterval(int index0,int index1){
  ((InternalReadWriteLock)eventList.getReadWriteLock()).internalLock().lock();
  try {
    if (!enabled)     return;
    anchorSelectionIndex=index0;
    leadSelectionIndex=index1;
    if (selectionMode == SINGLE_SELECTION) {
      setSubRangeOfRange(true,index0,index0,getMinSelectionIndex(),getMaxSelectionIndex());
    }
 else     if (selectionMode == SINGLE_INTERVAL_SELECTION) {
      boolean overlap=false;
      int minSelectedIndex=getMinSelectionIndex();
      int maxSelectedIndex=getMaxSelectionIndex();
      if (minSelectedIndex - 1 <= index0 && index0 <= maxSelectedIndex + 1)       overlap=true;
      if (minSelectedIndex - 1 <= index1 && index1 <= maxSelectedIndex + 1)       overlap=true;
      if (overlap) {
        setSubRangeOfRange(true,index0,index1,-1,-1);
      }
 else {
        setSubRangeOfRange(true,index0,index1,minSelectedIndex,maxSelectedIndex);
      }
    }
 else {
      setSubRangeOfRange(true,index0,index1,-1,-1);
    }
  }
  finally {
    ((InternalReadWriteLock)eventList.getReadWriteLock()).internalLock().unlock();
  }
}",0.9878738884397736
32833,"/** 
 * Change the selection to the empty set.
 */
public void clearSelection(){
  ((InternalReadWriteLock)eventList.getReadWriteLock()).internalLock().lock();
  try {
    setSubRangeOfRange(false,getMinSelectionIndex(),getMaxSelectionIndex(),-1,-1);
  }
  finally {
    ((InternalReadWriteLock)eventList.getReadWriteLock()).internalLock().unlock();
  }
}","/** 
 * Change the selection to the empty set.
 */
public void clearSelection(){
  ((InternalReadWriteLock)eventList.getReadWriteLock()).internalLock().lock();
  try {
    if (!enabled)     return;
    setSubRangeOfRange(false,getMinSelectionIndex(),getMaxSelectionIndex(),-1,-1);
  }
  finally {
    ((InternalReadWriteLock)eventList.getReadWriteLock()).internalLock().unlock();
  }
}",0.9594594594594594
32834,"/** 
 * Change the selection to be between index0 and index1 inclusive. First this calculates the smallest range where changes occur. This includes the union of the selection range before and the selection range specified. It then walks through the change and sets each index as selected or not based on whether the index is in the  new range. Finally it fires events to both the listening lists and selection listeners about what changes happened. If the selection does not change, this will not fire any events.
 */
public void setSelectionInterval(int index0,int index1){
  ((InternalReadWriteLock)eventList.getReadWriteLock()).internalLock().lock();
  try {
    anchorSelectionIndex=index0;
    leadSelectionIndex=index1;
    if (selectionMode == SINGLE_SELECTION) {
      setSubRangeOfRange(true,index0,index0,getMinSelectionIndex(),getMaxSelectionIndex());
    }
 else {
      setSubRangeOfRange(true,index0,index1,getMinSelectionIndex(),getMaxSelectionIndex());
    }
  }
  finally {
    ((InternalReadWriteLock)eventList.getReadWriteLock()).internalLock().unlock();
  }
}","/** 
 * Change the selection to be between index0 and index1 inclusive. First this calculates the smallest range where changes occur. This includes the union of the selection range before and the selection range specified. It then walks through the change and sets each index as selected or not based on whether the index is in the  new range. Finally it fires events to both the listening lists and selection listeners about what changes happened. If the selection does not change, this will not fire any events.
 */
public void setSelectionInterval(int index0,int index1){
  ((InternalReadWriteLock)eventList.getReadWriteLock()).internalLock().lock();
  try {
    if (!enabled)     return;
    anchorSelectionIndex=index0;
    leadSelectionIndex=index1;
    if (selectionMode == SINGLE_SELECTION) {
      setSubRangeOfRange(true,index0,index0,getMinSelectionIndex(),getMaxSelectionIndex());
    }
 else {
      setSubRangeOfRange(true,index0,index1,getMinSelectionIndex(),getMaxSelectionIndex());
    }
  }
  finally {
    ((InternalReadWriteLock)eventList.getReadWriteLock()).internalLock().unlock();
  }
}",0.986288848263254
32835,"/** 
 * Set the anchor selection index.
 */
public void setAnchorSelectionIndex(int anchorSelectionIndex){
  ((InternalReadWriteLock)eventList.getReadWriteLock()).internalLock().lock();
  try {
    this.anchorSelectionIndex=anchorSelectionIndex;
    if (anchorSelectionIndex == -1) {
      clearSelection();
      return;
    }
    if (selectionMode == SINGLE_SELECTION) {
      setSubRangeOfRange(true,anchorSelectionIndex,anchorSelectionIndex,getMinSelectionIndex(),getMaxSelectionIndex());
    }
 else     if (selectionMode == SINGLE_INTERVAL_SELECTION) {
      setSubRangeOfRange(true,anchorSelectionIndex,leadSelectionIndex,getMinSelectionIndex(),getMaxSelectionIndex());
    }
 else {
      setSubRangeOfRange(true,anchorSelectionIndex,leadSelectionIndex,-1,-1);
    }
  }
  finally {
    ((InternalReadWriteLock)eventList.getReadWriteLock()).internalLock().unlock();
  }
}","/** 
 * Set the anchor selection index.
 */
public void setAnchorSelectionIndex(int anchorSelectionIndex){
  ((InternalReadWriteLock)eventList.getReadWriteLock()).internalLock().lock();
  try {
    if (!enabled)     return;
    this.anchorSelectionIndex=anchorSelectionIndex;
    if (anchorSelectionIndex == -1) {
      clearSelection();
      return;
    }
    if (selectionMode == SINGLE_SELECTION) {
      setSubRangeOfRange(true,anchorSelectionIndex,anchorSelectionIndex,getMinSelectionIndex(),getMaxSelectionIndex());
    }
 else     if (selectionMode == SINGLE_INTERVAL_SELECTION) {
      setSubRangeOfRange(true,anchorSelectionIndex,leadSelectionIndex,getMinSelectionIndex(),getMaxSelectionIndex());
    }
 else {
      setSubRangeOfRange(true,anchorSelectionIndex,leadSelectionIndex,-1,-1);
    }
  }
  finally {
    ((InternalReadWriteLock)eventList.getReadWriteLock()).internalLock().unlock();
  }
}",0.9832214765100672
32836,"/** 
 * Change the selection to be the set difference of the current selection  and the indices between index0 and index1 inclusive.
 */
public void removeSelectionInterval(int index0,int index1){
  ((InternalReadWriteLock)eventList.getReadWriteLock()).internalLock().lock();
  try {
    anchorSelectionIndex=index0;
    leadSelectionIndex=index1;
    if (selectionMode == SINGLE_SELECTION) {
      setSubRangeOfRange(false,getMinSelectionIndex(),getMaxSelectionIndex(),-1,-1);
    }
 else     if (selectionMode == SINGLE_INTERVAL_SELECTION) {
      setSubRangeOfRange(false,index0,getMaxSelectionIndex(),-1,-1);
    }
 else {
      setSubRangeOfRange(false,index0,index1,-1,-1);
    }
  }
  finally {
    ((InternalReadWriteLock)eventList.getReadWriteLock()).internalLock().unlock();
  }
}","/** 
 * Change the selection to be the set difference of the current selection  and the indices between index0 and index1 inclusive.
 */
public void removeSelectionInterval(int index0,int index1){
  ((InternalReadWriteLock)eventList.getReadWriteLock()).internalLock().lock();
  try {
    if (!enabled)     return;
    anchorSelectionIndex=index0;
    leadSelectionIndex=index1;
    if (selectionMode == SINGLE_SELECTION) {
      setSubRangeOfRange(false,getMinSelectionIndex(),getMaxSelectionIndex(),-1,-1);
    }
 else     if (selectionMode == SINGLE_INTERVAL_SELECTION) {
      setSubRangeOfRange(false,index0,getMaxSelectionIndex(),-1,-1);
    }
 else {
      setSubRangeOfRange(false,index0,index1,-1,-1);
    }
  }
  finally {
    ((InternalReadWriteLock)eventList.getReadWriteLock()).internalLock().unlock();
  }
}",0.9813664596273292
32837,"/** 
 * Set the lead selection index.
 */
public void setLeadSelectionIndex(int leadSelectionIndex){
  ((InternalReadWriteLock)eventList.getReadWriteLock()).internalLock().lock();
  try {
    int originalLeadIndex=this.leadSelectionIndex;
    this.leadSelectionIndex=leadSelectionIndex;
    if (leadSelectionIndex == -1) {
      clearSelection();
      return;
    }
    if (selectionMode == SINGLE_SELECTION) {
      setSubRangeOfRange(true,leadSelectionIndex,leadSelectionIndex,getMinSelectionIndex(),getMaxSelectionIndex());
    }
 else     if (selectionMode == SINGLE_INTERVAL_SELECTION) {
      setSubRangeOfRange(true,anchorSelectionIndex,leadSelectionIndex,getMinSelectionIndex(),getMaxSelectionIndex());
    }
 else {
      setSubRangeOfRange(true,anchorSelectionIndex,leadSelectionIndex,anchorSelectionIndex,originalLeadIndex);
    }
  }
  finally {
    ((InternalReadWriteLock)eventList.getReadWriteLock()).internalLock().unlock();
  }
}","/** 
 * Set the lead selection index.
 */
public void setLeadSelectionIndex(int leadSelectionIndex){
  ((InternalReadWriteLock)eventList.getReadWriteLock()).internalLock().lock();
  try {
    if (!enabled)     return;
    int originalLeadIndex=this.leadSelectionIndex;
    this.leadSelectionIndex=leadSelectionIndex;
    if (leadSelectionIndex == -1) {
      clearSelection();
      return;
    }
    if (selectionMode == SINGLE_SELECTION) {
      setSubRangeOfRange(true,leadSelectionIndex,leadSelectionIndex,getMinSelectionIndex(),getMaxSelectionIndex());
    }
 else     if (selectionMode == SINGLE_INTERVAL_SELECTION) {
      setSubRangeOfRange(true,anchorSelectionIndex,leadSelectionIndex,getMinSelectionIndex(),getMaxSelectionIndex());
    }
 else {
      setSubRangeOfRange(true,anchorSelectionIndex,leadSelectionIndex,anchorSelectionIndex,originalLeadIndex);
    }
  }
  finally {
    ((InternalReadWriteLock)eventList.getReadWriteLock()).internalLock().unlock();
  }
}",0.9844074844074844
32838,"/** 
 * Creates a new TableComparatorChooser that responds to clicks on the specified table and uses them to sort the specified list.
 * @param table the table with headers that can be clicked on.
 * @param sortedList the sorted list to update.
 * @param multipleColumnSort true to sort by multiple columns at a time, ortrue to sort by a single column. Although sorting by multiple columns is more powerful, the user interface is not as simple and this strategy should only be used where necessary.
 */
public TableComparatorChooser(JTable table,SortedList sortedList,boolean multipleColumnSort){
  this.table=table;
  this.sortedList=sortedList;
  this.multipleColumnSort=multipleColumnSort;
  try {
    eventTableModel=(EventTableModel)table.getModel();
  }
 catch (  ClassCastException e) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  rebuildColumns();
  table.getTableHeader().setDefaultRenderer(new SortArrowHeaderRenderer());
  table.setColumnSelectionAllowed(false);
  table.getTableHeader().addMouseListener(this);
  table.getModel().addTableModelListener(this);
}","/** 
 * Creates a new TableComparatorChooser that responds to clicks on the specified table and uses them to sort the specified list.
 * @param table the table with headers that can be clicked on.
 * @param sortedList the sorted list to update.
 * @param multipleColumnSort <code>true</code> to sort by multiple columnsat a time, or <code>false</code> to sort by a single column. Although sorting by multiple columns is more powerful, the user interface is not as simple and this strategy should only be used where necessary.
 */
public TableComparatorChooser(JTable table,SortedList sortedList,boolean multipleColumnSort){
  this.table=table;
  this.sortedList=sortedList;
  this.multipleColumnSort=multipleColumnSort;
  try {
    eventTableModel=(EventTableModel)table.getModel();
  }
 catch (  ClassCastException e) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  rebuildColumns();
  table.getTableHeader().setDefaultRenderer(new SortArrowHeaderRenderer());
  table.setColumnSelectionAllowed(false);
  table.getTableHeader().addMouseListener(this);
  table.getModel().addTableModelListener(this);
}",0.9796656122910076
32839,"/** 
 * For implementing the ListEventListener interface. When the underlying list changes, this notification allows the object to repaint itself or update itself as necessary. <p>This is implemented in two phases. First, the unsorted index tree is updated so that it maches the source list. This is necessary so that when sorted operations are performed, the comparisons are done with respect to the correct unsorted index. In the second phase, the sorted list is updated with the changes.
 */
public void listChanged(ListEvent listChanges){
  if (debug)   System.out.println(""String_Node_Str"");
  if (debug)   System.out.println(""String_Node_Str"" + listChanges);
  updates.beginEvent();
  LinkedList insertNodes=new LinkedList();
  LinkedList updateNodes=new LinkedList();
  LinkedList deleteIndices=new LinkedList();
  ListEvent firstPass=new ListEvent(listChanges);
  while (firstPass.next()) {
    int unsortedIndex=firstPass.getIndex();
    int changeType=firstPass.getType();
    if (changeType == ListEvent.INSERT) {
      IndexedTreeNode unsortedNode=unsorted.addByNode(unsortedIndex,this);
      insertNodes.addLast(unsortedNode);
    }
 else     if (changeType == ListEvent.DELETE) {
      IndexedTreeNode unsortedNode=unsorted.getNode(unsortedIndex);
      unsortedNode.removeFromTree();
      int deleteSortedIndex=deleteByUnsortedNode(unsortedNode);
      updates.addDelete(deleteSortedIndex);
    }
 else     if (changeType == ListEvent.UPDATE) {
    }
  }
  ListEvent secondPass=listChanges;
  while (secondPass.next()) {
    int unsortedIndex=secondPass.getIndex();
    int changeType=secondPass.getType();
    if (changeType == ListEvent.UPDATE) {
      IndexedTreeNode unsortedNode=unsorted.getNode(unsortedIndex);
      int deleteSortedIndex=deleteByUnsortedNode(unsortedNode);
      updateNodes.addLast(unsortedNode);
      deleteIndices.addLast(new Integer(deleteSortedIndex));
    }
  }
  if (debug)   System.out.println(deleteIndices);
  while (!updateNodes.isEmpty()) {
    IndexedTreeNode updateNode=(IndexedTreeNode)updateNodes.removeFirst();
    int deletedIndex=((Integer)deleteIndices.removeFirst()).intValue();
    int insertedIndex=insertByUnsortedNode(updateNode);
    if (debug)     System.out.println(""String_Node_Str"" + deletedIndex + ""String_Node_Str""+ insertedIndex+ ""String_Node_Str""+ deleteIndices);
    for (ListIterator i=deleteIndices.listIterator(deleteIndices.size()); i.hasPrevious(); ) {
      int currentDeletedIndex=((Integer)i.previous()).intValue();
      if (currentDeletedIndex <= insertedIndex) {
        insertedIndex++;
      }
 else {
        currentDeletedIndex++;
        i.set(new Integer(currentDeletedIndex));
      }
    }
    if (deletedIndex == insertedIndex) {
      if (debug == true)       System.out.println(""String_Node_Str"" + insertedIndex);
      updates.addUpdate(insertedIndex);
    }
 else {
      if (debug == true)       System.out.println(""String_Node_Str"" + deletedIndex + ""String_Node_Str""+ insertedIndex);
      updates.addDelete(deletedIndex);
      updates.addInsert(insertedIndex);
    }
  }
  while (!insertNodes.isEmpty()) {
    IndexedTreeNode insertNode=(IndexedTreeNode)insertNodes.removeFirst();
    int insertedIndex=insertByUnsortedNode(insertNode);
    updates.addInsert(insertedIndex);
  }
  updates.commitEvent();
  if (debug)   System.out.println(""String_Node_Str"");
}","/** 
 * For implementing the ListEventListener interface. When the underlying list changes, this notification allows the object to repaint itself or update itself as necessary. <p>This is implemented in two phases. First, the unsorted index tree is updated so that it maches the source list. This is necessary so that when sorted operations are performed, the comparisons are done with respect to the correct unsorted index. In the second phase, the sorted list is updated with the changes.
 */
public void listChanged(ListEvent listChanges){
  if (debug)   System.out.println(""String_Node_Str"");
  if (debug)   System.out.println(""String_Node_Str"" + listChanges);
  updates.beginEvent();
  LinkedList insertNodes=new LinkedList();
  LinkedList updateNodes=new LinkedList();
  LinkedList deleteIndices=new LinkedList();
  ListEvent firstPass=new ListEvent(listChanges);
  while (firstPass.next()) {
    int unsortedIndex=firstPass.getIndex();
    int changeType=firstPass.getType();
    if (changeType == ListEvent.INSERT) {
      IndexedTreeNode unsortedNode=unsorted.addByNode(unsortedIndex,this);
      insertNodes.addLast(unsortedNode);
    }
 else     if (changeType == ListEvent.DELETE) {
      IndexedTreeNode unsortedNode=unsorted.getNode(unsortedIndex);
      unsortedNode.removeFromTree();
      int deleteSortedIndex=deleteByUnsortedNode(unsortedNode);
      updates.addDelete(deleteSortedIndex);
    }
 else     if (changeType == ListEvent.UPDATE) {
    }
  }
  ListEvent secondPass=listChanges;
  while (secondPass.next()) {
    int unsortedIndex=secondPass.getIndex();
    int changeType=secondPass.getType();
    if (changeType == ListEvent.UPDATE) {
      IndexedTreeNode unsortedNode=unsorted.getNode(unsortedIndex);
      int deleteSortedIndex=deleteByUnsortedNode(unsortedNode);
      updateNodes.addLast(unsortedNode);
      deleteIndices.addLast(new Integer(deleteSortedIndex));
    }
  }
  if (debug)   System.out.println(deleteIndices);
  while (!updateNodes.isEmpty()) {
    IndexedTreeNode updateNode=(IndexedTreeNode)updateNodes.removeFirst();
    int deletedIndex=((Integer)deleteIndices.removeFirst()).intValue();
    int insertedIndex=insertByUnsortedNode(updateNode);
    if (debug)     System.out.println(""String_Node_Str"" + deletedIndex + ""String_Node_Str""+ insertedIndex+ ""String_Node_Str""+ deleteIndices);
    for (ListIterator i=deleteIndices.listIterator(deleteIndices.size()); i.hasPrevious(); ) {
      int currentDeletedIndex=((Integer)i.previous()).intValue();
      if (currentDeletedIndex < insertedIndex || (currentDeletedIndex == insertedIndex && insertedIndex < deletedIndex)) {
        insertedIndex++;
      }
 else {
        currentDeletedIndex++;
        i.set(new Integer(currentDeletedIndex));
      }
    }
    if (deletedIndex == insertedIndex) {
      if (debug == true)       System.out.println(""String_Node_Str"" + insertedIndex);
      updates.addUpdate(insertedIndex);
    }
 else {
      if (debug == true)       System.out.println(""String_Node_Str"" + deletedIndex + ""String_Node_Str""+ insertedIndex);
      updates.addDelete(deletedIndex);
      updates.addInsert(insertedIndex);
    }
  }
  while (!insertNodes.isEmpty()) {
    IndexedTreeNode insertNode=(IndexedTreeNode)insertNodes.removeFirst();
    int insertedIndex=insertByUnsortedNode(insertNode);
    updates.addInsert(insertedIndex);
  }
  updates.commitEvent();
  if (debug)   System.out.println(""String_Node_Str"");
}",0.9848551683575943
32840,"/** 
 * For implementing the ListEventListener interface.
 */
public void listChanged(ListEvent listChanges){
  int highestChangeIndex=0;
  while (listChanges.next()) {
    int changeIndex=listChanges.getIndex();
    int changeType=listChanges.getType();
    if (changeIndex < highestChangeIndex) {
      new Exception(name + ""String_Node_Str"" + changeCount+ ""String_Node_Str""+ changeIndex+ ""String_Node_Str""+ highestChangeIndex+ ""String_Node_Str""+ listChanges).printStackTrace();
    }
    highestChangeIndex=changeIndex;
    if (changeIndex < 0)     new Exception(name + ""String_Node_Str"" + changeCount+ ""String_Node_Str""+ changeIndex+ ""String_Node_Str""+ listChanges).printStackTrace();
    if (changeType == ListEvent.INSERT) {
      if (changeIndex > size)       new Exception(name + ""String_Node_Str"" + changeCount+ ""String_Node_Str""+ changeIndex+ ""String_Node_Str""+ size+ ""String_Node_Str""+ listChanges).printStackTrace();
      size++;
    }
 else     if (changeType == ListEvent.DELETE) {
      if (changeIndex >= size)       new Exception(name + ""String_Node_Str"" + changeCount+ ""String_Node_Str""+ changeIndex+ ""String_Node_Str""+ size+ ""String_Node_Str""+ listChanges).printStackTrace();
      size--;
    }
 else     if (changeType == ListEvent.UPDATE) {
      if (changeIndex >= size)       new Exception(name + ""String_Node_Str"" + changeCount+ ""String_Node_Str""+ changeIndex+ ""String_Node_Str""+ size+ ""String_Node_Str""+ listChanges).printStackTrace();
    }
  }
  if (size != source.size()) {
    new Exception(name + ""String_Node_Str"" + changeCount+ ""String_Node_Str""+ size+ ""String_Node_Str""+ source.size()+ ""String_Node_Str""+ listChanges).printStackTrace();
  }
  changeCount++;
}","/** 
 * For implementing the ListEventListener interface.
 */
public void listChanged(ListEvent listChanges){
  if (verbose) {
    System.out.println(name + ""String_Node_Str"" + listChanges);
  }
  int highestChangeIndex=0;
  while (listChanges.next()) {
    int changeIndex=listChanges.getIndex();
    int changeType=listChanges.getType();
    if (changeIndex < highestChangeIndex) {
      new Exception(name + ""String_Node_Str"" + changeCount+ ""String_Node_Str""+ changeIndex+ ""String_Node_Str""+ highestChangeIndex+ ""String_Node_Str""+ listChanges).printStackTrace();
    }
    highestChangeIndex=changeIndex;
    if (changeIndex < 0)     new Exception(name + ""String_Node_Str"" + changeCount+ ""String_Node_Str""+ changeIndex+ ""String_Node_Str""+ listChanges).printStackTrace();
    if (changeType == ListEvent.INSERT) {
      if (changeIndex > size)       new Exception(name + ""String_Node_Str"" + changeCount+ ""String_Node_Str""+ changeIndex+ ""String_Node_Str""+ size+ ""String_Node_Str""+ listChanges).printStackTrace();
      size++;
    }
 else     if (changeType == ListEvent.DELETE) {
      if (changeIndex >= size)       new Exception(name + ""String_Node_Str"" + changeCount+ ""String_Node_Str""+ changeIndex+ ""String_Node_Str""+ size+ ""String_Node_Str""+ listChanges).printStackTrace();
      size--;
    }
 else     if (changeType == ListEvent.UPDATE) {
      if (changeIndex >= size)       new Exception(name + ""String_Node_Str"" + changeCount+ ""String_Node_Str""+ changeIndex+ ""String_Node_Str""+ size+ ""String_Node_Str""+ listChanges).printStackTrace();
    }
  }
  if (size != source.size()) {
    new Exception(name + ""String_Node_Str"" + changeCount+ ""String_Node_Str""+ size+ ""String_Node_Str""+ source.size()+ ""String_Node_Str""+ listChanges).printStackTrace();
  }
  changeCount++;
}",0.9755254822919666
32841,"/** 
 * Creates a new ConsistencyTestList that ensures events from the source list are consistent.
 */
public ConsistencyTestList(EventList source,String name){
  this.source=source;
  this.name=name;
  size=source.size();
}","/** 
 * Creates a new ConsistencyTestList that ensures events from the source list are consistent.
 */
public ConsistencyTestList(EventList source,String name){
  this(source,name,false);
}",0.8861985472154964
32842,"/** 
 * Create a filter list that filters the specified source list, which must contain only Issue objects.
 */
public IssuesUserFilter(EventList source){
  super(source);
  source.addListEventListener(new ConsistencyTestList(source,""String_Node_Str""));
  SortedList sortedSource=new SortedList(source);
  sortedSource.addListEventListener(new ConsistencyTestList(sortedSource,""String_Node_Str""));
  usersEventList=new UniqueList(new IssuesToUserList(source));
  ((UniqueList)usersEventList).debug=true;
  usersEventList.addListEventListener(new ConsistencyTestList(usersEventList,""String_Node_Str""));
  EventListModel usersListModel=new EventListModel(usersEventList);
  userSelect=new JList(usersListModel);
  EventSelectionModel userSelectionModel=new EventSelectionModel(usersEventList);
  userSelect.setSelectionModel(userSelectionModel.getListSelectionModel());
  usersSelectedList=userSelectionModel.getEventList();
  userSelect.addListSelectionListener(this);
  handleFilterChanged();
}","/** 
 * Create a filter list that filters the specified source list, which must contain only Issue objects.
 */
public IssuesUserFilter(EventList source){
  super(source);
  source.addListEventListener(new ConsistencyTestList(source,""String_Node_Str""));
  SortedList sortedSource=new SortedList(source);
  sortedSource.addListEventListener(new ConsistencyTestList(sortedSource,""String_Node_Str"",true));
  usersEventList=new UniqueList(new IssuesToUserList(source));
  usersEventList.addListEventListener(new ConsistencyTestList(usersEventList,""String_Node_Str"",true));
  EventListModel usersListModel=new EventListModel(usersEventList);
  userSelect=new JList(usersListModel);
  EventSelectionModel userSelectionModel=new EventSelectionModel(usersEventList);
  userSelect.setSelectionModel(userSelectionModel.getListSelectionModel());
  usersSelectedList=userSelectionModel.getEventList();
  userSelect.addListSelectionListener(this);
  handleFilterChanged();
}",0.9728900255754476
32843,"/** 
 * When the list is changed the change may create new duplicates or remove duplicates.  The list is then altered to restore uniqeness and the events describing the alteration of the unique view are forwarded on.
 * @param listChanges The group of list changes to process
 */
public void listChanged(ListEvent listChanges){
  List nonUniqueInserts=new ArrayList();
  updates.beginEvent();
  while (listChanges.next()) {
    int changeIndex=listChanges.getIndex();
    int changeType=listChanges.getType();
    int changeResult=-1;
    if (changeType == ListEvent.INSERT) {
      changeResult=processInsertEvent(changeIndex);
    }
 else     if (changeType == ListEvent.DELETE) {
      processDeleteEvent(changeIndex);
    }
 else     if (changeType == ListEvent.UPDATE) {
      changeResult=processUpdateEvent(changeIndex);
    }
    if (changeResult != -1) {
      nonUniqueInserts.add(new Integer(changeResult));
    }
  }
  int uniqueInsertSize=nonUniqueInserts.size();
  for (int i=0; i < uniqueInsertSize; i++) {
    int insertIndex=((Integer)nonUniqueInserts.get(i)).intValue();
    guaranteeUniqueness(insertIndex);
  }
  updates.commitEvent();
}","/** 
 * When the list is changed the change may create new duplicates or remove duplicates.  The list is then altered to restore uniqeness and the events describing the alteration of the unique view are forwarded on.
 * @param listChanges The group of list changes to process
 */
public void listChanged(ListEvent listChanges){
  List nonUniqueInserts=new ArrayList();
  updates.beginEvent();
  while (listChanges.next()) {
    int changeIndex=listChanges.getIndex();
    int changeType=listChanges.getType();
    int changeResult=-1;
    if (changeType == ListEvent.INSERT) {
      changeResult=processInsertEvent(changeIndex);
    }
 else     if (changeType == ListEvent.DELETE) {
      processDeleteEvent(changeIndex);
    }
 else     if (changeType == ListEvent.UPDATE) {
      changeResult=processUpdateEvent(changeIndex);
    }
    if (changeResult != -1) {
      nonUniqueInserts.add(new Integer(changeResult));
      updateIndexOffset++;
    }
  }
  updateIndexOffset=0;
  int uniqueInsertSize=nonUniqueInserts.size();
  for (int i=0; i < uniqueInsertSize; i++) {
    int insertIndex=((Integer)nonUniqueInserts.get(i)).intValue();
    guaranteeUniqueness(insertIndex);
  }
  updates.commitEvent();
}",0.901015228426396
32844,"/** 
 * Appends a change to the ListEventAssembler. <p>This is to handle the case where more verbosity could add value to lists listening to changes on the unique list.
 * @param index The index of the change
 * @param type The type of this change
 * @param mandatory Whether or not to propagate this change to all listeners
 */
private void addChange(int type,int index,boolean mandatory){
  if (mandatory) {
    updates.addChange(type,index);
  }
 else {
  }
}","/** 
 * Appends a change to the ListEventAssembler. <p>This is to handle the case where more verbosity could add value to lists listening to changes on the unique list.
 * @param index The index of the change
 * @param type The type of this change
 * @param mandatory Whether or not to propagate this change to all listeners
 */
private void addChange(int type,int index,boolean mandatory){
  if (mandatory) {
    updates.addChange(type,index - updateIndexOffset);
  }
 else {
  }
}",0.9788135593220338
32845,"/** 
 * Gets this event as a String. This simply iterates through all blocks and concatenates them.
 */
public String toString(){
  StringBuffer result=new StringBuffer();
  result.append(""String_Node_Str"" + atomicCount + ""String_Node_Str"");
  for (int b=0; b < masterSequence.getBlockCount(atomicCount); b++) {
    if (b != 0)     result.append(""String_Node_Str"");
    result.append(masterSequence.getBlock(atomicCount,b));
  }
  return result.toString();
}","/** 
 * Gets this event as a String. This simply iterates through all blocks and concatenates them.
 */
public String toString(){
  StringBuffer result=new StringBuffer();
  result.append(""String_Node_Str"" + atomicCount + ""String_Node_Str"");
  int atomicChangeToShow=0;
  if (atomicCount < masterSequence.getAtomicCount())   atomicChangeToShow=masterSequence.getAtomicCount();
 else   atomicChangeToShow=masterSequence.getAtomicCount()=1;
  int blocksToShow=masterSequence.getBlockCount(atomicChangeToShow);
  for (int b=0; b < blocksToShow; b++) {
    if (b != 0)     result.append(""String_Node_Str"");
    result.append(masterSequence.getBlock(atomicChangeToShow,b));
  }
  return result.toString();
}",0.753448275862069
32846,"/** 
 * Replaces the object at the specified index in the source list with the specified value. <p>This has been modified for UniqueList in order to remove all of the elements at the source index with a single instance of the specified element. <p><strong>Warning:</strong> Because the set() method is implemented using <i>multiple</i> modifying calls to the source list, <i>multiple</i> events will be propogated. Therefore this method has been carefully implemented to keep this list in a consistent state for each such modifying operation.
 */
public Object set(int index,Object value){
  getReadWriteLock().writeLock().lock();
  try {
    if (!isWritable())     throw new IllegalStateException(""String_Node_Str"");
    if (index < 0 || index >= size())     throw new ArrayIndexOutOfBoundsException(""String_Node_Str"" + index + ""String_Node_Str""+ size());
    Object replaced=get(index);
    updates.beginEvent(true);
    remove(index);
    add(index,value);
    updates.commitEvent();
    return replaced;
  }
  finally {
    getReadWriteLock().writeLock().unlock();
  }
}","/** 
 * Replaces the object at the specified index in the source list with the specified value. <p>This removes all duplicates of the replaced value, then sets the replacement value on the source list. <p><strong>Warning:</strong> Because the set() method is implemented using <i>multiple</i> modifying calls to the source list, <i>multiple</i> events will be propogated. Therefore this method has been carefully implemented to keep this list in a consistent state for each such modifying operation.
 */
public Object set(int index,Object value){
  getReadWriteLock().writeLock().lock();
  try {
    if (!isWritable())     throw new IllegalStateException(""String_Node_Str"");
    if (index < 0 || index >= size())     throw new ArrayIndexOutOfBoundsException(""String_Node_Str"" + index + ""String_Node_Str""+ size());
    Object replaced=get(index);
    updates.beginEvent(true);
    int removeStart=-1;
    int removeEnd=-1;
    if (index < size() - 1) {
      removeStart=getSourceIndex(index) + 1;
      removeEnd=getSourceIndex(index + 1);
    }
 else {
      removeStart=getSourceIndex(index) + 1;
      removeEnd=source.size();
    }
    if (removeStart < removeEnd) {
      source.subList(removeStart,removeEnd).clear();
    }
    source.set(getSourceIndex(index),value);
    updates.commitEvent();
    return replaced;
  }
  finally {
    getReadWriteLock().writeLock().unlock();
  }
}",0.7381242387332522
32847,"/** 
 * Removes the specified list from the lists that compose this list.
 */
public void removeMemberList(EventList list){
  MemberList memberList=null;
  for (int i=0; i < memberLists.size(); i++) {
    MemberList current=(MemberList)memberLists.get(i);
    if (current.getSourceList() == list) {
      memberList=current;
      break;
    }
  }
  if (memberList == null)   throw new IllegalArgumentException(""String_Node_Str"" + list + ""String_Node_Str"");
  int offset=getListOffset(memberList);
  memberLists.remove(memberList);
  if (memberList.size() > 0) {
    updates.beginEvent();
    updates.addDelete(offset,offset + memberList.size() - 1);
    updates.commitEvent();
  }
}","/** 
 * Removes the specified list from the lists that compose this list.
 */
public void removeMemberList(EventList list){
  MemberList memberList=null;
  for (int i=0; i < memberLists.size(); i++) {
    MemberList current=(MemberList)memberLists.get(i);
    if (current.getSourceList() == list) {
      memberList=current;
      break;
    }
  }
  if (memberList == null)   throw new IllegalArgumentException(""String_Node_Str"" + list + ""String_Node_Str"");
  memberList.getSourceList().removeListEventListener(memberList);
  int offset=getListOffset(memberList);
  memberLists.remove(memberList);
  if (memberList.size() > 0) {
    updates.beginEvent();
    updates.addDelete(offset,offset + memberList.size() - 1);
    updates.commitEvent();
  }
}",0.9539106145251396
32848,"/** 
 * Gets the offset of the specified member list.
 */
private int getListOffset(MemberList memberList){
  int listOffset=0;
  for (int i=0; i < memberLists.size(); i++) {
    MemberList current=(MemberList)memberLists.get(i);
    if (current == memberList)     return listOffset;
 else     listOffset=listOffset + current.size();
  }
  throw new RuntimeException();
}","/** 
 * Gets the offset of the specified member list.
 */
private int getListOffset(MemberList memberList){
  int listOffset=0;
  for (int i=0; i < memberLists.size(); i++) {
    MemberList current=(MemberList)memberLists.get(i);
    if (current == memberList)     return listOffset;
 else     listOffset=listOffset + current.size();
  }
  throw new RuntimeException(""String_Node_Str"" + memberList);
}",0.961139896373057
32849,"/** 
 * Commits the current atomic change to this list change queue. This will notify all listeners about the change.
 */
public synchronized void commitEvent(){
  if (atomicChangeBlocks.size() > 0) {
    ListEventBlock.sortListEventBlocks(atomicChangeBlocks);
    atomicChanges.add(atomicChangeBlocks);
    try {
      for (int i=0; i < listeners.size(); i++) {
        ListEventListener listener=(ListEventListener)listeners.get(i);
        ListEvent event=(ListEvent)listenerEvents.get(i);
        listener.listChanged(event);
      }
    }
  finally {
      atomicChangeBlocks=null;
      atomicLatestBlock=null;
    }
  }
 else {
    atomicChangeBlocks=null;
    atomicLatestBlock=null;
  }
}","/** 
 * Commits the current atomic change to this list change queue. This will notify all listeners about the change.
 */
public synchronized void commitEvent(){
  if (atomicChangeBlocks.size() > 0) {
    ListEventBlock.sortListEventBlocks(atomicChangeBlocks);
    atomicChanges.add(atomicChangeBlocks);
    try {
      List listenersToNotify=new ArrayList();
      List listenerEventsToNotify=new ArrayList();
      listenersToNotify.addAll(listeners);
      listenerEventsToNotify.addAll(listenerEvents);
      for (int i=0; i < listenersToNotify.size(); i++) {
        ListEventListener listener=(ListEventListener)listenersToNotify.get(i);
        ListEvent event=(ListEvent)listenerEventsToNotify.get(i);
        listener.listChanged(event);
      }
    }
  finally {
      atomicChangeBlocks=null;
      atomicLatestBlock=null;
    }
  }
 else {
    atomicChangeBlocks=null;
    atomicLatestBlock=null;
  }
}",0.8653010552451893
32850,"/** 
 * Removes from this collection all of its elements that are contained in the specified collection (optional operation). This method has been is available in this implementation, although the not particularly high performance.
 */
public boolean removeAll(Collection collection){
  getReadWriteLock().writeLock().lock();
  try {
    boolean changed=false;
    updates.beginEvent();
    for (Iterator i=collection.iterator(); i.hasNext(); ) {
      int index=-1;
      while ((index=data.indexOf(i.next())) != -1) {
        updates.addDelete(index);
        data.remove(index);
        changed=true;
      }
    }
    updates.commitEvent();
    return changed;
  }
  finally {
    getReadWriteLock().writeLock().unlock();
  }
}","/** 
 * Removes from this collection all of its elements that are contained in the specified collection (optional operation). This method has been is available in this implementation, although the not particularly high performance.
 */
public boolean removeAll(Collection collection){
  getReadWriteLock().writeLock().lock();
  try {
    boolean changed=false;
    updates.beginEvent();
    for (Iterator i=collection.iterator(); i.hasNext(); ) {
      int index=-1;
      if ((index=data.indexOf(i.next())) != -1) {
        updates.addDelete(index);
        data.remove(index);
        changed=true;
      }
    }
    updates.commitEvent();
    return changed;
  }
  finally {
    getReadWriteLock().writeLock().unlock();
  }
}",0.9952021932830706
32851,"/** 
 * Removes the specified element from the source list. <p>Like all modifying methods, this method manages its own thread safety via the <code>getReadWriteLock().writeLock()</code>. To perform several changes atomically, obtain the write lock before the first change and release it after the last change.
 * @throws IllegalStateException if this mutation cannot be modified in itscurrent state.
 */
public boolean remove(Object toRemove){
  getReadWriteLock().writeLock().lock();
  try {
    if (!isWritable())     throw new IllegalStateException(""String_Node_Str"");
    return source.remove(toRemove);
  }
  finally {
    getReadWriteLock().writeLock().unlock();
  }
}","/** 
 * Removes the specified element from the source list. <p>Like all modifying methods, this method manages its own thread safety via the <code>getReadWriteLock().writeLock()</code>. To perform several changes atomically, obtain the write lock before the first change and release it after the last change.
 * @throws IllegalStateException if this mutation cannot be modified in itscurrent state.
 */
public boolean remove(Object toRemove){
  getReadWriteLock().writeLock().lock();
  try {
    if (!isWritable())     throw new IllegalStateException(""String_Node_Str"");
    int index=indexOf(toRemove);
    if (index == -1)     return false;
    source.remove(getSourceIndex(index));
    return true;
  }
  finally {
    getReadWriteLock().writeLock().unlock();
  }
}",0.8188757807078417
32852,"/** 
 * Removes the specified elements from the source list. <p>Like all modifying methods, this method manages its own thread safety via the <code>getReadWriteLock().writeLock()</code>. To perform several changes atomically, obtain the write lock before the first change and release it after the last change.
 * @throws IllegalStateException if this mutation cannot be modified in itscurrent state.
 */
public boolean removeAll(Collection values){
  getReadWriteLock().writeLock().lock();
  try {
    if (!isWritable())     throw new IllegalStateException(""String_Node_Str"");
    return source.removeAll(values);
  }
  finally {
    getReadWriteLock().writeLock().unlock();
  }
}","/** 
 * Removes the specified elements from the source list. <p>Like all modifying methods, this method manages its own thread safety via the <code>getReadWriteLock().writeLock()</code>. To perform several changes atomically, obtain the write lock before the first change and release it after the last change.
 * @throws IllegalStateException if this mutation cannot be modified in itscurrent state.
 */
public boolean removeAll(Collection values){
  getReadWriteLock().writeLock().lock();
  try {
    if (!isWritable())     throw new IllegalStateException(""String_Node_Str"");
    boolean overallChanged=false;
    for (Iterator i=values.iterator(); i.hasNext(); ) {
      boolean removeChanged=remove(i.next());
      if (removeChanged)       overallChanged=true;
    }
    return overallChanged;
  }
  finally {
    getReadWriteLock().writeLock().unlock();
  }
}",0.844559585492228
32853,"/** 
 * Removes <strong>all</strong> elements from the source list, even those that are not displayed from this view. In order to remove only the elements displayed by this view, iterate through this list to remove its elements one at a time. <p>Like all modifying methods, this method manages its own thread safety via the <code>getReadWriteLock().writeLock()</code>. To perform several changes atomically, obtain the write lock before the first change and release it after the last change.
 * @throws IllegalStateException if this mutation cannot be modified in itscurrent state.
 */
public void clear(){
  getReadWriteLock().writeLock().lock();
  try {
    if (!isWritable())     throw new IllegalStateException(""String_Node_Str"");
    source.clear();
  }
  finally {
    getReadWriteLock().writeLock().unlock();
  }
}","/** 
 * Removes <strong>all</strong> elements from the source list, even those that are not displayed from this view. In order to remove only the elements displayed by this view, iterate through this list to remove its elements one at a time. <p>Like all modifying methods, this method manages its own thread safety via the <code>getReadWriteLock().writeLock()</code>. To perform several changes atomically, obtain the write lock before the first change and release it after the last change.
 * @throws IllegalStateException if this mutation cannot be modified in itscurrent state.
 */
public void clear(){
  getReadWriteLock().writeLock().lock();
  try {
    if (!isWritable())     throw new IllegalStateException(""String_Node_Str"");
    for (ListIterator i=listIterator(); i.hasNext(); ) {
      i.next();
      i.remove();
    }
  }
  finally {
    getReadWriteLock().writeLock().unlock();
  }
}",0.8714368819080861
32854,"/** 
 * Retains only the values from the source list that are in the specified collection. <p>Like all modifying methods, this method manages its own thread safety via the <code>getReadWriteLock().writeLock()</code>. To perform several changes atomically, obtain the write lock before the first change and release it after the last change.
 * @throws IllegalStateException if this mutation cannot be modified in itscurrent state.
 */
public boolean retainAll(Collection values){
  getReadWriteLock().writeLock().lock();
  try {
    if (!isWritable())     throw new IllegalStateException(""String_Node_Str"");
    return source.retainAll(values);
  }
  finally {
    getReadWriteLock().writeLock().unlock();
  }
}","/** 
 * Retains only the values from the source list that are in the specified collection. <p>Like all modifying methods, this method manages its own thread safety via the <code>getReadWriteLock().writeLock()</code>. To perform several changes atomically, obtain the write lock before the first change and release it after the last change.
 * @throws IllegalStateException if this mutation cannot be modified in itscurrent state.
 */
public boolean retainAll(Collection values){
  getReadWriteLock().writeLock().lock();
  try {
    if (!isWritable())     throw new IllegalStateException(""String_Node_Str"");
    boolean changed=false;
    for (ListIterator i=listIterator(); i.hasNext(); ) {
      if (!values.contains(i.next())) {
        i.remove();
        changed=true;
      }
    }
    return changed;
  }
  finally {
    getReadWriteLock().writeLock().unlock();
  }
}",0.866708780795957
32855,"/** 
 * Gets the index into the source list for the object with the specified index in this list.
 */
protected int getSourceIndex(int mutationIndex){
  return mutationIndex - startIndex;
}","/** 
 * Gets the index into the source list for the object with the specified index in this list.
 */
protected int getSourceIndex(int mutationIndex){
  return mutationIndex + startIndex;
}",0.9947089947089948
32856,"/** 
 * For implementing the ListChangeListener interface. When the underlying list changes, this notification allows the object to repaint itself or update itself as necessary. <p>This is implemented in two phases. The first phase updates the unsorted indexes of all nodes. The second phase updates the sorted indexes, removing and deleting nodes as necessary. Two phases are necessary because the sorted nodes cannot be inserted until all of the final offsets are known. This means that all offsets must be updated before the first sorted value is updated.
 */
public void notifyListChanges(ListChangeEvent listChanges){
synchronized (getRootList()) {
    updates.beginAtomicChange();
    ArrayList unsortedNodes=new ArrayList();
    ListChangeEvent clonedChanges=new ListChangeEvent(listChanges);
    while (clonedChanges.next()) {
      int unsortedIndex=clonedChanges.getIndex();
      int changeType=clonedChanges.getType();
      if (changeType == ListChangeBlock.INSERT) {
        IndexedTreeNode unsortedNode=unsorted.addByNode(unsortedIndex,this);
        unsortedNodes.add(unsortedNode);
      }
 else       if (changeType == ListChangeBlock.DELETE) {
        IndexedTreeNode unsortedNode=unsorted.getNode(unsortedIndex);
        unsortedNode.removeFromTree();
        unsortedNodes.add(unsortedNode);
      }
 else       if (changeType == ListChangeBlock.UPDATE) {
        IndexedTreeNode unsortedNode=unsorted.getNode(unsortedIndex);
        unsortedNodes.add(unsortedNode);
      }
    }
    Iterator unsortedNodesIterator=unsortedNodes.iterator();
    while (listChanges.next()) {
      int unsortedIndex=listChanges.getIndex();
      int changeType=listChanges.getType();
      IndexedTreeNode unsortedNode=(IndexedTreeNode)unsortedNodesIterator.next();
      if (changeType == ListChangeBlock.INSERT) {
        int sortedIndex=insertByUnsortedNode(unsortedNode);
        updates.appendChange(sortedIndex,ListChangeBlock.INSERT);
      }
 else       if (changeType == ListChangeBlock.DELETE) {
        int sortedIndex=deleteByUnsortedNode(unsortedNode);
        updates.appendChange(sortedIndex,ListChangeBlock.DELETE);
      }
 else       if (changeType == ListChangeBlock.UPDATE) {
        int deleteSortedIndex=deleteByUnsortedNode(unsortedNode);
        int insertSortedIndex=insertByUnsortedNode(unsortedNode);
        if (deleteSortedIndex == insertSortedIndex) {
          updates.appendChange(insertSortedIndex,ListChangeBlock.UPDATE);
        }
 else {
          updates.appendChange(deleteSortedIndex,ListChangeBlock.DELETE);
          updates.appendChange(insertSortedIndex,ListChangeBlock.INSERT);
        }
      }
    }
    updates.commitAtomicChange();
  }
}","/** 
 * For implementing the ListChangeListener interface. When the underlying list changes, this notification allows the object to repaint itself or update itself as necessary. <p>This is implemented in two phases. First, the unsorted index tree is updated so that it maches the source list. This is necessary so that when sorted operations are performed, the comparisons are done with respect to the correct unsorted index. In the second phase, the sorted list is updated with the changes.
 */
public void notifyListChanges(ListChangeEvent listChanges){
synchronized (getRootList()) {
    updates.beginAtomicChange();
    ArrayList unsortedNodes=new ArrayList();
    ArrayList deletedIndices=new ArrayList();
    ListChangeEvent clonedChanges=new ListChangeEvent(listChanges);
    int sortedOffset=0;
    while (clonedChanges.next()) {
      int unsortedIndex=clonedChanges.getIndex();
      int changeType=clonedChanges.getType();
      if (changeType == ListChangeBlock.INSERT) {
        IndexedTreeNode unsortedNode=unsorted.addByNode(unsortedIndex,this);
        unsortedNodes.add(unsortedNode);
        sortedOffset++;
      }
 else       if (changeType == ListChangeBlock.DELETE) {
        IndexedTreeNode unsortedNode=unsorted.getNode(unsortedIndex);
        unsortedNode.removeFromTree();
        int deleteSortedIndex=deleteByUnsortedNode(unsortedNode);
        updates.appendChange(deleteSortedIndex,ListChangeBlock.DELETE);
      }
 else       if (changeType == ListChangeBlock.UPDATE) {
        IndexedTreeNode unsortedNode=unsorted.getNode(unsortedIndex);
        int deleteSortedIndex=deleteByUnsortedNode(unsortedNode) + sortedOffset;
        unsortedNodes.add(unsortedNode);
        deletedIndices.add(new Integer(deleteSortedIndex));
        sortedOffset++;
      }
    }
    if (unsorted.size() != source.size())     throw new IllegalStateException();
    if (sorted.size() + sortedOffset != source.size())     throw new IllegalStateException();
    Iterator unsortedNodesIterator=unsortedNodes.iterator();
    Iterator deletedIndicesIterator=deletedIndices.iterator();
    while (listChanges.next()) {
      int unsortedIndex=listChanges.getIndex();
      int changeType=listChanges.getType();
      if (changeType == ListChangeBlock.INSERT) {
        IndexedTreeNode unsortedNode=(IndexedTreeNode)unsortedNodesIterator.next();
        int sortedIndex=insertByUnsortedNode(unsortedNode);
        updates.appendChange(sortedIndex,ListChangeBlock.INSERT);
      }
 else       if (changeType == ListChangeBlock.DELETE) {
      }
 else       if (changeType == ListChangeBlock.UPDATE) {
        int deleteSortedIndex=((Integer)deletedIndicesIterator.next()).intValue();
        IndexedTreeNode unsortedNode=(IndexedTreeNode)unsortedNodesIterator.next();
        int insertSortedIndex=insertByUnsortedNode(unsortedNode);
        if (deleteSortedIndex == insertSortedIndex) {
          updates.appendChange(insertSortedIndex,ListChangeBlock.UPDATE);
        }
 else {
          updates.appendChange(deleteSortedIndex,ListChangeBlock.DELETE);
          updates.appendChange(insertSortedIndex,ListChangeBlock.INSERT);
        }
      }
    }
    if (deletedIndicesIterator.hasNext())     throw new IllegalStateException();
    if (unsortedNodesIterator.hasNext())     throw new IllegalStateException();
    updates.commitAtomicChange();
  }
}",0.5725632963759723
32857,"/** 
 * Tests that sorting works on a large set of filter changes.
 */
public void testAgressiveFiltering(){
  BasicEventList source=new BasicEventList();
  IntArrayFilterList filterList=new IntArrayFilterList(source);
  SortedList sorted=new SortedList(filterList,new IntArrayComparator(0));
  for (int i=0; i < 20; i++) {
    int value=random.nextInt(10);
    int[] array=new int[]{value,random.nextInt(2),random.nextInt(2),random.nextInt(2)};
    source.add(array);
  }
  for (int i=0; i < 100; i++) {
    int filterColumn=random.nextInt(3);
    filterList.setFilter(filterColumn + 1,1);
    ArrayList controlList=new ArrayList();
    controlList.addAll(filterList);
    Collections.sort(controlList,new IntArrayComparator(0));
    System.out.println(""String_Node_Str"" + sorted.size() + ""String_Node_Str""+ controlList.size());
    System.out.print(""String_Node_Str"");
    for (int j=0; j < controlList.size(); j++) {
      System.out.print(((int[])controlList.get(j))[0] + ""String_Node_Str"");
    }
    System.out.println(""String_Node_Str"");
    System.out.print(""String_Node_Str"");
    for (int j=0; j < filterList.size(); j++) {
      System.out.print(((int[])filterList.get(j))[0] + ""String_Node_Str"");
    }
    System.out.println(""String_Node_Str"");
    System.out.print(""String_Node_Str"");
    for (int j=0; j < sorted.size(); j++) {
      System.out.print(((int[])sorted.get(j))[0] + ""String_Node_Str"");
    }
    System.out.println(""String_Node_Str"");
    assertEquals(sorted.size(),controlList.size());
    for (int j=0; j < sorted.size(); j++) {
      assertEquals(((int[])sorted.get(j))[0],((int[])controlList.get(j))[0]);
    }
  }
}","/** 
 * Tests that sorting works on a large set of filter changes.
 */
public void testAgressiveFiltering(){
  BasicEventList source=new BasicEventList();
  IntArrayFilterList filterList=new IntArrayFilterList(source);
  SortedList sorted=new SortedList(filterList,new IntArrayComparator(0));
  for (int i=0; i < 1000; i++) {
    int value=random.nextInt(1000);
    int[] array=new int[]{value,random.nextInt(2),random.nextInt(2),random.nextInt(2)};
    source.add(array);
  }
  for (int i=0; i < 10; i++) {
    int filterColumn=random.nextInt(3);
    filterList.setFilter(filterColumn + 1,1);
    ArrayList controlList=new ArrayList();
    controlList.addAll(filterList);
    Collections.sort(controlList,new IntArrayComparator(0));
    assertEquals(sorted.size(),controlList.size());
    for (int j=0; j < sorted.size(); j++) {
      assertEquals(((int[])sorted.get(j))[0],((int[])controlList.get(j))[0]);
    }
  }
}",0.6973120373977405
32858,"/** 
 * Tests a large set of random events.
 */
public void testLargeRandomSet(){
  source=new BasicEventList();
  IntArrayFilterList filterList=new IntArrayFilterList(source);
  unique=new UniqueList(filterList,new IntArrayComparator(0));
  SortedList sorted=new SortedList(filterList,new IntArrayComparator(0));
  for (int i=0; i < 20; i++) {
    int value=random.nextInt(10);
    int[] array=new int[]{value,random.nextInt(2),random.nextInt(2),random.nextInt(2)};
    source.add(array);
  }
  for (int i=0; i < 100; i++) {
    int filterColumn=random.nextInt(3);
    filterList.setFilter(filterColumn + 1,1);
    SortedSet controlSet=new TreeSet(new IntArrayComparator(0));
    controlSet.addAll(filterList);
    ArrayList controlList=new ArrayList();
    controlList.addAll(controlSet);
    Collections.sort(controlList,new IntArrayComparator(0));
    System.out.println(""String_Node_Str"" + unique.size() + ""String_Node_Str""+ controlList.size());
    if (unique.size() != controlList.size())     System.out.print(""String_Node_Str"");
    for (int j=0; unique.size() != controlList.size() && j < unique.size(); j++) {
      System.out.print(((int[])unique.get(j))[0] + ""String_Node_Str"");
    }
    if (unique.size() != controlList.size())     System.out.println(""String_Node_Str"");
    if (unique.size() != controlList.size())     System.out.print(""String_Node_Str"");
    for (int j=0; unique.size() != controlList.size() && j < controlList.size(); j++) {
      System.out.print(((int[])controlList.get(j))[0] + ""String_Node_Str"");
    }
    if (unique.size() != controlList.size())     System.out.println(""String_Node_Str"");
    if (unique.size() != controlList.size())     System.out.print(""String_Node_Str"");
    for (int j=0; unique.size() != controlList.size() && j < filterList.size(); j++) {
      System.out.print(((int[])filterList.get(j))[0] + ""String_Node_Str"");
    }
    if (unique.size() != controlList.size())     System.out.println(""String_Node_Str"");
    if (unique.size() != controlList.size())     System.out.print(""String_Node_Str"");
    for (int j=0; unique.size() != controlList.size() && j < sorted.size(); j++) {
      System.out.print(((int[])sorted.get(j))[0] + ""String_Node_Str"");
    }
    if (unique.size() != controlList.size())     System.out.println(""String_Node_Str"");
    assertEquals(unique.size(),controlList.size());
    for (int j=0; j < unique.size(); j++) {
      assertEquals(((int[])unique.get(j))[0],((int[])controlList.get(j))[0]);
    }
  }
}","/** 
 * Tests a large set of random events.
 */
public void testLargeRandomSet(){
  source=new BasicEventList();
  IntArrayFilterList filterList=new IntArrayFilterList(source);
  unique=new UniqueList(filterList,new IntArrayComparator(0));
  SortedList sorted=new SortedList(filterList,new IntArrayComparator(0));
  for (int i=0; i < 1000; i++) {
    int value=random.nextInt(1000);
    int[] array=new int[]{value,random.nextInt(2),random.nextInt(2),random.nextInt(2)};
    source.add(array);
  }
  for (int i=0; i < 10; i++) {
    int filterColumn=random.nextInt(3);
    filterList.setFilter(filterColumn + 1,1);
    SortedSet controlSet=new TreeSet(new IntArrayComparator(0));
    controlSet.addAll(filterList);
    ArrayList controlList=new ArrayList();
    controlList.addAll(controlSet);
    Collections.sort(controlList,new IntArrayComparator(0));
    assertEquals(unique.size(),controlList.size());
    for (int j=0; j < unique.size(); j++) {
      assertEquals(((int[])unique.get(j))[0],((int[])controlList.get(j))[0]);
    }
  }
}",0.5694050991501416
32859,"/** 
 * Commits the current atomic change to this list change queue. This will notify all listeners about the change.
 */
public synchronized void commitAtomicChange(){
  if (atomicChangeBlocks.size() > 0) {
    sortChangeBlocks(atomicChangeBlocks);
    atomicChanges.add(atomicChangeBlocks);
    changeCount=changeCount + atomicChangeCount;
    blockCount=blockCount + atomicChangeBlocks.size();
    for (int i=0; i < listeners.size(); i++) {
      ListChangeListener listener=(ListChangeListener)listeners.get(i);
      ListChangeEvent event=(ListChangeEvent)listenerEvents.get(i);
      listener.notifyListChanges(event);
    }
  }
  atomicChangeBlocks=null;
  atomicChangeCount=0;
  atomicLatestBlock=null;
}","/** 
 * Commits the current atomic change to this list change queue. This will notify all listeners about the change.
 */
public synchronized void commitAtomicChange(){
  if (atomicChangeBlocks.size() > 0) {
    ListChangeBlock.sortListChangeBlocks(atomicChangeBlocks);
    atomicChanges.add(atomicChangeBlocks);
    changeCount=changeCount + atomicChangeCount;
    blockCount=blockCount + atomicChangeBlocks.size();
    for (int i=0; i < listeners.size(); i++) {
      ListChangeListener listener=(ListChangeListener)listeners.get(i);
      ListChangeEvent event=(ListChangeEvent)listenerEvents.get(i);
      listener.notifyListChanges(event);
    }
  }
  atomicChangeBlocks=null;
  atomicChangeCount=0;
  atomicLatestBlock=null;
}",0.981994459833795
32860,"public void display(){
  ListTable listTable=new ListTable(customFilteredLanguages,new ProgrammingLanguageTableCell());
  TableComparatorSelector sortSelect=new TableComparatorSelector(listTable,sortedLanguages);
  sortSelect.addComparator(0,""String_Node_Str"",sortByName);
  sortSelect.addComparator(0,""String_Node_Str"",sortByYear);
  JFrame frame=new JFrame(""String_Node_Str"");
  ExitOnCloseHandler.addToFrame(frame);
  frame.getContentPane().setLayout(new GridBagLayout());
  frame.getContentPane().add(new JLabel(""String_Node_Str""),new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(2,2,2,2),0,0));
  frame.getContentPane().add(filteredLanguages.getFilterEdit(),new GridBagConstraints(1,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(2,2,2,2),0,0));
  frame.getContentPane().add(customFilteredLanguages.getObjectOrientedCheckBox(),new GridBagConstraints(0,1,2,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(2,2,2,2),0,0));
  frame.getContentPane().add(customFilteredLanguages.getVirtualMachineCheckBox(),new GridBagConstraints(0,2,2,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(2,2,2,2),0,0));
  frame.getContentPane().add(listTable.getTableScrollPane(),new GridBagConstraints(0,3,2,1,1.0,1.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(2,2,2,2),0,0));
  frame.setSize(640,480);
  frame.show();
}","public void display(){
  JTabbedPane listWidgetTabs=new JTabbedPane(JTabbedPane.BOTTOM);
  ListTable listTable=new ListTable(customFilteredLanguages,new ProgrammingLanguageTableCell());
  TableComparatorSelector sortSelect=new TableComparatorSelector(listTable,sortedLanguages);
  sortSelect.addComparator(0,""String_Node_Str"",sortByName);
  sortSelect.addComparator(0,""String_Node_Str"",sortByYear);
  listWidgetTabs.addTab(""String_Node_Str"",listTable.getTableScrollPane());
  EventJList eventJList=new EventJList(customFilteredLanguages);
  listWidgetTabs.addTab(""String_Node_Str"",new JScrollPane(eventJList.getJList()));
  JFrame frame=new JFrame(""String_Node_Str"");
  ExitOnCloseHandler.addToFrame(frame);
  frame.getContentPane().setLayout(new GridBagLayout());
  frame.getContentPane().add(new JLabel(""String_Node_Str""),new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(2,2,2,2),0,0));
  frame.getContentPane().add(filteredLanguages.getFilterEdit(),new GridBagConstraints(1,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(2,2,2,2),0,0));
  frame.getContentPane().add(customFilteredLanguages.getObjectOrientedCheckBox(),new GridBagConstraints(0,1,2,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(2,2,2,2),0,0));
  frame.getContentPane().add(customFilteredLanguages.getVirtualMachineCheckBox(),new GridBagConstraints(0,2,2,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(2,2,2,2),0,0));
  frame.getContentPane().add(listWidgetTabs,new GridBagConstraints(0,3,2,1,1.0,1.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(2,2,2,2),0,0));
  frame.setSize(640,480);
  frame.show();
}",0.8982785602503912
32861,"/** 
 * Adds the specified list to the lists that compose this list.
 * @param index the index within the list of lists.
 */
public void addMemberList(EventList list){
synchronized (getRootList()) {
    MemberList memberList=new MemberList(list);
    memberLists.add(memberList);
    int offset=getListOffset(memberList);
    updates.beginAtomicChange();
    updates.appendChange(offset,offset + memberList.size() - 1,ListChangeBlock.INSERT);
    updates.commitAtomicChange();
  }
}","/** 
 * Adds the specified list to the lists that compose this list.
 */
public void addMemberList(EventList list){
synchronized (getRootList()) {
    MemberList memberList=new MemberList(list);
    memberLists.add(memberList);
    int offset=getListOffset(memberList);
    updates.beginAtomicChange();
    updates.appendChange(offset,offset + memberList.size() - 1,ListChangeBlock.INSERT);
    updates.commitAtomicChange();
  }
}",0.9429824561403508
32862,"/** 
 * Removes the specified list from the lists that compose this list.
 */
public void removeMemberList(EventList list){
synchronized (getRootList()) {
    MemberList memberList=null;
    for (int i=0; i < memberLists.size(); i++) {
      MemberList current=(MemberList)memberLists.get(i);
      if (current.getSourceList() == list) {
        memberList=current;
        break;
      }
    }
    if (memberList == null)     throw new IllegalArgumentException(""String_Node_Str"" + list + ""String_Node_Str"");
    int offset=getListOffset(memberList);
    memberLists.remove(memberList);
    updates.beginAtomicChange();
    updates.appendChange(offset,offset + memberList.size() - 1,ListChangeBlock.DELETE);
    updates.commitAtomicChange();
  }
}","/** 
 * Removes the specified list from the lists that compose this list.
 */
public void removeMemberList(EventList list){
synchronized (getRootList()) {
    MemberList memberList=null;
    for (int i=0; i < memberLists.size(); i++) {
      MemberList current=(MemberList)memberLists.get(i);
      if (current.getSourceList() == list) {
        memberList=current;
        break;
      }
    }
    if (memberList == null)     throw new IllegalArgumentException(""String_Node_Str"" + list + ""String_Node_Str"");
    int offset=getListOffset(memberList);
    memberLists.remove(memberList);
    if (memberList.size() > 0) {
      updates.beginAtomicChange();
      updates.appendChange(offset,offset + memberList.size() - 1,ListChangeBlock.DELETE);
      updates.commitAtomicChange();
    }
  }
}",0.9707602339181286
32863,"/** 
 * Adds the specified list to the lists that compose this list.
 */
public void addMemberList(EventList list){
synchronized (getRootList()) {
    MemberList memberList=new MemberList(list);
    memberLists.add(memberList);
    int offset=getListOffset(memberList);
    updates.beginAtomicChange();
    updates.appendChange(offset,offset + memberList.size() - 1,ListChangeBlock.INSERT);
    updates.commitAtomicChange();
  }
}","/** 
 * Adds the specified list to the lists that compose this list.
 */
public void addMemberList(EventList list){
synchronized (getRootList()) {
    MemberList memberList=new MemberList(list);
    memberLists.add(memberList);
    int offset=getListOffset(memberList);
    if (memberList.size() > 0) {
      updates.beginAtomicChange();
      updates.appendChange(offset,offset + memberList.size() - 1,ListChangeBlock.INSERT);
      updates.commitAtomicChange();
    }
  }
}",0.9502762430939228
32864,"/** 
 * Returns the element at the specified position in this list. Most mutation lists will override the get method to use a mapping.
 */
public Object get(int index){
synchronized (getRootList()) {
    for (int i=0; i < memberLists.size(); i++) {
      MemberList current=(MemberList)memberLists.get(i);
      if (index < current.size())       return current.getSourceList().get(index);
 else       index=index - current.size();
    }
  }
  return null;
}","/** 
 * Returns the element at the specified position in this list. Most mutation lists will override the get method to use a mapping.
 */
public Object get(int index){
synchronized (getRootList()) {
    for (int i=0; i < memberLists.size(); i++) {
      MemberList current=(MemberList)memberLists.get(i);
      if (index < current.size()) {
        return current.getSourceList().get(index);
      }
 else {
        index=index - current.size();
      }
    }
  }
  return null;
}",0.9381663113006397
32865,"/** 
 * Sets the FreezableList to be synchronized with the source list. This will allow the FreezableList to resume receiving updates from its source. When thawed the FreezableList will notify listening lists that the data has changed.
 */
public void thaw(){
synchronized (getRootList()) {
    if (!frozen)     throw new IllegalStateException(""String_Node_Str"");
    frozen=false;
    int frozenDataSize=frozenData.size();
    frozenData.clear();
    updates.beginAtomicChange();
    if (frozenData.size() > 0)     updates.appendChange(0,frozenDataSize - 1,ListChangeBlock.DELETE);
    if (source.size() > 0)     updates.appendChange(0,source.size() - 1,ListChangeBlock.INSERT);
    updates.commitAtomicChange();
    source.addListChangeListener(this);
  }
}","/** 
 * Sets the FreezableList to be synchronized with the source list. This will allow the FreezableList to resume receiving updates from its source. When thawed the FreezableList will notify listening lists that the data has changed.
 */
public void thaw(){
synchronized (getRootList()) {
    if (!frozen)     throw new IllegalStateException(""String_Node_Str"");
    frozen=false;
    int frozenDataSize=frozenData.size();
    frozenData.clear();
    updates.beginAtomicChange();
    if (frozenDataSize > 0)     updates.appendChange(0,frozenDataSize - 1,ListChangeBlock.DELETE);
    if (source.size() > 0)     updates.appendChange(0,source.size() - 1,ListChangeBlock.INSERT);
    updates.commitAtomicChange();
    source.addListChangeListener(this);
  }
}",0.9927392739273928
32866,"/** 
 * For implementing the ListChangeListener interface. This sends changes to the table which can repaint the table cells. Because this class uses a ListChangeListenerEventThreadProxy, it is guaranteed that all natural calls to this method use the Swing thread. This tests the size of the change to determine how to handle it. If the size of the change is greater than the changeSizeRepaintAllThreshhold, then the entire table is notified as changed. Otherwise only the descrete areas that changed are notified.
 */
public void notifyListChanges(ListChangeEvent listChanges){
  ignoreSelectionEvents=true;
  if (!listChanges.hasNext()) {
    return;
  }
 else   if (listChanges.getBlocksRemaining() >= changeSizeRepaintAllThreshhold) {
    listChanges.clearEventQueue();
    tableScrollPane.getViewport().setViewPosition(table.getCellRect(0,0,true).getLocation());
    fireTableDataChanged();
  }
 else {
    while (listChanges.nextBlock()) {
      int startIndex=listChanges.getBlockStartIndex();
      int endIndex=listChanges.getBlockEndIndex();
      int changeType=listChanges.getType();
      tableModelEvent.setValues(startIndex,endIndex,changeType);
      fireTableChanged(tableModelEvent);
    }
  }
  ignoreSelectionEvents=false;
  selectedIndex=-1;
  valueChanged(null);
}","/** 
 * For implementing the ListChangeListener interface. This sends changes to the table which can repaint the table cells. Because this class uses a ListChangeListenerEventThreadProxy, it is guaranteed that all natural calls to this method use the Swing thread. This tests the size of the change to determine how to handle it. If the size of the change is greater than the changeSizeRepaintAllThreshhold, then the entire table is notified as changed. Otherwise only the descrete areas that changed are notified.
 */
public void notifyListChanges(ListChangeEvent listChanges){
  if (!listChanges.hasNext())   return;
  ignoreSelectionEvents=true;
  if (listChanges.getBlocksRemaining() >= changeSizeRepaintAllThreshhold) {
    listChanges.clearEventQueue();
    tableScrollPane.getViewport().setViewPosition(table.getCellRect(0,0,true).getLocation());
    fireTableDataChanged();
  }
 else {
    while (listChanges.nextBlock()) {
      int startIndex=listChanges.getBlockStartIndex();
      int endIndex=listChanges.getBlockEndIndex();
      int changeType=listChanges.getType();
      tableModelEvent.setValues(startIndex,endIndex,changeType);
      fireTableChanged(tableModelEvent);
    }
  }
  ignoreSelectionEvents=false;
  selectedIndex=-1;
  valueChanged(null);
}",0.9632525410476936
32867,"/** 
 * JDBC-testing method, remove this sometime soon please!
 */
public ProgrammingLanguageBrowser(EventList listImplementation){
  languages=listImplementation;
  languages.add(new ProgrammingLanguage(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true,true));
  languages.add(new ProgrammingLanguage(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false,false));
  languages.add(new ProgrammingLanguage(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true,false));
  languages.add(new ProgrammingLanguage(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false,false));
  languages.add(new ProgrammingLanguage(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false,false));
  languages.add(new ProgrammingLanguage(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true,false));
  languages.add(new ProgrammingLanguage(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false,false));
  languages.add(new ProgrammingLanguage(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false,false));
  languages.add(new ProgrammingLanguage(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false,true));
  languages.add(new ProgrammingLanguage(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true,false));
  languages.add(new ProgrammingLanguage(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true,false));
  languages.add(new ProgrammingLanguage(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true,false));
  languages.add(new ProgrammingLanguage(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false,false));
  CachingList cachingList=new CachingList(languages,5);
  sortedLanguages=new SortedList(cachingList,sortByName);
  filteredLanguages=new CaseInsensitiveFilterList(sortedLanguages);
  customFilteredLanguages=new ProgrammingLanguageFilter(filteredLanguages);
}","public ProgrammingLanguageBrowser(){
  languages=new BasicEventList();
  languages.add(new ProgrammingLanguage(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true,true));
  languages.add(new ProgrammingLanguage(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false,false));
  languages.add(new ProgrammingLanguage(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true,false));
  languages.add(new ProgrammingLanguage(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false,false));
  languages.add(new ProgrammingLanguage(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false,false));
  languages.add(new ProgrammingLanguage(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true,false));
  languages.add(new ProgrammingLanguage(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false,false));
  languages.add(new ProgrammingLanguage(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false,false));
  languages.add(new ProgrammingLanguage(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false,true));
  languages.add(new ProgrammingLanguage(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true,false));
  languages.add(new ProgrammingLanguage(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true,false));
  languages.add(new ProgrammingLanguage(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true,false));
  languages.add(new ProgrammingLanguage(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false,false));
  sortedLanguages=new SortedList(languages,sortByName);
  filteredLanguages=new CaseInsensitiveFilterList(sortedLanguages);
  customFilteredLanguages=new ProgrammingLanguageFilter(filteredLanguages);
}",0.1024765157984628
32868,"/** 
 * Gets an event list that contains the current selection in this list table. That list changes dynamically as elements are selected and deselected from the list.
 */
public EventList getSelectionList(){
  return selectionList;
}","/** 
 * Gets an event list that contains the current selection in this list table. That list changes dynamically as elements are selected and deselected from the list. Because the list is dynamic, users should be careful of changes when accessing the SelectionList. It is safer to access the  SelectionList on the Swing event dispatch thread because no selection changes can occur while that thread is executing code.  It is still possible for changes to occur if the base list is being modified on another thread.
 */
public EventList getSelectionList(){
  return selectionList;
}",0.5742331288343558
32869,"/** 
 * Sets the table to use the appropriate comparator for this column
 * @todo the setHeaderValue method won't work permanently due to the factthat the TableFormat class overrides its value. Work out a way to set the value directly on the TableFormat?
 */
public void chooseComparator(int column,boolean ascending){
  Comparator selected;
  String sortedHeader=listTable.getTableFormat().getFieldName(column);
  if (comparators[column].size() > 0) {
    int comparatorIndex=columnClicks[column] % comparators[column].size();
    sortedHeader=sortedHeader + ""String_Node_Str"" + comparatorNames[column].get(comparatorIndex);
    selected=(Comparator)comparators[column].get(comparatorIndex);
  }
 else {
    selected=new ComparableComparator();
  }
  if (!ascending)   selected=new ReverseComparator(selected);
  sortedList.setComparator(selected);
  for (int c=0; c < table.getColumnCount(); c++) {
    if (c == column) {
      table.getColumnModel().getColumn(column).setHeaderValue(sortedHeader);
    }
 else {
      String header=listTable.getTableFormat().getFieldName(c);
      table.getColumnModel().getColumn(c).setHeaderValue(header);
    }
  }
  table.getTableHeader().revalidate();
  table.getTableHeader().repaint();
}","/** 
 * Sets the table to use the appropriate comparator for this column
 * @todo the setHeaderValue method won't work permanently due to the factthat the TableFormat class overrides its value. Work out a way to set the value directly on the TableFormat?
 * @param column the column-model column to choose a comparator for. This isdifferent from the view column which is the natural column in the table.
 */
public void chooseComparator(int column,boolean ascending){
  Comparator selected;
  String sortedHeader=listTable.getTableFormat().getFieldName(column);
  if (comparators[column].size() > 0) {
    int comparatorIndex=columnClicks[column] % comparators[column].size();
    sortedHeader=sortedHeader + ""String_Node_Str"" + comparatorNames[column].get(comparatorIndex);
    selected=(Comparator)comparators[column].get(comparatorIndex);
  }
 else {
    selected=new ComparableComparator();
  }
  if (!ascending)   selected=new ReverseComparator(selected);
  sortedList.setComparator(selected);
  for (int c=0; c < table.getColumnCount(); c++) {
    int modelColumn=table.convertColumnIndexToModel(c);
    if (modelColumn == column) {
      table.getColumnModel().getColumn(c).setHeaderValue(sortedHeader);
    }
 else {
      String header=listTable.getTableFormat().getFieldName(modelColumn);
      table.getColumnModel().getColumn(c).setHeaderValue(header);
    }
  }
  table.getTableHeader().revalidate();
  table.getTableHeader().repaint();
}",0.912751677852349
32870,"/** 
 * AVL-Rotates this subtree with its left child. For every link (left, right, parent), there are up to three updates to be made. We need to set the new value on the replacement, the new value on this, and the new value on the other node.
 */
private void rotateLeft(){
  if (left == null)   throw new IllegalArgumentException(""String_Node_Str"");
  IndexedTreeNode replacement=left;
  left=replacement.right;
  leftSize=replacement.rightSize;
  if (replacement.right != null)   replacement.right.parent=this;
  if (parent != null) {
    parent.replaceChildNode(this,replacement);
  }
 else {
    host.setRootNode(replacement);
  }
  replacement.parent=parent;
  parent=replacement;
  replacement.right=this;
  replacement.rightSize=size();
}","/** 
 * AVL-Rotates this subtree with its left child. For every link (left, right, parent), there are up to three updates to be made. We need to set the new value on the replacement, the new value on this, and the new value on the other node.
 */
private void rotateLeft(){
  if (left == null)   throw new IllegalArgumentException(""String_Node_Str"");
  IndexedTreeNode replacement=left;
  left=replacement.right;
  leftSize=replacement.rightSize;
  if (replacement.right != null)   replacement.right.parent=this;
  if (parent != null) {
    parent.replaceChildNode(this,replacement);
  }
 else {
    host.setRootNode(replacement);
  }
  replacement.parent=parent;
  parent=replacement;
  replacement.right=this;
  replacement.rightSize=size();
  recalculateHeight();
  if (replacement.parent != null)   replacement.parent.recalculateHeight();
}",0.9376966645689112
32871,"/** 
 * Inserts the specified object into the tree with the specified index.
 * @return the SortedTreeNode node where the object was inserted. Thisnode can be used to call the deleteUp() method, which will delete the node from it's parent tree. It is also possible to call the getIndex() method on the node. As new nodes are inserted, the index will shift. The getIndex() method can be used to get the current index of the node at any time.
 */
public IndexedTreeNode insert(int index,Object inserted){
  if (index > leftSize + rootSize + rightSize)   throw new IndexOutOfBoundsException(""String_Node_Str"" + (leftSize + rootSize + rightSize) + ""String_Node_Str""+ index);
  if (inserted == null)   throw new NullPointerException(""String_Node_Str"");
  if (index == 0 && value == null) {
    if (leftSize > 0 || rightSize > 0)     throw new IllegalStateException(""String_Node_Str"");
    rootSize++;
    value=inserted;
    return this;
  }
 else   if (index <= leftSize) {
    if (left == null)     left=new IndexedTreeNode(host,this);
    leftSize++;
    IndexedTreeNode result=left.insert(index,inserted);
    doRotationsForThisLevel();
    return result;
  }
 else {
    if (right == null)     right=new IndexedTreeNode(host,this);
    rightSize++;
    IndexedTreeNode result=right.insert(index - leftSize - rootSize,inserted);
    doRotationsForThisLevel();
    return result;
  }
}","/** 
 * Inserts the specified object into the tree with the specified index.
 * @return the SortedTreeNode node where the object was inserted. Thisnode can be used to call the deleteUp() method, which will delete the node from it's parent tree. It is also possible to call the getIndex() method on the node. As new nodes are inserted, the index will shift. The getIndex() method can be used to get the current index of the node at any time.
 */
public IndexedTreeNode insert(int index,Object inserted){
  if (index > leftSize + rootSize + rightSize)   throw new IndexOutOfBoundsException(""String_Node_Str"" + (leftSize + rootSize + rightSize) + ""String_Node_Str""+ index);
  if (inserted == null)   throw new NullPointerException(""String_Node_Str"");
  if (index == 0 && value == null) {
    if (leftSize > 0 || rightSize > 0)     throw new IllegalStateException(""String_Node_Str"");
    rootSize++;
    value=inserted;
    recalculateHeight();
    return this;
  }
 else   if (index <= leftSize) {
    if (left == null)     left=new IndexedTreeNode(host,this);
    leftSize++;
    IndexedTreeNode result=left.insert(index,inserted);
    doRotationsForThisLevel();
    return result;
  }
 else {
    if (right == null)     right=new IndexedTreeNode(host,this);
    rightSize++;
    IndexedTreeNode result=right.insert(index - leftSize - rootSize,inserted);
    doRotationsForThisLevel();
    return result;
  }
}",0.9910426370476532
32872,"/** 
 * Unlinks this node from the sorted tree. This may cause the tree to rotate nodes using AVL rotations.
 */
public void removeFromTree(){
  if (value == null)   throw new IllegalStateException(""String_Node_Str"");
  if (leftSize == 0 && rightSize == 0) {
    if (parent != null) {
      parent.notifyChildNodeRemoved(this);
      parent.replaceChildNode(this,null);
    }
 else {
      host.setRootNode(null);
    }
    parent=null;
  }
 else   if (leftSize > 0 && rightSize == 0) {
    left.parent=parent;
    if (parent != null) {
      parent.notifyChildNodeRemoved(this);
      parent.replaceChildNode(this,left);
      parent.doRotationsUpTheTree();
    }
 else {
      host.setRootNode(left);
    }
  }
 else   if (leftSize == 0 && rightSize > 0) {
    right.parent=parent;
    if (parent != null) {
      parent.notifyChildNodeRemoved(this);
      parent.replaceChildNode(this,right);
      parent.doRotationsUpTheTree();
    }
 else {
      host.setRootNode(right);
    }
  }
 else {
    IndexedTreeNode middle=null;
    if (leftSize > rightSize) {
      middle=left.getLargestChildNode();
    }
 else {
      middle=right.getSmallestChildNode();
    }
    middle.removeFromTree();
    if (middle.leftSize > 0 || middle.rightSize > 0)     throw new IllegalStateException(""String_Node_Str"");
    middle.left=left;
    middle.leftSize=leftSize;
    if (left != null)     left.parent=middle;
    middle.right=right;
    middle.rightSize=rightSize;
    if (right != null)     right.parent=middle;
    middle.parent=parent;
    if (parent != null) {
      parent.replaceChildNode(this,middle);
      parent.doRotationsUpTheTree();
    }
 else {
      host.setRootNode(middle);
    }
  }
  parent=null;
  left=null;
  leftSize=0;
  right=null;
  rightSize=0;
}","/** 
 * Unlinks this node from the sorted tree. This may cause the tree to rotate nodes using AVL rotations.
 */
public void removeFromTree(){
  if (value == null)   throw new IllegalStateException(""String_Node_Str"");
  if (leftSize == 0 && rightSize == 0) {
    if (parent != null) {
      parent.notifyChildNodeRemoved(this);
      parent.replaceChildNode(this,null);
      parent.recalculateHeight();
    }
 else {
      host.setRootNode(null);
    }
    parent=null;
  }
 else   if (leftSize > 0 && rightSize == 0) {
    left.parent=parent;
    if (parent != null) {
      parent.notifyChildNodeRemoved(this);
      parent.replaceChildNode(this,left);
      parent.recalculateHeight();
      parent.doRotationsUpTheTree();
    }
 else {
      host.setRootNode(left);
    }
  }
 else   if (leftSize == 0 && rightSize > 0) {
    right.parent=parent;
    if (parent != null) {
      parent.notifyChildNodeRemoved(this);
      parent.replaceChildNode(this,right);
      parent.recalculateHeight();
      parent.doRotationsUpTheTree();
    }
 else {
      host.setRootNode(right);
    }
  }
 else {
    IndexedTreeNode middle=null;
    if (leftSize > rightSize) {
      middle=left.getLargestChildNode();
    }
 else {
      middle=right.getSmallestChildNode();
    }
    middle.removeFromTree();
    if (middle.leftSize > 0 || middle.rightSize > 0)     throw new IllegalStateException(""String_Node_Str"");
    middle.left=left;
    middle.leftSize=leftSize;
    if (left != null)     left.parent=middle;
    middle.right=right;
    middle.rightSize=rightSize;
    if (right != null)     right.parent=middle;
    middle.height=height;
    middle.parent=parent;
    if (parent != null) {
      parent.replaceChildNode(this,middle);
      parent.doRotationsUpTheTree();
    }
 else {
      host.setRootNode(middle);
    }
  }
  parent=null;
  left=null;
  leftSize=0;
  right=null;
  rightSize=0;
}",0.9650273224043716
32873,"/** 
 * Retrieves the height of this subtree.
 */
private int height(){
  if (left == null && right == null)   return 1;
 else   if (right == null)   return 1 + left.height();
 else   if (left == null)   return 1 + right.height();
 else   return 1 + Math.max(left.height(),right.height());
}","/** 
 * Retrieves the height of this subtree.
 */
private int height(){
  return height;
}",0.4724409448818897
32874,"/** 
 * A primitive way to validate that nodes are stored in sorted order and that their sizes are consistent. This throws a IllegalStateException if any infraction is found.
 */
public void validate(){
  if (host.getComparator() != null) {
    if (leftSize > 0 && rootSize > 0 && host.getComparator().compare(left.value,value) > 0) {
      throw new IllegalStateException(""String_Node_Str"" + this + ""String_Node_Str"");
    }
    if (rightSize > 0 && rootSize > 0)     if (host.getComparator().compare(value,right.value) > 0) {
      throw new IllegalStateException(""String_Node_Str"" + this + ""String_Node_Str"");
    }
  }
  if ((left == null && leftSize != 0) || (left != null && leftSize != left.size())) {
    throw new IllegalStateException(""String_Node_Str"" + leftSize + ""String_Node_Str""+ left.size());
  }
  if ((right == null && rightSize != 0) || (right != null && rightSize != right.size())) {
    throw new IllegalStateException(""String_Node_Str"" + rightSize + ""String_Node_Str""+ right.size());
  }
}","/** 
 * A primitive way to validate that nodes are stored in sorted order and that their sizes are consistent. This throws a IllegalStateException if any infraction is found.
 */
public void validate(){
  if (left != null)   left.validate();
  if (right != null)   right.validate();
  if (host.getComparator() != null) {
    if (leftSize > 0 && rootSize > 0 && host.getComparator().compare(left.value,value) > 0) {
      throw new IllegalStateException(""String_Node_Str"" + this + ""String_Node_Str"");
    }
    if (rightSize > 0 && rootSize > 0)     if (host.getComparator().compare(value,right.value) > 0) {
      throw new IllegalStateException(""String_Node_Str"" + this + ""String_Node_Str"");
    }
  }
  if ((left == null && leftSize != 0) || (left != null && leftSize != left.size())) {
    throw new IllegalStateException(""String_Node_Str"" + leftSize + ""String_Node_Str""+ left.size());
  }
  if ((right == null && rightSize != 0) || (right != null && rightSize != right.size())) {
    throw new IllegalStateException(""String_Node_Str"" + rightSize + ""String_Node_Str""+ right.size());
  }
}",0.961941008563273
32875,"/** 
 * AVL-Rotates this subtree with its right child. For every link (left, right, parent), there are up to three updates to be made. We need to set the new value on the replacement, the new value on this, and the new value on the other node.
 */
private void rotateRight(){
  if (right == null)   throw new IllegalArgumentException(""String_Node_Str"");
  IndexedTreeNode replacement=right;
  right=replacement.left;
  rightSize=replacement.leftSize;
  if (replacement.left != null)   replacement.left.parent=this;
  if (parent != null) {
    parent.replaceChildNode(this,replacement);
  }
 else {
    host.setRootNode(replacement);
  }
  replacement.parent=parent;
  parent=replacement;
  replacement.left=this;
  replacement.leftSize=size();
}","/** 
 * AVL-Rotates this subtree with its right child. For every link (left, right, parent), there are up to three updates to be made. We need to set the new value on the replacement, the new value on this, and the new value on the other node.
 */
private void rotateRight(){
  if (right == null)   throw new IllegalArgumentException(""String_Node_Str"");
  IndexedTreeNode replacement=right;
  right=replacement.left;
  rightSize=replacement.leftSize;
  if (replacement.left != null)   replacement.left.parent=this;
  if (parent != null) {
    parent.replaceChildNode(this,replacement);
  }
 else {
    host.setRootNode(replacement);
  }
  replacement.parent=parent;
  parent=replacement;
  replacement.left=this;
  replacement.leftSize=size();
  recalculateHeight();
  if (replacement.parent != null)   replacement.parent.recalculateHeight();
}",0.9376966645689112
32876,"/** 
 * Prints the tree by its contents.
 */
public String toString(){
  String valueString=""String_Node_Str"" + height();
  if (left != null && right != null) {
    return ""String_Node_Str"" + left.toString() + ""String_Node_Str""+ valueString+ ""String_Node_Str""+ right.toString()+ ""String_Node_Str"";
  }
 else   if (left != null) {
    return ""String_Node_Str"" + left.toString() + ""String_Node_Str""+ valueString+ ""String_Node_Str"";
  }
 else   if (right != null) {
    return ""String_Node_Str"" + valueString + ""String_Node_Str""+ right.toString()+ ""String_Node_Str"";
  }
 else   if (value == null) {
    return ""String_Node_Str"";
  }
 else {
    return valueString;
  }
}","/** 
 * Prints the tree by its contents.
 */
public String toString(){
  String valueString=value.toString();
  if (left != null && right != null) {
    return ""String_Node_Str"" + left.toString() + ""String_Node_Str""+ valueString+ ""String_Node_Str""+ right.toString()+ ""String_Node_Str"";
  }
 else   if (left != null) {
    return ""String_Node_Str"" + left.toString() + ""String_Node_Str""+ valueString+ ""String_Node_Str"";
  }
 else   if (right != null) {
    return ""String_Node_Str"" + valueString + ""String_Node_Str""+ right.toString()+ ""String_Node_Str"";
  }
 else   if (value == null) {
    return ""String_Node_Str"";
  }
 else {
    return valueString;
  }
}",0.9697885196374624
32877,"/** 
 * Removes from the list the last element that was returned by next or previous (optional operation).
 */
public void remove(){
  if (lastIndex == -1)   throw new IllegalStateException(""String_Node_Str"");
  target.remove(lastIndex);
  lastIndex=-1;
}","/** 
 * Removes from the list the last element that was returned by next or previous (optional operation).
 */
public void remove(){
  if (lastIndex == -1)   throw new IllegalStateException(""String_Node_Str"");
  target.remove(lastIndex);
  if (lastIndex <= nextIndex)   nextIndex--;
  lastIndex=-1;
}",0.918918918918919
32878,"/** 
 * Recompiles the filter regular expression patterns. When the user enters a regular expression that is not recognized, the error is silently ignored and no filters apply.
 */
private void updateFilterPattern(){
  try {
    String[] filterStrings=filterEdit.getText().toLowerCase().split(""String_Node_Str"");
    filters=new Matcher[filterStrings.length];
    for (int i=0; i < filterStrings.length; i++) {
      filters[i]=Pattern.compile(filterStrings[i],Pattern.CASE_INSENSITIVE).matcher(""String_Node_Str"");
    }
  }
 catch (  PatternSyntaxException e) {
    filters=new Matcher[0];
  }
}","/** 
 * Recompiles the filter regular expression patterns. When the user enters a regular expression that is not recognized, the error is silently ignored and no filters apply.
 */
private void updateFilterPattern(){
  try {
    String[] filterStrings=filterEdit.getText().toLowerCase().split(""String_Node_Str"");
    filters=new Matcher[filterStrings.length];
    for (int i=0; i < filterStrings.length; i++) {
      filters[i]=getMatcher(filterStrings[i]);
    }
  }
 catch (  PatternSyntaxException e) {
    filters=new Matcher[0];
  }
}",0.93215859030837
32879,"/** 
 * Sets the query list to display the specified query. The list will not change immediately, instead it will only change when the specified query has loaded. As a woraround, consider setting the query to an empty query to clear the list and then to the desired query.
 * @param period the number if milliseconds before the query isre-executed to refresh the table.
 */
public synchronized void setQuery(Query query){
  if (queryTimerTask != null)   queryTimerTask.cancel();
  queryTimerTask=taskManager.scheduleTask(new QueryTask(query),repeatPeriod);
}","/** 
 * Sets the query list to display the specified query. The list will not change immediately, instead it will only change when the specified query has loaded. As a woraround, consider setting the query to an empty query to clear the list and then to the desired query.
 * @param period the number if milliseconds before the query isre-executed to refresh the table.
 */
public synchronized void setQuery(Query query){
  if (queryTimerTask != null)   queryTimerTask.cancel();
  this.query=query;
  queryTimerTask=taskManager.scheduleTask(new QueryTask(query),repeatPeriod);
}",0.9823943661971832
32880,"/** 
 * When there is a change in one of the progress tasks, this is called to notify the Progress Bar of the change.
 */
public synchronized void taskUpdated(TaskContext task){
  boolean busy=false;
  for (Iterator i=taskManager.getTaskContexts().iterator(); i.hasNext(); ) {
    TaskContext taskContext=(TaskContext)i.next();
    if (taskContext.isBusy() || taskContext.getProgress() < 1.0)     busy=true;
  }
  if (busy)   iconHost.setIcon(busyIcon);
 else   iconHost.setIcon(idleIcon);
}","/** 
 * When there is a change in one of the progress tasks, this is called to notify the Progress Bar of the change.
 */
public synchronized void taskUpdated(TaskContext task){
  boolean busy=false;
  for (Iterator i=taskManager.getTaskContexts().iterator(); i.hasNext(); ) {
    TaskContext taskContext=(TaskContext)i.next();
    if (taskContext.isTaskFinished())     continue;
    if (taskContext.isBusy() || taskContext.getProgress() < 1.0)     busy=true;
  }
  if (busy)   iconHost.setIcon(busyIcon);
 else   iconHost.setIcon(idleIcon);
}",0.9497098646034816
32881,"/** 
 * Sets the query list to display the specified query. The list will not change immediately, instead it will only change when the specified query has loaded. As a woraround, consider setting the query to an empty query to clear the list and then to the desired query.
 */
public synchronized void setQuery(Query query){
  queryTaskContext.cancelTask();
  queryTaskContext=taskManager.runTask(new QueryTask(query));
}","/** 
 * Sets the query list to display the specified query. The list will not change immediately, instead it will only change when the specified query has loaded. As a woraround, consider setting the query to an empty query to clear the list and then to the desired query.
 */
public synchronized void setQuery(Query query){
  if (queryTaskContext != null)   queryTaskContext.cancelTask();
  queryTaskContext=taskManager.runTask(new QueryTask(query));
}",0.9633867276887872
32882,"/** 
 * When this task is executed it sets it's context as busy and performs the query on its background thread. It then sets the query results and sets itself as completed.
 */
public int doTask() throws InterruptedException, Exception {
  taskContext.setBusy(true);
  SortedSet results=query.doQuery();
  if (Thread.interrupted())   throw new InterruptedException();
  setQueryResults(results);
  taskContext.setBusy(false);
  return Task.COMPLETE;
}","/** 
 * When this task is executed it sets it's context as busy and performs the query on its background thread. It then sets the query results and sets itself as completed.
 */
public int doTask(int callSequence) throws InterruptedException, Exception {
  taskContext.setBusy(true);
  SortedSet results=query.doQuery();
  if (Thread.interrupted())   throw new InterruptedException();
  setQueryResults(results);
  taskContext.setBusy(false);
  return Task.COMPLETE;
}",0.982608695652174
32883,"/** 
 * Performs the action of the task. This method shall initially be called using a worker thread, which is not allowed to interact with the user interface. If it is ever necessary for this task to update the user interface before continuing, the task shall return REPEAT_ON_EVENT_DISPATCH_THREAD, and the doTask() method will be called again on the event dispatch thread. For this to work successfully, the task should keep track internally as to where it needs to resume work on the user interface. When user interface work is complete, if the task has additional background work to perform, it can return REPEAT_ON_WORKER_THREAD. This will call the method yet again, but using a worker thread as to not busy the user interface. If this task is cancelled, the thread.interrupt() method will be called. The task can check if it has been interrupted by calling the static method, Thread.interrupted(). If it is ever interrupted it should throw a InterruptedException. The task should clean up any necessary resources before throwing a InterruptedException, because the task shall not be run again. If at any point the task fails, it should throw an exception and the task will be stopped. The exception will be available to the user for their information as to why the task has stopped.
 */
public int doTask() throws InterruptedException, Exception ;","/** 
 * Performs the action of the task. This method shall initially be called using a worker thread, which is not allowed to interact with the user interface. If it is ever necessary for this task to update the user interface before continuing, the task shall return REPEAT_ON_EVENT_DISPATCH_THREAD, and the doTask() method will be called again on the event dispatch thread. For this to work successfully, the task should keep track internally as to where it needs to resume work on the user interface. When user interface work is complete, if the task has additional background work to perform, it can return REPEAT_ON_WORKER_THREAD. This will call the method yet again, but using a worker thread as to not busy the user interface. If this task is cancelled, the thread.interrupt() method will be called. The task can check if it has been interrupted by calling the static method, Thread.interrupted(). If it is ever interrupted it should throw a InterruptedException. The task should clean up any necessary resources before throwing a InterruptedException, because the task shall not be run again. If at any point the task fails, it should throw an exception and the task will be stopped. The exception will be available to the user for their information as to why the task has stopped. The call sequence parameter counts how many times the doTask method has been called in this single execution of the task. For example, if you have a task that performs background work and then GUI work and then background work, the first time this method is called it will be called with a background thread and the callSequence parameter will be 0. The second time the method is called it will be called on the event dispatch thread with a callSequence of 1. The third time the method is called it will be called on a background thread with a callSequence of 2. This can be used to separate your code into the segments that need to be executed on different threads by using if/then/else logic on the callSequence parameter.
 * @param callSequence the number of previous calls made to doTask() inis execution of this task.
 */
public int doTask(int callSequence) throws InterruptedException, Exception ;",0.7634620806315195
32884,"/** 
 * Starts the task runner to execute the specified task on its thread. The task will be executed until complete or an error occurs. The task runner may not be asked to run any more tasks until this task is marked complete in the TaskManager.taskComplete() method.
 */
public synchronized void runTask(Task task,TaskContext taskContext){
  if (executeState != IDLE || currentTask != null)   throw new RuntimeException(""String_Node_Str"");
  currentTask=task;
  currentTaskContext=taskContext;
  executeState=EXECUTE_WORKER;
  System.out.println(""String_Node_Str"");
  workerThread.interrupt();
}","/** 
 * Starts the task runner to execute the specified task on its thread. The task will be executed until complete or an error occurs. The task runner may not be asked to run any more tasks until this task is marked complete in the TaskManager.taskComplete() method.
 */
public synchronized void runTask(Task task,TaskContext taskContext){
  if (executeState != IDLE || currentTask != null)   throw new RuntimeException(""String_Node_Str"");
  currentTask=task;
  currentTaskContext=taskContext;
  currentCallSequence=0;
  executeState=EXECUTE_WORKER;
  System.out.println(""String_Node_Str"");
  workerThread.interrupt();
}",0.9794913863822804
32885,"/** 
 * Executes the task on the current thread one time, and prepares the execute state for the next execution.
 */
private synchronized void doTaskOnce(){
  try {
    int taskResult=currentTask.doTask();
    if (taskResult == Task.COMPLETE) {
      TaskContext completedContext=currentTaskContext;
      executeState=IDLE;
      currentTask=null;
      currentTaskContext=null;
      completedContext.taskComplete();
    }
 else     if (taskResult == Task.REPEAT_ON_WORKER_THREAD) {
      executeState=EXECUTE_WORKER;
    }
 else     if (taskResult == Task.REPEAT_ON_EVENT_DISPATCH_THREAD) {
      executeState=EXECUTE_EVENT_DISPATCH;
    }
  }
 catch (  InterruptedException e) {
    TaskContext completedContext=currentTaskContext;
    executeState=IDLE;
    currentTask=null;
    currentTaskContext=null;
    completedContext.taskInterrupted(e);
  }
catch (  Exception e) {
    TaskContext completedContext=currentTaskContext;
    executeState=IDLE;
    currentTask=null;
    currentTaskContext=null;
    completedContext.taskFailed(e);
  }
}","/** 
 * Executes the task on the current thread one time, and prepares the execute state for the next execution.
 */
private synchronized void doTaskOnce(){
  try {
    int taskResult=currentTask.doTask(currentCallSequence);
    currentCallSequence++;
    if (taskResult == Task.COMPLETE) {
      TaskContext completedContext=currentTaskContext;
      executeState=IDLE;
      currentTask=null;
      currentTaskContext=null;
      completedContext.taskComplete();
    }
 else     if (taskResult == Task.REPEAT_ON_WORKER_THREAD) {
      executeState=EXECUTE_WORKER;
    }
 else     if (taskResult == Task.REPEAT_ON_EVENT_DISPATCH_THREAD) {
      executeState=EXECUTE_EVENT_DISPATCH;
    }
  }
 catch (  InterruptedException e) {
    TaskContext completedContext=currentTaskContext;
    executeState=IDLE;
    currentTask=null;
    currentTaskContext=null;
    completedContext.taskInterrupted(e);
  }
catch (  Exception e) {
    TaskContext completedContext=currentTaskContext;
    executeState=IDLE;
    currentTask=null;
    currentTaskContext=null;
    completedContext.taskFailed(e);
  }
}",0.9785046728971962
32886,"/** 
 */
public ColorPickerDialog(final SkinEditorGame game,final Field field){
  super(""String_Node_Str"",game.skin);
  this.game=game;
  this.field=field;
  tableColors=new Table(game.skin);
  tableColors.left().top().pad(5);
  tableColors.defaults().pad(5);
  colors=game.skinProject.getAll(Color.class);
  updateTable();
  TextButton buttonNewColor=new TextButton(""String_Node_Str"",game.skin);
  buttonNewColor.addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      java.awt.Color color=JColorChooser.showDialog(null,""String_Node_Str"",java.awt.Color.WHITE);
      if (color != null) {
        String colorName=JOptionPane.showInputDialog(""String_Node_Str"");
        if ((colorName != null) && (colorName.isEmpty() == false)) {
          if (colors.containsKey(colorName) == true) {
            game.showNotice(""String_Node_Str"",""String_Node_Str"",game.screenMain.stage);
          }
 else {
            float[] components=color.getComponents(null);
            Color newColor=new Color(components[0],components[1],components[2],components[3]);
            if (isColorInUse(newColor)) {
              game.showNotice(""String_Node_Str"",""String_Node_Str"" + newColor.toString() + ""String_Node_Str"",game.screenMain.stage);
              return;
            }
            colors.put(colorName,newColor);
            game.screenMain.saveToSkin();
            updateTable();
          }
        }
      }
    }
  }
);
  TextButton buttonNoColor=new TextButton(""String_Node_Str"",game.skin);
  buttonNoColor.addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      try {
        field.set(game.screenMain.paneOptions.currentStyle,null);
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
      game.screenMain.saveToSkin();
      hide();
      game.screenMain.panePreview.refresh();
      game.screenMain.paneOptions.updateSelectedTableFields();
    }
  }
);
  ScrollPane scrollPane=new ScrollPane(tableColors,game.skin);
  scrollPane.setFlickScroll(false);
  scrollPane.setFadeScrollBars(false);
  scrollPane.setScrollbarsOnTop(true);
  getContentTable().add(scrollPane).width(640).height(320).pad(20);
  getButtonTable().add(buttonNewColor);
  getButtonTable().add(buttonNoColor);
  getButtonTable().padBottom(15);
  button(""String_Node_Str"",false);
  key(com.badlogic.gdx.Input.Keys.ESCAPE,false);
}","/** 
 */
public ColorPickerDialog(final SkinEditorGame game,final Field field){
  super(""String_Node_Str"",game.skin);
  this.game=game;
  this.field=field;
  tableColors=new Table(game.skin);
  tableColors.left().top().pad(5);
  tableColors.defaults().pad(5);
  colors=game.skinProject.getAll(Color.class);
  updateTable();
  TextButton buttonNewColor=new TextButton(""String_Node_Str"",game.skin);
  buttonNewColor.addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      Frame frame=new Frame();
      frame.setUndecorated(true);
      frame.setOpacity(0);
      frame.setLocationRelativeTo(null);
      frame.setVisible(true);
      frame.toFront();
      frame.setVisible(false);
      frame.dispose();
      java.awt.Color color=JColorChooser.showDialog(null,""String_Node_Str"",java.awt.Color.WHITE);
      if (color != null) {
        String colorName=JOptionPane.showInputDialog(""String_Node_Str"");
        if ((colorName != null) && (colorName.isEmpty() == false)) {
          if (colors.containsKey(colorName) == true) {
            game.showNotice(""String_Node_Str"",""String_Node_Str"",game.screenMain.stage);
          }
 else {
            float[] components=color.getComponents(null);
            Color newColor=new Color(components[0],components[1],components[2],components[3]);
            if (isColorInUse(newColor)) {
              game.showNotice(""String_Node_Str"",""String_Node_Str"" + newColor.toString() + ""String_Node_Str"",game.screenMain.stage);
              return;
            }
            colors.put(colorName,newColor);
            game.screenMain.saveToSkin();
            updateTable();
          }
        }
      }
    }
  }
);
  TextButton buttonNoColor=new TextButton(""String_Node_Str"",game.skin);
  buttonNoColor.addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      try {
        field.set(game.screenMain.paneOptions.currentStyle,null);
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
      game.screenMain.saveToSkin();
      hide();
      game.screenMain.panePreview.refresh();
      game.screenMain.paneOptions.updateSelectedTableFields();
    }
  }
);
  ScrollPane scrollPane=new ScrollPane(tableColors,game.skin);
  scrollPane.setFlickScroll(false);
  scrollPane.setFadeScrollBars(false);
  scrollPane.setScrollbarsOnTop(true);
  getContentTable().add(scrollPane).width(640).height(320).pad(20);
  getButtonTable().add(buttonNewColor);
  getButtonTable().add(buttonNoColor);
  getButtonTable().padBottom(15);
  button(""String_Node_Str"",false);
  key(com.badlogic.gdx.Input.Keys.ESCAPE,false);
}",0.9529964747356052
32887,"public DrawablePickerDialog(final SkinEditorGame game,final Field field){
  super(""String_Node_Str"",game.skin);
  this.game=game;
  this.field=field;
  tableDrawables=new Table(game.skin);
  scrollPane=new ScrollPane(tableDrawables,game.skin);
  getContentTable().add(scrollPane);
  scrollPane.setFlickScroll(false);
  scrollPane.setFadeScrollBars(false);
  scrollPane.setScrollbarsOnTop(true);
  TextButton buttonZoom=new TextButton(""String_Node_Str"",game.skin);
  buttonZoom.addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      zoom=!zoom;
      updateTable();
    }
  }
);
  TextButton buttonNewDrawable=new TextButton(""String_Node_Str"",game.skin);
  buttonNewDrawable.addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      JFileChooser chooser=new JFileChooser();
      FileNameExtensionFilter filter=new FileNameExtensionFilter(""String_Node_Str"",""String_Node_Str"");
      chooser.setFileFilter(filter);
      int returnVal=chooser.showOpenDialog(null);
      if (returnVal != JFileChooser.APPROVE_OPTION) {
        return;
      }
      File selectedFile=chooser.getSelectedFile();
      if (selectedFile == null) {
        return;
      }
      while (true) {
        String resourceName=selectedFile.getName();
        String ext=resourceName.substring(resourceName.lastIndexOf(""String_Node_Str"") + 1);
        resourceName=resourceName.substring(0,resourceName.lastIndexOf(""String_Node_Str""));
        resourceName=JOptionPane.showInputDialog(""String_Node_Str"",resourceName);
        if (resourceName == null) {
          return;
        }
        resourceName=resourceName.toLowerCase();
        FileHandle[] assetsFolder=new FileHandle(""String_Node_Str"" + game.screenMain.getcurrentProject() + ""String_Node_Str"").list();
        boolean foundSomething=false;
        for (        FileHandle file : assetsFolder) {
          if (file.nameWithoutExtension().toLowerCase().equals(resourceName)) {
            foundSomething=true;
            break;
          }
        }
        if (foundSomething == true) {
          JOptionPane.showMessageDialog(null,""String_Node_Str"");
        }
 else {
          FileHandle orig=new FileHandle(selectedFile);
          FileHandle dest=new FileHandle(""String_Node_Str"" + game.screenMain.getcurrentProject() + ""String_Node_Str""+ resourceName+ ""String_Node_Str""+ ext);
          orig.copyTo(dest);
          game.screenMain.refreshResources();
          refresh();
          JOptionPane.showMessageDialog(null,""String_Node_Str"");
          return;
        }
      }
    }
  }
);
  TextButton buttonNoDrawable=new TextButton(""String_Node_Str"",game.skin);
  buttonNoDrawable.addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      try {
        field.set(game.screenMain.paneOptions.currentStyle,null);
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
      game.screenMain.saveToSkin();
      hide();
      game.screenMain.panePreview.refresh();
      game.screenMain.paneOptions.updateSelectedTableFields();
    }
  }
);
  getContentTable().add(scrollPane).width(960).height(640).pad(20);
  getButtonTable().add(buttonZoom);
  getButtonTable().add(buttonNewDrawable);
  getButtonTable().add(buttonNoDrawable);
  getButtonTable().padBottom(15);
  button(""String_Node_Str"",false);
  key(com.badlogic.gdx.Input.Keys.ESCAPE,false);
}","public DrawablePickerDialog(final SkinEditorGame game,final Field field){
  super(""String_Node_Str"",game.skin);
  this.game=game;
  this.field=field;
  tableDrawables=new Table(game.skin);
  scrollPane=new ScrollPane(tableDrawables,game.skin);
  getContentTable().add(scrollPane);
  scrollPane.setFlickScroll(false);
  scrollPane.setFadeScrollBars(false);
  scrollPane.setScrollbarsOnTop(true);
  TextButton buttonZoom=new TextButton(""String_Node_Str"",game.skin);
  buttonZoom.addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      zoom=!zoom;
      updateTable();
    }
  }
);
  TextButton buttonNewDrawable=new TextButton(""String_Node_Str"",game.skin);
  buttonNewDrawable.addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      Frame frame=new Frame();
      frame.setUndecorated(true);
      frame.setOpacity(0);
      frame.setLocationRelativeTo(null);
      frame.setVisible(true);
      frame.toFront();
      frame.setVisible(false);
      frame.dispose();
      JFileChooser chooser=new JFileChooser();
      FileNameExtensionFilter filter=new FileNameExtensionFilter(""String_Node_Str"",""String_Node_Str"");
      chooser.setFileFilter(filter);
      int returnVal=chooser.showOpenDialog(null);
      if (returnVal != JFileChooser.APPROVE_OPTION) {
        return;
      }
      File selectedFile=chooser.getSelectedFile();
      if (selectedFile == null) {
        return;
      }
      while (true) {
        String resourceName=selectedFile.getName();
        String ext=resourceName.substring(resourceName.lastIndexOf(""String_Node_Str"") + 1);
        resourceName=resourceName.substring(0,resourceName.lastIndexOf(""String_Node_Str""));
        resourceName=JOptionPane.showInputDialog(""String_Node_Str"",resourceName);
        if (resourceName == null) {
          return;
        }
        resourceName=resourceName.toLowerCase();
        FileHandle[] assetsFolder=new FileHandle(""String_Node_Str"" + game.screenMain.getcurrentProject() + ""String_Node_Str"").list();
        boolean foundSomething=false;
        for (        FileHandle file : assetsFolder) {
          if (file.nameWithoutExtension().toLowerCase().equals(resourceName)) {
            foundSomething=true;
            break;
          }
        }
        if (foundSomething == true) {
          JOptionPane.showMessageDialog(null,""String_Node_Str"");
        }
 else {
          FileHandle orig=new FileHandle(selectedFile);
          FileHandle dest=new FileHandle(""String_Node_Str"" + game.screenMain.getcurrentProject() + ""String_Node_Str""+ resourceName+ ""String_Node_Str""+ ext);
          orig.copyTo(dest);
          game.screenMain.refreshResources();
          refresh();
          JOptionPane.showMessageDialog(null,""String_Node_Str"");
          return;
        }
      }
    }
  }
);
  TextButton buttonNoDrawable=new TextButton(""String_Node_Str"",game.skin);
  buttonNoDrawable.addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      try {
        field.set(game.screenMain.paneOptions.currentStyle,null);
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
      game.screenMain.saveToSkin();
      hide();
      game.screenMain.panePreview.refresh();
      game.screenMain.paneOptions.updateSelectedTableFields();
    }
  }
);
  getContentTable().add(scrollPane).width(960).height(640).pad(20);
  getButtonTable().add(buttonZoom);
  getButtonTable().add(buttonNewDrawable);
  getButtonTable().add(buttonNoDrawable);
  getButtonTable().padBottom(15);
  button(""String_Node_Str"",false);
  key(com.badlogic.gdx.Input.Keys.ESCAPE,false);
}",0.9666203059805284
32888,"protected void showExportDialog(){
  final Preferences prefs=Gdx.app.getPreferences(""String_Node_Str"" + game.screenMain.getcurrentProject());
  final TextField textDirectory=new TextField(prefs.getString(""String_Node_Str""),game.skin);
  Dialog dlg=new Dialog(""String_Node_Str"",game.skin){
    @Override protected void result(    Object object){
      if ((Boolean)object == true) {
        if (textDirectory.getText().isEmpty() == true) {
          game.showNotice(""String_Node_Str"",""String_Node_Str"",game.screenMain.stage);
          return;
        }
        FileHandle targetDirectory=new FileHandle(textDirectory.getText());
        if (targetDirectory.exists() == false) {
          game.showNotice(""String_Node_Str"",""String_Node_Str"",game.screenMain.stage);
          return;
        }
        FileHandle projectFolder=Gdx.files.local(""String_Node_Str"").child(game.screenMain.getcurrentProject());
        for (        FileHandle file : projectFolder.list()) {
          if (file.name().startsWith(""String_Node_Str"") || (file.extension() == ""String_Node_Str"")) {
            Gdx.app.log(""String_Node_Str"",""String_Node_Str"" + file.name() + ""String_Node_Str"");
            FileHandle target=targetDirectory.child(file.name());
            file.copyTo(target);
          }
        }
        game.showNotice(""String_Node_Str"",""String_Node_Str"",game.screenMain.stage);
      }
    }
  }
;
  dlg.pad(20);
  Table table=dlg.getContentTable();
  table.padTop(20);
  table.add(""String_Node_Str"");
  table.add(textDirectory).width(320);
  TextButton buttonChoose=new TextButton(""String_Node_Str"",game.skin);
  buttonChoose.addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      JFileChooser chooser=new JFileChooser();
      chooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
      int ret=chooser.showOpenDialog(null);
      if (ret == JFileChooser.APPROVE_OPTION) {
        File f=chooser.getSelectedFile();
        textDirectory.setText(f.getAbsolutePath());
        prefs.putString(""String_Node_Str"",f.getAbsolutePath());
        prefs.flush();
      }
    }
  }
);
  table.add(buttonChoose);
  table.row();
  table.padBottom(20);
  dlg.button(""String_Node_Str"",true);
  dlg.button(""String_Node_Str"",false);
  dlg.key(com.badlogic.gdx.Input.Keys.ENTER,true);
  dlg.key(com.badlogic.gdx.Input.Keys.ESCAPE,false);
  dlg.show(getStage());
}","protected void showExportDialog(){
  final Preferences prefs=Gdx.app.getPreferences(""String_Node_Str"" + game.screenMain.getcurrentProject());
  final TextField textDirectory=new TextField(prefs.getString(""String_Node_Str""),game.skin);
  Dialog dlg=new Dialog(""String_Node_Str"",game.skin){
    @Override protected void result(    Object object){
      if ((Boolean)object == true) {
        if (textDirectory.getText().isEmpty() == true) {
          game.showNotice(""String_Node_Str"",""String_Node_Str"",game.screenMain.stage);
          return;
        }
        FileHandle targetDirectory=new FileHandle(textDirectory.getText());
        if (targetDirectory.exists() == false) {
          game.showNotice(""String_Node_Str"",""String_Node_Str"",game.screenMain.stage);
          return;
        }
        FileHandle projectFolder=Gdx.files.local(""String_Node_Str"").child(game.screenMain.getcurrentProject());
        for (        FileHandle file : projectFolder.list()) {
          if (file.name().startsWith(""String_Node_Str"") || (file.extension() == ""String_Node_Str"")) {
            Gdx.app.log(""String_Node_Str"",""String_Node_Str"" + file.name() + ""String_Node_Str"");
            FileHandle target=targetDirectory.child(file.name());
            file.copyTo(target);
          }
        }
        game.showNotice(""String_Node_Str"",""String_Node_Str"",game.screenMain.stage);
      }
    }
  }
;
  dlg.pad(20);
  Table table=dlg.getContentTable();
  table.padTop(20);
  table.add(""String_Node_Str"");
  table.add(textDirectory).width(320);
  TextButton buttonChoose=new TextButton(""String_Node_Str"",game.skin);
  buttonChoose.addListener(new ChangeListener(){
    @Override public void changed(    ChangeEvent event,    Actor actor){
      Frame frame=new Frame();
      frame.setUndecorated(true);
      frame.setOpacity(0);
      frame.setLocationRelativeTo(null);
      frame.setVisible(true);
      frame.toFront();
      frame.setVisible(false);
      frame.dispose();
      JFileChooser chooser=new JFileChooser();
      chooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
      int ret=chooser.showOpenDialog(null);
      if (ret == JFileChooser.APPROVE_OPTION) {
        File f=chooser.getSelectedFile();
        textDirectory.setText(f.getAbsolutePath());
        prefs.putString(""String_Node_Str"",f.getAbsolutePath());
        prefs.flush();
      }
    }
  }
);
  table.add(buttonChoose);
  table.row();
  table.padBottom(20);
  dlg.button(""String_Node_Str"",true);
  dlg.button(""String_Node_Str"",false);
  dlg.key(com.badlogic.gdx.Input.Keys.ENTER,true);
  dlg.key(com.badlogic.gdx.Input.Keys.ESCAPE,false);
  dlg.show(getStage());
}",0.9524940617577196
32889,"@Override public void changed(ChangeEvent event,Actor actor){
  JFileChooser chooser=new JFileChooser();
  chooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
  int ret=chooser.showOpenDialog(null);
  if (ret == JFileChooser.APPROVE_OPTION) {
    File f=chooser.getSelectedFile();
    textDirectory.setText(f.getAbsolutePath());
    prefs.putString(""String_Node_Str"",f.getAbsolutePath());
    prefs.flush();
  }
}","@Override public void changed(ChangeEvent event,Actor actor){
  Frame frame=new Frame();
  frame.setUndecorated(true);
  frame.setOpacity(0);
  frame.setLocationRelativeTo(null);
  frame.setVisible(true);
  frame.toFront();
  frame.setVisible(false);
  frame.dispose();
  JFileChooser chooser=new JFileChooser();
  chooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
  int ret=chooser.showOpenDialog(null);
  if (ret == JFileChooser.APPROVE_OPTION) {
    File f=chooser.getSelectedFile();
    textDirectory.setText(f.getAbsolutePath());
    prefs.putString(""String_Node_Str"",f.getAbsolutePath());
    prefs.flush();
  }
}",0.8022813688212928
32890,"/** 
 */
public SystemFonts(){
  String osName=System.getProperty(""String_Node_Str"");
  if (osName.equals(""String_Node_Str"")) {
    fontPaths.add(""String_Node_Str"");
    fontPaths.add(""String_Node_Str"");
  }
 else   if (osName.contains(""String_Node_Str"")) {
    fontPaths.add(""String_Node_Str"");
  }
 else {
    fontPaths.add(""String_Node_Str"");
    fontPaths.add(""String_Node_Str"");
  }
}","/** 
 */
public SystemFonts(){
  String osName=System.getProperty(""String_Node_Str"");
  if (osName.equals(""String_Node_Str"")) {
    fontPaths.add(""String_Node_Str"");
    fontPaths.add(""String_Node_Str"");
  }
 else   if (osName.contains(""String_Node_Str"")) {
    fontPaths.add(""String_Node_Str"");
  }
 else {
    fontPaths.add(""String_Node_Str"");
    fontPaths.add(""String_Node_Str"");
    fontPaths.add(""String_Node_Str"");
  }
}",0.9534313725490196
32891,"public SkinManager(TextureManager textureManagerInstance,File skinCacheDirectory,MinecraftSessionService sessionService){
  this.textureManager=textureManagerInstance;
  this.skinCacheDir=skinCacheDirectory;
  this.sessionService=sessionService;
  this.skinCacheLoader=CacheBuilder.newBuilder().expireAfterAccess(15L,TimeUnit.SECONDS).<GameProfile,Map<Type,MinecraftProfileTexture>>build(new CacheLoader<GameProfile,Map<Type,MinecraftProfileTexture>>(){
    public Map<Type,MinecraftProfileTexture> load(    GameProfile p_load_1_) throws Exception {
      return Minecraft.getMinecraft().getSessionService().getTextures(p_load_1_,false);
    }
  }
);
  customskinloader.loader.MojangAPILoader.defaultSessionService=sessionService;
  customskinloader.utils.HttpTextureUtil.defaultCacheDir=skinCacheDirectory;
  customskinloader.utils.HttpTextureUtil.initDefaultCacheDir();
}","public SkinManager(TextureManager textureManagerInstance,File skinCacheDirectory,MinecraftSessionService sessionService){
  this.textureManager=textureManagerInstance;
  this.skinCacheDir=skinCacheDirectory;
  this.sessionService=sessionService;
  this.skinCacheLoader=CacheBuilder.newBuilder().expireAfterAccess(15L,TimeUnit.SECONDS).<GameProfile,Map<Type,MinecraftProfileTexture>>build(new CacheLoader<GameProfile,Map<Type,MinecraftProfileTexture>>(){
    public Map<Type,MinecraftProfileTexture> load(    GameProfile p_load_1_) throws Exception {
      return Minecraft.getMinecraft().getSessionService().getTextures(p_load_1_,false);
    }
  }
);
  customskinloader.loader.MojangAPILoader.defaultSessionService=sessionService;
  customskinloader.utils.HttpTextureUtil.defaultCacheDir=skinCacheDirectory;
}",0.961950059453032
32892,"public SkinManager(TextureManager textureManagerInstance,File skinCacheDirectory,MinecraftSessionService sessionService){
  this.textureManager=textureManagerInstance;
  this.skinCacheDir=skinCacheDirectory;
  this.sessionService=sessionService;
  this.skinCacheLoader=CacheBuilder.newBuilder().expireAfterAccess(15L,TimeUnit.SECONDS).<GameProfile,Map<Type,MinecraftProfileTexture>>build(new CacheLoader<GameProfile,Map<Type,MinecraftProfileTexture>>(){
    public Map<Type,MinecraftProfileTexture> load(    GameProfile p_load_1_) throws Exception {
      return Minecraft.getMinecraft().getSessionService().getTextures(p_load_1_,false);
    }
  }
);
  customskinloader.loader.MojangAPILoader.defaultSessionService=sessionService;
  customskinloader.utils.HttpTextureUtil.defaultCacheDir=skinCacheDirectory;
  customskinloader.utils.HttpTextureUtil.initDefaultCacheDir();
}","public SkinManager(TextureManager textureManagerInstance,File skinCacheDirectory,MinecraftSessionService sessionService){
  this.textureManager=textureManagerInstance;
  this.skinCacheDir=skinCacheDirectory;
  this.sessionService=sessionService;
  this.skinCacheLoader=CacheBuilder.newBuilder().expireAfterAccess(15L,TimeUnit.SECONDS).<GameProfile,Map<Type,MinecraftProfileTexture>>build(new CacheLoader<GameProfile,Map<Type,MinecraftProfileTexture>>(){
    public Map<Type,MinecraftProfileTexture> load(    GameProfile p_load_1_) throws Exception {
      return Minecraft.getMinecraft().getSessionService().getTextures(p_load_1_,false);
    }
  }
);
  customskinloader.loader.MojangAPILoader.defaultSessionService=sessionService;
  customskinloader.utils.HttpTextureUtil.defaultCacheDir=skinCacheDirectory;
}",0.961950059453032
32893,"public SkinManager(TextureManager textureManagerInstance,File skinCacheDirectory,MinecraftSessionService sessionService){
  this.textureManager=textureManagerInstance;
  this.skinCacheDir=skinCacheDirectory;
  this.sessionService=sessionService;
  this.skinCacheLoader=CacheBuilder.newBuilder().expireAfterAccess(15L,TimeUnit.SECONDS).build(new CacheLoader(){
    private static final String __OBFID=""String_Node_Str"";
    public Map func_152786_a(    GameProfile p_152786_1_){
      return Minecraft.getMinecraft().getSessionService().getTextures(p_152786_1_,false);
    }
    public Object load(    Object p_load_1_){
      return this.func_152786_a((GameProfile)p_load_1_);
    }
  }
);
  customskinloader.loader.MojangAPILoader.defaultSessionService=sessionService;
  customskinloader.utils.HttpTextureUtil.defaultCacheDir=skinCacheDirectory;
  customskinloader.utils.HttpTextureUtil.initDefaultCacheDir();
}","public SkinManager(TextureManager textureManagerInstance,File skinCacheDirectory,MinecraftSessionService sessionService){
  this.textureManager=textureManagerInstance;
  this.skinCacheDir=skinCacheDirectory;
  this.sessionService=sessionService;
  this.skinCacheLoader=CacheBuilder.newBuilder().expireAfterAccess(15L,TimeUnit.SECONDS).build(new CacheLoader(){
    private static final String __OBFID=""String_Node_Str"";
    public Map func_152786_a(    GameProfile p_152786_1_){
      return Minecraft.getMinecraft().getSessionService().getTextures(p_152786_1_,false);
    }
    public Object load(    Object p_load_1_){
      return this.func_152786_a((GameProfile)p_load_1_);
    }
  }
);
  customskinloader.loader.MojangAPILoader.defaultSessionService=sessionService;
  customskinloader.utils.HttpTextureUtil.defaultCacheDir=skinCacheDirectory;
}",0.9636363636363636
32894,"public SkinManager(TextureManager textureManagerInstance,File skinCacheDirectory,MinecraftSessionService sessionService){
  this.textureManager=textureManagerInstance;
  this.skinCacheDir=skinCacheDirectory;
  this.sessionService=sessionService;
  this.skinCacheLoader=CacheBuilder.newBuilder().expireAfterAccess(15L,TimeUnit.SECONDS).build(new CacheLoader(){
    private static final String __OBFID=""String_Node_Str"";
    public Map func_152786_a(    GameProfile profile){
      return Minecraft.getMinecraft().getSessionService().getTextures(profile,false);
    }
    public Object load(    Object p_load_1_){
      return this.func_152786_a((GameProfile)p_load_1_);
    }
  }
);
  customskinloader.loader.MojangAPILoader.defaultSessionService=sessionService;
  customskinloader.utils.HttpTextureUtil.defaultCacheDir=skinCacheDirectory;
  customskinloader.utils.HttpTextureUtil.initDefaultCacheDir();
}","public SkinManager(TextureManager textureManagerInstance,File skinCacheDirectory,MinecraftSessionService sessionService){
  this.textureManager=textureManagerInstance;
  this.skinCacheDir=skinCacheDirectory;
  this.sessionService=sessionService;
  this.skinCacheLoader=CacheBuilder.newBuilder().expireAfterAccess(15L,TimeUnit.SECONDS).build(new CacheLoader(){
    private static final String __OBFID=""String_Node_Str"";
    public Map func_152786_a(    GameProfile profile){
      return Minecraft.getMinecraft().getSessionService().getTextures(profile,false);
    }
    public Object load(    Object p_load_1_){
      return this.func_152786_a((GameProfile)p_load_1_);
    }
  }
);
  customskinloader.loader.MojangAPILoader.defaultSessionService=sessionService;
  customskinloader.utils.HttpTextureUtil.defaultCacheDir=skinCacheDirectory;
}",0.963302752293578
32895,"public SkinManager(TextureManager textureManagerInstance,File skinCacheDirectory,MinecraftSessionService sessionService){
  this.textureManager=textureManagerInstance;
  this.skinCacheDir=skinCacheDirectory;
  this.sessionService=sessionService;
  this.skinCacheLoader=CacheBuilder.newBuilder().expireAfterAccess(15L,TimeUnit.SECONDS).<GameProfile,Map<Type,MinecraftProfileTexture>>build(new CacheLoader<GameProfile,Map<Type,MinecraftProfileTexture>>(){
    public Map<Type,MinecraftProfileTexture> load(    GameProfile p_load_1_) throws Exception {
      return Minecraft.getMinecraft().getSessionService().getTextures(p_load_1_,false);
    }
  }
);
  customskinloader.loader.MojangAPILoader.defaultSessionService=sessionService;
  customskinloader.utils.HttpTextureUtil.defaultCacheDir=skinCacheDirectory;
  customskinloader.utils.HttpTextureUtil.initDefaultCacheDir();
}","public SkinManager(TextureManager textureManagerInstance,File skinCacheDirectory,MinecraftSessionService sessionService){
  this.textureManager=textureManagerInstance;
  this.skinCacheDir=skinCacheDirectory;
  this.sessionService=sessionService;
  this.skinCacheLoader=CacheBuilder.newBuilder().expireAfterAccess(15L,TimeUnit.SECONDS).<GameProfile,Map<Type,MinecraftProfileTexture>>build(new CacheLoader<GameProfile,Map<Type,MinecraftProfileTexture>>(){
    public Map<Type,MinecraftProfileTexture> load(    GameProfile p_load_1_) throws Exception {
      return Minecraft.getMinecraft().getSessionService().getTextures(p_load_1_,false);
    }
  }
);
  customskinloader.loader.MojangAPILoader.defaultSessionService=sessionService;
  customskinloader.utils.HttpTextureUtil.defaultCacheDir=skinCacheDirectory;
}",0.961950059453032
32896,"public SkinManager(TextureManager textureManagerInstance,File skinCacheDirectory,MinecraftSessionService sessionService){
  this.textureManager=textureManagerInstance;
  this.skinCacheDir=skinCacheDirectory;
  this.sessionService=sessionService;
  this.skinCacheLoader=CacheBuilder.newBuilder().expireAfterAccess(15L,TimeUnit.SECONDS).<GameProfile,Map<Type,MinecraftProfileTexture>>build(new CacheLoader<GameProfile,Map<Type,MinecraftProfileTexture>>(){
    public Map<Type,MinecraftProfileTexture> load(    GameProfile p_load_1_) throws Exception {
      return Minecraft.getMinecraft().getSessionService().getTextures(p_load_1_,false);
    }
  }
);
  customskinloader.loader.MojangAPILoader.defaultSessionService=sessionService;
  customskinloader.utils.HttpTextureUtil.defaultCacheDir=skinCacheDirectory;
  customskinloader.utils.HttpTextureUtil.initDefaultCacheDir();
}","public SkinManager(TextureManager textureManagerInstance,File skinCacheDirectory,MinecraftSessionService sessionService){
  this.textureManager=textureManagerInstance;
  this.skinCacheDir=skinCacheDirectory;
  this.sessionService=sessionService;
  this.skinCacheLoader=CacheBuilder.newBuilder().expireAfterAccess(15L,TimeUnit.SECONDS).<GameProfile,Map<Type,MinecraftProfileTexture>>build(new CacheLoader<GameProfile,Map<Type,MinecraftProfileTexture>>(){
    public Map<Type,MinecraftProfileTexture> load(    GameProfile p_load_1_) throws Exception {
      return Minecraft.getMinecraft().getSessionService().getTextures(p_load_1_,false);
    }
  }
);
  customskinloader.loader.MojangAPILoader.defaultSessionService=sessionService;
  customskinloader.utils.HttpTextureUtil.defaultCacheDir=skinCacheDirectory;
}",0.961950059453032
32897,"public SkinManager(TextureManager textureManagerInstance,File skinCacheDirectory,MinecraftSessionService sessionService){
  this.textureManager=textureManagerInstance;
  this.skinCacheDir=skinCacheDirectory;
  this.sessionService=sessionService;
  this.skinCacheLoader=CacheBuilder.newBuilder().expireAfterAccess(15L,TimeUnit.SECONDS).<GameProfile,Map<Type,MinecraftProfileTexture>>build(new CacheLoader<GameProfile,Map<Type,MinecraftProfileTexture>>(){
    public Map<Type,MinecraftProfileTexture> load(    GameProfile p_load_1_) throws Exception {
      return Minecraft.getMinecraft().getSessionService().getTextures(p_load_1_,false);
    }
  }
);
  customskinloader.loader.MojangAPILoader.defaultSessionService=sessionService;
  customskinloader.utils.HttpTextureUtil.defaultCacheDir=skinCacheDirectory;
  customskinloader.utils.HttpTextureUtil.initDefaultCacheDir();
}","public SkinManager(TextureManager textureManagerInstance,File skinCacheDirectory,MinecraftSessionService sessionService){
  this.textureManager=textureManagerInstance;
  this.skinCacheDir=skinCacheDirectory;
  this.sessionService=sessionService;
  this.skinCacheLoader=CacheBuilder.newBuilder().expireAfterAccess(15L,TimeUnit.SECONDS).<GameProfile,Map<Type,MinecraftProfileTexture>>build(new CacheLoader<GameProfile,Map<Type,MinecraftProfileTexture>>(){
    public Map<Type,MinecraftProfileTexture> load(    GameProfile p_load_1_) throws Exception {
      return Minecraft.getMinecraft().getSessionService().getTextures(p_load_1_,false);
    }
  }
);
  customskinloader.loader.MojangAPILoader.defaultSessionService=sessionService;
  customskinloader.utils.HttpTextureUtil.defaultCacheDir=skinCacheDirectory;
}",0.961950059453032
32898,"public static UserProfile loadProfile0(GameProfile gameProfile){
  String username=gameProfile.getName();
  profileCache.setLoading(username,true);
  logger.info(""String_Node_Str"" + username + ""String_Node_Str"");
  for (int i=0; i < config.loadlist.length; i++) {
    SkinSiteProfile ssp=config.loadlist[i];
    logger.info((i + 1) + ""String_Node_Str"" + config.loadlist.length+ ""String_Node_Str""+ ssp.name+ ""String_Node_Str"");
    ProfileLoader.IProfileLoader loader=ProfileLoader.LOADERS.get(ssp.type.toLowerCase());
    if (loader == null) {
      logger.info(""String_Node_Str"" + ssp.type + ""String_Node_Str"");
      continue;
    }
    UserProfile profile=null;
    try {
      profile=loader.loadProfile(ssp,gameProfile);
    }
 catch (    Exception e) {
      logger.warning(""String_Node_Str"");
      logger.warning(e);
    }
    if (profile == null)     continue;
    logger.info(username + ""String_Node_Str"");
    profileCache.updateCache(username,profile);
    profileCache.setLoading(username,false);
    logger.info(profile.toString(profileCache.getExpiry(username)));
    return profile;
  }
  logger.info(username + ""String_Node_Str"");
  if (config.enableLocalProfileCache) {
    UserProfile profile=profileCache.getLocalProfile(username);
    if (profile == null)     logger.info(username + ""String_Node_Str"");
 else {
      profileCache.updateCache(username,profile,false);
      profileCache.setLoading(username,false);
      logger.info(username + ""String_Node_Str"");
      logger.info(profile.toString(profileCache.getExpiry(username)));
      return profile;
    }
  }
  profileCache.setLoading(username,false);
  return null;
}","public static UserProfile loadProfile0(GameProfile gameProfile){
  String username=gameProfile.getName();
  profileCache.setLoading(username,true);
  logger.info(""String_Node_Str"" + username + ""String_Node_Str"");
  if (config.loadlist == null || config.loadlist.isEmpty()) {
    logger.info(""String_Node_Str"");
    return null;
  }
  for (int i=0; i < config.loadlist.size(); i++) {
    SkinSiteProfile ssp=config.loadlist.get(i);
    logger.info((i + 1) + ""String_Node_Str"" + config.loadlist.size()+ ""String_Node_Str""+ ssp.name+ ""String_Node_Str"");
    ProfileLoader.IProfileLoader loader=ProfileLoader.LOADERS.get(ssp.type.toLowerCase());
    if (loader == null) {
      logger.info(""String_Node_Str"" + ssp.type + ""String_Node_Str"");
      continue;
    }
    UserProfile profile=null;
    try {
      profile=loader.loadProfile(ssp,gameProfile);
    }
 catch (    Exception e) {
      logger.warning(""String_Node_Str"");
      logger.warning(e);
    }
    if (profile == null)     continue;
    logger.info(username + ""String_Node_Str"");
    profileCache.updateCache(username,profile);
    profileCache.setLoading(username,false);
    logger.info(profile.toString(profileCache.getExpiry(username)));
    return profile;
  }
  logger.info(username + ""String_Node_Str"");
  if (config.enableLocalProfileCache) {
    UserProfile profile=profileCache.getLocalProfile(username);
    if (profile == null)     logger.info(username + ""String_Node_Str"");
 else {
      profileCache.updateCache(username,profile,false);
      profileCache.setLoading(username,false);
      logger.info(username + ""String_Node_Str"");
      logger.info(profile.toString(profileCache.getExpiry(username)));
      return profile;
    }
  }
  profileCache.setLoading(username,false);
  return null;
}",0.9551976573938508
32899,"private void loadExtraList(){
  File listAddition=new File(CustomSkinLoader.DATA_DIR,""String_Node_Str"");
  if (!listAddition.isDirectory()) {
    listAddition.mkdirs();
    return;
  }
  ArrayList<SkinSiteProfile> adds=new ArrayList<SkinSiteProfile>();
  File[] files=listAddition.listFiles();
  for (  File file : files) {
    if (!file.getName().toLowerCase().endsWith(""String_Node_Str"") && !file.getName().toLowerCase().endsWith(""String_Node_Str""))     continue;
    try {
      CustomSkinLoader.logger.info(""String_Node_Str"" + file.getName() + ""String_Node_Str"");
      String json=IOUtils.toString(new FileInputStream(file),Charsets.UTF_8);
      SkinSiteProfile ssp=CustomSkinLoader.GSON.fromJson(json,SkinSiteProfile.class);
      CustomSkinLoader.logger.info(""String_Node_Str"");
      file.delete();
      ProfileLoader.IProfileLoader loader=ProfileLoader.LOADERS.get(ssp.type.toLowerCase());
      if (loader == null) {
        CustomSkinLoader.logger.info(""String_Node_Str"" + ssp.type + ""String_Node_Str"");
        continue;
      }
      boolean duplicate=false;
      for (      SkinSiteProfile ssp0 : this.loadlist) {
        if (!ssp0.type.equalsIgnoreCase(ssp.type))         continue;
        if (loader.compare(ssp0,ssp)) {
          duplicate=true;
          break;
        }
      }
      if (!duplicate) {
        adds.add(ssp);
        CustomSkinLoader.logger.info(""String_Node_Str"" + ssp.name + ""String_Node_Str"");
      }
 else {
        CustomSkinLoader.logger.info(""String_Node_Str"" + ssp.name + ""String_Node_Str"");
      }
    }
 catch (    Exception e) {
      CustomSkinLoader.logger.info(""String_Node_Str"" + e.toString() + ""String_Node_Str"");
    }
  }
  if (adds.size() != 0) {
    this.loadlist=ArrayUtils.addAll((SkinSiteProfile[])adds.toArray(),this.loadlist);
    writeConfig(this,true);
  }
}","private void loadExtraList(){
  File listAddition=new File(CustomSkinLoader.DATA_DIR,""String_Node_Str"");
  if (!listAddition.isDirectory()) {
    listAddition.mkdirs();
    return;
  }
  List<SkinSiteProfile> adds=new ArrayList<SkinSiteProfile>();
  File[] files=listAddition.listFiles();
  for (  File file : files) {
    if (!file.getName().toLowerCase().endsWith(""String_Node_Str"") && !file.getName().toLowerCase().endsWith(""String_Node_Str""))     continue;
    try {
      CustomSkinLoader.logger.info(""String_Node_Str"" + file.getName() + ""String_Node_Str"");
      String json=FileUtils.readFileToString(file,Charsets.UTF_8);
      SkinSiteProfile ssp=CustomSkinLoader.GSON.fromJson(json,SkinSiteProfile.class);
      CustomSkinLoader.logger.info(""String_Node_Str"");
      file.delete();
      ProfileLoader.IProfileLoader loader=ProfileLoader.LOADERS.get(ssp.type.toLowerCase());
      if (loader == null) {
        CustomSkinLoader.logger.info(""String_Node_Str"" + ssp.type + ""String_Node_Str"");
        continue;
      }
      boolean duplicate=false;
      for (      SkinSiteProfile ssp0 : this.loadlist) {
        if (!ssp0.type.equalsIgnoreCase(ssp.type))         continue;
        if (loader.compare(ssp0,ssp)) {
          duplicate=true;
          break;
        }
      }
      if (!duplicate) {
        adds.add(ssp);
        CustomSkinLoader.logger.info(""String_Node_Str"" + ssp.name + ""String_Node_Str"");
      }
 else {
        CustomSkinLoader.logger.info(""String_Node_Str"" + ssp.name + ""String_Node_Str"");
      }
    }
 catch (    Exception e) {
      CustomSkinLoader.logger.info(""String_Node_Str"" + e.toString() + ""String_Node_Str"");
    }
  }
  if (adds.size() != 0) {
    adds.addAll(this.loadlist);
    this.loadlist=adds;
    writeConfig(this,true);
  }
}",0.9262340543538546
32900,"private static Config loadConfig(){
  CustomSkinLoader.logger.info(""String_Node_Str"" + CustomSkinLoader.CONFIG_FILE.getAbsolutePath());
  if (!CustomSkinLoader.CONFIG_FILE.exists()) {
    CustomSkinLoader.logger.info(""String_Node_Str"");
    return initConfig();
  }
  try {
    CustomSkinLoader.logger.info(""String_Node_Str"");
    String json=IOUtils.toString(new FileInputStream(CustomSkinLoader.CONFIG_FILE),Charsets.UTF_8);
    Config config=CustomSkinLoader.GSON.fromJson(json,Config.class);
    CustomSkinLoader.logger.info(""String_Node_Str"");
    return config;
  }
 catch (  Exception e) {
    CustomSkinLoader.logger.info(""String_Node_Str"" + e.toString() + ""String_Node_Str"");
    File brokenFile=new File(CustomSkinLoader.DATA_DIR,""String_Node_Str"");
    if (brokenFile.exists())     brokenFile.delete();
    CustomSkinLoader.CONFIG_FILE.renameTo(brokenFile);
    return initConfig();
  }
}","private static Config loadConfig(){
  CustomSkinLoader.logger.info(""String_Node_Str"" + CustomSkinLoader.CONFIG_FILE.getAbsolutePath());
  if (!CustomSkinLoader.CONFIG_FILE.exists()) {
    CustomSkinLoader.logger.info(""String_Node_Str"");
    return initConfig();
  }
  try {
    CustomSkinLoader.logger.info(""String_Node_Str"");
    String json=FileUtils.readFileToString(CustomSkinLoader.CONFIG_FILE,Charsets.UTF_8);
    Config config=CustomSkinLoader.GSON.fromJson(json,Config.class);
    CustomSkinLoader.logger.info(""String_Node_Str"");
    return config;
  }
 catch (  Exception e) {
    CustomSkinLoader.logger.info(""String_Node_Str"" + e.toString() + ""String_Node_Str"");
    File brokenFile=new File(CustomSkinLoader.DATA_DIR,""String_Node_Str"");
    if (brokenFile.exists())     brokenFile.delete();
    CustomSkinLoader.CONFIG_FILE.renameTo(brokenFile);
    return initConfig();
  }
}",0.9714605484051484
32901,"public Config(SkinSiteProfile[] loadlist){
  this.version=CustomSkinLoader.CustomSkinLoader_VERSION;
  this.loadlist=loadlist;
}","public Config(SkinSiteProfile[] loadlist){
  this.version=CustomSkinLoader.CustomSkinLoader_VERSION;
  this.loadlist=Arrays.asList(loadlist);
}",0.9446494464944648
32902,"private static void writeConfig(Config config,boolean update){
  String json=CustomSkinLoader.GSON.toJson(config);
  if (CustomSkinLoader.CONFIG_FILE.exists())   CustomSkinLoader.CONFIG_FILE.delete();
  try {
    CustomSkinLoader.CONFIG_FILE.createNewFile();
    IOUtils.write(json,new FileOutputStream(CustomSkinLoader.CONFIG_FILE),Charsets.UTF_8);
    CustomSkinLoader.logger.info(""String_Node_Str"" + (update ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
  }
 catch (  Exception e) {
    CustomSkinLoader.logger.info(""String_Node_Str"" + (update ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ e.toString()+ ""String_Node_Str"");
  }
}","private static void writeConfig(Config config,boolean update){
  String json=CustomSkinLoader.GSON.toJson(config);
  if (CustomSkinLoader.CONFIG_FILE.exists())   CustomSkinLoader.CONFIG_FILE.delete();
  try {
    CustomSkinLoader.CONFIG_FILE.createNewFile();
    FileUtils.write(CustomSkinLoader.CONFIG_FILE,json,Charsets.UTF_8);
    CustomSkinLoader.logger.info(""String_Node_Str"" + (update ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
  }
 catch (  Exception e) {
    CustomSkinLoader.logger.info(""String_Node_Str"" + (update ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ e.toString()+ ""String_Node_Str"");
  }
}",0.917557251908397
32903,"public static Config loadConfig0(){
  Config config=loadConfig();
  config.loadExtraList();
  config.initLocalFolder();
  if (config.ignoreHttpsCertificate)   HttpUtil0.ignoreHttpsCertificate();
  if (config.enableCacheAutoClean)   HttpRequestUtil.CACHE_DIR.delete();
  CustomSkinLoader.logger.info(""String_Node_Str"" + config.enable + ""String_Node_Str""+ config.enableSkull+ ""String_Node_Str""+ config.enableDynamicSkull+ ""String_Node_Str""+ config.enableTransparentSkin+ ""String_Node_Str""+ config.ignoreHttpsCertificate+ ""String_Node_Str""+ config.cacheExpiry+ ""String_Node_Str""+ config.enableUpdateSkull+ ""String_Node_Str""+ config.enableLocalProfileCache+ ""String_Node_Str""+ config.enableCacheAutoClean+ ""String_Node_Str""+ (config.loadlist == null ? 0 : config.loadlist.length));
  float floatVersion=0f;
  float configVersion=0f;
  try {
    floatVersion=Float.parseFloat(CustomSkinLoader.CustomSkinLoader_VERSION);
    configVersion=Float.parseFloat(config.version);
  }
 catch (  Exception e) {
    CustomSkinLoader.logger.warning(""String_Node_Str"" + e.toString());
  }
  if (config.version == null || configVersion == 0f || floatVersion > configVersion) {
    CustomSkinLoader.logger.info(""String_Node_Str"" + config.version);
    config.version=CustomSkinLoader.CustomSkinLoader_VERSION;
    writeConfig(config,true);
  }
  return config;
}","public static Config loadConfig0(){
  Config config=loadConfig();
  if (config.loadlist == null) {
    config.loadlist=new ArrayList<SkinSiteProfile>();
  }
 else {
    for (int i=0; i < config.loadlist.size(); i++) {
      if (config.loadlist.get(i) == null)       config.loadlist.remove(i--);
    }
  }
  config.loadExtraList();
  config.initLocalFolder();
  if (config.ignoreHttpsCertificate)   HttpUtil0.ignoreHttpsCertificate();
  if (config.enableCacheAutoClean && !config.enableLocalProfileCache) {
    HttpRequestUtil.CACHE_DIR.delete();
    HttpTextureUtil.cleanCacheDir();
  }
  CustomSkinLoader.logger.info(""String_Node_Str"" + config.enable + ""String_Node_Str""+ config.enableSkull+ ""String_Node_Str""+ config.enableDynamicSkull+ ""String_Node_Str""+ config.enableTransparentSkin+ ""String_Node_Str""+ config.ignoreHttpsCertificate+ ""String_Node_Str""+ config.cacheExpiry+ ""String_Node_Str""+ config.enableUpdateSkull+ ""String_Node_Str""+ config.enableLocalProfileCache+ ""String_Node_Str""+ config.enableCacheAutoClean+ ""String_Node_Str""+ (config.loadlist == null ? 0 : config.loadlist.size()));
  float floatVersion=0f;
  float configVersion=0f;
  try {
    floatVersion=Float.parseFloat(CustomSkinLoader.CustomSkinLoader_VERSION);
    configVersion=Float.parseFloat(config.version);
  }
 catch (  Exception e) {
    CustomSkinLoader.logger.warning(""String_Node_Str"" + e.toString());
  }
  if (config.version == null || configVersion == 0f || floatVersion > configVersion) {
    CustomSkinLoader.logger.info(""String_Node_Str"" + config.version);
    config.version=CustomSkinLoader.CustomSkinLoader_VERSION;
    writeConfig(config,true);
  }
  return config;
}",0.8891108891108891
32904,"@Override public BufferedImage parseUserSkin(BufferedImage image){
  if (image == null)   return null;
  ratio=image.getWidth() / 64;
  BufferedImage bufferedimage=new BufferedImage(64 * ratio,64 * ratio,2);
  Graphics graphics=bufferedimage.getGraphics();
  graphics.setColor(new Color(0,0,0,0));
  graphics.fillRect(0,0,64,64);
  graphics.drawImage(image,0,0,(ImageObserver)null);
  if (image.getHeight() == 32 * ratio) {
    graphics.drawImage(bufferedimage,32 * ratio,48 * ratio,16 * ratio,64 * ratio,0 * ratio,16 * ratio,16 * ratio,32 * ratio,(ImageObserver)null);
    graphics.drawImage(bufferedimage,48 * ratio,48 * ratio,32 * ratio,64 * ratio,40 * ratio,16 * ratio,56 * ratio,32 * ratio,(ImageObserver)null);
  }
  graphics.dispose();
  this.imageData=((DataBufferInt)bufferedimage.getRaster().getDataBuffer()).getData();
  setAreaDueToConfig(0 * ratio,0 * ratio,32 * ratio,16 * ratio);
  setAreaTransparent(32 * ratio,0 * ratio,64 * ratio,16 * ratio);
  setAreaDueToConfig(0 * ratio,16 * ratio,16 * ratio,32 * ratio);
  setAreaDueToConfig(16 * ratio,16 * ratio,40 * ratio,32 * ratio);
  setAreaDueToConfig(40 * ratio,16 * ratio,56 * ratio,32 * ratio);
  setAreaTransparent(0 * ratio,32 * ratio,16 * ratio,48 * ratio);
  setAreaTransparent(16 * ratio,32 * ratio,40 * ratio,48 * ratio);
  setAreaTransparent(40 * ratio,32 * ratio,56 * ratio,48 * ratio);
  setAreaTransparent(0 * ratio,48 * ratio,16 * ratio,64 * ratio);
  setAreaDueToConfig(16 * ratio,48 * ratio,32 * ratio,64 * ratio);
  setAreaDueToConfig(32 * ratio,48 * ratio,48 * ratio,64 * ratio);
  setAreaTransparent(48 * ratio,48 * ratio,64 * ratio,64 * ratio);
  return bufferedimage;
}","@Override public BufferedImage parseUserSkin(BufferedImage image){
  if (image == null)   return null;
  ratio=image.getWidth() / 64;
  BufferedImage bufferedimage=new BufferedImage(64 * ratio,64 * ratio,2);
  Graphics graphics=bufferedimage.getGraphics();
  graphics.setColor(new Color(0,0,0,0));
  graphics.fillRect(0,0,64,64);
  graphics.drawImage(image,0,0,(ImageObserver)null);
  if (image.getHeight() == 32 * ratio) {
    graphics.drawImage(bufferedimage,24 * ratio,48 * ratio,20 * ratio,52 * ratio,4 * ratio,16 * ratio,8 * ratio,20 * ratio,(ImageObserver)null);
    graphics.drawImage(bufferedimage,28 * ratio,48 * ratio,24 * ratio,52 * ratio,8 * ratio,16 * ratio,12 * ratio,20 * ratio,(ImageObserver)null);
    graphics.drawImage(bufferedimage,20 * ratio,52 * ratio,16 * ratio,64 * ratio,8 * ratio,20 * ratio,12 * ratio,32 * ratio,(ImageObserver)null);
    graphics.drawImage(bufferedimage,24 * ratio,52 * ratio,20 * ratio,64 * ratio,4 * ratio,20 * ratio,8 * ratio,32 * ratio,(ImageObserver)null);
    graphics.drawImage(bufferedimage,28 * ratio,52 * ratio,24 * ratio,64 * ratio,0 * ratio,20 * ratio,4 * ratio,32 * ratio,(ImageObserver)null);
    graphics.drawImage(bufferedimage,32 * ratio,52 * ratio,28 * ratio,64 * ratio,12 * ratio,20 * ratio,16 * ratio,32 * ratio,(ImageObserver)null);
    graphics.drawImage(bufferedimage,40 * ratio,48 * ratio,36 * ratio,52 * ratio,44 * ratio,16 * ratio,48 * ratio,20 * ratio,(ImageObserver)null);
    graphics.drawImage(bufferedimage,44 * ratio,48 * ratio,40 * ratio,52 * ratio,48 * ratio,16 * ratio,52 * ratio,20 * ratio,(ImageObserver)null);
    graphics.drawImage(bufferedimage,36 * ratio,52 * ratio,32 * ratio,64 * ratio,48 * ratio,20 * ratio,52 * ratio,32 * ratio,(ImageObserver)null);
    graphics.drawImage(bufferedimage,40 * ratio,52 * ratio,36 * ratio,64 * ratio,44 * ratio,20 * ratio,48 * ratio,32 * ratio,(ImageObserver)null);
    graphics.drawImage(bufferedimage,44 * ratio,52 * ratio,40 * ratio,64 * ratio,40 * ratio,20 * ratio,44 * ratio,32 * ratio,(ImageObserver)null);
    graphics.drawImage(bufferedimage,48 * ratio,52 * ratio,44 * ratio,64 * ratio,52 * ratio,20 * ratio,56 * ratio,32 * ratio,(ImageObserver)null);
  }
  graphics.dispose();
  this.imageData=((DataBufferInt)bufferedimage.getRaster().getDataBuffer()).getData();
  setAreaDueToConfig(0 * ratio,0 * ratio,32 * ratio,16 * ratio);
  setAreaTransparent(32 * ratio,0 * ratio,64 * ratio,16 * ratio);
  setAreaDueToConfig(0 * ratio,16 * ratio,16 * ratio,32 * ratio);
  setAreaDueToConfig(16 * ratio,16 * ratio,40 * ratio,32 * ratio);
  setAreaDueToConfig(40 * ratio,16 * ratio,56 * ratio,32 * ratio);
  setAreaTransparent(0 * ratio,32 * ratio,16 * ratio,48 * ratio);
  setAreaTransparent(16 * ratio,32 * ratio,40 * ratio,48 * ratio);
  setAreaTransparent(40 * ratio,32 * ratio,56 * ratio,48 * ratio);
  setAreaTransparent(0 * ratio,48 * ratio,16 * ratio,64 * ratio);
  setAreaDueToConfig(16 * ratio,48 * ratio,32 * ratio,64 * ratio);
  setAreaDueToConfig(32 * ratio,48 * ratio,48 * ratio,64 * ratio);
  setAreaTransparent(48 * ratio,48 * ratio,64 * ratio,64 * ratio);
  return bufferedimage;
}",0.651708953659048
32905,"public static Config loadConfig0(){
  Config config=loadConfig();
  config.loadExtraList();
  config.initLocalFolder();
  CustomSkinLoader.logger.info(""String_Node_Str"" + config.enable + ""String_Node_Str""+ config.enableSkull+ ""String_Node_Str""+ config.enableTransparentSkin+ ""String_Node_Str""+ config.cacheExpiry+ ""String_Node_Str""+ config.enableUpdateSkull+ ""String_Node_Str""+ config.enableLocalProfileCache+ ""String_Node_Str""+ (config.loadlist == null ? 0 : config.loadlist.length));
  float floatVersion=0f;
  float configVersion=0f;
  try {
    floatVersion=Float.parseFloat(CustomSkinLoader.CustomSkinLoader_VERSION);
    configVersion=Float.parseFloat(config.version);
  }
 catch (  Exception e) {
    CustomSkinLoader.logger.warning(""String_Node_Str"" + e.toString());
  }
  if (config.version == null || configVersion == 0f || floatVersion > configVersion) {
    CustomSkinLoader.logger.info(""String_Node_Str"" + config.version);
    config.version=CustomSkinLoader.CustomSkinLoader_VERSION;
    writeConfig(config,true);
  }
  return config;
}","public static Config loadConfig0(){
  Config config=loadConfig();
  config.loadExtraList();
  config.initLocalFolder();
  CustomSkinLoader.logger.info(""String_Node_Str"" + config.enable + ""String_Node_Str""+ config.enableSkull+ ""String_Node_Str""+ config.enableDynamicSkull+ ""String_Node_Str""+ config.enableTransparentSkin+ ""String_Node_Str""+ config.cacheExpiry+ ""String_Node_Str""+ config.enableUpdateSkull+ ""String_Node_Str""+ config.enableLocalProfileCache+ ""String_Node_Str""+ (config.loadlist == null ? 0 : config.loadlist.length));
  float floatVersion=0f;
  float configVersion=0f;
  try {
    floatVersion=Float.parseFloat(CustomSkinLoader.CustomSkinLoader_VERSION);
    configVersion=Float.parseFloat(config.version);
  }
 catch (  Exception e) {
    CustomSkinLoader.logger.warning(""String_Node_Str"" + e.toString());
  }
  if (config.version == null || configVersion == 0f || floatVersion > configVersion) {
    CustomSkinLoader.logger.info(""String_Node_Str"" + config.version);
    config.version=CustomSkinLoader.CustomSkinLoader_VERSION;
    writeConfig(config,true);
  }
  return config;
}",0.97856477166822
32906,"public Map<Type,MinecraftProfileTexture> getTexture(final GameProfile profile){
  if (staticTextures.get(profile) != null)   return staticTextures.get(profile);
  if (loadingList.contains(profile))   return new HashMap();
  if (dynamicTextures.containsKey(profile)) {
    SkullTexture texture=dynamicTextures.get(profile);
    long time=System.currentTimeMillis() - texture.startTime;
    int index=(int)Math.floor((time % texture.period) / texture.skins.size());
    Map<Type,MinecraftProfileTexture> map=Maps.newHashMap();
    map.put(Type.SKIN,ModelManager0.getProfileTexture(texture.skins.get(index),null));
    return map;
  }
  loadingList.add(profile);
  Thread loadThread=new Thread(){
    public void run(){
      parseGameProfile(profile);
      loadingList.remove(profile);
    }
  }
;
  loadThread.setName(profile.toString() + ""String_Node_Str"");
  loadThread.start();
  return new HashMap();
}","public Map<Type,MinecraftProfileTexture> getTexture(final GameProfile profile){
  if (staticTextures.get(profile) != null)   return staticTextures.get(profile);
  if (loadingList.contains(profile))   return new HashMap();
  if (dynamicTextures.containsKey(profile)) {
    SkullTexture texture=dynamicTextures.get(profile);
    long time=System.currentTimeMillis() - texture.startTime;
    int index=(int)Math.floor((time % texture.period) / texture.interval);
    Map<Type,MinecraftProfileTexture> map=Maps.newHashMap();
    map.put(Type.SKIN,ModelManager0.getProfileTexture(texture.skins.get(index),null));
    return map;
  }
  loadingList.add(profile);
  Thread loadThread=new Thread(){
    public void run(){
      parseGameProfile(profile);
      loadingList.remove(profile);
    }
  }
;
  loadThread.setName(""String_Node_Str"" + profile.toString());
  loadThread.start();
  return new HashMap();
}",0.96570796460177
32907,"public void acceptOptions(List args,File gameDir,File assetsDir,String profile){
  MinecraftUtil.minecraftDataFolder=gameDir;
  File tweakerLogFile=new File(MinecraftUtil.getMinecraftDataDir(),""String_Node_Str"");
  logger=new Logger(tweakerLogFile);
  logger.info(""String_Node_Str"");
  logger.info(""String_Node_Str"");
  String[] temp={""String_Node_Str"",gameDir.getAbsolutePath(),""String_Node_Str"",assetsDir.getAbsolutePath(),""String_Node_Str"",profile};
  this.args=ArrayUtils.addAll((String[])args.toArray(),temp);
}","public void acceptOptions(List<String> args,File gameDir,File assetsDir,String profile){
  MinecraftUtil.minecraftDataFolder=gameDir;
  File tweakerLogFile=new File(MinecraftUtil.getMinecraftDataDir(),""String_Node_Str"");
  logger=new Logger(tweakerLogFile);
  logger.info(""String_Node_Str"");
  logger.info(""String_Node_Str"");
  String[] temp={""String_Node_Str"",gameDir.getAbsolutePath(),""String_Node_Str"",assetsDir.getAbsolutePath(),""String_Node_Str"",profile};
  this.args=ArrayUtils.addAll(args.toArray(new String[args.size()]),temp);
}",0.9515669515669516
32908,"public BufferedImage parseUserSkin(BufferedImage image){
  if (image == null) {
    return null;
  }
 else {
    int ratio=image.getWidth() / 64;
    this.imageWidth=64 * ratio;
    this.imageHeight=64 * ratio;
    BufferedImage bufferedimage=new BufferedImage(this.imageWidth,this.imageHeight,2);
    Graphics graphics=bufferedimage.getGraphics();
    graphics.drawImage(image,0,0,(ImageObserver)null);
    boolean flag=image.getHeight() == 32;
    if (flag) {
      if (!customskinloader.CustomSkinLoader.config.enableTransparentSkin) {
        graphics.setColor(new Color(0,0,0,0));
        graphics.fillRect(0,32,64,32);
      }
      graphics.drawImage(bufferedimage,24 * ratio,48 * ratio,20 * ratio,52 * ratio,4 * ratio,16 * ratio,8 * ratio,20 * ratio,(ImageObserver)null);
      graphics.drawImage(bufferedimage,28 * ratio,48 * ratio,24 * ratio,52 * ratio,8 * ratio,16 * ratio,12 * ratio,20 * ratio,(ImageObserver)null);
      graphics.drawImage(bufferedimage,20 * ratio,52 * ratio,16 * ratio,64 * ratio,8 * ratio,20 * ratio,12 * ratio,32 * ratio,(ImageObserver)null);
      graphics.drawImage(bufferedimage,24 * ratio,52 * ratio,20 * ratio,64 * ratio,4 * ratio,20 * ratio,8 * ratio,32 * ratio,(ImageObserver)null);
      graphics.drawImage(bufferedimage,28 * ratio,52 * ratio,24 * ratio,64 * ratio,0 * ratio,20 * ratio,4 * ratio,32 * ratio,(ImageObserver)null);
      graphics.drawImage(bufferedimage,32 * ratio,52 * ratio,28 * ratio,64 * ratio,12 * ratio,20 * ratio,16 * ratio,32 * ratio,(ImageObserver)null);
      graphics.drawImage(bufferedimage,40 * ratio,48 * ratio,36 * ratio,52 * ratio,44 * ratio,16 * ratio,48 * ratio,20 * ratio,(ImageObserver)null);
      graphics.drawImage(bufferedimage,44 * ratio,48 * ratio,40 * ratio,52 * ratio,48 * ratio,16 * ratio,52 * ratio,20 * ratio,(ImageObserver)null);
      graphics.drawImage(bufferedimage,36 * ratio,52 * ratio,32 * ratio,64 * ratio,48 * ratio,20 * ratio,52 * ratio,32 * ratio,(ImageObserver)null);
      graphics.drawImage(bufferedimage,40 * ratio,52 * ratio,36 * ratio,64 * ratio,44 * ratio,20 * ratio,48 * ratio,32 * ratio,(ImageObserver)null);
      graphics.drawImage(bufferedimage,44 * ratio,52 * ratio,40 * ratio,64 * ratio,40 * ratio,20 * ratio,44 * ratio,32 * ratio,(ImageObserver)null);
      graphics.drawImage(bufferedimage,48 * ratio,52 * ratio,44 * ratio,64 * ratio,52 * ratio,20 * ratio,56 * ratio,32 * ratio,(ImageObserver)null);
    }
    graphics.dispose();
    this.imageData=((DataBufferInt)bufferedimage.getRaster().getDataBuffer()).getData();
    if (!customskinloader.CustomSkinLoader.config.enableTransparentSkin) {
      this.setAreaOpaque(0,0,32,16);
      if (flag) {
        this.func_189559_a(32,0,64,32);
      }
      this.setAreaOpaque(0,16,64,32);
      this.setAreaOpaque(16,48,48,64);
    }
    return bufferedimage;
  }
}","public BufferedImage parseUserSkin(BufferedImage image){
  if (image == null) {
    return null;
  }
 else {
    int ratio=image.getWidth() / 64;
    this.imageWidth=64 * ratio;
    this.imageHeight=64 * ratio;
    BufferedImage bufferedimage=new BufferedImage(this.imageWidth,this.imageHeight,2);
    Graphics graphics=bufferedimage.getGraphics();
    graphics.drawImage(image,0,0,(ImageObserver)null);
    boolean flag=image.getHeight() == 32 * ratio;
    if (flag) {
      if (!customskinloader.CustomSkinLoader.config.enableTransparentSkin) {
        graphics.setColor(new Color(0,0,0,0));
        graphics.fillRect(0,32,64,32);
      }
      graphics.drawImage(bufferedimage,24 * ratio,48 * ratio,20 * ratio,52 * ratio,4 * ratio,16 * ratio,8 * ratio,20 * ratio,(ImageObserver)null);
      graphics.drawImage(bufferedimage,28 * ratio,48 * ratio,24 * ratio,52 * ratio,8 * ratio,16 * ratio,12 * ratio,20 * ratio,(ImageObserver)null);
      graphics.drawImage(bufferedimage,20 * ratio,52 * ratio,16 * ratio,64 * ratio,8 * ratio,20 * ratio,12 * ratio,32 * ratio,(ImageObserver)null);
      graphics.drawImage(bufferedimage,24 * ratio,52 * ratio,20 * ratio,64 * ratio,4 * ratio,20 * ratio,8 * ratio,32 * ratio,(ImageObserver)null);
      graphics.drawImage(bufferedimage,28 * ratio,52 * ratio,24 * ratio,64 * ratio,0 * ratio,20 * ratio,4 * ratio,32 * ratio,(ImageObserver)null);
      graphics.drawImage(bufferedimage,32 * ratio,52 * ratio,28 * ratio,64 * ratio,12 * ratio,20 * ratio,16 * ratio,32 * ratio,(ImageObserver)null);
      graphics.drawImage(bufferedimage,40 * ratio,48 * ratio,36 * ratio,52 * ratio,44 * ratio,16 * ratio,48 * ratio,20 * ratio,(ImageObserver)null);
      graphics.drawImage(bufferedimage,44 * ratio,48 * ratio,40 * ratio,52 * ratio,48 * ratio,16 * ratio,52 * ratio,20 * ratio,(ImageObserver)null);
      graphics.drawImage(bufferedimage,36 * ratio,52 * ratio,32 * ratio,64 * ratio,48 * ratio,20 * ratio,52 * ratio,32 * ratio,(ImageObserver)null);
      graphics.drawImage(bufferedimage,40 * ratio,52 * ratio,36 * ratio,64 * ratio,44 * ratio,20 * ratio,48 * ratio,32 * ratio,(ImageObserver)null);
      graphics.drawImage(bufferedimage,44 * ratio,52 * ratio,40 * ratio,64 * ratio,40 * ratio,20 * ratio,44 * ratio,32 * ratio,(ImageObserver)null);
      graphics.drawImage(bufferedimage,48 * ratio,52 * ratio,44 * ratio,64 * ratio,52 * ratio,20 * ratio,56 * ratio,32 * ratio,(ImageObserver)null);
    }
    graphics.dispose();
    this.imageData=((DataBufferInt)bufferedimage.getRaster().getDataBuffer()).getData();
    if (!customskinloader.CustomSkinLoader.config.enableTransparentSkin) {
      this.setAreaOpaque(0,0,32,16);
      if (flag) {
        this.func_189559_a(32,0,64,32);
      }
      this.setAreaOpaque(0,16,64,32);
      this.setAreaOpaque(16,48,48,64);
    }
    return bufferedimage;
  }
}",0.9985855728429984
32909,"public void warning(Exception e){
  log(Level.WARNING,""String_Node_Str"" + e.getMessage());
  StackTraceElement[] stes=e.getStackTrace();
  for (  StackTraceElement ste : stes) {
    log(Level.WARNING,ste.toString());
  }
  log(Level.WARNING,""String_Node_Str"");
}","public void warning(Exception e){
  log(Level.WARNING,""String_Node_Str"" + e.toString());
  StackTraceElement[] stes=e.getStackTrace();
  for (  StackTraceElement ste : stes) {
    log(Level.WARNING,ste.toString());
  }
  log(Level.WARNING,""String_Node_Str"");
}",0.9655172413793104
32910,"private static ZipFile getZipFile(URL url){
  if (MinecraftUtil.isCoreFile(url))   return null;
  ZipFile zipFile0;
  try {
    File file=new File(url.toURI());
    zipFile0=new ZipFile(file);
    return zipFile0;
  }
 catch (  Exception e) {
    ModSystemTweaker.logger.warning(e);
  }
  return null;
}","private static ZipFile getZipFile(URL url){
  if (MinecraftUtil.isCoreFile(url))   return null;
  ZipFile zipFile0=null;
  try {
    File file=new File(url.toURI());
    if (!file.exists() || !file.isFile())     return null;
    zipFile0=new ZipFile(file);
    return zipFile0;
  }
 catch (  Exception e) {
    ModSystemTweaker.logger.warning(e);
  }
  return null;
}",0.9044776119402984
32911,"/** 
 * May download the skin if its not in the cache, can be passed a SkinManager#SkinAvailableCallback for handling
 */
public ResourceLocation loadSkin(final MinecraftProfileTexture profileTexture,final Type textureType,@Nullable final SkinManager.SkinAvailableCallback skinAvailableCallback){
  customskinloader.utils.HttpTextureUtil.HttpTextureInfo info=customskinloader.utils.HttpTextureUtil.toHttpTextureInfo(this.skinCacheDir,profileTexture.getUrl());
  final ResourceLocation resourcelocation=new ResourceLocation(""String_Node_Str"" + info.hash);
  ITextureObject itextureobject=this.textureManager.getTexture(resourcelocation);
  if (itextureobject != null) {
    if (skinAvailableCallback != null) {
      skinAvailableCallback.skinAvailable(textureType,resourcelocation,profileTexture);
    }
  }
 else {
    final IImageBuffer iimagebuffer=textureType == Type.SKIN ? new ImageBufferDownload() : null;
    ThreadDownloadImageData threaddownloadimagedata=new ThreadDownloadImageData(info.cacheFile,info.url,DefaultPlayerSkin.getDefaultSkinLegacy(),new IImageBuffer(){
      public BufferedImage parseUserSkin(      BufferedImage image){
        if (iimagebuffer != null) {
          image=iimagebuffer.parseUserSkin(image);
        }
        return image;
      }
      public void skinAvailable(){
        if (iimagebuffer != null) {
          iimagebuffer.skinAvailable();
        }
        if (skinAvailableCallback != null) {
          skinAvailableCallback.skinAvailable(textureType,resourcelocation,profileTexture);
        }
      }
    }
);
    this.textureManager.loadTexture(resourcelocation,threaddownloadimagedata);
  }
  return resourcelocation;
}","/** 
 * May download the skin if its not in the cache, can be passed a SkinManager#SkinAvailableCallback for handling
 */
public ResourceLocation loadSkin(final MinecraftProfileTexture profileTexture,final Type textureType,@Nullable final SkinManager.SkinAvailableCallback skinAvailableCallback){
  customskinloader.utils.HttpTextureUtil.HttpTextureInfo info=customskinloader.utils.HttpTextureUtil.toHttpTextureInfo(this.skinCacheDir,profileTexture.getUrl());
  final ResourceLocation resourcelocation=new ResourceLocation(""String_Node_Str"" + info.hash);
  ITextureObject itextureobject=this.textureManager.getTexture(resourcelocation);
  if (itextureobject != null) {
    if (skinAvailableCallback != null) {
      skinAvailableCallback.skinAvailable(textureType,resourcelocation,profileTexture);
    }
  }
 else {
    final IImageBuffer iimagebuffer=textureType == Type.SKIN ? new customskinloader.renderer.SkinBuffer() : null;
    ThreadDownloadImageData threaddownloadimagedata=new ThreadDownloadImageData(info.cacheFile,info.url,DefaultPlayerSkin.getDefaultSkinLegacy(),new IImageBuffer(){
      public BufferedImage parseUserSkin(      BufferedImage image){
        if (iimagebuffer != null) {
          image=iimagebuffer.parseUserSkin(image);
        }
        return image;
      }
      public void skinAvailable(){
        if (iimagebuffer != null) {
          iimagebuffer.skinAvailable();
        }
        if (skinAvailableCallback != null) {
          skinAvailableCallback.skinAvailable(textureType,resourcelocation,profileTexture);
        }
      }
    }
);
    this.textureManager.loadTexture(resourcelocation,threaddownloadimagedata);
  }
  return resourcelocation;
}",0.987190944295502
32912,"/** 
 * May download the skin if its not in the cache, can be passed a SkinManager#SkinAvailableCallback for handling
 */
public ResourceLocation loadSkin(MinecraftProfileTexture p_152789_1_,final Type p_152789_2_,final SkinManager.SkinAvailableCallback p_152789_3_){
  customskinloader.utils.HttpTextureUtil.HttpTextureInfo info=customskinloader.utils.HttpTextureUtil.toHttpTextureInfo(this.skinCacheDir,p_152789_1_.getUrl());
  final ResourceLocation var4=new ResourceLocation(""String_Node_Str"" + info.hash);
  ITextureObject var5=this.textureManager.getTexture(var4);
  if (var5 != null) {
    if (p_152789_3_ != null) {
      p_152789_3_.onSkinAvailable(p_152789_2_,var4);
    }
  }
 else {
    final ImageBufferDownload var8=p_152789_2_ == Type.SKIN ? new ImageBufferDownload() : null;
    ThreadDownloadImageData var9=new ThreadDownloadImageData(info.cacheFile,info.url,DEFAULT_SKIN,new IImageBuffer(){
      private static final String __OBFID=""String_Node_Str"";
      public BufferedImage parseUserSkin(      BufferedImage p_78432_1_){
        if (var8 != null) {
          p_78432_1_=var8.parseUserSkin(p_78432_1_);
        }
        return p_78432_1_;
      }
      public void func_152634_a(){
        if (var8 != null) {
          var8.func_152634_a();
        }
        if (p_152789_3_ != null) {
          p_152789_3_.onSkinAvailable(p_152789_2_,var4);
        }
      }
    }
);
    this.textureManager.loadTexture(var4,var9);
  }
  return var4;
}","/** 
 * May download the skin if its not in the cache, can be passed a SkinManager#SkinAvailableCallback for handling
 */
public ResourceLocation loadSkin(MinecraftProfileTexture p_152789_1_,final Type p_152789_2_,final SkinManager.SkinAvailableCallback p_152789_3_){
  customskinloader.utils.HttpTextureUtil.HttpTextureInfo info=customskinloader.utils.HttpTextureUtil.toHttpTextureInfo(this.skinCacheDir,p_152789_1_.getUrl());
  final ResourceLocation var4=new ResourceLocation(""String_Node_Str"" + info.hash);
  ITextureObject var5=this.textureManager.getTexture(var4);
  if (var5 != null) {
    if (p_152789_3_ != null) {
      p_152789_3_.onSkinAvailable(p_152789_2_,var4);
    }
  }
 else {
    final ImageBufferDownload var8=p_152789_2_ == Type.SKIN ? new customskinloader.renderer.SkinBuffer() : null;
    ThreadDownloadImageData var9=new ThreadDownloadImageData(info.cacheFile,info.url,DEFAULT_SKIN,new IImageBuffer(){
      private static final String __OBFID=""String_Node_Str"";
      public BufferedImage parseUserSkin(      BufferedImage p_78432_1_){
        if (var8 != null) {
          p_78432_1_=var8.parseUserSkin(p_78432_1_);
        }
        return p_78432_1_;
      }
      public void func_152634_a(){
        if (var8 != null) {
          var8.func_152634_a();
        }
        if (p_152789_3_ != null) {
          p_152789_3_.onSkinAvailable(p_152789_2_,var4);
        }
      }
    }
);
    this.textureManager.loadTexture(var4,var9);
  }
  return var4;
}",0.9860591635498128
32913,"/** 
 * May download the skin if its not in the cache, can be passed a SkinManager#SkinAvailableCallback for handling
 */
public ResourceLocation loadSkin(final MinecraftProfileTexture profileTexture,final Type p_152789_2_,final SkinManager.SkinAvailableCallback skinAvailableCallback){
  customskinloader.utils.HttpTextureUtil.HttpTextureInfo info=customskinloader.utils.HttpTextureUtil.toHttpTextureInfo(this.skinCacheDir,profileTexture.getUrl());
  final ResourceLocation var4=new ResourceLocation(""String_Node_Str"" + info.hash);
  ITextureObject var5=this.textureManager.getTexture(var4);
  if (var5 != null) {
    if (skinAvailableCallback != null) {
      skinAvailableCallback.skinAvailable(p_152789_2_,var4,profileTexture);
    }
  }
 else {
    final ImageBufferDownload var8=p_152789_2_ == Type.SKIN ? new ImageBufferDownload() : null;
    ThreadDownloadImageData var9=new ThreadDownloadImageData(info.cacheFile,info.url,DefaultPlayerSkin.getDefaultSkinLegacy(),new IImageBuffer(){
      private static final String __OBFID=""String_Node_Str"";
      public BufferedImage parseUserSkin(      BufferedImage image){
        if (var8 != null) {
          image=var8.parseUserSkin(image);
        }
        return image;
      }
      public void skinAvailable(){
        if (var8 != null) {
          var8.skinAvailable();
        }
        if (skinAvailableCallback != null) {
          skinAvailableCallback.skinAvailable(p_152789_2_,var4,profileTexture);
        }
      }
    }
);
    this.textureManager.loadTexture(var4,var9);
  }
  return var4;
}","/** 
 * May download the skin if its not in the cache, can be passed a SkinManager#SkinAvailableCallback for handling
 */
public ResourceLocation loadSkin(final MinecraftProfileTexture profileTexture,final Type p_152789_2_,final SkinManager.SkinAvailableCallback skinAvailableCallback){
  customskinloader.utils.HttpTextureUtil.HttpTextureInfo info=customskinloader.utils.HttpTextureUtil.toHttpTextureInfo(this.skinCacheDir,profileTexture.getUrl());
  final ResourceLocation var4=new ResourceLocation(""String_Node_Str"" + info.hash);
  ITextureObject var5=this.textureManager.getTexture(var4);
  if (var5 != null) {
    if (skinAvailableCallback != null) {
      skinAvailableCallback.skinAvailable(p_152789_2_,var4,profileTexture);
    }
  }
 else {
    final ImageBufferDownload var8=p_152789_2_ == Type.SKIN ? new customskinloader.renderer.SkinBuffer() : null;
    ThreadDownloadImageData var9=new ThreadDownloadImageData(info.cacheFile,info.url,DefaultPlayerSkin.getDefaultSkinLegacy(),new IImageBuffer(){
      private static final String __OBFID=""String_Node_Str"";
      public BufferedImage parseUserSkin(      BufferedImage image){
        if (var8 != null) {
          image=var8.parseUserSkin(image);
        }
        return image;
      }
      public void skinAvailable(){
        if (var8 != null) {
          var8.skinAvailable();
        }
        if (skinAvailableCallback != null) {
          skinAvailableCallback.skinAvailable(p_152789_2_,var4,profileTexture);
        }
      }
    }
);
    this.textureManager.loadTexture(var4,var9);
  }
  return var4;
}",0.9869135014363232
32914,"private static Logger initLogger(){
  Logger logger=new Logger(LOG_FILE);
  logger.info(""String_Node_Str"" + CustomSkinLoader_VERSION);
  logger.info(""String_Node_Str"" + LOG_FILE.getAbsolutePath());
  return logger;
}","private static Logger initLogger(){
  Logger logger=new Logger(LOG_FILE);
  logger.info(""String_Node_Str"" + CustomSkinLoader_VERSION);
  logger.info(""String_Node_Str"" + DATA_DIR.getAbsolutePath());
  logger.info(""String_Node_Str"" + MinecraftUtil.getMinecraftVersion());
  return logger;
}",0.8293650793650794
32915,"@Override public UserProfile loadProfile(SkinSiteProfile ssp,String username) throws Exception {
  if (ssp.root == null || ssp.root.equals(""String_Node_Str"")) {
    CustomSkinLoader.logger.info(""String_Node_Str"");
    return null;
  }
  String json=HttpUtil0.readHttp(ssp.root + username + ""String_Node_Str"");
  if (json == null || json.equals(""String_Node_Str"")) {
    CustomSkinLoader.logger.info(""String_Node_Str"");
    return null;
  }
  CustomSkinAPI profile=new Gson().fromJson(json,CustomSkinAPI.class);
  UserProfile p=new UserProfile();
  if (profile.skins != null && !profile.skins.isEmpty()) {
    Set<String> keys=profile.skins.keySet();
    for (    String s : keys) {
      if (ModelManager.checkModel(s)) {
        p.skinUrl=ssp.root + TEXTURES + profile.skins.get(s);
        p.model=s;
        break;
      }
    }
    if (p.skinUrl == null) {
      p.skinUrl=ssp.root + TEXTURES + profile.skins.get(keys.toArray()[0]);
      p.model=""String_Node_Str"";
    }
  }
 else   if (profile.skin != null && !profile.skin.equals(""String_Node_Str"")) {
    p.skinUrl=ssp.root + TEXTURES + profile.skin;
  }
  if (profile.cape != null && !profile.cape.equals(""String_Node_Str"")) {
    p.capeUrl=ssp.root + TEXTURES + profile.cape;
  }
  if (p.isEmpty()) {
    CustomSkinLoader.logger.info(""String_Node_Str"");
    return null;
  }
 else {
    return p;
  }
}","@Override public UserProfile loadProfile(SkinSiteProfile ssp,String username) throws Exception {
  if (ssp.root == null || ssp.root.equals(""String_Node_Str"")) {
    CustomSkinLoader.logger.info(""String_Node_Str"");
    return null;
  }
  String json=HttpUtil0.readHttp(ssp.root + username + ""String_Node_Str"");
  if (json == null || json.equals(""String_Node_Str"")) {
    CustomSkinLoader.logger.info(""String_Node_Str"");
    return null;
  }
  CustomSkinAPI profile=new Gson().fromJson(json,CustomSkinAPI.class);
  UserProfile p=new UserProfile();
  if (profile.skins != null && !profile.skins.isEmpty()) {
    Set<String> keys=profile.skins.keySet();
    for (    String s : keys) {
      System.out.println(s + ""String_Node_Str"" + ModelManager.checkModel(s));
      if (ModelManager.checkModel(s)) {
        p.skinUrl=ssp.root + TEXTURES + profile.skins.get(s);
        p.model=s;
        break;
      }
    }
    if (p.skinUrl == null) {
      p.skinUrl=ssp.root + TEXTURES + profile.skins.get(keys.toArray()[0]);
      p.model=""String_Node_Str"";
    }
  }
 else   if (profile.skin != null && !profile.skin.equals(""String_Node_Str"")) {
    p.skinUrl=ssp.root + TEXTURES + profile.skin;
  }
  if (profile.cape != null && !profile.cape.equals(""String_Node_Str"")) {
    p.capeUrl=ssp.root + TEXTURES + profile.cape;
  }
  if (p.isEmpty()) {
    CustomSkinLoader.logger.info(""String_Node_Str"");
    return null;
  }
 else {
    return p;
  }
}",0.9721627408993576
32916,"/** 
 * Parse UserProfile to hashMapProfile
 * @param profile - UserProfile instance
 * @return profile - hashMapProfile (HashMap<String,MinecraftProfileTexture>)
 * @since 13.1
 */
public static Map fromUserProfile(UserProfile profile){
  Map map=Maps.newHashMap();
  if (profile.skinUrl != null)   map.put(Type.SKIN,new MinecraftProfileTexture(profile.skinUrl));
  if (profile.capeUrl != null)   map.put(Type.CAPE,new MinecraftProfileTexture(profile.capeUrl));
  return map;
}","/** 
 * Parse UserProfile to hashMapProfile
 * @param profile - UserProfile instance
 * @return profile - hashMapProfile (HashMap<String,MinecraftProfileTexture>)
 * @since 13.1
 */
public static Map fromUserProfile(UserProfile profile){
  Map map=Maps.newHashMap();
  if (profile.skinUrl != null)   map.put(Type.SKIN,getProfileTexture(profile.skinUrl));
  if (profile.capeUrl != null)   map.put(Type.CAPE,getProfileTexture(profile.capeUrl));
  return map;
}",0.97008547008547
32917,"public void func_152790_a(final GameProfile p_152790_1_,final SkinManager.SkinAvailableCallback p_152790_2_,final boolean p_152790_3_){
  field_152794_b.submit(new Runnable(){
    private static final String __OBFID=""String_Node_Str"";
    public void run(){
      final HashMap var1=Maps.newHashMap();
      try {
        var1.putAll(SkinManager.this.field_152797_e.getTextures(p_152790_1_,p_152790_3_));
      }
 catch (      InsecureTextureException var3) {
        ;
      }
      var1.clear();
      var1.putAll(customskinloader.CustomSkinLoader.loadProfile(p_152790_1_.getName(),var1));
      Minecraft.getMinecraft().func_152344_a(new Runnable(){
        private static final String __OBFID=""String_Node_Str"";
        public void run(){
          if (var1.containsKey(Type.SKIN)) {
            SkinManager.this.func_152789_a((MinecraftProfileTexture)var1.get(Type.SKIN),Type.SKIN,p_152790_2_);
          }
          if (var1.containsKey(Type.CAPE)) {
            SkinManager.this.func_152789_a((MinecraftProfileTexture)var1.get(Type.CAPE),Type.CAPE,p_152790_2_);
          }
        }
      }
);
    }
  }
);
}","public void func_152790_a(final GameProfile p_152790_1_,final SkinManager.SkinAvailableCallback p_152790_2_,final boolean p_152790_3_){
  field_152794_b.submit(new Runnable(){
    private static final String __OBFID=""String_Node_Str"";
    public void run(){
      final HashMap var1=Maps.newHashMap();
      try {
        var1.putAll(SkinManager.this.field_152797_e.getTextures(p_152790_1_,p_152790_3_));
      }
 catch (      InsecureTextureException var3) {
        ;
      }
      if (customskinloader.CustomSkinLoader.config.enable) {
        Map newMap=customskinloader.CustomSkinLoader.loadProfile(profile.getName(),var1);
        if (!newMap.isEmpty()) {
          var1.clear();
          var1.putAll(newMap);
        }
      }
      Minecraft.getMinecraft().func_152344_a(new Runnable(){
        private static final String __OBFID=""String_Node_Str"";
        public void run(){
          if (var1.containsKey(Type.SKIN)) {
            SkinManager.this.func_152789_a((MinecraftProfileTexture)var1.get(Type.SKIN),Type.SKIN,p_152790_2_);
          }
          if (var1.containsKey(Type.CAPE)) {
            SkinManager.this.func_152789_a((MinecraftProfileTexture)var1.get(Type.CAPE),Type.CAPE,p_152790_2_);
          }
        }
      }
);
    }
  }
);
}",0.903578947368421
32918,"public void func_152790_a(final GameProfile p_152790_1_,final SkinManager.SkinAvailableCallback p_152790_2_,final boolean p_152790_3_){
  THREAD_POOL.submit(new Runnable(){
    private static final String __OBFID=""String_Node_Str"";
    public void run(){
      final HashMap var1=Maps.newHashMap();
      try {
        var1.putAll(SkinManager.this.sessionService.getTextures(p_152790_1_,p_152790_3_));
      }
 catch (      InsecureTextureException var3) {
        ;
      }
      var1.clear();
      var1.putAll(customskinloader.CustomSkinLoader.loadProfile(p_152790_1_.getName(),var1));
      Minecraft.getMinecraft().addScheduledTask(new Runnable(){
        private static final String __OBFID=""String_Node_Str"";
        public void run(){
          if (var1.containsKey(Type.SKIN)) {
            SkinManager.this.loadSkin((MinecraftProfileTexture)var1.get(Type.SKIN),Type.SKIN,p_152790_2_);
          }
          if (var1.containsKey(Type.CAPE)) {
            SkinManager.this.loadSkin((MinecraftProfileTexture)var1.get(Type.CAPE),Type.CAPE,p_152790_2_);
          }
        }
      }
);
    }
  }
);
}","public void func_152790_a(final GameProfile p_152790_1_,final SkinManager.SkinAvailableCallback p_152790_2_,final boolean p_152790_3_){
  THREAD_POOL.submit(new Runnable(){
    private static final String __OBFID=""String_Node_Str"";
    public void run(){
      final HashMap var1=Maps.newHashMap();
      try {
        var1.putAll(SkinManager.this.sessionService.getTextures(p_152790_1_,p_152790_3_));
      }
 catch (      InsecureTextureException var3) {
        ;
      }
      if (customskinloader.CustomSkinLoader.config.enable) {
        Map newMap=customskinloader.CustomSkinLoader.loadProfile(profile.getName(),var1);
        if (!newMap.isEmpty()) {
          var1.clear();
          var1.putAll(newMap);
        }
      }
      Minecraft.getMinecraft().addScheduledTask(new Runnable(){
        private static final String __OBFID=""String_Node_Str"";
        public void run(){
          if (var1.containsKey(Type.SKIN)) {
            SkinManager.this.loadSkin((MinecraftProfileTexture)var1.get(Type.SKIN),Type.SKIN,p_152790_2_);
          }
          if (var1.containsKey(Type.CAPE)) {
            SkinManager.this.loadSkin((MinecraftProfileTexture)var1.get(Type.CAPE),Type.CAPE,p_152790_2_);
          }
        }
      }
);
    }
  }
);
}",0.8679405520169852
32919,"public void loadProfileTextures(final GameProfile profile,final SkinManager.SkinAvailableCallback skinAvailableCallback,final boolean requireSecure){
  THREAD_POOL.submit(new Runnable(){
    public void run(){
      final Map<Type,MinecraftProfileTexture> map=Maps.<Type,MinecraftProfileTexture>newHashMap();
      try {
        map.putAll(SkinManager.this.sessionService.getTextures(profile,requireSecure));
      }
 catch (      InsecureTextureException var3) {
        ;
      }
      if (CustomSkinLoader.config.enable) {
        Map newMap=customskinloader.CustomSkinLoader.loadProfile(profile.getName(),map);
        if (!newMap.isEmpty()) {
          map.clear();
          map.putAll(newMap);
        }
      }
      Minecraft.getMinecraft().addScheduledTask(new Runnable(){
        public void run(){
          if (map.containsKey(Type.SKIN)) {
            SkinManager.this.loadSkin((MinecraftProfileTexture)map.get(Type.SKIN),Type.SKIN,skinAvailableCallback);
          }
          if (map.containsKey(Type.CAPE)) {
            SkinManager.this.loadSkin((MinecraftProfileTexture)map.get(Type.CAPE),Type.CAPE,skinAvailableCallback);
          }
        }
      }
);
    }
  }
);
}","public void loadProfileTextures(final GameProfile profile,final SkinManager.SkinAvailableCallback skinAvailableCallback,final boolean requireSecure){
  THREAD_POOL.submit(new Runnable(){
    public void run(){
      final Map<Type,MinecraftProfileTexture> map=Maps.<Type,MinecraftProfileTexture>newHashMap();
      try {
        map.putAll(SkinManager.this.sessionService.getTextures(profile,requireSecure));
      }
 catch (      InsecureTextureException var3) {
        ;
      }
      if (customskinloader.CustomSkinLoader.config.enable) {
        Map newMap=customskinloader.CustomSkinLoader.loadProfile(profile.getName(),map);
        if (!newMap.isEmpty()) {
          map.clear();
          map.putAll(newMap);
        }
      }
      Minecraft.getMinecraft().addScheduledTask(new Runnable(){
        public void run(){
          if (map.containsKey(Type.SKIN)) {
            SkinManager.this.loadSkin((MinecraftProfileTexture)map.get(Type.SKIN),Type.SKIN,skinAvailableCallback);
          }
          if (map.containsKey(Type.CAPE)) {
            SkinManager.this.loadSkin((MinecraftProfileTexture)map.get(Type.CAPE),Type.CAPE,skinAvailableCallback);
          }
        }
      }
);
    }
  }
);
}",0.992901878914405
32920,"@Override public UserProfile loadProfile(SkinSiteProfile ssp,String username) throws Exception {
  if (ssp.root == null || ssp.root.equals(""String_Node_Str"")) {
    CustomSkinLoader.logger.info(""String_Node_Str"");
    return null;
  }
  String json=HttpUtil.readHttp(ssp.root + username + ""String_Node_Str"");
  if (json == null || json.equals(""String_Node_Str"")) {
    CustomSkinLoader.logger.info(""String_Node_Str"");
    return null;
  }
  CustomSkinAPI profile=new Gson().fromJson(json,CustomSkinAPI.class);
  UserProfile p=new UserProfile();
  if (profile.skins != null && !profile.skins.isEmpty()) {
    Set<String> keys=profile.skins.keySet();
    for (    String s : keys) {
      if (ModelManager.checkModel(s)) {
        p.skinUrl=ssp.root + TEXTURES + profile.skins.get(s);
        p.model=s;
        break;
      }
    }
    if (p.skinUrl == null) {
      p.skinUrl=ssp.root + TEXTURES + profile.skins.get(keys.toArray()[0]);
      p.model=""String_Node_Str"";
    }
  }
 else   if (profile.skin != null && !profile.skin.equals(""String_Node_Str"")) {
    p.skinUrl=ssp.root + TEXTURES + profile.skin;
  }
  if (profile.cape != null && !profile.cape.equals(""String_Node_Str"")) {
    p.capeUrl=ssp.root + TEXTURES + profile.cape;
  }
  if (p.isEmpty()) {
    CustomSkinLoader.logger.info(""String_Node_Str"");
    return null;
  }
 else {
    return p;
  }
}","@Override public UserProfile loadProfile(SkinSiteProfile ssp,String username) throws Exception {
  if (ssp.root == null || ssp.root.equals(""String_Node_Str"")) {
    CustomSkinLoader.logger.info(""String_Node_Str"");
    return null;
  }
  String json=HttpUtil0.readHttp(ssp.root + username + ""String_Node_Str"");
  if (json == null || json.equals(""String_Node_Str"")) {
    CustomSkinLoader.logger.info(""String_Node_Str"");
    return null;
  }
  CustomSkinAPI profile=new Gson().fromJson(json,CustomSkinAPI.class);
  UserProfile p=new UserProfile();
  if (profile.skins != null && !profile.skins.isEmpty()) {
    Set<String> keys=profile.skins.keySet();
    for (    String s : keys) {
      if (ModelManager.checkModel(s)) {
        p.skinUrl=ssp.root + TEXTURES + profile.skins.get(s);
        p.model=s;
        break;
      }
    }
    if (p.skinUrl == null) {
      p.skinUrl=ssp.root + TEXTURES + profile.skins.get(keys.toArray()[0]);
      p.model=""String_Node_Str"";
    }
  }
 else   if (profile.skin != null && !profile.skin.equals(""String_Node_Str"")) {
    p.skinUrl=ssp.root + TEXTURES + profile.skin;
  }
  if (profile.cape != null && !profile.cape.equals(""String_Node_Str"")) {
    p.capeUrl=ssp.root + TEXTURES + profile.cape;
  }
  if (p.isEmpty()) {
    CustomSkinLoader.logger.info(""String_Node_Str"");
    return null;
  }
 else {
    return p;
  }
}",0.9996327579875136
32921,"@Override public UserProfile loadProfile(SkinSiteProfile ssp,String username) throws Exception {
  UserProfile profile=new UserProfile();
  if (ssp.skin != null && !ssp.skin.equals(""String_Node_Str"")) {
    String skin=HttpUtil.getRealUrl(ssp.skin.replaceAll(USERNAME_REGEX,username));
    if (skin != null && !skin.equals(""String_Node_Str"")) {
      profile.skinUrl=skin;
      profile.model=""String_Node_Str"";
    }
  }
  if (ssp.cape != null && !ssp.cape.equals(""String_Node_Str"")) {
    String cape=HttpUtil.getRealUrl(ssp.cape.replaceAll(USERNAME_REGEX,username));
    if (cape != null && !cape.equals(""String_Node_Str"")) {
      profile.capeUrl=cape;
    }
  }
  if (profile.isEmpty()) {
    CustomSkinLoader.logger.info(""String_Node_Str"");
    return null;
  }
 else {
    return profile;
  }
}","@Override public UserProfile loadProfile(SkinSiteProfile ssp,String username) throws Exception {
  UserProfile profile=new UserProfile();
  if (ssp.skin != null && !ssp.skin.equals(""String_Node_Str"")) {
    String skin=HttpUtil0.getRealUrl(ssp.skin.replaceAll(USERNAME_REGEX,username));
    if (skin != null && !skin.equals(""String_Node_Str"")) {
      profile.skinUrl=skin;
      profile.model=""String_Node_Str"";
    }
  }
  if (ssp.cape != null && !ssp.cape.equals(""String_Node_Str"")) {
    String cape=HttpUtil0.getRealUrl(ssp.cape.replaceAll(USERNAME_REGEX,username));
    if (cape != null && !cape.equals(""String_Node_Str"")) {
      profile.capeUrl=cape;
    }
  }
  if (profile.isEmpty()) {
    CustomSkinLoader.logger.info(""String_Node_Str"");
    return null;
  }
 else {
    return profile;
  }
}",0.9987531172069826
32922,"@Override public UserProfile loadProfile(SkinSiteProfile ssp,String username) throws Exception {
  String json0=HttpUtil.readHttp(""String_Node_Str"" + username);
  if (json0 == null || json0.equals(""String_Node_Str"")) {
    CustomSkinLoader.logger.info(""String_Node_Str"" + username + ""String_Node_Str"");
    return null;
  }
  Gson gson=new Gson();
  UUIDProfile uuidProfile=gson.fromJson(json0,UUIDProfile.class);
  if (uuidProfile.id == null || uuidProfile.id.equals(""String_Node_Str"")) {
    CustomSkinLoader.logger.info(""String_Node_Str"" + username + ""String_Node_Str"");
    return null;
  }
  String json1=HttpUtil.readHttp(""String_Node_Str"" + uuidProfile.id);
  if (json1 == null || json1.equals(""String_Node_Str"")) {
    CustomSkinLoader.logger.info(""String_Node_Str"" + username + ""String_Node_Str"");
    return null;
  }
  UserProfile0 profile=gson.fromJson(json1,UserProfile0.class);
  Property p=profile.properties.length >= 1 ? profile.properties[0] : null;
  if (p == null) {
    CustomSkinLoader.logger.info(""String_Node_Str"" + username + ""String_Node_Str"");
    return null;
  }
  String texture=p.getValue();
  if (texture == null || texture.equals(""String_Node_Str"")) {
    CustomSkinLoader.logger.info(""String_Node_Str"" + username + ""String_Node_Str"");
    return null;
  }
  String json2=new String(Base64.decodeBase64(texture));
  UserTexture texture1=gson.fromJson(json2,UserTexture.class);
  if (texture1.textures == null || texture1.textures.isEmpty()) {
    CustomSkinLoader.logger.info(""String_Node_Str"" + username + ""String_Node_Str"");
    return null;
  }
  return ModelManager.toUserProfile(texture1.textures);
}","@Override public UserProfile loadProfile(SkinSiteProfile ssp,String username) throws Exception {
  String json0=HttpUtil0.readHttp(""String_Node_Str"" + username);
  if (json0 == null || json0.equals(""String_Node_Str"")) {
    CustomSkinLoader.logger.info(""String_Node_Str"" + username + ""String_Node_Str"");
    return null;
  }
  Gson gson=new Gson();
  UUIDProfile uuidProfile=gson.fromJson(json0,UUIDProfile.class);
  if (uuidProfile.id == null || uuidProfile.id.equals(""String_Node_Str"")) {
    CustomSkinLoader.logger.info(""String_Node_Str"" + username + ""String_Node_Str"");
    return null;
  }
  String json1=HttpUtil0.readHttp(""String_Node_Str"" + uuidProfile.id);
  if (json1 == null || json1.equals(""String_Node_Str"")) {
    CustomSkinLoader.logger.info(""String_Node_Str"" + username + ""String_Node_Str"");
    return null;
  }
  UserProfile0 profile=gson.fromJson(json1,UserProfile0.class);
  Property p=profile.properties.length >= 1 ? profile.properties[0] : null;
  if (p == null) {
    CustomSkinLoader.logger.info(""String_Node_Str"" + username + ""String_Node_Str"");
    return null;
  }
  String texture=p.getValue();
  if (texture == null || texture.equals(""String_Node_Str"")) {
    CustomSkinLoader.logger.info(""String_Node_Str"" + username + ""String_Node_Str"");
    return null;
  }
  String json2=new String(Base64.decodeBase64(texture));
  UserTexture texture1=gson.fromJson(json2,UserTexture.class);
  if (texture1.textures == null || texture1.textures.isEmpty()) {
    CustomSkinLoader.logger.info(""String_Node_Str"" + username + ""String_Node_Str"");
    return null;
  }
  return ModelManager.toUserProfile(texture1.textures);
}",0.9993898718730934
32923,"@Override public UserProfile loadProfile(SkinSiteProfile ssp,String username) throws Exception {
  if (ssp.root == null || ssp.root.equals(""String_Node_Str"")) {
    CustomSkinLoader.logger.info(""String_Node_Str"");
    return null;
  }
  String json=HttpUtil.readHttp(ssp.root + username + ""String_Node_Str"");
  if (json == null || json.equals(""String_Node_Str"")) {
    CustomSkinLoader.logger.info(""String_Node_Str"");
    return null;
  }
  UniSkinAPI profile=new Gson().fromJson(json,UniSkinAPI.class);
  UserProfile p=new UserProfile();
  if (profile.skins != null && !profile.skins.isEmpty()) {
    if (profile.model_preference != null && !profile.model_preference.isEmpty()) {
      for (      String s : profile.model_preference) {
        if (ModelManager.checkModel(s)) {
          p.skinUrl=ssp.root + TEXTURES + profile.skins.get(s);
          p.model=s;
          break;
        }
      }
    }
    if (p.skinUrl == null) {
      String s=profile.skins.get(""String_Node_Str"");
      if (s != null) {
        p.skinUrl=ssp.root + TEXTURES + s;
        p.model=""String_Node_Str"";
      }
    }
  }
  if (profile.cape != null && !profile.cape.equals(""String_Node_Str"")) {
    p.capeUrl=ssp.root + TEXTURES + profile.cape;
  }
  if (p.isEmpty()) {
    CustomSkinLoader.logger.info(""String_Node_Str"");
    return null;
  }
 else {
    return p;
  }
}","@Override public UserProfile loadProfile(SkinSiteProfile ssp,String username) throws Exception {
  if (ssp.root == null || ssp.root.equals(""String_Node_Str"")) {
    CustomSkinLoader.logger.info(""String_Node_Str"");
    return null;
  }
  String json=HttpUtil0.readHttp(ssp.root + username + ""String_Node_Str"");
  if (json == null || json.equals(""String_Node_Str"")) {
    CustomSkinLoader.logger.info(""String_Node_Str"");
    return null;
  }
  UniSkinAPI profile=new Gson().fromJson(json,UniSkinAPI.class);
  UserProfile p=new UserProfile();
  if (profile.skins != null && !profile.skins.isEmpty()) {
    if (profile.model_preference != null && !profile.model_preference.isEmpty()) {
      for (      String s : profile.model_preference) {
        if (ModelManager.checkModel(s)) {
          p.skinUrl=ssp.root + TEXTURES + profile.skins.get(s);
          p.model=s;
          break;
        }
      }
    }
    if (p.skinUrl == null) {
      String s=profile.skins.get(""String_Node_Str"");
      if (s != null) {
        p.skinUrl=ssp.root + TEXTURES + s;
        p.model=""String_Node_Str"";
      }
    }
  }
  if (profile.cape != null && !profile.cape.equals(""String_Node_Str"")) {
    p.capeUrl=ssp.root + TEXTURES + profile.cape;
  }
  if (p.isEmpty()) {
    CustomSkinLoader.logger.info(""String_Node_Str"");
    return null;
  }
 else {
    return p;
  }
}",0.99963113242346
32924,"public ClassTransformer(){
  ForgeTweaker.logger.info(""String_Node_Str"");
  try {
    URLClassLoader ucl=(URLClassLoader)idv.jlchntoz.tweaker.ClassTransformer.class.getClassLoader();
    URL urls[]=ucl.getURLs();
    for (int i=0; i < urls.length; i++) {
      URL url=urls[i];
      ZipFile tempZipFile=getZipFile(url);
      if (tempZipFile == null)       continue;
      zipFile=tempZipFile;
      ForgeTweaker.logger.info(""String_Node_Str"" + url);
      break;
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  if (zipFile == null) {
    ForgeTweaker.logger.info(""String_Node_Str"");
  }
}","public ClassTransformer(){
  ForgeTweaker.logger.info(""String_Node_Str"");
  try {
    URLClassLoader ucl=(URLClassLoader)this.getClass().getClassLoader();
    URL urls[]=ucl.getURLs();
    for (int i=0; i < urls.length; i++) {
      URL url=urls[i];
      ZipFile tempZipFile=getZipFile(url);
      if (tempZipFile == null)       continue;
      zipFile=tempZipFile;
      ForgeTweaker.logger.info(""String_Node_Str"" + url);
      break;
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  if (zipFile == null) {
    ForgeTweaker.logger.info(""String_Node_Str"");
  }
}",0.9612794612794612
32925,"private void saveToCache(InputStream is,File to){
  logger.info(""String_Node_Str"" + to.getAbsolutePath());
  FileOutputStream fs=null;
  int times=0;
  try {
    if (to.exists()) {
      to.delete();
    }
    fs=new FileOutputStream(to);
    int byteRead=0;
    byte[] buffer=new byte[1024];
    while ((byteRead=is.read(buffer)) != -1) {
      times+=byteRead;
      fs.write(buffer,0,byteRead);
      if (times >= C.getContentLength()) {
        break;
      }
    }
    if (to.length() > 1) {
      logger.info(""String_Node_Str"" + to.getAbsolutePath());
    }
 else {
      to.delete();
      logger.info(""String_Node_Str"" + to.getAbsolutePath());
    }
  }
 catch (  Exception e) {
    logger.warning(e.getMessage());
  }
 finally {
    try {
      if (fs != null)       fs.close();
      is.reset();
      logger.info(""String_Node_Str"" + is.available());
    }
 catch (    IOException e) {
      logger.warning(e.getMessage());
    }
    if (to.exists()) {
      to.setLastModified(C.getLastModified());
    }
  }
}","private void saveToCache(InputStream is,File to){
  logger.info(""String_Node_Str"" + to.getAbsolutePath());
  FileOutputStream fs=null;
  int times=0;
  try {
    if (to.exists()) {
      to.delete();
    }
    fs=new FileOutputStream(to);
    int byteRead=0;
    byte[] buffer=new byte[1024];
    while ((byteRead=is.read(buffer)) != -1) {
      times+=byteRead;
      fs.write(buffer,0,byteRead);
      if (times >= C.getContentLength()) {
        break;
      }
    }
    if (to.length() > 1) {
      to.setLastModified(C.getLastModified());
      logger.info(""String_Node_Str"" + to.getAbsolutePath() + ""String_Node_Str""+ to.lastModified()+ ""String_Node_Str""+ to.length()+ ""String_Node_Str"");
    }
 else {
      to.delete();
      logger.info(""String_Node_Str"" + to.getAbsolutePath());
    }
  }
 catch (  Exception e) {
    logger.warning(e.getMessage());
  }
 finally {
    try {
      if (fs != null)       fs.close();
      is.reset();
    }
 catch (    IOException e) {
      logger.warning(e.getMessage());
    }
  }
}",0.869140625
32926,"public InputStream getPlayerSkinStream(Boolean isCloak,String playerName){
  if (skinURLs == null || cloakURLs == null || skinURLs.length <= 0 || cloakURLs.length <= 0)   refreshSkinURL();
  InputStream S=null;
  for (  String l : isCloak ? cloakURLs : skinURLs) {
    if (l == null || l.equalsIgnoreCase(""String_Node_Str""))     continue;
    String loc=str_replace(""String_Node_Str"",playerName,l);
    logger.log(Level.INFO,""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ loc);
    S=getStream(loc,true);
    if (S == null) {
      logger.log(Level.INFO,""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ loc);
    }
 else {
      logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ loc);
      return S;
    }
  }
  logger.log(Level.INFO,""String_Node_Str"");
  return getStream(str_replace(""String_Node_Str"",playerName,isCloak ? DefaultCloakURL : DefaultSkinURL),true);
}","public InputStream getPlayerSkinStream(Boolean isCloak,String playerName){
  if ((skinURLs == null || skinURLs.length <= 0) && (cloakURLs == null || cloakURLs.length <= 0))   refreshSkinURL();
  InputStream S=null;
  for (  String l : isCloak ? cloakURLs : skinURLs) {
    if (l == null || l.equalsIgnoreCase(""String_Node_Str""))     continue;
    String loc=str_replace(""String_Node_Str"",playerName,l);
    logger.log(Level.INFO,""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ loc);
    S=getStream(loc,true);
    if (S == null) {
      logger.log(Level.INFO,""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ loc);
    }
 else {
      logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ loc);
      return S;
    }
  }
  logger.log(Level.INFO,""String_Node_Str"");
  return getStream(str_replace(""String_Node_Str"",playerName,isCloak ? DefaultCloakURL : DefaultSkinURL),true);
}",0.9642857142857144
32927,"private InputStream getStream(String URL,Boolean CheckPNG){
  boolean success=false;
  File cacheFile=new File(CACHE_DIR,MD5(URL));
  boolean alreadyCached=false;
  if (cacheFile.exists() && cacheFile.length() > 1) {
    alreadyCached=true;
    logger.info(""String_Node_Str"");
  }
  try {
    URL U=new URL(URL);
    C=(HttpURLConnection)U.openConnection();
    C.setReadTimeout(15000);
    C.setDoInput(true);
    C.setDoOutput(false);
    C.connect();
    logger.info(""String_Node_Str"" + C.getResponseCode());
    int respcode=C.getResponseCode() / 100;
    if (respcode != 4 && respcode != 5) {
      if (alreadyCached && C.getLastModified() == cacheFile.lastModified()) {
        logger.info(""String_Node_Str"");
        return getStreamFromCache(cacheFile);
      }
      if (C.getContentLength() <= 0) {
        return null;
      }
      InputStream IS=new BufferedInputStream(C.getInputStream());
      if (!CheckPNG) {
        success=true;
        saveToCache(IS,cacheFile);
        return IS;
      }
      IS.mark(C.getContentLength() + 10);
      byte[] ib=new byte[4];
      IS.read(ib);
      if (ib[1] == (byte)'P' && ib[2] == (byte)'N' && ib[3] == (byte)'G') {
        IS.reset();
        success=true;
        saveToCache(IS,cacheFile);
        return IS;
      }
    }
  }
 catch (  Exception ex) {
    success=false;
    logger.log(Level.WARNING,ex.getMessage());
    if (alreadyCached)     return getStreamFromCache(cacheFile);
  }
 finally {
    if (!success)     disconnect();
  }
  return null;
}","private InputStream getStream(String URL,Boolean CheckPNG){
  boolean success=false;
  File cacheFile=new File(CACHE_DIR,MD5(URL));
  boolean alreadyCached=false;
  if (cacheFile.exists() && cacheFile.length() > 1) {
    alreadyCached=true;
    logger.info(""String_Node_Str"" + cacheFile.lastModified() + ""String_Node_Str""+ cacheFile.length()+ ""String_Node_Str"");
  }
  try {
    URL U=new URL(URL);
    C=(HttpURLConnection)U.openConnection();
    C.setReadTimeout(15000);
    C.setDoInput(true);
    C.setDoOutput(false);
    C.connect();
    logger.info(""String_Node_Str"" + C.getResponseCode());
    int respcode=C.getResponseCode() / 100;
    if (respcode != 4 && respcode != 5) {
      if (C.getContentLength() <= 0) {
        logger.info(""String_Node_Str"");
        return null;
      }
      logger.info(""String_Node_Str"" + C.getLastModified() + ""String_Node_Str""+ C.getContentLength()+ ""String_Node_Str"");
      if (alreadyCached && C.getLastModified() == cacheFile.lastModified() && C.getContentLength() == cacheFile.length()) {
        logger.info(""String_Node_Str"");
        return getStreamFromCache(cacheFile);
      }
      InputStream IS=new BufferedInputStream(C.getInputStream());
      if (!CheckPNG) {
        success=true;
        saveToCache(IS,cacheFile);
        return IS;
      }
      IS.mark(C.getContentLength() + 10);
      byte[] ib=new byte[4];
      IS.read(ib);
      if (ib[1] == (byte)'P' && ib[2] == (byte)'N' && ib[3] == (byte)'G') {
        IS.reset();
        success=true;
        saveToCache(IS,cacheFile);
        return IS;
      }
    }
  }
 catch (  Exception ex) {
    success=false;
    logger.log(Level.WARNING,ex.getMessage());
    if (alreadyCached)     return getStreamFromCache(cacheFile);
  }
 finally {
    if (!success)     disconnect();
  }
  return null;
}",0.871209846892825
32928,"private void saveToCache(InputStream is,File to){
  logger.info(""String_Node_Str"" + to.getAbsolutePath());
  FileOutputStream fs=null;
  int times=0;
  try {
    if (to.exists()) {
      to.delete();
    }
    fs=new FileOutputStream(to);
    int byteRead=0;
    byte[] buffer=new byte[1024];
    while ((byteRead=is.read(buffer)) != -1) {
      times+=byteRead;
      fs.write(buffer,0,byteRead);
      if (times >= C.getContentLength()) {
        break;
      }
    }
    if (to.length() > 1) {
      logger.info(""String_Node_Str"" + to.getAbsolutePath());
    }
 else {
      to.delete();
      logger.info(""String_Node_Str"" + to.getAbsolutePath());
    }
  }
 catch (  Exception e) {
    logger.warning(e.getMessage());
  }
 finally {
    try {
      if (fs != null)       fs.close();
      is.reset();
      logger.info(""String_Node_Str"" + is.available());
    }
 catch (    IOException e) {
      logger.warning(e.getMessage());
    }
    if (to.exists()) {
      to.setLastModified(C.getLastModified());
    }
  }
}","private void saveToCache(InputStream is,File to){
  logger.info(""String_Node_Str"" + to.getAbsolutePath());
  FileOutputStream fs=null;
  int times=0;
  try {
    if (to.exists()) {
      to.delete();
    }
    fs=new FileOutputStream(to);
    int byteRead=0;
    byte[] buffer=new byte[1024];
    while ((byteRead=is.read(buffer)) != -1) {
      times+=byteRead;
      fs.write(buffer,0,byteRead);
      if (times >= C.getContentLength()) {
        break;
      }
    }
    if (to.length() > 1) {
      to.setLastModified(C.getLastModified());
      logger.info(""String_Node_Str"" + to.getAbsolutePath() + ""String_Node_Str""+ to.lastModified()+ ""String_Node_Str""+ to.length()+ ""String_Node_Str"");
    }
 else {
      to.delete();
      logger.info(""String_Node_Str"" + to.getAbsolutePath());
    }
  }
 catch (  Exception e) {
    logger.warning(e.getMessage());
  }
 finally {
    try {
      if (fs != null)       fs.close();
      is.reset();
    }
 catch (    IOException e) {
      logger.warning(e.getMessage());
    }
  }
}",0.869140625
32929,"public InputStream getPlayerSkinStream(Boolean isCloak,String playerName){
  if (skinURLs == null || cloakURLs == null || skinURLs.length <= 0 || cloakURLs.length <= 0)   refreshSkinURL();
  InputStream S=null;
  for (  String l : isCloak ? cloakURLs : skinURLs) {
    if (l == null || l.equalsIgnoreCase(""String_Node_Str""))     continue;
    String loc=str_replace(""String_Node_Str"",playerName,l);
    logger.log(Level.INFO,""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ loc);
    S=getStream(loc,true);
    if (S == null) {
      logger.log(Level.INFO,""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ loc);
    }
 else {
      logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ loc);
      return S;
    }
  }
  logger.log(Level.INFO,""String_Node_Str"");
  return getStream(str_replace(""String_Node_Str"",playerName,isCloak ? DefaultCloakURL : DefaultSkinURL),true);
}","public InputStream getPlayerSkinStream(Boolean isCloak,String playerName){
  if ((skinURLs == null || skinURLs.length <= 0) && (cloakURLs == null || cloakURLs.length <= 0))   refreshSkinURL();
  InputStream S=null;
  for (  String l : isCloak ? cloakURLs : skinURLs) {
    if (l == null || l.equalsIgnoreCase(""String_Node_Str""))     continue;
    String loc=str_replace(""String_Node_Str"",playerName,l);
    logger.log(Level.INFO,""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ loc);
    S=getStream(loc,true);
    if (S == null) {
      logger.log(Level.INFO,""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ loc);
    }
 else {
      logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ loc);
      return S;
    }
  }
  logger.log(Level.INFO,""String_Node_Str"");
  return getStream(str_replace(""String_Node_Str"",playerName,isCloak ? DefaultCloakURL : DefaultSkinURL),true);
}",0.9642857142857144
32930,"private InputStream getStream(String URL,Boolean CheckPNG){
  boolean success=false;
  File cacheFile=new File(CACHE_DIR,MD5(URL));
  boolean alreadyCached=false;
  if (cacheFile.exists() && cacheFile.length() > 1) {
    alreadyCached=true;
    logger.info(""String_Node_Str"");
  }
  try {
    URL U=new URL(URL);
    C=(HttpURLConnection)U.openConnection();
    C.setReadTimeout(15000);
    C.setDoInput(true);
    C.setDoOutput(false);
    C.connect();
    logger.info(""String_Node_Str"" + C.getResponseCode());
    int respcode=C.getResponseCode() / 100;
    if (respcode != 4 && respcode != 5) {
      if (alreadyCached && C.getLastModified() == cacheFile.lastModified()) {
        logger.info(""String_Node_Str"");
        return getStreamFromCache(cacheFile);
      }
      if (C.getContentLength() <= 0) {
        return null;
      }
      InputStream IS=new BufferedInputStream(C.getInputStream());
      if (!CheckPNG) {
        success=true;
        saveToCache(IS,cacheFile);
        return IS;
      }
      IS.mark(C.getContentLength() + 10);
      byte[] ib=new byte[4];
      IS.read(ib);
      if (ib[1] == (byte)'P' && ib[2] == (byte)'N' && ib[3] == (byte)'G') {
        IS.reset();
        success=true;
        saveToCache(IS,cacheFile);
        return IS;
      }
    }
  }
 catch (  Exception ex) {
    success=false;
    logger.log(Level.WARNING,ex.getMessage());
    if (alreadyCached)     return getStreamFromCache(cacheFile);
  }
 finally {
    if (!success)     disconnect();
  }
  return null;
}","private InputStream getStream(String URL,Boolean CheckPNG){
  boolean success=false;
  File cacheFile=new File(CACHE_DIR,MD5(URL));
  boolean alreadyCached=false;
  if (cacheFile.exists() && cacheFile.length() > 1) {
    alreadyCached=true;
    logger.info(""String_Node_Str"" + cacheFile.lastModified() + ""String_Node_Str""+ cacheFile.length()+ ""String_Node_Str"");
  }
  try {
    URL U=new URL(URL);
    C=(HttpURLConnection)U.openConnection();
    C.setReadTimeout(15000);
    C.setDoInput(true);
    C.setDoOutput(false);
    C.connect();
    logger.info(""String_Node_Str"" + C.getResponseCode());
    int respcode=C.getResponseCode() / 100;
    if (respcode != 4 && respcode != 5) {
      if (C.getContentLength() <= 0) {
        logger.info(""String_Node_Str"");
        return null;
      }
      logger.info(""String_Node_Str"" + C.getLastModified() + ""String_Node_Str""+ C.getContentLength()+ ""String_Node_Str"");
      if (alreadyCached && C.getLastModified() == cacheFile.lastModified() && C.getContentLength() == cacheFile.length()) {
        logger.info(""String_Node_Str"");
        return getStreamFromCache(cacheFile);
      }
      InputStream IS=new BufferedInputStream(C.getInputStream());
      if (!CheckPNG) {
        success=true;
        saveToCache(IS,cacheFile);
        return IS;
      }
      IS.mark(C.getContentLength() + 10);
      byte[] ib=new byte[4];
      IS.read(ib);
      if (ib[1] == (byte)'P' && ib[2] == (byte)'N' && ib[3] == (byte)'G') {
        IS.reset();
        success=true;
        saveToCache(IS,cacheFile);
        return IS;
      }
    }
  }
 catch (  Exception ex) {
    success=false;
    logger.log(Level.WARNING,ex.getMessage());
    if (alreadyCached)     return getStreamFromCache(cacheFile);
  }
 finally {
    if (!success)     disconnect();
  }
  return null;
}",0.871209846892825
32931,"private void saveToCache(InputStream is,File to){
  logger.info(""String_Node_Str"" + to.getAbsolutePath());
  FileOutputStream fs=null;
  int times=0;
  try {
    if (to.exists()) {
      to.delete();
    }
    fs=new FileOutputStream(to);
    int byteRead=0;
    byte[] buffer=new byte[1024];
    while ((byteRead=is.read(buffer)) != -1) {
      times+=byteRead;
      fs.write(buffer,0,byteRead);
      if (times >= C.getContentLength()) {
        break;
      }
    }
    if (to.length() > 1) {
      logger.info(""String_Node_Str"" + to.getAbsolutePath());
    }
 else {
      to.delete();
      logger.info(""String_Node_Str"" + to.getAbsolutePath());
    }
  }
 catch (  Exception e) {
    logger.warning(e.getMessage());
  }
 finally {
    try {
      if (fs != null)       fs.close();
      is.reset();
      logger.info(""String_Node_Str"" + is.available());
    }
 catch (    IOException e) {
      logger.warning(e.getMessage());
    }
    if (to.exists()) {
      to.setLastModified(C.getLastModified());
    }
  }
}","private void saveToCache(InputStream is,File to){
  logger.info(""String_Node_Str"" + to.getAbsolutePath());
  FileOutputStream fs=null;
  int times=0;
  try {
    if (to.exists()) {
      to.delete();
    }
    fs=new FileOutputStream(to);
    int byteRead=0;
    byte[] buffer=new byte[1024];
    while ((byteRead=is.read(buffer)) != -1) {
      times+=byteRead;
      fs.write(buffer,0,byteRead);
      if (times >= C.getContentLength()) {
        break;
      }
    }
    if (to.length() > 1) {
      to.setLastModified(C.getLastModified());
      logger.info(""String_Node_Str"" + to.getAbsolutePath() + ""String_Node_Str""+ to.lastModified()+ ""String_Node_Str""+ to.length()+ ""String_Node_Str"");
    }
 else {
      to.delete();
      logger.info(""String_Node_Str"" + to.getAbsolutePath());
    }
  }
 catch (  Exception e) {
    logger.warning(e.getMessage());
  }
 finally {
    try {
      if (fs != null)       fs.close();
      is.reset();
    }
 catch (    IOException e) {
      logger.warning(e.getMessage());
    }
  }
}",0.869140625
32932,"public InputStream getPlayerSkinStream(Boolean isCloak,String playerName){
  if (skinURLs == null || cloakURLs == null || skinURLs.length <= 0 || cloakURLs.length <= 0)   refreshSkinURL();
  InputStream S=null;
  for (  String l : isCloak ? cloakURLs : skinURLs) {
    if (l == null || l.equalsIgnoreCase(""String_Node_Str""))     continue;
    String loc=str_replace(""String_Node_Str"",playerName,l);
    logger.log(Level.INFO,""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ loc);
    S=getStream(loc,true);
    if (S == null) {
      logger.log(Level.INFO,""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ loc);
    }
 else {
      logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ loc);
      return S;
    }
  }
  logger.log(Level.INFO,""String_Node_Str"");
  return getStream(str_replace(""String_Node_Str"",playerName,isCloak ? DefaultCloakURL : DefaultSkinURL),true);
}","public InputStream getPlayerSkinStream(Boolean isCloak,String playerName){
  if ((skinURLs == null || skinURLs.length <= 0) && (cloakURLs == null || cloakURLs.length <= 0))   refreshSkinURL();
  InputStream S=null;
  for (  String l : isCloak ? cloakURLs : skinURLs) {
    if (l == null || l.equalsIgnoreCase(""String_Node_Str""))     continue;
    String loc=str_replace(""String_Node_Str"",playerName,l);
    logger.log(Level.INFO,""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ loc);
    S=getStream(loc,true);
    if (S == null) {
      logger.log(Level.INFO,""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ loc);
    }
 else {
      logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ loc);
      return S;
    }
  }
  logger.log(Level.INFO,""String_Node_Str"");
  return getStream(str_replace(""String_Node_Str"",playerName,isCloak ? DefaultCloakURL : DefaultSkinURL),true);
}",0.9642857142857144
32933,"private InputStream getStream(String URL,Boolean CheckPNG){
  boolean success=false;
  File cacheFile=new File(CACHE_DIR,MD5(URL));
  boolean alreadyCached=false;
  if (cacheFile.exists() && cacheFile.length() > 1) {
    alreadyCached=true;
    logger.info(""String_Node_Str"");
  }
  try {
    URL U=new URL(URL);
    C=(HttpURLConnection)U.openConnection();
    C.setReadTimeout(15000);
    C.setDoInput(true);
    C.setDoOutput(false);
    C.connect();
    logger.info(""String_Node_Str"" + C.getResponseCode());
    int respcode=C.getResponseCode() / 100;
    if (respcode != 4 && respcode != 5) {
      if (alreadyCached && C.getLastModified() == cacheFile.lastModified()) {
        logger.info(""String_Node_Str"");
        return getStreamFromCache(cacheFile);
      }
      if (C.getContentLength() <= 0) {
        return null;
      }
      InputStream IS=new BufferedInputStream(C.getInputStream());
      if (!CheckPNG) {
        success=true;
        saveToCache(IS,cacheFile);
        return IS;
      }
      IS.mark(C.getContentLength() + 10);
      byte[] ib=new byte[4];
      IS.read(ib);
      if (ib[1] == (byte)'P' && ib[2] == (byte)'N' && ib[3] == (byte)'G') {
        IS.reset();
        success=true;
        saveToCache(IS,cacheFile);
        return IS;
      }
    }
  }
 catch (  Exception ex) {
    success=false;
    logger.log(Level.WARNING,ex.getMessage());
    if (alreadyCached)     return getStreamFromCache(cacheFile);
  }
 finally {
    if (!success)     disconnect();
  }
  return null;
}","private InputStream getStream(String URL,Boolean CheckPNG){
  boolean success=false;
  File cacheFile=new File(CACHE_DIR,MD5(URL));
  boolean alreadyCached=false;
  if (cacheFile.exists() && cacheFile.length() > 1) {
    alreadyCached=true;
    logger.info(""String_Node_Str"" + cacheFile.lastModified() + ""String_Node_Str""+ cacheFile.length()+ ""String_Node_Str"");
  }
  try {
    URL U=new URL(URL);
    C=(HttpURLConnection)U.openConnection();
    C.setReadTimeout(15000);
    C.setDoInput(true);
    C.setDoOutput(false);
    C.connect();
    logger.info(""String_Node_Str"" + C.getResponseCode());
    int respcode=C.getResponseCode() / 100;
    if (respcode != 4 && respcode != 5) {
      if (C.getContentLength() <= 0) {
        logger.info(""String_Node_Str"");
        return null;
      }
      logger.info(""String_Node_Str"" + C.getLastModified() + ""String_Node_Str""+ C.getContentLength()+ ""String_Node_Str"");
      if (alreadyCached && C.getLastModified() == cacheFile.lastModified() && C.getContentLength() == cacheFile.length()) {
        logger.info(""String_Node_Str"");
        return getStreamFromCache(cacheFile);
      }
      InputStream IS=new BufferedInputStream(C.getInputStream());
      if (!CheckPNG) {
        success=true;
        saveToCache(IS,cacheFile);
        return IS;
      }
      IS.mark(C.getContentLength() + 10);
      byte[] ib=new byte[4];
      IS.read(ib);
      if (ib[1] == (byte)'P' && ib[2] == (byte)'N' && ib[3] == (byte)'G') {
        IS.reset();
        success=true;
        saveToCache(IS,cacheFile);
        return IS;
      }
    }
  }
 catch (  Exception ex) {
    success=false;
    logger.log(Level.WARNING,ex.getMessage());
    if (alreadyCached)     return getStreamFromCache(cacheFile);
  }
 finally {
    if (!success)     disconnect();
  }
  return null;
}",0.871209846892825
32934,"private void saveToCache(InputStream is,File to){
  logger.info(""String_Node_Str"" + to.getAbsolutePath());
  FileOutputStream fs=null;
  int times=0;
  try {
    if (to.exists()) {
      to.delete();
    }
    fs=new FileOutputStream(to);
    int byteRead=0;
    byte[] buffer=new byte[1024];
    while ((byteRead=is.read(buffer)) != -1) {
      times+=byteRead;
      fs.write(buffer,0,byteRead);
      if (times >= C.getContentLength()) {
        break;
      }
    }
    if (to.length() > 1) {
      logger.info(""String_Node_Str"" + to.getAbsolutePath());
    }
 else {
      to.delete();
      logger.info(""String_Node_Str"" + to.getAbsolutePath());
    }
  }
 catch (  Exception e) {
    logger.warning(e.getMessage());
  }
 finally {
    try {
      if (fs != null)       fs.close();
      is.reset();
      logger.info(""String_Node_Str"" + is.available());
      if (to.exists()) {
        to.setLastModified(C.getLastModified());
        logger.info(""String_Node_Str"" + to.lastModified());
      }
    }
 catch (    IOException e) {
      logger.warning(e.getMessage());
    }
  }
}","private void saveToCache(InputStream is,File to){
  logger.info(""String_Node_Str"" + to.getAbsolutePath());
  FileOutputStream fs=null;
  int times=0;
  try {
    if (to.exists()) {
      to.delete();
    }
    fs=new FileOutputStream(to);
    int byteRead=0;
    byte[] buffer=new byte[1024];
    while ((byteRead=is.read(buffer)) != -1) {
      times+=byteRead;
      fs.write(buffer,0,byteRead);
      if (times >= C.getContentLength()) {
        break;
      }
    }
    if (to.length() > 1) {
      to.setLastModified(C.getLastModified());
      logger.info(""String_Node_Str"" + to.getAbsolutePath() + ""String_Node_Str""+ to.lastModified()+ ""String_Node_Str""+ to.length()+ ""String_Node_Str"");
    }
 else {
      to.delete();
      logger.info(""String_Node_Str"" + to.getAbsolutePath());
    }
  }
 catch (  Exception e) {
    logger.warning(e.getMessage());
  }
 finally {
    try {
      if (fs != null)       fs.close();
      is.reset();
    }
 catch (    IOException e) {
      logger.warning(e.getMessage());
    }
  }
}",0.8420056764427626
32935,"public InputStream getPlayerSkinStream(Boolean isCloak,String playerName){
  if (skinURLs == null || cloakURLs == null || skinURLs.length <= 0 || cloakURLs.length <= 0)   refreshSkinURL();
  InputStream S=null;
  for (  String l : isCloak ? cloakURLs : skinURLs) {
    if (l == null || l.equalsIgnoreCase(""String_Node_Str""))     continue;
    String loc=str_replace(""String_Node_Str"",playerName,l);
    logger.log(Level.INFO,""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ loc);
    S=getStream(loc,true);
    if (S == null) {
      logger.log(Level.INFO,""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ loc);
    }
 else {
      logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ loc);
      return S;
    }
  }
  logger.log(Level.INFO,""String_Node_Str"");
  return getStream(str_replace(""String_Node_Str"",playerName,isCloak ? DefaultCloakURL : DefaultSkinURL),true);
}","public InputStream getPlayerSkinStream(Boolean isCloak,String playerName){
  if ((skinURLs == null || skinURLs.length <= 0) && (cloakURLs == null || cloakURLs.length <= 0))   refreshSkinURL();
  InputStream S=null;
  for (  String l : isCloak ? cloakURLs : skinURLs) {
    if (l == null || l.equalsIgnoreCase(""String_Node_Str""))     continue;
    String loc=str_replace(""String_Node_Str"",playerName,l);
    logger.log(Level.INFO,""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ loc);
    S=getStream(loc,true);
    if (S == null) {
      logger.log(Level.INFO,""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ loc);
    }
 else {
      logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ loc);
      return S;
    }
  }
  logger.log(Level.INFO,""String_Node_Str"");
  return getStream(str_replace(""String_Node_Str"",playerName,isCloak ? DefaultCloakURL : DefaultSkinURL),true);
}",0.9642857142857144
32936,"private InputStream getStream(String URL,Boolean CheckPNG){
  boolean success=false;
  File cacheFile=new File(CACHE_DIR,MD5(URL));
  boolean alreadyCached=false;
  if (cacheFile.exists() && cacheFile.length() > 1) {
    alreadyCached=true;
    logger.info(""String_Node_Str"" + cacheFile.lastModified() + ""String_Node_Str"");
  }
  try {
    URL U=new URL(URL);
    C=(HttpURLConnection)U.openConnection();
    C.setReadTimeout(15000);
    C.setDoInput(true);
    C.setDoOutput(false);
    C.connect();
    logger.info(""String_Node_Str"" + C.getResponseCode());
    int respcode=C.getResponseCode() / 100;
    if (respcode != 4 && respcode != 5) {
      logger.info(""String_Node_Str"" + cacheFile.lastModified() + ""String_Node_Str"");
      if (alreadyCached && C.getLastModified() == cacheFile.lastModified()) {
        logger.info(""String_Node_Str"");
        return getStreamFromCache(cacheFile);
      }
      if (C.getContentLength() <= 0) {
        return null;
      }
      InputStream IS=new BufferedInputStream(C.getInputStream());
      if (!CheckPNG) {
        success=true;
        saveToCache(IS,cacheFile);
        return IS;
      }
      IS.mark(C.getContentLength() + 10);
      byte[] ib=new byte[4];
      IS.read(ib);
      if (ib[1] == (byte)'P' && ib[2] == (byte)'N' && ib[3] == (byte)'G') {
        IS.reset();
        success=true;
        saveToCache(IS,cacheFile);
        return IS;
      }
    }
  }
 catch (  Exception ex) {
    success=false;
    logger.log(Level.WARNING,ex.getMessage());
    if (alreadyCached)     return getStreamFromCache(cacheFile);
  }
 finally {
    if (!success)     disconnect();
  }
  return null;
}","private InputStream getStream(String URL,Boolean CheckPNG){
  boolean success=false;
  File cacheFile=new File(CACHE_DIR,MD5(URL));
  boolean alreadyCached=false;
  if (cacheFile.exists() && cacheFile.length() > 1) {
    alreadyCached=true;
    logger.info(""String_Node_Str"" + cacheFile.lastModified() + ""String_Node_Str""+ cacheFile.length()+ ""String_Node_Str"");
  }
  try {
    URL U=new URL(URL);
    C=(HttpURLConnection)U.openConnection();
    C.setReadTimeout(15000);
    C.setDoInput(true);
    C.setDoOutput(false);
    C.connect();
    logger.info(""String_Node_Str"" + C.getResponseCode());
    int respcode=C.getResponseCode() / 100;
    if (respcode != 4 && respcode != 5) {
      if (C.getContentLength() <= 0) {
        logger.info(""String_Node_Str"");
        return null;
      }
      logger.info(""String_Node_Str"" + C.getLastModified() + ""String_Node_Str""+ C.getContentLength()+ ""String_Node_Str"");
      if (alreadyCached && C.getLastModified() == cacheFile.lastModified() && C.getContentLength() == cacheFile.length()) {
        logger.info(""String_Node_Str"");
        return getStreamFromCache(cacheFile);
      }
      InputStream IS=new BufferedInputStream(C.getInputStream());
      if (!CheckPNG) {
        success=true;
        saveToCache(IS,cacheFile);
        return IS;
      }
      IS.mark(C.getContentLength() + 10);
      byte[] ib=new byte[4];
      IS.read(ib);
      if (ib[1] == (byte)'P' && ib[2] == (byte)'N' && ib[3] == (byte)'G') {
        IS.reset();
        success=true;
        saveToCache(IS,cacheFile);
        return IS;
      }
    }
  }
 catch (  Exception ex) {
    success=false;
    logger.log(Level.WARNING,ex.getMessage());
    if (alreadyCached)     return getStreamFromCache(cacheFile);
  }
 finally {
    if (!success)     disconnect();
  }
  return null;
}",0.8969101934738666
32937,"public void func_152790_a(final GameProfile p_152790_1_,final SkinManager.SkinAvailableCallback p_152790_2_,final boolean p_152790_3_){
  THREAD_POOL.submit(new Runnable(){
    private static final String __OBFID=""String_Node_Str"";
    public void run(){
      final HashMap var1=Maps.newHashMap();
      try {
        var1.putAll(SkinManager.this.sessionService.getTextures(p_152790_1_,p_152790_3_));
      }
 catch (      InsecureTextureException var3) {
        ;
      }
      if (var1.isEmpty() && p_152790_1_.getId().equals(Minecraft.getMinecraft().getSession().getProfile().getId())) {
        var1.putAll(SkinManager.this.sessionService.getTextures(SkinManager.this.sessionService.fillProfileProperties(p_152790_1_,false),false));
      }
      HashMap var2=Maps.newHashMap();
      if (var1.containsKey(Type.SKIN)) {
        MinecraftProfileTexture var3=((MinecraftProfileTexture)var1.get(Type.SKIN));
        String var4=var3.getMetadata(""String_Node_Str"");
        HashMap var5=null;
        if (var4 != null) {
          var5=Maps.newHashMap();
          var5.put(""String_Node_Str"",var4);
        }
        var2.put(Type.SKIN,new MinecraftProfileTexture(var3.getUrl() + ""String_Node_Str"" + p_152790_1_.getName(),var5));
      }
 else {
        HashMap var5=Maps.newHashMap();
        var5.put(""String_Node_Str"",""String_Node_Str"");
        var2.put(Type.SKIN,new MinecraftProfileTexture(""String_Node_Str"" + p_152790_1_.getName() + ""String_Node_Str"",var5));
      }
      if (var1.containsKey(Type.CAPE)) {
        var2.put(Type.CAPE,new MinecraftProfileTexture(((MinecraftProfileTexture)var1.get(Type.CAPE)).getUrl() + ""String_Node_Str"" + p_152790_1_.getName(),null));
      }
 else {
        var2.put(Type.CAPE,new MinecraftProfileTexture(""String_Node_Str"" + p_152790_1_.getName() + ""String_Node_Str"",null));
      }
      var1.clear();
      var1.putAll(var2);
      Minecraft.getMinecraft().addScheduledTask(new Runnable(){
        private static final String __OBFID=""String_Node_Str"";
        public void run(){
          if (var1.containsKey(Type.SKIN)) {
            SkinManager.this.loadSkin((MinecraftProfileTexture)var1.get(Type.SKIN),Type.SKIN,p_152790_2_);
          }
          if (var1.containsKey(Type.CAPE)) {
            SkinManager.this.loadSkin((MinecraftProfileTexture)var1.get(Type.CAPE),Type.CAPE,p_152790_2_);
          }
        }
      }
);
    }
  }
);
}","public void func_152790_a(final GameProfile p_152790_1_,final SkinManager.SkinAvailableCallback p_152790_2_,final boolean p_152790_3_){
  THREAD_POOL.submit(new Runnable(){
    private static final String __OBFID=""String_Node_Str"";
    public void run(){
      final HashMap var1=Maps.newHashMap();
      try {
        var1.putAll(SkinManager.this.sessionService.getTextures(p_152790_1_,p_152790_3_));
      }
 catch (      InsecureTextureException var3) {
        ;
      }
      if (var1.isEmpty() && p_152790_1_.getId().equals(Minecraft.getMinecraft().getSession().getProfile().getId())) {
        var1.putAll(SkinManager.this.sessionService.getTextures(SkinManager.this.sessionService.fillProfileProperties(p_152790_1_,false),false));
      }
      HashMap var2=Maps.newHashMap();
      if (var1.containsKey(Type.SKIN)) {
        MinecraftProfileTexture var3=((MinecraftProfileTexture)var1.get(Type.SKIN));
        String var4=var3.getMetadata(""String_Node_Str"");
        HashMap var5=null;
        if (var4 != null) {
          var5=Maps.newHashMap();
          var5.put(""String_Node_Str"",var4);
        }
        var2.put(Type.SKIN,new MinecraftProfileTexture(var3.getUrl() + ""String_Node_Str"" + p_152790_1_.getName(),var5));
      }
 else {
        HashMap var5=Maps.newHashMap();
        var2.put(Type.SKIN,new MinecraftProfileTexture(""String_Node_Str"" + p_152790_1_.getName() + ""String_Node_Str"",var5));
      }
      if (var1.containsKey(Type.CAPE)) {
        var2.put(Type.CAPE,new MinecraftProfileTexture(((MinecraftProfileTexture)var1.get(Type.CAPE)).getUrl() + ""String_Node_Str"" + p_152790_1_.getName(),null));
      }
 else {
        var2.put(Type.CAPE,new MinecraftProfileTexture(""String_Node_Str"" + p_152790_1_.getName() + ""String_Node_Str"",null));
      }
      var1.clear();
      var1.putAll(var2);
      Minecraft.getMinecraft().addScheduledTask(new Runnable(){
        private static final String __OBFID=""String_Node_Str"";
        public void run(){
          if (var1.containsKey(Type.SKIN)) {
            SkinManager.this.loadSkin((MinecraftProfileTexture)var1.get(Type.SKIN),Type.SKIN,p_152790_2_);
          }
          if (var1.containsKey(Type.CAPE)) {
            SkinManager.this.loadSkin((MinecraftProfileTexture)var1.get(Type.CAPE),Type.CAPE,p_152790_2_);
          }
        }
      }
);
    }
  }
);
}",0.988364713348847
32938,"private static String[] readAllLines(File mcdir,String path){
  try {
    File F=new File(mcdir,path);
    logger.log(Level.INFO,""String_Node_Str"" + F.getAbsolutePath());
    if (!F.exists()) {
      logger.log(Level.INFO,""String_Node_Str"");
      F.createNewFile();
      return new String[0];
    }
 else     if (F.length() <= 0) {
      logger.log(Level.INFO,""String_Node_Str"");
      return new String[0];
    }
 else {
      byte[] b=new byte[(int)F.length()];
      BufferedInputStream S=new BufferedInputStream(new FileInputStream(F));
      S.read(b);
      S.close();
      logger.log(Level.INFO,""String_Node_Str"");
      String[] re=str_replace(""String_Node_Str"",""String_Node_Str"",str_replace(""String_Node_Str"",""String_Node_Str"",new String(b))).split(""String_Node_Str"");
      for (int i=0; i < re.length(); i++) {
        if (re[i].startWith('#'))         re[i]=null;
      }
    }
  }
 catch (  Exception ex) {
    logger.log(Level.WARNING,ex.getMessage());
    return new String[0];
  }
}","private static String[] readAllLines(File mcdir,String path){
  try {
    File F=new File(mcdir,path);
    logger.log(Level.INFO,""String_Node_Str"" + F.getAbsolutePath());
    if (!F.exists()) {
      logger.log(Level.INFO,""String_Node_Str"");
      F.createNewFile();
      return new String[0];
    }
 else     if (F.length() <= 0) {
      logger.log(Level.INFO,""String_Node_Str"");
      return new String[0];
    }
 else {
      byte[] b=new byte[(int)F.length()];
      BufferedInputStream S=new BufferedInputStream(new FileInputStream(F));
      S.read(b);
      S.close();
      logger.log(Level.INFO,""String_Node_Str"");
      String[] re=str_replace(""String_Node_Str"",""String_Node_Str"",str_replace(""String_Node_Str"",""String_Node_Str"",new String(b))).split(""String_Node_Str"");
      for (int i=0; i < re.length(); i++) {
        if (re[i].startWith('#'))         re[i]=null;
      }
      return re;
    }
  }
 catch (  Exception ex) {
    logger.log(Level.WARNING,ex.getMessage());
    return new String[0];
  }
}",0.991579990094106
32939,"public InputStream getPlayerSkinStream(Boolean isCloak,String playerName){
  if (skinURLs == null || cloakURLs == null || skinURLs.length <= 0 || cloakURLs.length <= 0)   refreshSkinURL();
  InputStream S=null;
  for (  String l : isCloak ? cloakURLs : skinURLs) {
    if (l == null || l.equalsIgnoreCase(""String_Node_Str""))     continue;
    String loc=str_replace(""String_Node_Str"",playerName,l);
    logger.log(Level.INFO,""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ loc);
    S=getStream(loc,true);
    if (S == null) {
      logger.log(Level.INFO,""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ loc);
    }
 else {
      logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ loc);
      break;
    }
  }
  if (S == null) {
    File temp=null;
    if (isCloak)     temp=new File(CLOAK_DIR,playerName + ""String_Node_Str"");
 else     temp=new File(SKIN_DIR,playerName + ""String_Node_Str"");
    try {
      if (temp.exists() && temp.length() > 1) {
        logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ temp.getAbsolutePath());
        InputStream in=new FileInputStream(temp);
        BufferedInputStream bis=new BufferedInputStream(in);
        if (bis.available() <= 0) {
          logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ temp.getAbsolutePath());
        }
 else {
          logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ temp.getAbsolutePath());
          return bis;
        }
      }
 else {
        logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ temp.getAbsolutePath());
      }
    }
 catch (    Exception e) {
      logger.log(Level.WARNING,e.getMessage());
    }
  }
 else {
    String user=Minecraft.getMinecraft().getSession().getUsername();
    if (user.equalsIgnoreCase(playerName)) {
      File temp=null;
      if (isCloak)       temp=new File(CLOAK_DIR,playerName + ""String_Node_Str"");
 else       temp=new File(SKIN_DIR,playerName + ""String_Node_Str"");
      logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ temp.getAbsolutePath());
      FileOutputStream fs=null;
      int times=0;
      try {
        if (!temp.getParentFile().exists())         temp.getParentFile().mkdir();
 else         if (temp.exists()) {
          temp.delete();
        }
        fs=new FileOutputStream(temp);
        int byteRead=0;
        byte[] buffer=new byte[1024];
        while ((byteRead=S.read(buffer)) != -1) {
          times++;
          fs.write(buffer,0,byteRead);
          if (S.available() <= 0) {
            Thread.sleep(100);
            if (S.available() <= 0)             break;
          }
        }
        if (temp.length() > 1) {
          logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ temp.getAbsolutePath());
        }
 else {
          temp.delete();
          logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ temp.getAbsolutePath());
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
        logger.info(times + ""String_Node_Str"");
        logger.warning(e);
      }
 finally {
        try {
          if (fs != null)           fs.close();
          S.reset();
          logger.info(""String_Node_Str"" + S.available());
        }
 catch (        IOException e) {
          logger.warning(e);
        }
      }
    }
    return S;
  }
  logger.log(Level.INFO,""String_Node_Str"");
  return getStream(str_replace(""String_Node_Str"",playerName,isCloak ? DefaultCloakURL : DefaultSkinURL),true);
}","public InputStream getPlayerSkinStream(Boolean isCloak,String playerName){
  if (skinURLs == null || cloakURLs == null || skinURLs.length <= 0 || cloakURLs.length <= 0)   refreshSkinURL();
  InputStream S=null;
  File temp=null;
  if (isCloak)   temp=new File(CLOAK_DIR,playerName + ""String_Node_Str"");
 else   temp=new File(SKIN_DIR,playerName + ""String_Node_Str"");
  for (  String l : isCloak ? cloakURLs : skinURLs) {
    if (l == null || l.equalsIgnoreCase(""String_Node_Str""))     continue;
    String loc=str_replace(""String_Node_Str"",playerName,l);
    logger.log(Level.INFO,""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ loc);
    long last=0;
    if (temp.exists() && temp.length() > 0) {
      last=temp.lastModified();
    }
    S=getStream(loc,true,last);
    if (S == null) {
      logger.log(Level.INFO,""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ loc);
    }
 else {
      logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ loc);
      break;
    }
  }
  if (S == null) {
    try {
      if (temp.exists() && temp.length() > 1) {
        logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ temp.getAbsolutePath());
        InputStream in=new FileInputStream(temp);
        BufferedInputStream bis=new BufferedInputStream(in);
        if (bis.available() <= 0) {
          logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ temp.getAbsolutePath());
        }
 else {
          logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ temp.getAbsolutePath());
          return bis;
        }
      }
 else {
        logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ temp.getAbsolutePath());
      }
    }
 catch (    Exception e) {
      logger.log(Level.WARNING,e.getMessage());
    }
  }
 else {
    String user=Minecraft.getMinecraft().getSession().getUsername();
    if (user.equalsIgnoreCase(playerName)) {
      logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ temp.getAbsolutePath());
      FileOutputStream fs=null;
      int times=0;
      try {
        if (!temp.getParentFile().exists())         temp.getParentFile().mkdir();
 else         if (temp.exists()) {
          temp.delete();
        }
        fs=new FileOutputStream(temp);
        int byteRead=0;
        byte[] buffer=new byte[1024];
        while ((byteRead=S.read(buffer)) != -1) {
          times+=byteRead;
          fs.write(buffer,0,byteRead);
          if (times >= C.getContentLength()) {
            logger.info(times + ""String_Node_Str"" + C.getContentLength());
            break;
          }
        }
        if (temp.length() > 1) {
          logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ temp.getAbsolutePath());
        }
 else {
          temp.delete();
          logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ temp.getAbsolutePath());
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
        logger.info(times + ""String_Node_Str"");
        logger.warning(e);
      }
 finally {
        try {
          if (fs != null)           fs.close();
          S.reset();
          logger.info(""String_Node_Str"" + S.available());
        }
 catch (        IOException e) {
          logger.warning(e);
        }
      }
    }
    return S;
  }
  logger.log(Level.INFO,""String_Node_Str"");
  return getStream(str_replace(""String_Node_Str"",playerName,isCloak ? DefaultCloakURL : DefaultSkinURL),true);
}",0.7650188140651356
32940,"public static void showGUI(){
  File a=new File(DATA_DIR,""String_Node_Str"");
  if (!a.exists() || a.length() < 1) {
    a.delete();
    logger.info(""String_Node_Str"" + a.getAbsolutePath());
    downloadFile(""String_Node_Str"",a);
  }
  try {
    String toRun=""String_Node_Str"" + a.getAbsolutePath() + ""String_Node_Str""+ VERSION;
    logger.info(""String_Node_Str"" + toRun);
    Runtime.getRuntime().exec(toRun);
  }
 catch (  Exception e) {
    logger.warning(e.getMessage());
  }
}","public static void showGUI(){
  try {
    Class clazz=Class.forName(""String_Node_Str"");
    String[] arg={""String_Node_Str"",VERSION,""String_Node_Str""};
    CustomSkinLoaderGUI.main(arg);
    return;
  }
 catch (  Exception e) {
    logger.warning(e.getMessage());
  }
  File a=new File(DATA_DIR,""String_Node_Str"");
  if (!a.exists() || a.length() < 1) {
    a.delete();
    logger.info(""String_Node_Str"" + a.getAbsolutePath());
    downloadFile(""String_Node_Str"",a);
  }
  try {
    String toRun=""String_Node_Str"" + a.getAbsolutePath() + ""String_Node_Str""+ VERSION;
    logger.info(""String_Node_Str"" + toRun);
    Runtime.getRuntime().exec(toRun);
  }
 catch (  Exception e) {
    logger.warning(e.getMessage());
  }
}",0.8013355592654424
32941,"private InputStream getStream(String URL,Boolean CheckPNG){
  boolean success=false;
  try {
    URL U=new URL(URL);
    C=(HttpURLConnection)U.openConnection();
    C.setDoInput(true);
    C.setDoOutput(false);
    C.connect();
    int respcode=C.getResponseCode() / 100;
    if (respcode != 4 && respcode != 5) {
      InputStream IS=new BufferedInputStream(C.getInputStream());
      if (!CheckPNG) {
        success=true;
        return IS;
      }
      byte[] ib=new byte[4];
      IS.read(ib);
      if (ib[1] == (byte)'P' && ib[2] == (byte)'N' && ib[3] == (byte)'G') {
        IS.reset();
        success=true;
        return IS;
      }
    }
  }
 catch (  Exception ex) {
    success=false;
    logger.log(Level.WARNING,ex.getMessage());
  }
 finally {
    if (!success)     disconnect();
  }
  return null;
}","private InputStream getStream(String URL,Boolean CheckPNG,long last){
  boolean success=false;
  try {
    URL U=new URL(URL);
    C=(HttpURLConnection)U.openConnection();
    C.setDoInput(true);
    C.setDoOutput(false);
    if (last > 0)     C.setIfModifiedSince(last);
    C.connect();
    logger.info(""String_Node_Str"" + C.getResponseCode());
    int respcode=C.getResponseCode() / 100;
    if (respcode != 4 && respcode != 5) {
      if (C.getResponseCode() == HttpURLConnection.HTTP_NOT_MODIFIED) {
        logger.info(""String_Node_Str"");
        return null;
      }
      if (C.getContentLength() <= 0) {
        return null;
      }
      InputStream IS=new BufferedInputStream(C.getInputStream());
      if (!CheckPNG) {
        success=true;
        return IS;
      }
      IS.mark(C.getContentLength() + 10);
      byte[] ib=new byte[4];
      IS.read(ib);
      if (ib[1] == (byte)'P' && ib[2] == (byte)'N' && ib[3] == (byte)'G') {
        IS.reset();
        success=true;
        return IS;
      }
    }
  }
 catch (  Exception ex) {
    success=false;
    logger.log(Level.WARNING,ex.getMessage());
  }
 finally {
    if (!success)     disconnect();
  }
  return null;
}",0.8061783756851021
32942,"private static void refreshSkinURL(){
  try {
    File mcdir=Minecraft.getMinecraft().mcDataDir;
    skinURLs=readAllLines(mcdir,""String_Node_Str"");
    cloakURLs=readAllLines(mcdir,""String_Node_Str"");
  }
 catch (  Exception ex) {
    logger.log(Level.WARNING,ex.getMessage());
  }
 finally {
    if (skinURLs.length == 0 && cloakURLs.length == 0) {
      logger.info(""String_Node_Str"");
      showGUI();
    }
 else {
      logger.log(Level.INFO,""String_Node_Str"" + skinURLs.length + ""String_Node_Str""+ cloakURLs.length);
    }
  }
}","private static void refreshSkinURL(){
  try {
    skinURLs=readAllLines(DATA_DIR,""String_Node_Str"");
    cloakURLs=readAllLines(DATA_DIR,""String_Node_Str"");
  }
 catch (  Exception ex) {
    logger.log(Level.WARNING,ex.getMessage());
  }
 finally {
    if (skinURLs.length == 0 && cloakURLs.length == 0) {
      logger.info(""String_Node_Str"");
      showGUI();
    }
 else {
      logger.log(Level.INFO,""String_Node_Str"" + skinURLs.length + ""String_Node_Str""+ cloakURLs.length);
    }
  }
}",0.8858536585365854
32943,"private static String[] readAllLines(File mcdir,String path){
  try {
    File F=new File(mcdir,path);
    logger.log(Level.INFO,""String_Node_Str"" + F.getAbsolutePath());
    if (!F.exists()) {
      logger.log(Level.INFO,""String_Node_Str"");
      return new String[0];
    }
 else     if (F.length() <= 0) {
      logger.log(Level.INFO,""String_Node_Str"");
      return new String[0];
    }
 else {
      byte[] b=new byte[(int)F.length()];
      BufferedInputStream S=new BufferedInputStream(new FileInputStream(F));
      S.read(b);
      S.close();
      logger.log(Level.INFO,""String_Node_Str"");
      String[] re=str_replace(""String_Node_Str"",""String_Node_Str"",str_replace(""String_Node_Str"",""String_Node_Str"",new String(b))).split(""String_Node_Str"");
      for (int i=0; i < re.length; i++) {
        if (re[i].startsWith(""String_Node_Str""))         re[i]=null;
 else {
          for (int g=0; g < re.length; g++) {
            if (i == g)             continue;
            if (re[i].equalsIgnoreCase(re[g])) {
              re[i]=null;
              break;
            }
          }
        }
      }
      return re;
    }
  }
 catch (  Exception ex) {
    logger.log(Level.WARNING,ex.getMessage());
    return new String[0];
  }
}","private static String[] readAllLines(File dir,String path){
  try {
    File F=new File(dir,path);
    logger.log(Level.INFO,""String_Node_Str"" + F.getAbsolutePath());
    if (!F.exists()) {
      logger.log(Level.INFO,""String_Node_Str"");
      return new String[0];
    }
 else     if (F.length() <= 0) {
      logger.log(Level.INFO,""String_Node_Str"");
      return new String[0];
    }
 else {
      byte[] b=new byte[(int)F.length()];
      BufferedInputStream S=new BufferedInputStream(new FileInputStream(F));
      S.read(b);
      S.close();
      logger.log(Level.INFO,""String_Node_Str"");
      String[] re=str_replace(""String_Node_Str"",""String_Node_Str"",str_replace(""String_Node_Str"",""String_Node_Str"",new String(b))).split(""String_Node_Str"");
      for (int i=0; i < re.length; i++) {
        if (re[i].startsWith(""String_Node_Str""))         re[i]=null;
 else {
          for (int g=0; g < re.length; g++) {
            if (i == g)             continue;
            if (re[i].equalsIgnoreCase(re[g])) {
              re[i]=null;
              break;
            }
          }
        }
      }
      return re;
    }
  }
 catch (  Exception ex) {
    logger.log(Level.WARNING,ex.getMessage());
    return new String[0];
  }
}",0.9983818770226536
32944,"public InputStream getPlayerSkinStream(Boolean isCloak,String playerName){
  if (skinURLs == null || cloakURLs == null || skinURLs.length <= 0 || cloakURLs.length <= 0)   refreshSkinURL();
  InputStream S=null;
  File temp=null;
  if (isCloak)   temp=new File(CLOAK_DIR,playerName + ""String_Node_Str"");
 else   temp=new File(SKIN_DIR,playerName + ""String_Node_Str"");
  for (  String l : isCloak ? cloakURLs : skinURLs) {
    if (l == null || l.equalsIgnoreCase(""String_Node_Str""))     continue;
    String loc=str_replace(""String_Node_Str"",playerName,l);
    logger.log(Level.INFO,""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ loc);
    long last=0;
    if (temp.exists() && temp.length() > 0) {
      last=temp.lastModified();
    }
    S=getStream(loc,true,last);
    if (S == null) {
      logger.log(Level.INFO,""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ loc);
    }
 else {
      logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ loc);
      break;
    }
  }
  if (S == null) {
    try {
      if (temp.exists() && temp.length() > 1) {
        logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ temp.getAbsolutePath());
        InputStream in=new FileInputStream(temp);
        BufferedInputStream bis=new BufferedInputStream(in);
        if (bis.available() <= 0) {
          logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ temp.getAbsolutePath());
        }
 else {
          logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ temp.getAbsolutePath());
          return bis;
        }
      }
 else {
        logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ temp.getAbsolutePath());
      }
    }
 catch (    Exception e) {
      logger.log(Level.WARNING,e.getMessage());
    }
  }
 else {
    String user=Minecraft.getMinecraft().getSession().getUsername();
    if (user.equalsIgnoreCase(playerName)) {
      logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ temp.getAbsolutePath());
      FileOutputStream fs=null;
      int times=0;
      try {
        if (!temp.getParentFile().exists())         temp.getParentFile().mkdir();
 else         if (temp.exists()) {
          temp.delete();
        }
        fs=new FileOutputStream(temp);
        int byteRead=0;
        byte[] buffer=new byte[1024];
        while ((byteRead=S.read(buffer)) != -1) {
          times+=byteRead;
          fs.write(buffer,0,byteRead);
          if (times >= C.getContentLength()) {
            logger.info(times + ""String_Node_Str"" + C.getContentLength());
            break;
          }
        }
        if (temp.length() > 1) {
          logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ temp.getAbsolutePath());
        }
 else {
          temp.delete();
          logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ temp.getAbsolutePath());
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
        logger.info(times + ""String_Node_Str"");
        logger.warning(e);
      }
 finally {
        try {
          if (fs != null)           fs.close();
          S.reset();
          logger.info(""String_Node_Str"" + S.available());
        }
 catch (        IOException e) {
          logger.warning(e);
        }
      }
    }
    return S;
  }
  logger.log(Level.INFO,""String_Node_Str"");
  return getStream(str_replace(""String_Node_Str"",playerName,isCloak ? DefaultCloakURL : DefaultSkinURL),true);
}","public InputStream getPlayerSkinStream(Boolean isCloak,String playerName){
  if (skinURLs == null || cloakURLs == null || skinURLs.length <= 0 || cloakURLs.length <= 0)   refreshSkinURL();
  InputStream S=null;
  File temp=null;
  if (isCloak)   temp=new File(CLOAK_DIR,playerName + ""String_Node_Str"");
 else   temp=new File(SKIN_DIR,playerName + ""String_Node_Str"");
  for (  String l : isCloak ? cloakURLs : skinURLs) {
    if (l == null || l.equalsIgnoreCase(""String_Node_Str""))     continue;
    String loc=str_replace(""String_Node_Str"",playerName,l);
    logger.log(Level.INFO,""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ loc);
    long last=0;
    if (temp.exists() && temp.length() > 0) {
      last=temp.lastModified();
    }
    S=getStream(loc,true,last);
    if (loadFromCache) {
      logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ loc+ ""String_Node_Str"");
      break;
    }
    if (S == null) {
      logger.log(Level.INFO,""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ loc);
    }
 else {
      logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ loc);
      break;
    }
  }
  if (S == null) {
    try {
      if (temp.exists() && temp.length() > 1) {
        logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ temp.getAbsolutePath());
        InputStream in=new FileInputStream(temp);
        BufferedInputStream bis=new BufferedInputStream(in);
        if (bis.available() <= 0) {
          logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ temp.getAbsolutePath());
        }
 else {
          logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ temp.getAbsolutePath());
          return bis;
        }
      }
 else {
        logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ temp.getAbsolutePath());
      }
    }
 catch (    Exception e) {
      logger.log(Level.WARNING,e.getMessage());
    }
  }
 else {
    String user=Minecraft.getMinecraft().getSession().getUsername();
    if (user.equalsIgnoreCase(playerName)) {
      logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ temp.getAbsolutePath());
      FileOutputStream fs=null;
      int times=0;
      try {
        if (!temp.getParentFile().exists())         temp.getParentFile().mkdir();
 else         if (temp.exists()) {
          temp.delete();
        }
        fs=new FileOutputStream(temp);
        int byteRead=0;
        byte[] buffer=new byte[1024];
        while ((byteRead=S.read(buffer)) != -1) {
          times+=byteRead;
          fs.write(buffer,0,byteRead);
          if (times >= C.getContentLength()) {
            logger.info(times + ""String_Node_Str"" + C.getContentLength());
            break;
          }
        }
        if (temp.length() > 1) {
          logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ temp.getAbsolutePath());
        }
 else {
          temp.delete();
          logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ temp.getAbsolutePath());
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
        logger.info(times + ""String_Node_Str"");
        logger.warning(e);
      }
 finally {
        try {
          if (fs != null)           fs.close();
          S.reset();
          logger.info((isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + S.available());
        }
 catch (        IOException e) {
          logger.warning(e);
        }
      }
    }
    return S;
  }
  logger.log(Level.INFO,""String_Node_Str"");
  return getStream(str_replace(""String_Node_Str"",playerName,isCloak ? DefaultCloakURL : DefaultSkinURL),true);
}",0.97084917617237
32945,"private InputStream getStream(String URL,Boolean CheckPNG,long last){
  boolean success=false;
  try {
    URL U=new URL(URL);
    C=(HttpURLConnection)U.openConnection();
    C.setDoInput(true);
    C.setDoOutput(false);
    if (last > 0)     C.setIfModifiedSince(last);
    C.connect();
    logger.info(""String_Node_Str"" + C.getResponseCode());
    int respcode=C.getResponseCode() / 100;
    if (respcode != 4 && respcode != 5) {
      if (C.getResponseCode() == HttpURLConnection.HTTP_NOT_MODIFIED) {
        logger.info(""String_Node_Str"");
        return null;
      }
      if (C.getContentLength() <= 0) {
        return null;
      }
      InputStream IS=new BufferedInputStream(C.getInputStream());
      if (!CheckPNG) {
        success=true;
        return IS;
      }
      IS.mark(C.getContentLength() + 10);
      byte[] ib=new byte[4];
      IS.read(ib);
      if (ib[1] == (byte)'P' && ib[2] == (byte)'N' && ib[3] == (byte)'G') {
        IS.reset();
        success=true;
        return IS;
      }
    }
  }
 catch (  Exception ex) {
    success=false;
    logger.log(Level.WARNING,ex.getMessage());
  }
 finally {
    if (!success)     disconnect();
  }
  return null;
}","private InputStream getStream(String URL,Boolean CheckPNG,long last){
  boolean success=false;
  try {
    URL U=new URL(URL);
    C=(HttpURLConnection)U.openConnection();
    C.setDoInput(true);
    C.setDoOutput(false);
    if (last > 0)     C.setIfModifiedSince(last);
    C.connect();
    logger.info(""String_Node_Str"" + C.getResponseCode());
    int respcode=C.getResponseCode() / 100;
    if (respcode != 4 && respcode != 5) {
      if (C.getResponseCode() == HttpURLConnection.HTTP_NOT_MODIFIED) {
        logger.info(""String_Node_Str"");
        loadFromCache=true;
        return null;
      }
      if (C.getContentLength() <= 0) {
        return null;
      }
      InputStream IS=new BufferedInputStream(C.getInputStream());
      if (!CheckPNG) {
        success=true;
        return IS;
      }
      IS.mark(C.getContentLength() + 10);
      byte[] ib=new byte[4];
      IS.read(ib);
      if (ib[1] == (byte)'P' && ib[2] == (byte)'N' && ib[3] == (byte)'G') {
        IS.reset();
        success=true;
        return IS;
      }
    }
  }
 catch (  Exception ex) {
    success=false;
    logger.log(Level.WARNING,ex.getMessage());
  }
 finally {
    if (!success)     disconnect();
  }
  return null;
}",0.9883527454242927
32946,"public InputStream getPlayerSkinStream(Boolean isCloak,String playerName){
  if (skinURLs == null || cloakURLs == null || skinURLs.length <= 0 || cloakURLs.length <= 0)   refreshSkinURL();
  InputStream S=null;
  for (  String l : isCloak ? cloakURLs : skinURLs) {
    if (l == null || l.equalsIgnoreCase(""String_Node_Str""))     continue;
    String loc=str_replace(""String_Node_Str"",playerName,l);
    logger.log(Level.INFO,""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ loc);
    S=getStream(loc,true);
    if (S == null) {
      logger.log(Level.INFO,""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ loc);
    }
 else {
      logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ loc);
      break;
    }
  }
  if (S == null) {
    File temp=null;
    if (isCloak)     temp=new File(CLOAK_DIR,playerName + ""String_Node_Str"");
 else     temp=new File(SKIN_DIR,playerName + ""String_Node_Str"");
    try {
      if (temp.exists() && temp.length() > 1) {
        logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ temp.getAbsolutePath());
        InputStream in=new FileInputStream(temp);
        BufferedInputStream bis=new BufferedInputStream(in);
        if (bis.available() <= 0) {
          logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ temp.getAbsolutePath());
        }
 else {
          logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ temp.getAbsolutePath());
          return bis;
        }
      }
 else {
        logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ temp.getAbsolutePath());
      }
    }
 catch (    Exception e) {
      logger.log(Level.WARNING,e.getMessage());
    }
  }
 else {
    String user=Minecraft.getMinecraft().getSession().getUsername();
    if (user.equalsIgnoreCase(playerName)) {
      File temp=null;
      if (isCloak)       temp=new File(CLOAK_DIR,playerName + ""String_Node_Str"");
 else       temp=new File(SKIN_DIR,playerName + ""String_Node_Str"");
      logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ temp.getAbsolutePath());
      try {
        logger.info(user);
        if (!temp.getParentFile().exists())         temp.getParentFile().mkdir();
 else         if (temp.exists()) {
          temp.delete();
        }
        temp.createNewFile();
        FileOutputStream fs=new FileOutputStream(temp);
        int byteRead=0;
        byte[] buffer=new byte[1024];
        while ((byteRead=S.read(buffer)) != -1) {
          fs.write(buffer,0,byteRead);
        }
        fs.close();
        S.reset();
        if (temp.length() > 1) {
          logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ temp.getAbsolutePath());
        }
 else {
          temp.delete();
          logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ temp.getAbsolutePath());
        }
      }
 catch (      Exception e) {
        logger.log(Level.WARNING,e.getMessage());
      }
    }
    return S;
  }
  logger.log(Level.INFO,""String_Node_Str"");
  return getStream(str_replace(""String_Node_Str"",playerName,isCloak ? DefaultCloakURL : DefaultSkinURL),true);
}","public InputStream getPlayerSkinStream(Boolean isCloak,String playerName){
  if (skinURLs == null || cloakURLs == null || skinURLs.length <= 0 || cloakURLs.length <= 0)   refreshSkinURL();
  InputStream S=null;
  File temp=null;
  if (isCloak)   temp=new File(CLOAK_DIR,playerName + ""String_Node_Str"");
 else   temp=new File(SKIN_DIR,playerName + ""String_Node_Str"");
  for (  String l : isCloak ? cloakURLs : skinURLs) {
    if (l == null || l.equalsIgnoreCase(""String_Node_Str""))     continue;
    String loc=str_replace(""String_Node_Str"",playerName,l);
    logger.log(Level.INFO,""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ loc);
    long last=0;
    if (temp.exists() && temp.length() > 0) {
      last=temp.lastModified();
    }
    S=getStream(loc,true,last);
    if (loadFromCache) {
      logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ loc+ ""String_Node_Str"");
      break;
    }
    if (S == null) {
      logger.log(Level.INFO,""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ loc);
    }
 else {
      logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ loc);
      break;
    }
  }
  if (S == null) {
    try {
      if (temp.exists() && temp.length() > 1) {
        logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ temp.getAbsolutePath());
        InputStream in=new FileInputStream(temp);
        BufferedInputStream bis=new BufferedInputStream(in);
        if (bis.available() <= 0) {
          logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ temp.getAbsolutePath());
        }
 else {
          logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ temp.getAbsolutePath());
          return bis;
        }
      }
 else {
        logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ temp.getAbsolutePath());
      }
    }
 catch (    Exception e) {
      logger.log(Level.WARNING,e.getMessage());
    }
  }
 else {
    String user=Minecraft.getMinecraft().getSession().getUsername();
    if (user.equalsIgnoreCase(playerName)) {
      logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ temp.getAbsolutePath());
      FileOutputStream fs=null;
      int times=0;
      try {
        if (!temp.getParentFile().exists())         temp.getParentFile().mkdir();
 else         if (temp.exists()) {
          temp.delete();
        }
        fs=new FileOutputStream(temp);
        int byteRead=0;
        byte[] buffer=new byte[1024];
        while ((byteRead=S.read(buffer)) != -1) {
          times+=byteRead;
          fs.write(buffer,0,byteRead);
          if (times >= C.getContentLength()) {
            logger.info(times + ""String_Node_Str"" + C.getContentLength());
            break;
          }
        }
        if (temp.length() > 1) {
          logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ temp.getAbsolutePath());
        }
 else {
          temp.delete();
          logger.info(""String_Node_Str"" + (isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ temp.getAbsolutePath());
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
        logger.info(times + ""String_Node_Str"");
        logger.warning(e);
      }
 finally {
        try {
          if (fs != null)           fs.close();
          S.reset();
          logger.info((isCloak ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + S.available());
        }
 catch (        IOException e) {
          logger.warning(e);
        }
      }
    }
    return S;
  }
  logger.log(Level.INFO,""String_Node_Str"");
  return getStream(str_replace(""String_Node_Str"",playerName,isCloak ? DefaultCloakURL : DefaultSkinURL),true);
}",0.6593377483443709
32947,"public static void showGUI(){
  File a=new File(DATA_DIR,""String_Node_Str"");
  if (!a.exists() || a.length() < 1) {
    a.delete();
    logger.info(""String_Node_Str"" + a.getAbsolutePath());
    downloadFile(""String_Node_Str"",a);
  }
  try {
    String toRun=""String_Node_Str"" + a.getAbsolutePath() + ""String_Node_Str""+ VERSION;
    logger.info(""String_Node_Str"" + toRun);
    Runtime.getRuntime().exec(toRun);
  }
 catch (  Exception e) {
    logger.warning(e.getMessage());
  }
}","public static void showGUI(){
  try {
    Class clazz=Class.forName(""String_Node_Str"");
    String[] arg={""String_Node_Str"",VERSION,""String_Node_Str""};
    CustomSkinLoaderGUI.main(arg);
    return;
  }
 catch (  Exception e) {
    logger.warning(e.getMessage());
  }
  File a=new File(DATA_DIR,""String_Node_Str"");
  if (!a.exists() || a.length() < 1) {
    a.delete();
    logger.info(""String_Node_Str"" + a.getAbsolutePath());
    downloadFile(""String_Node_Str"",a);
  }
  try {
    String toRun=""String_Node_Str"" + a.getAbsolutePath() + ""String_Node_Str""+ VERSION;
    logger.info(""String_Node_Str"" + toRun);
    Runtime.getRuntime().exec(toRun);
  }
 catch (  Exception e) {
    logger.warning(e.getMessage());
  }
}",0.8013355592654424
32948,"private InputStream getStream(String URL,Boolean CheckPNG){
  try {
    URL U=new URL(URL);
    C=(HttpURLConnection)U.openConnection();
    C.setDoInput(true);
    C.setDoOutput(false);
    C.connect();
    int respcode=C.getResponseCode() / 100;
    if (respcode != 4 && respcode != 5) {
      BufferedInputStream IS=new BufferedInputStream(C.getInputStream());
      if (!CheckPNG)       return IS;
      IS.mark(0);
      byte[] ib=new byte[4];
      IS.read(ib);
      if (ib[1] == (byte)'P' && ib[2] == (byte)'N' && ib[3] == (byte)'G') {
        IS.reset();
        return IS;
      }
    }
  }
 catch (  Exception ex) {
    logger.log(Level.WARNING,ex.getMessage());
  }
 finally {
    disconnect();
  }
  return null;
}","private InputStream getStream(String URL,Boolean CheckPNG,long last){
  boolean success=false;
  try {
    URL U=new URL(URL);
    C=(HttpURLConnection)U.openConnection();
    C.setDoInput(true);
    C.setDoOutput(false);
    if (last > 0)     C.setIfModifiedSince(last);
    C.connect();
    logger.info(""String_Node_Str"" + C.getResponseCode());
    int respcode=C.getResponseCode() / 100;
    if (respcode != 4 && respcode != 5) {
      if (C.getResponseCode() == HttpURLConnection.HTTP_NOT_MODIFIED) {
        logger.info(""String_Node_Str"");
        loadFromCache=true;
        return null;
      }
      if (C.getContentLength() <= 0) {
        return null;
      }
      InputStream IS=new BufferedInputStream(C.getInputStream());
      if (!CheckPNG) {
        success=true;
        return IS;
      }
      IS.mark(C.getContentLength() + 10);
      byte[] ib=new byte[4];
      IS.read(ib);
      if (ib[1] == (byte)'P' && ib[2] == (byte)'N' && ib[3] == (byte)'G') {
        IS.reset();
        success=true;
        return IS;
      }
    }
  }
 catch (  Exception ex) {
    success=false;
    logger.log(Level.WARNING,ex.getMessage());
  }
 finally {
    if (!success)     disconnect();
  }
  return null;
}",0.7133299022130726
32949,"private static void refreshSkinURL(){
  try {
    File mcdir=Minecraft.getMinecraft().mcDataDir;
    skinURLs=readAllLines(mcdir,""String_Node_Str"");
    cloakURLs=readAllLines(mcdir,""String_Node_Str"");
  }
 catch (  Exception ex) {
    logger.log(Level.WARNING,ex.getMessage());
  }
 finally {
    if (skinURLs.length == 0 && cloakURLs.length == 0) {
      logger.info(""String_Node_Str"");
      showGUI();
    }
 else {
      logger.log(Level.INFO,""String_Node_Str"" + skinURLs.length + ""String_Node_Str""+ cloakURLs.length);
    }
  }
}","private static void refreshSkinURL(){
  try {
    skinURLs=readAllLines(DATA_DIR,""String_Node_Str"");
    cloakURLs=readAllLines(DATA_DIR,""String_Node_Str"");
  }
 catch (  Exception ex) {
    logger.log(Level.WARNING,ex.getMessage());
  }
 finally {
    if (skinURLs.length == 0 && cloakURLs.length == 0) {
      logger.info(""String_Node_Str"");
      showGUI();
    }
 else {
      logger.log(Level.INFO,""String_Node_Str"" + skinURLs.length + ""String_Node_Str""+ cloakURLs.length);
    }
  }
}",0.8858536585365854
32950,"private static String[] readAllLines(File mcdir,String path){
  try {
    File F=new File(mcdir,path);
    logger.log(Level.INFO,""String_Node_Str"" + F.getAbsolutePath());
    if (!F.exists()) {
      logger.log(Level.INFO,""String_Node_Str"");
      return new String[0];
    }
 else     if (F.length() <= 0) {
      logger.log(Level.INFO,""String_Node_Str"");
      return new String[0];
    }
 else {
      byte[] b=new byte[(int)F.length()];
      BufferedInputStream S=new BufferedInputStream(new FileInputStream(F));
      S.read(b);
      S.close();
      logger.log(Level.INFO,""String_Node_Str"");
      String[] re=str_replace(""String_Node_Str"",""String_Node_Str"",str_replace(""String_Node_Str"",""String_Node_Str"",new String(b))).split(""String_Node_Str"");
      for (int i=0; i < re.length; i++) {
        if (re[i].startsWith(""String_Node_Str""))         re[i]=null;
 else {
          for (int g=0; g < re.length; g++) {
            if (i == g)             continue;
            if (re[i].equalsIgnoreCase(re[g])) {
              re[i]=null;
              break;
            }
          }
        }
      }
      return re;
    }
  }
 catch (  Exception ex) {
    logger.log(Level.WARNING,ex.getMessage());
    return new String[0];
  }
}","private static String[] readAllLines(File dir,String path){
  try {
    File F=new File(dir,path);
    logger.log(Level.INFO,""String_Node_Str"" + F.getAbsolutePath());
    if (!F.exists()) {
      logger.log(Level.INFO,""String_Node_Str"");
      return new String[0];
    }
 else     if (F.length() <= 0) {
      logger.log(Level.INFO,""String_Node_Str"");
      return new String[0];
    }
 else {
      byte[] b=new byte[(int)F.length()];
      BufferedInputStream S=new BufferedInputStream(new FileInputStream(F));
      S.read(b);
      S.close();
      logger.log(Level.INFO,""String_Node_Str"");
      String[] re=str_replace(""String_Node_Str"",""String_Node_Str"",str_replace(""String_Node_Str"",""String_Node_Str"",new String(b))).split(""String_Node_Str"");
      for (int i=0; i < re.length; i++) {
        if (re[i].startsWith(""String_Node_Str""))         re[i]=null;
 else {
          for (int g=0; g < re.length; g++) {
            if (i == g)             continue;
            if (re[i].equalsIgnoreCase(re[g])) {
              re[i]=null;
              break;
            }
          }
        }
      }
      return re;
    }
  }
 catch (  Exception ex) {
    logger.log(Level.WARNING,ex.getMessage());
    return new String[0];
  }
}",0.9983818770226536
32951,"public void log(Level level,String msg){
  if (level.intValue() >= LOWEST_DISPLAY_LEVEL)   System.out.println(msg);
  try {
    writer.write(""String_Node_Str"");
    writer.write(DATE_FORMAT.format(new Date()));
    writer.write(""String_Node_Str"");
    writer.write(level.getName());
    writer.write(""String_Node_Str"");
    writer.write(msg);
    writer.write(""String_Node_Str"");
    writer.flush();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","public void log(Level level,String msg){
  if (level.intValue() >= LOWEST_DISPLAY_LEVEL)   System.out.println(msg);
  try {
    writer.write(""String_Node_Str"");
    writer.write(DATE_FORMAT.format(new Date()));
    writer.write(""String_Node_Str"");
    writer.write(Thread.currentThread().getName());
    writer.write(""String_Node_Str"");
    writer.write(level.getName());
    writer.write(""String_Node_Str"");
    writer.write(msg);
    writer.write(""String_Node_Str"");
    writer.flush();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.9116186693147964
32952,"public void warning(String msg){
  log(Level.WARNING,msg);
}","public void warning(Exception e){
  log(Level.WARNING,""String_Node_Str"" + e.getMessage());
  StackTraceElement[] stes=e.getStackTrace();
  for (  StackTraceElement ste : stes) {
    log(Level.WARNING,ste.toString());
  }
  log(Level.WARNING,""String_Node_Str"");
}",0.2795031055900621
32953,"public void loadTexture(IResourceManager par1ResourceManager) throws IOException {
  if (this.bufferedImage == null && this.textureLocation != null) {
    super.loadTexture(par1ResourceManager);
  }
  if (this.imageThread == null) {
    this.imageThread=new Thread(""String_Node_Str"" + field_147643_d.incrementAndGet()){
      private static final String __OBFID=""String_Node_Str"";
      public void run(){
        try {
          BufferedImage var2=ImageIO.read(ThreadDownloadImageData.this.customSkinLoader.getPlayerSkinStream(ThreadDownloadImageData.this.imageUrl));
          if (ThreadDownloadImageData.this.imageBuffer != null) {
            var2=ThreadDownloadImageData.this.imageBuffer.parseUserSkin(var2);
          }
          ThreadDownloadImageData.this.func_147641_a(var2);
        }
 catch (        Exception var6) {
          ThreadDownloadImageData.logger.error(""String_Node_Str"",var6);
          return;
        }
      }
    }
;
    this.imageThread.setDaemon(true);
    this.imageThread.setName(""String_Node_Str"" + this.imageUrl);
    this.imageThread.start();
  }
}","public void loadTexture(IResourceManager par1ResourceManager) throws IOException {
  if (this.bufferedImage == null && this.textureLocation != null) {
    super.loadTexture(par1ResourceManager);
  }
  if (this.imageThread == null) {
    this.imageThread=new Thread(""String_Node_Str"" + field_147643_d.incrementAndGet()){
      private static final String __OBFID=""String_Node_Str"";
      public void run(){
        try {
          BufferedImage var2=ImageIO.read(ThreadDownloadImageData.this.customSkinLoader.getPlayerSkinStream(ThreadDownloadImageData.this.imageUrl));
          if (ThreadDownloadImageData.this.imageBuffer != null) {
            var2=ThreadDownloadImageData.this.imageBuffer.parseUserSkin(var2);
          }
          ThreadDownloadImageData.this.func_147641_a(var2);
          customSkinLoader.disconnect();
        }
 catch (        Exception var6) {
          ThreadDownloadImageData.logger.error(""String_Node_Str"",var6);
          return;
        }
      }
    }
;
    this.imageThread.setDaemon(true);
    this.imageThread.start();
  }
}",0.9458955223880596
32954,"public void run(){
  try {
    BufferedImage var2=ImageIO.read(ThreadDownloadImageData.this.customSkinLoader.getPlayerSkinStream(ThreadDownloadImageData.this.imageUrl));
    if (ThreadDownloadImageData.this.imageBuffer != null) {
      var2=ThreadDownloadImageData.this.imageBuffer.parseUserSkin(var2);
    }
    ThreadDownloadImageData.this.func_147641_a(var2);
  }
 catch (  Exception var6) {
    ThreadDownloadImageData.logger.error(""String_Node_Str"",var6);
    return;
  }
}","public void run(){
  try {
    BufferedImage var2=ImageIO.read(ThreadDownloadImageData.this.customSkinLoader.getPlayerSkinStream(ThreadDownloadImageData.this.imageUrl));
    if (ThreadDownloadImageData.this.imageBuffer != null) {
      var2=ThreadDownloadImageData.this.imageBuffer.parseUserSkin(var2);
    }
    ThreadDownloadImageData.this.func_147641_a(var2);
    customSkinLoader.disconnect();
  }
 catch (  Exception var6) {
    ThreadDownloadImageData.logger.error(""String_Node_Str"",var6);
    return;
  }
}",0.9646821392532796
32955,"@Override public void showIdentifierCreatedSuccessfully(){
  Toast.makeText(getActivity(),R.string.identifier_created_successfully,Toast.LENGTH_SHORT).show();
  getDialog().dismiss();
}","@Override public void showIdentifierCreatedSuccessfully(){
  Toast.makeText(getActivity(),R.string.identifier_created_successfully,Toast.LENGTH_SHORT).show();
  getDialog().dismiss();
  ((ClientIdentifiersFragment)getTargetFragment()).doRefresh();
}",0.8525345622119815
32956,"@Override public void showClientIdentifiers(List<Identifier> identifiers){
  this.identifiers=identifiers;
  identifierListAdapter.setIdentifiers(identifiers);
}","@Override public void showClientIdentifiers(List<Identifier> identifiers){
  if (llError.getVisibility() == View.VISIBLE) {
    llError.setVisibility(View.GONE);
  }
  this.identifiers=identifiers;
  identifierListAdapter.setIdentifiers(identifiers);
}",0.7796610169491526
32957,"@Override public void showEmptyClientIdentifier(){
  ll_error.setVisibility(View.VISIBLE);
  mNoIdentifierText.setText(getResources().getString(R.string.no_identifier_to_show));
  mNoIdentifierIcon.setImageResource(R.drawable.ic_assignment_turned_in_black_24dp);
}","@Override public void showEmptyClientIdentifier(){
  llError.setVisibility(View.VISIBLE);
  mNoIdentifierText.setText(getResources().getString(R.string.no_identifier_to_show));
  mNoIdentifierIcon.setImageResource(R.drawable.ic_assignment_turned_in_black_24dp);
}",0.9943074003795066
32958,"@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.menu_add:
    IdentifierDialogFragment identifierDialogFragment=IdentifierDialogFragment.newInstance(clientId);
  FragmentTransaction fragmentTransaction=getActivity().getSupportFragmentManager().beginTransaction();
fragmentTransaction.addToBackStack(FragmentConstants.FRAG_DOCUMENT_LIST);
identifierDialogFragment.show(fragmentTransaction,""String_Node_Str"");
break;
}
return super.onOptionsItemSelected(item);
}","@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.menu_add:
    IdentifierDialogFragment identifierDialogFragment=IdentifierDialogFragment.newInstance(clientId);
  identifierDialogFragment.setTargetFragment(this,1);
FragmentTransaction fragmentTransaction=getActivity().getSupportFragmentManager().beginTransaction();
fragmentTransaction.addToBackStack(FragmentConstants.FRAG_DOCUMENT_LIST);
identifierDialogFragment.show(fragmentTransaction,""String_Node_Str"");
break;
}
return super.onOptionsItemSelected(item);
}",0.9517625231910948
32959,"public void loadIdentifiers(int clientId){
  checkViewAttached();
  getMvpView().showProgressbar(true);
  mSubscriptions.add(mDataManagerClient.getClientIdentifiers(clientId).observeOn(AndroidSchedulers.mainThread()).subscribeOn(Schedulers.io()).subscribe(new Subscriber<List<Identifier>>(){
    @Override public void onCompleted(){
      getMvpView().showProgressbar(false);
    }
    @Override public void onError(    Throwable e){
      getMvpView().showProgressbar(false);
      getMvpView().showFetchingError(R.string.failed_to_fetch_identifier);
    }
    @Override public void onNext(    List<Identifier> identifiers){
      getMvpView().showProgressbar(false);
      if (!identifiers.isEmpty()) {
        getMvpView().showClientIdentifiers(identifiers);
      }
 else {
        getMvpView().showEmptyClientIdentifier();
      }
    }
  }
));
}","public void loadIdentifiers(int clientId){
  checkViewAttached();
  getMvpView().showProgressbar(true);
  mSubscriptions.add(mDataManagerClient.getClientIdentifiers(clientId).observeOn(AndroidSchedulers.mainThread()).subscribeOn(Schedulers.io()).subscribe(new Subscriber<List<Identifier>>(){
    @Override public void onCompleted(){
      getMvpView().showProgressbar(false);
    }
    @Override public void onError(    Throwable e){
      getMvpView().showProgressbar(false);
      getMvpView().showFetchingError(R.string.failed_to_fetch_identifier);
    }
    @Override public void onNext(    List<Identifier> identifiers){
      getMvpView().showProgressbar(false);
      getMvpView().showClientIdentifiers(identifiers);
      if (identifiers.isEmpty()) {
        getMvpView().showEmptyClientIdentifier();
      }
    }
  }
));
}",0.9185977421271538
32960,"/** 
 * Returns a   {@link ViewAction} that navigates to a menu item in {@link NavigationView} using amenu item resource id. <p/> <p/> View constraints: <ul> <li>View must be a child of a  {@link DrawerLayout}<li>View must be of type   {@link NavigationView}<li>View must be visible on screen <li>View must be displayed on screen <ul>
 * @param menuItemId the resource id of the menu item
 * @return a {@link ViewAction} that navigates on a menu item
 */
public static ViewAction navigateTo(final int menuItemId){
  return new ViewAction(){
    @Override public void perform(    UiController uiController,    View view){
      NavigationView navigationView=(NavigationView)view;
      Menu menu=navigationView.getMenu();
      if (null == menu.findItem(menuItemId)) {
        throw new PerformException.Builder().withActionDescription(this.getDescription()).withViewDescription(HumanReadables.describe(view)).withCause(new RuntimeException(getErrorMessage(menu,view))).build();
      }
      menu.performIdentifierAction(menuItemId,0);
      uiController.loopMainThreadUntilIdle();
    }
    private String getErrorMessage(    Menu menu,    View view){
      String NEW_LINE=System.getProperty(""String_Node_Str"");
      StringBuilder errorMessage=new StringBuilder(20).append(""String_Node_Str"").append(NEW_LINE);
      for (int position=0; position < menu.size(); position++) {
        errorMessage.append(""String_Node_Str"").append(position);
        MenuItem menuItem=menu.getItem(position);
        if (menuItem != null) {
          CharSequence itemTitle=menuItem.getTitle();
          if (itemTitle != null) {
            errorMessage.append(""String_Node_Str"").append(itemTitle);
          }
          if (view.getResources() != null) {
            int itemId=menuItem.getItemId();
            try {
              errorMessage.append(""String_Node_Str"");
              String menuItemResourceName=view.getResources().getResourceName(itemId);
              errorMessage.append(menuItemResourceName);
            }
 catch (            NotFoundException nfe) {
              errorMessage.append(""String_Node_Str"");
            }
          }
          errorMessage.append(NEW_LINE);
        }
      }
      return errorMessage.toString();
    }
    @Override public String getDescription(){
      return ""String_Node_Str"";
    }
    @Override public Matcher<View> getConstraints(){
      return allOf(isAssignableFrom(NavigationView.class),withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE),isDisplayingAtLeast(90));
    }
  }
;
}","/** 
 * Returns a   {@link ViewAction} that navigates to a menu item in {@link NavigationView} using amenu item resource id. <p/> <p/> View constraints: <ul> <li>View must be a child of a  {@link DrawerLayout}<li>View must be of type   {@link NavigationView}<li>View must be visible on screen <li>View must be displayed on screen <ul>
 * @param menuItemId the resource id of the menu item
 * @return a {@link ViewAction} that navigates on a menu item
 */
public static ViewAction navigateTo(final int menuItemId){
  return new ViewAction(){
    @Override public void perform(    UiController uiController,    View view){
      NavigationView navigationView=(NavigationView)view;
      Menu menu=navigationView.getMenu();
      if (null == menu.findItem(menuItemId)) {
        throw new PerformException.Builder().withActionDescription(this.getDescription()).withViewDescription(HumanReadables.describe(view)).withCause(new RuntimeException(getErrorMessage(menu,view))).build();
      }
      menu.performIdentifierAction(menuItemId,0);
      uiController.loopMainThreadUntilIdle();
    }
    private String getErrorMessage(    Menu menu,    View view){
      String NEW_LINE=System.getProperty(""String_Node_Str"");
      StringBuilder errorMessage=new StringBuilder(66).append(""String_Node_Str"").append(NEW_LINE);
      for (int position=0; position < menu.size(); position++) {
        errorMessage.append(""String_Node_Str"").append(position);
        MenuItem menuItem=menu.getItem(position);
        if (menuItem != null) {
          CharSequence itemTitle=menuItem.getTitle();
          if (itemTitle != null) {
            errorMessage.append(""String_Node_Str"").append(itemTitle);
          }
          if (view.getResources() != null) {
            int itemId=menuItem.getItemId();
            try {
              errorMessage.append(""String_Node_Str"");
              String menuItemResourceName=view.getResources().getResourceName(itemId);
              errorMessage.append(menuItemResourceName);
            }
 catch (            NotFoundException nfe) {
              errorMessage.append(""String_Node_Str"");
            }
          }
          errorMessage.append(NEW_LINE);
        }
      }
      return errorMessage.toString();
    }
    @Override public String getDescription(){
      return ""String_Node_Str"";
    }
    @Override public Matcher<View> getConstraints(){
      return allOf(isAssignableFrom(NavigationView.class),withEffectiveVisibility(ViewMatchers.Visibility.VISIBLE),isDisplayingAtLeast(90));
    }
  }
;
}",0.9992110453648916
32961,"private String getErrorMessage(Menu menu,View view){
  String NEW_LINE=System.getProperty(""String_Node_Str"");
  StringBuilder errorMessage=new StringBuilder(20).append(""String_Node_Str"").append(NEW_LINE);
  for (int position=0; position < menu.size(); position++) {
    errorMessage.append(""String_Node_Str"").append(position);
    MenuItem menuItem=menu.getItem(position);
    if (menuItem != null) {
      CharSequence itemTitle=menuItem.getTitle();
      if (itemTitle != null) {
        errorMessage.append(""String_Node_Str"").append(itemTitle);
      }
      if (view.getResources() != null) {
        int itemId=menuItem.getItemId();
        try {
          errorMessage.append(""String_Node_Str"");
          String menuItemResourceName=view.getResources().getResourceName(itemId);
          errorMessage.append(menuItemResourceName);
        }
 catch (        NotFoundException nfe) {
          errorMessage.append(""String_Node_Str"");
        }
      }
      errorMessage.append(NEW_LINE);
    }
  }
  return errorMessage.toString();
}","private String getErrorMessage(Menu menu,View view){
  String NEW_LINE=System.getProperty(""String_Node_Str"");
  StringBuilder errorMessage=new StringBuilder(66).append(""String_Node_Str"").append(NEW_LINE);
  for (int position=0; position < menu.size(); position++) {
    errorMessage.append(""String_Node_Str"").append(position);
    MenuItem menuItem=menu.getItem(position);
    if (menuItem != null) {
      CharSequence itemTitle=menuItem.getTitle();
      if (itemTitle != null) {
        errorMessage.append(""String_Node_Str"").append(itemTitle);
      }
      if (view.getResources() != null) {
        int itemId=menuItem.getItemId();
        try {
          errorMessage.append(""String_Node_Str"");
          String menuItemResourceName=view.getResources().getResourceName(itemId);
          errorMessage.append(menuItemResourceName);
        }
 catch (        NotFoundException nfe) {
          errorMessage.append(""String_Node_Str"");
        }
      }
      errorMessage.append(NEW_LINE);
    }
  }
  return errorMessage.toString();
}",0.9980750721847932
32962,"public void loadLoanDataTables(){
  DataTableFragment loanAccountFragment=DataTableFragment.newInstance(Constants.DATA_TABLE_NAME_LOANS,loanAccountNumber);
  FragmentTransaction fragmentTransaction=getActivity().getSupportFragmentManager().beginTransaction();
  fragmentTransaction.addToBackStack(FragmentConstants.FRAG_LOAN_ACCOUNT_SUMMARY);
  fragmentTransaction.replace(R.id.container,loanAccountFragment);
  fragmentTransaction.commit();
}","public void loadLoanDataTables(){
  DataTableFragment loanAccountFragment=DataTableFragment.newInstance(Constants.DATA_TABLE_NAME_LOANS,loanAccountNumber);
  FragmentTransaction fragmentTransaction=getActivity().getSupportFragmentManager().beginTransaction();
  fragmentTransaction.addToBackStack(FragmentConstants.FRAG_LOAN_ACCOUNT_SUMMARY);
  fragmentTransaction.replace(container,loanAccountFragment);
  fragmentTransaction.commit();
}",0.9943246311010216
32963,"public boolean isRecurring(){
  return this.getDepositType() == null ? false : this.getDepositType().isRecurring();
}","public boolean isRecurring(){
  return this.getDepositType() != null && this.getDepositType().isRecurring();
}",0.9427312775330396
32964,"@Override public void showCenterDetails(CenterWithAssociations centerWithAssociations){
  setToolbarTitle(centerWithAssociations.getName());
  if (!centerWithAssociations.getActivationDate().isEmpty()) {
    tvStaffName.setText(centerWithAssociations.getStaffName());
    tvActivationDate.setText(Utils.getStringOfDate(getContext(),centerWithAssociations.getActivationDate()));
  }
}","@Override public void showCenterDetails(CenterWithAssociations centerWithAssociations){
  setToolbarTitle(centerWithAssociations.getName());
  if (!centerWithAssociations.getActivationDate().isEmpty()) {
    tvStaffName.setText(centerWithAssociations.getStaffName());
    tvActivationDate.setText(Utils.getStringOfDate(centerWithAssociations.getActivationDate()));
  }
}",0.9827357237715804
32965,"@Override public void showMeetingDetails(CenterWithAssociations centerWithAssociations){
  if (!centerWithAssociations.getActive()) {
    llBottomPanel.setVisibility(View.VISIBLE);
    showErrorMessage(R.string.error_center_inactive);
  }
  if (centerWithAssociations.getCollectionMeetingCalendar().getCalendarInstanceId() == null) {
    tvMeetingDate.setText(getString(R.string.unassigned));
    if (getView() != null) {
      getView().findViewById(R.id.row_meeting_frequency).setVisibility(View.GONE);
    }
  }
 else {
    tvMeetingDate.setText(Utils.getStringOfDate(getContext(),centerWithAssociations.getCollectionMeetingCalendar().getNextTenRecurringDates().get(0)));
    if (getView() != null) {
      getView().findViewById(R.id.row_meeting_frequency).setVisibility(View.VISIBLE);
      tvMeetingFrequency.setText(centerWithAssociations.getCollectionMeetingCalendar().getHumanReadable());
    }
  }
}","@Override public void showMeetingDetails(CenterWithAssociations centerWithAssociations){
  if (!centerWithAssociations.getActive()) {
    llBottomPanel.setVisibility(View.VISIBLE);
    showErrorMessage(R.string.error_center_inactive);
  }
  if (centerWithAssociations.getCollectionMeetingCalendar().getCalendarInstanceId() == null) {
    tvMeetingDate.setText(getString(R.string.unassigned));
    if (getView() != null) {
      getView().findViewById(R.id.row_meeting_frequency).setVisibility(View.GONE);
    }
  }
 else {
    tvMeetingDate.setText(Utils.getStringOfDate(centerWithAssociations.getCollectionMeetingCalendar().getNextTenRecurringDates().get(0)));
    if (getView() != null) {
      getView().findViewById(R.id.row_meeting_frequency).setVisibility(View.VISIBLE);
      tvMeetingFrequency.setText(centerWithAssociations.getCollectionMeetingCalendar().getHumanReadable());
    }
  }
}",0.992797783933518
32966,"@Override public void showClientInformation(Client client){
  if (client != null) {
    setToolbarTitle(getString(R.string.client) + ""String_Node_Str"" + client.getLastname());
    isClientActive=client.isActive();
    getActivity().invalidateOptionsMenu();
    if (!client.isActive()) {
      llBottomPanel.setVisibility(VISIBLE);
    }
    tv_fullName.setText(client.getDisplayName());
    tv_accountNumber.setText(client.getAccountNo());
    tv_externalId.setText(client.getExternalId());
    if (TextUtils.isEmpty(client.getAccountNo()))     rowAccount.setVisibility(GONE);
    if (TextUtils.isEmpty(client.getExternalId()))     rowExternal.setVisibility(GONE);
    try {
      String dateString=Utils.getStringOfDate(getActivity(),client.getActivationDate());
      tv_activationDate.setText(dateString);
      if (TextUtils.isEmpty(dateString))       rowActivation.setVisibility(GONE);
    }
 catch (    IndexOutOfBoundsException e) {
      Toast.makeText(getActivity(),getString(R.string.error_client_inactive),Toast.LENGTH_SHORT).show();
      tv_activationDate.setText(""String_Node_Str"");
    }
    tv_office.setText(client.getOfficeName());
    if (TextUtils.isEmpty(client.getOfficeName()))     rowOffice.setVisibility(GONE);
    if (client.isImagePresent()) {
      loadClientProfileImage();
    }
 else {
      iv_clientImage.setImageDrawable(ResourcesCompat.getDrawable(getResources(),R.drawable.ic_launcher,null));
      pb_imageProgressBar.setVisibility(GONE);
    }
    iv_clientImage.setOnClickListener(new OnClickListener(){
      @Override public void onClick(      View view){
        PopupMenu menu=new PopupMenu(getActivity(),view);
        menu.getMenuInflater().inflate(R.menu.client_image_popup,menu.getMenu());
        menu.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener(){
          @Override public boolean onMenuItemClick(          MenuItem menuItem){
switch (menuItem.getItemId()) {
case R.id.client_image_capture:
              captureClientImage();
            break;
case R.id.client_image_remove:
          mClientDetailsPresenter.deleteClientImage(clientId);
        break;
default :
      Log.e(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  return true;
}
}
);
menu.show();
}
}
);
}
}","@Override public void showClientInformation(Client client){
  if (client != null) {
    setToolbarTitle(getString(R.string.client) + ""String_Node_Str"" + client.getLastname());
    isClientActive=client.isActive();
    getActivity().invalidateOptionsMenu();
    if (!client.isActive()) {
      llBottomPanel.setVisibility(VISIBLE);
    }
    tv_fullName.setText(client.getDisplayName());
    tv_accountNumber.setText(client.getAccountNo());
    tv_externalId.setText(client.getExternalId());
    if (TextUtils.isEmpty(client.getAccountNo()))     rowAccount.setVisibility(GONE);
    if (TextUtils.isEmpty(client.getExternalId()))     rowExternal.setVisibility(GONE);
    try {
      String dateString=Utils.getStringOfDate(client.getActivationDate());
      tv_activationDate.setText(dateString);
      if (TextUtils.isEmpty(dateString))       rowActivation.setVisibility(GONE);
    }
 catch (    IndexOutOfBoundsException e) {
      Toast.makeText(getActivity(),getString(R.string.error_client_inactive),Toast.LENGTH_SHORT).show();
      tv_activationDate.setText(""String_Node_Str"");
    }
    tv_office.setText(client.getOfficeName());
    if (TextUtils.isEmpty(client.getOfficeName()))     rowOffice.setVisibility(GONE);
    if (client.isImagePresent()) {
      loadClientProfileImage();
    }
 else {
      iv_clientImage.setImageDrawable(ResourcesCompat.getDrawable(getResources(),R.drawable.ic_launcher,null));
      pb_imageProgressBar.setVisibility(GONE);
    }
    iv_clientImage.setOnClickListener(new OnClickListener(){
      @Override public void onClick(      View view){
        PopupMenu menu=new PopupMenu(getActivity(),view);
        menu.getMenuInflater().inflate(R.menu.client_image_popup,menu.getMenu());
        menu.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener(){
          @Override public boolean onMenuItemClick(          MenuItem menuItem){
switch (menuItem.getItemId()) {
case R.id.client_image_capture:
              captureClientImage();
            break;
case R.id.client_image_remove:
          mClientDetailsPresenter.deleteClientImage(clientId);
        break;
default :
      Log.e(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  return true;
}
}
);
menu.show();
}
}
);
}
}",0.996914940502424
32967,"@Override public void showGroup(Group group){
  if (group != null) {
    if (!group.getActive()) {
      llBottomPanel.setVisibility(VISIBLE);
    }
    setToolbarTitle(getString(R.string.group) + ""String_Node_Str"" + group.getName());
    tv_fullName.setText(group.getName());
    tv_externalId.setText(group.getExternalId());
    try {
      String dateString=Utils.getStringOfDate(getActivity(),group.getActivationDate());
      tv_activationDate.setText(dateString);
      if (TextUtils.isEmpty(dateString))       rowActivation.setVisibility(GONE);
    }
 catch (    IndexOutOfBoundsException e) {
      Toast.makeText(getActivity(),getString(R.string.error_group_inactive),Toast.LENGTH_SHORT).show();
      tv_activationDate.setText(""String_Node_Str"");
    }
    tv_office.setText(group.getOfficeName());
    if (TextUtils.isEmpty(group.getOfficeName()))     rowOffice.setVisibility(GONE);
  }
}","@Override public void showGroup(Group group){
  if (group != null) {
    if (!group.getActive()) {
      llBottomPanel.setVisibility(VISIBLE);
    }
    setToolbarTitle(getString(R.string.group) + ""String_Node_Str"" + group.getName());
    tv_fullName.setText(group.getName());
    tv_externalId.setText(group.getExternalId());
    try {
      String dateString=Utils.getStringOfDate(group.getActivationDate());
      tv_activationDate.setText(dateString);
      if (TextUtils.isEmpty(dateString))       rowActivation.setVisibility(GONE);
    }
 catch (    IndexOutOfBoundsException e) {
      Toast.makeText(getActivity(),getString(R.string.error_group_inactive),Toast.LENGTH_SHORT).show();
      tv_activationDate.setText(""String_Node_Str"");
    }
    tv_office.setText(group.getOfficeName());
    if (TextUtils.isEmpty(group.getOfficeName()))     rowOffice.setVisibility(GONE);
  }
}",0.992152466367713
32968,"/** 
 * This Method Converting the List<Integer> of Activation Date to String.
 * @param context Context
 * @param dateObj List<Integer> of Date
 * @return
 */
public static String getStringOfDate(Context context,List<Integer> dateObj){
  SimpleDateFormat simpleDateFormat=new SimpleDateFormat(""String_Node_Str"",context.getResources().getConfiguration().locale);
  Date date=null;
  try {
    date=simpleDateFormat.parse(DateHelper.getDateAsString(dateObj));
  }
 catch (  ParseException e) {
    Log.d(LOG_TAG,e.getLocalizedMessage());
  }
  DateFormat df=DateFormat.getDateInstance(DateFormat.MEDIUM);
  return df.format(date);
}","/** 
 * This Method Converting the List<Integer> of Activation Date to String.
 * @param dateObj List<Integer> of Date
 * @return
 */
public static String getStringOfDate(List<Integer> dateObj){
  Calendar calendar=Calendar.getInstance();
  calendar.setTimeZone(TimeZone.getTimeZone(""String_Node_Str""));
  calendar.set(Calendar.YEAR,dateObj.get(0));
  calendar.set(Calendar.MONTH,dateObj.get(1) - 1);
  calendar.set(Calendar.DAY_OF_MONTH,dateObj.get(2));
  DateFormat df=DateFormat.getDateInstance(DateFormat.MEDIUM);
  return df.format(calendar.getTime());
}",0.5260504201680672
32969,"@Override public void onScrolled(RecyclerView recyclerView,int dx,int dy){
  super.onScrolled(recyclerView,dx,dy);
  visibleItemCount=recyclerView.getChildCount();
  totalItemCount=mLinearLayoutManager.getItemCount();
  firstVisibleItem=mLinearLayoutManager.findFirstVisibleItemPosition();
  if (loading && (totalItemCount > previousTotal + 1)) {
    loading=false;
    previousTotal=totalItemCount;
  }
  if (!loading && (totalItemCount - visibleItemCount) <= (firstVisibleItem + visibleThreshold)) {
    current_page++;
    onLoadMore(current_page);
    loading=true;
  }
}","@Override public void onScrolled(RecyclerView recyclerView,int dx,int dy){
  super.onScrolled(recyclerView,dx,dy);
  visibleItemCount=recyclerView.getChildCount();
  totalItemCount=mLinearLayoutManager.getItemCount();
  if (previousTotal > totalItemCount) {
    previousTotal=0;
  }
  firstVisibleItem=mLinearLayoutManager.findFirstVisibleItemPosition();
  if (loading && (totalItemCount > previousTotal + 1)) {
    loading=false;
    previousTotal=totalItemCount;
  }
  if (!loading && (totalItemCount - visibleItemCount) <= (firstVisibleItem + visibleThreshold)) {
    current_page++;
    onLoadMore(current_page);
    loading=true;
  }
}",0.9465020576131687
32970,"@Override public void onScrolled(RecyclerView view,int dx,int dy){
  int lastVisibleItemPosition=0;
  int totalItemCount=mLayoutManager.getItemCount();
  if (mLayoutManager instanceof StaggeredGridLayoutManager) {
    int[] lastVisibleItemPositions=((StaggeredGridLayoutManager)mLayoutManager).findLastVisibleItemPositions(null);
    lastVisibleItemPosition=getLastVisibleItem(lastVisibleItemPositions);
  }
 else   if (mLayoutManager instanceof LinearLayoutManager) {
    lastVisibleItemPosition=((LinearLayoutManager)mLayoutManager).findLastVisibleItemPosition();
  }
 else   if (mLayoutManager instanceof GridLayoutManager) {
    lastVisibleItemPosition=((GridLayoutManager)mLayoutManager).findLastVisibleItemPosition();
  }
  if (totalItemCount < previousTotalItemCount) {
    this.currentPage=this.startingPageIndex;
    this.previousTotalItemCount=totalItemCount;
    if (totalItemCount == 0) {
      this.loading=true;
    }
  }
  if (loading && (totalItemCount > previousTotalItemCount)) {
    loading=false;
    previousTotalItemCount=totalItemCount;
  }
  if (!loading && (lastVisibleItemPosition + visibleThreshold) > totalItemCount) {
    currentPage++;
    onLoadMore(currentPage,totalItemCount);
    loading=true;
  }
}","@Override public void onScrolled(RecyclerView view,int dx,int dy){
  int lastVisibleItemPosition=0;
  int totalItemCount=mLayoutManager.getItemCount();
  if (mLayoutManager instanceof StaggeredGridLayoutManager) {
    int[] lastVisibleItemPositions=((StaggeredGridLayoutManager)mLayoutManager).findLastVisibleItemPositions(null);
    lastVisibleItemPosition=getLastVisibleItem(lastVisibleItemPositions);
  }
 else   if (mLayoutManager instanceof LinearLayoutManager) {
    lastVisibleItemPosition=((LinearLayoutManager)mLayoutManager).findLastVisibleItemPosition();
  }
 else   if (mLayoutManager instanceof GridLayoutManager) {
    lastVisibleItemPosition=((GridLayoutManager)mLayoutManager).findLastVisibleItemPosition();
  }
  if (totalItemCount < previousTotalItemCount) {
    this.currentPage=this.startingPageIndex;
    this.previousTotalItemCount=totalItemCount;
    if (totalItemCount == 0) {
      this.loading=true;
    }
 else {
      this.loading=false;
    }
  }
  if (loading && (totalItemCount > previousTotalItemCount)) {
    loading=false;
    previousTotalItemCount=totalItemCount;
  }
  if (!loading && (lastVisibleItemPosition + visibleThreshold) > totalItemCount) {
    currentPage++;
    onLoadMore(currentPage,totalItemCount);
    loading=true;
  }
}",0.9840383080606544
32971,"@Override public void onLoadMore(int current_page){
  mClientListPresenter.loadClients(true,clientList.size());
}","@Override public void onLoadMore(int page,int totalItemCount){
  mClientListPresenter.loadClients(true,totalItemCount);
}",0.7863247863247863
32972,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  rootView=inflater.inflate(R.layout.fragment_client,container,false);
  setHasOptionsMenu(true);
  setToolbarTitle(getResources().getString(R.string.clients));
  ButterKnife.bind(this,rootView);
  mClientListPresenter.attachView(this);
  showUserInterface();
  rv_clients.addOnScrollListener(new EndlessRecyclerOnScrollListener(mLayoutManager){
    @Override public void onLoadMore(    int current_page){
      mClientListPresenter.loadClients(true,clientList.size());
    }
  }
);
  if (isParentFragment) {
    mClientListPresenter.showParentClients(clientList);
  }
 else {
    mClientListPresenter.loadClients(false,0);
  }
  mClientListPresenter.loadDatabaseClients();
  return rootView;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  rootView=inflater.inflate(R.layout.fragment_client,container,false);
  setHasOptionsMenu(true);
  setToolbarTitle(getResources().getString(R.string.clients));
  ButterKnife.bind(this,rootView);
  mClientListPresenter.attachView(this);
  showUserInterface();
  rv_clients.addOnScrollListener(new EndlessRecyclerViewScrollListener(mLayoutManager){
    @Override public void onLoadMore(    int page,    int totalItemCount){
      mClientListPresenter.loadClients(true,totalItemCount);
    }
  }
);
  if (isParentFragment) {
    mClientListPresenter.showParentClients(clientList);
  }
 else {
    mClientListPresenter.loadClients(false,0);
  }
  mClientListPresenter.loadDatabaseClients();
  return rootView;
}",0.957920792079208
32973,"public void syncClientAndUpdateUI(){
  mLoanAndRepaymentSyncIndex=0;
  mSavingsAndTransactionSyncIndex=0;
  updateTotalSyncProgressBarAndCount();
  if (mClientSyncIndex != mClientList.size()) {
    updateClientName();
    syncClientAccounts(mClientList.get(mClientSyncIndex).getId());
  }
 else {
    getMvpView().showClientsSyncSuccessfully();
  }
}","public void syncClientAndUpdateUI(){
  mLoanAndRepaymentSyncIndex=0;
  mSavingsAndTransactionSyncIndex=0;
  mLoanAccountSyncStatus=false;
  updateTotalSyncProgressBarAndCount();
  if (mClientSyncIndex != mClientList.size()) {
    updateClientName();
    syncClientAccounts(mClientList.get(mClientSyncIndex).getId());
  }
 else {
    getMvpView().showClientsSyncSuccessfully();
  }
}",0.9562841530054644
32974,"@Override public void onDatePicked(String date){
  if (isdisbursementDate) {
    tvDisbursementonDate.setText(date);
    isdisbursementDate=false;
  }
  if (issubmittedDate) {
    tvSubmittedonDate.setText(date);
    issubmittedDate=false;
  }
}","@Override public void onDatePicked(String date){
  if (isdisbursementDate) {
    tvDisbursementonDate.setText(date);
    disbursementon_date=date;
    isdisbursementDate=false;
  }
  if (issubmittedDate) {
    tvSubmittedonDate.setText(date);
    submittion_date=date;
    issubmittedDate=false;
  }
}",0.8974358974358975
32975,"@Override public void onDatePicked(String date){
  if (isSubmissionDate) {
    tvSubmittedOnDate.setText(date);
    isSubmissionDate=false;
  }
  if (isDisbursebemntDate) {
    tvDisbursementOnDate.setText(date);
    isDisbursebemntDate=false;
  }
}","@Override public void onDatePicked(String date){
  if (isSubmissionDate) {
    tvSubmittedOnDate.setText(date);
    submissionDate=date;
    isSubmissionDate=false;
  }
  if (isDisbursebemntDate) {
    tvDisbursementOnDate.setText(date);
    disbursementDate=date;
    isDisbursebemntDate=false;
  }
}",0.9054545454545454
32976,"public void approveLoan(){
  LoanAccountApproval loanAccountApproval=LoanAccountApproval.newInstance(loanAccountNumber);
  FragmentTransaction fragmentTransaction=getActivity().getSupportFragmentManager().beginTransaction();
  fragmentTransaction.addToBackStack(FragmentConstants.FRAG_LOAN_ACCOUNT_SUMMARY);
  fragmentTransaction.replace(container,loanAccountApproval);
  fragmentTransaction.commit();
}","public void approveLoan(){
  LoanAccountApproval loanAccountApproval=LoanAccountApproval.newInstance(loanAccountNumber,clientLoanWithAssociations);
  FragmentTransaction fragmentTransaction=getActivity().getSupportFragmentManager().beginTransaction();
  fragmentTransaction.addToBackStack(FragmentConstants.FRAG_LOAN_ACCOUNT_SUMMARY);
  fragmentTransaction.replace(container,loanAccountApproval);
  fragmentTransaction.commit();
}",0.9675870348139256
32977,"@Override public void onDatePicked(String date){
  tvSubmissionDate.setText(date);
  setSubmissionDate();
}","@Override public void onDatePicked(String date){
  tvSubmissionDate.setText(date);
  submission_date=date;
  setSubmissionDate();
}",0.8991596638655462
32978,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_dashboard);
  ButterKnife.bind(this);
  replaceFragment(new ClientSearchFragment(),false,R.id.container);
  setupNavigationBar();
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_dashboard);
  ButterKnife.bind(this);
  replaceFragment(new ClientSearchFragment(),false,R.id.container);
  setupNavigationBar();
  addOnBackStackChangedListener();
}",0.9376114081996436
32979,"@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.mItem_create_new_client:
    openCreateClient();
  break;
case R.id.mItem_create_new_center:
openCreateCenter();
break;
case R.id.mItem_create_new_group:
openCreateGroup();
break;
case R.id.logout:
logout();
break;
default :
break;
}
return super.onOptionsItemSelected(item);
}","@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.mItem_create_new_client:
    setActionBarTitle(R.string.create_client);
  openCreateClient();
break;
case R.id.mItem_create_new_center:
setActionBarTitle(R.string.create_center);
openCreateCenter();
break;
case R.id.mItem_create_new_group:
openCreateGroup();
setActionBarTitle(R.string.create_group);
break;
case R.id.logout:
logout();
break;
default :
break;
}
return super.onOptionsItemSelected(item);
}",0.8506787330316742
32980,"@Override public boolean onCreateOptionsMenu(Menu menu){
  getMenuInflater().inflate(R.menu.client_search,menu);
  return super.onCreateOptionsMenu(menu);
}","@Override public boolean onCreateOptionsMenu(Menu menu){
  this.menu=menu;
  getMenuInflater().inflate(R.menu.menu_main,menu);
  return super.onCreateOptionsMenu(menu);
}",0.901840490797546
32981,"@Override public void showAllSurvey(final List<Survey> surveys){
  SurveyListAdapter surveyListAdapter=new SurveyListAdapter(getActivity(),surveys);
  lv_surveys_list.setAdapter(surveyListAdapter);
  lv_surveys_list.setOnItemClickListener(new AdapterView.OnItemClickListener(){
    @Override public void onItemClick(    AdapterView<?> adapterView,    View view,    int position,    long l){
      mListener.loadSurveyQuestion(surveys.get(position),clientId);
    }
  }
);
}","@Override public void showAllSurvey(final List<Survey> surveys){
  if (surveys.size() == 0) {
    surveySelectText.setText(getResources().getString(R.string.no_survey_available_for_client));
  }
 else {
    SurveyListAdapter surveyListAdapter=new SurveyListAdapter(getActivity(),surveys);
    lv_surveys_list.setAdapter(surveyListAdapter);
    lv_surveys_list.setOnItemClickListener(new AdapterView.OnItemClickListener(){
      @Override public void onItemClick(      AdapterView<?> adapterView,      View view,      int position,      long l){
        mListener.loadSurveyQuestion(surveys.get(position),clientId);
      }
    }
);
  }
}",0.8522522522522522
32982,"public OkHttpClient getMifosOkHttpClient(){
  OkHttpClient.Builder builder=new OkHttpClient.Builder();
  try {
    TrustManager[] trustAllCerts={new X509TrustManager(){
      @Override public void checkClientTrusted(      X509Certificate[] chain,      String authType) throws CertificateException {
      }
      @Override public void checkServerTrusted(      X509Certificate[] chain,      String authType) throws CertificateException {
      }
      @Override public X509Certificate[] getAcceptedIssuers(){
        return new X509Certificate[0];
      }
    }
};
    SSLContext sslContext=SSLContext.getInstance(""String_Node_Str"");
    sslContext.init(null,trustAllCerts,new java.security.SecureRandom());
    SSLSocketFactory sslSocketFactory=sslContext.getSocketFactory();
    HttpLoggingInterceptor logger=new HttpLoggingInterceptor();
    logger.setLevel(Level.BODY);
    builder.sslSocketFactory(sslSocketFactory);
    builder.hostnameVerifier(new HostnameVerifier(){
      @Override public boolean verify(      String hostname,      SSLSession session){
        return true;
      }
    }
);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  HttpLoggingInterceptor logger=new HttpLoggingInterceptor();
  logger.setLevel(Level.BODY);
  builder.connectTimeout(30,TimeUnit.SECONDS);
  builder.readTimeout(30,TimeUnit.SECONDS);
  builder.addInterceptor(logger);
  builder.addInterceptor(new MifosInterceptor());
  builder.addNetworkInterceptor(new StethoInterceptor());
  return builder.build();
}","public OkHttpClient getMifosOkHttpClient(){
  OkHttpClient.Builder builder=new OkHttpClient.Builder();
  try {
    TrustManager[] trustAllCerts={new X509TrustManager(){
      @Override public void checkClientTrusted(      X509Certificate[] chain,      String authType) throws CertificateException {
      }
      @Override public void checkServerTrusted(      X509Certificate[] chain,      String authType) throws CertificateException {
      }
      @Override public X509Certificate[] getAcceptedIssuers(){
        return new X509Certificate[0];
      }
    }
};
    SSLContext sslContext=SSLContext.getInstance(""String_Node_Str"");
    sslContext.init(null,trustAllCerts,new java.security.SecureRandom());
    SSLSocketFactory sslSocketFactory=sslContext.getSocketFactory();
    HttpLoggingInterceptor logger=new HttpLoggingInterceptor();
    logger.setLevel(Level.BODY);
    builder.sslSocketFactory(sslSocketFactory);
    builder.hostnameVerifier(new HostnameVerifier(){
      @Override public boolean verify(      String hostname,      SSLSession session){
        return true;
      }
    }
);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  HttpLoggingInterceptor logger=new HttpLoggingInterceptor();
  logger.setLevel(Level.BODY);
  builder.connectTimeout(60,TimeUnit.SECONDS);
  builder.readTimeout(60,TimeUnit.SECONDS);
  builder.addInterceptor(logger);
  builder.addInterceptor(new MifosInterceptor());
  builder.addNetworkInterceptor(new StethoInterceptor());
  return builder.build();
}",0.9986842105263158
32983,"/** 
 * Sync the Client Account with Client Id. This method fetching the Client Accounts from the REST API using retrofit 2 and saving these accounts to Database with DatabaseHelperClient and then DataManagerClient gives the returns the Clients Accounts to Presenter. <p> <p> onNext : As Client Accounts Successfully sync then now sync the there Loan and LoanRepayment onError :
 * @param clientId Client Id
 */
public void syncClientAccounts(int clientId){
  checkViewAttached();
  mSubscriptions.add(mDataManagerClient.syncClientAccounts(clientId).observeOn(AndroidSchedulers.mainThread()).subscribeOn(Schedulers.io()).subscribe(new Subscriber<ClientAccounts>(){
    @Override public void onCompleted(){
    }
    @Override public void onError(    Throwable e){
      getMvpView().showError(R.string.failed_to_sync_clientaccounts);
      mFailedSyncClient.add(mClientList.get(mClientSyncIndex));
      getMvpView().showSyncedFailedClients(mFailedSyncClient.size());
      mClientSyncIndex=mClientSyncIndex + 1;
      checkNetworkConnectionAndSyncClient();
    }
    @Override public void onNext(    ClientAccounts clientAccounts){
      mLoanAccountList=getActiveLoanAccounts(clientAccounts.getLoanAccounts());
      mSavingsAccountList=getActiveSavingsAccounts(clientAccounts.getSavingsAccounts());
      getMvpView().setMaxSingleSyncClientProgressBar(mLoanAccountList.size() + mSavingsAccountList.size());
      checkAccountsSyncStatusAndSyncAccounts();
    }
  }
));
}","/** 
 * Sync the Client Account with Client Id. This method fetching the Client Accounts from the REST API using retrofit 2 and saving these accounts to Database with DatabaseHelperClient and then DataManagerClient gives the returns the Clients Accounts to Presenter. <p/> <p/> onNext : As Client Accounts Successfully sync then now sync the there Loan and LoanRepayment onError :
 * @param clientId Client Id
 */
public void syncClientAccounts(int clientId){
  checkViewAttached();
  mSubscriptions.add(mDataManagerClient.syncClientAccounts(clientId).observeOn(AndroidSchedulers.mainThread()).subscribeOn(Schedulers.io()).subscribe(new Subscriber<ClientAccounts>(){
    @Override public void onCompleted(){
    }
    @Override public void onError(    Throwable e){
      getMvpView().showError(R.string.failed_to_sync_clientaccounts);
      mFailedSyncClient.add(mClientList.get(mClientSyncIndex));
      getMvpView().showSyncedFailedClients(mFailedSyncClient.size());
      mClientSyncIndex=mClientSyncIndex + 1;
      checkNetworkConnectionAndSyncClient();
    }
    @Override public void onNext(    ClientAccounts clientAccounts){
      mLoanAccountList=getActiveLoanAccounts(clientAccounts.getLoanAccounts());
      mSavingsAccountList=getActiveSavingsAccounts(clientAccounts.getSavingsAccounts());
      getMvpView().setMaxSingleSyncClientProgressBar(mLoanAccountList.size() + mSavingsAccountList.size());
      checkAccountsSyncStatusAndSyncAccounts();
    }
  }
));
}",0.9993215739484396
32984,"public void onAccountSyncFailed(){
  int singleSyncClientMax=getMvpView().getMaxSingleSyncClientProgressBar();
  getMvpView().updateSingleSyncClientProgressBar(singleSyncClientMax);
  mClientSyncIndex=mClientSyncIndex + 1;
  mFailedSyncClient.add(mClientList.get(mClientSyncIndex));
  getMvpView().showSyncedFailedClients(mFailedSyncClient.size());
  checkNetworkConnectionAndSyncClient();
}","public void onAccountSyncFailed(Throwable e){
  try {
    if (e instanceof HttpException) {
      int singleSyncClientMax=getMvpView().getMaxSingleSyncClientProgressBar();
      getMvpView().updateSingleSyncClientProgressBar(singleSyncClientMax);
      mFailedSyncClient.add(mClientList.get(mClientSyncIndex));
      mClientSyncIndex=mClientSyncIndex + 1;
      getMvpView().showSyncedFailedClients(mFailedSyncClient.size());
      checkNetworkConnectionAndSyncClient();
    }
  }
 catch (  Throwable throwable) {
    RxJavaPlugins.getInstance().getErrorHandler().handleError(throwable);
  }
}",0.5975609756097561
32985,"/** 
 * This Method Fetch SavingsAccount and SavingsAccountTransactionTemplate and Sync them in Database table.
 * @param savingsAccountType SavingsAccount Type Example : savingsaccounts
 * @param savingsAccountId SavingsAccount Id
 */
public void syncSavingsAccountAndTemplate(String savingsAccountType,int savingsAccountId){
  checkViewAttached();
  mSubscriptions.add(Observable.zip(mDataManagerSavings.syncSavingsAccount(savingsAccountType,savingsAccountId,Constants.TRANSACTIONS),mDataManagerSavings.syncSavingsAccountTransactionTemplate(savingsAccountType,savingsAccountId,Constants.SAVINGS_ACCOUNT_TRANSACTION_DEPOSIT),new Func2<SavingsAccountWithAssociations,SavingsAccountTransactionTemplate,SavingsAccountAndTransactionTemplate>(){
    @Override public SavingsAccountAndTransactionTemplate call(    SavingsAccountWithAssociations savingsAccountWithAssociations,    SavingsAccountTransactionTemplate savingsAccountTransactionTemplate){
      SavingsAccountAndTransactionTemplate accountAndTransactionTemplate=new SavingsAccountAndTransactionTemplate();
      accountAndTransactionTemplate.setSavingsAccountTransactionTemplate(savingsAccountTransactionTemplate);
      accountAndTransactionTemplate.setSavingsAccountWithAssociations(savingsAccountWithAssociations);
      return accountAndTransactionTemplate;
    }
  }
).observeOn(AndroidSchedulers.mainThread()).subscribeOn(Schedulers.io()).subscribe(new Subscriber<SavingsAccountAndTransactionTemplate>(){
    @Override public void onCompleted(){
    }
    @Override public void onError(    Throwable e){
      onAccountSyncFailed();
    }
    @Override public void onNext(    SavingsAccountAndTransactionTemplate savingsAccountAndTransactionTemplate){
      mSavingsAndTransactionSyncIndex=mSavingsAndTransactionSyncIndex + 1;
      getMvpView().updateSingleSyncClientProgressBar(mLoanAndRepaymentSyncIndex + mSavingsAndTransactionSyncIndex);
      if (mSavingsAndTransactionSyncIndex != mSavingsAccountList.size()) {
        checkNetworkConnectionAndSyncSavingsAccountAndTransactionTemplate();
      }
 else {
        syncClient(mClientList.get(mClientSyncIndex));
      }
    }
  }
));
}","/** 
 * This Method Fetch SavingsAccount and SavingsAccountTransactionTemplate and Sync them in Database table.
 * @param savingsAccountType SavingsAccount Type Example : savingsaccounts
 * @param savingsAccountId   SavingsAccount Id
 */
public void syncSavingsAccountAndTemplate(String savingsAccountType,int savingsAccountId){
  checkViewAttached();
  mSubscriptions.add(Observable.combineLatest(mDataManagerSavings.syncSavingsAccount(savingsAccountType,savingsAccountId,Constants.TRANSACTIONS),mDataManagerSavings.syncSavingsAccountTransactionTemplate(savingsAccountType,savingsAccountId,Constants.SAVINGS_ACCOUNT_TRANSACTION_DEPOSIT),new Func2<SavingsAccountWithAssociations,SavingsAccountTransactionTemplate,SavingsAccountAndTransactionTemplate>(){
    @Override public SavingsAccountAndTransactionTemplate call(    SavingsAccountWithAssociations savingsAccountWithAssociations,    SavingsAccountTransactionTemplate savingsAccountTransactionTemplate){
      SavingsAccountAndTransactionTemplate accountAndTransactionTemplate=new SavingsAccountAndTransactionTemplate();
      accountAndTransactionTemplate.setSavingsAccountTransactionTemplate(savingsAccountTransactionTemplate);
      accountAndTransactionTemplate.setSavingsAccountWithAssociations(savingsAccountWithAssociations);
      return accountAndTransactionTemplate;
    }
  }
).observeOn(AndroidSchedulers.mainThread()).subscribeOn(Schedulers.io()).subscribe(new Subscriber<SavingsAccountAndTransactionTemplate>(){
    @Override public void onCompleted(){
    }
    @Override public void onError(    Throwable e){
      onAccountSyncFailed(e);
    }
    @Override public void onNext(    SavingsAccountAndTransactionTemplate savingsAccountAndTransactionTemplate){
      mSavingsAndTransactionSyncIndex=mSavingsAndTransactionSyncIndex + 1;
      getMvpView().updateSingleSyncClientProgressBar(mLoanAndRepaymentSyncIndex + mSavingsAndTransactionSyncIndex);
      if (mSavingsAndTransactionSyncIndex != mSavingsAccountList.size()) {
        checkNetworkConnectionAndSyncSavingsAccountAndTransactionTemplate();
      }
 else {
        syncClient(mClientList.get(mClientSyncIndex));
      }
    }
  }
));
}",0.9955967555040556
32986,"public List<SavingsAccount> getActiveSavingsAccounts(List<SavingsAccount> savingsAccounts){
  final List<SavingsAccount> accounts=new ArrayList<>();
  Observable.from(savingsAccounts).filter(new Func1<SavingsAccount,Boolean>(){
    @Override public Boolean call(    SavingsAccount savingsAccount){
      return savingsAccount.getStatus().getActive();
    }
  }
).subscribe(new Action1<SavingsAccount>(){
    @Override public void call(    SavingsAccount savingsAccount){
      accounts.add(savingsAccount);
    }
  }
);
  return accounts;
}","public List<SavingsAccount> getActiveSavingsAccounts(List<SavingsAccount> savingsAccounts){
  final List<SavingsAccount> accounts=new ArrayList<>();
  Observable.from(savingsAccounts).filter(new Func1<SavingsAccount,Boolean>(){
    @Override public Boolean call(    SavingsAccount savingsAccount){
      return (savingsAccount.getStatus().getActive() && !savingsAccount.isRecurring());
    }
  }
).subscribe(new Action1<SavingsAccount>(){
    @Override public void call(    SavingsAccount savingsAccount){
      accounts.add(savingsAccount);
    }
  }
);
  return accounts;
}",0.9022421524663676
32987,"/** 
 * This Method Syncing the Client's Loans and their LoanRepayment. This is the Observable.zip In Which two request is going to server Loans and LoanRepayment and This request will not complete till that both request successfully got response (200 OK). In Which one will fail then response will come in onError. and If both request is 200 response then response will come in onNext.
 * @param loanId Loan Id
 */
public void syncLoanAndLoanRepayment(int loanId){
  checkViewAttached();
  mSubscriptions.add(Observable.zip(mDataManagerLoan.syncLoanById(loanId),mDataManagerLoan.syncLoanRepaymentTemplate(loanId),new Func2<LoanWithAssociations,LoanRepaymentTemplate,LoanAndLoanRepayment>(){
    @Override public LoanAndLoanRepayment call(    LoanWithAssociations loanWithAssociations,    LoanRepaymentTemplate loanRepaymentTemplate){
      LoanAndLoanRepayment loanAndLoanRepayment=new LoanAndLoanRepayment();
      loanAndLoanRepayment.setLoanWithAssociations(loanWithAssociations);
      loanAndLoanRepayment.setLoanRepaymentTemplate(loanRepaymentTemplate);
      return loanAndLoanRepayment;
    }
  }
).observeOn(AndroidSchedulers.mainThread()).subscribeOn(Schedulers.io()).subscribe(new Subscriber<LoanAndLoanRepayment>(){
    @Override public void onCompleted(){
    }
    @Override public void onError(    Throwable e){
      onAccountSyncFailed();
    }
    @Override public void onNext(    LoanAndLoanRepayment loanAndLoanRepayment){
      mLoanAndRepaymentSyncIndex=mLoanAndRepaymentSyncIndex + 1;
      getMvpView().updateSingleSyncClientProgressBar(mLoanAndRepaymentSyncIndex);
      if (mLoanAndRepaymentSyncIndex != mLoanAccountList.size()) {
        checkNetworkConnectionAndSyncLoanAndLoanRepayment();
      }
 else {
        setLoanAccountSyncStatusTrue();
        checkAccountsSyncStatusAndSyncAccounts();
      }
    }
  }
));
}","/** 
 * This Method Syncing the Client's Loans and their LoanRepayment. This is the Observable.zip In Which two request is going to server Loans and LoanRepayment and This request will not complete till that both request successfully got response (200 OK). In Which one will fail then response will come in onError. and If both request is 200 response then response will come in onNext.
 * @param loanId Loan Id
 */
public void syncLoanAndLoanRepayment(int loanId){
  checkViewAttached();
  mSubscriptions.add(Observable.combineLatest(mDataManagerLoan.syncLoanById(loanId),mDataManagerLoan.syncLoanRepaymentTemplate(loanId),new Func2<LoanWithAssociations,LoanRepaymentTemplate,LoanAndLoanRepayment>(){
    @Override public LoanAndLoanRepayment call(    LoanWithAssociations loanWithAssociations,    LoanRepaymentTemplate loanRepaymentTemplate){
      LoanAndLoanRepayment loanAndLoanRepayment=new LoanAndLoanRepayment();
      loanAndLoanRepayment.setLoanWithAssociations(loanWithAssociations);
      loanAndLoanRepayment.setLoanRepaymentTemplate(loanRepaymentTemplate);
      return loanAndLoanRepayment;
    }
  }
).observeOn(AndroidSchedulers.mainThread()).subscribeOn(Schedulers.io()).subscribe(new Subscriber<LoanAndLoanRepayment>(){
    @Override public void onCompleted(){
    }
    @Override public void onError(    Throwable e){
      onAccountSyncFailed(e);
    }
    @Override public void onNext(    LoanAndLoanRepayment loanAndLoanRepayment){
      mLoanAndRepaymentSyncIndex=mLoanAndRepaymentSyncIndex + 1;
      getMvpView().updateSingleSyncClientProgressBar(mLoanAndRepaymentSyncIndex);
      if (mLoanAndRepaymentSyncIndex != mLoanAccountList.size()) {
        checkNetworkConnectionAndSyncLoanAndLoanRepayment();
      }
 else {
        setLoanAccountSyncStatusTrue();
        checkAccountsSyncStatusAndSyncAccounts();
      }
    }
  }
));
}",0.995414081467494
32988,"public Integer getFeeChargesCharged(){
  return feeChargesCharged;
}","public Double getFeeChargesCharged(){
  return feeChargesCharged;
}",0.9185185185185184
32989,"public void setInterestWaived(Integer interestWaived){
  this.interestWaived=interestWaived;
}","public void setInterestWaived(Double interestWaived){
  this.interestWaived=interestWaived;
}",0.9411764705882352
32990,"public Integer getFeeChargesOverdue(){
  return feeChargesOverdue;
}","public Double getFeeChargesOverdue(){
  return feeChargesOverdue;
}",0.9185185185185184
32991,"public Integer getFeeChargesWaived(){
  return feeChargesWaived;
}","public Double getFeeChargesWaived(){
  return feeChargesWaived;
}",0.916030534351145
32992,"public void setFeeChargesOverdue(Integer feeChargesOverdue){
  this.feeChargesOverdue=feeChargesOverdue;
}","public void setFeeChargesOverdue(Double feeChargesOverdue){
  this.feeChargesOverdue=feeChargesOverdue;
}",0.9478672985781992
32993,"public Integer getFeeChargesPaid(){
  return feeChargesPaid;
}","public Double getFeeChargesPaid(){
  return feeChargesPaid;
}",0.9105691056910568
32994,"public void setFeeChargesCharged(Integer feeChargesCharged){
  this.feeChargesCharged=feeChargesCharged;
}","public void setFeeChargesCharged(Double feeChargesCharged){
  this.feeChargesCharged=feeChargesCharged;
}",0.9478672985781992
32995,"public void setFeeChargesWaived(Integer feeChargesWaived){
  this.feeChargesWaived=feeChargesWaived;
}","public void setFeeChargesWaived(Double feeChargesWaived){
  this.feeChargesWaived=feeChargesWaived;
}",0.9458128078817734
32996,"public Integer getTotalWaived(){
  return totalWaived;
}","public Double getTotalWaived(){
  return totalWaived;
}",0.9009009009009008
32997,"public void setFeeChargesPaid(Integer feeChargesPaid){
  this.feeChargesPaid=feeChargesPaid;
}","public void setFeeChargesPaid(Double feeChargesPaid){
  this.feeChargesPaid=feeChargesPaid;
}",0.9411764705882352
32998,"public void setTotalWaived(Integer totalWaived){
  this.totalWaived=totalWaived;
}","public void setTotalWaived(Double totalWaived){
  this.totalWaived=totalWaived;
}",0.9325153374233128
32999,"public Integer getInterestWaived(){
  return interestWaived;
}","public Double getInterestWaived(){
  return interestWaived;
}",0.9105691056910568
33000,"protected Summary(Parcel in){
  this.currency=in.readParcelable(Currency.class.getClassLoader());
  this.principalDisbursed=(Integer)in.readValue(Integer.class.getClassLoader());
  this.principalPaid=(Double)in.readValue(Double.class.getClassLoader());
  this.principalWrittenOff=(Integer)in.readValue(Integer.class.getClassLoader());
  this.principalOutstanding=(Double)in.readValue(Double.class.getClassLoader());
  this.principalOverdue=(Double)in.readValue(Double.class.getClassLoader());
  this.interestCharged=(Double)in.readValue(Double.class.getClassLoader());
  this.interestPaid=(Double)in.readValue(Double.class.getClassLoader());
  this.interestWaived=(Integer)in.readValue(Integer.class.getClassLoader());
  this.interestWrittenOff=(Integer)in.readValue(Integer.class.getClassLoader());
  this.interestOutstanding=(Double)in.readValue(Double.class.getClassLoader());
  this.interestOverdue=(Double)in.readValue(Double.class.getClassLoader());
  this.feeChargesCharged=(Integer)in.readValue(Integer.class.getClassLoader());
  this.feeChargesDueAtDisbursementCharged=(Integer)in.readValue(Integer.class.getClassLoader());
  this.feeChargesPaid=(Integer)in.readValue(Integer.class.getClassLoader());
  this.feeChargesWaived=(Integer)in.readValue(Integer.class.getClassLoader());
  this.feeChargesWrittenOff=(Integer)in.readValue(Integer.class.getClassLoader());
  this.feeChargesOutstanding=(Integer)in.readValue(Integer.class.getClassLoader());
  this.feeChargesOverdue=(Integer)in.readValue(Integer.class.getClassLoader());
  this.penaltyChargesCharged=(Integer)in.readValue(Integer.class.getClassLoader());
  this.penaltyChargesPaid=(Integer)in.readValue(Integer.class.getClassLoader());
  this.penaltyChargesWaived=(Integer)in.readValue(Integer.class.getClassLoader());
  this.penaltyChargesWrittenOff=(Integer)in.readValue(Integer.class.getClassLoader());
  this.penaltyChargesOutstanding=(Integer)in.readValue(Integer.class.getClassLoader());
  this.penaltyChargesOverdue=(Integer)in.readValue(Integer.class.getClassLoader());
  this.totalExpectedRepayment=(Double)in.readValue(Double.class.getClassLoader());
  this.totalRepayment=(Double)in.readValue(Double.class.getClassLoader());
  this.totalExpectedCostOfLoan=(Double)in.readValue(Double.class.getClassLoader());
  this.totalCostOfLoan=(Double)in.readValue(Double.class.getClassLoader());
  this.totalWaived=(Integer)in.readValue(Integer.class.getClassLoader());
  this.totalWrittenOff=(Integer)in.readValue(Integer.class.getClassLoader());
  this.totalOutstanding=(Double)in.readValue(Double.class.getClassLoader());
  this.totalOverdue=(Double)in.readValue(Double.class.getClassLoader());
  this.overdueSinceDate=new ArrayList<Integer>();
  in.readList(this.overdueSinceDate,Integer.class.getClassLoader());
}","protected Summary(Parcel in){
  this.currency=in.readParcelable(Currency.class.getClassLoader());
  this.principalDisbursed=(Integer)in.readValue(Integer.class.getClassLoader());
  this.principalPaid=(Double)in.readValue(Double.class.getClassLoader());
  this.principalWrittenOff=(Integer)in.readValue(Integer.class.getClassLoader());
  this.principalOutstanding=(Double)in.readValue(Double.class.getClassLoader());
  this.principalOverdue=(Double)in.readValue(Double.class.getClassLoader());
  this.interestCharged=(Double)in.readValue(Double.class.getClassLoader());
  this.interestPaid=(Double)in.readValue(Double.class.getClassLoader());
  this.interestWaived=(Double)in.readValue(Double.class.getClassLoader());
  this.interestWrittenOff=(Integer)in.readValue(Integer.class.getClassLoader());
  this.interestOutstanding=(Double)in.readValue(Double.class.getClassLoader());
  this.interestOverdue=(Double)in.readValue(Double.class.getClassLoader());
  this.feeChargesCharged=(Double)in.readValue(Double.class.getClassLoader());
  this.feeChargesDueAtDisbursementCharged=(Integer)in.readValue(Integer.class.getClassLoader());
  this.feeChargesPaid=(Double)in.readValue(Double.class.getClassLoader());
  this.feeChargesWaived=(Double)in.readValue(Double.class.getClassLoader());
  this.feeChargesWrittenOff=(Integer)in.readValue(Integer.class.getClassLoader());
  this.feeChargesOutstanding=(Integer)in.readValue(Integer.class.getClassLoader());
  this.feeChargesOverdue=(Double)in.readValue(Double.class.getClassLoader());
  this.penaltyChargesCharged=(Integer)in.readValue(Integer.class.getClassLoader());
  this.penaltyChargesPaid=(Integer)in.readValue(Integer.class.getClassLoader());
  this.penaltyChargesWaived=(Integer)in.readValue(Integer.class.getClassLoader());
  this.penaltyChargesWrittenOff=(Integer)in.readValue(Integer.class.getClassLoader());
  this.penaltyChargesOutstanding=(Integer)in.readValue(Integer.class.getClassLoader());
  this.penaltyChargesOverdue=(Integer)in.readValue(Integer.class.getClassLoader());
  this.totalExpectedRepayment=(Double)in.readValue(Double.class.getClassLoader());
  this.totalRepayment=(Double)in.readValue(Double.class.getClassLoader());
  this.totalExpectedCostOfLoan=(Double)in.readValue(Double.class.getClassLoader());
  this.totalCostOfLoan=(Double)in.readValue(Double.class.getClassLoader());
  this.totalWaived=(Double)in.readValue(Double.class.getClassLoader());
  this.totalWrittenOff=(Integer)in.readValue(Integer.class.getClassLoader());
  this.totalOutstanding=(Double)in.readValue(Double.class.getClassLoader());
  this.totalOverdue=(Double)in.readValue(Double.class.getClassLoader());
  this.overdueSinceDate=new ArrayList<Integer>();
  in.readList(this.overdueSinceDate,Integer.class.getClassLoader());
}",0.9146561037090384
