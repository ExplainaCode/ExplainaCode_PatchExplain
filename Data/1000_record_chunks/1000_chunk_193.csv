record_number,buggy_code,fixed_code,code_similarity
192001,"private void recreateNotificationHeader(){
  final Notification.Builder builder=Notification.Builder.recoverBuilder(getContext(),getStatusBarNotification().getNotification());
  final RemoteViews header=builder.makeNotificationHeader();
  if (mNotificationHeader == null) {
    mNotificationHeader=(NotificationHeaderView)header.apply(getContext(),this);
    final View expandButton=mNotificationHeader.findViewById(com.android.internal.R.id.expand_button);
    expandButton.setVisibility(VISIBLE);
    mNotificationHeader.setOnClickListener(mExpandClickListener);
    mNotificationHeaderWrapper=NotificationViewWrapper.wrap(getContext(),mNotificationHeader);
    addView(mNotificationHeader,indexOfChild(mChildrenContainer) + 1);
    mTranslateableViews.add(mNotificationHeader);
  }
 else {
    header.reapply(getContext(),mNotificationHeader);
    mNotificationHeaderWrapper.notifyContentUpdated(mEntry.notification);
  }
  updateChildrenHeaderAppearance();
}","private void recreateNotificationHeader(){
  final Notification.Builder builder=Notification.Builder.recoverBuilder(getContext(),getStatusBarNotification().getNotification());
  final RemoteViews header=builder.makeNotificationHeader();
  if (mNotificationHeader == null) {
    mNotificationHeader=(NotificationHeaderView)header.apply(getContext(),this);
    final View expandButton=mNotificationHeader.findViewById(com.android.internal.R.id.expand_button);
    expandButton.setVisibility(VISIBLE);
    mNotificationHeader.setOnClickListener(mExpandClickListener);
    mNotificationHeaderWrapper=NotificationViewWrapper.wrap(getContext(),mNotificationHeader,this);
    addView(mNotificationHeader,indexOfChild(mChildrenContainer) + 1);
    mTranslateableViews.add(mNotificationHeader);
  }
 else {
    header.reapply(getContext(),mNotificationHeader);
    mNotificationHeaderWrapper.notifyContentUpdated(mEntry.notification);
  }
  updateChildrenHeaderAppearance();
}",0.9974079834110938
192002,"public void setContractedChild(View child){
  if (mContractedChild != null) {
    mContractedChild.animate().cancel();
    mContractedChild.removeOnLayoutChangeListener(mLayoutUpdater);
    removeView(mContractedChild);
  }
  addView(child);
  mContractedChild=child;
  mContractedChild.addOnLayoutChangeListener(mLayoutUpdater);
  mContractedWrapper=NotificationViewWrapper.wrap(getContext(),child);
  selectLayout(false,true);
  mContractedWrapper.setDark(mDark,false,0);
}","public void setContractedChild(View child){
  if (mContractedChild != null) {
    mContractedChild.animate().cancel();
    mContractedChild.removeOnLayoutChangeListener(mLayoutUpdater);
    removeView(mContractedChild);
  }
  addView(child);
  mContractedChild=child;
  mContractedChild.addOnLayoutChangeListener(mLayoutUpdater);
  mContractedWrapper=NotificationViewWrapper.wrap(getContext(),child,mContainingNotification);
  selectLayout(false,true);
  mContractedWrapper.setDark(mDark,false,0);
}",0.9753593429158112
192003,"public void setExpandedChild(View child){
  if (mExpandedChild != null) {
    mExpandedChild.animate().cancel();
    mExpandedChild.removeOnLayoutChangeListener(mLayoutUpdater);
    removeView(mExpandedChild);
  }
  addView(child);
  mExpandedChild=child;
  mExpandedChild.addOnLayoutChangeListener(mLayoutUpdater);
  mExpandedWrapper=NotificationViewWrapper.wrap(getContext(),child);
  selectLayout(false,true);
}","public void setExpandedChild(View child){
  if (mExpandedChild != null) {
    mExpandedChild.animate().cancel();
    mExpandedChild.removeOnLayoutChangeListener(mLayoutUpdater);
    removeView(mExpandedChild);
  }
  addView(child);
  mExpandedChild=child;
  mExpandedChild.addOnLayoutChangeListener(mLayoutUpdater);
  mExpandedWrapper=NotificationViewWrapper.wrap(getContext(),child,mContainingNotification);
  selectLayout(false,true);
}",0.971830985915493
192004,"public void setHeadsUpChild(View child){
  if (mHeadsUpChild != null) {
    mHeadsUpChild.animate().cancel();
    mHeadsUpChild.removeOnLayoutChangeListener(mLayoutUpdater);
    removeView(mHeadsUpChild);
  }
  addView(child);
  mHeadsUpChild=child;
  mHeadsUpChild.addOnLayoutChangeListener(mLayoutUpdater);
  mHeadsUpWrapper=NotificationViewWrapper.wrap(getContext(),child);
  selectLayout(false,true);
}","public void setHeadsUpChild(View child){
  if (mHeadsUpChild != null) {
    mHeadsUpChild.animate().cancel();
    mHeadsUpChild.removeOnLayoutChangeListener(mLayoutUpdater);
    removeView(mHeadsUpChild);
  }
  addView(child);
  mHeadsUpChild=child;
  mHeadsUpChild.addOnLayoutChangeListener(mLayoutUpdater);
  mHeadsUpWrapper=NotificationViewWrapper.wrap(getContext(),child,mContainingNotification);
  selectLayout(false,true);
}",0.971291866028708
192005,"protected NotificationBigPictureTemplateViewWrapper(Context ctx,View view){
  super(ctx,view);
}","protected NotificationBigPictureTemplateViewWrapper(Context ctx,View view,ExpandableNotificationRow row){
  super(ctx,view,row);
}",0.8495575221238938
192006,"protected NotificationBigTextTemplateViewWrapper(Context ctx,View view){
  super(ctx,view);
}","protected NotificationBigTextTemplateViewWrapper(Context ctx,View view,ExpandableNotificationRow row){
  super(ctx,view,row);
}",0.8454545454545455
192007,"protected NotificationCustomViewWrapper(View view){
  super(view);
  mInvertHelper=new ViewInvertHelper(view,NotificationPanelView.DOZE_ANIMATION_DURATION);
}","protected NotificationCustomViewWrapper(View view,ExpandableNotificationRow row){
  super(view,row);
  mInvertHelper=new ViewInvertHelper(view,NotificationPanelView.DOZE_ANIMATION_DURATION);
}",0.9028571428571428
192008,"@Override public void setDark(boolean dark,boolean fade,long delay){
  if (dark == mDark && mDarkInitialized) {
    return;
  }
  super.setDark(dark,fade,delay);
  if (fade) {
    mInvertHelper.fade(dark,delay);
  }
 else {
    mInvertHelper.update(dark);
  }
  if (mIcon != null) {
    boolean hadColorFilter=mNotificationHeader.getOriginalIconColor() != NotificationHeaderView.NO_COLOR;
    if (fade) {
      if (hadColorFilter) {
        fadeIconColorFilter(mIcon,dark,delay);
        fadeIconAlpha(mIcon,dark,delay);
      }
 else {
        fadeGrayscale(mIcon,dark,delay);
      }
    }
 else {
      if (hadColorFilter) {
        updateIconColorFilter(mIcon,dark);
        updateIconAlpha(mIcon,dark);
      }
 else {
        updateGrayscale(mIcon,dark);
      }
    }
  }
}","@Override public void setDark(boolean dark,boolean fade,long delay){
  if (dark == mDark && mDarkInitialized) {
    return;
  }
  super.setDark(dark,fade,delay);
  if (fade) {
    mInvertHelper.fade(dark,delay);
  }
 else {
    mInvertHelper.update(dark);
  }
  if (mIcon != null && !mRow.isChildInGroup()) {
    boolean hadColorFilter=mNotificationHeader.getOriginalIconColor() != NotificationHeaderView.NO_COLOR;
    if (fade) {
      if (hadColorFilter) {
        fadeIconColorFilter(mIcon,dark,delay);
        fadeIconAlpha(mIcon,dark,delay);
      }
 else {
        fadeGrayscale(mIcon,dark,delay);
      }
    }
 else {
      if (hadColorFilter) {
        updateIconColorFilter(mIcon,dark);
        updateIconAlpha(mIcon,dark);
      }
 else {
        updateGrayscale(mIcon,dark);
      }
    }
  }
}",0.9836065573770492
192009,"protected NotificationHeaderViewWrapper(Context ctx,View view){
  super(view);
  mIconDarkAlpha=ctx.getResources().getInteger(R.integer.doze_small_icon_alpha);
  mInvertHelper=new ViewInvertHelper(ctx,NotificationPanelView.DOZE_ANIMATION_DURATION);
  mTransformationHelper=new ViewTransformationHelper();
  resolveHeaderViews();
  updateInvertHelper();
}","protected NotificationHeaderViewWrapper(Context ctx,View view,ExpandableNotificationRow row){
  super(view,row);
  mIconDarkAlpha=ctx.getResources().getInteger(R.integer.doze_small_icon_alpha);
  mInvertHelper=new ViewInvertHelper(ctx,NotificationPanelView.DOZE_ANIMATION_DURATION);
  mTransformationHelper=new ViewTransformationHelper();
  resolveHeaderViews();
  updateInvertHelper();
}",0.954177897574124
192010,"protected NotificationMediaTemplateViewWrapper(Context ctx,View view){
  super(ctx,view);
}","protected NotificationMediaTemplateViewWrapper(Context ctx,View view,ExpandableNotificationRow row){
  super(ctx,view,row);
}",0.8425925925925926
192011,"protected NotificationTemplateViewWrapper(Context ctx,View view){
  super(ctx,view);
  mTransformationHelper.setCustomTransformation(new ViewTransformationHelper.CustomTransformation(){
    @Override public boolean transformTo(    TransformState ownState,    TransformableView notification,    final float transformationAmount){
      if (!(notification instanceof HybridNotificationView)) {
        return false;
      }
      TransformState otherState=notification.getCurrentState(TRANSFORMING_VIEW_TITLE);
      final View text=ownState.getTransformedView();
      CrossFadeHelper.fadeOut(text,transformationAmount);
      if (otherState != null) {
        ownState.transformViewVerticalTo(otherState,this,transformationAmount);
        otherState.recycle();
      }
      return true;
    }
    @Override public boolean customTransformTarget(    TransformState ownState,    TransformState otherState){
      float endY=getTransformationY(ownState,otherState);
      ownState.setTransformationEndY(endY);
      return true;
    }
    @Override public boolean transformFrom(    TransformState ownState,    TransformableView notification,    float transformationAmount){
      if (!(notification instanceof HybridNotificationView)) {
        return false;
      }
      TransformState otherState=notification.getCurrentState(TRANSFORMING_VIEW_TITLE);
      final View text=ownState.getTransformedView();
      CrossFadeHelper.fadeIn(text,transformationAmount);
      if (otherState != null) {
        ownState.transformViewVerticalFrom(otherState,this,transformationAmount);
        otherState.recycle();
      }
      return true;
    }
    @Override public boolean initTransformation(    TransformState ownState,    TransformState otherState){
      float startY=getTransformationY(ownState,otherState);
      ownState.setTransformationStartY(startY);
      return true;
    }
    private float getTransformationY(    TransformState ownState,    TransformState otherState){
      int[] otherStablePosition=otherState.getLaidOutLocationOnScreen();
      int[] ownStablePosition=ownState.getLaidOutLocationOnScreen();
      return (otherStablePosition[1] + otherState.getTransformedView().getHeight() - ownStablePosition[1]) * 0.33f;
    }
  }
,TRANSFORMING_VIEW_TEXT);
}","protected NotificationTemplateViewWrapper(Context ctx,View view,ExpandableNotificationRow row){
  super(ctx,view,row);
  mTransformationHelper.setCustomTransformation(new ViewTransformationHelper.CustomTransformation(){
    @Override public boolean transformTo(    TransformState ownState,    TransformableView notification,    final float transformationAmount){
      if (!(notification instanceof HybridNotificationView)) {
        return false;
      }
      TransformState otherState=notification.getCurrentState(TRANSFORMING_VIEW_TITLE);
      final View text=ownState.getTransformedView();
      CrossFadeHelper.fadeOut(text,transformationAmount);
      if (otherState != null) {
        ownState.transformViewVerticalTo(otherState,this,transformationAmount);
        otherState.recycle();
      }
      return true;
    }
    @Override public boolean customTransformTarget(    TransformState ownState,    TransformState otherState){
      float endY=getTransformationY(ownState,otherState);
      ownState.setTransformationEndY(endY);
      return true;
    }
    @Override public boolean transformFrom(    TransformState ownState,    TransformableView notification,    float transformationAmount){
      if (!(notification instanceof HybridNotificationView)) {
        return false;
      }
      TransformState otherState=notification.getCurrentState(TRANSFORMING_VIEW_TITLE);
      final View text=ownState.getTransformedView();
      CrossFadeHelper.fadeIn(text,transformationAmount);
      if (otherState != null) {
        ownState.transformViewVerticalFrom(otherState,this,transformationAmount);
        otherState.recycle();
      }
      return true;
    }
    @Override public boolean initTransformation(    TransformState ownState,    TransformState otherState){
      float startY=getTransformationY(ownState,otherState);
      ownState.setTransformationStartY(startY);
      return true;
    }
    private float getTransformationY(    TransformState ownState,    TransformState otherState){
      int[] otherStablePosition=otherState.getLaidOutLocationOnScreen();
      int[] ownStablePosition=ownState.getLaidOutLocationOnScreen();
      return (otherStablePosition[1] + otherState.getTransformedView().getHeight() - ownStablePosition[1]) * 0.33f;
    }
  }
,TRANSFORMING_VIEW_TEXT);
}",0.9925731760594146
192012,"protected NotificationViewWrapper(View view){
  mView=view;
}","protected NotificationViewWrapper(View view,ExpandableNotificationRow row){
  mView=view;
  mRow=row;
}",0.7439024390243902
192013,"public static NotificationViewWrapper wrap(Context ctx,View v){
  if (v.getId() == com.android.internal.R.id.status_bar_latest_event_content) {
    if (""String_Node_Str"".equals(v.getTag())) {
      return new NotificationBigPictureTemplateViewWrapper(ctx,v);
    }
 else     if (""String_Node_Str"".equals(v.getTag())) {
      return new NotificationBigTextTemplateViewWrapper(ctx,v);
    }
 else     if (""String_Node_Str"".equals(v.getTag()) || ""String_Node_Str"".equals(v.getTag())) {
      return new NotificationMediaTemplateViewWrapper(ctx,v);
    }
    return new NotificationTemplateViewWrapper(ctx,v);
  }
 else   if (v instanceof NotificationHeaderView) {
    return new NotificationHeaderViewWrapper(ctx,v);
  }
 else {
    return new NotificationCustomViewWrapper(v);
  }
}","public static NotificationViewWrapper wrap(Context ctx,View v,ExpandableNotificationRow row){
  if (v.getId() == com.android.internal.R.id.status_bar_latest_event_content) {
    if (""String_Node_Str"".equals(v.getTag())) {
      return new NotificationBigPictureTemplateViewWrapper(ctx,v,row);
    }
 else     if (""String_Node_Str"".equals(v.getTag())) {
      return new NotificationBigTextTemplateViewWrapper(ctx,v,row);
    }
 else     if (""String_Node_Str"".equals(v.getTag()) || ""String_Node_Str"".equals(v.getTag())) {
      return new NotificationMediaTemplateViewWrapper(ctx,v,row);
    }
    return new NotificationTemplateViewWrapper(ctx,v,row);
  }
 else   if (v instanceof NotificationHeaderView) {
    return new NotificationHeaderViewWrapper(ctx,v,row);
  }
 else {
    return new NotificationCustomViewWrapper(v,row);
  }
}",0.966542750929368
192014,"/** 
 * Unflatten the notification from a parcel.
 */
public Notification(Parcel parcel){
  int version=parcel.readInt();
  when=parcel.readLong();
  if (parcel.readInt() != 0) {
    mSmallIcon=Icon.CREATOR.createFromParcel(parcel);
    if (mSmallIcon.getType() == Icon.TYPE_RESOURCE) {
      icon=mSmallIcon.getResId();
    }
  }
  number=parcel.readInt();
  if (parcel.readInt() != 0) {
    contentIntent=PendingIntent.CREATOR.createFromParcel(parcel);
  }
  if (parcel.readInt() != 0) {
    deleteIntent=PendingIntent.CREATOR.createFromParcel(parcel);
  }
  if (parcel.readInt() != 0) {
    tickerText=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(parcel);
  }
  if (parcel.readInt() != 0) {
    tickerView=RemoteViews.CREATOR.createFromParcel(parcel);
  }
  if (parcel.readInt() != 0) {
    contentView=RemoteViews.CREATOR.createFromParcel(parcel);
  }
  if (parcel.readInt() != 0) {
    mLargeIcon=Icon.CREATOR.createFromParcel(parcel);
  }
  defaults=parcel.readInt();
  flags=parcel.readInt();
  if (parcel.readInt() != 0) {
    sound=Uri.CREATOR.createFromParcel(parcel);
  }
  audioStreamType=parcel.readInt();
  if (parcel.readInt() != 0) {
    audioAttributes=AudioAttributes.CREATOR.createFromParcel(parcel);
  }
  vibrate=parcel.createLongArray();
  ledARGB=parcel.readInt();
  ledOnMS=parcel.readInt();
  ledOffMS=parcel.readInt();
  iconLevel=parcel.readInt();
  if (parcel.readInt() != 0) {
    fullScreenIntent=PendingIntent.CREATOR.createFromParcel(parcel);
  }
  priority=parcel.readInt();
  category=parcel.readString();
  mGroupKey=parcel.readString();
  mSortKey=parcel.readString();
  extras=Bundle.setDefusable(parcel.readBundle(),true);
  actions=parcel.createTypedArray(Action.CREATOR);
  if (parcel.readInt() != 0) {
    bigContentView=RemoteViews.CREATOR.createFromParcel(parcel);
  }
  if (parcel.readInt() != 0) {
    headsUpContentView=RemoteViews.CREATOR.createFromParcel(parcel);
  }
  visibility=parcel.readInt();
  if (parcel.readInt() != 0) {
    publicVersion=Notification.CREATOR.createFromParcel(parcel);
  }
  color=parcel.readInt();
}","/** 
 * Unflatten the notification from a parcel.
 */
public Notification(Parcel parcel){
  int version=parcel.readInt();
  when=parcel.readLong();
  creationTime=parcel.readLong();
  if (parcel.readInt() != 0) {
    mSmallIcon=Icon.CREATOR.createFromParcel(parcel);
    if (mSmallIcon.getType() == Icon.TYPE_RESOURCE) {
      icon=mSmallIcon.getResId();
    }
  }
  number=parcel.readInt();
  if (parcel.readInt() != 0) {
    contentIntent=PendingIntent.CREATOR.createFromParcel(parcel);
  }
  if (parcel.readInt() != 0) {
    deleteIntent=PendingIntent.CREATOR.createFromParcel(parcel);
  }
  if (parcel.readInt() != 0) {
    tickerText=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(parcel);
  }
  if (parcel.readInt() != 0) {
    tickerView=RemoteViews.CREATOR.createFromParcel(parcel);
  }
  if (parcel.readInt() != 0) {
    contentView=RemoteViews.CREATOR.createFromParcel(parcel);
  }
  if (parcel.readInt() != 0) {
    mLargeIcon=Icon.CREATOR.createFromParcel(parcel);
  }
  defaults=parcel.readInt();
  flags=parcel.readInt();
  if (parcel.readInt() != 0) {
    sound=Uri.CREATOR.createFromParcel(parcel);
  }
  audioStreamType=parcel.readInt();
  if (parcel.readInt() != 0) {
    audioAttributes=AudioAttributes.CREATOR.createFromParcel(parcel);
  }
  vibrate=parcel.createLongArray();
  ledARGB=parcel.readInt();
  ledOnMS=parcel.readInt();
  ledOffMS=parcel.readInt();
  iconLevel=parcel.readInt();
  if (parcel.readInt() != 0) {
    fullScreenIntent=PendingIntent.CREATOR.createFromParcel(parcel);
  }
  priority=parcel.readInt();
  category=parcel.readString();
  mGroupKey=parcel.readString();
  mSortKey=parcel.readString();
  extras=Bundle.setDefusable(parcel.readBundle(),true);
  actions=parcel.createTypedArray(Action.CREATOR);
  if (parcel.readInt() != 0) {
    bigContentView=RemoteViews.CREATOR.createFromParcel(parcel);
  }
  if (parcel.readInt() != 0) {
    headsUpContentView=RemoteViews.CREATOR.createFromParcel(parcel);
  }
  visibility=parcel.readInt();
  if (parcel.readInt() != 0) {
    publicVersion=Notification.CREATOR.createFromParcel(parcel);
  }
  color=parcel.readInt();
}",0.9918854415274464
192015,"private void bindHeaderChronometerAndTime(RemoteViews contentView){
  if (showsTimeOrChronometer()) {
    contentView.setViewVisibility(R.id.time_divider,View.VISIBLE);
    if (mN.extras.getBoolean(EXTRA_SHOW_CHRONOMETER)) {
      contentView.setViewVisibility(R.id.chronometer,View.VISIBLE);
      contentView.setLong(R.id.chronometer,""String_Node_Str"",mN.when + (SystemClock.elapsedRealtime() - System.currentTimeMillis()));
      contentView.setBoolean(R.id.chronometer,""String_Node_Str"",true);
      boolean countsDown=mN.extras.getBoolean(EXTRA_CHRONOMETER_COUNTS_DOWN);
      contentView.setChronometerCountDown(R.id.chronometer,countsDown);
    }
 else {
      contentView.setViewVisibility(R.id.time,View.VISIBLE);
      contentView.setLong(R.id.time,""String_Node_Str"",mN.when);
    }
  }
}","private void bindHeaderChronometerAndTime(RemoteViews contentView){
  if (showsTimeOrChronometer()) {
    contentView.setViewVisibility(R.id.time_divider,View.VISIBLE);
    if (mN.extras.getBoolean(EXTRA_SHOW_CHRONOMETER)) {
      contentView.setViewVisibility(R.id.chronometer,View.VISIBLE);
      contentView.setLong(R.id.chronometer,""String_Node_Str"",mN.when + (SystemClock.elapsedRealtime() - System.currentTimeMillis()));
      contentView.setBoolean(R.id.chronometer,""String_Node_Str"",true);
      boolean countsDown=mN.extras.getBoolean(EXTRA_CHRONOMETER_COUNTS_DOWN);
      contentView.setChronometerCountDown(R.id.chronometer,countsDown);
    }
 else {
      contentView.setViewVisibility(R.id.time,View.VISIBLE);
      contentView.setLong(R.id.time,""String_Node_Str"",mN.when);
    }
  }
 else {
    contentView.setLong(R.id.time,""String_Node_Str"",mN.when != 0 ? mN.when : mN.creationTime);
  }
}",0.9371697005284793
192016,"/** 
 * Resets the notification header to its original state
 */
private void resetNotificationHeader(RemoteViews contentView){
  contentView.setImageViewResource(R.id.icon,0);
  contentView.setBoolean(R.id.notification_header,""String_Node_Str"",false);
  contentView.setTextViewText(R.id.app_name_text,null);
  contentView.setViewVisibility(R.id.chronometer,View.GONE);
  contentView.setViewVisibility(R.id.header_text,View.GONE);
  contentView.setViewVisibility(R.id.header_text_divider,View.GONE);
  contentView.setViewVisibility(R.id.time_divider,View.GONE);
  contentView.setImageViewIcon(R.id.profile_badge,null);
  contentView.setViewVisibility(R.id.profile_badge,View.GONE);
}","/** 
 * Resets the notification header to its original state
 */
private void resetNotificationHeader(RemoteViews contentView){
  contentView.setImageViewResource(R.id.icon,0);
  contentView.setBoolean(R.id.notification_header,""String_Node_Str"",false);
  contentView.setTextViewText(R.id.app_name_text,null);
  contentView.setViewVisibility(R.id.chronometer,View.GONE);
  contentView.setViewVisibility(R.id.header_text,View.GONE);
  contentView.setViewVisibility(R.id.header_text_divider,View.GONE);
  contentView.setViewVisibility(R.id.time_divider,View.GONE);
  contentView.setViewVisibility(R.id.time,View.GONE);
  contentView.setImageViewIcon(R.id.profile_badge,null);
  contentView.setViewVisibility(R.id.profile_badge,View.GONE);
}",0.8380281690140845
192017,"/** 
 * @return true if the built notification will show the time or the chronometer; falseotherwise
 */
private boolean showsTimeOrChronometer(){
  return mN.when != 0 && mN.extras.getBoolean(EXTRA_SHOW_WHEN);
}","/** 
 * @return true if the notification will show the time or the chronometer; falseotherwise
 * @hide
 */
public boolean showsTimeOrChronometer(){
  return when != 0 && extras.getBoolean(EXTRA_SHOW_WHEN);
}",0.5952380952380952
192018,"/** 
 * Copy all (or if heavy is false, all except Bitmaps and RemoteViews) members of this into that.
 * @hide
 */
public void cloneInto(Notification that,boolean heavy){
  that.when=this.when;
  that.mSmallIcon=this.mSmallIcon;
  that.number=this.number;
  that.contentIntent=this.contentIntent;
  that.deleteIntent=this.deleteIntent;
  that.fullScreenIntent=this.fullScreenIntent;
  if (this.tickerText != null) {
    that.tickerText=this.tickerText.toString();
  }
  if (heavy && this.tickerView != null) {
    that.tickerView=this.tickerView.clone();
  }
  if (heavy && this.contentView != null) {
    that.contentView=this.contentView.clone();
  }
  if (heavy && this.mLargeIcon != null) {
    that.mLargeIcon=this.mLargeIcon;
  }
  that.iconLevel=this.iconLevel;
  that.sound=this.sound;
  that.audioStreamType=this.audioStreamType;
  if (this.audioAttributes != null) {
    that.audioAttributes=new AudioAttributes.Builder(this.audioAttributes).build();
  }
  final long[] vibrate=this.vibrate;
  if (vibrate != null) {
    final int N=vibrate.length;
    final long[] vib=that.vibrate=new long[N];
    System.arraycopy(vibrate,0,vib,0,N);
  }
  that.ledARGB=this.ledARGB;
  that.ledOnMS=this.ledOnMS;
  that.ledOffMS=this.ledOffMS;
  that.defaults=this.defaults;
  that.flags=this.flags;
  that.priority=this.priority;
  that.category=this.category;
  that.mGroupKey=this.mGroupKey;
  that.mSortKey=this.mSortKey;
  if (this.extras != null) {
    try {
      that.extras=new Bundle(this.extras);
      that.extras.size();
    }
 catch (    BadParcelableException e) {
      Log.e(TAG,""String_Node_Str"" + this,e);
      that.extras=null;
    }
  }
  if (this.actions != null) {
    that.actions=new Action[this.actions.length];
    for (int i=0; i < this.actions.length; i++) {
      that.actions[i]=this.actions[i].clone();
    }
  }
  if (heavy && this.bigContentView != null) {
    that.bigContentView=this.bigContentView.clone();
  }
  if (heavy && this.headsUpContentView != null) {
    that.headsUpContentView=this.headsUpContentView.clone();
  }
  that.visibility=this.visibility;
  if (this.publicVersion != null) {
    that.publicVersion=new Notification();
    this.publicVersion.cloneInto(that.publicVersion,heavy);
  }
  that.color=this.color;
  if (!heavy) {
    that.lightenPayload();
  }
}","/** 
 * Copy all (or if heavy is false, all except Bitmaps and RemoteViews) members of this into that.
 * @hide
 */
public void cloneInto(Notification that,boolean heavy){
  that.when=this.when;
  that.creationTime=this.creationTime;
  that.mSmallIcon=this.mSmallIcon;
  that.number=this.number;
  that.contentIntent=this.contentIntent;
  that.deleteIntent=this.deleteIntent;
  that.fullScreenIntent=this.fullScreenIntent;
  if (this.tickerText != null) {
    that.tickerText=this.tickerText.toString();
  }
  if (heavy && this.tickerView != null) {
    that.tickerView=this.tickerView.clone();
  }
  if (heavy && this.contentView != null) {
    that.contentView=this.contentView.clone();
  }
  if (heavy && this.mLargeIcon != null) {
    that.mLargeIcon=this.mLargeIcon;
  }
  that.iconLevel=this.iconLevel;
  that.sound=this.sound;
  that.audioStreamType=this.audioStreamType;
  if (this.audioAttributes != null) {
    that.audioAttributes=new AudioAttributes.Builder(this.audioAttributes).build();
  }
  final long[] vibrate=this.vibrate;
  if (vibrate != null) {
    final int N=vibrate.length;
    final long[] vib=that.vibrate=new long[N];
    System.arraycopy(vibrate,0,vib,0,N);
  }
  that.ledARGB=this.ledARGB;
  that.ledOnMS=this.ledOnMS;
  that.ledOffMS=this.ledOffMS;
  that.defaults=this.defaults;
  that.flags=this.flags;
  that.priority=this.priority;
  that.category=this.category;
  that.mGroupKey=this.mGroupKey;
  that.mSortKey=this.mSortKey;
  if (this.extras != null) {
    try {
      that.extras=new Bundle(this.extras);
      that.extras.size();
    }
 catch (    BadParcelableException e) {
      Log.e(TAG,""String_Node_Str"" + this,e);
      that.extras=null;
    }
  }
  if (this.actions != null) {
    that.actions=new Action[this.actions.length];
    for (int i=0; i < this.actions.length; i++) {
      that.actions[i]=this.actions[i].clone();
    }
  }
  if (heavy && this.bigContentView != null) {
    that.bigContentView=this.bigContentView.clone();
  }
  if (heavy && this.headsUpContentView != null) {
    that.headsUpContentView=this.headsUpContentView.clone();
  }
  that.visibility=this.visibility;
  if (this.publicVersion != null) {
    that.publicVersion=new Notification();
    this.publicVersion.cloneInto(that.publicVersion,heavy);
  }
  that.color=this.color;
  if (!heavy) {
    that.lightenPayload();
  }
}",0.9916362856530132
192019,"void update(){
  if (mTime == null) {
    return;
  }
  if (mShowRelativeTime) {
    updateRelativeTime();
    return;
  }
  int display;
  Date time=mTime;
  Time t=new Time();
  t.set(mTimeMillis);
  t.second=0;
  t.hour-=12;
  long twelveHoursBefore=t.toMillis(false);
  t.hour+=12;
  long twelveHoursAfter=t.toMillis(false);
  t.hour=0;
  t.minute=0;
  long midnightBefore=t.toMillis(false);
  t.monthDay++;
  long midnightAfter=t.toMillis(false);
  long nowMillis=System.currentTimeMillis();
  t.set(nowMillis);
  t.second=0;
  nowMillis=t.normalize(false);
  choose_display: {
    if ((nowMillis >= midnightBefore && nowMillis < midnightAfter) || (nowMillis >= twelveHoursBefore && nowMillis < twelveHoursAfter)) {
      display=SHOW_TIME;
      break choose_display;
    }
    display=SHOW_MONTH_DAY_YEAR;
    break choose_display;
  }
  DateFormat format;
  if (display == mLastDisplay && mLastFormat != null) {
    format=mLastFormat;
  }
 else {
switch (display) {
case SHOW_TIME:
      format=getTimeFormat();
    break;
case SHOW_MONTH_DAY_YEAR:
  format=DateFormat.getDateInstance(DateFormat.SHORT);
break;
default :
throw new RuntimeException(""String_Node_Str"" + display);
}
mLastFormat=format;
}
String text=format.format(mTime);
setText(text);
if (display == SHOW_TIME) {
mUpdateTimeMillis=twelveHoursAfter > midnightAfter ? twelveHoursAfter : midnightAfter;
}
 else {
if (mTimeMillis < nowMillis) {
mUpdateTimeMillis=0;
}
 else {
mUpdateTimeMillis=twelveHoursBefore < midnightBefore ? twelveHoursBefore : midnightBefore;
}
}
}","void update(){
  if (mTime == null || getVisibility() == GONE) {
    return;
  }
  if (mShowRelativeTime) {
    updateRelativeTime();
    return;
  }
  int display;
  Date time=mTime;
  Time t=new Time();
  t.set(mTimeMillis);
  t.second=0;
  t.hour-=12;
  long twelveHoursBefore=t.toMillis(false);
  t.hour+=12;
  long twelveHoursAfter=t.toMillis(false);
  t.hour=0;
  t.minute=0;
  long midnightBefore=t.toMillis(false);
  t.monthDay++;
  long midnightAfter=t.toMillis(false);
  long nowMillis=System.currentTimeMillis();
  t.set(nowMillis);
  t.second=0;
  nowMillis=t.normalize(false);
  choose_display: {
    if ((nowMillis >= midnightBefore && nowMillis < midnightAfter) || (nowMillis >= twelveHoursBefore && nowMillis < twelveHoursAfter)) {
      display=SHOW_TIME;
      break choose_display;
    }
    display=SHOW_MONTH_DAY_YEAR;
    break choose_display;
  }
  DateFormat format;
  if (display == mLastDisplay && mLastFormat != null) {
    format=mLastFormat;
  }
 else {
switch (display) {
case SHOW_TIME:
      format=getTimeFormat();
    break;
case SHOW_MONTH_DAY_YEAR:
  format=DateFormat.getDateInstance(DateFormat.SHORT);
break;
default :
throw new RuntimeException(""String_Node_Str"" + display);
}
mLastFormat=format;
}
String text=format.format(mTime);
setText(text);
if (display == SHOW_TIME) {
mUpdateTimeMillis=twelveHoursAfter > midnightAfter ? twelveHoursAfter : midnightAfter;
}
 else {
if (mTimeMillis < nowMillis) {
mUpdateTimeMillis=0;
}
 else {
mUpdateTimeMillis=twelveHoursBefore < midnightBefore ? twelveHoursBefore : midnightBefore;
}
}
}",0.9913266945069064
192020,"void positionTask(final TaskRecord task,int position){
  final ActivityStack prevStack=preAddTask(task,""String_Node_Str"");
  task.stack=this;
  insertTaskAtPosition(task,position);
  postAddTask(task,prevStack);
}","void positionTask(final TaskRecord task,int position){
  final ActivityRecord topRunningActivity=task.topRunningActivityLocked();
  final boolean wasResumed=topRunningActivity == task.stack.mResumedActivity;
  final ActivityStack prevStack=preAddTask(task,""String_Node_Str"");
  task.stack=this;
  insertTaskAtPosition(task,position);
  postAddTask(task,prevStack);
  if (wasResumed) {
    if (mResumedActivity != null) {
      Log.wtf(TAG,""String_Node_Str"" + ""String_Node_Str"" + mResumedActivity + ""String_Node_Str""+ topRunningActivity);
    }
    mResumedActivity=topRunningActivity;
  }
}",0.5305105853051059
192021,"/** 
 * Handles dragging touch events
 */
private void handleTouchEvent(MotionEvent ev){
  int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
    mDownPos.set((int)ev.getX(),(int)ev.getY());
  break;
case MotionEvent.ACTION_MOVE:
{
  float evX=ev.getX();
  float evY=ev.getY();
  float x=evX - mTaskViewOffset.x;
  float y=evY - mTaskViewOffset.y;
  if (mDragRequested) {
    if (!mIsDragging) {
      mIsDragging=Math.hypot(evX - mDownPos.x,evY - mDownPos.y) > mDragSlop;
    }
    if (mIsDragging) {
      int width=mRv.getMeasuredWidth();
      int height=mRv.getMeasuredHeight();
      DropTarget currentDropTarget=null;
      if (mLastDropTarget != null) {
        if (mLastDropTarget.acceptsDrop((int)evX,(int)evY,width,height,true)) {
          currentDropTarget=mLastDropTarget;
        }
      }
      if (currentDropTarget == null) {
        for (        DropTarget target : mDropTargets) {
          if (target.acceptsDrop((int)evX,(int)evY,width,height,false)) {
            currentDropTarget=target;
            break;
          }
        }
      }
      if (mLastDropTarget != currentDropTarget) {
        mLastDropTarget=currentDropTarget;
        EventBus.getDefault().send(new DragDropTargetChangedEvent(mDragTask,currentDropTarget));
      }
    }
    mTaskView.setTranslationX(x);
    mTaskView.setTranslationY(y);
  }
  break;
}
case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_CANCEL:
{
if (mDragRequested) {
  EventBus.getDefault().send(new DragEndEvent(mDragTask,mTaskView,mLastDropTarget));
  break;
}
}
}
}","/** 
 * Handles dragging touch events
 */
private void handleTouchEvent(MotionEvent ev){
  int action=ev.getActionMasked();
switch (action) {
case MotionEvent.ACTION_DOWN:
    mDownPos.set((int)ev.getX(),(int)ev.getY());
  break;
case MotionEvent.ACTION_MOVE:
{
  float evX=ev.getX();
  float evY=ev.getY();
  float x=evX - mTaskViewOffset.x;
  float y=evY - mTaskViewOffset.y;
  if (mDragRequested) {
    if (!mIsDragging) {
      mIsDragging=Math.hypot(evX - mDownPos.x,evY - mDownPos.y) > mDragSlop;
    }
    if (mIsDragging) {
      int width=mRv.getMeasuredWidth();
      int height=mRv.getMeasuredHeight();
      DropTarget currentDropTarget=null;
      if (mLastDropTarget != null) {
        if (mLastDropTarget.acceptsDrop((int)evX,(int)evY,width,height,true)) {
          currentDropTarget=mLastDropTarget;
        }
      }
      if (currentDropTarget == null) {
        for (        DropTarget target : mDropTargets) {
          if (target.acceptsDrop((int)evX,(int)evY,width,height,false)) {
            currentDropTarget=target;
            break;
          }
        }
      }
      if (mLastDropTarget != currentDropTarget) {
        mLastDropTarget=currentDropTarget;
        EventBus.getDefault().send(new DragDropTargetChangedEvent(mDragTask,currentDropTarget));
      }
    }
    mTaskView.setTranslationX(x);
    mTaskView.setTranslationY(y);
  }
  break;
}
case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_CANCEL:
{
if (mDragRequested) {
  EventBus.getDefault().send(new DragEndEvent(mDragTask,mTaskView,action == MotionEvent.ACTION_UP ? mLastDropTarget : null));
  break;
}
}
}
}",0.9771088115396676
192022,"/** 
 * @return true if transition is not running and should not be skipped, false if transition isalready running
 */
boolean prepareAppTransitionLocked(int transit,boolean alwaysKeepCurrent){
  if (DEBUG_APP_TRANSITIONS)   Slog.v(TAG,""String_Node_Str"" + ""String_Node_Str"" + appTransitionToString(transit) + ""String_Node_Str""+ this+ ""String_Node_Str""+ alwaysKeepCurrent+ ""String_Node_Str""+ Debug.getCallers(3));
  if (!isTransitionSet() || mNextAppTransition == TRANSIT_NONE) {
    setAppTransition(transit);
  }
 else   if (!alwaysKeepCurrent) {
    if (transit == TRANSIT_TASK_OPEN && isTransitionEqual(TRANSIT_TASK_CLOSE)) {
      setAppTransition(transit);
    }
 else     if (transit == TRANSIT_ACTIVITY_OPEN && isTransitionEqual(TRANSIT_ACTIVITY_CLOSE)) {
      setAppTransition(transit);
    }
  }
  boolean prepared=prepare();
  if (isTransitionSet()) {
    mService.mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
    mService.mH.sendEmptyMessageDelayed(H.APP_TRANSITION_TIMEOUT,APP_TRANSITION_TIMEOUT_MS);
  }
  return prepared;
}","/** 
 * @return true if transition is not running and should not be skipped, false if transition isalready running
 */
boolean prepareAppTransitionLocked(int transit,boolean alwaysKeepCurrent){
  if (DEBUG_APP_TRANSITIONS)   Slog.v(TAG,""String_Node_Str"" + ""String_Node_Str"" + appTransitionToString(transit) + ""String_Node_Str""+ this+ ""String_Node_Str""+ alwaysKeepCurrent+ ""String_Node_Str""+ Debug.getCallers(3));
  if (!isTransitionSet() || mNextAppTransition == TRANSIT_NONE) {
    setAppTransition(transit);
  }
 else   if (!alwaysKeepCurrent) {
    if (transit == TRANSIT_TASK_OPEN && isTransitionEqual(TRANSIT_TASK_CLOSE)) {
      setAppTransition(transit);
    }
 else     if (transit == TRANSIT_ACTIVITY_OPEN && isTransitionEqual(TRANSIT_ACTIVITY_CLOSE)) {
      setAppTransition(transit);
    }
  }
  if (transit != TRANSIT_DOCK_TASK_FROM_RECENTS && mNextAppTransition == TRANSIT_DOCK_TASK_FROM_RECENTS) {
    setAppTransition(transit);
  }
  boolean prepared=prepare();
  if (isTransitionSet()) {
    mService.mH.removeMessages(H.APP_TRANSITION_TIMEOUT);
    mService.mH.sendEmptyMessageDelayed(H.APP_TRANSITION_TIMEOUT,APP_TRANSITION_TIMEOUT_MS);
  }
  return prepared;
}",0.9359783588818756
192023,"final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle resultExtras,String[] requiredPermissions,int appOp,Bundle bOptions,boolean ordered,boolean sticky,int callingPid,int callingUid,int userId){
  intent=new Intent(intent);
  intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
  if (!mProcessesReady && (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) {
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
  }
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG_BROADCAST,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered+ ""String_Node_Str""+ userId);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  userId=mUserController.handleIncomingUser(callingPid,callingUid,userId,true,ALLOW_NON_FULL,""String_Node_Str"",callerPackage);
  if (userId != UserHandle.USER_ALL && !mUserController.isUserRunningLocked(userId,0)) {
    if ((callingUid != Process.SYSTEM_UID || (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) && !Intent.ACTION_SHUTDOWN.equals(intent.getAction())) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
      return ActivityManager.BROADCAST_FAILED_USER_STOPPED;
    }
  }
  BroadcastOptions brOptions=null;
  if (bOptions != null) {
    brOptions=new BroadcastOptions(bOptions);
    if (brOptions.getTemporaryAppWhitelistDuration() > 0) {
      if (checkComponentPermission(android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST,Binder.getCallingPid(),Binder.getCallingUid(),-1,true) != PackageManager.PERMISSION_GRANTED) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
    }
  }
  final String action=intent.getAction();
  final boolean isProtectedBroadcast;
  try {
    isProtectedBroadcast=AppGlobals.getPackageManager().isProtectedBroadcast(action);
  }
 catch (  RemoteException e) {
    Slog.w(TAG,""String_Node_Str"",e);
    return ActivityManager.BROADCAST_SUCCESS;
  }
  final boolean isCallerSystem;
switch (UserHandle.getAppId(callingUid)) {
case Process.ROOT_UID:
case Process.SYSTEM_UID:
case Process.PHONE_UID:
case Process.BLUETOOTH_UID:
case Process.NFC_UID:
    isCallerSystem=true;
  break;
default :
isCallerSystem=(callerApp != null) && callerApp.persistent;
break;
}
if (isCallerSystem) {
if (isProtectedBroadcast || Intent.ACTION_CLOSE_SYSTEM_DIALOGS.equals(action) || Intent.ACTION_MEDIA_SCANNER_SCAN_FILE.equals(action)|| Intent.ACTION_GET_PERMISSIONS_COUNT.equals(action)|| Intent.ACTION_GET_PERMISSIONS_PACKAGES.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)|| LocationManager.HIGH_POWER_REQUEST_CHANGE_ACTION.equals(action)) {
}
 else {
Log.wtf(TAG,""String_Node_Str"" + action + ""String_Node_Str"",new Throwable());
}
}
 else {
if (isProtectedBroadcast) {
String msg=""String_Node_Str"" + action + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action) || AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)) {
if (callerPackage == null) {
String msg=""String_Node_Str"" + action + ""String_Node_Str"";
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (intent.getComponent() != null) {
if (!intent.getComponent().getPackageName().equals(callerPackage)) {
  String msg=""String_Node_Str"" + action + ""String_Node_Str""+ intent.getComponent().getPackageName()+ ""String_Node_Str""+ callerPackage;
  Slog.w(TAG,msg);
  throw new SecurityException(msg);
}
}
 else {
intent.setPackage(callerPackage);
}
}
}
if (action != null) {
switch (action) {
case Intent.ACTION_UID_REMOVED:
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1,true) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
switch (action) {
case Intent.ACTION_UID_REMOVED:
final Bundle intentExtras=intent.getExtras();
final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
if (uid >= 0) {
mBatteryStatsService.removeUid(uid);
mAppOpsService.uidRemoved(uid);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
if (list != null && list.length > 0) {
for (int i=0; i < list.length; i++) {
forceStopPackageLocked(list[i],-1,false,true,true,false,false,userId,""String_Node_Str"");
}
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE,list,userId);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
break;
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
boolean removed=Intent.ACTION_PACKAGE_REMOVED.equals(action);
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
final boolean killProcess=!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false);
final boolean fullUninstall=removed && !replacing;
if (killProcess) {
forceStopPackageLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),false,true,true,false,fullUninstall,userId,removed ? ""String_Node_Str"" : ""String_Node_Str"");
}
if (removed) {
final int cmd=killProcess ? IApplicationThread.PACKAGE_REMOVED : IApplicationThread.PACKAGE_REMOVED_DONT_KILL;
sendPackageBroadcastLocked(cmd,new String[]{ssp},userId);
if (fullUninstall) {
mAppOpsService.packageRemoved(intent.getIntExtra(Intent.EXTRA_UID,-1),ssp);
removeUriPermissionsForPackageLocked(ssp,userId,true);
removeTasksByPackageNameLocked(ssp,userId);
mBatteryStatsService.notePackageUninstalled(ssp);
}
}
 else {
cleanupDisabledPackageComponentsLocked(ssp,userId,killProcess,intent.getStringArrayExtra(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST));
}
}
break;
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
final boolean suspended=Intent.ACTION_PACKAGES_SUSPENDED.equals(intent.getAction());
final String[] packageNames=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
final int userHandle=intent.getIntExtra(Intent.EXTRA_USER_HANDLE,UserHandle.USER_NULL);
synchronized (ActivityManagerService.this) {
mRecentTasks.onPackagesSuspendedChanged(packageNames,suspended,userHandle);
}
break;
}
break;
case Intent.ACTION_PACKAGE_REPLACED:
{
final Uri data=intent.getData();
final String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final ApplicationInfo aInfo=getPackageManagerInternalLocked().getApplicationInfo(ssp,userId);
mStackSupervisor.updateActivityApplicationInfoLocked(aInfo);
sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REPLACED,new String[]{ssp},userId);
}
break;
}
case Intent.ACTION_PACKAGE_ADDED:
{
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
mCompatModePackages.handlePackageAddedLocked(ssp,replacing);
try {
ApplicationInfo ai=AppGlobals.getPackageManager().getApplicationInfo(ssp,0,0);
mBatteryStatsService.notePackageInstalled(ssp,ai != null ? ai.versionCode : 0);
}
 catch (RemoteException e) {
}
}
break;
}
case Intent.ACTION_TIMEZONE_CHANGED:
mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
break;
case Intent.ACTION_TIME_CHANGED:
final int is24Hour=intent.getBooleanExtra(Intent.EXTRA_TIME_PREF_24_HOUR_FORMAT,false) ? 1 : 0;
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_TIME,is24Hour,0));
BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
stats.noteCurrentTimeChangedLocked();
}
break;
case Intent.ACTION_CLEAR_DNS_CACHE:
mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);
break;
case Proxy.PROXY_CHANGE_ACTION:
ProxyInfo proxy=intent.getParcelableExtra(Proxy.EXTRA_PROXY_INFO);
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG,proxy));
break;
case android.hardware.Camera.ACTION_NEW_PICTURE:
case android.hardware.Camera.ACTION_NEW_VIDEO:
Slog.w(TAG,action + ""String_Node_Str"" + UserHandle.formatUid(callingUid));
return ActivityManager.BROADCAST_SUCCESS;
}
}
if (sticky) {
if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
if (requiredPermissions != null && requiredPermissions.length > 0) {
Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ Arrays.toString(requiredPermissions));
return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;
}
if (intent.getComponent() != null) {
throw new SecurityException(""String_Node_Str"");
}
if (userId != UserHandle.USER_ALL) {
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(UserHandle.USER_ALL);
if (stickies != null) {
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list != null) {
int N=list.size();
int i;
for (i=0; i < N; i++) {
if (intent.filterEquals(list.get(i))) {
throw new IllegalArgumentException(""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
}
}
}
}
}
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(userId);
if (stickies == null) {
stickies=new ArrayMap<>();
mStickyBroadcasts.put(userId,stickies);
}
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list == null) {
list=new ArrayList<>();
stickies.put(intent.getAction(),list);
}
final int stickiesCount=list.size();
int i;
for (i=0; i < stickiesCount; i++) {
if (intent.filterEquals(list.get(i))) {
list.set(i,new Intent(intent));
break;
}
}
if (i >= stickiesCount) {
list.add(new Intent(intent));
}
}
int[] users;
if (userId == UserHandle.USER_ALL) {
users=mUserController.getStartedUserArrayLocked();
}
 else {
users=new int[]{userId};
}
List receivers=null;
List<BroadcastFilter> registeredReceivers=null;
if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
receivers=collectReceiverComponents(intent,resolvedType,callingUid,users);
}
if (intent.getComponent() == null) {
if (userId == UserHandle.USER_ALL && callingUid == Process.SHELL_UID) {
for (int i=0; i < users.length; i++) {
if (mUserController.hasUserRestriction(UserManager.DISALLOW_DEBUGGING_FEATURES,users[i])) {
continue;
}
List<BroadcastFilter> registeredReceiversForUser=mReceiverResolver.queryIntent(intent,resolvedType,false,users[i]);
if (registeredReceivers == null) {
registeredReceivers=registeredReceiversForUser;
}
 else if (registeredReceiversForUser != null) {
registeredReceivers.addAll(registeredReceiversForUser);
}
}
}
 else {
registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false,userId);
}
}
final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
if (!ordered && NR > 0) {
final BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,registeredReceivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r);
final boolean replaced=replacePending && queue.replaceParallelBroadcastLocked(r);
if (!replaced) {
queue.enqueueParallelBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
registeredReceivers=null;
NR=0;
}
int ir=0;
if (receivers != null) {
String skipPackages[]=null;
if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
Uri data=intent.getData();
if (data != null) {
String pkgName=data.getSchemeSpecificPart();
if (pkgName != null) {
skipPackages=new String[]{pkgName};
}
}
}
 else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
}
if (skipPackages != null && (skipPackages.length > 0)) {
for (String skipPackage : skipPackages) {
if (skipPackage != null) {
int NT=receivers.size();
for (int it=0; it < NT; it++) {
ResolveInfo curt=(ResolveInfo)receivers.get(it);
if (curt.activityInfo.packageName.equals(skipPackage)) {
receivers.remove(it);
it--;
NT--;
}
}
}
}
}
int NT=receivers != null ? receivers.size() : 0;
int it=0;
ResolveInfo curt=null;
BroadcastFilter curr=null;
while (it < NT && ir < NR) {
if (curt == null) {
curt=(ResolveInfo)receivers.get(it);
}
if (curr == null) {
curr=registeredReceivers.get(ir);
}
if (curr.getPriority() >= curt.priority) {
receivers.add(it,curr);
ir++;
curr=null;
it++;
NT++;
}
 else {
it++;
curt=null;
}
}
}
while (ir < NR) {
if (receivers == null) {
receivers=new ArrayList();
}
receivers.add(registeredReceivers.get(ir));
ir++;
}
if ((receivers != null && receivers.size() > 0) || resultTo != null) {
BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,receivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r + ""String_Node_Str""+ queue.mOrderedBroadcasts.size());
if (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,""String_Node_Str"" + r.intent.getAction());
boolean replaced=replacePending && queue.replaceOrderedBroadcastLocked(r);
if (!replaced) {
queue.enqueueOrderedBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
}
return ActivityManager.BROADCAST_SUCCESS;
}","final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle resultExtras,String[] requiredPermissions,int appOp,Bundle bOptions,boolean ordered,boolean sticky,int callingPid,int callingUid,int userId){
  intent=new Intent(intent);
  intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
  if (!mProcessesReady && (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) {
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
  }
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG_BROADCAST,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered+ ""String_Node_Str""+ userId);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  userId=mUserController.handleIncomingUser(callingPid,callingUid,userId,true,ALLOW_NON_FULL,""String_Node_Str"",callerPackage);
  if (userId != UserHandle.USER_ALL && !mUserController.isUserRunningLocked(userId,0)) {
    if ((callingUid != Process.SYSTEM_UID || (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) && !Intent.ACTION_SHUTDOWN.equals(intent.getAction())) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
      return ActivityManager.BROADCAST_FAILED_USER_STOPPED;
    }
  }
  BroadcastOptions brOptions=null;
  if (bOptions != null) {
    brOptions=new BroadcastOptions(bOptions);
    if (brOptions.getTemporaryAppWhitelistDuration() > 0) {
      if (checkComponentPermission(android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST,Binder.getCallingPid(),Binder.getCallingUid(),-1,true) != PackageManager.PERMISSION_GRANTED) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
    }
  }
  final String action=intent.getAction();
  final boolean isProtectedBroadcast;
  try {
    isProtectedBroadcast=AppGlobals.getPackageManager().isProtectedBroadcast(action);
  }
 catch (  RemoteException e) {
    Slog.w(TAG,""String_Node_Str"",e);
    return ActivityManager.BROADCAST_SUCCESS;
  }
  final boolean isCallerSystem;
switch (UserHandle.getAppId(callingUid)) {
case Process.ROOT_UID:
case Process.SYSTEM_UID:
case Process.PHONE_UID:
case Process.BLUETOOTH_UID:
case Process.NFC_UID:
    isCallerSystem=true;
  break;
default :
isCallerSystem=(callerApp != null) && callerApp.persistent;
break;
}
if (isCallerSystem) {
if (isProtectedBroadcast || Intent.ACTION_CLOSE_SYSTEM_DIALOGS.equals(action) || Intent.ACTION_MEDIA_SCANNER_SCAN_FILE.equals(action)|| Intent.ACTION_GET_PERMISSIONS_COUNT.equals(action)|| Intent.ACTION_GET_PERMISSIONS_PACKAGES.equals(action)|| Intent.ACTION_SHOW_KEYBOARD_SHORTCUTS.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)|| LocationManager.HIGH_POWER_REQUEST_CHANGE_ACTION.equals(action)) {
}
 else {
Log.wtf(TAG,""String_Node_Str"" + action + ""String_Node_Str"",new Throwable());
}
}
 else {
if (isProtectedBroadcast) {
String msg=""String_Node_Str"" + action + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action) || AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)) {
if (callerPackage == null) {
String msg=""String_Node_Str"" + action + ""String_Node_Str"";
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (intent.getComponent() != null) {
if (!intent.getComponent().getPackageName().equals(callerPackage)) {
  String msg=""String_Node_Str"" + action + ""String_Node_Str""+ intent.getComponent().getPackageName()+ ""String_Node_Str""+ callerPackage;
  Slog.w(TAG,msg);
  throw new SecurityException(msg);
}
}
 else {
intent.setPackage(callerPackage);
}
}
}
if (action != null) {
switch (action) {
case Intent.ACTION_UID_REMOVED:
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1,true) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
switch (action) {
case Intent.ACTION_UID_REMOVED:
final Bundle intentExtras=intent.getExtras();
final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
if (uid >= 0) {
mBatteryStatsService.removeUid(uid);
mAppOpsService.uidRemoved(uid);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
if (list != null && list.length > 0) {
for (int i=0; i < list.length; i++) {
forceStopPackageLocked(list[i],-1,false,true,true,false,false,userId,""String_Node_Str"");
}
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE,list,userId);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
break;
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
boolean removed=Intent.ACTION_PACKAGE_REMOVED.equals(action);
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
final boolean killProcess=!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false);
final boolean fullUninstall=removed && !replacing;
if (killProcess) {
forceStopPackageLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),false,true,true,false,fullUninstall,userId,removed ? ""String_Node_Str"" : ""String_Node_Str"");
}
if (removed) {
final int cmd=killProcess ? IApplicationThread.PACKAGE_REMOVED : IApplicationThread.PACKAGE_REMOVED_DONT_KILL;
sendPackageBroadcastLocked(cmd,new String[]{ssp},userId);
if (fullUninstall) {
mAppOpsService.packageRemoved(intent.getIntExtra(Intent.EXTRA_UID,-1),ssp);
removeUriPermissionsForPackageLocked(ssp,userId,true);
removeTasksByPackageNameLocked(ssp,userId);
mBatteryStatsService.notePackageUninstalled(ssp);
}
}
 else {
cleanupDisabledPackageComponentsLocked(ssp,userId,killProcess,intent.getStringArrayExtra(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST));
}
}
break;
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
final boolean suspended=Intent.ACTION_PACKAGES_SUSPENDED.equals(intent.getAction());
final String[] packageNames=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
final int userHandle=intent.getIntExtra(Intent.EXTRA_USER_HANDLE,UserHandle.USER_NULL);
synchronized (ActivityManagerService.this) {
mRecentTasks.onPackagesSuspendedChanged(packageNames,suspended,userHandle);
}
break;
}
break;
case Intent.ACTION_PACKAGE_REPLACED:
{
final Uri data=intent.getData();
final String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final ApplicationInfo aInfo=getPackageManagerInternalLocked().getApplicationInfo(ssp,userId);
mStackSupervisor.updateActivityApplicationInfoLocked(aInfo);
sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REPLACED,new String[]{ssp},userId);
}
break;
}
case Intent.ACTION_PACKAGE_ADDED:
{
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
mCompatModePackages.handlePackageAddedLocked(ssp,replacing);
try {
ApplicationInfo ai=AppGlobals.getPackageManager().getApplicationInfo(ssp,0,0);
mBatteryStatsService.notePackageInstalled(ssp,ai != null ? ai.versionCode : 0);
}
 catch (RemoteException e) {
}
}
break;
}
case Intent.ACTION_TIMEZONE_CHANGED:
mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
break;
case Intent.ACTION_TIME_CHANGED:
final int is24Hour=intent.getBooleanExtra(Intent.EXTRA_TIME_PREF_24_HOUR_FORMAT,false) ? 1 : 0;
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_TIME,is24Hour,0));
BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
stats.noteCurrentTimeChangedLocked();
}
break;
case Intent.ACTION_CLEAR_DNS_CACHE:
mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);
break;
case Proxy.PROXY_CHANGE_ACTION:
ProxyInfo proxy=intent.getParcelableExtra(Proxy.EXTRA_PROXY_INFO);
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG,proxy));
break;
case android.hardware.Camera.ACTION_NEW_PICTURE:
case android.hardware.Camera.ACTION_NEW_VIDEO:
Slog.w(TAG,action + ""String_Node_Str"" + UserHandle.formatUid(callingUid));
return ActivityManager.BROADCAST_SUCCESS;
}
}
if (sticky) {
if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
if (requiredPermissions != null && requiredPermissions.length > 0) {
Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ Arrays.toString(requiredPermissions));
return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;
}
if (intent.getComponent() != null) {
throw new SecurityException(""String_Node_Str"");
}
if (userId != UserHandle.USER_ALL) {
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(UserHandle.USER_ALL);
if (stickies != null) {
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list != null) {
int N=list.size();
int i;
for (i=0; i < N; i++) {
if (intent.filterEquals(list.get(i))) {
throw new IllegalArgumentException(""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
}
}
}
}
}
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(userId);
if (stickies == null) {
stickies=new ArrayMap<>();
mStickyBroadcasts.put(userId,stickies);
}
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list == null) {
list=new ArrayList<>();
stickies.put(intent.getAction(),list);
}
final int stickiesCount=list.size();
int i;
for (i=0; i < stickiesCount; i++) {
if (intent.filterEquals(list.get(i))) {
list.set(i,new Intent(intent));
break;
}
}
if (i >= stickiesCount) {
list.add(new Intent(intent));
}
}
int[] users;
if (userId == UserHandle.USER_ALL) {
users=mUserController.getStartedUserArrayLocked();
}
 else {
users=new int[]{userId};
}
List receivers=null;
List<BroadcastFilter> registeredReceivers=null;
if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
receivers=collectReceiverComponents(intent,resolvedType,callingUid,users);
}
if (intent.getComponent() == null) {
if (userId == UserHandle.USER_ALL && callingUid == Process.SHELL_UID) {
for (int i=0; i < users.length; i++) {
if (mUserController.hasUserRestriction(UserManager.DISALLOW_DEBUGGING_FEATURES,users[i])) {
continue;
}
List<BroadcastFilter> registeredReceiversForUser=mReceiverResolver.queryIntent(intent,resolvedType,false,users[i]);
if (registeredReceivers == null) {
registeredReceivers=registeredReceiversForUser;
}
 else if (registeredReceiversForUser != null) {
registeredReceivers.addAll(registeredReceiversForUser);
}
}
}
 else {
registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false,userId);
}
}
final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
if (!ordered && NR > 0) {
final BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,registeredReceivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r);
final boolean replaced=replacePending && queue.replaceParallelBroadcastLocked(r);
if (!replaced) {
queue.enqueueParallelBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
registeredReceivers=null;
NR=0;
}
int ir=0;
if (receivers != null) {
String skipPackages[]=null;
if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
Uri data=intent.getData();
if (data != null) {
String pkgName=data.getSchemeSpecificPart();
if (pkgName != null) {
skipPackages=new String[]{pkgName};
}
}
}
 else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
}
if (skipPackages != null && (skipPackages.length > 0)) {
for (String skipPackage : skipPackages) {
if (skipPackage != null) {
int NT=receivers.size();
for (int it=0; it < NT; it++) {
ResolveInfo curt=(ResolveInfo)receivers.get(it);
if (curt.activityInfo.packageName.equals(skipPackage)) {
receivers.remove(it);
it--;
NT--;
}
}
}
}
}
int NT=receivers != null ? receivers.size() : 0;
int it=0;
ResolveInfo curt=null;
BroadcastFilter curr=null;
while (it < NT && ir < NR) {
if (curt == null) {
curt=(ResolveInfo)receivers.get(it);
}
if (curr == null) {
curr=registeredReceivers.get(ir);
}
if (curr.getPriority() >= curt.priority) {
receivers.add(it,curr);
ir++;
curr=null;
it++;
NT++;
}
 else {
it++;
curt=null;
}
}
}
while (ir < NR) {
if (receivers == null) {
receivers=new ArrayList();
}
receivers.add(registeredReceivers.get(ir));
ir++;
}
if ((receivers != null && receivers.size() > 0) || resultTo != null) {
BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,receivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r + ""String_Node_Str""+ queue.mOrderedBroadcasts.size());
if (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,""String_Node_Str"" + r.intent.getAction());
boolean replaced=replacePending && queue.replaceOrderedBroadcastLocked(r);
if (!replaced) {
queue.enqueueOrderedBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
}
return ActivityManager.BROADCAST_SUCCESS;
}",0.9981567746908409
192024,"final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle resultExtras,String[] requiredPermissions,int appOp,Bundle bOptions,boolean ordered,boolean sticky,int callingPid,int callingUid,int userId){
  intent=new Intent(intent);
  intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
  if (!mProcessesReady && (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) {
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
  }
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG_BROADCAST,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered+ ""String_Node_Str""+ userId);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  userId=mUserController.handleIncomingUser(callingPid,callingUid,userId,true,ALLOW_NON_FULL,""String_Node_Str"",callerPackage);
  if (userId != UserHandle.USER_ALL && !mUserController.isUserRunningLocked(userId,0)) {
    if ((callingUid != Process.SYSTEM_UID || (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) && !Intent.ACTION_SHUTDOWN.equals(intent.getAction())) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
      return ActivityManager.BROADCAST_FAILED_USER_STOPPED;
    }
  }
  BroadcastOptions brOptions=null;
  if (bOptions != null) {
    brOptions=new BroadcastOptions(bOptions);
    if (brOptions.getTemporaryAppWhitelistDuration() > 0) {
      if (checkComponentPermission(android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST,Binder.getCallingPid(),Binder.getCallingUid(),-1,true) != PackageManager.PERMISSION_GRANTED) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
    }
  }
  final String action=intent.getAction();
  final boolean isProtectedBroadcast;
  try {
    isProtectedBroadcast=AppGlobals.getPackageManager().isProtectedBroadcast(action);
  }
 catch (  RemoteException e) {
    Slog.w(TAG,""String_Node_Str"",e);
    return ActivityManager.BROADCAST_SUCCESS;
  }
  final boolean isCallerSystem;
switch (UserHandle.getAppId(callingUid)) {
case Process.ROOT_UID:
case Process.SYSTEM_UID:
case Process.PHONE_UID:
case Process.BLUETOOTH_UID:
case Process.NFC_UID:
    isCallerSystem=true;
  break;
default :
isCallerSystem=(callerApp != null) && callerApp.persistent;
break;
}
if (isCallerSystem) {
if (isProtectedBroadcast || Intent.ACTION_CLOSE_SYSTEM_DIALOGS.equals(action) || Intent.ACTION_MEDIA_SCANNER_SCAN_FILE.equals(action)|| Intent.ACTION_GET_PERMISSIONS_COUNT.equals(action)|| Intent.ACTION_GET_PERMISSIONS_PACKAGES.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)|| LocationManager.HIGH_POWER_REQUEST_CHANGE_ACTION.equals(action)) {
}
 else {
Log.wtf(TAG,""String_Node_Str"" + action + ""String_Node_Str"",new Throwable());
}
}
 else {
if (isProtectedBroadcast) {
String msg=""String_Node_Str"" + action + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action) || AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)) {
if (callerPackage == null) {
String msg=""String_Node_Str"" + action + ""String_Node_Str"";
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (intent.getComponent() != null) {
if (!intent.getComponent().getPackageName().equals(callerPackage)) {
  String msg=""String_Node_Str"" + action + ""String_Node_Str""+ intent.getComponent().getPackageName()+ ""String_Node_Str""+ callerPackage;
  Slog.w(TAG,msg);
  throw new SecurityException(msg);
}
}
 else {
intent.setPackage(callerPackage);
}
}
}
if (action != null) {
switch (action) {
case Intent.ACTION_UID_REMOVED:
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1,true) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
switch (action) {
case Intent.ACTION_UID_REMOVED:
final Bundle intentExtras=intent.getExtras();
final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
if (uid >= 0) {
mBatteryStatsService.removeUid(uid);
mAppOpsService.uidRemoved(uid);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
if (list != null && list.length > 0) {
for (int i=0; i < list.length; i++) {
forceStopPackageLocked(list[i],-1,false,true,true,false,false,userId,""String_Node_Str"");
}
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE,list,userId);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
break;
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
boolean removed=Intent.ACTION_PACKAGE_REMOVED.equals(action);
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
final boolean killProcess=!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false);
final boolean fullUninstall=removed && !replacing;
if (killProcess) {
forceStopPackageLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),false,true,true,false,fullUninstall,userId,removed ? ""String_Node_Str"" : ""String_Node_Str"");
}
if (removed) {
final int cmd=killProcess ? IApplicationThread.PACKAGE_REMOVED : IApplicationThread.PACKAGE_REMOVED_DONT_KILL;
sendPackageBroadcastLocked(cmd,new String[]{ssp},userId);
if (fullUninstall) {
mAppOpsService.packageRemoved(intent.getIntExtra(Intent.EXTRA_UID,-1),ssp);
removeUriPermissionsForPackageLocked(ssp,userId,true);
removeTasksByPackageNameLocked(ssp,userId);
mBatteryStatsService.notePackageUninstalled(ssp);
}
}
 else {
cleanupDisabledPackageComponentsLocked(ssp,userId,killProcess,intent.getStringArrayExtra(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST));
}
}
break;
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
final boolean suspended=Intent.ACTION_PACKAGES_SUSPENDED.equals(intent.getAction());
final String[] packageNames=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
final int userHandle=intent.getIntExtra(Intent.EXTRA_USER_HANDLE,UserHandle.USER_NULL);
synchronized (ActivityManagerService.this) {
mRecentTasks.onPackagesSuspendedChanged(packageNames,suspended,userHandle);
}
break;
}
break;
case Intent.ACTION_PACKAGE_REPLACED:
{
final Uri data=intent.getData();
final String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final ApplicationInfo aInfo=getPackageManagerInternalLocked().getApplicationInfo(ssp,userId);
mStackSupervisor.updateActivityApplicationInfoLocked(aInfo);
sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REPLACED,new String[]{ssp},userId);
}
break;
}
case Intent.ACTION_PACKAGE_ADDED:
{
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
mCompatModePackages.handlePackageAddedLocked(ssp,replacing);
try {
ApplicationInfo ai=AppGlobals.getPackageManager().getApplicationInfo(ssp,0,0);
mBatteryStatsService.notePackageInstalled(ssp,ai != null ? ai.versionCode : 0);
}
 catch (RemoteException e) {
}
}
break;
}
case Intent.ACTION_TIMEZONE_CHANGED:
mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
break;
case Intent.ACTION_TIME_CHANGED:
final int is24Hour=intent.getBooleanExtra(Intent.EXTRA_TIME_PREF_24_HOUR_FORMAT,false) ? 1 : 0;
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_TIME,is24Hour,0));
BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
stats.noteCurrentTimeChangedLocked();
}
break;
case Intent.ACTION_CLEAR_DNS_CACHE:
mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);
break;
case Proxy.PROXY_CHANGE_ACTION:
ProxyInfo proxy=intent.getParcelableExtra(Proxy.EXTRA_PROXY_INFO);
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG,proxy));
break;
case android.hardware.Camera.ACTION_NEW_PICTURE:
case android.hardware.Camera.ACTION_NEW_VIDEO:
Slog.w(TAG,action + ""String_Node_Str"" + UserHandle.formatUid(callingUid));
return ActivityManager.BROADCAST_SUCCESS;
}
}
if (sticky) {
if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
if (requiredPermissions != null && requiredPermissions.length > 0) {
Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ Arrays.toString(requiredPermissions));
return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;
}
if (intent.getComponent() != null) {
throw new SecurityException(""String_Node_Str"");
}
if (userId != UserHandle.USER_ALL) {
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(UserHandle.USER_ALL);
if (stickies != null) {
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list != null) {
int N=list.size();
int i;
for (i=0; i < N; i++) {
if (intent.filterEquals(list.get(i))) {
throw new IllegalArgumentException(""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
}
}
}
}
}
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(userId);
if (stickies == null) {
stickies=new ArrayMap<>();
mStickyBroadcasts.put(userId,stickies);
}
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list == null) {
list=new ArrayList<>();
stickies.put(intent.getAction(),list);
}
final int stickiesCount=list.size();
int i;
for (i=0; i < stickiesCount; i++) {
if (intent.filterEquals(list.get(i))) {
list.set(i,new Intent(intent));
break;
}
}
if (i >= stickiesCount) {
list.add(new Intent(intent));
}
}
int[] users;
if (userId == UserHandle.USER_ALL) {
users=mUserController.getStartedUserArrayLocked();
}
 else {
users=new int[]{userId};
}
List receivers=null;
List<BroadcastFilter> registeredReceivers=null;
if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
receivers=collectReceiverComponents(intent,resolvedType,callingUid,users);
}
if (intent.getComponent() == null) {
if (userId == UserHandle.USER_ALL && callingUid == Process.SHELL_UID) {
for (int i=0; i < users.length; i++) {
if (mUserController.hasUserRestriction(UserManager.DISALLOW_DEBUGGING_FEATURES,users[i])) {
continue;
}
List<BroadcastFilter> registeredReceiversForUser=mReceiverResolver.queryIntent(intent,resolvedType,false,users[i]);
if (registeredReceivers == null) {
registeredReceivers=registeredReceiversForUser;
}
 else if (registeredReceiversForUser != null) {
registeredReceivers.addAll(registeredReceiversForUser);
}
}
}
 else {
registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false,userId);
}
}
final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
if (!ordered && NR > 0) {
final BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,registeredReceivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r);
final boolean replaced=replacePending && queue.replaceParallelBroadcastLocked(r);
if (!replaced) {
queue.enqueueParallelBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
registeredReceivers=null;
NR=0;
}
int ir=0;
if (receivers != null) {
String skipPackages[]=null;
if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
Uri data=intent.getData();
if (data != null) {
String pkgName=data.getSchemeSpecificPart();
if (pkgName != null) {
skipPackages=new String[]{pkgName};
}
}
}
 else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
}
if (skipPackages != null && (skipPackages.length > 0)) {
for (String skipPackage : skipPackages) {
if (skipPackage != null) {
int NT=receivers.size();
for (int it=0; it < NT; it++) {
ResolveInfo curt=(ResolveInfo)receivers.get(it);
if (curt.activityInfo.packageName.equals(skipPackage)) {
receivers.remove(it);
it--;
NT--;
}
}
}
}
}
int NT=receivers != null ? receivers.size() : 0;
int it=0;
ResolveInfo curt=null;
BroadcastFilter curr=null;
while (it < NT && ir < NR) {
if (curt == null) {
curt=(ResolveInfo)receivers.get(it);
}
if (curr == null) {
curr=registeredReceivers.get(ir);
}
if (curr.getPriority() >= curt.priority) {
receivers.add(it,curr);
ir++;
curr=null;
it++;
NT++;
}
 else {
it++;
curt=null;
}
}
}
while (ir < NR) {
if (receivers == null) {
receivers=new ArrayList();
}
receivers.add(registeredReceivers.get(ir));
ir++;
}
if ((receivers != null && receivers.size() > 0) || resultTo != null) {
BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,receivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r + ""String_Node_Str""+ queue.mOrderedBroadcasts.size());
if (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,""String_Node_Str"" + r.intent.getAction());
boolean replaced=replacePending && queue.replaceOrderedBroadcastLocked(r);
if (!replaced) {
queue.enqueueOrderedBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
}
return ActivityManager.BROADCAST_SUCCESS;
}","final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle resultExtras,String[] requiredPermissions,int appOp,Bundle bOptions,boolean ordered,boolean sticky,int callingPid,int callingUid,int userId){
  intent=new Intent(intent);
  intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
  if (!mProcessesReady && (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) {
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
  }
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG_BROADCAST,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered+ ""String_Node_Str""+ userId);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  userId=mUserController.handleIncomingUser(callingPid,callingUid,userId,true,ALLOW_NON_FULL,""String_Node_Str"",callerPackage);
  if (userId != UserHandle.USER_ALL && !mUserController.isUserRunningLocked(userId,0)) {
    if ((callingUid != Process.SYSTEM_UID || (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) && !Intent.ACTION_SHUTDOWN.equals(intent.getAction())) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
      return ActivityManager.BROADCAST_FAILED_USER_STOPPED;
    }
  }
  BroadcastOptions brOptions=null;
  if (bOptions != null) {
    brOptions=new BroadcastOptions(bOptions);
    if (brOptions.getTemporaryAppWhitelistDuration() > 0) {
      if (checkComponentPermission(android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST,Binder.getCallingPid(),Binder.getCallingUid(),-1,true) != PackageManager.PERMISSION_GRANTED) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
    }
  }
  final String action=intent.getAction();
  final boolean isProtectedBroadcast;
  try {
    isProtectedBroadcast=AppGlobals.getPackageManager().isProtectedBroadcast(action);
  }
 catch (  RemoteException e) {
    Slog.w(TAG,""String_Node_Str"",e);
    return ActivityManager.BROADCAST_SUCCESS;
  }
  final boolean isCallerSystem;
switch (UserHandle.getAppId(callingUid)) {
case Process.ROOT_UID:
case Process.SYSTEM_UID:
case Process.PHONE_UID:
case Process.BLUETOOTH_UID:
case Process.NFC_UID:
    isCallerSystem=true;
  break;
default :
isCallerSystem=(callerApp != null) && callerApp.persistent;
break;
}
if (isCallerSystem) {
if (isProtectedBroadcast || Intent.ACTION_CLOSE_SYSTEM_DIALOGS.equals(action) || Intent.ACTION_MEDIA_SCANNER_SCAN_FILE.equals(action)|| Intent.ACTION_GET_PERMISSIONS_COUNT.equals(action)|| Intent.ACTION_GET_PERMISSIONS_PACKAGES.equals(action)|| Intent.ACTION_SHOW_KEYBOARD_SHORTCUTS.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)|| LocationManager.HIGH_POWER_REQUEST_CHANGE_ACTION.equals(action)) {
}
 else {
Log.wtf(TAG,""String_Node_Str"" + action + ""String_Node_Str"",new Throwable());
}
}
 else {
if (isProtectedBroadcast) {
String msg=""String_Node_Str"" + action + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action) || AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)) {
if (callerPackage == null) {
String msg=""String_Node_Str"" + action + ""String_Node_Str"";
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (intent.getComponent() != null) {
if (!intent.getComponent().getPackageName().equals(callerPackage)) {
  String msg=""String_Node_Str"" + action + ""String_Node_Str""+ intent.getComponent().getPackageName()+ ""String_Node_Str""+ callerPackage;
  Slog.w(TAG,msg);
  throw new SecurityException(msg);
}
}
 else {
intent.setPackage(callerPackage);
}
}
}
if (action != null) {
switch (action) {
case Intent.ACTION_UID_REMOVED:
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1,true) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
switch (action) {
case Intent.ACTION_UID_REMOVED:
final Bundle intentExtras=intent.getExtras();
final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
if (uid >= 0) {
mBatteryStatsService.removeUid(uid);
mAppOpsService.uidRemoved(uid);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
if (list != null && list.length > 0) {
for (int i=0; i < list.length; i++) {
forceStopPackageLocked(list[i],-1,false,true,true,false,false,userId,""String_Node_Str"");
}
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE,list,userId);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
break;
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
boolean removed=Intent.ACTION_PACKAGE_REMOVED.equals(action);
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
final boolean killProcess=!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false);
final boolean fullUninstall=removed && !replacing;
if (killProcess) {
forceStopPackageLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),false,true,true,false,fullUninstall,userId,removed ? ""String_Node_Str"" : ""String_Node_Str"");
}
if (removed) {
final int cmd=killProcess ? IApplicationThread.PACKAGE_REMOVED : IApplicationThread.PACKAGE_REMOVED_DONT_KILL;
sendPackageBroadcastLocked(cmd,new String[]{ssp},userId);
if (fullUninstall) {
mAppOpsService.packageRemoved(intent.getIntExtra(Intent.EXTRA_UID,-1),ssp);
removeUriPermissionsForPackageLocked(ssp,userId,true);
removeTasksByPackageNameLocked(ssp,userId);
mBatteryStatsService.notePackageUninstalled(ssp);
}
}
 else {
cleanupDisabledPackageComponentsLocked(ssp,userId,killProcess,intent.getStringArrayExtra(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST));
}
}
break;
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
final boolean suspended=Intent.ACTION_PACKAGES_SUSPENDED.equals(intent.getAction());
final String[] packageNames=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
final int userHandle=intent.getIntExtra(Intent.EXTRA_USER_HANDLE,UserHandle.USER_NULL);
synchronized (ActivityManagerService.this) {
mRecentTasks.onPackagesSuspendedChanged(packageNames,suspended,userHandle);
}
break;
}
break;
case Intent.ACTION_PACKAGE_REPLACED:
{
final Uri data=intent.getData();
final String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final ApplicationInfo aInfo=getPackageManagerInternalLocked().getApplicationInfo(ssp,userId);
mStackSupervisor.updateActivityApplicationInfoLocked(aInfo);
sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REPLACED,new String[]{ssp},userId);
}
break;
}
case Intent.ACTION_PACKAGE_ADDED:
{
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
mCompatModePackages.handlePackageAddedLocked(ssp,replacing);
try {
ApplicationInfo ai=AppGlobals.getPackageManager().getApplicationInfo(ssp,0,0);
mBatteryStatsService.notePackageInstalled(ssp,ai != null ? ai.versionCode : 0);
}
 catch (RemoteException e) {
}
}
break;
}
case Intent.ACTION_TIMEZONE_CHANGED:
mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
break;
case Intent.ACTION_TIME_CHANGED:
final int is24Hour=intent.getBooleanExtra(Intent.EXTRA_TIME_PREF_24_HOUR_FORMAT,false) ? 1 : 0;
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_TIME,is24Hour,0));
BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
stats.noteCurrentTimeChangedLocked();
}
break;
case Intent.ACTION_CLEAR_DNS_CACHE:
mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);
break;
case Proxy.PROXY_CHANGE_ACTION:
ProxyInfo proxy=intent.getParcelableExtra(Proxy.EXTRA_PROXY_INFO);
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG,proxy));
break;
case android.hardware.Camera.ACTION_NEW_PICTURE:
case android.hardware.Camera.ACTION_NEW_VIDEO:
Slog.w(TAG,action + ""String_Node_Str"" + UserHandle.formatUid(callingUid));
return ActivityManager.BROADCAST_SUCCESS;
}
}
if (sticky) {
if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
if (requiredPermissions != null && requiredPermissions.length > 0) {
Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ Arrays.toString(requiredPermissions));
return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;
}
if (intent.getComponent() != null) {
throw new SecurityException(""String_Node_Str"");
}
if (userId != UserHandle.USER_ALL) {
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(UserHandle.USER_ALL);
if (stickies != null) {
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list != null) {
int N=list.size();
int i;
for (i=0; i < N; i++) {
if (intent.filterEquals(list.get(i))) {
throw new IllegalArgumentException(""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
}
}
}
}
}
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(userId);
if (stickies == null) {
stickies=new ArrayMap<>();
mStickyBroadcasts.put(userId,stickies);
}
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list == null) {
list=new ArrayList<>();
stickies.put(intent.getAction(),list);
}
final int stickiesCount=list.size();
int i;
for (i=0; i < stickiesCount; i++) {
if (intent.filterEquals(list.get(i))) {
list.set(i,new Intent(intent));
break;
}
}
if (i >= stickiesCount) {
list.add(new Intent(intent));
}
}
int[] users;
if (userId == UserHandle.USER_ALL) {
users=mUserController.getStartedUserArrayLocked();
}
 else {
users=new int[]{userId};
}
List receivers=null;
List<BroadcastFilter> registeredReceivers=null;
if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
receivers=collectReceiverComponents(intent,resolvedType,callingUid,users);
}
if (intent.getComponent() == null) {
if (userId == UserHandle.USER_ALL && callingUid == Process.SHELL_UID) {
for (int i=0; i < users.length; i++) {
if (mUserController.hasUserRestriction(UserManager.DISALLOW_DEBUGGING_FEATURES,users[i])) {
continue;
}
List<BroadcastFilter> registeredReceiversForUser=mReceiverResolver.queryIntent(intent,resolvedType,false,users[i]);
if (registeredReceivers == null) {
registeredReceivers=registeredReceiversForUser;
}
 else if (registeredReceiversForUser != null) {
registeredReceivers.addAll(registeredReceiversForUser);
}
}
}
 else {
registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false,userId);
}
}
final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
if (!ordered && NR > 0) {
final BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,registeredReceivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r);
final boolean replaced=replacePending && queue.replaceParallelBroadcastLocked(r);
if (!replaced) {
queue.enqueueParallelBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
registeredReceivers=null;
NR=0;
}
int ir=0;
if (receivers != null) {
String skipPackages[]=null;
if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
Uri data=intent.getData();
if (data != null) {
String pkgName=data.getSchemeSpecificPart();
if (pkgName != null) {
skipPackages=new String[]{pkgName};
}
}
}
 else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
}
if (skipPackages != null && (skipPackages.length > 0)) {
for (String skipPackage : skipPackages) {
if (skipPackage != null) {
int NT=receivers.size();
for (int it=0; it < NT; it++) {
ResolveInfo curt=(ResolveInfo)receivers.get(it);
if (curt.activityInfo.packageName.equals(skipPackage)) {
receivers.remove(it);
it--;
NT--;
}
}
}
}
}
int NT=receivers != null ? receivers.size() : 0;
int it=0;
ResolveInfo curt=null;
BroadcastFilter curr=null;
while (it < NT && ir < NR) {
if (curt == null) {
curt=(ResolveInfo)receivers.get(it);
}
if (curr == null) {
curr=registeredReceivers.get(ir);
}
if (curr.getPriority() >= curt.priority) {
receivers.add(it,curr);
ir++;
curr=null;
it++;
NT++;
}
 else {
it++;
curt=null;
}
}
}
while (ir < NR) {
if (receivers == null) {
receivers=new ArrayList();
}
receivers.add(registeredReceivers.get(ir));
ir++;
}
if ((receivers != null && receivers.size() > 0) || resultTo != null) {
BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,receivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r + ""String_Node_Str""+ queue.mOrderedBroadcasts.size());
if (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,""String_Node_Str"" + r.intent.getAction());
boolean replaced=replacePending && queue.replaceOrderedBroadcastLocked(r);
if (!replaced) {
queue.enqueueOrderedBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
}
return ActivityManager.BROADCAST_SUCCESS;
}",0.9981567746908409
192025,"final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle resultExtras,String[] requiredPermissions,int appOp,Bundle bOptions,boolean ordered,boolean sticky,int callingPid,int callingUid,int userId){
  intent=new Intent(intent);
  intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
  if (!mProcessesReady && (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) {
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
  }
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG_BROADCAST,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered+ ""String_Node_Str""+ userId);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  userId=mUserController.handleIncomingUser(callingPid,callingUid,userId,true,ALLOW_NON_FULL,""String_Node_Str"",callerPackage);
  if (userId != UserHandle.USER_ALL && !mUserController.isUserRunningLocked(userId,0)) {
    if ((callingUid != Process.SYSTEM_UID || (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) && !Intent.ACTION_SHUTDOWN.equals(intent.getAction())) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
      return ActivityManager.BROADCAST_FAILED_USER_STOPPED;
    }
  }
  BroadcastOptions brOptions=null;
  if (bOptions != null) {
    brOptions=new BroadcastOptions(bOptions);
    if (brOptions.getTemporaryAppWhitelistDuration() > 0) {
      if (checkComponentPermission(android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST,Binder.getCallingPid(),Binder.getCallingUid(),-1,true) != PackageManager.PERMISSION_GRANTED) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
    }
  }
  final String action=intent.getAction();
  final boolean isProtectedBroadcast;
  try {
    isProtectedBroadcast=AppGlobals.getPackageManager().isProtectedBroadcast(action);
  }
 catch (  RemoteException e) {
    Slog.w(TAG,""String_Node_Str"",e);
    return ActivityManager.BROADCAST_SUCCESS;
  }
  final boolean isCallerSystem;
switch (UserHandle.getAppId(callingUid)) {
case Process.ROOT_UID:
case Process.SYSTEM_UID:
case Process.PHONE_UID:
case Process.BLUETOOTH_UID:
case Process.NFC_UID:
    isCallerSystem=true;
  break;
default :
isCallerSystem=(callerApp != null) && callerApp.persistent;
break;
}
if (isCallerSystem) {
if (isProtectedBroadcast || Intent.ACTION_CLOSE_SYSTEM_DIALOGS.equals(action) || Intent.ACTION_MEDIA_SCANNER_SCAN_FILE.equals(action)|| Intent.ACTION_GET_PERMISSIONS_COUNT.equals(action)|| Intent.ACTION_GET_PERMISSIONS_PACKAGES.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)|| LocationManager.HIGH_POWER_REQUEST_CHANGE_ACTION.equals(action)) {
}
 else {
Log.wtf(TAG,""String_Node_Str"" + action + ""String_Node_Str"",new Throwable());
}
}
 else {
if (isProtectedBroadcast) {
String msg=""String_Node_Str"" + action + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action) || AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)) {
if (callerPackage == null) {
String msg=""String_Node_Str"" + action + ""String_Node_Str"";
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (intent.getComponent() != null) {
if (!intent.getComponent().getPackageName().equals(callerPackage)) {
  String msg=""String_Node_Str"" + action + ""String_Node_Str""+ intent.getComponent().getPackageName()+ ""String_Node_Str""+ callerPackage;
  Slog.w(TAG,msg);
  throw new SecurityException(msg);
}
}
 else {
intent.setPackage(callerPackage);
}
}
}
if (action != null) {
switch (action) {
case Intent.ACTION_UID_REMOVED:
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1,true) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
switch (action) {
case Intent.ACTION_UID_REMOVED:
final Bundle intentExtras=intent.getExtras();
final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
if (uid >= 0) {
mBatteryStatsService.removeUid(uid);
mAppOpsService.uidRemoved(uid);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
if (list != null && list.length > 0) {
for (int i=0; i < list.length; i++) {
forceStopPackageLocked(list[i],-1,false,true,true,false,false,userId,""String_Node_Str"");
}
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE,list,userId);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
break;
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
boolean removed=Intent.ACTION_PACKAGE_REMOVED.equals(action);
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
final boolean killProcess=!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false);
final boolean fullUninstall=removed && !replacing;
if (killProcess) {
forceStopPackageLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),false,true,true,false,fullUninstall,userId,removed ? ""String_Node_Str"" : ""String_Node_Str"");
}
if (removed) {
final int cmd=killProcess ? IApplicationThread.PACKAGE_REMOVED : IApplicationThread.PACKAGE_REMOVED_DONT_KILL;
sendPackageBroadcastLocked(cmd,new String[]{ssp},userId);
if (fullUninstall) {
mAppOpsService.packageRemoved(intent.getIntExtra(Intent.EXTRA_UID,-1),ssp);
removeUriPermissionsForPackageLocked(ssp,userId,true);
removeTasksByPackageNameLocked(ssp,userId);
mBatteryStatsService.notePackageUninstalled(ssp);
}
}
 else {
cleanupDisabledPackageComponentsLocked(ssp,userId,killProcess,intent.getStringArrayExtra(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST));
}
}
break;
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
final boolean suspended=Intent.ACTION_PACKAGES_SUSPENDED.equals(intent.getAction());
final String[] packageNames=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
final int userHandle=intent.getIntExtra(Intent.EXTRA_USER_HANDLE,UserHandle.USER_NULL);
synchronized (ActivityManagerService.this) {
mRecentTasks.onPackagesSuspendedChanged(packageNames,suspended,userHandle);
}
break;
}
break;
case Intent.ACTION_PACKAGE_REPLACED:
{
final Uri data=intent.getData();
final String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final ApplicationInfo aInfo=getPackageManagerInternalLocked().getApplicationInfo(ssp,userId);
mStackSupervisor.updateActivityApplicationInfoLocked(aInfo);
sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REPLACED,new String[]{ssp},userId);
}
break;
}
case Intent.ACTION_PACKAGE_ADDED:
{
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
mCompatModePackages.handlePackageAddedLocked(ssp,replacing);
try {
ApplicationInfo ai=AppGlobals.getPackageManager().getApplicationInfo(ssp,0,0);
mBatteryStatsService.notePackageInstalled(ssp,ai != null ? ai.versionCode : 0);
}
 catch (RemoteException e) {
}
}
break;
}
case Intent.ACTION_TIMEZONE_CHANGED:
mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
break;
case Intent.ACTION_TIME_CHANGED:
final int is24Hour=intent.getBooleanExtra(Intent.EXTRA_TIME_PREF_24_HOUR_FORMAT,false) ? 1 : 0;
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_TIME,is24Hour,0));
BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
stats.noteCurrentTimeChangedLocked();
}
break;
case Intent.ACTION_CLEAR_DNS_CACHE:
mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);
break;
case Proxy.PROXY_CHANGE_ACTION:
ProxyInfo proxy=intent.getParcelableExtra(Proxy.EXTRA_PROXY_INFO);
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG,proxy));
break;
case android.hardware.Camera.ACTION_NEW_PICTURE:
case android.hardware.Camera.ACTION_NEW_VIDEO:
Slog.w(TAG,action + ""String_Node_Str"" + UserHandle.formatUid(callingUid));
return ActivityManager.BROADCAST_SUCCESS;
}
}
if (sticky) {
if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
if (requiredPermissions != null && requiredPermissions.length > 0) {
Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ Arrays.toString(requiredPermissions));
return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;
}
if (intent.getComponent() != null) {
throw new SecurityException(""String_Node_Str"");
}
if (userId != UserHandle.USER_ALL) {
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(UserHandle.USER_ALL);
if (stickies != null) {
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list != null) {
int N=list.size();
int i;
for (i=0; i < N; i++) {
if (intent.filterEquals(list.get(i))) {
throw new IllegalArgumentException(""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
}
}
}
}
}
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(userId);
if (stickies == null) {
stickies=new ArrayMap<>();
mStickyBroadcasts.put(userId,stickies);
}
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list == null) {
list=new ArrayList<>();
stickies.put(intent.getAction(),list);
}
final int stickiesCount=list.size();
int i;
for (i=0; i < stickiesCount; i++) {
if (intent.filterEquals(list.get(i))) {
list.set(i,new Intent(intent));
break;
}
}
if (i >= stickiesCount) {
list.add(new Intent(intent));
}
}
int[] users;
if (userId == UserHandle.USER_ALL) {
users=mUserController.getStartedUserArrayLocked();
}
 else {
users=new int[]{userId};
}
List receivers=null;
List<BroadcastFilter> registeredReceivers=null;
if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
receivers=collectReceiverComponents(intent,resolvedType,callingUid,users);
}
if (intent.getComponent() == null) {
if (userId == UserHandle.USER_ALL && callingUid == Process.SHELL_UID) {
for (int i=0; i < users.length; i++) {
if (mUserController.hasUserRestriction(UserManager.DISALLOW_DEBUGGING_FEATURES,users[i])) {
continue;
}
List<BroadcastFilter> registeredReceiversForUser=mReceiverResolver.queryIntent(intent,resolvedType,false,users[i]);
if (registeredReceivers == null) {
registeredReceivers=registeredReceiversForUser;
}
 else if (registeredReceiversForUser != null) {
registeredReceivers.addAll(registeredReceiversForUser);
}
}
}
 else {
registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false,userId);
}
}
final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
if (!ordered && NR > 0) {
final BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,registeredReceivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r);
final boolean replaced=replacePending && queue.replaceParallelBroadcastLocked(r);
if (!replaced) {
queue.enqueueParallelBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
registeredReceivers=null;
NR=0;
}
int ir=0;
if (receivers != null) {
String skipPackages[]=null;
if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
Uri data=intent.getData();
if (data != null) {
String pkgName=data.getSchemeSpecificPart();
if (pkgName != null) {
skipPackages=new String[]{pkgName};
}
}
}
 else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
}
if (skipPackages != null && (skipPackages.length > 0)) {
for (String skipPackage : skipPackages) {
if (skipPackage != null) {
int NT=receivers.size();
for (int it=0; it < NT; it++) {
ResolveInfo curt=(ResolveInfo)receivers.get(it);
if (curt.activityInfo.packageName.equals(skipPackage)) {
receivers.remove(it);
it--;
NT--;
}
}
}
}
}
int NT=receivers != null ? receivers.size() : 0;
int it=0;
ResolveInfo curt=null;
BroadcastFilter curr=null;
while (it < NT && ir < NR) {
if (curt == null) {
curt=(ResolveInfo)receivers.get(it);
}
if (curr == null) {
curr=registeredReceivers.get(ir);
}
if (curr.getPriority() >= curt.priority) {
receivers.add(it,curr);
ir++;
curr=null;
it++;
NT++;
}
 else {
it++;
curt=null;
}
}
}
while (ir < NR) {
if (receivers == null) {
receivers=new ArrayList();
}
receivers.add(registeredReceivers.get(ir));
ir++;
}
if ((receivers != null && receivers.size() > 0) || resultTo != null) {
BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,receivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r + ""String_Node_Str""+ queue.mOrderedBroadcasts.size());
if (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,""String_Node_Str"" + r.intent.getAction());
boolean replaced=replacePending && queue.replaceOrderedBroadcastLocked(r);
if (!replaced) {
queue.enqueueOrderedBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
}
return ActivityManager.BROADCAST_SUCCESS;
}","final int broadcastIntentLocked(ProcessRecord callerApp,String callerPackage,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle resultExtras,String[] requiredPermissions,int appOp,Bundle bOptions,boolean ordered,boolean sticky,int callingPid,int callingUid,int userId){
  intent=new Intent(intent);
  intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
  if (!mProcessesReady && (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) {
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
  }
  if (DEBUG_BROADCAST_LIGHT)   Slog.v(TAG_BROADCAST,(sticky ? ""String_Node_Str"" : ""String_Node_Str"") + intent + ""String_Node_Str""+ ordered+ ""String_Node_Str""+ userId);
  if ((resultTo != null) && !ordered) {
    Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str"");
  }
  userId=mUserController.handleIncomingUser(callingPid,callingUid,userId,true,ALLOW_NON_FULL,""String_Node_Str"",callerPackage);
  if (userId != UserHandle.USER_ALL && !mUserController.isUserRunningLocked(userId,0)) {
    if ((callingUid != Process.SYSTEM_UID || (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) && !Intent.ACTION_SHUTDOWN.equals(intent.getAction())) {
      Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
      return ActivityManager.BROADCAST_FAILED_USER_STOPPED;
    }
  }
  BroadcastOptions brOptions=null;
  if (bOptions != null) {
    brOptions=new BroadcastOptions(bOptions);
    if (brOptions.getTemporaryAppWhitelistDuration() > 0) {
      if (checkComponentPermission(android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST,Binder.getCallingPid(),Binder.getCallingUid(),-1,true) != PackageManager.PERMISSION_GRANTED) {
        String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST;
        Slog.w(TAG,msg);
        throw new SecurityException(msg);
      }
    }
  }
  final String action=intent.getAction();
  final boolean isProtectedBroadcast;
  try {
    isProtectedBroadcast=AppGlobals.getPackageManager().isProtectedBroadcast(action);
  }
 catch (  RemoteException e) {
    Slog.w(TAG,""String_Node_Str"",e);
    return ActivityManager.BROADCAST_SUCCESS;
  }
  final boolean isCallerSystem;
switch (UserHandle.getAppId(callingUid)) {
case Process.ROOT_UID:
case Process.SYSTEM_UID:
case Process.PHONE_UID:
case Process.BLUETOOTH_UID:
case Process.NFC_UID:
    isCallerSystem=true;
  break;
default :
isCallerSystem=(callerApp != null) && callerApp.persistent;
break;
}
if (isCallerSystem) {
if (isProtectedBroadcast || Intent.ACTION_CLOSE_SYSTEM_DIALOGS.equals(action) || Intent.ACTION_MEDIA_SCANNER_SCAN_FILE.equals(action)|| Intent.ACTION_GET_PERMISSIONS_COUNT.equals(action)|| Intent.ACTION_GET_PERMISSIONS_PACKAGES.equals(action)|| Intent.ACTION_SHOW_KEYBOARD_SHORTCUTS.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action)|| AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)|| LocationManager.HIGH_POWER_REQUEST_CHANGE_ACTION.equals(action)) {
}
 else {
Log.wtf(TAG,""String_Node_Str"" + action + ""String_Node_Str"",new Throwable());
}
}
 else {
if (isProtectedBroadcast) {
String msg=""String_Node_Str"" + action + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action) || AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)) {
if (callerPackage == null) {
String msg=""String_Node_Str"" + action + ""String_Node_Str"";
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
 else if (intent.getComponent() != null) {
if (!intent.getComponent().getPackageName().equals(callerPackage)) {
  String msg=""String_Node_Str"" + action + ""String_Node_Str""+ intent.getComponent().getPackageName()+ ""String_Node_Str""+ callerPackage;
  Slog.w(TAG,msg);
  throw new SecurityException(msg);
}
}
 else {
intent.setPackage(callerPackage);
}
}
}
if (action != null) {
switch (action) {
case Intent.ACTION_UID_REMOVED:
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,callingPid,callingUid,-1,true) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ callerPackage+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
switch (action) {
case Intent.ACTION_UID_REMOVED:
final Bundle intentExtras=intent.getExtras();
final int uid=intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
if (uid >= 0) {
mBatteryStatsService.removeUid(uid);
mAppOpsService.uidRemoved(uid);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
String list[]=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
if (list != null && list.length > 0) {
for (int i=0; i < list.length; i++) {
forceStopPackageLocked(list[i],-1,false,true,true,false,false,userId,""String_Node_Str"");
}
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE,list,userId);
}
break;
case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
break;
case Intent.ACTION_PACKAGE_REMOVED:
case Intent.ACTION_PACKAGE_CHANGED:
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
boolean removed=Intent.ACTION_PACKAGE_REMOVED.equals(action);
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
final boolean killProcess=!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP,false);
final boolean fullUninstall=removed && !replacing;
if (killProcess) {
forceStopPackageLocked(ssp,UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID,-1)),false,true,true,false,fullUninstall,userId,removed ? ""String_Node_Str"" : ""String_Node_Str"");
}
if (removed) {
final int cmd=killProcess ? IApplicationThread.PACKAGE_REMOVED : IApplicationThread.PACKAGE_REMOVED_DONT_KILL;
sendPackageBroadcastLocked(cmd,new String[]{ssp},userId);
if (fullUninstall) {
mAppOpsService.packageRemoved(intent.getIntExtra(Intent.EXTRA_UID,-1),ssp);
removeUriPermissionsForPackageLocked(ssp,userId,true);
removeTasksByPackageNameLocked(ssp,userId);
mBatteryStatsService.notePackageUninstalled(ssp);
}
}
 else {
cleanupDisabledPackageComponentsLocked(ssp,userId,killProcess,intent.getStringArrayExtra(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST));
}
}
break;
case Intent.ACTION_PACKAGES_SUSPENDED:
case Intent.ACTION_PACKAGES_UNSUSPENDED:
final boolean suspended=Intent.ACTION_PACKAGES_SUSPENDED.equals(intent.getAction());
final String[] packageNames=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
final int userHandle=intent.getIntExtra(Intent.EXTRA_USER_HANDLE,UserHandle.USER_NULL);
synchronized (ActivityManagerService.this) {
mRecentTasks.onPackagesSuspendedChanged(packageNames,suspended,userHandle);
}
break;
}
break;
case Intent.ACTION_PACKAGE_REPLACED:
{
final Uri data=intent.getData();
final String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final ApplicationInfo aInfo=getPackageManagerInternalLocked().getApplicationInfo(ssp,userId);
mStackSupervisor.updateActivityApplicationInfoLocked(aInfo);
sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REPLACED,new String[]{ssp},userId);
}
break;
}
case Intent.ACTION_PACKAGE_ADDED:
{
Uri data=intent.getData();
String ssp;
if (data != null && (ssp=data.getSchemeSpecificPart()) != null) {
final boolean replacing=intent.getBooleanExtra(Intent.EXTRA_REPLACING,false);
mCompatModePackages.handlePackageAddedLocked(ssp,replacing);
try {
ApplicationInfo ai=AppGlobals.getPackageManager().getApplicationInfo(ssp,0,0);
mBatteryStatsService.notePackageInstalled(ssp,ai != null ? ai.versionCode : 0);
}
 catch (RemoteException e) {
}
}
break;
}
case Intent.ACTION_TIMEZONE_CHANGED:
mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
break;
case Intent.ACTION_TIME_CHANGED:
final int is24Hour=intent.getBooleanExtra(Intent.EXTRA_TIME_PREF_24_HOUR_FORMAT,false) ? 1 : 0;
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_TIME,is24Hour,0));
BatteryStatsImpl stats=mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
stats.noteCurrentTimeChangedLocked();
}
break;
case Intent.ACTION_CLEAR_DNS_CACHE:
mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);
break;
case Proxy.PROXY_CHANGE_ACTION:
ProxyInfo proxy=intent.getParcelableExtra(Proxy.EXTRA_PROXY_INFO);
mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG,proxy));
break;
case android.hardware.Camera.ACTION_NEW_PICTURE:
case android.hardware.Camera.ACTION_NEW_VIDEO:
Slog.w(TAG,action + ""String_Node_Str"" + UserHandle.formatUid(callingUid));
return ActivityManager.BROADCAST_SUCCESS;
}
}
if (sticky) {
if (checkPermission(android.Manifest.permission.BROADCAST_STICKY,callingPid,callingUid) != PackageManager.PERMISSION_GRANTED) {
String msg=""String_Node_Str"" + callingPid + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ android.Manifest.permission.BROADCAST_STICKY;
Slog.w(TAG,msg);
throw new SecurityException(msg);
}
if (requiredPermissions != null && requiredPermissions.length > 0) {
Slog.w(TAG,""String_Node_Str"" + intent + ""String_Node_Str""+ Arrays.toString(requiredPermissions));
return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;
}
if (intent.getComponent() != null) {
throw new SecurityException(""String_Node_Str"");
}
if (userId != UserHandle.USER_ALL) {
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(UserHandle.USER_ALL);
if (stickies != null) {
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list != null) {
int N=list.size();
int i;
for (i=0; i < N; i++) {
if (intent.filterEquals(list.get(i))) {
throw new IllegalArgumentException(""String_Node_Str"" + intent + ""String_Node_Str""+ userId+ ""String_Node_Str"");
}
}
}
}
}
ArrayMap<String,ArrayList<Intent>> stickies=mStickyBroadcasts.get(userId);
if (stickies == null) {
stickies=new ArrayMap<>();
mStickyBroadcasts.put(userId,stickies);
}
ArrayList<Intent> list=stickies.get(intent.getAction());
if (list == null) {
list=new ArrayList<>();
stickies.put(intent.getAction(),list);
}
final int stickiesCount=list.size();
int i;
for (i=0; i < stickiesCount; i++) {
if (intent.filterEquals(list.get(i))) {
list.set(i,new Intent(intent));
break;
}
}
if (i >= stickiesCount) {
list.add(new Intent(intent));
}
}
int[] users;
if (userId == UserHandle.USER_ALL) {
users=mUserController.getStartedUserArrayLocked();
}
 else {
users=new int[]{userId};
}
List receivers=null;
List<BroadcastFilter> registeredReceivers=null;
if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
receivers=collectReceiverComponents(intent,resolvedType,callingUid,users);
}
if (intent.getComponent() == null) {
if (userId == UserHandle.USER_ALL && callingUid == Process.SHELL_UID) {
for (int i=0; i < users.length; i++) {
if (mUserController.hasUserRestriction(UserManager.DISALLOW_DEBUGGING_FEATURES,users[i])) {
continue;
}
List<BroadcastFilter> registeredReceiversForUser=mReceiverResolver.queryIntent(intent,resolvedType,false,users[i]);
if (registeredReceivers == null) {
registeredReceivers=registeredReceiversForUser;
}
 else if (registeredReceiversForUser != null) {
registeredReceivers.addAll(registeredReceiversForUser);
}
}
}
 else {
registeredReceivers=mReceiverResolver.queryIntent(intent,resolvedType,false,userId);
}
}
final boolean replacePending=(intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + intent.getAction() + ""String_Node_Str""+ replacePending);
int NR=registeredReceivers != null ? registeredReceivers.size() : 0;
if (!ordered && NR > 0) {
final BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,registeredReceivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r);
final boolean replaced=replacePending && queue.replaceParallelBroadcastLocked(r);
if (!replaced) {
queue.enqueueParallelBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
registeredReceivers=null;
NR=0;
}
int ir=0;
if (receivers != null) {
String skipPackages[]=null;
if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
Uri data=intent.getData();
if (data != null) {
String pkgName=data.getSchemeSpecificPart();
if (pkgName != null) {
skipPackages=new String[]{pkgName};
}
}
}
 else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
skipPackages=intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
}
if (skipPackages != null && (skipPackages.length > 0)) {
for (String skipPackage : skipPackages) {
if (skipPackage != null) {
int NT=receivers.size();
for (int it=0; it < NT; it++) {
ResolveInfo curt=(ResolveInfo)receivers.get(it);
if (curt.activityInfo.packageName.equals(skipPackage)) {
receivers.remove(it);
it--;
NT--;
}
}
}
}
}
int NT=receivers != null ? receivers.size() : 0;
int it=0;
ResolveInfo curt=null;
BroadcastFilter curr=null;
while (it < NT && ir < NR) {
if (curt == null) {
curt=(ResolveInfo)receivers.get(it);
}
if (curr == null) {
curr=registeredReceivers.get(ir);
}
if (curr.getPriority() >= curt.priority) {
receivers.add(it,curr);
ir++;
curr=null;
it++;
NT++;
}
 else {
it++;
curt=null;
}
}
}
while (ir < NR) {
if (receivers == null) {
receivers=new ArrayList();
}
receivers.add(registeredReceivers.get(ir));
ir++;
}
if ((receivers != null && receivers.size() > 0) || resultTo != null) {
BroadcastQueue queue=broadcastQueueForIntent(intent);
BroadcastRecord r=new BroadcastRecord(queue,intent,callerApp,callerPackage,callingPid,callingUid,resolvedType,requiredPermissions,appOp,brOptions,receivers,resultTo,resultCode,resultData,resultExtras,ordered,sticky,false,userId);
if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,""String_Node_Str"" + r + ""String_Node_Str""+ queue.mOrderedBroadcasts.size());
if (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,""String_Node_Str"" + r.intent.getAction());
boolean replaced=replacePending && queue.replaceOrderedBroadcastLocked(r);
if (!replaced) {
queue.enqueueOrderedBroadcastLocked(r);
queue.scheduleBroadcastsLocked();
}
}
return ActivityManager.BROADCAST_SUCCESS;
}",0.9981567746908409
192026,"/** 
 * Remove given fingerprint template from fingerprint hardware and/or protected storage.
 * @param fp the fingerprint item to remove
 * @param userId the user who this fingerprint belongs to
 * @param callback an optional callback to verify that fingerprint templates have beensuccessfully removed. May be null of no callback is required.
 * @hide
 */
@RequiresPermission(MANAGE_FINGERPRINT) public void remove(Fingerprint fp,int userId,RemovalCallback callback){
  if (mService != null)   try {
    mRemovalCallback=callback;
    mRemovalFingerprint=fp;
    mService.remove(mToken,fp.getFingerId(),userId,mServiceReceiver);
  }
 catch (  RemoteException e) {
    Log.w(TAG,""String_Node_Str"",e);
    if (callback != null) {
      callback.onRemovalError(fp,FINGERPRINT_ERROR_HW_UNAVAILABLE,getErrorString(FINGERPRINT_ERROR_HW_UNAVAILABLE));
    }
  }
}","/** 
 * Remove given fingerprint template from fingerprint hardware and/or protected storage.
 * @param fp the fingerprint item to remove
 * @param userId the user who this fingerprint belongs to
 * @param callback an optional callback to verify that fingerprint templates have beensuccessfully removed. May be null of no callback is required.
 * @hide
 */
@RequiresPermission(MANAGE_FINGERPRINT) public void remove(Fingerprint fp,int userId,RemovalCallback callback){
  if (mService != null)   try {
    mRemovalCallback=callback;
    mRemovalFingerprint=fp;
    mService.remove(mToken,fp.getFingerId(),fp.getGroupId(),userId,mServiceReceiver);
  }
 catch (  RemoteException e) {
    Log.w(TAG,""String_Node_Str"",e);
    if (callback != null) {
      callback.onRemovalError(fp,FINGERPRINT_ERROR_HW_UNAVAILABLE,getErrorString(FINGERPRINT_ERROR_HW_UNAVAILABLE));
    }
  }
}",0.9907514450867052
192027,"private void sendRemovedResult(long deviceId,int fingerId,int groupId){
  if (mRemovalCallback != null) {
    int reqFingerId=mRemovalFingerprint.getFingerId();
    int reqGroupId=mRemovalFingerprint.getGroupId();
    if (reqFingerId != 0 && fingerId != reqFingerId) {
      Log.w(TAG,""String_Node_Str"" + fingerId + ""String_Node_Str""+ reqFingerId);
    }
    if (groupId != reqGroupId) {
      Log.w(TAG,""String_Node_Str"" + groupId + ""String_Node_Str""+ reqGroupId);
    }
    mRemovalCallback.onRemovalSucceeded(new Fingerprint(null,groupId,fingerId,deviceId));
  }
}","private void sendRemovedResult(long deviceId,int fingerId,int groupId){
  if (mRemovalCallback != null) {
    int reqFingerId=mRemovalFingerprint.getFingerId();
    int reqGroupId=mRemovalFingerprint.getGroupId();
    if (reqFingerId != 0 && fingerId != 0 && fingerId != reqFingerId) {
      Log.w(TAG,""String_Node_Str"" + fingerId + ""String_Node_Str""+ reqFingerId);
      return;
    }
    if (groupId != reqGroupId) {
      Log.w(TAG,""String_Node_Str"" + groupId + ""String_Node_Str""+ reqGroupId);
      return;
    }
    mRemovalCallback.onRemovalSucceeded(new Fingerprint(null,groupId,fingerId,deviceId));
  }
}",0.9618320610687024
192028,"/** 
 * Remove given fingerprint template from fingerprint hardware and/or protected storage.
 * @param fp the fingerprint item to remove
 * @param userId the user who this fingerprint belongs to
 * @param callback an optional callback to verify that fingerprint templates have beensuccessfully removed. May be null of no callback is required.
 * @hide
 */
@RequiresPermission(MANAGE_FINGERPRINT) public void remove(Fingerprint fp,int userId,RemovalCallback callback){
  if (mService != null)   try {
    mRemovalCallback=callback;
    mRemovalFingerprint=fp;
    mService.remove(mToken,fp.getFingerId(),userId,mServiceReceiver);
  }
 catch (  RemoteException e) {
    Log.w(TAG,""String_Node_Str"",e);
    if (callback != null) {
      callback.onRemovalError(fp,FINGERPRINT_ERROR_HW_UNAVAILABLE,getErrorString(FINGERPRINT_ERROR_HW_UNAVAILABLE));
    }
  }
}","/** 
 * Remove given fingerprint template from fingerprint hardware and/or protected storage.
 * @param fp the fingerprint item to remove
 * @param userId the user who this fingerprint belongs to
 * @param callback an optional callback to verify that fingerprint templates have beensuccessfully removed. May be null of no callback is required.
 * @hide
 */
@RequiresPermission(MANAGE_FINGERPRINT) public void remove(Fingerprint fp,int userId,RemovalCallback callback){
  if (mService != null)   try {
    mRemovalCallback=callback;
    mRemovalFingerprint=fp;
    mService.remove(mToken,fp.getFingerId(),fp.getGroupId(),userId,mServiceReceiver);
  }
 catch (  RemoteException e) {
    Log.w(TAG,""String_Node_Str"",e);
    if (callback != null) {
      callback.onRemovalError(fp,FINGERPRINT_ERROR_HW_UNAVAILABLE,getErrorString(FINGERPRINT_ERROR_HW_UNAVAILABLE));
    }
  }
}",0.9907514450867052
192029,"private void sendRemovedResult(long deviceId,int fingerId,int groupId){
  if (mRemovalCallback != null) {
    int reqFingerId=mRemovalFingerprint.getFingerId();
    int reqGroupId=mRemovalFingerprint.getGroupId();
    if (reqFingerId != 0 && fingerId != reqFingerId) {
      Log.w(TAG,""String_Node_Str"" + fingerId + ""String_Node_Str""+ reqFingerId);
    }
    if (groupId != reqGroupId) {
      Log.w(TAG,""String_Node_Str"" + groupId + ""String_Node_Str""+ reqGroupId);
    }
    mRemovalCallback.onRemovalSucceeded(new Fingerprint(null,groupId,fingerId,deviceId));
  }
}","private void sendRemovedResult(long deviceId,int fingerId,int groupId){
  if (mRemovalCallback != null) {
    int reqFingerId=mRemovalFingerprint.getFingerId();
    int reqGroupId=mRemovalFingerprint.getGroupId();
    if (reqFingerId != 0 && fingerId != 0 && fingerId != reqFingerId) {
      Log.w(TAG,""String_Node_Str"" + fingerId + ""String_Node_Str""+ reqFingerId);
      return;
    }
    if (groupId != reqGroupId) {
      Log.w(TAG,""String_Node_Str"" + groupId + ""String_Node_Str""+ reqGroupId);
      return;
    }
    mRemovalCallback.onRemovalSucceeded(new Fingerprint(null,groupId,fingerId,deviceId));
  }
}",0.9618320610687024
192030,"/** 
 * Remove given fingerprint template from fingerprint hardware and/or protected storage.
 * @param fp the fingerprint item to remove
 * @param userId the user who this fingerprint belongs to
 * @param callback an optional callback to verify that fingerprint templates have beensuccessfully removed. May be null of no callback is required.
 * @hide
 */
@RequiresPermission(MANAGE_FINGERPRINT) public void remove(Fingerprint fp,int userId,RemovalCallback callback){
  if (mService != null)   try {
    mRemovalCallback=callback;
    mRemovalFingerprint=fp;
    mService.remove(mToken,fp.getFingerId(),userId,mServiceReceiver);
  }
 catch (  RemoteException e) {
    Log.w(TAG,""String_Node_Str"",e);
    if (callback != null) {
      callback.onRemovalError(fp,FINGERPRINT_ERROR_HW_UNAVAILABLE,getErrorString(FINGERPRINT_ERROR_HW_UNAVAILABLE));
    }
  }
}","/** 
 * Remove given fingerprint template from fingerprint hardware and/or protected storage.
 * @param fp the fingerprint item to remove
 * @param userId the user who this fingerprint belongs to
 * @param callback an optional callback to verify that fingerprint templates have beensuccessfully removed. May be null of no callback is required.
 * @hide
 */
@RequiresPermission(MANAGE_FINGERPRINT) public void remove(Fingerprint fp,int userId,RemovalCallback callback){
  if (mService != null)   try {
    mRemovalCallback=callback;
    mRemovalFingerprint=fp;
    mService.remove(mToken,fp.getFingerId(),fp.getGroupId(),userId,mServiceReceiver);
  }
 catch (  RemoteException e) {
    Log.w(TAG,""String_Node_Str"",e);
    if (callback != null) {
      callback.onRemovalError(fp,FINGERPRINT_ERROR_HW_UNAVAILABLE,getErrorString(FINGERPRINT_ERROR_HW_UNAVAILABLE));
    }
  }
}",0.9907514450867052
192031,"private void sendRemovedResult(long deviceId,int fingerId,int groupId){
  if (mRemovalCallback != null) {
    int reqFingerId=mRemovalFingerprint.getFingerId();
    int reqGroupId=mRemovalFingerprint.getGroupId();
    if (reqFingerId != 0 && fingerId != reqFingerId) {
      Log.w(TAG,""String_Node_Str"" + fingerId + ""String_Node_Str""+ reqFingerId);
    }
    if (groupId != reqGroupId) {
      Log.w(TAG,""String_Node_Str"" + groupId + ""String_Node_Str""+ reqGroupId);
    }
    mRemovalCallback.onRemovalSucceeded(new Fingerprint(null,groupId,fingerId,deviceId));
  }
}","private void sendRemovedResult(long deviceId,int fingerId,int groupId){
  if (mRemovalCallback != null) {
    int reqFingerId=mRemovalFingerprint.getFingerId();
    int reqGroupId=mRemovalFingerprint.getGroupId();
    if (reqFingerId != 0 && fingerId != 0 && fingerId != reqFingerId) {
      Log.w(TAG,""String_Node_Str"" + fingerId + ""String_Node_Str""+ reqFingerId);
      return;
    }
    if (groupId != reqGroupId) {
      Log.w(TAG,""String_Node_Str"" + groupId + ""String_Node_Str""+ reqGroupId);
      return;
    }
    mRemovalCallback.onRemovalSucceeded(new Fingerprint(null,groupId,fingerId,deviceId));
  }
}",0.9618320610687024
192032,"/** 
 * Remove given fingerprint template from fingerprint hardware and/or protected storage.
 * @param fp the fingerprint item to remove
 * @param userId the user who this fingerprint belongs to
 * @param callback an optional callback to verify that fingerprint templates have beensuccessfully removed. May be null of no callback is required.
 * @hide
 */
@RequiresPermission(MANAGE_FINGERPRINT) public void remove(Fingerprint fp,int userId,RemovalCallback callback){
  if (mService != null)   try {
    mRemovalCallback=callback;
    mRemovalFingerprint=fp;
    mService.remove(mToken,fp.getFingerId(),userId,mServiceReceiver);
  }
 catch (  RemoteException e) {
    Log.w(TAG,""String_Node_Str"",e);
    if (callback != null) {
      callback.onRemovalError(fp,FINGERPRINT_ERROR_HW_UNAVAILABLE,getErrorString(FINGERPRINT_ERROR_HW_UNAVAILABLE));
    }
  }
}","/** 
 * Remove given fingerprint template from fingerprint hardware and/or protected storage.
 * @param fp the fingerprint item to remove
 * @param userId the user who this fingerprint belongs to
 * @param callback an optional callback to verify that fingerprint templates have beensuccessfully removed. May be null of no callback is required.
 * @hide
 */
@RequiresPermission(MANAGE_FINGERPRINT) public void remove(Fingerprint fp,int userId,RemovalCallback callback){
  if (mService != null)   try {
    mRemovalCallback=callback;
    mRemovalFingerprint=fp;
    mService.remove(mToken,fp.getFingerId(),fp.getGroupId(),userId,mServiceReceiver);
  }
 catch (  RemoteException e) {
    Log.w(TAG,""String_Node_Str"",e);
    if (callback != null) {
      callback.onRemovalError(fp,FINGERPRINT_ERROR_HW_UNAVAILABLE,getErrorString(FINGERPRINT_ERROR_HW_UNAVAILABLE));
    }
  }
}",0.9907514450867052
192033,"private void sendRemovedResult(long deviceId,int fingerId,int groupId){
  if (mRemovalCallback != null) {
    int reqFingerId=mRemovalFingerprint.getFingerId();
    int reqGroupId=mRemovalFingerprint.getGroupId();
    if (reqFingerId != 0 && fingerId != reqFingerId) {
      Log.w(TAG,""String_Node_Str"" + fingerId + ""String_Node_Str""+ reqFingerId);
    }
    if (groupId != reqGroupId) {
      Log.w(TAG,""String_Node_Str"" + groupId + ""String_Node_Str""+ reqGroupId);
    }
    mRemovalCallback.onRemovalSucceeded(new Fingerprint(null,groupId,fingerId,deviceId));
  }
}","private void sendRemovedResult(long deviceId,int fingerId,int groupId){
  if (mRemovalCallback != null) {
    int reqFingerId=mRemovalFingerprint.getFingerId();
    int reqGroupId=mRemovalFingerprint.getGroupId();
    if (reqFingerId != 0 && fingerId != 0 && fingerId != reqFingerId) {
      Log.w(TAG,""String_Node_Str"" + fingerId + ""String_Node_Str""+ reqFingerId);
      return;
    }
    if (groupId != reqGroupId) {
      Log.w(TAG,""String_Node_Str"" + groupId + ""String_Node_Str""+ reqGroupId);
      return;
    }
    mRemovalCallback.onRemovalSucceeded(new Fingerprint(null,groupId,fingerId,deviceId));
  }
}",0.9618320610687024
192034,"private SubscriptionInfo addSignalController(int id,int simSlotIndex){
  SubscriptionInfo info=new SubscriptionInfo(id,""String_Node_Str"",simSlotIndex,""String_Node_Str"",""String_Node_Str"",0,0,""String_Node_Str"",0,null,0,0,""String_Node_Str"");
  mMobileSignalControllers.put(id,new MobileSignalController(mContext,mConfig,mHasMobileDataFeature,mPhone,mCallbackHandler,this,info,mSubDefaults,mReceiverHandler.getLooper()));
  return info;
}","private SubscriptionInfo addSignalController(int id,int simSlotIndex){
  SubscriptionInfo info=new SubscriptionInfo(id,""String_Node_Str"",simSlotIndex,""String_Node_Str"",""String_Node_Str"",0,0,""String_Node_Str"",0,null,0,0,""String_Node_Str"",SubscriptionManager.SIM_PROVISIONED);
  mMobileSignalControllers.put(id,new MobileSignalController(mContext,mConfig,mHasMobileDataFeature,mPhone,mCallbackHandler,this,info,mSubDefaults,mReceiverHandler.getLooper()));
  return info;
}",0.9601769911504424
192035,"/** 
 * @hide
 */
public SubscriptionInfo(int id,String iccId,int simSlotIndex,CharSequence displayName,CharSequence carrierName,int nameSource,int iconTint,String number,int roaming,Bitmap icon,int mcc,int mnc,String countryIso){
  this.mId=id;
  this.mIccId=iccId;
  this.mSimSlotIndex=simSlotIndex;
  this.mDisplayName=displayName;
  this.mCarrierName=carrierName;
  this.mNameSource=nameSource;
  this.mIconTint=iconTint;
  this.mNumber=number;
  this.mDataRoaming=roaming;
  this.mIconBitmap=icon;
  this.mMcc=mcc;
  this.mMnc=mnc;
  this.mCountryIso=countryIso;
}","/** 
 * @hide
 */
public SubscriptionInfo(int id,String iccId,int simSlotIndex,CharSequence displayName,CharSequence carrierName,int nameSource,int iconTint,String number,int roaming,Bitmap icon,int mcc,int mnc,String countryIso,int simProvisioningStatus){
  this.mId=id;
  this.mIccId=iccId;
  this.mSimSlotIndex=simSlotIndex;
  this.mDisplayName=displayName;
  this.mCarrierName=carrierName;
  this.mNameSource=nameSource;
  this.mIconTint=iconTint;
  this.mNumber=number;
  this.mDataRoaming=roaming;
  this.mIconBitmap=icon;
  this.mMcc=mcc;
  this.mMnc=mnc;
  this.mCountryIso=countryIso;
  this.mSimProvisioningStatus=simProvisioningStatus;
}",0.9350862777321282
192036,"@Override public SubscriptionInfo createFromParcel(Parcel source){
  int id=source.readInt();
  String iccId=source.readString();
  int simSlotIndex=source.readInt();
  CharSequence displayName=source.readCharSequence();
  CharSequence carrierName=source.readCharSequence();
  int nameSource=source.readInt();
  int iconTint=source.readInt();
  String number=source.readString();
  int dataRoaming=source.readInt();
  int mcc=source.readInt();
  int mnc=source.readInt();
  String countryIso=source.readString();
  Bitmap iconBitmap=Bitmap.CREATOR.createFromParcel(source);
  return new SubscriptionInfo(id,iccId,simSlotIndex,displayName,carrierName,nameSource,iconTint,number,dataRoaming,iconBitmap,mcc,mnc,countryIso);
}","@Override public SubscriptionInfo createFromParcel(Parcel source){
  int id=source.readInt();
  String iccId=source.readString();
  int simSlotIndex=source.readInt();
  CharSequence displayName=source.readCharSequence();
  CharSequence carrierName=source.readCharSequence();
  int nameSource=source.readInt();
  int iconTint=source.readInt();
  String number=source.readString();
  int dataRoaming=source.readInt();
  int mcc=source.readInt();
  int mnc=source.readInt();
  String countryIso=source.readString();
  int simProvisioningStatus=source.readInt();
  Bitmap iconBitmap=Bitmap.CREATOR.createFromParcel(source);
  return new SubscriptionInfo(id,iccId,simSlotIndex,displayName,carrierName,nameSource,iconTint,number,dataRoaming,iconBitmap,mcc,mnc,countryIso,simProvisioningStatus);
}",0.955026455026455
192037,"@Override public String toString(){
  String iccIdToPrint=givePrintableIccid(mIccId);
  return ""String_Node_Str"" + mId + ""String_Node_Str""+ iccIdToPrint+ ""String_Node_Str""+ mSimSlotIndex+ ""String_Node_Str""+ mDisplayName+ ""String_Node_Str""+ mCarrierName+ ""String_Node_Str""+ mNameSource+ ""String_Node_Str""+ mIconTint+ ""String_Node_Str""+ mDataRoaming+ ""String_Node_Str""+ mIconBitmap+ ""String_Node_Str""+ mMcc+ ""String_Node_Str""+ mMnc+ ""String_Node_Str"";
}","@Override public String toString(){
  String iccIdToPrint=givePrintableIccid(mIccId);
  return ""String_Node_Str"" + mId + ""String_Node_Str""+ iccIdToPrint+ ""String_Node_Str""+ mSimSlotIndex+ ""String_Node_Str""+ mDisplayName+ ""String_Node_Str""+ mCarrierName+ ""String_Node_Str""+ mNameSource+ ""String_Node_Str""+ mIconTint+ ""String_Node_Str""+ mDataRoaming+ ""String_Node_Str""+ mIconBitmap+ ""String_Node_Str""+ mMcc+ ""String_Node_Str""+ mMnc+ ""String_Node_Str""+ mSimProvisioningStatus+ ""String_Node_Str"";
}",0.9544973544973544
192038,"@Override public void writeToParcel(Parcel dest,int flags){
  dest.writeInt(mId);
  dest.writeString(mIccId);
  dest.writeInt(mSimSlotIndex);
  dest.writeCharSequence(mDisplayName);
  dest.writeCharSequence(mCarrierName);
  dest.writeInt(mNameSource);
  dest.writeInt(mIconTint);
  dest.writeString(mNumber);
  dest.writeInt(mDataRoaming);
  dest.writeInt(mMcc);
  dest.writeInt(mMnc);
  dest.writeString(mCountryIso);
  mIconBitmap.writeToParcel(dest,flags);
}","@Override public void writeToParcel(Parcel dest,int flags){
  dest.writeInt(mId);
  dest.writeString(mIccId);
  dest.writeInt(mSimSlotIndex);
  dest.writeCharSequence(mDisplayName);
  dest.writeCharSequence(mCarrierName);
  dest.writeInt(mNameSource);
  dest.writeInt(mIconTint);
  dest.writeString(mNumber);
  dest.writeInt(mDataRoaming);
  dest.writeInt(mMcc);
  dest.writeInt(mMnc);
  dest.writeString(mCountryIso);
  dest.writeInt(mSimProvisioningStatus);
  mIconBitmap.writeToParcel(dest,flags);
}",0.9574247144340602
192039,"private SubscriptionInfo addSignalController(int id,int simSlotIndex){
  SubscriptionInfo info=new SubscriptionInfo(id,""String_Node_Str"",simSlotIndex,""String_Node_Str"",""String_Node_Str"",0,0,""String_Node_Str"",0,null,0,0,""String_Node_Str"");
  mMobileSignalControllers.put(id,new MobileSignalController(mContext,mConfig,mHasMobileDataFeature,mPhone,mCallbackHandler,this,info,mSubDefaults,mReceiverHandler.getLooper()));
  return info;
}","private SubscriptionInfo addSignalController(int id,int simSlotIndex){
  SubscriptionInfo info=new SubscriptionInfo(id,""String_Node_Str"",simSlotIndex,""String_Node_Str"",""String_Node_Str"",0,0,""String_Node_Str"",0,null,0,0,""String_Node_Str"",SubscriptionManager.SIM_PROVISIONED);
  mMobileSignalControllers.put(id,new MobileSignalController(mContext,mConfig,mHasMobileDataFeature,mPhone,mCallbackHandler,this,info,mSubDefaults,mReceiverHandler.getLooper()));
  return info;
}",0.9601769911504424
192040,"/** 
 * @hide
 */
public SubscriptionInfo(int id,String iccId,int simSlotIndex,CharSequence displayName,CharSequence carrierName,int nameSource,int iconTint,String number,int roaming,Bitmap icon,int mcc,int mnc,String countryIso){
  this.mId=id;
  this.mIccId=iccId;
  this.mSimSlotIndex=simSlotIndex;
  this.mDisplayName=displayName;
  this.mCarrierName=carrierName;
  this.mNameSource=nameSource;
  this.mIconTint=iconTint;
  this.mNumber=number;
  this.mDataRoaming=roaming;
  this.mIconBitmap=icon;
  this.mMcc=mcc;
  this.mMnc=mnc;
  this.mCountryIso=countryIso;
}","/** 
 * @hide
 */
public SubscriptionInfo(int id,String iccId,int simSlotIndex,CharSequence displayName,CharSequence carrierName,int nameSource,int iconTint,String number,int roaming,Bitmap icon,int mcc,int mnc,String countryIso,int simProvisioningStatus){
  this.mId=id;
  this.mIccId=iccId;
  this.mSimSlotIndex=simSlotIndex;
  this.mDisplayName=displayName;
  this.mCarrierName=carrierName;
  this.mNameSource=nameSource;
  this.mIconTint=iconTint;
  this.mNumber=number;
  this.mDataRoaming=roaming;
  this.mIconBitmap=icon;
  this.mMcc=mcc;
  this.mMnc=mnc;
  this.mCountryIso=countryIso;
  this.mSimProvisioningStatus=simProvisioningStatus;
}",0.9350862777321282
192041,"@Override public SubscriptionInfo createFromParcel(Parcel source){
  int id=source.readInt();
  String iccId=source.readString();
  int simSlotIndex=source.readInt();
  CharSequence displayName=source.readCharSequence();
  CharSequence carrierName=source.readCharSequence();
  int nameSource=source.readInt();
  int iconTint=source.readInt();
  String number=source.readString();
  int dataRoaming=source.readInt();
  int mcc=source.readInt();
  int mnc=source.readInt();
  String countryIso=source.readString();
  Bitmap iconBitmap=Bitmap.CREATOR.createFromParcel(source);
  return new SubscriptionInfo(id,iccId,simSlotIndex,displayName,carrierName,nameSource,iconTint,number,dataRoaming,iconBitmap,mcc,mnc,countryIso);
}","@Override public SubscriptionInfo createFromParcel(Parcel source){
  int id=source.readInt();
  String iccId=source.readString();
  int simSlotIndex=source.readInt();
  CharSequence displayName=source.readCharSequence();
  CharSequence carrierName=source.readCharSequence();
  int nameSource=source.readInt();
  int iconTint=source.readInt();
  String number=source.readString();
  int dataRoaming=source.readInt();
  int mcc=source.readInt();
  int mnc=source.readInt();
  String countryIso=source.readString();
  int simProvisioningStatus=source.readInt();
  Bitmap iconBitmap=Bitmap.CREATOR.createFromParcel(source);
  return new SubscriptionInfo(id,iccId,simSlotIndex,displayName,carrierName,nameSource,iconTint,number,dataRoaming,iconBitmap,mcc,mnc,countryIso,simProvisioningStatus);
}",0.955026455026455
192042,"@Override public String toString(){
  String iccIdToPrint=givePrintableIccid(mIccId);
  return ""String_Node_Str"" + mId + ""String_Node_Str""+ iccIdToPrint+ ""String_Node_Str""+ mSimSlotIndex+ ""String_Node_Str""+ mDisplayName+ ""String_Node_Str""+ mCarrierName+ ""String_Node_Str""+ mNameSource+ ""String_Node_Str""+ mIconTint+ ""String_Node_Str""+ mDataRoaming+ ""String_Node_Str""+ mIconBitmap+ ""String_Node_Str""+ mMcc+ ""String_Node_Str""+ mMnc+ ""String_Node_Str"";
}","@Override public String toString(){
  String iccIdToPrint=givePrintableIccid(mIccId);
  return ""String_Node_Str"" + mId + ""String_Node_Str""+ iccIdToPrint+ ""String_Node_Str""+ mSimSlotIndex+ ""String_Node_Str""+ mDisplayName+ ""String_Node_Str""+ mCarrierName+ ""String_Node_Str""+ mNameSource+ ""String_Node_Str""+ mIconTint+ ""String_Node_Str""+ mDataRoaming+ ""String_Node_Str""+ mIconBitmap+ ""String_Node_Str""+ mMcc+ ""String_Node_Str""+ mMnc+ ""String_Node_Str""+ mSimProvisioningStatus+ ""String_Node_Str"";
}",0.9544973544973544
192043,"@Override public void writeToParcel(Parcel dest,int flags){
  dest.writeInt(mId);
  dest.writeString(mIccId);
  dest.writeInt(mSimSlotIndex);
  dest.writeCharSequence(mDisplayName);
  dest.writeCharSequence(mCarrierName);
  dest.writeInt(mNameSource);
  dest.writeInt(mIconTint);
  dest.writeString(mNumber);
  dest.writeInt(mDataRoaming);
  dest.writeInt(mMcc);
  dest.writeInt(mMnc);
  dest.writeString(mCountryIso);
  mIconBitmap.writeToParcel(dest,flags);
}","@Override public void writeToParcel(Parcel dest,int flags){
  dest.writeInt(mId);
  dest.writeString(mIccId);
  dest.writeInt(mSimSlotIndex);
  dest.writeCharSequence(mDisplayName);
  dest.writeCharSequence(mCarrierName);
  dest.writeInt(mNameSource);
  dest.writeInt(mIconTint);
  dest.writeString(mNumber);
  dest.writeInt(mDataRoaming);
  dest.writeInt(mMcc);
  dest.writeInt(mMnc);
  dest.writeString(mCountryIso);
  dest.writeInt(mSimProvisioningStatus);
  mIconBitmap.writeToParcel(dest,flags);
}",0.9574247144340602
192044,"@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return false;
  }
  trackVelocity(ev);
  final int action=ev.getAction();
  if (DEBUG_SCALE)   Log.d(TAG,""String_Node_Str"" + MotionEvent.actionToString(action) + ""String_Node_Str""+ mExpanding+ (0 != (mExpansionStyle & BLINDS) ? ""String_Node_Str"" : ""String_Node_Str"")+ (0 != (mExpansionStyle & PULL) ? ""String_Node_Str"" : ""String_Node_Str"")+ (0 != (mExpansionStyle & STRETCH) ? ""String_Node_Str"" : ""String_Node_Str""));
  mSGD.onTouchEvent(ev);
  final int x=(int)mSGD.getFocusX();
  final int y=(int)mSGD.getFocusY();
  mInitialTouchFocusY=y;
  mInitialTouchSpan=mSGD.getCurrentSpan();
  mLastFocusY=mInitialTouchFocusY;
  mLastSpanY=mInitialTouchSpan;
  if (DEBUG_SCALE)   Log.d(TAG,""String_Node_Str"" + mInitialTouchSpan);
  if (mExpanding) {
    mLastMotionY=ev.getRawY();
    maybeRecycleVelocityTracker(ev);
    return true;
  }
 else {
    if ((action == MotionEvent.ACTION_MOVE) && 0 != (mExpansionStyle & BLINDS)) {
      return true;
    }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_MOVE:
{
        final float xspan=mSGD.getCurrentSpanX();
        if (xspan > mPullGestureMinXSpan && xspan > mSGD.getCurrentSpanY() && !mExpanding) {
          if (DEBUG_SCALE)           Log.v(TAG,""String_Node_Str"" + xspan + ""String_Node_Str"");
          startExpanding(mResizedView,PULL);
          mWatchingForPull=false;
        }
        if (mWatchingForPull) {
          final float yDiff=ev.getRawY() - mInitialTouchY;
          final float xDiff=ev.getRawX() - mInitialTouchX;
          if (yDiff > mTouchSlop && yDiff > Math.abs(xDiff)) {
            if (DEBUG)             Log.v(TAG,""String_Node_Str"" + yDiff + ""String_Node_Str"");
            mWatchingForPull=false;
            if (mResizedView != null && !isFullyExpanded(mResizedView)) {
              if (startExpanding(mResizedView,BLINDS)) {
                mLastMotionY=ev.getRawY();
                mInitialTouchY=ev.getRawY();
                mHasPopped=false;
              }
            }
          }
        }
        break;
      }
case MotionEvent.ACTION_DOWN:
    mWatchingForPull=mScrollAdapter != null && isInside(mScrollAdapter.getHostView(),x,y) && mScrollAdapter.isScrolledToTop();
  mResizedView=findView(x,y);
if (mResizedView != null && !mCallback.canChildBeExpanded(mResizedView)) {
  mResizedView=null;
  mWatchingForPull=false;
}
mInitialTouchY=ev.getY();
mInitialTouchX=ev.getX();
break;
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
finishExpanding(false,getCurrentVelocity());
clearView();
break;
}
mLastMotionY=ev.getRawY();
maybeRecycleVelocityTracker(ev);
return mExpanding;
}
}","@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return false;
  }
  trackVelocity(ev);
  final int action=ev.getAction();
  if (DEBUG_SCALE)   Log.d(TAG,""String_Node_Str"" + MotionEvent.actionToString(action) + ""String_Node_Str""+ mExpanding+ (0 != (mExpansionStyle & BLINDS) ? ""String_Node_Str"" : ""String_Node_Str"")+ (0 != (mExpansionStyle & PULL) ? ""String_Node_Str"" : ""String_Node_Str"")+ (0 != (mExpansionStyle & STRETCH) ? ""String_Node_Str"" : ""String_Node_Str""));
  mSGD.onTouchEvent(ev);
  final int x=(int)mSGD.getFocusX();
  final int y=(int)mSGD.getFocusY();
  mInitialTouchFocusY=y;
  mInitialTouchSpan=mSGD.getCurrentSpan();
  mLastFocusY=mInitialTouchFocusY;
  mLastSpanY=mInitialTouchSpan;
  if (DEBUG_SCALE)   Log.d(TAG,""String_Node_Str"" + mInitialTouchSpan);
  if (mExpanding) {
    mLastMotionY=ev.getRawY();
    maybeRecycleVelocityTracker(ev);
    return true;
  }
 else {
    if ((action == MotionEvent.ACTION_MOVE) && 0 != (mExpansionStyle & BLINDS)) {
      return true;
    }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_MOVE:
{
        final float xspan=mSGD.getCurrentSpanX();
        if (xspan > mPullGestureMinXSpan && xspan > mSGD.getCurrentSpanY() && !mExpanding) {
          if (DEBUG_SCALE)           Log.v(TAG,""String_Node_Str"" + xspan + ""String_Node_Str"");
          startExpanding(mResizedView,PULL);
          mWatchingForPull=false;
        }
        if (mWatchingForPull) {
          final float yDiff=ev.getRawY() - mInitialTouchY;
          final float xDiff=ev.getRawX() - mInitialTouchX;
          if (yDiff > mTouchSlop && yDiff > Math.abs(xDiff)) {
            if (DEBUG)             Log.v(TAG,""String_Node_Str"" + yDiff + ""String_Node_Str"");
            mWatchingForPull=false;
            if (mResizedView != null && !isFullyExpanded(mResizedView)) {
              if (startExpanding(mResizedView,BLINDS)) {
                mLastMotionY=ev.getRawY();
                mInitialTouchY=ev.getRawY();
                mHasPopped=false;
              }
            }
          }
        }
        break;
      }
case MotionEvent.ACTION_DOWN:
    mWatchingForPull=mScrollAdapter != null && isInside(mScrollAdapter.getHostView(),x,y) && mScrollAdapter.isScrolledToTop();
  mResizedView=findView(x,y);
if (mResizedView != null && !mCallback.canChildBeExpanded(mResizedView)) {
  mResizedView=null;
  mWatchingForPull=false;
}
mInitialTouchY=ev.getRawY();
mInitialTouchX=ev.getRawX();
break;
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
finishExpanding(false,getCurrentVelocity());
clearView();
break;
}
mLastMotionY=ev.getRawY();
maybeRecycleVelocityTracker(ev);
return mExpanding;
}
}",0.9989023051591658
192045,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return false;
  }
  trackVelocity(ev);
  final int action=ev.getActionMasked();
  if (DEBUG_SCALE)   Log.d(TAG,""String_Node_Str"" + MotionEvent.actionToString(action) + ""String_Node_Str""+ mExpanding+ (0 != (mExpansionStyle & BLINDS) ? ""String_Node_Str"" : ""String_Node_Str"")+ (0 != (mExpansionStyle & PULL) ? ""String_Node_Str"" : ""String_Node_Str"")+ (0 != (mExpansionStyle & STRETCH) ? ""String_Node_Str"" : ""String_Node_Str""));
  mSGD.onTouchEvent(ev);
  final int x=(int)mSGD.getFocusX();
  final int y=(int)mSGD.getFocusY();
  if (mOnlyMovements) {
    mLastMotionY=ev.getRawY();
    return false;
  }
switch (action) {
case MotionEvent.ACTION_DOWN:
    mWatchingForPull=mScrollAdapter != null && isInside(mScrollAdapter.getHostView(),x,y);
  mResizedView=findView(x,y);
mInitialTouchX=ev.getX();
mInitialTouchY=ev.getY();
break;
case MotionEvent.ACTION_MOVE:
{
if (mWatchingForPull) {
final float yDiff=ev.getRawY() - mInitialTouchY;
final float xDiff=ev.getRawX() - mInitialTouchX;
if (yDiff > mTouchSlop && yDiff > Math.abs(xDiff)) {
if (DEBUG) Log.v(TAG,""String_Node_Str"" + yDiff + ""String_Node_Str"");
mWatchingForPull=false;
if (mResizedView != null && !isFullyExpanded(mResizedView)) {
  if (startExpanding(mResizedView,BLINDS)) {
    mInitialTouchY=ev.getRawY();
    mLastMotionY=ev.getRawY();
    mHasPopped=false;
  }
}
}
}
if (mExpanding && 0 != (mExpansionStyle & BLINDS)) {
final float rawHeight=ev.getRawY() - mLastMotionY + mCurrentHeight;
final float newHeight=clamp(rawHeight);
boolean isFinished=false;
boolean expanded=false;
if (rawHeight > mNaturalHeight) {
isFinished=true;
expanded=true;
}
if (rawHeight < mSmallSize) {
isFinished=true;
expanded=false;
}
if (!mHasPopped) {
if (mEventSource != null) {
  mEventSource.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
}
mHasPopped=true;
}
mScaler.setHeight(newHeight);
mLastMotionY=ev.getRawY();
if (isFinished) {
mCallback.expansionStateChanged(false);
}
 else {
mCallback.expansionStateChanged(true);
}
return true;
}
if (mExpanding) {
updateExpansion();
mLastMotionY=ev.getRawY();
return true;
}
break;
}
case MotionEvent.ACTION_POINTER_UP:
case MotionEvent.ACTION_POINTER_DOWN:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
mInitialTouchY+=mSGD.getFocusY() - mLastFocusY;
mInitialTouchSpan+=mSGD.getCurrentSpan() - mLastSpanY;
break;
case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_CANCEL:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
finishExpanding(false,getCurrentVelocity());
clearView();
break;
}
mLastMotionY=ev.getRawY();
maybeRecycleVelocityTracker(ev);
return mResizedView != null;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return false;
  }
  trackVelocity(ev);
  final int action=ev.getActionMasked();
  if (DEBUG_SCALE)   Log.d(TAG,""String_Node_Str"" + MotionEvent.actionToString(action) + ""String_Node_Str""+ mExpanding+ (0 != (mExpansionStyle & BLINDS) ? ""String_Node_Str"" : ""String_Node_Str"")+ (0 != (mExpansionStyle & PULL) ? ""String_Node_Str"" : ""String_Node_Str"")+ (0 != (mExpansionStyle & STRETCH) ? ""String_Node_Str"" : ""String_Node_Str""));
  mSGD.onTouchEvent(ev);
  final int x=(int)mSGD.getFocusX();
  final int y=(int)mSGD.getFocusY();
  if (mOnlyMovements) {
    mLastMotionY=ev.getRawY();
    return false;
  }
switch (action) {
case MotionEvent.ACTION_DOWN:
    mWatchingForPull=mScrollAdapter != null && isInside(mScrollAdapter.getHostView(),x,y);
  mResizedView=findView(x,y);
mInitialTouchX=ev.getRawX();
mInitialTouchY=ev.getRawY();
break;
case MotionEvent.ACTION_MOVE:
{
if (mWatchingForPull) {
final float yDiff=ev.getRawY() - mInitialTouchY;
final float xDiff=ev.getRawX() - mInitialTouchX;
if (yDiff > mTouchSlop && yDiff > Math.abs(xDiff)) {
if (DEBUG) Log.v(TAG,""String_Node_Str"" + yDiff + ""String_Node_Str"");
mWatchingForPull=false;
if (mResizedView != null && !isFullyExpanded(mResizedView)) {
  if (startExpanding(mResizedView,BLINDS)) {
    mInitialTouchY=ev.getRawY();
    mLastMotionY=ev.getRawY();
    mHasPopped=false;
  }
}
}
}
if (mExpanding && 0 != (mExpansionStyle & BLINDS)) {
final float rawHeight=ev.getRawY() - mLastMotionY + mCurrentHeight;
final float newHeight=clamp(rawHeight);
boolean isFinished=false;
boolean expanded=false;
if (rawHeight > mNaturalHeight) {
isFinished=true;
expanded=true;
}
if (rawHeight < mSmallSize) {
isFinished=true;
expanded=false;
}
if (!mHasPopped) {
if (mEventSource != null) {
  mEventSource.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
}
mHasPopped=true;
}
mScaler.setHeight(newHeight);
mLastMotionY=ev.getRawY();
if (isFinished) {
mCallback.expansionStateChanged(false);
}
 else {
mCallback.expansionStateChanged(true);
}
return true;
}
if (mExpanding) {
updateExpansion();
mLastMotionY=ev.getRawY();
return true;
}
break;
}
case MotionEvent.ACTION_POINTER_UP:
case MotionEvent.ACTION_POINTER_DOWN:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
mInitialTouchY+=mSGD.getFocusY() - mLastFocusY;
mInitialTouchSpan+=mSGD.getCurrentSpan() - mLastSpanY;
break;
case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_CANCEL:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
finishExpanding(false,getCurrentVelocity());
clearView();
break;
}
mLastMotionY=ev.getRawY();
maybeRecycleVelocityTracker(ev);
return mResizedView != null;
}",0.9988696307460436
192046,"private SubscriptionInfo addSignalController(int id,int simSlotIndex){
  SubscriptionInfo info=new SubscriptionInfo(id,""String_Node_Str"",simSlotIndex,""String_Node_Str"",""String_Node_Str"",0,0,""String_Node_Str"",0,null,0,0,""String_Node_Str"");
  mMobileSignalControllers.put(id,new MobileSignalController(mContext,mConfig,mHasMobileDataFeature,mPhone,mCallbackHandler,this,info,mSubDefaults,mReceiverHandler.getLooper()));
  return info;
}","private SubscriptionInfo addSignalController(int id,int simSlotIndex){
  SubscriptionInfo info=new SubscriptionInfo(id,""String_Node_Str"",simSlotIndex,""String_Node_Str"",""String_Node_Str"",0,0,""String_Node_Str"",0,null,0,0,""String_Node_Str"",SubscriptionManager.SIM_PROVISIONED);
  mMobileSignalControllers.put(id,new MobileSignalController(mContext,mConfig,mHasMobileDataFeature,mPhone,mCallbackHandler,this,info,mSubDefaults,mReceiverHandler.getLooper()));
  return info;
}",0.9601769911504424
192047,"/** 
 * @hide
 */
public SubscriptionInfo(int id,String iccId,int simSlotIndex,CharSequence displayName,CharSequence carrierName,int nameSource,int iconTint,String number,int roaming,Bitmap icon,int mcc,int mnc,String countryIso){
  this.mId=id;
  this.mIccId=iccId;
  this.mSimSlotIndex=simSlotIndex;
  this.mDisplayName=displayName;
  this.mCarrierName=carrierName;
  this.mNameSource=nameSource;
  this.mIconTint=iconTint;
  this.mNumber=number;
  this.mDataRoaming=roaming;
  this.mIconBitmap=icon;
  this.mMcc=mcc;
  this.mMnc=mnc;
  this.mCountryIso=countryIso;
}","/** 
 * @hide
 */
public SubscriptionInfo(int id,String iccId,int simSlotIndex,CharSequence displayName,CharSequence carrierName,int nameSource,int iconTint,String number,int roaming,Bitmap icon,int mcc,int mnc,String countryIso,int simProvisioningStatus){
  this.mId=id;
  this.mIccId=iccId;
  this.mSimSlotIndex=simSlotIndex;
  this.mDisplayName=displayName;
  this.mCarrierName=carrierName;
  this.mNameSource=nameSource;
  this.mIconTint=iconTint;
  this.mNumber=number;
  this.mDataRoaming=roaming;
  this.mIconBitmap=icon;
  this.mMcc=mcc;
  this.mMnc=mnc;
  this.mCountryIso=countryIso;
  this.mSimProvisioningStatus=simProvisioningStatus;
}",0.9350862777321282
192048,"@Override public SubscriptionInfo createFromParcel(Parcel source){
  int id=source.readInt();
  String iccId=source.readString();
  int simSlotIndex=source.readInt();
  CharSequence displayName=source.readCharSequence();
  CharSequence carrierName=source.readCharSequence();
  int nameSource=source.readInt();
  int iconTint=source.readInt();
  String number=source.readString();
  int dataRoaming=source.readInt();
  int mcc=source.readInt();
  int mnc=source.readInt();
  String countryIso=source.readString();
  Bitmap iconBitmap=Bitmap.CREATOR.createFromParcel(source);
  return new SubscriptionInfo(id,iccId,simSlotIndex,displayName,carrierName,nameSource,iconTint,number,dataRoaming,iconBitmap,mcc,mnc,countryIso);
}","@Override public SubscriptionInfo createFromParcel(Parcel source){
  int id=source.readInt();
  String iccId=source.readString();
  int simSlotIndex=source.readInt();
  CharSequence displayName=source.readCharSequence();
  CharSequence carrierName=source.readCharSequence();
  int nameSource=source.readInt();
  int iconTint=source.readInt();
  String number=source.readString();
  int dataRoaming=source.readInt();
  int mcc=source.readInt();
  int mnc=source.readInt();
  String countryIso=source.readString();
  int simProvisioningStatus=source.readInt();
  Bitmap iconBitmap=Bitmap.CREATOR.createFromParcel(source);
  return new SubscriptionInfo(id,iccId,simSlotIndex,displayName,carrierName,nameSource,iconTint,number,dataRoaming,iconBitmap,mcc,mnc,countryIso,simProvisioningStatus);
}",0.955026455026455
192049,"@Override public String toString(){
  String iccIdToPrint=givePrintableIccid(mIccId);
  return ""String_Node_Str"" + mId + ""String_Node_Str""+ iccIdToPrint+ ""String_Node_Str""+ mSimSlotIndex+ ""String_Node_Str""+ mDisplayName+ ""String_Node_Str""+ mCarrierName+ ""String_Node_Str""+ mNameSource+ ""String_Node_Str""+ mIconTint+ ""String_Node_Str""+ mDataRoaming+ ""String_Node_Str""+ mIconBitmap+ ""String_Node_Str""+ mMcc+ ""String_Node_Str""+ mMnc+ ""String_Node_Str"";
}","@Override public String toString(){
  String iccIdToPrint=givePrintableIccid(mIccId);
  return ""String_Node_Str"" + mId + ""String_Node_Str""+ iccIdToPrint+ ""String_Node_Str""+ mSimSlotIndex+ ""String_Node_Str""+ mDisplayName+ ""String_Node_Str""+ mCarrierName+ ""String_Node_Str""+ mNameSource+ ""String_Node_Str""+ mIconTint+ ""String_Node_Str""+ mDataRoaming+ ""String_Node_Str""+ mIconBitmap+ ""String_Node_Str""+ mMcc+ ""String_Node_Str""+ mMnc+ ""String_Node_Str""+ mSimProvisioningStatus+ ""String_Node_Str"";
}",0.9544973544973544
192050,"@Override public void writeToParcel(Parcel dest,int flags){
  dest.writeInt(mId);
  dest.writeString(mIccId);
  dest.writeInt(mSimSlotIndex);
  dest.writeCharSequence(mDisplayName);
  dest.writeCharSequence(mCarrierName);
  dest.writeInt(mNameSource);
  dest.writeInt(mIconTint);
  dest.writeString(mNumber);
  dest.writeInt(mDataRoaming);
  dest.writeInt(mMcc);
  dest.writeInt(mMnc);
  dest.writeString(mCountryIso);
  mIconBitmap.writeToParcel(dest,flags);
}","@Override public void writeToParcel(Parcel dest,int flags){
  dest.writeInt(mId);
  dest.writeString(mIccId);
  dest.writeInt(mSimSlotIndex);
  dest.writeCharSequence(mDisplayName);
  dest.writeCharSequence(mCarrierName);
  dest.writeInt(mNameSource);
  dest.writeInt(mIconTint);
  dest.writeString(mNumber);
  dest.writeInt(mDataRoaming);
  dest.writeInt(mMcc);
  dest.writeInt(mMnc);
  dest.writeString(mCountryIso);
  dest.writeInt(mSimProvisioningStatus);
  mIconBitmap.writeToParcel(dest,flags);
}",0.9574247144340602
192051,"/** 
 * Composes the animation specs for all the tasks in the target stack.
 */
private List<AppTransitionAnimationSpec> composeAnimationSpecs(final Task task,final TaskStackView stackView,final int destinationStack){
  final int targetStackId=destinationStack != INVALID_STACK_ID ? destinationStack : task.key.stackId;
  if (!StackId.useAnimationSpecForAppTransition(targetStackId)) {
    return null;
  }
  float stackScroll=stackView.getScroller().getStackScroll();
  TaskView taskView=stackView.getChildViewForTask(task);
  TaskStackLayoutAlgorithm layoutAlgorithm=stackView.getStackAlgorithm();
  Rect offscreenTaskRect=new Rect(layoutAlgorithm.mTaskRect);
  offscreenTaskRect.offsetTo(offscreenTaskRect.left,layoutAlgorithm.mStackRect.bottom);
  List<AppTransitionAnimationSpec> specs=new ArrayList<>();
  if (targetStackId == FULLSCREEN_WORKSPACE_STACK_ID || targetStackId == DOCKED_STACK_ID || targetStackId == INVALID_STACK_ID) {
    if (taskView == null) {
      specs.add(composeOffscreenAnimationSpec(task,offscreenTaskRect));
    }
 else {
      layoutAlgorithm.getStackTransformScreenCoordinates(task,stackScroll,mTmpTransform,null);
      specs.add(composeAnimationSpec(stackView,taskView,mTmpTransform,true));
    }
    return specs;
  }
  TaskStack stack=stackView.getStack();
  ArrayList<Task> tasks=stack.getStackTasks();
  int taskCount=tasks.size();
  for (int i=taskCount - 1; i >= 0; i--) {
    Task t=tasks.get(i);
    if (t.isFreeformTask() || targetStackId == FREEFORM_WORKSPACE_STACK_ID) {
      TaskView tv=stackView.getChildViewForTask(t);
      if (tv == null) {
        specs.add(composeOffscreenAnimationSpec(t,offscreenTaskRect));
      }
 else {
        layoutAlgorithm.getStackTransformScreenCoordinates(t,stackScroll,mTmpTransform,null);
        specs.add(composeAnimationSpec(stackView,tv,mTmpTransform,true));
      }
    }
  }
  return specs;
}","/** 
 * Composes the animation specs for all the tasks in the target stack.
 */
private List<AppTransitionAnimationSpec> composeAnimationSpecs(final Task task,final TaskStackView stackView,final int destinationStack){
  final int targetStackId=destinationStack != INVALID_STACK_ID ? destinationStack : task.key.stackId;
  if (!StackId.useAnimationSpecForAppTransition(targetStackId)) {
    return null;
  }
  float stackScroll=stackView.getScroller().getStackScroll();
  TaskView taskView=stackView.getChildViewForTask(task);
  TaskStackLayoutAlgorithm stackLayout=stackView.getStackAlgorithm();
  Rect offscreenTaskRect=new Rect();
  stackLayout.getFrontOfStackTransform().rect.round(offscreenTaskRect);
  List<AppTransitionAnimationSpec> specs=new ArrayList<>();
  if (targetStackId == FULLSCREEN_WORKSPACE_STACK_ID || targetStackId == DOCKED_STACK_ID || targetStackId == INVALID_STACK_ID) {
    if (taskView == null) {
      specs.add(composeOffscreenAnimationSpec(task,offscreenTaskRect));
    }
 else {
      mTmpTransform.fillIn(taskView);
      stackLayout.transformToScreenCoordinates(mTmpTransform);
      specs.add(composeAnimationSpec(stackView,taskView,mTmpTransform,true));
    }
    return specs;
  }
  TaskStack stack=stackView.getStack();
  ArrayList<Task> tasks=stack.getStackTasks();
  int taskCount=tasks.size();
  for (int i=taskCount - 1; i >= 0; i--) {
    Task t=tasks.get(i);
    if (t.isFreeformTask() || targetStackId == FREEFORM_WORKSPACE_STACK_ID) {
      TaskView tv=stackView.getChildViewForTask(t);
      if (tv == null) {
        specs.add(composeOffscreenAnimationSpec(t,offscreenTaskRect));
      }
 else {
        mTmpTransform.fillIn(taskView);
        stackLayout.transformToScreenCoordinates(mTmpTransform);
        specs.add(composeAnimationSpec(stackView,tv,mTmpTransform,true));
      }
    }
  }
  return specs;
}",0.8485821294810059
192052,"/** 
 * Like   {@link #getStackTransform}, but in screen coordinates
 */
public TaskViewTransform getStackTransformScreenCoordinates(Task task,float stackScroll,TaskViewTransform transformOut,TaskViewTransform frontTransform){
  Rect windowRect=Recents.getSystemServices().getWindowRect();
  TaskViewTransform transform=getStackTransform(task,stackScroll,mFocusState,transformOut,frontTransform,true,false);
  transform.rect.offset(windowRect.left,windowRect.top);
  return transform;
}","/** 
 * Like   {@link #getStackTransform}, but in screen coordinates
 */
public TaskViewTransform getStackTransformScreenCoordinates(Task task,float stackScroll,TaskViewTransform transformOut,TaskViewTransform frontTransform){
  TaskViewTransform transform=getStackTransform(task,stackScroll,mFocusState,transformOut,frontTransform,true,false);
  return transformToScreenCoordinates(transform);
}",0.5600907029478458
192053,"/** 
 * Computes the stack and task rects.  The given task stack bounds already has the top/right insets and left/right padding already applied.
 */
public void initialize(Rect windowRect,Rect taskStackBounds,StackState state){
  SystemServicesProxy ssp=Recents.getSystemServices();
  Rect lastStackRect=new Rect(mStackRect);
  Rect displayRect=ssp.getDisplayRect();
  int topMargin=getScaleForExtent(windowRect,displayRect,mBaseTopMargin,mMinMargin,HEIGHT);
  int bottomMargin=getScaleForExtent(windowRect,displayRect,mBaseBottomMargin,mMinMargin,HEIGHT);
  mInitialTopOffset=getScaleForExtent(windowRect,displayRect,mBaseInitialTopOffset,mMinMargin,HEIGHT);
  mInitialBottomOffset=mBaseInitialBottomOffset;
  mState=state;
  mStackBottomOffset=mSystemInsets.bottom + bottomMargin;
  state.computeRects(mFreeformRect,mStackRect,taskStackBounds,topMargin,mFreeformStackGap,mStackBottomOffset);
  mStackActionButtonRect.set(mStackRect.left,mStackRect.top - topMargin,mStackRect.right,mStackRect.top + mFocusedTopPeekHeight);
  float aspect=(float)(windowRect.width() - (mSystemInsets.left + mSystemInsets.right)) / (windowRect.height() - (mSystemInsets.top + mSystemInsets.bottom));
  int minHeight=mStackRect.height() - mInitialTopOffset - mStackBottomOffset;
  int height=(int)Math.min(mStackRect.width() / aspect,minHeight);
  mTaskRect.set(mStackRect.left,mStackRect.top,mStackRect.right,mStackRect.top + height);
  if (!lastStackRect.equals(mStackRect)) {
    mUnfocusedCurve=constructUnfocusedCurve();
    mUnfocusedCurveInterpolator=new FreePathInterpolator(mUnfocusedCurve);
    mFocusedCurve=constructFocusedCurve();
    mFocusedCurveInterpolator=new FreePathInterpolator(mFocusedCurve);
    mUnfocusedDimCurve=constructUnfocusedDimCurve();
    mUnfocusedDimCurveInterpolator=new FreePathInterpolator(mUnfocusedDimCurve);
    mFocusedDimCurve=constructFocusedDimCurve();
    mFocusedDimCurveInterpolator=new FreePathInterpolator(mFocusedDimCurve);
    updateFrontBackTransforms();
  }
}","/** 
 * Computes the stack and task rects.  The given task stack bounds already has the top/right insets and left/right padding already applied.
 */
public void initialize(Rect windowRect,Rect taskStackBounds,StackState state){
  SystemServicesProxy ssp=Recents.getSystemServices();
  Rect lastStackRect=new Rect(mStackRect);
  Rect displayRect=ssp.getDisplayRect();
  int topMargin=getScaleForExtent(windowRect,displayRect,mBaseTopMargin,mMinMargin,HEIGHT);
  int bottomMargin=getScaleForExtent(windowRect,displayRect,mBaseBottomMargin,mMinMargin,HEIGHT);
  mInitialTopOffset=getScaleForExtent(windowRect,displayRect,mBaseInitialTopOffset,mMinMargin,HEIGHT);
  mInitialBottomOffset=mBaseInitialBottomOffset;
  mState=state;
  mStackBottomOffset=mSystemInsets.bottom + bottomMargin;
  state.computeRects(mFreeformRect,mStackRect,taskStackBounds,topMargin,mFreeformStackGap,mStackBottomOffset);
  mStackActionButtonRect.set(mStackRect.left,mStackRect.top - topMargin,mStackRect.right,mStackRect.top + mFocusedTopPeekHeight);
  int height=mStackRect.height() - mInitialTopOffset - mStackBottomOffset;
  mTaskRect.set(mStackRect.left,mStackRect.top,mStackRect.right,mStackRect.top + height);
  if (!lastStackRect.equals(mStackRect)) {
    mUnfocusedCurve=constructUnfocusedCurve();
    mUnfocusedCurveInterpolator=new FreePathInterpolator(mUnfocusedCurve);
    mFocusedCurve=constructFocusedCurve();
    mFocusedCurveInterpolator=new FreePathInterpolator(mFocusedCurve);
    mUnfocusedDimCurve=constructUnfocusedDimCurve();
    mUnfocusedDimCurveInterpolator=new FreePathInterpolator(mUnfocusedDimCurve);
    mFocusedDimCurve=constructFocusedDimCurve();
    mFocusedDimCurveInterpolator=new FreePathInterpolator(mFocusedDimCurve);
    updateFrontBackTransforms();
  }
}",0.5622340425531915
192054,"protected void handleError(long deviceId,int error){
  ClientMonitor client=mCurrentClient;
  if (client != null && client.onError(error)) {
    removeClient(client);
  }
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"" + client != null ? client.getOwnerString() : ""String_Node_Str"" + ""String_Node_Str"" + error + ""String_Node_Str"");
  if (error == FingerprintManager.FINGERPRINT_ERROR_CANCELED) {
    mHandler.removeCallbacks(mResetClientState);
    if (mPendingClient != null) {
      if (DEBUG)       Slog.v(TAG,""String_Node_Str"" + mPendingClient.getOwnerString());
      startClient(mPendingClient,false);
      mPendingClient=null;
    }
  }
}","protected void handleError(long deviceId,int error){
  ClientMonitor client=mCurrentClient;
  if (client != null && client.onError(error)) {
    removeClient(client);
  }
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"" + (client != null ? client.getOwnerString() : ""String_Node_Str"") + ""String_Node_Str""+ error+ ""String_Node_Str"");
  if (error == FingerprintManager.FINGERPRINT_ERROR_CANCELED) {
    mHandler.removeCallbacks(mResetClientState);
    if (mPendingClient != null) {
      if (DEBUG)       Slog.v(TAG,""String_Node_Str"" + mPendingClient.getOwnerString());
      startClient(mPendingClient,false);
      mPendingClient=null;
    }
  }
}",0.9968847352024922
192055,"protected void handleError(long deviceId,int error){
  ClientMonitor client=mCurrentClient;
  if (client != null && client.onError(error)) {
    removeClient(client);
  }
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"" + client != null ? client.getOwnerString() : ""String_Node_Str"" + ""String_Node_Str"" + error + ""String_Node_Str"");
  if (error == FingerprintManager.FINGERPRINT_ERROR_CANCELED) {
    mHandler.removeCallbacks(mResetClientState);
    if (mPendingClient != null) {
      if (DEBUG)       Slog.v(TAG,""String_Node_Str"" + mPendingClient.getOwnerString());
      startClient(mPendingClient,false);
      mPendingClient=null;
    }
  }
}","protected void handleError(long deviceId,int error){
  ClientMonitor client=mCurrentClient;
  if (client != null && client.onError(error)) {
    removeClient(client);
  }
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"" + (client != null ? client.getOwnerString() : ""String_Node_Str"") + ""String_Node_Str""+ error+ ""String_Node_Str"");
  if (error == FingerprintManager.FINGERPRINT_ERROR_CANCELED) {
    mHandler.removeCallbacks(mResetClientState);
    if (mPendingClient != null) {
      if (DEBUG)       Slog.v(TAG,""String_Node_Str"" + mPendingClient.getOwnerString());
      startClient(mPendingClient,false);
      mPendingClient=null;
    }
  }
}",0.9968847352024922
192056,"protected void handleError(long deviceId,int error){
  ClientMonitor client=mCurrentClient;
  if (client != null && client.onError(error)) {
    removeClient(client);
  }
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"" + client != null ? client.getOwnerString() : ""String_Node_Str"" + ""String_Node_Str"" + error + ""String_Node_Str"");
  if (error == FingerprintManager.FINGERPRINT_ERROR_CANCELED) {
    mHandler.removeCallbacks(mResetClientState);
    if (mPendingClient != null) {
      if (DEBUG)       Slog.v(TAG,""String_Node_Str"" + mPendingClient.getOwnerString());
      startClient(mPendingClient,false);
      mPendingClient=null;
    }
  }
}","protected void handleError(long deviceId,int error){
  ClientMonitor client=mCurrentClient;
  if (client != null && client.onError(error)) {
    removeClient(client);
  }
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"" + (client != null ? client.getOwnerString() : ""String_Node_Str"") + ""String_Node_Str""+ error+ ""String_Node_Str"");
  if (error == FingerprintManager.FINGERPRINT_ERROR_CANCELED) {
    mHandler.removeCallbacks(mResetClientState);
    if (mPendingClient != null) {
      if (DEBUG)       Slog.v(TAG,""String_Node_Str"" + mPendingClient.getOwnerString());
      startClient(mPendingClient,false);
      mPendingClient=null;
    }
  }
}",0.9968847352024922
192057,"protected void handleError(long deviceId,int error){
  ClientMonitor client=mCurrentClient;
  if (client != null && client.onError(error)) {
    removeClient(client);
  }
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"" + client != null ? client.getOwnerString() : ""String_Node_Str"" + ""String_Node_Str"" + error + ""String_Node_Str"");
  if (error == FingerprintManager.FINGERPRINT_ERROR_CANCELED) {
    mHandler.removeCallbacks(mResetClientState);
    if (mPendingClient != null) {
      if (DEBUG)       Slog.v(TAG,""String_Node_Str"" + mPendingClient.getOwnerString());
      startClient(mPendingClient,false);
      mPendingClient=null;
    }
  }
}","protected void handleError(long deviceId,int error){
  ClientMonitor client=mCurrentClient;
  if (client != null && client.onError(error)) {
    removeClient(client);
  }
  if (DEBUG)   Slog.v(TAG,""String_Node_Str"" + (client != null ? client.getOwnerString() : ""String_Node_Str"") + ""String_Node_Str""+ error+ ""String_Node_Str"");
  if (error == FingerprintManager.FINGERPRINT_ERROR_CANCELED) {
    mHandler.removeCallbacks(mResetClientState);
    if (mPendingClient != null) {
      if (DEBUG)       Slog.v(TAG,""String_Node_Str"" + mPendingClient.getOwnerString());
      startClient(mPendingClient,false);
      mPendingClient=null;
    }
  }
}",0.9968847352024922
192058,"public void onNotificationUpdated(NotificationData.Entry entry){
  mEntry=entry;
  mStatusBarNotification=entry.notification;
  mPrivateLayout.onNotificationUpdated(entry);
  mPublicLayout.onNotificationUpdated(entry);
  mShowingPublicInitialized=false;
  updateClearability();
  if (mIsSummaryWithChildren) {
    recreateNotificationHeader();
    mChildrenContainer.onNotificationUpdated();
  }
  if (mIconAnimationRunning) {
    setIconAnimationRunning(true);
  }
  if (mNotificationParent != null) {
    mNotificationParent.updateChildrenHeaderAppearance();
  }
  onChildrenCountChanged();
  mPublicLayout.updateExpandButtons(true);
  updateLimits();
}","public void onNotificationUpdated(NotificationData.Entry entry){
  mEntry=entry;
  mStatusBarNotification=entry.notification;
  mPrivateLayout.onNotificationUpdated(entry);
  mPublicLayout.onNotificationUpdated(entry);
  mShowingPublicInitialized=false;
  updateNotificationColor();
  updateClearability();
  if (mIsSummaryWithChildren) {
    recreateNotificationHeader();
    mChildrenContainer.onNotificationUpdated();
  }
  if (mIconAnimationRunning) {
    setIconAnimationRunning(true);
  }
  if (mNotificationParent != null) {
    mNotificationParent.updateChildrenHeaderAppearance();
  }
  onChildrenCountChanged();
  mPublicLayout.updateExpandButtons(true);
  updateLimits();
}",0.9783420463032112
192059,"public int getNotificationColor(){
  int color=getStatusBarNotification().getNotification().color;
  if (color == Notification.COLOR_DEFAULT) {
    return mContext.getColor(com.android.internal.R.color.notification_icon_default_color);
  }
  return color;
}","public int getNotificationColor(){
  return mNotificationColor;
}",0.3850931677018633
192060,"public void reInflateViews(){
  initDimens();
  for (int i=0; i < mDividers.size(); i++) {
    View prevDivider=mDividers.get(i);
    int index=indexOfChild(prevDivider);
    removeView(prevDivider);
    View divider=inflateDivider();
    addView(divider,index);
    mDividers.set(i,divider);
  }
}","public void reInflateViews(){
  initDimens();
  for (int i=0; i < mDividers.size(); i++) {
    View prevDivider=mDividers.get(i);
    int index=indexOfChild(prevDivider);
    removeView(prevDivider);
    View divider=inflateDivider();
    addView(divider,index);
    mDividers.set(i,divider);
  }
  removeView(mOverflowNumber);
  mOverflowNumber=null;
  mOverflowInvertHelper=null;
  mGroupOverFlowState=null;
  updateGroupOverflow();
}",0.8119891008174387
192061,"public void onNotificationUpdated(NotificationData.Entry entry){
  mEntry=entry;
  mStatusBarNotification=entry.notification;
  mPrivateLayout.onNotificationUpdated(entry);
  mPublicLayout.onNotificationUpdated(entry);
  mShowingPublicInitialized=false;
  updateClearability();
  if (mIsSummaryWithChildren) {
    recreateNotificationHeader();
    mChildrenContainer.onNotificationUpdated();
  }
  if (mIconAnimationRunning) {
    setIconAnimationRunning(true);
  }
  if (mNotificationParent != null) {
    mNotificationParent.updateChildrenHeaderAppearance();
  }
  onChildrenCountChanged();
  mPublicLayout.updateExpandButtons(true);
  updateLimits();
}","public void onNotificationUpdated(NotificationData.Entry entry){
  mEntry=entry;
  mStatusBarNotification=entry.notification;
  mPrivateLayout.onNotificationUpdated(entry);
  mPublicLayout.onNotificationUpdated(entry);
  mShowingPublicInitialized=false;
  updateNotificationColor();
  updateClearability();
  if (mIsSummaryWithChildren) {
    recreateNotificationHeader();
    mChildrenContainer.onNotificationUpdated();
  }
  if (mIconAnimationRunning) {
    setIconAnimationRunning(true);
  }
  if (mNotificationParent != null) {
    mNotificationParent.updateChildrenHeaderAppearance();
  }
  onChildrenCountChanged();
  mPublicLayout.updateExpandButtons(true);
  updateLimits();
}",0.9783420463032112
192062,"public int getNotificationColor(){
  int color=getStatusBarNotification().getNotification().color;
  if (color == Notification.COLOR_DEFAULT) {
    return mContext.getColor(com.android.internal.R.color.notification_icon_default_color);
  }
  return color;
}","public int getNotificationColor(){
  return mNotificationColor;
}",0.3850931677018633
192063,"public void reInflateViews(){
  initDimens();
  for (int i=0; i < mDividers.size(); i++) {
    View prevDivider=mDividers.get(i);
    int index=indexOfChild(prevDivider);
    removeView(prevDivider);
    View divider=inflateDivider();
    addView(divider,index);
    mDividers.set(i,divider);
  }
}","public void reInflateViews(){
  initDimens();
  for (int i=0; i < mDividers.size(); i++) {
    View prevDivider=mDividers.get(i);
    int index=indexOfChild(prevDivider);
    removeView(prevDivider);
    View divider=inflateDivider();
    addView(divider,index);
    mDividers.set(i,divider);
  }
  removeView(mOverflowNumber);
  mOverflowNumber=null;
  mOverflowInvertHelper=null;
  mGroupOverFlowState=null;
  updateGroupOverflow();
}",0.8119891008174387
192064,"private DhcpErrorEvent(Parcel in){
  this.errorCode=in.readInt();
}","private DhcpErrorEvent(Parcel in){
  this.ifName=in.readString();
  this.errorCode=in.readInt();
}",0.8121212121212121
192065,"public void writeToParcel(Parcel out,int flags){
  out.writeInt(errorCode);
}","public void writeToParcel(Parcel out,int flags){
  out.writeString(ifName);
  out.writeInt(errorCode);
}",0.850828729281768
192066,"@Override public void run(){
  if (DBG)   Log.d(TAG,""String_Node_Str"");
  while (!mStopped) {
    int length=0;
    try {
      length=Os.read(mPacketSock,mPacket,0,mPacket.length);
      DhcpPacket packet=null;
      packet=DhcpPacket.decodeFullPacket(mPacket,length,DhcpPacket.ENCAP_L2);
      if (DBG)       Log.d(TAG,""String_Node_Str"" + packet);
      sendMessage(CMD_RECEIVED_PACKET,packet);
    }
 catch (    IOException|ErrnoException e) {
      if (!mStopped) {
        Log.e(TAG,""String_Node_Str"",e);
      }
      DhcpClientEvent.logEvent(IpConnectivityEvent.IPCE_DHCP_RECV_ERROR,mIfaceName,e.getMessage());
    }
catch (    DhcpPacket.ParseException e) {
      Log.e(TAG,""String_Node_Str"" + e.getMessage());
      if (PACKET_DBG) {
        Log.d(TAG,HexDump.dumpHexString(mPacket,0,length));
      }
      DhcpClientEvent.logEvent(IpConnectivityEvent.IPCE_DHCP_PARSE_ERROR,mIfaceName,e.getMessage());
    }
  }
  if (DBG)   Log.d(TAG,""String_Node_Str"");
}","@Override public void run(){
  if (DBG)   Log.d(TAG,""String_Node_Str"");
  while (!mStopped) {
    int length=0;
    try {
      length=Os.read(mPacketSock,mPacket,0,mPacket.length);
      DhcpPacket packet=null;
      packet=DhcpPacket.decodeFullPacket(mPacket,length,DhcpPacket.ENCAP_L2);
      if (DBG)       Log.d(TAG,""String_Node_Str"" + packet);
      sendMessage(CMD_RECEIVED_PACKET,packet);
    }
 catch (    IOException|ErrnoException e) {
      if (!mStopped) {
        Log.e(TAG,""String_Node_Str"",e);
      }
      DhcpErrorEvent.logReceiveError(mIfaceName);
    }
catch (    DhcpPacket.ParseException e) {
      Log.e(TAG,""String_Node_Str"" + e.getMessage());
      if (PACKET_DBG) {
        Log.d(TAG,HexDump.dumpHexString(mPacket,0,length));
      }
      DhcpErrorEvent.logParseError(mIfaceName,e.errorCode);
    }
  }
  if (DBG)   Log.d(TAG,""String_Node_Str"");
}",0.9060293318848452
192067,"public ParseException(String msg,Object... args){
  super(String.format(msg,args));
}","public ParseException(int errorCode,String msg,Object... args){
  super(String.format(msg,args));
  this.errorCode=errorCode;
}",0.8018867924528302
192068,"public CaptivePortalCheckResultEvent(Parcel in){
  mNetId=in.readInt();
  mResult=in.readInt();
}","private CaptivePortalCheckResultEvent(Parcel in){
  this.netId=in.readInt();
  this.result=in.readInt();
}",0.8768472906403941
192069,"public void writeToParcel(Parcel out,int flags){
  out.writeInt(mNetId);
  out.writeInt(mResult);
}","public void writeToParcel(Parcel out,int flags){
  out.writeInt(netId);
  out.writeInt(result);
}",0.9693877551020408
192070,"public static void logEvent(int netId,int result){
  IpConnectivityEvent.logEvent(IpConnectivityEvent.IPCE_NETMON_CHECK_RESULT,new CaptivePortalCheckResultEvent(netId,result));
}","public static void logEvent(int netId,int result){
  logEvent(IPCE_NETMON_CHECK_RESULT,new CaptivePortalCheckResultEvent(netId,result));
}",0.8734177215189873
192071,"public CaptivePortalStateChangeEvent(Parcel in){
  mState=in.readInt();
}","public CaptivePortalStateChangeEvent(Parcel in){
  state=in.readInt();
}",0.9793103448275862
192072,"public void writeToParcel(Parcel out,int flags){
  out.writeInt(mState);
}","public void writeToParcel(Parcel out,int flags){
  out.writeInt(state);
}",0.979591836734694
192073,"public static void logEvent(int state){
  IpConnectivityEvent.logEvent(IpConnectivityEvent.IPCE_NETMON_STATE_CHANGE,new CaptivePortalStateChangeEvent(state));
}","public static void logEvent(int state){
  logEvent(IPCE_NETMON_STATE_CHANGE,new CaptivePortalStateChangeEvent(state));
}",0.8571428571428571
192074,"public void writeToParcel(Parcel out,int flags){
  out.writeInt(mNetId);
  out.writeIntArray(mTransportTypes);
  out.writeInt(mPrevNetId);
  out.writeByte(mPrevIPv4 ? (byte)1 : (byte)0);
  out.writeByte(mPrevIPv6 ? (byte)1 : (byte)0);
}","public void writeToParcel(Parcel out,int flags){
  out.writeInt(netId);
  out.writeIntArray(transportTypes);
  out.writeInt(prevNetId);
  out.writeByte(prevIPv4 ? (byte)1 : (byte)0);
  out.writeByte(prevIPv6 ? (byte)1 : (byte)0);
}",0.7066381156316917
192075,"public ConnectivityServiceChangeEvent(Parcel in){
  mNetId=in.readInt();
  mTransportTypes=in.createIntArray();
  mPrevNetId=in.readInt();
  mPrevIPv4=(in.readByte() > 0);
  mPrevIPv6=(in.readByte() > 0);
}","private ConnectivityServiceChangeEvent(Parcel in){
  this.netId=in.readInt();
  this.transportTypes=in.createIntArray();
  this.prevNetId=in.readInt();
  this.prevIPv4=(in.readByte() > 0);
  this.prevIPv6=(in.readByte() > 0);
}",0.4341801385681293
192076,"public static void logEvent(int netId,int[] transportTypes,int prevNetId,boolean prevIPv4,boolean prevIPv6){
  IpConnectivityEvent.logEvent(IpConnectivityEvent.IPCE_CONSRV_DEFAULT_NET_CHANGE,new ConnectivityServiceChangeEvent(netId,transportTypes,prevNetId,prevIPv4,prevIPv6));
}","public static void logEvent(int netId,int[] transportTypes,int prevNetId,boolean prevIPv4,boolean prevIPv6){
  logEvent(IPCE_CONSRV_DEFAULT_NET_CHANGE,new ConnectivityServiceChangeEvent(netId,transportTypes,prevNetId,prevIPv4,prevIPv6));
}",0.9227799227799228
192077,"public static void logStateEvent(String ifName,String state){
  logEvent(IpConnectivityEvent.IPCE_DHCP_STATE_CHANGE,new DhcpClientEvent(ifName,state));
}","public static void logStateEvent(String ifName,String state){
  logEvent(IPCE_DHCP_STATE_CHANGE,new DhcpClientEvent(ifName,state));
}",0.93006993006993
192078,"public DhcpClientEvent(Parcel in){
  mIfName=in.readString();
  mMsg=in.readString();
}","private DhcpClientEvent(Parcel in){
  this.ifName=in.readString();
  this.msg=in.readString();
}",0.8743169398907104
192079,"public void writeToParcel(Parcel out,int flags){
  out.writeString(mIfName);
  out.writeString(mMsg);
}","public void writeToParcel(Parcel out,int flags){
  out.writeString(ifName);
  out.writeString(msg);
}",0.9803921568627452
192080,"public static void logParseError(String ifName,int errorCode){
  IpConnectivityEvent.logEvent(IPCE_DHCP_PARSE_ERROR,new DhcpErrorEvent(ifName,errorCode));
}","public static void logParseError(String ifName,int errorCode){
  logEvent(IPCE_DHCP_PARSE_ERROR,new DhcpErrorEvent(ifName,errorCode));
}",0.9315068493150684
192081,"private DnsEvent(Parcel in){
  netId=in.readInt();
  eventTypes=in.createByteArray();
  returnCodes=in.createByteArray();
  latenciesMs=in.createIntArray();
}","private DnsEvent(Parcel in){
  this.netId=in.readInt();
  this.eventTypes=in.createByteArray();
  this.returnCodes=in.createByteArray();
  this.latenciesMs=in.createIntArray();
}",0.9404761904761904
192082,"public static void logEvent(int netId,byte[] eventTypes,byte[] returnCodes,int[] latenciesMs){
  IpConnectivityEvent.logEvent(IPCE_DNS_LOOKUPS,new DnsEvent(netId,eventTypes,returnCodes,latenciesMs));
}","public static void logEvent(int netId,byte[] eventTypes,byte[] returnCodes,int[] latenciesMs){
  logEvent(IPCE_DNS_LOOKUPS,new DnsEvent(netId,eventTypes,returnCodes,latenciesMs));
}",0.9476439790575916
192083,"public static void logEvent(int tag,IpConnectivityEvent event){
  long timestamp=System.currentTimeMillis();
  mMetricsLogger.logEvent(timestamp,ConnectivityMetricsLogger.COMPONENT_TAG_CONNECTIVITY,tag,event);
}","public static <T extends IpConnectivityEvent & Parcelable>void logEvent(int tag,T event){
  final long timestamp=System.currentTimeMillis();
  final int componentTag=ConnectivityMetricsLogger.COMPONENT_TAG_CONNECTIVITY;
  mMetricsLogger.logEvent(timestamp,componentTag,tag,event);
}",0.6288032454361054
192084,"public IpManagerEvent(Parcel in){
  mIfName=in.readString();
  mDurationMs=in.readLong();
}","private IpManagerEvent(Parcel in){
  this.ifName=in.readString();
  this.durationMs=in.readLong();
}",0.8691099476439791
192085,"public void writeToParcel(Parcel out,int flags){
  out.writeString(mIfName);
  out.writeLong(mDurationMs);
}","public void writeToParcel(Parcel out,int flags){
  out.writeString(ifName);
  out.writeLong(durationMs);
}",0.97196261682243
192086,"public static void logEvent(int eventType,String ifName,long durationMs){
  IpConnectivityEvent.logEvent(eventType,new IpManagerEvent(ifName,durationMs));
}","public static void logEvent(int eventType,String ifName,long durationMs){
  logEvent(eventType,new IpManagerEvent(ifName,durationMs));
}",0.9315068493150684
192087,"public CaptivePortalCheckResultEvent(Parcel in){
  mNetId=in.readInt();
  mResult=in.readInt();
}","private CaptivePortalCheckResultEvent(Parcel in){
  this.netId=in.readInt();
  this.result=in.readInt();
}",0.8768472906403941
192088,"public void writeToParcel(Parcel out,int flags){
  out.writeInt(mNetId);
  out.writeInt(mResult);
}","public void writeToParcel(Parcel out,int flags){
  out.writeInt(netId);
  out.writeInt(result);
}",0.9693877551020408
192089,"public static void logEvent(int netId,int result){
  IpConnectivityEvent.logEvent(IpConnectivityEvent.IPCE_NETMON_CHECK_RESULT,new CaptivePortalCheckResultEvent(netId,result));
}","public static void logEvent(int netId,int result){
  logEvent(IPCE_NETMON_CHECK_RESULT,new CaptivePortalCheckResultEvent(netId,result));
}",0.8734177215189873
192090,"public CaptivePortalStateChangeEvent(Parcel in){
  mState=in.readInt();
}","public CaptivePortalStateChangeEvent(Parcel in){
  state=in.readInt();
}",0.9793103448275862
192091,"public void writeToParcel(Parcel out,int flags){
  out.writeInt(mState);
}","public void writeToParcel(Parcel out,int flags){
  out.writeInt(state);
}",0.979591836734694
192092,"public static void logEvent(int state){
  IpConnectivityEvent.logEvent(IpConnectivityEvent.IPCE_NETMON_STATE_CHANGE,new CaptivePortalStateChangeEvent(state));
}","public static void logEvent(int state){
  logEvent(IPCE_NETMON_STATE_CHANGE,new CaptivePortalStateChangeEvent(state));
}",0.8571428571428571
192093,"public void writeToParcel(Parcel out,int flags){
  out.writeInt(mNetId);
  out.writeIntArray(mTransportTypes);
  out.writeInt(mPrevNetId);
  out.writeByte(mPrevIPv4 ? (byte)1 : (byte)0);
  out.writeByte(mPrevIPv6 ? (byte)1 : (byte)0);
}","public void writeToParcel(Parcel out,int flags){
  out.writeInt(netId);
  out.writeIntArray(transportTypes);
  out.writeInt(prevNetId);
  out.writeByte(prevIPv4 ? (byte)1 : (byte)0);
  out.writeByte(prevIPv6 ? (byte)1 : (byte)0);
}",0.7066381156316917
192094,"public ConnectivityServiceChangeEvent(Parcel in){
  mNetId=in.readInt();
  mTransportTypes=in.createIntArray();
  mPrevNetId=in.readInt();
  mPrevIPv4=(in.readByte() > 0);
  mPrevIPv6=(in.readByte() > 0);
}","private ConnectivityServiceChangeEvent(Parcel in){
  this.netId=in.readInt();
  this.transportTypes=in.createIntArray();
  this.prevNetId=in.readInt();
  this.prevIPv4=(in.readByte() > 0);
  this.prevIPv6=(in.readByte() > 0);
}",0.4341801385681293
192095,"public static void logEvent(int netId,int[] transportTypes,int prevNetId,boolean prevIPv4,boolean prevIPv6){
  IpConnectivityEvent.logEvent(IpConnectivityEvent.IPCE_CONSRV_DEFAULT_NET_CHANGE,new ConnectivityServiceChangeEvent(netId,transportTypes,prevNetId,prevIPv4,prevIPv6));
}","public static void logEvent(int netId,int[] transportTypes,int prevNetId,boolean prevIPv4,boolean prevIPv6){
  logEvent(IPCE_CONSRV_DEFAULT_NET_CHANGE,new ConnectivityServiceChangeEvent(netId,transportTypes,prevNetId,prevIPv4,prevIPv6));
}",0.9227799227799228
192096,"public static void logStateEvent(String ifName,String state){
  logEvent(IpConnectivityEvent.IPCE_DHCP_STATE_CHANGE,new DhcpClientEvent(ifName,state));
}","public static void logStateEvent(String ifName,String state){
  logEvent(IPCE_DHCP_STATE_CHANGE,new DhcpClientEvent(ifName,state));
}",0.93006993006993
192097,"public DhcpClientEvent(Parcel in){
  mIfName=in.readString();
  mMsg=in.readString();
}","private DhcpClientEvent(Parcel in){
  this.ifName=in.readString();
  this.msg=in.readString();
}",0.8743169398907104
192098,"public void writeToParcel(Parcel out,int flags){
  out.writeString(mIfName);
  out.writeString(mMsg);
}","public void writeToParcel(Parcel out,int flags){
  out.writeString(ifName);
  out.writeString(msg);
}",0.9803921568627452
192099,"public static void logParseError(String ifName,int errorCode){
  IpConnectivityEvent.logEvent(IPCE_DHCP_PARSE_ERROR,new DhcpErrorEvent(ifName,errorCode));
}","public static void logParseError(String ifName,int errorCode){
  logEvent(IPCE_DHCP_PARSE_ERROR,new DhcpErrorEvent(ifName,errorCode));
}",0.9315068493150684
192100,"private DnsEvent(Parcel in){
  netId=in.readInt();
  eventTypes=in.createByteArray();
  returnCodes=in.createByteArray();
  latenciesMs=in.createIntArray();
}","private DnsEvent(Parcel in){
  this.netId=in.readInt();
  this.eventTypes=in.createByteArray();
  this.returnCodes=in.createByteArray();
  this.latenciesMs=in.createIntArray();
}",0.9404761904761904
192101,"public static void logEvent(int netId,byte[] eventTypes,byte[] returnCodes,int[] latenciesMs){
  IpConnectivityEvent.logEvent(IPCE_DNS_LOOKUPS,new DnsEvent(netId,eventTypes,returnCodes,latenciesMs));
}","public static void logEvent(int netId,byte[] eventTypes,byte[] returnCodes,int[] latenciesMs){
  logEvent(IPCE_DNS_LOOKUPS,new DnsEvent(netId,eventTypes,returnCodes,latenciesMs));
}",0.9476439790575916
192102,"public static void logEvent(int tag,IpConnectivityEvent event){
  long timestamp=System.currentTimeMillis();
  mMetricsLogger.logEvent(timestamp,ConnectivityMetricsLogger.COMPONENT_TAG_CONNECTIVITY,tag,event);
}","public static <T extends IpConnectivityEvent & Parcelable>void logEvent(int tag,T event){
  final long timestamp=System.currentTimeMillis();
  final int componentTag=ConnectivityMetricsLogger.COMPONENT_TAG_CONNECTIVITY;
  mMetricsLogger.logEvent(timestamp,componentTag,tag,event);
}",0.6288032454361054
192103,"public IpManagerEvent(Parcel in){
  mIfName=in.readString();
  mDurationMs=in.readLong();
}","private IpManagerEvent(Parcel in){
  this.ifName=in.readString();
  this.durationMs=in.readLong();
}",0.8691099476439791
192104,"public void writeToParcel(Parcel out,int flags){
  out.writeString(mIfName);
  out.writeLong(mDurationMs);
}","public void writeToParcel(Parcel out,int flags){
  out.writeString(ifName);
  out.writeLong(durationMs);
}",0.97196261682243
192105,"public static void logEvent(int eventType,String ifName,long durationMs){
  IpConnectivityEvent.logEvent(eventType,new IpManagerEvent(ifName,durationMs));
}","public static void logEvent(int eventType,String ifName,long durationMs){
  logEvent(eventType,new IpManagerEvent(ifName,durationMs));
}",0.9315068493150684
192106,"private DhcpErrorEvent(Parcel in){
  this.errorCode=in.readInt();
}","private DhcpErrorEvent(Parcel in){
  this.ifName=in.readString();
  this.errorCode=in.readInt();
}",0.8121212121212121
192107,"public void writeToParcel(Parcel out,int flags){
  out.writeInt(errorCode);
}","public void writeToParcel(Parcel out,int flags){
  out.writeString(ifName);
  out.writeInt(errorCode);
}",0.850828729281768
192108,"@Override public void run(){
  if (DBG)   Log.d(TAG,""String_Node_Str"");
  while (!mStopped) {
    int length=0;
    try {
      length=Os.read(mPacketSock,mPacket,0,mPacket.length);
      DhcpPacket packet=null;
      packet=DhcpPacket.decodeFullPacket(mPacket,length,DhcpPacket.ENCAP_L2);
      if (DBG)       Log.d(TAG,""String_Node_Str"" + packet);
      sendMessage(CMD_RECEIVED_PACKET,packet);
    }
 catch (    IOException|ErrnoException e) {
      if (!mStopped) {
        Log.e(TAG,""String_Node_Str"",e);
      }
      DhcpClientEvent.logEvent(IpConnectivityEvent.IPCE_DHCP_RECV_ERROR,mIfaceName,e.getMessage());
    }
catch (    DhcpPacket.ParseException e) {
      Log.e(TAG,""String_Node_Str"" + e.getMessage());
      if (PACKET_DBG) {
        Log.d(TAG,HexDump.dumpHexString(mPacket,0,length));
      }
      DhcpClientEvent.logEvent(IpConnectivityEvent.IPCE_DHCP_PARSE_ERROR,mIfaceName,e.getMessage());
    }
  }
  if (DBG)   Log.d(TAG,""String_Node_Str"");
}","@Override public void run(){
  if (DBG)   Log.d(TAG,""String_Node_Str"");
  while (!mStopped) {
    int length=0;
    try {
      length=Os.read(mPacketSock,mPacket,0,mPacket.length);
      DhcpPacket packet=null;
      packet=DhcpPacket.decodeFullPacket(mPacket,length,DhcpPacket.ENCAP_L2);
      if (DBG)       Log.d(TAG,""String_Node_Str"" + packet);
      sendMessage(CMD_RECEIVED_PACKET,packet);
    }
 catch (    IOException|ErrnoException e) {
      if (!mStopped) {
        Log.e(TAG,""String_Node_Str"",e);
      }
      DhcpErrorEvent.logReceiveError(mIfaceName);
    }
catch (    DhcpPacket.ParseException e) {
      Log.e(TAG,""String_Node_Str"" + e.getMessage());
      if (PACKET_DBG) {
        Log.d(TAG,HexDump.dumpHexString(mPacket,0,length));
      }
      DhcpErrorEvent.logParseError(mIfaceName,e.errorCode);
    }
  }
  if (DBG)   Log.d(TAG,""String_Node_Str"");
}",0.9060293318848452
192109,"public ParseException(String msg,Object... args){
  super(String.format(msg,args));
}","public ParseException(int errorCode,String msg,Object... args){
  super(String.format(msg,args));
  this.errorCode=errorCode;
}",0.8018867924528302
192110,"/** 
 * Moves the specified task record to the input stack id. WARNING: This method performs an unchecked/raw move of the task and can leave the system in an unstable state if used incorrectly. Use   {@link #moveTaskToStackLocked} to perform safe task movement to a stack.
 * @param task Task to move.
 * @param stackId Id of stack to move task to.
 * @param toTop True if the task should be placed at the top of the stack.
 * @param forceFocus if focus should be moved to the new stack
 * @param reason Reason the task is been moved.
 * @return The stack the task was moved to.
 */
ActivityStack moveTaskToStackUncheckedLocked(TaskRecord task,int stackId,boolean toTop,boolean forceFocus,String reason){
  if (StackId.isMultiWindowStack(stackId) && !mService.mSupportsMultiWindow) {
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + task + ""String_Node_Str""+ stackId);
  }
  final ActivityRecord r=task.getTopActivity();
  final ActivityStack prevStack=task.stack;
  final boolean wasFocused=isFocusedStack(prevStack) && (topRunningActivityLocked() == r);
  final boolean wasResumed=wasFocused && (prevStack.mResumedActivity == r);
  final boolean wasFront=isFrontStack(prevStack) && (prevStack.topRunningActivityLocked() == r);
  if (stackId == DOCKED_STACK_ID && !task.isResizeable()) {
    stackId=(prevStack != null) ? prevStack.mStackId : FULLSCREEN_WORKSPACE_STACK_ID;
    Slog.w(TAG,""String_Node_Str"" + task + ""String_Node_Str""+ stackId+ ""String_Node_Str"");
  }
  task.mTemporarilyUnresizable=true;
  final ActivityStack stack=getStack(stackId,CREATE_IF_NEEDED,toTop);
  task.mTemporarilyUnresizable=false;
  mWindowManager.moveTaskToStack(task.taskId,stack.mStackId,toTop);
  stack.addTask(task,toTop,reason);
  stack.moveToFrontAndResumeStateIfNeeded(r,forceFocus || wasFocused || wasFront,wasResumed,reason);
  return stack;
}","/** 
 * Moves the specified task record to the input stack id. WARNING: This method performs an unchecked/raw move of the task and can leave the system in an unstable state if used incorrectly. Use   {@link #moveTaskToStackLocked} to perform safe task movement to a stack.
 * @param task Task to move.
 * @param stackId Id of stack to move task to.
 * @param toTop True if the task should be placed at the top of the stack.
 * @param forceFocus if focus should be moved to the new stack
 * @param reason Reason the task is been moved.
 * @return The stack the task was moved to.
 */
ActivityStack moveTaskToStackUncheckedLocked(TaskRecord task,int stackId,boolean toTop,boolean forceFocus,String reason){
  if (StackId.isMultiWindowStack(stackId) && !mService.mSupportsMultiWindow) {
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + task + ""String_Node_Str""+ stackId);
  }
  final ActivityRecord r=task.getTopActivity();
  final ActivityStack prevStack=task.stack;
  final boolean wasFocused=isFocusedStack(prevStack) && (topRunningActivityLocked() == r);
  final boolean wasResumed=prevStack.mResumedActivity == r;
  final boolean wasFront=isFrontStack(prevStack) && (prevStack.topRunningActivityLocked() == r);
  if (stackId == DOCKED_STACK_ID && !task.isResizeable()) {
    stackId=(prevStack != null) ? prevStack.mStackId : FULLSCREEN_WORKSPACE_STACK_ID;
    Slog.w(TAG,""String_Node_Str"" + task + ""String_Node_Str""+ stackId+ ""String_Node_Str"");
  }
  task.mTemporarilyUnresizable=true;
  final ActivityStack stack=getStack(stackId,CREATE_IF_NEEDED,toTop);
  task.mTemporarilyUnresizable=false;
  mWindowManager.moveTaskToStack(task.taskId,stack.mStackId,toTop);
  stack.addTask(task,toTop,reason);
  stack.moveToFrontAndResumeStateIfNeeded(r,forceFocus || wasFocused || wasFront,wasResumed,reason);
  return stack;
}",0.995687331536388
192111,"/** 
 * Choose the correct animation and set it to the passed WindowState.
 * @param transit If AppTransition.TRANSIT_PREVIEW_DONE and the app window has been drawnthen the animation will be app_starting_exit. Any other value loads the animation from the switch statement below.
 * @param isEntrance The animation type the last time this was called. Used to keep fromloading the same animation twice.
 * @return true if an animation has been loaded.
 */
boolean applyAnimationLocked(int transit,boolean isEntrance){
  if ((mLocalAnimating && mAnimationIsEntrance == isEntrance) || mKeyguardGoingAwayAnimation) {
    if (mAnimation != null && mKeyguardGoingAwayAnimation && transit == WindowManagerPolicy.TRANSIT_PREVIEW_DONE) {
      applyFadeoutDuringKeyguardExitAnimation();
    }
    return true;
  }
  if (mService.okToDisplay()) {
    int anim=mPolicy.selectAnimationLw(mWin,transit);
    int attr=-1;
    Animation a=null;
    if (anim != 0) {
      a=anim != -1 ? AnimationUtils.loadAnimation(mContext,anim) : null;
    }
 else {
switch (transit) {
case WindowManagerPolicy.TRANSIT_ENTER:
        attr=com.android.internal.R.styleable.WindowAnimation_windowEnterAnimation;
      break;
case WindowManagerPolicy.TRANSIT_EXIT:
    attr=com.android.internal.R.styleable.WindowAnimation_windowExitAnimation;
  break;
case WindowManagerPolicy.TRANSIT_SHOW:
attr=com.android.internal.R.styleable.WindowAnimation_windowShowAnimation;
break;
case WindowManagerPolicy.TRANSIT_HIDE:
attr=com.android.internal.R.styleable.WindowAnimation_windowHideAnimation;
break;
}
if (attr >= 0) {
a=mService.mAppTransition.loadAnimationAttr(mWin.mAttrs,attr);
}
}
if (DEBUG_ANIM) Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ anim+ ""String_Node_Str""+ Integer.toHexString(attr)+ ""String_Node_Str""+ a+ ""String_Node_Str""+ transit+ ""String_Node_Str""+ isEntrance+ ""String_Node_Str""+ Debug.getCallers(3));
if (a != null) {
if (DEBUG_ANIM) logWithStack(TAG,""String_Node_Str"" + a + ""String_Node_Str""+ this);
setAnimation(a);
mAnimationIsEntrance=isEntrance;
}
}
 else {
clearAnimation();
}
if (mWin.mAttrs.type == TYPE_INPUT_METHOD) {
mService.adjustForImeIfNeeded(mWin.mDisplayContent);
}
return mAnimation != null;
}","/** 
 * Choose the correct animation and set it to the passed WindowState.
 * @param transit If AppTransition.TRANSIT_PREVIEW_DONE and the app window has been drawnthen the animation will be app_starting_exit. Any other value loads the animation from the switch statement below.
 * @param isEntrance The animation type the last time this was called. Used to keep fromloading the same animation twice.
 * @return true if an animation has been loaded.
 */
boolean applyAnimationLocked(int transit,boolean isEntrance){
  if ((mLocalAnimating && mAnimationIsEntrance == isEntrance) || mKeyguardGoingAwayAnimation) {
    if (mAnimation != null && mKeyguardGoingAwayAnimation && transit == WindowManagerPolicy.TRANSIT_PREVIEW_DONE) {
      applyFadeoutDuringKeyguardExitAnimation();
    }
    return true;
  }
  if (mService.okToDisplay()) {
    int anim=mPolicy.selectAnimationLw(mWin,transit);
    int attr=-1;
    Animation a=null;
    if (anim != 0) {
      a=anim != -1 ? AnimationUtils.loadAnimation(mContext,anim) : null;
    }
 else {
switch (transit) {
case WindowManagerPolicy.TRANSIT_ENTER:
        attr=com.android.internal.R.styleable.WindowAnimation_windowEnterAnimation;
      break;
case WindowManagerPolicy.TRANSIT_EXIT:
    attr=com.android.internal.R.styleable.WindowAnimation_windowExitAnimation;
  break;
case WindowManagerPolicy.TRANSIT_SHOW:
attr=com.android.internal.R.styleable.WindowAnimation_windowShowAnimation;
break;
case WindowManagerPolicy.TRANSIT_HIDE:
attr=com.android.internal.R.styleable.WindowAnimation_windowHideAnimation;
break;
}
if (attr >= 0) {
a=mService.mAppTransition.loadAnimationAttr(mWin.mAttrs,attr);
}
}
if (DEBUG_ANIM) Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ anim+ ""String_Node_Str""+ Integer.toHexString(attr)+ ""String_Node_Str""+ a+ ""String_Node_Str""+ transit+ ""String_Node_Str""+ isEntrance+ ""String_Node_Str""+ Debug.getCallers(3));
if (a != null) {
if (DEBUG_ANIM) logWithStack(TAG,""String_Node_Str"" + a + ""String_Node_Str""+ this);
setAnimation(a);
mAnimationIsEntrance=isEntrance;
}
}
 else {
clearAnimation();
}
if (mWin.mAttrs.type == TYPE_INPUT_METHOD) {
mService.adjustForImeIfNeeded(mWin.mDisplayContent);
if (isEntrance) {
mWin.setDisplayLayoutNeeded();
mService.mWindowPlacerLocked.requestTraversal();
}
}
return mAnimation != null;
}",0.9778270509977828
192112,"public void onNotificationUpdated(NotificationData.Entry entry){
  mEntry=entry;
  mStatusBarNotification=entry.notification;
  mPrivateLayout.onNotificationUpdated(entry);
  mPublicLayout.onNotificationUpdated(entry);
  mShowingPublicInitialized=false;
  updateClearability();
  if (mIsSummaryWithChildren) {
    recreateNotificationHeader();
    mChildrenContainer.onNotificationUpdated();
  }
  if (mIconAnimationRunning) {
    setIconAnimationRunning(true);
  }
  if (mNotificationParent != null) {
    mNotificationParent.updateChildrenHeaderAppearance();
  }
  onChildrenCountChanged();
  mPublicLayout.updateExpandButtons(true);
  updateLimits();
}","public void onNotificationUpdated(NotificationData.Entry entry){
  mEntry=entry;
  mStatusBarNotification=entry.notification;
  mPrivateLayout.onNotificationUpdated(entry);
  mPublicLayout.onNotificationUpdated(entry);
  mShowingPublicInitialized=false;
  updateNotificationColor();
  updateClearability();
  if (mIsSummaryWithChildren) {
    recreateNotificationHeader();
    mChildrenContainer.onNotificationUpdated();
  }
  if (mIconAnimationRunning) {
    setIconAnimationRunning(true);
  }
  if (mNotificationParent != null) {
    mNotificationParent.updateChildrenHeaderAppearance();
  }
  onChildrenCountChanged();
  mPublicLayout.updateExpandButtons(true);
  updateLimits();
}",0.9783420463032112
192113,"public int getNotificationColor(){
  int color=getStatusBarNotification().getNotification().color;
  if (color == Notification.COLOR_DEFAULT) {
    return mContext.getColor(com.android.internal.R.color.notification_icon_default_color);
  }
  return color;
}","public int getNotificationColor(){
  return mNotificationColor;
}",0.3850931677018633
192114,"public void reInflateViews(){
  initDimens();
  for (int i=0; i < mDividers.size(); i++) {
    View prevDivider=mDividers.get(i);
    int index=indexOfChild(prevDivider);
    removeView(prevDivider);
    View divider=inflateDivider();
    addView(divider,index);
    mDividers.set(i,divider);
  }
}","public void reInflateViews(){
  initDimens();
  for (int i=0; i < mDividers.size(); i++) {
    View prevDivider=mDividers.get(i);
    int index=indexOfChild(prevDivider);
    removeView(prevDivider);
    View divider=inflateDivider();
    addView(divider,index);
    mDividers.set(i,divider);
  }
  removeView(mOverflowNumber);
  mOverflowNumber=null;
  mOverflowInvertHelper=null;
  mGroupOverFlowState=null;
  updateGroupOverflow();
}",0.8119891008174387
192115,"/** 
 * Request fingerprint enrollment. This call warms up the fingerprint hardware and starts scanning for fingerprints. Progress will be indicated by callbacks to the  {@link EnrollmentCallback} object. It terminates when{@link EnrollmentCallback#onEnrollmentError(int,CharSequence)} or{@link EnrollmentCallback#onEnrollmentProgress(int) is called with remaining == 0, atwhich point the object is no longer valid. The operation can be canceled by using the provided cancel object.}
 * @param token a unique token provided by a recent creation or verification of devicecredentials (e.g. pin, pattern or password).
 * @param cancel an object that can be used to cancel enrollment
 * @param flags optional flags
 * @param userId the user to whom this fingerprint will belong to
 * @param callback an object to receive enrollment events
 * @hide
 */
@RequiresPermission(MANAGE_FINGERPRINT) public void enroll(byte[] token,CancellationSignal cancel,int flags,int userId,EnrollmentCallback callback){
  if (userId == UserHandle.USER_CURRENT) {
    userId=getCurrentUserId();
  }
  if (callback == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (cancel != null) {
    if (cancel.isCanceled()) {
      Log.w(TAG,""String_Node_Str"");
      return;
    }
 else {
      cancel.setOnCancelListener(new OnEnrollCancelListener());
    }
  }
  if (mService != null)   try {
    mEnrollmentCallback=callback;
    mService.enroll(mToken,token,userId,mServiceReceiver,flags);
  }
 catch (  RemoteException e) {
    Log.w(TAG,""String_Node_Str"",e);
    if (callback != null) {
      callback.onEnrollmentError(FINGERPRINT_ERROR_HW_UNAVAILABLE,getErrorString(FINGERPRINT_ERROR_HW_UNAVAILABLE));
    }
  }
}","/** 
 * Request fingerprint enrollment. This call warms up the fingerprint hardware and starts scanning for fingerprints. Progress will be indicated by callbacks to the  {@link EnrollmentCallback} object. It terminates when{@link EnrollmentCallback#onEnrollmentError(int,CharSequence)} or{@link EnrollmentCallback#onEnrollmentProgress(int) is called with remaining == 0, atwhich point the object is no longer valid. The operation can be canceled by using the provided cancel object.}
 * @param token a unique token provided by a recent creation or verification of devicecredentials (e.g. pin, pattern or password).
 * @param cancel an object that can be used to cancel enrollment
 * @param flags optional flags
 * @param userId the user to whom this fingerprint will belong to
 * @param callback an object to receive enrollment events
 * @hide
 */
@RequiresPermission(MANAGE_FINGERPRINT) public void enroll(byte[] token,CancellationSignal cancel,int flags,int userId,EnrollmentCallback callback){
  if (userId == UserHandle.USER_CURRENT) {
    userId=getCurrentUserId();
  }
  if (callback == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (cancel != null) {
    if (cancel.isCanceled()) {
      Log.w(TAG,""String_Node_Str"");
      return;
    }
 else {
      cancel.setOnCancelListener(new OnEnrollCancelListener());
    }
  }
  if (mService != null)   try {
    mEnrollmentCallback=callback;
    mService.enroll(mToken,token,userId,mServiceReceiver,flags,mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
    Log.w(TAG,""String_Node_Str"",e);
    if (callback != null) {
      callback.onEnrollmentError(FINGERPRINT_ERROR_HW_UNAVAILABLE,getErrorString(FINGERPRINT_ERROR_HW_UNAVAILABLE));
    }
  }
}",0.9919028340080972
192116,"/** 
 * Request fingerprint enrollment. This call warms up the fingerprint hardware and starts scanning for fingerprints. Progress will be indicated by callbacks to the  {@link EnrollmentCallback} object. It terminates when{@link EnrollmentCallback#onEnrollmentError(int,CharSequence)} or{@link EnrollmentCallback#onEnrollmentProgress(int) is called with remaining == 0, atwhich point the object is no longer valid. The operation can be canceled by using the provided cancel object.}
 * @param token a unique token provided by a recent creation or verification of devicecredentials (e.g. pin, pattern or password).
 * @param cancel an object that can be used to cancel enrollment
 * @param flags optional flags
 * @param userId the user to whom this fingerprint will belong to
 * @param callback an object to receive enrollment events
 * @hide
 */
@RequiresPermission(MANAGE_FINGERPRINT) public void enroll(byte[] token,CancellationSignal cancel,int flags,int userId,EnrollmentCallback callback){
  if (userId == UserHandle.USER_CURRENT) {
    userId=getCurrentUserId();
  }
  if (callback == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (cancel != null) {
    if (cancel.isCanceled()) {
      Log.w(TAG,""String_Node_Str"");
      return;
    }
 else {
      cancel.setOnCancelListener(new OnEnrollCancelListener());
    }
  }
  if (mService != null)   try {
    mEnrollmentCallback=callback;
    mService.enroll(mToken,token,userId,mServiceReceiver,flags);
  }
 catch (  RemoteException e) {
    Log.w(TAG,""String_Node_Str"",e);
    if (callback != null) {
      callback.onEnrollmentError(FINGERPRINT_ERROR_HW_UNAVAILABLE,getErrorString(FINGERPRINT_ERROR_HW_UNAVAILABLE));
    }
  }
}","/** 
 * Request fingerprint enrollment. This call warms up the fingerprint hardware and starts scanning for fingerprints. Progress will be indicated by callbacks to the  {@link EnrollmentCallback} object. It terminates when{@link EnrollmentCallback#onEnrollmentError(int,CharSequence)} or{@link EnrollmentCallback#onEnrollmentProgress(int) is called with remaining == 0, atwhich point the object is no longer valid. The operation can be canceled by using the provided cancel object.}
 * @param token a unique token provided by a recent creation or verification of devicecredentials (e.g. pin, pattern or password).
 * @param cancel an object that can be used to cancel enrollment
 * @param flags optional flags
 * @param userId the user to whom this fingerprint will belong to
 * @param callback an object to receive enrollment events
 * @hide
 */
@RequiresPermission(MANAGE_FINGERPRINT) public void enroll(byte[] token,CancellationSignal cancel,int flags,int userId,EnrollmentCallback callback){
  if (userId == UserHandle.USER_CURRENT) {
    userId=getCurrentUserId();
  }
  if (callback == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (cancel != null) {
    if (cancel.isCanceled()) {
      Log.w(TAG,""String_Node_Str"");
      return;
    }
 else {
      cancel.setOnCancelListener(new OnEnrollCancelListener());
    }
  }
  if (mService != null)   try {
    mEnrollmentCallback=callback;
    mService.enroll(mToken,token,userId,mServiceReceiver,flags,mContext.getOpPackageName());
  }
 catch (  RemoteException e) {
    Log.w(TAG,""String_Node_Str"",e);
    if (callback != null) {
      callback.onEnrollmentError(FINGERPRINT_ERROR_HW_UNAVAILABLE,getErrorString(FINGERPRINT_ERROR_HW_UNAVAILABLE));
    }
  }
}",0.9919028340080972
192117,"/** 
 * {@inheritDoc} 
 */
@Override public long interceptKeyBeforeDispatching(WindowState win,KeyEvent event,int policyFlags){
  final boolean keyguardOn=keyguardOn();
  final int keyCode=event.getKeyCode();
  final int repeatCount=event.getRepeatCount();
  final int metaState=event.getMetaState();
  final int flags=event.getFlags();
  final boolean down=event.getAction() == KeyEvent.ACTION_DOWN;
  final boolean canceled=event.isCanceled();
  if (DEBUG_INPUT) {
    Log.d(TAG,""String_Node_Str"" + keyCode + ""String_Node_Str""+ down+ ""String_Node_Str""+ repeatCount+ ""String_Node_Str""+ keyguardOn+ ""String_Node_Str""+ mHomePressed+ ""String_Node_Str""+ canceled);
  }
  if (mScreenshotChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
    if (mScreenshotChordVolumeDownKeyTriggered && !mScreenshotChordPowerKeyTriggered) {
      final long now=SystemClock.uptimeMillis();
      final long timeoutTime=mScreenshotChordVolumeDownKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
      if (now < timeoutTime) {
        return timeoutTime - now;
      }
    }
    if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN && mScreenshotChordVolumeDownKeyConsumed) {
      if (!down) {
        mScreenshotChordVolumeDownKeyConsumed=false;
      }
      return -1;
    }
  }
  if (mPendingMetaAction && !KeyEvent.isMetaKey(keyCode)) {
    mPendingMetaAction=false;
  }
  if (mPendingCapsLockToggle && !KeyEvent.isMetaKey(keyCode) && !KeyEvent.isAltKey(keyCode)) {
    mPendingCapsLockToggle=false;
  }
  if (keyCode == KeyEvent.KEYCODE_HOME) {
    if (!down) {
      cancelPreloadRecentApps();
      mHomePressed=false;
      if (mHomeConsumed) {
        mHomeConsumed=false;
        return -1;
      }
      if (canceled) {
        Log.i(TAG,""String_Node_Str"");
        return -1;
      }
      TelecomManager telecomManager=getTelecommService();
      if (telecomManager != null && telecomManager.isRinging()) {
        Log.i(TAG,""String_Node_Str"");
        return -1;
      }
      if (mDoubleTapOnHomeBehavior != DOUBLE_TAP_HOME_NOTHING) {
        mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
        mHomeDoubleTapPending=true;
        mHandler.postDelayed(mHomeDoubleTapTimeoutRunnable,ViewConfiguration.getDoubleTapTimeout());
        return -1;
      }
      handleShortPressOnHome();
      return -1;
    }
    WindowManager.LayoutParams attrs=win != null ? win.getAttrs() : null;
    if (attrs != null) {
      final int type=attrs.type;
      if (type == WindowManager.LayoutParams.TYPE_KEYGUARD_SCRIM || type == WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG || (attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
        return 0;
      }
      final int typeCount=WINDOW_TYPES_WHERE_HOME_DOESNT_WORK.length;
      for (int i=0; i < typeCount; i++) {
        if (type == WINDOW_TYPES_WHERE_HOME_DOESNT_WORK[i]) {
          return -1;
        }
      }
    }
    if (repeatCount == 0) {
      mHomePressed=true;
      if (mHomeDoubleTapPending) {
        mHomeDoubleTapPending=false;
        mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
        handleDoubleTapOnHome();
      }
 else       if (mLongPressOnHomeBehavior == LONG_PRESS_HOME_RECENT_SYSTEM_UI || mDoubleTapOnHomeBehavior == DOUBLE_TAP_HOME_RECENT_SYSTEM_UI) {
        preloadRecentApps();
      }
    }
 else     if ((event.getFlags() & KeyEvent.FLAG_LONG_PRESS) != 0) {
      if (!keyguardOn) {
        handleLongPressOnHome(event.getDeviceId());
      }
    }
    return -1;
  }
 else   if (keyCode == KeyEvent.KEYCODE_MENU) {
    final int chordBug=KeyEvent.META_SHIFT_ON;
    if (down && repeatCount == 0) {
      if (mEnableShiftMenuBugReports && (metaState & chordBug) == chordBug) {
        Intent intent=new Intent(Intent.ACTION_BUG_REPORT);
        mContext.sendOrderedBroadcastAsUser(intent,UserHandle.CURRENT,null,null,null,0,null,null);
        return -1;
      }
 else       if (SHOW_PROCESSES_ON_ALT_MENU && (metaState & KeyEvent.META_ALT_ON) == KeyEvent.META_ALT_ON) {
        Intent service=new Intent();
        service.setClassName(mContext,""String_Node_Str"");
        ContentResolver res=mContext.getContentResolver();
        boolean shown=Settings.Global.getInt(res,Settings.Global.SHOW_PROCESSES,0) != 0;
        if (!shown) {
          mContext.startService(service);
        }
 else {
          mContext.stopService(service);
        }
        Settings.Global.putInt(res,Settings.Global.SHOW_PROCESSES,shown ? 0 : 1);
        return -1;
      }
    }
  }
 else   if (keyCode == KeyEvent.KEYCODE_SEARCH) {
    if (down) {
      if (repeatCount == 0) {
        mSearchKeyShortcutPending=true;
        mConsumeSearchKeyUp=false;
      }
    }
 else {
      mSearchKeyShortcutPending=false;
      if (mConsumeSearchKeyUp) {
        mConsumeSearchKeyUp=false;
        return -1;
      }
    }
    return 0;
  }
 else   if (keyCode == KeyEvent.KEYCODE_APP_SWITCH) {
    if (!keyguardOn) {
      if (down && repeatCount == 0) {
        preloadRecentApps();
      }
 else       if (!down) {
        toggleRecentApps();
      }
    }
    return -1;
  }
 else   if (keyCode == KeyEvent.KEYCODE_N && event.isMetaPressed()) {
    if (down) {
      IStatusBarService service=getStatusBarService();
      if (service != null) {
        try {
          service.expandNotificationsPanel();
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
 else   if (keyCode == KeyEvent.KEYCODE_S && event.isMetaPressed() && event.isCtrlPressed()) {
    if (down && repeatCount == 0) {
      int type=event.isShiftPressed() ? TAKE_SCREENSHOT_SELECTED_REGION : TAKE_SCREENSHOT_FULLSCREEN;
      mScreenshotRunnable.setScreenshotType(type);
      mHandler.post(mScreenshotRunnable);
      return -1;
    }
  }
 else   if (keyCode == KeyEvent.KEYCODE_SLASH && event.isMetaPressed()) {
    if (down && repeatCount == 0 && !isKeyguardLocked()) {
      toggleKeyboardShortcutsMenu(event.getDeviceId());
    }
  }
 else   if (keyCode == KeyEvent.KEYCODE_ASSIST) {
    if (down) {
      if (repeatCount == 0) {
        mAssistKeyLongPressed=false;
      }
 else       if (repeatCount == 1) {
        mAssistKeyLongPressed=true;
        if (!keyguardOn) {
          launchAssistLongPressAction();
        }
      }
    }
 else {
      if (mAssistKeyLongPressed) {
        mAssistKeyLongPressed=false;
      }
 else {
        if (!keyguardOn) {
          launchAssistAction(null,event.getDeviceId());
        }
      }
    }
    return -1;
  }
 else   if (keyCode == KeyEvent.KEYCODE_VOICE_ASSIST) {
    if (!down) {
      Intent voiceIntent;
      if (!keyguardOn) {
        voiceIntent=new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
      }
 else {
        IDeviceIdleController dic=IDeviceIdleController.Stub.asInterface(ServiceManager.getService(Context.DEVICE_IDLE_CONTROLLER));
        if (dic != null) {
          try {
            dic.exitIdle(""String_Node_Str"");
          }
 catch (          RemoteException e) {
          }
        }
        voiceIntent=new Intent(RecognizerIntent.ACTION_VOICE_SEARCH_HANDS_FREE);
        voiceIntent.putExtra(RecognizerIntent.EXTRA_SECURE,true);
      }
      startActivityAsUser(voiceIntent,UserHandle.CURRENT_OR_SELF);
    }
  }
 else   if (keyCode == KeyEvent.KEYCODE_SYSRQ) {
    if (down && repeatCount == 0) {
      mScreenshotRunnable.setScreenshotType(TAKE_SCREENSHOT_FULLSCREEN);
      mHandler.post(mScreenshotRunnable);
    }
    return -1;
  }
 else   if (keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP || keyCode == KeyEvent.KEYCODE_BRIGHTNESS_DOWN) {
    if (down) {
      int direction=keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP ? 1 : -1;
      int auto=Settings.System.getIntForUser(mContext.getContentResolver(),Settings.System.SCREEN_BRIGHTNESS_MODE,Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL,UserHandle.USER_CURRENT_OR_SELF);
      if (auto != 0) {
        Settings.System.putIntForUser(mContext.getContentResolver(),Settings.System.SCREEN_BRIGHTNESS_MODE,Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL,UserHandle.USER_CURRENT_OR_SELF);
      }
      int min=mPowerManager.getMinimumScreenBrightnessSetting();
      int max=mPowerManager.getMaximumScreenBrightnessSetting();
      int step=(max - min + BRIGHTNESS_STEPS - 1) / BRIGHTNESS_STEPS * direction;
      int brightness=Settings.System.getIntForUser(mContext.getContentResolver(),Settings.System.SCREEN_BRIGHTNESS,mPowerManager.getDefaultScreenBrightnessSetting(),UserHandle.USER_CURRENT_OR_SELF);
      brightness+=step;
      brightness=Math.min(max,brightness);
      brightness=Math.max(min,brightness);
      Settings.System.putIntForUser(mContext.getContentResolver(),Settings.System.SCREEN_BRIGHTNESS,brightness,UserHandle.USER_CURRENT_OR_SELF);
      startActivityAsUser(new Intent(Intent.ACTION_SHOW_BRIGHTNESS_DIALOG),UserHandle.CURRENT_OR_SELF);
    }
    return -1;
  }
 else   if (keyCode == KeyEvent.KEYCODE_VOLUME_UP || keyCode == KeyEvent.KEYCODE_VOLUME_DOWN || keyCode == KeyEvent.KEYCODE_VOLUME_MUTE) {
    if (mUseTvRouting) {
      dispatchDirectAudioEvent(event);
      return -1;
    }
  }
  boolean actionTriggered=false;
  if (KeyEvent.isModifierKey(keyCode)) {
    if (!mPendingCapsLockToggle) {
      mInitialMetaState=mMetaState;
      mPendingCapsLockToggle=true;
    }
 else     if (event.getAction() == KeyEvent.ACTION_UP) {
      int altOnMask=mMetaState & KeyEvent.META_ALT_MASK;
      int metaOnMask=mMetaState & KeyEvent.META_META_MASK;
      if ((metaOnMask != 0) && (altOnMask != 0)) {
        if (mInitialMetaState == (mMetaState ^ (altOnMask | metaOnMask))) {
          mInputManagerInternal.toggleCapsLock(event.getDeviceId());
          actionTriggered=true;
        }
      }
      mPendingCapsLockToggle=false;
    }
  }
  mMetaState=metaState;
  if (actionTriggered) {
    return -1;
  }
  if (KeyEvent.isMetaKey(keyCode)) {
    if (down) {
      mPendingMetaAction=true;
    }
 else     if (mPendingMetaAction) {
      launchAssistAction(Intent.EXTRA_ASSIST_INPUT_HINT_KEYBOARD,event.getDeviceId());
    }
    return -1;
  }
  if (mSearchKeyShortcutPending) {
    final KeyCharacterMap kcm=event.getKeyCharacterMap();
    if (kcm.isPrintingKey(keyCode)) {
      mConsumeSearchKeyUp=true;
      mSearchKeyShortcutPending=false;
      if (down && repeatCount == 0 && !keyguardOn) {
        Intent shortcutIntent=mShortcutManager.getIntent(kcm,keyCode,metaState);
        if (shortcutIntent != null) {
          shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
          try {
            startActivityAsUser(shortcutIntent,UserHandle.CURRENT);
          }
 catch (          ActivityNotFoundException ex) {
            Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ KeyEvent.keyCodeToString(keyCode),ex);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + ""String_Node_Str"" + KeyEvent.keyCodeToString(keyCode));
        }
      }
      return -1;
    }
  }
  if (down && repeatCount == 0 && !keyguardOn && (metaState & KeyEvent.META_META_ON) != 0) {
    final KeyCharacterMap kcm=event.getKeyCharacterMap();
    if (kcm.isPrintingKey(keyCode)) {
      Intent shortcutIntent=mShortcutManager.getIntent(kcm,keyCode,metaState & ~(KeyEvent.META_META_ON | KeyEvent.META_META_LEFT_ON | KeyEvent.META_META_RIGHT_ON));
      if (shortcutIntent != null) {
        shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        try {
          startActivityAsUser(shortcutIntent,UserHandle.CURRENT);
        }
 catch (        ActivityNotFoundException ex) {
          Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ KeyEvent.keyCodeToString(keyCode),ex);
        }
        return -1;
      }
    }
  }
  if (down && repeatCount == 0 && !keyguardOn) {
    String category=sApplicationLaunchKeyCategories.get(keyCode);
    if (category != null) {
      Intent intent=Intent.makeMainSelectorActivity(Intent.ACTION_MAIN,category);
      intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
      try {
        startActivityAsUser(intent,UserHandle.CURRENT);
      }
 catch (      ActivityNotFoundException ex) {
        Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + keyCode + ""String_Node_Str""+ category,ex);
      }
      return -1;
    }
  }
  if (down && repeatCount == 0 && keyCode == KeyEvent.KEYCODE_TAB) {
    if (mRecentAppsHeldModifiers == 0 && !keyguardOn && isUserSetupComplete()) {
      final int shiftlessModifiers=event.getModifiers() & ~KeyEvent.META_SHIFT_MASK;
      if (KeyEvent.metaStateHasModifiers(shiftlessModifiers,KeyEvent.META_ALT_ON)) {
        mRecentAppsHeldModifiers=shiftlessModifiers;
        showRecentApps(true);
        return -1;
      }
    }
  }
 else   if (!down && mRecentAppsHeldModifiers != 0 && (metaState & mRecentAppsHeldModifiers) == 0) {
    mRecentAppsHeldModifiers=0;
    hideRecentApps(true,false);
  }
  if (down && repeatCount == 0 && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || (keyCode == KeyEvent.KEYCODE_SPACE && (metaState & KeyEvent.META_META_MASK) != 0))) {
    final boolean forwardDirection=(metaState & KeyEvent.META_SHIFT_MASK) == 0;
    mWindowManagerFuncs.switchInputMethod(forwardDirection);
    return -1;
  }
  if (mLanguageSwitchKeyPressed && !down && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || keyCode == KeyEvent.KEYCODE_SPACE)) {
    mLanguageSwitchKeyPressed=false;
    return -1;
  }
  if (isValidGlobalKey(keyCode) && mGlobalKeyManager.handleGlobalKey(mContext,keyCode,event)) {
    return -1;
  }
  if (down) {
    long shortcutCode=(long)keyCode;
    if (event.isCtrlPressed()) {
      shortcutCode|=((long)KeyEvent.META_CTRL_ON) << Integer.SIZE;
    }
    if (event.isAltPressed()) {
      shortcutCode|=((long)KeyEvent.META_ALT_ON) << Integer.SIZE;
    }
    if (event.isShiftPressed()) {
      shortcutCode|=((long)KeyEvent.META_SHIFT_ON) << Integer.SIZE;
    }
    if (event.isMetaPressed()) {
      shortcutCode|=((long)KeyEvent.META_META_ON) << Integer.SIZE;
    }
    IShortcutService shortcutService=mShortcutKeyServices.get(shortcutCode);
    if (shortcutService != null) {
      try {
        shortcutService.notifyShortcutKeyPressed(shortcutCode);
      }
 catch (      RemoteException e) {
        mShortcutKeyServices.delete(shortcutCode);
      }
      return -1;
    }
  }
  if ((metaState & KeyEvent.META_META_ON) != 0) {
    return -1;
  }
  return 0;
}","/** 
 * {@inheritDoc} 
 */
@Override public long interceptKeyBeforeDispatching(WindowState win,KeyEvent event,int policyFlags){
  final boolean keyguardOn=keyguardOn();
  final int keyCode=event.getKeyCode();
  final int repeatCount=event.getRepeatCount();
  final int metaState=event.getMetaState();
  final int flags=event.getFlags();
  final boolean down=event.getAction() == KeyEvent.ACTION_DOWN;
  final boolean canceled=event.isCanceled();
  if (DEBUG_INPUT) {
    Log.d(TAG,""String_Node_Str"" + keyCode + ""String_Node_Str""+ down+ ""String_Node_Str""+ repeatCount+ ""String_Node_Str""+ keyguardOn+ ""String_Node_Str""+ mHomePressed+ ""String_Node_Str""+ canceled);
  }
  if (mScreenshotChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
    if (mScreenshotChordVolumeDownKeyTriggered && !mScreenshotChordPowerKeyTriggered) {
      final long now=SystemClock.uptimeMillis();
      final long timeoutTime=mScreenshotChordVolumeDownKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
      if (now < timeoutTime) {
        return timeoutTime - now;
      }
    }
    if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN && mScreenshotChordVolumeDownKeyConsumed) {
      if (!down) {
        mScreenshotChordVolumeDownKeyConsumed=false;
      }
      return -1;
    }
  }
  if (mPendingMetaAction && !KeyEvent.isMetaKey(keyCode)) {
    mPendingMetaAction=false;
  }
  if (mPendingCapsLockToggle && !KeyEvent.isMetaKey(keyCode) && !KeyEvent.isAltKey(keyCode)) {
    mPendingCapsLockToggle=false;
  }
  if (keyCode == KeyEvent.KEYCODE_HOME) {
    if (!down) {
      cancelPreloadRecentApps();
      mHomePressed=false;
      if (mHomeConsumed) {
        mHomeConsumed=false;
        return -1;
      }
      if (canceled) {
        Log.i(TAG,""String_Node_Str"");
        return -1;
      }
      TelecomManager telecomManager=getTelecommService();
      if (telecomManager != null && telecomManager.isRinging()) {
        Log.i(TAG,""String_Node_Str"");
        return -1;
      }
      if (mDoubleTapOnHomeBehavior != DOUBLE_TAP_HOME_NOTHING) {
        mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
        mHomeDoubleTapPending=true;
        mHandler.postDelayed(mHomeDoubleTapTimeoutRunnable,ViewConfiguration.getDoubleTapTimeout());
        return -1;
      }
      handleShortPressOnHome();
      return -1;
    }
    WindowManager.LayoutParams attrs=win != null ? win.getAttrs() : null;
    if (attrs != null) {
      final int type=attrs.type;
      if (type == WindowManager.LayoutParams.TYPE_KEYGUARD_SCRIM || type == WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG || (attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
        return 0;
      }
      final int typeCount=WINDOW_TYPES_WHERE_HOME_DOESNT_WORK.length;
      for (int i=0; i < typeCount; i++) {
        if (type == WINDOW_TYPES_WHERE_HOME_DOESNT_WORK[i]) {
          return -1;
        }
      }
    }
    if (repeatCount == 0) {
      mHomePressed=true;
      if (mHomeDoubleTapPending) {
        mHomeDoubleTapPending=false;
        mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
        handleDoubleTapOnHome();
      }
 else       if (mLongPressOnHomeBehavior == LONG_PRESS_HOME_RECENT_SYSTEM_UI || mDoubleTapOnHomeBehavior == DOUBLE_TAP_HOME_RECENT_SYSTEM_UI) {
        preloadRecentApps();
      }
    }
 else     if ((event.getFlags() & KeyEvent.FLAG_LONG_PRESS) != 0) {
      if (!keyguardOn) {
        handleLongPressOnHome(event.getDeviceId());
      }
    }
    return -1;
  }
 else   if (keyCode == KeyEvent.KEYCODE_MENU) {
    final int chordBug=KeyEvent.META_SHIFT_ON;
    if (down && repeatCount == 0) {
      if (mEnableShiftMenuBugReports && (metaState & chordBug) == chordBug) {
        Intent intent=new Intent(Intent.ACTION_BUG_REPORT);
        mContext.sendOrderedBroadcastAsUser(intent,UserHandle.CURRENT,null,null,null,0,null,null);
        return -1;
      }
 else       if (SHOW_PROCESSES_ON_ALT_MENU && (metaState & KeyEvent.META_ALT_ON) == KeyEvent.META_ALT_ON) {
        Intent service=new Intent();
        service.setClassName(mContext,""String_Node_Str"");
        ContentResolver res=mContext.getContentResolver();
        boolean shown=Settings.Global.getInt(res,Settings.Global.SHOW_PROCESSES,0) != 0;
        if (!shown) {
          mContext.startService(service);
        }
 else {
          mContext.stopService(service);
        }
        Settings.Global.putInt(res,Settings.Global.SHOW_PROCESSES,shown ? 0 : 1);
        return -1;
      }
    }
  }
 else   if (keyCode == KeyEvent.KEYCODE_SEARCH) {
    if (down) {
      if (repeatCount == 0) {
        mSearchKeyShortcutPending=true;
        mConsumeSearchKeyUp=false;
      }
    }
 else {
      mSearchKeyShortcutPending=false;
      if (mConsumeSearchKeyUp) {
        mConsumeSearchKeyUp=false;
        return -1;
      }
    }
    return 0;
  }
 else   if (keyCode == KeyEvent.KEYCODE_APP_SWITCH) {
    if (!keyguardOn) {
      if (down && repeatCount == 0) {
        preloadRecentApps();
      }
 else       if (!down) {
        toggleRecentApps();
      }
    }
    return -1;
  }
 else   if (keyCode == KeyEvent.KEYCODE_N && event.isMetaPressed()) {
    if (down) {
      IStatusBarService service=getStatusBarService();
      if (service != null) {
        try {
          service.expandNotificationsPanel();
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
 else   if (keyCode == KeyEvent.KEYCODE_S && event.isMetaPressed() && event.isCtrlPressed()) {
    if (down && repeatCount == 0) {
      int type=event.isShiftPressed() ? TAKE_SCREENSHOT_SELECTED_REGION : TAKE_SCREENSHOT_FULLSCREEN;
      mScreenshotRunnable.setScreenshotType(type);
      mHandler.post(mScreenshotRunnable);
      return -1;
    }
  }
 else   if (keyCode == KeyEvent.KEYCODE_SLASH && event.isMetaPressed()) {
    if (down && repeatCount == 0 && !isKeyguardLocked()) {
      toggleKeyboardShortcutsMenu(event.getDeviceId());
    }
  }
 else   if (keyCode == KeyEvent.KEYCODE_ASSIST) {
    if (down) {
      if (repeatCount == 0) {
        mAssistKeyLongPressed=false;
      }
 else       if (repeatCount == 1) {
        mAssistKeyLongPressed=true;
        if (!keyguardOn) {
          launchAssistLongPressAction();
        }
      }
    }
 else {
      if (mAssistKeyLongPressed) {
        mAssistKeyLongPressed=false;
      }
 else {
        if (!keyguardOn) {
          launchAssistAction(null,event.getDeviceId());
        }
      }
    }
    return -1;
  }
 else   if (keyCode == KeyEvent.KEYCODE_VOICE_ASSIST) {
    if (!down) {
      Intent voiceIntent;
      if (!keyguardOn) {
        voiceIntent=new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
      }
 else {
        IDeviceIdleController dic=IDeviceIdleController.Stub.asInterface(ServiceManager.getService(Context.DEVICE_IDLE_CONTROLLER));
        if (dic != null) {
          try {
            dic.exitIdle(""String_Node_Str"");
          }
 catch (          RemoteException e) {
          }
        }
        voiceIntent=new Intent(RecognizerIntent.ACTION_VOICE_SEARCH_HANDS_FREE);
        voiceIntent.putExtra(RecognizerIntent.EXTRA_SECURE,true);
      }
      startActivityAsUser(voiceIntent,UserHandle.CURRENT_OR_SELF);
    }
  }
 else   if (keyCode == KeyEvent.KEYCODE_SYSRQ) {
    if (down && repeatCount == 0) {
      mScreenshotRunnable.setScreenshotType(TAKE_SCREENSHOT_FULLSCREEN);
      mHandler.post(mScreenshotRunnable);
    }
    return -1;
  }
 else   if (keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP || keyCode == KeyEvent.KEYCODE_BRIGHTNESS_DOWN) {
    if (down) {
      int direction=keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP ? 1 : -1;
      int auto=Settings.System.getIntForUser(mContext.getContentResolver(),Settings.System.SCREEN_BRIGHTNESS_MODE,Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL,UserHandle.USER_CURRENT_OR_SELF);
      if (auto != 0) {
        Settings.System.putIntForUser(mContext.getContentResolver(),Settings.System.SCREEN_BRIGHTNESS_MODE,Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL,UserHandle.USER_CURRENT_OR_SELF);
      }
      int min=mPowerManager.getMinimumScreenBrightnessSetting();
      int max=mPowerManager.getMaximumScreenBrightnessSetting();
      int step=(max - min + BRIGHTNESS_STEPS - 1) / BRIGHTNESS_STEPS * direction;
      int brightness=Settings.System.getIntForUser(mContext.getContentResolver(),Settings.System.SCREEN_BRIGHTNESS,mPowerManager.getDefaultScreenBrightnessSetting(),UserHandle.USER_CURRENT_OR_SELF);
      brightness+=step;
      brightness=Math.min(max,brightness);
      brightness=Math.max(min,brightness);
      Settings.System.putIntForUser(mContext.getContentResolver(),Settings.System.SCREEN_BRIGHTNESS,brightness,UserHandle.USER_CURRENT_OR_SELF);
      startActivityAsUser(new Intent(Intent.ACTION_SHOW_BRIGHTNESS_DIALOG),UserHandle.CURRENT_OR_SELF);
    }
    return -1;
  }
 else   if (keyCode == KeyEvent.KEYCODE_VOLUME_UP || keyCode == KeyEvent.KEYCODE_VOLUME_DOWN || keyCode == KeyEvent.KEYCODE_VOLUME_MUTE) {
    if (mUseTvRouting) {
      dispatchDirectAudioEvent(event);
      return -1;
    }
  }
  boolean actionTriggered=false;
  if (KeyEvent.isModifierKey(keyCode)) {
    if (!mPendingCapsLockToggle) {
      mInitialMetaState=mMetaState;
      mPendingCapsLockToggle=true;
    }
 else     if (event.getAction() == KeyEvent.ACTION_UP) {
      int altOnMask=mMetaState & KeyEvent.META_ALT_MASK;
      int metaOnMask=mMetaState & KeyEvent.META_META_MASK;
      if ((metaOnMask != 0) && (altOnMask != 0)) {
        if (mInitialMetaState == (mMetaState ^ (altOnMask | metaOnMask))) {
          mInputManagerInternal.toggleCapsLock(event.getDeviceId());
          actionTriggered=true;
        }
      }
      mPendingCapsLockToggle=false;
    }
  }
  mMetaState=metaState;
  if (actionTriggered) {
    return -1;
  }
  if (KeyEvent.isMetaKey(keyCode)) {
    if (down) {
      mPendingMetaAction=true;
    }
 else     if (mPendingMetaAction) {
      launchAssistAction(Intent.EXTRA_ASSIST_INPUT_HINT_KEYBOARD,event.getDeviceId());
    }
    return -1;
  }
  if (mSearchKeyShortcutPending) {
    final KeyCharacterMap kcm=event.getKeyCharacterMap();
    if (kcm.isPrintingKey(keyCode)) {
      mConsumeSearchKeyUp=true;
      mSearchKeyShortcutPending=false;
      if (down && repeatCount == 0 && !keyguardOn) {
        Intent shortcutIntent=mShortcutManager.getIntent(kcm,keyCode,metaState);
        if (shortcutIntent != null) {
          shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
          try {
            startActivityAsUser(shortcutIntent,UserHandle.CURRENT);
          }
 catch (          ActivityNotFoundException ex) {
            Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ KeyEvent.keyCodeToString(keyCode),ex);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + ""String_Node_Str"" + KeyEvent.keyCodeToString(keyCode));
        }
      }
      return -1;
    }
  }
  if (down && repeatCount == 0 && !keyguardOn && (metaState & KeyEvent.META_META_ON) != 0) {
    final KeyCharacterMap kcm=event.getKeyCharacterMap();
    if (kcm.isPrintingKey(keyCode)) {
      Intent shortcutIntent=mShortcutManager.getIntent(kcm,keyCode,metaState & ~(KeyEvent.META_META_ON | KeyEvent.META_META_LEFT_ON | KeyEvent.META_META_RIGHT_ON));
      if (shortcutIntent != null) {
        shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        try {
          startActivityAsUser(shortcutIntent,UserHandle.CURRENT);
        }
 catch (        ActivityNotFoundException ex) {
          Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ KeyEvent.keyCodeToString(keyCode),ex);
        }
        return -1;
      }
    }
  }
  if (down && repeatCount == 0 && !keyguardOn) {
    String category=sApplicationLaunchKeyCategories.get(keyCode);
    if (category != null) {
      Intent intent=Intent.makeMainSelectorActivity(Intent.ACTION_MAIN,category);
      intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
      try {
        startActivityAsUser(intent,UserHandle.CURRENT);
      }
 catch (      ActivityNotFoundException ex) {
        Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + keyCode + ""String_Node_Str""+ category,ex);
      }
      return -1;
    }
  }
  if (down && repeatCount == 0 && keyCode == KeyEvent.KEYCODE_TAB) {
    if (mRecentAppsHeldModifiers == 0 && !keyguardOn && isUserSetupComplete()) {
      final int shiftlessModifiers=event.getModifiers() & ~KeyEvent.META_SHIFT_MASK;
      if (KeyEvent.metaStateHasModifiers(shiftlessModifiers,KeyEvent.META_ALT_ON)) {
        mRecentAppsHeldModifiers=shiftlessModifiers;
        showRecentApps(true);
        return -1;
      }
    }
  }
 else   if (!down && mRecentAppsHeldModifiers != 0 && (metaState & mRecentAppsHeldModifiers) == 0) {
    mRecentAppsHeldModifiers=0;
    hideRecentApps(true,false);
  }
  if (down && repeatCount == 0 && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || (keyCode == KeyEvent.KEYCODE_SPACE && (metaState & KeyEvent.META_META_MASK) != 0))) {
    final boolean forwardDirection=(metaState & KeyEvent.META_SHIFT_MASK) == 0;
    mWindowManagerFuncs.switchInputMethod(forwardDirection);
    return -1;
  }
  if (mLanguageSwitchKeyPressed && !down && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || keyCode == KeyEvent.KEYCODE_SPACE)) {
    mLanguageSwitchKeyPressed=false;
    return -1;
  }
  if (isValidGlobalKey(keyCode) && mGlobalKeyManager.handleGlobalKey(mContext,keyCode,event)) {
    return -1;
  }
  if (down) {
    long shortcutCode=(long)keyCode;
    if (event.isCtrlPressed()) {
      shortcutCode|=((long)KeyEvent.META_CTRL_ON) << Integer.SIZE;
    }
    if (event.isAltPressed()) {
      shortcutCode|=((long)KeyEvent.META_ALT_ON) << Integer.SIZE;
    }
    if (event.isShiftPressed()) {
      shortcutCode|=((long)KeyEvent.META_SHIFT_ON) << Integer.SIZE;
    }
    if (event.isMetaPressed()) {
      shortcutCode|=((long)KeyEvent.META_META_ON) << Integer.SIZE;
    }
    IShortcutService shortcutService=mShortcutKeyServices.get(shortcutCode);
    if (shortcutService != null) {
      try {
        if (isUserSetupComplete()) {
          shortcutService.notifyShortcutKeyPressed(shortcutCode);
        }
      }
 catch (      RemoteException e) {
        mShortcutKeyServices.delete(shortcutCode);
      }
      return -1;
    }
  }
  if ((metaState & KeyEvent.META_META_ON) != 0) {
    return -1;
  }
  return 0;
}",0.9982883291997066
192118,"/** 
 * {@inheritDoc} 
 */
@Override public long interceptKeyBeforeDispatching(WindowState win,KeyEvent event,int policyFlags){
  final boolean keyguardOn=keyguardOn();
  final int keyCode=event.getKeyCode();
  final int repeatCount=event.getRepeatCount();
  final int metaState=event.getMetaState();
  final int flags=event.getFlags();
  final boolean down=event.getAction() == KeyEvent.ACTION_DOWN;
  final boolean canceled=event.isCanceled();
  if (DEBUG_INPUT) {
    Log.d(TAG,""String_Node_Str"" + keyCode + ""String_Node_Str""+ down+ ""String_Node_Str""+ repeatCount+ ""String_Node_Str""+ keyguardOn+ ""String_Node_Str""+ mHomePressed+ ""String_Node_Str""+ canceled);
  }
  if (mScreenshotChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
    if (mScreenshotChordVolumeDownKeyTriggered && !mScreenshotChordPowerKeyTriggered) {
      final long now=SystemClock.uptimeMillis();
      final long timeoutTime=mScreenshotChordVolumeDownKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
      if (now < timeoutTime) {
        return timeoutTime - now;
      }
    }
    if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN && mScreenshotChordVolumeDownKeyConsumed) {
      if (!down) {
        mScreenshotChordVolumeDownKeyConsumed=false;
      }
      return -1;
    }
  }
  if (mPendingMetaAction && !KeyEvent.isMetaKey(keyCode)) {
    mPendingMetaAction=false;
  }
  if (mPendingCapsLockToggle && !KeyEvent.isMetaKey(keyCode) && !KeyEvent.isAltKey(keyCode)) {
    mPendingCapsLockToggle=false;
  }
  if (keyCode == KeyEvent.KEYCODE_HOME) {
    if (!down) {
      cancelPreloadRecentApps();
      mHomePressed=false;
      if (mHomeConsumed) {
        mHomeConsumed=false;
        return -1;
      }
      if (canceled) {
        Log.i(TAG,""String_Node_Str"");
        return -1;
      }
      TelecomManager telecomManager=getTelecommService();
      if (telecomManager != null && telecomManager.isRinging()) {
        Log.i(TAG,""String_Node_Str"");
        return -1;
      }
      if (mDoubleTapOnHomeBehavior != DOUBLE_TAP_HOME_NOTHING) {
        mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
        mHomeDoubleTapPending=true;
        mHandler.postDelayed(mHomeDoubleTapTimeoutRunnable,ViewConfiguration.getDoubleTapTimeout());
        return -1;
      }
      handleShortPressOnHome();
      return -1;
    }
    WindowManager.LayoutParams attrs=win != null ? win.getAttrs() : null;
    if (attrs != null) {
      final int type=attrs.type;
      if (type == WindowManager.LayoutParams.TYPE_KEYGUARD_SCRIM || type == WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG || (attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
        return 0;
      }
      final int typeCount=WINDOW_TYPES_WHERE_HOME_DOESNT_WORK.length;
      for (int i=0; i < typeCount; i++) {
        if (type == WINDOW_TYPES_WHERE_HOME_DOESNT_WORK[i]) {
          return -1;
        }
      }
    }
    if (repeatCount == 0) {
      mHomePressed=true;
      if (mHomeDoubleTapPending) {
        mHomeDoubleTapPending=false;
        mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
        handleDoubleTapOnHome();
      }
 else       if (mLongPressOnHomeBehavior == LONG_PRESS_HOME_RECENT_SYSTEM_UI || mDoubleTapOnHomeBehavior == DOUBLE_TAP_HOME_RECENT_SYSTEM_UI) {
        preloadRecentApps();
      }
    }
 else     if ((event.getFlags() & KeyEvent.FLAG_LONG_PRESS) != 0) {
      if (!keyguardOn) {
        handleLongPressOnHome(event.getDeviceId());
      }
    }
    return -1;
  }
 else   if (keyCode == KeyEvent.KEYCODE_MENU) {
    final int chordBug=KeyEvent.META_SHIFT_ON;
    if (down && repeatCount == 0) {
      if (mEnableShiftMenuBugReports && (metaState & chordBug) == chordBug) {
        Intent intent=new Intent(Intent.ACTION_BUG_REPORT);
        mContext.sendOrderedBroadcastAsUser(intent,UserHandle.CURRENT,null,null,null,0,null,null);
        return -1;
      }
 else       if (SHOW_PROCESSES_ON_ALT_MENU && (metaState & KeyEvent.META_ALT_ON) == KeyEvent.META_ALT_ON) {
        Intent service=new Intent();
        service.setClassName(mContext,""String_Node_Str"");
        ContentResolver res=mContext.getContentResolver();
        boolean shown=Settings.Global.getInt(res,Settings.Global.SHOW_PROCESSES,0) != 0;
        if (!shown) {
          mContext.startService(service);
        }
 else {
          mContext.stopService(service);
        }
        Settings.Global.putInt(res,Settings.Global.SHOW_PROCESSES,shown ? 0 : 1);
        return -1;
      }
    }
  }
 else   if (keyCode == KeyEvent.KEYCODE_SEARCH) {
    if (down) {
      if (repeatCount == 0) {
        mSearchKeyShortcutPending=true;
        mConsumeSearchKeyUp=false;
      }
    }
 else {
      mSearchKeyShortcutPending=false;
      if (mConsumeSearchKeyUp) {
        mConsumeSearchKeyUp=false;
        return -1;
      }
    }
    return 0;
  }
 else   if (keyCode == KeyEvent.KEYCODE_APP_SWITCH) {
    if (!keyguardOn) {
      if (down && repeatCount == 0) {
        preloadRecentApps();
      }
 else       if (!down) {
        toggleRecentApps();
      }
    }
    return -1;
  }
 else   if (keyCode == KeyEvent.KEYCODE_N && event.isMetaPressed()) {
    if (down) {
      IStatusBarService service=getStatusBarService();
      if (service != null) {
        try {
          service.expandNotificationsPanel();
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
 else   if (keyCode == KeyEvent.KEYCODE_S && event.isMetaPressed() && event.isCtrlPressed()) {
    if (down && repeatCount == 0) {
      int type=event.isShiftPressed() ? TAKE_SCREENSHOT_SELECTED_REGION : TAKE_SCREENSHOT_FULLSCREEN;
      mScreenshotRunnable.setScreenshotType(type);
      mHandler.post(mScreenshotRunnable);
      return -1;
    }
  }
 else   if (keyCode == KeyEvent.KEYCODE_SLASH && event.isMetaPressed()) {
    if (down && repeatCount == 0 && !isKeyguardLocked()) {
      toggleKeyboardShortcutsMenu(event.getDeviceId());
    }
  }
 else   if (keyCode == KeyEvent.KEYCODE_ASSIST) {
    if (down) {
      if (repeatCount == 0) {
        mAssistKeyLongPressed=false;
      }
 else       if (repeatCount == 1) {
        mAssistKeyLongPressed=true;
        if (!keyguardOn) {
          launchAssistLongPressAction();
        }
      }
    }
 else {
      if (mAssistKeyLongPressed) {
        mAssistKeyLongPressed=false;
      }
 else {
        if (!keyguardOn) {
          launchAssistAction(null,event.getDeviceId());
        }
      }
    }
    return -1;
  }
 else   if (keyCode == KeyEvent.KEYCODE_VOICE_ASSIST) {
    if (!down) {
      Intent voiceIntent;
      if (!keyguardOn) {
        voiceIntent=new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
      }
 else {
        IDeviceIdleController dic=IDeviceIdleController.Stub.asInterface(ServiceManager.getService(Context.DEVICE_IDLE_CONTROLLER));
        if (dic != null) {
          try {
            dic.exitIdle(""String_Node_Str"");
          }
 catch (          RemoteException e) {
          }
        }
        voiceIntent=new Intent(RecognizerIntent.ACTION_VOICE_SEARCH_HANDS_FREE);
        voiceIntent.putExtra(RecognizerIntent.EXTRA_SECURE,true);
      }
      startActivityAsUser(voiceIntent,UserHandle.CURRENT_OR_SELF);
    }
  }
 else   if (keyCode == KeyEvent.KEYCODE_SYSRQ) {
    if (down && repeatCount == 0) {
      mScreenshotRunnable.setScreenshotType(TAKE_SCREENSHOT_FULLSCREEN);
      mHandler.post(mScreenshotRunnable);
    }
    return -1;
  }
 else   if (keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP || keyCode == KeyEvent.KEYCODE_BRIGHTNESS_DOWN) {
    if (down) {
      int direction=keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP ? 1 : -1;
      int auto=Settings.System.getIntForUser(mContext.getContentResolver(),Settings.System.SCREEN_BRIGHTNESS_MODE,Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL,UserHandle.USER_CURRENT_OR_SELF);
      if (auto != 0) {
        Settings.System.putIntForUser(mContext.getContentResolver(),Settings.System.SCREEN_BRIGHTNESS_MODE,Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL,UserHandle.USER_CURRENT_OR_SELF);
      }
      int min=mPowerManager.getMinimumScreenBrightnessSetting();
      int max=mPowerManager.getMaximumScreenBrightnessSetting();
      int step=(max - min + BRIGHTNESS_STEPS - 1) / BRIGHTNESS_STEPS * direction;
      int brightness=Settings.System.getIntForUser(mContext.getContentResolver(),Settings.System.SCREEN_BRIGHTNESS,mPowerManager.getDefaultScreenBrightnessSetting(),UserHandle.USER_CURRENT_OR_SELF);
      brightness+=step;
      brightness=Math.min(max,brightness);
      brightness=Math.max(min,brightness);
      Settings.System.putIntForUser(mContext.getContentResolver(),Settings.System.SCREEN_BRIGHTNESS,brightness,UserHandle.USER_CURRENT_OR_SELF);
      startActivityAsUser(new Intent(Intent.ACTION_SHOW_BRIGHTNESS_DIALOG),UserHandle.CURRENT_OR_SELF);
    }
    return -1;
  }
 else   if (keyCode == KeyEvent.KEYCODE_VOLUME_UP || keyCode == KeyEvent.KEYCODE_VOLUME_DOWN || keyCode == KeyEvent.KEYCODE_VOLUME_MUTE) {
    if (mUseTvRouting) {
      dispatchDirectAudioEvent(event);
      return -1;
    }
  }
  boolean actionTriggered=false;
  if (KeyEvent.isModifierKey(keyCode)) {
    if (!mPendingCapsLockToggle) {
      mInitialMetaState=mMetaState;
      mPendingCapsLockToggle=true;
    }
 else     if (event.getAction() == KeyEvent.ACTION_UP) {
      int altOnMask=mMetaState & KeyEvent.META_ALT_MASK;
      int metaOnMask=mMetaState & KeyEvent.META_META_MASK;
      if ((metaOnMask != 0) && (altOnMask != 0)) {
        if (mInitialMetaState == (mMetaState ^ (altOnMask | metaOnMask))) {
          mInputManagerInternal.toggleCapsLock(event.getDeviceId());
          actionTriggered=true;
        }
      }
      mPendingCapsLockToggle=false;
    }
  }
  mMetaState=metaState;
  if (actionTriggered) {
    return -1;
  }
  if (KeyEvent.isMetaKey(keyCode)) {
    if (down) {
      mPendingMetaAction=true;
    }
 else     if (mPendingMetaAction) {
      launchAssistAction(Intent.EXTRA_ASSIST_INPUT_HINT_KEYBOARD,event.getDeviceId());
    }
    return -1;
  }
  if (mSearchKeyShortcutPending) {
    final KeyCharacterMap kcm=event.getKeyCharacterMap();
    if (kcm.isPrintingKey(keyCode)) {
      mConsumeSearchKeyUp=true;
      mSearchKeyShortcutPending=false;
      if (down && repeatCount == 0 && !keyguardOn) {
        Intent shortcutIntent=mShortcutManager.getIntent(kcm,keyCode,metaState);
        if (shortcutIntent != null) {
          shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
          try {
            startActivityAsUser(shortcutIntent,UserHandle.CURRENT);
          }
 catch (          ActivityNotFoundException ex) {
            Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ KeyEvent.keyCodeToString(keyCode),ex);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + ""String_Node_Str"" + KeyEvent.keyCodeToString(keyCode));
        }
      }
      return -1;
    }
  }
  if (down && repeatCount == 0 && !keyguardOn && (metaState & KeyEvent.META_META_ON) != 0) {
    final KeyCharacterMap kcm=event.getKeyCharacterMap();
    if (kcm.isPrintingKey(keyCode)) {
      Intent shortcutIntent=mShortcutManager.getIntent(kcm,keyCode,metaState & ~(KeyEvent.META_META_ON | KeyEvent.META_META_LEFT_ON | KeyEvent.META_META_RIGHT_ON));
      if (shortcutIntent != null) {
        shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        try {
          startActivityAsUser(shortcutIntent,UserHandle.CURRENT);
        }
 catch (        ActivityNotFoundException ex) {
          Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ KeyEvent.keyCodeToString(keyCode),ex);
        }
        return -1;
      }
    }
  }
  if (down && repeatCount == 0 && !keyguardOn) {
    String category=sApplicationLaunchKeyCategories.get(keyCode);
    if (category != null) {
      Intent intent=Intent.makeMainSelectorActivity(Intent.ACTION_MAIN,category);
      intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
      try {
        startActivityAsUser(intent,UserHandle.CURRENT);
      }
 catch (      ActivityNotFoundException ex) {
        Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + keyCode + ""String_Node_Str""+ category,ex);
      }
      return -1;
    }
  }
  if (down && repeatCount == 0 && keyCode == KeyEvent.KEYCODE_TAB) {
    if (mRecentAppsHeldModifiers == 0 && !keyguardOn && isUserSetupComplete()) {
      final int shiftlessModifiers=event.getModifiers() & ~KeyEvent.META_SHIFT_MASK;
      if (KeyEvent.metaStateHasModifiers(shiftlessModifiers,KeyEvent.META_ALT_ON)) {
        mRecentAppsHeldModifiers=shiftlessModifiers;
        showRecentApps(true);
        return -1;
      }
    }
  }
 else   if (!down && mRecentAppsHeldModifiers != 0 && (metaState & mRecentAppsHeldModifiers) == 0) {
    mRecentAppsHeldModifiers=0;
    hideRecentApps(true,false);
  }
  if (down && repeatCount == 0 && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || (keyCode == KeyEvent.KEYCODE_SPACE && (metaState & KeyEvent.META_META_MASK) != 0))) {
    final boolean forwardDirection=(metaState & KeyEvent.META_SHIFT_MASK) == 0;
    mWindowManagerFuncs.switchInputMethod(forwardDirection);
    return -1;
  }
  if (mLanguageSwitchKeyPressed && !down && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || keyCode == KeyEvent.KEYCODE_SPACE)) {
    mLanguageSwitchKeyPressed=false;
    return -1;
  }
  if (isValidGlobalKey(keyCode) && mGlobalKeyManager.handleGlobalKey(mContext,keyCode,event)) {
    return -1;
  }
  if (down) {
    long shortcutCode=(long)keyCode;
    if (event.isCtrlPressed()) {
      shortcutCode|=((long)KeyEvent.META_CTRL_ON) << Integer.SIZE;
    }
    if (event.isAltPressed()) {
      shortcutCode|=((long)KeyEvent.META_ALT_ON) << Integer.SIZE;
    }
    if (event.isShiftPressed()) {
      shortcutCode|=((long)KeyEvent.META_SHIFT_ON) << Integer.SIZE;
    }
    if (event.isMetaPressed()) {
      shortcutCode|=((long)KeyEvent.META_META_ON) << Integer.SIZE;
    }
    IShortcutService shortcutService=mShortcutKeyServices.get(shortcutCode);
    if (shortcutService != null) {
      try {
        shortcutService.notifyShortcutKeyPressed(shortcutCode);
      }
 catch (      RemoteException e) {
        mShortcutKeyServices.delete(shortcutCode);
      }
      return -1;
    }
  }
  if ((metaState & KeyEvent.META_META_ON) != 0) {
    return -1;
  }
  return 0;
}","/** 
 * {@inheritDoc} 
 */
@Override public long interceptKeyBeforeDispatching(WindowState win,KeyEvent event,int policyFlags){
  final boolean keyguardOn=keyguardOn();
  final int keyCode=event.getKeyCode();
  final int repeatCount=event.getRepeatCount();
  final int metaState=event.getMetaState();
  final int flags=event.getFlags();
  final boolean down=event.getAction() == KeyEvent.ACTION_DOWN;
  final boolean canceled=event.isCanceled();
  if (DEBUG_INPUT) {
    Log.d(TAG,""String_Node_Str"" + keyCode + ""String_Node_Str""+ down+ ""String_Node_Str""+ repeatCount+ ""String_Node_Str""+ keyguardOn+ ""String_Node_Str""+ mHomePressed+ ""String_Node_Str""+ canceled);
  }
  if (mScreenshotChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
    if (mScreenshotChordVolumeDownKeyTriggered && !mScreenshotChordPowerKeyTriggered) {
      final long now=SystemClock.uptimeMillis();
      final long timeoutTime=mScreenshotChordVolumeDownKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
      if (now < timeoutTime) {
        return timeoutTime - now;
      }
    }
    if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN && mScreenshotChordVolumeDownKeyConsumed) {
      if (!down) {
        mScreenshotChordVolumeDownKeyConsumed=false;
      }
      return -1;
    }
  }
  if (mPendingMetaAction && !KeyEvent.isMetaKey(keyCode)) {
    mPendingMetaAction=false;
  }
  if (mPendingCapsLockToggle && !KeyEvent.isMetaKey(keyCode) && !KeyEvent.isAltKey(keyCode)) {
    mPendingCapsLockToggle=false;
  }
  if (keyCode == KeyEvent.KEYCODE_HOME) {
    if (!down) {
      cancelPreloadRecentApps();
      mHomePressed=false;
      if (mHomeConsumed) {
        mHomeConsumed=false;
        return -1;
      }
      if (canceled) {
        Log.i(TAG,""String_Node_Str"");
        return -1;
      }
      TelecomManager telecomManager=getTelecommService();
      if (telecomManager != null && telecomManager.isRinging()) {
        Log.i(TAG,""String_Node_Str"");
        return -1;
      }
      if (mDoubleTapOnHomeBehavior != DOUBLE_TAP_HOME_NOTHING) {
        mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
        mHomeDoubleTapPending=true;
        mHandler.postDelayed(mHomeDoubleTapTimeoutRunnable,ViewConfiguration.getDoubleTapTimeout());
        return -1;
      }
      handleShortPressOnHome();
      return -1;
    }
    WindowManager.LayoutParams attrs=win != null ? win.getAttrs() : null;
    if (attrs != null) {
      final int type=attrs.type;
      if (type == WindowManager.LayoutParams.TYPE_KEYGUARD_SCRIM || type == WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG || (attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
        return 0;
      }
      final int typeCount=WINDOW_TYPES_WHERE_HOME_DOESNT_WORK.length;
      for (int i=0; i < typeCount; i++) {
        if (type == WINDOW_TYPES_WHERE_HOME_DOESNT_WORK[i]) {
          return -1;
        }
      }
    }
    if (repeatCount == 0) {
      mHomePressed=true;
      if (mHomeDoubleTapPending) {
        mHomeDoubleTapPending=false;
        mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
        handleDoubleTapOnHome();
      }
 else       if (mLongPressOnHomeBehavior == LONG_PRESS_HOME_RECENT_SYSTEM_UI || mDoubleTapOnHomeBehavior == DOUBLE_TAP_HOME_RECENT_SYSTEM_UI) {
        preloadRecentApps();
      }
    }
 else     if ((event.getFlags() & KeyEvent.FLAG_LONG_PRESS) != 0) {
      if (!keyguardOn) {
        handleLongPressOnHome(event.getDeviceId());
      }
    }
    return -1;
  }
 else   if (keyCode == KeyEvent.KEYCODE_MENU) {
    final int chordBug=KeyEvent.META_SHIFT_ON;
    if (down && repeatCount == 0) {
      if (mEnableShiftMenuBugReports && (metaState & chordBug) == chordBug) {
        Intent intent=new Intent(Intent.ACTION_BUG_REPORT);
        mContext.sendOrderedBroadcastAsUser(intent,UserHandle.CURRENT,null,null,null,0,null,null);
        return -1;
      }
 else       if (SHOW_PROCESSES_ON_ALT_MENU && (metaState & KeyEvent.META_ALT_ON) == KeyEvent.META_ALT_ON) {
        Intent service=new Intent();
        service.setClassName(mContext,""String_Node_Str"");
        ContentResolver res=mContext.getContentResolver();
        boolean shown=Settings.Global.getInt(res,Settings.Global.SHOW_PROCESSES,0) != 0;
        if (!shown) {
          mContext.startService(service);
        }
 else {
          mContext.stopService(service);
        }
        Settings.Global.putInt(res,Settings.Global.SHOW_PROCESSES,shown ? 0 : 1);
        return -1;
      }
    }
  }
 else   if (keyCode == KeyEvent.KEYCODE_SEARCH) {
    if (down) {
      if (repeatCount == 0) {
        mSearchKeyShortcutPending=true;
        mConsumeSearchKeyUp=false;
      }
    }
 else {
      mSearchKeyShortcutPending=false;
      if (mConsumeSearchKeyUp) {
        mConsumeSearchKeyUp=false;
        return -1;
      }
    }
    return 0;
  }
 else   if (keyCode == KeyEvent.KEYCODE_APP_SWITCH) {
    if (!keyguardOn) {
      if (down && repeatCount == 0) {
        preloadRecentApps();
      }
 else       if (!down) {
        toggleRecentApps();
      }
    }
    return -1;
  }
 else   if (keyCode == KeyEvent.KEYCODE_N && event.isMetaPressed()) {
    if (down) {
      IStatusBarService service=getStatusBarService();
      if (service != null) {
        try {
          service.expandNotificationsPanel();
        }
 catch (        RemoteException e) {
        }
      }
    }
  }
 else   if (keyCode == KeyEvent.KEYCODE_S && event.isMetaPressed() && event.isCtrlPressed()) {
    if (down && repeatCount == 0) {
      int type=event.isShiftPressed() ? TAKE_SCREENSHOT_SELECTED_REGION : TAKE_SCREENSHOT_FULLSCREEN;
      mScreenshotRunnable.setScreenshotType(type);
      mHandler.post(mScreenshotRunnable);
      return -1;
    }
  }
 else   if (keyCode == KeyEvent.KEYCODE_SLASH && event.isMetaPressed()) {
    if (down && repeatCount == 0 && !isKeyguardLocked()) {
      toggleKeyboardShortcutsMenu(event.getDeviceId());
    }
  }
 else   if (keyCode == KeyEvent.KEYCODE_ASSIST) {
    if (down) {
      if (repeatCount == 0) {
        mAssistKeyLongPressed=false;
      }
 else       if (repeatCount == 1) {
        mAssistKeyLongPressed=true;
        if (!keyguardOn) {
          launchAssistLongPressAction();
        }
      }
    }
 else {
      if (mAssistKeyLongPressed) {
        mAssistKeyLongPressed=false;
      }
 else {
        if (!keyguardOn) {
          launchAssistAction(null,event.getDeviceId());
        }
      }
    }
    return -1;
  }
 else   if (keyCode == KeyEvent.KEYCODE_VOICE_ASSIST) {
    if (!down) {
      Intent voiceIntent;
      if (!keyguardOn) {
        voiceIntent=new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
      }
 else {
        IDeviceIdleController dic=IDeviceIdleController.Stub.asInterface(ServiceManager.getService(Context.DEVICE_IDLE_CONTROLLER));
        if (dic != null) {
          try {
            dic.exitIdle(""String_Node_Str"");
          }
 catch (          RemoteException e) {
          }
        }
        voiceIntent=new Intent(RecognizerIntent.ACTION_VOICE_SEARCH_HANDS_FREE);
        voiceIntent.putExtra(RecognizerIntent.EXTRA_SECURE,true);
      }
      startActivityAsUser(voiceIntent,UserHandle.CURRENT_OR_SELF);
    }
  }
 else   if (keyCode == KeyEvent.KEYCODE_SYSRQ) {
    if (down && repeatCount == 0) {
      mScreenshotRunnable.setScreenshotType(TAKE_SCREENSHOT_FULLSCREEN);
      mHandler.post(mScreenshotRunnable);
    }
    return -1;
  }
 else   if (keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP || keyCode == KeyEvent.KEYCODE_BRIGHTNESS_DOWN) {
    if (down) {
      int direction=keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP ? 1 : -1;
      int auto=Settings.System.getIntForUser(mContext.getContentResolver(),Settings.System.SCREEN_BRIGHTNESS_MODE,Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL,UserHandle.USER_CURRENT_OR_SELF);
      if (auto != 0) {
        Settings.System.putIntForUser(mContext.getContentResolver(),Settings.System.SCREEN_BRIGHTNESS_MODE,Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL,UserHandle.USER_CURRENT_OR_SELF);
      }
      int min=mPowerManager.getMinimumScreenBrightnessSetting();
      int max=mPowerManager.getMaximumScreenBrightnessSetting();
      int step=(max - min + BRIGHTNESS_STEPS - 1) / BRIGHTNESS_STEPS * direction;
      int brightness=Settings.System.getIntForUser(mContext.getContentResolver(),Settings.System.SCREEN_BRIGHTNESS,mPowerManager.getDefaultScreenBrightnessSetting(),UserHandle.USER_CURRENT_OR_SELF);
      brightness+=step;
      brightness=Math.min(max,brightness);
      brightness=Math.max(min,brightness);
      Settings.System.putIntForUser(mContext.getContentResolver(),Settings.System.SCREEN_BRIGHTNESS,brightness,UserHandle.USER_CURRENT_OR_SELF);
      startActivityAsUser(new Intent(Intent.ACTION_SHOW_BRIGHTNESS_DIALOG),UserHandle.CURRENT_OR_SELF);
    }
    return -1;
  }
 else   if (keyCode == KeyEvent.KEYCODE_VOLUME_UP || keyCode == KeyEvent.KEYCODE_VOLUME_DOWN || keyCode == KeyEvent.KEYCODE_VOLUME_MUTE) {
    if (mUseTvRouting) {
      dispatchDirectAudioEvent(event);
      return -1;
    }
  }
  boolean actionTriggered=false;
  if (KeyEvent.isModifierKey(keyCode)) {
    if (!mPendingCapsLockToggle) {
      mInitialMetaState=mMetaState;
      mPendingCapsLockToggle=true;
    }
 else     if (event.getAction() == KeyEvent.ACTION_UP) {
      int altOnMask=mMetaState & KeyEvent.META_ALT_MASK;
      int metaOnMask=mMetaState & KeyEvent.META_META_MASK;
      if ((metaOnMask != 0) && (altOnMask != 0)) {
        if (mInitialMetaState == (mMetaState ^ (altOnMask | metaOnMask))) {
          mInputManagerInternal.toggleCapsLock(event.getDeviceId());
          actionTriggered=true;
        }
      }
      mPendingCapsLockToggle=false;
    }
  }
  mMetaState=metaState;
  if (actionTriggered) {
    return -1;
  }
  if (KeyEvent.isMetaKey(keyCode)) {
    if (down) {
      mPendingMetaAction=true;
    }
 else     if (mPendingMetaAction) {
      launchAssistAction(Intent.EXTRA_ASSIST_INPUT_HINT_KEYBOARD,event.getDeviceId());
    }
    return -1;
  }
  if (mSearchKeyShortcutPending) {
    final KeyCharacterMap kcm=event.getKeyCharacterMap();
    if (kcm.isPrintingKey(keyCode)) {
      mConsumeSearchKeyUp=true;
      mSearchKeyShortcutPending=false;
      if (down && repeatCount == 0 && !keyguardOn) {
        Intent shortcutIntent=mShortcutManager.getIntent(kcm,keyCode,metaState);
        if (shortcutIntent != null) {
          shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
          try {
            startActivityAsUser(shortcutIntent,UserHandle.CURRENT);
          }
 catch (          ActivityNotFoundException ex) {
            Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ KeyEvent.keyCodeToString(keyCode),ex);
          }
        }
 else {
          Slog.i(TAG,""String_Node_Str"" + ""String_Node_Str"" + KeyEvent.keyCodeToString(keyCode));
        }
      }
      return -1;
    }
  }
  if (down && repeatCount == 0 && !keyguardOn && (metaState & KeyEvent.META_META_ON) != 0) {
    final KeyCharacterMap kcm=event.getKeyCharacterMap();
    if (kcm.isPrintingKey(keyCode)) {
      Intent shortcutIntent=mShortcutManager.getIntent(kcm,keyCode,metaState & ~(KeyEvent.META_META_ON | KeyEvent.META_META_LEFT_ON | KeyEvent.META_META_RIGHT_ON));
      if (shortcutIntent != null) {
        shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        try {
          startActivityAsUser(shortcutIntent,UserHandle.CURRENT);
        }
 catch (        ActivityNotFoundException ex) {
          Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ KeyEvent.keyCodeToString(keyCode),ex);
        }
        return -1;
      }
    }
  }
  if (down && repeatCount == 0 && !keyguardOn) {
    String category=sApplicationLaunchKeyCategories.get(keyCode);
    if (category != null) {
      Intent intent=Intent.makeMainSelectorActivity(Intent.ACTION_MAIN,category);
      intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
      try {
        startActivityAsUser(intent,UserHandle.CURRENT);
      }
 catch (      ActivityNotFoundException ex) {
        Slog.w(TAG,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + keyCode + ""String_Node_Str""+ category,ex);
      }
      return -1;
    }
  }
  if (down && repeatCount == 0 && keyCode == KeyEvent.KEYCODE_TAB) {
    if (mRecentAppsHeldModifiers == 0 && !keyguardOn && isUserSetupComplete()) {
      final int shiftlessModifiers=event.getModifiers() & ~KeyEvent.META_SHIFT_MASK;
      if (KeyEvent.metaStateHasModifiers(shiftlessModifiers,KeyEvent.META_ALT_ON)) {
        mRecentAppsHeldModifiers=shiftlessModifiers;
        showRecentApps(true);
        return -1;
      }
    }
  }
 else   if (!down && mRecentAppsHeldModifiers != 0 && (metaState & mRecentAppsHeldModifiers) == 0) {
    mRecentAppsHeldModifiers=0;
    hideRecentApps(true,false);
  }
  if (down && repeatCount == 0 && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || (keyCode == KeyEvent.KEYCODE_SPACE && (metaState & KeyEvent.META_META_MASK) != 0))) {
    final boolean forwardDirection=(metaState & KeyEvent.META_SHIFT_MASK) == 0;
    mWindowManagerFuncs.switchInputMethod(forwardDirection);
    return -1;
  }
  if (mLanguageSwitchKeyPressed && !down && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || keyCode == KeyEvent.KEYCODE_SPACE)) {
    mLanguageSwitchKeyPressed=false;
    return -1;
  }
  if (isValidGlobalKey(keyCode) && mGlobalKeyManager.handleGlobalKey(mContext,keyCode,event)) {
    return -1;
  }
  if (down) {
    long shortcutCode=(long)keyCode;
    if (event.isCtrlPressed()) {
      shortcutCode|=((long)KeyEvent.META_CTRL_ON) << Integer.SIZE;
    }
    if (event.isAltPressed()) {
      shortcutCode|=((long)KeyEvent.META_ALT_ON) << Integer.SIZE;
    }
    if (event.isShiftPressed()) {
      shortcutCode|=((long)KeyEvent.META_SHIFT_ON) << Integer.SIZE;
    }
    if (event.isMetaPressed()) {
      shortcutCode|=((long)KeyEvent.META_META_ON) << Integer.SIZE;
    }
    IShortcutService shortcutService=mShortcutKeyServices.get(shortcutCode);
    if (shortcutService != null) {
      try {
        if (isUserSetupComplete()) {
          shortcutService.notifyShortcutKeyPressed(shortcutCode);
        }
      }
 catch (      RemoteException e) {
        mShortcutKeyServices.delete(shortcutCode);
      }
      return -1;
    }
  }
  if ((metaState & KeyEvent.META_META_ON) != 0) {
    return -1;
  }
  return 0;
}",0.9982883291997066
192119,"private boolean isFlushed(SpeechItem speechItem){
synchronized (mFlushedObjects) {
    return mFlushAll || mFlushedObjects.contains(speechItem.getCallerIdentity());
  }
}","private boolean isFlushed(SpeechItem speechItem){
synchronized (mFlushedObjects) {
    return mFlushAll > 0 || mFlushedObjects.contains(speechItem.getCallerIdentity());
  }
}",0.9883720930232558
192120,"private void startFlushingSpeechItems(Object callerIdentity){
synchronized (mFlushedObjects) {
    if (callerIdentity == null) {
      mFlushAll=true;
    }
 else {
      mFlushedObjects.add(callerIdentity);
    }
  }
}","private void startFlushingSpeechItems(Object callerIdentity){
synchronized (mFlushedObjects) {
    if (callerIdentity == null) {
      mFlushAll+=1;
    }
 else {
      mFlushedObjects.add(callerIdentity);
    }
  }
}",0.9862385321100916
192121,"private void endFlushingSpeechItems(Object callerIdentity){
synchronized (mFlushedObjects) {
    if (callerIdentity == null) {
      mFlushAll=false;
    }
 else {
      mFlushedObjects.remove(callerIdentity);
    }
  }
}","private void endFlushingSpeechItems(Object callerIdentity){
synchronized (mFlushedObjects) {
    if (callerIdentity == null) {
      mFlushAll-=1;
    }
 else {
      mFlushedObjects.remove(callerIdentity);
    }
  }
}",0.9840546697038725
192122,"public final int broadcastIntent(IApplicationThread caller,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle resultExtras,String[] requiredPermissions,int appOp,Bundle bOptions,boolean serialized,boolean sticky,int userId){
  enforceNotIsolatedCaller(""String_Node_Str"");
synchronized (this) {
    intent=verifyBroadcastLocked(intent);
    final ProcessRecord callerApp=getRecordForAppLocked(caller);
    final int callingPid=Binder.getCallingPid();
    final int callingUid=Binder.getCallingUid();
    final long origId=Binder.clearCallingIdentity();
    int res=broadcastIntentLocked(callerApp,callerApp != null ? callerApp.info.packageName : null,intent,resolvedType,resultTo,resultCode,resultData,resultExtras,requiredPermissions,appOp,null,serialized,sticky,callingPid,callingUid,userId);
    Binder.restoreCallingIdentity(origId);
    return res;
  }
}","public final int broadcastIntent(IApplicationThread caller,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle resultExtras,String[] requiredPermissions,int appOp,Bundle bOptions,boolean serialized,boolean sticky,int userId){
  enforceNotIsolatedCaller(""String_Node_Str"");
synchronized (this) {
    intent=verifyBroadcastLocked(intent);
    final ProcessRecord callerApp=getRecordForAppLocked(caller);
    final int callingPid=Binder.getCallingPid();
    final int callingUid=Binder.getCallingUid();
    final long origId=Binder.clearCallingIdentity();
    int res=broadcastIntentLocked(callerApp,callerApp != null ? callerApp.info.packageName : null,intent,resolvedType,resultTo,resultCode,resultData,resultExtras,requiredPermissions,appOp,bOptions,serialized,sticky,callingPid,callingUid,userId);
    Binder.restoreCallingIdentity(origId);
    return res;
  }
}",0.9933920704845814
192123,"public final int broadcastIntent(IApplicationThread caller,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle resultExtras,String[] requiredPermissions,int appOp,Bundle bOptions,boolean serialized,boolean sticky,int userId){
  enforceNotIsolatedCaller(""String_Node_Str"");
synchronized (this) {
    intent=verifyBroadcastLocked(intent);
    final ProcessRecord callerApp=getRecordForAppLocked(caller);
    final int callingPid=Binder.getCallingPid();
    final int callingUid=Binder.getCallingUid();
    final long origId=Binder.clearCallingIdentity();
    int res=broadcastIntentLocked(callerApp,callerApp != null ? callerApp.info.packageName : null,intent,resolvedType,resultTo,resultCode,resultData,resultExtras,requiredPermissions,appOp,null,serialized,sticky,callingPid,callingUid,userId);
    Binder.restoreCallingIdentity(origId);
    return res;
  }
}","public final int broadcastIntent(IApplicationThread caller,Intent intent,String resolvedType,IIntentReceiver resultTo,int resultCode,String resultData,Bundle resultExtras,String[] requiredPermissions,int appOp,Bundle bOptions,boolean serialized,boolean sticky,int userId){
  enforceNotIsolatedCaller(""String_Node_Str"");
synchronized (this) {
    intent=verifyBroadcastLocked(intent);
    final ProcessRecord callerApp=getRecordForAppLocked(caller);
    final int callingPid=Binder.getCallingPid();
    final int callingUid=Binder.getCallingUid();
    final long origId=Binder.clearCallingIdentity();
    int res=broadcastIntentLocked(callerApp,callerApp != null ? callerApp.info.packageName : null,intent,resolvedType,resultTo,resultCode,resultData,resultExtras,requiredPermissions,appOp,bOptions,serialized,sticky,callingPid,callingUid,userId);
    Binder.restoreCallingIdentity(origId);
    return res;
  }
}",0.9933920704845814
192124,"@Override protected void onDraw(Canvas canvas){
  if (mInvisible) {
    return;
  }
  int viewWidth=mTaskViewRect.width();
  int viewHeight=mTaskViewRect.height();
  if (mBitmapShader != null) {
    int thumbnailWidth=(int)(mThumbnailRect.width() * mThumbnailScale);
    int thumbnailHeight=(int)(mThumbnailRect.height() * mThumbnailScale);
    if (thumbnailWidth >= viewWidth && thumbnailHeight >= viewHeight) {
      canvas.drawRoundRect(0,0,viewWidth,viewHeight,mCornerRadius,mCornerRadius,mDrawPaint);
    }
 else {
      int count=canvas.save();
      canvas.clipRect(0,0,thumbnailWidth,thumbnailHeight,Region.Op.REPLACE);
      canvas.drawRoundRect(0,0,thumbnailWidth + (thumbnailWidth < viewWidth ? mCornerRadius : 0),thumbnailHeight + (thumbnailHeight < viewHeight ? mCornerRadius : 0),mCornerRadius,mCornerRadius,mDrawPaint);
      if (thumbnailWidth < viewWidth) {
        canvas.clipRect(thumbnailWidth,0,viewWidth,viewHeight,Region.Op.REPLACE);
        canvas.drawRoundRect(Math.max(0,thumbnailWidth - mCornerRadius),0,viewWidth,viewHeight,mCornerRadius,mCornerRadius,mBgFillPaint);
      }
      if (thumbnailWidth > 0 && thumbnailHeight < viewHeight) {
        canvas.clipRect(0,thumbnailHeight,viewWidth,viewHeight,Region.Op.REPLACE);
        canvas.drawRoundRect(0,Math.max(0,thumbnailHeight - mCornerRadius),viewWidth,viewHeight,mCornerRadius,mCornerRadius,mBgFillPaint);
      }
      canvas.restoreToCount(count);
    }
  }
 else {
    canvas.drawRoundRect(0,0,viewWidth,viewHeight,mCornerRadius,mCornerRadius,mBgFillPaint);
  }
}","@Override protected void onDraw(Canvas canvas){
  if (mInvisible) {
    return;
  }
  int viewWidth=mTaskViewRect.width();
  int viewHeight=mTaskViewRect.height();
  int thumbnailWidth=Math.min(viewWidth,(int)(mThumbnailRect.width() * mThumbnailScale));
  int thumbnailHeight=Math.min(viewHeight,(int)(mThumbnailRect.height() * mThumbnailScale));
  if (mBitmapShader != null && thumbnailWidth > 0 && thumbnailHeight > 0) {
    if (thumbnailWidth < viewWidth) {
      canvas.drawRoundRect(Math.max(0,thumbnailWidth - mCornerRadius),0,viewWidth,viewHeight,mCornerRadius,mCornerRadius,mBgFillPaint);
    }
    if (thumbnailHeight < viewHeight) {
      canvas.drawRoundRect(0,Math.max(0,thumbnailHeight - mCornerRadius),viewWidth,viewHeight,mCornerRadius,mCornerRadius,mBgFillPaint);
    }
    canvas.drawRoundRect(0,0,thumbnailWidth,thumbnailHeight,mCornerRadius,mCornerRadius,mDrawPaint);
  }
 else {
    canvas.drawRoundRect(0,0,viewWidth,viewHeight,mCornerRadius,mCornerRadius,mBgFillPaint);
  }
}",0.3362136684996072
192125,"@Override protected void onDraw(Canvas canvas){
  if (mInvisible) {
    return;
  }
  int viewWidth=mTaskViewRect.width();
  int viewHeight=mTaskViewRect.height();
  if (mBitmapShader != null) {
    int thumbnailWidth=(int)(mThumbnailRect.width() * mThumbnailScale);
    int thumbnailHeight=(int)(mThumbnailRect.height() * mThumbnailScale);
    if (thumbnailWidth >= viewWidth && thumbnailHeight >= viewHeight) {
      canvas.drawRoundRect(0,0,viewWidth,viewHeight,mCornerRadius,mCornerRadius,mDrawPaint);
    }
 else {
      int count=canvas.save();
      canvas.clipRect(0,0,thumbnailWidth,thumbnailHeight,Region.Op.REPLACE);
      canvas.drawRoundRect(0,0,thumbnailWidth + (thumbnailWidth < viewWidth ? mCornerRadius : 0),thumbnailHeight + (thumbnailHeight < viewHeight ? mCornerRadius : 0),mCornerRadius,mCornerRadius,mDrawPaint);
      if (thumbnailWidth < viewWidth) {
        canvas.clipRect(thumbnailWidth,0,viewWidth,viewHeight,Region.Op.REPLACE);
        canvas.drawRoundRect(Math.max(0,thumbnailWidth - mCornerRadius),0,viewWidth,viewHeight,mCornerRadius,mCornerRadius,mBgFillPaint);
      }
      if (thumbnailWidth > 0 && thumbnailHeight < viewHeight) {
        canvas.clipRect(0,thumbnailHeight,viewWidth,viewHeight,Region.Op.REPLACE);
        canvas.drawRoundRect(0,Math.max(0,thumbnailHeight - mCornerRadius),viewWidth,viewHeight,mCornerRadius,mCornerRadius,mBgFillPaint);
      }
      canvas.restoreToCount(count);
    }
  }
 else {
    canvas.drawRoundRect(0,0,viewWidth,viewHeight,mCornerRadius,mCornerRadius,mBgFillPaint);
  }
}","@Override protected void onDraw(Canvas canvas){
  if (mInvisible) {
    return;
  }
  int viewWidth=mTaskViewRect.width();
  int viewHeight=mTaskViewRect.height();
  int thumbnailWidth=Math.min(viewWidth,(int)(mThumbnailRect.width() * mThumbnailScale));
  int thumbnailHeight=Math.min(viewHeight,(int)(mThumbnailRect.height() * mThumbnailScale));
  if (mBitmapShader != null && thumbnailWidth > 0 && thumbnailHeight > 0) {
    if (thumbnailWidth < viewWidth) {
      canvas.drawRoundRect(Math.max(0,thumbnailWidth - mCornerRadius),0,viewWidth,viewHeight,mCornerRadius,mCornerRadius,mBgFillPaint);
    }
    if (thumbnailHeight < viewHeight) {
      canvas.drawRoundRect(0,Math.max(0,thumbnailHeight - mCornerRadius),viewWidth,viewHeight,mCornerRadius,mCornerRadius,mBgFillPaint);
    }
    canvas.drawRoundRect(0,0,thumbnailWidth,thumbnailHeight,mCornerRadius,mCornerRadius,mDrawPaint);
  }
 else {
    canvas.drawRoundRect(0,0,viewWidth,viewHeight,mCornerRadius,mCornerRadius,mBgFillPaint);
  }
}",0.3362136684996072
192126,"private void writeCompactedLongArray(Parcel out,long[] array,int num){
  for (int i=0; i < num; i++) {
    long val=array[i];
    if (val < 0) {
      Slog.w(TAG,""String_Node_Str"" + val);
      val=0;
    }
    if (val <= Integer.MAX_VALUE) {
      out.writeInt((int)val);
    }
 else {
      int top=~((int)((val >> 32) & 0x7fffffff));
      int bottom=(int)(val & 0xfffffff);
      out.writeInt(top);
      out.writeInt(bottom);
    }
  }
}","private void writeCompactedLongArray(Parcel out,long[] array,int num){
  for (int i=0; i < num; i++) {
    long val=array[i];
    if (val < 0) {
      Slog.w(TAG,""String_Node_Str"" + val);
      val=0;
    }
    if (val <= Integer.MAX_VALUE) {
      out.writeInt((int)val);
    }
 else {
      int top=~((int)((val >> 32) & 0x7fffffff));
      int bottom=(int)(val & 0x0ffffffffL);
      out.writeInt(top);
      out.writeInt(bottom);
    }
  }
}",0.9808342728297632
192127,"/** 
 * Allocates data in the buffer, and stores that key in the mapping for this table.
 * @param id    The id of the item (will be used in making the key)
 * @param count The number of bytes to allocate.  Must be less thanSparseMappingTable.ARRAY_SIZE.
 * @return The 'key' for this data value, which contains both the id itselfand the location in the long arrays that the data is actually stored but should be considered opaque to the caller.
 */
public int getOrAddKey(byte id,int count){
  if (mSequence == UNINITIALIZED_SEQUENCE) {
    mSequence=mParent.mSequence;
  }
  assertConsistency();
  final int idx=binarySearch(id);
  if (idx >= 0) {
    return mTable[idx];
  }
 else {
    final ArrayList<long[]> list=mParent.mLongs;
    int whichArray=list.size() - 1;
    long[] array=list.get(whichArray);
    if (mParent.mNextIndex + count > array.length) {
      array=new long[ARRAY_SIZE];
      list.add(array);
      whichArray++;
      mParent.mNextIndex=0;
    }
    final int key=(whichArray << ARRAY_SHIFT) | (mParent.mNextIndex << INDEX_SHIFT) | (((int)id) << ID_SHIFT);
    mParent.mNextIndex+=count;
    mTable=GrowingArrayUtils.insert(mTable != null ? mTable : EmptyArray.INT,mSize,~idx,key);
    mSize++;
    return key;
  }
}","/** 
 * Allocates data in the buffer, and stores that key in the mapping for this table.
 * @param id    The id of the item (will be used in making the key)
 * @param count The number of bytes to allocate.  Must be less thanSparseMappingTable.ARRAY_SIZE.
 * @return The 'key' for this data value, which contains both the id itselfand the location in the long arrays that the data is actually stored but should be considered opaque to the caller.
 */
public int getOrAddKey(byte id,int count){
  assertConsistency();
  final int idx=binarySearch(id);
  if (idx >= 0) {
    return mTable[idx];
  }
 else {
    final ArrayList<long[]> list=mParent.mLongs;
    int whichArray=list.size() - 1;
    long[] array=list.get(whichArray);
    if (mParent.mNextIndex + count > array.length) {
      array=new long[ARRAY_SIZE];
      list.add(array);
      whichArray++;
      mParent.mNextIndex=0;
    }
    final int key=(whichArray << ARRAY_SHIFT) | (mParent.mNextIndex << INDEX_SHIFT) | (((int)id) << ID_SHIFT);
    mParent.mNextIndex+=count;
    mTable=GrowingArrayUtils.insert(mTable != null ? mTable : EmptyArray.INT,mSize,~idx,key);
    mSize++;
    return key;
  }
}",0.9659185369908562
192128,"/** 
 * Clear out the table, and reset the sequence numbers so future writes without allocations will assert.
 */
public void resetTable(){
  mTable=null;
  mSize=0;
  mSequence=UNINITIALIZED_SEQUENCE;
}","/** 
 * Clear out the table, and reset the sequence numbers so future writes without allocations will assert.
 */
public void resetTable(){
  mTable=null;
  mSize=0;
  mSequence=mParent.mSequence;
}",0.9077306733167082
192129,"public String dumpInternalState(){
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"");
  sb.append(mSequence);
  sb.append(""String_Node_Str"");
  sb.append(mParent.mSequence);
  sb.append(""String_Node_Str"");
  sb.append(mParent.mLongs.size());
  sb.append(""String_Node_Str"");
  sb.append(mSize);
  sb.append(""String_Node_Str"");
  if (mTable == null) {
    sb.append(""String_Node_Str"");
  }
 else {
    final int N=mTable.length;
    sb.append('[');
    for (int i=0; i < N; i++) {
      final int key=mTable[i];
      sb.append(""String_Node_Str"");
      sb.append(Integer.toHexString((key >> ID_SHIFT) & ID_MASK));
      sb.append(""String_Node_Str"");
      sb.append(Integer.toHexString((key >> ARRAY_SHIFT) & ARRAY_MASK));
      sb.append(""String_Node_Str"");
      sb.append(Integer.toHexString((key >> INDEX_SHIFT) & INDEX_MASK));
      if (i != N - 1) {
        sb.append(""String_Node_Str"");
      }
    }
    sb.append(']');
  }
  sb.append(""String_Node_Str"");
  sb.append(getClass().getName());
  sb.append('}');
  return sb.toString();
}","/** 
 * Return a string for debugging.
 */
public String dumpInternalState(boolean includeData){
  final StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(mSequence);
  sb.append(""String_Node_Str"");
  sb.append(mNextIndex);
  sb.append(""String_Node_Str"");
  final int N=mLongs.size();
  sb.append(N);
  sb.append(""String_Node_Str"");
  if (includeData) {
    for (int i=0; i < N; i++) {
      final long[] array=mLongs.get(i);
      for (int j=0; j < array.length; j++) {
        if (i == N - 1 && j == mNextIndex) {
          break;
        }
        sb.append(String.format(""String_Node_Str"",i,j,array[j],array[j]));
      }
    }
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}",0.3276525563496427
192130,"/** 
 * Write the long array to the parcel in a compacted form.  Does not allow negative values in the array.
 */
private static void writeCompactedLongArray(Parcel out,long[] array,int num){
  for (int i=0; i < num; i++) {
    long val=array[i];
    if (val < 0) {
      Slog.w(TAG,""String_Node_Str"" + val);
      val=0;
    }
    if (val <= Integer.MAX_VALUE) {
      out.writeInt((int)val);
    }
 else {
      int top=~((int)((val >> 32) & 0x7fffffff));
      int bottom=(int)(val & 0xfffffff);
      out.writeInt(top);
      out.writeInt(bottom);
    }
  }
}","/** 
 * Write the long array to the parcel in a compacted form.  Does not allow negative values in the array.
 */
private static void writeCompactedLongArray(Parcel out,long[] array,int num){
  for (int i=0; i < num; i++) {
    long val=array[i];
    if (val < 0) {
      Slog.w(TAG,""String_Node_Str"" + val);
      val=0;
    }
    if (val <= Integer.MAX_VALUE) {
      out.writeInt((int)val);
    }
 else {
      int top=~((int)((val >> 32) & 0x7fffffff));
      int bottom=(int)(val & 0x0ffffffffL);
      out.writeInt(top);
      out.writeInt(bottom);
    }
  }
}",0.9849424269264836
192131,"/** 
 * Throw an exception if one of a variety of internal consistency checks fails.
 */
private void assertConsistency(){
  if (false) {
    if (mSequence == UNINITIALIZED_SEQUENCE) {
      logOrThrow(""String_Node_Str"" + ""String_Node_Str"" + dumpInternalState());
      return;
    }
    if (mSequence != mParent.mSequence) {
      if (mSequence < mParent.mSequence) {
        logOrThrow(""String_Node_Str"" + ""String_Node_Str"" + dumpInternalState());
        return;
      }
 else       if (mSequence > mParent.mSequence) {
        logOrThrow(""String_Node_Str"" + ""String_Node_Str"" + dumpInternalState());
        return;
      }
    }
  }
}","/** 
 * Throw an exception if one of a variety of internal consistency checks fails.
 */
private void assertConsistency(){
  if (false) {
    if (mSequence != mParent.mSequence) {
      if (mSequence < mParent.mSequence) {
        logOrThrow(""String_Node_Str"" + ""String_Node_Str"" + dumpInternalState());
        return;
      }
 else       if (mSequence > mParent.mSequence) {
        logOrThrow(""String_Node_Str"" + ""String_Node_Str"" + dumpInternalState());
        return;
      }
    }
  }
}",0.7049469964664311
192132,"void dismissRecentsToHome(boolean animateTaskViews){
  Runnable closeSystemWindows=new Runnable(){
    @Override public void run(){
      Recents.getSystemServices().sendCloseSystemWindows(BaseStatusBar.SYSTEM_DIALOG_REASON_HOME_KEY);
    }
  }
;
  DismissRecentsToHomeAnimationStarted dismissEvent=new DismissRecentsToHomeAnimationStarted(animateTaskViews);
  dismissEvent.addPostAnimationCallback(mFinishLaunchHomeRunnable);
  dismissEvent.addPostAnimationCallback(closeSystemWindows);
  if (mTaskStackHorizontalGridView.getChildCount() > 0) {
    mHomeRecentsEnterExitAnimationHolder.startExitAnimation(dismissEvent);
  }
 else {
    closeSystemWindows.run();
    mFinishLaunchHomeRunnable.run();
  }
}","void dismissRecentsToHome(boolean animateTaskViews){
  Runnable closeSystemWindows=new Runnable(){
    @Override public void run(){
      Recents.getSystemServices().sendCloseSystemWindows(BaseStatusBar.SYSTEM_DIALOG_REASON_HOME_KEY);
    }
  }
;
  DismissRecentsToHomeAnimationStarted dismissEvent=new DismissRecentsToHomeAnimationStarted(animateTaskViews);
  dismissEvent.addPostAnimationCallback(mFinishLaunchHomeRunnable);
  dismissEvent.addPostAnimationCallback(closeSystemWindows);
  if (mTaskStackHorizontalGridView.getChildCount() > 0 && animateTaskViews) {
    mHomeRecentsEnterExitAnimationHolder.startExitAnimation(dismissEvent);
  }
 else {
    closeSystemWindows.run();
    mFinishLaunchHomeRunnable.run();
  }
}",0.986013986013986
192133,"public DismissAnimationsHolder(TaskCardView taskCardView){
  mTaskCardView=(LinearLayout)taskCardView.findViewById(R.id.recents_tv_card);
  mDismissArea=(LinearLayout)taskCardView.findViewById(R.id.card_dismiss);
  Resources res=taskCardView.getResources();
  mCardYDelta=res.getDimensionPixelOffset(R.dimen.recents_tv_dismiss_shift_down);
  mShortDuration=res.getInteger(R.integer.dismiss_short_duration);
  mLongDuration=res.getInteger(R.integer.dismiss_long_duration);
}","public DismissAnimationsHolder(TaskCardView taskCardView){
  mRecentsTvCard=(LinearLayout)taskCardView.findViewById(R.id.recents_tv_card);
  mDismissArea=(LinearLayout)taskCardView.findViewById(R.id.card_dismiss);
  Resources res=taskCardView.getResources();
  mCardYDelta=res.getDimensionPixelOffset(R.dimen.recents_tv_dismiss_shift_down);
  mShortDuration=res.getInteger(R.integer.dismiss_short_duration);
  mLongDuration=res.getInteger(R.integer.dismiss_long_duration);
}",0.97571277719113
192134,"public void startExitAnimation(){
  mDismissArea.animate().setDuration(mShortDuration).setInterpolator(Interpolators.FAST_OUT_SLOW_IN).alpha(0.0f);
  mTaskCardView.animate().setDuration(mShortDuration).setInterpolator(Interpolators.FAST_OUT_SLOW_IN).translationYBy(-mCardYDelta).alpha(1.0f);
}","public void startExitAnimation(){
  mDismissArea.animate().setDuration(mShortDuration).setInterpolator(Interpolators.FAST_OUT_SLOW_IN).alpha(0.0f);
  mRecentsTvCard.animate().setDuration(mShortDuration).setInterpolator(Interpolators.FAST_OUT_SLOW_IN).translationYBy(-mCardYDelta).alpha(1.0f);
}",0.9710391822827938
192135,"public void startDismissAnimation(Animator.AnimatorListener listener){
  mDismissArea.animate().setDuration(mShortDuration).setInterpolator(Interpolators.FAST_OUT_SLOW_IN).alpha(0.0f);
  mTaskCardView.animate().setDuration(mLongDuration).setInterpolator(Interpolators.FAST_OUT_SLOW_IN).translationYBy(mCardYDelta).alpha(0.0f).setListener(listener);
}","public void startDismissAnimation(Animator.AnimatorListener listener){
  mDismissArea.animate().setDuration(mShortDuration).setInterpolator(Interpolators.FAST_OUT_SLOW_IN).alpha(0.0f);
  mRecentsTvCard.animate().setDuration(mLongDuration).setInterpolator(Interpolators.FAST_OUT_SLOW_IN).translationYBy(mCardYDelta).alpha(0.0f).setListener(listener);
}",0.9757489300998572
192136,"public void startEnterAnimation(){
  mDismissArea.animate().setDuration(mShortDuration).setInterpolator(Interpolators.FAST_OUT_SLOW_IN).alpha(1.0f);
  mTaskCardView.animate().setDuration(mShortDuration).setInterpolator(Interpolators.FAST_OUT_SLOW_IN).translationYBy(mCardYDelta).alpha(0.5f);
}","public void startEnterAnimation(){
  mDismissArea.animate().setDuration(mShortDuration).setInterpolator(Interpolators.FAST_OUT_SLOW_IN).alpha(1.0f);
  mRecentsTvCard.animate().setDuration(mShortDuration).setInterpolator(Interpolators.FAST_OUT_SLOW_IN).translationYBy(mCardYDelta).alpha(0.5f);
}",0.9710391822827938
192137,"public TaskStackHorizontalGridView setTaskStackViewAdapter(TaskStackHorizontalViewAdapter taskStackViewAdapter){
  if (mTaskStackHorizontalView != null) {
    mTaskStackHorizontalView.setAdapter(taskStackViewAdapter);
  }
  return mTaskStackHorizontalView;
}","public TaskStackHorizontalGridView setTaskStackViewAdapter(TaskStackHorizontalViewAdapter taskStackViewAdapter){
  if (mTaskStackHorizontalView != null) {
    mTaskStackHorizontalView.setAdapter(taskStackViewAdapter);
    taskStackViewAdapter.setTaskStackHorizontalGridView(mTaskStackHorizontalView);
  }
  return mTaskStackHorizontalView;
}",0.8614357262103506
192138,"public void startDismissTaskAnimation(Animator.AnimatorListener listener){
  mDismissAnimationsHolder.startDismissAnimation(listener);
}","public void startDismissTaskAnimation(Animator.AnimatorListener listener){
  mDismissState=false;
  mDismissAnimationsHolder.startDismissAnimation(listener);
}",0.9220338983050848
192139,"@Override public void onStackTaskRemoved(TaskStack stack,Task removedTask,boolean wasFrontMostTask,Task newFrontMostTask,AnimationProps animation,boolean fromDockGesture){
  getAdapter().notifyItemRemoved(stack.getStackTasks().indexOf(removedTask));
  if (mFocusedTask == removedTask) {
    resetFocusedTask(removedTask);
  }
  if (mStack.getStackTaskCount() == 0) {
    boolean shouldFinishActivity=(mStack.getStackTaskCount() == 0);
    if (shouldFinishActivity) {
      EventBus.getDefault().send(new AllTaskViewsDismissedEvent(fromDockGesture ? R.string.recents_empty_message : R.string.recents_empty_message_dismissed_all));
    }
  }
}","@Override public void onStackTaskRemoved(TaskStack stack,Task removedTask,boolean wasFrontMostTask,Task newFrontMostTask,AnimationProps animation,boolean fromDockGesture){
  ((TaskStackHorizontalViewAdapter)getAdapter()).removeTask(removedTask);
  if (mFocusedTask == removedTask) {
    resetFocusedTask(removedTask);
  }
  if (mStack.getStackTaskCount() == 0) {
    boolean shouldFinishActivity=(mStack.getStackTaskCount() == 0);
    if (shouldFinishActivity) {
      EventBus.getDefault().send(new AllTaskViewsDismissedEvent(fromDockGesture ? R.string.recents_empty_message : R.string.recents_empty_message_dismissed_all));
    }
  }
}",0.8998435054773083
192140,"@Override public void onStackTaskAdded(TaskStack stack,Task newTask){
  getAdapter().notifyItemInserted(stack.getStackTasks().indexOf(newTask));
}","@Override public void onStackTaskAdded(TaskStack stack,Task newTask){
  ((TaskStackHorizontalViewAdapter)getAdapter()).addTaskAt(newTask,stack.indexOfStackTask(newTask));
}",0.7358490566037735
192141,"@Override public void onClick(View v){
  try {
    if (mTaskCardView.isInDismissState()) {
      mTaskCardView.startDismissTaskAnimation(getRemoveAtListener(getAdapterPosition(),mTaskCardView));
    }
 else {
      EventBus.getDefault().send(new LaunchTvTaskEvent(mTaskCardView,mTask,null,INVALID_STACK_ID));
      ((Activity)(v.getContext())).finish();
    }
  }
 catch (  Exception e) {
    Log.e(TAG,v.getContext().getString(R.string.recents_launch_error_message,mTask.title),e);
  }
}","@Override public void onClick(View v){
  try {
    if (mTaskCardView.isInDismissState()) {
      mTaskCardView.startDismissTaskAnimation(getRemoveAtListener(getAdapterPosition(),mTaskCardView.getTask()));
    }
 else {
      EventBus.getDefault().send(new LaunchTvTaskEvent(mTaskCardView,mTask,null,INVALID_STACK_ID));
      ((Activity)(v.getContext())).finish();
    }
  }
 catch (  Exception e) {
    Log.e(TAG,v.getContext().getString(R.string.recents_launch_error_message,mTask.title),e);
  }
}",0.9898580121703854
192142,"@Override public void onAnimationEnd(Animator animation){
  removeAt(position);
  EventBus.getDefault().send(new DeleteTaskDataEvent(taskCardView.getTask()));
}","@Override public void onAnimationEnd(Animator animation){
  removeAt(position);
  EventBus.getDefault().send(new DeleteTaskDataEvent(task));
}",0.9403973509933776
192143,"private Animator.AnimatorListener getRemoveAtListener(final int position,final TaskCardView taskCardView){
  return new Animator.AnimatorListener(){
    @Override public void onAnimationStart(    Animator animation){
    }
    @Override public void onAnimationEnd(    Animator animation){
      removeAt(position);
      EventBus.getDefault().send(new DeleteTaskDataEvent(taskCardView.getTask()));
    }
    @Override public void onAnimationCancel(    Animator animation){
    }
    @Override public void onAnimationRepeat(    Animator animation){
    }
  }
;
}","private Animator.AnimatorListener getRemoveAtListener(final int position,final Task task){
  return new Animator.AnimatorListener(){
    @Override public void onAnimationStart(    Animator animation){
    }
    @Override public void onAnimationEnd(    Animator animation){
      removeAt(position);
      EventBus.getDefault().send(new DeleteTaskDataEvent(task));
    }
    @Override public void onAnimationCancel(    Animator animation){
    }
    @Override public void onAnimationRepeat(    Animator animation){
    }
  }
;
}",0.96875
192144,"private void removeAt(int position){
  mTaskList.remove(position);
  notifyItemRemoved(position);
}","private void removeAt(int position){
  Task removedTask=mTaskList.remove(position);
  if (mGridView != null) {
    mGridView.getStack().removeTask(removedTask,AnimationProps.IMMEDIATE,false);
  }
  notifyItemRemoved(position);
}",0.6055045871559633
192145,"private void writeCompactedLongArray(Parcel out,long[] array,int num){
  for (int i=0; i < num; i++) {
    long val=array[i];
    if (val < 0) {
      Slog.w(TAG,""String_Node_Str"" + val);
      val=0;
    }
    if (val <= Integer.MAX_VALUE) {
      out.writeInt((int)val);
    }
 else {
      int top=~((int)((val >> 32) & 0x7fffffff));
      int bottom=(int)(val & 0xfffffff);
      out.writeInt(top);
      out.writeInt(bottom);
    }
  }
}","private void writeCompactedLongArray(Parcel out,long[] array,int num){
  for (int i=0; i < num; i++) {
    long val=array[i];
    if (val < 0) {
      Slog.w(TAG,""String_Node_Str"" + val);
      val=0;
    }
    if (val <= Integer.MAX_VALUE) {
      out.writeInt((int)val);
    }
 else {
      int top=~((int)((val >> 32) & 0x7fffffff));
      int bottom=(int)(val & 0x0ffffffffL);
      out.writeInt(top);
      out.writeInt(bottom);
    }
  }
}",0.9808342728297632
192146,"/** 
 * Allocates data in the buffer, and stores that key in the mapping for this table.
 * @param id    The id of the item (will be used in making the key)
 * @param count The number of bytes to allocate.  Must be less thanSparseMappingTable.ARRAY_SIZE.
 * @return The 'key' for this data value, which contains both the id itselfand the location in the long arrays that the data is actually stored but should be considered opaque to the caller.
 */
public int getOrAddKey(byte id,int count){
  if (mSequence == UNINITIALIZED_SEQUENCE) {
    mSequence=mParent.mSequence;
  }
  assertConsistency();
  final int idx=binarySearch(id);
  if (idx >= 0) {
    return mTable[idx];
  }
 else {
    final ArrayList<long[]> list=mParent.mLongs;
    int whichArray=list.size() - 1;
    long[] array=list.get(whichArray);
    if (mParent.mNextIndex + count > array.length) {
      array=new long[ARRAY_SIZE];
      list.add(array);
      whichArray++;
      mParent.mNextIndex=0;
    }
    final int key=(whichArray << ARRAY_SHIFT) | (mParent.mNextIndex << INDEX_SHIFT) | (((int)id) << ID_SHIFT);
    mParent.mNextIndex+=count;
    mTable=GrowingArrayUtils.insert(mTable != null ? mTable : EmptyArray.INT,mSize,~idx,key);
    mSize++;
    return key;
  }
}","/** 
 * Allocates data in the buffer, and stores that key in the mapping for this table.
 * @param id    The id of the item (will be used in making the key)
 * @param count The number of bytes to allocate.  Must be less thanSparseMappingTable.ARRAY_SIZE.
 * @return The 'key' for this data value, which contains both the id itselfand the location in the long arrays that the data is actually stored but should be considered opaque to the caller.
 */
public int getOrAddKey(byte id,int count){
  assertConsistency();
  final int idx=binarySearch(id);
  if (idx >= 0) {
    return mTable[idx];
  }
 else {
    final ArrayList<long[]> list=mParent.mLongs;
    int whichArray=list.size() - 1;
    long[] array=list.get(whichArray);
    if (mParent.mNextIndex + count > array.length) {
      array=new long[ARRAY_SIZE];
      list.add(array);
      whichArray++;
      mParent.mNextIndex=0;
    }
    final int key=(whichArray << ARRAY_SHIFT) | (mParent.mNextIndex << INDEX_SHIFT) | (((int)id) << ID_SHIFT);
    mParent.mNextIndex+=count;
    mTable=GrowingArrayUtils.insert(mTable != null ? mTable : EmptyArray.INT,mSize,~idx,key);
    mSize++;
    return key;
  }
}",0.9659185369908562
192147,"/** 
 * Clear out the table, and reset the sequence numbers so future writes without allocations will assert.
 */
public void resetTable(){
  mTable=null;
  mSize=0;
  mSequence=UNINITIALIZED_SEQUENCE;
}","/** 
 * Clear out the table, and reset the sequence numbers so future writes without allocations will assert.
 */
public void resetTable(){
  mTable=null;
  mSize=0;
  mSequence=mParent.mSequence;
}",0.9077306733167082
192148,"public String dumpInternalState(){
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"");
  sb.append(mSequence);
  sb.append(""String_Node_Str"");
  sb.append(mParent.mSequence);
  sb.append(""String_Node_Str"");
  sb.append(mParent.mLongs.size());
  sb.append(""String_Node_Str"");
  sb.append(mSize);
  sb.append(""String_Node_Str"");
  if (mTable == null) {
    sb.append(""String_Node_Str"");
  }
 else {
    final int N=mTable.length;
    sb.append('[');
    for (int i=0; i < N; i++) {
      final int key=mTable[i];
      sb.append(""String_Node_Str"");
      sb.append(Integer.toHexString((key >> ID_SHIFT) & ID_MASK));
      sb.append(""String_Node_Str"");
      sb.append(Integer.toHexString((key >> ARRAY_SHIFT) & ARRAY_MASK));
      sb.append(""String_Node_Str"");
      sb.append(Integer.toHexString((key >> INDEX_SHIFT) & INDEX_MASK));
      if (i != N - 1) {
        sb.append(""String_Node_Str"");
      }
    }
    sb.append(']');
  }
  sb.append(""String_Node_Str"");
  sb.append(getClass().getName());
  sb.append('}');
  return sb.toString();
}","/** 
 * Return a string for debugging.
 */
public String dumpInternalState(boolean includeData){
  final StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(mSequence);
  sb.append(""String_Node_Str"");
  sb.append(mNextIndex);
  sb.append(""String_Node_Str"");
  final int N=mLongs.size();
  sb.append(N);
  sb.append(""String_Node_Str"");
  if (includeData) {
    for (int i=0; i < N; i++) {
      final long[] array=mLongs.get(i);
      for (int j=0; j < array.length; j++) {
        if (i == N - 1 && j == mNextIndex) {
          break;
        }
        sb.append(String.format(""String_Node_Str"",i,j,array[j],array[j]));
      }
    }
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}",0.3276525563496427
192149,"/** 
 * Write the long array to the parcel in a compacted form.  Does not allow negative values in the array.
 */
private static void writeCompactedLongArray(Parcel out,long[] array,int num){
  for (int i=0; i < num; i++) {
    long val=array[i];
    if (val < 0) {
      Slog.w(TAG,""String_Node_Str"" + val);
      val=0;
    }
    if (val <= Integer.MAX_VALUE) {
      out.writeInt((int)val);
    }
 else {
      int top=~((int)((val >> 32) & 0x7fffffff));
      int bottom=(int)(val & 0xfffffff);
      out.writeInt(top);
      out.writeInt(bottom);
    }
  }
}","/** 
 * Write the long array to the parcel in a compacted form.  Does not allow negative values in the array.
 */
private static void writeCompactedLongArray(Parcel out,long[] array,int num){
  for (int i=0; i < num; i++) {
    long val=array[i];
    if (val < 0) {
      Slog.w(TAG,""String_Node_Str"" + val);
      val=0;
    }
    if (val <= Integer.MAX_VALUE) {
      out.writeInt((int)val);
    }
 else {
      int top=~((int)((val >> 32) & 0x7fffffff));
      int bottom=(int)(val & 0x0ffffffffL);
      out.writeInt(top);
      out.writeInt(bottom);
    }
  }
}",0.9849424269264836
192150,"/** 
 * Throw an exception if one of a variety of internal consistency checks fails.
 */
private void assertConsistency(){
  if (false) {
    if (mSequence == UNINITIALIZED_SEQUENCE) {
      logOrThrow(""String_Node_Str"" + ""String_Node_Str"" + dumpInternalState());
      return;
    }
    if (mSequence != mParent.mSequence) {
      if (mSequence < mParent.mSequence) {
        logOrThrow(""String_Node_Str"" + ""String_Node_Str"" + dumpInternalState());
        return;
      }
 else       if (mSequence > mParent.mSequence) {
        logOrThrow(""String_Node_Str"" + ""String_Node_Str"" + dumpInternalState());
        return;
      }
    }
  }
}","/** 
 * Throw an exception if one of a variety of internal consistency checks fails.
 */
private void assertConsistency(){
  if (false) {
    if (mSequence != mParent.mSequence) {
      if (mSequence < mParent.mSequence) {
        logOrThrow(""String_Node_Str"" + ""String_Node_Str"" + dumpInternalState());
        return;
      }
 else       if (mSequence > mParent.mSequence) {
        logOrThrow(""String_Node_Str"" + ""String_Node_Str"" + dumpInternalState());
        return;
      }
    }
  }
}",0.7049469964664311
192151,"private boolean adjustForIME(final WindowState imeWin){
  final int dockedSide=getDockSide();
  final boolean dockedTopOrBottom=dockedSide == DOCKED_TOP || dockedSide == DOCKED_BOTTOM;
  final Rect adjustedBounds=mTmpAdjustedBounds;
  if (imeWin == null || !dockedTopOrBottom) {
    return false;
  }
  final Rect displayContentRect=mTmpRect;
  final Rect contentBounds=mTmpRect2;
  getDisplayContent().getContentRect(displayContentRect);
  contentBounds.set(displayContentRect);
  int imeTop=Math.max(imeWin.getDisplayFrameLw().top,contentBounds.top);
  if (imeWin.isAnimatingLw()) {
    imeTop=Math.max(imeTop,imeWin.getShownPositionLw().y);
  }
  imeTop+=imeWin.getGivenContentInsetsLw().top;
  if (contentBounds.bottom > imeTop) {
    contentBounds.bottom=imeTop;
  }
  if (mLastContentBounds.equals(contentBounds)) {
    return true;
  }
  mLastContentBounds.set(contentBounds);
  adjustedBounds.set(mBounds);
  final int yOffset=displayContentRect.bottom - contentBounds.bottom;
  if (dockedSide == DOCKED_TOP) {
    adjustedBounds.bottom=Math.max(adjustedBounds.bottom - yOffset,displayContentRect.top);
  }
 else {
    final int dividerWidth=getDisplayContent().mDividerControllerLocked.getContentWidth();
    adjustedBounds.top=Math.max(adjustedBounds.top - yOffset,displayContentRect.top + dividerWidth);
    adjustedBounds.bottom=adjustedBounds.top + mBounds.height();
  }
  return true;
}","private boolean adjustForIME(final WindowState imeWin){
  final int dockedSide=getDockSide();
  final boolean dockedTopOrBottom=dockedSide == DOCKED_TOP || dockedSide == DOCKED_BOTTOM;
  final Rect adjustedBounds=mTmpAdjustedBounds;
  if (imeWin == null || !dockedTopOrBottom) {
    return false;
  }
  final Rect displayContentRect=mTmpRect;
  final Rect contentBounds=mTmpRect2;
  getDisplayContent().getContentRect(displayContentRect);
  contentBounds.set(displayContentRect);
  int imeTop=Math.max(imeWin.getFrameLw().top,contentBounds.top);
  if (imeWin.isAnimatingLw()) {
    imeTop=Math.max(imeTop,imeWin.getShownPositionLw().y);
  }
  imeTop+=imeWin.getGivenContentInsetsLw().top;
  if (contentBounds.bottom > imeTop) {
    contentBounds.bottom=imeTop;
  }
  if (mLastContentBounds.equals(contentBounds)) {
    return true;
  }
  mLastContentBounds.set(contentBounds);
  adjustedBounds.set(mBounds);
  final int yOffset=displayContentRect.bottom - contentBounds.bottom;
  if (dockedSide == DOCKED_TOP) {
    adjustedBounds.bottom=Math.max(adjustedBounds.bottom - yOffset,displayContentRect.top);
  }
 else {
    final int dividerWidth=getDisplayContent().mDividerControllerLocked.getContentWidth();
    adjustedBounds.top=Math.max(adjustedBounds.top - yOffset,displayContentRect.top + dividerWidth);
    adjustedBounds.bottom=adjustedBounds.top + mBounds.height();
  }
  return true;
}",0.9974937343358397
192152,"/** 
 * Updates this stack when a scroll happens.
 */
public void updateFocusStateOnScroll(float stackScroll,float deltaScroll){
  if (deltaScroll == 0f) {
    return;
  }
  for (int i=mTaskIndexOverrideMap.size() - 1; i >= 0; i--) {
    int taskId=mTaskIndexOverrideMap.keyAt(i);
    float x=mTaskIndexMap.get(taskId);
    float overrideX=mTaskIndexOverrideMap.get(taskId,0f);
    float newOverrideX=overrideX + deltaScroll;
    mUnfocusedRange.offset(stackScroll);
    boolean outOfBounds=mUnfocusedRange.getNormalizedX(newOverrideX) < 0f || mUnfocusedRange.getNormalizedX(newOverrideX) > 1f;
    if (outOfBounds || (overrideX >= x && x >= newOverrideX) || (overrideX <= x && x <= newOverrideX)) {
      mTaskIndexOverrideMap.removeAt(i);
    }
 else     if ((overrideX >= x && deltaScroll <= 0f) || (overrideX <= x && deltaScroll >= 0f)) {
      mTaskIndexOverrideMap.put(taskId,newOverrideX);
    }
 else {
      float deltaX=overrideX - x;
      newOverrideX=Math.signum(deltaX) * (Math.abs(deltaX) - Math.abs(deltaScroll));
      mTaskIndexOverrideMap.put(taskId,x + newOverrideX);
    }
  }
}","/** 
 * Updates this stack when a scroll happens.
 */
public float updateFocusStateOnScroll(float lastTargetStackScroll,float targetStackScroll,float lastStackScroll){
  if (targetStackScroll == lastStackScroll) {
    return targetStackScroll;
  }
  float deltaScroll=targetStackScroll - lastStackScroll;
  float deltaTargetScroll=targetStackScroll - lastTargetStackScroll;
  float newScroll=targetStackScroll;
  mUnfocusedRange.offset(targetStackScroll);
  for (int i=mTaskIndexOverrideMap.size() - 1; i >= 0; i--) {
    int taskId=mTaskIndexOverrideMap.keyAt(i);
    float x=mTaskIndexMap.get(taskId);
    float overrideX=mTaskIndexOverrideMap.get(taskId,0f);
    float newOverrideX=overrideX + deltaScroll;
    if (isInvalidOverrideX(x,overrideX,newOverrideX)) {
      mTaskIndexOverrideMap.removeAt(i);
    }
 else     if ((overrideX >= x && deltaScroll <= 0f) || (overrideX <= x && deltaScroll >= 0f)) {
      mTaskIndexOverrideMap.put(taskId,newOverrideX);
    }
 else {
      newScroll=lastStackScroll;
      newOverrideX=overrideX - deltaTargetScroll;
      if (isInvalidOverrideX(x,overrideX,newOverrideX)) {
        mTaskIndexOverrideMap.removeAt(i);
      }
 else {
        mTaskIndexOverrideMap.put(taskId,newOverrideX);
      }
    }
  }
  return newScroll;
}",0.4968367777309152
192153,"/** 
 * TaskStackViewScroller.TaskStackViewScrollerCallbacks 
 */
@Override public void onStackScrollChanged(float prevScroll,float curScroll,AnimationProps animation){
  mUIDozeTrigger.poke();
  if (animation != null) {
    relayoutTaskViewsOnNextFrame(animation);
  }
  mLayoutAlgorithm.updateFocusStateOnScroll(curScroll,curScroll - prevScroll);
  if (mEnterAnimationComplete) {
    if (prevScroll > SHOW_STACK_ACTION_BUTTON_SCROLL_THRESHOLD && curScroll <= SHOW_STACK_ACTION_BUTTON_SCROLL_THRESHOLD && mStack.getTaskCount() > 0) {
      EventBus.getDefault().send(new ShowStackActionButtonEvent(true));
    }
 else     if (prevScroll < HIDE_STACK_ACTION_BUTTON_SCROLL_THRESHOLD && curScroll >= HIDE_STACK_ACTION_BUTTON_SCROLL_THRESHOLD) {
      EventBus.getDefault().send(new HideStackActionButtonEvent());
    }
  }
}","/** 
 * TaskStackViewScroller.TaskStackViewScrollerCallbacks 
 */
@Override public void onStackScrollChanged(float prevScroll,float curScroll,AnimationProps animation){
  mUIDozeTrigger.poke();
  if (animation != null) {
    relayoutTaskViewsOnNextFrame(animation);
  }
  if (mEnterAnimationComplete) {
    if (prevScroll > SHOW_STACK_ACTION_BUTTON_SCROLL_THRESHOLD && curScroll <= SHOW_STACK_ACTION_BUTTON_SCROLL_THRESHOLD && mStack.getTaskCount() > 0) {
      EventBus.getDefault().send(new ShowStackActionButtonEvent(true));
    }
 else     if (prevScroll < HIDE_STACK_ACTION_BUTTON_SCROLL_THRESHOLD && curScroll >= HIDE_STACK_ACTION_BUTTON_SCROLL_THRESHOLD) {
      EventBus.getDefault().send(new HideStackActionButtonEvent());
    }
  }
}",0.949520766773163
192154,"/** 
 * Called from the view draw, computes the next scroll. 
 */
boolean computeScroll(){
  if (mScroller.computeScrollOffset()) {
    float deltaP=mLayoutAlgorithm.getDeltaPForY(mFlingDownY,mScroller.getCurrY());
    float scroll=mFlingDownScrollP + deltaP;
    setStackScroll(scroll);
    if (DEBUG) {
      Log.d(TAG,""String_Node_Str"" + scroll);
    }
    return true;
  }
  return false;
}","/** 
 * Called from the view draw, computes the next scroll. 
 */
boolean computeScroll(){
  if (mScroller.computeScrollOffset()) {
    float deltaP=mLayoutAlgorithm.getDeltaPForY(mFlingDownY,mScroller.getCurrY());
    mFlingDownScrollP+=setDeltaStackScroll(mFlingDownScrollP,deltaP);
    if (DEBUG) {
      Log.d(TAG,""String_Node_Str"" + (mFlingDownScrollP + deltaP));
    }
    return true;
  }
  return false;
}",0.7360594795539034
192155,"/** 
 * Sets the current stack scroll, but indicates to the callback the preferred animation to update to this new scroll.
 */
public void setStackScroll(float s,AnimationProps animation){
  float prevStackScroll=mStackScrollP;
  mStackScrollP=s;
  if (mCb != null) {
    mCb.onStackScrollChanged(prevStackScroll,mStackScrollP,animation);
  }
}","/** 
 * Sets the current stack scroll, but indicates to the callback the preferred animation to update to this new scroll.
 */
public void setStackScroll(float newScroll,AnimationProps animation){
  float prevScroll=mStackScrollP;
  mStackScrollP=newScroll;
  if (mCb != null) {
    mCb.onStackScrollChanged(prevScroll,mStackScrollP,animation);
  }
}",0.956772334293948
192156,"/** 
 * Sets the current stack scroll to the initial state when you first enter recents.
 * @return whether the stack progress changed.
 */
public boolean setStackScrollToInitialState(){
  float prevStackScrollP=mStackScrollP;
  setStackScroll(mLayoutAlgorithm.mInitialScrollP);
  return Float.compare(prevStackScrollP,mStackScrollP) != 0;
}","/** 
 * Sets the current stack scroll to the initial state when you first enter recents.
 * @return whether the stack progress changed.
 */
public boolean setStackScrollToInitialState(){
  float prevScroll=mStackScrollP;
  setStackScroll(mLayoutAlgorithm.mInitialScrollP);
  return Float.compare(prevScroll,mStackScrollP) != 0;
}",0.9522388059701492
192157,"/** 
 * Resets the task scroller. 
 */
void reset(){
  mStackScrollP=0f;
}","/** 
 * Resets the task scroller. 
 */
void reset(){
  mStackScrollP=0f;
  mLastDeltaP=0f;
}",0.891566265060241
192158,"private boolean handleTouchEvent(MotionEvent ev){
  if (mSv.getTaskViews().size() == 0) {
    return false;
  }
  final TaskStackLayoutAlgorithm layoutAlgorithm=mSv.mLayoutAlgorithm;
  int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      mDownX=(int)ev.getX();
      mDownY=(int)ev.getY();
      mLastY=mDownY;
      mDownScrollP=mScroller.getStackScroll();
      mActivePointerId=ev.getPointerId(0);
      mActiveTaskView=findViewAtPoint(mDownX,mDownY);
      mScroller.stopScroller();
      mScroller.stopBoundScrollAnimation();
      Utilities.cancelAnimationWithoutCallbacks(mScrollFlingAnimator);
      mSv.cancelAllTaskViewAnimations();
      ArrayMap<View,Animator> existingAnimators=new ArrayMap<>(mSwipeHelperAnimations);
      for (int i=0; i < existingAnimators.size(); i++) {
        existingAnimators.get(existingAnimators.keyAt(i)).end();
      }
      mSwipeHelperAnimations.clear();
      initOrResetVelocityTracker();
      mVelocityTracker.addMovement(ev);
      break;
    }
case MotionEvent.ACTION_POINTER_DOWN:
{
    final int index=ev.getActionIndex();
    mActivePointerId=ev.getPointerId(index);
    mDownX=(int)ev.getX(index);
    mDownY=(int)ev.getY(index);
    mLastY=mDownY;
    mDownScrollP=mScroller.getStackScroll();
    mVelocityTracker.addMovement(ev);
    break;
  }
case MotionEvent.ACTION_MOVE:
{
  int activePointerIndex=ev.findPointerIndex(mActivePointerId);
  int y=(int)ev.getY(activePointerIndex);
  int x=(int)ev.getX(activePointerIndex);
  if (!mIsScrolling) {
    int yDiff=Math.abs(y - mDownY);
    int xDiff=Math.abs(x - mDownX);
    if (Math.abs(y - mDownY) > mScrollTouchSlop && yDiff > xDiff) {
      mIsScrolling=true;
      float stackScroll=mScroller.getStackScroll();
      List<TaskView> taskViews=mSv.getTaskViews();
      for (int i=taskViews.size() - 1; i >= 0; i--) {
        layoutAlgorithm.addUnfocusedTaskOverride(taskViews.get(i).getTask(),stackScroll);
      }
      layoutAlgorithm.setFocusState(TaskStackLayoutAlgorithm.STATE_UNFOCUSED);
      final ViewParent parent=mSv.getParent();
      if (parent != null) {
        parent.requestDisallowInterceptTouchEvent(true);
      }
      MetricsLogger.action(mSv.getContext(),MetricsEvent.OVERVIEW_SCROLL);
    }
  }
  if (mIsScrolling) {
    float deltaP=layoutAlgorithm.getDeltaPForY(mDownY,y);
    float curScrollP=mDownScrollP + deltaP;
    float minScrollP=layoutAlgorithm.mMinScrollP;
    float maxScrollP=layoutAlgorithm.mMaxScrollP;
    if (curScrollP < minScrollP || curScrollP > maxScrollP) {
      float clampedScrollP=Utilities.clamp(curScrollP,minScrollP,maxScrollP);
      float overscrollP=(curScrollP - clampedScrollP);
      float overscrollX=Math.abs(overscrollP) / MAX_OVERSCROLL;
      curScrollP=clampedScrollP + (Math.signum(overscrollP) * (OVERSCROLL_INTERP.getInterpolation(overscrollX) * MAX_OVERSCROLL));
    }
    mScroller.setStackScroll(curScrollP);
    mStackViewScrolledEvent.updateY(y - mLastY);
    EventBus.getDefault().send(mStackViewScrolledEvent);
  }
  mLastY=y;
  mVelocityTracker.addMovement(ev);
  break;
}
case MotionEvent.ACTION_POINTER_UP:
{
int pointerIndex=ev.getActionIndex();
int pointerId=ev.getPointerId(pointerIndex);
if (pointerId == mActivePointerId) {
  final int newPointerIndex=(pointerIndex == 0) ? 1 : 0;
  mActivePointerId=ev.getPointerId(newPointerIndex);
  mDownX=(int)ev.getX(pointerIndex);
  mDownY=(int)ev.getY(pointerIndex);
  mLastY=mDownY;
  mDownScrollP=mScroller.getStackScroll();
}
mVelocityTracker.addMovement(ev);
break;
}
case MotionEvent.ACTION_UP:
{
mVelocityTracker.addMovement(ev);
mVelocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int activePointerIndex=ev.findPointerIndex(mActivePointerId);
int y=(int)ev.getY(activePointerIndex);
int velocity=(int)mVelocityTracker.getYVelocity(mActivePointerId);
if (mIsScrolling) {
if (mScroller.isScrollOutOfBounds()) {
  mScroller.animateBoundScroll();
}
 else if (Math.abs(velocity) > mMinimumVelocity) {
  float minY=mDownY + layoutAlgorithm.getYForDeltaP(mDownScrollP,layoutAlgorithm.mMaxScrollP);
  float maxY=mDownY + layoutAlgorithm.getYForDeltaP(mDownScrollP,layoutAlgorithm.mMinScrollP);
  mScroller.fling(mDownScrollP,mDownY,y,velocity,(int)minY,(int)maxY,mOverscrollSize);
  mSv.invalidate();
}
mSv.resetFocusedTask(mSv.getFocusedTask());
}
 else if (mActiveTaskView == null) {
maybeHideRecentsFromBackgroundTap((int)ev.getX(),(int)ev.getY());
}
mActivePointerId=INACTIVE_POINTER_ID;
mIsScrolling=false;
recycleVelocityTracker();
break;
}
case MotionEvent.ACTION_CANCEL:
{
mActivePointerId=INACTIVE_POINTER_ID;
mIsScrolling=false;
recycleVelocityTracker();
break;
}
}
return mIsScrolling;
}","private boolean handleTouchEvent(MotionEvent ev){
  if (mSv.getTaskViews().size() == 0) {
    return false;
  }
  final TaskStackLayoutAlgorithm layoutAlgorithm=mSv.mLayoutAlgorithm;
  int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      mDownX=(int)ev.getX();
      mDownY=(int)ev.getY();
      mLastY=mDownY;
      mDownScrollP=mScroller.getStackScroll();
      mActivePointerId=ev.getPointerId(0);
      mActiveTaskView=findViewAtPoint(mDownX,mDownY);
      mScroller.stopScroller();
      mScroller.stopBoundScrollAnimation();
      mScroller.resetDeltaScroll();
      Utilities.cancelAnimationWithoutCallbacks(mScrollFlingAnimator);
      mSv.cancelAllTaskViewAnimations();
      ArrayMap<View,Animator> existingAnimators=new ArrayMap<>(mSwipeHelperAnimations);
      for (int i=0; i < existingAnimators.size(); i++) {
        existingAnimators.get(existingAnimators.keyAt(i)).end();
      }
      mSwipeHelperAnimations.clear();
      initOrResetVelocityTracker();
      mVelocityTracker.addMovement(ev);
      break;
    }
case MotionEvent.ACTION_POINTER_DOWN:
{
    final int index=ev.getActionIndex();
    mActivePointerId=ev.getPointerId(index);
    mDownX=(int)ev.getX(index);
    mDownY=(int)ev.getY(index);
    mLastY=mDownY;
    mDownScrollP=mScroller.getStackScroll();
    mScroller.resetDeltaScroll();
    mVelocityTracker.addMovement(ev);
    break;
  }
case MotionEvent.ACTION_MOVE:
{
  int activePointerIndex=ev.findPointerIndex(mActivePointerId);
  int y=(int)ev.getY(activePointerIndex);
  int x=(int)ev.getX(activePointerIndex);
  if (!mIsScrolling) {
    int yDiff=Math.abs(y - mDownY);
    int xDiff=Math.abs(x - mDownX);
    if (Math.abs(y - mDownY) > mScrollTouchSlop && yDiff > xDiff) {
      mIsScrolling=true;
      float stackScroll=mScroller.getStackScroll();
      List<TaskView> taskViews=mSv.getTaskViews();
      for (int i=taskViews.size() - 1; i >= 0; i--) {
        layoutAlgorithm.addUnfocusedTaskOverride(taskViews.get(i).getTask(),stackScroll);
      }
      layoutAlgorithm.setFocusState(TaskStackLayoutAlgorithm.STATE_UNFOCUSED);
      final ViewParent parent=mSv.getParent();
      if (parent != null) {
        parent.requestDisallowInterceptTouchEvent(true);
      }
      MetricsLogger.action(mSv.getContext(),MetricsEvent.OVERVIEW_SCROLL);
    }
  }
  if (mIsScrolling) {
    float deltaP=layoutAlgorithm.getDeltaPForY(mDownY,y);
    float minScrollP=layoutAlgorithm.mMinScrollP;
    float maxScrollP=layoutAlgorithm.mMaxScrollP;
    float curScrollP=mDownScrollP + deltaP;
    if (curScrollP < minScrollP || curScrollP > maxScrollP) {
      float clampedScrollP=Utilities.clamp(curScrollP,minScrollP,maxScrollP);
      float overscrollP=(curScrollP - clampedScrollP);
      float overscrollX=Math.abs(overscrollP) / MAX_OVERSCROLL;
      float interpX=OVERSCROLL_INTERP.getInterpolation(overscrollX);
      curScrollP=clampedScrollP + Math.signum(overscrollP) * (interpX * MAX_OVERSCROLL);
    }
    mDownScrollP+=mScroller.setDeltaStackScroll(mDownScrollP,curScrollP - mDownScrollP);
    mStackViewScrolledEvent.updateY(y - mLastY);
    EventBus.getDefault().send(mStackViewScrolledEvent);
  }
  mLastY=y;
  mVelocityTracker.addMovement(ev);
  break;
}
case MotionEvent.ACTION_POINTER_UP:
{
int pointerIndex=ev.getActionIndex();
int pointerId=ev.getPointerId(pointerIndex);
if (pointerId == mActivePointerId) {
  final int newPointerIndex=(pointerIndex == 0) ? 1 : 0;
  mActivePointerId=ev.getPointerId(newPointerIndex);
  mDownX=(int)ev.getX(pointerIndex);
  mDownY=(int)ev.getY(pointerIndex);
  mLastY=mDownY;
  mDownScrollP=mScroller.getStackScroll();
}
mVelocityTracker.addMovement(ev);
break;
}
case MotionEvent.ACTION_UP:
{
mVelocityTracker.addMovement(ev);
mVelocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int activePointerIndex=ev.findPointerIndex(mActivePointerId);
int y=(int)ev.getY(activePointerIndex);
int velocity=(int)mVelocityTracker.getYVelocity(mActivePointerId);
if (mIsScrolling) {
if (mScroller.isScrollOutOfBounds()) {
  mScroller.animateBoundScroll();
}
 else if (Math.abs(velocity) > mMinimumVelocity) {
  float minY=mDownY + layoutAlgorithm.getYForDeltaP(mDownScrollP,layoutAlgorithm.mMaxScrollP);
  float maxY=mDownY + layoutAlgorithm.getYForDeltaP(mDownScrollP,layoutAlgorithm.mMinScrollP);
  mScroller.fling(mDownScrollP,mDownY,y,velocity,(int)minY,(int)maxY,mOverscrollSize);
  mSv.invalidate();
}
mSv.resetFocusedTask(mSv.getFocusedTask());
}
 else if (mActiveTaskView == null) {
maybeHideRecentsFromBackgroundTap((int)ev.getX(),(int)ev.getY());
}
mActivePointerId=INACTIVE_POINTER_ID;
mIsScrolling=false;
recycleVelocityTracker();
break;
}
case MotionEvent.ACTION_CANCEL:
{
mActivePointerId=INACTIVE_POINTER_ID;
mIsScrolling=false;
recycleVelocityTracker();
break;
}
}
return mIsScrolling;
}",0.9492768811569902
192159,"/** 
 * Updates this stack when a scroll happens.
 */
public void updateFocusStateOnScroll(float stackScroll,float deltaScroll){
  if (deltaScroll == 0f) {
    return;
  }
  for (int i=mTaskIndexOverrideMap.size() - 1; i >= 0; i--) {
    int taskId=mTaskIndexOverrideMap.keyAt(i);
    float x=mTaskIndexMap.get(taskId);
    float overrideX=mTaskIndexOverrideMap.get(taskId,0f);
    float newOverrideX=overrideX + deltaScroll;
    mUnfocusedRange.offset(stackScroll);
    boolean outOfBounds=mUnfocusedRange.getNormalizedX(newOverrideX) < 0f || mUnfocusedRange.getNormalizedX(newOverrideX) > 1f;
    if (outOfBounds || (overrideX >= x && x >= newOverrideX) || (overrideX <= x && x <= newOverrideX)) {
      mTaskIndexOverrideMap.removeAt(i);
    }
 else     if ((overrideX >= x && deltaScroll <= 0f) || (overrideX <= x && deltaScroll >= 0f)) {
      mTaskIndexOverrideMap.put(taskId,newOverrideX);
    }
 else {
      float deltaX=overrideX - x;
      newOverrideX=Math.signum(deltaX) * (Math.abs(deltaX) - Math.abs(deltaScroll));
      mTaskIndexOverrideMap.put(taskId,x + newOverrideX);
    }
  }
}","/** 
 * Updates this stack when a scroll happens.
 */
public float updateFocusStateOnScroll(float lastTargetStackScroll,float targetStackScroll,float lastStackScroll){
  if (targetStackScroll == lastStackScroll) {
    return targetStackScroll;
  }
  float deltaScroll=targetStackScroll - lastStackScroll;
  float deltaTargetScroll=targetStackScroll - lastTargetStackScroll;
  float newScroll=targetStackScroll;
  mUnfocusedRange.offset(targetStackScroll);
  for (int i=mTaskIndexOverrideMap.size() - 1; i >= 0; i--) {
    int taskId=mTaskIndexOverrideMap.keyAt(i);
    float x=mTaskIndexMap.get(taskId);
    float overrideX=mTaskIndexOverrideMap.get(taskId,0f);
    float newOverrideX=overrideX + deltaScroll;
    if (isInvalidOverrideX(x,overrideX,newOverrideX)) {
      mTaskIndexOverrideMap.removeAt(i);
    }
 else     if ((overrideX >= x && deltaScroll <= 0f) || (overrideX <= x && deltaScroll >= 0f)) {
      mTaskIndexOverrideMap.put(taskId,newOverrideX);
    }
 else {
      newScroll=lastStackScroll;
      newOverrideX=overrideX - deltaTargetScroll;
      if (isInvalidOverrideX(x,overrideX,newOverrideX)) {
        mTaskIndexOverrideMap.removeAt(i);
      }
 else {
        mTaskIndexOverrideMap.put(taskId,newOverrideX);
      }
    }
  }
  return newScroll;
}",0.4968367777309152
192160,"/** 
 * TaskStackViewScroller.TaskStackViewScrollerCallbacks 
 */
@Override public void onStackScrollChanged(float prevScroll,float curScroll,AnimationProps animation){
  mUIDozeTrigger.poke();
  if (animation != null) {
    relayoutTaskViewsOnNextFrame(animation);
  }
  mLayoutAlgorithm.updateFocusStateOnScroll(curScroll,curScroll - prevScroll);
  if (mEnterAnimationComplete) {
    if (prevScroll > SHOW_STACK_ACTION_BUTTON_SCROLL_THRESHOLD && curScroll <= SHOW_STACK_ACTION_BUTTON_SCROLL_THRESHOLD && mStack.getTaskCount() > 0) {
      EventBus.getDefault().send(new ShowStackActionButtonEvent(true));
    }
 else     if (prevScroll < HIDE_STACK_ACTION_BUTTON_SCROLL_THRESHOLD && curScroll >= HIDE_STACK_ACTION_BUTTON_SCROLL_THRESHOLD) {
      EventBus.getDefault().send(new HideStackActionButtonEvent());
    }
  }
}","/** 
 * TaskStackViewScroller.TaskStackViewScrollerCallbacks 
 */
@Override public void onStackScrollChanged(float prevScroll,float curScroll,AnimationProps animation){
  mUIDozeTrigger.poke();
  if (animation != null) {
    relayoutTaskViewsOnNextFrame(animation);
  }
  if (mEnterAnimationComplete) {
    if (prevScroll > SHOW_STACK_ACTION_BUTTON_SCROLL_THRESHOLD && curScroll <= SHOW_STACK_ACTION_BUTTON_SCROLL_THRESHOLD && mStack.getTaskCount() > 0) {
      EventBus.getDefault().send(new ShowStackActionButtonEvent(true));
    }
 else     if (prevScroll < HIDE_STACK_ACTION_BUTTON_SCROLL_THRESHOLD && curScroll >= HIDE_STACK_ACTION_BUTTON_SCROLL_THRESHOLD) {
      EventBus.getDefault().send(new HideStackActionButtonEvent());
    }
  }
}",0.949520766773163
192161,"/** 
 * Called from the view draw, computes the next scroll. 
 */
boolean computeScroll(){
  if (mScroller.computeScrollOffset()) {
    float deltaP=mLayoutAlgorithm.getDeltaPForY(mFlingDownY,mScroller.getCurrY());
    float scroll=mFlingDownScrollP + deltaP;
    setStackScroll(scroll);
    if (DEBUG) {
      Log.d(TAG,""String_Node_Str"" + scroll);
    }
    return true;
  }
  return false;
}","/** 
 * Called from the view draw, computes the next scroll. 
 */
boolean computeScroll(){
  if (mScroller.computeScrollOffset()) {
    float deltaP=mLayoutAlgorithm.getDeltaPForY(mFlingDownY,mScroller.getCurrY());
    mFlingDownScrollP+=setDeltaStackScroll(mFlingDownScrollP,deltaP);
    if (DEBUG) {
      Log.d(TAG,""String_Node_Str"" + (mFlingDownScrollP + deltaP));
    }
    return true;
  }
  return false;
}",0.7360594795539034
192162,"/** 
 * Sets the current stack scroll, but indicates to the callback the preferred animation to update to this new scroll.
 */
public void setStackScroll(float s,AnimationProps animation){
  float prevStackScroll=mStackScrollP;
  mStackScrollP=s;
  if (mCb != null) {
    mCb.onStackScrollChanged(prevStackScroll,mStackScrollP,animation);
  }
}","/** 
 * Sets the current stack scroll, but indicates to the callback the preferred animation to update to this new scroll.
 */
public void setStackScroll(float newScroll,AnimationProps animation){
  float prevScroll=mStackScrollP;
  mStackScrollP=newScroll;
  if (mCb != null) {
    mCb.onStackScrollChanged(prevScroll,mStackScrollP,animation);
  }
}",0.956772334293948
192163,"/** 
 * Sets the current stack scroll to the initial state when you first enter recents.
 * @return whether the stack progress changed.
 */
public boolean setStackScrollToInitialState(){
  float prevStackScrollP=mStackScrollP;
  setStackScroll(mLayoutAlgorithm.mInitialScrollP);
  return Float.compare(prevStackScrollP,mStackScrollP) != 0;
}","/** 
 * Sets the current stack scroll to the initial state when you first enter recents.
 * @return whether the stack progress changed.
 */
public boolean setStackScrollToInitialState(){
  float prevScroll=mStackScrollP;
  setStackScroll(mLayoutAlgorithm.mInitialScrollP);
  return Float.compare(prevScroll,mStackScrollP) != 0;
}",0.9522388059701492
192164,"/** 
 * Resets the task scroller. 
 */
void reset(){
  mStackScrollP=0f;
}","/** 
 * Resets the task scroller. 
 */
void reset(){
  mStackScrollP=0f;
  mLastDeltaP=0f;
}",0.891566265060241
192165,"private boolean handleTouchEvent(MotionEvent ev){
  if (mSv.getTaskViews().size() == 0) {
    return false;
  }
  final TaskStackLayoutAlgorithm layoutAlgorithm=mSv.mLayoutAlgorithm;
  int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      mDownX=(int)ev.getX();
      mDownY=(int)ev.getY();
      mLastY=mDownY;
      mDownScrollP=mScroller.getStackScroll();
      mActivePointerId=ev.getPointerId(0);
      mActiveTaskView=findViewAtPoint(mDownX,mDownY);
      mScroller.stopScroller();
      mScroller.stopBoundScrollAnimation();
      Utilities.cancelAnimationWithoutCallbacks(mScrollFlingAnimator);
      mSv.cancelAllTaskViewAnimations();
      ArrayMap<View,Animator> existingAnimators=new ArrayMap<>(mSwipeHelperAnimations);
      for (int i=0; i < existingAnimators.size(); i++) {
        existingAnimators.get(existingAnimators.keyAt(i)).end();
      }
      mSwipeHelperAnimations.clear();
      initOrResetVelocityTracker();
      mVelocityTracker.addMovement(ev);
      break;
    }
case MotionEvent.ACTION_POINTER_DOWN:
{
    final int index=ev.getActionIndex();
    mActivePointerId=ev.getPointerId(index);
    mDownX=(int)ev.getX(index);
    mDownY=(int)ev.getY(index);
    mLastY=mDownY;
    mDownScrollP=mScroller.getStackScroll();
    mVelocityTracker.addMovement(ev);
    break;
  }
case MotionEvent.ACTION_MOVE:
{
  int activePointerIndex=ev.findPointerIndex(mActivePointerId);
  int y=(int)ev.getY(activePointerIndex);
  int x=(int)ev.getX(activePointerIndex);
  if (!mIsScrolling) {
    int yDiff=Math.abs(y - mDownY);
    int xDiff=Math.abs(x - mDownX);
    if (Math.abs(y - mDownY) > mScrollTouchSlop && yDiff > xDiff) {
      mIsScrolling=true;
      float stackScroll=mScroller.getStackScroll();
      List<TaskView> taskViews=mSv.getTaskViews();
      for (int i=taskViews.size() - 1; i >= 0; i--) {
        layoutAlgorithm.addUnfocusedTaskOverride(taskViews.get(i).getTask(),stackScroll);
      }
      layoutAlgorithm.setFocusState(TaskStackLayoutAlgorithm.STATE_UNFOCUSED);
      final ViewParent parent=mSv.getParent();
      if (parent != null) {
        parent.requestDisallowInterceptTouchEvent(true);
      }
      MetricsLogger.action(mSv.getContext(),MetricsEvent.OVERVIEW_SCROLL);
    }
  }
  if (mIsScrolling) {
    float deltaP=layoutAlgorithm.getDeltaPForY(mDownY,y);
    float curScrollP=mDownScrollP + deltaP;
    float minScrollP=layoutAlgorithm.mMinScrollP;
    float maxScrollP=layoutAlgorithm.mMaxScrollP;
    if (curScrollP < minScrollP || curScrollP > maxScrollP) {
      float clampedScrollP=Utilities.clamp(curScrollP,minScrollP,maxScrollP);
      float overscrollP=(curScrollP - clampedScrollP);
      float overscrollX=Math.abs(overscrollP) / MAX_OVERSCROLL;
      curScrollP=clampedScrollP + (Math.signum(overscrollP) * (OVERSCROLL_INTERP.getInterpolation(overscrollX) * MAX_OVERSCROLL));
    }
    mScroller.setStackScroll(curScrollP);
    mStackViewScrolledEvent.updateY(y - mLastY);
    EventBus.getDefault().send(mStackViewScrolledEvent);
  }
  mLastY=y;
  mVelocityTracker.addMovement(ev);
  break;
}
case MotionEvent.ACTION_POINTER_UP:
{
int pointerIndex=ev.getActionIndex();
int pointerId=ev.getPointerId(pointerIndex);
if (pointerId == mActivePointerId) {
  final int newPointerIndex=(pointerIndex == 0) ? 1 : 0;
  mActivePointerId=ev.getPointerId(newPointerIndex);
  mDownX=(int)ev.getX(pointerIndex);
  mDownY=(int)ev.getY(pointerIndex);
  mLastY=mDownY;
  mDownScrollP=mScroller.getStackScroll();
}
mVelocityTracker.addMovement(ev);
break;
}
case MotionEvent.ACTION_UP:
{
mVelocityTracker.addMovement(ev);
mVelocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int activePointerIndex=ev.findPointerIndex(mActivePointerId);
int y=(int)ev.getY(activePointerIndex);
int velocity=(int)mVelocityTracker.getYVelocity(mActivePointerId);
if (mIsScrolling) {
if (mScroller.isScrollOutOfBounds()) {
  mScroller.animateBoundScroll();
}
 else if (Math.abs(velocity) > mMinimumVelocity) {
  float minY=mDownY + layoutAlgorithm.getYForDeltaP(mDownScrollP,layoutAlgorithm.mMaxScrollP);
  float maxY=mDownY + layoutAlgorithm.getYForDeltaP(mDownScrollP,layoutAlgorithm.mMinScrollP);
  mScroller.fling(mDownScrollP,mDownY,y,velocity,(int)minY,(int)maxY,mOverscrollSize);
  mSv.invalidate();
}
mSv.resetFocusedTask(mSv.getFocusedTask());
}
 else if (mActiveTaskView == null) {
maybeHideRecentsFromBackgroundTap((int)ev.getX(),(int)ev.getY());
}
mActivePointerId=INACTIVE_POINTER_ID;
mIsScrolling=false;
recycleVelocityTracker();
break;
}
case MotionEvent.ACTION_CANCEL:
{
mActivePointerId=INACTIVE_POINTER_ID;
mIsScrolling=false;
recycleVelocityTracker();
break;
}
}
return mIsScrolling;
}","private boolean handleTouchEvent(MotionEvent ev){
  if (mSv.getTaskViews().size() == 0) {
    return false;
  }
  final TaskStackLayoutAlgorithm layoutAlgorithm=mSv.mLayoutAlgorithm;
  int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
{
      mDownX=(int)ev.getX();
      mDownY=(int)ev.getY();
      mLastY=mDownY;
      mDownScrollP=mScroller.getStackScroll();
      mActivePointerId=ev.getPointerId(0);
      mActiveTaskView=findViewAtPoint(mDownX,mDownY);
      mScroller.stopScroller();
      mScroller.stopBoundScrollAnimation();
      mScroller.resetDeltaScroll();
      Utilities.cancelAnimationWithoutCallbacks(mScrollFlingAnimator);
      mSv.cancelAllTaskViewAnimations();
      ArrayMap<View,Animator> existingAnimators=new ArrayMap<>(mSwipeHelperAnimations);
      for (int i=0; i < existingAnimators.size(); i++) {
        existingAnimators.get(existingAnimators.keyAt(i)).end();
      }
      mSwipeHelperAnimations.clear();
      initOrResetVelocityTracker();
      mVelocityTracker.addMovement(ev);
      break;
    }
case MotionEvent.ACTION_POINTER_DOWN:
{
    final int index=ev.getActionIndex();
    mActivePointerId=ev.getPointerId(index);
    mDownX=(int)ev.getX(index);
    mDownY=(int)ev.getY(index);
    mLastY=mDownY;
    mDownScrollP=mScroller.getStackScroll();
    mScroller.resetDeltaScroll();
    mVelocityTracker.addMovement(ev);
    break;
  }
case MotionEvent.ACTION_MOVE:
{
  int activePointerIndex=ev.findPointerIndex(mActivePointerId);
  int y=(int)ev.getY(activePointerIndex);
  int x=(int)ev.getX(activePointerIndex);
  if (!mIsScrolling) {
    int yDiff=Math.abs(y - mDownY);
    int xDiff=Math.abs(x - mDownX);
    if (Math.abs(y - mDownY) > mScrollTouchSlop && yDiff > xDiff) {
      mIsScrolling=true;
      float stackScroll=mScroller.getStackScroll();
      List<TaskView> taskViews=mSv.getTaskViews();
      for (int i=taskViews.size() - 1; i >= 0; i--) {
        layoutAlgorithm.addUnfocusedTaskOverride(taskViews.get(i).getTask(),stackScroll);
      }
      layoutAlgorithm.setFocusState(TaskStackLayoutAlgorithm.STATE_UNFOCUSED);
      final ViewParent parent=mSv.getParent();
      if (parent != null) {
        parent.requestDisallowInterceptTouchEvent(true);
      }
      MetricsLogger.action(mSv.getContext(),MetricsEvent.OVERVIEW_SCROLL);
    }
  }
  if (mIsScrolling) {
    float deltaP=layoutAlgorithm.getDeltaPForY(mDownY,y);
    float minScrollP=layoutAlgorithm.mMinScrollP;
    float maxScrollP=layoutAlgorithm.mMaxScrollP;
    float curScrollP=mDownScrollP + deltaP;
    if (curScrollP < minScrollP || curScrollP > maxScrollP) {
      float clampedScrollP=Utilities.clamp(curScrollP,minScrollP,maxScrollP);
      float overscrollP=(curScrollP - clampedScrollP);
      float overscrollX=Math.abs(overscrollP) / MAX_OVERSCROLL;
      float interpX=OVERSCROLL_INTERP.getInterpolation(overscrollX);
      curScrollP=clampedScrollP + Math.signum(overscrollP) * (interpX * MAX_OVERSCROLL);
    }
    mDownScrollP+=mScroller.setDeltaStackScroll(mDownScrollP,curScrollP - mDownScrollP);
    mStackViewScrolledEvent.updateY(y - mLastY);
    EventBus.getDefault().send(mStackViewScrolledEvent);
  }
  mLastY=y;
  mVelocityTracker.addMovement(ev);
  break;
}
case MotionEvent.ACTION_POINTER_UP:
{
int pointerIndex=ev.getActionIndex();
int pointerId=ev.getPointerId(pointerIndex);
if (pointerId == mActivePointerId) {
  final int newPointerIndex=(pointerIndex == 0) ? 1 : 0;
  mActivePointerId=ev.getPointerId(newPointerIndex);
  mDownX=(int)ev.getX(pointerIndex);
  mDownY=(int)ev.getY(pointerIndex);
  mLastY=mDownY;
  mDownScrollP=mScroller.getStackScroll();
}
mVelocityTracker.addMovement(ev);
break;
}
case MotionEvent.ACTION_UP:
{
mVelocityTracker.addMovement(ev);
mVelocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int activePointerIndex=ev.findPointerIndex(mActivePointerId);
int y=(int)ev.getY(activePointerIndex);
int velocity=(int)mVelocityTracker.getYVelocity(mActivePointerId);
if (mIsScrolling) {
if (mScroller.isScrollOutOfBounds()) {
  mScroller.animateBoundScroll();
}
 else if (Math.abs(velocity) > mMinimumVelocity) {
  float minY=mDownY + layoutAlgorithm.getYForDeltaP(mDownScrollP,layoutAlgorithm.mMaxScrollP);
  float maxY=mDownY + layoutAlgorithm.getYForDeltaP(mDownScrollP,layoutAlgorithm.mMinScrollP);
  mScroller.fling(mDownScrollP,mDownY,y,velocity,(int)minY,(int)maxY,mOverscrollSize);
  mSv.invalidate();
}
mSv.resetFocusedTask(mSv.getFocusedTask());
}
 else if (mActiveTaskView == null) {
maybeHideRecentsFromBackgroundTap((int)ev.getX(),(int)ev.getY());
}
mActivePointerId=INACTIVE_POINTER_ID;
mIsScrolling=false;
recycleVelocityTracker();
break;
}
case MotionEvent.ACTION_CANCEL:
{
mActivePointerId=INACTIVE_POINTER_ID;
mIsScrolling=false;
recycleVelocityTracker();
break;
}
}
return mIsScrolling;
}",0.9492768811569902
192166,"void dismissRecentsToHome(boolean animateTaskViews){
  Runnable closeSystemWindows=new Runnable(){
    @Override public void run(){
      Recents.getSystemServices().sendCloseSystemWindows(BaseStatusBar.SYSTEM_DIALOG_REASON_HOME_KEY);
    }
  }
;
  DismissRecentsToHomeAnimationStarted dismissEvent=new DismissRecentsToHomeAnimationStarted(animateTaskViews);
  dismissEvent.addPostAnimationCallback(mFinishLaunchHomeRunnable);
  dismissEvent.addPostAnimationCallback(closeSystemWindows);
  if (mTaskStackHorizontalGridView.getChildCount() > 0) {
    mHomeRecentsEnterExitAnimationHolder.startExitAnimation(dismissEvent);
  }
 else {
    closeSystemWindows.run();
    mFinishLaunchHomeRunnable.run();
  }
}","void dismissRecentsToHome(boolean animateTaskViews){
  Runnable closeSystemWindows=new Runnable(){
    @Override public void run(){
      Recents.getSystemServices().sendCloseSystemWindows(BaseStatusBar.SYSTEM_DIALOG_REASON_HOME_KEY);
    }
  }
;
  DismissRecentsToHomeAnimationStarted dismissEvent=new DismissRecentsToHomeAnimationStarted(animateTaskViews);
  dismissEvent.addPostAnimationCallback(mFinishLaunchHomeRunnable);
  dismissEvent.addPostAnimationCallback(closeSystemWindows);
  if (mTaskStackHorizontalGridView.getChildCount() > 0 && animateTaskViews) {
    mHomeRecentsEnterExitAnimationHolder.startExitAnimation(dismissEvent);
  }
 else {
    closeSystemWindows.run();
    mFinishLaunchHomeRunnable.run();
  }
}",0.986013986013986
192167,"public DismissAnimationsHolder(TaskCardView taskCardView){
  mTaskCardView=(LinearLayout)taskCardView.findViewById(R.id.recents_tv_card);
  mDismissArea=(LinearLayout)taskCardView.findViewById(R.id.card_dismiss);
  Resources res=taskCardView.getResources();
  mCardYDelta=res.getDimensionPixelOffset(R.dimen.recents_tv_dismiss_shift_down);
  mShortDuration=res.getInteger(R.integer.dismiss_short_duration);
  mLongDuration=res.getInteger(R.integer.dismiss_long_duration);
}","public DismissAnimationsHolder(TaskCardView taskCardView){
  mRecentsTvCard=(LinearLayout)taskCardView.findViewById(R.id.recents_tv_card);
  mDismissArea=(LinearLayout)taskCardView.findViewById(R.id.card_dismiss);
  Resources res=taskCardView.getResources();
  mCardYDelta=res.getDimensionPixelOffset(R.dimen.recents_tv_dismiss_shift_down);
  mShortDuration=res.getInteger(R.integer.dismiss_short_duration);
  mLongDuration=res.getInteger(R.integer.dismiss_long_duration);
}",0.97571277719113
192168,"public void startExitAnimation(){
  mDismissArea.animate().setDuration(mShortDuration).setInterpolator(Interpolators.FAST_OUT_SLOW_IN).alpha(0.0f);
  mTaskCardView.animate().setDuration(mShortDuration).setInterpolator(Interpolators.FAST_OUT_SLOW_IN).translationYBy(-mCardYDelta).alpha(1.0f);
}","public void startExitAnimation(){
  mDismissArea.animate().setDuration(mShortDuration).setInterpolator(Interpolators.FAST_OUT_SLOW_IN).alpha(0.0f);
  mRecentsTvCard.animate().setDuration(mShortDuration).setInterpolator(Interpolators.FAST_OUT_SLOW_IN).translationYBy(-mCardYDelta).alpha(1.0f);
}",0.9710391822827938
192169,"public void startDismissAnimation(Animator.AnimatorListener listener){
  mDismissArea.animate().setDuration(mShortDuration).setInterpolator(Interpolators.FAST_OUT_SLOW_IN).alpha(0.0f);
  mTaskCardView.animate().setDuration(mLongDuration).setInterpolator(Interpolators.FAST_OUT_SLOW_IN).translationYBy(mCardYDelta).alpha(0.0f).setListener(listener);
}","public void startDismissAnimation(Animator.AnimatorListener listener){
  mDismissArea.animate().setDuration(mShortDuration).setInterpolator(Interpolators.FAST_OUT_SLOW_IN).alpha(0.0f);
  mRecentsTvCard.animate().setDuration(mLongDuration).setInterpolator(Interpolators.FAST_OUT_SLOW_IN).translationYBy(mCardYDelta).alpha(0.0f).setListener(listener);
}",0.9757489300998572
192170,"public void startEnterAnimation(){
  mDismissArea.animate().setDuration(mShortDuration).setInterpolator(Interpolators.FAST_OUT_SLOW_IN).alpha(1.0f);
  mTaskCardView.animate().setDuration(mShortDuration).setInterpolator(Interpolators.FAST_OUT_SLOW_IN).translationYBy(mCardYDelta).alpha(0.5f);
}","public void startEnterAnimation(){
  mDismissArea.animate().setDuration(mShortDuration).setInterpolator(Interpolators.FAST_OUT_SLOW_IN).alpha(1.0f);
  mRecentsTvCard.animate().setDuration(mShortDuration).setInterpolator(Interpolators.FAST_OUT_SLOW_IN).translationYBy(mCardYDelta).alpha(0.5f);
}",0.9710391822827938
192171,"public TaskStackHorizontalGridView setTaskStackViewAdapter(TaskStackHorizontalViewAdapter taskStackViewAdapter){
  if (mTaskStackHorizontalView != null) {
    mTaskStackHorizontalView.setAdapter(taskStackViewAdapter);
  }
  return mTaskStackHorizontalView;
}","public TaskStackHorizontalGridView setTaskStackViewAdapter(TaskStackHorizontalViewAdapter taskStackViewAdapter){
  if (mTaskStackHorizontalView != null) {
    mTaskStackHorizontalView.setAdapter(taskStackViewAdapter);
    taskStackViewAdapter.setTaskStackHorizontalGridView(mTaskStackHorizontalView);
  }
  return mTaskStackHorizontalView;
}",0.8614357262103506
192172,"public void startDismissTaskAnimation(Animator.AnimatorListener listener){
  mDismissAnimationsHolder.startDismissAnimation(listener);
}","public void startDismissTaskAnimation(Animator.AnimatorListener listener){
  mDismissState=false;
  mDismissAnimationsHolder.startDismissAnimation(listener);
}",0.9220338983050848
192173,"@Override public void onStackTaskRemoved(TaskStack stack,Task removedTask,boolean wasFrontMostTask,Task newFrontMostTask,AnimationProps animation,boolean fromDockGesture){
  getAdapter().notifyItemRemoved(stack.getStackTasks().indexOf(removedTask));
  if (mFocusedTask == removedTask) {
    resetFocusedTask(removedTask);
  }
  if (mStack.getStackTaskCount() == 0) {
    boolean shouldFinishActivity=(mStack.getStackTaskCount() == 0);
    if (shouldFinishActivity) {
      EventBus.getDefault().send(new AllTaskViewsDismissedEvent(fromDockGesture ? R.string.recents_empty_message : R.string.recents_empty_message_dismissed_all));
    }
  }
}","@Override public void onStackTaskRemoved(TaskStack stack,Task removedTask,boolean wasFrontMostTask,Task newFrontMostTask,AnimationProps animation,boolean fromDockGesture){
  ((TaskStackHorizontalViewAdapter)getAdapter()).removeTask(removedTask);
  if (mFocusedTask == removedTask) {
    resetFocusedTask(removedTask);
  }
  if (mStack.getStackTaskCount() == 0) {
    boolean shouldFinishActivity=(mStack.getStackTaskCount() == 0);
    if (shouldFinishActivity) {
      EventBus.getDefault().send(new AllTaskViewsDismissedEvent(fromDockGesture ? R.string.recents_empty_message : R.string.recents_empty_message_dismissed_all));
    }
  }
}",0.8998435054773083
192174,"@Override public void onStackTaskAdded(TaskStack stack,Task newTask){
  getAdapter().notifyItemInserted(stack.getStackTasks().indexOf(newTask));
}","@Override public void onStackTaskAdded(TaskStack stack,Task newTask){
  ((TaskStackHorizontalViewAdapter)getAdapter()).addTaskAt(newTask,stack.indexOfStackTask(newTask));
}",0.7358490566037735
192175,"@Override public void onClick(View v){
  try {
    if (mTaskCardView.isInDismissState()) {
      mTaskCardView.startDismissTaskAnimation(getRemoveAtListener(getAdapterPosition(),mTaskCardView));
    }
 else {
      EventBus.getDefault().send(new LaunchTvTaskEvent(mTaskCardView,mTask,null,INVALID_STACK_ID));
      ((Activity)(v.getContext())).finish();
    }
  }
 catch (  Exception e) {
    Log.e(TAG,v.getContext().getString(R.string.recents_launch_error_message,mTask.title),e);
  }
}","@Override public void onClick(View v){
  try {
    if (mTaskCardView.isInDismissState()) {
      mTaskCardView.startDismissTaskAnimation(getRemoveAtListener(getAdapterPosition(),mTaskCardView.getTask()));
    }
 else {
      EventBus.getDefault().send(new LaunchTvTaskEvent(mTaskCardView,mTask,null,INVALID_STACK_ID));
      ((Activity)(v.getContext())).finish();
    }
  }
 catch (  Exception e) {
    Log.e(TAG,v.getContext().getString(R.string.recents_launch_error_message,mTask.title),e);
  }
}",0.9898580121703854
192176,"@Override public void onAnimationEnd(Animator animation){
  removeAt(position);
  EventBus.getDefault().send(new DeleteTaskDataEvent(taskCardView.getTask()));
}","@Override public void onAnimationEnd(Animator animation){
  removeAt(position);
  EventBus.getDefault().send(new DeleteTaskDataEvent(task));
}",0.9403973509933776
192177,"private Animator.AnimatorListener getRemoveAtListener(final int position,final TaskCardView taskCardView){
  return new Animator.AnimatorListener(){
    @Override public void onAnimationStart(    Animator animation){
    }
    @Override public void onAnimationEnd(    Animator animation){
      removeAt(position);
      EventBus.getDefault().send(new DeleteTaskDataEvent(taskCardView.getTask()));
    }
    @Override public void onAnimationCancel(    Animator animation){
    }
    @Override public void onAnimationRepeat(    Animator animation){
    }
  }
;
}","private Animator.AnimatorListener getRemoveAtListener(final int position,final Task task){
  return new Animator.AnimatorListener(){
    @Override public void onAnimationStart(    Animator animation){
    }
    @Override public void onAnimationEnd(    Animator animation){
      removeAt(position);
      EventBus.getDefault().send(new DeleteTaskDataEvent(task));
    }
    @Override public void onAnimationCancel(    Animator animation){
    }
    @Override public void onAnimationRepeat(    Animator animation){
    }
  }
;
}",0.96875
192178,"private void removeAt(int position){
  mTaskList.remove(position);
  notifyItemRemoved(position);
}","private void removeAt(int position){
  Task removedTask=mTaskList.remove(position);
  if (mGridView != null) {
    mGridView.getStack().removeTask(removedTask,AnimationProps.IMMEDIATE,false);
  }
  notifyItemRemoved(position);
}",0.6055045871559633
192179,"private boolean isCarrierApp(String packageName){
synchronized (mLock) {
    if (mCarrierPrivilegedApps == null) {
      fetchCarrierPrivilegedAppsLocked();
    }
  }
  return mCarrierPrivilegedApps.contains(packageName);
}","private boolean isCarrierApp(String packageName){
synchronized (mLock) {
    if (!mHaveCarrierPrivilegedApps) {
      fetchCarrierPrivilegedAppsLocked();
    }
    if (mCarrierPrivilegedApps != null) {
      return mCarrierPrivilegedApps.contains(packageName);
    }
    return false;
  }
}",0.4639376218323586
192180,"void clearCarrierPrivilegedApps(){
  if (DEBUG) {
    Slog.i(TAG,""String_Node_Str"");
  }
synchronized (mLock) {
    mCarrierPrivilegedApps=null;
  }
}","void clearCarrierPrivilegedApps(){
  if (DEBUG) {
    Slog.i(TAG,""String_Node_Str"");
  }
synchronized (mLock) {
    mHaveCarrierPrivilegedApps=false;
    mCarrierPrivilegedApps=null;
  }
}",0.8875739644970414
192181,"private void fetchCarrierPrivilegedAppsLocked(){
  TelephonyManager telephonyManager=getContext().getSystemService(TelephonyManager.class);
  mCarrierPrivilegedApps=telephonyManager.getPackagesWithCarrierPrivileges();
  if (DEBUG) {
    Slog.d(TAG,""String_Node_Str"" + mCarrierPrivilegedApps);
  }
}","private void fetchCarrierPrivilegedAppsLocked(){
  TelephonyManager telephonyManager=getContext().getSystemService(TelephonyManager.class);
  mCarrierPrivilegedApps=telephonyManager.getPackagesWithCarrierPrivileges();
  mHaveCarrierPrivilegedApps=true;
  if (DEBUG) {
    Slog.d(TAG,""String_Node_Str"" + mCarrierPrivilegedApps);
  }
}",0.9445324881141046
192182,"private boolean isCarrierApp(String packageName){
synchronized (mLock) {
    if (mCarrierPrivilegedApps == null) {
      fetchCarrierPrivilegedAppsLocked();
    }
  }
  return mCarrierPrivilegedApps.contains(packageName);
}","private boolean isCarrierApp(String packageName){
synchronized (mLock) {
    if (!mHaveCarrierPrivilegedApps) {
      fetchCarrierPrivilegedAppsLocked();
    }
    if (mCarrierPrivilegedApps != null) {
      return mCarrierPrivilegedApps.contains(packageName);
    }
    return false;
  }
}",0.4639376218323586
192183,"void clearCarrierPrivilegedApps(){
  if (DEBUG) {
    Slog.i(TAG,""String_Node_Str"");
  }
synchronized (mLock) {
    mCarrierPrivilegedApps=null;
  }
}","void clearCarrierPrivilegedApps(){
  if (DEBUG) {
    Slog.i(TAG,""String_Node_Str"");
  }
synchronized (mLock) {
    mHaveCarrierPrivilegedApps=false;
    mCarrierPrivilegedApps=null;
  }
}",0.8875739644970414
192184,"private void fetchCarrierPrivilegedAppsLocked(){
  TelephonyManager telephonyManager=getContext().getSystemService(TelephonyManager.class);
  mCarrierPrivilegedApps=telephonyManager.getPackagesWithCarrierPrivileges();
  if (DEBUG) {
    Slog.d(TAG,""String_Node_Str"" + mCarrierPrivilegedApps);
  }
}","private void fetchCarrierPrivilegedAppsLocked(){
  TelephonyManager telephonyManager=getContext().getSystemService(TelephonyManager.class);
  mCarrierPrivilegedApps=telephonyManager.getPackagesWithCarrierPrivileges();
  mHaveCarrierPrivilegedApps=true;
  if (DEBUG) {
    Slog.d(TAG,""String_Node_Str"" + mCarrierPrivilegedApps);
  }
}",0.9445324881141046
192185,"@Override public void onHeadsUpStateChanged(NotificationData.Entry entry,boolean isHeadsUp){
  final StatusBarNotification sbn=entry.notification;
  if (entry.row.isHeadsUp()) {
    if (shouldIsolate(sbn)) {
      onEntryRemovedInternal(entry,entry.notification);
      mIsolatedEntries.put(sbn.getKey(),sbn);
      onEntryAdded(entry);
      updateSuppression(mGroupMap.get(entry.notification.getGroupKey()));
      mListener.onGroupsChanged();
    }
  }
 else {
    if (mIsolatedEntries.containsKey(sbn.getKey())) {
      onEntryRemovedInternal(entry,entry.notification);
      mIsolatedEntries.remove(sbn.getKey());
      onEntryAdded(entry);
      mListener.onGroupsChanged();
    }
  }
}","@Override public void onHeadsUpStateChanged(NotificationData.Entry entry,boolean isHeadsUp){
  final StatusBarNotification sbn=entry.notification;
  if (entry.row.isHeadsUp()) {
    if (shouldIsolate(sbn)) {
      onEntryRemovedInternal(entry,entry.notification);
      mIsolatedEntries.put(sbn.getKey(),sbn);
      onEntryAdded(entry);
      updateSuppression(mGroupMap.get(entry.notification.getGroupKey()));
      mListener.onGroupsChanged();
    }
 else {
      handleSuppressedSummaryHeadsUpped(entry);
    }
  }
 else {
    if (mIsolatedEntries.containsKey(sbn.getKey())) {
      onEntryRemovedInternal(entry,entry.notification);
      mIsolatedEntries.remove(sbn.getKey());
      onEntryAdded(entry);
      mListener.onGroupsChanged();
    }
  }
}",0.9571230982019364
192186,"private void updateSuppression(NotificationGroup group){
  if (group == null) {
    return;
  }
  boolean prevSuppressed=group.suppressed;
  group.suppressed=group.summary != null && !group.expanded && (group.children.size() == 1 || (group.children.size() == 0 && group.summary.notification.getNotification().isGroupSummary() && hasIsolatedChildren(group)));
  if (prevSuppressed != group.suppressed) {
    mListener.onGroupsChanged();
  }
}","private void updateSuppression(NotificationGroup group){
  if (group == null) {
    return;
  }
  boolean prevSuppressed=group.suppressed;
  group.suppressed=group.summary != null && !group.expanded && (group.children.size() == 1 || (group.children.size() == 0 && group.summary.notification.getNotification().isGroupSummary() && hasIsolatedChildren(group)));
  if (prevSuppressed != group.suppressed) {
    if (group.suppressed) {
      handleSuppressedSummaryHeadsUpped(group.summary);
    }
    mListener.onGroupsChanged();
  }
}",0.9074074074074074
192187,"protected PhoneStatusBarView makeStatusBarView(){
  final Context context=mContext;
  updateDisplaySize();
  updateResources();
  inflateStatusBarWindow(context);
  mStatusBarWindow.setService(this);
  mStatusBarWindow.setOnTouchListener(new View.OnTouchListener(){
    @Override public boolean onTouch(    View v,    MotionEvent event){
      checkUserAutohide(v,event);
      if (event.getAction() == MotionEvent.ACTION_DOWN) {
        if (mExpandedVisible) {
          animateCollapsePanels();
        }
      }
      return mStatusBarWindow.onTouchEvent(event);
    }
  }
);
  mNotificationPanel=(NotificationPanelView)mStatusBarWindow.findViewById(R.id.notification_panel);
  mNotificationPanel.setStatusBar(this);
  mNotificationPanel.setGroupManager(mGroupManager);
  mStatusBarView=(PhoneStatusBarView)mStatusBarWindow.findViewById(R.id.status_bar);
  mStatusBarView.setBar(this);
  mStatusBarView.setPanel(mNotificationPanel);
  if (!ActivityManager.isHighEndGfx()) {
    mStatusBarWindow.setBackground(null);
    mNotificationPanel.setBackground(new FastColorDrawable(context.getColor(R.color.notification_panel_solid_background)));
  }
  mHeadsUpManager=new HeadsUpManager(context,mStatusBarWindow,mGroupManager);
  mHeadsUpManager.setBar(this);
  mHeadsUpManager.addListener(this);
  mHeadsUpManager.addListener(mNotificationPanel);
  mHeadsUpManager.addListener(mGroupManager);
  mNotificationPanel.setHeadsUpManager(mHeadsUpManager);
  mNotificationData.setHeadsUpManager(mHeadsUpManager);
  if (MULTIUSER_DEBUG) {
    mNotificationPanelDebugText=(TextView)mNotificationPanel.findViewById(R.id.header_debug_info);
    mNotificationPanelDebugText.setVisibility(View.VISIBLE);
  }
  try {
    boolean showNav=mWindowManagerService.hasNavigationBar();
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + showNav);
    if (showNav) {
      createNavigationBarView(context);
    }
  }
 catch (  RemoteException ex) {
  }
  mAssistManager=new AssistManager(this,context);
  mPixelFormat=PixelFormat.OPAQUE;
  mStackScroller=(NotificationStackScrollLayout)mStatusBarWindow.findViewById(R.id.notification_stack_scroller);
  mStackScroller.setLongPressListener(getNotificationLongClicker());
  mStackScroller.setPhoneStatusBar(this);
  mStackScroller.setGroupManager(mGroupManager);
  mStackScroller.setHeadsUpManager(mHeadsUpManager);
  mGroupManager.setOnGroupChangeListener(mStackScroller);
  mKeyguardIconOverflowContainer=(NotificationOverflowContainer)LayoutInflater.from(mContext).inflate(R.layout.status_bar_notification_keyguard_overflow,mStackScroller,false);
  mKeyguardIconOverflowContainer.setOnActivatedListener(this);
  mKeyguardIconOverflowContainer.setOnClickListener(mOverflowClickListener);
  mStackScroller.setOverflowContainer(mKeyguardIconOverflowContainer);
  inflateEmptyShadeView();
  inflateDismissView();
  mExpandedContents=mStackScroller;
  mBackdrop=(BackDropView)mStatusBarWindow.findViewById(R.id.backdrop);
  mBackdropFront=(ImageView)mBackdrop.findViewById(R.id.backdrop_front);
  mBackdropBack=(ImageView)mBackdrop.findViewById(R.id.backdrop_back);
  ScrimView scrimBehind=(ScrimView)mStatusBarWindow.findViewById(R.id.scrim_behind);
  ScrimView scrimInFront=(ScrimView)mStatusBarWindow.findViewById(R.id.scrim_in_front);
  View headsUpScrim=mStatusBarWindow.findViewById(R.id.heads_up_scrim);
  mScrimController=SystemUIFactory.getInstance().createScrimController(scrimBehind,scrimInFront,headsUpScrim);
  if (mScrimSrcModeEnabled) {
    Runnable runnable=new Runnable(){
      @Override public void run(){
        boolean asSrc=mBackdrop.getVisibility() != View.VISIBLE;
        mScrimController.setDrawBehindAsSrc(asSrc);
        mStackScroller.setDrawBackgroundAsSrc(asSrc);
      }
    }
;
    mBackdrop.setOnVisibilityChangedRunnable(runnable);
    runnable.run();
  }
  mHeadsUpManager.addListener(mScrimController);
  mStackScroller.setScrimController(mScrimController);
  mStatusBarView.setScrimController(mScrimController);
  mDozeScrimController=new DozeScrimController(mScrimController,context);
  mKeyguardStatusBar=(KeyguardStatusBarView)mStatusBarWindow.findViewById(R.id.keyguard_header);
  mKeyguardStatusView=mStatusBarWindow.findViewById(R.id.keyguard_status_view);
  mKeyguardBottomArea=(KeyguardBottomAreaView)mStatusBarWindow.findViewById(R.id.keyguard_bottom_area);
  mKeyguardBottomArea.setActivityStarter(this);
  mKeyguardBottomArea.setAssistManager(mAssistManager);
  mKeyguardIndicationController=new KeyguardIndicationController(mContext,(KeyguardIndicationTextView)mStatusBarWindow.findViewById(R.id.keyguard_indication_text),mKeyguardBottomArea.getLockIcon());
  mKeyguardBottomArea.setKeyguardIndicationController(mKeyguardIndicationController);
  if (ENABLE_LOCKSCREEN_WALLPAPER) {
    mLockscreenWallpaper=new LockscreenWallpaper(mContext,this,mHandler);
  }
  setAreThereNotifications();
  createIconController();
  mHandlerThread=new HandlerThread(TAG,Process.THREAD_PRIORITY_BACKGROUND);
  mHandlerThread.start();
  mLocationController=new LocationControllerImpl(mContext,mHandlerThread.getLooper());
  mBatteryController=createBatteryController();
  mBatteryController.addStateChangedCallback(new BatteryStateChangeCallback(){
    @Override public void onPowerSaveChanged(    boolean isPowerSave){
      mHandler.post(mCheckBarModes);
      if (mDozeServiceHost != null) {
        mDozeServiceHost.firePowerSaveChanged(isPowerSave);
      }
    }
    @Override public void onBatteryLevelChanged(    int level,    boolean pluggedIn,    boolean charging){
    }
  }
);
  mNetworkController=new NetworkControllerImpl(mContext,mHandlerThread.getLooper());
  mHotspotController=new HotspotControllerImpl(mContext);
  mBluetoothController=new BluetoothControllerImpl(mContext,mHandlerThread.getLooper());
  mSecurityController=new SecurityControllerImpl(mContext);
  if (mContext.getResources().getBoolean(R.bool.config_showRotationLock)) {
    mRotationLockController=new RotationLockControllerImpl(mContext);
  }
  mUserInfoController=new UserInfoController(mContext);
  mVolumeComponent=getComponent(VolumeComponent.class);
  if (mVolumeComponent != null) {
    mZenModeController=mVolumeComponent.getZenController();
  }
  mCastController=new CastControllerImpl(mContext);
  initSignalCluster(mStatusBarView);
  initSignalCluster(mKeyguardStatusBar);
  mFlashlightController=new FlashlightController(mContext);
  mKeyguardBottomArea.setFlashlightController(mFlashlightController);
  mKeyguardBottomArea.setPhoneStatusBar(this);
  mKeyguardBottomArea.setUserSetupComplete(mUserSetup);
  mAccessibilityController=new AccessibilityController(mContext);
  mKeyguardBottomArea.setAccessibilityController(mAccessibilityController);
  mNextAlarmController=new NextAlarmController(mContext);
  mLightStatusBarController=new LightStatusBarController(mIconController,mBatteryController);
  mKeyguardMonitor=new KeyguardMonitor(mContext);
  if (UserManager.get(mContext).isUserSwitcherEnabled()) {
    mUserSwitcherController=new UserSwitcherController(mContext,mKeyguardMonitor,mHandler,this);
    createUserSwitcher();
  }
  DensityContainer container=(DensityContainer)mStatusBarWindow.findViewById(R.id.qs_density_container);
  if (container != null) {
    final QSTileHost qsh=SystemUIFactory.getInstance().createQSTileHost(mContext,this,mBluetoothController,mLocationController,mRotationLockController,mNetworkController,mZenModeController,mHotspotController,mCastController,mFlashlightController,mUserSwitcherController,mUserInfoController,mKeyguardMonitor,mSecurityController,mBatteryController,mIconController,mNextAlarmController);
    mBrightnessMirrorController=new BrightnessMirrorController(mStatusBarWindow);
    container.addInflateListener(new InflateListener(){
      @Override public void onInflated(      View v){
        QSContainer qsContainer=(QSContainer)v.findViewById(R.id.quick_settings_container);
        qsContainer.setHost(qsh);
        mQSPanel=qsContainer.getQsPanel();
        mQSPanel.setBrightnessMirror(mBrightnessMirrorController);
        mHeader=qsContainer.getHeader();
        initSignalCluster(mHeader);
        mHeader.setActivityStarter(PhoneStatusBar.this);
      }
    }
);
  }
  mKeyguardStatusBar.setUserInfoController(mUserInfoController);
  mKeyguardStatusBar.setUserSwitcherController(mUserSwitcherController);
  mUserInfoController.reloadUserInfo();
  ((BatteryMeterView)mStatusBarView.findViewById(R.id.battery)).setBatteryController(mBatteryController);
  mKeyguardStatusBar.setBatteryController(mBatteryController);
  PowerManager pm=(PowerManager)mContext.getSystemService(Context.POWER_SERVICE);
  mBroadcastReceiver.onReceive(mContext,new Intent(pm.isScreenOn() ? Intent.ACTION_SCREEN_ON : Intent.ACTION_SCREEN_OFF));
  mGestureWakeLock=pm.newWakeLock(PowerManager.SCREEN_BRIGHT_WAKE_LOCK,""String_Node_Str"");
  mVibrator=mContext.getSystemService(Vibrator.class);
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
  filter.addAction(Intent.ACTION_SCREEN_OFF);
  filter.addAction(Intent.ACTION_SCREEN_ON);
  context.registerReceiverAsUser(mBroadcastReceiver,UserHandle.ALL,filter,null,null);
  IntentFilter demoFilter=new IntentFilter();
  if (DEBUG_MEDIA_FAKE_ARTWORK) {
    demoFilter.addAction(ACTION_FAKE_ARTWORK);
  }
  demoFilter.addAction(ACTION_DEMO);
  context.registerReceiverAsUser(mDemoReceiver,UserHandle.ALL,demoFilter,android.Manifest.permission.DUMP,null);
  resetUserSetupObserver();
  ThreadedRenderer.overrideProperty(""String_Node_Str"",""String_Node_Str"");
  ThreadedRenderer.overrideProperty(""String_Node_Str"",String.valueOf(1.5f));
  return mStatusBarView;
}","protected PhoneStatusBarView makeStatusBarView(){
  final Context context=mContext;
  updateDisplaySize();
  updateResources();
  inflateStatusBarWindow(context);
  mStatusBarWindow.setService(this);
  mStatusBarWindow.setOnTouchListener(new View.OnTouchListener(){
    @Override public boolean onTouch(    View v,    MotionEvent event){
      checkUserAutohide(v,event);
      if (event.getAction() == MotionEvent.ACTION_DOWN) {
        if (mExpandedVisible) {
          animateCollapsePanels();
        }
      }
      return mStatusBarWindow.onTouchEvent(event);
    }
  }
);
  mNotificationPanel=(NotificationPanelView)mStatusBarWindow.findViewById(R.id.notification_panel);
  mNotificationPanel.setStatusBar(this);
  mNotificationPanel.setGroupManager(mGroupManager);
  mStatusBarView=(PhoneStatusBarView)mStatusBarWindow.findViewById(R.id.status_bar);
  mStatusBarView.setBar(this);
  mStatusBarView.setPanel(mNotificationPanel);
  if (!ActivityManager.isHighEndGfx()) {
    mStatusBarWindow.setBackground(null);
    mNotificationPanel.setBackground(new FastColorDrawable(context.getColor(R.color.notification_panel_solid_background)));
  }
  mHeadsUpManager=new HeadsUpManager(context,mStatusBarWindow,mGroupManager);
  mHeadsUpManager.setBar(this);
  mHeadsUpManager.addListener(this);
  mHeadsUpManager.addListener(mNotificationPanel);
  mHeadsUpManager.addListener(mGroupManager);
  mNotificationPanel.setHeadsUpManager(mHeadsUpManager);
  mNotificationData.setHeadsUpManager(mHeadsUpManager);
  mGroupManager.setHeadsUpManager(mHeadsUpManager);
  if (MULTIUSER_DEBUG) {
    mNotificationPanelDebugText=(TextView)mNotificationPanel.findViewById(R.id.header_debug_info);
    mNotificationPanelDebugText.setVisibility(View.VISIBLE);
  }
  try {
    boolean showNav=mWindowManagerService.hasNavigationBar();
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + showNav);
    if (showNav) {
      createNavigationBarView(context);
    }
  }
 catch (  RemoteException ex) {
  }
  mAssistManager=new AssistManager(this,context);
  mPixelFormat=PixelFormat.OPAQUE;
  mStackScroller=(NotificationStackScrollLayout)mStatusBarWindow.findViewById(R.id.notification_stack_scroller);
  mStackScroller.setLongPressListener(getNotificationLongClicker());
  mStackScroller.setPhoneStatusBar(this);
  mStackScroller.setGroupManager(mGroupManager);
  mStackScroller.setHeadsUpManager(mHeadsUpManager);
  mGroupManager.setOnGroupChangeListener(mStackScroller);
  mKeyguardIconOverflowContainer=(NotificationOverflowContainer)LayoutInflater.from(mContext).inflate(R.layout.status_bar_notification_keyguard_overflow,mStackScroller,false);
  mKeyguardIconOverflowContainer.setOnActivatedListener(this);
  mKeyguardIconOverflowContainer.setOnClickListener(mOverflowClickListener);
  mStackScroller.setOverflowContainer(mKeyguardIconOverflowContainer);
  inflateEmptyShadeView();
  inflateDismissView();
  mExpandedContents=mStackScroller;
  mBackdrop=(BackDropView)mStatusBarWindow.findViewById(R.id.backdrop);
  mBackdropFront=(ImageView)mBackdrop.findViewById(R.id.backdrop_front);
  mBackdropBack=(ImageView)mBackdrop.findViewById(R.id.backdrop_back);
  ScrimView scrimBehind=(ScrimView)mStatusBarWindow.findViewById(R.id.scrim_behind);
  ScrimView scrimInFront=(ScrimView)mStatusBarWindow.findViewById(R.id.scrim_in_front);
  View headsUpScrim=mStatusBarWindow.findViewById(R.id.heads_up_scrim);
  mScrimController=SystemUIFactory.getInstance().createScrimController(scrimBehind,scrimInFront,headsUpScrim);
  if (mScrimSrcModeEnabled) {
    Runnable runnable=new Runnable(){
      @Override public void run(){
        boolean asSrc=mBackdrop.getVisibility() != View.VISIBLE;
        mScrimController.setDrawBehindAsSrc(asSrc);
        mStackScroller.setDrawBackgroundAsSrc(asSrc);
      }
    }
;
    mBackdrop.setOnVisibilityChangedRunnable(runnable);
    runnable.run();
  }
  mHeadsUpManager.addListener(mScrimController);
  mStackScroller.setScrimController(mScrimController);
  mStatusBarView.setScrimController(mScrimController);
  mDozeScrimController=new DozeScrimController(mScrimController,context);
  mKeyguardStatusBar=(KeyguardStatusBarView)mStatusBarWindow.findViewById(R.id.keyguard_header);
  mKeyguardStatusView=mStatusBarWindow.findViewById(R.id.keyguard_status_view);
  mKeyguardBottomArea=(KeyguardBottomAreaView)mStatusBarWindow.findViewById(R.id.keyguard_bottom_area);
  mKeyguardBottomArea.setActivityStarter(this);
  mKeyguardBottomArea.setAssistManager(mAssistManager);
  mKeyguardIndicationController=new KeyguardIndicationController(mContext,(KeyguardIndicationTextView)mStatusBarWindow.findViewById(R.id.keyguard_indication_text),mKeyguardBottomArea.getLockIcon());
  mKeyguardBottomArea.setKeyguardIndicationController(mKeyguardIndicationController);
  if (ENABLE_LOCKSCREEN_WALLPAPER) {
    mLockscreenWallpaper=new LockscreenWallpaper(mContext,this,mHandler);
  }
  setAreThereNotifications();
  createIconController();
  mHandlerThread=new HandlerThread(TAG,Process.THREAD_PRIORITY_BACKGROUND);
  mHandlerThread.start();
  mLocationController=new LocationControllerImpl(mContext,mHandlerThread.getLooper());
  mBatteryController=createBatteryController();
  mBatteryController.addStateChangedCallback(new BatteryStateChangeCallback(){
    @Override public void onPowerSaveChanged(    boolean isPowerSave){
      mHandler.post(mCheckBarModes);
      if (mDozeServiceHost != null) {
        mDozeServiceHost.firePowerSaveChanged(isPowerSave);
      }
    }
    @Override public void onBatteryLevelChanged(    int level,    boolean pluggedIn,    boolean charging){
    }
  }
);
  mNetworkController=new NetworkControllerImpl(mContext,mHandlerThread.getLooper());
  mHotspotController=new HotspotControllerImpl(mContext);
  mBluetoothController=new BluetoothControllerImpl(mContext,mHandlerThread.getLooper());
  mSecurityController=new SecurityControllerImpl(mContext);
  if (mContext.getResources().getBoolean(R.bool.config_showRotationLock)) {
    mRotationLockController=new RotationLockControllerImpl(mContext);
  }
  mUserInfoController=new UserInfoController(mContext);
  mVolumeComponent=getComponent(VolumeComponent.class);
  if (mVolumeComponent != null) {
    mZenModeController=mVolumeComponent.getZenController();
  }
  mCastController=new CastControllerImpl(mContext);
  initSignalCluster(mStatusBarView);
  initSignalCluster(mKeyguardStatusBar);
  mFlashlightController=new FlashlightController(mContext);
  mKeyguardBottomArea.setFlashlightController(mFlashlightController);
  mKeyguardBottomArea.setPhoneStatusBar(this);
  mKeyguardBottomArea.setUserSetupComplete(mUserSetup);
  mAccessibilityController=new AccessibilityController(mContext);
  mKeyguardBottomArea.setAccessibilityController(mAccessibilityController);
  mNextAlarmController=new NextAlarmController(mContext);
  mLightStatusBarController=new LightStatusBarController(mIconController,mBatteryController);
  mKeyguardMonitor=new KeyguardMonitor(mContext);
  if (UserManager.get(mContext).isUserSwitcherEnabled()) {
    mUserSwitcherController=new UserSwitcherController(mContext,mKeyguardMonitor,mHandler,this);
    createUserSwitcher();
  }
  DensityContainer container=(DensityContainer)mStatusBarWindow.findViewById(R.id.qs_density_container);
  if (container != null) {
    final QSTileHost qsh=SystemUIFactory.getInstance().createQSTileHost(mContext,this,mBluetoothController,mLocationController,mRotationLockController,mNetworkController,mZenModeController,mHotspotController,mCastController,mFlashlightController,mUserSwitcherController,mUserInfoController,mKeyguardMonitor,mSecurityController,mBatteryController,mIconController,mNextAlarmController);
    mBrightnessMirrorController=new BrightnessMirrorController(mStatusBarWindow);
    container.addInflateListener(new InflateListener(){
      @Override public void onInflated(      View v){
        QSContainer qsContainer=(QSContainer)v.findViewById(R.id.quick_settings_container);
        qsContainer.setHost(qsh);
        mQSPanel=qsContainer.getQsPanel();
        mQSPanel.setBrightnessMirror(mBrightnessMirrorController);
        mHeader=qsContainer.getHeader();
        initSignalCluster(mHeader);
        mHeader.setActivityStarter(PhoneStatusBar.this);
      }
    }
);
  }
  mKeyguardStatusBar.setUserInfoController(mUserInfoController);
  mKeyguardStatusBar.setUserSwitcherController(mUserSwitcherController);
  mUserInfoController.reloadUserInfo();
  ((BatteryMeterView)mStatusBarView.findViewById(R.id.battery)).setBatteryController(mBatteryController);
  mKeyguardStatusBar.setBatteryController(mBatteryController);
  PowerManager pm=(PowerManager)mContext.getSystemService(Context.POWER_SERVICE);
  mBroadcastReceiver.onReceive(mContext,new Intent(pm.isScreenOn() ? Intent.ACTION_SCREEN_ON : Intent.ACTION_SCREEN_OFF));
  mGestureWakeLock=pm.newWakeLock(PowerManager.SCREEN_BRIGHT_WAKE_LOCK,""String_Node_Str"");
  mVibrator=mContext.getSystemService(Vibrator.class);
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
  filter.addAction(Intent.ACTION_SCREEN_OFF);
  filter.addAction(Intent.ACTION_SCREEN_ON);
  context.registerReceiverAsUser(mBroadcastReceiver,UserHandle.ALL,filter,null,null);
  IntentFilter demoFilter=new IntentFilter();
  if (DEBUG_MEDIA_FAKE_ARTWORK) {
    demoFilter.addAction(ACTION_FAKE_ARTWORK);
  }
  demoFilter.addAction(ACTION_DEMO);
  context.registerReceiverAsUser(mDemoReceiver,UserHandle.ALL,demoFilter,android.Manifest.permission.DUMP,null);
  resetUserSetupObserver();
  ThreadedRenderer.overrideProperty(""String_Node_Str"",""String_Node_Str"");
  ThreadedRenderer.overrideProperty(""String_Node_Str"",String.valueOf(1.5f));
  return mStatusBarView;
}",0.9973118279569892
192188,"/** 
 * Called when updating or posting a notification to the heads up.
 */
public void updateNotification(NotificationData.Entry headsUp,boolean alert){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"");
  headsUp.row.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED);
  if (alert) {
    HeadsUpEntry headsUpEntry=mHeadsUpEntries.get(headsUp.key);
    headsUpEntry.updateEntry();
    setEntryPinned(headsUpEntry,shouldHeadsUpBecomePinned(headsUp));
  }
}","/** 
 * Called when updating or posting a notification to the heads up.
 */
public void updateNotification(NotificationData.Entry headsUp,boolean alert){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"");
  headsUp.row.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED);
  if (alert) {
    HeadsUpEntry headsUpEntry=mHeadsUpEntries.get(headsUp.key);
    if (headsUpEntry == null) {
      return;
    }
    headsUpEntry.updateEntry();
    setEntryPinned(headsUpEntry,shouldHeadsUpBecomePinned(headsUp));
  }
}",0.8951612903225806
192189,"@Override public void onHeadsUpStateChanged(NotificationData.Entry entry,boolean isHeadsUp){
  final StatusBarNotification sbn=entry.notification;
  if (entry.row.isHeadsUp()) {
    if (shouldIsolate(sbn)) {
      onEntryRemovedInternal(entry,entry.notification);
      mIsolatedEntries.put(sbn.getKey(),sbn);
      onEntryAdded(entry);
      updateSuppression(mGroupMap.get(entry.notification.getGroupKey()));
      mListener.onGroupsChanged();
    }
  }
 else {
    if (mIsolatedEntries.containsKey(sbn.getKey())) {
      onEntryRemovedInternal(entry,entry.notification);
      mIsolatedEntries.remove(sbn.getKey());
      onEntryAdded(entry);
      mListener.onGroupsChanged();
    }
  }
}","@Override public void onHeadsUpStateChanged(NotificationData.Entry entry,boolean isHeadsUp){
  final StatusBarNotification sbn=entry.notification;
  if (entry.row.isHeadsUp()) {
    if (shouldIsolate(sbn)) {
      onEntryRemovedInternal(entry,entry.notification);
      mIsolatedEntries.put(sbn.getKey(),sbn);
      onEntryAdded(entry);
      updateSuppression(mGroupMap.get(entry.notification.getGroupKey()));
      mListener.onGroupsChanged();
    }
 else {
      handleSuppressedSummaryHeadsUpped(entry);
    }
  }
 else {
    if (mIsolatedEntries.containsKey(sbn.getKey())) {
      onEntryRemovedInternal(entry,entry.notification);
      mIsolatedEntries.remove(sbn.getKey());
      onEntryAdded(entry);
      mListener.onGroupsChanged();
    }
  }
}",0.9571230982019364
192190,"private void updateSuppression(NotificationGroup group){
  if (group == null) {
    return;
  }
  boolean prevSuppressed=group.suppressed;
  group.suppressed=group.summary != null && !group.expanded && (group.children.size() == 1 || (group.children.size() == 0 && group.summary.notification.getNotification().isGroupSummary() && hasIsolatedChildren(group)));
  if (prevSuppressed != group.suppressed) {
    mListener.onGroupsChanged();
  }
}","private void updateSuppression(NotificationGroup group){
  if (group == null) {
    return;
  }
  boolean prevSuppressed=group.suppressed;
  group.suppressed=group.summary != null && !group.expanded && (group.children.size() == 1 || (group.children.size() == 0 && group.summary.notification.getNotification().isGroupSummary() && hasIsolatedChildren(group)));
  if (prevSuppressed != group.suppressed) {
    if (group.suppressed) {
      handleSuppressedSummaryHeadsUpped(group.summary);
    }
    mListener.onGroupsChanged();
  }
}",0.9074074074074074
192191,"protected PhoneStatusBarView makeStatusBarView(){
  final Context context=mContext;
  updateDisplaySize();
  updateResources();
  inflateStatusBarWindow(context);
  mStatusBarWindow.setService(this);
  mStatusBarWindow.setOnTouchListener(new View.OnTouchListener(){
    @Override public boolean onTouch(    View v,    MotionEvent event){
      checkUserAutohide(v,event);
      if (event.getAction() == MotionEvent.ACTION_DOWN) {
        if (mExpandedVisible) {
          animateCollapsePanels();
        }
      }
      return mStatusBarWindow.onTouchEvent(event);
    }
  }
);
  mNotificationPanel=(NotificationPanelView)mStatusBarWindow.findViewById(R.id.notification_panel);
  mNotificationPanel.setStatusBar(this);
  mNotificationPanel.setGroupManager(mGroupManager);
  mStatusBarView=(PhoneStatusBarView)mStatusBarWindow.findViewById(R.id.status_bar);
  mStatusBarView.setBar(this);
  mStatusBarView.setPanel(mNotificationPanel);
  if (!ActivityManager.isHighEndGfx()) {
    mStatusBarWindow.setBackground(null);
    mNotificationPanel.setBackground(new FastColorDrawable(context.getColor(R.color.notification_panel_solid_background)));
  }
  mHeadsUpManager=new HeadsUpManager(context,mStatusBarWindow,mGroupManager);
  mHeadsUpManager.setBar(this);
  mHeadsUpManager.addListener(this);
  mHeadsUpManager.addListener(mNotificationPanel);
  mHeadsUpManager.addListener(mGroupManager);
  mNotificationPanel.setHeadsUpManager(mHeadsUpManager);
  mNotificationData.setHeadsUpManager(mHeadsUpManager);
  if (MULTIUSER_DEBUG) {
    mNotificationPanelDebugText=(TextView)mNotificationPanel.findViewById(R.id.header_debug_info);
    mNotificationPanelDebugText.setVisibility(View.VISIBLE);
  }
  try {
    boolean showNav=mWindowManagerService.hasNavigationBar();
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + showNav);
    if (showNav) {
      createNavigationBarView(context);
    }
  }
 catch (  RemoteException ex) {
  }
  mAssistManager=new AssistManager(this,context);
  mPixelFormat=PixelFormat.OPAQUE;
  mStackScroller=(NotificationStackScrollLayout)mStatusBarWindow.findViewById(R.id.notification_stack_scroller);
  mStackScroller.setLongPressListener(getNotificationLongClicker());
  mStackScroller.setPhoneStatusBar(this);
  mStackScroller.setGroupManager(mGroupManager);
  mStackScroller.setHeadsUpManager(mHeadsUpManager);
  mGroupManager.setOnGroupChangeListener(mStackScroller);
  mKeyguardIconOverflowContainer=(NotificationOverflowContainer)LayoutInflater.from(mContext).inflate(R.layout.status_bar_notification_keyguard_overflow,mStackScroller,false);
  mKeyguardIconOverflowContainer.setOnActivatedListener(this);
  mKeyguardIconOverflowContainer.setOnClickListener(mOverflowClickListener);
  mStackScroller.setOverflowContainer(mKeyguardIconOverflowContainer);
  inflateEmptyShadeView();
  inflateDismissView();
  mExpandedContents=mStackScroller;
  mBackdrop=(BackDropView)mStatusBarWindow.findViewById(R.id.backdrop);
  mBackdropFront=(ImageView)mBackdrop.findViewById(R.id.backdrop_front);
  mBackdropBack=(ImageView)mBackdrop.findViewById(R.id.backdrop_back);
  ScrimView scrimBehind=(ScrimView)mStatusBarWindow.findViewById(R.id.scrim_behind);
  ScrimView scrimInFront=(ScrimView)mStatusBarWindow.findViewById(R.id.scrim_in_front);
  View headsUpScrim=mStatusBarWindow.findViewById(R.id.heads_up_scrim);
  mScrimController=SystemUIFactory.getInstance().createScrimController(scrimBehind,scrimInFront,headsUpScrim);
  if (mScrimSrcModeEnabled) {
    Runnable runnable=new Runnable(){
      @Override public void run(){
        boolean asSrc=mBackdrop.getVisibility() != View.VISIBLE;
        mScrimController.setDrawBehindAsSrc(asSrc);
        mStackScroller.setDrawBackgroundAsSrc(asSrc);
      }
    }
;
    mBackdrop.setOnVisibilityChangedRunnable(runnable);
    runnable.run();
  }
  mHeadsUpManager.addListener(mScrimController);
  mStackScroller.setScrimController(mScrimController);
  mStatusBarView.setScrimController(mScrimController);
  mDozeScrimController=new DozeScrimController(mScrimController,context);
  mKeyguardStatusBar=(KeyguardStatusBarView)mStatusBarWindow.findViewById(R.id.keyguard_header);
  mKeyguardStatusView=mStatusBarWindow.findViewById(R.id.keyguard_status_view);
  mKeyguardBottomArea=(KeyguardBottomAreaView)mStatusBarWindow.findViewById(R.id.keyguard_bottom_area);
  mKeyguardBottomArea.setActivityStarter(this);
  mKeyguardBottomArea.setAssistManager(mAssistManager);
  mKeyguardIndicationController=new KeyguardIndicationController(mContext,(KeyguardIndicationTextView)mStatusBarWindow.findViewById(R.id.keyguard_indication_text),mKeyguardBottomArea.getLockIcon());
  mKeyguardBottomArea.setKeyguardIndicationController(mKeyguardIndicationController);
  if (ENABLE_LOCKSCREEN_WALLPAPER) {
    mLockscreenWallpaper=new LockscreenWallpaper(mContext,this,mHandler);
  }
  setAreThereNotifications();
  createIconController();
  mHandlerThread=new HandlerThread(TAG,Process.THREAD_PRIORITY_BACKGROUND);
  mHandlerThread.start();
  mLocationController=new LocationControllerImpl(mContext,mHandlerThread.getLooper());
  mBatteryController=new BatteryController(mContext);
  mBatteryController.addStateChangedCallback(new BatteryStateChangeCallback(){
    @Override public void onPowerSaveChanged(    boolean isPowerSave){
      mHandler.post(mCheckBarModes);
      if (mDozeServiceHost != null) {
        mDozeServiceHost.firePowerSaveChanged(isPowerSave);
      }
    }
    @Override public void onBatteryLevelChanged(    int level,    boolean pluggedIn,    boolean charging){
    }
  }
);
  mNetworkController=new NetworkControllerImpl(mContext,mHandlerThread.getLooper());
  mHotspotController=new HotspotControllerImpl(mContext);
  mBluetoothController=new BluetoothControllerImpl(mContext,mHandlerThread.getLooper());
  mSecurityController=new SecurityControllerImpl(mContext);
  if (mContext.getResources().getBoolean(R.bool.config_showRotationLock)) {
    mRotationLockController=new RotationLockControllerImpl(mContext);
  }
  mUserInfoController=new UserInfoController(mContext);
  mVolumeComponent=getComponent(VolumeComponent.class);
  if (mVolumeComponent != null) {
    mZenModeController=mVolumeComponent.getZenController();
  }
  mCastController=new CastControllerImpl(mContext);
  initSignalCluster(mStatusBarView);
  initSignalCluster(mKeyguardStatusBar);
  mFlashlightController=new FlashlightController(mContext);
  mKeyguardBottomArea.setFlashlightController(mFlashlightController);
  mKeyguardBottomArea.setPhoneStatusBar(this);
  mKeyguardBottomArea.setUserSetupComplete(mUserSetup);
  mAccessibilityController=new AccessibilityController(mContext);
  mKeyguardBottomArea.setAccessibilityController(mAccessibilityController);
  mNextAlarmController=new NextAlarmController(mContext);
  mLightStatusBarController=new LightStatusBarController(mIconController,mBatteryController);
  mKeyguardMonitor=new KeyguardMonitor(mContext);
  if (UserManager.get(mContext).isUserSwitcherEnabled()) {
    mUserSwitcherController=new UserSwitcherController(mContext,mKeyguardMonitor,mHandler,this);
    createUserSwitcher();
  }
  DensityContainer container=(DensityContainer)mStatusBarWindow.findViewById(R.id.qs_density_container);
  if (container != null) {
    final QSTileHost qsh=SystemUIFactory.getInstance().createQSTileHost(mContext,this,mBluetoothController,mLocationController,mRotationLockController,mNetworkController,mZenModeController,mHotspotController,mCastController,mFlashlightController,mUserSwitcherController,mUserInfoController,mKeyguardMonitor,mSecurityController,mBatteryController,mIconController,mNextAlarmController);
    mBrightnessMirrorController=new BrightnessMirrorController(mStatusBarWindow);
    container.addInflateListener(new InflateListener(){
      @Override public void onInflated(      View v){
        QSContainer qsContainer=(QSContainer)v.findViewById(R.id.quick_settings_container);
        qsContainer.setHost(qsh);
        mQSPanel=qsContainer.getQsPanel();
        mQSPanel.setBrightnessMirror(mBrightnessMirrorController);
        mHeader=qsContainer.getHeader();
        initSignalCluster(mHeader);
        mHeader.setActivityStarter(PhoneStatusBar.this);
      }
    }
);
  }
  mKeyguardStatusBar.setUserInfoController(mUserInfoController);
  mKeyguardStatusBar.setUserSwitcherController(mUserSwitcherController);
  mUserInfoController.reloadUserInfo();
  ((BatteryMeterView)mStatusBarView.findViewById(R.id.battery)).setBatteryController(mBatteryController);
  mKeyguardStatusBar.setBatteryController(mBatteryController);
  PowerManager pm=(PowerManager)mContext.getSystemService(Context.POWER_SERVICE);
  mBroadcastReceiver.onReceive(mContext,new Intent(pm.isScreenOn() ? Intent.ACTION_SCREEN_ON : Intent.ACTION_SCREEN_OFF));
  mGestureWakeLock=pm.newWakeLock(PowerManager.SCREEN_BRIGHT_WAKE_LOCK,""String_Node_Str"");
  mVibrator=mContext.getSystemService(Vibrator.class);
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
  filter.addAction(Intent.ACTION_SCREEN_OFF);
  filter.addAction(Intent.ACTION_SCREEN_ON);
  context.registerReceiverAsUser(mBroadcastReceiver,UserHandle.ALL,filter,null,null);
  IntentFilter demoFilter=new IntentFilter();
  if (DEBUG_MEDIA_FAKE_ARTWORK) {
    demoFilter.addAction(ACTION_FAKE_ARTWORK);
  }
  demoFilter.addAction(ACTION_DEMO);
  context.registerReceiverAsUser(mDemoReceiver,UserHandle.ALL,demoFilter,android.Manifest.permission.DUMP,null);
  resetUserSetupObserver();
  ThreadedRenderer.overrideProperty(""String_Node_Str"",""String_Node_Str"");
  ThreadedRenderer.overrideProperty(""String_Node_Str"",String.valueOf(1.5f));
  return mStatusBarView;
}","protected PhoneStatusBarView makeStatusBarView(){
  final Context context=mContext;
  updateDisplaySize();
  updateResources();
  inflateStatusBarWindow(context);
  mStatusBarWindow.setService(this);
  mStatusBarWindow.setOnTouchListener(new View.OnTouchListener(){
    @Override public boolean onTouch(    View v,    MotionEvent event){
      checkUserAutohide(v,event);
      if (event.getAction() == MotionEvent.ACTION_DOWN) {
        if (mExpandedVisible) {
          animateCollapsePanels();
        }
      }
      return mStatusBarWindow.onTouchEvent(event);
    }
  }
);
  mNotificationPanel=(NotificationPanelView)mStatusBarWindow.findViewById(R.id.notification_panel);
  mNotificationPanel.setStatusBar(this);
  mNotificationPanel.setGroupManager(mGroupManager);
  mStatusBarView=(PhoneStatusBarView)mStatusBarWindow.findViewById(R.id.status_bar);
  mStatusBarView.setBar(this);
  mStatusBarView.setPanel(mNotificationPanel);
  if (!ActivityManager.isHighEndGfx()) {
    mStatusBarWindow.setBackground(null);
    mNotificationPanel.setBackground(new FastColorDrawable(context.getColor(R.color.notification_panel_solid_background)));
  }
  mHeadsUpManager=new HeadsUpManager(context,mStatusBarWindow,mGroupManager);
  mHeadsUpManager.setBar(this);
  mHeadsUpManager.addListener(this);
  mHeadsUpManager.addListener(mNotificationPanel);
  mHeadsUpManager.addListener(mGroupManager);
  mNotificationPanel.setHeadsUpManager(mHeadsUpManager);
  mNotificationData.setHeadsUpManager(mHeadsUpManager);
  mGroupManager.setHeadsUpManager(mHeadsUpManager);
  if (MULTIUSER_DEBUG) {
    mNotificationPanelDebugText=(TextView)mNotificationPanel.findViewById(R.id.header_debug_info);
    mNotificationPanelDebugText.setVisibility(View.VISIBLE);
  }
  try {
    boolean showNav=mWindowManagerService.hasNavigationBar();
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + showNav);
    if (showNav) {
      createNavigationBarView(context);
    }
  }
 catch (  RemoteException ex) {
  }
  mAssistManager=new AssistManager(this,context);
  mPixelFormat=PixelFormat.OPAQUE;
  mStackScroller=(NotificationStackScrollLayout)mStatusBarWindow.findViewById(R.id.notification_stack_scroller);
  mStackScroller.setLongPressListener(getNotificationLongClicker());
  mStackScroller.setPhoneStatusBar(this);
  mStackScroller.setGroupManager(mGroupManager);
  mStackScroller.setHeadsUpManager(mHeadsUpManager);
  mGroupManager.setOnGroupChangeListener(mStackScroller);
  mKeyguardIconOverflowContainer=(NotificationOverflowContainer)LayoutInflater.from(mContext).inflate(R.layout.status_bar_notification_keyguard_overflow,mStackScroller,false);
  mKeyguardIconOverflowContainer.setOnActivatedListener(this);
  mKeyguardIconOverflowContainer.setOnClickListener(mOverflowClickListener);
  mStackScroller.setOverflowContainer(mKeyguardIconOverflowContainer);
  inflateEmptyShadeView();
  inflateDismissView();
  mExpandedContents=mStackScroller;
  mBackdrop=(BackDropView)mStatusBarWindow.findViewById(R.id.backdrop);
  mBackdropFront=(ImageView)mBackdrop.findViewById(R.id.backdrop_front);
  mBackdropBack=(ImageView)mBackdrop.findViewById(R.id.backdrop_back);
  ScrimView scrimBehind=(ScrimView)mStatusBarWindow.findViewById(R.id.scrim_behind);
  ScrimView scrimInFront=(ScrimView)mStatusBarWindow.findViewById(R.id.scrim_in_front);
  View headsUpScrim=mStatusBarWindow.findViewById(R.id.heads_up_scrim);
  mScrimController=SystemUIFactory.getInstance().createScrimController(scrimBehind,scrimInFront,headsUpScrim);
  if (mScrimSrcModeEnabled) {
    Runnable runnable=new Runnable(){
      @Override public void run(){
        boolean asSrc=mBackdrop.getVisibility() != View.VISIBLE;
        mScrimController.setDrawBehindAsSrc(asSrc);
        mStackScroller.setDrawBackgroundAsSrc(asSrc);
      }
    }
;
    mBackdrop.setOnVisibilityChangedRunnable(runnable);
    runnable.run();
  }
  mHeadsUpManager.addListener(mScrimController);
  mStackScroller.setScrimController(mScrimController);
  mStatusBarView.setScrimController(mScrimController);
  mDozeScrimController=new DozeScrimController(mScrimController,context);
  mKeyguardStatusBar=(KeyguardStatusBarView)mStatusBarWindow.findViewById(R.id.keyguard_header);
  mKeyguardStatusView=mStatusBarWindow.findViewById(R.id.keyguard_status_view);
  mKeyguardBottomArea=(KeyguardBottomAreaView)mStatusBarWindow.findViewById(R.id.keyguard_bottom_area);
  mKeyguardBottomArea.setActivityStarter(this);
  mKeyguardBottomArea.setAssistManager(mAssistManager);
  mKeyguardIndicationController=new KeyguardIndicationController(mContext,(KeyguardIndicationTextView)mStatusBarWindow.findViewById(R.id.keyguard_indication_text),mKeyguardBottomArea.getLockIcon());
  mKeyguardBottomArea.setKeyguardIndicationController(mKeyguardIndicationController);
  if (ENABLE_LOCKSCREEN_WALLPAPER) {
    mLockscreenWallpaper=new LockscreenWallpaper(mContext,this,mHandler);
  }
  setAreThereNotifications();
  createIconController();
  mHandlerThread=new HandlerThread(TAG,Process.THREAD_PRIORITY_BACKGROUND);
  mHandlerThread.start();
  mLocationController=new LocationControllerImpl(mContext,mHandlerThread.getLooper());
  mBatteryController=new BatteryController(mContext);
  mBatteryController.addStateChangedCallback(new BatteryStateChangeCallback(){
    @Override public void onPowerSaveChanged(    boolean isPowerSave){
      mHandler.post(mCheckBarModes);
      if (mDozeServiceHost != null) {
        mDozeServiceHost.firePowerSaveChanged(isPowerSave);
      }
    }
    @Override public void onBatteryLevelChanged(    int level,    boolean pluggedIn,    boolean charging){
    }
  }
);
  mNetworkController=new NetworkControllerImpl(mContext,mHandlerThread.getLooper());
  mHotspotController=new HotspotControllerImpl(mContext);
  mBluetoothController=new BluetoothControllerImpl(mContext,mHandlerThread.getLooper());
  mSecurityController=new SecurityControllerImpl(mContext);
  if (mContext.getResources().getBoolean(R.bool.config_showRotationLock)) {
    mRotationLockController=new RotationLockControllerImpl(mContext);
  }
  mUserInfoController=new UserInfoController(mContext);
  mVolumeComponent=getComponent(VolumeComponent.class);
  if (mVolumeComponent != null) {
    mZenModeController=mVolumeComponent.getZenController();
  }
  mCastController=new CastControllerImpl(mContext);
  initSignalCluster(mStatusBarView);
  initSignalCluster(mKeyguardStatusBar);
  mFlashlightController=new FlashlightController(mContext);
  mKeyguardBottomArea.setFlashlightController(mFlashlightController);
  mKeyguardBottomArea.setPhoneStatusBar(this);
  mKeyguardBottomArea.setUserSetupComplete(mUserSetup);
  mAccessibilityController=new AccessibilityController(mContext);
  mKeyguardBottomArea.setAccessibilityController(mAccessibilityController);
  mNextAlarmController=new NextAlarmController(mContext);
  mLightStatusBarController=new LightStatusBarController(mIconController,mBatteryController);
  mKeyguardMonitor=new KeyguardMonitor(mContext);
  if (UserManager.get(mContext).isUserSwitcherEnabled()) {
    mUserSwitcherController=new UserSwitcherController(mContext,mKeyguardMonitor,mHandler,this);
    createUserSwitcher();
  }
  DensityContainer container=(DensityContainer)mStatusBarWindow.findViewById(R.id.qs_density_container);
  if (container != null) {
    final QSTileHost qsh=SystemUIFactory.getInstance().createQSTileHost(mContext,this,mBluetoothController,mLocationController,mRotationLockController,mNetworkController,mZenModeController,mHotspotController,mCastController,mFlashlightController,mUserSwitcherController,mUserInfoController,mKeyguardMonitor,mSecurityController,mBatteryController,mIconController,mNextAlarmController);
    mBrightnessMirrorController=new BrightnessMirrorController(mStatusBarWindow);
    container.addInflateListener(new InflateListener(){
      @Override public void onInflated(      View v){
        QSContainer qsContainer=(QSContainer)v.findViewById(R.id.quick_settings_container);
        qsContainer.setHost(qsh);
        mQSPanel=qsContainer.getQsPanel();
        mQSPanel.setBrightnessMirror(mBrightnessMirrorController);
        mHeader=qsContainer.getHeader();
        initSignalCluster(mHeader);
        mHeader.setActivityStarter(PhoneStatusBar.this);
      }
    }
);
  }
  mKeyguardStatusBar.setUserInfoController(mUserInfoController);
  mKeyguardStatusBar.setUserSwitcherController(mUserSwitcherController);
  mUserInfoController.reloadUserInfo();
  ((BatteryMeterView)mStatusBarView.findViewById(R.id.battery)).setBatteryController(mBatteryController);
  mKeyguardStatusBar.setBatteryController(mBatteryController);
  PowerManager pm=(PowerManager)mContext.getSystemService(Context.POWER_SERVICE);
  mBroadcastReceiver.onReceive(mContext,new Intent(pm.isScreenOn() ? Intent.ACTION_SCREEN_ON : Intent.ACTION_SCREEN_OFF));
  mGestureWakeLock=pm.newWakeLock(PowerManager.SCREEN_BRIGHT_WAKE_LOCK,""String_Node_Str"");
  mVibrator=mContext.getSystemService(Vibrator.class);
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
  filter.addAction(Intent.ACTION_SCREEN_OFF);
  filter.addAction(Intent.ACTION_SCREEN_ON);
  context.registerReceiverAsUser(mBroadcastReceiver,UserHandle.ALL,filter,null,null);
  IntentFilter demoFilter=new IntentFilter();
  if (DEBUG_MEDIA_FAKE_ARTWORK) {
    demoFilter.addAction(ACTION_FAKE_ARTWORK);
  }
  demoFilter.addAction(ACTION_DEMO);
  context.registerReceiverAsUser(mDemoReceiver,UserHandle.ALL,demoFilter,android.Manifest.permission.DUMP,null);
  resetUserSetupObserver();
  ThreadedRenderer.overrideProperty(""String_Node_Str"",""String_Node_Str"");
  ThreadedRenderer.overrideProperty(""String_Node_Str"",String.valueOf(1.5f));
  return mStatusBarView;
}",0.997313494523662
192192,"/** 
 * Called when updating or posting a notification to the heads up.
 */
public void updateNotification(NotificationData.Entry headsUp,boolean alert){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"");
  headsUp.row.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED);
  if (alert) {
    HeadsUpEntry headsUpEntry=mHeadsUpEntries.get(headsUp.key);
    headsUpEntry.updateEntry();
    setEntryPinned(headsUpEntry,shouldHeadsUpBecomePinned(headsUp));
  }
}","/** 
 * Called when updating or posting a notification to the heads up.
 */
public void updateNotification(NotificationData.Entry headsUp,boolean alert){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"");
  headsUp.row.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED);
  if (alert) {
    HeadsUpEntry headsUpEntry=mHeadsUpEntries.get(headsUp.key);
    if (headsUpEntry == null) {
      return;
    }
    headsUpEntry.updateEntry();
    setEntryPinned(headsUpEntry,shouldHeadsUpBecomePinned(headsUp));
  }
}",0.8951612903225806
192193,"/** 
 * Gets the GNSS receiver internal hardware clock value in nanoseconds. <p>This value is expected to be monotonically increasing while the hardware clock remains powered on. For the case of a hardware clock that is not continuously on, see the  {@link #getHardwareClockDiscontinuityCount} field. The GPS time can be derived by adding{@link #getFullBiasNanos()} and {@link #getBiasNanos()} (when they are available) to thisvalue. Sub-nanosecond accuracy can be provided by means of  {@link #getBiasNanos()}. <p>The error estimate for this value (if applicable) is   {@link #getTimeUncertaintyNanos()}.
 */
public long getTimeNanos(){
  return mTimeNanos;
}","/** 
 * Gets the GNSS receiver internal hardware clock value in nanoseconds. <p>This value is expected to be monotonically increasing while the hardware clock remains powered on. For the case of a hardware clock that is not continuously on, see the  {@link #getHardwareClockDiscontinuityCount} field. The GPS time can be derived by subtractingthe sum of  {@link #getFullBiasNanos()} and {@link #getBiasNanos()} (when they are available)from this value. Sub-nanosecond accuracy can be provided by means of  {@link #getBiasNanos()}. <p>The error estimate for this value (if applicable) is   {@link #getTimeUncertaintyNanos()}.
 */
public long getTimeNanos(){
  return mTimeNanos;
}",0.9648991784914116
192194,"/** 
 * Gets the leap second associated with the clock's time. <p>The sign of the value is defined by the following equation: <pre> UtcTimeNanos = TimeNanos + (FullBiasNanos + BiasNanos) - LeapSecond * 1,000,000,000</pre> <p>The value is only available if   {@link #hasLeapSecond()} is {@code true}.
 */
public int getLeapSecond(){
  return mLeapSecond;
}","/** 
 * Gets the leap second associated with the clock's time. <p>The sign of the value is defined by the following equation: <pre> UtcTimeNanos = TimeNanos - (FullBiasNanos + BiasNanos) - LeapSecond * 1,000,000,000</pre> <p>The value is only available if   {@link #hasLeapSecond()} is {@code true}.
 */
public int getLeapSecond(){
  return mLeapSecond;
}",0.9971830985915492
192195,"/** 
 * Gets the difference between hardware clock (  {@link #getTimeNanos()}) inside GPS receiver and the true GPS time since 0000Z, January 6, 1980, in nanoseconds. <p>This value is available if the receiver has estimated GPS time. If the computed time is for a non-GPS constellation, the time offset of that constellation to GPS has to be applied to fill this value. The value is only available if   {@link #hasFullBiasNanos()} is{@code true}. <p>The error estimate for the sum of this field and   {@link #getBiasNanos} is{@link #getBiasUncertaintyNanos()}. <p>The sign of the value is defined by the following equation: <pre> local estimate of GPS time = TimeNanos + (FullBiasNanos + BiasNanos)</pre>
 */
public long getFullBiasNanos(){
  return mFullBiasNanos;
}","/** 
 * Gets the difference between hardware clock (  {@link #getTimeNanos()}) inside GPS receiver and the true GPS time since 0000Z, January 6, 1980, in nanoseconds. <p>This value is available if the receiver has estimated GPS time. If the computed time is for a non-GPS constellation, the time offset of that constellation to GPS has to be applied to fill this value. The value is only available if   {@link #hasFullBiasNanos()} is{@code true}. <p>The error estimate for the sum of this field and   {@link #getBiasNanos} is{@link #getBiasUncertaintyNanos()}. <p>The sign of the value is defined by the following equation: <pre> local estimate of GPS time = TimeNanos - (FullBiasNanos + BiasNanos)</pre>
 */
public long getFullBiasNanos(){
  return mFullBiasNanos;
}",0.998696219035202
192196,"/** 
 * Gets the GNSS receiver internal hardware clock value in nanoseconds. <p>This value is expected to be monotonically increasing while the hardware clock remains powered on. For the case of a hardware clock that is not continuously on, see the  {@link #getHardwareClockDiscontinuityCount} field. The GPS time can be derived by adding{@link #getFullBiasNanos()} and {@link #getBiasNanos()} (when they are available) to thisvalue. Sub-nanosecond accuracy can be provided by means of  {@link #getBiasNanos()}. <p>The error estimate for this value (if applicable) is   {@link #getTimeUncertaintyNanos()}.
 */
public long getTimeNanos(){
  return mTimeNanos;
}","/** 
 * Gets the GNSS receiver internal hardware clock value in nanoseconds. <p>This value is expected to be monotonically increasing while the hardware clock remains powered on. For the case of a hardware clock that is not continuously on, see the  {@link #getHardwareClockDiscontinuityCount} field. The GPS time can be derived by subtractingthe sum of  {@link #getFullBiasNanos()} and {@link #getBiasNanos()} (when they are available)from this value. Sub-nanosecond accuracy can be provided by means of  {@link #getBiasNanos()}. <p>The error estimate for this value (if applicable) is   {@link #getTimeUncertaintyNanos()}.
 */
public long getTimeNanos(){
  return mTimeNanos;
}",0.9648991784914116
192197,"/** 
 * Gets the leap second associated with the clock's time. <p>The sign of the value is defined by the following equation: <pre> UtcTimeNanos = TimeNanos + (FullBiasNanos + BiasNanos) - LeapSecond * 1,000,000,000</pre> <p>The value is only available if   {@link #hasLeapSecond()} is {@code true}.
 */
public int getLeapSecond(){
  return mLeapSecond;
}","/** 
 * Gets the leap second associated with the clock's time. <p>The sign of the value is defined by the following equation: <pre> UtcTimeNanos = TimeNanos - (FullBiasNanos + BiasNanos) - LeapSecond * 1,000,000,000</pre> <p>The value is only available if   {@link #hasLeapSecond()} is {@code true}.
 */
public int getLeapSecond(){
  return mLeapSecond;
}",0.9971830985915492
192198,"/** 
 * Gets the difference between hardware clock (  {@link #getTimeNanos()}) inside GPS receiver and the true GPS time since 0000Z, January 6, 1980, in nanoseconds. <p>This value is available if the receiver has estimated GPS time. If the computed time is for a non-GPS constellation, the time offset of that constellation to GPS has to be applied to fill this value. The value is only available if   {@link #hasFullBiasNanos()} is{@code true}. <p>The error estimate for the sum of this field and   {@link #getBiasNanos} is{@link #getBiasUncertaintyNanos()}. <p>The sign of the value is defined by the following equation: <pre> local estimate of GPS time = TimeNanos + (FullBiasNanos + BiasNanos)</pre>
 */
public long getFullBiasNanos(){
  return mFullBiasNanos;
}","/** 
 * Gets the difference between hardware clock (  {@link #getTimeNanos()}) inside GPS receiver and the true GPS time since 0000Z, January 6, 1980, in nanoseconds. <p>This value is available if the receiver has estimated GPS time. If the computed time is for a non-GPS constellation, the time offset of that constellation to GPS has to be applied to fill this value. The value is only available if   {@link #hasFullBiasNanos()} is{@code true}. <p>The error estimate for the sum of this field and   {@link #getBiasNanos} is{@link #getBiasUncertaintyNanos()}. <p>The sign of the value is defined by the following equation: <pre> local estimate of GPS time = TimeNanos - (FullBiasNanos + BiasNanos)</pre>
 */
public long getFullBiasNanos(){
  return mFullBiasNanos;
}",0.998696219035202
192199,"private void updateSoftKeyboardShowModeLocked(UserState userState){
  final int userId=userState.mUserId;
  if ((userId == mCurrentUserId) && (userState.mSoftKeyboardShowMode != 0)) {
    boolean serviceChangingSoftKeyboardModeIsEnabled=userState.mEnabledServices.contains(userState.mServiceChangingSoftKeyboardMode);
    if (!serviceChangingSoftKeyboardModeIsEnabled) {
      final long identity=Binder.clearCallingIdentity();
      try {
        Settings.Secure.putIntForUser(mContext.getContentResolver(),Settings.Secure.ACCESSIBILITY_SOFT_KEYBOARD_MODE,0,userState.mUserId);
      }
  finally {
        Binder.restoreCallingIdentity(identity);
      }
      userState.mSoftKeyboardShowMode=0;
      userState.mServiceChangingSoftKeyboardMode=null;
    }
    notifySoftKeyboardShowModeChangedLocked(userState.mSoftKeyboardShowMode);
  }
}","private void updateSoftKeyboardShowModeLocked(UserState userState){
  final int userId=userState.mUserId;
  if ((userId == mCurrentUserId) && (userState.mSoftKeyboardShowMode != 0)) {
    boolean serviceChangingSoftKeyboardModeIsEnabled=userState.mEnabledServices.contains(userState.mServiceChangingSoftKeyboardMode);
    if (!serviceChangingSoftKeyboardModeIsEnabled) {
      final long identity=Binder.clearCallingIdentity();
      try {
        Settings.Secure.putIntForUser(mContext.getContentResolver(),Settings.Secure.ACCESSIBILITY_SOFT_KEYBOARD_MODE,0,userState.mUserId);
      }
  finally {
        Binder.restoreCallingIdentity(identity);
      }
      userState.mSoftKeyboardShowMode=0;
      userState.mServiceChangingSoftKeyboardMode=null;
      notifySoftKeyboardShowModeChangedLocked(userState.mSoftKeyboardShowMode);
    }
  }
}",0.9061757719714963
192200,"@Override public void onChange(boolean selfChange,Uri uri){
synchronized (mLock) {
    UserState userState=getCurrentUserStateLocked();
    if (userState.isUiAutomationSuppressingOtherServices()) {
      return;
    }
    if (mTouchExplorationEnabledUri.equals(uri)) {
      if (readTouchExplorationEnabledSettingLocked(userState)) {
        onUserStateChangedLocked(userState);
      }
    }
 else     if (mDisplayMagnificationEnabledUri.equals(uri)) {
      if (readDisplayMagnificationEnabledSettingLocked(userState)) {
        onUserStateChangedLocked(userState);
      }
    }
 else     if (mAutoclickEnabledUri.equals(uri)) {
      if (readAutoclickEnabledSettingLocked(userState)) {
        onUserStateChangedLocked(userState);
      }
    }
 else     if (mEnabledAccessibilityServicesUri.equals(uri)) {
      if (readEnabledAccessibilityServicesLocked(userState)) {
        onUserStateChangedLocked(userState);
      }
    }
 else     if (mTouchExplorationGrantedAccessibilityServicesUri.equals(uri)) {
      if (readTouchExplorationGrantedAccessibilityServicesLocked(userState)) {
        onUserStateChangedLocked(userState);
      }
    }
 else     if (mEnhancedWebAccessibilityUri.equals(uri)) {
      if (readEnhancedWebAccessibilityEnabledChangedLocked(userState)) {
        onUserStateChangedLocked(userState);
      }
    }
 else     if (mDisplayInversionEnabledUri.equals(uri) || mDisplayDaltonizerEnabledUri.equals(uri) || mDisplayDaltonizerUri.equals(uri)) {
      if (readDisplayColorAdjustmentSettingsLocked(userState)) {
        updateDisplayColorAdjustmentSettingsLocked(userState);
      }
    }
 else     if (mDisplayColorMatrixUri.equals(uri)) {
      updateDisplayColorAdjustmentSettingsLocked(userState);
    }
 else     if (mHighTextContrastUri.equals(uri)) {
      if (readHighTextContrastEnabledSettingLocked(userState)) {
        onUserStateChangedLocked(userState);
      }
    }
 else     if (mAccessibilitySoftKeyboardModeUri.equals(uri)) {
      if (readSoftKeyboardShowModeChangedLocked(userState)) {
        onUserStateChangedLocked(userState);
      }
    }
  }
}","@Override public void onChange(boolean selfChange,Uri uri){
synchronized (mLock) {
    UserState userState=getCurrentUserStateLocked();
    if (userState.isUiAutomationSuppressingOtherServices()) {
      return;
    }
    if (mTouchExplorationEnabledUri.equals(uri)) {
      if (readTouchExplorationEnabledSettingLocked(userState)) {
        onUserStateChangedLocked(userState);
      }
    }
 else     if (mDisplayMagnificationEnabledUri.equals(uri)) {
      if (readDisplayMagnificationEnabledSettingLocked(userState)) {
        onUserStateChangedLocked(userState);
      }
    }
 else     if (mAutoclickEnabledUri.equals(uri)) {
      if (readAutoclickEnabledSettingLocked(userState)) {
        onUserStateChangedLocked(userState);
      }
    }
 else     if (mEnabledAccessibilityServicesUri.equals(uri)) {
      if (readEnabledAccessibilityServicesLocked(userState)) {
        onUserStateChangedLocked(userState);
      }
    }
 else     if (mTouchExplorationGrantedAccessibilityServicesUri.equals(uri)) {
      if (readTouchExplorationGrantedAccessibilityServicesLocked(userState)) {
        onUserStateChangedLocked(userState);
      }
    }
 else     if (mEnhancedWebAccessibilityUri.equals(uri)) {
      if (readEnhancedWebAccessibilityEnabledChangedLocked(userState)) {
        onUserStateChangedLocked(userState);
      }
    }
 else     if (mDisplayInversionEnabledUri.equals(uri) || mDisplayDaltonizerEnabledUri.equals(uri) || mDisplayDaltonizerUri.equals(uri)) {
      if (readDisplayColorAdjustmentSettingsLocked(userState)) {
        updateDisplayColorAdjustmentSettingsLocked(userState);
      }
    }
 else     if (mDisplayColorMatrixUri.equals(uri)) {
      updateDisplayColorAdjustmentSettingsLocked(userState);
    }
 else     if (mHighTextContrastUri.equals(uri)) {
      if (readHighTextContrastEnabledSettingLocked(userState)) {
        onUserStateChangedLocked(userState);
      }
    }
 else     if (mAccessibilitySoftKeyboardModeUri.equals(uri)) {
      if (readSoftKeyboardShowModeChangedLocked(userState)) {
        notifySoftKeyboardShowModeChangedLocked(userState.mSoftKeyboardShowMode);
        onUserStateChangedLocked(userState);
      }
    }
  }
}",0.9761904761904762
192201,"@Override public void stopJob(JobParameters jobParams){
  ensureHandler();
  Message m=Message.obtain(mHandler,MSG_STOP_JOB,jobParams);
  m.sendToTarget();
}","@Override public void stopJob(JobParameters jobParams) throws RemoteException {
  JobService service=mService.get();
  if (service != null) {
    service.ensureHandler();
    Message m=Message.obtain(service.mHandler,MSG_STOP_JOB,jobParams);
    m.sendToTarget();
  }
}",0.7230046948356808
192202,"@Override public void startJob(JobParameters jobParams){
  ensureHandler();
  Message m=Message.obtain(mHandler,MSG_EXECUTE_JOB,jobParams);
  m.sendToTarget();
}","@Override public void startJob(JobParameters jobParams) throws RemoteException {
  JobService service=mService.get();
  if (service != null) {
    service.ensureHandler();
    Message m=Message.obtain(service.mHandler,MSG_EXECUTE_JOB,jobParams);
    m.sendToTarget();
  }
}",0.728110599078341
192203,"/** 
 * @hide 
 */
public final IBinder onBind(Intent intent){
  return mBinder.asBinder();
}","/** 
 * @hide 
 */
public final IBinder onBind(Intent intent){
  if (mBinder == null) {
    mBinder=new JobInterface(this);
  }
  return mBinder.asBinder();
}",0.7410358565737052
192204,"void stepLightIdleStateLocked(String reason){
  if (mLightState == LIGHT_STATE_OVERRIDE) {
    return;
  }
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + mLightState);
  EventLogTags.writeDeviceIdleLightStep();
switch (mLightState) {
case LIGHT_STATE_INACTIVE:
    mCurIdleBudget=mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET;
  mNextLightIdleDelay=mConstants.LIGHT_IDLE_TIMEOUT;
mMaintenanceStartTime=0;
if (!isOpsInactiveLocked()) {
mLightState=LIGHT_STATE_PRE_IDLE;
EventLogTags.writeDeviceIdleLight(mLightState,reason);
scheduleLightAlarmLocked(mConstants.LIGHT_PRE_IDLE_TIMEOUT);
break;
}
case LIGHT_STATE_PRE_IDLE:
case LIGHT_STATE_IDLE_MAINTENANCE:
if (mMaintenanceStartTime != 0) {
long duration=SystemClock.elapsedRealtime() - mMaintenanceStartTime;
if (duration < mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET) {
mCurIdleBudget+=(mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET - duration);
}
 else {
mCurIdleBudget-=(duration - mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET);
}
}
mMaintenanceStartTime=0;
scheduleLightAlarmLocked(mNextLightIdleDelay);
mNextLightIdleDelay=Math.min(mConstants.LIGHT_MAX_IDLE_TIMEOUT,(long)(mNextLightIdleDelay * mConstants.LIGHT_IDLE_FACTOR));
if (mNextLightIdleDelay < mConstants.LIGHT_IDLE_TIMEOUT) {
mNextLightIdleDelay=mConstants.LIGHT_IDLE_TIMEOUT;
}
if (DEBUG) Slog.d(TAG,""String_Node_Str"");
mLightState=LIGHT_STATE_IDLE;
EventLogTags.writeDeviceIdleLight(mLightState,reason);
addEvent(EVENT_LIGHT_IDLE);
mHandler.sendEmptyMessage(MSG_REPORT_IDLE_ON_LIGHT);
break;
case LIGHT_STATE_IDLE:
mActiveIdleOpCount=1;
mActiveIdleWakeLock.acquire();
mMaintenanceStartTime=SystemClock.elapsedRealtime();
if (mCurIdleBudget < mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET) {
mCurIdleBudget=mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET;
}
 else if (mCurIdleBudget > mConstants.LIGHT_IDLE_MAINTENANCE_MAX_BUDGET) {
mCurIdleBudget=mConstants.LIGHT_IDLE_MAINTENANCE_MAX_BUDGET;
}
scheduleLightAlarmLocked(mCurIdleBudget);
if (DEBUG) Slog.d(TAG,""String_Node_Str"");
mLightState=LIGHT_STATE_IDLE_MAINTENANCE;
EventLogTags.writeDeviceIdleLight(mLightState,reason);
addEvent(EVENT_LIGHT_MAINTENANCE);
mHandler.sendEmptyMessage(MSG_REPORT_IDLE_OFF);
break;
}
}","void stepLightIdleStateLocked(String reason){
  if (mLightState == LIGHT_STATE_OVERRIDE) {
    return;
  }
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + mLightState);
  EventLogTags.writeDeviceIdleLightStep();
switch (mLightState) {
case LIGHT_STATE_INACTIVE:
    mCurIdleBudget=mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET;
  mNextLightIdleDelay=mConstants.LIGHT_IDLE_TIMEOUT;
mMaintenanceStartTime=0;
if (!isOpsInactiveLocked()) {
mLightState=LIGHT_STATE_PRE_IDLE;
EventLogTags.writeDeviceIdleLight(mLightState,reason);
scheduleLightAlarmLocked(mConstants.LIGHT_PRE_IDLE_TIMEOUT);
break;
}
case LIGHT_STATE_PRE_IDLE:
case LIGHT_STATE_IDLE_MAINTENANCE:
if (mMaintenanceStartTime != 0) {
long duration=SystemClock.elapsedRealtime() - mMaintenanceStartTime;
if (duration < mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET) {
mCurIdleBudget+=(mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET - duration);
}
 else {
mCurIdleBudget-=(duration - mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET);
}
}
mMaintenanceStartTime=0;
scheduleLightAlarmLocked(mNextLightIdleDelay);
mNextLightIdleDelay=Math.min(mConstants.LIGHT_MAX_IDLE_TIMEOUT,(long)(mNextLightIdleDelay * mConstants.LIGHT_IDLE_FACTOR));
if (mNextLightIdleDelay < mConstants.LIGHT_IDLE_TIMEOUT) {
mNextLightIdleDelay=mConstants.LIGHT_IDLE_TIMEOUT;
}
if (DEBUG) Slog.d(TAG,""String_Node_Str"");
mLightState=LIGHT_STATE_IDLE;
EventLogTags.writeDeviceIdleLight(mLightState,reason);
addEvent(EVENT_LIGHT_IDLE);
mHandler.sendEmptyMessage(MSG_REPORT_IDLE_ON_LIGHT);
break;
case LIGHT_STATE_IDLE:
case LIGHT_STATE_WAITING_FOR_NETWORK:
if (mNetworkConnected || mLightState == LIGHT_STATE_WAITING_FOR_NETWORK) {
mActiveIdleOpCount=1;
mActiveIdleWakeLock.acquire();
mMaintenanceStartTime=SystemClock.elapsedRealtime();
if (mCurIdleBudget < mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET) {
mCurIdleBudget=mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET;
}
 else if (mCurIdleBudget > mConstants.LIGHT_IDLE_MAINTENANCE_MAX_BUDGET) {
mCurIdleBudget=mConstants.LIGHT_IDLE_MAINTENANCE_MAX_BUDGET;
}
scheduleLightAlarmLocked(mCurIdleBudget);
if (DEBUG) Slog.d(TAG,""String_Node_Str"");
mLightState=LIGHT_STATE_IDLE_MAINTENANCE;
EventLogTags.writeDeviceIdleLight(mLightState,reason);
addEvent(EVENT_LIGHT_MAINTENANCE);
mHandler.sendEmptyMessage(MSG_REPORT_IDLE_OFF);
}
 else {
scheduleLightAlarmLocked(mNextLightIdleDelay);
if (DEBUG) Slog.d(TAG,""String_Node_Str"");
mLightState=LIGHT_STATE_WAITING_FOR_NETWORK;
EventLogTags.writeDeviceIdleLight(mLightState,reason);
}
break;
}
}",0.9328198545143346
192205,"static void dumpHelp(PrintWriter pw){
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
}","static void dumpHelp(PrintWriter pw){
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
}",0.8944337811900192
192206,"@Override public void onStart(){
  final PackageManager pm=getContext().getPackageManager();
synchronized (this) {
    mLightEnabled=mDeepEnabled=getContext().getResources().getBoolean(com.android.internal.R.bool.config_enableAutoPowerModes);
    SystemConfig sysConfig=SystemConfig.getInstance();
    ArraySet<String> allowPowerExceptIdle=sysConfig.getAllowInPowerSaveExceptIdle();
    for (int i=0; i < allowPowerExceptIdle.size(); i++) {
      String pkg=allowPowerExceptIdle.valueAt(i);
      try {
        ApplicationInfo ai=pm.getApplicationInfo(pkg,PackageManager.MATCH_SYSTEM_ONLY);
        int appid=UserHandle.getAppId(ai.uid);
        mPowerSaveWhitelistAppsExceptIdle.put(ai.packageName,appid);
        mPowerSaveWhitelistSystemAppIdsExceptIdle.put(appid,true);
      }
 catch (      PackageManager.NameNotFoundException e) {
      }
    }
    ArraySet<String> allowPower=sysConfig.getAllowInPowerSave();
    for (int i=0; i < allowPower.size(); i++) {
      String pkg=allowPower.valueAt(i);
      try {
        ApplicationInfo ai=pm.getApplicationInfo(pkg,PackageManager.MATCH_SYSTEM_ONLY);
        int appid=UserHandle.getAppId(ai.uid);
        mPowerSaveWhitelistAppsExceptIdle.put(ai.packageName,appid);
        mPowerSaveWhitelistSystemAppIdsExceptIdle.put(appid,true);
        mPowerSaveWhitelistApps.put(ai.packageName,appid);
        mPowerSaveWhitelistSystemAppIds.put(appid,true);
      }
 catch (      PackageManager.NameNotFoundException e) {
      }
    }
    mConstants=new Constants(mHandler,getContext().getContentResolver());
    readConfigFileLocked();
    updateWhitelistAppIdsLocked();
    mScreenOn=true;
    mCharging=true;
    mState=STATE_ACTIVE;
    mLightState=LIGHT_STATE_ACTIVE;
    mInactiveTimeout=mConstants.INACTIVE_TIMEOUT;
  }
  mBinderService=new BinderService();
  publishBinderService(Context.DEVICE_IDLE_CONTROLLER,mBinderService);
  publishLocalService(LocalService.class,new LocalService());
}","@Override public void onStart(){
  final PackageManager pm=getContext().getPackageManager();
synchronized (this) {
    mLightEnabled=mDeepEnabled=getContext().getResources().getBoolean(com.android.internal.R.bool.config_enableAutoPowerModes);
    SystemConfig sysConfig=SystemConfig.getInstance();
    ArraySet<String> allowPowerExceptIdle=sysConfig.getAllowInPowerSaveExceptIdle();
    for (int i=0; i < allowPowerExceptIdle.size(); i++) {
      String pkg=allowPowerExceptIdle.valueAt(i);
      try {
        ApplicationInfo ai=pm.getApplicationInfo(pkg,PackageManager.MATCH_SYSTEM_ONLY);
        int appid=UserHandle.getAppId(ai.uid);
        mPowerSaveWhitelistAppsExceptIdle.put(ai.packageName,appid);
        mPowerSaveWhitelistSystemAppIdsExceptIdle.put(appid,true);
      }
 catch (      PackageManager.NameNotFoundException e) {
      }
    }
    ArraySet<String> allowPower=sysConfig.getAllowInPowerSave();
    for (int i=0; i < allowPower.size(); i++) {
      String pkg=allowPower.valueAt(i);
      try {
        ApplicationInfo ai=pm.getApplicationInfo(pkg,PackageManager.MATCH_SYSTEM_ONLY);
        int appid=UserHandle.getAppId(ai.uid);
        mPowerSaveWhitelistAppsExceptIdle.put(ai.packageName,appid);
        mPowerSaveWhitelistSystemAppIdsExceptIdle.put(appid,true);
        mPowerSaveWhitelistApps.put(ai.packageName,appid);
        mPowerSaveWhitelistSystemAppIds.put(appid,true);
      }
 catch (      PackageManager.NameNotFoundException e) {
      }
    }
    mConstants=new Constants(mHandler,getContext().getContentResolver());
    readConfigFileLocked();
    updateWhitelistAppIdsLocked();
    mNetworkConnected=true;
    mScreenOn=true;
    mCharging=true;
    mState=STATE_ACTIVE;
    mLightState=LIGHT_STATE_ACTIVE;
    mInactiveTimeout=mConstants.INACTIVE_TIMEOUT;
  }
  mBinderService=new BinderService();
  publishBinderService(Context.DEVICE_IDLE_CONTROLLER,mBinderService);
  publishLocalService(LocalService.class,new LocalService());
}",0.9928571428571428
192207,"private static String lightStateToString(int state){
switch (state) {
case LIGHT_STATE_ACTIVE:
    return ""String_Node_Str"";
case LIGHT_STATE_INACTIVE:
  return ""String_Node_Str"";
case LIGHT_STATE_PRE_IDLE:
return ""String_Node_Str"";
case LIGHT_STATE_IDLE:
return ""String_Node_Str"";
case LIGHT_STATE_IDLE_MAINTENANCE:
return ""String_Node_Str"";
case LIGHT_STATE_OVERRIDE:
return ""String_Node_Str"";
default :
return Integer.toString(state);
}
}","private static String lightStateToString(int state){
switch (state) {
case LIGHT_STATE_ACTIVE:
    return ""String_Node_Str"";
case LIGHT_STATE_INACTIVE:
  return ""String_Node_Str"";
case LIGHT_STATE_PRE_IDLE:
return ""String_Node_Str"";
case LIGHT_STATE_IDLE:
return ""String_Node_Str"";
case LIGHT_STATE_WAITING_FOR_NETWORK:
return ""String_Node_Str"";
case LIGHT_STATE_IDLE_MAINTENANCE:
return ""String_Node_Str"";
case LIGHT_STATE_OVERRIDE:
return ""String_Node_Str"";
default :
return Integer.toString(state);
}
}",0.9323467230443976
192208,"void scheduleLightAlarmLocked(long delay){
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + delay + ""String_Node_Str"");
  if (mMotionSensor == null) {
    return;
  }
  mNextLightAlarmTime=SystemClock.elapsedRealtime() + delay;
  mAlarmManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,mNextLightAlarmTime,""String_Node_Str"",mLightAlarmListener,mHandler);
}","void scheduleLightAlarmLocked(long delay){
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + delay + ""String_Node_Str"");
  mNextLightAlarmTime=SystemClock.elapsedRealtime() + delay;
  mAlarmManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,mNextLightAlarmTime,""String_Node_Str"",mLightAlarmListener,mHandler);
}",0.928462709284627
192209,"int onShellCommand(Shell shell,String cmd){
  PrintWriter pw=shell.getOutPrintWriter();
  if (""String_Node_Str"".equals(cmd)) {
    getContext().enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER,null);
synchronized (this) {
      long token=Binder.clearCallingIdentity();
      String arg=shell.getNextArg();
      try {
        if (arg == null || ""String_Node_Str"".equals(arg)) {
          exitForceIdleLocked();
          stepIdleStateLocked(""String_Node_Str"");
          pw.print(""String_Node_Str"");
          pw.println(stateToString(mState));
        }
 else         if (""String_Node_Str"".equals(arg)) {
          exitForceIdleLocked();
          stepLightIdleStateLocked(""String_Node_Str"");
          pw.print(""String_Node_Str"");
          pw.println(lightStateToString(mLightState));
        }
 else {
          pw.println(""String_Node_Str"" + arg);
        }
      }
  finally {
        Binder.restoreCallingIdentity(token);
      }
    }
  }
 else   if (""String_Node_Str"".equals(cmd)) {
    getContext().enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER,null);
synchronized (this) {
      long token=Binder.clearCallingIdentity();
      try {
        if (!mDeepEnabled) {
          pw.println(""String_Node_Str"");
          return -1;
        }
        mForceIdle=true;
        becomeInactiveIfAppropriateLocked();
        int curState=mState;
        while (curState != STATE_IDLE) {
          stepIdleStateLocked(""String_Node_Str"");
          if (curState == mState) {
            pw.print(""String_Node_Str"");
            pw.println(stateToString(mState));
            exitForceIdleLocked();
            return -1;
          }
          curState=mState;
        }
        pw.println(""String_Node_Str"");
      }
  finally {
        Binder.restoreCallingIdentity(token);
      }
    }
  }
 else   if (""String_Node_Str"".equals(cmd)) {
    getContext().enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER,null);
synchronized (this) {
      long token=Binder.clearCallingIdentity();
      String arg=shell.getNextArg();
      try {
        boolean becomeActive=false;
        boolean valid=false;
        if (arg == null || ""String_Node_Str"".equals(arg) || ""String_Node_Str"".equals(arg)) {
          valid=true;
          if (mDeepEnabled) {
            mDeepEnabled=false;
            becomeActive=true;
            pw.println(""String_Node_Str"");
          }
        }
        if (arg == null || ""String_Node_Str"".equals(arg) || ""String_Node_Str"".equals(arg)) {
          valid=true;
          if (mLightEnabled) {
            mLightEnabled=false;
            becomeActive=true;
            pw.println(""String_Node_Str"");
          }
        }
        if (becomeActive) {
          becomeActiveLocked((arg == null ? ""String_Node_Str"" : arg) + ""String_Node_Str"",Process.myUid());
        }
        if (!valid) {
          pw.println(""String_Node_Str"" + arg);
        }
      }
  finally {
        Binder.restoreCallingIdentity(token);
      }
    }
  }
 else   if (""String_Node_Str"".equals(cmd)) {
    getContext().enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER,null);
synchronized (this) {
      long token=Binder.clearCallingIdentity();
      String arg=shell.getNextArg();
      try {
        boolean becomeInactive=false;
        boolean valid=false;
        if (arg == null || ""String_Node_Str"".equals(arg) || ""String_Node_Str"".equals(arg)) {
          valid=true;
          if (!mDeepEnabled) {
            mDeepEnabled=true;
            becomeInactive=true;
            pw.println(""String_Node_Str"");
          }
        }
        if (arg == null || ""String_Node_Str"".equals(arg) || ""String_Node_Str"".equals(arg)) {
          valid=true;
          if (!mLightEnabled) {
            mLightEnabled=true;
            becomeInactive=true;
            pw.println(""String_Node_Str"");
          }
        }
        if (becomeInactive) {
          becomeInactiveIfAppropriateLocked();
        }
        if (!valid) {
          pw.println(""String_Node_Str"" + arg);
        }
      }
  finally {
        Binder.restoreCallingIdentity(token);
      }
    }
  }
 else   if (""String_Node_Str"".equals(cmd)) {
synchronized (this) {
      String arg=shell.getNextArg();
      if (arg == null || ""String_Node_Str"".equals(arg)) {
        pw.println(mDeepEnabled && mLightEnabled ? ""String_Node_Str"" : 0);
      }
 else       if (""String_Node_Str"".equals(arg)) {
        pw.println(mDeepEnabled ? ""String_Node_Str"" : 0);
      }
 else       if (""String_Node_Str"".equals(arg)) {
        pw.println(mLightEnabled ? ""String_Node_Str"" : 0);
      }
 else {
        pw.println(""String_Node_Str"" + arg);
      }
    }
  }
 else   if (""String_Node_Str"".equals(cmd)) {
    long token=Binder.clearCallingIdentity();
    try {
      String arg=shell.getNextArg();
      if (arg != null) {
        getContext().enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER,null);
        do {
          if (arg.length() < 1 || (arg.charAt(0) != '-' && arg.charAt(0) != '+' && arg.charAt(0) != '=')) {
            pw.println(""String_Node_Str"" + arg);
            return -1;
          }
          char op=arg.charAt(0);
          String pkg=arg.substring(1);
          if (op == '+') {
            if (addPowerSaveWhitelistAppInternal(pkg)) {
              pw.println(""String_Node_Str"" + pkg);
            }
 else {
              pw.println(""String_Node_Str"" + pkg);
            }
          }
 else           if (op == '-') {
            if (removePowerSaveWhitelistAppInternal(pkg)) {
              pw.println(""String_Node_Str"" + pkg);
            }
          }
 else {
            pw.println(getPowerSaveWhitelistAppInternal(pkg));
          }
        }
 while ((arg=shell.getNextArg()) != null);
      }
 else {
synchronized (this) {
          for (int j=0; j < mPowerSaveWhitelistAppsExceptIdle.size(); j++) {
            pw.print(""String_Node_Str"");
            pw.print(mPowerSaveWhitelistAppsExceptIdle.keyAt(j));
            pw.print(""String_Node_Str"");
            pw.println(mPowerSaveWhitelistAppsExceptIdle.valueAt(j));
          }
          for (int j=0; j < mPowerSaveWhitelistApps.size(); j++) {
            pw.print(""String_Node_Str"");
            pw.print(mPowerSaveWhitelistApps.keyAt(j));
            pw.print(""String_Node_Str"");
            pw.println(mPowerSaveWhitelistApps.valueAt(j));
          }
          for (int j=0; j < mPowerSaveWhitelistUserApps.size(); j++) {
            pw.print(""String_Node_Str"");
            pw.print(mPowerSaveWhitelistUserApps.keyAt(j));
            pw.print(""String_Node_Str"");
            pw.println(mPowerSaveWhitelistUserApps.valueAt(j));
          }
        }
      }
    }
  finally {
      Binder.restoreCallingIdentity(token);
    }
  }
 else   if (""String_Node_Str"".equals(cmd)) {
    String opt;
    while ((opt=shell.getNextOption()) != null) {
      if (""String_Node_Str"".equals(opt)) {
        opt=shell.getNextArg();
        if (opt == null) {
          pw.println(""String_Node_Str"");
          return -1;
        }
        shell.userId=Integer.parseInt(opt);
      }
    }
    String arg=shell.getNextArg();
    if (arg != null) {
      try {
        addPowerSaveTempWhitelistAppChecked(arg,10000L,shell.userId,""String_Node_Str"");
      }
 catch (      RemoteException re) {
        pw.println(""String_Node_Str"" + re);
      }
    }
 else {
      pw.println(""String_Node_Str"");
      return -1;
    }
  }
 else {
    return shell.handleDefaultCommands(cmd);
  }
  return 0;
}","int onShellCommand(Shell shell,String cmd){
  PrintWriter pw=shell.getOutPrintWriter();
  if (""String_Node_Str"".equals(cmd)) {
    getContext().enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER,null);
synchronized (this) {
      long token=Binder.clearCallingIdentity();
      String arg=shell.getNextArg();
      try {
        if (arg == null || ""String_Node_Str"".equals(arg)) {
          stepIdleStateLocked(""String_Node_Str"");
          pw.print(""String_Node_Str"");
          pw.println(stateToString(mState));
        }
 else         if (""String_Node_Str"".equals(arg)) {
          stepLightIdleStateLocked(""String_Node_Str"");
          pw.print(""String_Node_Str"");
          pw.println(lightStateToString(mLightState));
        }
 else {
          pw.println(""String_Node_Str"" + arg);
        }
      }
  finally {
        Binder.restoreCallingIdentity(token);
      }
    }
  }
 else   if (""String_Node_Str"".equals(cmd)) {
    getContext().enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER,null);
synchronized (this) {
      long token=Binder.clearCallingIdentity();
      String arg=shell.getNextArg();
      try {
        if (arg == null || ""String_Node_Str"".equals(arg)) {
          if (!mDeepEnabled) {
            pw.println(""String_Node_Str"");
            return -1;
          }
          mForceIdle=true;
          becomeInactiveIfAppropriateLocked();
          int curState=mState;
          while (curState != STATE_IDLE) {
            stepIdleStateLocked(""String_Node_Str"");
            if (curState == mState) {
              pw.print(""String_Node_Str"");
              pw.println(stateToString(mState));
              exitForceIdleLocked();
              return -1;
            }
            curState=mState;
          }
          pw.println(""String_Node_Str"");
        }
 else         if (""String_Node_Str"".equals(arg)) {
          mForceIdle=true;
          becomeInactiveIfAppropriateLocked();
          int curLightState=mLightState;
          while (curLightState != LIGHT_STATE_IDLE) {
            stepIdleStateLocked(""String_Node_Str"");
            if (curLightState == mLightState) {
              pw.print(""String_Node_Str"");
              pw.println(lightStateToString(mLightState));
              exitForceIdleLocked();
              return -1;
            }
            curLightState=mLightState;
          }
          pw.println(""String_Node_Str"");
        }
 else {
          pw.println(""String_Node_Str"" + arg);
        }
      }
  finally {
        Binder.restoreCallingIdentity(token);
      }
    }
  }
 else   if (""String_Node_Str"".equals(cmd)) {
    getContext().enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER,null);
synchronized (this) {
      long token=Binder.clearCallingIdentity();
      try {
        mForceIdle=true;
        becomeInactiveIfAppropriateLocked();
        pw.print(""String_Node_Str"");
        pw.print(lightStateToString(mLightState));
        pw.print(""String_Node_Str"");
        pw.println(stateToString(mState));
      }
  finally {
        Binder.restoreCallingIdentity(token);
      }
    }
  }
 else   if (""String_Node_Str"".equals(cmd)) {
    getContext().enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER,null);
synchronized (this) {
      long token=Binder.clearCallingIdentity();
      try {
        exitForceIdleLocked();
        pw.print(""String_Node_Str"");
        pw.print(lightStateToString(mLightState));
        pw.print(""String_Node_Str"");
        pw.println(stateToString(mState));
      }
  finally {
        Binder.restoreCallingIdentity(token);
      }
    }
  }
 else   if (""String_Node_Str"".equals(cmd)) {
    getContext().enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER,null);
synchronized (this) {
      String arg=shell.getNextArg();
      if (arg != null) {
        long token=Binder.clearCallingIdentity();
        try {
switch (arg) {
case ""String_Node_Str"":
            pw.println(lightStateToString(mLightState));
          break;
case ""String_Node_Str"":
        pw.println(stateToString(mState));
      break;
case ""String_Node_Str"":
    pw.println(mForceIdle);
  break;
case ""String_Node_Str"":
pw.println(mScreenOn);
break;
case ""String_Node_Str"":
pw.println(mCharging);
break;
case ""String_Node_Str"":
pw.println(mNetworkConnected);
break;
default :
pw.println(""String_Node_Str"" + arg);
break;
}
}
  finally {
Binder.restoreCallingIdentity(token);
}
}
 else {
pw.println(""String_Node_Str"");
}
}
}
 else if (""String_Node_Str"".equals(cmd)) {
getContext().enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER,null);
synchronized (this) {
long token=Binder.clearCallingIdentity();
String arg=shell.getNextArg();
try {
boolean becomeActive=false;
boolean valid=false;
if (arg == null || ""String_Node_Str"".equals(arg) || ""String_Node_Str"".equals(arg)) {
valid=true;
if (mDeepEnabled) {
mDeepEnabled=false;
becomeActive=true;
pw.println(""String_Node_Str"");
}
}
if (arg == null || ""String_Node_Str"".equals(arg) || ""String_Node_Str"".equals(arg)) {
valid=true;
if (mLightEnabled) {
mLightEnabled=false;
becomeActive=true;
pw.println(""String_Node_Str"");
}
}
if (becomeActive) {
becomeActiveLocked((arg == null ? ""String_Node_Str"" : arg) + ""String_Node_Str"",Process.myUid());
}
if (!valid) {
pw.println(""String_Node_Str"" + arg);
}
}
  finally {
Binder.restoreCallingIdentity(token);
}
}
}
 else if (""String_Node_Str"".equals(cmd)) {
getContext().enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER,null);
synchronized (this) {
long token=Binder.clearCallingIdentity();
String arg=shell.getNextArg();
try {
boolean becomeInactive=false;
boolean valid=false;
if (arg == null || ""String_Node_Str"".equals(arg) || ""String_Node_Str"".equals(arg)) {
valid=true;
if (!mDeepEnabled) {
mDeepEnabled=true;
becomeInactive=true;
pw.println(""String_Node_Str"");
}
}
if (arg == null || ""String_Node_Str"".equals(arg) || ""String_Node_Str"".equals(arg)) {
valid=true;
if (!mLightEnabled) {
mLightEnabled=true;
becomeInactive=true;
pw.println(""String_Node_Str"");
}
}
if (becomeInactive) {
becomeInactiveIfAppropriateLocked();
}
if (!valid) {
pw.println(""String_Node_Str"" + arg);
}
}
  finally {
Binder.restoreCallingIdentity(token);
}
}
}
 else if (""String_Node_Str"".equals(cmd)) {
synchronized (this) {
String arg=shell.getNextArg();
if (arg == null || ""String_Node_Str"".equals(arg)) {
pw.println(mDeepEnabled && mLightEnabled ? ""String_Node_Str"" : 0);
}
 else if (""String_Node_Str"".equals(arg)) {
pw.println(mDeepEnabled ? ""String_Node_Str"" : 0);
}
 else if (""String_Node_Str"".equals(arg)) {
pw.println(mLightEnabled ? ""String_Node_Str"" : 0);
}
 else {
pw.println(""String_Node_Str"" + arg);
}
}
}
 else if (""String_Node_Str"".equals(cmd)) {
long token=Binder.clearCallingIdentity();
try {
String arg=shell.getNextArg();
if (arg != null) {
getContext().enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER,null);
do {
if (arg.length() < 1 || (arg.charAt(0) != '-' && arg.charAt(0) != '+' && arg.charAt(0) != '=')) {
pw.println(""String_Node_Str"" + arg);
return -1;
}
char op=arg.charAt(0);
String pkg=arg.substring(1);
if (op == '+') {
if (addPowerSaveWhitelistAppInternal(pkg)) {
pw.println(""String_Node_Str"" + pkg);
}
 else {
pw.println(""String_Node_Str"" + pkg);
}
}
 else if (op == '-') {
if (removePowerSaveWhitelistAppInternal(pkg)) {
pw.println(""String_Node_Str"" + pkg);
}
}
 else {
pw.println(getPowerSaveWhitelistAppInternal(pkg));
}
}
 while ((arg=shell.getNextArg()) != null);
}
 else {
synchronized (this) {
for (int j=0; j < mPowerSaveWhitelistAppsExceptIdle.size(); j++) {
pw.print(""String_Node_Str"");
pw.print(mPowerSaveWhitelistAppsExceptIdle.keyAt(j));
pw.print(""String_Node_Str"");
pw.println(mPowerSaveWhitelistAppsExceptIdle.valueAt(j));
}
for (int j=0; j < mPowerSaveWhitelistApps.size(); j++) {
pw.print(""String_Node_Str"");
pw.print(mPowerSaveWhitelistApps.keyAt(j));
pw.print(""String_Node_Str"");
pw.println(mPowerSaveWhitelistApps.valueAt(j));
}
for (int j=0; j < mPowerSaveWhitelistUserApps.size(); j++) {
pw.print(""String_Node_Str"");
pw.print(mPowerSaveWhitelistUserApps.keyAt(j));
pw.print(""String_Node_Str"");
pw.println(mPowerSaveWhitelistUserApps.valueAt(j));
}
}
}
}
  finally {
Binder.restoreCallingIdentity(token);
}
}
 else if (""String_Node_Str"".equals(cmd)) {
String opt;
while ((opt=shell.getNextOption()) != null) {
if (""String_Node_Str"".equals(opt)) {
opt=shell.getNextArg();
if (opt == null) {
pw.println(""String_Node_Str"");
return -1;
}
shell.userId=Integer.parseInt(opt);
}
}
String arg=shell.getNextArg();
if (arg != null) {
try {
addPowerSaveTempWhitelistAppChecked(arg,10000L,shell.userId,""String_Node_Str"");
}
 catch (RemoteException re) {
pw.println(""String_Node_Str"" + re);
}
}
 else {
pw.println(""String_Node_Str"");
return -1;
}
}
 else {
return shell.handleDefaultCommands(cmd);
}
return 0;
}",0.5335367714372902
192210,"@Override public void onBootPhase(int phase){
  if (phase == PHASE_SYSTEM_SERVICES_READY) {
synchronized (this) {
      mAlarmManager=(AlarmManager)getContext().getSystemService(Context.ALARM_SERVICE);
      mBatteryStats=BatteryStatsService.getService();
      mLocalPowerManager=getLocalService(PowerManagerInternal.class);
      mPowerManager=getContext().getSystemService(PowerManager.class);
      mActiveIdleWakeLock=mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,""String_Node_Str"");
      mActiveIdleWakeLock.setReferenceCounted(false);
      mLocalAlarmManager=getLocalService(AlarmManagerService.LocalService.class);
      mNetworkPolicyManager=INetworkPolicyManager.Stub.asInterface(ServiceManager.getService(Context.NETWORK_POLICY_SERVICE));
      mDisplayManager=(DisplayManager)getContext().getSystemService(Context.DISPLAY_SERVICE);
      mSensorManager=(SensorManager)getContext().getSystemService(Context.SENSOR_SERVICE);
      int sigMotionSensorId=getContext().getResources().getInteger(com.android.internal.R.integer.config_autoPowerModeAnyMotionSensor);
      if (sigMotionSensorId > 0) {
        mMotionSensor=mSensorManager.getDefaultSensor(sigMotionSensorId,true);
      }
      if (mMotionSensor == null && getContext().getResources().getBoolean(com.android.internal.R.bool.config_autoPowerModePreferWristTilt)) {
        mMotionSensor=mSensorManager.getDefaultSensor(Sensor.TYPE_WRIST_TILT_GESTURE,true);
      }
      if (mMotionSensor == null) {
        mMotionSensor=mSensorManager.getDefaultSensor(Sensor.TYPE_SIGNIFICANT_MOTION,true);
      }
      if (getContext().getResources().getBoolean(com.android.internal.R.bool.config_autoPowerModePrefetchLocation)) {
        mLocationManager=(LocationManager)getContext().getSystemService(Context.LOCATION_SERVICE);
        mLocationRequest=new LocationRequest().setQuality(LocationRequest.ACCURACY_FINE).setInterval(0).setFastestInterval(0).setNumUpdates(1);
      }
      float angleThreshold=getContext().getResources().getInteger(com.android.internal.R.integer.config_autoPowerModeThresholdAngle) / 100f;
      mAnyMotionDetector=new AnyMotionDetector((PowerManager)getContext().getSystemService(Context.POWER_SERVICE),mHandler,mSensorManager,this,angleThreshold);
      mIdleIntent=new Intent(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED);
      mIdleIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
      mLightIdleIntent=new Intent(PowerManager.ACTION_LIGHT_DEVICE_IDLE_MODE_CHANGED);
      mLightIdleIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
      IntentFilter filter=new IntentFilter();
      filter.addAction(Intent.ACTION_BATTERY_CHANGED);
      getContext().registerReceiver(mReceiver,filter);
      filter=new IntentFilter();
      filter.addAction(Intent.ACTION_PACKAGE_REMOVED);
      filter.addDataScheme(""String_Node_Str"");
      getContext().registerReceiver(mReceiver,filter);
      mLocalPowerManager.setDeviceIdleWhitelist(mPowerSaveWhitelistAllAppIdArray);
      mLocalAlarmManager.setDeviceIdleUserWhitelist(mPowerSaveWhitelistUserAppIdArray);
      mDisplayManager.registerDisplayListener(mDisplayListener,null);
      updateDisplayLocked();
    }
  }
}","@Override public void onBootPhase(int phase){
  if (phase == PHASE_SYSTEM_SERVICES_READY) {
synchronized (this) {
      mAlarmManager=(AlarmManager)getContext().getSystemService(Context.ALARM_SERVICE);
      mBatteryStats=BatteryStatsService.getService();
      mLocalPowerManager=getLocalService(PowerManagerInternal.class);
      mPowerManager=getContext().getSystemService(PowerManager.class);
      mActiveIdleWakeLock=mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,""String_Node_Str"");
      mActiveIdleWakeLock.setReferenceCounted(false);
      mConnectivityService=(ConnectivityService)ServiceManager.getService(Context.CONNECTIVITY_SERVICE);
      mLocalAlarmManager=getLocalService(AlarmManagerService.LocalService.class);
      mNetworkPolicyManager=INetworkPolicyManager.Stub.asInterface(ServiceManager.getService(Context.NETWORK_POLICY_SERVICE));
      mDisplayManager=(DisplayManager)getContext().getSystemService(Context.DISPLAY_SERVICE);
      mSensorManager=(SensorManager)getContext().getSystemService(Context.SENSOR_SERVICE);
      int sigMotionSensorId=getContext().getResources().getInteger(com.android.internal.R.integer.config_autoPowerModeAnyMotionSensor);
      if (sigMotionSensorId > 0) {
        mMotionSensor=mSensorManager.getDefaultSensor(sigMotionSensorId,true);
      }
      if (mMotionSensor == null && getContext().getResources().getBoolean(com.android.internal.R.bool.config_autoPowerModePreferWristTilt)) {
        mMotionSensor=mSensorManager.getDefaultSensor(Sensor.TYPE_WRIST_TILT_GESTURE,true);
      }
      if (mMotionSensor == null) {
        mMotionSensor=mSensorManager.getDefaultSensor(Sensor.TYPE_SIGNIFICANT_MOTION,true);
      }
      if (getContext().getResources().getBoolean(com.android.internal.R.bool.config_autoPowerModePrefetchLocation)) {
        mLocationManager=(LocationManager)getContext().getSystemService(Context.LOCATION_SERVICE);
        mLocationRequest=new LocationRequest().setQuality(LocationRequest.ACCURACY_FINE).setInterval(0).setFastestInterval(0).setNumUpdates(1);
      }
      float angleThreshold=getContext().getResources().getInteger(com.android.internal.R.integer.config_autoPowerModeThresholdAngle) / 100f;
      mAnyMotionDetector=new AnyMotionDetector((PowerManager)getContext().getSystemService(Context.POWER_SERVICE),mHandler,mSensorManager,this,angleThreshold);
      mIdleIntent=new Intent(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED);
      mIdleIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
      mLightIdleIntent=new Intent(PowerManager.ACTION_LIGHT_DEVICE_IDLE_MODE_CHANGED);
      mLightIdleIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
      IntentFilter filter=new IntentFilter();
      filter.addAction(Intent.ACTION_BATTERY_CHANGED);
      getContext().registerReceiver(mReceiver,filter);
      filter=new IntentFilter();
      filter.addAction(Intent.ACTION_PACKAGE_REMOVED);
      filter.addDataScheme(""String_Node_Str"");
      filter=new IntentFilter();
      filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);
      getContext().registerReceiver(mReceiver,filter);
      mLocalPowerManager.setDeviceIdleWhitelist(mPowerSaveWhitelistAllAppIdArray);
      mLocalAlarmManager.setDeviceIdleUserWhitelist(mPowerSaveWhitelistUserAppIdArray);
      mDisplayManager.registerDisplayListener(mDisplayListener,null);
      updateConnectivityStateLocked(null);
      updateDisplayLocked();
    }
  }
}",0.9635123108869772
192211,"void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (getContext().checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  if (args != null) {
    int userId=UserHandle.USER_SYSTEM;
    for (int i=0; i < args.length; i++) {
      String arg=args[i];
      if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i < args.length) {
          arg=args[i];
          userId=Integer.parseInt(arg);
        }
      }
 else       if (""String_Node_Str"".equals(arg)) {
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        return;
      }
 else {
        Shell shell=new Shell();
        shell.userId=userId;
        String[] newArgs=new String[args.length - i];
        System.arraycopy(args,i,newArgs,0,args.length - i);
        shell.exec(mBinderService,null,fd,null,newArgs,new ResultReceiver(null));
        return;
      }
    }
  }
synchronized (this) {
    mConstants.dump(pw);
    if (mEventCmds[0] != EVENT_NULL) {
      pw.println(""String_Node_Str"");
      long now=SystemClock.elapsedRealtime();
      for (int i=EVENT_BUFFER_SIZE - 1; i >= 0; i--) {
        int cmd=mEventCmds[i];
        if (cmd == EVENT_NULL) {
          continue;
        }
        String label;
switch (mEventCmds[i]) {
case EVENT_NORMAL:
          label=""String_Node_Str"";
        break;
case EVENT_LIGHT_IDLE:
      label=""String_Node_Str"";
    break;
case EVENT_LIGHT_MAINTENANCE:
  label=""String_Node_Str"";
break;
case EVENT_DEEP_IDLE:
label=""String_Node_Str"";
break;
case EVENT_DEEP_MAINTENANCE:
label=""String_Node_Str"";
break;
default :
label=""String_Node_Str"";
break;
}
pw.print(""String_Node_Str"");
pw.print(label);
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mEventTimes[i],now,pw);
;
pw.println();
}
}
int size=mPowerSaveWhitelistAppsExceptIdle.size();
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.println(mPowerSaveWhitelistAppsExceptIdle.keyAt(i));
}
}
size=mPowerSaveWhitelistApps.size();
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.println(mPowerSaveWhitelistApps.keyAt(i));
}
}
size=mPowerSaveWhitelistUserApps.size();
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.println(mPowerSaveWhitelistUserApps.keyAt(i));
}
}
size=mPowerSaveWhitelistExceptIdleAppIds.size();
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.print(mPowerSaveWhitelistExceptIdleAppIds.keyAt(i));
pw.println();
}
}
size=mPowerSaveWhitelistUserAppIds.size();
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.print(mPowerSaveWhitelistUserAppIds.keyAt(i));
pw.println();
}
}
size=mPowerSaveWhitelistAllAppIds.size();
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.print(mPowerSaveWhitelistAllAppIds.keyAt(i));
pw.println();
}
}
size=mTempWhitelistAppIdEndTimes.size();
if (size > 0) {
pw.println(""String_Node_Str"");
final long timeNow=SystemClock.elapsedRealtime();
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.print(mTempWhitelistAppIdEndTimes.keyAt(i));
pw.print(""String_Node_Str"");
Pair<MutableLong,String> entry=mTempWhitelistAppIdEndTimes.valueAt(i);
TimeUtils.formatDuration(entry.first.value,timeNow,pw);
pw.print(""String_Node_Str"");
pw.println(entry.second);
}
}
size=mTempWhitelistAppIdArray != null ? mTempWhitelistAppIdArray.length : 0;
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.print(mTempWhitelistAppIdArray[i]);
pw.println();
}
}
pw.print(""String_Node_Str"");
pw.print(mLightEnabled);
pw.print(""String_Node_Str"");
pw.println(mDeepEnabled);
pw.print(""String_Node_Str"");
pw.println(mForceIdle);
pw.print(""String_Node_Str"");
pw.println(mMotionSensor);
pw.print(""String_Node_Str"");
pw.println(mCurDisplay);
pw.print(""String_Node_Str"");
pw.println(mScreenOn);
pw.print(""String_Node_Str"");
pw.println(mCharging);
pw.print(""String_Node_Str"");
pw.println(mMotionListener.active);
pw.print(""String_Node_Str"");
pw.println(mNotMoving);
pw.print(""String_Node_Str"");
pw.print(mLocating);
pw.print(""String_Node_Str"");
pw.print(mHasGps);
pw.print(""String_Node_Str"");
pw.print(mHasNetworkLocation);
pw.print(""String_Node_Str"");
pw.println(mLocated);
if (mLastGenericLocation != null) {
pw.print(""String_Node_Str"");
pw.println(mLastGenericLocation);
}
if (mLastGpsLocation != null) {
pw.print(""String_Node_Str"");
pw.println(mLastGpsLocation);
}
pw.print(""String_Node_Str"");
pw.print(stateToString(mState));
pw.print(""String_Node_Str"");
pw.println(lightStateToString(mLightState));
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mInactiveTimeout,pw);
pw.println();
if (mActiveIdleOpCount != 0) {
pw.print(""String_Node_Str"");
pw.println(mActiveIdleOpCount);
}
if (mNextAlarmTime != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mNextAlarmTime,SystemClock.elapsedRealtime(),pw);
pw.println();
}
if (mNextIdlePendingDelay != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mNextIdlePendingDelay,pw);
pw.println();
}
if (mNextIdleDelay != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mNextIdleDelay,pw);
pw.println();
}
if (mNextLightIdleDelay != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mNextLightIdleDelay,pw);
pw.println();
}
if (mNextLightAlarmTime != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mNextLightAlarmTime,SystemClock.elapsedRealtime(),pw);
pw.println();
}
if (mCurIdleBudget != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mCurIdleBudget,pw);
pw.println();
}
if (mMaintenanceStartTime != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mMaintenanceStartTime,SystemClock.elapsedRealtime(),pw);
pw.println();
}
if (mJobsActive) {
pw.print(""String_Node_Str"");
pw.println(mJobsActive);
}
if (mAlarmsActive) {
pw.print(""String_Node_Str"");
pw.println(mAlarmsActive);
}
if (mDownloadServiceActive != null) {
pw.print(""String_Node_Str"");
pw.println(mDownloadServiceActive);
}
}
}","void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (getContext().checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  if (args != null) {
    int userId=UserHandle.USER_SYSTEM;
    for (int i=0; i < args.length; i++) {
      String arg=args[i];
      if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i < args.length) {
          arg=args[i];
          userId=Integer.parseInt(arg);
        }
      }
 else       if (""String_Node_Str"".equals(arg)) {
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        return;
      }
 else {
        Shell shell=new Shell();
        shell.userId=userId;
        String[] newArgs=new String[args.length - i];
        System.arraycopy(args,i,newArgs,0,args.length - i);
        shell.exec(mBinderService,null,fd,null,newArgs,new ResultReceiver(null));
        return;
      }
    }
  }
synchronized (this) {
    mConstants.dump(pw);
    if (mEventCmds[0] != EVENT_NULL) {
      pw.println(""String_Node_Str"");
      long now=SystemClock.elapsedRealtime();
      for (int i=EVENT_BUFFER_SIZE - 1; i >= 0; i--) {
        int cmd=mEventCmds[i];
        if (cmd == EVENT_NULL) {
          continue;
        }
        String label;
switch (mEventCmds[i]) {
case EVENT_NORMAL:
          label=""String_Node_Str"";
        break;
case EVENT_LIGHT_IDLE:
      label=""String_Node_Str"";
    break;
case EVENT_LIGHT_MAINTENANCE:
  label=""String_Node_Str"";
break;
case EVENT_DEEP_IDLE:
label=""String_Node_Str"";
break;
case EVENT_DEEP_MAINTENANCE:
label=""String_Node_Str"";
break;
default :
label=""String_Node_Str"";
break;
}
pw.print(""String_Node_Str"");
pw.print(label);
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mEventTimes[i],now,pw);
;
pw.println();
}
}
int size=mPowerSaveWhitelistAppsExceptIdle.size();
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.println(mPowerSaveWhitelistAppsExceptIdle.keyAt(i));
}
}
size=mPowerSaveWhitelistApps.size();
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.println(mPowerSaveWhitelistApps.keyAt(i));
}
}
size=mPowerSaveWhitelistUserApps.size();
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.println(mPowerSaveWhitelistUserApps.keyAt(i));
}
}
size=mPowerSaveWhitelistExceptIdleAppIds.size();
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.print(mPowerSaveWhitelistExceptIdleAppIds.keyAt(i));
pw.println();
}
}
size=mPowerSaveWhitelistUserAppIds.size();
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.print(mPowerSaveWhitelistUserAppIds.keyAt(i));
pw.println();
}
}
size=mPowerSaveWhitelistAllAppIds.size();
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.print(mPowerSaveWhitelistAllAppIds.keyAt(i));
pw.println();
}
}
size=mTempWhitelistAppIdEndTimes.size();
if (size > 0) {
pw.println(""String_Node_Str"");
final long timeNow=SystemClock.elapsedRealtime();
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.print(mTempWhitelistAppIdEndTimes.keyAt(i));
pw.print(""String_Node_Str"");
Pair<MutableLong,String> entry=mTempWhitelistAppIdEndTimes.valueAt(i);
TimeUtils.formatDuration(entry.first.value,timeNow,pw);
pw.print(""String_Node_Str"");
pw.println(entry.second);
}
}
size=mTempWhitelistAppIdArray != null ? mTempWhitelistAppIdArray.length : 0;
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.print(mTempWhitelistAppIdArray[i]);
pw.println();
}
}
pw.print(""String_Node_Str"");
pw.print(mLightEnabled);
pw.print(""String_Node_Str"");
pw.println(mDeepEnabled);
pw.print(""String_Node_Str"");
pw.println(mForceIdle);
pw.print(""String_Node_Str"");
pw.println(mMotionSensor);
pw.print(""String_Node_Str"");
pw.println(mCurDisplay);
pw.print(""String_Node_Str"");
pw.println(mScreenOn);
pw.print(""String_Node_Str"");
pw.println(mNetworkConnected);
pw.print(""String_Node_Str"");
pw.println(mCharging);
pw.print(""String_Node_Str"");
pw.println(mMotionListener.active);
pw.print(""String_Node_Str"");
pw.println(mNotMoving);
pw.print(""String_Node_Str"");
pw.print(mLocating);
pw.print(""String_Node_Str"");
pw.print(mHasGps);
pw.print(""String_Node_Str"");
pw.print(mHasNetworkLocation);
pw.print(""String_Node_Str"");
pw.println(mLocated);
if (mLastGenericLocation != null) {
pw.print(""String_Node_Str"");
pw.println(mLastGenericLocation);
}
if (mLastGpsLocation != null) {
pw.print(""String_Node_Str"");
pw.println(mLastGpsLocation);
}
pw.print(""String_Node_Str"");
pw.print(stateToString(mState));
pw.print(""String_Node_Str"");
pw.println(lightStateToString(mLightState));
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mInactiveTimeout,pw);
pw.println();
if (mActiveIdleOpCount != 0) {
pw.print(""String_Node_Str"");
pw.println(mActiveIdleOpCount);
}
if (mNextAlarmTime != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mNextAlarmTime,SystemClock.elapsedRealtime(),pw);
pw.println();
}
if (mNextIdlePendingDelay != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mNextIdlePendingDelay,pw);
pw.println();
}
if (mNextIdleDelay != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mNextIdleDelay,pw);
pw.println();
}
if (mNextLightIdleDelay != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mNextLightIdleDelay,pw);
pw.println();
}
if (mNextLightAlarmTime != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mNextLightAlarmTime,SystemClock.elapsedRealtime(),pw);
pw.println();
}
if (mCurIdleBudget != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mCurIdleBudget,pw);
pw.println();
}
if (mMaintenanceStartTime != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mMaintenanceStartTime,SystemClock.elapsedRealtime(),pw);
pw.println();
}
if (mJobsActive) {
pw.print(""String_Node_Str"");
pw.println(mJobsActive);
}
if (mAlarmsActive) {
pw.print(""String_Node_Str"");
pw.println(mAlarmsActive);
}
if (mDownloadServiceActive != null) {
pw.print(""String_Node_Str"");
pw.println(mDownloadServiceActive);
}
}
}",0.9954156479217604
192212,"private boolean isFlushed(SpeechItem speechItem){
synchronized (mFlushedObjects) {
    return mFlushAll || mFlushedObjects.contains(speechItem.getCallerIdentity());
  }
}","private boolean isFlushed(SpeechItem speechItem){
synchronized (mFlushedObjects) {
    return mFlushAll > 0 || mFlushedObjects.contains(speechItem.getCallerIdentity());
  }
}",0.9883720930232558
192213,"private void startFlushingSpeechItems(Object callerIdentity){
synchronized (mFlushedObjects) {
    if (callerIdentity == null) {
      mFlushAll=true;
    }
 else {
      mFlushedObjects.add(callerIdentity);
    }
  }
}","private void startFlushingSpeechItems(Object callerIdentity){
synchronized (mFlushedObjects) {
    if (callerIdentity == null) {
      mFlushAll+=1;
    }
 else {
      mFlushedObjects.add(callerIdentity);
    }
  }
}",0.9862385321100916
192214,"private void endFlushingSpeechItems(Object callerIdentity){
synchronized (mFlushedObjects) {
    if (callerIdentity == null) {
      mFlushAll=false;
    }
 else {
      mFlushedObjects.remove(callerIdentity);
    }
  }
}","private void endFlushingSpeechItems(Object callerIdentity){
synchronized (mFlushedObjects) {
    if (callerIdentity == null) {
      mFlushAll-=1;
    }
 else {
      mFlushedObjects.remove(callerIdentity);
    }
  }
}",0.9840546697038725
192215,"/** 
 * Moves the specified task record to the input stack id. WARNING: This method performs an unchecked/raw move of the task and can leave the system in an unstable state if used incorrectly. Use   {@link #moveTaskToStackLocked} to perform safe task movement to a stack.
 * @param task Task to move.
 * @param stackId Id of stack to move task to.
 * @param toTop True if the task should be placed at the top of the stack.
 * @param forceFocus if focus should be moved to the new stack
 * @param reason Reason the task is been moved.
 * @return The stack the task was moved to.
 */
ActivityStack moveTaskToStackUncheckedLocked(TaskRecord task,int stackId,boolean toTop,boolean forceFocus,String reason){
  if (StackId.isMultiWindowStack(stackId) && !mService.mSupportsMultiWindow) {
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + task + ""String_Node_Str""+ stackId);
  }
  final ActivityRecord r=task.getTopActivity();
  final ActivityStack prevStack=task.stack;
  final boolean wasFocused=isFocusedStack(prevStack) && (topRunningActivityLocked() == r);
  final boolean wasResumed=wasFocused && (prevStack.mResumedActivity == r);
  final boolean wasFront=isFrontStack(prevStack) && (prevStack.topRunningActivityLocked() == r);
  if (stackId == DOCKED_STACK_ID && !task.isResizeable()) {
    stackId=(prevStack != null) ? prevStack.mStackId : FULLSCREEN_WORKSPACE_STACK_ID;
    Slog.w(TAG,""String_Node_Str"" + task + ""String_Node_Str""+ stackId+ ""String_Node_Str"");
  }
  task.mTemporarilyUnresizable=true;
  final ActivityStack stack=getStack(stackId,CREATE_IF_NEEDED,toTop);
  task.mTemporarilyUnresizable=false;
  mWindowManager.moveTaskToStack(task.taskId,stack.mStackId,toTop);
  stack.addTask(task,toTop,reason);
  stack.moveToFrontAndResumeStateIfNeeded(r,forceFocus || wasFocused || wasFront,wasResumed,reason);
  return stack;
}","/** 
 * Moves the specified task record to the input stack id. WARNING: This method performs an unchecked/raw move of the task and can leave the system in an unstable state if used incorrectly. Use   {@link #moveTaskToStackLocked} to perform safe task movement to a stack.
 * @param task Task to move.
 * @param stackId Id of stack to move task to.
 * @param toTop True if the task should be placed at the top of the stack.
 * @param forceFocus if focus should be moved to the new stack
 * @param reason Reason the task is been moved.
 * @return The stack the task was moved to.
 */
ActivityStack moveTaskToStackUncheckedLocked(TaskRecord task,int stackId,boolean toTop,boolean forceFocus,String reason){
  if (StackId.isMultiWindowStack(stackId) && !mService.mSupportsMultiWindow) {
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + task + ""String_Node_Str""+ stackId);
  }
  final ActivityRecord r=task.getTopActivity();
  final ActivityStack prevStack=task.stack;
  final boolean wasFocused=isFocusedStack(prevStack) && (topRunningActivityLocked() == r);
  final boolean wasResumed=prevStack.mResumedActivity == r;
  final boolean wasFront=isFrontStack(prevStack) && (prevStack.topRunningActivityLocked() == r);
  if (stackId == DOCKED_STACK_ID && !task.isResizeable()) {
    stackId=(prevStack != null) ? prevStack.mStackId : FULLSCREEN_WORKSPACE_STACK_ID;
    Slog.w(TAG,""String_Node_Str"" + task + ""String_Node_Str""+ stackId+ ""String_Node_Str"");
  }
  task.mTemporarilyUnresizable=true;
  final ActivityStack stack=getStack(stackId,CREATE_IF_NEEDED,toTop);
  task.mTemporarilyUnresizable=false;
  mWindowManager.moveTaskToStack(task.taskId,stack.mStackId,toTop);
  stack.addTask(task,toTop,reason);
  stack.moveToFrontAndResumeStateIfNeeded(r,forceFocus || wasFocused || wasFront,wasResumed,reason);
  return stack;
}",0.995687331536388
192216,"void stepLightIdleStateLocked(String reason){
  if (mLightState == LIGHT_STATE_OVERRIDE) {
    return;
  }
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + mLightState);
  EventLogTags.writeDeviceIdleLightStep();
switch (mLightState) {
case LIGHT_STATE_INACTIVE:
    mCurIdleBudget=mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET;
  mNextLightIdleDelay=mConstants.LIGHT_IDLE_TIMEOUT;
mMaintenanceStartTime=0;
if (!isOpsInactiveLocked()) {
mLightState=LIGHT_STATE_PRE_IDLE;
EventLogTags.writeDeviceIdleLight(mLightState,reason);
scheduleLightAlarmLocked(mConstants.LIGHT_PRE_IDLE_TIMEOUT);
break;
}
case LIGHT_STATE_PRE_IDLE:
case LIGHT_STATE_IDLE_MAINTENANCE:
if (mMaintenanceStartTime != 0) {
long duration=SystemClock.elapsedRealtime() - mMaintenanceStartTime;
if (duration < mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET) {
mCurIdleBudget+=(mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET - duration);
}
 else {
mCurIdleBudget-=(duration - mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET);
}
}
mMaintenanceStartTime=0;
scheduleLightAlarmLocked(mNextLightIdleDelay);
mNextLightIdleDelay=Math.min(mConstants.LIGHT_MAX_IDLE_TIMEOUT,(long)(mNextLightIdleDelay * mConstants.LIGHT_IDLE_FACTOR));
if (mNextLightIdleDelay < mConstants.LIGHT_IDLE_TIMEOUT) {
mNextLightIdleDelay=mConstants.LIGHT_IDLE_TIMEOUT;
}
if (DEBUG) Slog.d(TAG,""String_Node_Str"");
mLightState=LIGHT_STATE_IDLE;
EventLogTags.writeDeviceIdleLight(mLightState,reason);
addEvent(EVENT_LIGHT_IDLE);
mHandler.sendEmptyMessage(MSG_REPORT_IDLE_ON_LIGHT);
break;
case LIGHT_STATE_IDLE:
mActiveIdleOpCount=1;
mActiveIdleWakeLock.acquire();
mMaintenanceStartTime=SystemClock.elapsedRealtime();
if (mCurIdleBudget < mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET) {
mCurIdleBudget=mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET;
}
 else if (mCurIdleBudget > mConstants.LIGHT_IDLE_MAINTENANCE_MAX_BUDGET) {
mCurIdleBudget=mConstants.LIGHT_IDLE_MAINTENANCE_MAX_BUDGET;
}
scheduleLightAlarmLocked(mCurIdleBudget);
if (DEBUG) Slog.d(TAG,""String_Node_Str"");
mLightState=LIGHT_STATE_IDLE_MAINTENANCE;
EventLogTags.writeDeviceIdleLight(mLightState,reason);
addEvent(EVENT_LIGHT_MAINTENANCE);
mHandler.sendEmptyMessage(MSG_REPORT_IDLE_OFF);
break;
}
}","void stepLightIdleStateLocked(String reason){
  if (mLightState == LIGHT_STATE_OVERRIDE) {
    return;
  }
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + mLightState);
  EventLogTags.writeDeviceIdleLightStep();
switch (mLightState) {
case LIGHT_STATE_INACTIVE:
    mCurIdleBudget=mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET;
  mNextLightIdleDelay=mConstants.LIGHT_IDLE_TIMEOUT;
mMaintenanceStartTime=0;
if (!isOpsInactiveLocked()) {
mLightState=LIGHT_STATE_PRE_IDLE;
EventLogTags.writeDeviceIdleLight(mLightState,reason);
scheduleLightAlarmLocked(mConstants.LIGHT_PRE_IDLE_TIMEOUT);
break;
}
case LIGHT_STATE_PRE_IDLE:
case LIGHT_STATE_IDLE_MAINTENANCE:
if (mMaintenanceStartTime != 0) {
long duration=SystemClock.elapsedRealtime() - mMaintenanceStartTime;
if (duration < mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET) {
mCurIdleBudget+=(mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET - duration);
}
 else {
mCurIdleBudget-=(duration - mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET);
}
}
mMaintenanceStartTime=0;
scheduleLightAlarmLocked(mNextLightIdleDelay);
mNextLightIdleDelay=Math.min(mConstants.LIGHT_MAX_IDLE_TIMEOUT,(long)(mNextLightIdleDelay * mConstants.LIGHT_IDLE_FACTOR));
if (mNextLightIdleDelay < mConstants.LIGHT_IDLE_TIMEOUT) {
mNextLightIdleDelay=mConstants.LIGHT_IDLE_TIMEOUT;
}
if (DEBUG) Slog.d(TAG,""String_Node_Str"");
mLightState=LIGHT_STATE_IDLE;
EventLogTags.writeDeviceIdleLight(mLightState,reason);
addEvent(EVENT_LIGHT_IDLE);
mHandler.sendEmptyMessage(MSG_REPORT_IDLE_ON_LIGHT);
break;
case LIGHT_STATE_IDLE:
case LIGHT_STATE_WAITING_FOR_NETWORK:
if (mNetworkConnected || mLightState == LIGHT_STATE_WAITING_FOR_NETWORK) {
mActiveIdleOpCount=1;
mActiveIdleWakeLock.acquire();
mMaintenanceStartTime=SystemClock.elapsedRealtime();
if (mCurIdleBudget < mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET) {
mCurIdleBudget=mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET;
}
 else if (mCurIdleBudget > mConstants.LIGHT_IDLE_MAINTENANCE_MAX_BUDGET) {
mCurIdleBudget=mConstants.LIGHT_IDLE_MAINTENANCE_MAX_BUDGET;
}
scheduleLightAlarmLocked(mCurIdleBudget);
if (DEBUG) Slog.d(TAG,""String_Node_Str"");
mLightState=LIGHT_STATE_IDLE_MAINTENANCE;
EventLogTags.writeDeviceIdleLight(mLightState,reason);
addEvent(EVENT_LIGHT_MAINTENANCE);
mHandler.sendEmptyMessage(MSG_REPORT_IDLE_OFF);
}
 else {
scheduleLightAlarmLocked(mNextLightIdleDelay);
if (DEBUG) Slog.d(TAG,""String_Node_Str"");
mLightState=LIGHT_STATE_WAITING_FOR_NETWORK;
EventLogTags.writeDeviceIdleLight(mLightState,reason);
}
break;
}
}",0.9328198545143346
192217,"static void dumpHelp(PrintWriter pw){
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
}","static void dumpHelp(PrintWriter pw){
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
}",0.8944337811900192
192218,"@Override public void onStart(){
  final PackageManager pm=getContext().getPackageManager();
synchronized (this) {
    mLightEnabled=mDeepEnabled=getContext().getResources().getBoolean(com.android.internal.R.bool.config_enableAutoPowerModes);
    SystemConfig sysConfig=SystemConfig.getInstance();
    ArraySet<String> allowPowerExceptIdle=sysConfig.getAllowInPowerSaveExceptIdle();
    for (int i=0; i < allowPowerExceptIdle.size(); i++) {
      String pkg=allowPowerExceptIdle.valueAt(i);
      try {
        ApplicationInfo ai=pm.getApplicationInfo(pkg,PackageManager.MATCH_SYSTEM_ONLY);
        int appid=UserHandle.getAppId(ai.uid);
        mPowerSaveWhitelistAppsExceptIdle.put(ai.packageName,appid);
        mPowerSaveWhitelistSystemAppIdsExceptIdle.put(appid,true);
      }
 catch (      PackageManager.NameNotFoundException e) {
      }
    }
    ArraySet<String> allowPower=sysConfig.getAllowInPowerSave();
    for (int i=0; i < allowPower.size(); i++) {
      String pkg=allowPower.valueAt(i);
      try {
        ApplicationInfo ai=pm.getApplicationInfo(pkg,PackageManager.MATCH_SYSTEM_ONLY);
        int appid=UserHandle.getAppId(ai.uid);
        mPowerSaveWhitelistAppsExceptIdle.put(ai.packageName,appid);
        mPowerSaveWhitelistSystemAppIdsExceptIdle.put(appid,true);
        mPowerSaveWhitelistApps.put(ai.packageName,appid);
        mPowerSaveWhitelistSystemAppIds.put(appid,true);
      }
 catch (      PackageManager.NameNotFoundException e) {
      }
    }
    mConstants=new Constants(mHandler,getContext().getContentResolver());
    readConfigFileLocked();
    updateWhitelistAppIdsLocked();
    mScreenOn=true;
    mCharging=true;
    mState=STATE_ACTIVE;
    mLightState=LIGHT_STATE_ACTIVE;
    mInactiveTimeout=mConstants.INACTIVE_TIMEOUT;
  }
  mBinderService=new BinderService();
  publishBinderService(Context.DEVICE_IDLE_CONTROLLER,mBinderService);
  publishLocalService(LocalService.class,new LocalService());
}","@Override public void onStart(){
  final PackageManager pm=getContext().getPackageManager();
synchronized (this) {
    mLightEnabled=mDeepEnabled=getContext().getResources().getBoolean(com.android.internal.R.bool.config_enableAutoPowerModes);
    SystemConfig sysConfig=SystemConfig.getInstance();
    ArraySet<String> allowPowerExceptIdle=sysConfig.getAllowInPowerSaveExceptIdle();
    for (int i=0; i < allowPowerExceptIdle.size(); i++) {
      String pkg=allowPowerExceptIdle.valueAt(i);
      try {
        ApplicationInfo ai=pm.getApplicationInfo(pkg,PackageManager.MATCH_SYSTEM_ONLY);
        int appid=UserHandle.getAppId(ai.uid);
        mPowerSaveWhitelistAppsExceptIdle.put(ai.packageName,appid);
        mPowerSaveWhitelistSystemAppIdsExceptIdle.put(appid,true);
      }
 catch (      PackageManager.NameNotFoundException e) {
      }
    }
    ArraySet<String> allowPower=sysConfig.getAllowInPowerSave();
    for (int i=0; i < allowPower.size(); i++) {
      String pkg=allowPower.valueAt(i);
      try {
        ApplicationInfo ai=pm.getApplicationInfo(pkg,PackageManager.MATCH_SYSTEM_ONLY);
        int appid=UserHandle.getAppId(ai.uid);
        mPowerSaveWhitelistAppsExceptIdle.put(ai.packageName,appid);
        mPowerSaveWhitelistSystemAppIdsExceptIdle.put(appid,true);
        mPowerSaveWhitelistApps.put(ai.packageName,appid);
        mPowerSaveWhitelistSystemAppIds.put(appid,true);
      }
 catch (      PackageManager.NameNotFoundException e) {
      }
    }
    mConstants=new Constants(mHandler,getContext().getContentResolver());
    readConfigFileLocked();
    updateWhitelistAppIdsLocked();
    mNetworkConnected=true;
    mScreenOn=true;
    mCharging=true;
    mState=STATE_ACTIVE;
    mLightState=LIGHT_STATE_ACTIVE;
    mInactiveTimeout=mConstants.INACTIVE_TIMEOUT;
  }
  mBinderService=new BinderService();
  publishBinderService(Context.DEVICE_IDLE_CONTROLLER,mBinderService);
  publishLocalService(LocalService.class,new LocalService());
}",0.9928571428571428
192219,"private static String lightStateToString(int state){
switch (state) {
case LIGHT_STATE_ACTIVE:
    return ""String_Node_Str"";
case LIGHT_STATE_INACTIVE:
  return ""String_Node_Str"";
case LIGHT_STATE_PRE_IDLE:
return ""String_Node_Str"";
case LIGHT_STATE_IDLE:
return ""String_Node_Str"";
case LIGHT_STATE_IDLE_MAINTENANCE:
return ""String_Node_Str"";
case LIGHT_STATE_OVERRIDE:
return ""String_Node_Str"";
default :
return Integer.toString(state);
}
}","private static String lightStateToString(int state){
switch (state) {
case LIGHT_STATE_ACTIVE:
    return ""String_Node_Str"";
case LIGHT_STATE_INACTIVE:
  return ""String_Node_Str"";
case LIGHT_STATE_PRE_IDLE:
return ""String_Node_Str"";
case LIGHT_STATE_IDLE:
return ""String_Node_Str"";
case LIGHT_STATE_WAITING_FOR_NETWORK:
return ""String_Node_Str"";
case LIGHT_STATE_IDLE_MAINTENANCE:
return ""String_Node_Str"";
case LIGHT_STATE_OVERRIDE:
return ""String_Node_Str"";
default :
return Integer.toString(state);
}
}",0.9323467230443976
192220,"void scheduleLightAlarmLocked(long delay){
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + delay + ""String_Node_Str"");
  if (mMotionSensor == null) {
    return;
  }
  mNextLightAlarmTime=SystemClock.elapsedRealtime() + delay;
  mAlarmManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,mNextLightAlarmTime,""String_Node_Str"",mLightAlarmListener,mHandler);
}","void scheduleLightAlarmLocked(long delay){
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + delay + ""String_Node_Str"");
  mNextLightAlarmTime=SystemClock.elapsedRealtime() + delay;
  mAlarmManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,mNextLightAlarmTime,""String_Node_Str"",mLightAlarmListener,mHandler);
}",0.928462709284627
192221,"int onShellCommand(Shell shell,String cmd){
  PrintWriter pw=shell.getOutPrintWriter();
  if (""String_Node_Str"".equals(cmd)) {
    getContext().enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER,null);
synchronized (this) {
      long token=Binder.clearCallingIdentity();
      String arg=shell.getNextArg();
      try {
        if (arg == null || ""String_Node_Str"".equals(arg)) {
          exitForceIdleLocked();
          stepIdleStateLocked(""String_Node_Str"");
          pw.print(""String_Node_Str"");
          pw.println(stateToString(mState));
        }
 else         if (""String_Node_Str"".equals(arg)) {
          exitForceIdleLocked();
          stepLightIdleStateLocked(""String_Node_Str"");
          pw.print(""String_Node_Str"");
          pw.println(lightStateToString(mLightState));
        }
 else {
          pw.println(""String_Node_Str"" + arg);
        }
      }
  finally {
        Binder.restoreCallingIdentity(token);
      }
    }
  }
 else   if (""String_Node_Str"".equals(cmd)) {
    getContext().enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER,null);
synchronized (this) {
      long token=Binder.clearCallingIdentity();
      try {
        if (!mDeepEnabled) {
          pw.println(""String_Node_Str"");
          return -1;
        }
        mForceIdle=true;
        becomeInactiveIfAppropriateLocked();
        int curState=mState;
        while (curState != STATE_IDLE) {
          stepIdleStateLocked(""String_Node_Str"");
          if (curState == mState) {
            pw.print(""String_Node_Str"");
            pw.println(stateToString(mState));
            exitForceIdleLocked();
            return -1;
          }
          curState=mState;
        }
        pw.println(""String_Node_Str"");
      }
  finally {
        Binder.restoreCallingIdentity(token);
      }
    }
  }
 else   if (""String_Node_Str"".equals(cmd)) {
    getContext().enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER,null);
synchronized (this) {
      long token=Binder.clearCallingIdentity();
      String arg=shell.getNextArg();
      try {
        boolean becomeActive=false;
        boolean valid=false;
        if (arg == null || ""String_Node_Str"".equals(arg) || ""String_Node_Str"".equals(arg)) {
          valid=true;
          if (mDeepEnabled) {
            mDeepEnabled=false;
            becomeActive=true;
            pw.println(""String_Node_Str"");
          }
        }
        if (arg == null || ""String_Node_Str"".equals(arg) || ""String_Node_Str"".equals(arg)) {
          valid=true;
          if (mLightEnabled) {
            mLightEnabled=false;
            becomeActive=true;
            pw.println(""String_Node_Str"");
          }
        }
        if (becomeActive) {
          becomeActiveLocked((arg == null ? ""String_Node_Str"" : arg) + ""String_Node_Str"",Process.myUid());
        }
        if (!valid) {
          pw.println(""String_Node_Str"" + arg);
        }
      }
  finally {
        Binder.restoreCallingIdentity(token);
      }
    }
  }
 else   if (""String_Node_Str"".equals(cmd)) {
    getContext().enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER,null);
synchronized (this) {
      long token=Binder.clearCallingIdentity();
      String arg=shell.getNextArg();
      try {
        boolean becomeInactive=false;
        boolean valid=false;
        if (arg == null || ""String_Node_Str"".equals(arg) || ""String_Node_Str"".equals(arg)) {
          valid=true;
          if (!mDeepEnabled) {
            mDeepEnabled=true;
            becomeInactive=true;
            pw.println(""String_Node_Str"");
          }
        }
        if (arg == null || ""String_Node_Str"".equals(arg) || ""String_Node_Str"".equals(arg)) {
          valid=true;
          if (!mLightEnabled) {
            mLightEnabled=true;
            becomeInactive=true;
            pw.println(""String_Node_Str"");
          }
        }
        if (becomeInactive) {
          becomeInactiveIfAppropriateLocked();
        }
        if (!valid) {
          pw.println(""String_Node_Str"" + arg);
        }
      }
  finally {
        Binder.restoreCallingIdentity(token);
      }
    }
  }
 else   if (""String_Node_Str"".equals(cmd)) {
synchronized (this) {
      String arg=shell.getNextArg();
      if (arg == null || ""String_Node_Str"".equals(arg)) {
        pw.println(mDeepEnabled && mLightEnabled ? ""String_Node_Str"" : 0);
      }
 else       if (""String_Node_Str"".equals(arg)) {
        pw.println(mDeepEnabled ? ""String_Node_Str"" : 0);
      }
 else       if (""String_Node_Str"".equals(arg)) {
        pw.println(mLightEnabled ? ""String_Node_Str"" : 0);
      }
 else {
        pw.println(""String_Node_Str"" + arg);
      }
    }
  }
 else   if (""String_Node_Str"".equals(cmd)) {
    long token=Binder.clearCallingIdentity();
    try {
      String arg=shell.getNextArg();
      if (arg != null) {
        getContext().enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER,null);
        do {
          if (arg.length() < 1 || (arg.charAt(0) != '-' && arg.charAt(0) != '+' && arg.charAt(0) != '=')) {
            pw.println(""String_Node_Str"" + arg);
            return -1;
          }
          char op=arg.charAt(0);
          String pkg=arg.substring(1);
          if (op == '+') {
            if (addPowerSaveWhitelistAppInternal(pkg)) {
              pw.println(""String_Node_Str"" + pkg);
            }
 else {
              pw.println(""String_Node_Str"" + pkg);
            }
          }
 else           if (op == '-') {
            if (removePowerSaveWhitelistAppInternal(pkg)) {
              pw.println(""String_Node_Str"" + pkg);
            }
          }
 else {
            pw.println(getPowerSaveWhitelistAppInternal(pkg));
          }
        }
 while ((arg=shell.getNextArg()) != null);
      }
 else {
synchronized (this) {
          for (int j=0; j < mPowerSaveWhitelistAppsExceptIdle.size(); j++) {
            pw.print(""String_Node_Str"");
            pw.print(mPowerSaveWhitelistAppsExceptIdle.keyAt(j));
            pw.print(""String_Node_Str"");
            pw.println(mPowerSaveWhitelistAppsExceptIdle.valueAt(j));
          }
          for (int j=0; j < mPowerSaveWhitelistApps.size(); j++) {
            pw.print(""String_Node_Str"");
            pw.print(mPowerSaveWhitelistApps.keyAt(j));
            pw.print(""String_Node_Str"");
            pw.println(mPowerSaveWhitelistApps.valueAt(j));
          }
          for (int j=0; j < mPowerSaveWhitelistUserApps.size(); j++) {
            pw.print(""String_Node_Str"");
            pw.print(mPowerSaveWhitelistUserApps.keyAt(j));
            pw.print(""String_Node_Str"");
            pw.println(mPowerSaveWhitelistUserApps.valueAt(j));
          }
        }
      }
    }
  finally {
      Binder.restoreCallingIdentity(token);
    }
  }
 else   if (""String_Node_Str"".equals(cmd)) {
    String opt;
    while ((opt=shell.getNextOption()) != null) {
      if (""String_Node_Str"".equals(opt)) {
        opt=shell.getNextArg();
        if (opt == null) {
          pw.println(""String_Node_Str"");
          return -1;
        }
        shell.userId=Integer.parseInt(opt);
      }
    }
    String arg=shell.getNextArg();
    if (arg != null) {
      try {
        addPowerSaveTempWhitelistAppChecked(arg,10000L,shell.userId,""String_Node_Str"");
      }
 catch (      RemoteException re) {
        pw.println(""String_Node_Str"" + re);
      }
    }
 else {
      pw.println(""String_Node_Str"");
      return -1;
    }
  }
 else {
    return shell.handleDefaultCommands(cmd);
  }
  return 0;
}","int onShellCommand(Shell shell,String cmd){
  PrintWriter pw=shell.getOutPrintWriter();
  if (""String_Node_Str"".equals(cmd)) {
    getContext().enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER,null);
synchronized (this) {
      long token=Binder.clearCallingIdentity();
      String arg=shell.getNextArg();
      try {
        if (arg == null || ""String_Node_Str"".equals(arg)) {
          stepIdleStateLocked(""String_Node_Str"");
          pw.print(""String_Node_Str"");
          pw.println(stateToString(mState));
        }
 else         if (""String_Node_Str"".equals(arg)) {
          stepLightIdleStateLocked(""String_Node_Str"");
          pw.print(""String_Node_Str"");
          pw.println(lightStateToString(mLightState));
        }
 else {
          pw.println(""String_Node_Str"" + arg);
        }
      }
  finally {
        Binder.restoreCallingIdentity(token);
      }
    }
  }
 else   if (""String_Node_Str"".equals(cmd)) {
    getContext().enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER,null);
synchronized (this) {
      long token=Binder.clearCallingIdentity();
      String arg=shell.getNextArg();
      try {
        if (arg == null || ""String_Node_Str"".equals(arg)) {
          if (!mDeepEnabled) {
            pw.println(""String_Node_Str"");
            return -1;
          }
          mForceIdle=true;
          becomeInactiveIfAppropriateLocked();
          int curState=mState;
          while (curState != STATE_IDLE) {
            stepIdleStateLocked(""String_Node_Str"");
            if (curState == mState) {
              pw.print(""String_Node_Str"");
              pw.println(stateToString(mState));
              exitForceIdleLocked();
              return -1;
            }
            curState=mState;
          }
          pw.println(""String_Node_Str"");
        }
 else         if (""String_Node_Str"".equals(arg)) {
          mForceIdle=true;
          becomeInactiveIfAppropriateLocked();
          int curLightState=mLightState;
          while (curLightState != LIGHT_STATE_IDLE) {
            stepIdleStateLocked(""String_Node_Str"");
            if (curLightState == mLightState) {
              pw.print(""String_Node_Str"");
              pw.println(lightStateToString(mLightState));
              exitForceIdleLocked();
              return -1;
            }
            curLightState=mLightState;
          }
          pw.println(""String_Node_Str"");
        }
 else {
          pw.println(""String_Node_Str"" + arg);
        }
      }
  finally {
        Binder.restoreCallingIdentity(token);
      }
    }
  }
 else   if (""String_Node_Str"".equals(cmd)) {
    getContext().enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER,null);
synchronized (this) {
      long token=Binder.clearCallingIdentity();
      try {
        mForceIdle=true;
        becomeInactiveIfAppropriateLocked();
        pw.print(""String_Node_Str"");
        pw.print(lightStateToString(mLightState));
        pw.print(""String_Node_Str"");
        pw.println(stateToString(mState));
      }
  finally {
        Binder.restoreCallingIdentity(token);
      }
    }
  }
 else   if (""String_Node_Str"".equals(cmd)) {
    getContext().enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER,null);
synchronized (this) {
      long token=Binder.clearCallingIdentity();
      try {
        exitForceIdleLocked();
        pw.print(""String_Node_Str"");
        pw.print(lightStateToString(mLightState));
        pw.print(""String_Node_Str"");
        pw.println(stateToString(mState));
      }
  finally {
        Binder.restoreCallingIdentity(token);
      }
    }
  }
 else   if (""String_Node_Str"".equals(cmd)) {
    getContext().enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER,null);
synchronized (this) {
      String arg=shell.getNextArg();
      if (arg != null) {
        long token=Binder.clearCallingIdentity();
        try {
switch (arg) {
case ""String_Node_Str"":
            pw.println(lightStateToString(mLightState));
          break;
case ""String_Node_Str"":
        pw.println(stateToString(mState));
      break;
case ""String_Node_Str"":
    pw.println(mForceIdle);
  break;
case ""String_Node_Str"":
pw.println(mScreenOn);
break;
case ""String_Node_Str"":
pw.println(mCharging);
break;
case ""String_Node_Str"":
pw.println(mNetworkConnected);
break;
default :
pw.println(""String_Node_Str"" + arg);
break;
}
}
  finally {
Binder.restoreCallingIdentity(token);
}
}
 else {
pw.println(""String_Node_Str"");
}
}
}
 else if (""String_Node_Str"".equals(cmd)) {
getContext().enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER,null);
synchronized (this) {
long token=Binder.clearCallingIdentity();
String arg=shell.getNextArg();
try {
boolean becomeActive=false;
boolean valid=false;
if (arg == null || ""String_Node_Str"".equals(arg) || ""String_Node_Str"".equals(arg)) {
valid=true;
if (mDeepEnabled) {
mDeepEnabled=false;
becomeActive=true;
pw.println(""String_Node_Str"");
}
}
if (arg == null || ""String_Node_Str"".equals(arg) || ""String_Node_Str"".equals(arg)) {
valid=true;
if (mLightEnabled) {
mLightEnabled=false;
becomeActive=true;
pw.println(""String_Node_Str"");
}
}
if (becomeActive) {
becomeActiveLocked((arg == null ? ""String_Node_Str"" : arg) + ""String_Node_Str"",Process.myUid());
}
if (!valid) {
pw.println(""String_Node_Str"" + arg);
}
}
  finally {
Binder.restoreCallingIdentity(token);
}
}
}
 else if (""String_Node_Str"".equals(cmd)) {
getContext().enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER,null);
synchronized (this) {
long token=Binder.clearCallingIdentity();
String arg=shell.getNextArg();
try {
boolean becomeInactive=false;
boolean valid=false;
if (arg == null || ""String_Node_Str"".equals(arg) || ""String_Node_Str"".equals(arg)) {
valid=true;
if (!mDeepEnabled) {
mDeepEnabled=true;
becomeInactive=true;
pw.println(""String_Node_Str"");
}
}
if (arg == null || ""String_Node_Str"".equals(arg) || ""String_Node_Str"".equals(arg)) {
valid=true;
if (!mLightEnabled) {
mLightEnabled=true;
becomeInactive=true;
pw.println(""String_Node_Str"");
}
}
if (becomeInactive) {
becomeInactiveIfAppropriateLocked();
}
if (!valid) {
pw.println(""String_Node_Str"" + arg);
}
}
  finally {
Binder.restoreCallingIdentity(token);
}
}
}
 else if (""String_Node_Str"".equals(cmd)) {
synchronized (this) {
String arg=shell.getNextArg();
if (arg == null || ""String_Node_Str"".equals(arg)) {
pw.println(mDeepEnabled && mLightEnabled ? ""String_Node_Str"" : 0);
}
 else if (""String_Node_Str"".equals(arg)) {
pw.println(mDeepEnabled ? ""String_Node_Str"" : 0);
}
 else if (""String_Node_Str"".equals(arg)) {
pw.println(mLightEnabled ? ""String_Node_Str"" : 0);
}
 else {
pw.println(""String_Node_Str"" + arg);
}
}
}
 else if (""String_Node_Str"".equals(cmd)) {
long token=Binder.clearCallingIdentity();
try {
String arg=shell.getNextArg();
if (arg != null) {
getContext().enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER,null);
do {
if (arg.length() < 1 || (arg.charAt(0) != '-' && arg.charAt(0) != '+' && arg.charAt(0) != '=')) {
pw.println(""String_Node_Str"" + arg);
return -1;
}
char op=arg.charAt(0);
String pkg=arg.substring(1);
if (op == '+') {
if (addPowerSaveWhitelistAppInternal(pkg)) {
pw.println(""String_Node_Str"" + pkg);
}
 else {
pw.println(""String_Node_Str"" + pkg);
}
}
 else if (op == '-') {
if (removePowerSaveWhitelistAppInternal(pkg)) {
pw.println(""String_Node_Str"" + pkg);
}
}
 else {
pw.println(getPowerSaveWhitelistAppInternal(pkg));
}
}
 while ((arg=shell.getNextArg()) != null);
}
 else {
synchronized (this) {
for (int j=0; j < mPowerSaveWhitelistAppsExceptIdle.size(); j++) {
pw.print(""String_Node_Str"");
pw.print(mPowerSaveWhitelistAppsExceptIdle.keyAt(j));
pw.print(""String_Node_Str"");
pw.println(mPowerSaveWhitelistAppsExceptIdle.valueAt(j));
}
for (int j=0; j < mPowerSaveWhitelistApps.size(); j++) {
pw.print(""String_Node_Str"");
pw.print(mPowerSaveWhitelistApps.keyAt(j));
pw.print(""String_Node_Str"");
pw.println(mPowerSaveWhitelistApps.valueAt(j));
}
for (int j=0; j < mPowerSaveWhitelistUserApps.size(); j++) {
pw.print(""String_Node_Str"");
pw.print(mPowerSaveWhitelistUserApps.keyAt(j));
pw.print(""String_Node_Str"");
pw.println(mPowerSaveWhitelistUserApps.valueAt(j));
}
}
}
}
  finally {
Binder.restoreCallingIdentity(token);
}
}
 else if (""String_Node_Str"".equals(cmd)) {
String opt;
while ((opt=shell.getNextOption()) != null) {
if (""String_Node_Str"".equals(opt)) {
opt=shell.getNextArg();
if (opt == null) {
pw.println(""String_Node_Str"");
return -1;
}
shell.userId=Integer.parseInt(opt);
}
}
String arg=shell.getNextArg();
if (arg != null) {
try {
addPowerSaveTempWhitelistAppChecked(arg,10000L,shell.userId,""String_Node_Str"");
}
 catch (RemoteException re) {
pw.println(""String_Node_Str"" + re);
}
}
 else {
pw.println(""String_Node_Str"");
return -1;
}
}
 else {
return shell.handleDefaultCommands(cmd);
}
return 0;
}",0.5335367714372902
192222,"@Override public void onBootPhase(int phase){
  if (phase == PHASE_SYSTEM_SERVICES_READY) {
synchronized (this) {
      mAlarmManager=(AlarmManager)getContext().getSystemService(Context.ALARM_SERVICE);
      mBatteryStats=BatteryStatsService.getService();
      mLocalPowerManager=getLocalService(PowerManagerInternal.class);
      mPowerManager=getContext().getSystemService(PowerManager.class);
      mActiveIdleWakeLock=mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,""String_Node_Str"");
      mActiveIdleWakeLock.setReferenceCounted(false);
      mLocalAlarmManager=getLocalService(AlarmManagerService.LocalService.class);
      mNetworkPolicyManager=INetworkPolicyManager.Stub.asInterface(ServiceManager.getService(Context.NETWORK_POLICY_SERVICE));
      mDisplayManager=(DisplayManager)getContext().getSystemService(Context.DISPLAY_SERVICE);
      mSensorManager=(SensorManager)getContext().getSystemService(Context.SENSOR_SERVICE);
      int sigMotionSensorId=getContext().getResources().getInteger(com.android.internal.R.integer.config_autoPowerModeAnyMotionSensor);
      if (sigMotionSensorId > 0) {
        mMotionSensor=mSensorManager.getDefaultSensor(sigMotionSensorId,true);
      }
      if (mMotionSensor == null && getContext().getResources().getBoolean(com.android.internal.R.bool.config_autoPowerModePreferWristTilt)) {
        mMotionSensor=mSensorManager.getDefaultSensor(Sensor.TYPE_WRIST_TILT_GESTURE,true);
      }
      if (mMotionSensor == null) {
        mMotionSensor=mSensorManager.getDefaultSensor(Sensor.TYPE_SIGNIFICANT_MOTION,true);
      }
      if (getContext().getResources().getBoolean(com.android.internal.R.bool.config_autoPowerModePrefetchLocation)) {
        mLocationManager=(LocationManager)getContext().getSystemService(Context.LOCATION_SERVICE);
        mLocationRequest=new LocationRequest().setQuality(LocationRequest.ACCURACY_FINE).setInterval(0).setFastestInterval(0).setNumUpdates(1);
      }
      float angleThreshold=getContext().getResources().getInteger(com.android.internal.R.integer.config_autoPowerModeThresholdAngle) / 100f;
      mAnyMotionDetector=new AnyMotionDetector((PowerManager)getContext().getSystemService(Context.POWER_SERVICE),mHandler,mSensorManager,this,angleThreshold);
      mIdleIntent=new Intent(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED);
      mIdleIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
      mLightIdleIntent=new Intent(PowerManager.ACTION_LIGHT_DEVICE_IDLE_MODE_CHANGED);
      mLightIdleIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
      IntentFilter filter=new IntentFilter();
      filter.addAction(Intent.ACTION_BATTERY_CHANGED);
      getContext().registerReceiver(mReceiver,filter);
      filter=new IntentFilter();
      filter.addAction(Intent.ACTION_PACKAGE_REMOVED);
      filter.addDataScheme(""String_Node_Str"");
      getContext().registerReceiver(mReceiver,filter);
      mLocalPowerManager.setDeviceIdleWhitelist(mPowerSaveWhitelistAllAppIdArray);
      mLocalAlarmManager.setDeviceIdleUserWhitelist(mPowerSaveWhitelistUserAppIdArray);
      mDisplayManager.registerDisplayListener(mDisplayListener,null);
      updateDisplayLocked();
    }
  }
}","@Override public void onBootPhase(int phase){
  if (phase == PHASE_SYSTEM_SERVICES_READY) {
synchronized (this) {
      mAlarmManager=(AlarmManager)getContext().getSystemService(Context.ALARM_SERVICE);
      mBatteryStats=BatteryStatsService.getService();
      mLocalPowerManager=getLocalService(PowerManagerInternal.class);
      mPowerManager=getContext().getSystemService(PowerManager.class);
      mActiveIdleWakeLock=mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,""String_Node_Str"");
      mActiveIdleWakeLock.setReferenceCounted(false);
      mConnectivityService=(ConnectivityService)ServiceManager.getService(Context.CONNECTIVITY_SERVICE);
      mLocalAlarmManager=getLocalService(AlarmManagerService.LocalService.class);
      mNetworkPolicyManager=INetworkPolicyManager.Stub.asInterface(ServiceManager.getService(Context.NETWORK_POLICY_SERVICE));
      mDisplayManager=(DisplayManager)getContext().getSystemService(Context.DISPLAY_SERVICE);
      mSensorManager=(SensorManager)getContext().getSystemService(Context.SENSOR_SERVICE);
      int sigMotionSensorId=getContext().getResources().getInteger(com.android.internal.R.integer.config_autoPowerModeAnyMotionSensor);
      if (sigMotionSensorId > 0) {
        mMotionSensor=mSensorManager.getDefaultSensor(sigMotionSensorId,true);
      }
      if (mMotionSensor == null && getContext().getResources().getBoolean(com.android.internal.R.bool.config_autoPowerModePreferWristTilt)) {
        mMotionSensor=mSensorManager.getDefaultSensor(Sensor.TYPE_WRIST_TILT_GESTURE,true);
      }
      if (mMotionSensor == null) {
        mMotionSensor=mSensorManager.getDefaultSensor(Sensor.TYPE_SIGNIFICANT_MOTION,true);
      }
      if (getContext().getResources().getBoolean(com.android.internal.R.bool.config_autoPowerModePrefetchLocation)) {
        mLocationManager=(LocationManager)getContext().getSystemService(Context.LOCATION_SERVICE);
        mLocationRequest=new LocationRequest().setQuality(LocationRequest.ACCURACY_FINE).setInterval(0).setFastestInterval(0).setNumUpdates(1);
      }
      float angleThreshold=getContext().getResources().getInteger(com.android.internal.R.integer.config_autoPowerModeThresholdAngle) / 100f;
      mAnyMotionDetector=new AnyMotionDetector((PowerManager)getContext().getSystemService(Context.POWER_SERVICE),mHandler,mSensorManager,this,angleThreshold);
      mIdleIntent=new Intent(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED);
      mIdleIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
      mLightIdleIntent=new Intent(PowerManager.ACTION_LIGHT_DEVICE_IDLE_MODE_CHANGED);
      mLightIdleIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
      IntentFilter filter=new IntentFilter();
      filter.addAction(Intent.ACTION_BATTERY_CHANGED);
      getContext().registerReceiver(mReceiver,filter);
      filter=new IntentFilter();
      filter.addAction(Intent.ACTION_PACKAGE_REMOVED);
      filter.addDataScheme(""String_Node_Str"");
      filter=new IntentFilter();
      filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);
      getContext().registerReceiver(mReceiver,filter);
      mLocalPowerManager.setDeviceIdleWhitelist(mPowerSaveWhitelistAllAppIdArray);
      mLocalAlarmManager.setDeviceIdleUserWhitelist(mPowerSaveWhitelistUserAppIdArray);
      mDisplayManager.registerDisplayListener(mDisplayListener,null);
      updateConnectivityStateLocked(null);
      updateDisplayLocked();
    }
  }
}",0.9635123108869772
192223,"void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (getContext().checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  if (args != null) {
    int userId=UserHandle.USER_SYSTEM;
    for (int i=0; i < args.length; i++) {
      String arg=args[i];
      if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i < args.length) {
          arg=args[i];
          userId=Integer.parseInt(arg);
        }
      }
 else       if (""String_Node_Str"".equals(arg)) {
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        return;
      }
 else {
        Shell shell=new Shell();
        shell.userId=userId;
        String[] newArgs=new String[args.length - i];
        System.arraycopy(args,i,newArgs,0,args.length - i);
        shell.exec(mBinderService,null,fd,null,newArgs,new ResultReceiver(null));
        return;
      }
    }
  }
synchronized (this) {
    mConstants.dump(pw);
    if (mEventCmds[0] != EVENT_NULL) {
      pw.println(""String_Node_Str"");
      long now=SystemClock.elapsedRealtime();
      for (int i=EVENT_BUFFER_SIZE - 1; i >= 0; i--) {
        int cmd=mEventCmds[i];
        if (cmd == EVENT_NULL) {
          continue;
        }
        String label;
switch (mEventCmds[i]) {
case EVENT_NORMAL:
          label=""String_Node_Str"";
        break;
case EVENT_LIGHT_IDLE:
      label=""String_Node_Str"";
    break;
case EVENT_LIGHT_MAINTENANCE:
  label=""String_Node_Str"";
break;
case EVENT_DEEP_IDLE:
label=""String_Node_Str"";
break;
case EVENT_DEEP_MAINTENANCE:
label=""String_Node_Str"";
break;
default :
label=""String_Node_Str"";
break;
}
pw.print(""String_Node_Str"");
pw.print(label);
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mEventTimes[i],now,pw);
;
pw.println();
}
}
int size=mPowerSaveWhitelistAppsExceptIdle.size();
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.println(mPowerSaveWhitelistAppsExceptIdle.keyAt(i));
}
}
size=mPowerSaveWhitelistApps.size();
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.println(mPowerSaveWhitelistApps.keyAt(i));
}
}
size=mPowerSaveWhitelistUserApps.size();
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.println(mPowerSaveWhitelistUserApps.keyAt(i));
}
}
size=mPowerSaveWhitelistExceptIdleAppIds.size();
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.print(mPowerSaveWhitelistExceptIdleAppIds.keyAt(i));
pw.println();
}
}
size=mPowerSaveWhitelistUserAppIds.size();
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.print(mPowerSaveWhitelistUserAppIds.keyAt(i));
pw.println();
}
}
size=mPowerSaveWhitelistAllAppIds.size();
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.print(mPowerSaveWhitelistAllAppIds.keyAt(i));
pw.println();
}
}
size=mTempWhitelistAppIdEndTimes.size();
if (size > 0) {
pw.println(""String_Node_Str"");
final long timeNow=SystemClock.elapsedRealtime();
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.print(mTempWhitelistAppIdEndTimes.keyAt(i));
pw.print(""String_Node_Str"");
Pair<MutableLong,String> entry=mTempWhitelistAppIdEndTimes.valueAt(i);
TimeUtils.formatDuration(entry.first.value,timeNow,pw);
pw.print(""String_Node_Str"");
pw.println(entry.second);
}
}
size=mTempWhitelistAppIdArray != null ? mTempWhitelistAppIdArray.length : 0;
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.print(mTempWhitelistAppIdArray[i]);
pw.println();
}
}
pw.print(""String_Node_Str"");
pw.print(mLightEnabled);
pw.print(""String_Node_Str"");
pw.println(mDeepEnabled);
pw.print(""String_Node_Str"");
pw.println(mForceIdle);
pw.print(""String_Node_Str"");
pw.println(mMotionSensor);
pw.print(""String_Node_Str"");
pw.println(mCurDisplay);
pw.print(""String_Node_Str"");
pw.println(mScreenOn);
pw.print(""String_Node_Str"");
pw.println(mCharging);
pw.print(""String_Node_Str"");
pw.println(mMotionListener.active);
pw.print(""String_Node_Str"");
pw.println(mNotMoving);
pw.print(""String_Node_Str"");
pw.print(mLocating);
pw.print(""String_Node_Str"");
pw.print(mHasGps);
pw.print(""String_Node_Str"");
pw.print(mHasNetworkLocation);
pw.print(""String_Node_Str"");
pw.println(mLocated);
if (mLastGenericLocation != null) {
pw.print(""String_Node_Str"");
pw.println(mLastGenericLocation);
}
if (mLastGpsLocation != null) {
pw.print(""String_Node_Str"");
pw.println(mLastGpsLocation);
}
pw.print(""String_Node_Str"");
pw.print(stateToString(mState));
pw.print(""String_Node_Str"");
pw.println(lightStateToString(mLightState));
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mInactiveTimeout,pw);
pw.println();
if (mActiveIdleOpCount != 0) {
pw.print(""String_Node_Str"");
pw.println(mActiveIdleOpCount);
}
if (mNextAlarmTime != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mNextAlarmTime,SystemClock.elapsedRealtime(),pw);
pw.println();
}
if (mNextIdlePendingDelay != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mNextIdlePendingDelay,pw);
pw.println();
}
if (mNextIdleDelay != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mNextIdleDelay,pw);
pw.println();
}
if (mNextLightIdleDelay != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mNextLightIdleDelay,pw);
pw.println();
}
if (mNextLightAlarmTime != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mNextLightAlarmTime,SystemClock.elapsedRealtime(),pw);
pw.println();
}
if (mCurIdleBudget != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mCurIdleBudget,pw);
pw.println();
}
if (mMaintenanceStartTime != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mMaintenanceStartTime,SystemClock.elapsedRealtime(),pw);
pw.println();
}
if (mJobsActive) {
pw.print(""String_Node_Str"");
pw.println(mJobsActive);
}
if (mAlarmsActive) {
pw.print(""String_Node_Str"");
pw.println(mAlarmsActive);
}
if (mDownloadServiceActive != null) {
pw.print(""String_Node_Str"");
pw.println(mDownloadServiceActive);
}
}
}","void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (getContext().checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  if (args != null) {
    int userId=UserHandle.USER_SYSTEM;
    for (int i=0; i < args.length; i++) {
      String arg=args[i];
      if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i < args.length) {
          arg=args[i];
          userId=Integer.parseInt(arg);
        }
      }
 else       if (""String_Node_Str"".equals(arg)) {
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        return;
      }
 else {
        Shell shell=new Shell();
        shell.userId=userId;
        String[] newArgs=new String[args.length - i];
        System.arraycopy(args,i,newArgs,0,args.length - i);
        shell.exec(mBinderService,null,fd,null,newArgs,new ResultReceiver(null));
        return;
      }
    }
  }
synchronized (this) {
    mConstants.dump(pw);
    if (mEventCmds[0] != EVENT_NULL) {
      pw.println(""String_Node_Str"");
      long now=SystemClock.elapsedRealtime();
      for (int i=EVENT_BUFFER_SIZE - 1; i >= 0; i--) {
        int cmd=mEventCmds[i];
        if (cmd == EVENT_NULL) {
          continue;
        }
        String label;
switch (mEventCmds[i]) {
case EVENT_NORMAL:
          label=""String_Node_Str"";
        break;
case EVENT_LIGHT_IDLE:
      label=""String_Node_Str"";
    break;
case EVENT_LIGHT_MAINTENANCE:
  label=""String_Node_Str"";
break;
case EVENT_DEEP_IDLE:
label=""String_Node_Str"";
break;
case EVENT_DEEP_MAINTENANCE:
label=""String_Node_Str"";
break;
default :
label=""String_Node_Str"";
break;
}
pw.print(""String_Node_Str"");
pw.print(label);
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mEventTimes[i],now,pw);
;
pw.println();
}
}
int size=mPowerSaveWhitelistAppsExceptIdle.size();
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.println(mPowerSaveWhitelistAppsExceptIdle.keyAt(i));
}
}
size=mPowerSaveWhitelistApps.size();
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.println(mPowerSaveWhitelistApps.keyAt(i));
}
}
size=mPowerSaveWhitelistUserApps.size();
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.println(mPowerSaveWhitelistUserApps.keyAt(i));
}
}
size=mPowerSaveWhitelistExceptIdleAppIds.size();
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.print(mPowerSaveWhitelistExceptIdleAppIds.keyAt(i));
pw.println();
}
}
size=mPowerSaveWhitelistUserAppIds.size();
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.print(mPowerSaveWhitelistUserAppIds.keyAt(i));
pw.println();
}
}
size=mPowerSaveWhitelistAllAppIds.size();
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.print(mPowerSaveWhitelistAllAppIds.keyAt(i));
pw.println();
}
}
size=mTempWhitelistAppIdEndTimes.size();
if (size > 0) {
pw.println(""String_Node_Str"");
final long timeNow=SystemClock.elapsedRealtime();
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.print(mTempWhitelistAppIdEndTimes.keyAt(i));
pw.print(""String_Node_Str"");
Pair<MutableLong,String> entry=mTempWhitelistAppIdEndTimes.valueAt(i);
TimeUtils.formatDuration(entry.first.value,timeNow,pw);
pw.print(""String_Node_Str"");
pw.println(entry.second);
}
}
size=mTempWhitelistAppIdArray != null ? mTempWhitelistAppIdArray.length : 0;
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.print(mTempWhitelistAppIdArray[i]);
pw.println();
}
}
pw.print(""String_Node_Str"");
pw.print(mLightEnabled);
pw.print(""String_Node_Str"");
pw.println(mDeepEnabled);
pw.print(""String_Node_Str"");
pw.println(mForceIdle);
pw.print(""String_Node_Str"");
pw.println(mMotionSensor);
pw.print(""String_Node_Str"");
pw.println(mCurDisplay);
pw.print(""String_Node_Str"");
pw.println(mScreenOn);
pw.print(""String_Node_Str"");
pw.println(mNetworkConnected);
pw.print(""String_Node_Str"");
pw.println(mCharging);
pw.print(""String_Node_Str"");
pw.println(mMotionListener.active);
pw.print(""String_Node_Str"");
pw.println(mNotMoving);
pw.print(""String_Node_Str"");
pw.print(mLocating);
pw.print(""String_Node_Str"");
pw.print(mHasGps);
pw.print(""String_Node_Str"");
pw.print(mHasNetworkLocation);
pw.print(""String_Node_Str"");
pw.println(mLocated);
if (mLastGenericLocation != null) {
pw.print(""String_Node_Str"");
pw.println(mLastGenericLocation);
}
if (mLastGpsLocation != null) {
pw.print(""String_Node_Str"");
pw.println(mLastGpsLocation);
}
pw.print(""String_Node_Str"");
pw.print(stateToString(mState));
pw.print(""String_Node_Str"");
pw.println(lightStateToString(mLightState));
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mInactiveTimeout,pw);
pw.println();
if (mActiveIdleOpCount != 0) {
pw.print(""String_Node_Str"");
pw.println(mActiveIdleOpCount);
}
if (mNextAlarmTime != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mNextAlarmTime,SystemClock.elapsedRealtime(),pw);
pw.println();
}
if (mNextIdlePendingDelay != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mNextIdlePendingDelay,pw);
pw.println();
}
if (mNextIdleDelay != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mNextIdleDelay,pw);
pw.println();
}
if (mNextLightIdleDelay != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mNextLightIdleDelay,pw);
pw.println();
}
if (mNextLightAlarmTime != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mNextLightAlarmTime,SystemClock.elapsedRealtime(),pw);
pw.println();
}
if (mCurIdleBudget != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mCurIdleBudget,pw);
pw.println();
}
if (mMaintenanceStartTime != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mMaintenanceStartTime,SystemClock.elapsedRealtime(),pw);
pw.println();
}
if (mJobsActive) {
pw.print(""String_Node_Str"");
pw.println(mJobsActive);
}
if (mAlarmsActive) {
pw.print(""String_Node_Str"");
pw.println(mAlarmsActive);
}
if (mDownloadServiceActive != null) {
pw.print(""String_Node_Str"");
pw.println(mDownloadServiceActive);
}
}
}",0.9954156479217604
192224,"@Override public void stopJob(JobParameters jobParams){
  ensureHandler();
  Message m=Message.obtain(mHandler,MSG_STOP_JOB,jobParams);
  m.sendToTarget();
}","@Override public void stopJob(JobParameters jobParams) throws RemoteException {
  JobService service=mService.get();
  if (service != null) {
    service.ensureHandler();
    Message m=Message.obtain(service.mHandler,MSG_STOP_JOB,jobParams);
    m.sendToTarget();
  }
}",0.7230046948356808
192225,"@Override public void startJob(JobParameters jobParams){
  ensureHandler();
  Message m=Message.obtain(mHandler,MSG_EXECUTE_JOB,jobParams);
  m.sendToTarget();
}","@Override public void startJob(JobParameters jobParams) throws RemoteException {
  JobService service=mService.get();
  if (service != null) {
    service.ensureHandler();
    Message m=Message.obtain(service.mHandler,MSG_EXECUTE_JOB,jobParams);
    m.sendToTarget();
  }
}",0.728110599078341
192226,"/** 
 * @hide 
 */
public final IBinder onBind(Intent intent){
  return mBinder.asBinder();
}","/** 
 * @hide 
 */
public final IBinder onBind(Intent intent){
  if (mBinder == null) {
    mBinder=new JobInterface(this);
  }
  return mBinder.asBinder();
}",0.7410358565737052
192227,"public void cancelPeek(){
  if (mPeekAnimator != null) {
    mPeekAnimator.cancel();
  }
  removeCallbacks(mPeekRunnable);
  mPeekPending=false;
  notifyBarPanelExpansionChanged();
}","public void cancelPeek(){
  boolean cancelled=mPeekPending;
  if (mPeekAnimator != null) {
    cancelled=true;
    mPeekAnimator.cancel();
  }
  removeCallbacks(mPeekRunnable);
  mPeekPending=false;
  if (cancelled) {
    notifyBarPanelExpansionChanged();
  }
}",0.8216704288939052
192228,"@Override public void onTrackingStarted(){
  super.onTrackingStarted();
  mBar.onTrackingStarted();
  mScrimController.onTrackingStarted();
}","@Override public void onTrackingStarted(){
  super.onTrackingStarted();
  mBar.onTrackingStarted();
  mScrimController.onTrackingStarted();
  removePendingHideExpandedRunnables();
}",0.8757763975155279
192229,"@Override public void run(){
  mBar.makeExpandedInvisible();
}","@Override public void run(){
  if (mPanelFraction == 0.0f) {
    mBar.makeExpandedInvisible();
  }
}",0.7654320987654321
192230,"void dump(PrintWriter pw,String prefix,boolean dumpAll){
  final TaskStack stack=getStack();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(getDisplayId());
  if (stack != null) {
    pw.print(""String_Node_Str"");
    pw.print(stack.mStackId);
  }
  pw.print(""String_Node_Str"");
  pw.print(mSession);
  pw.print(""String_Node_Str"");
  pw.println(mClient.asBinder());
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mOwnerUid);
  pw.print(""String_Node_Str"");
  pw.print(mShowToOwnerOnly);
  pw.print(""String_Node_Str"");
  pw.print(mAttrs.packageName);
  pw.print(""String_Node_Str"");
  pw.println(AppOpsManager.opToName(mAppOp));
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(mAttrs);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mRequestedWidth);
  pw.print(""String_Node_Str"");
  pw.print(mRequestedHeight);
  pw.print(""String_Node_Str"");
  pw.println(mLayoutSeq);
  if (mRequestedWidth != mLastRequestedWidth || mRequestedHeight != mLastRequestedHeight) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(mLastRequestedWidth);
    pw.print(""String_Node_Str"");
    pw.println(mLastRequestedHeight);
  }
  if (isChildWindow() || mLayoutAttached) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(mAttachedWindow);
    pw.print(""String_Node_Str"");
    pw.println(mLayoutAttached);
  }
  if (mIsImWindow || mIsWallpaper || mIsFloatingLayer) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(mIsImWindow);
    pw.print(""String_Node_Str"");
    pw.print(mIsWallpaper);
    pw.print(""String_Node_Str"");
    pw.print(mIsFloatingLayer);
    pw.print(""String_Node_Str"");
    pw.println(mWallpaperVisible);
  }
  if (dumpAll) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(mBaseLayer);
    pw.print(""String_Node_Str"");
    pw.print(mSubLayer);
    pw.print(""String_Node_Str"");
    pw.print(mLayer);
    pw.print(""String_Node_Str"");
    pw.print((mTargetAppToken != null ? mTargetAppToken.mAppAnimator.animLayerAdjustment : (mAppToken != null ? mAppToken.mAppAnimator.animLayerAdjustment : 0)));
    pw.print(""String_Node_Str"");
    pw.print(mWinAnimator.mAnimLayer);
    pw.print(""String_Node_Str"");
    pw.println(mWinAnimator.mLastLayer);
  }
  if (dumpAll) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mToken);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mRootToken);
    if (mAppToken != null) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.print(mAppToken);
      pw.print(""String_Node_Str"");
      pw.print(isAnimatingWithSavedSurface());
      pw.print(""String_Node_Str"");
      pw.println(mAppDied);
    }
    if (mTargetAppToken != null) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(mTargetAppToken);
    }
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(Integer.toHexString(mViewVisibility));
    pw.print(""String_Node_Str"");
    pw.print(mHaveFrame);
    pw.print(""String_Node_Str"");
    pw.println(mObscured);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(mSeq);
    pw.print(""String_Node_Str"");
    pw.println(Integer.toHexString(mSystemUiVisibility));
  }
  if (!mPolicyVisibility || !mPolicyVisibilityAfterAnim || !mAppOpVisibility|| mAttachedHidden) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(mPolicyVisibility);
    pw.print(""String_Node_Str"");
    pw.print(mPolicyVisibilityAfterAnim);
    pw.print(""String_Node_Str"");
    pw.print(mAppOpVisibility);
    pw.print(""String_Node_Str"");
    pw.println(mAttachedHidden);
  }
  if (!mRelayoutCalled || mLayoutNeeded) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(mRelayoutCalled);
    pw.print(""String_Node_Str"");
    pw.println(mLayoutNeeded);
  }
  if (mXOffset != 0 || mYOffset != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(mXOffset);
    pw.print(""String_Node_Str"");
    pw.println(mYOffset);
  }
  if (dumpAll) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    mGivenContentInsets.printShortString(pw);
    pw.print(""String_Node_Str"");
    mGivenVisibleInsets.printShortString(pw);
    pw.println();
    if (mTouchableInsets != 0 || mGivenInsetsPending) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.print(mTouchableInsets);
      pw.print(""String_Node_Str"");
      pw.println(mGivenInsetsPending);
      Region region=new Region();
      getTouchableRegion(region);
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(region);
    }
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mConfiguration);
    if (mOverrideConfig != Configuration.EMPTY) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(mOverrideConfig);
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mHasSurface);
  pw.print(""String_Node_Str"");
  mShownPosition.printShortString(pw);
  pw.print(""String_Node_Str"");
  pw.print(isReadyForDisplay());
  pw.print(""String_Node_Str"");
  pw.print(hasSavedSurface());
  pw.print(""String_Node_Str"");
  pw.println(mWindowRemovalAllowed);
  if (dumpAll) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    mFrame.printShortString(pw);
    pw.print(""String_Node_Str"");
    mLastFrame.printShortString(pw);
    pw.println();
  }
  if (mEnforceSizeCompat) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    mCompatFrame.printShortString(pw);
    pw.println();
  }
  if (dumpAll) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    mContainingFrame.printShortString(pw);
    pw.print(""String_Node_Str"");
    mParentFrame.printShortString(pw);
    pw.println();
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    mDisplayFrame.printShortString(pw);
    pw.print(""String_Node_Str"");
    mOverscanFrame.printShortString(pw);
    pw.println();
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    mContentFrame.printShortString(pw);
    pw.print(""String_Node_Str"");
    mVisibleFrame.printShortString(pw);
    pw.println();
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    mDecorFrame.printShortString(pw);
    pw.println();
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    mOutsetFrame.printShortString(pw);
    pw.println();
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    mOverscanInsets.printShortString(pw);
    pw.print(""String_Node_Str"");
    mContentInsets.printShortString(pw);
    pw.print(""String_Node_Str"");
    mVisibleInsets.printShortString(pw);
    pw.print(""String_Node_Str"");
    mStableInsets.printShortString(pw);
    pw.print(""String_Node_Str"");
    mOutsets.printShortString(pw);
    pw.println();
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    mLastOverscanInsets.printShortString(pw);
    pw.print(""String_Node_Str"");
    mLastContentInsets.printShortString(pw);
    pw.print(""String_Node_Str"");
    mLastVisibleInsets.printShortString(pw);
    pw.print(""String_Node_Str"");
    mLastStableInsets.printShortString(pw);
    pw.print(""String_Node_Str"");
    mLastOutsets.printShortString(pw);
    pw.print(""String_Node_Str"");
    mLastOutsets.printShortString(pw);
    pw.println();
  }
  pw.print(prefix);
  pw.print(mWinAnimator);
  pw.println(""String_Node_Str"");
  mWinAnimator.dump(pw,prefix + ""String_Node_Str"",dumpAll);
  if (mAnimatingExit || mRemoveOnExit || mDestroying|| mRemoved) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(mAnimatingExit);
    pw.print(""String_Node_Str"");
    pw.print(mRemoveOnExit);
    pw.print(""String_Node_Str"");
    pw.print(mDestroying);
    pw.print(""String_Node_Str"");
    pw.println(mRemoved);
  }
  if (mOrientationChanging || mAppFreezing || mTurnOnScreen) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(mOrientationChanging);
    pw.print(""String_Node_Str"");
    pw.print(mAppFreezing);
    pw.print(""String_Node_Str"");
    pw.println(mTurnOnScreen);
  }
  if (mLastFreezeDuration != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(mLastFreezeDuration,pw);
    pw.println();
  }
  if (mHScale != 1 || mVScale != 1) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(mHScale);
    pw.print(""String_Node_Str"");
    pw.println(mVScale);
  }
  if (mWallpaperX != -1 || mWallpaperY != -1) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(mWallpaperX);
    pw.print(""String_Node_Str"");
    pw.println(mWallpaperY);
  }
  if (mWallpaperXStep != -1 || mWallpaperYStep != -1) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(mWallpaperXStep);
    pw.print(""String_Node_Str"");
    pw.println(mWallpaperYStep);
  }
  if (mWallpaperDisplayOffsetX != Integer.MIN_VALUE || mWallpaperDisplayOffsetY != Integer.MIN_VALUE) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(mWallpaperDisplayOffsetX);
    pw.print(""String_Node_Str"");
    pw.println(mWallpaperDisplayOffsetY);
  }
  if (mDrawLock != null) {
    pw.print(prefix);
    pw.println(""String_Node_Str"" + mDrawLock);
  }
  if (isDragResizing()) {
    pw.print(prefix);
    pw.println(""String_Node_Str"" + isDragResizing());
  }
  if (computeDragResizing()) {
    pw.print(prefix);
    pw.println(""String_Node_Str"" + computeDragResizing());
  }
}","void dump(PrintWriter pw,String prefix,boolean dumpAll){
  final TaskStack stack=getStack();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(getDisplayId());
  if (stack != null) {
    pw.print(""String_Node_Str"");
    pw.print(stack.mStackId);
  }
  pw.print(""String_Node_Str"");
  pw.print(mSession);
  pw.print(""String_Node_Str"");
  pw.println(mClient.asBinder());
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mOwnerUid);
  pw.print(""String_Node_Str"");
  pw.print(mShowToOwnerOnly);
  pw.print(""String_Node_Str"");
  pw.print(mAttrs.packageName);
  pw.print(""String_Node_Str"");
  pw.println(AppOpsManager.opToName(mAppOp));
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(mAttrs);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mRequestedWidth);
  pw.print(""String_Node_Str"");
  pw.print(mRequestedHeight);
  pw.print(""String_Node_Str"");
  pw.println(mLayoutSeq);
  if (mRequestedWidth != mLastRequestedWidth || mRequestedHeight != mLastRequestedHeight) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(mLastRequestedWidth);
    pw.print(""String_Node_Str"");
    pw.println(mLastRequestedHeight);
  }
  if (isChildWindow() || mLayoutAttached) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(mAttachedWindow);
    pw.print(""String_Node_Str"");
    pw.println(mLayoutAttached);
  }
  if (mIsImWindow || mIsWallpaper || mIsFloatingLayer) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(mIsImWindow);
    pw.print(""String_Node_Str"");
    pw.print(mIsWallpaper);
    pw.print(""String_Node_Str"");
    pw.print(mIsFloatingLayer);
    pw.print(""String_Node_Str"");
    pw.println(mWallpaperVisible);
  }
  if (dumpAll) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(mBaseLayer);
    pw.print(""String_Node_Str"");
    pw.print(mSubLayer);
    pw.print(""String_Node_Str"");
    pw.print(mLayer);
    pw.print(""String_Node_Str"");
    pw.print((mTargetAppToken != null ? mTargetAppToken.mAppAnimator.animLayerAdjustment : (mAppToken != null ? mAppToken.mAppAnimator.animLayerAdjustment : 0)));
    pw.print(""String_Node_Str"");
    pw.print(mWinAnimator.mAnimLayer);
    pw.print(""String_Node_Str"");
    pw.println(mWinAnimator.mLastLayer);
  }
  if (dumpAll) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mToken);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mRootToken);
    if (mAppToken != null) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(mAppToken);
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.print(isAnimatingWithSavedSurface());
      pw.print(""String_Node_Str"");
      pw.println(mAppDied);
    }
    if (mTargetAppToken != null) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(mTargetAppToken);
    }
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(Integer.toHexString(mViewVisibility));
    pw.print(""String_Node_Str"");
    pw.print(mHaveFrame);
    pw.print(""String_Node_Str"");
    pw.println(mObscured);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(mSeq);
    pw.print(""String_Node_Str"");
    pw.println(Integer.toHexString(mSystemUiVisibility));
  }
  if (!mPolicyVisibility || !mPolicyVisibilityAfterAnim || !mAppOpVisibility|| mAttachedHidden) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(mPolicyVisibility);
    pw.print(""String_Node_Str"");
    pw.print(mPolicyVisibilityAfterAnim);
    pw.print(""String_Node_Str"");
    pw.print(mAppOpVisibility);
    pw.print(""String_Node_Str"");
    pw.println(mAttachedHidden);
  }
  if (!mRelayoutCalled || mLayoutNeeded) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(mRelayoutCalled);
    pw.print(""String_Node_Str"");
    pw.println(mLayoutNeeded);
  }
  if (mXOffset != 0 || mYOffset != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(mXOffset);
    pw.print(""String_Node_Str"");
    pw.println(mYOffset);
  }
  if (dumpAll) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    mGivenContentInsets.printShortString(pw);
    pw.print(""String_Node_Str"");
    mGivenVisibleInsets.printShortString(pw);
    pw.println();
    if (mTouchableInsets != 0 || mGivenInsetsPending) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.print(mTouchableInsets);
      pw.print(""String_Node_Str"");
      pw.println(mGivenInsetsPending);
      Region region=new Region();
      getTouchableRegion(region);
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(region);
    }
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mConfiguration);
    if (mOverrideConfig != Configuration.EMPTY) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(mOverrideConfig);
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(mHasSurface);
  pw.print(""String_Node_Str"");
  mShownPosition.printShortString(pw);
  pw.print(""String_Node_Str"");
  pw.print(isReadyForDisplay());
  pw.print(""String_Node_Str"");
  pw.print(hasSavedSurface());
  pw.print(""String_Node_Str"");
  pw.println(mWindowRemovalAllowed);
  if (dumpAll) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    mFrame.printShortString(pw);
    pw.print(""String_Node_Str"");
    mLastFrame.printShortString(pw);
    pw.println();
  }
  if (mEnforceSizeCompat) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    mCompatFrame.printShortString(pw);
    pw.println();
  }
  if (dumpAll) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    mContainingFrame.printShortString(pw);
    pw.print(""String_Node_Str"");
    mParentFrame.printShortString(pw);
    pw.println();
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    mDisplayFrame.printShortString(pw);
    pw.print(""String_Node_Str"");
    mOverscanFrame.printShortString(pw);
    pw.println();
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    mContentFrame.printShortString(pw);
    pw.print(""String_Node_Str"");
    mVisibleFrame.printShortString(pw);
    pw.println();
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    mDecorFrame.printShortString(pw);
    pw.println();
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    mOutsetFrame.printShortString(pw);
    pw.println();
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    mOverscanInsets.printShortString(pw);
    pw.print(""String_Node_Str"");
    mContentInsets.printShortString(pw);
    pw.print(""String_Node_Str"");
    mVisibleInsets.printShortString(pw);
    pw.print(""String_Node_Str"");
    mStableInsets.printShortString(pw);
    pw.print(""String_Node_Str"");
    mAttrs.surfaceInsets.printShortString(pw);
    pw.print(""String_Node_Str"");
    mOutsets.printShortString(pw);
    pw.println();
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    mLastOverscanInsets.printShortString(pw);
    pw.print(""String_Node_Str"");
    mLastContentInsets.printShortString(pw);
    pw.print(""String_Node_Str"");
    mLastVisibleInsets.printShortString(pw);
    pw.print(""String_Node_Str"");
    mLastStableInsets.printShortString(pw);
    pw.print(""String_Node_Str"");
    mLastOutsets.printShortString(pw);
    pw.print(""String_Node_Str"");
    mLastOutsets.printShortString(pw);
    pw.println();
  }
  pw.print(prefix);
  pw.print(mWinAnimator);
  pw.println(""String_Node_Str"");
  mWinAnimator.dump(pw,prefix + ""String_Node_Str"",dumpAll);
  if (mAnimatingExit || mRemoveOnExit || mDestroying|| mRemoved) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(mAnimatingExit);
    pw.print(""String_Node_Str"");
    pw.print(mRemoveOnExit);
    pw.print(""String_Node_Str"");
    pw.print(mDestroying);
    pw.print(""String_Node_Str"");
    pw.println(mRemoved);
  }
  if (mOrientationChanging || mAppFreezing || mTurnOnScreen) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(mOrientationChanging);
    pw.print(""String_Node_Str"");
    pw.print(mAppFreezing);
    pw.print(""String_Node_Str"");
    pw.println(mTurnOnScreen);
  }
  if (mLastFreezeDuration != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    TimeUtils.formatDuration(mLastFreezeDuration,pw);
    pw.println();
  }
  if (mHScale != 1 || mVScale != 1) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(mHScale);
    pw.print(""String_Node_Str"");
    pw.println(mVScale);
  }
  if (mWallpaperX != -1 || mWallpaperY != -1) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(mWallpaperX);
    pw.print(""String_Node_Str"");
    pw.println(mWallpaperY);
  }
  if (mWallpaperXStep != -1 || mWallpaperYStep != -1) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(mWallpaperXStep);
    pw.print(""String_Node_Str"");
    pw.println(mWallpaperYStep);
  }
  if (mWallpaperDisplayOffsetX != Integer.MIN_VALUE || mWallpaperDisplayOffsetY != Integer.MIN_VALUE) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(mWallpaperDisplayOffsetX);
    pw.print(""String_Node_Str"");
    pw.println(mWallpaperDisplayOffsetY);
  }
  if (mDrawLock != null) {
    pw.print(prefix);
    pw.println(""String_Node_Str"" + mDrawLock);
  }
  if (isDragResizing()) {
    pw.print(prefix);
    pw.println(""String_Node_Str"" + isDragResizing());
  }
  if (computeDragResizing()) {
    pw.print(prefix);
    pw.println(""String_Node_Str"" + computeDragResizing());
  }
}",0.9943712829226848
192231,"private void adjustCropToStackBounds(WindowState w,Rect clipRect,Rect finalClipRect,boolean isFreeformResizing){
  final Task task=w.getTask();
  if (task == null || !task.cropWindowsToStackBounds()) {
    return;
  }
  final int stackClip=resolveStackClip();
  if (isAnimating() && stackClip == STACK_CLIP_NONE) {
    return;
  }
  final WindowState winShowWhenLocked=(WindowState)mPolicy.getWinShowWhenLockedLw();
  if (w == winShowWhenLocked) {
    return;
  }
  final TaskStack stack=task.mStack;
  stack.getDimBounds(mTmpStackBounds);
  final int frameX=isFreeformResizing ? (int)mSurfaceController.getX() : w.mFrame.left + mWin.mXOffset - w.getAttrs().surfaceInsets.left;
  final int frameY=isFreeformResizing ? (int)mSurfaceController.getY() : w.mFrame.top + mWin.mYOffset - w.getAttrs().surfaceInsets.top;
  final boolean useFinalClipRect=isAnimating() && stackClip == STACK_CLIP_AFTER_ANIM;
  if (useFinalClipRect) {
    finalClipRect.set(mTmpStackBounds);
  }
 else {
    clipRect.left=Math.max(0,Math.max(mTmpStackBounds.left,frameX + clipRect.left) - frameX);
    clipRect.top=Math.max(0,Math.max(mTmpStackBounds.top,frameY + clipRect.top) - frameY);
    clipRect.right=Math.max(0,Math.min(mTmpStackBounds.right,frameX + clipRect.right) - frameX);
    clipRect.bottom=Math.max(0,Math.min(mTmpStackBounds.bottom,frameY + clipRect.bottom) - frameY);
  }
}","private void adjustCropToStackBounds(WindowState w,Rect clipRect,Rect finalClipRect,boolean isFreeformResizing){
  final Task task=w.getTask();
  if (task == null || !task.cropWindowsToStackBounds()) {
    return;
  }
  final int stackClip=resolveStackClip();
  if (isAnimating() && stackClip == STACK_CLIP_NONE) {
    return;
  }
  final WindowState winShowWhenLocked=(WindowState)mPolicy.getWinShowWhenLockedLw();
  if (w == winShowWhenLocked) {
    return;
  }
  final TaskStack stack=task.mStack;
  stack.getDimBounds(mTmpStackBounds);
  final Rect surfaceInsets=w.getAttrs().surfaceInsets;
  final int frameX=isFreeformResizing ? (int)mSurfaceController.getX() : w.mFrame.left + mWin.mXOffset - surfaceInsets.left;
  final int frameY=isFreeformResizing ? (int)mSurfaceController.getY() : w.mFrame.top + mWin.mYOffset - surfaceInsets.top;
  final boolean useFinalClipRect=isAnimating() && stackClip == STACK_CLIP_AFTER_ANIM;
  if (useFinalClipRect) {
    finalClipRect.set(mTmpStackBounds);
  }
 else {
    if (StackId.hasWindowShadow(stack.mStackId) && !StackId.isTaskResizeAllowed(stack.mStackId)) {
      mTmpStackBounds.inset(-surfaceInsets.left,-surfaceInsets.top,-surfaceInsets.right,-surfaceInsets.bottom);
    }
    clipRect.left=Math.max(0,Math.max(mTmpStackBounds.left,frameX + clipRect.left) - frameX);
    clipRect.top=Math.max(0,Math.max(mTmpStackBounds.top,frameY + clipRect.top) - frameY);
    clipRect.right=Math.max(0,Math.min(mTmpStackBounds.right,frameX + clipRect.right) - frameX);
    clipRect.bottom=Math.max(0,Math.min(mTmpStackBounds.bottom,frameY + clipRect.bottom) - frameY);
  }
}",0.8998655913978495
192232,"void updateSurfaceWindowCrop(Rect clipRect,Rect finalClipRect,boolean recoveringMemory){
  if (!clipRect.equals(mLastClipRect)) {
    mLastClipRect.set(clipRect);
    mSurfaceController.setCropInTransaction(clipRect,recoveringMemory);
  }
  if (!finalClipRect.equals(mLastFinalClipRect)) {
    mLastFinalClipRect.set(finalClipRect);
    mSurfaceController.setFinalCropInTransaction(finalClipRect);
  }
}","void updateSurfaceWindowCrop(Rect clipRect,Rect finalClipRect,boolean recoveringMemory){
  if (DEBUG_WINDOW_CROP)   Slog.d(TAG,""String_Node_Str"" + mWin + ""String_Node_Str""+ clipRect+ ""String_Node_Str""+ finalClipRect);
  if (!clipRect.equals(mLastClipRect)) {
    mLastClipRect.set(clipRect);
    mSurfaceController.setCropInTransaction(clipRect,recoveringMemory);
  }
  if (!finalClipRect.equals(mLastFinalClipRect)) {
    mLastFinalClipRect.set(finalClipRect);
    mSurfaceController.setFinalCropInTransaction(finalClipRect);
  }
}",0.8620320855614974
192233,"void setSurfaceBoundariesLocked(final boolean recoveringMemory){
  final WindowState w=mWin;
  final Task task=w.getTask();
  if (w.mResizedWhileNotDragResizing) {
    return;
  }
  mTmpSize.set(w.mShownPosition.x,w.mShownPosition.y,0,0);
  calculateSurfaceBounds(w,w.getAttrs());
  float extraHScale=(float)1.0;
  float extraVScale=(float)1.0;
  calculateSurfaceWindowCrop(mTmpClipRect,mTmpFinalClipRect);
  if (task != null && task.mStack.getForceScaleToCrop()) {
    extraHScale=mTmpClipRect.width() / (float)mTmpSize.width();
    extraVScale=mTmpClipRect.height() / (float)mTmpSize.height();
    int posX=(int)(mTmpSize.left - w.mAttrs.x * (1 - extraHScale));
    int posY=(int)(mTmpSize.top - w.mAttrs.y * (1 - extraVScale));
    posX+=w.getAttrs().surfaceInsets.left * (1 - extraHScale);
    posY+=w.getAttrs().surfaceInsets.top * (1 - extraVScale);
    mSurfaceController.setPositionInTransaction(posX,posY,recoveringMemory);
    mTmpClipRect.set(0,0,mTmpSize.width(),mTmpSize.height());
    mTmpFinalClipRect.setEmpty();
    updateSurfaceWindowCrop(mTmpClipRect,mTmpFinalClipRect,recoveringMemory);
  }
 else {
    mSurfaceController.setPositionInTransaction(mTmpSize.left,mTmpSize.top,recoveringMemory);
    updateSurfaceWindowCrop(mTmpClipRect,mTmpFinalClipRect,recoveringMemory);
  }
  mSurfaceController.setMatrixInTransaction(mDsDx * w.mHScale * extraHScale,mDtDx * w.mVScale * extraVScale,mDsDy * w.mHScale * extraHScale,mDtDy * w.mVScale * extraVScale,recoveringMemory);
  mSurfaceResized=mSurfaceController.setSizeInTransaction(mTmpSize.width(),mTmpSize.height(),recoveringMemory);
  if (mSurfaceResized) {
    mReportSurfaceResized=true;
    mAnimator.setPendingLayoutChanges(w.getDisplayId(),WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER);
    w.applyDimLayerIfNeeded();
  }
}","void setSurfaceBoundariesLocked(final boolean recoveringMemory){
  final WindowState w=mWin;
  final Task task=w.getTask();
  if (w.mResizedWhileNotDragResizing) {
    return;
  }
  mTmpSize.set(w.mShownPosition.x,w.mShownPosition.y,0,0);
  calculateSurfaceBounds(w,w.getAttrs());
  float extraHScale=(float)1.0;
  float extraVScale=(float)1.0;
  calculateSurfaceWindowCrop(mTmpClipRect,mTmpFinalClipRect);
  if (task != null && task.mStack.getForceScaleToCrop()) {
    extraHScale=mTmpClipRect.width() / (float)mTmpSize.width();
    extraVScale=mTmpClipRect.height() / (float)mTmpSize.height();
    int posX=(int)(mTmpSize.left - w.mAttrs.x * (1 - extraHScale));
    int posY=(int)(mTmpSize.top - w.mAttrs.y * (1 - extraVScale));
    posX+=w.getAttrs().surfaceInsets.left * (1 - extraHScale);
    posY+=w.getAttrs().surfaceInsets.top * (1 - extraVScale);
    mSurfaceController.setPositionInTransaction(posX,posY,recoveringMemory);
    mTmpClipRect.set(0,0,mTmpSize.width(),mTmpSize.height());
    mTmpFinalClipRect.setEmpty();
  }
 else {
    mSurfaceController.setPositionInTransaction(mTmpSize.left,mTmpSize.top,recoveringMemory);
  }
  updateSurfaceWindowCrop(mTmpClipRect,mTmpFinalClipRect,recoveringMemory);
  mSurfaceController.setMatrixInTransaction(mDsDx * w.mHScale * extraHScale,mDtDx * w.mVScale * extraVScale,mDsDy * w.mHScale * extraHScale,mDtDy * w.mVScale * extraVScale,recoveringMemory);
  mSurfaceResized=mSurfaceController.setSizeInTransaction(mTmpSize.width(),mTmpSize.height(),recoveringMemory);
  if (mSurfaceResized) {
    mReportSurfaceResized=true;
    mAnimator.setPendingLayoutChanges(w.getDisplayId(),WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER);
    w.applyDimLayerIfNeeded();
  }
}",0.9157655093910074
192234,"public void dump(PrintWriter pw,String prefix,boolean dumpAll){
  if (mAnimating || mLocalAnimating || mAnimationIsEntrance|| mAnimation != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(mAnimating);
    pw.print(""String_Node_Str"");
    pw.print(mLocalAnimating);
    pw.print(""String_Node_Str"");
    pw.print(mAnimationIsEntrance);
    pw.print(""String_Node_Str"");
    pw.println(mAnimation);
    pw.print(""String_Node_Str"");
    pw.println(mStackClip);
  }
  if (mHasTransformation || mHasLocalTransformation) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(mHasTransformation);
    pw.print(""String_Node_Str"");
    pw.print(mHasLocalTransformation);
    pw.print(""String_Node_Str"");
    mTransformation.printShortString(pw);
    pw.println();
  }
  if (mSurfaceController != null) {
    mSurfaceController.dump(pw,prefix,dumpAll);
  }
  if (dumpAll) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(drawStateToString());
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mLastHidden);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    mSystemDecorRect.printShortString(pw);
    pw.print(""String_Node_Str"");
    mLastSystemDecorRect.printShortString(pw);
    if (mHasClipRect) {
      pw.print(""String_Node_Str"");
      mLastClipRect.printShortString(pw);
    }
    if (!mLastFinalClipRect.isEmpty()) {
      pw.print(""String_Node_Str"");
      mLastFinalClipRect.printShortString(pw);
    }
    pw.println();
  }
  if (mPendingDestroySurface != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mPendingDestroySurface);
  }
  if (mSurfaceResized || mSurfaceDestroyDeferred) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(mSurfaceResized);
    pw.print(""String_Node_Str"");
    pw.println(mSurfaceDestroyDeferred);
  }
  if (mShownAlpha != 1 || mAlpha != 1 || mLastAlpha != 1) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(mShownAlpha);
    pw.print(""String_Node_Str"");
    pw.print(mAlpha);
    pw.print(""String_Node_Str"");
    pw.println(mLastAlpha);
  }
  if (mHaveMatrix || mWin.mGlobalScale != 1) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(mWin.mGlobalScale);
    pw.print(""String_Node_Str"");
    pw.print(mDsDx);
    pw.print(""String_Node_Str"");
    pw.print(mDtDx);
    pw.print(""String_Node_Str"");
    pw.print(mDsDy);
    pw.print(""String_Node_Str"");
    pw.println(mDtDy);
  }
}","public void dump(PrintWriter pw,String prefix,boolean dumpAll){
  if (mAnimating || mLocalAnimating || mAnimationIsEntrance|| mAnimation != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(mAnimating);
    pw.print(""String_Node_Str"");
    pw.print(mLocalAnimating);
    pw.print(""String_Node_Str"");
    pw.print(mAnimationIsEntrance);
    pw.print(""String_Node_Str"");
    pw.print(mAnimation);
    pw.print(""String_Node_Str"");
    pw.println(mStackClip);
  }
  if (mHasTransformation || mHasLocalTransformation) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(mHasTransformation);
    pw.print(""String_Node_Str"");
    pw.print(mHasLocalTransformation);
    pw.print(""String_Node_Str"");
    mTransformation.printShortString(pw);
    pw.println();
  }
  if (mSurfaceController != null) {
    mSurfaceController.dump(pw,prefix,dumpAll);
  }
  if (dumpAll) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(drawStateToString());
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mLastHidden);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    mSystemDecorRect.printShortString(pw);
    pw.print(""String_Node_Str"");
    mLastSystemDecorRect.printShortString(pw);
    pw.print(""String_Node_Str"");
    pw.print(mHasClipRect);
    pw.print(""String_Node_Str"");
    mLastClipRect.printShortString(pw);
    if (!mLastFinalClipRect.isEmpty()) {
      pw.print(""String_Node_Str"");
      mLastFinalClipRect.printShortString(pw);
    }
    pw.println();
  }
  if (mPendingDestroySurface != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(mPendingDestroySurface);
  }
  if (mSurfaceResized || mSurfaceDestroyDeferred) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(mSurfaceResized);
    pw.print(""String_Node_Str"");
    pw.println(mSurfaceDestroyDeferred);
  }
  if (mShownAlpha != 1 || mAlpha != 1 || mLastAlpha != 1) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(mShownAlpha);
    pw.print(""String_Node_Str"");
    pw.print(mAlpha);
    pw.print(""String_Node_Str"");
    pw.println(mLastAlpha);
  }
  if (mHaveMatrix || mWin.mGlobalScale != 1) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(mWin.mGlobalScale);
    pw.print(""String_Node_Str"");
    pw.print(mDsDx);
    pw.print(""String_Node_Str"");
    pw.print(mDtDx);
    pw.print(""String_Node_Str"");
    pw.print(mDsDy);
    pw.print(""String_Node_Str"");
    pw.println(mDtDy);
  }
}",0.98781705612143
192235,"void calculateSurfaceWindowCrop(Rect clipRect,Rect finalClipRect){
  final WindowState w=mWin;
  final DisplayContent displayContent=w.getDisplayContent();
  if (displayContent == null) {
    clipRect.setEmpty();
    finalClipRect.setEmpty();
    return;
  }
  final DisplayInfo displayInfo=displayContent.getDisplayInfo();
  if (DEBUG_WINDOW_CROP)   Slog.d(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ ""String_Node_Str""+ mLastClipRect);
  if (!w.isDefaultDisplay()) {
    mSystemDecorRect.set(0,0,w.mCompatFrame.width(),w.mCompatFrame.height());
    mSystemDecorRect.intersect(-w.mCompatFrame.left,-w.mCompatFrame.top,displayInfo.logicalWidth - w.mCompatFrame.left,displayInfo.logicalHeight - w.mCompatFrame.top);
  }
 else   if (w.mLayer >= mService.mSystemDecorLayer) {
    mSystemDecorRect.set(0,0,w.mCompatFrame.width(),w.mCompatFrame.height());
  }
 else   if (w.mDecorFrame.isEmpty()) {
    mSystemDecorRect.set(0,0,w.mCompatFrame.width(),w.mCompatFrame.height());
  }
 else   if (w.mAttrs.type == LayoutParams.TYPE_WALLPAPER && mAnimator.isAnimating()) {
    mTmpClipRect.set(mSystemDecorRect);
    calculateSystemDecorRect();
    mSystemDecorRect.union(mTmpClipRect);
  }
 else {
    calculateSystemDecorRect();
    if (DEBUG_WINDOW_CROP)     Slog.d(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mDecorFrame+ ""String_Node_Str""+ mSystemDecorRect);
  }
  final boolean fullscreen=w.isFrameFullscreen(displayInfo);
  final boolean isFreeformResizing=w.isDragResizing() && w.getResizeMode() == DRAG_RESIZE_MODE_FREEFORM;
  clipRect.set((mHasClipRect && !fullscreen) ? mClipRect : mSystemDecorRect);
  if (DEBUG_WINDOW_CROP)   Slog.d(TAG,""String_Node_Str"" + clipRect + ""String_Node_Str""+ mHasClipRect+ ""String_Node_Str""+ fullscreen);
  if (isFreeformResizing && !w.isChildWindow()) {
    clipRect.offset(w.mShownPosition.x,w.mShownPosition.y);
  }
  final WindowManager.LayoutParams attrs=w.mAttrs;
  clipRect.left-=attrs.surfaceInsets.left;
  clipRect.top-=attrs.surfaceInsets.top;
  clipRect.right+=attrs.surfaceInsets.right;
  clipRect.bottom+=attrs.surfaceInsets.bottom;
  if (mHasClipRect && fullscreen) {
    clipRect.intersect(mClipRect);
  }
  clipRect.offset(attrs.surfaceInsets.left,attrs.surfaceInsets.top);
  finalClipRect.setEmpty();
  adjustCropToStackBounds(w,clipRect,finalClipRect,isFreeformResizing);
  if (DEBUG_WINDOW_CROP)   Slog.d(TAG,""String_Node_Str"" + clipRect);
  w.transformFromScreenToSurfaceSpace(clipRect);
  if (w.hasJustMovedInStack() && mLastClipRect.isEmpty() && !clipRect.isEmpty()) {
    clipRect.setEmpty();
  }
}","void calculateSurfaceWindowCrop(Rect clipRect,Rect finalClipRect){
  final WindowState w=mWin;
  final DisplayContent displayContent=w.getDisplayContent();
  if (displayContent == null) {
    clipRect.setEmpty();
    finalClipRect.setEmpty();
    return;
  }
  final DisplayInfo displayInfo=displayContent.getDisplayInfo();
  if (DEBUG_WINDOW_CROP)   Slog.d(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ mLastClipRect);
  if (!w.isDefaultDisplay()) {
    mSystemDecorRect.set(0,0,w.mCompatFrame.width(),w.mCompatFrame.height());
    mSystemDecorRect.intersect(-w.mCompatFrame.left,-w.mCompatFrame.top,displayInfo.logicalWidth - w.mCompatFrame.left,displayInfo.logicalHeight - w.mCompatFrame.top);
  }
 else   if (w.mLayer >= mService.mSystemDecorLayer) {
    mSystemDecorRect.set(0,0,w.mCompatFrame.width(),w.mCompatFrame.height());
  }
 else   if (w.mDecorFrame.isEmpty()) {
    mSystemDecorRect.set(0,0,w.mCompatFrame.width(),w.mCompatFrame.height());
  }
 else   if (w.mAttrs.type == LayoutParams.TYPE_WALLPAPER && mAnimator.isAnimating()) {
    mTmpClipRect.set(mSystemDecorRect);
    calculateSystemDecorRect();
    mSystemDecorRect.union(mTmpClipRect);
  }
 else {
    calculateSystemDecorRect();
    if (DEBUG_WINDOW_CROP)     Slog.d(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ w.mDecorFrame+ ""String_Node_Str""+ mSystemDecorRect);
  }
  final boolean fullscreen=w.isFrameFullscreen(displayInfo);
  final boolean isFreeformResizing=w.isDragResizing() && w.getResizeMode() == DRAG_RESIZE_MODE_FREEFORM;
  clipRect.set((mHasClipRect && !fullscreen) ? mClipRect : mSystemDecorRect);
  if (DEBUG_WINDOW_CROP)   Slog.d(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ clipRect+ ""String_Node_Str""+ mHasClipRect+ ""String_Node_Str""+ fullscreen);
  if (isFreeformResizing && !w.isChildWindow()) {
    clipRect.offset(w.mShownPosition.x,w.mShownPosition.y);
  }
  final WindowManager.LayoutParams attrs=w.mAttrs;
  clipRect.left-=attrs.surfaceInsets.left;
  clipRect.top-=attrs.surfaceInsets.top;
  clipRect.right+=attrs.surfaceInsets.right;
  clipRect.bottom+=attrs.surfaceInsets.bottom;
  if (mHasClipRect && fullscreen) {
    clipRect.intersect(mClipRect);
  }
  clipRect.offset(attrs.surfaceInsets.left,attrs.surfaceInsets.top);
  finalClipRect.setEmpty();
  adjustCropToStackBounds(w,clipRect,finalClipRect,isFreeformResizing);
  if (DEBUG_WINDOW_CROP)   Slog.d(TAG,""String_Node_Str"" + w + ""String_Node_Str""+ clipRect);
  w.transformFromScreenToSurfaceSpace(clipRect);
  if (w.hasJustMovedInStack() && mLastClipRect.isEmpty() && !clipRect.isEmpty()) {
    clipRect.setEmpty();
  }
}",0.9840590979782272
192236,"public void cancelPeek(){
  if (mPeekAnimator != null) {
    mPeekAnimator.cancel();
  }
  removeCallbacks(mPeekRunnable);
  mPeekPending=false;
  notifyBarPanelExpansionChanged();
}","public void cancelPeek(){
  boolean cancelled=mPeekPending;
  if (mPeekAnimator != null) {
    cancelled=true;
    mPeekAnimator.cancel();
  }
  removeCallbacks(mPeekRunnable);
  mPeekPending=false;
  if (cancelled) {
    notifyBarPanelExpansionChanged();
  }
}",0.8216704288939052
192237,"@Override public void onTrackingStarted(){
  super.onTrackingStarted();
  mBar.onTrackingStarted();
  mScrimController.onTrackingStarted();
}","@Override public void onTrackingStarted(){
  super.onTrackingStarted();
  mBar.onTrackingStarted();
  mScrimController.onTrackingStarted();
  removePendingHideExpandedRunnables();
}",0.8757763975155279
192238,"@Override public void run(){
  mBar.makeExpandedInvisible();
}","@Override public void run(){
  if (mPanelFraction == 0.0f) {
    mBar.makeExpandedInvisible();
  }
}",0.7654320987654321
192239,"/** 
 * Sends a notification indicating the bugreport has finished so use can share it.
 */
private static void sendBugreportNotification(Context context,BugreportInfo info,boolean takingScreenshot){
  addDetailsToZipFile(context,info);
  final Intent shareIntent=new Intent(INTENT_BUGREPORT_SHARE);
  shareIntent.setClass(context,BugreportProgressService.class);
  shareIntent.setAction(INTENT_BUGREPORT_SHARE);
  shareIntent.putExtra(EXTRA_ID,info.id);
  shareIntent.putExtra(EXTRA_INFO,info);
  final String title, content;
  if (takingScreenshot) {
    title=context.getString(R.string.bugreport_finished_pending_screenshot_title,info.id);
    content=context.getString(R.string.bugreport_finished_pending_screenshot_text);
  }
 else {
    title=context.getString(R.string.bugreport_finished_title,info.id);
    content=context.getString(R.string.bugreport_finished_text);
  }
  final Notification.Builder builder=newBaseNotification(context).setContentTitle(title).setTicker(title).setContentText(content).setContentIntent(PendingIntent.getService(context,info.id,shareIntent,PendingIntent.FLAG_UPDATE_CURRENT)).setDeleteIntent(newCancelIntent(context,info));
  if (!TextUtils.isEmpty(info.name)) {
    builder.setContentInfo(info.name);
  }
  Log.v(TAG,""String_Node_Str"" + info.id + ""String_Node_Str""+ title);
  NotificationManager.from(context).notify(TAG,info.id,builder.build());
}","/** 
 * Sends a notification indicating the bugreport has finished so use can share it.
 */
private static void sendBugreportNotification(Context context,BugreportInfo info,boolean takingScreenshot){
  addDetailsToZipFile(context,info);
  final Intent shareIntent=new Intent(INTENT_BUGREPORT_SHARE);
  shareIntent.setClass(context,BugreportProgressService.class);
  shareIntent.setAction(INTENT_BUGREPORT_SHARE);
  shareIntent.putExtra(EXTRA_ID,info.id);
  shareIntent.putExtra(EXTRA_INFO,info);
  final String title, content;
  if (takingScreenshot) {
    title=context.getString(R.string.bugreport_finished_pending_screenshot_title,info.id);
    content=context.getString(R.string.bugreport_finished_pending_screenshot_text);
  }
 else {
    title=context.getString(R.string.bugreport_finished_title,info.id);
    content=context.getString(R.string.bugreport_finished_text);
  }
  final Notification.Builder builder=newBaseNotification(context).setContentTitle(title).setTicker(title).setContentText(content).setContentIntent(PendingIntent.getService(context,info.id,shareIntent,PendingIntent.FLAG_UPDATE_CURRENT)).setDeleteIntent(newCancelIntent(context,info));
  if (!TextUtils.isEmpty(info.name)) {
    builder.setSubText(info.name);
  }
  Log.v(TAG,""String_Node_Str"" + info.id + ""String_Node_Str""+ title);
  NotificationManager.from(context).notify(TAG,info.id,builder.build());
}",0.9935158501440924
192240,"/** 
 * Updates the system notification for a given bugreport.
 */
private void updateProgress(BugreportInfo info){
  if (info.max <= 0 || info.progress < 0) {
    Log.e(TAG,""String_Node_Str"" + info);
    return;
  }
  final NumberFormat nf=NumberFormat.getPercentInstance();
  nf.setMinimumFractionDigits(2);
  nf.setMaximumFractionDigits(2);
  final String percentageText=nf.format((double)info.progress / info.max);
  final Action cancelAction=new Action.Builder(null,mContext.getString(com.android.internal.R.string.cancel),newCancelIntent(mContext,info)).build();
  final Intent infoIntent=new Intent(mContext,BugreportProgressService.class);
  infoIntent.setAction(INTENT_BUGREPORT_INFO_LAUNCH);
  infoIntent.putExtra(EXTRA_ID,info.id);
  final PendingIntent infoPendingIntent=PendingIntent.getService(mContext,info.id,infoIntent,PendingIntent.FLAG_UPDATE_CURRENT);
  final Action infoAction=new Action.Builder(null,mContext.getString(R.string.bugreport_info_action),infoPendingIntent).build();
  final Intent screenshotIntent=new Intent(mContext,BugreportProgressService.class);
  screenshotIntent.setAction(INTENT_BUGREPORT_SCREENSHOT);
  screenshotIntent.putExtra(EXTRA_ID,info.id);
  PendingIntent screenshotPendingIntent=mTakingScreenshot ? null : PendingIntent.getService(mContext,info.id,screenshotIntent,PendingIntent.FLAG_UPDATE_CURRENT);
  final Action screenshotAction=new Action.Builder(null,mContext.getString(R.string.bugreport_screenshot_action),screenshotPendingIntent).build();
  final String title=mContext.getString(R.string.bugreport_in_progress_title,info.id);
  final String name=info.name != null ? info.name : mContext.getString(R.string.bugreport_unnamed);
  final Notification notification=newBaseNotification(mContext).setContentTitle(title).setTicker(title).setContentText(name).setContentInfo(percentageText).setProgress(info.max,info.progress,false).setOngoing(true).setContentIntent(infoPendingIntent).setActions(infoAction,screenshotAction,cancelAction).build();
  if (info.finished) {
    Log.w(TAG,""String_Node_Str"" + info + ""String_Node_Str"");
    return;
  }
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + info.id + ""String_Node_Str""+ info.pid+ ""String_Node_Str""+ percentageText);
  }
  NotificationManager.from(mContext).notify(TAG,info.id,notification);
}","/** 
 * Updates the system notification for a given bugreport.
 */
private void updateProgress(BugreportInfo info){
  if (info.max <= 0 || info.progress < 0) {
    Log.e(TAG,""String_Node_Str"" + info);
    return;
  }
  final NumberFormat nf=NumberFormat.getPercentInstance();
  nf.setMinimumFractionDigits(2);
  nf.setMaximumFractionDigits(2);
  final String percentageText=nf.format((double)info.progress / info.max);
  final Action cancelAction=new Action.Builder(null,mContext.getString(com.android.internal.R.string.cancel),newCancelIntent(mContext,info)).build();
  final Intent infoIntent=new Intent(mContext,BugreportProgressService.class);
  infoIntent.setAction(INTENT_BUGREPORT_INFO_LAUNCH);
  infoIntent.putExtra(EXTRA_ID,info.id);
  final PendingIntent infoPendingIntent=PendingIntent.getService(mContext,info.id,infoIntent,PendingIntent.FLAG_UPDATE_CURRENT);
  final Action infoAction=new Action.Builder(null,mContext.getString(R.string.bugreport_info_action),infoPendingIntent).build();
  final Intent screenshotIntent=new Intent(mContext,BugreportProgressService.class);
  screenshotIntent.setAction(INTENT_BUGREPORT_SCREENSHOT);
  screenshotIntent.putExtra(EXTRA_ID,info.id);
  PendingIntent screenshotPendingIntent=mTakingScreenshot ? null : PendingIntent.getService(mContext,info.id,screenshotIntent,PendingIntent.FLAG_UPDATE_CURRENT);
  final Action screenshotAction=new Action.Builder(null,mContext.getString(R.string.bugreport_screenshot_action),screenshotPendingIntent).build();
  final String title=mContext.getString(R.string.bugreport_in_progress_title,info.id);
  final String name=info.name != null ? info.name : mContext.getString(R.string.bugreport_unnamed);
  final Notification notification=newBaseNotification(mContext).setContentTitle(title).setTicker(title).setContentText(name).setProgress(info.max,info.progress,false).setOngoing(true).setContentIntent(infoPendingIntent).setActions(infoAction,screenshotAction,cancelAction).build();
  if (info.finished) {
    Log.w(TAG,""String_Node_Str"" + info + ""String_Node_Str"");
    return;
  }
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + info.id + ""String_Node_Str""+ info.pid+ ""String_Node_Str""+ percentageText);
  }
  NotificationManager.from(mContext).notify(TAG,info.id,notification);
}",0.993218114198206
192241,"/** 
 * Sends a notification indicating the bugreport has finished so use can share it.
 */
private static void sendBugreportNotification(Context context,BugreportInfo info,boolean takingScreenshot){
  addDetailsToZipFile(context,info);
  final Intent shareIntent=new Intent(INTENT_BUGREPORT_SHARE);
  shareIntent.setClass(context,BugreportProgressService.class);
  shareIntent.setAction(INTENT_BUGREPORT_SHARE);
  shareIntent.putExtra(EXTRA_ID,info.id);
  shareIntent.putExtra(EXTRA_INFO,info);
  final String title, content;
  if (takingScreenshot) {
    title=context.getString(R.string.bugreport_finished_pending_screenshot_title,info.id);
    content=context.getString(R.string.bugreport_finished_pending_screenshot_text);
  }
 else {
    title=context.getString(R.string.bugreport_finished_title,info.id);
    content=context.getString(R.string.bugreport_finished_text);
  }
  final Notification.Builder builder=newBaseNotification(context).setContentTitle(title).setTicker(title).setContentText(content).setContentIntent(PendingIntent.getService(context,info.id,shareIntent,PendingIntent.FLAG_UPDATE_CURRENT)).setDeleteIntent(newCancelIntent(context,info));
  if (!TextUtils.isEmpty(info.name)) {
    builder.setContentInfo(info.name);
  }
  Log.v(TAG,""String_Node_Str"" + info.id + ""String_Node_Str""+ title);
  NotificationManager.from(context).notify(TAG,info.id,builder.build());
}","/** 
 * Sends a notification indicating the bugreport has finished so use can share it.
 */
private static void sendBugreportNotification(Context context,BugreportInfo info,boolean takingScreenshot){
  addDetailsToZipFile(context,info);
  final Intent shareIntent=new Intent(INTENT_BUGREPORT_SHARE);
  shareIntent.setClass(context,BugreportProgressService.class);
  shareIntent.setAction(INTENT_BUGREPORT_SHARE);
  shareIntent.putExtra(EXTRA_ID,info.id);
  shareIntent.putExtra(EXTRA_INFO,info);
  final String title, content;
  if (takingScreenshot) {
    title=context.getString(R.string.bugreport_finished_pending_screenshot_title,info.id);
    content=context.getString(R.string.bugreport_finished_pending_screenshot_text);
  }
 else {
    title=context.getString(R.string.bugreport_finished_title,info.id);
    content=context.getString(R.string.bugreport_finished_text);
  }
  final Notification.Builder builder=newBaseNotification(context).setContentTitle(title).setTicker(title).setContentText(content).setContentIntent(PendingIntent.getService(context,info.id,shareIntent,PendingIntent.FLAG_UPDATE_CURRENT)).setDeleteIntent(newCancelIntent(context,info));
  if (!TextUtils.isEmpty(info.name)) {
    builder.setSubText(info.name);
  }
  Log.v(TAG,""String_Node_Str"" + info.id + ""String_Node_Str""+ title);
  NotificationManager.from(context).notify(TAG,info.id,builder.build());
}",0.9935158501440924
192242,"/** 
 * Updates the system notification for a given bugreport.
 */
private void updateProgress(BugreportInfo info){
  if (info.max <= 0 || info.progress < 0) {
    Log.e(TAG,""String_Node_Str"" + info);
    return;
  }
  final NumberFormat nf=NumberFormat.getPercentInstance();
  nf.setMinimumFractionDigits(2);
  nf.setMaximumFractionDigits(2);
  final String percentageText=nf.format((double)info.progress / info.max);
  final Action cancelAction=new Action.Builder(null,mContext.getString(com.android.internal.R.string.cancel),newCancelIntent(mContext,info)).build();
  final Intent infoIntent=new Intent(mContext,BugreportProgressService.class);
  infoIntent.setAction(INTENT_BUGREPORT_INFO_LAUNCH);
  infoIntent.putExtra(EXTRA_ID,info.id);
  final PendingIntent infoPendingIntent=PendingIntent.getService(mContext,info.id,infoIntent,PendingIntent.FLAG_UPDATE_CURRENT);
  final Action infoAction=new Action.Builder(null,mContext.getString(R.string.bugreport_info_action),infoPendingIntent).build();
  final Intent screenshotIntent=new Intent(mContext,BugreportProgressService.class);
  screenshotIntent.setAction(INTENT_BUGREPORT_SCREENSHOT);
  screenshotIntent.putExtra(EXTRA_ID,info.id);
  PendingIntent screenshotPendingIntent=mTakingScreenshot ? null : PendingIntent.getService(mContext,info.id,screenshotIntent,PendingIntent.FLAG_UPDATE_CURRENT);
  final Action screenshotAction=new Action.Builder(null,mContext.getString(R.string.bugreport_screenshot_action),screenshotPendingIntent).build();
  final String title=mContext.getString(R.string.bugreport_in_progress_title,info.id);
  final String name=info.name != null ? info.name : mContext.getString(R.string.bugreport_unnamed);
  final Notification notification=newBaseNotification(mContext).setContentTitle(title).setTicker(title).setContentText(name).setContentInfo(percentageText).setProgress(info.max,info.progress,false).setOngoing(true).setContentIntent(infoPendingIntent).setActions(infoAction,screenshotAction,cancelAction).build();
  if (info.finished) {
    Log.w(TAG,""String_Node_Str"" + info + ""String_Node_Str"");
    return;
  }
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + info.id + ""String_Node_Str""+ info.pid+ ""String_Node_Str""+ percentageText);
  }
  NotificationManager.from(mContext).notify(TAG,info.id,notification);
}","/** 
 * Updates the system notification for a given bugreport.
 */
private void updateProgress(BugreportInfo info){
  if (info.max <= 0 || info.progress < 0) {
    Log.e(TAG,""String_Node_Str"" + info);
    return;
  }
  final NumberFormat nf=NumberFormat.getPercentInstance();
  nf.setMinimumFractionDigits(2);
  nf.setMaximumFractionDigits(2);
  final String percentageText=nf.format((double)info.progress / info.max);
  final Action cancelAction=new Action.Builder(null,mContext.getString(com.android.internal.R.string.cancel),newCancelIntent(mContext,info)).build();
  final Intent infoIntent=new Intent(mContext,BugreportProgressService.class);
  infoIntent.setAction(INTENT_BUGREPORT_INFO_LAUNCH);
  infoIntent.putExtra(EXTRA_ID,info.id);
  final PendingIntent infoPendingIntent=PendingIntent.getService(mContext,info.id,infoIntent,PendingIntent.FLAG_UPDATE_CURRENT);
  final Action infoAction=new Action.Builder(null,mContext.getString(R.string.bugreport_info_action),infoPendingIntent).build();
  final Intent screenshotIntent=new Intent(mContext,BugreportProgressService.class);
  screenshotIntent.setAction(INTENT_BUGREPORT_SCREENSHOT);
  screenshotIntent.putExtra(EXTRA_ID,info.id);
  PendingIntent screenshotPendingIntent=mTakingScreenshot ? null : PendingIntent.getService(mContext,info.id,screenshotIntent,PendingIntent.FLAG_UPDATE_CURRENT);
  final Action screenshotAction=new Action.Builder(null,mContext.getString(R.string.bugreport_screenshot_action),screenshotPendingIntent).build();
  final String title=mContext.getString(R.string.bugreport_in_progress_title,info.id);
  final String name=info.name != null ? info.name : mContext.getString(R.string.bugreport_unnamed);
  final Notification notification=newBaseNotification(mContext).setContentTitle(title).setTicker(title).setContentText(name).setProgress(info.max,info.progress,false).setOngoing(true).setContentIntent(infoPendingIntent).setActions(infoAction,screenshotAction,cancelAction).build();
  if (info.finished) {
    Log.w(TAG,""String_Node_Str"" + info + ""String_Node_Str"");
    return;
  }
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + info.id + ""String_Node_Str""+ info.pid+ ""String_Node_Str""+ percentageText);
  }
  NotificationManager.from(mContext).notify(TAG,info.id,notification);
}",0.993218114198206
192243,"public void scrollTo(View v){
  ExpandableView expandableView=(ExpandableView)v;
  int positionInLinearLayout=getPositionInLinearLayout(v);
  int targetScroll=positionInLinearLayout + expandableView.getActualHeight() + mBottomInset - getHeight() + getTopPadding();
  if (mOwnScrollY < targetScroll) {
    mScroller.startScroll(mScrollX,mOwnScrollY,0,targetScroll - mOwnScrollY);
    mDontReportNextOverScroll=true;
    postInvalidateOnAnimation();
  }
}","public void scrollTo(View v){
  ExpandableView expandableView=(ExpandableView)v;
  int positionInLinearLayout=getPositionInLinearLayout(v);
  int targetScroll=positionInLinearLayout + expandableView.getActualHeight() + getImeInset() - getHeight() + getTopPadding();
  if (mOwnScrollY < targetScroll) {
    mScroller.startScroll(mScrollX,mOwnScrollY,0,targetScroll - mOwnScrollY);
    mDontReportNextOverScroll=true;
    postInvalidateOnAnimation();
  }
}",0.9724366041896362
192244,"@Override public WindowInsets onApplyWindowInsets(WindowInsets insets){
  mBottomInset=Math.max(0,insets.getSystemWindowInsetBottom() - (getRootView().getHeight() - getHeight()));
  int range=getScrollRange();
  if (mOwnScrollY > range) {
    removeCallbacks(mReclamp);
    postDelayed(mReclamp,50);
  }
  return insets;
}","@Override public WindowInsets onApplyWindowInsets(WindowInsets insets){
  mBottomInset=insets.getSystemWindowInsetBottom();
  int range=getScrollRange();
  if (mOwnScrollY > range) {
    removeCallbacks(mReclamp);
    postDelayed(mReclamp,50);
  }
  return insets;
}",0.9047619047619048
192245,"private int getScrollRange(){
  int scrollRange=0;
  ExpandableView firstChild=(ExpandableView)getFirstChildNotGone();
  if (firstChild != null) {
    int contentHeight=getContentHeight();
    scrollRange=Math.max(0,contentHeight - mMaxLayoutHeight + mBottomStackPeekSize + mBottomStackSlowDownHeight);
    if (scrollRange > 0) {
      int firstChildMaxExpandHeight=getMaxExpandHeight(firstChild);
      scrollRange=Math.max(scrollRange,firstChildMaxExpandHeight - firstChild.getMinHeight());
    }
  }
  int imeOverlap=Math.max(0,getContentHeight() - (getHeight() - mBottomInset));
  return scrollRange + imeOverlap;
}","private int getScrollRange(){
  int contentHeight=getContentHeight();
  int scrollRange=Math.max(0,contentHeight - mMaxLayoutHeight + mBottomStackPeekSize + mBottomStackSlowDownHeight);
  int imeInset=getImeInset();
  scrollRange+=Math.min(imeInset,Math.max(0,getContentHeight() - (getHeight() - imeInset)));
  return scrollRange;
}",0.5152471083070452
192246,"public void scrollTo(View v){
  ExpandableView expandableView=(ExpandableView)v;
  int positionInLinearLayout=getPositionInLinearLayout(v);
  int targetScroll=positionInLinearLayout + expandableView.getActualHeight() + mBottomInset - getHeight() + getTopPadding();
  if (mOwnScrollY < targetScroll) {
    mScroller.startScroll(mScrollX,mOwnScrollY,0,targetScroll - mOwnScrollY);
    mDontReportNextOverScroll=true;
    postInvalidateOnAnimation();
  }
}","public void scrollTo(View v){
  ExpandableView expandableView=(ExpandableView)v;
  int positionInLinearLayout=getPositionInLinearLayout(v);
  int targetScroll=positionInLinearLayout + expandableView.getActualHeight() + getImeInset() - getHeight() + getTopPadding();
  if (mOwnScrollY < targetScroll) {
    mScroller.startScroll(mScrollX,mOwnScrollY,0,targetScroll - mOwnScrollY);
    mDontReportNextOverScroll=true;
    postInvalidateOnAnimation();
  }
}",0.9724366041896362
192247,"@Override public WindowInsets onApplyWindowInsets(WindowInsets insets){
  mBottomInset=Math.max(0,insets.getSystemWindowInsetBottom() - (getRootView().getHeight() - getHeight()));
  int range=getScrollRange();
  if (mOwnScrollY > range) {
    removeCallbacks(mReclamp);
    postDelayed(mReclamp,50);
  }
  return insets;
}","@Override public WindowInsets onApplyWindowInsets(WindowInsets insets){
  mBottomInset=insets.getSystemWindowInsetBottom();
  int range=getScrollRange();
  if (mOwnScrollY > range) {
    removeCallbacks(mReclamp);
    postDelayed(mReclamp,50);
  }
  return insets;
}",0.9047619047619048
192248,"private int getScrollRange(){
  int scrollRange=0;
  ExpandableView firstChild=(ExpandableView)getFirstChildNotGone();
  if (firstChild != null) {
    int contentHeight=getContentHeight();
    scrollRange=Math.max(0,contentHeight - mMaxLayoutHeight + mBottomStackPeekSize + mBottomStackSlowDownHeight);
    if (scrollRange > 0) {
      int firstChildMaxExpandHeight=getMaxExpandHeight(firstChild);
      scrollRange=Math.max(scrollRange,firstChildMaxExpandHeight - firstChild.getMinHeight());
    }
  }
  int imeOverlap=Math.max(0,getContentHeight() - (getHeight() - mBottomInset));
  return scrollRange + imeOverlap;
}","private int getScrollRange(){
  int contentHeight=getContentHeight();
  int scrollRange=Math.max(0,contentHeight - mMaxLayoutHeight + mBottomStackPeekSize + mBottomStackSlowDownHeight);
  int imeInset=getImeInset();
  scrollRange+=Math.min(imeInset,Math.max(0,getContentHeight() - (getHeight() - imeInset)));
  return scrollRange;
}",0.5152471083070452
192249,"private int getMinHeight(int maxAllowedVisibleChildren){
  int minExpandHeight=mNotificationHeaderHeight;
  int visibleChildren=0;
  boolean firstChild=true;
  int childCount=mChildren.size();
  for (int i=0; i < childCount; i++) {
    if (visibleChildren >= maxAllowedVisibleChildren) {
      break;
    }
    if (!firstChild) {
      minExpandHeight+=mChildPadding;
    }
 else {
      firstChild=false;
    }
    ExpandableNotificationRow child=mChildren.get(i);
    minExpandHeight+=child.getMinHeight();
    visibleChildren++;
  }
  minExpandHeight+=mCollapsedBottompadding;
  return minExpandHeight;
}","private int getMinHeight(int maxAllowedVisibleChildren){
  int minExpandHeight=mNotificationHeaderHeight;
  int visibleChildren=0;
  boolean firstChild=true;
  int childCount=mChildren.size();
  for (int i=0; i < childCount; i++) {
    if (visibleChildren >= maxAllowedVisibleChildren) {
      break;
    }
    if (!firstChild) {
      minExpandHeight+=mChildPadding;
    }
 else {
      firstChild=false;
    }
    ExpandableNotificationRow child=mChildren.get(i);
    minExpandHeight+=child.getSingleLineView().getHeight();
    visibleChildren++;
  }
  minExpandHeight+=mCollapsedBottompadding;
  return minExpandHeight;
}",0.9813160032493908
192250,"private void updateSoftKeyboardShowModeLocked(UserState userState){
  final int userId=userState.mUserId;
  if ((userId == mCurrentUserId) && (userState.mSoftKeyboardShowMode != 0)) {
    boolean serviceChangingSoftKeyboardModeIsEnabled=userState.mEnabledServices.contains(userState.mServiceChangingSoftKeyboardMode);
    if (!serviceChangingSoftKeyboardModeIsEnabled) {
      final long identity=Binder.clearCallingIdentity();
      try {
        Settings.Secure.putIntForUser(mContext.getContentResolver(),Settings.Secure.ACCESSIBILITY_SOFT_KEYBOARD_MODE,0,userState.mUserId);
      }
  finally {
        Binder.restoreCallingIdentity(identity);
      }
      userState.mSoftKeyboardShowMode=0;
      userState.mServiceChangingSoftKeyboardMode=null;
    }
    notifySoftKeyboardShowModeChangedLocked(userState.mSoftKeyboardShowMode);
  }
}","private void updateSoftKeyboardShowModeLocked(UserState userState){
  final int userId=userState.mUserId;
  if ((userId == mCurrentUserId) && (userState.mSoftKeyboardShowMode != 0)) {
    boolean serviceChangingSoftKeyboardModeIsEnabled=userState.mEnabledServices.contains(userState.mServiceChangingSoftKeyboardMode);
    if (!serviceChangingSoftKeyboardModeIsEnabled) {
      final long identity=Binder.clearCallingIdentity();
      try {
        Settings.Secure.putIntForUser(mContext.getContentResolver(),Settings.Secure.ACCESSIBILITY_SOFT_KEYBOARD_MODE,0,userState.mUserId);
      }
  finally {
        Binder.restoreCallingIdentity(identity);
      }
      userState.mSoftKeyboardShowMode=0;
      userState.mServiceChangingSoftKeyboardMode=null;
      notifySoftKeyboardShowModeChangedLocked(userState.mSoftKeyboardShowMode);
    }
  }
}",0.9061757719714963
192251,"@Override public void onChange(boolean selfChange,Uri uri){
synchronized (mLock) {
    UserState userState=getCurrentUserStateLocked();
    if (userState.isUiAutomationSuppressingOtherServices()) {
      return;
    }
    if (mTouchExplorationEnabledUri.equals(uri)) {
      if (readTouchExplorationEnabledSettingLocked(userState)) {
        onUserStateChangedLocked(userState);
      }
    }
 else     if (mDisplayMagnificationEnabledUri.equals(uri)) {
      if (readDisplayMagnificationEnabledSettingLocked(userState)) {
        onUserStateChangedLocked(userState);
      }
    }
 else     if (mAutoclickEnabledUri.equals(uri)) {
      if (readAutoclickEnabledSettingLocked(userState)) {
        onUserStateChangedLocked(userState);
      }
    }
 else     if (mEnabledAccessibilityServicesUri.equals(uri)) {
      if (readEnabledAccessibilityServicesLocked(userState)) {
        onUserStateChangedLocked(userState);
      }
    }
 else     if (mTouchExplorationGrantedAccessibilityServicesUri.equals(uri)) {
      if (readTouchExplorationGrantedAccessibilityServicesLocked(userState)) {
        onUserStateChangedLocked(userState);
      }
    }
 else     if (mEnhancedWebAccessibilityUri.equals(uri)) {
      if (readEnhancedWebAccessibilityEnabledChangedLocked(userState)) {
        onUserStateChangedLocked(userState);
      }
    }
 else     if (mDisplayInversionEnabledUri.equals(uri) || mDisplayDaltonizerEnabledUri.equals(uri) || mDisplayDaltonizerUri.equals(uri)) {
      if (readDisplayColorAdjustmentSettingsLocked(userState)) {
        updateDisplayColorAdjustmentSettingsLocked(userState);
      }
    }
 else     if (mDisplayColorMatrixUri.equals(uri)) {
      updateDisplayColorAdjustmentSettingsLocked(userState);
    }
 else     if (mHighTextContrastUri.equals(uri)) {
      if (readHighTextContrastEnabledSettingLocked(userState)) {
        onUserStateChangedLocked(userState);
      }
    }
 else     if (mAccessibilitySoftKeyboardModeUri.equals(uri)) {
      if (readSoftKeyboardShowModeChangedLocked(userState)) {
        onUserStateChangedLocked(userState);
      }
    }
  }
}","@Override public void onChange(boolean selfChange,Uri uri){
synchronized (mLock) {
    UserState userState=getCurrentUserStateLocked();
    if (userState.isUiAutomationSuppressingOtherServices()) {
      return;
    }
    if (mTouchExplorationEnabledUri.equals(uri)) {
      if (readTouchExplorationEnabledSettingLocked(userState)) {
        onUserStateChangedLocked(userState);
      }
    }
 else     if (mDisplayMagnificationEnabledUri.equals(uri)) {
      if (readDisplayMagnificationEnabledSettingLocked(userState)) {
        onUserStateChangedLocked(userState);
      }
    }
 else     if (mAutoclickEnabledUri.equals(uri)) {
      if (readAutoclickEnabledSettingLocked(userState)) {
        onUserStateChangedLocked(userState);
      }
    }
 else     if (mEnabledAccessibilityServicesUri.equals(uri)) {
      if (readEnabledAccessibilityServicesLocked(userState)) {
        onUserStateChangedLocked(userState);
      }
    }
 else     if (mTouchExplorationGrantedAccessibilityServicesUri.equals(uri)) {
      if (readTouchExplorationGrantedAccessibilityServicesLocked(userState)) {
        onUserStateChangedLocked(userState);
      }
    }
 else     if (mEnhancedWebAccessibilityUri.equals(uri)) {
      if (readEnhancedWebAccessibilityEnabledChangedLocked(userState)) {
        onUserStateChangedLocked(userState);
      }
    }
 else     if (mDisplayInversionEnabledUri.equals(uri) || mDisplayDaltonizerEnabledUri.equals(uri) || mDisplayDaltonizerUri.equals(uri)) {
      if (readDisplayColorAdjustmentSettingsLocked(userState)) {
        updateDisplayColorAdjustmentSettingsLocked(userState);
      }
    }
 else     if (mDisplayColorMatrixUri.equals(uri)) {
      updateDisplayColorAdjustmentSettingsLocked(userState);
    }
 else     if (mHighTextContrastUri.equals(uri)) {
      if (readHighTextContrastEnabledSettingLocked(userState)) {
        onUserStateChangedLocked(userState);
      }
    }
 else     if (mAccessibilitySoftKeyboardModeUri.equals(uri)) {
      if (readSoftKeyboardShowModeChangedLocked(userState)) {
        notifySoftKeyboardShowModeChangedLocked(userState.mSoftKeyboardShowMode);
        onUserStateChangedLocked(userState);
      }
    }
  }
}",0.9761904761904762
192252,"/** 
 * This is called with the full size of the window since we are handling our own insets.
 */
@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  if (mTaskStackView.getVisibility() != GONE) {
    mTaskStackView.layout(left,top,left + getMeasuredWidth(),top + getMeasuredHeight());
  }
  if (mEmptyView.getVisibility() != GONE) {
    int leftRightInsets=mSystemInsets.left + mSystemInsets.right;
    int topBottomInsets=mSystemInsets.top + mSystemInsets.bottom;
    int childWidth=mEmptyView.getMeasuredWidth();
    int childHeight=mEmptyView.getMeasuredHeight();
    int childLeft=left + Math.max(0,(right - left - leftRightInsets- childWidth)) / 2;
    int childTop=top + Math.max(0,(bottom - top - topBottomInsets- childHeight)) / 2;
    mEmptyView.layout(childLeft,childTop,childLeft + childWidth,childTop + childHeight);
  }
  if (RecentsDebugFlags.Static.EnableStackActionButton) {
    Rect buttonBounds=getStackActionButtonBoundsFromStackLayout();
    mStackActionButton.layout(buttonBounds.left,buttonBounds.top,buttonBounds.right,buttonBounds.bottom);
  }
  if (mAwaitingFirstLayout) {
    mAwaitingFirstLayout=false;
    RecentsActivityLaunchState launchState=Recents.getConfiguration().getLaunchState();
    if (launchState.launchedViaDragGesture) {
      setTranslationY(getMeasuredHeight());
    }
 else {
      setTranslationY(0f);
    }
  }
}","/** 
 * This is called with the full size of the window since we are handling our own insets.
 */
@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  if (mTaskStackView.getVisibility() != GONE) {
    mTaskStackView.layout(left,top,left + getMeasuredWidth(),top + getMeasuredHeight());
  }
  if (mEmptyView.getVisibility() != GONE) {
    int leftRightInsets=mSystemInsets.left + mSystemInsets.right;
    int topBottomInsets=mSystemInsets.top + mSystemInsets.bottom;
    int childWidth=mEmptyView.getMeasuredWidth();
    int childHeight=mEmptyView.getMeasuredHeight();
    int childLeft=left + mSystemInsets.left + Math.max(0,(right - left - leftRightInsets- childWidth)) / 2;
    int childTop=top + mSystemInsets.top + Math.max(0,(bottom - top - topBottomInsets- childHeight)) / 2;
    mEmptyView.layout(childLeft,childTop,childLeft + childWidth,childTop + childHeight);
  }
  if (RecentsDebugFlags.Static.EnableStackActionButton) {
    Rect buttonBounds=getStackActionButtonBoundsFromStackLayout();
    mStackActionButton.layout(buttonBounds.left,buttonBounds.top,buttonBounds.right,buttonBounds.bottom);
  }
  if (mAwaitingFirstLayout) {
    mAwaitingFirstLayout=false;
    RecentsActivityLaunchState launchState=Recents.getConfiguration().getLaunchState();
    if (launchState.launchedViaDragGesture) {
      setTranslationY(getMeasuredHeight());
    }
 else {
      setTranslationY(0f);
    }
  }
}",0.985568461809222
192253,"/** 
 * @return True if the view is expandable, false otherwise.
 */
private boolean startExpanding(ExpandableView v,int expandType){
  if (!(v instanceof ExpandableNotificationRow)) {
    return false;
  }
  mExpansionStyle=expandType;
  if (mExpanding && v == mResizedView) {
    return true;
  }
  mExpanding=true;
  mCallback.expansionStateChanged(true);
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + expandType + ""String_Node_Str""+ v);
  mCallback.setUserLockedChild(v,true);
  mScaler.setView(v);
  mOldHeight=mScaler.getHeight();
  mCurrentHeight=mOldHeight;
  boolean canBeExpanded=mCallback.canChildBeExpanded(v);
  if (canBeExpanded) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mNaturalHeight=mScaler.getNaturalHeight();
    mSmallSize=v.getMinExpandHeight();
  }
 else {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mNaturalHeight=mOldHeight;
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + mOldHeight + ""String_Node_Str""+ mNaturalHeight);
  return true;
}","/** 
 * @return True if the view is expandable, false otherwise.
 */
private boolean startExpanding(ExpandableView v,int expandType){
  if (!(v instanceof ExpandableNotificationRow)) {
    return false;
  }
  mExpansionStyle=expandType;
  if (mExpanding && v == mResizedView) {
    return true;
  }
  mExpanding=true;
  mCallback.expansionStateChanged(true);
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + expandType + ""String_Node_Str""+ v);
  mCallback.setUserLockedChild(v,true);
  mScaler.setView(v);
  mOldHeight=mScaler.getHeight();
  mCurrentHeight=mOldHeight;
  boolean canBeExpanded=mCallback.canChildBeExpanded(v);
  if (canBeExpanded) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mNaturalHeight=mScaler.getNaturalHeight();
    mSmallSize=v.getCollapsedHeight();
  }
 else {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mNaturalHeight=mOldHeight;
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + mOldHeight + ""String_Node_Str""+ mNaturalHeight);
  return true;
}",0.9918864097363084
192254,"private void handleExpansion(float heightDelta,ExpandableView child){
  if (heightDelta < 0) {
    heightDelta=0;
  }
  boolean expandable=child.isContentExpandable();
  float rubberbandFactor=expandable ? RUBBERBAND_FACTOR_EXPANDABLE : RUBBERBAND_FACTOR_STATIC;
  float rubberband=heightDelta * rubberbandFactor;
  if (expandable && (rubberband + child.getMinExpandHeight()) > child.getMaxContentHeight()) {
    float overshoot=(rubberband + child.getMinExpandHeight()) - child.getMaxContentHeight();
    overshoot*=(1 - RUBBERBAND_FACTOR_STATIC);
    rubberband-=overshoot;
  }
  child.setActualHeight((int)(child.getMinExpandHeight() + rubberband));
}","private void handleExpansion(float heightDelta,ExpandableView child){
  if (heightDelta < 0) {
    heightDelta=0;
  }
  boolean expandable=child.isContentExpandable();
  float rubberbandFactor=expandable ? RUBBERBAND_FACTOR_EXPANDABLE : RUBBERBAND_FACTOR_STATIC;
  float rubberband=heightDelta * rubberbandFactor;
  if (expandable && (rubberband + child.getCollapsedHeight()) > child.getMaxContentHeight()) {
    float overshoot=(rubberband + child.getCollapsedHeight()) - child.getMaxContentHeight();
    overshoot*=(1 - RUBBERBAND_FACTOR_STATIC);
    rubberband-=overshoot;
  }
  child.setActualHeight((int)(child.getCollapsedHeight() + rubberband));
}",0.8623853211009175
192255,"@Override public int getIntrinsicHeight(){
  if (isUserLocked()) {
    return getActualHeight();
  }
  if (mGuts != null && mGuts.areGutsExposed()) {
    return mGuts.getHeight();
  }
 else   if ((isChildInGroup() && !isGroupExpanded())) {
    return mPrivateLayout.getMinHeight();
  }
 else   if (mSensitive && mHideSensitiveForIntrinsicHeight) {
    return getMinHeight();
  }
 else   if (mIsSummaryWithChildren && !mOnKeyguard) {
    return mChildrenContainer.getIntrinsicHeight();
  }
 else   if (mIsHeadsUp) {
    if (isPinned()) {
      return getPinnedHeadsUpHeight(true);
    }
 else     if (isExpanded()) {
      return Math.max(getMaxExpandHeight(),mHeadsUpHeight);
    }
 else {
      return Math.max(getMinHeight(),mHeadsUpHeight);
    }
  }
 else   if (isExpanded()) {
    return getMaxExpandHeight();
  }
 else {
    return getMinHeight();
  }
}","@Override public int getIntrinsicHeight(){
  if (isUserLocked()) {
    return getActualHeight();
  }
  if (mGuts != null && mGuts.areGutsExposed()) {
    return mGuts.getHeight();
  }
 else   if ((isChildInGroup() && !isGroupExpanded())) {
    return mPrivateLayout.getMinHeight();
  }
 else   if (mSensitive && mHideSensitiveForIntrinsicHeight) {
    return getMinHeight();
  }
 else   if (mIsSummaryWithChildren && !mOnKeyguard) {
    return mChildrenContainer.getIntrinsicHeight();
  }
 else   if (mIsHeadsUp) {
    if (isPinned()) {
      return getPinnedHeadsUpHeight(true);
    }
 else     if (isExpanded()) {
      return Math.max(getMaxExpandHeight(),mHeadsUpHeight);
    }
 else {
      return Math.max(getCollapsedHeight(),mHeadsUpHeight);
    }
  }
 else   if (isExpanded()) {
    return getMaxExpandHeight();
  }
 else {
    return getCollapsedHeight();
  }
}",0.8346820809248555
192256,"/** 
 * @param atLeastMinHeight should the value returned be at least the minimum height.Used to avoid cyclic calls
 * @return the height of the heads up notification when pinned
 */
public int getPinnedHeadsUpHeight(boolean atLeastMinHeight){
  if (mIsSummaryWithChildren) {
    return mChildrenContainer.getIntrinsicHeight();
  }
  if (mExpandedWhenPinned) {
    return Math.max(getMaxExpandHeight(),mHeadsUpHeight);
  }
 else   if (atLeastMinHeight) {
    return Math.max(getMinHeight(),mHeadsUpHeight);
  }
 else {
    return mHeadsUpHeight;
  }
}","/** 
 * @param atLeastMinHeight should the value returned be at least the minimum height.Used to avoid cyclic calls
 * @return the height of the heads up notification when pinned
 */
public int getPinnedHeadsUpHeight(boolean atLeastMinHeight){
  if (mIsSummaryWithChildren) {
    return mChildrenContainer.getIntrinsicHeight();
  }
  if (mExpandedWhenPinned) {
    return Math.max(getMaxExpandHeight(),mHeadsUpHeight);
  }
 else   if (atLeastMinHeight) {
    return Math.max(getCollapsedHeight(),mHeadsUpHeight);
  }
 else {
    return mHeadsUpHeight;
  }
}",0.9891696750902528
192257,"/** 
 * @return one of the static enum types in this view, calculated form the current state
 */
private int calculateVisibleType(){
  if (mUserExpanding) {
    int height=!mIsChildInGroup || isGroupExpanded() || mContainingNotification.isExpanded(true) ? mContainingNotification.getMaxContentHeight() : mContainingNotification.getShowingLayout().getMinHeight();
    if (height == 0) {
      height=mContentHeight;
    }
    int expandedVisualType=getVisualTypeForHeight(height);
    int collapsedVisualType=getVisualTypeForHeight(mContainingNotification.getMinExpandHeight());
    return mTransformationStartVisibleType == collapsedVisualType ? expandedVisualType : collapsedVisualType;
  }
  int intrinsicHeight=mContainingNotification.getIntrinsicHeight();
  int viewHeight=mContentHeight;
  if (intrinsicHeight != 0) {
    viewHeight=Math.min(mContentHeight,intrinsicHeight);
  }
  return getVisualTypeForHeight(viewHeight);
}","/** 
 * @return one of the static enum types in this view, calculated form the current state
 */
private int calculateVisibleType(){
  if (mUserExpanding) {
    int height=!mIsChildInGroup || isGroupExpanded() || mContainingNotification.isExpanded(true) ? mContainingNotification.getMaxContentHeight() : mContainingNotification.getShowingLayout().getMinHeight();
    if (height == 0) {
      height=mContentHeight;
    }
    int expandedVisualType=getVisualTypeForHeight(height);
    int collapsedVisualType=getVisualTypeForHeight(mContainingNotification.getCollapsedHeight());
    return mTransformationStartVisibleType == collapsedVisualType ? expandedVisualType : collapsedVisualType;
  }
  int intrinsicHeight=mContainingNotification.getIntrinsicHeight();
  int viewHeight=mContentHeight;
  if (intrinsicHeight != 0) {
    viewHeight=Math.min(mContentHeight,intrinsicHeight);
  }
  return getVisualTypeForHeight(viewHeight);
}",0.613978494623656
192258,"public float getGroupExpandFraction(){
  int visibleChildrenExpandedHeight=getVisibleChildrenExpandHeight();
  int minExpandHeight=getMinExpandHeight();
  float factor=(mActualHeight - minExpandHeight) / (float)(visibleChildrenExpandedHeight - minExpandHeight);
  return Math.max(0.0f,Math.min(1.0f,factor));
}","public float getGroupExpandFraction(){
  int visibleChildrenExpandedHeight=getVisibleChildrenExpandHeight();
  int minExpandHeight=getCollapsedHeight();
  float factor=(mActualHeight - minExpandHeight) / (float)(visibleChildrenExpandedHeight - minExpandHeight);
  return Math.max(0.0f,Math.min(1.0f,factor));
}",0.9741935483870968
192259,"public int getMinHeight(){
  return getIntrinsicHeight(NUMBER_OF_CHILDREN_WHEN_COLLAPSED);
}","private int getMinHeight(int maxAllowedVisibleChildren){
  int minExpandHeight=mNotificationHeaderHeight;
  int visibleChildren=0;
  boolean firstChild=true;
  int childCount=mChildren.size();
  for (int i=0; i < childCount; i++) {
    if (visibleChildren >= maxAllowedVisibleChildren) {
      break;
    }
    if (!firstChild) {
      minExpandHeight+=mChildPadding;
    }
 else {
      firstChild=false;
    }
    ExpandableNotificationRow child=mChildren.get(i);
    minExpandHeight+=child.getMinHeight();
    visibleChildren++;
  }
  minExpandHeight+=mCollapsedBottompadding;
  return minExpandHeight;
}",0.0572246065808297
192260,"public int getPeekHeight(){
  final ExpandableView firstChild=getFirstChildNotGone();
  final int firstChildMinHeight=firstChild != null ? (int)firstChild.getMinHeight() : mCollapsedSize;
  return mIntrinsicPadding + firstChildMinHeight + mBottomStackPeekSize+ mBottomStackSlowDownHeight;
}","public int getPeekHeight(){
  final ExpandableView firstChild=getFirstChildNotGone();
  final int firstChildMinHeight=firstChild != null ? firstChild.getCollapsedHeight() : mCollapsedSize;
  return mIntrinsicPadding + firstChildMinHeight + mBottomStackPeekSize+ mBottomStackSlowDownHeight;
}",0.9707401032702238
192261,"/** 
 * Update the height of the first child i.e clamp it to the bottom stack
 * @param child the child to update
 * @param childViewState the viewstate of the child
 * @param childHeight the height of the child
 * @param ambientState The ambient state of the algorithm
 */
private void updateFirstChildHeight(ExpandableView child,StackViewState childViewState,int childHeight,AmbientState ambientState){
  int bottomPeekStart=ambientState.getInnerHeight() - mBottomStackPeekSize - mBottomStackSlowDownLength + ambientState.getScrollY();
  childViewState.height=(int)Math.max(Math.min(bottomPeekStart,(float)childHeight),child.getMinHeight());
}","/** 
 * Update the height of the first child i.e clamp it to the bottom stack
 * @param child the child to update
 * @param childViewState the viewstate of the child
 * @param childHeight the height of the child
 * @param ambientState The ambient state of the algorithm
 */
private void updateFirstChildHeight(ExpandableView child,StackViewState childViewState,int childHeight,AmbientState ambientState){
  int bottomPeekStart=ambientState.getInnerHeight() - mBottomStackPeekSize - mBottomStackSlowDownLength + ambientState.getScrollY();
  childViewState.height=(int)Math.max(Math.min(bottomPeekStart,(float)childHeight),child.getCollapsedHeight());
}",0.9907407407407408
192262,"/** 
 * Determine the positions for the views. This is the main part of the algorithm.
 * @param resultState The result state to update if a change to the properties of a child occurs
 * @param algorithmState The state in which the current pass of the algorithm is currently in
 * @param ambientState The current ambient state
 */
private void updatePositionsForState(StackScrollState resultState,StackScrollAlgorithmState algorithmState,AmbientState ambientState){
  float bottomPeekStart=ambientState.getInnerHeight() - mBottomStackPeekSize;
  float bottomStackStart=bottomPeekStart - mBottomStackSlowDownLength;
  float currentYPosition=-algorithmState.scrollY;
  int childCount=algorithmState.visibleChildren.size();
  int paddingAfterChild;
  for (int i=0; i < childCount; i++) {
    ExpandableView child=algorithmState.visibleChildren.get(i);
    StackViewState childViewState=resultState.getViewStateForView(child);
    childViewState.location=StackViewState.LOCATION_UNKNOWN;
    paddingAfterChild=getPaddingAfterChild(algorithmState,child);
    int childHeight=getMaxAllowedChildHeight(child);
    int minHeight=child.getMinHeight();
    childViewState.yTranslation=currentYPosition;
    if (i == 0) {
      updateFirstChildHeight(child,childViewState,childHeight,ambientState);
    }
    float nextYPosition=currentYPosition + childHeight + paddingAfterChild;
    if (nextYPosition >= bottomStackStart) {
      if (currentYPosition >= bottomStackStart) {
        updateStateForChildFullyInBottomStack(algorithmState,bottomStackStart,childViewState,minHeight,ambientState,child);
      }
 else {
        updateStateForChildTransitioningInBottom(algorithmState,bottomStackStart,child,currentYPosition,childViewState,childHeight);
      }
    }
 else {
      childViewState.location=StackViewState.LOCATION_MAIN_AREA;
      clampPositionToBottomStackStart(childViewState,childViewState.height,childHeight,ambientState);
    }
    if (i == 0 && ambientState.getScrollY() <= 0) {
      childViewState.yTranslation=Math.max(0,childViewState.yTranslation);
    }
    currentYPosition=childViewState.yTranslation + childHeight + paddingAfterChild;
    if (currentYPosition <= 0) {
      childViewState.location=StackViewState.LOCATION_HIDDEN_TOP;
    }
    if (childViewState.location == StackViewState.LOCATION_UNKNOWN) {
      Log.wtf(LOG_TAG,""String_Node_Str"" + i);
    }
    childViewState.yTranslation+=ambientState.getTopPadding() + ambientState.getStackTranslation();
  }
}","/** 
 * Determine the positions for the views. This is the main part of the algorithm.
 * @param resultState The result state to update if a change to the properties of a child occurs
 * @param algorithmState The state in which the current pass of the algorithm is currently in
 * @param ambientState The current ambient state
 */
private void updatePositionsForState(StackScrollState resultState,StackScrollAlgorithmState algorithmState,AmbientState ambientState){
  float bottomPeekStart=ambientState.getInnerHeight() - mBottomStackPeekSize;
  float bottomStackStart=bottomPeekStart - mBottomStackSlowDownLength;
  float currentYPosition=-algorithmState.scrollY;
  int childCount=algorithmState.visibleChildren.size();
  int paddingAfterChild;
  for (int i=0; i < childCount; i++) {
    ExpandableView child=algorithmState.visibleChildren.get(i);
    StackViewState childViewState=resultState.getViewStateForView(child);
    childViewState.location=StackViewState.LOCATION_UNKNOWN;
    paddingAfterChild=getPaddingAfterChild(algorithmState,child);
    int childHeight=getMaxAllowedChildHeight(child);
    int collapsedHeight=child.getCollapsedHeight();
    childViewState.yTranslation=currentYPosition;
    if (i == 0) {
      updateFirstChildHeight(child,childViewState,childHeight,ambientState);
    }
    float nextYPosition=currentYPosition + childHeight + paddingAfterChild;
    if (nextYPosition >= bottomStackStart) {
      if (currentYPosition >= bottomStackStart) {
        updateStateForChildFullyInBottomStack(algorithmState,bottomStackStart,childViewState,collapsedHeight,ambientState,child);
      }
 else {
        updateStateForChildTransitioningInBottom(algorithmState,bottomStackStart,child,currentYPosition,childViewState,childHeight);
      }
    }
 else {
      childViewState.location=StackViewState.LOCATION_MAIN_AREA;
      clampPositionToBottomStackStart(childViewState,childViewState.height,childHeight,ambientState);
    }
    if (i == 0 && ambientState.getScrollY() <= 0) {
      childViewState.yTranslation=Math.max(0,childViewState.yTranslation);
    }
    currentYPosition=childViewState.yTranslation + childHeight + paddingAfterChild;
    if (currentYPosition <= 0) {
      childViewState.location=StackViewState.LOCATION_HIDDEN_TOP;
    }
    if (childViewState.location == StackViewState.LOCATION_UNKNOWN) {
      Log.wtf(LOG_TAG,""String_Node_Str"" + i);
    }
    childViewState.yTranslation+=ambientState.getTopPadding() + ambientState.getStackTranslation();
  }
}",0.9927739863508632
192263,"private void updateStateForChildTransitioningInBottom(StackScrollAlgorithmState algorithmState,float transitioningPositionStart,ExpandableView child,float currentYPosition,StackViewState childViewState,int childHeight){
  algorithmState.partialInBottom=1.0f - ((transitioningPositionStart - currentYPosition) / (childHeight + getPaddingAfterChild(algorithmState,child)));
  float offset=mBottomStackIndentationFunctor.getValue(algorithmState.partialInBottom);
  algorithmState.itemsInBottomStack+=algorithmState.partialInBottom;
  int newHeight=childHeight;
  if (childHeight > child.getMinHeight()) {
    newHeight=(int)Math.max(Math.min(transitioningPositionStart + offset - getPaddingAfterChild(algorithmState,child) - currentYPosition,childHeight),child.getMinHeight());
    childViewState.height=newHeight;
  }
  childViewState.yTranslation=transitioningPositionStart + offset - newHeight - getPaddingAfterChild(algorithmState,child);
  childViewState.location=StackViewState.LOCATION_MAIN_AREA;
}","private void updateStateForChildTransitioningInBottom(StackScrollAlgorithmState algorithmState,float transitioningPositionStart,ExpandableView child,float currentYPosition,StackViewState childViewState,int childHeight){
  algorithmState.partialInBottom=1.0f - ((transitioningPositionStart - currentYPosition) / (childHeight + getPaddingAfterChild(algorithmState,child)));
  float offset=mBottomStackIndentationFunctor.getValue(algorithmState.partialInBottom);
  algorithmState.itemsInBottomStack+=algorithmState.partialInBottom;
  int newHeight=childHeight;
  if (childHeight > child.getCollapsedHeight()) {
    newHeight=(int)Math.max(Math.min(transitioningPositionStart + offset - getPaddingAfterChild(algorithmState,child) - currentYPosition,childHeight),child.getCollapsedHeight());
    childViewState.height=newHeight;
  }
  childViewState.yTranslation=transitioningPositionStart + offset - newHeight - getPaddingAfterChild(algorithmState,child);
  childViewState.location=StackViewState.LOCATION_MAIN_AREA;
}",0.988095238095238
192264,"private void clampHunToTop(AmbientState ambientState,ExpandableNotificationRow row,StackViewState childState){
  float newTranslation=Math.max(ambientState.getTopPadding() + ambientState.getStackTranslation(),childState.yTranslation);
  childState.height=(int)Math.max(childState.height - (newTranslation - childState.yTranslation),row.getMinHeight());
  childState.yTranslation=newTranslation;
}","private void clampHunToTop(AmbientState ambientState,ExpandableNotificationRow row,StackViewState childState){
  float newTranslation=Math.max(ambientState.getTopPadding() + ambientState.getStackTranslation(),childState.yTranslation);
  childState.height=(int)Math.max(childState.height - (newTranslation - childState.yTranslation),row.getCollapsedHeight());
  childState.yTranslation=newTranslation;
}",0.9849624060150376
192265,"private void clampHunToMaxTranslation(AmbientState ambientState,ExpandableNotificationRow row,StackViewState childState){
  float newTranslation;
  float bottomPosition=ambientState.getMaxHeadsUpTranslation() - row.getMinHeight();
  newTranslation=Math.min(childState.yTranslation,bottomPosition);
  childState.height=(int)Math.max(childState.height - (childState.yTranslation - newTranslation),row.getMinHeight());
  childState.yTranslation=newTranslation;
}","private void clampHunToMaxTranslation(AmbientState ambientState,ExpandableNotificationRow row,StackViewState childState){
  float newTranslation;
  float bottomPosition=ambientState.getMaxHeadsUpTranslation() - row.getCollapsedHeight();
  newTranslation=Math.min(childState.yTranslation,bottomPosition);
  childState.height=(int)Math.max(childState.height - (childState.yTranslation - newTranslation),row.getCollapsedHeight());
  childState.yTranslation=newTranslation;
}",0.9741935483870968
192266,"private void updateStateForChildFullyInBottomStack(StackScrollAlgorithmState algorithmState,float transitioningPositionStart,StackViewState childViewState,int minHeight,AmbientState ambientState,ExpandableView child){
  float currentYPosition;
  algorithmState.itemsInBottomStack+=1.0f;
  if (algorithmState.itemsInBottomStack < MAX_ITEMS_IN_BOTTOM_STACK) {
    currentYPosition=transitioningPositionStart + mBottomStackIndentationFunctor.getValue(algorithmState.itemsInBottomStack) - getPaddingAfterChild(algorithmState,child);
    childViewState.location=StackViewState.LOCATION_BOTTOM_STACK_PEEKING;
  }
 else {
    if (algorithmState.itemsInBottomStack > MAX_ITEMS_IN_BOTTOM_STACK + 2) {
      childViewState.hidden=true;
      childViewState.shadowAlpha=0.0f;
    }
 else     if (algorithmState.itemsInBottomStack > MAX_ITEMS_IN_BOTTOM_STACK + 1) {
      childViewState.shadowAlpha=1.0f - algorithmState.partialInBottom;
    }
    childViewState.location=StackViewState.LOCATION_BOTTOM_STACK_HIDDEN;
    currentYPosition=ambientState.getInnerHeight();
  }
  childViewState.height=minHeight;
  childViewState.yTranslation=currentYPosition - minHeight;
}","private void updateStateForChildFullyInBottomStack(StackScrollAlgorithmState algorithmState,float transitioningPositionStart,StackViewState childViewState,int collapsedHeight,AmbientState ambientState,ExpandableView child){
  float currentYPosition;
  algorithmState.itemsInBottomStack+=1.0f;
  if (algorithmState.itemsInBottomStack < MAX_ITEMS_IN_BOTTOM_STACK) {
    currentYPosition=transitioningPositionStart + mBottomStackIndentationFunctor.getValue(algorithmState.itemsInBottomStack) - getPaddingAfterChild(algorithmState,child);
    childViewState.location=StackViewState.LOCATION_BOTTOM_STACK_PEEKING;
  }
 else {
    if (algorithmState.itemsInBottomStack > MAX_ITEMS_IN_BOTTOM_STACK + 2) {
      childViewState.hidden=true;
      childViewState.shadowAlpha=0.0f;
    }
 else     if (algorithmState.itemsInBottomStack > MAX_ITEMS_IN_BOTTOM_STACK + 1) {
      childViewState.shadowAlpha=1.0f - algorithmState.partialInBottom;
    }
    childViewState.location=StackViewState.LOCATION_BOTTOM_STACK_HIDDEN;
    currentYPosition=ambientState.getInnerHeight();
  }
  childViewState.height=collapsedHeight;
  childViewState.yTranslation=currentYPosition - collapsedHeight;
}",0.9845626072041166
192267,"/** 
 * @return True if the view is expandable, false otherwise.
 */
private boolean startExpanding(ExpandableView v,int expandType){
  if (!(v instanceof ExpandableNotificationRow)) {
    return false;
  }
  mExpansionStyle=expandType;
  if (mExpanding && v == mResizedView) {
    return true;
  }
  mExpanding=true;
  mCallback.expansionStateChanged(true);
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + expandType + ""String_Node_Str""+ v);
  mCallback.setUserLockedChild(v,true);
  mScaler.setView(v);
  mOldHeight=mScaler.getHeight();
  mCurrentHeight=mOldHeight;
  boolean canBeExpanded=mCallback.canChildBeExpanded(v);
  if (canBeExpanded) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mNaturalHeight=mScaler.getNaturalHeight();
    mSmallSize=v.getMinExpandHeight();
  }
 else {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mNaturalHeight=mOldHeight;
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + mOldHeight + ""String_Node_Str""+ mNaturalHeight);
  return true;
}","/** 
 * @return True if the view is expandable, false otherwise.
 */
private boolean startExpanding(ExpandableView v,int expandType){
  if (!(v instanceof ExpandableNotificationRow)) {
    return false;
  }
  mExpansionStyle=expandType;
  if (mExpanding && v == mResizedView) {
    return true;
  }
  mExpanding=true;
  mCallback.expansionStateChanged(true);
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + expandType + ""String_Node_Str""+ v);
  mCallback.setUserLockedChild(v,true);
  mScaler.setView(v);
  mOldHeight=mScaler.getHeight();
  mCurrentHeight=mOldHeight;
  boolean canBeExpanded=mCallback.canChildBeExpanded(v);
  if (canBeExpanded) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mNaturalHeight=mScaler.getNaturalHeight();
    mSmallSize=v.getCollapsedHeight();
  }
 else {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"");
    mNaturalHeight=mOldHeight;
  }
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + mOldHeight + ""String_Node_Str""+ mNaturalHeight);
  return true;
}",0.9918864097363084
192268,"private void handleExpansion(float heightDelta,ExpandableView child){
  if (heightDelta < 0) {
    heightDelta=0;
  }
  boolean expandable=child.isContentExpandable();
  float rubberbandFactor=expandable ? RUBBERBAND_FACTOR_EXPANDABLE : RUBBERBAND_FACTOR_STATIC;
  float rubberband=heightDelta * rubberbandFactor;
  if (expandable && (rubberband + child.getMinExpandHeight()) > child.getMaxContentHeight()) {
    float overshoot=(rubberband + child.getMinExpandHeight()) - child.getMaxContentHeight();
    overshoot*=(1 - RUBBERBAND_FACTOR_STATIC);
    rubberband-=overshoot;
  }
  child.setActualHeight((int)(child.getMinExpandHeight() + rubberband));
}","private void handleExpansion(float heightDelta,ExpandableView child){
  if (heightDelta < 0) {
    heightDelta=0;
  }
  boolean expandable=child.isContentExpandable();
  float rubberbandFactor=expandable ? RUBBERBAND_FACTOR_EXPANDABLE : RUBBERBAND_FACTOR_STATIC;
  float rubberband=heightDelta * rubberbandFactor;
  if (expandable && (rubberband + child.getCollapsedHeight()) > child.getMaxContentHeight()) {
    float overshoot=(rubberband + child.getCollapsedHeight()) - child.getMaxContentHeight();
    overshoot*=(1 - RUBBERBAND_FACTOR_STATIC);
    rubberband-=overshoot;
  }
  child.setActualHeight((int)(child.getCollapsedHeight() + rubberband));
}",0.8623853211009175
192269,"@Override public int getIntrinsicHeight(){
  if (isUserLocked()) {
    return getActualHeight();
  }
  if (mGuts != null && mGuts.areGutsExposed()) {
    return mGuts.getHeight();
  }
 else   if ((isChildInGroup() && !isGroupExpanded())) {
    return mPrivateLayout.getMinHeight();
  }
 else   if (mSensitive && mHideSensitiveForIntrinsicHeight) {
    return getMinHeight();
  }
 else   if (mIsSummaryWithChildren && !mOnKeyguard) {
    return mChildrenContainer.getIntrinsicHeight();
  }
 else   if (mIsHeadsUp) {
    if (isPinned()) {
      return getPinnedHeadsUpHeight(true);
    }
 else     if (isExpanded()) {
      return Math.max(getMaxExpandHeight(),mHeadsUpHeight);
    }
 else {
      return Math.max(getMinHeight(),mHeadsUpHeight);
    }
  }
 else   if (isExpanded()) {
    return getMaxExpandHeight();
  }
 else {
    return getMinHeight();
  }
}","@Override public int getIntrinsicHeight(){
  if (isUserLocked()) {
    return getActualHeight();
  }
  if (mGuts != null && mGuts.areGutsExposed()) {
    return mGuts.getHeight();
  }
 else   if ((isChildInGroup() && !isGroupExpanded())) {
    return mPrivateLayout.getMinHeight();
  }
 else   if (mSensitive && mHideSensitiveForIntrinsicHeight) {
    return getMinHeight();
  }
 else   if (mIsSummaryWithChildren && !mOnKeyguard) {
    return mChildrenContainer.getIntrinsicHeight();
  }
 else   if (mIsHeadsUp) {
    if (isPinned()) {
      return getPinnedHeadsUpHeight(true);
    }
 else     if (isExpanded()) {
      return Math.max(getMaxExpandHeight(),mHeadsUpHeight);
    }
 else {
      return Math.max(getCollapsedHeight(),mHeadsUpHeight);
    }
  }
 else   if (isExpanded()) {
    return getMaxExpandHeight();
  }
 else {
    return getCollapsedHeight();
  }
}",0.8346820809248555
192270,"/** 
 * @param atLeastMinHeight should the value returned be at least the minimum height.Used to avoid cyclic calls
 * @return the height of the heads up notification when pinned
 */
public int getPinnedHeadsUpHeight(boolean atLeastMinHeight){
  if (mIsSummaryWithChildren) {
    return mChildrenContainer.getIntrinsicHeight();
  }
  if (mExpandedWhenPinned) {
    return Math.max(getMaxExpandHeight(),mHeadsUpHeight);
  }
 else   if (atLeastMinHeight) {
    return Math.max(getMinHeight(),mHeadsUpHeight);
  }
 else {
    return mHeadsUpHeight;
  }
}","/** 
 * @param atLeastMinHeight should the value returned be at least the minimum height.Used to avoid cyclic calls
 * @return the height of the heads up notification when pinned
 */
public int getPinnedHeadsUpHeight(boolean atLeastMinHeight){
  if (mIsSummaryWithChildren) {
    return mChildrenContainer.getIntrinsicHeight();
  }
  if (mExpandedWhenPinned) {
    return Math.max(getMaxExpandHeight(),mHeadsUpHeight);
  }
 else   if (atLeastMinHeight) {
    return Math.max(getCollapsedHeight(),mHeadsUpHeight);
  }
 else {
    return mHeadsUpHeight;
  }
}",0.9891696750902528
192271,"/** 
 * @return one of the static enum types in this view, calculated form the current state
 */
private int calculateVisibleType(){
  if (mUserExpanding) {
    int height=!mIsChildInGroup || isGroupExpanded() || mContainingNotification.isExpanded(true) ? mContainingNotification.getMaxContentHeight() : mContainingNotification.getShowingLayout().getMinHeight();
    if (height == 0) {
      height=mContentHeight;
    }
    int expandedVisualType=getVisualTypeForHeight(height);
    int collapsedVisualType=getVisualTypeForHeight(mContainingNotification.getMinExpandHeight());
    return mTransformationStartVisibleType == collapsedVisualType ? expandedVisualType : collapsedVisualType;
  }
  int intrinsicHeight=mContainingNotification.getIntrinsicHeight();
  int viewHeight=mContentHeight;
  if (intrinsicHeight != 0) {
    viewHeight=Math.min(mContentHeight,intrinsicHeight);
  }
  return getVisualTypeForHeight(viewHeight);
}","/** 
 * @return one of the static enum types in this view, calculated form the current state
 */
private int calculateVisibleType(){
  if (mUserExpanding) {
    int height=!mIsChildInGroup || isGroupExpanded() || mContainingNotification.isExpanded(true) ? mContainingNotification.getMaxContentHeight() : mContainingNotification.getShowingLayout().getMinHeight();
    if (height == 0) {
      height=mContentHeight;
    }
    int expandedVisualType=getVisualTypeForHeight(height);
    int collapsedVisualType=getVisualTypeForHeight(mContainingNotification.getCollapsedHeight());
    return mTransformationStartVisibleType == collapsedVisualType ? expandedVisualType : collapsedVisualType;
  }
  int intrinsicHeight=mContainingNotification.getIntrinsicHeight();
  int viewHeight=mContentHeight;
  if (intrinsicHeight != 0) {
    viewHeight=Math.min(mContentHeight,intrinsicHeight);
  }
  return getVisualTypeForHeight(viewHeight);
}",0.613978494623656
192272,"public float getGroupExpandFraction(){
  int visibleChildrenExpandedHeight=getVisibleChildrenExpandHeight();
  int minExpandHeight=getMinExpandHeight();
  float factor=(mActualHeight - minExpandHeight) / (float)(visibleChildrenExpandedHeight - minExpandHeight);
  return Math.max(0.0f,Math.min(1.0f,factor));
}","public float getGroupExpandFraction(){
  int visibleChildrenExpandedHeight=getVisibleChildrenExpandHeight();
  int minExpandHeight=getCollapsedHeight();
  float factor=(mActualHeight - minExpandHeight) / (float)(visibleChildrenExpandedHeight - minExpandHeight);
  return Math.max(0.0f,Math.min(1.0f,factor));
}",0.9741935483870968
192273,"public int getMinHeight(){
  return getIntrinsicHeight(NUMBER_OF_CHILDREN_WHEN_COLLAPSED);
}","private int getMinHeight(int maxAllowedVisibleChildren){
  int minExpandHeight=mNotificationHeaderHeight;
  int visibleChildren=0;
  boolean firstChild=true;
  int childCount=mChildren.size();
  for (int i=0; i < childCount; i++) {
    if (visibleChildren >= maxAllowedVisibleChildren) {
      break;
    }
    if (!firstChild) {
      minExpandHeight+=mChildPadding;
    }
 else {
      firstChild=false;
    }
    ExpandableNotificationRow child=mChildren.get(i);
    minExpandHeight+=child.getMinHeight();
    visibleChildren++;
  }
  minExpandHeight+=mCollapsedBottompadding;
  return minExpandHeight;
}",0.0572246065808297
192274,"public int getPeekHeight(){
  final ExpandableView firstChild=getFirstChildNotGone();
  final int firstChildMinHeight=firstChild != null ? (int)firstChild.getMinHeight() : mCollapsedSize;
  return mIntrinsicPadding + firstChildMinHeight + mBottomStackPeekSize+ mBottomStackSlowDownHeight;
}","public int getPeekHeight(){
  final ExpandableView firstChild=getFirstChildNotGone();
  final int firstChildMinHeight=firstChild != null ? firstChild.getCollapsedHeight() : mCollapsedSize;
  return mIntrinsicPadding + firstChildMinHeight + mBottomStackPeekSize+ mBottomStackSlowDownHeight;
}",0.9707401032702238
192275,"/** 
 * Update the height of the first child i.e clamp it to the bottom stack
 * @param child the child to update
 * @param childViewState the viewstate of the child
 * @param childHeight the height of the child
 * @param ambientState The ambient state of the algorithm
 */
private void updateFirstChildHeight(ExpandableView child,StackViewState childViewState,int childHeight,AmbientState ambientState){
  int bottomPeekStart=ambientState.getInnerHeight() - mBottomStackPeekSize - mBottomStackSlowDownLength + ambientState.getScrollY();
  childViewState.height=(int)Math.max(Math.min(bottomPeekStart,(float)childHeight),child.getMinHeight());
}","/** 
 * Update the height of the first child i.e clamp it to the bottom stack
 * @param child the child to update
 * @param childViewState the viewstate of the child
 * @param childHeight the height of the child
 * @param ambientState The ambient state of the algorithm
 */
private void updateFirstChildHeight(ExpandableView child,StackViewState childViewState,int childHeight,AmbientState ambientState){
  int bottomPeekStart=ambientState.getInnerHeight() - mBottomStackPeekSize - mBottomStackSlowDownLength + ambientState.getScrollY();
  childViewState.height=(int)Math.max(Math.min(bottomPeekStart,(float)childHeight),child.getCollapsedHeight());
}",0.9907407407407408
192276,"/** 
 * Determine the positions for the views. This is the main part of the algorithm.
 * @param resultState The result state to update if a change to the properties of a child occurs
 * @param algorithmState The state in which the current pass of the algorithm is currently in
 * @param ambientState The current ambient state
 */
private void updatePositionsForState(StackScrollState resultState,StackScrollAlgorithmState algorithmState,AmbientState ambientState){
  float bottomPeekStart=ambientState.getInnerHeight() - mBottomStackPeekSize;
  float bottomStackStart=bottomPeekStart - mBottomStackSlowDownLength;
  float currentYPosition=-algorithmState.scrollY;
  int childCount=algorithmState.visibleChildren.size();
  int paddingAfterChild;
  for (int i=0; i < childCount; i++) {
    ExpandableView child=algorithmState.visibleChildren.get(i);
    StackViewState childViewState=resultState.getViewStateForView(child);
    childViewState.location=StackViewState.LOCATION_UNKNOWN;
    paddingAfterChild=getPaddingAfterChild(algorithmState,child);
    int childHeight=getMaxAllowedChildHeight(child);
    int minHeight=child.getMinHeight();
    childViewState.yTranslation=currentYPosition;
    if (i == 0) {
      updateFirstChildHeight(child,childViewState,childHeight,ambientState);
    }
    float nextYPosition=currentYPosition + childHeight + paddingAfterChild;
    if (nextYPosition >= bottomStackStart) {
      if (currentYPosition >= bottomStackStart) {
        updateStateForChildFullyInBottomStack(algorithmState,bottomStackStart,childViewState,minHeight,ambientState,child);
      }
 else {
        updateStateForChildTransitioningInBottom(algorithmState,bottomStackStart,child,currentYPosition,childViewState,childHeight);
      }
    }
 else {
      childViewState.location=StackViewState.LOCATION_MAIN_AREA;
      clampPositionToBottomStackStart(childViewState,childViewState.height,childHeight,ambientState);
    }
    if (i == 0 && ambientState.getScrollY() <= 0) {
      childViewState.yTranslation=Math.max(0,childViewState.yTranslation);
    }
    currentYPosition=childViewState.yTranslation + childHeight + paddingAfterChild;
    if (currentYPosition <= 0) {
      childViewState.location=StackViewState.LOCATION_HIDDEN_TOP;
    }
    if (childViewState.location == StackViewState.LOCATION_UNKNOWN) {
      Log.wtf(LOG_TAG,""String_Node_Str"" + i);
    }
    childViewState.yTranslation+=ambientState.getTopPadding() + ambientState.getStackTranslation();
  }
}","/** 
 * Determine the positions for the views. This is the main part of the algorithm.
 * @param resultState The result state to update if a change to the properties of a child occurs
 * @param algorithmState The state in which the current pass of the algorithm is currently in
 * @param ambientState The current ambient state
 */
private void updatePositionsForState(StackScrollState resultState,StackScrollAlgorithmState algorithmState,AmbientState ambientState){
  float bottomPeekStart=ambientState.getInnerHeight() - mBottomStackPeekSize;
  float bottomStackStart=bottomPeekStart - mBottomStackSlowDownLength;
  float currentYPosition=-algorithmState.scrollY;
  int childCount=algorithmState.visibleChildren.size();
  int paddingAfterChild;
  for (int i=0; i < childCount; i++) {
    ExpandableView child=algorithmState.visibleChildren.get(i);
    StackViewState childViewState=resultState.getViewStateForView(child);
    childViewState.location=StackViewState.LOCATION_UNKNOWN;
    paddingAfterChild=getPaddingAfterChild(algorithmState,child);
    int childHeight=getMaxAllowedChildHeight(child);
    int collapsedHeight=child.getCollapsedHeight();
    childViewState.yTranslation=currentYPosition;
    if (i == 0) {
      updateFirstChildHeight(child,childViewState,childHeight,ambientState);
    }
    float nextYPosition=currentYPosition + childHeight + paddingAfterChild;
    if (nextYPosition >= bottomStackStart) {
      if (currentYPosition >= bottomStackStart) {
        updateStateForChildFullyInBottomStack(algorithmState,bottomStackStart,childViewState,collapsedHeight,ambientState,child);
      }
 else {
        updateStateForChildTransitioningInBottom(algorithmState,bottomStackStart,child,currentYPosition,childViewState,childHeight);
      }
    }
 else {
      childViewState.location=StackViewState.LOCATION_MAIN_AREA;
      clampPositionToBottomStackStart(childViewState,childViewState.height,childHeight,ambientState);
    }
    if (i == 0 && ambientState.getScrollY() <= 0) {
      childViewState.yTranslation=Math.max(0,childViewState.yTranslation);
    }
    currentYPosition=childViewState.yTranslation + childHeight + paddingAfterChild;
    if (currentYPosition <= 0) {
      childViewState.location=StackViewState.LOCATION_HIDDEN_TOP;
    }
    if (childViewState.location == StackViewState.LOCATION_UNKNOWN) {
      Log.wtf(LOG_TAG,""String_Node_Str"" + i);
    }
    childViewState.yTranslation+=ambientState.getTopPadding() + ambientState.getStackTranslation();
  }
}",0.9927739863508632
192277,"private void updateStateForChildTransitioningInBottom(StackScrollAlgorithmState algorithmState,float transitioningPositionStart,ExpandableView child,float currentYPosition,StackViewState childViewState,int childHeight){
  algorithmState.partialInBottom=1.0f - ((transitioningPositionStart - currentYPosition) / (childHeight + getPaddingAfterChild(algorithmState,child)));
  float offset=mBottomStackIndentationFunctor.getValue(algorithmState.partialInBottom);
  algorithmState.itemsInBottomStack+=algorithmState.partialInBottom;
  int newHeight=childHeight;
  if (childHeight > child.getMinHeight()) {
    newHeight=(int)Math.max(Math.min(transitioningPositionStart + offset - getPaddingAfterChild(algorithmState,child) - currentYPosition,childHeight),child.getMinHeight());
    childViewState.height=newHeight;
  }
  childViewState.yTranslation=transitioningPositionStart + offset - newHeight - getPaddingAfterChild(algorithmState,child);
  childViewState.location=StackViewState.LOCATION_MAIN_AREA;
}","private void updateStateForChildTransitioningInBottom(StackScrollAlgorithmState algorithmState,float transitioningPositionStart,ExpandableView child,float currentYPosition,StackViewState childViewState,int childHeight){
  algorithmState.partialInBottom=1.0f - ((transitioningPositionStart - currentYPosition) / (childHeight + getPaddingAfterChild(algorithmState,child)));
  float offset=mBottomStackIndentationFunctor.getValue(algorithmState.partialInBottom);
  algorithmState.itemsInBottomStack+=algorithmState.partialInBottom;
  int newHeight=childHeight;
  if (childHeight > child.getCollapsedHeight()) {
    newHeight=(int)Math.max(Math.min(transitioningPositionStart + offset - getPaddingAfterChild(algorithmState,child) - currentYPosition,childHeight),child.getCollapsedHeight());
    childViewState.height=newHeight;
  }
  childViewState.yTranslation=transitioningPositionStart + offset - newHeight - getPaddingAfterChild(algorithmState,child);
  childViewState.location=StackViewState.LOCATION_MAIN_AREA;
}",0.988095238095238
192278,"private void clampHunToTop(AmbientState ambientState,ExpandableNotificationRow row,StackViewState childState){
  float newTranslation=Math.max(ambientState.getTopPadding() + ambientState.getStackTranslation(),childState.yTranslation);
  childState.height=(int)Math.max(childState.height - (newTranslation - childState.yTranslation),row.getMinHeight());
  childState.yTranslation=newTranslation;
}","private void clampHunToTop(AmbientState ambientState,ExpandableNotificationRow row,StackViewState childState){
  float newTranslation=Math.max(ambientState.getTopPadding() + ambientState.getStackTranslation(),childState.yTranslation);
  childState.height=(int)Math.max(childState.height - (newTranslation - childState.yTranslation),row.getCollapsedHeight());
  childState.yTranslation=newTranslation;
}",0.9849624060150376
192279,"private void clampHunToMaxTranslation(AmbientState ambientState,ExpandableNotificationRow row,StackViewState childState){
  float newTranslation;
  float bottomPosition=ambientState.getMaxHeadsUpTranslation() - row.getMinHeight();
  newTranslation=Math.min(childState.yTranslation,bottomPosition);
  childState.height=(int)Math.max(childState.height - (childState.yTranslation - newTranslation),row.getMinHeight());
  childState.yTranslation=newTranslation;
}","private void clampHunToMaxTranslation(AmbientState ambientState,ExpandableNotificationRow row,StackViewState childState){
  float newTranslation;
  float bottomPosition=ambientState.getMaxHeadsUpTranslation() - row.getCollapsedHeight();
  newTranslation=Math.min(childState.yTranslation,bottomPosition);
  childState.height=(int)Math.max(childState.height - (childState.yTranslation - newTranslation),row.getCollapsedHeight());
  childState.yTranslation=newTranslation;
}",0.9741935483870968
192280,"private void updateStateForChildFullyInBottomStack(StackScrollAlgorithmState algorithmState,float transitioningPositionStart,StackViewState childViewState,int minHeight,AmbientState ambientState,ExpandableView child){
  float currentYPosition;
  algorithmState.itemsInBottomStack+=1.0f;
  if (algorithmState.itemsInBottomStack < MAX_ITEMS_IN_BOTTOM_STACK) {
    currentYPosition=transitioningPositionStart + mBottomStackIndentationFunctor.getValue(algorithmState.itemsInBottomStack) - getPaddingAfterChild(algorithmState,child);
    childViewState.location=StackViewState.LOCATION_BOTTOM_STACK_PEEKING;
  }
 else {
    if (algorithmState.itemsInBottomStack > MAX_ITEMS_IN_BOTTOM_STACK + 2) {
      childViewState.hidden=true;
      childViewState.shadowAlpha=0.0f;
    }
 else     if (algorithmState.itemsInBottomStack > MAX_ITEMS_IN_BOTTOM_STACK + 1) {
      childViewState.shadowAlpha=1.0f - algorithmState.partialInBottom;
    }
    childViewState.location=StackViewState.LOCATION_BOTTOM_STACK_HIDDEN;
    currentYPosition=ambientState.getInnerHeight();
  }
  childViewState.height=minHeight;
  childViewState.yTranslation=currentYPosition - minHeight;
}","private void updateStateForChildFullyInBottomStack(StackScrollAlgorithmState algorithmState,float transitioningPositionStart,StackViewState childViewState,int collapsedHeight,AmbientState ambientState,ExpandableView child){
  float currentYPosition;
  algorithmState.itemsInBottomStack+=1.0f;
  if (algorithmState.itemsInBottomStack < MAX_ITEMS_IN_BOTTOM_STACK) {
    currentYPosition=transitioningPositionStart + mBottomStackIndentationFunctor.getValue(algorithmState.itemsInBottomStack) - getPaddingAfterChild(algorithmState,child);
    childViewState.location=StackViewState.LOCATION_BOTTOM_STACK_PEEKING;
  }
 else {
    if (algorithmState.itemsInBottomStack > MAX_ITEMS_IN_BOTTOM_STACK + 2) {
      childViewState.hidden=true;
      childViewState.shadowAlpha=0.0f;
    }
 else     if (algorithmState.itemsInBottomStack > MAX_ITEMS_IN_BOTTOM_STACK + 1) {
      childViewState.shadowAlpha=1.0f - algorithmState.partialInBottom;
    }
    childViewState.location=StackViewState.LOCATION_BOTTOM_STACK_HIDDEN;
    currentYPosition=ambientState.getInnerHeight();
  }
  childViewState.height=collapsedHeight;
  childViewState.yTranslation=currentYPosition - collapsedHeight;
}",0.9845626072041166
192281,"ComponentName startServiceLocked(IApplicationThread caller,Intent service,String resolvedType,int callingPid,int callingUid,String callingPackage,final int userId) throws TransactionTooLargeException {
  if (DEBUG_DELAYED_STARTS)   Slog.v(TAG_SERVICE,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ service.getExtras());
  final boolean callerFg;
  if (caller != null) {
    final ProcessRecord callerApp=mAm.getRecordForAppLocked(caller);
    if (callerApp == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ service);
    }
    callerFg=callerApp.setSchedGroup != ProcessList.SCHED_GROUP_BACKGROUND;
  }
 else {
    callerFg=true;
  }
  ServiceLookupResult res=retrieveServiceLocked(service,resolvedType,callingPackage,callingPid,callingUid,userId,true,callerFg,false);
  if (res == null) {
    return null;
  }
  if (res.record == null) {
    return new ComponentName(""String_Node_Str"",res.permission != null ? res.permission : ""String_Node_Str"");
  }
  ServiceRecord r=res.record;
  if (!mAm.mUserController.exists(r.userId)) {
    Slog.w(TAG,""String_Node_Str"" + r.userId);
    return null;
  }
  NeededUriGrants neededGrants=mAm.checkGrantUriPermissionFromIntentLocked(callingUid,r.packageName,service,service.getFlags(),null,r.userId);
  if (Build.PERMISSIONS_REVIEW_REQUIRED) {
    if (!requestStartTargetPermissionsReviewIfNeededLocked(r,callingPackage,callingUid,service,callerFg,userId)) {
      return null;
    }
  }
  if (unscheduleServiceRestartLocked(r,callingUid,false)) {
    if (DEBUG_SERVICE)     Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
  }
  r.lastActivity=SystemClock.uptimeMillis();
  r.startRequested=true;
  r.delayedStop=false;
  r.pendingStarts.add(new ServiceRecord.StartItem(r,false,r.makeNextStartId(),service,neededGrants));
  final ServiceMap smap=getServiceMap(r.userId);
  boolean addToStarting=false;
  if (!callerFg && r.app == null && mAm.mUserController.hasStartedUserState(r.userId)) {
    ProcessRecord proc=mAm.getProcessRecordLocked(r.processName,r.appInfo.uid,false);
    if (proc == null || proc.curProcState > ActivityManager.PROCESS_STATE_RECEIVER) {
      if (DEBUG_DELAYED_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + r + ""String_Node_Str""+ proc);
      if (r.delayed) {
        if (DEBUG_DELAYED_STARTS)         Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
        return r.name;
      }
      if (smap.mStartingBackground.size() >= mMaxStartingBackground) {
        Slog.i(TAG_SERVICE,""String_Node_Str"" + r);
        smap.mDelayedStartList.add(r);
        r.delayed=true;
        return r.name;
      }
      if (DEBUG_DELAYED_STARTS)       Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
      addToStarting=true;
    }
 else     if (proc.curProcState >= ActivityManager.PROCESS_STATE_SERVICE) {
      addToStarting=true;
      if (DEBUG_DELAYED_STARTS)       Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
    }
 else     if (DEBUG_DELAYED_STARTS) {
      StringBuilder sb=new StringBuilder(128);
      sb.append(""String_Node_Str"").append(proc.curProcState).append(' ').append(proc.adjType);
      String reason=proc.makeAdjReason();
      if (reason != null) {
        sb.append(' ');
        sb.append(reason);
      }
      sb.append(""String_Node_Str"");
      sb.append(r.toString());
      Slog.v(TAG_SERVICE,sb.toString());
    }
  }
 else   if (DEBUG_DELAYED_STARTS) {
    if (callerFg) {
      Slog.v(TAG_SERVICE,""String_Node_Str"" + callerFg + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ r);
    }
 else     if (r.app != null) {
      Slog.v(TAG_SERVICE,""String_Node_Str"" + r.app + ""String_Node_Str""+ r);
    }
 else {
      Slog.v(TAG_SERVICE,""String_Node_Str"" + r.userId + ""String_Node_Str""+ r);
    }
  }
  return startServiceInnerLocked(smap,service,r,callerFg,addToStarting);
}","ComponentName startServiceLocked(IApplicationThread caller,Intent service,String resolvedType,int callingPid,int callingUid,String callingPackage,final int userId) throws TransactionTooLargeException {
  if (DEBUG_DELAYED_STARTS)   Slog.v(TAG_SERVICE,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ service.getExtras());
  final boolean callerFg;
  if (caller != null) {
    final ProcessRecord callerApp=mAm.getRecordForAppLocked(caller);
    if (callerApp == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ service);
    }
    callerFg=callerApp.setSchedGroup != ProcessList.SCHED_GROUP_BACKGROUND;
  }
 else {
    callerFg=true;
  }
  ServiceLookupResult res=retrieveServiceLocked(service,resolvedType,callingPackage,callingPid,callingUid,userId,true,callerFg,false);
  if (res == null) {
    return null;
  }
  if (res.record == null) {
    return new ComponentName(""String_Node_Str"",res.permission != null ? res.permission : ""String_Node_Str"");
  }
  ServiceRecord r=res.record;
  if (!mAm.mUserController.exists(r.userId)) {
    Slog.w(TAG,""String_Node_Str"" + r.userId);
    return null;
  }
  if (!r.startRequested) {
    final long token=Binder.clearCallingIdentity();
    try {
      final int allowed=mAm.checkAllowBackgroundLocked(r.appInfo.uid,r.packageName,callingPid,true);
      if (allowed != ActivityManager.APP_START_MODE_NORMAL) {
        Slog.w(TAG,""String_Node_Str"" + service + ""String_Node_Str""+ r.name.flattenToShortString()+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ callingPackage);
        return null;
      }
    }
  finally {
      Binder.restoreCallingIdentity(token);
    }
  }
  NeededUriGrants neededGrants=mAm.checkGrantUriPermissionFromIntentLocked(callingUid,r.packageName,service,service.getFlags(),null,r.userId);
  if (Build.PERMISSIONS_REVIEW_REQUIRED) {
    if (!requestStartTargetPermissionsReviewIfNeededLocked(r,callingPackage,callingUid,service,callerFg,userId)) {
      return null;
    }
  }
  if (unscheduleServiceRestartLocked(r,callingUid,false)) {
    if (DEBUG_SERVICE)     Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
  }
  r.lastActivity=SystemClock.uptimeMillis();
  r.startRequested=true;
  r.delayedStop=false;
  r.pendingStarts.add(new ServiceRecord.StartItem(r,false,r.makeNextStartId(),service,neededGrants));
  final ServiceMap smap=getServiceMap(r.userId);
  boolean addToStarting=false;
  if (!callerFg && r.app == null && mAm.mUserController.hasStartedUserState(r.userId)) {
    ProcessRecord proc=mAm.getProcessRecordLocked(r.processName,r.appInfo.uid,false);
    if (proc == null || proc.curProcState > ActivityManager.PROCESS_STATE_RECEIVER) {
      if (DEBUG_DELAYED_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + r + ""String_Node_Str""+ proc);
      if (r.delayed) {
        if (DEBUG_DELAYED_STARTS)         Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
        return r.name;
      }
      if (smap.mStartingBackground.size() >= mMaxStartingBackground) {
        Slog.i(TAG_SERVICE,""String_Node_Str"" + r);
        smap.mDelayedStartList.add(r);
        r.delayed=true;
        return r.name;
      }
      if (DEBUG_DELAYED_STARTS)       Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
      addToStarting=true;
    }
 else     if (proc.curProcState >= ActivityManager.PROCESS_STATE_SERVICE) {
      addToStarting=true;
      if (DEBUG_DELAYED_STARTS)       Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
    }
 else     if (DEBUG_DELAYED_STARTS) {
      StringBuilder sb=new StringBuilder(128);
      sb.append(""String_Node_Str"").append(proc.curProcState).append(' ').append(proc.adjType);
      String reason=proc.makeAdjReason();
      if (reason != null) {
        sb.append(' ');
        sb.append(reason);
      }
      sb.append(""String_Node_Str"");
      sb.append(r.toString());
      Slog.v(TAG_SERVICE,sb.toString());
    }
  }
 else   if (DEBUG_DELAYED_STARTS) {
    if (callerFg) {
      Slog.v(TAG_SERVICE,""String_Node_Str"" + callerFg + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ r);
    }
 else     if (r.app != null) {
      Slog.v(TAG_SERVICE,""String_Node_Str"" + r.app + ""String_Node_Str""+ r);
    }
 else {
      Slog.v(TAG_SERVICE,""String_Node_Str"" + r.userId + ""String_Node_Str""+ r);
    }
  }
  return startServiceInnerLocked(smap,service,r,callerFg,addToStarting);
}",0.934068568688564
192282,"private ServiceLookupResult retrieveServiceLocked(Intent service,String resolvedType,String callingPackage,int callingPid,int callingUid,int userId,boolean createIfNeeded,boolean callingFromFg,boolean isBindExternal){
  ServiceRecord r=null;
  if (DEBUG_SERVICE)   Slog.v(TAG_SERVICE,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ callingUid);
  userId=mAm.mUserController.handleIncomingUser(callingPid,callingUid,userId,false,ActivityManagerService.ALLOW_NON_FULL_IN_PROFILE,""String_Node_Str"",null);
  ServiceMap smap=getServiceMap(userId);
  final ComponentName comp=service.getComponent();
  if (comp != null) {
    r=smap.mServicesByName.get(comp);
  }
  if (r == null && !isBindExternal) {
    Intent.FilterComparison filter=new Intent.FilterComparison(service);
    r=smap.mServicesByIntent.get(filter);
  }
  if (r != null && (r.serviceInfo.flags & ServiceInfo.FLAG_EXTERNAL_SERVICE) != 0 && !callingPackage.equals(r.packageName)) {
    r=null;
  }
  if (r == null) {
    try {
      ResolveInfo rInfo=AppGlobals.getPackageManager().resolveService(service,resolvedType,ActivityManagerService.STOCK_PM_FLAGS | PackageManager.MATCH_DEBUG_TRIAGED_MISSING,userId);
      ServiceInfo sInfo=rInfo != null ? rInfo.serviceInfo : null;
      if (sInfo == null) {
        Slog.w(TAG_SERVICE,""String_Node_Str"" + service + ""String_Node_Str""+ userId+ ""String_Node_Str"");
        return null;
      }
      ComponentName name=new ComponentName(sInfo.applicationInfo.packageName,sInfo.name);
      if ((sInfo.flags & ServiceInfo.FLAG_EXTERNAL_SERVICE) != 0) {
        if (isBindExternal) {
          if (!sInfo.exported) {
            throw new SecurityException(""String_Node_Str"" + name + ""String_Node_Str"");
          }
          if ((sInfo.flags & ServiceInfo.FLAG_ISOLATED_PROCESS) == 0) {
            throw new SecurityException(""String_Node_Str"" + name + ""String_Node_Str"");
          }
          ApplicationInfo aInfo=AppGlobals.getPackageManager().getApplicationInfo(callingPackage,ActivityManagerService.STOCK_PM_FLAGS,userId);
          if (aInfo == null) {
            throw new SecurityException(""String_Node_Str"" + ""String_Node_Str"" + callingPackage);
          }
          sInfo=new ServiceInfo(sInfo);
          sInfo.applicationInfo=new ApplicationInfo(sInfo.applicationInfo);
          sInfo.applicationInfo.packageName=aInfo.packageName;
          sInfo.applicationInfo.uid=aInfo.uid;
          name=new ComponentName(aInfo.packageName,name.getClassName());
          service.setComponent(name);
        }
 else {
          throw new SecurityException(""String_Node_Str"" + name);
        }
      }
 else       if (isBindExternal) {
        throw new SecurityException(""String_Node_Str"" + name + ""String_Node_Str"");
      }
      if (userId > 0) {
        if (mAm.isSingleton(sInfo.processName,sInfo.applicationInfo,sInfo.name,sInfo.flags) && mAm.isValidSingletonCall(callingUid,sInfo.applicationInfo.uid)) {
          userId=0;
          smap=getServiceMap(0);
        }
        sInfo=new ServiceInfo(sInfo);
        sInfo.applicationInfo=mAm.getAppInfoForUser(sInfo.applicationInfo,userId);
      }
      r=smap.mServicesByName.get(name);
      if (r == null && createIfNeeded) {
        final long token=Binder.clearCallingIdentity();
        try {
          final int allowed=mAm.checkAllowBackgroundLocked(sInfo.applicationInfo.uid,sInfo.packageName,callingPid,true);
          if (allowed != ActivityManager.APP_START_MODE_NORMAL) {
            Slog.w(TAG,""String_Node_Str"" + service + ""String_Node_Str""+ name.flattenToShortString()+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ callingPackage);
            return null;
          }
        }
  finally {
          Binder.restoreCallingIdentity(token);
        }
        Intent.FilterComparison filter=new Intent.FilterComparison(service.cloneFilter());
        ServiceRestarter res=new ServiceRestarter();
        BatteryStatsImpl.Uid.Pkg.Serv ss=null;
        BatteryStatsImpl stats=mAm.mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
          ss=stats.getServiceStatsLocked(sInfo.applicationInfo.uid,sInfo.packageName,sInfo.name);
        }
        r=new ServiceRecord(mAm,ss,name,filter,sInfo,callingFromFg,res);
        res.setService(r);
        smap.mServicesByName.put(name,r);
        smap.mServicesByIntent.put(filter,r);
        for (int i=mPendingServices.size() - 1; i >= 0; i--) {
          ServiceRecord pr=mPendingServices.get(i);
          if (pr.serviceInfo.applicationInfo.uid == sInfo.applicationInfo.uid && pr.name.equals(name)) {
            mPendingServices.remove(i);
          }
        }
      }
    }
 catch (    RemoteException ex) {
    }
  }
  if (r != null) {
    if (mAm.checkComponentPermission(r.permission,callingPid,callingUid,r.appInfo.uid,r.exported) != PackageManager.PERMISSION_GRANTED) {
      if (!r.exported) {
        Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ r.appInfo.uid);
        return new ServiceLookupResult(null,""String_Node_Str"" + r.appInfo.uid);
      }
      Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ r.permission);
      return new ServiceLookupResult(null,r.permission);
    }
 else     if (r.permission != null && callingPackage != null) {
      final int opCode=AppOpsManager.permissionToOpCode(r.permission);
      if (opCode != AppOpsManager.OP_NONE && mAm.mAppOpsService.noteOperation(opCode,callingUid,callingPackage) != AppOpsManager.MODE_ALLOWED) {
        Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ AppOpsManager.opToName(opCode));
        return null;
      }
    }
    if (!mAm.mIntentFirewall.checkService(r.name,service,callingUid,callingPid,resolvedType,r.appInfo)) {
      return null;
    }
    return new ServiceLookupResult(r,null);
  }
  return null;
}","private ServiceLookupResult retrieveServiceLocked(Intent service,String resolvedType,String callingPackage,int callingPid,int callingUid,int userId,boolean createIfNeeded,boolean callingFromFg,boolean isBindExternal){
  ServiceRecord r=null;
  if (DEBUG_SERVICE)   Slog.v(TAG_SERVICE,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ callingUid);
  userId=mAm.mUserController.handleIncomingUser(callingPid,callingUid,userId,false,ActivityManagerService.ALLOW_NON_FULL_IN_PROFILE,""String_Node_Str"",null);
  ServiceMap smap=getServiceMap(userId);
  final ComponentName comp=service.getComponent();
  if (comp != null) {
    r=smap.mServicesByName.get(comp);
  }
  if (r == null && !isBindExternal) {
    Intent.FilterComparison filter=new Intent.FilterComparison(service);
    r=smap.mServicesByIntent.get(filter);
  }
  if (r != null && (r.serviceInfo.flags & ServiceInfo.FLAG_EXTERNAL_SERVICE) != 0 && !callingPackage.equals(r.packageName)) {
    r=null;
  }
  if (r == null) {
    try {
      ResolveInfo rInfo=AppGlobals.getPackageManager().resolveService(service,resolvedType,ActivityManagerService.STOCK_PM_FLAGS | PackageManager.MATCH_DEBUG_TRIAGED_MISSING,userId);
      ServiceInfo sInfo=rInfo != null ? rInfo.serviceInfo : null;
      if (sInfo == null) {
        Slog.w(TAG_SERVICE,""String_Node_Str"" + service + ""String_Node_Str""+ userId+ ""String_Node_Str"");
        return null;
      }
      ComponentName name=new ComponentName(sInfo.applicationInfo.packageName,sInfo.name);
      if ((sInfo.flags & ServiceInfo.FLAG_EXTERNAL_SERVICE) != 0) {
        if (isBindExternal) {
          if (!sInfo.exported) {
            throw new SecurityException(""String_Node_Str"" + name + ""String_Node_Str"");
          }
          if ((sInfo.flags & ServiceInfo.FLAG_ISOLATED_PROCESS) == 0) {
            throw new SecurityException(""String_Node_Str"" + name + ""String_Node_Str"");
          }
          ApplicationInfo aInfo=AppGlobals.getPackageManager().getApplicationInfo(callingPackage,ActivityManagerService.STOCK_PM_FLAGS,userId);
          if (aInfo == null) {
            throw new SecurityException(""String_Node_Str"" + ""String_Node_Str"" + callingPackage);
          }
          sInfo=new ServiceInfo(sInfo);
          sInfo.applicationInfo=new ApplicationInfo(sInfo.applicationInfo);
          sInfo.applicationInfo.packageName=aInfo.packageName;
          sInfo.applicationInfo.uid=aInfo.uid;
          name=new ComponentName(aInfo.packageName,name.getClassName());
          service.setComponent(name);
        }
 else {
          throw new SecurityException(""String_Node_Str"" + name);
        }
      }
 else       if (isBindExternal) {
        throw new SecurityException(""String_Node_Str"" + name + ""String_Node_Str"");
      }
      if (userId > 0) {
        if (mAm.isSingleton(sInfo.processName,sInfo.applicationInfo,sInfo.name,sInfo.flags) && mAm.isValidSingletonCall(callingUid,sInfo.applicationInfo.uid)) {
          userId=0;
          smap=getServiceMap(0);
        }
        sInfo=new ServiceInfo(sInfo);
        sInfo.applicationInfo=mAm.getAppInfoForUser(sInfo.applicationInfo,userId);
      }
      r=smap.mServicesByName.get(name);
      if (r == null && createIfNeeded) {
        Intent.FilterComparison filter=new Intent.FilterComparison(service.cloneFilter());
        ServiceRestarter res=new ServiceRestarter();
        BatteryStatsImpl.Uid.Pkg.Serv ss=null;
        BatteryStatsImpl stats=mAm.mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
          ss=stats.getServiceStatsLocked(sInfo.applicationInfo.uid,sInfo.packageName,sInfo.name);
        }
        r=new ServiceRecord(mAm,ss,name,filter,sInfo,callingFromFg,res);
        res.setService(r);
        smap.mServicesByName.put(name,r);
        smap.mServicesByIntent.put(filter,r);
        for (int i=mPendingServices.size() - 1; i >= 0; i--) {
          ServiceRecord pr=mPendingServices.get(i);
          if (pr.serviceInfo.applicationInfo.uid == sInfo.applicationInfo.uid && pr.name.equals(name)) {
            mPendingServices.remove(i);
          }
        }
      }
    }
 catch (    RemoteException ex) {
    }
  }
  if (r != null) {
    if (mAm.checkComponentPermission(r.permission,callingPid,callingUid,r.appInfo.uid,r.exported) != PackageManager.PERMISSION_GRANTED) {
      if (!r.exported) {
        Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ r.appInfo.uid);
        return new ServiceLookupResult(null,""String_Node_Str"" + r.appInfo.uid);
      }
      Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ r.permission);
      return new ServiceLookupResult(null,r.permission);
    }
 else     if (r.permission != null && callingPackage != null) {
      final int opCode=AppOpsManager.permissionToOpCode(r.permission);
      if (opCode != AppOpsManager.OP_NONE && mAm.mAppOpsService.noteOperation(opCode,callingUid,callingPackage) != AppOpsManager.MODE_ALLOWED) {
        Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ AppOpsManager.opToName(opCode));
        return null;
      }
    }
    if (!mAm.mIntentFirewall.checkService(r.name,service,callingUid,callingPid,resolvedType,r.appInfo)) {
      return null;
    }
    return new ServiceLookupResult(r,null);
  }
  return null;
}",0.9500218054949848
192283,"ComponentName startServiceLocked(IApplicationThread caller,Intent service,String resolvedType,int callingPid,int callingUid,String callingPackage,final int userId) throws TransactionTooLargeException {
  if (DEBUG_DELAYED_STARTS)   Slog.v(TAG_SERVICE,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ service.getExtras());
  final boolean callerFg;
  if (caller != null) {
    final ProcessRecord callerApp=mAm.getRecordForAppLocked(caller);
    if (callerApp == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ service);
    }
    callerFg=callerApp.setSchedGroup != ProcessList.SCHED_GROUP_BACKGROUND;
  }
 else {
    callerFg=true;
  }
  ServiceLookupResult res=retrieveServiceLocked(service,resolvedType,callingPackage,callingPid,callingUid,userId,true,callerFg,false);
  if (res == null) {
    return null;
  }
  if (res.record == null) {
    return new ComponentName(""String_Node_Str"",res.permission != null ? res.permission : ""String_Node_Str"");
  }
  ServiceRecord r=res.record;
  if (!mAm.mUserController.exists(r.userId)) {
    Slog.w(TAG,""String_Node_Str"" + r.userId);
    return null;
  }
  NeededUriGrants neededGrants=mAm.checkGrantUriPermissionFromIntentLocked(callingUid,r.packageName,service,service.getFlags(),null,r.userId);
  if (Build.PERMISSIONS_REVIEW_REQUIRED) {
    if (!requestStartTargetPermissionsReviewIfNeededLocked(r,callingPackage,callingUid,service,callerFg,userId)) {
      return null;
    }
  }
  if (unscheduleServiceRestartLocked(r,callingUid,false)) {
    if (DEBUG_SERVICE)     Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
  }
  r.lastActivity=SystemClock.uptimeMillis();
  r.startRequested=true;
  r.delayedStop=false;
  r.pendingStarts.add(new ServiceRecord.StartItem(r,false,r.makeNextStartId(),service,neededGrants));
  final ServiceMap smap=getServiceMap(r.userId);
  boolean addToStarting=false;
  if (!callerFg && r.app == null && mAm.mUserController.hasStartedUserState(r.userId)) {
    ProcessRecord proc=mAm.getProcessRecordLocked(r.processName,r.appInfo.uid,false);
    if (proc == null || proc.curProcState > ActivityManager.PROCESS_STATE_RECEIVER) {
      if (DEBUG_DELAYED_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + r + ""String_Node_Str""+ proc);
      if (r.delayed) {
        if (DEBUG_DELAYED_STARTS)         Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
        return r.name;
      }
      if (smap.mStartingBackground.size() >= mMaxStartingBackground) {
        Slog.i(TAG_SERVICE,""String_Node_Str"" + r);
        smap.mDelayedStartList.add(r);
        r.delayed=true;
        return r.name;
      }
      if (DEBUG_DELAYED_STARTS)       Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
      addToStarting=true;
    }
 else     if (proc.curProcState >= ActivityManager.PROCESS_STATE_SERVICE) {
      addToStarting=true;
      if (DEBUG_DELAYED_STARTS)       Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
    }
 else     if (DEBUG_DELAYED_STARTS) {
      StringBuilder sb=new StringBuilder(128);
      sb.append(""String_Node_Str"").append(proc.curProcState).append(' ').append(proc.adjType);
      String reason=proc.makeAdjReason();
      if (reason != null) {
        sb.append(' ');
        sb.append(reason);
      }
      sb.append(""String_Node_Str"");
      sb.append(r.toString());
      Slog.v(TAG_SERVICE,sb.toString());
    }
  }
 else   if (DEBUG_DELAYED_STARTS) {
    if (callerFg) {
      Slog.v(TAG_SERVICE,""String_Node_Str"" + callerFg + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ r);
    }
 else     if (r.app != null) {
      Slog.v(TAG_SERVICE,""String_Node_Str"" + r.app + ""String_Node_Str""+ r);
    }
 else {
      Slog.v(TAG_SERVICE,""String_Node_Str"" + r.userId + ""String_Node_Str""+ r);
    }
  }
  return startServiceInnerLocked(smap,service,r,callerFg,addToStarting);
}","ComponentName startServiceLocked(IApplicationThread caller,Intent service,String resolvedType,int callingPid,int callingUid,String callingPackage,final int userId) throws TransactionTooLargeException {
  if (DEBUG_DELAYED_STARTS)   Slog.v(TAG_SERVICE,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ service.getExtras());
  final boolean callerFg;
  if (caller != null) {
    final ProcessRecord callerApp=mAm.getRecordForAppLocked(caller);
    if (callerApp == null) {
      throw new SecurityException(""String_Node_Str"" + caller + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ service);
    }
    callerFg=callerApp.setSchedGroup != ProcessList.SCHED_GROUP_BACKGROUND;
  }
 else {
    callerFg=true;
  }
  ServiceLookupResult res=retrieveServiceLocked(service,resolvedType,callingPackage,callingPid,callingUid,userId,true,callerFg,false);
  if (res == null) {
    return null;
  }
  if (res.record == null) {
    return new ComponentName(""String_Node_Str"",res.permission != null ? res.permission : ""String_Node_Str"");
  }
  ServiceRecord r=res.record;
  if (!mAm.mUserController.exists(r.userId)) {
    Slog.w(TAG,""String_Node_Str"" + r.userId);
    return null;
  }
  if (!r.startRequested) {
    final long token=Binder.clearCallingIdentity();
    try {
      final int allowed=mAm.checkAllowBackgroundLocked(r.appInfo.uid,r.packageName,callingPid,true);
      if (allowed != ActivityManager.APP_START_MODE_NORMAL) {
        Slog.w(TAG,""String_Node_Str"" + service + ""String_Node_Str""+ r.name.flattenToShortString()+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ callingPackage);
        return null;
      }
    }
  finally {
      Binder.restoreCallingIdentity(token);
    }
  }
  NeededUriGrants neededGrants=mAm.checkGrantUriPermissionFromIntentLocked(callingUid,r.packageName,service,service.getFlags(),null,r.userId);
  if (Build.PERMISSIONS_REVIEW_REQUIRED) {
    if (!requestStartTargetPermissionsReviewIfNeededLocked(r,callingPackage,callingUid,service,callerFg,userId)) {
      return null;
    }
  }
  if (unscheduleServiceRestartLocked(r,callingUid,false)) {
    if (DEBUG_SERVICE)     Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
  }
  r.lastActivity=SystemClock.uptimeMillis();
  r.startRequested=true;
  r.delayedStop=false;
  r.pendingStarts.add(new ServiceRecord.StartItem(r,false,r.makeNextStartId(),service,neededGrants));
  final ServiceMap smap=getServiceMap(r.userId);
  boolean addToStarting=false;
  if (!callerFg && r.app == null && mAm.mUserController.hasStartedUserState(r.userId)) {
    ProcessRecord proc=mAm.getProcessRecordLocked(r.processName,r.appInfo.uid,false);
    if (proc == null || proc.curProcState > ActivityManager.PROCESS_STATE_RECEIVER) {
      if (DEBUG_DELAYED_SERVICE)       Slog.v(TAG_SERVICE,""String_Node_Str"" + r + ""String_Node_Str""+ proc);
      if (r.delayed) {
        if (DEBUG_DELAYED_STARTS)         Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
        return r.name;
      }
      if (smap.mStartingBackground.size() >= mMaxStartingBackground) {
        Slog.i(TAG_SERVICE,""String_Node_Str"" + r);
        smap.mDelayedStartList.add(r);
        r.delayed=true;
        return r.name;
      }
      if (DEBUG_DELAYED_STARTS)       Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
      addToStarting=true;
    }
 else     if (proc.curProcState >= ActivityManager.PROCESS_STATE_SERVICE) {
      addToStarting=true;
      if (DEBUG_DELAYED_STARTS)       Slog.v(TAG_SERVICE,""String_Node_Str"" + r);
    }
 else     if (DEBUG_DELAYED_STARTS) {
      StringBuilder sb=new StringBuilder(128);
      sb.append(""String_Node_Str"").append(proc.curProcState).append(' ').append(proc.adjType);
      String reason=proc.makeAdjReason();
      if (reason != null) {
        sb.append(' ');
        sb.append(reason);
      }
      sb.append(""String_Node_Str"");
      sb.append(r.toString());
      Slog.v(TAG_SERVICE,sb.toString());
    }
  }
 else   if (DEBUG_DELAYED_STARTS) {
    if (callerFg) {
      Slog.v(TAG_SERVICE,""String_Node_Str"" + callerFg + ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ r);
    }
 else     if (r.app != null) {
      Slog.v(TAG_SERVICE,""String_Node_Str"" + r.app + ""String_Node_Str""+ r);
    }
 else {
      Slog.v(TAG_SERVICE,""String_Node_Str"" + r.userId + ""String_Node_Str""+ r);
    }
  }
  return startServiceInnerLocked(smap,service,r,callerFg,addToStarting);
}",0.934068568688564
192284,"private ServiceLookupResult retrieveServiceLocked(Intent service,String resolvedType,String callingPackage,int callingPid,int callingUid,int userId,boolean createIfNeeded,boolean callingFromFg,boolean isBindExternal){
  ServiceRecord r=null;
  if (DEBUG_SERVICE)   Slog.v(TAG_SERVICE,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ callingUid);
  userId=mAm.mUserController.handleIncomingUser(callingPid,callingUid,userId,false,ActivityManagerService.ALLOW_NON_FULL_IN_PROFILE,""String_Node_Str"",null);
  ServiceMap smap=getServiceMap(userId);
  final ComponentName comp=service.getComponent();
  if (comp != null) {
    r=smap.mServicesByName.get(comp);
  }
  if (r == null && !isBindExternal) {
    Intent.FilterComparison filter=new Intent.FilterComparison(service);
    r=smap.mServicesByIntent.get(filter);
  }
  if (r != null && (r.serviceInfo.flags & ServiceInfo.FLAG_EXTERNAL_SERVICE) != 0 && !callingPackage.equals(r.packageName)) {
    r=null;
  }
  if (r == null) {
    try {
      ResolveInfo rInfo=AppGlobals.getPackageManager().resolveService(service,resolvedType,ActivityManagerService.STOCK_PM_FLAGS | PackageManager.MATCH_DEBUG_TRIAGED_MISSING,userId);
      ServiceInfo sInfo=rInfo != null ? rInfo.serviceInfo : null;
      if (sInfo == null) {
        Slog.w(TAG_SERVICE,""String_Node_Str"" + service + ""String_Node_Str""+ userId+ ""String_Node_Str"");
        return null;
      }
      ComponentName name=new ComponentName(sInfo.applicationInfo.packageName,sInfo.name);
      if ((sInfo.flags & ServiceInfo.FLAG_EXTERNAL_SERVICE) != 0) {
        if (isBindExternal) {
          if (!sInfo.exported) {
            throw new SecurityException(""String_Node_Str"" + name + ""String_Node_Str"");
          }
          if ((sInfo.flags & ServiceInfo.FLAG_ISOLATED_PROCESS) == 0) {
            throw new SecurityException(""String_Node_Str"" + name + ""String_Node_Str"");
          }
          ApplicationInfo aInfo=AppGlobals.getPackageManager().getApplicationInfo(callingPackage,ActivityManagerService.STOCK_PM_FLAGS,userId);
          if (aInfo == null) {
            throw new SecurityException(""String_Node_Str"" + ""String_Node_Str"" + callingPackage);
          }
          sInfo=new ServiceInfo(sInfo);
          sInfo.applicationInfo=new ApplicationInfo(sInfo.applicationInfo);
          sInfo.applicationInfo.packageName=aInfo.packageName;
          sInfo.applicationInfo.uid=aInfo.uid;
          name=new ComponentName(aInfo.packageName,name.getClassName());
          service.setComponent(name);
        }
 else {
          throw new SecurityException(""String_Node_Str"" + name);
        }
      }
 else       if (isBindExternal) {
        throw new SecurityException(""String_Node_Str"" + name + ""String_Node_Str"");
      }
      if (userId > 0) {
        if (mAm.isSingleton(sInfo.processName,sInfo.applicationInfo,sInfo.name,sInfo.flags) && mAm.isValidSingletonCall(callingUid,sInfo.applicationInfo.uid)) {
          userId=0;
          smap=getServiceMap(0);
        }
        sInfo=new ServiceInfo(sInfo);
        sInfo.applicationInfo=mAm.getAppInfoForUser(sInfo.applicationInfo,userId);
      }
      r=smap.mServicesByName.get(name);
      if (r == null && createIfNeeded) {
        final long token=Binder.clearCallingIdentity();
        try {
          final int allowed=mAm.checkAllowBackgroundLocked(sInfo.applicationInfo.uid,sInfo.packageName,callingPid,true);
          if (allowed != ActivityManager.APP_START_MODE_NORMAL) {
            Slog.w(TAG,""String_Node_Str"" + service + ""String_Node_Str""+ name.flattenToShortString()+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ callingPackage);
            return null;
          }
        }
  finally {
          Binder.restoreCallingIdentity(token);
        }
        Intent.FilterComparison filter=new Intent.FilterComparison(service.cloneFilter());
        ServiceRestarter res=new ServiceRestarter();
        BatteryStatsImpl.Uid.Pkg.Serv ss=null;
        BatteryStatsImpl stats=mAm.mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
          ss=stats.getServiceStatsLocked(sInfo.applicationInfo.uid,sInfo.packageName,sInfo.name);
        }
        r=new ServiceRecord(mAm,ss,name,filter,sInfo,callingFromFg,res);
        res.setService(r);
        smap.mServicesByName.put(name,r);
        smap.mServicesByIntent.put(filter,r);
        for (int i=mPendingServices.size() - 1; i >= 0; i--) {
          ServiceRecord pr=mPendingServices.get(i);
          if (pr.serviceInfo.applicationInfo.uid == sInfo.applicationInfo.uid && pr.name.equals(name)) {
            mPendingServices.remove(i);
          }
        }
      }
    }
 catch (    RemoteException ex) {
    }
  }
  if (r != null) {
    if (mAm.checkComponentPermission(r.permission,callingPid,callingUid,r.appInfo.uid,r.exported) != PackageManager.PERMISSION_GRANTED) {
      if (!r.exported) {
        Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ r.appInfo.uid);
        return new ServiceLookupResult(null,""String_Node_Str"" + r.appInfo.uid);
      }
      Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ r.permission);
      return new ServiceLookupResult(null,r.permission);
    }
 else     if (r.permission != null && callingPackage != null) {
      final int opCode=AppOpsManager.permissionToOpCode(r.permission);
      if (opCode != AppOpsManager.OP_NONE && mAm.mAppOpsService.noteOperation(opCode,callingUid,callingPackage) != AppOpsManager.MODE_ALLOWED) {
        Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ AppOpsManager.opToName(opCode));
        return null;
      }
    }
    if (!mAm.mIntentFirewall.checkService(r.name,service,callingUid,callingPid,resolvedType,r.appInfo)) {
      return null;
    }
    return new ServiceLookupResult(r,null);
  }
  return null;
}","private ServiceLookupResult retrieveServiceLocked(Intent service,String resolvedType,String callingPackage,int callingPid,int callingUid,int userId,boolean createIfNeeded,boolean callingFromFg,boolean isBindExternal){
  ServiceRecord r=null;
  if (DEBUG_SERVICE)   Slog.v(TAG_SERVICE,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ callingUid);
  userId=mAm.mUserController.handleIncomingUser(callingPid,callingUid,userId,false,ActivityManagerService.ALLOW_NON_FULL_IN_PROFILE,""String_Node_Str"",null);
  ServiceMap smap=getServiceMap(userId);
  final ComponentName comp=service.getComponent();
  if (comp != null) {
    r=smap.mServicesByName.get(comp);
  }
  if (r == null && !isBindExternal) {
    Intent.FilterComparison filter=new Intent.FilterComparison(service);
    r=smap.mServicesByIntent.get(filter);
  }
  if (r != null && (r.serviceInfo.flags & ServiceInfo.FLAG_EXTERNAL_SERVICE) != 0 && !callingPackage.equals(r.packageName)) {
    r=null;
  }
  if (r == null) {
    try {
      ResolveInfo rInfo=AppGlobals.getPackageManager().resolveService(service,resolvedType,ActivityManagerService.STOCK_PM_FLAGS | PackageManager.MATCH_DEBUG_TRIAGED_MISSING,userId);
      ServiceInfo sInfo=rInfo != null ? rInfo.serviceInfo : null;
      if (sInfo == null) {
        Slog.w(TAG_SERVICE,""String_Node_Str"" + service + ""String_Node_Str""+ userId+ ""String_Node_Str"");
        return null;
      }
      ComponentName name=new ComponentName(sInfo.applicationInfo.packageName,sInfo.name);
      if ((sInfo.flags & ServiceInfo.FLAG_EXTERNAL_SERVICE) != 0) {
        if (isBindExternal) {
          if (!sInfo.exported) {
            throw new SecurityException(""String_Node_Str"" + name + ""String_Node_Str"");
          }
          if ((sInfo.flags & ServiceInfo.FLAG_ISOLATED_PROCESS) == 0) {
            throw new SecurityException(""String_Node_Str"" + name + ""String_Node_Str"");
          }
          ApplicationInfo aInfo=AppGlobals.getPackageManager().getApplicationInfo(callingPackage,ActivityManagerService.STOCK_PM_FLAGS,userId);
          if (aInfo == null) {
            throw new SecurityException(""String_Node_Str"" + ""String_Node_Str"" + callingPackage);
          }
          sInfo=new ServiceInfo(sInfo);
          sInfo.applicationInfo=new ApplicationInfo(sInfo.applicationInfo);
          sInfo.applicationInfo.packageName=aInfo.packageName;
          sInfo.applicationInfo.uid=aInfo.uid;
          name=new ComponentName(aInfo.packageName,name.getClassName());
          service.setComponent(name);
        }
 else {
          throw new SecurityException(""String_Node_Str"" + name);
        }
      }
 else       if (isBindExternal) {
        throw new SecurityException(""String_Node_Str"" + name + ""String_Node_Str"");
      }
      if (userId > 0) {
        if (mAm.isSingleton(sInfo.processName,sInfo.applicationInfo,sInfo.name,sInfo.flags) && mAm.isValidSingletonCall(callingUid,sInfo.applicationInfo.uid)) {
          userId=0;
          smap=getServiceMap(0);
        }
        sInfo=new ServiceInfo(sInfo);
        sInfo.applicationInfo=mAm.getAppInfoForUser(sInfo.applicationInfo,userId);
      }
      r=smap.mServicesByName.get(name);
      if (r == null && createIfNeeded) {
        Intent.FilterComparison filter=new Intent.FilterComparison(service.cloneFilter());
        ServiceRestarter res=new ServiceRestarter();
        BatteryStatsImpl.Uid.Pkg.Serv ss=null;
        BatteryStatsImpl stats=mAm.mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
          ss=stats.getServiceStatsLocked(sInfo.applicationInfo.uid,sInfo.packageName,sInfo.name);
        }
        r=new ServiceRecord(mAm,ss,name,filter,sInfo,callingFromFg,res);
        res.setService(r);
        smap.mServicesByName.put(name,r);
        smap.mServicesByIntent.put(filter,r);
        for (int i=mPendingServices.size() - 1; i >= 0; i--) {
          ServiceRecord pr=mPendingServices.get(i);
          if (pr.serviceInfo.applicationInfo.uid == sInfo.applicationInfo.uid && pr.name.equals(name)) {
            mPendingServices.remove(i);
          }
        }
      }
    }
 catch (    RemoteException ex) {
    }
  }
  if (r != null) {
    if (mAm.checkComponentPermission(r.permission,callingPid,callingUid,r.appInfo.uid,r.exported) != PackageManager.PERMISSION_GRANTED) {
      if (!r.exported) {
        Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ r.appInfo.uid);
        return new ServiceLookupResult(null,""String_Node_Str"" + r.appInfo.uid);
      }
      Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ r.permission);
      return new ServiceLookupResult(null,r.permission);
    }
 else     if (r.permission != null && callingPackage != null) {
      final int opCode=AppOpsManager.permissionToOpCode(r.permission);
      if (opCode != AppOpsManager.OP_NONE && mAm.mAppOpsService.noteOperation(opCode,callingUid,callingPackage) != AppOpsManager.MODE_ALLOWED) {
        Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ AppOpsManager.opToName(opCode));
        return null;
      }
    }
    if (!mAm.mIntentFirewall.checkService(r.name,service,callingUid,callingPid,resolvedType,r.appInfo)) {
      return null;
    }
    return new ServiceLookupResult(r,null);
  }
  return null;
}",0.9500218054949848
192285,"/** 
 * This is called with the full size of the window since we are handling our own insets.
 */
@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  if (mTaskStackView.getVisibility() != GONE) {
    mTaskStackView.layout(left,top,left + getMeasuredWidth(),top + getMeasuredHeight());
  }
  if (mEmptyView.getVisibility() != GONE) {
    int leftRightInsets=mSystemInsets.left + mSystemInsets.right;
    int topBottomInsets=mSystemInsets.top + mSystemInsets.bottom;
    int childWidth=mEmptyView.getMeasuredWidth();
    int childHeight=mEmptyView.getMeasuredHeight();
    int childLeft=left + Math.max(0,(right - left - leftRightInsets- childWidth)) / 2;
    int childTop=top + Math.max(0,(bottom - top - topBottomInsets- childHeight)) / 2;
    mEmptyView.layout(childLeft,childTop,childLeft + childWidth,childTop + childHeight);
  }
  if (RecentsDebugFlags.Static.EnableStackActionButton) {
    Rect buttonBounds=getStackActionButtonBoundsFromStackLayout();
    mStackActionButton.layout(buttonBounds.left,buttonBounds.top,buttonBounds.right,buttonBounds.bottom);
  }
  if (mAwaitingFirstLayout) {
    mAwaitingFirstLayout=false;
    RecentsActivityLaunchState launchState=Recents.getConfiguration().getLaunchState();
    if (launchState.launchedViaDragGesture) {
      setTranslationY(getMeasuredHeight());
    }
 else {
      setTranslationY(0f);
    }
  }
}","/** 
 * This is called with the full size of the window since we are handling our own insets.
 */
@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  if (mTaskStackView.getVisibility() != GONE) {
    mTaskStackView.layout(left,top,left + getMeasuredWidth(),top + getMeasuredHeight());
  }
  if (mEmptyView.getVisibility() != GONE) {
    int leftRightInsets=mSystemInsets.left + mSystemInsets.right;
    int topBottomInsets=mSystemInsets.top + mSystemInsets.bottom;
    int childWidth=mEmptyView.getMeasuredWidth();
    int childHeight=mEmptyView.getMeasuredHeight();
    int childLeft=left + mSystemInsets.left + Math.max(0,(right - left - leftRightInsets- childWidth)) / 2;
    int childTop=top + mSystemInsets.top + Math.max(0,(bottom - top - topBottomInsets- childHeight)) / 2;
    mEmptyView.layout(childLeft,childTop,childLeft + childWidth,childTop + childHeight);
  }
  if (RecentsDebugFlags.Static.EnableStackActionButton) {
    Rect buttonBounds=getStackActionButtonBoundsFromStackLayout();
    mStackActionButton.layout(buttonBounds.left,buttonBounds.top,buttonBounds.right,buttonBounds.bottom);
  }
  if (mAwaitingFirstLayout) {
    mAwaitingFirstLayout=false;
    RecentsActivityLaunchState launchState=Recents.getConfiguration().getLaunchState();
    if (launchState.launchedViaDragGesture) {
      setTranslationY(getMeasuredHeight());
    }
 else {
      setTranslationY(0f);
    }
  }
}",0.985568461809222
192286,"/** 
 * Decides whether to update an Activity's configuration and whether to tell the Activity/Component about it.
 * @param cb The component callback to notify of configuration change.
 * @param activityToken The Activity binder token for which this configuration change happened.If the change is global, this is null.
 * @param newConfig The new configuration.
 * @param overrideConfig The override config that differentiates the Activity's configurationfrom the base global configuration.
 * @param reportToActivity Notify the Activity of the change.
 */
private void performConfigurationChanged(ComponentCallbacks2 cb,IBinder activityToken,Configuration newConfig,Configuration overrideConfig,boolean reportToActivity){
  Activity activity=(cb instanceof Activity) ? (Activity)cb : null;
  if (activity != null) {
    activity.mCalled=false;
  }
  boolean shouldChangeConfig=false;
  if ((activity == null) || (activity.mCurrentConfig == null)) {
    shouldChangeConfig=true;
  }
 else {
    int diff=activity.mCurrentConfig.diff(newConfig);
    if (diff != 0) {
      if ((~activity.mActivityInfo.getRealConfigChanged() & diff) == 0 || !reportToActivity) {
        shouldChangeConfig=true;
      }
    }
  }
  if (DEBUG_CONFIGURATION) {
    Slog.v(TAG,""String_Node_Str"" + cb + ""String_Node_Str""+ shouldChangeConfig);
  }
  if (shouldChangeConfig) {
    if (activityToken != null) {
      mResourcesManager.updateResourcesForActivity(activityToken,overrideConfig);
    }
    if (reportToActivity) {
      cb.onConfigurationChanged(newConfig);
    }
    if (activity != null) {
      if (reportToActivity && !activity.mCalled) {
        throw new SuperNotCalledException(""String_Node_Str"" + activity.getLocalClassName() + ""String_Node_Str"");
      }
      activity.mConfigChangeFlags=0;
      activity.mCurrentConfig=new Configuration(newConfig);
    }
  }
}","/** 
 * Decides whether to update an Activity's configuration and whether to tell the Activity/Component about it.
 * @param cb The component callback to notify of configuration change.
 * @param activityToken The Activity binder token for which this configuration change happened.If the change is global, this is null.
 * @param newConfig The new configuration.
 * @param overrideConfig The override config that differentiates the Activity's configurationfrom the base global configuration.
 * @param reportToActivity Notify the Activity of the change.
 */
private void performConfigurationChanged(ComponentCallbacks2 cb,IBinder activityToken,Configuration newConfig,Configuration overrideConfig,boolean reportToActivity){
  Activity activity=(cb instanceof Activity) ? (Activity)cb : null;
  if (activity != null) {
    activity.mCalled=false;
  }
  boolean shouldChangeConfig=false;
  if ((activity == null) || (activity.mCurrentConfig == null)) {
    shouldChangeConfig=true;
  }
 else {
    int diff=activity.mCurrentConfig.diff(newConfig);
    if (diff != 0) {
      if ((~activity.mActivityInfo.getRealConfigChanged() & diff) == 0 || !reportToActivity) {
        shouldChangeConfig=true;
      }
    }
  }
  if (DEBUG_CONFIGURATION) {
    Slog.v(TAG,""String_Node_Str"" + cb + ""String_Node_Str""+ shouldChangeConfig);
  }
  if (shouldChangeConfig) {
    if (activityToken != null) {
      mResourcesManager.updateResourcesForActivity(activityToken,overrideConfig);
    }
    if (reportToActivity) {
      Configuration configToReport=newConfig;
      if (cb instanceof ContextThemeWrapper) {
        ContextThemeWrapper contextThemeWrapper=(ContextThemeWrapper)cb;
        final Configuration localOverrideConfig=contextThemeWrapper.getOverrideConfiguration();
        if (localOverrideConfig != null) {
          configToReport=new Configuration(newConfig);
          configToReport.updateFrom(localOverrideConfig);
        }
      }
      cb.onConfigurationChanged(configToReport);
    }
    if (activity != null) {
      if (reportToActivity && !activity.mCalled) {
        throw new SuperNotCalledException(""String_Node_Str"" + activity.getLocalClassName() + ""String_Node_Str"");
      }
      activity.mConfigChangeFlags=0;
      activity.mCurrentConfig=new Configuration(newConfig);
    }
  }
}",0.8897429738169589
192287,"/** 
 * Decides whether to update an Activity's configuration and whether to tell the Activity/Component about it.
 * @param cb The component callback to notify of configuration change.
 * @param activityToken The Activity binder token for which this configuration change happened.If the change is global, this is null.
 * @param newConfig The new configuration.
 * @param overrideConfig The override config that differentiates the Activity's configurationfrom the base global configuration.
 * @param reportToActivity Notify the Activity of the change.
 */
private void performConfigurationChanged(ComponentCallbacks2 cb,IBinder activityToken,Configuration newConfig,Configuration overrideConfig,boolean reportToActivity){
  Activity activity=(cb instanceof Activity) ? (Activity)cb : null;
  if (activity != null) {
    activity.mCalled=false;
  }
  boolean shouldChangeConfig=false;
  if ((activity == null) || (activity.mCurrentConfig == null)) {
    shouldChangeConfig=true;
  }
 else {
    int diff=activity.mCurrentConfig.diff(newConfig);
    if (diff != 0) {
      if ((~activity.mActivityInfo.getRealConfigChanged() & diff) == 0 || !reportToActivity) {
        shouldChangeConfig=true;
      }
    }
  }
  if (DEBUG_CONFIGURATION) {
    Slog.v(TAG,""String_Node_Str"" + cb + ""String_Node_Str""+ shouldChangeConfig);
  }
  if (shouldChangeConfig) {
    if (activityToken != null) {
      mResourcesManager.updateResourcesForActivity(activityToken,overrideConfig);
    }
    if (reportToActivity) {
      cb.onConfigurationChanged(newConfig);
    }
    if (activity != null) {
      if (reportToActivity && !activity.mCalled) {
        throw new SuperNotCalledException(""String_Node_Str"" + activity.getLocalClassName() + ""String_Node_Str"");
      }
      activity.mConfigChangeFlags=0;
      activity.mCurrentConfig=new Configuration(newConfig);
    }
  }
}","/** 
 * Decides whether to update an Activity's configuration and whether to tell the Activity/Component about it.
 * @param cb The component callback to notify of configuration change.
 * @param activityToken The Activity binder token for which this configuration change happened.If the change is global, this is null.
 * @param newConfig The new configuration.
 * @param overrideConfig The override config that differentiates the Activity's configurationfrom the base global configuration.
 * @param reportToActivity Notify the Activity of the change.
 */
private void performConfigurationChanged(ComponentCallbacks2 cb,IBinder activityToken,Configuration newConfig,Configuration overrideConfig,boolean reportToActivity){
  Activity activity=(cb instanceof Activity) ? (Activity)cb : null;
  if (activity != null) {
    activity.mCalled=false;
  }
  boolean shouldChangeConfig=false;
  if ((activity == null) || (activity.mCurrentConfig == null)) {
    shouldChangeConfig=true;
  }
 else {
    int diff=activity.mCurrentConfig.diff(newConfig);
    if (diff != 0) {
      if ((~activity.mActivityInfo.getRealConfigChanged() & diff) == 0 || !reportToActivity) {
        shouldChangeConfig=true;
      }
    }
  }
  if (DEBUG_CONFIGURATION) {
    Slog.v(TAG,""String_Node_Str"" + cb + ""String_Node_Str""+ shouldChangeConfig);
  }
  if (shouldChangeConfig) {
    if (activityToken != null) {
      mResourcesManager.updateResourcesForActivity(activityToken,overrideConfig);
    }
    if (reportToActivity) {
      Configuration configToReport=newConfig;
      if (cb instanceof ContextThemeWrapper) {
        ContextThemeWrapper contextThemeWrapper=(ContextThemeWrapper)cb;
        final Configuration localOverrideConfig=contextThemeWrapper.getOverrideConfiguration();
        if (localOverrideConfig != null) {
          configToReport=new Configuration(newConfig);
          configToReport.updateFrom(localOverrideConfig);
        }
      }
      cb.onConfigurationChanged(configToReport);
    }
    if (activity != null) {
      if (reportToActivity && !activity.mCalled) {
        throw new SuperNotCalledException(""String_Node_Str"" + activity.getLocalClassName() + ""String_Node_Str"");
      }
      activity.mConfigChangeFlags=0;
      activity.mCurrentConfig=new Configuration(newConfig);
    }
  }
}",0.8897429738169589
192288,"boolean matches(byte[] packet,int length){
  if (length != mPacket.limit())   return false;
  ByteBuffer a=ByteBuffer.wrap(packet);
  ByteBuffer b=mPacket;
  for (  Pair<Integer,Integer> nonLifetime : mNonLifetimes) {
    a.clear();
    b.clear();
    a.position(nonLifetime.first);
    b.position(nonLifetime.first);
    a.limit(nonLifetime.first + nonLifetime.second);
    b.limit(nonLifetime.first + nonLifetime.second);
    if (a.compareTo(b) != 0)     return false;
  }
  return true;
}","boolean matches(byte[] packet,int length){
  if (length != mPacket.capacity())   return false;
  byte[] referencePacket=mPacket.array();
  for (  Pair<Integer,Integer> nonLifetime : mNonLifetimes) {
    for (int i=nonLifetime.first; i < (nonLifetime.first + nonLifetime.second); i++) {
      if (packet[i] != referencePacket[i])       return false;
    }
  }
  return true;
}",0.4757505773672055
192289,"@GuardedBy(""String_Node_Str"") long generateFilterLocked(ApfGenerator gen) throws IllegalInstructionException {
  String nextFilterLabel=""String_Node_Str"" + getUniqueNumberLocked();
  gen.addLoadFromMemory(Register.R0,gen.PACKET_SIZE_MEMORY_SLOT);
  gen.addJumpIfR0NotEquals(mPacket.limit(),nextFilterLabel);
  int filterLifetime=(int)(currentLifetime() / FRACTION_OF_LIFETIME_TO_FILTER);
  gen.addLoadFromMemory(Register.R0,gen.FILTER_AGE_MEMORY_SLOT);
  gen.addJumpIfR0GreaterThan(filterLifetime,nextFilterLabel);
  for (int i=0; i < mNonLifetimes.size(); i++) {
    Pair<Integer,Integer> nonLifetime=mNonLifetimes.get(i);
    if (nonLifetime.second != 0) {
      gen.addLoadImmediate(Register.R0,nonLifetime.first);
      gen.addJumpIfBytesNotEqual(Register.R0,Arrays.copyOfRange(mPacket.array(),nonLifetime.first,nonLifetime.first + nonLifetime.second),nextFilterLabel);
    }
    if ((i + 1) < mNonLifetimes.size()) {
      Pair<Integer,Integer> nextNonLifetime=mNonLifetimes.get(i + 1);
      int offset=nonLifetime.first + nonLifetime.second;
      if (offset == ICMP6_RA_CHECKSUM_OFFSET) {
        continue;
      }
      int length=nextNonLifetime.first - offset;
switch (length) {
case 4:
        gen.addLoad32(Register.R0,offset);
      break;
case 2:
    gen.addLoad16(Register.R0,offset);
  break;
default :
throw new IllegalStateException(""String_Node_Str"" + length);
}
gen.addJumpIfR0LessThan(filterLifetime,nextFilterLabel);
}
}
gen.addJump(gen.DROP_LABEL);
gen.defineLabel(nextFilterLabel);
return filterLifetime;
}","@GuardedBy(""String_Node_Str"") long generateFilterLocked(ApfGenerator gen) throws IllegalInstructionException {
  String nextFilterLabel=""String_Node_Str"" + getUniqueNumberLocked();
  gen.addLoadFromMemory(Register.R0,gen.PACKET_SIZE_MEMORY_SLOT);
  gen.addJumpIfR0NotEquals(mPacket.capacity(),nextFilterLabel);
  int filterLifetime=(int)(currentLifetime() / FRACTION_OF_LIFETIME_TO_FILTER);
  gen.addLoadFromMemory(Register.R0,gen.FILTER_AGE_MEMORY_SLOT);
  gen.addJumpIfR0GreaterThan(filterLifetime,nextFilterLabel);
  for (int i=0; i < mNonLifetimes.size(); i++) {
    Pair<Integer,Integer> nonLifetime=mNonLifetimes.get(i);
    if (nonLifetime.second != 0) {
      gen.addLoadImmediate(Register.R0,nonLifetime.first);
      gen.addJumpIfBytesNotEqual(Register.R0,Arrays.copyOfRange(mPacket.array(),nonLifetime.first,nonLifetime.first + nonLifetime.second),nextFilterLabel);
    }
    if ((i + 1) < mNonLifetimes.size()) {
      Pair<Integer,Integer> nextNonLifetime=mNonLifetimes.get(i + 1);
      int offset=nonLifetime.first + nonLifetime.second;
      if (offset == ICMP6_RA_CHECKSUM_OFFSET) {
        continue;
      }
      int length=nextNonLifetime.first - offset;
switch (length) {
case 4:
        gen.addLoad32(Register.R0,offset);
      break;
case 2:
    gen.addLoad16(Register.R0,offset);
  break;
default :
throw new IllegalStateException(""String_Node_Str"" + length);
}
gen.addJumpIfR0LessThan(filterLifetime,nextFilterLabel);
}
}
gen.addJump(gen.DROP_LABEL);
gen.defineLabel(nextFilterLabel);
return filterLifetime;
}",0.995758564437194
192290,"private void updateSoftKeyboardShowModeLocked(UserState userState){
  final int userId=userState.mUserId;
  if ((userId == mCurrentUserId) && (userState.mSoftKeyboardShowMode != 0)) {
    boolean serviceChangingSoftKeyboardModeIsEnabled=userState.mEnabledServices.contains(userState.mServiceChangingSoftKeyboardMode);
    if (!serviceChangingSoftKeyboardModeIsEnabled) {
      Settings.Secure.putIntForUser(mContext.getContentResolver(),Settings.Secure.ACCESSIBILITY_SOFT_KEYBOARD_MODE,0,userState.mUserId);
      userState.mSoftKeyboardShowMode=0;
      userState.mServiceChangingSoftKeyboardMode=null;
    }
    notifySoftKeyboardShowModeChangedLocked(userState.mSoftKeyboardShowMode);
  }
}","private void updateSoftKeyboardShowModeLocked(UserState userState){
  final int userId=userState.mUserId;
  if ((userId == mCurrentUserId) && (userState.mSoftKeyboardShowMode != 0)) {
    boolean serviceChangingSoftKeyboardModeIsEnabled=userState.mEnabledServices.contains(userState.mServiceChangingSoftKeyboardMode);
    if (!serviceChangingSoftKeyboardModeIsEnabled) {
      final long identity=Binder.clearCallingIdentity();
      try {
        Settings.Secure.putIntForUser(mContext.getContentResolver(),Settings.Secure.ACCESSIBILITY_SOFT_KEYBOARD_MODE,0,userState.mUserId);
      }
  finally {
        Binder.restoreCallingIdentity(identity);
      }
      userState.mSoftKeyboardShowMode=0;
      userState.mServiceChangingSoftKeyboardMode=null;
    }
    notifySoftKeyboardShowModeChangedLocked(userState.mSoftKeyboardShowMode);
  }
}",0.9035202086049544
192291,"void initViews(){
  mInitialized=false;
  mWindowCreated=false;
  mShowInputRequested=false;
  mShowInputForced=false;
  mThemeAttrs=obtainStyledAttributes(android.R.styleable.InputMethodService);
  mRootView=mInflater.inflate(com.android.internal.R.layout.input_method,null);
  mRootView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION);
  mWindow.setContentView(mRootView);
  mRootView.getViewTreeObserver().removeOnComputeInternalInsetsListener(mInsetsComputer);
  mRootView.getViewTreeObserver().addOnComputeInternalInsetsListener(mInsetsComputer);
  if (Settings.Global.getInt(getContentResolver(),Settings.Global.FANCY_IME_ANIMATIONS,0) != 0) {
    mWindow.getWindow().setWindowAnimations(com.android.internal.R.style.Animation_InputMethodFancy);
  }
  mFullscreenArea=(ViewGroup)mRootView.findViewById(com.android.internal.R.id.fullscreenArea);
  mExtractViewHidden=false;
  mExtractFrame=(FrameLayout)mRootView.findViewById(android.R.id.extractArea);
  mExtractView=null;
  mExtractEditText=null;
  mExtractAccessories=null;
  mExtractAction=null;
  mFullscreenApplied=false;
  mCandidatesFrame=(FrameLayout)mRootView.findViewById(android.R.id.candidatesArea);
  mInputFrame=(FrameLayout)mRootView.findViewById(android.R.id.inputArea);
  mInputView=null;
  mIsInputViewShown=false;
  mExtractFrame.setVisibility(View.GONE);
  mCandidatesVisibility=getCandidatesHiddenVisibility();
  mCandidatesFrame.setVisibility(mCandidatesVisibility);
  mInputFrame.setVisibility(View.GONE);
}","void initViews(){
  mInitialized=false;
  mWindowCreated=false;
  mShowInputRequested=false;
  mShowInputFlags=0;
  mThemeAttrs=obtainStyledAttributes(android.R.styleable.InputMethodService);
  mRootView=mInflater.inflate(com.android.internal.R.layout.input_method,null);
  mRootView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION);
  mWindow.setContentView(mRootView);
  mRootView.getViewTreeObserver().removeOnComputeInternalInsetsListener(mInsetsComputer);
  mRootView.getViewTreeObserver().addOnComputeInternalInsetsListener(mInsetsComputer);
  if (Settings.Global.getInt(getContentResolver(),Settings.Global.FANCY_IME_ANIMATIONS,0) != 0) {
    mWindow.getWindow().setWindowAnimations(com.android.internal.R.style.Animation_InputMethodFancy);
  }
  mFullscreenArea=(ViewGroup)mRootView.findViewById(com.android.internal.R.id.fullscreenArea);
  mExtractViewHidden=false;
  mExtractFrame=(FrameLayout)mRootView.findViewById(android.R.id.extractArea);
  mExtractView=null;
  mExtractEditText=null;
  mExtractAccessories=null;
  mExtractAction=null;
  mFullscreenApplied=false;
  mCandidatesFrame=(FrameLayout)mRootView.findViewById(android.R.id.candidatesArea);
  mInputFrame=(FrameLayout)mRootView.findViewById(android.R.id.inputArea);
  mInputView=null;
  mIsInputViewShown=false;
  mExtractFrame.setVisibility(View.GONE);
  mCandidatesVisibility=getCandidatesHiddenVisibility();
  mCandidatesFrame.setVisibility(mCandidatesVisibility);
  mInputFrame.setVisibility(View.GONE);
}",0.9944715447154472
192292,"/** 
 * Handle a request by the system to show the soft input area.
 */
public void showSoftInput(int flags,ResultReceiver resultReceiver){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"");
  boolean wasVis=isInputViewShown();
  mShowInputFlags=0;
  if (onShowInputRequested(flags,false)) {
    try {
      showWindow(true);
    }
 catch (    BadTokenException e) {
    }
  }
  clearInsetOfPreviousIme();
  boolean showing=isInputViewShown();
  mImm.setImeWindowStatus(mToken,IME_ACTIVE | (showing ? IME_VISIBLE : 0),mBackDisposition);
  if (resultReceiver != null) {
    resultReceiver.send(wasVis != isInputViewShown() ? InputMethodManager.RESULT_SHOWN : (wasVis ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN),null);
  }
}","/** 
 * Handle a request by the system to show the soft input area.
 */
public void showSoftInput(int flags,ResultReceiver resultReceiver){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"");
  boolean wasVis=isInputViewShown();
  if (dispatchOnShowInputRequested(flags,false)) {
    try {
      showWindow(true);
    }
 catch (    BadTokenException e) {
    }
  }
  clearInsetOfPreviousIme();
  boolean showing=isInputViewShown();
  mImm.setImeWindowStatus(mToken,IME_ACTIVE | (showing ? IME_VISIBLE : 0),mBackDisposition);
  if (resultReceiver != null) {
    resultReceiver.send(wasVis != isInputViewShown() ? InputMethodManager.RESULT_SHOWN : (wasVis ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN),null);
  }
}",0.9741892786234282
192293,"/** 
 * Handle a request by the system to hide the soft input area.
 */
public void hideSoftInput(int flags,ResultReceiver resultReceiver){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"");
  boolean wasVis=isInputViewShown();
  mShowInputFlags=0;
  mShowInputRequested=false;
  mShowInputForced=false;
  doHideWindow();
  clearInsetOfPreviousIme();
  if (resultReceiver != null) {
    resultReceiver.send(wasVis != isInputViewShown() ? InputMethodManager.RESULT_HIDDEN : (wasVis ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN),null);
  }
}","/** 
 * Handle a request by the system to hide the soft input area.
 */
public void hideSoftInput(int flags,ResultReceiver resultReceiver){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"");
  boolean wasVis=isInputViewShown();
  mShowInputFlags=0;
  mShowInputRequested=false;
  doHideWindow();
  clearInsetOfPreviousIme();
  if (resultReceiver != null) {
    resultReceiver.send(wasVis != isInputViewShown() ? InputMethodManager.RESULT_HIDDEN : (wasVis ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN),null);
  }
}",0.9769503546099292
192294,"/** 
 * The system has decided that it may be time to show your input method. This is called due to a corresponding call to your  {@link InputMethod#showSoftInput InputMethod.showSoftInput()}method.  The default implementation uses  {@link #onEvaluateInputViewShown()},   {@link #onEvaluateFullscreenMode()}, and the current configuration to decide whether the input view should be shown at this point.
 * @param flags Provides additional information about the show request,as per  {@link InputMethod#showSoftInput InputMethod.showSoftInput()}.
 * @param configChange This is true if we are re-showing due to aconfiguration change.
 * @return Returns true to indicate that the window should be shown.
 */
public boolean onShowInputRequested(int flags,boolean configChange){
  if (!onEvaluateInputViewShown()) {
    return false;
  }
  if ((flags & InputMethod.SHOW_EXPLICIT) == 0) {
    if (!configChange && onEvaluateFullscreenMode()) {
      return false;
    }
    Configuration config=getResources().getConfiguration();
    if (config.keyboard != Configuration.KEYBOARD_NOKEYS) {
      return false;
    }
  }
  if ((flags & InputMethod.SHOW_FORCED) != 0) {
    mShowInputForced=true;
  }
  return true;
}","/** 
 * The system has decided that it may be time to show your input method. This is called due to a corresponding call to your  {@link InputMethod#showSoftInput InputMethod.showSoftInput()}method.  The default implementation uses  {@link #onEvaluateInputViewShown()},   {@link #onEvaluateFullscreenMode()}, and the current configuration to decide whether the input view should be shown at this point.
 * @param flags Provides additional information about the show request,as per  {@link InputMethod#showSoftInput InputMethod.showSoftInput()}.
 * @param configChange This is true if we are re-showing due to aconfiguration change.
 * @return Returns true to indicate that the window should be shown.
 */
public boolean onShowInputRequested(int flags,boolean configChange){
  if (!onEvaluateInputViewShown()) {
    return false;
  }
  if ((flags & InputMethod.SHOW_EXPLICIT) == 0) {
    if (!configChange && onEvaluateFullscreenMode()) {
      return false;
    }
    Configuration config=getResources().getConfiguration();
    if (config.keyboard != Configuration.KEYBOARD_NOKEYS) {
      return false;
    }
  }
  return true;
}",0.960239418554938
192295,"public void showWindow(boolean showInput){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + showInput + ""String_Node_Str""+ mShowInputRequested+ ""String_Node_Str""+ mWindowAdded+ ""String_Node_Str""+ mWindowCreated+ ""String_Node_Str""+ mWindowVisible+ ""String_Node_Str""+ mInputStarted);
  if (mInShowWindow) {
    Log.w(TAG,""String_Node_Str"");
    return;
  }
  try {
    mWindowWasVisible=mWindowVisible;
    mInShowWindow=true;
    showWindowInner(showInput);
  }
 catch (  BadTokenException e) {
    if (DEBUG)     Log.v(TAG,""String_Node_Str"");
    mWindowVisible=false;
    mWindowAdded=false;
    throw e;
  }
 finally {
    mWindowWasVisible=true;
    mInShowWindow=false;
  }
}","public void showWindow(boolean showInput){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + showInput + ""String_Node_Str""+ mShowInputRequested+ ""String_Node_Str""+ mWindowAdded+ ""String_Node_Str""+ mWindowCreated+ ""String_Node_Str""+ mWindowVisible+ ""String_Node_Str""+ mInputStarted+ ""String_Node_Str""+ mShowInputFlags);
  if (mInShowWindow) {
    Log.w(TAG,""String_Node_Str"");
    return;
  }
  try {
    mWindowWasVisible=mWindowVisible;
    mInShowWindow=true;
    showWindowInner(showInput);
  }
 catch (  BadTokenException e) {
    if (DEBUG)     Log.v(TAG,""String_Node_Str"");
    mWindowVisible=false;
    mWindowAdded=false;
    throw e;
  }
 finally {
    mWindowWasVisible=true;
    mInShowWindow=false;
  }
}",0.974025974025974
192296,"/** 
 * Take care of handling configuration changes.  Subclasses of InputMethodService generally don't need to deal directly with this on their own; the standard implementation here takes care of regenerating the input method UI as a result of the configuration change, so you can rely on your   {@link #onCreateInputView} andother methods being called as appropriate due to a configuration change. <p>When a configuration change does happen, {@link #onInitializeInterface()} is guaranteed to be called the nexttime prior to any of the other input or UI creation callbacks.  The following will be called immediately depending if appropriate for current  state:  {@link #onStartInput} if input is active, and{@link #onCreateInputView} and {@link #onStartInputView} and relatedappropriate functions if the UI is displayed.
 */
@Override public void onConfigurationChanged(Configuration newConfig){
  super.onConfigurationChanged(newConfig);
  boolean visible=mWindowVisible;
  int showFlags=mShowInputFlags;
  boolean showingInput=mShowInputRequested;
  CompletionInfo[] completions=mCurCompletions;
  initViews();
  mInputViewStarted=false;
  mCandidatesViewStarted=false;
  if (mInputStarted) {
    doStartInput(getCurrentInputConnection(),getCurrentInputEditorInfo(),true);
  }
  if (visible) {
    if (showingInput) {
      if (onShowInputRequested(showFlags,true)) {
        showWindow(true);
        if (completions != null) {
          mCurCompletions=completions;
          onDisplayCompletions(completions);
        }
      }
 else {
        doHideWindow();
      }
    }
 else     if (mCandidatesVisibility == View.VISIBLE) {
      showWindow(false);
    }
 else {
      doHideWindow();
    }
    boolean showing=onEvaluateInputViewShown();
    mImm.setImeWindowStatus(mToken,IME_ACTIVE | (showing ? IME_VISIBLE : 0),mBackDisposition);
  }
}","/** 
 * Take care of handling configuration changes.  Subclasses of InputMethodService generally don't need to deal directly with this on their own; the standard implementation here takes care of regenerating the input method UI as a result of the configuration change, so you can rely on your   {@link #onCreateInputView} andother methods being called as appropriate due to a configuration change. <p>When a configuration change does happen, {@link #onInitializeInterface()} is guaranteed to be called the nexttime prior to any of the other input or UI creation callbacks.  The following will be called immediately depending if appropriate for current  state:  {@link #onStartInput} if input is active, and{@link #onCreateInputView} and {@link #onStartInputView} and relatedappropriate functions if the UI is displayed.
 */
@Override public void onConfigurationChanged(Configuration newConfig){
  super.onConfigurationChanged(newConfig);
  boolean visible=mWindowVisible;
  int showFlags=mShowInputFlags;
  boolean showingInput=mShowInputRequested;
  CompletionInfo[] completions=mCurCompletions;
  initViews();
  mInputViewStarted=false;
  mCandidatesViewStarted=false;
  if (mInputStarted) {
    doStartInput(getCurrentInputConnection(),getCurrentInputEditorInfo(),true);
  }
  if (visible) {
    if (showingInput) {
      if (dispatchOnShowInputRequested(showFlags,true)) {
        showWindow(true);
        if (completions != null) {
          mCurCompletions=completions;
          onDisplayCompletions(completions);
        }
      }
 else {
        doHideWindow();
      }
    }
 else     if (mCandidatesVisibility == View.VISIBLE) {
      showWindow(false);
    }
 else {
      doHideWindow();
    }
    boolean showing=onEvaluateInputViewShown();
    mImm.setImeWindowStatus(mToken,IME_ACTIVE | (showing ? IME_VISIBLE : 0),mBackDisposition);
  }
}",0.9973016729627632
192297,"/** 
 * Performs a dump of the InputMethodService's internal state.  Override to add your own information to the dump.
 */
@Override protected void dump(FileDescriptor fd,PrintWriter fout,String[] args){
  final Printer p=new PrintWriterPrinter(fout);
  p.println(""String_Node_Str"" + this + ""String_Node_Str"");
  p.println(""String_Node_Str"" + mWindowCreated + ""String_Node_Str""+ mWindowAdded);
  p.println(""String_Node_Str"" + mWindowVisible + ""String_Node_Str""+ mWindowWasVisible+ ""String_Node_Str""+ mInShowWindow);
  p.println(""String_Node_Str"" + getResources().getConfiguration());
  p.println(""String_Node_Str"" + mToken);
  p.println(""String_Node_Str"" + mInputBinding);
  p.println(""String_Node_Str"" + mInputConnection);
  p.println(""String_Node_Str"" + mStartedInputConnection);
  p.println(""String_Node_Str"" + mInputStarted + ""String_Node_Str""+ mInputViewStarted+ ""String_Node_Str""+ mCandidatesViewStarted);
  if (mInputEditorInfo != null) {
    p.println(""String_Node_Str"");
    mInputEditorInfo.dump(p,""String_Node_Str"");
  }
 else {
    p.println(""String_Node_Str"");
  }
  p.println(""String_Node_Str"" + mShowInputRequested + ""String_Node_Str""+ mLastShowInputRequested+ ""String_Node_Str""+ mShowInputForced+ ""String_Node_Str""+ Integer.toHexString(mShowInputFlags));
  p.println(""String_Node_Str"" + mCandidatesVisibility + ""String_Node_Str""+ mFullscreenApplied+ ""String_Node_Str""+ mIsFullscreen+ ""String_Node_Str""+ mExtractViewHidden);
  if (mExtractedText != null) {
    p.println(""String_Node_Str"");
    p.println(""String_Node_Str"" + mExtractedText.text.length() + ""String_Node_Str""+ ""String_Node_Str""+ mExtractedText.startOffset);
    p.println(""String_Node_Str"" + mExtractedText.selectionStart + ""String_Node_Str""+ mExtractedText.selectionEnd+ ""String_Node_Str""+ Integer.toHexString(mExtractedText.flags));
  }
 else {
    p.println(""String_Node_Str"");
  }
  p.println(""String_Node_Str"" + mExtractedToken);
  p.println(""String_Node_Str"" + mIsInputViewShown + ""String_Node_Str""+ mStatusIcon);
  p.println(""String_Node_Str"");
  p.println(""String_Node_Str"" + mTmpInsets.contentTopInsets + ""String_Node_Str""+ mTmpInsets.visibleTopInsets+ ""String_Node_Str""+ mTmpInsets.touchableInsets+ ""String_Node_Str""+ mTmpInsets.touchableRegion);
  p.println(""String_Node_Str"" + mShouldClearInsetOfPreviousIme);
  p.println(""String_Node_Str"" + mSettingsObserver);
}","/** 
 * Performs a dump of the InputMethodService's internal state.  Override to add your own information to the dump.
 */
@Override protected void dump(FileDescriptor fd,PrintWriter fout,String[] args){
  final Printer p=new PrintWriterPrinter(fout);
  p.println(""String_Node_Str"" + this + ""String_Node_Str"");
  p.println(""String_Node_Str"" + mWindowCreated + ""String_Node_Str""+ mWindowAdded);
  p.println(""String_Node_Str"" + mWindowVisible + ""String_Node_Str""+ mWindowWasVisible+ ""String_Node_Str""+ mInShowWindow);
  p.println(""String_Node_Str"" + getResources().getConfiguration());
  p.println(""String_Node_Str"" + mToken);
  p.println(""String_Node_Str"" + mInputBinding);
  p.println(""String_Node_Str"" + mInputConnection);
  p.println(""String_Node_Str"" + mStartedInputConnection);
  p.println(""String_Node_Str"" + mInputStarted + ""String_Node_Str""+ mInputViewStarted+ ""String_Node_Str""+ mCandidatesViewStarted);
  if (mInputEditorInfo != null) {
    p.println(""String_Node_Str"");
    mInputEditorInfo.dump(p,""String_Node_Str"");
  }
 else {
    p.println(""String_Node_Str"");
  }
  p.println(""String_Node_Str"" + mShowInputRequested + ""String_Node_Str""+ mLastShowInputRequested+ ""String_Node_Str""+ Integer.toHexString(mShowInputFlags));
  p.println(""String_Node_Str"" + mCandidatesVisibility + ""String_Node_Str""+ mFullscreenApplied+ ""String_Node_Str""+ mIsFullscreen+ ""String_Node_Str""+ mExtractViewHidden);
  if (mExtractedText != null) {
    p.println(""String_Node_Str"");
    p.println(""String_Node_Str"" + mExtractedText.text.length() + ""String_Node_Str""+ ""String_Node_Str""+ mExtractedText.startOffset);
    p.println(""String_Node_Str"" + mExtractedText.selectionStart + ""String_Node_Str""+ mExtractedText.selectionEnd+ ""String_Node_Str""+ Integer.toHexString(mExtractedText.flags));
  }
 else {
    p.println(""String_Node_Str"");
  }
  p.println(""String_Node_Str"" + mExtractedToken);
  p.println(""String_Node_Str"" + mIsInputViewShown + ""String_Node_Str""+ mStatusIcon);
  p.println(""String_Node_Str"");
  p.println(""String_Node_Str"" + mTmpInsets.contentTopInsets + ""String_Node_Str""+ mTmpInsets.visibleTopInsets+ ""String_Node_Str""+ mTmpInsets.touchableInsets+ ""String_Node_Str""+ mTmpInsets.touchableRegion);
  p.println(""String_Node_Str"" + mShouldClearInsetOfPreviousIme);
  p.println(""String_Node_Str"" + mSettingsObserver);
}",0.9920821741921678
192298,"private void updateSoftKeyboardShowModeLocked(UserState userState){
  final int userId=userState.mUserId;
  if ((userId == mCurrentUserId) && (userState.mSoftKeyboardShowMode != 0)) {
    boolean serviceChangingSoftKeyboardModeIsEnabled=userState.mEnabledServices.contains(userState.mServiceChangingSoftKeyboardMode);
    if (!serviceChangingSoftKeyboardModeIsEnabled) {
      Settings.Secure.putIntForUser(mContext.getContentResolver(),Settings.Secure.ACCESSIBILITY_SOFT_KEYBOARD_MODE,0,userState.mUserId);
      userState.mSoftKeyboardShowMode=0;
      userState.mServiceChangingSoftKeyboardMode=null;
    }
    notifySoftKeyboardShowModeChangedLocked(userState.mSoftKeyboardShowMode);
  }
}","private void updateSoftKeyboardShowModeLocked(UserState userState){
  final int userId=userState.mUserId;
  if ((userId == mCurrentUserId) && (userState.mSoftKeyboardShowMode != 0)) {
    boolean serviceChangingSoftKeyboardModeIsEnabled=userState.mEnabledServices.contains(userState.mServiceChangingSoftKeyboardMode);
    if (!serviceChangingSoftKeyboardModeIsEnabled) {
      final long identity=Binder.clearCallingIdentity();
      try {
        Settings.Secure.putIntForUser(mContext.getContentResolver(),Settings.Secure.ACCESSIBILITY_SOFT_KEYBOARD_MODE,0,userState.mUserId);
      }
  finally {
        Binder.restoreCallingIdentity(identity);
      }
      userState.mSoftKeyboardShowMode=0;
      userState.mServiceChangingSoftKeyboardMode=null;
    }
    notifySoftKeyboardShowModeChangedLocked(userState.mSoftKeyboardShowMode);
  }
}",0.9035202086049544
192299,"void initViews(){
  mInitialized=false;
  mWindowCreated=false;
  mShowInputRequested=false;
  mShowInputForced=false;
  mThemeAttrs=obtainStyledAttributes(android.R.styleable.InputMethodService);
  mRootView=mInflater.inflate(com.android.internal.R.layout.input_method,null);
  mRootView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION);
  mWindow.setContentView(mRootView);
  mRootView.getViewTreeObserver().removeOnComputeInternalInsetsListener(mInsetsComputer);
  mRootView.getViewTreeObserver().addOnComputeInternalInsetsListener(mInsetsComputer);
  if (Settings.Global.getInt(getContentResolver(),Settings.Global.FANCY_IME_ANIMATIONS,0) != 0) {
    mWindow.getWindow().setWindowAnimations(com.android.internal.R.style.Animation_InputMethodFancy);
  }
  mFullscreenArea=(ViewGroup)mRootView.findViewById(com.android.internal.R.id.fullscreenArea);
  mExtractViewHidden=false;
  mExtractFrame=(FrameLayout)mRootView.findViewById(android.R.id.extractArea);
  mExtractView=null;
  mExtractEditText=null;
  mExtractAccessories=null;
  mExtractAction=null;
  mFullscreenApplied=false;
  mCandidatesFrame=(FrameLayout)mRootView.findViewById(android.R.id.candidatesArea);
  mInputFrame=(FrameLayout)mRootView.findViewById(android.R.id.inputArea);
  mInputView=null;
  mIsInputViewShown=false;
  mExtractFrame.setVisibility(View.GONE);
  mCandidatesVisibility=getCandidatesHiddenVisibility();
  mCandidatesFrame.setVisibility(mCandidatesVisibility);
  mInputFrame.setVisibility(View.GONE);
}","void initViews(){
  mInitialized=false;
  mWindowCreated=false;
  mShowInputRequested=false;
  mShowInputFlags=0;
  mThemeAttrs=obtainStyledAttributes(android.R.styleable.InputMethodService);
  mRootView=mInflater.inflate(com.android.internal.R.layout.input_method,null);
  mRootView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION);
  mWindow.setContentView(mRootView);
  mRootView.getViewTreeObserver().removeOnComputeInternalInsetsListener(mInsetsComputer);
  mRootView.getViewTreeObserver().addOnComputeInternalInsetsListener(mInsetsComputer);
  if (Settings.Global.getInt(getContentResolver(),Settings.Global.FANCY_IME_ANIMATIONS,0) != 0) {
    mWindow.getWindow().setWindowAnimations(com.android.internal.R.style.Animation_InputMethodFancy);
  }
  mFullscreenArea=(ViewGroup)mRootView.findViewById(com.android.internal.R.id.fullscreenArea);
  mExtractViewHidden=false;
  mExtractFrame=(FrameLayout)mRootView.findViewById(android.R.id.extractArea);
  mExtractView=null;
  mExtractEditText=null;
  mExtractAccessories=null;
  mExtractAction=null;
  mFullscreenApplied=false;
  mCandidatesFrame=(FrameLayout)mRootView.findViewById(android.R.id.candidatesArea);
  mInputFrame=(FrameLayout)mRootView.findViewById(android.R.id.inputArea);
  mInputView=null;
  mIsInputViewShown=false;
  mExtractFrame.setVisibility(View.GONE);
  mCandidatesVisibility=getCandidatesHiddenVisibility();
  mCandidatesFrame.setVisibility(mCandidatesVisibility);
  mInputFrame.setVisibility(View.GONE);
}",0.9944715447154472
192300,"/** 
 * Handle a request by the system to show the soft input area.
 */
public void showSoftInput(int flags,ResultReceiver resultReceiver){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"");
  boolean wasVis=isInputViewShown();
  mShowInputFlags=0;
  if (onShowInputRequested(flags,false)) {
    try {
      showWindow(true);
    }
 catch (    BadTokenException e) {
    }
  }
  clearInsetOfPreviousIme();
  boolean showing=isInputViewShown();
  mImm.setImeWindowStatus(mToken,IME_ACTIVE | (showing ? IME_VISIBLE : 0),mBackDisposition);
  if (resultReceiver != null) {
    resultReceiver.send(wasVis != isInputViewShown() ? InputMethodManager.RESULT_SHOWN : (wasVis ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN),null);
  }
}","/** 
 * Handle a request by the system to show the soft input area.
 */
public void showSoftInput(int flags,ResultReceiver resultReceiver){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"");
  boolean wasVis=isInputViewShown();
  if (dispatchOnShowInputRequested(flags,false)) {
    try {
      showWindow(true);
    }
 catch (    BadTokenException e) {
    }
  }
  clearInsetOfPreviousIme();
  boolean showing=isInputViewShown();
  mImm.setImeWindowStatus(mToken,IME_ACTIVE | (showing ? IME_VISIBLE : 0),mBackDisposition);
  if (resultReceiver != null) {
    resultReceiver.send(wasVis != isInputViewShown() ? InputMethodManager.RESULT_SHOWN : (wasVis ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN),null);
  }
}",0.9741892786234282
192301,"/** 
 * Handle a request by the system to hide the soft input area.
 */
public void hideSoftInput(int flags,ResultReceiver resultReceiver){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"");
  boolean wasVis=isInputViewShown();
  mShowInputFlags=0;
  mShowInputRequested=false;
  mShowInputForced=false;
  doHideWindow();
  clearInsetOfPreviousIme();
  if (resultReceiver != null) {
    resultReceiver.send(wasVis != isInputViewShown() ? InputMethodManager.RESULT_HIDDEN : (wasVis ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN),null);
  }
}","/** 
 * Handle a request by the system to hide the soft input area.
 */
public void hideSoftInput(int flags,ResultReceiver resultReceiver){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"");
  boolean wasVis=isInputViewShown();
  mShowInputFlags=0;
  mShowInputRequested=false;
  doHideWindow();
  clearInsetOfPreviousIme();
  if (resultReceiver != null) {
    resultReceiver.send(wasVis != isInputViewShown() ? InputMethodManager.RESULT_HIDDEN : (wasVis ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN),null);
  }
}",0.9769503546099292
192302,"/** 
 * The system has decided that it may be time to show your input method. This is called due to a corresponding call to your  {@link InputMethod#showSoftInput InputMethod.showSoftInput()}method.  The default implementation uses  {@link #onEvaluateInputViewShown()},   {@link #onEvaluateFullscreenMode()}, and the current configuration to decide whether the input view should be shown at this point.
 * @param flags Provides additional information about the show request,as per  {@link InputMethod#showSoftInput InputMethod.showSoftInput()}.
 * @param configChange This is true if we are re-showing due to aconfiguration change.
 * @return Returns true to indicate that the window should be shown.
 */
public boolean onShowInputRequested(int flags,boolean configChange){
  if (!onEvaluateInputViewShown()) {
    return false;
  }
  if ((flags & InputMethod.SHOW_EXPLICIT) == 0) {
    if (!configChange && onEvaluateFullscreenMode()) {
      return false;
    }
    Configuration config=getResources().getConfiguration();
    if (config.keyboard != Configuration.KEYBOARD_NOKEYS) {
      return false;
    }
  }
  if ((flags & InputMethod.SHOW_FORCED) != 0) {
    mShowInputForced=true;
  }
  return true;
}","/** 
 * The system has decided that it may be time to show your input method. This is called due to a corresponding call to your  {@link InputMethod#showSoftInput InputMethod.showSoftInput()}method.  The default implementation uses  {@link #onEvaluateInputViewShown()},   {@link #onEvaluateFullscreenMode()}, and the current configuration to decide whether the input view should be shown at this point.
 * @param flags Provides additional information about the show request,as per  {@link InputMethod#showSoftInput InputMethod.showSoftInput()}.
 * @param configChange This is true if we are re-showing due to aconfiguration change.
 * @return Returns true to indicate that the window should be shown.
 */
public boolean onShowInputRequested(int flags,boolean configChange){
  if (!onEvaluateInputViewShown()) {
    return false;
  }
  if ((flags & InputMethod.SHOW_EXPLICIT) == 0) {
    if (!configChange && onEvaluateFullscreenMode()) {
      return false;
    }
    Configuration config=getResources().getConfiguration();
    if (config.keyboard != Configuration.KEYBOARD_NOKEYS) {
      return false;
    }
  }
  return true;
}",0.960239418554938
192303,"public void showWindow(boolean showInput){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + showInput + ""String_Node_Str""+ mShowInputRequested+ ""String_Node_Str""+ mWindowAdded+ ""String_Node_Str""+ mWindowCreated+ ""String_Node_Str""+ mWindowVisible+ ""String_Node_Str""+ mInputStarted);
  if (mInShowWindow) {
    Log.w(TAG,""String_Node_Str"");
    return;
  }
  try {
    mWindowWasVisible=mWindowVisible;
    mInShowWindow=true;
    showWindowInner(showInput);
  }
 catch (  BadTokenException e) {
    if (DEBUG)     Log.v(TAG,""String_Node_Str"");
    mWindowVisible=false;
    mWindowAdded=false;
    throw e;
  }
 finally {
    mWindowWasVisible=true;
    mInShowWindow=false;
  }
}","public void showWindow(boolean showInput){
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + showInput + ""String_Node_Str""+ mShowInputRequested+ ""String_Node_Str""+ mWindowAdded+ ""String_Node_Str""+ mWindowCreated+ ""String_Node_Str""+ mWindowVisible+ ""String_Node_Str""+ mInputStarted+ ""String_Node_Str""+ mShowInputFlags);
  if (mInShowWindow) {
    Log.w(TAG,""String_Node_Str"");
    return;
  }
  try {
    mWindowWasVisible=mWindowVisible;
    mInShowWindow=true;
    showWindowInner(showInput);
  }
 catch (  BadTokenException e) {
    if (DEBUG)     Log.v(TAG,""String_Node_Str"");
    mWindowVisible=false;
    mWindowAdded=false;
    throw e;
  }
 finally {
    mWindowWasVisible=true;
    mInShowWindow=false;
  }
}",0.974025974025974
192304,"/** 
 * Take care of handling configuration changes.  Subclasses of InputMethodService generally don't need to deal directly with this on their own; the standard implementation here takes care of regenerating the input method UI as a result of the configuration change, so you can rely on your   {@link #onCreateInputView} andother methods being called as appropriate due to a configuration change. <p>When a configuration change does happen, {@link #onInitializeInterface()} is guaranteed to be called the nexttime prior to any of the other input or UI creation callbacks.  The following will be called immediately depending if appropriate for current  state:  {@link #onStartInput} if input is active, and{@link #onCreateInputView} and {@link #onStartInputView} and relatedappropriate functions if the UI is displayed.
 */
@Override public void onConfigurationChanged(Configuration newConfig){
  super.onConfigurationChanged(newConfig);
  boolean visible=mWindowVisible;
  int showFlags=mShowInputFlags;
  boolean showingInput=mShowInputRequested;
  CompletionInfo[] completions=mCurCompletions;
  initViews();
  mInputViewStarted=false;
  mCandidatesViewStarted=false;
  if (mInputStarted) {
    doStartInput(getCurrentInputConnection(),getCurrentInputEditorInfo(),true);
  }
  if (visible) {
    if (showingInput) {
      if (onShowInputRequested(showFlags,true)) {
        showWindow(true);
        if (completions != null) {
          mCurCompletions=completions;
          onDisplayCompletions(completions);
        }
      }
 else {
        doHideWindow();
      }
    }
 else     if (mCandidatesVisibility == View.VISIBLE) {
      showWindow(false);
    }
 else {
      doHideWindow();
    }
    boolean showing=onEvaluateInputViewShown();
    mImm.setImeWindowStatus(mToken,IME_ACTIVE | (showing ? IME_VISIBLE : 0),mBackDisposition);
  }
}","/** 
 * Take care of handling configuration changes.  Subclasses of InputMethodService generally don't need to deal directly with this on their own; the standard implementation here takes care of regenerating the input method UI as a result of the configuration change, so you can rely on your   {@link #onCreateInputView} andother methods being called as appropriate due to a configuration change. <p>When a configuration change does happen, {@link #onInitializeInterface()} is guaranteed to be called the nexttime prior to any of the other input or UI creation callbacks.  The following will be called immediately depending if appropriate for current  state:  {@link #onStartInput} if input is active, and{@link #onCreateInputView} and {@link #onStartInputView} and relatedappropriate functions if the UI is displayed.
 */
@Override public void onConfigurationChanged(Configuration newConfig){
  super.onConfigurationChanged(newConfig);
  boolean visible=mWindowVisible;
  int showFlags=mShowInputFlags;
  boolean showingInput=mShowInputRequested;
  CompletionInfo[] completions=mCurCompletions;
  initViews();
  mInputViewStarted=false;
  mCandidatesViewStarted=false;
  if (mInputStarted) {
    doStartInput(getCurrentInputConnection(),getCurrentInputEditorInfo(),true);
  }
  if (visible) {
    if (showingInput) {
      if (dispatchOnShowInputRequested(showFlags,true)) {
        showWindow(true);
        if (completions != null) {
          mCurCompletions=completions;
          onDisplayCompletions(completions);
        }
      }
 else {
        doHideWindow();
      }
    }
 else     if (mCandidatesVisibility == View.VISIBLE) {
      showWindow(false);
    }
 else {
      doHideWindow();
    }
    boolean showing=onEvaluateInputViewShown();
    mImm.setImeWindowStatus(mToken,IME_ACTIVE | (showing ? IME_VISIBLE : 0),mBackDisposition);
  }
}",0.9973016729627632
192305,"/** 
 * Performs a dump of the InputMethodService's internal state.  Override to add your own information to the dump.
 */
@Override protected void dump(FileDescriptor fd,PrintWriter fout,String[] args){
  final Printer p=new PrintWriterPrinter(fout);
  p.println(""String_Node_Str"" + this + ""String_Node_Str"");
  p.println(""String_Node_Str"" + mWindowCreated + ""String_Node_Str""+ mWindowAdded);
  p.println(""String_Node_Str"" + mWindowVisible + ""String_Node_Str""+ mWindowWasVisible+ ""String_Node_Str""+ mInShowWindow);
  p.println(""String_Node_Str"" + getResources().getConfiguration());
  p.println(""String_Node_Str"" + mToken);
  p.println(""String_Node_Str"" + mInputBinding);
  p.println(""String_Node_Str"" + mInputConnection);
  p.println(""String_Node_Str"" + mStartedInputConnection);
  p.println(""String_Node_Str"" + mInputStarted + ""String_Node_Str""+ mInputViewStarted+ ""String_Node_Str""+ mCandidatesViewStarted);
  if (mInputEditorInfo != null) {
    p.println(""String_Node_Str"");
    mInputEditorInfo.dump(p,""String_Node_Str"");
  }
 else {
    p.println(""String_Node_Str"");
  }
  p.println(""String_Node_Str"" + mShowInputRequested + ""String_Node_Str""+ mLastShowInputRequested+ ""String_Node_Str""+ mShowInputForced+ ""String_Node_Str""+ Integer.toHexString(mShowInputFlags));
  p.println(""String_Node_Str"" + mCandidatesVisibility + ""String_Node_Str""+ mFullscreenApplied+ ""String_Node_Str""+ mIsFullscreen+ ""String_Node_Str""+ mExtractViewHidden);
  if (mExtractedText != null) {
    p.println(""String_Node_Str"");
    p.println(""String_Node_Str"" + mExtractedText.text.length() + ""String_Node_Str""+ ""String_Node_Str""+ mExtractedText.startOffset);
    p.println(""String_Node_Str"" + mExtractedText.selectionStart + ""String_Node_Str""+ mExtractedText.selectionEnd+ ""String_Node_Str""+ Integer.toHexString(mExtractedText.flags));
  }
 else {
    p.println(""String_Node_Str"");
  }
  p.println(""String_Node_Str"" + mExtractedToken);
  p.println(""String_Node_Str"" + mIsInputViewShown + ""String_Node_Str""+ mStatusIcon);
  p.println(""String_Node_Str"");
  p.println(""String_Node_Str"" + mTmpInsets.contentTopInsets + ""String_Node_Str""+ mTmpInsets.visibleTopInsets+ ""String_Node_Str""+ mTmpInsets.touchableInsets+ ""String_Node_Str""+ mTmpInsets.touchableRegion);
  p.println(""String_Node_Str"" + mShouldClearInsetOfPreviousIme);
  p.println(""String_Node_Str"" + mSettingsObserver);
}","/** 
 * Performs a dump of the InputMethodService's internal state.  Override to add your own information to the dump.
 */
@Override protected void dump(FileDescriptor fd,PrintWriter fout,String[] args){
  final Printer p=new PrintWriterPrinter(fout);
  p.println(""String_Node_Str"" + this + ""String_Node_Str"");
  p.println(""String_Node_Str"" + mWindowCreated + ""String_Node_Str""+ mWindowAdded);
  p.println(""String_Node_Str"" + mWindowVisible + ""String_Node_Str""+ mWindowWasVisible+ ""String_Node_Str""+ mInShowWindow);
  p.println(""String_Node_Str"" + getResources().getConfiguration());
  p.println(""String_Node_Str"" + mToken);
  p.println(""String_Node_Str"" + mInputBinding);
  p.println(""String_Node_Str"" + mInputConnection);
  p.println(""String_Node_Str"" + mStartedInputConnection);
  p.println(""String_Node_Str"" + mInputStarted + ""String_Node_Str""+ mInputViewStarted+ ""String_Node_Str""+ mCandidatesViewStarted);
  if (mInputEditorInfo != null) {
    p.println(""String_Node_Str"");
    mInputEditorInfo.dump(p,""String_Node_Str"");
  }
 else {
    p.println(""String_Node_Str"");
  }
  p.println(""String_Node_Str"" + mShowInputRequested + ""String_Node_Str""+ mLastShowInputRequested+ ""String_Node_Str""+ Integer.toHexString(mShowInputFlags));
  p.println(""String_Node_Str"" + mCandidatesVisibility + ""String_Node_Str""+ mFullscreenApplied+ ""String_Node_Str""+ mIsFullscreen+ ""String_Node_Str""+ mExtractViewHidden);
  if (mExtractedText != null) {
    p.println(""String_Node_Str"");
    p.println(""String_Node_Str"" + mExtractedText.text.length() + ""String_Node_Str""+ ""String_Node_Str""+ mExtractedText.startOffset);
    p.println(""String_Node_Str"" + mExtractedText.selectionStart + ""String_Node_Str""+ mExtractedText.selectionEnd+ ""String_Node_Str""+ Integer.toHexString(mExtractedText.flags));
  }
 else {
    p.println(""String_Node_Str"");
  }
  p.println(""String_Node_Str"" + mExtractedToken);
  p.println(""String_Node_Str"" + mIsInputViewShown + ""String_Node_Str""+ mStatusIcon);
  p.println(""String_Node_Str"");
  p.println(""String_Node_Str"" + mTmpInsets.contentTopInsets + ""String_Node_Str""+ mTmpInsets.visibleTopInsets+ ""String_Node_Str""+ mTmpInsets.touchableInsets+ ""String_Node_Str""+ mTmpInsets.touchableRegion);
  p.println(""String_Node_Str"" + mShouldClearInsetOfPreviousIme);
  p.println(""String_Node_Str"" + mSettingsObserver);
}",0.9920821741921678
192306,"/** 
 * Prepares the header bar layout for the next transition, if the task view bounds has changed since the last call, it will attempt to re-measure and layout the header bar to the new size.
 * @param stack the stack to initialize the stack layout with
 */
private void updateHeaderBarLayout(TaskStack stack){
  SystemServicesProxy ssp=Recents.getSystemServices();
  Rect systemInsets=new Rect();
  ssp.getStableInsets(systemInsets);
  Rect windowRect=ssp.getWindowRect();
  calculateWindowStableInsets(systemInsets,windowRect);
  windowRect.offsetTo(0,0);
  TaskStackLayoutAlgorithm stackLayout=mDummyStackView.getStackAlgorithm();
  stackLayout.getTaskStackBounds(windowRect,systemInsets.top,systemInsets.right,mTaskStackBounds);
  Rect taskStackBounds=new Rect(mTaskStackBounds);
  stackLayout.setSystemInsets(systemInsets);
  if (stack != null) {
    stackLayout.initialize(windowRect,taskStackBounds,TaskStackLayoutAlgorithm.StackState.getStackStateForStack(stack));
    mDummyStackView.setTasks(stack,false);
  }
  Rect taskViewBounds=stackLayout.getUntransformedTaskViewBounds();
  if (!taskViewBounds.equals(mLastTaskViewBounds)) {
    mLastTaskViewBounds.set(taskViewBounds);
    int taskViewWidth=taskViewBounds.width();
synchronized (mHeaderBarLock) {
      mHeaderBar.measure(View.MeasureSpec.makeMeasureSpec(taskViewWidth,View.MeasureSpec.EXACTLY),View.MeasureSpec.makeMeasureSpec(mTaskBarHeight,View.MeasureSpec.EXACTLY));
      mHeaderBar.layout(0,0,taskViewWidth,mTaskBarHeight);
    }
  }
}","/** 
 * Prepares the header bar layout for the next transition, if the task view bounds has changed since the last call, it will attempt to re-measure and layout the header bar to the new size.
 * @param stack the stack to initialize the stack layout with
 */
private void updateHeaderBarLayout(TaskStack stack){
  SystemServicesProxy ssp=Recents.getSystemServices();
  Rect systemInsets=new Rect();
  ssp.getStableInsets(systemInsets);
  Rect windowRect=ssp.getWindowRect();
  if (ssp.hasDockedTask()) {
    windowRect.bottom-=systemInsets.bottom;
    systemInsets.bottom=0;
  }
  calculateWindowStableInsets(systemInsets,windowRect);
  windowRect.offsetTo(0,0);
  TaskStackLayoutAlgorithm stackLayout=mDummyStackView.getStackAlgorithm();
  stackLayout.setSystemInsets(systemInsets);
  if (stack != null) {
    stackLayout.getTaskStackBounds(windowRect,systemInsets.top,systemInsets.right,mTaskStackBounds);
    stackLayout.initialize(windowRect,mTaskStackBounds,TaskStackLayoutAlgorithm.StackState.getStackStateForStack(stack));
    mDummyStackView.setTasks(stack,false);
  }
  Rect taskViewBounds=stackLayout.getUntransformedTaskViewBounds();
  if (!taskViewBounds.equals(mLastTaskViewBounds)) {
    mLastTaskViewBounds.set(taskViewBounds);
    int taskViewWidth=taskViewBounds.width();
synchronized (mHeaderBarLock) {
      mHeaderBar.measure(View.MeasureSpec.makeMeasureSpec(taskViewWidth,View.MeasureSpec.EXACTLY),View.MeasureSpec.makeMeasureSpec(mTaskBarHeight,View.MeasureSpec.EXACTLY));
      mHeaderBar.layout(0,0,taskViewWidth,mTaskBarHeight);
    }
  }
}",0.8842652795838751
192307,"/** 
 * Prepares the header bar layout for the next transition, if the task view bounds has changed since the last call, it will attempt to re-measure and layout the header bar to the new size.
 * @param stack the stack to initialize the stack layout with
 */
private void updateHeaderBarLayout(TaskStack stack){
  SystemServicesProxy ssp=Recents.getSystemServices();
  Rect systemInsets=new Rect();
  ssp.getStableInsets(systemInsets);
  Rect windowRect=ssp.getWindowRect();
  calculateWindowStableInsets(systemInsets,windowRect);
  windowRect.offsetTo(0,0);
  TaskStackLayoutAlgorithm stackLayout=mDummyStackView.getStackAlgorithm();
  stackLayout.getTaskStackBounds(windowRect,systemInsets.top,systemInsets.right,mTaskStackBounds);
  Rect taskStackBounds=new Rect(mTaskStackBounds);
  stackLayout.setSystemInsets(systemInsets);
  if (stack != null) {
    stackLayout.initialize(windowRect,taskStackBounds,TaskStackLayoutAlgorithm.StackState.getStackStateForStack(stack));
    mDummyStackView.setTasks(stack,false);
  }
  Rect taskViewBounds=stackLayout.getUntransformedTaskViewBounds();
  if (!taskViewBounds.equals(mLastTaskViewBounds)) {
    mLastTaskViewBounds.set(taskViewBounds);
    int taskViewWidth=taskViewBounds.width();
synchronized (mHeaderBarLock) {
      mHeaderBar.measure(View.MeasureSpec.makeMeasureSpec(taskViewWidth,View.MeasureSpec.EXACTLY),View.MeasureSpec.makeMeasureSpec(mTaskBarHeight,View.MeasureSpec.EXACTLY));
      mHeaderBar.layout(0,0,taskViewWidth,mTaskBarHeight);
    }
  }
}","/** 
 * Prepares the header bar layout for the next transition, if the task view bounds has changed since the last call, it will attempt to re-measure and layout the header bar to the new size.
 * @param stack the stack to initialize the stack layout with
 */
private void updateHeaderBarLayout(TaskStack stack){
  SystemServicesProxy ssp=Recents.getSystemServices();
  Rect systemInsets=new Rect();
  ssp.getStableInsets(systemInsets);
  Rect windowRect=ssp.getWindowRect();
  if (ssp.hasDockedTask()) {
    windowRect.bottom-=systemInsets.bottom;
    systemInsets.bottom=0;
  }
  calculateWindowStableInsets(systemInsets,windowRect);
  windowRect.offsetTo(0,0);
  TaskStackLayoutAlgorithm stackLayout=mDummyStackView.getStackAlgorithm();
  stackLayout.setSystemInsets(systemInsets);
  if (stack != null) {
    stackLayout.getTaskStackBounds(windowRect,systemInsets.top,systemInsets.right,mTaskStackBounds);
    stackLayout.initialize(windowRect,mTaskStackBounds,TaskStackLayoutAlgorithm.StackState.getStackStateForStack(stack));
    mDummyStackView.setTasks(stack,false);
  }
  Rect taskViewBounds=stackLayout.getUntransformedTaskViewBounds();
  if (!taskViewBounds.equals(mLastTaskViewBounds)) {
    mLastTaskViewBounds.set(taskViewBounds);
    int taskViewWidth=taskViewBounds.width();
synchronized (mHeaderBarLock) {
      mHeaderBar.measure(View.MeasureSpec.makeMeasureSpec(taskViewWidth,View.MeasureSpec.EXACTLY),View.MeasureSpec.makeMeasureSpec(mTaskBarHeight,View.MeasureSpec.EXACTLY));
      mHeaderBar.layout(0,0,taskViewWidth,mTaskBarHeight);
    }
  }
}",0.8842652795838751
192308,"/** 
 * Creates base resources for an Activity. Calls to  {@link #getResources(IBinder,String,String[],String[],String[],int,Configuration,CompatibilityInfo,ClassLoader)} with the same activityToken will have their overrideconfigurations merged with the one specified here.
 * @param activityToken Represents an Activity.
 * @param resDir The base resource path. Can be null (only framework resources will be loaded).
 * @param splitResDirs An array of split resource paths. Can be null.
 * @param overlayDirs An array of overlay paths. Can be null.
 * @param libDirs An array of resource library paths. Can be null.
 * @param displayId The ID of the display for which to create the resources.
 * @param overrideConfig The configuration to apply on top of the base configuration. Can benull. This provides the base override for this Activity.
 * @param compatInfo The compatibility settings to use. Cannot be null. A default to use is{@link CompatibilityInfo#DEFAULT_COMPATIBILITY_INFO}.
 * @param classLoader The class loader to use when inflating Resources. If null, the{@link ClassLoader#getSystemClassLoader()} is used.
 * @return a Resources object from which to access resources.
 */
public Resources createBaseActivityResources(@NonNull IBinder activityToken,@Nullable String resDir,@Nullable String[] splitResDirs,@Nullable String[] overlayDirs,@Nullable String[] libDirs,int displayId,@Nullable Configuration overrideConfig,@NonNull CompatibilityInfo compatInfo,@Nullable ClassLoader classLoader){
  final ResourcesKey key=new ResourcesKey(resDir,splitResDirs,overlayDirs,libDirs,displayId,overrideConfig != null ? new Configuration(overrideConfig) : null,compatInfo);
  classLoader=classLoader != null ? classLoader : ClassLoader.getSystemClassLoader();
synchronized (this) {
    final ActivityResources activityResources=getOrCreateActivityResourcesStructLocked(activityToken);
    if (overrideConfig != null) {
      activityResources.overrideConfig.setTo(overrideConfig);
    }
 else {
      activityResources.overrideConfig.setToDefaults();
    }
  }
  updateResourcesForActivity(activityToken,overrideConfig);
  return getOrCreateResources(activityToken,key,classLoader);
}","/** 
 * Creates base resources for an Activity. Calls to  {@link #getResources(IBinder,String,String[],String[],String[],int,Configuration,CompatibilityInfo,ClassLoader)} with the same activityToken will have their overrideconfigurations merged with the one specified here.
 * @param activityToken Represents an Activity.
 * @param resDir The base resource path. Can be null (only framework resources will be loaded).
 * @param splitResDirs An array of split resource paths. Can be null.
 * @param overlayDirs An array of overlay paths. Can be null.
 * @param libDirs An array of resource library paths. Can be null.
 * @param displayId The ID of the display for which to create the resources.
 * @param overrideConfig The configuration to apply on top of the base configuration. Can benull. This provides the base override for this Activity.
 * @param compatInfo The compatibility settings to use. Cannot be null. A default to use is{@link CompatibilityInfo#DEFAULT_COMPATIBILITY_INFO}.
 * @param classLoader The class loader to use when inflating Resources. If null, the{@link ClassLoader#getSystemClassLoader()} is used.
 * @return a Resources object from which to access resources.
 */
public Resources createBaseActivityResources(@NonNull IBinder activityToken,@Nullable String resDir,@Nullable String[] splitResDirs,@Nullable String[] overlayDirs,@Nullable String[] libDirs,int displayId,@Nullable Configuration overrideConfig,@NonNull CompatibilityInfo compatInfo,@Nullable ClassLoader classLoader){
  final ResourcesKey key=new ResourcesKey(resDir,splitResDirs,overlayDirs,libDirs,displayId,overrideConfig != null ? new Configuration(overrideConfig) : null,compatInfo);
  classLoader=classLoader != null ? classLoader : ClassLoader.getSystemClassLoader();
  if (DEBUG) {
    Slog.d(TAG,""String_Node_Str"" + activityToken + ""String_Node_Str""+ key);
  }
synchronized (this) {
    final ActivityResources activityResources=getOrCreateActivityResourcesStructLocked(activityToken);
    if (overrideConfig != null) {
      activityResources.overrideConfig.setTo(overrideConfig);
    }
 else {
      activityResources.overrideConfig.setToDefaults();
    }
  }
  updateResourcesForActivity(activityToken,overrideConfig);
  return getOrCreateResources(activityToken,key,classLoader);
}",0.9787519570565868
192309,"/** 
 * Updates an Activity's Resources object with overrideConfig. The Resources object that was previously returned by  {@link #getResources(IBinder,String,String[],String[],String[],int,Configuration,CompatibilityInfo,ClassLoader)} isstill valid and will have the updated configuration.
 * @param activityToken The Activity token.
 * @param overrideConfig The configuration override to update.
 */
public void updateResourcesForActivity(@NonNull IBinder activityToken,@Nullable Configuration overrideConfig){
synchronized (this) {
    final ActivityResources activityResources=getOrCreateActivityResourcesStructLocked(activityToken);
    if (Objects.equals(activityResources.overrideConfig,overrideConfig)) {
      return;
    }
    final Configuration oldConfig=new Configuration(activityResources.overrideConfig);
    if (overrideConfig != null) {
      activityResources.overrideConfig.setTo(overrideConfig);
    }
 else {
      activityResources.overrideConfig.setToDefaults();
    }
    final boolean activityHasOverrideConfig=!activityResources.overrideConfig.equals(Configuration.EMPTY);
    final int refCount=activityResources.activityResources.size();
    for (int i=0; i < refCount; i++) {
      WeakReference<Resources> weakResRef=activityResources.activityResources.get(i);
      Resources resources=weakResRef.get();
      if (resources == null) {
        continue;
      }
      final ResourcesKey oldKey=findKeyForResourceImplLocked(resources.getImpl());
      if (oldKey == null) {
        Slog.e(TAG,""String_Node_Str"" + resources.getImpl());
        continue;
      }
      final Configuration rebasedOverrideConfig=new Configuration();
      if (overrideConfig != null) {
        rebasedOverrideConfig.setTo(overrideConfig);
      }
      if (activityHasOverrideConfig && oldKey.hasOverrideConfiguration()) {
        Configuration overrideOverrideConfig=Configuration.generateDelta(oldConfig,oldKey.mOverrideConfiguration);
        rebasedOverrideConfig.updateFrom(overrideOverrideConfig);
      }
      final ResourcesKey newKey=new ResourcesKey(oldKey.mResDir,oldKey.mSplitResDirs,oldKey.mOverlayDirs,oldKey.mLibDirs,oldKey.mDisplayId,rebasedOverrideConfig,oldKey.mCompatInfo);
      ResourcesImpl resourcesImpl=findResourcesImplForKeyLocked(newKey);
      if (resourcesImpl == null) {
        resourcesImpl=createResourcesImpl(newKey);
      }
      if (resourcesImpl != resources.getImpl()) {
        resources.setImpl(resourcesImpl);
      }
    }
  }
}","/** 
 * Updates an Activity's Resources object with overrideConfig. The Resources object that was previously returned by  {@link #getResources(IBinder,String,String[],String[],String[],int,Configuration,CompatibilityInfo,ClassLoader)} isstill valid and will have the updated configuration.
 * @param activityToken The Activity token.
 * @param overrideConfig The configuration override to update.
 */
public void updateResourcesForActivity(@NonNull IBinder activityToken,@Nullable Configuration overrideConfig){
synchronized (this) {
    final ActivityResources activityResources=getOrCreateActivityResourcesStructLocked(activityToken);
    if (Objects.equals(activityResources.overrideConfig,overrideConfig)) {
      return;
    }
    final Configuration oldConfig=new Configuration(activityResources.overrideConfig);
    if (overrideConfig != null) {
      activityResources.overrideConfig.setTo(overrideConfig);
    }
 else {
      activityResources.overrideConfig.setToDefaults();
    }
    if (DEBUG) {
      Throwable here=new Throwable();
      here.fillInStackTrace();
      Slog.d(TAG,""String_Node_Str"" + activityToken + ""String_Node_Str""+ Configuration.resourceQualifierString(oldConfig)+ ""String_Node_Str""+ Configuration.resourceQualifierString(activityResources.overrideConfig),here);
    }
    final boolean activityHasOverrideConfig=!activityResources.overrideConfig.equals(Configuration.EMPTY);
    final int refCount=activityResources.activityResources.size();
    for (int i=0; i < refCount; i++) {
      WeakReference<Resources> weakResRef=activityResources.activityResources.get(i);
      Resources resources=weakResRef.get();
      if (resources == null) {
        continue;
      }
      final ResourcesKey oldKey=findKeyForResourceImplLocked(resources.getImpl());
      if (oldKey == null) {
        Slog.e(TAG,""String_Node_Str"" + resources.getImpl());
        continue;
      }
      final Configuration rebasedOverrideConfig=new Configuration();
      if (overrideConfig != null) {
        rebasedOverrideConfig.setTo(overrideConfig);
      }
      if (activityHasOverrideConfig && oldKey.hasOverrideConfiguration()) {
        Configuration overrideOverrideConfig=Configuration.generateDelta(oldConfig,oldKey.mOverrideConfiguration);
        rebasedOverrideConfig.updateFrom(overrideOverrideConfig);
      }
      final ResourcesKey newKey=new ResourcesKey(oldKey.mResDir,oldKey.mSplitResDirs,oldKey.mOverlayDirs,oldKey.mLibDirs,oldKey.mDisplayId,rebasedOverrideConfig,oldKey.mCompatInfo);
      if (DEBUG) {
        Slog.d(TAG,""String_Node_Str"" + resources + ""String_Node_Str""+ oldKey+ ""String_Node_Str""+ newKey);
      }
      ResourcesImpl resourcesImpl=findResourcesImplForKeyLocked(newKey);
      if (resourcesImpl == null) {
        resourcesImpl=createResourcesImpl(newKey);
        mResourceImpls.put(newKey,new WeakReference<>(resourcesImpl));
      }
      if (resourcesImpl != resources.getImpl()) {
        resources.setImpl(resourcesImpl);
      }
    }
  }
}",0.6928414901387875
192310,"/** 
 * Creates base resources for an Activity. Calls to  {@link #getResources(IBinder,String,String[],String[],String[],int,Configuration,CompatibilityInfo,ClassLoader)} with the same activityToken will have their overrideconfigurations merged with the one specified here.
 * @param activityToken Represents an Activity.
 * @param resDir The base resource path. Can be null (only framework resources will be loaded).
 * @param splitResDirs An array of split resource paths. Can be null.
 * @param overlayDirs An array of overlay paths. Can be null.
 * @param libDirs An array of resource library paths. Can be null.
 * @param displayId The ID of the display for which to create the resources.
 * @param overrideConfig The configuration to apply on top of the base configuration. Can benull. This provides the base override for this Activity.
 * @param compatInfo The compatibility settings to use. Cannot be null. A default to use is{@link CompatibilityInfo#DEFAULT_COMPATIBILITY_INFO}.
 * @param classLoader The class loader to use when inflating Resources. If null, the{@link ClassLoader#getSystemClassLoader()} is used.
 * @return a Resources object from which to access resources.
 */
public Resources createBaseActivityResources(@NonNull IBinder activityToken,@Nullable String resDir,@Nullable String[] splitResDirs,@Nullable String[] overlayDirs,@Nullable String[] libDirs,int displayId,@Nullable Configuration overrideConfig,@NonNull CompatibilityInfo compatInfo,@Nullable ClassLoader classLoader){
  final ResourcesKey key=new ResourcesKey(resDir,splitResDirs,overlayDirs,libDirs,displayId,overrideConfig != null ? new Configuration(overrideConfig) : null,compatInfo);
  classLoader=classLoader != null ? classLoader : ClassLoader.getSystemClassLoader();
synchronized (this) {
    final ActivityResources activityResources=getOrCreateActivityResourcesStructLocked(activityToken);
    if (overrideConfig != null) {
      activityResources.overrideConfig.setTo(overrideConfig);
    }
 else {
      activityResources.overrideConfig.setToDefaults();
    }
  }
  updateResourcesForActivity(activityToken,overrideConfig);
  return getOrCreateResources(activityToken,key,classLoader);
}","/** 
 * Creates base resources for an Activity. Calls to  {@link #getResources(IBinder,String,String[],String[],String[],int,Configuration,CompatibilityInfo,ClassLoader)} with the same activityToken will have their overrideconfigurations merged with the one specified here.
 * @param activityToken Represents an Activity.
 * @param resDir The base resource path. Can be null (only framework resources will be loaded).
 * @param splitResDirs An array of split resource paths. Can be null.
 * @param overlayDirs An array of overlay paths. Can be null.
 * @param libDirs An array of resource library paths. Can be null.
 * @param displayId The ID of the display for which to create the resources.
 * @param overrideConfig The configuration to apply on top of the base configuration. Can benull. This provides the base override for this Activity.
 * @param compatInfo The compatibility settings to use. Cannot be null. A default to use is{@link CompatibilityInfo#DEFAULT_COMPATIBILITY_INFO}.
 * @param classLoader The class loader to use when inflating Resources. If null, the{@link ClassLoader#getSystemClassLoader()} is used.
 * @return a Resources object from which to access resources.
 */
public Resources createBaseActivityResources(@NonNull IBinder activityToken,@Nullable String resDir,@Nullable String[] splitResDirs,@Nullable String[] overlayDirs,@Nullable String[] libDirs,int displayId,@Nullable Configuration overrideConfig,@NonNull CompatibilityInfo compatInfo,@Nullable ClassLoader classLoader){
  final ResourcesKey key=new ResourcesKey(resDir,splitResDirs,overlayDirs,libDirs,displayId,overrideConfig != null ? new Configuration(overrideConfig) : null,compatInfo);
  classLoader=classLoader != null ? classLoader : ClassLoader.getSystemClassLoader();
  if (DEBUG) {
    Slog.d(TAG,""String_Node_Str"" + activityToken + ""String_Node_Str""+ key);
  }
synchronized (this) {
    final ActivityResources activityResources=getOrCreateActivityResourcesStructLocked(activityToken);
    if (overrideConfig != null) {
      activityResources.overrideConfig.setTo(overrideConfig);
    }
 else {
      activityResources.overrideConfig.setToDefaults();
    }
  }
  updateResourcesForActivity(activityToken,overrideConfig);
  return getOrCreateResources(activityToken,key,classLoader);
}",0.9787519570565868
192311,"/** 
 * Updates an Activity's Resources object with overrideConfig. The Resources object that was previously returned by  {@link #getResources(IBinder,String,String[],String[],String[],int,Configuration,CompatibilityInfo,ClassLoader)} isstill valid and will have the updated configuration.
 * @param activityToken The Activity token.
 * @param overrideConfig The configuration override to update.
 */
public void updateResourcesForActivity(@NonNull IBinder activityToken,@Nullable Configuration overrideConfig){
synchronized (this) {
    final ActivityResources activityResources=getOrCreateActivityResourcesStructLocked(activityToken);
    if (Objects.equals(activityResources.overrideConfig,overrideConfig)) {
      return;
    }
    final Configuration oldConfig=new Configuration(activityResources.overrideConfig);
    if (overrideConfig != null) {
      activityResources.overrideConfig.setTo(overrideConfig);
    }
 else {
      activityResources.overrideConfig.setToDefaults();
    }
    final boolean activityHasOverrideConfig=!activityResources.overrideConfig.equals(Configuration.EMPTY);
    final int refCount=activityResources.activityResources.size();
    for (int i=0; i < refCount; i++) {
      WeakReference<Resources> weakResRef=activityResources.activityResources.get(i);
      Resources resources=weakResRef.get();
      if (resources == null) {
        continue;
      }
      final ResourcesKey oldKey=findKeyForResourceImplLocked(resources.getImpl());
      if (oldKey == null) {
        Slog.e(TAG,""String_Node_Str"" + resources.getImpl());
        continue;
      }
      final Configuration rebasedOverrideConfig=new Configuration();
      if (overrideConfig != null) {
        rebasedOverrideConfig.setTo(overrideConfig);
      }
      if (activityHasOverrideConfig && oldKey.hasOverrideConfiguration()) {
        Configuration overrideOverrideConfig=Configuration.generateDelta(oldConfig,oldKey.mOverrideConfiguration);
        rebasedOverrideConfig.updateFrom(overrideOverrideConfig);
      }
      final ResourcesKey newKey=new ResourcesKey(oldKey.mResDir,oldKey.mSplitResDirs,oldKey.mOverlayDirs,oldKey.mLibDirs,oldKey.mDisplayId,rebasedOverrideConfig,oldKey.mCompatInfo);
      ResourcesImpl resourcesImpl=findResourcesImplForKeyLocked(newKey);
      if (resourcesImpl == null) {
        resourcesImpl=createResourcesImpl(newKey);
      }
      if (resourcesImpl != resources.getImpl()) {
        resources.setImpl(resourcesImpl);
      }
    }
  }
}","/** 
 * Updates an Activity's Resources object with overrideConfig. The Resources object that was previously returned by  {@link #getResources(IBinder,String,String[],String[],String[],int,Configuration,CompatibilityInfo,ClassLoader)} isstill valid and will have the updated configuration.
 * @param activityToken The Activity token.
 * @param overrideConfig The configuration override to update.
 */
public void updateResourcesForActivity(@NonNull IBinder activityToken,@Nullable Configuration overrideConfig){
synchronized (this) {
    final ActivityResources activityResources=getOrCreateActivityResourcesStructLocked(activityToken);
    if (Objects.equals(activityResources.overrideConfig,overrideConfig)) {
      return;
    }
    final Configuration oldConfig=new Configuration(activityResources.overrideConfig);
    if (overrideConfig != null) {
      activityResources.overrideConfig.setTo(overrideConfig);
    }
 else {
      activityResources.overrideConfig.setToDefaults();
    }
    if (DEBUG) {
      Throwable here=new Throwable();
      here.fillInStackTrace();
      Slog.d(TAG,""String_Node_Str"" + activityToken + ""String_Node_Str""+ Configuration.resourceQualifierString(oldConfig)+ ""String_Node_Str""+ Configuration.resourceQualifierString(activityResources.overrideConfig),here);
    }
    final boolean activityHasOverrideConfig=!activityResources.overrideConfig.equals(Configuration.EMPTY);
    final int refCount=activityResources.activityResources.size();
    for (int i=0; i < refCount; i++) {
      WeakReference<Resources> weakResRef=activityResources.activityResources.get(i);
      Resources resources=weakResRef.get();
      if (resources == null) {
        continue;
      }
      final ResourcesKey oldKey=findKeyForResourceImplLocked(resources.getImpl());
      if (oldKey == null) {
        Slog.e(TAG,""String_Node_Str"" + resources.getImpl());
        continue;
      }
      final Configuration rebasedOverrideConfig=new Configuration();
      if (overrideConfig != null) {
        rebasedOverrideConfig.setTo(overrideConfig);
      }
      if (activityHasOverrideConfig && oldKey.hasOverrideConfiguration()) {
        Configuration overrideOverrideConfig=Configuration.generateDelta(oldConfig,oldKey.mOverrideConfiguration);
        rebasedOverrideConfig.updateFrom(overrideOverrideConfig);
      }
      final ResourcesKey newKey=new ResourcesKey(oldKey.mResDir,oldKey.mSplitResDirs,oldKey.mOverlayDirs,oldKey.mLibDirs,oldKey.mDisplayId,rebasedOverrideConfig,oldKey.mCompatInfo);
      if (DEBUG) {
        Slog.d(TAG,""String_Node_Str"" + resources + ""String_Node_Str""+ oldKey+ ""String_Node_Str""+ newKey);
      }
      ResourcesImpl resourcesImpl=findResourcesImplForKeyLocked(newKey);
      if (resourcesImpl == null) {
        resourcesImpl=createResourcesImpl(newKey);
        mResourceImpls.put(newKey,new WeakReference<>(resourcesImpl));
      }
      if (resourcesImpl != resources.getImpl()) {
        resources.setImpl(resourcesImpl);
      }
    }
  }
}",0.6928414901387875
192312,"void handleLaunchTaskBehindCompleteLocked(ActivityRecord r){
  r.mLaunchTaskBehind=false;
  final TaskRecord task=r.task;
  task.setLastThumbnailLocked(task.stack.screenshotActivitiesLocked(r));
  mRecentTasks.addLocked(task);
  mService.notifyTaskStackChangedLocked();
  mWindowManager.setAppVisibility(r.appToken,false);
}","void handleLaunchTaskBehindCompleteLocked(ActivityRecord r){
  final TaskRecord task=r.task;
  final ActivityStack stack=task.stack;
  r.mLaunchTaskBehind=false;
  task.setLastThumbnailLocked(stack.screenshotActivitiesLocked(r));
  mRecentTasks.addLocked(task);
  mService.notifyTaskStackChangedLocked();
  mWindowManager.setAppVisibility(r.appToken,false);
  final ActivityRecord top=stack.topActivity();
  if (top != null) {
    top.task.touchActiveTime();
  }
}",0.7284263959390863
192313,"/** 
 * Checks the two objects for equality by delegating to their respective  {@link Object#equals(Object)} methods.
 * @param o the {@link Pair} to which this one is to be checked for equality
 * @return true if the underlying objects of the Pair are both consideredequal
 */
@Override public boolean equals(Object o){
  if (!(o instanceof Pair)) {
    return false;
  }
  Pair<?,?> p=(Pair<?,?>)o;
  return Objects.equal(p.first,first) && Objects.equal(p.second,second);
}","/** 
 * Checks the two objects for equality by delegating to their respective  {@link Object#equals(Object)} methods.
 * @param o the {@link Pair} to which this one is to be checked for equality
 * @return true if the underlying objects of the Pair are both consideredequal
 */
@Override public boolean equals(Object o){
  if (!(o instanceof Pair)) {
    return false;
  }
  Pair<?,?> p=(Pair<?,?>)o;
  return Objects.equals(p.first,first) && Objects.equals(p.second,second);
}",0.9978991596638656
192314,"@Override protected Void doInBackground(Void... params){
  final long start=SystemClock.elapsedRealtime();
  if (mFilterPackage != null) {
    if (!waitForFirstLoad()) {
      return null;
    }
  }
  mTaskRoots.put(mRecentsRoot.authority,mRecentsRoot);
  final ContentResolver resolver=mContext.getContentResolver();
  final PackageManager pm=mContext.getPackageManager();
  final Intent intent=new Intent(DocumentsContract.PROVIDER_INTERFACE);
  final List<ResolveInfo> providers=pm.queryIntentContentProviders(intent,0);
  for (  ResolveInfo info : providers) {
    handleDocumentsProvider(info.providerInfo);
  }
  final long delta=SystemClock.elapsedRealtime() - start;
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + mTaskRoots.size() + ""String_Node_Str""+ delta+ ""String_Node_Str"");
synchronized (mLock) {
    mFirstLoadDone=true;
    if (mBootCompletedResult != null) {
      mBootCompletedResult.finish();
      mBootCompletedResult=null;
    }
    mRoots=mTaskRoots;
    mStoppedAuthorities=mTaskStoppedAuthorities;
  }
  mFirstLoad.countDown();
  resolver.notifyChange(sNotificationUri,null,false);
  return null;
}","@Override protected Void doInBackground(Void... params){
  final long start=SystemClock.elapsedRealtime();
  if (mForceRefreshPackage != null) {
    if (!waitForFirstLoad()) {
      return null;
    }
  }
  mTaskRoots.put(mRecentsRoot.authority,mRecentsRoot);
  final ContentResolver resolver=mContext.getContentResolver();
  final PackageManager pm=mContext.getPackageManager();
  final Intent intent=new Intent(DocumentsContract.PROVIDER_INTERFACE);
  final List<ResolveInfo> providers=pm.queryIntentContentProviders(intent,0);
  for (  ResolveInfo info : providers) {
    handleDocumentsProvider(info.providerInfo);
  }
  final long delta=SystemClock.elapsedRealtime() - start;
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + mTaskRoots.size() + ""String_Node_Str""+ delta+ ""String_Node_Str"");
synchronized (mLock) {
    mFirstLoadDone=true;
    if (mBootCompletedResult != null) {
      mBootCompletedResult.finish();
      mBootCompletedResult=null;
    }
    mRoots=mTaskRoots;
    mStoppedAuthorities=mTaskStoppedAuthorities;
  }
  mFirstLoad.countDown();
  resolver.notifyChange(sNotificationUri,null,false);
  return null;
}",0.9928888888888888
192315,"/** 
 * Bring up requested provider and query for all active roots.
 */
private Collection<RootInfo> loadRootsForAuthority(ContentResolver resolver,String authority){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + authority);
synchronized (mObservedAuthorities) {
    if (mObservedAuthorities.add(authority)) {
      final Uri rootsUri=DocumentsContract.buildRootsUri(authority);
      mContext.getContentResolver().registerContentObserver(rootsUri,true,mObserver);
    }
  }
  final Uri rootsUri=DocumentsContract.buildRootsUri(authority);
  if (ENABLE_SYSTEM_CACHE) {
    final Bundle systemCache=resolver.getCache(rootsUri);
    if (systemCache != null) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + authority);
      return systemCache.getParcelableArrayList(TAG);
    }
  }
  final ArrayList<RootInfo> roots=new ArrayList<>();
  ContentProviderClient client=null;
  Cursor cursor=null;
  try {
    client=DocumentsApplication.acquireUnstableProviderOrThrow(resolver,authority);
    cursor=client.query(rootsUri,null,null,null,null);
    while (cursor.moveToNext()) {
      final RootInfo root=RootInfo.fromRootsCursor(authority,cursor);
      roots.add(root);
    }
  }
 catch (  Exception e) {
    Log.w(TAG,""String_Node_Str"" + authority + ""String_Node_Str""+ e);
  }
 finally {
    IoUtils.closeQuietly(cursor);
    ContentProviderClient.releaseQuietly(client);
  }
  if (ENABLE_SYSTEM_CACHE) {
    final Bundle systemCache=new Bundle();
    systemCache.putParcelableArrayList(TAG,roots);
    resolver.putCache(rootsUri,systemCache);
  }
  return roots;
}","/** 
 * Bring up requested provider and query for all active roots.
 */
private Collection<RootInfo> loadRootsForAuthority(ContentResolver resolver,String authority,boolean forceRefresh){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + authority);
synchronized (mObservedAuthorities) {
    if (mObservedAuthorities.add(authority)) {
      final Uri rootsUri=DocumentsContract.buildRootsUri(authority);
      mContext.getContentResolver().registerContentObserver(rootsUri,true,mObserver);
    }
  }
  final Uri rootsUri=DocumentsContract.buildRootsUri(authority);
  if (!forceRefresh) {
    final Bundle systemCache=resolver.getCache(rootsUri);
    if (systemCache != null) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + authority);
      return systemCache.getParcelableArrayList(TAG);
    }
  }
  final ArrayList<RootInfo> roots=new ArrayList<>();
  ContentProviderClient client=null;
  Cursor cursor=null;
  try {
    client=DocumentsApplication.acquireUnstableProviderOrThrow(resolver,authority);
    cursor=client.query(rootsUri,null,null,null,null);
    while (cursor.moveToNext()) {
      final RootInfo root=RootInfo.fromRootsCursor(authority,cursor);
      roots.add(root);
    }
  }
 catch (  Exception e) {
    Log.w(TAG,""String_Node_Str"" + authority + ""String_Node_Str""+ e);
  }
 finally {
    IoUtils.closeQuietly(cursor);
    ContentProviderClient.releaseQuietly(client);
  }
  final Bundle systemCache=new Bundle();
  systemCache.putParcelableArrayList(TAG,roots);
  resolver.putCache(rootsUri,systemCache);
  return roots;
}",0.941516709511568
192316,"/** 
 * Only update roots belonging to given package name. Other roots will be copied from cached   {@link #mRoots} values.
 */
public UpdateTask(String filterPackage){
  mFilterPackage=filterPackage;
}","/** 
 * Force update roots belonging to given package name. Other roots will be copied from cached   {@link #mRoots} values.
 */
public UpdateTask(String forceRefreshPackage){
  mForceRefreshPackage=forceRefreshPackage;
}",0.8652482269503546
192317,"/** 
 * Return the requested   {@link RootInfo}, but only loading the roots for the requested authority. This is useful when we want to load fast without waiting for all the other roots to come back.
 */
public RootInfo getRootOneshot(String authority,String rootId){
synchronized (mLock) {
    RootInfo root=getRootLocked(authority,rootId);
    if (root == null) {
      mRoots.putAll(authority,loadRootsForAuthority(mContext.getContentResolver(),authority));
      root=getRootLocked(authority,rootId);
    }
    return root;
  }
}","/** 
 * Return the requested   {@link RootInfo}, but only loading the roots for the requested authority. This is useful when we want to load fast without waiting for all the other roots to come back.
 */
public RootInfo getRootOneshot(String authority,String rootId){
synchronized (mLock) {
    RootInfo root=getRootLocked(authority,rootId);
    if (root == null) {
      mRoots.putAll(authority,loadRootsForAuthority(mContext.getContentResolver(),authority,false));
      root=getRootLocked(authority,rootId);
    }
    return root;
  }
}",0.9944029850746268
192318,"/** 
 * Load roots from authorities that are in stopped state. Normal  {@link UpdateTask} passes ignore stopped applications.
 */
private void loadStoppedAuthorities(){
  final ContentResolver resolver=mContext.getContentResolver();
synchronized (mLock) {
    for (    String authority : mStoppedAuthorities) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + authority);
      mRoots.putAll(authority,loadRootsForAuthority(resolver,authority));
    }
    mStoppedAuthorities.clear();
  }
}","/** 
 * Load roots from authorities that are in stopped state. Normal  {@link UpdateTask} passes ignore stopped applications.
 */
private void loadStoppedAuthorities(){
  final ContentResolver resolver=mContext.getContentResolver();
synchronized (mLock) {
    for (    String authority : mStoppedAuthorities) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + authority);
      mRoots.putAll(authority,loadRootsForAuthority(resolver,authority,true));
    }
    mStoppedAuthorities.clear();
  }
}",0.9949647532729105
192319,"private void handleDocumentsProvider(ProviderInfo info){
  if ((info.applicationInfo.flags & ApplicationInfo.FLAG_STOPPED) != 0) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + info.authority);
    mTaskStoppedAuthorities.add(info.authority);
    return;
  }
  boolean cacheHit=false;
  if (mFilterPackage != null && !mFilterPackage.equals(info.packageName)) {
synchronized (mLock) {
      if (mTaskRoots.putAll(info.authority,mRoots.get(info.authority))) {
        if (DEBUG)         Log.d(TAG,""String_Node_Str"" + info.authority);
        cacheHit=true;
      }
    }
  }
  if (!cacheHit) {
    mTaskRoots.putAll(info.authority,loadRootsForAuthority(mContext.getContentResolver(),info.authority));
  }
}","private void handleDocumentsProvider(ProviderInfo info){
  if ((info.applicationInfo.flags & ApplicationInfo.FLAG_STOPPED) != 0) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + info.authority);
    mTaskStoppedAuthorities.add(info.authority);
    return;
  }
  final boolean forceRefresh=Objects.equals(mForceRefreshPackage,info.packageName);
  mTaskRoots.putAll(info.authority,loadRootsForAuthority(mContext.getContentResolver(),info.authority,forceRefresh));
}",0.5784982935153583
192320,"/** 
 * Load roots from a stopped authority. Normal   {@link UpdateTask} passesignore stopped applications.
 */
private void loadStoppedAuthority(String authority){
  final ContentResolver resolver=mContext.getContentResolver();
synchronized (mLock) {
    if (!mStoppedAuthorities.contains(authority)) {
      return;
    }
    if (DEBUG) {
      Log.d(TAG,""String_Node_Str"" + authority);
    }
    mRoots.putAll(authority,loadRootsForAuthority(resolver,authority));
    mStoppedAuthorities.remove(authority);
  }
}","/** 
 * Load roots from a stopped authority. Normal   {@link UpdateTask} passesignore stopped applications.
 */
private void loadStoppedAuthority(String authority){
  final ContentResolver resolver=mContext.getContentResolver();
synchronized (mLock) {
    if (!mStoppedAuthorities.contains(authority)) {
      return;
    }
    if (DEBUG) {
      Log.d(TAG,""String_Node_Str"" + authority);
    }
    mRoots.putAll(authority,loadRootsForAuthority(resolver,authority,true));
    mStoppedAuthorities.remove(authority);
  }
}",0.9951690821256038
192321,"private void onDiskScannedLocked(DiskInfo disk){
  int volumeCount=0;
  for (int i=0; i < mVolumes.size(); i++) {
    final VolumeInfo vol=mVolumes.valueAt(i);
    if (Objects.equals(disk.id,vol.getDiskId())) {
      volumeCount++;
    }
  }
  final Intent intent=new Intent(DiskInfo.ACTION_DISK_SCANNED);
  intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
  intent.putExtra(DiskInfo.EXTRA_DISK_ID,disk.id);
  intent.putExtra(DiskInfo.EXTRA_VOLUME_COUNT,volumeCount);
  mHandler.obtainMessage(H_INTERNAL_BROADCAST,intent).sendToTarget();
  final CountDownLatch latch=mDiskScanLatches.remove(disk.id);
  if (latch != null) {
    latch.countDown();
  }
  disk.volumeCount=volumeCount;
  mCallbacks.notifyDiskScanned(disk,volumeCount);
}","private void onDiskScannedLocked(DiskInfo disk){
  int volumeCount=0;
  for (int i=0; i < mVolumes.size(); i++) {
    final VolumeInfo vol=mVolumes.valueAt(i);
    if (Objects.equals(disk.id,vol.getDiskId())) {
      volumeCount++;
    }
  }
  final Intent intent=new Intent(DiskInfo.ACTION_DISK_SCANNED);
  intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);
  intent.putExtra(DiskInfo.EXTRA_DISK_ID,disk.id);
  intent.putExtra(DiskInfo.EXTRA_VOLUME_COUNT,volumeCount);
  mHandler.obtainMessage(H_INTERNAL_BROADCAST,intent).sendToTarget();
  final CountDownLatch latch=mDiskScanLatches.remove(disk.id);
  if (latch != null) {
    latch.countDown();
  }
  disk.volumeCount=volumeCount;
  mCallbacks.notifyDiskScanned(disk,volumeCount);
}",0.9728331177231564
192322,"private void onVolumeStateChangedLocked(VolumeInfo vol,int oldState,int newState){
  if (vol.isMountedReadable() && !TextUtils.isEmpty(vol.fsUuid)) {
    VolumeRecord rec=mRecords.get(vol.fsUuid);
    if (rec == null) {
      rec=new VolumeRecord(vol.type,vol.fsUuid);
      rec.partGuid=vol.partGuid;
      rec.createdMillis=System.currentTimeMillis();
      if (vol.type == VolumeInfo.TYPE_PRIVATE) {
        rec.nickname=vol.disk.getDescription();
      }
      mRecords.put(rec.fsUuid,rec);
      writeSettingsLocked();
    }
 else {
      if (TextUtils.isEmpty(rec.partGuid)) {
        rec.partGuid=vol.partGuid;
        writeSettingsLocked();
      }
    }
  }
  mCallbacks.notifyVolumeStateChanged(vol,oldState,newState);
  if (mBootCompleted && isBroadcastWorthy(vol)) {
    final Intent intent=new Intent(VolumeInfo.ACTION_VOLUME_STATE_CHANGED);
    intent.putExtra(VolumeInfo.EXTRA_VOLUME_ID,vol.id);
    intent.putExtra(VolumeInfo.EXTRA_VOLUME_STATE,newState);
    intent.putExtra(VolumeRecord.EXTRA_FS_UUID,vol.fsUuid);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    mHandler.obtainMessage(H_INTERNAL_BROADCAST,intent).sendToTarget();
  }
  final String oldStateEnv=VolumeInfo.getEnvironmentForState(oldState);
  final String newStateEnv=VolumeInfo.getEnvironmentForState(newState);
  if (!Objects.equals(oldStateEnv,newStateEnv)) {
    for (    int userId : mSystemUnlockedUsers) {
      if (vol.isVisibleForRead(userId)) {
        final StorageVolume userVol=vol.buildStorageVolume(mContext,userId,false);
        mHandler.obtainMessage(H_VOLUME_BROADCAST,userVol).sendToTarget();
        mCallbacks.notifyStorageStateChanged(userVol.getPath(),oldStateEnv,newStateEnv);
      }
    }
  }
  if (vol.type == VolumeInfo.TYPE_PUBLIC && vol.state == VolumeInfo.STATE_EJECTING) {
    mObbActionHandler.sendMessage(mObbActionHandler.obtainMessage(OBB_FLUSH_MOUNT_STATE,vol.path));
  }
}","private void onVolumeStateChangedLocked(VolumeInfo vol,int oldState,int newState){
  if (vol.isMountedReadable() && !TextUtils.isEmpty(vol.fsUuid)) {
    VolumeRecord rec=mRecords.get(vol.fsUuid);
    if (rec == null) {
      rec=new VolumeRecord(vol.type,vol.fsUuid);
      rec.partGuid=vol.partGuid;
      rec.createdMillis=System.currentTimeMillis();
      if (vol.type == VolumeInfo.TYPE_PRIVATE) {
        rec.nickname=vol.disk.getDescription();
      }
      mRecords.put(rec.fsUuid,rec);
      writeSettingsLocked();
    }
 else {
      if (TextUtils.isEmpty(rec.partGuid)) {
        rec.partGuid=vol.partGuid;
        writeSettingsLocked();
      }
    }
  }
  mCallbacks.notifyVolumeStateChanged(vol,oldState,newState);
  if (mBootCompleted && isBroadcastWorthy(vol)) {
    final Intent intent=new Intent(VolumeInfo.ACTION_VOLUME_STATE_CHANGED);
    intent.putExtra(VolumeInfo.EXTRA_VOLUME_ID,vol.id);
    intent.putExtra(VolumeInfo.EXTRA_VOLUME_STATE,newState);
    intent.putExtra(VolumeRecord.EXTRA_FS_UUID,vol.fsUuid);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);
    mHandler.obtainMessage(H_INTERNAL_BROADCAST,intent).sendToTarget();
  }
  final String oldStateEnv=VolumeInfo.getEnvironmentForState(oldState);
  final String newStateEnv=VolumeInfo.getEnvironmentForState(newState);
  if (!Objects.equals(oldStateEnv,newStateEnv)) {
    for (    int userId : mSystemUnlockedUsers) {
      if (vol.isVisibleForRead(userId)) {
        final StorageVolume userVol=vol.buildStorageVolume(mContext,userId,false);
        mHandler.obtainMessage(H_VOLUME_BROADCAST,userVol).sendToTarget();
        mCallbacks.notifyStorageStateChanged(userVol.getPath(),oldStateEnv,newStateEnv);
      }
    }
  }
  if (vol.type == VolumeInfo.TYPE_PUBLIC && vol.state == VolumeInfo.STATE_EJECTING) {
    mObbActionHandler.sendMessage(mObbActionHandler.obtainMessage(OBB_FLUSH_MOUNT_STATE,vol.path));
  }
}",0.9891864057672504
192323,"private void invalidateCacheLocked(int userId,String providerPackageName,Uri uri){
  ArrayMap<String,ArrayMap<Pair<String,Uri>,Bundle>> userCache=mCache.get(userId);
  if (userCache == null)   return;
  ArrayMap<Pair<String,Uri>,Bundle> packageCache=userCache.get(providerPackageName);
  if (packageCache == null)   return;
  if (uri != null) {
    for (int i=0; i < packageCache.size(); ) {
      final Uri key=packageCache.keyAt(i).second;
      if (Objects.equals(key,uri)) {
        packageCache.removeAt(i);
      }
 else {
        i++;
      }
    }
  }
 else {
    packageCache.clear();
  }
}","private void invalidateCacheLocked(int userId,String providerPackageName,Uri uri){
  ArrayMap<String,ArrayMap<Pair<String,Uri>,Bundle>> userCache=mCache.get(userId);
  if (userCache == null)   return;
  ArrayMap<Pair<String,Uri>,Bundle> packageCache=userCache.get(providerPackageName);
  if (packageCache == null)   return;
  if (uri != null) {
    for (int i=0; i < packageCache.size(); ) {
      final Pair<String,Uri> key=packageCache.keyAt(i);
      if (key.second != null && key.second.toString().startsWith(uri.toString())) {
        Slog.d(TAG,""String_Node_Str"" + key);
        packageCache.removeAt(i);
      }
 else {
        i++;
      }
    }
  }
 else {
    Slog.d(TAG,""String_Node_Str"" + providerPackageName);
    packageCache.clear();
  }
}",0.8470066518847007
192324,"void becomeActiveLocked(String activeReason,int activeUid){
  if (DEBUG)   Slog.i(TAG,""String_Node_Str"" + activeReason);
  if (mState != STATE_ACTIVE || mLightState != STATE_ACTIVE) {
    EventLogTags.writeDeviceIdle(STATE_ACTIVE,activeReason);
    EventLogTags.writeDeviceIdleLight(LIGHT_STATE_ACTIVE,activeReason);
    scheduleReportActiveLocked(activeReason,activeUid);
    mState=STATE_ACTIVE;
    mLightState=LIGHT_STATE_ACTIVE;
    mInactiveTimeout=mConstants.INACTIVE_TIMEOUT;
    mCurIdleBudget=0;
    mMaintenanceStartTime=0;
    if (mMaintenanceMinCheckScheduled) {
      mAlarmManager.cancel(mMaintenanceMinCheckListener);
      mMaintenanceMinCheckScheduled=false;
    }
    resetIdleManagementLocked();
    resetLightIdleManagementLocked();
    addEvent(EVENT_NORMAL);
  }
}","void becomeActiveLocked(String activeReason,int activeUid){
  if (DEBUG)   Slog.i(TAG,""String_Node_Str"" + activeReason);
  if (mState != STATE_ACTIVE || mLightState != STATE_ACTIVE) {
    EventLogTags.writeDeviceIdle(STATE_ACTIVE,activeReason);
    EventLogTags.writeDeviceIdleLight(LIGHT_STATE_ACTIVE,activeReason);
    scheduleReportActiveLocked(activeReason,activeUid);
    mState=STATE_ACTIVE;
    mLightState=LIGHT_STATE_ACTIVE;
    mInactiveTimeout=mConstants.INACTIVE_TIMEOUT;
    mCurIdleBudget=0;
    mMaintenanceStartTime=0;
    resetIdleManagementLocked();
    resetLightIdleManagementLocked();
    addEvent(EVENT_NORMAL);
  }
}",0.8962131837307152
192325,"void stepIdleStateLocked(String reason){
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + mState);
  EventLogTags.writeDeviceIdleStep();
  final long now=SystemClock.elapsedRealtime();
  if ((now + mConstants.MIN_TIME_TO_ALARM) > mAlarmManager.getNextWakeFromIdleTime()) {
    if (mState != STATE_ACTIVE) {
      becomeActiveLocked(""String_Node_Str"",Process.myUid());
      becomeInactiveIfAppropriateLocked();
    }
    return;
  }
switch (mState) {
case STATE_INACTIVE:
    startMonitoringMotionLocked();
  scheduleAlarmLocked(mConstants.IDLE_AFTER_INACTIVE_TIMEOUT,false);
mNextIdlePendingDelay=mConstants.IDLE_PENDING_TIMEOUT;
mNextIdleDelay=mConstants.IDLE_TIMEOUT;
mState=STATE_IDLE_PENDING;
if (DEBUG) Slog.d(TAG,""String_Node_Str"");
EventLogTags.writeDeviceIdle(mState,reason);
break;
case STATE_IDLE_PENDING:
mState=STATE_SENSING;
if (DEBUG) Slog.d(TAG,""String_Node_Str"");
EventLogTags.writeDeviceIdle(mState,reason);
scheduleAlarmLocked(mConstants.SENSING_TIMEOUT,false);
cancelLocatingLocked();
mAnyMotionDetector.checkForAnyMotion();
mNotMoving=false;
mLocated=false;
mLastGenericLocation=null;
mLastGpsLocation=null;
break;
case STATE_SENSING:
mState=STATE_LOCATING;
if (DEBUG) Slog.d(TAG,""String_Node_Str"");
EventLogTags.writeDeviceIdle(mState,reason);
scheduleAlarmLocked(mConstants.LOCATING_TIMEOUT,false);
if (mLocationManager != null && mLocationManager.getProvider(LocationManager.NETWORK_PROVIDER) != null) {
mLocationManager.requestLocationUpdates(mLocationRequest,mGenericLocationListener,mHandler.getLooper());
mLocating=true;
}
 else {
mHasNetworkLocation=false;
}
if (mLocationManager != null && mLocationManager.getProvider(LocationManager.GPS_PROVIDER) != null) {
mHasGps=true;
mLocationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER,1000,5,mGpsLocationListener,mHandler.getLooper());
mLocating=true;
}
 else {
mHasGps=false;
}
if (mLocating) {
break;
}
case STATE_LOCATING:
cancelAlarmLocked();
cancelLocatingLocked();
mAnyMotionDetector.stop();
case STATE_IDLE_MAINTENANCE:
scheduleAlarmLocked(mNextIdleDelay,true);
if (DEBUG) Slog.d(TAG,""String_Node_Str"" + mNextIdleDelay + ""String_Node_Str"");
mNextIdleDelay=(long)(mNextIdleDelay * mConstants.IDLE_FACTOR);
if (DEBUG) Slog.d(TAG,""String_Node_Str"" + mNextIdleDelay);
mNextIdleDelay=Math.min(mNextIdleDelay,mConstants.MAX_IDLE_TIMEOUT);
if (mNextIdleDelay < mConstants.IDLE_TIMEOUT) {
mNextIdleDelay=mConstants.IDLE_TIMEOUT;
}
mState=STATE_IDLE;
if (mLightState != LIGHT_STATE_OVERRIDE) {
mLightState=LIGHT_STATE_OVERRIDE;
cancelLightAlarmLocked();
}
EventLogTags.writeDeviceIdle(mState,reason);
addEvent(EVENT_DEEP_IDLE);
mHandler.sendEmptyMessage(MSG_REPORT_IDLE_ON);
if (mMaintenanceMinCheckScheduled) {
mAlarmManager.cancel(mMaintenanceMinCheckListener);
mMaintenanceMinCheckScheduled=false;
}
break;
case STATE_IDLE:
mActiveIdleOpCount=1;
scheduleAlarmLocked(mNextIdlePendingDelay,false);
if (DEBUG) Slog.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + mNextIdlePendingDelay + ""String_Node_Str"");
mMaintenanceStartTime=SystemClock.elapsedRealtime();
mNextIdlePendingDelay=Math.min(mConstants.MAX_IDLE_PENDING_TIMEOUT,(long)(mNextIdlePendingDelay * mConstants.IDLE_PENDING_FACTOR));
if (mNextIdlePendingDelay < mConstants.IDLE_PENDING_TIMEOUT) {
mNextIdlePendingDelay=mConstants.IDLE_PENDING_TIMEOUT;
}
mState=STATE_IDLE_MAINTENANCE;
EventLogTags.writeDeviceIdle(mState,reason);
addEvent(EVENT_DEEP_MAINTENANCE);
mHandler.sendEmptyMessage(MSG_REPORT_IDLE_OFF);
mAlarmManager.setExact(AlarmManager.ELAPSED_REALTIME,mMaintenanceStartTime + mConstants.MIN_DEEP_MAINTENANCE_TIME,""String_Node_Str"",mMaintenanceMinCheckListener,mHandler);
mMaintenanceMinCheckScheduled=true;
break;
}
}","void stepIdleStateLocked(String reason){
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + mState);
  EventLogTags.writeDeviceIdleStep();
  final long now=SystemClock.elapsedRealtime();
  if ((now + mConstants.MIN_TIME_TO_ALARM) > mAlarmManager.getNextWakeFromIdleTime()) {
    if (mState != STATE_ACTIVE) {
      becomeActiveLocked(""String_Node_Str"",Process.myUid());
      becomeInactiveIfAppropriateLocked();
    }
    return;
  }
switch (mState) {
case STATE_INACTIVE:
    startMonitoringMotionLocked();
  scheduleAlarmLocked(mConstants.IDLE_AFTER_INACTIVE_TIMEOUT,false);
mNextIdlePendingDelay=mConstants.IDLE_PENDING_TIMEOUT;
mNextIdleDelay=mConstants.IDLE_TIMEOUT;
mState=STATE_IDLE_PENDING;
if (DEBUG) Slog.d(TAG,""String_Node_Str"");
EventLogTags.writeDeviceIdle(mState,reason);
break;
case STATE_IDLE_PENDING:
mState=STATE_SENSING;
if (DEBUG) Slog.d(TAG,""String_Node_Str"");
EventLogTags.writeDeviceIdle(mState,reason);
scheduleAlarmLocked(mConstants.SENSING_TIMEOUT,false);
cancelLocatingLocked();
mAnyMotionDetector.checkForAnyMotion();
mNotMoving=false;
mLocated=false;
mLastGenericLocation=null;
mLastGpsLocation=null;
break;
case STATE_SENSING:
mState=STATE_LOCATING;
if (DEBUG) Slog.d(TAG,""String_Node_Str"");
EventLogTags.writeDeviceIdle(mState,reason);
scheduleAlarmLocked(mConstants.LOCATING_TIMEOUT,false);
if (mLocationManager != null && mLocationManager.getProvider(LocationManager.NETWORK_PROVIDER) != null) {
mLocationManager.requestLocationUpdates(mLocationRequest,mGenericLocationListener,mHandler.getLooper());
mLocating=true;
}
 else {
mHasNetworkLocation=false;
}
if (mLocationManager != null && mLocationManager.getProvider(LocationManager.GPS_PROVIDER) != null) {
mHasGps=true;
mLocationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER,1000,5,mGpsLocationListener,mHandler.getLooper());
mLocating=true;
}
 else {
mHasGps=false;
}
if (mLocating) {
break;
}
case STATE_LOCATING:
cancelAlarmLocked();
cancelLocatingLocked();
mAnyMotionDetector.stop();
case STATE_IDLE_MAINTENANCE:
scheduleAlarmLocked(mNextIdleDelay,true);
if (DEBUG) Slog.d(TAG,""String_Node_Str"" + mNextIdleDelay + ""String_Node_Str"");
mNextIdleDelay=(long)(mNextIdleDelay * mConstants.IDLE_FACTOR);
if (DEBUG) Slog.d(TAG,""String_Node_Str"" + mNextIdleDelay);
mNextIdleDelay=Math.min(mNextIdleDelay,mConstants.MAX_IDLE_TIMEOUT);
if (mNextIdleDelay < mConstants.IDLE_TIMEOUT) {
mNextIdleDelay=mConstants.IDLE_TIMEOUT;
}
mState=STATE_IDLE;
if (mLightState != LIGHT_STATE_OVERRIDE) {
mLightState=LIGHT_STATE_OVERRIDE;
cancelLightAlarmLocked();
}
EventLogTags.writeDeviceIdle(mState,reason);
addEvent(EVENT_DEEP_IDLE);
mHandler.sendEmptyMessage(MSG_REPORT_IDLE_ON);
break;
case STATE_IDLE:
mActiveIdleOpCount=1;
mActiveIdleWakeLock.acquire();
scheduleAlarmLocked(mNextIdlePendingDelay,false);
if (DEBUG) Slog.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + mNextIdlePendingDelay + ""String_Node_Str"");
mMaintenanceStartTime=SystemClock.elapsedRealtime();
mNextIdlePendingDelay=Math.min(mConstants.MAX_IDLE_PENDING_TIMEOUT,(long)(mNextIdlePendingDelay * mConstants.IDLE_PENDING_FACTOR));
if (mNextIdlePendingDelay < mConstants.IDLE_PENDING_TIMEOUT) {
mNextIdlePendingDelay=mConstants.IDLE_PENDING_TIMEOUT;
}
mState=STATE_IDLE_MAINTENANCE;
EventLogTags.writeDeviceIdle(mState,reason);
addEvent(EVENT_DEEP_MAINTENANCE);
mHandler.sendEmptyMessage(MSG_REPORT_IDLE_OFF);
break;
}
}",0.9466799374377932
192326,"void stepLightIdleStateLocked(String reason){
  if (mLightState == LIGHT_STATE_OVERRIDE) {
    return;
  }
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + mLightState);
  EventLogTags.writeDeviceIdleLightStep();
switch (mLightState) {
case LIGHT_STATE_INACTIVE:
    mCurIdleBudget=mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET;
  mNextLightIdleDelay=mConstants.LIGHT_IDLE_TIMEOUT;
mMaintenanceStartTime=0;
case LIGHT_STATE_IDLE_MAINTENANCE:
if (mMaintenanceStartTime != 0) {
long duration=SystemClock.elapsedRealtime() - mMaintenanceStartTime;
if (duration < mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET) {
  mCurIdleBudget+=(mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET - duration);
}
 else {
  mCurIdleBudget-=(duration - mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET);
}
}
mMaintenanceStartTime=0;
scheduleLightAlarmLocked(mNextLightIdleDelay);
mNextLightIdleDelay=Math.min(mConstants.LIGHT_MAX_IDLE_TIMEOUT,(long)(mNextLightIdleDelay * mConstants.LIGHT_IDLE_FACTOR));
if (mNextLightIdleDelay < mConstants.LIGHT_IDLE_TIMEOUT) {
mNextLightIdleDelay=mConstants.LIGHT_IDLE_TIMEOUT;
}
if (DEBUG) Slog.d(TAG,""String_Node_Str"");
mLightState=LIGHT_STATE_IDLE;
EventLogTags.writeDeviceIdleLight(mLightState,reason);
addEvent(EVENT_LIGHT_IDLE);
mHandler.sendEmptyMessage(MSG_REPORT_IDLE_ON_LIGHT);
if (mMaintenanceMinCheckScheduled) {
mAlarmManager.cancel(mMaintenanceMinCheckListener);
mMaintenanceMinCheckScheduled=false;
}
break;
case LIGHT_STATE_IDLE:
mActiveIdleOpCount=1;
mMaintenanceStartTime=SystemClock.elapsedRealtime();
if (mCurIdleBudget < mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET) {
mCurIdleBudget=mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET;
}
 else if (mCurIdleBudget > mConstants.LIGHT_IDLE_MAINTENANCE_MAX_BUDGET) {
mCurIdleBudget=mConstants.LIGHT_IDLE_MAINTENANCE_MAX_BUDGET;
}
scheduleLightAlarmLocked(mCurIdleBudget);
if (DEBUG) Slog.d(TAG,""String_Node_Str"");
mLightState=LIGHT_STATE_IDLE_MAINTENANCE;
EventLogTags.writeDeviceIdleLight(mLightState,reason);
addEvent(EVENT_LIGHT_MAINTENANCE);
mHandler.sendEmptyMessage(MSG_REPORT_IDLE_OFF);
mAlarmManager.setExact(AlarmManager.ELAPSED_REALTIME,mMaintenanceStartTime + mConstants.MIN_LIGHT_MAINTENANCE_TIME,""String_Node_Str"",mMaintenanceMinCheckListener,mHandler);
mMaintenanceMinCheckScheduled=true;
break;
}
}","void stepLightIdleStateLocked(String reason){
  if (mLightState == LIGHT_STATE_OVERRIDE) {
    return;
  }
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + mLightState);
  EventLogTags.writeDeviceIdleLightStep();
switch (mLightState) {
case LIGHT_STATE_INACTIVE:
    mCurIdleBudget=mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET;
  mNextLightIdleDelay=mConstants.LIGHT_IDLE_TIMEOUT;
mMaintenanceStartTime=0;
if (!isOpsInactiveLocked()) {
mLightState=LIGHT_STATE_PRE_IDLE;
EventLogTags.writeDeviceIdleLight(mLightState,reason);
scheduleLightAlarmLocked(mConstants.LIGHT_PRE_IDLE_TIMEOUT);
break;
}
case LIGHT_STATE_PRE_IDLE:
case LIGHT_STATE_IDLE_MAINTENANCE:
if (mMaintenanceStartTime != 0) {
long duration=SystemClock.elapsedRealtime() - mMaintenanceStartTime;
if (duration < mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET) {
mCurIdleBudget+=(mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET - duration);
}
 else {
mCurIdleBudget-=(duration - mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET);
}
}
mMaintenanceStartTime=0;
scheduleLightAlarmLocked(mNextLightIdleDelay);
mNextLightIdleDelay=Math.min(mConstants.LIGHT_MAX_IDLE_TIMEOUT,(long)(mNextLightIdleDelay * mConstants.LIGHT_IDLE_FACTOR));
if (mNextLightIdleDelay < mConstants.LIGHT_IDLE_TIMEOUT) {
mNextLightIdleDelay=mConstants.LIGHT_IDLE_TIMEOUT;
}
if (DEBUG) Slog.d(TAG,""String_Node_Str"");
mLightState=LIGHT_STATE_IDLE;
EventLogTags.writeDeviceIdleLight(mLightState,reason);
addEvent(EVENT_LIGHT_IDLE);
mHandler.sendEmptyMessage(MSG_REPORT_IDLE_ON_LIGHT);
break;
case LIGHT_STATE_IDLE:
mActiveIdleOpCount=1;
mActiveIdleWakeLock.acquire();
mMaintenanceStartTime=SystemClock.elapsedRealtime();
if (mCurIdleBudget < mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET) {
mCurIdleBudget=mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET;
}
 else if (mCurIdleBudget > mConstants.LIGHT_IDLE_MAINTENANCE_MAX_BUDGET) {
mCurIdleBudget=mConstants.LIGHT_IDLE_MAINTENANCE_MAX_BUDGET;
}
scheduleLightAlarmLocked(mCurIdleBudget);
if (DEBUG) Slog.d(TAG,""String_Node_Str"");
mLightState=LIGHT_STATE_IDLE_MAINTENANCE;
EventLogTags.writeDeviceIdleLight(mLightState,reason);
addEvent(EVENT_LIGHT_MAINTENANCE);
mHandler.sendEmptyMessage(MSG_REPORT_IDLE_OFF);
break;
}
}",0.8661876964526268
192327,"private void updateConstants(){
synchronized (DeviceIdleController.this) {
    try {
      mParser.setString(Settings.Global.getString(mResolver,mHasWatch ? Settings.Global.DEVICE_IDLE_CONSTANTS_WATCH : Settings.Global.DEVICE_IDLE_CONSTANTS));
    }
 catch (    IllegalArgumentException e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
    LIGHT_IDLE_AFTER_INACTIVE_TIMEOUT=mParser.getLong(KEY_LIGHT_IDLE_AFTER_INACTIVE_TIMEOUT,!COMPRESS_TIME ? 5 * 60 * 1000L : 15 * 1000L);
    LIGHT_IDLE_TIMEOUT=mParser.getLong(KEY_LIGHT_IDLE_TIMEOUT,!COMPRESS_TIME ? 5 * 60 * 1000L : 15 * 1000L);
    LIGHT_IDLE_FACTOR=mParser.getFloat(KEY_LIGHT_IDLE_FACTOR,2f);
    LIGHT_MAX_IDLE_TIMEOUT=mParser.getLong(KEY_LIGHT_MAX_IDLE_TIMEOUT,!COMPRESS_TIME ? 15 * 60 * 1000L : 60 * 1000L);
    LIGHT_IDLE_MAINTENANCE_MIN_BUDGET=mParser.getLong(KEY_LIGHT_IDLE_MAINTENANCE_MIN_BUDGET,!COMPRESS_TIME ? 1 * 60 * 1000L : 15 * 1000L);
    LIGHT_IDLE_MAINTENANCE_MAX_BUDGET=mParser.getLong(KEY_LIGHT_IDLE_MAINTENANCE_MAX_BUDGET,!COMPRESS_TIME ? 5 * 60 * 1000L : 30 * 1000L);
    MIN_LIGHT_MAINTENANCE_TIME=mParser.getLong(KEY_MIN_LIGHT_MAINTENANCE_TIME,!COMPRESS_TIME ? 5 * 1000L : 1 * 1000L);
    MIN_DEEP_MAINTENANCE_TIME=mParser.getLong(KEY_MIN_DEEP_MAINTENANCE_TIME,!COMPRESS_TIME ? 30 * 1000L : 5 * 1000L);
    long inactiveTimeoutDefault=(mHasWatch ? 15 : 30) * 60 * 1000L;
    INACTIVE_TIMEOUT=mParser.getLong(KEY_INACTIVE_TIMEOUT,!COMPRESS_TIME ? inactiveTimeoutDefault : (inactiveTimeoutDefault / 10));
    SENSING_TIMEOUT=mParser.getLong(KEY_SENSING_TIMEOUT,!DEBUG ? 4 * 60 * 1000L : 60 * 1000L);
    LOCATING_TIMEOUT=mParser.getLong(KEY_LOCATING_TIMEOUT,!DEBUG ? 30 * 1000L : 15 * 1000L);
    LOCATION_ACCURACY=mParser.getFloat(KEY_LOCATION_ACCURACY,20);
    MOTION_INACTIVE_TIMEOUT=mParser.getLong(KEY_MOTION_INACTIVE_TIMEOUT,!COMPRESS_TIME ? 10 * 60 * 1000L : 60 * 1000L);
    long idleAfterInactiveTimeout=(mHasWatch ? 15 : 30) * 60 * 1000L;
    IDLE_AFTER_INACTIVE_TIMEOUT=mParser.getLong(KEY_IDLE_AFTER_INACTIVE_TIMEOUT,!COMPRESS_TIME ? idleAfterInactiveTimeout : (idleAfterInactiveTimeout / 10));
    IDLE_PENDING_TIMEOUT=mParser.getLong(KEY_IDLE_PENDING_TIMEOUT,!COMPRESS_TIME ? 5 * 60 * 1000L : 30 * 1000L);
    MAX_IDLE_PENDING_TIMEOUT=mParser.getLong(KEY_MAX_IDLE_PENDING_TIMEOUT,!COMPRESS_TIME ? 10 * 60 * 1000L : 60 * 1000L);
    IDLE_PENDING_FACTOR=mParser.getFloat(KEY_IDLE_PENDING_FACTOR,2f);
    IDLE_TIMEOUT=mParser.getLong(KEY_IDLE_TIMEOUT,!COMPRESS_TIME ? 60 * 60 * 1000L : 6 * 60 * 1000L);
    MAX_IDLE_TIMEOUT=mParser.getLong(KEY_MAX_IDLE_TIMEOUT,!COMPRESS_TIME ? 6 * 60 * 60* 1000L : 30 * 60 * 1000L);
    IDLE_FACTOR=mParser.getFloat(KEY_IDLE_FACTOR,2f);
    MIN_TIME_TO_ALARM=mParser.getLong(KEY_MIN_TIME_TO_ALARM,!COMPRESS_TIME ? 60 * 60 * 1000L : 6 * 60 * 1000L);
    MAX_TEMP_APP_WHITELIST_DURATION=mParser.getLong(KEY_MAX_TEMP_APP_WHITELIST_DURATION,5 * 60 * 1000L);
    MMS_TEMP_APP_WHITELIST_DURATION=mParser.getLong(KEY_MMS_TEMP_APP_WHITELIST_DURATION,60 * 1000L);
    SMS_TEMP_APP_WHITELIST_DURATION=mParser.getLong(KEY_SMS_TEMP_APP_WHITELIST_DURATION,20 * 1000L);
  }
}","private void updateConstants(){
synchronized (DeviceIdleController.this) {
    try {
      mParser.setString(Settings.Global.getString(mResolver,mHasWatch ? Settings.Global.DEVICE_IDLE_CONSTANTS_WATCH : Settings.Global.DEVICE_IDLE_CONSTANTS));
    }
 catch (    IllegalArgumentException e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
    LIGHT_IDLE_AFTER_INACTIVE_TIMEOUT=mParser.getLong(KEY_LIGHT_IDLE_AFTER_INACTIVE_TIMEOUT,!COMPRESS_TIME ? 5 * 60 * 1000L : 15 * 1000L);
    LIGHT_PRE_IDLE_TIMEOUT=mParser.getLong(KEY_LIGHT_PRE_IDLE_TIMEOUT,!COMPRESS_TIME ? 10 * 60 * 1000L : 30 * 1000L);
    LIGHT_IDLE_TIMEOUT=mParser.getLong(KEY_LIGHT_IDLE_TIMEOUT,!COMPRESS_TIME ? 5 * 60 * 1000L : 15 * 1000L);
    LIGHT_IDLE_FACTOR=mParser.getFloat(KEY_LIGHT_IDLE_FACTOR,2f);
    LIGHT_MAX_IDLE_TIMEOUT=mParser.getLong(KEY_LIGHT_MAX_IDLE_TIMEOUT,!COMPRESS_TIME ? 15 * 60 * 1000L : 60 * 1000L);
    LIGHT_IDLE_MAINTENANCE_MIN_BUDGET=mParser.getLong(KEY_LIGHT_IDLE_MAINTENANCE_MIN_BUDGET,!COMPRESS_TIME ? 1 * 60 * 1000L : 15 * 1000L);
    LIGHT_IDLE_MAINTENANCE_MAX_BUDGET=mParser.getLong(KEY_LIGHT_IDLE_MAINTENANCE_MAX_BUDGET,!COMPRESS_TIME ? 5 * 60 * 1000L : 30 * 1000L);
    MIN_LIGHT_MAINTENANCE_TIME=mParser.getLong(KEY_MIN_LIGHT_MAINTENANCE_TIME,!COMPRESS_TIME ? 5 * 1000L : 1 * 1000L);
    MIN_DEEP_MAINTENANCE_TIME=mParser.getLong(KEY_MIN_DEEP_MAINTENANCE_TIME,!COMPRESS_TIME ? 30 * 1000L : 5 * 1000L);
    long inactiveTimeoutDefault=(mHasWatch ? 15 : 30) * 60 * 1000L;
    INACTIVE_TIMEOUT=mParser.getLong(KEY_INACTIVE_TIMEOUT,!COMPRESS_TIME ? inactiveTimeoutDefault : (inactiveTimeoutDefault / 10));
    SENSING_TIMEOUT=mParser.getLong(KEY_SENSING_TIMEOUT,!DEBUG ? 4 * 60 * 1000L : 60 * 1000L);
    LOCATING_TIMEOUT=mParser.getLong(KEY_LOCATING_TIMEOUT,!DEBUG ? 30 * 1000L : 15 * 1000L);
    LOCATION_ACCURACY=mParser.getFloat(KEY_LOCATION_ACCURACY,20);
    MOTION_INACTIVE_TIMEOUT=mParser.getLong(KEY_MOTION_INACTIVE_TIMEOUT,!COMPRESS_TIME ? 10 * 60 * 1000L : 60 * 1000L);
    long idleAfterInactiveTimeout=(mHasWatch ? 15 : 30) * 60 * 1000L;
    IDLE_AFTER_INACTIVE_TIMEOUT=mParser.getLong(KEY_IDLE_AFTER_INACTIVE_TIMEOUT,!COMPRESS_TIME ? idleAfterInactiveTimeout : (idleAfterInactiveTimeout / 10));
    IDLE_PENDING_TIMEOUT=mParser.getLong(KEY_IDLE_PENDING_TIMEOUT,!COMPRESS_TIME ? 5 * 60 * 1000L : 30 * 1000L);
    MAX_IDLE_PENDING_TIMEOUT=mParser.getLong(KEY_MAX_IDLE_PENDING_TIMEOUT,!COMPRESS_TIME ? 10 * 60 * 1000L : 60 * 1000L);
    IDLE_PENDING_FACTOR=mParser.getFloat(KEY_IDLE_PENDING_FACTOR,2f);
    IDLE_TIMEOUT=mParser.getLong(KEY_IDLE_TIMEOUT,!COMPRESS_TIME ? 60 * 60 * 1000L : 6 * 60 * 1000L);
    MAX_IDLE_TIMEOUT=mParser.getLong(KEY_MAX_IDLE_TIMEOUT,!COMPRESS_TIME ? 6 * 60 * 60* 1000L : 30 * 60 * 1000L);
    IDLE_FACTOR=mParser.getFloat(KEY_IDLE_FACTOR,2f);
    MIN_TIME_TO_ALARM=mParser.getLong(KEY_MIN_TIME_TO_ALARM,!COMPRESS_TIME ? 60 * 60 * 1000L : 6 * 60 * 1000L);
    MAX_TEMP_APP_WHITELIST_DURATION=mParser.getLong(KEY_MAX_TEMP_APP_WHITELIST_DURATION,5 * 60 * 1000L);
    MMS_TEMP_APP_WHITELIST_DURATION=mParser.getLong(KEY_MMS_TEMP_APP_WHITELIST_DURATION,60 * 1000L);
    SMS_TEMP_APP_WHITELIST_DURATION=mParser.getLong(KEY_SMS_TEMP_APP_WHITELIST_DURATION,20 * 1000L);
  }
}",0.981234096692112
192328,"@Override public void onReceive(Context context,Intent intent){
  decActiveIdleOps();
}","@Override public void onReceive(Context context,Intent intent){
  if (PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED.equals(intent.getAction())) {
    mHandler.sendEmptyMessageDelayed(MSG_FINISH_IDLE_OP,mConstants.MIN_DEEP_MAINTENANCE_TIME);
  }
 else {
    mHandler.sendEmptyMessageDelayed(MSG_FINISH_IDLE_OP,mConstants.MIN_LIGHT_MAINTENANCE_TIME);
  }
}",0.3272727272727272
192329,"void exitMaintenanceEarlyIfNeededLocked(){
  if (mState == STATE_IDLE_MAINTENANCE || mLightState == LIGHT_STATE_IDLE_MAINTENANCE) {
    if (mActiveIdleOpCount <= 0 && mDownloadServiceActive == null && !mJobsActive && !mAlarmsActive) {
      final long now=SystemClock.elapsedRealtime();
      if (DEBUG) {
        StringBuilder sb=new StringBuilder();
        sb.append(""String_Node_Str"");
        TimeUtils.formatDuration(mMaintenanceStartTime,sb);
        sb.append(""String_Node_Str"");
        TimeUtils.formatDuration(now,sb);
        Slog.d(TAG,sb.toString());
      }
      if (mState == STATE_IDLE_MAINTENANCE) {
        if (now >= (mMaintenanceStartTime + mConstants.MIN_DEEP_MAINTENANCE_TIME)) {
          stepIdleStateLocked(""String_Node_Str"");
        }
      }
 else {
        if (now >= (mMaintenanceStartTime + mConstants.MIN_LIGHT_MAINTENANCE_TIME)) {
          stepLightIdleStateLocked(""String_Node_Str"");
        }
      }
    }
  }
}","void exitMaintenanceEarlyIfNeededLocked(){
  if (mState == STATE_IDLE_MAINTENANCE || mLightState == LIGHT_STATE_IDLE_MAINTENANCE || mLightState == LIGHT_STATE_PRE_IDLE) {
    if (isOpsInactiveLocked()) {
      final long now=SystemClock.elapsedRealtime();
      if (DEBUG) {
        StringBuilder sb=new StringBuilder();
        sb.append(""String_Node_Str"");
        TimeUtils.formatDuration(mMaintenanceStartTime,sb);
        sb.append(""String_Node_Str"");
        TimeUtils.formatDuration(now,sb);
        Slog.d(TAG,sb.toString());
      }
      if (mState == STATE_IDLE_MAINTENANCE) {
        stepIdleStateLocked(""String_Node_Str"");
      }
 else       if (mLightState == LIGHT_STATE_PRE_IDLE) {
        stepLightIdleStateLocked(""String_Node_Str"");
      }
 else {
        stepLightIdleStateLocked(""String_Node_Str"");
      }
    }
  }
}",0.770949720670391
192330,"void decActiveIdleOps(){
synchronized (this) {
    mActiveIdleOpCount--;
    if (mActiveIdleOpCount <= 0) {
      exitMaintenanceEarlyIfNeededLocked();
    }
  }
}","void decActiveIdleOps(){
synchronized (this) {
    mActiveIdleOpCount--;
    if (mActiveIdleOpCount <= 0) {
      exitMaintenanceEarlyIfNeededLocked();
      mActiveIdleWakeLock.release();
    }
  }
}",0.8980716253443526
192331,"private static String lightStateToString(int state){
switch (state) {
case LIGHT_STATE_ACTIVE:
    return ""String_Node_Str"";
case LIGHT_STATE_INACTIVE:
  return ""String_Node_Str"";
case LIGHT_STATE_IDLE:
return ""String_Node_Str"";
case LIGHT_STATE_IDLE_MAINTENANCE:
return ""String_Node_Str"";
case LIGHT_STATE_OVERRIDE:
return ""String_Node_Str"";
default :
return Integer.toString(state);
}
}","private static String lightStateToString(int state){
switch (state) {
case LIGHT_STATE_ACTIVE:
    return ""String_Node_Str"";
case LIGHT_STATE_INACTIVE:
  return ""String_Node_Str"";
case LIGHT_STATE_PRE_IDLE:
return ""String_Node_Str"";
case LIGHT_STATE_IDLE:
return ""String_Node_Str"";
case LIGHT_STATE_IDLE_MAINTENANCE:
return ""String_Node_Str"";
case LIGHT_STATE_OVERRIDE:
return ""String_Node_Str"";
default :
return Integer.toString(state);
}
}",0.9360675512665864
192332,"@Override public void onBootPhase(int phase){
  if (phase == PHASE_SYSTEM_SERVICES_READY) {
synchronized (this) {
      mAlarmManager=(AlarmManager)getContext().getSystemService(Context.ALARM_SERVICE);
      mBatteryStats=BatteryStatsService.getService();
      mLocalPowerManager=getLocalService(PowerManagerInternal.class);
      mLocalAlarmManager=getLocalService(AlarmManagerService.LocalService.class);
      mNetworkPolicyManager=INetworkPolicyManager.Stub.asInterface(ServiceManager.getService(Context.NETWORK_POLICY_SERVICE));
      mDisplayManager=(DisplayManager)getContext().getSystemService(Context.DISPLAY_SERVICE);
      mSensorManager=(SensorManager)getContext().getSystemService(Context.SENSOR_SERVICE);
      int sigMotionSensorId=getContext().getResources().getInteger(com.android.internal.R.integer.config_autoPowerModeAnyMotionSensor);
      if (sigMotionSensorId > 0) {
        mMotionSensor=mSensorManager.getDefaultSensor(sigMotionSensorId,true);
      }
      if (mMotionSensor == null && getContext().getResources().getBoolean(com.android.internal.R.bool.config_autoPowerModePreferWristTilt)) {
        mMotionSensor=mSensorManager.getDefaultSensor(Sensor.TYPE_WRIST_TILT_GESTURE,true);
      }
      if (mMotionSensor == null) {
        mMotionSensor=mSensorManager.getDefaultSensor(Sensor.TYPE_SIGNIFICANT_MOTION,true);
      }
      if (getContext().getResources().getBoolean(com.android.internal.R.bool.config_autoPowerModePrefetchLocation)) {
        mLocationManager=(LocationManager)getContext().getSystemService(Context.LOCATION_SERVICE);
        mLocationRequest=new LocationRequest().setQuality(LocationRequest.ACCURACY_FINE).setInterval(0).setFastestInterval(0).setNumUpdates(1);
      }
      float angleThreshold=getContext().getResources().getInteger(com.android.internal.R.integer.config_autoPowerModeThresholdAngle) / 100f;
      mAnyMotionDetector=new AnyMotionDetector((PowerManager)getContext().getSystemService(Context.POWER_SERVICE),mHandler,mSensorManager,this,angleThreshold);
      mIdleIntent=new Intent(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED);
      mIdleIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
      mLightIdleIntent=new Intent(PowerManager.ACTION_LIGHT_DEVICE_IDLE_MODE_CHANGED);
      mLightIdleIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
      IntentFilter filter=new IntentFilter();
      filter.addAction(Intent.ACTION_BATTERY_CHANGED);
      getContext().registerReceiver(mReceiver,filter);
      filter=new IntentFilter();
      filter.addAction(Intent.ACTION_PACKAGE_REMOVED);
      filter.addDataScheme(""String_Node_Str"");
      getContext().registerReceiver(mReceiver,filter);
      mLocalPowerManager.setDeviceIdleWhitelist(mPowerSaveWhitelistAllAppIdArray);
      mLocalAlarmManager.setDeviceIdleUserWhitelist(mPowerSaveWhitelistUserAppIdArray);
      mDisplayManager.registerDisplayListener(mDisplayListener,null);
      updateDisplayLocked();
    }
  }
}","@Override public void onBootPhase(int phase){
  if (phase == PHASE_SYSTEM_SERVICES_READY) {
synchronized (this) {
      mAlarmManager=(AlarmManager)getContext().getSystemService(Context.ALARM_SERVICE);
      mBatteryStats=BatteryStatsService.getService();
      mLocalPowerManager=getLocalService(PowerManagerInternal.class);
      mPowerManager=getContext().getSystemService(PowerManager.class);
      mActiveIdleWakeLock=mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,""String_Node_Str"");
      mActiveIdleWakeLock.setReferenceCounted(false);
      mLocalAlarmManager=getLocalService(AlarmManagerService.LocalService.class);
      mNetworkPolicyManager=INetworkPolicyManager.Stub.asInterface(ServiceManager.getService(Context.NETWORK_POLICY_SERVICE));
      mDisplayManager=(DisplayManager)getContext().getSystemService(Context.DISPLAY_SERVICE);
      mSensorManager=(SensorManager)getContext().getSystemService(Context.SENSOR_SERVICE);
      int sigMotionSensorId=getContext().getResources().getInteger(com.android.internal.R.integer.config_autoPowerModeAnyMotionSensor);
      if (sigMotionSensorId > 0) {
        mMotionSensor=mSensorManager.getDefaultSensor(sigMotionSensorId,true);
      }
      if (mMotionSensor == null && getContext().getResources().getBoolean(com.android.internal.R.bool.config_autoPowerModePreferWristTilt)) {
        mMotionSensor=mSensorManager.getDefaultSensor(Sensor.TYPE_WRIST_TILT_GESTURE,true);
      }
      if (mMotionSensor == null) {
        mMotionSensor=mSensorManager.getDefaultSensor(Sensor.TYPE_SIGNIFICANT_MOTION,true);
      }
      if (getContext().getResources().getBoolean(com.android.internal.R.bool.config_autoPowerModePrefetchLocation)) {
        mLocationManager=(LocationManager)getContext().getSystemService(Context.LOCATION_SERVICE);
        mLocationRequest=new LocationRequest().setQuality(LocationRequest.ACCURACY_FINE).setInterval(0).setFastestInterval(0).setNumUpdates(1);
      }
      float angleThreshold=getContext().getResources().getInteger(com.android.internal.R.integer.config_autoPowerModeThresholdAngle) / 100f;
      mAnyMotionDetector=new AnyMotionDetector((PowerManager)getContext().getSystemService(Context.POWER_SERVICE),mHandler,mSensorManager,this,angleThreshold);
      mIdleIntent=new Intent(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED);
      mIdleIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
      mLightIdleIntent=new Intent(PowerManager.ACTION_LIGHT_DEVICE_IDLE_MODE_CHANGED);
      mLightIdleIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
      IntentFilter filter=new IntentFilter();
      filter.addAction(Intent.ACTION_BATTERY_CHANGED);
      getContext().registerReceiver(mReceiver,filter);
      filter=new IntentFilter();
      filter.addAction(Intent.ACTION_PACKAGE_REMOVED);
      filter.addDataScheme(""String_Node_Str"");
      getContext().registerReceiver(mReceiver,filter);
      mLocalPowerManager.setDeviceIdleWhitelist(mPowerSaveWhitelistAllAppIdArray);
      mLocalAlarmManager.setDeviceIdleUserWhitelist(mPowerSaveWhitelistUserAppIdArray);
      mDisplayManager.registerDisplayListener(mDisplayListener,null);
      updateDisplayLocked();
    }
  }
}",0.9636247606892152
192333,"void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (getContext().checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  if (args != null) {
    int userId=UserHandle.USER_SYSTEM;
    for (int i=0; i < args.length; i++) {
      String arg=args[i];
      if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i < args.length) {
          arg=args[i];
          userId=Integer.parseInt(arg);
        }
      }
 else       if (""String_Node_Str"".equals(arg)) {
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        return;
      }
 else {
        Shell shell=new Shell();
        shell.userId=userId;
        String[] newArgs=new String[args.length - i];
        System.arraycopy(args,i,newArgs,0,args.length - i);
        shell.exec(mBinderService,null,fd,null,newArgs,new ResultReceiver(null));
        return;
      }
    }
  }
synchronized (this) {
    mConstants.dump(pw);
    if (mEventCmds[0] != EVENT_NULL) {
      pw.println(""String_Node_Str"");
      long now=SystemClock.elapsedRealtime();
      for (int i=EVENT_BUFFER_SIZE - 1; i >= 0; i--) {
        int cmd=mEventCmds[i];
        if (cmd == EVENT_NULL) {
          continue;
        }
        String label;
switch (mEventCmds[i]) {
case EVENT_NORMAL:
          label=""String_Node_Str"";
        break;
case EVENT_LIGHT_IDLE:
      label=""String_Node_Str"";
    break;
case EVENT_LIGHT_MAINTENANCE:
  label=""String_Node_Str"";
break;
case EVENT_DEEP_IDLE:
label=""String_Node_Str"";
break;
case EVENT_DEEP_MAINTENANCE:
label=""String_Node_Str"";
break;
default :
label=""String_Node_Str"";
break;
}
pw.print(""String_Node_Str"");
pw.print(label);
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mEventTimes[i],now,pw);
;
pw.println();
}
}
int size=mPowerSaveWhitelistAppsExceptIdle.size();
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.println(mPowerSaveWhitelistAppsExceptIdle.keyAt(i));
}
}
size=mPowerSaveWhitelistApps.size();
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.println(mPowerSaveWhitelistApps.keyAt(i));
}
}
size=mPowerSaveWhitelistUserApps.size();
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.println(mPowerSaveWhitelistUserApps.keyAt(i));
}
}
size=mPowerSaveWhitelistExceptIdleAppIds.size();
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.print(mPowerSaveWhitelistExceptIdleAppIds.keyAt(i));
pw.println();
}
}
size=mPowerSaveWhitelistUserAppIds.size();
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.print(mPowerSaveWhitelistUserAppIds.keyAt(i));
pw.println();
}
}
size=mPowerSaveWhitelistAllAppIds.size();
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.print(mPowerSaveWhitelistAllAppIds.keyAt(i));
pw.println();
}
}
size=mTempWhitelistAppIdEndTimes.size();
if (size > 0) {
pw.println(""String_Node_Str"");
final long timeNow=SystemClock.elapsedRealtime();
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.print(mTempWhitelistAppIdEndTimes.keyAt(i));
pw.print(""String_Node_Str"");
Pair<MutableLong,String> entry=mTempWhitelistAppIdEndTimes.valueAt(i);
TimeUtils.formatDuration(entry.first.value,timeNow,pw);
pw.print(""String_Node_Str"");
pw.println(entry.second);
}
}
size=mTempWhitelistAppIdArray != null ? mTempWhitelistAppIdArray.length : 0;
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.print(mTempWhitelistAppIdArray[i]);
pw.println();
}
}
pw.print(""String_Node_Str"");
pw.print(mLightEnabled);
pw.print(""String_Node_Str"");
pw.println(mDeepEnabled);
pw.print(""String_Node_Str"");
pw.println(mForceIdle);
pw.print(""String_Node_Str"");
pw.println(mMotionSensor);
pw.print(""String_Node_Str"");
pw.println(mCurDisplay);
pw.print(""String_Node_Str"");
pw.println(mScreenOn);
pw.print(""String_Node_Str"");
pw.println(mCharging);
pw.print(""String_Node_Str"");
pw.println(mMotionListener.active);
pw.print(""String_Node_Str"");
pw.println(mNotMoving);
pw.print(""String_Node_Str"");
pw.print(mLocating);
pw.print(""String_Node_Str"");
pw.print(mHasGps);
pw.print(""String_Node_Str"");
pw.print(mHasNetworkLocation);
pw.print(""String_Node_Str"");
pw.println(mLocated);
if (mLastGenericLocation != null) {
pw.print(""String_Node_Str"");
pw.println(mLastGenericLocation);
}
if (mLastGpsLocation != null) {
pw.print(""String_Node_Str"");
pw.println(mLastGpsLocation);
}
pw.print(""String_Node_Str"");
pw.print(stateToString(mState));
pw.print(""String_Node_Str"");
pw.println(lightStateToString(mLightState));
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mInactiveTimeout,pw);
pw.println();
if (mActiveIdleOpCount != 0) {
pw.print(""String_Node_Str"");
pw.println(mActiveIdleOpCount);
}
if (mNextAlarmTime != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mNextAlarmTime,SystemClock.elapsedRealtime(),pw);
pw.println();
}
if (mNextIdlePendingDelay != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mNextIdlePendingDelay,pw);
pw.println();
}
if (mNextIdleDelay != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mNextIdleDelay,pw);
pw.println();
}
if (mNextLightIdleDelay != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mNextLightIdleDelay,pw);
pw.println();
}
if (mNextLightAlarmTime != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mNextLightAlarmTime,SystemClock.elapsedRealtime(),pw);
pw.println();
}
if (mCurIdleBudget != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mCurIdleBudget,pw);
pw.println();
}
if (mMaintenanceStartTime != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mMaintenanceStartTime,SystemClock.elapsedRealtime(),pw);
pw.println();
}
if (mMaintenanceMinCheckScheduled) {
pw.print(""String_Node_Str"");
pw.println(mMaintenanceMinCheckScheduled);
}
if (mJobsActive) {
pw.print(""String_Node_Str"");
pw.println(mJobsActive);
}
if (mAlarmsActive) {
pw.print(""String_Node_Str"");
pw.println(mAlarmsActive);
}
if (mDownloadServiceActive != null) {
pw.print(""String_Node_Str"");
pw.println(mDownloadServiceActive);
}
}
}","void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (getContext().checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  if (args != null) {
    int userId=UserHandle.USER_SYSTEM;
    for (int i=0; i < args.length; i++) {
      String arg=args[i];
      if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i < args.length) {
          arg=args[i];
          userId=Integer.parseInt(arg);
        }
      }
 else       if (""String_Node_Str"".equals(arg)) {
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        return;
      }
 else {
        Shell shell=new Shell();
        shell.userId=userId;
        String[] newArgs=new String[args.length - i];
        System.arraycopy(args,i,newArgs,0,args.length - i);
        shell.exec(mBinderService,null,fd,null,newArgs,new ResultReceiver(null));
        return;
      }
    }
  }
synchronized (this) {
    mConstants.dump(pw);
    if (mEventCmds[0] != EVENT_NULL) {
      pw.println(""String_Node_Str"");
      long now=SystemClock.elapsedRealtime();
      for (int i=EVENT_BUFFER_SIZE - 1; i >= 0; i--) {
        int cmd=mEventCmds[i];
        if (cmd == EVENT_NULL) {
          continue;
        }
        String label;
switch (mEventCmds[i]) {
case EVENT_NORMAL:
          label=""String_Node_Str"";
        break;
case EVENT_LIGHT_IDLE:
      label=""String_Node_Str"";
    break;
case EVENT_LIGHT_MAINTENANCE:
  label=""String_Node_Str"";
break;
case EVENT_DEEP_IDLE:
label=""String_Node_Str"";
break;
case EVENT_DEEP_MAINTENANCE:
label=""String_Node_Str"";
break;
default :
label=""String_Node_Str"";
break;
}
pw.print(""String_Node_Str"");
pw.print(label);
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mEventTimes[i],now,pw);
;
pw.println();
}
}
int size=mPowerSaveWhitelistAppsExceptIdle.size();
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.println(mPowerSaveWhitelistAppsExceptIdle.keyAt(i));
}
}
size=mPowerSaveWhitelistApps.size();
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.println(mPowerSaveWhitelistApps.keyAt(i));
}
}
size=mPowerSaveWhitelistUserApps.size();
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.println(mPowerSaveWhitelistUserApps.keyAt(i));
}
}
size=mPowerSaveWhitelistExceptIdleAppIds.size();
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.print(mPowerSaveWhitelistExceptIdleAppIds.keyAt(i));
pw.println();
}
}
size=mPowerSaveWhitelistUserAppIds.size();
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.print(mPowerSaveWhitelistUserAppIds.keyAt(i));
pw.println();
}
}
size=mPowerSaveWhitelistAllAppIds.size();
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.print(mPowerSaveWhitelistAllAppIds.keyAt(i));
pw.println();
}
}
size=mTempWhitelistAppIdEndTimes.size();
if (size > 0) {
pw.println(""String_Node_Str"");
final long timeNow=SystemClock.elapsedRealtime();
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.print(mTempWhitelistAppIdEndTimes.keyAt(i));
pw.print(""String_Node_Str"");
Pair<MutableLong,String> entry=mTempWhitelistAppIdEndTimes.valueAt(i);
TimeUtils.formatDuration(entry.first.value,timeNow,pw);
pw.print(""String_Node_Str"");
pw.println(entry.second);
}
}
size=mTempWhitelistAppIdArray != null ? mTempWhitelistAppIdArray.length : 0;
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.print(mTempWhitelistAppIdArray[i]);
pw.println();
}
}
pw.print(""String_Node_Str"");
pw.print(mLightEnabled);
pw.print(""String_Node_Str"");
pw.println(mDeepEnabled);
pw.print(""String_Node_Str"");
pw.println(mForceIdle);
pw.print(""String_Node_Str"");
pw.println(mMotionSensor);
pw.print(""String_Node_Str"");
pw.println(mCurDisplay);
pw.print(""String_Node_Str"");
pw.println(mScreenOn);
pw.print(""String_Node_Str"");
pw.println(mCharging);
pw.print(""String_Node_Str"");
pw.println(mMotionListener.active);
pw.print(""String_Node_Str"");
pw.println(mNotMoving);
pw.print(""String_Node_Str"");
pw.print(mLocating);
pw.print(""String_Node_Str"");
pw.print(mHasGps);
pw.print(""String_Node_Str"");
pw.print(mHasNetworkLocation);
pw.print(""String_Node_Str"");
pw.println(mLocated);
if (mLastGenericLocation != null) {
pw.print(""String_Node_Str"");
pw.println(mLastGenericLocation);
}
if (mLastGpsLocation != null) {
pw.print(""String_Node_Str"");
pw.println(mLastGpsLocation);
}
pw.print(""String_Node_Str"");
pw.print(stateToString(mState));
pw.print(""String_Node_Str"");
pw.println(lightStateToString(mLightState));
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mInactiveTimeout,pw);
pw.println();
if (mActiveIdleOpCount != 0) {
pw.print(""String_Node_Str"");
pw.println(mActiveIdleOpCount);
}
if (mNextAlarmTime != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mNextAlarmTime,SystemClock.elapsedRealtime(),pw);
pw.println();
}
if (mNextIdlePendingDelay != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mNextIdlePendingDelay,pw);
pw.println();
}
if (mNextIdleDelay != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mNextIdleDelay,pw);
pw.println();
}
if (mNextLightIdleDelay != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mNextLightIdleDelay,pw);
pw.println();
}
if (mNextLightAlarmTime != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mNextLightAlarmTime,SystemClock.elapsedRealtime(),pw);
pw.println();
}
if (mCurIdleBudget != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mCurIdleBudget,pw);
pw.println();
}
if (mMaintenanceStartTime != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mMaintenanceStartTime,SystemClock.elapsedRealtime(),pw);
pw.println();
}
if (mJobsActive) {
pw.print(""String_Node_Str"");
pw.println(mJobsActive);
}
if (mAlarmsActive) {
pw.print(""String_Node_Str"");
pw.println(mAlarmsActive);
}
if (mDownloadServiceActive != null) {
pw.print(""String_Node_Str"");
pw.println(mDownloadServiceActive);
}
}
}",0.9915518684831418
192334,"@Override public void handleMessage(Message msg){
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + msg.what + ""String_Node_Str"");
switch (msg.what) {
case MSG_WRITE_CONFIG:
{
      handleWriteConfigFile();
    }
  break;
case MSG_REPORT_IDLE_ON:
case MSG_REPORT_IDLE_ON_LIGHT:
{
  EventLogTags.writeDeviceIdleOnStart();
  final boolean deepChanged;
  final boolean lightChanged;
  if (msg.what == MSG_REPORT_IDLE_ON) {
    deepChanged=mLocalPowerManager.setDeviceIdleMode(true);
    lightChanged=mLocalPowerManager.setLightDeviceIdleMode(false);
  }
 else {
    deepChanged=mLocalPowerManager.setDeviceIdleMode(false);
    lightChanged=mLocalPowerManager.setLightDeviceIdleMode(true);
  }
  try {
    mNetworkPolicyManager.setDeviceIdleMode(true);
    mBatteryStats.noteDeviceIdleMode(msg.what == MSG_REPORT_IDLE_ON ? BatteryStats.DEVICE_IDLE_MODE_DEEP : BatteryStats.DEVICE_IDLE_MODE_LIGHT,null,Process.myUid());
  }
 catch (  RemoteException e) {
  }
  if (deepChanged) {
    getContext().sendBroadcastAsUser(mIdleIntent,UserHandle.ALL);
  }
  if (lightChanged) {
    getContext().sendBroadcastAsUser(mLightIdleIntent,UserHandle.ALL);
  }
  EventLogTags.writeDeviceIdleOnComplete();
}
break;
case MSG_REPORT_IDLE_OFF:
{
EventLogTags.writeDeviceIdleOffStart(""String_Node_Str"");
final boolean deepChanged=mLocalPowerManager.setDeviceIdleMode(false);
final boolean lightChanged=mLocalPowerManager.setLightDeviceIdleMode(false);
try {
mNetworkPolicyManager.setDeviceIdleMode(false);
mBatteryStats.noteDeviceIdleMode(BatteryStats.DEVICE_IDLE_MODE_OFF,null,Process.myUid());
}
 catch (RemoteException e) {
}
if (deepChanged) {
incActiveIdleOps();
getContext().sendOrderedBroadcastAsUser(mIdleIntent,UserHandle.ALL,null,mIdleStartedDoneReceiver,null,0,null,null);
}
if (lightChanged) {
incActiveIdleOps();
getContext().sendOrderedBroadcastAsUser(mLightIdleIntent,UserHandle.ALL,null,mIdleStartedDoneReceiver,null,0,null,null);
}
decActiveIdleOps();
EventLogTags.writeDeviceIdleOffComplete();
}
break;
case MSG_REPORT_ACTIVE:
{
String activeReason=(String)msg.obj;
int activeUid=msg.arg1;
EventLogTags.writeDeviceIdleOffStart(activeReason != null ? activeReason : ""String_Node_Str"");
final boolean deepChanged=mLocalPowerManager.setDeviceIdleMode(false);
final boolean lightChanged=mLocalPowerManager.setLightDeviceIdleMode(false);
try {
mNetworkPolicyManager.setDeviceIdleMode(false);
mBatteryStats.noteDeviceIdleMode(BatteryStats.DEVICE_IDLE_MODE_OFF,activeReason,activeUid);
}
 catch (RemoteException e) {
}
if (deepChanged) {
getContext().sendBroadcastAsUser(mIdleIntent,UserHandle.ALL);
}
if (lightChanged) {
getContext().sendBroadcastAsUser(mLightIdleIntent,UserHandle.ALL);
}
EventLogTags.writeDeviceIdleOffComplete();
}
break;
case MSG_TEMP_APP_WHITELIST_TIMEOUT:
{
int uid=msg.arg1;
checkTempAppWhitelistTimeout(uid);
}
break;
case MSG_REPORT_MAINTENANCE_ACTIVITY:
{
boolean active=(msg.arg1 == 1);
final int size=mMaintenanceActivityListeners.beginBroadcast();
try {
for (int i=0; i < size; i++) {
try {
mMaintenanceActivityListeners.getBroadcastItem(i).onMaintenanceActivityChanged(active);
}
 catch (RemoteException ignored) {
}
}
}
  finally {
mMaintenanceActivityListeners.finishBroadcast();
}
}
break;
}
}","@Override public void handleMessage(Message msg){
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + msg.what + ""String_Node_Str"");
switch (msg.what) {
case MSG_WRITE_CONFIG:
{
      handleWriteConfigFile();
    }
  break;
case MSG_REPORT_IDLE_ON:
case MSG_REPORT_IDLE_ON_LIGHT:
{
  EventLogTags.writeDeviceIdleOnStart();
  final boolean deepChanged;
  final boolean lightChanged;
  if (msg.what == MSG_REPORT_IDLE_ON) {
    deepChanged=mLocalPowerManager.setDeviceIdleMode(true);
    lightChanged=mLocalPowerManager.setLightDeviceIdleMode(false);
  }
 else {
    deepChanged=mLocalPowerManager.setDeviceIdleMode(false);
    lightChanged=mLocalPowerManager.setLightDeviceIdleMode(true);
  }
  try {
    mNetworkPolicyManager.setDeviceIdleMode(true);
    mBatteryStats.noteDeviceIdleMode(msg.what == MSG_REPORT_IDLE_ON ? BatteryStats.DEVICE_IDLE_MODE_DEEP : BatteryStats.DEVICE_IDLE_MODE_LIGHT,null,Process.myUid());
  }
 catch (  RemoteException e) {
  }
  if (deepChanged) {
    getContext().sendBroadcastAsUser(mIdleIntent,UserHandle.ALL);
  }
  if (lightChanged) {
    getContext().sendBroadcastAsUser(mLightIdleIntent,UserHandle.ALL);
  }
  EventLogTags.writeDeviceIdleOnComplete();
}
break;
case MSG_REPORT_IDLE_OFF:
{
EventLogTags.writeDeviceIdleOffStart(""String_Node_Str"");
final boolean deepChanged=mLocalPowerManager.setDeviceIdleMode(false);
final boolean lightChanged=mLocalPowerManager.setLightDeviceIdleMode(false);
try {
mNetworkPolicyManager.setDeviceIdleMode(false);
mBatteryStats.noteDeviceIdleMode(BatteryStats.DEVICE_IDLE_MODE_OFF,null,Process.myUid());
}
 catch (RemoteException e) {
}
if (deepChanged) {
incActiveIdleOps();
getContext().sendOrderedBroadcastAsUser(mIdleIntent,UserHandle.ALL,null,mIdleStartedDoneReceiver,null,0,null,null);
}
if (lightChanged) {
incActiveIdleOps();
getContext().sendOrderedBroadcastAsUser(mLightIdleIntent,UserHandle.ALL,null,mIdleStartedDoneReceiver,null,0,null,null);
}
decActiveIdleOps();
EventLogTags.writeDeviceIdleOffComplete();
}
break;
case MSG_REPORT_ACTIVE:
{
String activeReason=(String)msg.obj;
int activeUid=msg.arg1;
EventLogTags.writeDeviceIdleOffStart(activeReason != null ? activeReason : ""String_Node_Str"");
final boolean deepChanged=mLocalPowerManager.setDeviceIdleMode(false);
final boolean lightChanged=mLocalPowerManager.setLightDeviceIdleMode(false);
try {
mNetworkPolicyManager.setDeviceIdleMode(false);
mBatteryStats.noteDeviceIdleMode(BatteryStats.DEVICE_IDLE_MODE_OFF,activeReason,activeUid);
}
 catch (RemoteException e) {
}
if (deepChanged) {
getContext().sendBroadcastAsUser(mIdleIntent,UserHandle.ALL);
}
if (lightChanged) {
getContext().sendBroadcastAsUser(mLightIdleIntent,UserHandle.ALL);
}
EventLogTags.writeDeviceIdleOffComplete();
}
break;
case MSG_TEMP_APP_WHITELIST_TIMEOUT:
{
int uid=msg.arg1;
checkTempAppWhitelistTimeout(uid);
}
break;
case MSG_REPORT_MAINTENANCE_ACTIVITY:
{
boolean active=(msg.arg1 == 1);
final int size=mMaintenanceActivityListeners.beginBroadcast();
try {
for (int i=0; i < size; i++) {
try {
mMaintenanceActivityListeners.getBroadcastItem(i).onMaintenanceActivityChanged(active);
}
 catch (RemoteException ignored) {
}
}
}
  finally {
mMaintenanceActivityListeners.finishBroadcast();
}
}
break;
case MSG_FINISH_IDLE_OP:
{
decActiveIdleOps();
}
break;
}
}",0.9913553565915406
192335,"@Override public void onAlarm(){
synchronized (DeviceIdleController.this) {
    exitMaintenanceEarlyIfNeededLocked();
  }
}","@Override public void onAlarm(){
synchronized (DeviceIdleController.this) {
    stepIdleStateLocked(""String_Node_Str"");
  }
}",0.7983870967741935
192336,"/** 
 * Checks the two objects for equality by delegating to their respective  {@link Object#equals(Object)} methods.
 * @param o the {@link Pair} to which this one is to be checked for equality
 * @return true if the underlying objects of the Pair are both consideredequal
 */
@Override public boolean equals(Object o){
  if (!(o instanceof Pair)) {
    return false;
  }
  Pair<?,?> p=(Pair<?,?>)o;
  return Objects.equal(p.first,first) && Objects.equal(p.second,second);
}","/** 
 * Checks the two objects for equality by delegating to their respective  {@link Object#equals(Object)} methods.
 * @param o the {@link Pair} to which this one is to be checked for equality
 * @return true if the underlying objects of the Pair are both consideredequal
 */
@Override public boolean equals(Object o){
  if (!(o instanceof Pair)) {
    return false;
  }
  Pair<?,?> p=(Pair<?,?>)o;
  return Objects.equals(p.first,first) && Objects.equals(p.second,second);
}",0.9978991596638656
192337,"@Override protected Void doInBackground(Void... params){
  final long start=SystemClock.elapsedRealtime();
  if (mFilterPackage != null) {
    if (!waitForFirstLoad()) {
      return null;
    }
  }
  mTaskRoots.put(mRecentsRoot.authority,mRecentsRoot);
  final ContentResolver resolver=mContext.getContentResolver();
  final PackageManager pm=mContext.getPackageManager();
  final Intent intent=new Intent(DocumentsContract.PROVIDER_INTERFACE);
  final List<ResolveInfo> providers=pm.queryIntentContentProviders(intent,0);
  for (  ResolveInfo info : providers) {
    handleDocumentsProvider(info.providerInfo);
  }
  final long delta=SystemClock.elapsedRealtime() - start;
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + mTaskRoots.size() + ""String_Node_Str""+ delta+ ""String_Node_Str"");
synchronized (mLock) {
    mFirstLoadDone=true;
    if (mBootCompletedResult != null) {
      mBootCompletedResult.finish();
      mBootCompletedResult=null;
    }
    mRoots=mTaskRoots;
    mStoppedAuthorities=mTaskStoppedAuthorities;
  }
  mFirstLoad.countDown();
  resolver.notifyChange(sNotificationUri,null,false);
  return null;
}","@Override protected Void doInBackground(Void... params){
  final long start=SystemClock.elapsedRealtime();
  if (mForceRefreshPackage != null) {
    if (!waitForFirstLoad()) {
      return null;
    }
  }
  mTaskRoots.put(mRecentsRoot.authority,mRecentsRoot);
  final ContentResolver resolver=mContext.getContentResolver();
  final PackageManager pm=mContext.getPackageManager();
  final Intent intent=new Intent(DocumentsContract.PROVIDER_INTERFACE);
  final List<ResolveInfo> providers=pm.queryIntentContentProviders(intent,0);
  for (  ResolveInfo info : providers) {
    handleDocumentsProvider(info.providerInfo);
  }
  final long delta=SystemClock.elapsedRealtime() - start;
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + mTaskRoots.size() + ""String_Node_Str""+ delta+ ""String_Node_Str"");
synchronized (mLock) {
    mFirstLoadDone=true;
    if (mBootCompletedResult != null) {
      mBootCompletedResult.finish();
      mBootCompletedResult=null;
    }
    mRoots=mTaskRoots;
    mStoppedAuthorities=mTaskStoppedAuthorities;
  }
  mFirstLoad.countDown();
  resolver.notifyChange(sNotificationUri,null,false);
  return null;
}",0.9928888888888888
192338,"/** 
 * Bring up requested provider and query for all active roots.
 */
private Collection<RootInfo> loadRootsForAuthority(ContentResolver resolver,String authority){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + authority);
synchronized (mObservedAuthorities) {
    if (mObservedAuthorities.add(authority)) {
      final Uri rootsUri=DocumentsContract.buildRootsUri(authority);
      mContext.getContentResolver().registerContentObserver(rootsUri,true,mObserver);
    }
  }
  final Uri rootsUri=DocumentsContract.buildRootsUri(authority);
  if (ENABLE_SYSTEM_CACHE) {
    final Bundle systemCache=resolver.getCache(rootsUri);
    if (systemCache != null) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + authority);
      return systemCache.getParcelableArrayList(TAG);
    }
  }
  final ArrayList<RootInfo> roots=new ArrayList<>();
  ContentProviderClient client=null;
  Cursor cursor=null;
  try {
    client=DocumentsApplication.acquireUnstableProviderOrThrow(resolver,authority);
    cursor=client.query(rootsUri,null,null,null,null);
    while (cursor.moveToNext()) {
      final RootInfo root=RootInfo.fromRootsCursor(authority,cursor);
      roots.add(root);
    }
  }
 catch (  Exception e) {
    Log.w(TAG,""String_Node_Str"" + authority + ""String_Node_Str""+ e);
  }
 finally {
    IoUtils.closeQuietly(cursor);
    ContentProviderClient.releaseQuietly(client);
  }
  if (ENABLE_SYSTEM_CACHE) {
    final Bundle systemCache=new Bundle();
    systemCache.putParcelableArrayList(TAG,roots);
    resolver.putCache(rootsUri,systemCache);
  }
  return roots;
}","/** 
 * Bring up requested provider and query for all active roots.
 */
private Collection<RootInfo> loadRootsForAuthority(ContentResolver resolver,String authority,boolean forceRefresh){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + authority);
synchronized (mObservedAuthorities) {
    if (mObservedAuthorities.add(authority)) {
      final Uri rootsUri=DocumentsContract.buildRootsUri(authority);
      mContext.getContentResolver().registerContentObserver(rootsUri,true,mObserver);
    }
  }
  final Uri rootsUri=DocumentsContract.buildRootsUri(authority);
  if (!forceRefresh) {
    final Bundle systemCache=resolver.getCache(rootsUri);
    if (systemCache != null) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + authority);
      return systemCache.getParcelableArrayList(TAG);
    }
  }
  final ArrayList<RootInfo> roots=new ArrayList<>();
  ContentProviderClient client=null;
  Cursor cursor=null;
  try {
    client=DocumentsApplication.acquireUnstableProviderOrThrow(resolver,authority);
    cursor=client.query(rootsUri,null,null,null,null);
    while (cursor.moveToNext()) {
      final RootInfo root=RootInfo.fromRootsCursor(authority,cursor);
      roots.add(root);
    }
  }
 catch (  Exception e) {
    Log.w(TAG,""String_Node_Str"" + authority + ""String_Node_Str""+ e);
  }
 finally {
    IoUtils.closeQuietly(cursor);
    ContentProviderClient.releaseQuietly(client);
  }
  final Bundle systemCache=new Bundle();
  systemCache.putParcelableArrayList(TAG,roots);
  resolver.putCache(rootsUri,systemCache);
  return roots;
}",0.941516709511568
192339,"/** 
 * Only update roots belonging to given package name. Other roots will be copied from cached   {@link #mRoots} values.
 */
public UpdateTask(String filterPackage){
  mFilterPackage=filterPackage;
}","/** 
 * Force update roots belonging to given package name. Other roots will be copied from cached   {@link #mRoots} values.
 */
public UpdateTask(String forceRefreshPackage){
  mForceRefreshPackage=forceRefreshPackage;
}",0.8652482269503546
192340,"/** 
 * Return the requested   {@link RootInfo}, but only loading the roots for the requested authority. This is useful when we want to load fast without waiting for all the other roots to come back.
 */
public RootInfo getRootOneshot(String authority,String rootId){
synchronized (mLock) {
    RootInfo root=getRootLocked(authority,rootId);
    if (root == null) {
      mRoots.putAll(authority,loadRootsForAuthority(mContext.getContentResolver(),authority));
      root=getRootLocked(authority,rootId);
    }
    return root;
  }
}","/** 
 * Return the requested   {@link RootInfo}, but only loading the roots for the requested authority. This is useful when we want to load fast without waiting for all the other roots to come back.
 */
public RootInfo getRootOneshot(String authority,String rootId){
synchronized (mLock) {
    RootInfo root=getRootLocked(authority,rootId);
    if (root == null) {
      mRoots.putAll(authority,loadRootsForAuthority(mContext.getContentResolver(),authority,false));
      root=getRootLocked(authority,rootId);
    }
    return root;
  }
}",0.9944029850746268
192341,"/** 
 * Load roots from authorities that are in stopped state. Normal  {@link UpdateTask} passes ignore stopped applications.
 */
private void loadStoppedAuthorities(){
  final ContentResolver resolver=mContext.getContentResolver();
synchronized (mLock) {
    for (    String authority : mStoppedAuthorities) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + authority);
      mRoots.putAll(authority,loadRootsForAuthority(resolver,authority));
    }
    mStoppedAuthorities.clear();
  }
}","/** 
 * Load roots from authorities that are in stopped state. Normal  {@link UpdateTask} passes ignore stopped applications.
 */
private void loadStoppedAuthorities(){
  final ContentResolver resolver=mContext.getContentResolver();
synchronized (mLock) {
    for (    String authority : mStoppedAuthorities) {
      if (DEBUG)       Log.d(TAG,""String_Node_Str"" + authority);
      mRoots.putAll(authority,loadRootsForAuthority(resolver,authority,true));
    }
    mStoppedAuthorities.clear();
  }
}",0.9949647532729105
192342,"private void handleDocumentsProvider(ProviderInfo info){
  if ((info.applicationInfo.flags & ApplicationInfo.FLAG_STOPPED) != 0) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + info.authority);
    mTaskStoppedAuthorities.add(info.authority);
    return;
  }
  boolean cacheHit=false;
  if (mFilterPackage != null && !mFilterPackage.equals(info.packageName)) {
synchronized (mLock) {
      if (mTaskRoots.putAll(info.authority,mRoots.get(info.authority))) {
        if (DEBUG)         Log.d(TAG,""String_Node_Str"" + info.authority);
        cacheHit=true;
      }
    }
  }
  if (!cacheHit) {
    mTaskRoots.putAll(info.authority,loadRootsForAuthority(mContext.getContentResolver(),info.authority));
  }
}","private void handleDocumentsProvider(ProviderInfo info){
  if ((info.applicationInfo.flags & ApplicationInfo.FLAG_STOPPED) != 0) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + info.authority);
    mTaskStoppedAuthorities.add(info.authority);
    return;
  }
  final boolean forceRefresh=Objects.equals(mForceRefreshPackage,info.packageName);
  mTaskRoots.putAll(info.authority,loadRootsForAuthority(mContext.getContentResolver(),info.authority,forceRefresh));
}",0.5784982935153583
192343,"/** 
 * Load roots from a stopped authority. Normal   {@link UpdateTask} passesignore stopped applications.
 */
private void loadStoppedAuthority(String authority){
  final ContentResolver resolver=mContext.getContentResolver();
synchronized (mLock) {
    if (!mStoppedAuthorities.contains(authority)) {
      return;
    }
    if (DEBUG) {
      Log.d(TAG,""String_Node_Str"" + authority);
    }
    mRoots.putAll(authority,loadRootsForAuthority(resolver,authority));
    mStoppedAuthorities.remove(authority);
  }
}","/** 
 * Load roots from a stopped authority. Normal   {@link UpdateTask} passesignore stopped applications.
 */
private void loadStoppedAuthority(String authority){
  final ContentResolver resolver=mContext.getContentResolver();
synchronized (mLock) {
    if (!mStoppedAuthorities.contains(authority)) {
      return;
    }
    if (DEBUG) {
      Log.d(TAG,""String_Node_Str"" + authority);
    }
    mRoots.putAll(authority,loadRootsForAuthority(resolver,authority,true));
    mStoppedAuthorities.remove(authority);
  }
}",0.9951690821256038
192344,"private void onDiskScannedLocked(DiskInfo disk){
  int volumeCount=0;
  for (int i=0; i < mVolumes.size(); i++) {
    final VolumeInfo vol=mVolumes.valueAt(i);
    if (Objects.equals(disk.id,vol.getDiskId())) {
      volumeCount++;
    }
  }
  final Intent intent=new Intent(DiskInfo.ACTION_DISK_SCANNED);
  intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
  intent.putExtra(DiskInfo.EXTRA_DISK_ID,disk.id);
  intent.putExtra(DiskInfo.EXTRA_VOLUME_COUNT,volumeCount);
  mHandler.obtainMessage(H_INTERNAL_BROADCAST,intent).sendToTarget();
  final CountDownLatch latch=mDiskScanLatches.remove(disk.id);
  if (latch != null) {
    latch.countDown();
  }
  disk.volumeCount=volumeCount;
  mCallbacks.notifyDiskScanned(disk,volumeCount);
}","private void onDiskScannedLocked(DiskInfo disk){
  int volumeCount=0;
  for (int i=0; i < mVolumes.size(); i++) {
    final VolumeInfo vol=mVolumes.valueAt(i);
    if (Objects.equals(disk.id,vol.getDiskId())) {
      volumeCount++;
    }
  }
  final Intent intent=new Intent(DiskInfo.ACTION_DISK_SCANNED);
  intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);
  intent.putExtra(DiskInfo.EXTRA_DISK_ID,disk.id);
  intent.putExtra(DiskInfo.EXTRA_VOLUME_COUNT,volumeCount);
  mHandler.obtainMessage(H_INTERNAL_BROADCAST,intent).sendToTarget();
  final CountDownLatch latch=mDiskScanLatches.remove(disk.id);
  if (latch != null) {
    latch.countDown();
  }
  disk.volumeCount=volumeCount;
  mCallbacks.notifyDiskScanned(disk,volumeCount);
}",0.9728331177231564
192345,"private void onVolumeStateChangedLocked(VolumeInfo vol,int oldState,int newState){
  if (vol.isMountedReadable() && !TextUtils.isEmpty(vol.fsUuid)) {
    VolumeRecord rec=mRecords.get(vol.fsUuid);
    if (rec == null) {
      rec=new VolumeRecord(vol.type,vol.fsUuid);
      rec.partGuid=vol.partGuid;
      rec.createdMillis=System.currentTimeMillis();
      if (vol.type == VolumeInfo.TYPE_PRIVATE) {
        rec.nickname=vol.disk.getDescription();
      }
      mRecords.put(rec.fsUuid,rec);
      writeSettingsLocked();
    }
 else {
      if (TextUtils.isEmpty(rec.partGuid)) {
        rec.partGuid=vol.partGuid;
        writeSettingsLocked();
      }
    }
  }
  mCallbacks.notifyVolumeStateChanged(vol,oldState,newState);
  if (mBootCompleted && isBroadcastWorthy(vol)) {
    final Intent intent=new Intent(VolumeInfo.ACTION_VOLUME_STATE_CHANGED);
    intent.putExtra(VolumeInfo.EXTRA_VOLUME_ID,vol.id);
    intent.putExtra(VolumeInfo.EXTRA_VOLUME_STATE,newState);
    intent.putExtra(VolumeRecord.EXTRA_FS_UUID,vol.fsUuid);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    mHandler.obtainMessage(H_INTERNAL_BROADCAST,intent).sendToTarget();
  }
  final String oldStateEnv=VolumeInfo.getEnvironmentForState(oldState);
  final String newStateEnv=VolumeInfo.getEnvironmentForState(newState);
  if (!Objects.equals(oldStateEnv,newStateEnv)) {
    for (    int userId : mSystemUnlockedUsers) {
      if (vol.isVisibleForRead(userId)) {
        final StorageVolume userVol=vol.buildStorageVolume(mContext,userId,false);
        mHandler.obtainMessage(H_VOLUME_BROADCAST,userVol).sendToTarget();
        mCallbacks.notifyStorageStateChanged(userVol.getPath(),oldStateEnv,newStateEnv);
      }
    }
  }
  if (vol.type == VolumeInfo.TYPE_PUBLIC && vol.state == VolumeInfo.STATE_EJECTING) {
    mObbActionHandler.sendMessage(mObbActionHandler.obtainMessage(OBB_FLUSH_MOUNT_STATE,vol.path));
  }
}","private void onVolumeStateChangedLocked(VolumeInfo vol,int oldState,int newState){
  if (vol.isMountedReadable() && !TextUtils.isEmpty(vol.fsUuid)) {
    VolumeRecord rec=mRecords.get(vol.fsUuid);
    if (rec == null) {
      rec=new VolumeRecord(vol.type,vol.fsUuid);
      rec.partGuid=vol.partGuid;
      rec.createdMillis=System.currentTimeMillis();
      if (vol.type == VolumeInfo.TYPE_PRIVATE) {
        rec.nickname=vol.disk.getDescription();
      }
      mRecords.put(rec.fsUuid,rec);
      writeSettingsLocked();
    }
 else {
      if (TextUtils.isEmpty(rec.partGuid)) {
        rec.partGuid=vol.partGuid;
        writeSettingsLocked();
      }
    }
  }
  mCallbacks.notifyVolumeStateChanged(vol,oldState,newState);
  if (mBootCompleted && isBroadcastWorthy(vol)) {
    final Intent intent=new Intent(VolumeInfo.ACTION_VOLUME_STATE_CHANGED);
    intent.putExtra(VolumeInfo.EXTRA_VOLUME_ID,vol.id);
    intent.putExtra(VolumeInfo.EXTRA_VOLUME_STATE,newState);
    intent.putExtra(VolumeRecord.EXTRA_FS_UUID,vol.fsUuid);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT | Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);
    mHandler.obtainMessage(H_INTERNAL_BROADCAST,intent).sendToTarget();
  }
  final String oldStateEnv=VolumeInfo.getEnvironmentForState(oldState);
  final String newStateEnv=VolumeInfo.getEnvironmentForState(newState);
  if (!Objects.equals(oldStateEnv,newStateEnv)) {
    for (    int userId : mSystemUnlockedUsers) {
      if (vol.isVisibleForRead(userId)) {
        final StorageVolume userVol=vol.buildStorageVolume(mContext,userId,false);
        mHandler.obtainMessage(H_VOLUME_BROADCAST,userVol).sendToTarget();
        mCallbacks.notifyStorageStateChanged(userVol.getPath(),oldStateEnv,newStateEnv);
      }
    }
  }
  if (vol.type == VolumeInfo.TYPE_PUBLIC && vol.state == VolumeInfo.STATE_EJECTING) {
    mObbActionHandler.sendMessage(mObbActionHandler.obtainMessage(OBB_FLUSH_MOUNT_STATE,vol.path));
  }
}",0.9891864057672504
192346,"private void invalidateCacheLocked(int userId,String providerPackageName,Uri uri){
  ArrayMap<String,ArrayMap<Pair<String,Uri>,Bundle>> userCache=mCache.get(userId);
  if (userCache == null)   return;
  ArrayMap<Pair<String,Uri>,Bundle> packageCache=userCache.get(providerPackageName);
  if (packageCache == null)   return;
  if (uri != null) {
    for (int i=0; i < packageCache.size(); ) {
      final Uri key=packageCache.keyAt(i).second;
      if (Objects.equals(key,uri)) {
        packageCache.removeAt(i);
      }
 else {
        i++;
      }
    }
  }
 else {
    packageCache.clear();
  }
}","private void invalidateCacheLocked(int userId,String providerPackageName,Uri uri){
  ArrayMap<String,ArrayMap<Pair<String,Uri>,Bundle>> userCache=mCache.get(userId);
  if (userCache == null)   return;
  ArrayMap<Pair<String,Uri>,Bundle> packageCache=userCache.get(providerPackageName);
  if (packageCache == null)   return;
  if (uri != null) {
    for (int i=0; i < packageCache.size(); ) {
      final Pair<String,Uri> key=packageCache.keyAt(i);
      if (key.second != null && key.second.toString().startsWith(uri.toString())) {
        Slog.d(TAG,""String_Node_Str"" + key);
        packageCache.removeAt(i);
      }
 else {
        i++;
      }
    }
  }
 else {
    Slog.d(TAG,""String_Node_Str"" + providerPackageName);
    packageCache.clear();
  }
}",0.8470066518847007
192347,"void becomeActiveLocked(String activeReason,int activeUid){
  if (DEBUG)   Slog.i(TAG,""String_Node_Str"" + activeReason);
  if (mState != STATE_ACTIVE || mLightState != STATE_ACTIVE) {
    EventLogTags.writeDeviceIdle(STATE_ACTIVE,activeReason);
    EventLogTags.writeDeviceIdleLight(LIGHT_STATE_ACTIVE,activeReason);
    scheduleReportActiveLocked(activeReason,activeUid);
    mState=STATE_ACTIVE;
    mLightState=LIGHT_STATE_ACTIVE;
    mInactiveTimeout=mConstants.INACTIVE_TIMEOUT;
    mCurIdleBudget=0;
    mMaintenanceStartTime=0;
    if (mMaintenanceMinCheckScheduled) {
      mAlarmManager.cancel(mMaintenanceMinCheckListener);
      mMaintenanceMinCheckScheduled=false;
    }
    resetIdleManagementLocked();
    resetLightIdleManagementLocked();
    addEvent(EVENT_NORMAL);
  }
}","void becomeActiveLocked(String activeReason,int activeUid){
  if (DEBUG)   Slog.i(TAG,""String_Node_Str"" + activeReason);
  if (mState != STATE_ACTIVE || mLightState != STATE_ACTIVE) {
    EventLogTags.writeDeviceIdle(STATE_ACTIVE,activeReason);
    EventLogTags.writeDeviceIdleLight(LIGHT_STATE_ACTIVE,activeReason);
    scheduleReportActiveLocked(activeReason,activeUid);
    mState=STATE_ACTIVE;
    mLightState=LIGHT_STATE_ACTIVE;
    mInactiveTimeout=mConstants.INACTIVE_TIMEOUT;
    mCurIdleBudget=0;
    mMaintenanceStartTime=0;
    resetIdleManagementLocked();
    resetLightIdleManagementLocked();
    addEvent(EVENT_NORMAL);
  }
}",0.8962131837307152
192348,"void stepIdleStateLocked(String reason){
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + mState);
  EventLogTags.writeDeviceIdleStep();
  final long now=SystemClock.elapsedRealtime();
  if ((now + mConstants.MIN_TIME_TO_ALARM) > mAlarmManager.getNextWakeFromIdleTime()) {
    if (mState != STATE_ACTIVE) {
      becomeActiveLocked(""String_Node_Str"",Process.myUid());
      becomeInactiveIfAppropriateLocked();
    }
    return;
  }
switch (mState) {
case STATE_INACTIVE:
    startMonitoringMotionLocked();
  scheduleAlarmLocked(mConstants.IDLE_AFTER_INACTIVE_TIMEOUT,false);
mNextIdlePendingDelay=mConstants.IDLE_PENDING_TIMEOUT;
mNextIdleDelay=mConstants.IDLE_TIMEOUT;
mState=STATE_IDLE_PENDING;
if (DEBUG) Slog.d(TAG,""String_Node_Str"");
EventLogTags.writeDeviceIdle(mState,reason);
break;
case STATE_IDLE_PENDING:
mState=STATE_SENSING;
if (DEBUG) Slog.d(TAG,""String_Node_Str"");
EventLogTags.writeDeviceIdle(mState,reason);
scheduleAlarmLocked(mConstants.SENSING_TIMEOUT,false);
cancelLocatingLocked();
mAnyMotionDetector.checkForAnyMotion();
mNotMoving=false;
mLocated=false;
mLastGenericLocation=null;
mLastGpsLocation=null;
break;
case STATE_SENSING:
mState=STATE_LOCATING;
if (DEBUG) Slog.d(TAG,""String_Node_Str"");
EventLogTags.writeDeviceIdle(mState,reason);
scheduleAlarmLocked(mConstants.LOCATING_TIMEOUT,false);
if (mLocationManager != null && mLocationManager.getProvider(LocationManager.NETWORK_PROVIDER) != null) {
mLocationManager.requestLocationUpdates(mLocationRequest,mGenericLocationListener,mHandler.getLooper());
mLocating=true;
}
 else {
mHasNetworkLocation=false;
}
if (mLocationManager != null && mLocationManager.getProvider(LocationManager.GPS_PROVIDER) != null) {
mHasGps=true;
mLocationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER,1000,5,mGpsLocationListener,mHandler.getLooper());
mLocating=true;
}
 else {
mHasGps=false;
}
if (mLocating) {
break;
}
case STATE_LOCATING:
cancelAlarmLocked();
cancelLocatingLocked();
mAnyMotionDetector.stop();
case STATE_IDLE_MAINTENANCE:
scheduleAlarmLocked(mNextIdleDelay,true);
if (DEBUG) Slog.d(TAG,""String_Node_Str"" + mNextIdleDelay + ""String_Node_Str"");
mNextIdleDelay=(long)(mNextIdleDelay * mConstants.IDLE_FACTOR);
if (DEBUG) Slog.d(TAG,""String_Node_Str"" + mNextIdleDelay);
mNextIdleDelay=Math.min(mNextIdleDelay,mConstants.MAX_IDLE_TIMEOUT);
if (mNextIdleDelay < mConstants.IDLE_TIMEOUT) {
mNextIdleDelay=mConstants.IDLE_TIMEOUT;
}
mState=STATE_IDLE;
if (mLightState != LIGHT_STATE_OVERRIDE) {
mLightState=LIGHT_STATE_OVERRIDE;
cancelLightAlarmLocked();
}
EventLogTags.writeDeviceIdle(mState,reason);
addEvent(EVENT_DEEP_IDLE);
mHandler.sendEmptyMessage(MSG_REPORT_IDLE_ON);
if (mMaintenanceMinCheckScheduled) {
mAlarmManager.cancel(mMaintenanceMinCheckListener);
mMaintenanceMinCheckScheduled=false;
}
break;
case STATE_IDLE:
mActiveIdleOpCount=1;
scheduleAlarmLocked(mNextIdlePendingDelay,false);
if (DEBUG) Slog.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + mNextIdlePendingDelay + ""String_Node_Str"");
mMaintenanceStartTime=SystemClock.elapsedRealtime();
mNextIdlePendingDelay=Math.min(mConstants.MAX_IDLE_PENDING_TIMEOUT,(long)(mNextIdlePendingDelay * mConstants.IDLE_PENDING_FACTOR));
if (mNextIdlePendingDelay < mConstants.IDLE_PENDING_TIMEOUT) {
mNextIdlePendingDelay=mConstants.IDLE_PENDING_TIMEOUT;
}
mState=STATE_IDLE_MAINTENANCE;
EventLogTags.writeDeviceIdle(mState,reason);
addEvent(EVENT_DEEP_MAINTENANCE);
mHandler.sendEmptyMessage(MSG_REPORT_IDLE_OFF);
mAlarmManager.setExact(AlarmManager.ELAPSED_REALTIME,mMaintenanceStartTime + mConstants.MIN_DEEP_MAINTENANCE_TIME,""String_Node_Str"",mMaintenanceMinCheckListener,mHandler);
mMaintenanceMinCheckScheduled=true;
break;
}
}","void stepIdleStateLocked(String reason){
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + mState);
  EventLogTags.writeDeviceIdleStep();
  final long now=SystemClock.elapsedRealtime();
  if ((now + mConstants.MIN_TIME_TO_ALARM) > mAlarmManager.getNextWakeFromIdleTime()) {
    if (mState != STATE_ACTIVE) {
      becomeActiveLocked(""String_Node_Str"",Process.myUid());
      becomeInactiveIfAppropriateLocked();
    }
    return;
  }
switch (mState) {
case STATE_INACTIVE:
    startMonitoringMotionLocked();
  scheduleAlarmLocked(mConstants.IDLE_AFTER_INACTIVE_TIMEOUT,false);
mNextIdlePendingDelay=mConstants.IDLE_PENDING_TIMEOUT;
mNextIdleDelay=mConstants.IDLE_TIMEOUT;
mState=STATE_IDLE_PENDING;
if (DEBUG) Slog.d(TAG,""String_Node_Str"");
EventLogTags.writeDeviceIdle(mState,reason);
break;
case STATE_IDLE_PENDING:
mState=STATE_SENSING;
if (DEBUG) Slog.d(TAG,""String_Node_Str"");
EventLogTags.writeDeviceIdle(mState,reason);
scheduleAlarmLocked(mConstants.SENSING_TIMEOUT,false);
cancelLocatingLocked();
mAnyMotionDetector.checkForAnyMotion();
mNotMoving=false;
mLocated=false;
mLastGenericLocation=null;
mLastGpsLocation=null;
break;
case STATE_SENSING:
mState=STATE_LOCATING;
if (DEBUG) Slog.d(TAG,""String_Node_Str"");
EventLogTags.writeDeviceIdle(mState,reason);
scheduleAlarmLocked(mConstants.LOCATING_TIMEOUT,false);
if (mLocationManager != null && mLocationManager.getProvider(LocationManager.NETWORK_PROVIDER) != null) {
mLocationManager.requestLocationUpdates(mLocationRequest,mGenericLocationListener,mHandler.getLooper());
mLocating=true;
}
 else {
mHasNetworkLocation=false;
}
if (mLocationManager != null && mLocationManager.getProvider(LocationManager.GPS_PROVIDER) != null) {
mHasGps=true;
mLocationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER,1000,5,mGpsLocationListener,mHandler.getLooper());
mLocating=true;
}
 else {
mHasGps=false;
}
if (mLocating) {
break;
}
case STATE_LOCATING:
cancelAlarmLocked();
cancelLocatingLocked();
mAnyMotionDetector.stop();
case STATE_IDLE_MAINTENANCE:
scheduleAlarmLocked(mNextIdleDelay,true);
if (DEBUG) Slog.d(TAG,""String_Node_Str"" + mNextIdleDelay + ""String_Node_Str"");
mNextIdleDelay=(long)(mNextIdleDelay * mConstants.IDLE_FACTOR);
if (DEBUG) Slog.d(TAG,""String_Node_Str"" + mNextIdleDelay);
mNextIdleDelay=Math.min(mNextIdleDelay,mConstants.MAX_IDLE_TIMEOUT);
if (mNextIdleDelay < mConstants.IDLE_TIMEOUT) {
mNextIdleDelay=mConstants.IDLE_TIMEOUT;
}
mState=STATE_IDLE;
if (mLightState != LIGHT_STATE_OVERRIDE) {
mLightState=LIGHT_STATE_OVERRIDE;
cancelLightAlarmLocked();
}
EventLogTags.writeDeviceIdle(mState,reason);
addEvent(EVENT_DEEP_IDLE);
mHandler.sendEmptyMessage(MSG_REPORT_IDLE_ON);
break;
case STATE_IDLE:
mActiveIdleOpCount=1;
mActiveIdleWakeLock.acquire();
scheduleAlarmLocked(mNextIdlePendingDelay,false);
if (DEBUG) Slog.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + mNextIdlePendingDelay + ""String_Node_Str"");
mMaintenanceStartTime=SystemClock.elapsedRealtime();
mNextIdlePendingDelay=Math.min(mConstants.MAX_IDLE_PENDING_TIMEOUT,(long)(mNextIdlePendingDelay * mConstants.IDLE_PENDING_FACTOR));
if (mNextIdlePendingDelay < mConstants.IDLE_PENDING_TIMEOUT) {
mNextIdlePendingDelay=mConstants.IDLE_PENDING_TIMEOUT;
}
mState=STATE_IDLE_MAINTENANCE;
EventLogTags.writeDeviceIdle(mState,reason);
addEvent(EVENT_DEEP_MAINTENANCE);
mHandler.sendEmptyMessage(MSG_REPORT_IDLE_OFF);
break;
}
}",0.9466799374377932
192349,"void stepLightIdleStateLocked(String reason){
  if (mLightState == LIGHT_STATE_OVERRIDE) {
    return;
  }
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + mLightState);
  EventLogTags.writeDeviceIdleLightStep();
switch (mLightState) {
case LIGHT_STATE_INACTIVE:
    mCurIdleBudget=mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET;
  mNextLightIdleDelay=mConstants.LIGHT_IDLE_TIMEOUT;
mMaintenanceStartTime=0;
case LIGHT_STATE_IDLE_MAINTENANCE:
if (mMaintenanceStartTime != 0) {
long duration=SystemClock.elapsedRealtime() - mMaintenanceStartTime;
if (duration < mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET) {
  mCurIdleBudget+=(mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET - duration);
}
 else {
  mCurIdleBudget-=(duration - mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET);
}
}
mMaintenanceStartTime=0;
scheduleLightAlarmLocked(mNextLightIdleDelay);
mNextLightIdleDelay=Math.min(mConstants.LIGHT_MAX_IDLE_TIMEOUT,(long)(mNextLightIdleDelay * mConstants.LIGHT_IDLE_FACTOR));
if (mNextLightIdleDelay < mConstants.LIGHT_IDLE_TIMEOUT) {
mNextLightIdleDelay=mConstants.LIGHT_IDLE_TIMEOUT;
}
if (DEBUG) Slog.d(TAG,""String_Node_Str"");
mLightState=LIGHT_STATE_IDLE;
EventLogTags.writeDeviceIdleLight(mLightState,reason);
addEvent(EVENT_LIGHT_IDLE);
mHandler.sendEmptyMessage(MSG_REPORT_IDLE_ON_LIGHT);
if (mMaintenanceMinCheckScheduled) {
mAlarmManager.cancel(mMaintenanceMinCheckListener);
mMaintenanceMinCheckScheduled=false;
}
break;
case LIGHT_STATE_IDLE:
mActiveIdleOpCount=1;
mMaintenanceStartTime=SystemClock.elapsedRealtime();
if (mCurIdleBudget < mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET) {
mCurIdleBudget=mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET;
}
 else if (mCurIdleBudget > mConstants.LIGHT_IDLE_MAINTENANCE_MAX_BUDGET) {
mCurIdleBudget=mConstants.LIGHT_IDLE_MAINTENANCE_MAX_BUDGET;
}
scheduleLightAlarmLocked(mCurIdleBudget);
if (DEBUG) Slog.d(TAG,""String_Node_Str"");
mLightState=LIGHT_STATE_IDLE_MAINTENANCE;
EventLogTags.writeDeviceIdleLight(mLightState,reason);
addEvent(EVENT_LIGHT_MAINTENANCE);
mHandler.sendEmptyMessage(MSG_REPORT_IDLE_OFF);
mAlarmManager.setExact(AlarmManager.ELAPSED_REALTIME,mMaintenanceStartTime + mConstants.MIN_LIGHT_MAINTENANCE_TIME,""String_Node_Str"",mMaintenanceMinCheckListener,mHandler);
mMaintenanceMinCheckScheduled=true;
break;
}
}","void stepLightIdleStateLocked(String reason){
  if (mLightState == LIGHT_STATE_OVERRIDE) {
    return;
  }
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + mLightState);
  EventLogTags.writeDeviceIdleLightStep();
switch (mLightState) {
case LIGHT_STATE_INACTIVE:
    mCurIdleBudget=mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET;
  mNextLightIdleDelay=mConstants.LIGHT_IDLE_TIMEOUT;
mMaintenanceStartTime=0;
if (!isOpsInactiveLocked()) {
mLightState=LIGHT_STATE_PRE_IDLE;
EventLogTags.writeDeviceIdleLight(mLightState,reason);
scheduleLightAlarmLocked(mConstants.LIGHT_PRE_IDLE_TIMEOUT);
break;
}
case LIGHT_STATE_PRE_IDLE:
case LIGHT_STATE_IDLE_MAINTENANCE:
if (mMaintenanceStartTime != 0) {
long duration=SystemClock.elapsedRealtime() - mMaintenanceStartTime;
if (duration < mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET) {
mCurIdleBudget+=(mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET - duration);
}
 else {
mCurIdleBudget-=(duration - mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET);
}
}
mMaintenanceStartTime=0;
scheduleLightAlarmLocked(mNextLightIdleDelay);
mNextLightIdleDelay=Math.min(mConstants.LIGHT_MAX_IDLE_TIMEOUT,(long)(mNextLightIdleDelay * mConstants.LIGHT_IDLE_FACTOR));
if (mNextLightIdleDelay < mConstants.LIGHT_IDLE_TIMEOUT) {
mNextLightIdleDelay=mConstants.LIGHT_IDLE_TIMEOUT;
}
if (DEBUG) Slog.d(TAG,""String_Node_Str"");
mLightState=LIGHT_STATE_IDLE;
EventLogTags.writeDeviceIdleLight(mLightState,reason);
addEvent(EVENT_LIGHT_IDLE);
mHandler.sendEmptyMessage(MSG_REPORT_IDLE_ON_LIGHT);
break;
case LIGHT_STATE_IDLE:
mActiveIdleOpCount=1;
mActiveIdleWakeLock.acquire();
mMaintenanceStartTime=SystemClock.elapsedRealtime();
if (mCurIdleBudget < mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET) {
mCurIdleBudget=mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET;
}
 else if (mCurIdleBudget > mConstants.LIGHT_IDLE_MAINTENANCE_MAX_BUDGET) {
mCurIdleBudget=mConstants.LIGHT_IDLE_MAINTENANCE_MAX_BUDGET;
}
scheduleLightAlarmLocked(mCurIdleBudget);
if (DEBUG) Slog.d(TAG,""String_Node_Str"");
mLightState=LIGHT_STATE_IDLE_MAINTENANCE;
EventLogTags.writeDeviceIdleLight(mLightState,reason);
addEvent(EVENT_LIGHT_MAINTENANCE);
mHandler.sendEmptyMessage(MSG_REPORT_IDLE_OFF);
break;
}
}",0.8661876964526268
192350,"private void updateConstants(){
synchronized (DeviceIdleController.this) {
    try {
      mParser.setString(Settings.Global.getString(mResolver,mHasWatch ? Settings.Global.DEVICE_IDLE_CONSTANTS_WATCH : Settings.Global.DEVICE_IDLE_CONSTANTS));
    }
 catch (    IllegalArgumentException e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
    LIGHT_IDLE_AFTER_INACTIVE_TIMEOUT=mParser.getLong(KEY_LIGHT_IDLE_AFTER_INACTIVE_TIMEOUT,!COMPRESS_TIME ? 5 * 60 * 1000L : 15 * 1000L);
    LIGHT_IDLE_TIMEOUT=mParser.getLong(KEY_LIGHT_IDLE_TIMEOUT,!COMPRESS_TIME ? 5 * 60 * 1000L : 15 * 1000L);
    LIGHT_IDLE_FACTOR=mParser.getFloat(KEY_LIGHT_IDLE_FACTOR,2f);
    LIGHT_MAX_IDLE_TIMEOUT=mParser.getLong(KEY_LIGHT_MAX_IDLE_TIMEOUT,!COMPRESS_TIME ? 15 * 60 * 1000L : 60 * 1000L);
    LIGHT_IDLE_MAINTENANCE_MIN_BUDGET=mParser.getLong(KEY_LIGHT_IDLE_MAINTENANCE_MIN_BUDGET,!COMPRESS_TIME ? 1 * 60 * 1000L : 15 * 1000L);
    LIGHT_IDLE_MAINTENANCE_MAX_BUDGET=mParser.getLong(KEY_LIGHT_IDLE_MAINTENANCE_MAX_BUDGET,!COMPRESS_TIME ? 5 * 60 * 1000L : 30 * 1000L);
    MIN_LIGHT_MAINTENANCE_TIME=mParser.getLong(KEY_MIN_LIGHT_MAINTENANCE_TIME,!COMPRESS_TIME ? 5 * 1000L : 1 * 1000L);
    MIN_DEEP_MAINTENANCE_TIME=mParser.getLong(KEY_MIN_DEEP_MAINTENANCE_TIME,!COMPRESS_TIME ? 30 * 1000L : 5 * 1000L);
    long inactiveTimeoutDefault=(mHasWatch ? 15 : 30) * 60 * 1000L;
    INACTIVE_TIMEOUT=mParser.getLong(KEY_INACTIVE_TIMEOUT,!COMPRESS_TIME ? inactiveTimeoutDefault : (inactiveTimeoutDefault / 10));
    SENSING_TIMEOUT=mParser.getLong(KEY_SENSING_TIMEOUT,!DEBUG ? 4 * 60 * 1000L : 60 * 1000L);
    LOCATING_TIMEOUT=mParser.getLong(KEY_LOCATING_TIMEOUT,!DEBUG ? 30 * 1000L : 15 * 1000L);
    LOCATION_ACCURACY=mParser.getFloat(KEY_LOCATION_ACCURACY,20);
    MOTION_INACTIVE_TIMEOUT=mParser.getLong(KEY_MOTION_INACTIVE_TIMEOUT,!COMPRESS_TIME ? 10 * 60 * 1000L : 60 * 1000L);
    long idleAfterInactiveTimeout=(mHasWatch ? 15 : 30) * 60 * 1000L;
    IDLE_AFTER_INACTIVE_TIMEOUT=mParser.getLong(KEY_IDLE_AFTER_INACTIVE_TIMEOUT,!COMPRESS_TIME ? idleAfterInactiveTimeout : (idleAfterInactiveTimeout / 10));
    IDLE_PENDING_TIMEOUT=mParser.getLong(KEY_IDLE_PENDING_TIMEOUT,!COMPRESS_TIME ? 5 * 60 * 1000L : 30 * 1000L);
    MAX_IDLE_PENDING_TIMEOUT=mParser.getLong(KEY_MAX_IDLE_PENDING_TIMEOUT,!COMPRESS_TIME ? 10 * 60 * 1000L : 60 * 1000L);
    IDLE_PENDING_FACTOR=mParser.getFloat(KEY_IDLE_PENDING_FACTOR,2f);
    IDLE_TIMEOUT=mParser.getLong(KEY_IDLE_TIMEOUT,!COMPRESS_TIME ? 60 * 60 * 1000L : 6 * 60 * 1000L);
    MAX_IDLE_TIMEOUT=mParser.getLong(KEY_MAX_IDLE_TIMEOUT,!COMPRESS_TIME ? 6 * 60 * 60* 1000L : 30 * 60 * 1000L);
    IDLE_FACTOR=mParser.getFloat(KEY_IDLE_FACTOR,2f);
    MIN_TIME_TO_ALARM=mParser.getLong(KEY_MIN_TIME_TO_ALARM,!COMPRESS_TIME ? 60 * 60 * 1000L : 6 * 60 * 1000L);
    MAX_TEMP_APP_WHITELIST_DURATION=mParser.getLong(KEY_MAX_TEMP_APP_WHITELIST_DURATION,5 * 60 * 1000L);
    MMS_TEMP_APP_WHITELIST_DURATION=mParser.getLong(KEY_MMS_TEMP_APP_WHITELIST_DURATION,60 * 1000L);
    SMS_TEMP_APP_WHITELIST_DURATION=mParser.getLong(KEY_SMS_TEMP_APP_WHITELIST_DURATION,20 * 1000L);
  }
}","private void updateConstants(){
synchronized (DeviceIdleController.this) {
    try {
      mParser.setString(Settings.Global.getString(mResolver,mHasWatch ? Settings.Global.DEVICE_IDLE_CONSTANTS_WATCH : Settings.Global.DEVICE_IDLE_CONSTANTS));
    }
 catch (    IllegalArgumentException e) {
      Slog.e(TAG,""String_Node_Str"",e);
    }
    LIGHT_IDLE_AFTER_INACTIVE_TIMEOUT=mParser.getLong(KEY_LIGHT_IDLE_AFTER_INACTIVE_TIMEOUT,!COMPRESS_TIME ? 5 * 60 * 1000L : 15 * 1000L);
    LIGHT_PRE_IDLE_TIMEOUT=mParser.getLong(KEY_LIGHT_PRE_IDLE_TIMEOUT,!COMPRESS_TIME ? 10 * 60 * 1000L : 30 * 1000L);
    LIGHT_IDLE_TIMEOUT=mParser.getLong(KEY_LIGHT_IDLE_TIMEOUT,!COMPRESS_TIME ? 5 * 60 * 1000L : 15 * 1000L);
    LIGHT_IDLE_FACTOR=mParser.getFloat(KEY_LIGHT_IDLE_FACTOR,2f);
    LIGHT_MAX_IDLE_TIMEOUT=mParser.getLong(KEY_LIGHT_MAX_IDLE_TIMEOUT,!COMPRESS_TIME ? 15 * 60 * 1000L : 60 * 1000L);
    LIGHT_IDLE_MAINTENANCE_MIN_BUDGET=mParser.getLong(KEY_LIGHT_IDLE_MAINTENANCE_MIN_BUDGET,!COMPRESS_TIME ? 1 * 60 * 1000L : 15 * 1000L);
    LIGHT_IDLE_MAINTENANCE_MAX_BUDGET=mParser.getLong(KEY_LIGHT_IDLE_MAINTENANCE_MAX_BUDGET,!COMPRESS_TIME ? 5 * 60 * 1000L : 30 * 1000L);
    MIN_LIGHT_MAINTENANCE_TIME=mParser.getLong(KEY_MIN_LIGHT_MAINTENANCE_TIME,!COMPRESS_TIME ? 5 * 1000L : 1 * 1000L);
    MIN_DEEP_MAINTENANCE_TIME=mParser.getLong(KEY_MIN_DEEP_MAINTENANCE_TIME,!COMPRESS_TIME ? 30 * 1000L : 5 * 1000L);
    long inactiveTimeoutDefault=(mHasWatch ? 15 : 30) * 60 * 1000L;
    INACTIVE_TIMEOUT=mParser.getLong(KEY_INACTIVE_TIMEOUT,!COMPRESS_TIME ? inactiveTimeoutDefault : (inactiveTimeoutDefault / 10));
    SENSING_TIMEOUT=mParser.getLong(KEY_SENSING_TIMEOUT,!DEBUG ? 4 * 60 * 1000L : 60 * 1000L);
    LOCATING_TIMEOUT=mParser.getLong(KEY_LOCATING_TIMEOUT,!DEBUG ? 30 * 1000L : 15 * 1000L);
    LOCATION_ACCURACY=mParser.getFloat(KEY_LOCATION_ACCURACY,20);
    MOTION_INACTIVE_TIMEOUT=mParser.getLong(KEY_MOTION_INACTIVE_TIMEOUT,!COMPRESS_TIME ? 10 * 60 * 1000L : 60 * 1000L);
    long idleAfterInactiveTimeout=(mHasWatch ? 15 : 30) * 60 * 1000L;
    IDLE_AFTER_INACTIVE_TIMEOUT=mParser.getLong(KEY_IDLE_AFTER_INACTIVE_TIMEOUT,!COMPRESS_TIME ? idleAfterInactiveTimeout : (idleAfterInactiveTimeout / 10));
    IDLE_PENDING_TIMEOUT=mParser.getLong(KEY_IDLE_PENDING_TIMEOUT,!COMPRESS_TIME ? 5 * 60 * 1000L : 30 * 1000L);
    MAX_IDLE_PENDING_TIMEOUT=mParser.getLong(KEY_MAX_IDLE_PENDING_TIMEOUT,!COMPRESS_TIME ? 10 * 60 * 1000L : 60 * 1000L);
    IDLE_PENDING_FACTOR=mParser.getFloat(KEY_IDLE_PENDING_FACTOR,2f);
    IDLE_TIMEOUT=mParser.getLong(KEY_IDLE_TIMEOUT,!COMPRESS_TIME ? 60 * 60 * 1000L : 6 * 60 * 1000L);
    MAX_IDLE_TIMEOUT=mParser.getLong(KEY_MAX_IDLE_TIMEOUT,!COMPRESS_TIME ? 6 * 60 * 60* 1000L : 30 * 60 * 1000L);
    IDLE_FACTOR=mParser.getFloat(KEY_IDLE_FACTOR,2f);
    MIN_TIME_TO_ALARM=mParser.getLong(KEY_MIN_TIME_TO_ALARM,!COMPRESS_TIME ? 60 * 60 * 1000L : 6 * 60 * 1000L);
    MAX_TEMP_APP_WHITELIST_DURATION=mParser.getLong(KEY_MAX_TEMP_APP_WHITELIST_DURATION,5 * 60 * 1000L);
    MMS_TEMP_APP_WHITELIST_DURATION=mParser.getLong(KEY_MMS_TEMP_APP_WHITELIST_DURATION,60 * 1000L);
    SMS_TEMP_APP_WHITELIST_DURATION=mParser.getLong(KEY_SMS_TEMP_APP_WHITELIST_DURATION,20 * 1000L);
  }
}",0.981234096692112
192351,"@Override public void onReceive(Context context,Intent intent){
  decActiveIdleOps();
}","@Override public void onReceive(Context context,Intent intent){
  if (PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED.equals(intent.getAction())) {
    mHandler.sendEmptyMessageDelayed(MSG_FINISH_IDLE_OP,mConstants.MIN_DEEP_MAINTENANCE_TIME);
  }
 else {
    mHandler.sendEmptyMessageDelayed(MSG_FINISH_IDLE_OP,mConstants.MIN_LIGHT_MAINTENANCE_TIME);
  }
}",0.3272727272727272
192352,"void exitMaintenanceEarlyIfNeededLocked(){
  if (mState == STATE_IDLE_MAINTENANCE || mLightState == LIGHT_STATE_IDLE_MAINTENANCE) {
    if (mActiveIdleOpCount <= 0 && mDownloadServiceActive == null && !mJobsActive && !mAlarmsActive) {
      final long now=SystemClock.elapsedRealtime();
      if (DEBUG) {
        StringBuilder sb=new StringBuilder();
        sb.append(""String_Node_Str"");
        TimeUtils.formatDuration(mMaintenanceStartTime,sb);
        sb.append(""String_Node_Str"");
        TimeUtils.formatDuration(now,sb);
        Slog.d(TAG,sb.toString());
      }
      if (mState == STATE_IDLE_MAINTENANCE) {
        if (now >= (mMaintenanceStartTime + mConstants.MIN_DEEP_MAINTENANCE_TIME)) {
          stepIdleStateLocked(""String_Node_Str"");
        }
      }
 else {
        if (now >= (mMaintenanceStartTime + mConstants.MIN_LIGHT_MAINTENANCE_TIME)) {
          stepLightIdleStateLocked(""String_Node_Str"");
        }
      }
    }
  }
}","void exitMaintenanceEarlyIfNeededLocked(){
  if (mState == STATE_IDLE_MAINTENANCE || mLightState == LIGHT_STATE_IDLE_MAINTENANCE || mLightState == LIGHT_STATE_PRE_IDLE) {
    if (isOpsInactiveLocked()) {
      final long now=SystemClock.elapsedRealtime();
      if (DEBUG) {
        StringBuilder sb=new StringBuilder();
        sb.append(""String_Node_Str"");
        TimeUtils.formatDuration(mMaintenanceStartTime,sb);
        sb.append(""String_Node_Str"");
        TimeUtils.formatDuration(now,sb);
        Slog.d(TAG,sb.toString());
      }
      if (mState == STATE_IDLE_MAINTENANCE) {
        stepIdleStateLocked(""String_Node_Str"");
      }
 else       if (mLightState == LIGHT_STATE_PRE_IDLE) {
        stepLightIdleStateLocked(""String_Node_Str"");
      }
 else {
        stepLightIdleStateLocked(""String_Node_Str"");
      }
    }
  }
}",0.770949720670391
192353,"void decActiveIdleOps(){
synchronized (this) {
    mActiveIdleOpCount--;
    if (mActiveIdleOpCount <= 0) {
      exitMaintenanceEarlyIfNeededLocked();
    }
  }
}","void decActiveIdleOps(){
synchronized (this) {
    mActiveIdleOpCount--;
    if (mActiveIdleOpCount <= 0) {
      exitMaintenanceEarlyIfNeededLocked();
      mActiveIdleWakeLock.release();
    }
  }
}",0.8980716253443526
192354,"private static String lightStateToString(int state){
switch (state) {
case LIGHT_STATE_ACTIVE:
    return ""String_Node_Str"";
case LIGHT_STATE_INACTIVE:
  return ""String_Node_Str"";
case LIGHT_STATE_IDLE:
return ""String_Node_Str"";
case LIGHT_STATE_IDLE_MAINTENANCE:
return ""String_Node_Str"";
case LIGHT_STATE_OVERRIDE:
return ""String_Node_Str"";
default :
return Integer.toString(state);
}
}","private static String lightStateToString(int state){
switch (state) {
case LIGHT_STATE_ACTIVE:
    return ""String_Node_Str"";
case LIGHT_STATE_INACTIVE:
  return ""String_Node_Str"";
case LIGHT_STATE_PRE_IDLE:
return ""String_Node_Str"";
case LIGHT_STATE_IDLE:
return ""String_Node_Str"";
case LIGHT_STATE_IDLE_MAINTENANCE:
return ""String_Node_Str"";
case LIGHT_STATE_OVERRIDE:
return ""String_Node_Str"";
default :
return Integer.toString(state);
}
}",0.9360675512665864
192355,"@Override public void onBootPhase(int phase){
  if (phase == PHASE_SYSTEM_SERVICES_READY) {
synchronized (this) {
      mAlarmManager=(AlarmManager)getContext().getSystemService(Context.ALARM_SERVICE);
      mBatteryStats=BatteryStatsService.getService();
      mLocalPowerManager=getLocalService(PowerManagerInternal.class);
      mLocalAlarmManager=getLocalService(AlarmManagerService.LocalService.class);
      mNetworkPolicyManager=INetworkPolicyManager.Stub.asInterface(ServiceManager.getService(Context.NETWORK_POLICY_SERVICE));
      mDisplayManager=(DisplayManager)getContext().getSystemService(Context.DISPLAY_SERVICE);
      mSensorManager=(SensorManager)getContext().getSystemService(Context.SENSOR_SERVICE);
      int sigMotionSensorId=getContext().getResources().getInteger(com.android.internal.R.integer.config_autoPowerModeAnyMotionSensor);
      if (sigMotionSensorId > 0) {
        mMotionSensor=mSensorManager.getDefaultSensor(sigMotionSensorId,true);
      }
      if (mMotionSensor == null && getContext().getResources().getBoolean(com.android.internal.R.bool.config_autoPowerModePreferWristTilt)) {
        mMotionSensor=mSensorManager.getDefaultSensor(Sensor.TYPE_WRIST_TILT_GESTURE,true);
      }
      if (mMotionSensor == null) {
        mMotionSensor=mSensorManager.getDefaultSensor(Sensor.TYPE_SIGNIFICANT_MOTION,true);
      }
      if (getContext().getResources().getBoolean(com.android.internal.R.bool.config_autoPowerModePrefetchLocation)) {
        mLocationManager=(LocationManager)getContext().getSystemService(Context.LOCATION_SERVICE);
        mLocationRequest=new LocationRequest().setQuality(LocationRequest.ACCURACY_FINE).setInterval(0).setFastestInterval(0).setNumUpdates(1);
      }
      float angleThreshold=getContext().getResources().getInteger(com.android.internal.R.integer.config_autoPowerModeThresholdAngle) / 100f;
      mAnyMotionDetector=new AnyMotionDetector((PowerManager)getContext().getSystemService(Context.POWER_SERVICE),mHandler,mSensorManager,this,angleThreshold);
      mIdleIntent=new Intent(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED);
      mIdleIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
      mLightIdleIntent=new Intent(PowerManager.ACTION_LIGHT_DEVICE_IDLE_MODE_CHANGED);
      mLightIdleIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
      IntentFilter filter=new IntentFilter();
      filter.addAction(Intent.ACTION_BATTERY_CHANGED);
      getContext().registerReceiver(mReceiver,filter);
      filter=new IntentFilter();
      filter.addAction(Intent.ACTION_PACKAGE_REMOVED);
      filter.addDataScheme(""String_Node_Str"");
      getContext().registerReceiver(mReceiver,filter);
      mLocalPowerManager.setDeviceIdleWhitelist(mPowerSaveWhitelistAllAppIdArray);
      mLocalAlarmManager.setDeviceIdleUserWhitelist(mPowerSaveWhitelistUserAppIdArray);
      mDisplayManager.registerDisplayListener(mDisplayListener,null);
      updateDisplayLocked();
    }
  }
}","@Override public void onBootPhase(int phase){
  if (phase == PHASE_SYSTEM_SERVICES_READY) {
synchronized (this) {
      mAlarmManager=(AlarmManager)getContext().getSystemService(Context.ALARM_SERVICE);
      mBatteryStats=BatteryStatsService.getService();
      mLocalPowerManager=getLocalService(PowerManagerInternal.class);
      mPowerManager=getContext().getSystemService(PowerManager.class);
      mActiveIdleWakeLock=mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,""String_Node_Str"");
      mActiveIdleWakeLock.setReferenceCounted(false);
      mLocalAlarmManager=getLocalService(AlarmManagerService.LocalService.class);
      mNetworkPolicyManager=INetworkPolicyManager.Stub.asInterface(ServiceManager.getService(Context.NETWORK_POLICY_SERVICE));
      mDisplayManager=(DisplayManager)getContext().getSystemService(Context.DISPLAY_SERVICE);
      mSensorManager=(SensorManager)getContext().getSystemService(Context.SENSOR_SERVICE);
      int sigMotionSensorId=getContext().getResources().getInteger(com.android.internal.R.integer.config_autoPowerModeAnyMotionSensor);
      if (sigMotionSensorId > 0) {
        mMotionSensor=mSensorManager.getDefaultSensor(sigMotionSensorId,true);
      }
      if (mMotionSensor == null && getContext().getResources().getBoolean(com.android.internal.R.bool.config_autoPowerModePreferWristTilt)) {
        mMotionSensor=mSensorManager.getDefaultSensor(Sensor.TYPE_WRIST_TILT_GESTURE,true);
      }
      if (mMotionSensor == null) {
        mMotionSensor=mSensorManager.getDefaultSensor(Sensor.TYPE_SIGNIFICANT_MOTION,true);
      }
      if (getContext().getResources().getBoolean(com.android.internal.R.bool.config_autoPowerModePrefetchLocation)) {
        mLocationManager=(LocationManager)getContext().getSystemService(Context.LOCATION_SERVICE);
        mLocationRequest=new LocationRequest().setQuality(LocationRequest.ACCURACY_FINE).setInterval(0).setFastestInterval(0).setNumUpdates(1);
      }
      float angleThreshold=getContext().getResources().getInteger(com.android.internal.R.integer.config_autoPowerModeThresholdAngle) / 100f;
      mAnyMotionDetector=new AnyMotionDetector((PowerManager)getContext().getSystemService(Context.POWER_SERVICE),mHandler,mSensorManager,this,angleThreshold);
      mIdleIntent=new Intent(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED);
      mIdleIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
      mLightIdleIntent=new Intent(PowerManager.ACTION_LIGHT_DEVICE_IDLE_MODE_CHANGED);
      mLightIdleIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
      IntentFilter filter=new IntentFilter();
      filter.addAction(Intent.ACTION_BATTERY_CHANGED);
      getContext().registerReceiver(mReceiver,filter);
      filter=new IntentFilter();
      filter.addAction(Intent.ACTION_PACKAGE_REMOVED);
      filter.addDataScheme(""String_Node_Str"");
      getContext().registerReceiver(mReceiver,filter);
      mLocalPowerManager.setDeviceIdleWhitelist(mPowerSaveWhitelistAllAppIdArray);
      mLocalAlarmManager.setDeviceIdleUserWhitelist(mPowerSaveWhitelistUserAppIdArray);
      mDisplayManager.registerDisplayListener(mDisplayListener,null);
      updateDisplayLocked();
    }
  }
}",0.9636247606892152
192356,"void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (getContext().checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  if (args != null) {
    int userId=UserHandle.USER_SYSTEM;
    for (int i=0; i < args.length; i++) {
      String arg=args[i];
      if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i < args.length) {
          arg=args[i];
          userId=Integer.parseInt(arg);
        }
      }
 else       if (""String_Node_Str"".equals(arg)) {
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        return;
      }
 else {
        Shell shell=new Shell();
        shell.userId=userId;
        String[] newArgs=new String[args.length - i];
        System.arraycopy(args,i,newArgs,0,args.length - i);
        shell.exec(mBinderService,null,fd,null,newArgs,new ResultReceiver(null));
        return;
      }
    }
  }
synchronized (this) {
    mConstants.dump(pw);
    if (mEventCmds[0] != EVENT_NULL) {
      pw.println(""String_Node_Str"");
      long now=SystemClock.elapsedRealtime();
      for (int i=EVENT_BUFFER_SIZE - 1; i >= 0; i--) {
        int cmd=mEventCmds[i];
        if (cmd == EVENT_NULL) {
          continue;
        }
        String label;
switch (mEventCmds[i]) {
case EVENT_NORMAL:
          label=""String_Node_Str"";
        break;
case EVENT_LIGHT_IDLE:
      label=""String_Node_Str"";
    break;
case EVENT_LIGHT_MAINTENANCE:
  label=""String_Node_Str"";
break;
case EVENT_DEEP_IDLE:
label=""String_Node_Str"";
break;
case EVENT_DEEP_MAINTENANCE:
label=""String_Node_Str"";
break;
default :
label=""String_Node_Str"";
break;
}
pw.print(""String_Node_Str"");
pw.print(label);
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mEventTimes[i],now,pw);
;
pw.println();
}
}
int size=mPowerSaveWhitelistAppsExceptIdle.size();
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.println(mPowerSaveWhitelistAppsExceptIdle.keyAt(i));
}
}
size=mPowerSaveWhitelistApps.size();
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.println(mPowerSaveWhitelistApps.keyAt(i));
}
}
size=mPowerSaveWhitelistUserApps.size();
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.println(mPowerSaveWhitelistUserApps.keyAt(i));
}
}
size=mPowerSaveWhitelistExceptIdleAppIds.size();
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.print(mPowerSaveWhitelistExceptIdleAppIds.keyAt(i));
pw.println();
}
}
size=mPowerSaveWhitelistUserAppIds.size();
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.print(mPowerSaveWhitelistUserAppIds.keyAt(i));
pw.println();
}
}
size=mPowerSaveWhitelistAllAppIds.size();
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.print(mPowerSaveWhitelistAllAppIds.keyAt(i));
pw.println();
}
}
size=mTempWhitelistAppIdEndTimes.size();
if (size > 0) {
pw.println(""String_Node_Str"");
final long timeNow=SystemClock.elapsedRealtime();
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.print(mTempWhitelistAppIdEndTimes.keyAt(i));
pw.print(""String_Node_Str"");
Pair<MutableLong,String> entry=mTempWhitelistAppIdEndTimes.valueAt(i);
TimeUtils.formatDuration(entry.first.value,timeNow,pw);
pw.print(""String_Node_Str"");
pw.println(entry.second);
}
}
size=mTempWhitelistAppIdArray != null ? mTempWhitelistAppIdArray.length : 0;
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.print(mTempWhitelistAppIdArray[i]);
pw.println();
}
}
pw.print(""String_Node_Str"");
pw.print(mLightEnabled);
pw.print(""String_Node_Str"");
pw.println(mDeepEnabled);
pw.print(""String_Node_Str"");
pw.println(mForceIdle);
pw.print(""String_Node_Str"");
pw.println(mMotionSensor);
pw.print(""String_Node_Str"");
pw.println(mCurDisplay);
pw.print(""String_Node_Str"");
pw.println(mScreenOn);
pw.print(""String_Node_Str"");
pw.println(mCharging);
pw.print(""String_Node_Str"");
pw.println(mMotionListener.active);
pw.print(""String_Node_Str"");
pw.println(mNotMoving);
pw.print(""String_Node_Str"");
pw.print(mLocating);
pw.print(""String_Node_Str"");
pw.print(mHasGps);
pw.print(""String_Node_Str"");
pw.print(mHasNetworkLocation);
pw.print(""String_Node_Str"");
pw.println(mLocated);
if (mLastGenericLocation != null) {
pw.print(""String_Node_Str"");
pw.println(mLastGenericLocation);
}
if (mLastGpsLocation != null) {
pw.print(""String_Node_Str"");
pw.println(mLastGpsLocation);
}
pw.print(""String_Node_Str"");
pw.print(stateToString(mState));
pw.print(""String_Node_Str"");
pw.println(lightStateToString(mLightState));
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mInactiveTimeout,pw);
pw.println();
if (mActiveIdleOpCount != 0) {
pw.print(""String_Node_Str"");
pw.println(mActiveIdleOpCount);
}
if (mNextAlarmTime != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mNextAlarmTime,SystemClock.elapsedRealtime(),pw);
pw.println();
}
if (mNextIdlePendingDelay != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mNextIdlePendingDelay,pw);
pw.println();
}
if (mNextIdleDelay != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mNextIdleDelay,pw);
pw.println();
}
if (mNextLightIdleDelay != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mNextLightIdleDelay,pw);
pw.println();
}
if (mNextLightAlarmTime != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mNextLightAlarmTime,SystemClock.elapsedRealtime(),pw);
pw.println();
}
if (mCurIdleBudget != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mCurIdleBudget,pw);
pw.println();
}
if (mMaintenanceStartTime != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mMaintenanceStartTime,SystemClock.elapsedRealtime(),pw);
pw.println();
}
if (mMaintenanceMinCheckScheduled) {
pw.print(""String_Node_Str"");
pw.println(mMaintenanceMinCheckScheduled);
}
if (mJobsActive) {
pw.print(""String_Node_Str"");
pw.println(mJobsActive);
}
if (mAlarmsActive) {
pw.print(""String_Node_Str"");
pw.println(mAlarmsActive);
}
if (mDownloadServiceActive != null) {
pw.print(""String_Node_Str"");
pw.println(mDownloadServiceActive);
}
}
}","void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (getContext().checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  if (args != null) {
    int userId=UserHandle.USER_SYSTEM;
    for (int i=0; i < args.length; i++) {
      String arg=args[i];
      if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        i++;
        if (i < args.length) {
          arg=args[i];
          userId=Integer.parseInt(arg);
        }
      }
 else       if (""String_Node_Str"".equals(arg)) {
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        return;
      }
 else {
        Shell shell=new Shell();
        shell.userId=userId;
        String[] newArgs=new String[args.length - i];
        System.arraycopy(args,i,newArgs,0,args.length - i);
        shell.exec(mBinderService,null,fd,null,newArgs,new ResultReceiver(null));
        return;
      }
    }
  }
synchronized (this) {
    mConstants.dump(pw);
    if (mEventCmds[0] != EVENT_NULL) {
      pw.println(""String_Node_Str"");
      long now=SystemClock.elapsedRealtime();
      for (int i=EVENT_BUFFER_SIZE - 1; i >= 0; i--) {
        int cmd=mEventCmds[i];
        if (cmd == EVENT_NULL) {
          continue;
        }
        String label;
switch (mEventCmds[i]) {
case EVENT_NORMAL:
          label=""String_Node_Str"";
        break;
case EVENT_LIGHT_IDLE:
      label=""String_Node_Str"";
    break;
case EVENT_LIGHT_MAINTENANCE:
  label=""String_Node_Str"";
break;
case EVENT_DEEP_IDLE:
label=""String_Node_Str"";
break;
case EVENT_DEEP_MAINTENANCE:
label=""String_Node_Str"";
break;
default :
label=""String_Node_Str"";
break;
}
pw.print(""String_Node_Str"");
pw.print(label);
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mEventTimes[i],now,pw);
;
pw.println();
}
}
int size=mPowerSaveWhitelistAppsExceptIdle.size();
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.println(mPowerSaveWhitelistAppsExceptIdle.keyAt(i));
}
}
size=mPowerSaveWhitelistApps.size();
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.println(mPowerSaveWhitelistApps.keyAt(i));
}
}
size=mPowerSaveWhitelistUserApps.size();
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.println(mPowerSaveWhitelistUserApps.keyAt(i));
}
}
size=mPowerSaveWhitelistExceptIdleAppIds.size();
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.print(mPowerSaveWhitelistExceptIdleAppIds.keyAt(i));
pw.println();
}
}
size=mPowerSaveWhitelistUserAppIds.size();
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.print(mPowerSaveWhitelistUserAppIds.keyAt(i));
pw.println();
}
}
size=mPowerSaveWhitelistAllAppIds.size();
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.print(mPowerSaveWhitelistAllAppIds.keyAt(i));
pw.println();
}
}
size=mTempWhitelistAppIdEndTimes.size();
if (size > 0) {
pw.println(""String_Node_Str"");
final long timeNow=SystemClock.elapsedRealtime();
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.print(mTempWhitelistAppIdEndTimes.keyAt(i));
pw.print(""String_Node_Str"");
Pair<MutableLong,String> entry=mTempWhitelistAppIdEndTimes.valueAt(i);
TimeUtils.formatDuration(entry.first.value,timeNow,pw);
pw.print(""String_Node_Str"");
pw.println(entry.second);
}
}
size=mTempWhitelistAppIdArray != null ? mTempWhitelistAppIdArray.length : 0;
if (size > 0) {
pw.println(""String_Node_Str"");
for (int i=0; i < size; i++) {
pw.print(""String_Node_Str"");
pw.print(mTempWhitelistAppIdArray[i]);
pw.println();
}
}
pw.print(""String_Node_Str"");
pw.print(mLightEnabled);
pw.print(""String_Node_Str"");
pw.println(mDeepEnabled);
pw.print(""String_Node_Str"");
pw.println(mForceIdle);
pw.print(""String_Node_Str"");
pw.println(mMotionSensor);
pw.print(""String_Node_Str"");
pw.println(mCurDisplay);
pw.print(""String_Node_Str"");
pw.println(mScreenOn);
pw.print(""String_Node_Str"");
pw.println(mCharging);
pw.print(""String_Node_Str"");
pw.println(mMotionListener.active);
pw.print(""String_Node_Str"");
pw.println(mNotMoving);
pw.print(""String_Node_Str"");
pw.print(mLocating);
pw.print(""String_Node_Str"");
pw.print(mHasGps);
pw.print(""String_Node_Str"");
pw.print(mHasNetworkLocation);
pw.print(""String_Node_Str"");
pw.println(mLocated);
if (mLastGenericLocation != null) {
pw.print(""String_Node_Str"");
pw.println(mLastGenericLocation);
}
if (mLastGpsLocation != null) {
pw.print(""String_Node_Str"");
pw.println(mLastGpsLocation);
}
pw.print(""String_Node_Str"");
pw.print(stateToString(mState));
pw.print(""String_Node_Str"");
pw.println(lightStateToString(mLightState));
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mInactiveTimeout,pw);
pw.println();
if (mActiveIdleOpCount != 0) {
pw.print(""String_Node_Str"");
pw.println(mActiveIdleOpCount);
}
if (mNextAlarmTime != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mNextAlarmTime,SystemClock.elapsedRealtime(),pw);
pw.println();
}
if (mNextIdlePendingDelay != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mNextIdlePendingDelay,pw);
pw.println();
}
if (mNextIdleDelay != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mNextIdleDelay,pw);
pw.println();
}
if (mNextLightIdleDelay != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mNextLightIdleDelay,pw);
pw.println();
}
if (mNextLightAlarmTime != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mNextLightAlarmTime,SystemClock.elapsedRealtime(),pw);
pw.println();
}
if (mCurIdleBudget != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mCurIdleBudget,pw);
pw.println();
}
if (mMaintenanceStartTime != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(mMaintenanceStartTime,SystemClock.elapsedRealtime(),pw);
pw.println();
}
if (mJobsActive) {
pw.print(""String_Node_Str"");
pw.println(mJobsActive);
}
if (mAlarmsActive) {
pw.print(""String_Node_Str"");
pw.println(mAlarmsActive);
}
if (mDownloadServiceActive != null) {
pw.print(""String_Node_Str"");
pw.println(mDownloadServiceActive);
}
}
}",0.9915518684831418
192357,"@Override public void handleMessage(Message msg){
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + msg.what + ""String_Node_Str"");
switch (msg.what) {
case MSG_WRITE_CONFIG:
{
      handleWriteConfigFile();
    }
  break;
case MSG_REPORT_IDLE_ON:
case MSG_REPORT_IDLE_ON_LIGHT:
{
  EventLogTags.writeDeviceIdleOnStart();
  final boolean deepChanged;
  final boolean lightChanged;
  if (msg.what == MSG_REPORT_IDLE_ON) {
    deepChanged=mLocalPowerManager.setDeviceIdleMode(true);
    lightChanged=mLocalPowerManager.setLightDeviceIdleMode(false);
  }
 else {
    deepChanged=mLocalPowerManager.setDeviceIdleMode(false);
    lightChanged=mLocalPowerManager.setLightDeviceIdleMode(true);
  }
  try {
    mNetworkPolicyManager.setDeviceIdleMode(true);
    mBatteryStats.noteDeviceIdleMode(msg.what == MSG_REPORT_IDLE_ON ? BatteryStats.DEVICE_IDLE_MODE_DEEP : BatteryStats.DEVICE_IDLE_MODE_LIGHT,null,Process.myUid());
  }
 catch (  RemoteException e) {
  }
  if (deepChanged) {
    getContext().sendBroadcastAsUser(mIdleIntent,UserHandle.ALL);
  }
  if (lightChanged) {
    getContext().sendBroadcastAsUser(mLightIdleIntent,UserHandle.ALL);
  }
  EventLogTags.writeDeviceIdleOnComplete();
}
break;
case MSG_REPORT_IDLE_OFF:
{
EventLogTags.writeDeviceIdleOffStart(""String_Node_Str"");
final boolean deepChanged=mLocalPowerManager.setDeviceIdleMode(false);
final boolean lightChanged=mLocalPowerManager.setLightDeviceIdleMode(false);
try {
mNetworkPolicyManager.setDeviceIdleMode(false);
mBatteryStats.noteDeviceIdleMode(BatteryStats.DEVICE_IDLE_MODE_OFF,null,Process.myUid());
}
 catch (RemoteException e) {
}
if (deepChanged) {
incActiveIdleOps();
getContext().sendOrderedBroadcastAsUser(mIdleIntent,UserHandle.ALL,null,mIdleStartedDoneReceiver,null,0,null,null);
}
if (lightChanged) {
incActiveIdleOps();
getContext().sendOrderedBroadcastAsUser(mLightIdleIntent,UserHandle.ALL,null,mIdleStartedDoneReceiver,null,0,null,null);
}
decActiveIdleOps();
EventLogTags.writeDeviceIdleOffComplete();
}
break;
case MSG_REPORT_ACTIVE:
{
String activeReason=(String)msg.obj;
int activeUid=msg.arg1;
EventLogTags.writeDeviceIdleOffStart(activeReason != null ? activeReason : ""String_Node_Str"");
final boolean deepChanged=mLocalPowerManager.setDeviceIdleMode(false);
final boolean lightChanged=mLocalPowerManager.setLightDeviceIdleMode(false);
try {
mNetworkPolicyManager.setDeviceIdleMode(false);
mBatteryStats.noteDeviceIdleMode(BatteryStats.DEVICE_IDLE_MODE_OFF,activeReason,activeUid);
}
 catch (RemoteException e) {
}
if (deepChanged) {
getContext().sendBroadcastAsUser(mIdleIntent,UserHandle.ALL);
}
if (lightChanged) {
getContext().sendBroadcastAsUser(mLightIdleIntent,UserHandle.ALL);
}
EventLogTags.writeDeviceIdleOffComplete();
}
break;
case MSG_TEMP_APP_WHITELIST_TIMEOUT:
{
int uid=msg.arg1;
checkTempAppWhitelistTimeout(uid);
}
break;
case MSG_REPORT_MAINTENANCE_ACTIVITY:
{
boolean active=(msg.arg1 == 1);
final int size=mMaintenanceActivityListeners.beginBroadcast();
try {
for (int i=0; i < size; i++) {
try {
mMaintenanceActivityListeners.getBroadcastItem(i).onMaintenanceActivityChanged(active);
}
 catch (RemoteException ignored) {
}
}
}
  finally {
mMaintenanceActivityListeners.finishBroadcast();
}
}
break;
}
}","@Override public void handleMessage(Message msg){
  if (DEBUG)   Slog.d(TAG,""String_Node_Str"" + msg.what + ""String_Node_Str"");
switch (msg.what) {
case MSG_WRITE_CONFIG:
{
      handleWriteConfigFile();
    }
  break;
case MSG_REPORT_IDLE_ON:
case MSG_REPORT_IDLE_ON_LIGHT:
{
  EventLogTags.writeDeviceIdleOnStart();
  final boolean deepChanged;
  final boolean lightChanged;
  if (msg.what == MSG_REPORT_IDLE_ON) {
    deepChanged=mLocalPowerManager.setDeviceIdleMode(true);
    lightChanged=mLocalPowerManager.setLightDeviceIdleMode(false);
  }
 else {
    deepChanged=mLocalPowerManager.setDeviceIdleMode(false);
    lightChanged=mLocalPowerManager.setLightDeviceIdleMode(true);
  }
  try {
    mNetworkPolicyManager.setDeviceIdleMode(true);
    mBatteryStats.noteDeviceIdleMode(msg.what == MSG_REPORT_IDLE_ON ? BatteryStats.DEVICE_IDLE_MODE_DEEP : BatteryStats.DEVICE_IDLE_MODE_LIGHT,null,Process.myUid());
  }
 catch (  RemoteException e) {
  }
  if (deepChanged) {
    getContext().sendBroadcastAsUser(mIdleIntent,UserHandle.ALL);
  }
  if (lightChanged) {
    getContext().sendBroadcastAsUser(mLightIdleIntent,UserHandle.ALL);
  }
  EventLogTags.writeDeviceIdleOnComplete();
}
break;
case MSG_REPORT_IDLE_OFF:
{
EventLogTags.writeDeviceIdleOffStart(""String_Node_Str"");
final boolean deepChanged=mLocalPowerManager.setDeviceIdleMode(false);
final boolean lightChanged=mLocalPowerManager.setLightDeviceIdleMode(false);
try {
mNetworkPolicyManager.setDeviceIdleMode(false);
mBatteryStats.noteDeviceIdleMode(BatteryStats.DEVICE_IDLE_MODE_OFF,null,Process.myUid());
}
 catch (RemoteException e) {
}
if (deepChanged) {
incActiveIdleOps();
getContext().sendOrderedBroadcastAsUser(mIdleIntent,UserHandle.ALL,null,mIdleStartedDoneReceiver,null,0,null,null);
}
if (lightChanged) {
incActiveIdleOps();
getContext().sendOrderedBroadcastAsUser(mLightIdleIntent,UserHandle.ALL,null,mIdleStartedDoneReceiver,null,0,null,null);
}
decActiveIdleOps();
EventLogTags.writeDeviceIdleOffComplete();
}
break;
case MSG_REPORT_ACTIVE:
{
String activeReason=(String)msg.obj;
int activeUid=msg.arg1;
EventLogTags.writeDeviceIdleOffStart(activeReason != null ? activeReason : ""String_Node_Str"");
final boolean deepChanged=mLocalPowerManager.setDeviceIdleMode(false);
final boolean lightChanged=mLocalPowerManager.setLightDeviceIdleMode(false);
try {
mNetworkPolicyManager.setDeviceIdleMode(false);
mBatteryStats.noteDeviceIdleMode(BatteryStats.DEVICE_IDLE_MODE_OFF,activeReason,activeUid);
}
 catch (RemoteException e) {
}
if (deepChanged) {
getContext().sendBroadcastAsUser(mIdleIntent,UserHandle.ALL);
}
if (lightChanged) {
getContext().sendBroadcastAsUser(mLightIdleIntent,UserHandle.ALL);
}
EventLogTags.writeDeviceIdleOffComplete();
}
break;
case MSG_TEMP_APP_WHITELIST_TIMEOUT:
{
int uid=msg.arg1;
checkTempAppWhitelistTimeout(uid);
}
break;
case MSG_REPORT_MAINTENANCE_ACTIVITY:
{
boolean active=(msg.arg1 == 1);
final int size=mMaintenanceActivityListeners.beginBroadcast();
try {
for (int i=0; i < size; i++) {
try {
mMaintenanceActivityListeners.getBroadcastItem(i).onMaintenanceActivityChanged(active);
}
 catch (RemoteException ignored) {
}
}
}
  finally {
mMaintenanceActivityListeners.finishBroadcast();
}
}
break;
case MSG_FINISH_IDLE_OP:
{
decActiveIdleOps();
}
break;
}
}",0.9913553565915406
192358,"@Override public void onAlarm(){
synchronized (DeviceIdleController.this) {
    exitMaintenanceEarlyIfNeededLocked();
  }
}","@Override public void onAlarm(){
synchronized (DeviceIdleController.this) {
    stepIdleStateLocked(""String_Node_Str"");
  }
}",0.7983870967741935
192359,"@Override public void run(){
  updateAnimators();
}","@Override public void run(){
  updateAnimators();
  setPosition(mLastPosition);
}",0.7727272727272727
192360,"public void setPosition(float position){
  if (mFirstPageAnimator == null)   return;
  if (mOnKeyguard) {
    return;
  }
  if (mOnFirstPage && mAllowFancy) {
    mQuickQsPanel.setAlpha(1);
    mFirstPageAnimator.setPosition(position);
    mFirstPageDelayedAnimator.setPosition(position);
    mTranslationXAnimator.setPosition(position);
    mTranslationYAnimator.setPosition(position);
    mLastRowAnimator.setPosition(position);
  }
 else {
    mNonfirstPageAnimator.setPosition(position);
  }
}","public void setPosition(float position){
  if (mFirstPageAnimator == null)   return;
  if (mOnKeyguard) {
    return;
  }
  mLastPosition=position;
  if (mOnFirstPage && mAllowFancy) {
    mQuickQsPanel.setAlpha(1);
    mFirstPageAnimator.setPosition(position);
    mFirstPageDelayedAnimator.setPosition(position);
    mTranslationXAnimator.setPosition(position);
    mTranslationYAnimator.setPosition(position);
    mLastRowAnimator.setPosition(position);
  }
 else {
    mNonfirstPageAnimator.setPosition(position);
  }
}",0.9745098039215686
192361,"private void clearAnimationState(){
  final int N=mAllViews.size();
  mQuickQsPanel.setAlpha(0);
  mQuickQsPanel.setVisibility(View.INVISIBLE);
  for (int i=0; i < N; i++) {
    View v=mAllViews.get(i);
    v.setAlpha(1);
    v.setTranslationX(1);
    v.setTranslationY(1);
  }
  final int N2=mTopFiveQs.size();
  for (int i=0; i < N2; i++) {
    mTopFiveQs.get(i).setVisibility(View.VISIBLE);
  }
}","private void clearAnimationState(){
  final int N=mAllViews.size();
  mQuickQsPanel.setAlpha(0);
  mQuickQsPanel.setVisibility(View.VISIBLE);
  for (int i=0; i < N; i++) {
    View v=mAllViews.get(i);
    v.setAlpha(1);
    v.setTranslationX(1);
    v.setTranslationY(1);
  }
  final int N2=mTopFiveQs.size();
  for (int i=0; i < N2; i++) {
    mTopFiveQs.get(i).setVisibility(View.VISIBLE);
  }
}",0.9974874371859296
192362,"/** 
 * Disable additional status bar features. Pass the bitwise-or of the DISABLE2_* flags. To re-enable everything, pass   {@link #DISABLE_NONE}. Warning: Only pass DISABLE2_* flags into this function, do not use DISABLE_* flags.
 */
@Override public void disable2(int what,IBinder token,String pkg){
  disableForUser(what,token,pkg,mCurrentUserId);
}","/** 
 * Disable additional status bar features. Pass the bitwise-or of the DISABLE2_* flags. To re-enable everything, pass   {@link #DISABLE_NONE}. Warning: Only pass DISABLE2_* flags into this function, do not use DISABLE_* flags.
 */
@Override public void disable2(int what,IBinder token,String pkg){
  disable2ForUser(what,token,pkg,mCurrentUserId);
}",0.9985855728429984
192363,"/** 
 * Disable additional status bar features. Pass the bitwise-or of the DISABLE2_* flags. To re-enable everything, pass   {@link #DISABLE_NONE}. Warning: Only pass DISABLE2_* flags into this function, do not use DISABLE_* flags.
 */
@Override public void disable2(int what,IBinder token,String pkg){
  disableForUser(what,token,pkg,mCurrentUserId);
}","/** 
 * Disable additional status bar features. Pass the bitwise-or of the DISABLE2_* flags. To re-enable everything, pass   {@link #DISABLE_NONE}. Warning: Only pass DISABLE2_* flags into this function, do not use DISABLE_* flags.
 */
@Override public void disable2(int what,IBinder token,String pkg){
  disable2ForUser(what,token,pkg,mCurrentUserId);
}",0.9985855728429984
192364,"boolean matches(byte[] packet,int length){
  if (length != mPacket.limit())   return false;
  ByteBuffer a=ByteBuffer.wrap(packet);
  ByteBuffer b=mPacket;
  for (  Pair<Integer,Integer> nonLifetime : mNonLifetimes) {
    a.clear();
    b.clear();
    a.position(nonLifetime.first);
    b.position(nonLifetime.first);
    a.limit(nonLifetime.first + nonLifetime.second);
    b.limit(nonLifetime.first + nonLifetime.second);
    if (a.compareTo(b) != 0)     return false;
  }
  return true;
}","boolean matches(byte[] packet,int length){
  if (length != mPacket.capacity())   return false;
  byte[] referencePacket=mPacket.array();
  for (  Pair<Integer,Integer> nonLifetime : mNonLifetimes) {
    for (int i=nonLifetime.first; i < (nonLifetime.first + nonLifetime.second); i++) {
      if (packet[i] != referencePacket[i])       return false;
    }
  }
  return true;
}",0.4757505773672055
192365,"@GuardedBy(""String_Node_Str"") long generateFilterLocked(ApfGenerator gen) throws IllegalInstructionException {
  String nextFilterLabel=""String_Node_Str"" + getUniqueNumberLocked();
  gen.addLoadFromMemory(Register.R0,gen.PACKET_SIZE_MEMORY_SLOT);
  gen.addJumpIfR0NotEquals(mPacket.limit(),nextFilterLabel);
  int filterLifetime=(int)(currentLifetime() / FRACTION_OF_LIFETIME_TO_FILTER);
  gen.addLoadFromMemory(Register.R0,gen.FILTER_AGE_MEMORY_SLOT);
  gen.addJumpIfR0GreaterThan(filterLifetime,nextFilterLabel);
  for (int i=0; i < mNonLifetimes.size(); i++) {
    Pair<Integer,Integer> nonLifetime=mNonLifetimes.get(i);
    if (nonLifetime.second != 0) {
      gen.addLoadImmediate(Register.R0,nonLifetime.first);
      gen.addJumpIfBytesNotEqual(Register.R0,Arrays.copyOfRange(mPacket.array(),nonLifetime.first,nonLifetime.first + nonLifetime.second),nextFilterLabel);
    }
    if ((i + 1) < mNonLifetimes.size()) {
      Pair<Integer,Integer> nextNonLifetime=mNonLifetimes.get(i + 1);
      int offset=nonLifetime.first + nonLifetime.second;
      if (offset == ICMP6_RA_CHECKSUM_OFFSET) {
        continue;
      }
      int length=nextNonLifetime.first - offset;
switch (length) {
case 4:
        gen.addLoad32(Register.R0,offset);
      break;
case 2:
    gen.addLoad16(Register.R0,offset);
  break;
default :
throw new IllegalStateException(""String_Node_Str"" + length);
}
gen.addJumpIfR0LessThan(filterLifetime,nextFilterLabel);
}
}
gen.addJump(gen.DROP_LABEL);
gen.defineLabel(nextFilterLabel);
return filterLifetime;
}","@GuardedBy(""String_Node_Str"") long generateFilterLocked(ApfGenerator gen) throws IllegalInstructionException {
  String nextFilterLabel=""String_Node_Str"" + getUniqueNumberLocked();
  gen.addLoadFromMemory(Register.R0,gen.PACKET_SIZE_MEMORY_SLOT);
  gen.addJumpIfR0NotEquals(mPacket.capacity(),nextFilterLabel);
  int filterLifetime=(int)(currentLifetime() / FRACTION_OF_LIFETIME_TO_FILTER);
  gen.addLoadFromMemory(Register.R0,gen.FILTER_AGE_MEMORY_SLOT);
  gen.addJumpIfR0GreaterThan(filterLifetime,nextFilterLabel);
  for (int i=0; i < mNonLifetimes.size(); i++) {
    Pair<Integer,Integer> nonLifetime=mNonLifetimes.get(i);
    if (nonLifetime.second != 0) {
      gen.addLoadImmediate(Register.R0,nonLifetime.first);
      gen.addJumpIfBytesNotEqual(Register.R0,Arrays.copyOfRange(mPacket.array(),nonLifetime.first,nonLifetime.first + nonLifetime.second),nextFilterLabel);
    }
    if ((i + 1) < mNonLifetimes.size()) {
      Pair<Integer,Integer> nextNonLifetime=mNonLifetimes.get(i + 1);
      int offset=nonLifetime.first + nonLifetime.second;
      if (offset == ICMP6_RA_CHECKSUM_OFFSET) {
        continue;
      }
      int length=nextNonLifetime.first - offset;
switch (length) {
case 4:
        gen.addLoad32(Register.R0,offset);
      break;
case 2:
    gen.addLoad16(Register.R0,offset);
  break;
default :
throw new IllegalStateException(""String_Node_Str"" + length);
}
gen.addJumpIfR0LessThan(filterLifetime,nextFilterLabel);
}
}
gen.addJump(gen.DROP_LABEL);
gen.defineLabel(nextFilterLabel);
return filterLifetime;
}",0.995758564437194
192366,"static void dumpCommandHelp(PrintWriter pw){
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
}","static void dumpCommandHelp(PrintWriter pw){
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
}",0.953257790368272
192367,"static int onShellCommand(Shell shell,String cmd){
  if (cmd == null) {
    return shell.handleDefaultCommands(cmd);
  }
  PrintWriter pw=shell.getOutPrintWriter();
  PrintWriter err=shell.getErrPrintWriter();
  try {
switch (cmd) {
case ""String_Node_Str"":
{
        int res=shell.parseUserPackageOp(true,err);
        if (res < 0) {
          return res;
        }
        String modeStr=shell.getNextArg();
        if (modeStr == null) {
          err.println(""String_Node_Str"");
          return -1;
        }
        final int mode;
switch (modeStr) {
case ""String_Node_Str"":
          mode=AppOpsManager.MODE_ALLOWED;
        break;
case ""String_Node_Str"":
      mode=AppOpsManager.MODE_ERRORED;
    break;
case ""String_Node_Str"":
  mode=AppOpsManager.MODE_IGNORED;
break;
case ""String_Node_Str"":
mode=AppOpsManager.MODE_DEFAULT;
break;
default :
err.println(""String_Node_Str"" + modeStr + ""String_Node_Str"");
return -1;
}
shell.mInterface.setMode(shell.op,shell.packageUid,shell.packageName,mode);
return 0;
}
case ""String_Node_Str"":
{
int res=shell.parseUserPackageOp(false,err);
if (res < 0) {
return res;
}
List<AppOpsManager.PackageOps> ops=shell.mInterface.getOpsForPackage(shell.packageUid,shell.packageName,shell.op != AppOpsManager.OP_NONE ? new int[]{shell.op} : null);
if (ops == null || ops.size() <= 0) {
pw.println(""String_Node_Str"");
return 0;
}
final long now=System.currentTimeMillis();
for (int i=0; i < ops.size(); i++) {
List<AppOpsManager.OpEntry> entries=ops.get(i).getOps();
for (int j=0; j < entries.size(); j++) {
AppOpsManager.OpEntry ent=entries.get(j);
pw.print(AppOpsManager.opToName(ent.getOp()));
pw.print(""String_Node_Str"");
switch (ent.getMode()) {
case AppOpsManager.MODE_ALLOWED:
pw.print(""String_Node_Str"");
break;
case AppOpsManager.MODE_IGNORED:
pw.print(""String_Node_Str"");
break;
case AppOpsManager.MODE_ERRORED:
pw.print(""String_Node_Str"");
break;
case AppOpsManager.MODE_DEFAULT:
pw.print(""String_Node_Str"");
break;
default :
pw.print(""String_Node_Str"");
pw.print(ent.getMode());
break;
}
if (ent.getTime() != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(now - ent.getTime(),pw);
pw.print(""String_Node_Str"");
}
if (ent.getRejectTime() != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(now - ent.getRejectTime(),pw);
pw.print(""String_Node_Str"");
}
if (ent.getDuration() == -1) {
pw.print(""String_Node_Str"");
}
 else if (ent.getDuration() != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(ent.getDuration(),pw);
}
pw.println();
}
}
return 0;
}
case ""String_Node_Str"":
{
String packageName=null;
int userId=UserHandle.USER_CURRENT;
for (String argument; (argument=shell.getNextArg()) != null; ) {
if (""String_Node_Str"".equals(argument)) {
String userStr=shell.getNextArgRequired();
userId=UserHandle.parseUserArg(userStr);
}
 else {
if (packageName == null) {
packageName=argument;
}
 else {
err.println(""String_Node_Str"" + argument);
return -1;
}
}
}
if (userId == UserHandle.USER_CURRENT) {
userId=ActivityManager.getCurrentUser();
}
shell.mInterface.resetAllModes(userId,packageName);
pw.print(""String_Node_Str"");
if (userId == UserHandle.USER_ALL) {
pw.print(""String_Node_Str"");
}
 else {
pw.print(""String_Node_Str"");
pw.print(userId);
}
pw.print(""String_Node_Str"");
if (packageName == null) {
pw.println(""String_Node_Str"");
}
 else {
pw.print(""String_Node_Str"");
pw.println(packageName);
}
return 0;
}
case ""String_Node_Str"":
{
shell.mInternal.mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,Binder.getCallingPid(),Binder.getCallingUid(),null);
long token=Binder.clearCallingIdentity();
try {
synchronized (shell.mInternal) {
shell.mInternal.mHandler.removeCallbacks(shell.mInternal.mWriteRunner);
}
shell.mInternal.writeState();
pw.println(""String_Node_Str"");
}
  finally {
Binder.restoreCallingIdentity(token);
}
return 0;
}
case ""String_Node_Str"":
{
shell.mInternal.mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,Binder.getCallingPid(),Binder.getCallingUid(),null);
long token=Binder.clearCallingIdentity();
try {
shell.mInternal.readState();
pw.println(""String_Node_Str"");
}
  finally {
Binder.restoreCallingIdentity(token);
}
return 0;
}
default :
return shell.handleDefaultCommands(cmd);
}
}
 catch (RemoteException e) {
pw.println(""String_Node_Str"" + e);
}
return -1;
}","static int onShellCommand(Shell shell,String cmd){
  if (cmd == null) {
    return shell.handleDefaultCommands(cmd);
  }
  PrintWriter pw=shell.getOutPrintWriter();
  PrintWriter err=shell.getErrPrintWriter();
  try {
switch (cmd) {
case ""String_Node_Str"":
{
        int res=shell.parseUserPackageOp(true,err);
        if (res < 0) {
          return res;
        }
        String modeStr=shell.getNextArg();
        if (modeStr == null) {
          err.println(""String_Node_Str"");
          return -1;
        }
        final int mode=shell.strModeToMode(modeStr,err);
        if (mode < 0) {
          return -1;
        }
        shell.mInterface.setMode(shell.op,shell.packageUid,shell.packageName,mode);
        return 0;
      }
case ""String_Node_Str"":
{
      int res=shell.parseUserPackageOp(false,err);
      if (res < 0) {
        return res;
      }
      List<AppOpsManager.PackageOps> ops=shell.mInterface.getOpsForPackage(shell.packageUid,shell.packageName,shell.op != AppOpsManager.OP_NONE ? new int[]{shell.op} : null);
      if (ops == null || ops.size() <= 0) {
        pw.println(""String_Node_Str"");
        return 0;
      }
      final long now=System.currentTimeMillis();
      for (int i=0; i < ops.size(); i++) {
        List<AppOpsManager.OpEntry> entries=ops.get(i).getOps();
        for (int j=0; j < entries.size(); j++) {
          AppOpsManager.OpEntry ent=entries.get(j);
          pw.print(AppOpsManager.opToName(ent.getOp()));
          pw.print(""String_Node_Str"");
switch (ent.getMode()) {
case AppOpsManager.MODE_ALLOWED:
            pw.print(""String_Node_Str"");
          break;
case AppOpsManager.MODE_IGNORED:
        pw.print(""String_Node_Str"");
      break;
case AppOpsManager.MODE_ERRORED:
    pw.print(""String_Node_Str"");
  break;
case AppOpsManager.MODE_DEFAULT:
pw.print(""String_Node_Str"");
break;
default :
pw.print(""String_Node_Str"");
pw.print(ent.getMode());
break;
}
if (ent.getTime() != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(now - ent.getTime(),pw);
pw.print(""String_Node_Str"");
}
if (ent.getRejectTime() != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(now - ent.getRejectTime(),pw);
pw.print(""String_Node_Str"");
}
if (ent.getDuration() == -1) {
pw.print(""String_Node_Str"");
}
 else if (ent.getDuration() != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(ent.getDuration(),pw);
}
pw.println();
}
}
return 0;
}
case ""String_Node_Str"":
{
int res=shell.parseUserOpMode(AppOpsManager.MODE_IGNORED,err);
if (res < 0) {
return res;
}
List<AppOpsManager.PackageOps> ops=shell.mInterface.getPackagesForOps(new int[]{shell.op});
if (ops == null || ops.size() <= 0) {
pw.println(""String_Node_Str"");
return 0;
}
for (int i=0; i < ops.size(); i++) {
final AppOpsManager.PackageOps pkg=ops.get(i);
boolean hasMatch=false;
final List<AppOpsManager.OpEntry> entries=ops.get(i).getOps();
for (int j=0; j < entries.size(); j++) {
AppOpsManager.OpEntry ent=entries.get(j);
if (ent.getOp() == shell.op && ent.getMode() == shell.mode) {
hasMatch=true;
break;
}
}
if (hasMatch) {
pw.println(pkg.getPackageName());
}
}
return 0;
}
case ""String_Node_Str"":
{
String packageName=null;
int userId=UserHandle.USER_CURRENT;
for (String argument; (argument=shell.getNextArg()) != null; ) {
if (""String_Node_Str"".equals(argument)) {
String userStr=shell.getNextArgRequired();
userId=UserHandle.parseUserArg(userStr);
}
 else {
if (packageName == null) {
packageName=argument;
}
 else {
err.println(""String_Node_Str"" + argument);
return -1;
}
}
}
if (userId == UserHandle.USER_CURRENT) {
userId=ActivityManager.getCurrentUser();
}
shell.mInterface.resetAllModes(userId,packageName);
pw.print(""String_Node_Str"");
if (userId == UserHandle.USER_ALL) {
pw.print(""String_Node_Str"");
}
 else {
pw.print(""String_Node_Str"");
pw.print(userId);
}
pw.print(""String_Node_Str"");
if (packageName == null) {
pw.println(""String_Node_Str"");
}
 else {
pw.print(""String_Node_Str"");
pw.println(packageName);
}
return 0;
}
case ""String_Node_Str"":
{
shell.mInternal.mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,Binder.getCallingPid(),Binder.getCallingUid(),null);
long token=Binder.clearCallingIdentity();
try {
synchronized (shell.mInternal) {
shell.mInternal.mHandler.removeCallbacks(shell.mInternal.mWriteRunner);
}
shell.mInternal.writeState();
pw.println(""String_Node_Str"");
}
  finally {
Binder.restoreCallingIdentity(token);
}
return 0;
}
case ""String_Node_Str"":
{
shell.mInternal.mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,Binder.getCallingPid(),Binder.getCallingUid(),null);
long token=Binder.clearCallingIdentity();
try {
shell.mInternal.readState();
pw.println(""String_Node_Str"");
}
  finally {
Binder.restoreCallingIdentity(token);
}
return 0;
}
default :
return shell.handleDefaultCommands(cmd);
}
}
 catch (RemoteException e) {
pw.println(""String_Node_Str"" + e);
}
return -1;
}",0.853423022675491
192368,"private ServiceLookupResult retrieveServiceLocked(Intent service,String resolvedType,String callingPackage,int callingPid,int callingUid,int userId,boolean createIfNeeded,boolean callingFromFg,boolean isBindExternal){
  ServiceRecord r=null;
  if (DEBUG_SERVICE)   Slog.v(TAG_SERVICE,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ callingUid);
  userId=mAm.mUserController.handleIncomingUser(callingPid,callingUid,userId,false,ActivityManagerService.ALLOW_NON_FULL_IN_PROFILE,""String_Node_Str"",null);
  ServiceMap smap=getServiceMap(userId);
  final ComponentName comp=service.getComponent();
  if (comp != null) {
    r=smap.mServicesByName.get(comp);
  }
  if (r == null && !isBindExternal) {
    Intent.FilterComparison filter=new Intent.FilterComparison(service);
    r=smap.mServicesByIntent.get(filter);
  }
  if (r != null && (r.serviceInfo.flags & ServiceInfo.FLAG_EXTERNAL_SERVICE) != 0 && !callingPackage.equals(r.packageName)) {
    r=null;
  }
  if (r == null) {
    try {
      ResolveInfo rInfo=AppGlobals.getPackageManager().resolveService(service,resolvedType,ActivityManagerService.STOCK_PM_FLAGS | PackageManager.MATCH_DEBUG_TRIAGED_MISSING,userId);
      ServiceInfo sInfo=rInfo != null ? rInfo.serviceInfo : null;
      if (sInfo == null) {
        Slog.w(TAG_SERVICE,""String_Node_Str"" + service + ""String_Node_Str""+ userId+ ""String_Node_Str"");
        return null;
      }
      ComponentName name=new ComponentName(sInfo.applicationInfo.packageName,sInfo.name);
      if ((sInfo.flags & ServiceInfo.FLAG_EXTERNAL_SERVICE) != 0) {
        if (isBindExternal) {
          if (!sInfo.exported) {
            throw new SecurityException(""String_Node_Str"" + name + ""String_Node_Str"");
          }
          if ((sInfo.flags & ServiceInfo.FLAG_ISOLATED_PROCESS) == 0) {
            throw new SecurityException(""String_Node_Str"" + name + ""String_Node_Str"");
          }
          ApplicationInfo aInfo=AppGlobals.getPackageManager().getApplicationInfo(callingPackage,ActivityManagerService.STOCK_PM_FLAGS,userId);
          if (aInfo == null) {
            throw new SecurityException(""String_Node_Str"" + ""String_Node_Str"" + callingPackage);
          }
          sInfo=new ServiceInfo(sInfo);
          sInfo.applicationInfo=new ApplicationInfo(sInfo.applicationInfo);
          sInfo.applicationInfo.packageName=aInfo.packageName;
          sInfo.applicationInfo.uid=aInfo.uid;
          name=new ComponentName(aInfo.packageName,name.getClassName());
          service.setComponent(name);
        }
 else {
          throw new SecurityException(""String_Node_Str"" + name);
        }
      }
 else       if (isBindExternal) {
        throw new SecurityException(""String_Node_Str"" + name + ""String_Node_Str"");
      }
      if (userId > 0) {
        if (mAm.isSingleton(sInfo.processName,sInfo.applicationInfo,sInfo.name,sInfo.flags) && mAm.isValidSingletonCall(callingUid,sInfo.applicationInfo.uid)) {
          userId=0;
          smap=getServiceMap(0);
        }
        sInfo=new ServiceInfo(sInfo);
        sInfo.applicationInfo=mAm.getAppInfoForUser(sInfo.applicationInfo,userId);
      }
      r=smap.mServicesByName.get(name);
      if (r == null && createIfNeeded) {
        final long token=Binder.clearCallingIdentity();
        try {
          final int allowed=mAm.checkAllowBackgroundLocked(sInfo.applicationInfo.uid,sInfo.packageName,callingPid);
          if (allowed != ActivityManager.APP_START_MODE_NORMAL) {
            Slog.w(TAG,""String_Node_Str"" + service + ""String_Node_Str""+ name.flattenToShortString()+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ callingPackage);
            return null;
          }
        }
  finally {
          Binder.restoreCallingIdentity(token);
        }
        Intent.FilterComparison filter=new Intent.FilterComparison(service.cloneFilter());
        ServiceRestarter res=new ServiceRestarter();
        BatteryStatsImpl.Uid.Pkg.Serv ss=null;
        BatteryStatsImpl stats=mAm.mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
          ss=stats.getServiceStatsLocked(sInfo.applicationInfo.uid,sInfo.packageName,sInfo.name);
        }
        r=new ServiceRecord(mAm,ss,name,filter,sInfo,callingFromFg,res);
        res.setService(r);
        smap.mServicesByName.put(name,r);
        smap.mServicesByIntent.put(filter,r);
        for (int i=mPendingServices.size() - 1; i >= 0; i--) {
          ServiceRecord pr=mPendingServices.get(i);
          if (pr.serviceInfo.applicationInfo.uid == sInfo.applicationInfo.uid && pr.name.equals(name)) {
            mPendingServices.remove(i);
          }
        }
      }
    }
 catch (    RemoteException ex) {
    }
  }
  if (r != null) {
    if (mAm.checkComponentPermission(r.permission,callingPid,callingUid,r.appInfo.uid,r.exported) != PackageManager.PERMISSION_GRANTED) {
      if (!r.exported) {
        Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ r.appInfo.uid);
        return new ServiceLookupResult(null,""String_Node_Str"" + r.appInfo.uid);
      }
      Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ r.permission);
      return new ServiceLookupResult(null,r.permission);
    }
 else     if (r.permission != null && callingPackage != null) {
      final int opCode=AppOpsManager.permissionToOpCode(r.permission);
      if (opCode != AppOpsManager.OP_NONE && mAm.mAppOpsService.noteOperation(opCode,callingUid,callingPackage) != AppOpsManager.MODE_ALLOWED) {
        Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ AppOpsManager.opToName(opCode));
        return null;
      }
    }
    if (!mAm.mIntentFirewall.checkService(r.name,service,callingUid,callingPid,resolvedType,r.appInfo)) {
      return null;
    }
    return new ServiceLookupResult(r,null);
  }
  return null;
}","private ServiceLookupResult retrieveServiceLocked(Intent service,String resolvedType,String callingPackage,int callingPid,int callingUid,int userId,boolean createIfNeeded,boolean callingFromFg,boolean isBindExternal){
  ServiceRecord r=null;
  if (DEBUG_SERVICE)   Slog.v(TAG_SERVICE,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ callingUid);
  userId=mAm.mUserController.handleIncomingUser(callingPid,callingUid,userId,false,ActivityManagerService.ALLOW_NON_FULL_IN_PROFILE,""String_Node_Str"",null);
  ServiceMap smap=getServiceMap(userId);
  final ComponentName comp=service.getComponent();
  if (comp != null) {
    r=smap.mServicesByName.get(comp);
  }
  if (r == null && !isBindExternal) {
    Intent.FilterComparison filter=new Intent.FilterComparison(service);
    r=smap.mServicesByIntent.get(filter);
  }
  if (r != null && (r.serviceInfo.flags & ServiceInfo.FLAG_EXTERNAL_SERVICE) != 0 && !callingPackage.equals(r.packageName)) {
    r=null;
  }
  if (r == null) {
    try {
      ResolveInfo rInfo=AppGlobals.getPackageManager().resolveService(service,resolvedType,ActivityManagerService.STOCK_PM_FLAGS | PackageManager.MATCH_DEBUG_TRIAGED_MISSING,userId);
      ServiceInfo sInfo=rInfo != null ? rInfo.serviceInfo : null;
      if (sInfo == null) {
        Slog.w(TAG_SERVICE,""String_Node_Str"" + service + ""String_Node_Str""+ userId+ ""String_Node_Str"");
        return null;
      }
      ComponentName name=new ComponentName(sInfo.applicationInfo.packageName,sInfo.name);
      if ((sInfo.flags & ServiceInfo.FLAG_EXTERNAL_SERVICE) != 0) {
        if (isBindExternal) {
          if (!sInfo.exported) {
            throw new SecurityException(""String_Node_Str"" + name + ""String_Node_Str"");
          }
          if ((sInfo.flags & ServiceInfo.FLAG_ISOLATED_PROCESS) == 0) {
            throw new SecurityException(""String_Node_Str"" + name + ""String_Node_Str"");
          }
          ApplicationInfo aInfo=AppGlobals.getPackageManager().getApplicationInfo(callingPackage,ActivityManagerService.STOCK_PM_FLAGS,userId);
          if (aInfo == null) {
            throw new SecurityException(""String_Node_Str"" + ""String_Node_Str"" + callingPackage);
          }
          sInfo=new ServiceInfo(sInfo);
          sInfo.applicationInfo=new ApplicationInfo(sInfo.applicationInfo);
          sInfo.applicationInfo.packageName=aInfo.packageName;
          sInfo.applicationInfo.uid=aInfo.uid;
          name=new ComponentName(aInfo.packageName,name.getClassName());
          service.setComponent(name);
        }
 else {
          throw new SecurityException(""String_Node_Str"" + name);
        }
      }
 else       if (isBindExternal) {
        throw new SecurityException(""String_Node_Str"" + name + ""String_Node_Str"");
      }
      if (userId > 0) {
        if (mAm.isSingleton(sInfo.processName,sInfo.applicationInfo,sInfo.name,sInfo.flags) && mAm.isValidSingletonCall(callingUid,sInfo.applicationInfo.uid)) {
          userId=0;
          smap=getServiceMap(0);
        }
        sInfo=new ServiceInfo(sInfo);
        sInfo.applicationInfo=mAm.getAppInfoForUser(sInfo.applicationInfo,userId);
      }
      r=smap.mServicesByName.get(name);
      if (r == null && createIfNeeded) {
        final long token=Binder.clearCallingIdentity();
        try {
          final int allowed=mAm.checkAllowBackgroundLocked(sInfo.applicationInfo.uid,sInfo.packageName,callingPid,true);
          if (allowed != ActivityManager.APP_START_MODE_NORMAL) {
            Slog.w(TAG,""String_Node_Str"" + service + ""String_Node_Str""+ name.flattenToShortString()+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ callingPackage);
            return null;
          }
        }
  finally {
          Binder.restoreCallingIdentity(token);
        }
        Intent.FilterComparison filter=new Intent.FilterComparison(service.cloneFilter());
        ServiceRestarter res=new ServiceRestarter();
        BatteryStatsImpl.Uid.Pkg.Serv ss=null;
        BatteryStatsImpl stats=mAm.mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
          ss=stats.getServiceStatsLocked(sInfo.applicationInfo.uid,sInfo.packageName,sInfo.name);
        }
        r=new ServiceRecord(mAm,ss,name,filter,sInfo,callingFromFg,res);
        res.setService(r);
        smap.mServicesByName.put(name,r);
        smap.mServicesByIntent.put(filter,r);
        for (int i=mPendingServices.size() - 1; i >= 0; i--) {
          ServiceRecord pr=mPendingServices.get(i);
          if (pr.serviceInfo.applicationInfo.uid == sInfo.applicationInfo.uid && pr.name.equals(name)) {
            mPendingServices.remove(i);
          }
        }
      }
    }
 catch (    RemoteException ex) {
    }
  }
  if (r != null) {
    if (mAm.checkComponentPermission(r.permission,callingPid,callingUid,r.appInfo.uid,r.exported) != PackageManager.PERMISSION_GRANTED) {
      if (!r.exported) {
        Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ r.appInfo.uid);
        return new ServiceLookupResult(null,""String_Node_Str"" + r.appInfo.uid);
      }
      Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ r.permission);
      return new ServiceLookupResult(null,r.permission);
    }
 else     if (r.permission != null && callingPackage != null) {
      final int opCode=AppOpsManager.permissionToOpCode(r.permission);
      if (opCode != AppOpsManager.OP_NONE && mAm.mAppOpsService.noteOperation(opCode,callingUid,callingPackage) != AppOpsManager.MODE_ALLOWED) {
        Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ AppOpsManager.opToName(opCode));
        return null;
      }
    }
    if (!mAm.mIntentFirewall.checkService(r.name,service,callingUid,callingPid,resolvedType,r.appInfo)) {
      return null;
    }
    return new ServiceLookupResult(r,null);
  }
  return null;
}",0.9995844760242666
192369,"public int getAppStartMode(int uid,String packageName){
synchronized (this) {
    return checkAllowBackgroundLocked(uid,packageName,-1);
  }
}","public int getAppStartMode(int uid,String packageName){
synchronized (this) {
    return checkAllowBackgroundLocked(uid,packageName,-1,true);
  }
}",0.9826989619377162
192370,"int checkAllowBackgroundLocked(int uid,String packageName,int callingPid){
  UidRecord uidRec=mActiveUids.get(uid);
  if (!mLenientBackgroundCheck) {
    if (uidRec == null || uidRec.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
      if (mAppOpsService.noteOperation(AppOpsManager.OP_RUN_IN_BACKGROUND,uid,packageName) != AppOpsManager.MODE_ALLOWED) {
        return ActivityManager.APP_START_MODE_DELAYED;
      }
    }
  }
 else   if (uidRec == null || uidRec.idle) {
    if (callingPid >= 0) {
      ProcessRecord proc;
synchronized (mPidsSelfLocked) {
        proc=mPidsSelfLocked.get(callingPid);
      }
      if (proc != null && proc.curProcState < ActivityManager.PROCESS_STATE_RECEIVER) {
        return ActivityManager.APP_START_MODE_NORMAL;
      }
    }
    if (mAppOpsService.noteOperation(AppOpsManager.OP_RUN_IN_BACKGROUND,uid,packageName) != AppOpsManager.MODE_ALLOWED) {
      return ActivityManager.APP_START_MODE_DELAYED;
    }
  }
  return ActivityManager.APP_START_MODE_NORMAL;
}","int checkAllowBackgroundLocked(int uid,String packageName,int callingPid,boolean allowWhenForeground){
  UidRecord uidRec=mActiveUids.get(uid);
  if (!mLenientBackgroundCheck) {
    if (!allowWhenForeground || uidRec == null || uidRec.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
      if (mAppOpsService.noteOperation(AppOpsManager.OP_RUN_IN_BACKGROUND,uid,packageName) != AppOpsManager.MODE_ALLOWED) {
        return ActivityManager.APP_START_MODE_DELAYED;
      }
    }
  }
 else   if (uidRec == null || uidRec.idle) {
    if (callingPid >= 0) {
      ProcessRecord proc;
synchronized (mPidsSelfLocked) {
        proc=mPidsSelfLocked.get(callingPid);
      }
      if (proc != null && proc.curProcState < ActivityManager.PROCESS_STATE_RECEIVER) {
        return ActivityManager.APP_START_MODE_NORMAL;
      }
    }
    if (mAppOpsService.noteOperation(AppOpsManager.OP_RUN_IN_BACKGROUND,uid,packageName) != AppOpsManager.MODE_ALLOWED) {
      return ActivityManager.APP_START_MODE_DELAYED;
    }
  }
  return ActivityManager.APP_START_MODE_NORMAL;
}",0.9752616555661276
192371,"private void deliverToRegisteredReceiverLocked(BroadcastRecord r,BroadcastFilter filter,boolean ordered,int index){
  boolean skip=false;
  if (filter.requiredPermission != null) {
    int perm=mService.checkComponentPermission(filter.requiredPermission,r.callingPid,r.callingUid,-1,true);
    if (perm != PackageManager.PERMISSION_GRANTED) {
      Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingPid+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ filter.requiredPermission+ ""String_Node_Str""+ filter);
      skip=true;
    }
 else {
      final int opCode=AppOpsManager.permissionToOpCode(filter.requiredPermission);
      if (opCode != AppOpsManager.OP_NONE && mService.mAppOpsService.noteOperation(opCode,r.callingUid,r.callerPackage) != AppOpsManager.MODE_ALLOWED) {
        Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingPid+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ AppOpsManager.permissionToOp(filter.requiredPermission)+ ""String_Node_Str""+ filter);
        skip=true;
      }
    }
  }
  if (!skip && r.requiredPermissions != null && r.requiredPermissions.length > 0) {
    for (int i=0; i < r.requiredPermissions.length; i++) {
      String requiredPermission=r.requiredPermissions[i];
      int perm=mService.checkComponentPermission(requiredPermission,filter.receiverList.pid,filter.receiverList.uid,-1,true);
      if (perm != PackageManager.PERMISSION_GRANTED) {
        Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ filter.receiverList.app+ ""String_Node_Str""+ filter.receiverList.pid+ ""String_Node_Str""+ filter.receiverList.uid+ ""String_Node_Str""+ ""String_Node_Str""+ requiredPermission+ ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str"");
        skip=true;
        break;
      }
      int appOp=AppOpsManager.permissionToOpCode(requiredPermission);
      if (appOp != AppOpsManager.OP_NONE && appOp != r.appOp && mService.mAppOpsService.noteOperation(appOp,filter.receiverList.uid,filter.packageName) != AppOpsManager.MODE_ALLOWED) {
        Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ filter.receiverList.app+ ""String_Node_Str""+ filter.receiverList.pid+ ""String_Node_Str""+ filter.receiverList.uid+ ""String_Node_Str""+ ""String_Node_Str""+ AppOpsManager.permissionToOp(requiredPermission)+ ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str"");
        skip=true;
        break;
      }
    }
  }
  if (!skip && (r.requiredPermissions == null || r.requiredPermissions.length == 0)) {
    int perm=mService.checkComponentPermission(null,filter.receiverList.pid,filter.receiverList.uid,-1,true);
    if (perm != PackageManager.PERMISSION_GRANTED) {
      Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ filter.receiverList.app+ ""String_Node_Str""+ filter.receiverList.pid+ ""String_Node_Str""+ filter.receiverList.uid+ ""String_Node_Str""+ ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str"");
      skip=true;
    }
  }
  if (!skip && r.appOp != AppOpsManager.OP_NONE && mService.mAppOpsService.noteOperation(r.appOp,filter.receiverList.uid,filter.packageName) != AppOpsManager.MODE_ALLOWED) {
    Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ filter.receiverList.app+ ""String_Node_Str""+ filter.receiverList.pid+ ""String_Node_Str""+ filter.receiverList.uid+ ""String_Node_Str""+ ""String_Node_Str""+ AppOpsManager.opToName(r.appOp)+ ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str"");
    skip=true;
  }
  if (!skip) {
    final int allowed=mService.checkAllowBackgroundLocked(filter.receiverList.uid,filter.packageName,-1);
    if (allowed == ActivityManager.APP_START_MODE_DISABLED) {
      Slog.w(TAG,""String_Node_Str"" + r.intent + ""String_Node_Str""+ filter.receiverList.app+ ""String_Node_Str""+ filter.receiverList.pid+ ""String_Node_Str""+ filter.receiverList.uid+ ""String_Node_Str"");
      skip=true;
    }
  }
  if (!mService.mIntentFirewall.checkBroadcast(r.intent,r.callingUid,r.callingPid,r.resolvedType,filter.receiverList.uid)) {
    skip=true;
  }
  if (!skip && (filter.receiverList.app == null || filter.receiverList.app.crashing)) {
    Slog.w(TAG,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r+ ""String_Node_Str""+ filter.receiverList+ ""String_Node_Str"");
    skip=true;
  }
  if (skip) {
    r.delivery[index]=BroadcastRecord.DELIVERY_SKIPPED;
    return;
  }
  if (Build.PERMISSIONS_REVIEW_REQUIRED) {
    if (!requestStartTargetPermissionsReviewIfNeededLocked(r,filter.packageName,filter.owningUserId)) {
      r.delivery[index]=BroadcastRecord.DELIVERY_SKIPPED;
      return;
    }
  }
  r.delivery[index]=BroadcastRecord.DELIVERY_DELIVERED;
  if (ordered) {
    r.receiver=filter.receiverList.receiver.asBinder();
    r.curFilter=filter;
    filter.receiverList.curBroadcast=r;
    r.state=BroadcastRecord.CALL_IN_RECEIVE;
    if (filter.receiverList.app != null) {
      r.curApp=filter.receiverList.app;
      filter.receiverList.app.curReceiver=r;
      mService.updateOomAdjLocked(r.curApp);
    }
  }
  try {
    if (DEBUG_BROADCAST_LIGHT)     Slog.i(TAG_BROADCAST,""String_Node_Str"" + filter + ""String_Node_Str""+ r);
    performReceiveLocked(filter.receiverList.app,filter.receiverList.receiver,new Intent(r.intent),r.resultCode,r.resultData,r.resultExtras,r.ordered,r.initialSticky,r.userId);
    if (ordered) {
      r.state=BroadcastRecord.CALL_DONE_RECEIVE;
    }
  }
 catch (  RemoteException e) {
    Slog.w(TAG,""String_Node_Str"" + r.intent,e);
    if (ordered) {
      r.receiver=null;
      r.curFilter=null;
      filter.receiverList.curBroadcast=null;
      if (filter.receiverList.app != null) {
        filter.receiverList.app.curReceiver=null;
      }
    }
  }
}","private void deliverToRegisteredReceiverLocked(BroadcastRecord r,BroadcastFilter filter,boolean ordered,int index){
  boolean skip=false;
  if (filter.requiredPermission != null) {
    int perm=mService.checkComponentPermission(filter.requiredPermission,r.callingPid,r.callingUid,-1,true);
    if (perm != PackageManager.PERMISSION_GRANTED) {
      Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingPid+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ filter.requiredPermission+ ""String_Node_Str""+ filter);
      skip=true;
    }
 else {
      final int opCode=AppOpsManager.permissionToOpCode(filter.requiredPermission);
      if (opCode != AppOpsManager.OP_NONE && mService.mAppOpsService.noteOperation(opCode,r.callingUid,r.callerPackage) != AppOpsManager.MODE_ALLOWED) {
        Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingPid+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ AppOpsManager.permissionToOp(filter.requiredPermission)+ ""String_Node_Str""+ filter);
        skip=true;
      }
    }
  }
  if (!skip && r.requiredPermissions != null && r.requiredPermissions.length > 0) {
    for (int i=0; i < r.requiredPermissions.length; i++) {
      String requiredPermission=r.requiredPermissions[i];
      int perm=mService.checkComponentPermission(requiredPermission,filter.receiverList.pid,filter.receiverList.uid,-1,true);
      if (perm != PackageManager.PERMISSION_GRANTED) {
        Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ filter.receiverList.app+ ""String_Node_Str""+ filter.receiverList.pid+ ""String_Node_Str""+ filter.receiverList.uid+ ""String_Node_Str""+ ""String_Node_Str""+ requiredPermission+ ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str"");
        skip=true;
        break;
      }
      int appOp=AppOpsManager.permissionToOpCode(requiredPermission);
      if (appOp != AppOpsManager.OP_NONE && appOp != r.appOp && mService.mAppOpsService.noteOperation(appOp,filter.receiverList.uid,filter.packageName) != AppOpsManager.MODE_ALLOWED) {
        Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ filter.receiverList.app+ ""String_Node_Str""+ filter.receiverList.pid+ ""String_Node_Str""+ filter.receiverList.uid+ ""String_Node_Str""+ ""String_Node_Str""+ AppOpsManager.permissionToOp(requiredPermission)+ ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str"");
        skip=true;
        break;
      }
    }
  }
  if (!skip && (r.requiredPermissions == null || r.requiredPermissions.length == 0)) {
    int perm=mService.checkComponentPermission(null,filter.receiverList.pid,filter.receiverList.uid,-1,true);
    if (perm != PackageManager.PERMISSION_GRANTED) {
      Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ filter.receiverList.app+ ""String_Node_Str""+ filter.receiverList.pid+ ""String_Node_Str""+ filter.receiverList.uid+ ""String_Node_Str""+ ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str"");
      skip=true;
    }
  }
  if (!skip && r.appOp != AppOpsManager.OP_NONE && mService.mAppOpsService.noteOperation(r.appOp,filter.receiverList.uid,filter.packageName) != AppOpsManager.MODE_ALLOWED) {
    Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ filter.receiverList.app+ ""String_Node_Str""+ filter.receiverList.pid+ ""String_Node_Str""+ filter.receiverList.uid+ ""String_Node_Str""+ ""String_Node_Str""+ AppOpsManager.opToName(r.appOp)+ ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str"");
    skip=true;
  }
  if (!skip) {
    final int allowed=mService.checkAllowBackgroundLocked(filter.receiverList.uid,filter.packageName,-1,true);
    if (allowed == ActivityManager.APP_START_MODE_DISABLED) {
      Slog.w(TAG,""String_Node_Str"" + r.intent + ""String_Node_Str""+ filter.receiverList.app+ ""String_Node_Str""+ filter.receiverList.pid+ ""String_Node_Str""+ filter.receiverList.uid+ ""String_Node_Str"");
      skip=true;
    }
  }
  if (!mService.mIntentFirewall.checkBroadcast(r.intent,r.callingUid,r.callingPid,r.resolvedType,filter.receiverList.uid)) {
    skip=true;
  }
  if (!skip && (filter.receiverList.app == null || filter.receiverList.app.crashing)) {
    Slog.w(TAG,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r+ ""String_Node_Str""+ filter.receiverList+ ""String_Node_Str"");
    skip=true;
  }
  if (skip) {
    r.delivery[index]=BroadcastRecord.DELIVERY_SKIPPED;
    return;
  }
  if (Build.PERMISSIONS_REVIEW_REQUIRED) {
    if (!requestStartTargetPermissionsReviewIfNeededLocked(r,filter.packageName,filter.owningUserId)) {
      r.delivery[index]=BroadcastRecord.DELIVERY_SKIPPED;
      return;
    }
  }
  r.delivery[index]=BroadcastRecord.DELIVERY_DELIVERED;
  if (ordered) {
    r.receiver=filter.receiverList.receiver.asBinder();
    r.curFilter=filter;
    filter.receiverList.curBroadcast=r;
    r.state=BroadcastRecord.CALL_IN_RECEIVE;
    if (filter.receiverList.app != null) {
      r.curApp=filter.receiverList.app;
      filter.receiverList.app.curReceiver=r;
      mService.updateOomAdjLocked(r.curApp);
    }
  }
  try {
    if (DEBUG_BROADCAST_LIGHT)     Slog.i(TAG_BROADCAST,""String_Node_Str"" + filter + ""String_Node_Str""+ r);
    performReceiveLocked(filter.receiverList.app,filter.receiverList.receiver,new Intent(r.intent),r.resultCode,r.resultData,r.resultExtras,r.ordered,r.initialSticky,r.userId);
    if (ordered) {
      r.state=BroadcastRecord.CALL_DONE_RECEIVE;
    }
  }
 catch (  RemoteException e) {
    Slog.w(TAG,""String_Node_Str"" + r.intent,e);
    if (ordered) {
      r.receiver=null;
      r.curFilter=null;
      filter.receiverList.curBroadcast=null;
      if (filter.receiverList.app != null) {
        filter.receiverList.app.curReceiver=null;
      }
    }
  }
}",0.9995799378307988
192372,"final void processNextBroadcast(boolean fromMsg){
synchronized (mService) {
    BroadcastRecord r;
    if (DEBUG_BROADCAST)     Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ mParallelBroadcasts.size()+ ""String_Node_Str""+ mOrderedBroadcasts.size()+ ""String_Node_Str"");
    mService.updateCpuStats();
    if (fromMsg) {
      mBroadcastsScheduled=false;
    }
    while (mParallelBroadcasts.size() > 0) {
      r=mParallelBroadcasts.remove(0);
      r.dispatchTime=SystemClock.uptimeMillis();
      r.dispatchClockTime=System.currentTimeMillis();
      final int N=r.receivers.size();
      if (DEBUG_BROADCAST_LIGHT)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r);
      for (int i=0; i < N; i++) {
        Object target=r.receivers.get(i);
        if (DEBUG_BROADCAST)         Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ target+ ""String_Node_Str""+ r);
        deliverToRegisteredReceiverLocked(r,(BroadcastFilter)target,false,i);
      }
      addBroadcastToHistoryLocked(r);
      if (DEBUG_BROADCAST_LIGHT)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r);
    }
    if (mPendingBroadcast != null) {
      if (DEBUG_BROADCAST_LIGHT)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ mPendingBroadcast.curApp);
      boolean isDead;
synchronized (mService.mPidsSelfLocked) {
        ProcessRecord proc=mService.mPidsSelfLocked.get(mPendingBroadcast.curApp.pid);
        isDead=proc == null || proc.crashing;
      }
      if (!isDead) {
        return;
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ mPendingBroadcast.curApp+ ""String_Node_Str"");
        mPendingBroadcast.state=BroadcastRecord.IDLE;
        mPendingBroadcast.nextReceiver=mPendingBroadcastRecvIndex;
        mPendingBroadcast=null;
      }
    }
    boolean looped=false;
    do {
      if (mOrderedBroadcasts.size() == 0) {
        mService.scheduleAppGcsLocked();
        if (looped) {
          mService.updateOomAdjLocked();
        }
        return;
      }
      r=mOrderedBroadcasts.get(0);
      boolean forceReceive=false;
      int numReceivers=(r.receivers != null) ? r.receivers.size() : 0;
      if (mService.mProcessesReady && r.dispatchTime > 0) {
        long now=SystemClock.uptimeMillis();
        if ((numReceivers > 0) && (now > r.dispatchTime + (2 * mTimeoutPeriod * numReceivers))) {
          Slog.w(TAG,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ ""String_Node_Str""+ now+ ""String_Node_Str""+ r.dispatchTime+ ""String_Node_Str""+ r.receiverTime+ ""String_Node_Str""+ r.intent+ ""String_Node_Str""+ numReceivers+ ""String_Node_Str""+ r.nextReceiver+ ""String_Node_Str""+ r.state);
          broadcastTimeoutLocked(false);
          forceReceive=true;
          r.state=BroadcastRecord.IDLE;
        }
      }
      if (r.state != BroadcastRecord.IDLE) {
        if (DEBUG_BROADCAST)         Slog.d(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r.state+ ""String_Node_Str"");
        return;
      }
      if (r.receivers == null || r.nextReceiver >= numReceivers || r.resultAbort || forceReceive) {
        if (r.resultTo != null) {
          try {
            if (DEBUG_BROADCAST)             Slog.i(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r.intent.getAction()+ ""String_Node_Str""+ r.callerApp);
            performReceiveLocked(r.callerApp,r.resultTo,new Intent(r.intent),r.resultCode,r.resultData,r.resultExtras,false,false,r.userId);
            r.resultTo=null;
          }
 catch (          RemoteException e) {
            r.resultTo=null;
            Slog.w(TAG,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r.intent,e);
          }
        }
        if (DEBUG_BROADCAST)         Slog.v(TAG_BROADCAST,""String_Node_Str"");
        cancelBroadcastTimeoutLocked();
        if (DEBUG_BROADCAST_LIGHT)         Slog.v(TAG_BROADCAST,""String_Node_Str"" + r);
        addBroadcastToHistoryLocked(r);
        mOrderedBroadcasts.remove(0);
        r=null;
        looped=true;
        continue;
      }
    }
 while (r == null);
    int recIdx=r.nextReceiver++;
    r.receiverTime=SystemClock.uptimeMillis();
    if (recIdx == 0) {
      r.dispatchTime=r.receiverTime;
      r.dispatchClockTime=System.currentTimeMillis();
      if (DEBUG_BROADCAST_LIGHT)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r);
    }
    if (!mPendingBroadcastTimeoutMessage) {
      long timeoutTime=r.receiverTime + mTimeoutPeriod;
      if (DEBUG_BROADCAST)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r+ ""String_Node_Str""+ timeoutTime);
      setBroadcastTimeoutLocked(timeoutTime);
    }
    final BroadcastOptions brOptions=r.options;
    final Object nextReceiver=r.receivers.get(recIdx);
    if (nextReceiver instanceof BroadcastFilter) {
      BroadcastFilter filter=(BroadcastFilter)nextReceiver;
      if (DEBUG_BROADCAST)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ filter+ ""String_Node_Str""+ r);
      deliverToRegisteredReceiverLocked(r,filter,r.ordered,recIdx);
      if (r.receiver == null || !r.ordered) {
        if (DEBUG_BROADCAST)         Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r.ordered+ ""String_Node_Str""+ r.receiver);
        r.state=BroadcastRecord.IDLE;
        scheduleBroadcastsLocked();
      }
 else {
        if (brOptions != null && brOptions.getTemporaryAppWhitelistDuration() > 0) {
          scheduleTempWhitelistLocked(filter.owningUid,brOptions.getTemporaryAppWhitelistDuration(),r);
        }
      }
      return;
    }
    ResolveInfo info=(ResolveInfo)nextReceiver;
    ComponentName component=new ComponentName(info.activityInfo.applicationInfo.packageName,info.activityInfo.name);
    boolean skip=false;
    if (brOptions != null && (info.activityInfo.applicationInfo.targetSdkVersion < brOptions.getMinManifestReceiverApiLevel() || info.activityInfo.applicationInfo.targetSdkVersion > brOptions.getMaxManifestReceiverApiLevel())) {
      skip=true;
    }
    int perm=mService.checkComponentPermission(info.activityInfo.permission,r.callingPid,r.callingUid,info.activityInfo.applicationInfo.uid,info.activityInfo.exported);
    if (!skip && perm != PackageManager.PERMISSION_GRANTED) {
      if (!info.activityInfo.exported) {
        Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingPid+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ info.activityInfo.applicationInfo.uid+ ""String_Node_Str""+ component.flattenToShortString());
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingPid+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ info.activityInfo.permission+ ""String_Node_Str""+ component.flattenToShortString());
      }
      skip=true;
    }
 else     if (!skip && info.activityInfo.permission != null) {
      final int opCode=AppOpsManager.permissionToOpCode(info.activityInfo.permission);
      if (opCode != AppOpsManager.OP_NONE && mService.mAppOpsService.noteOperation(opCode,r.callingUid,r.callerPackage) != AppOpsManager.MODE_ALLOWED) {
        Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingPid+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ AppOpsManager.permissionToOp(info.activityInfo.permission)+ ""String_Node_Str""+ component.flattenToShortString());
        skip=true;
      }
    }
    if (!skip && info.activityInfo.applicationInfo.uid != Process.SYSTEM_UID && r.requiredPermissions != null && r.requiredPermissions.length > 0) {
      for (int i=0; i < r.requiredPermissions.length; i++) {
        String requiredPermission=r.requiredPermissions[i];
        try {
          perm=AppGlobals.getPackageManager().checkPermission(requiredPermission,info.activityInfo.applicationInfo.packageName,UserHandle.getUserId(info.activityInfo.applicationInfo.uid));
        }
 catch (        RemoteException e) {
          perm=PackageManager.PERMISSION_DENIED;
        }
        if (perm != PackageManager.PERMISSION_GRANTED) {
          Slog.w(TAG,""String_Node_Str"" + r.intent + ""String_Node_Str""+ component.flattenToShortString()+ ""String_Node_Str""+ requiredPermission+ ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str"");
          skip=true;
          break;
        }
        int appOp=AppOpsManager.permissionToOpCode(requiredPermission);
        if (appOp != AppOpsManager.OP_NONE && appOp != r.appOp && mService.mAppOpsService.noteOperation(appOp,info.activityInfo.applicationInfo.uid,info.activityInfo.packageName) != AppOpsManager.MODE_ALLOWED) {
          Slog.w(TAG,""String_Node_Str"" + r.intent + ""String_Node_Str""+ component.flattenToShortString()+ ""String_Node_Str""+ AppOpsManager.permissionToOp(requiredPermission)+ ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str"");
          skip=true;
          break;
        }
      }
    }
    if (!skip && r.appOp != AppOpsManager.OP_NONE && mService.mAppOpsService.noteOperation(r.appOp,info.activityInfo.applicationInfo.uid,info.activityInfo.packageName) != AppOpsManager.MODE_ALLOWED) {
      Slog.w(TAG,""String_Node_Str"" + r.intent + ""String_Node_Str""+ component.flattenToShortString()+ ""String_Node_Str""+ AppOpsManager.opToName(r.appOp)+ ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str"");
      skip=true;
    }
    if (!skip) {
      skip=!mService.mIntentFirewall.checkBroadcast(r.intent,r.callingUid,r.callingPid,r.resolvedType,info.activityInfo.applicationInfo.uid);
    }
    boolean isSingleton=false;
    try {
      isSingleton=mService.isSingleton(info.activityInfo.processName,info.activityInfo.applicationInfo,info.activityInfo.name,info.activityInfo.flags);
    }
 catch (    SecurityException e) {
      Slog.w(TAG,e.getMessage());
      skip=true;
    }
    if ((info.activityInfo.flags & ActivityInfo.FLAG_SINGLE_USER) != 0) {
      if (ActivityManager.checkUidPermission(android.Manifest.permission.INTERACT_ACROSS_USERS,info.activityInfo.applicationInfo.uid) != PackageManager.PERMISSION_GRANTED) {
        Slog.w(TAG,""String_Node_Str"" + component.flattenToShortString() + ""String_Node_Str""+ android.Manifest.permission.INTERACT_ACROSS_USERS);
        skip=true;
      }
    }
    if (r.curApp != null && r.curApp.crashing) {
      Slog.w(TAG,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r+ ""String_Node_Str""+ r.curApp+ ""String_Node_Str"");
      skip=true;
    }
    if (!skip) {
      boolean isAvailable=false;
      try {
        isAvailable=AppGlobals.getPackageManager().isPackageAvailable(info.activityInfo.packageName,UserHandle.getUserId(info.activityInfo.applicationInfo.uid));
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + info.activityInfo.packageName,e);
      }
      if (!isAvailable) {
        if (DEBUG_BROADCAST)         Slog.v(TAG_BROADCAST,""String_Node_Str"" + info.activityInfo.packageName + ""String_Node_Str""+ info.activityInfo.applicationInfo.uid+ ""String_Node_Str"");
        skip=true;
      }
    }
    if (Build.PERMISSIONS_REVIEW_REQUIRED && !skip) {
      if (!requestStartTargetPermissionsReviewIfNeededLocked(r,info.activityInfo.packageName,UserHandle.getUserId(info.activityInfo.applicationInfo.uid))) {
        skip=true;
      }
    }
    final int receiverUid=info.activityInfo.applicationInfo.uid;
    if (r.callingUid != Process.SYSTEM_UID && isSingleton && mService.isValidSingletonCall(r.callingUid,receiverUid)) {
      info.activityInfo=mService.getActivityInfoForUser(info.activityInfo,0);
    }
    String targetProcess=info.activityInfo.processName;
    ProcessRecord app=mService.getProcessRecordLocked(targetProcess,info.activityInfo.applicationInfo.uid,false);
    if (!skip) {
      final int allowed=mService.checkAllowBackgroundLocked(info.activityInfo.applicationInfo.uid,info.activityInfo.packageName,-1);
      if (allowed != ActivityManager.APP_START_MODE_NORMAL) {
        if (allowed == ActivityManager.APP_START_MODE_DISABLED) {
          Slog.w(TAG,""String_Node_Str"" + r.intent + ""String_Node_Str""+ component.flattenToShortString());
          skip=true;
        }
        if (((r.intent.getFlags() & Intent.FLAG_RECEIVER_EXCLUDE_BACKGROUND) != 0) || (r.intent.getComponent() == null && r.intent.getPackage() == null && app == null && ((r.intent.getFlags() & Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND) == 0))) {
          Slog.w(TAG,""String_Node_Str"" + r.intent + ""String_Node_Str""+ component.flattenToShortString());
          skip=true;
        }
      }
    }
    if (skip) {
      if (DEBUG_BROADCAST)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r+ ""String_Node_Str"");
      r.delivery[recIdx]=BroadcastRecord.DELIVERY_SKIPPED;
      r.receiver=null;
      r.curFilter=null;
      r.state=BroadcastRecord.IDLE;
      scheduleBroadcastsLocked();
      return;
    }
    r.delivery[recIdx]=BroadcastRecord.DELIVERY_DELIVERED;
    r.state=BroadcastRecord.APP_RECEIVE;
    r.curComponent=component;
    r.curReceiver=info.activityInfo;
    if (DEBUG_MU && r.callingUid > UserHandle.PER_USER_RANGE) {
      Slog.v(TAG_MU,""String_Node_Str"" + info.activityInfo + ""String_Node_Str""+ r.callingUid+ ""String_Node_Str""+ info.activityInfo.applicationInfo.uid);
    }
    if (brOptions != null && brOptions.getTemporaryAppWhitelistDuration() > 0) {
      scheduleTempWhitelistLocked(receiverUid,brOptions.getTemporaryAppWhitelistDuration(),r);
    }
    try {
      AppGlobals.getPackageManager().setPackageStoppedState(r.curComponent.getPackageName(),false,UserHandle.getUserId(r.callingUid));
    }
 catch (    RemoteException e) {
    }
catch (    IllegalArgumentException e) {
      Slog.w(TAG,""String_Node_Str"" + r.curComponent.getPackageName() + ""String_Node_Str""+ e);
    }
    if (app != null && app.thread != null) {
      try {
        app.addPackage(info.activityInfo.packageName,info.activityInfo.applicationInfo.versionCode,mService.mProcessStats);
        processCurBroadcastLocked(r,app);
        return;
      }
 catch (      RemoteException e) {
        Slog.w(TAG,""String_Node_Str"" + r.curComponent,e);
      }
catch (      RuntimeException e) {
        Slog.wtf(TAG,""String_Node_Str"" + r.curComponent + ""String_Node_Str""+ r.intent,e);
        logBroadcastReceiverDiscardLocked(r);
        finishReceiverLocked(r,r.resultCode,r.resultData,r.resultExtras,r.resultAbort,false);
        scheduleBroadcastsLocked();
        r.state=BroadcastRecord.IDLE;
        return;
      }
    }
    if (DEBUG_BROADCAST)     Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ targetProcess+ ""String_Node_Str""+ r);
    if ((r.curApp=mService.startProcessLocked(targetProcess,info.activityInfo.applicationInfo,true,r.intent.getFlags() | Intent.FLAG_FROM_BACKGROUND,""String_Node_Str"",r.curComponent,(r.intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) != 0,false,false)) == null) {
      Slog.w(TAG,""String_Node_Str"" + info.activityInfo.applicationInfo.packageName + ""String_Node_Str""+ info.activityInfo.applicationInfo.uid+ ""String_Node_Str""+ r.intent+ ""String_Node_Str"");
      logBroadcastReceiverDiscardLocked(r);
      finishReceiverLocked(r,r.resultCode,r.resultData,r.resultExtras,r.resultAbort,false);
      scheduleBroadcastsLocked();
      r.state=BroadcastRecord.IDLE;
      return;
    }
    mPendingBroadcast=r;
    mPendingBroadcastRecvIndex=recIdx;
  }
}","final void processNextBroadcast(boolean fromMsg){
synchronized (mService) {
    BroadcastRecord r;
    if (DEBUG_BROADCAST)     Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ mParallelBroadcasts.size()+ ""String_Node_Str""+ mOrderedBroadcasts.size()+ ""String_Node_Str"");
    mService.updateCpuStats();
    if (fromMsg) {
      mBroadcastsScheduled=false;
    }
    while (mParallelBroadcasts.size() > 0) {
      r=mParallelBroadcasts.remove(0);
      r.dispatchTime=SystemClock.uptimeMillis();
      r.dispatchClockTime=System.currentTimeMillis();
      final int N=r.receivers.size();
      if (DEBUG_BROADCAST_LIGHT)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r);
      for (int i=0; i < N; i++) {
        Object target=r.receivers.get(i);
        if (DEBUG_BROADCAST)         Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ target+ ""String_Node_Str""+ r);
        deliverToRegisteredReceiverLocked(r,(BroadcastFilter)target,false,i);
      }
      addBroadcastToHistoryLocked(r);
      if (DEBUG_BROADCAST_LIGHT)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r);
    }
    if (mPendingBroadcast != null) {
      if (DEBUG_BROADCAST_LIGHT)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ mPendingBroadcast.curApp);
      boolean isDead;
synchronized (mService.mPidsSelfLocked) {
        ProcessRecord proc=mService.mPidsSelfLocked.get(mPendingBroadcast.curApp.pid);
        isDead=proc == null || proc.crashing;
      }
      if (!isDead) {
        return;
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ mPendingBroadcast.curApp+ ""String_Node_Str"");
        mPendingBroadcast.state=BroadcastRecord.IDLE;
        mPendingBroadcast.nextReceiver=mPendingBroadcastRecvIndex;
        mPendingBroadcast=null;
      }
    }
    boolean looped=false;
    do {
      if (mOrderedBroadcasts.size() == 0) {
        mService.scheduleAppGcsLocked();
        if (looped) {
          mService.updateOomAdjLocked();
        }
        return;
      }
      r=mOrderedBroadcasts.get(0);
      boolean forceReceive=false;
      int numReceivers=(r.receivers != null) ? r.receivers.size() : 0;
      if (mService.mProcessesReady && r.dispatchTime > 0) {
        long now=SystemClock.uptimeMillis();
        if ((numReceivers > 0) && (now > r.dispatchTime + (2 * mTimeoutPeriod * numReceivers))) {
          Slog.w(TAG,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ ""String_Node_Str""+ now+ ""String_Node_Str""+ r.dispatchTime+ ""String_Node_Str""+ r.receiverTime+ ""String_Node_Str""+ r.intent+ ""String_Node_Str""+ numReceivers+ ""String_Node_Str""+ r.nextReceiver+ ""String_Node_Str""+ r.state);
          broadcastTimeoutLocked(false);
          forceReceive=true;
          r.state=BroadcastRecord.IDLE;
        }
      }
      if (r.state != BroadcastRecord.IDLE) {
        if (DEBUG_BROADCAST)         Slog.d(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r.state+ ""String_Node_Str"");
        return;
      }
      if (r.receivers == null || r.nextReceiver >= numReceivers || r.resultAbort || forceReceive) {
        if (r.resultTo != null) {
          try {
            if (DEBUG_BROADCAST)             Slog.i(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r.intent.getAction()+ ""String_Node_Str""+ r.callerApp);
            performReceiveLocked(r.callerApp,r.resultTo,new Intent(r.intent),r.resultCode,r.resultData,r.resultExtras,false,false,r.userId);
            r.resultTo=null;
          }
 catch (          RemoteException e) {
            r.resultTo=null;
            Slog.w(TAG,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r.intent,e);
          }
        }
        if (DEBUG_BROADCAST)         Slog.v(TAG_BROADCAST,""String_Node_Str"");
        cancelBroadcastTimeoutLocked();
        if (DEBUG_BROADCAST_LIGHT)         Slog.v(TAG_BROADCAST,""String_Node_Str"" + r);
        addBroadcastToHistoryLocked(r);
        mOrderedBroadcasts.remove(0);
        r=null;
        looped=true;
        continue;
      }
    }
 while (r == null);
    int recIdx=r.nextReceiver++;
    r.receiverTime=SystemClock.uptimeMillis();
    if (recIdx == 0) {
      r.dispatchTime=r.receiverTime;
      r.dispatchClockTime=System.currentTimeMillis();
      if (DEBUG_BROADCAST_LIGHT)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r);
    }
    if (!mPendingBroadcastTimeoutMessage) {
      long timeoutTime=r.receiverTime + mTimeoutPeriod;
      if (DEBUG_BROADCAST)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r+ ""String_Node_Str""+ timeoutTime);
      setBroadcastTimeoutLocked(timeoutTime);
    }
    final BroadcastOptions brOptions=r.options;
    final Object nextReceiver=r.receivers.get(recIdx);
    if (nextReceiver instanceof BroadcastFilter) {
      BroadcastFilter filter=(BroadcastFilter)nextReceiver;
      if (DEBUG_BROADCAST)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ filter+ ""String_Node_Str""+ r);
      deliverToRegisteredReceiverLocked(r,filter,r.ordered,recIdx);
      if (r.receiver == null || !r.ordered) {
        if (DEBUG_BROADCAST)         Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r.ordered+ ""String_Node_Str""+ r.receiver);
        r.state=BroadcastRecord.IDLE;
        scheduleBroadcastsLocked();
      }
 else {
        if (brOptions != null && brOptions.getTemporaryAppWhitelistDuration() > 0) {
          scheduleTempWhitelistLocked(filter.owningUid,brOptions.getTemporaryAppWhitelistDuration(),r);
        }
      }
      return;
    }
    ResolveInfo info=(ResolveInfo)nextReceiver;
    ComponentName component=new ComponentName(info.activityInfo.applicationInfo.packageName,info.activityInfo.name);
    boolean skip=false;
    if (brOptions != null && (info.activityInfo.applicationInfo.targetSdkVersion < brOptions.getMinManifestReceiverApiLevel() || info.activityInfo.applicationInfo.targetSdkVersion > brOptions.getMaxManifestReceiverApiLevel())) {
      skip=true;
    }
    int perm=mService.checkComponentPermission(info.activityInfo.permission,r.callingPid,r.callingUid,info.activityInfo.applicationInfo.uid,info.activityInfo.exported);
    if (!skip && perm != PackageManager.PERMISSION_GRANTED) {
      if (!info.activityInfo.exported) {
        Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingPid+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ info.activityInfo.applicationInfo.uid+ ""String_Node_Str""+ component.flattenToShortString());
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingPid+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ info.activityInfo.permission+ ""String_Node_Str""+ component.flattenToShortString());
      }
      skip=true;
    }
 else     if (!skip && info.activityInfo.permission != null) {
      final int opCode=AppOpsManager.permissionToOpCode(info.activityInfo.permission);
      if (opCode != AppOpsManager.OP_NONE && mService.mAppOpsService.noteOperation(opCode,r.callingUid,r.callerPackage) != AppOpsManager.MODE_ALLOWED) {
        Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingPid+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ AppOpsManager.permissionToOp(info.activityInfo.permission)+ ""String_Node_Str""+ component.flattenToShortString());
        skip=true;
      }
    }
    if (!skip && info.activityInfo.applicationInfo.uid != Process.SYSTEM_UID && r.requiredPermissions != null && r.requiredPermissions.length > 0) {
      for (int i=0; i < r.requiredPermissions.length; i++) {
        String requiredPermission=r.requiredPermissions[i];
        try {
          perm=AppGlobals.getPackageManager().checkPermission(requiredPermission,info.activityInfo.applicationInfo.packageName,UserHandle.getUserId(info.activityInfo.applicationInfo.uid));
        }
 catch (        RemoteException e) {
          perm=PackageManager.PERMISSION_DENIED;
        }
        if (perm != PackageManager.PERMISSION_GRANTED) {
          Slog.w(TAG,""String_Node_Str"" + r.intent + ""String_Node_Str""+ component.flattenToShortString()+ ""String_Node_Str""+ requiredPermission+ ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str"");
          skip=true;
          break;
        }
        int appOp=AppOpsManager.permissionToOpCode(requiredPermission);
        if (appOp != AppOpsManager.OP_NONE && appOp != r.appOp && mService.mAppOpsService.noteOperation(appOp,info.activityInfo.applicationInfo.uid,info.activityInfo.packageName) != AppOpsManager.MODE_ALLOWED) {
          Slog.w(TAG,""String_Node_Str"" + r.intent + ""String_Node_Str""+ component.flattenToShortString()+ ""String_Node_Str""+ AppOpsManager.permissionToOp(requiredPermission)+ ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str"");
          skip=true;
          break;
        }
      }
    }
    if (!skip && r.appOp != AppOpsManager.OP_NONE && mService.mAppOpsService.noteOperation(r.appOp,info.activityInfo.applicationInfo.uid,info.activityInfo.packageName) != AppOpsManager.MODE_ALLOWED) {
      Slog.w(TAG,""String_Node_Str"" + r.intent + ""String_Node_Str""+ component.flattenToShortString()+ ""String_Node_Str""+ AppOpsManager.opToName(r.appOp)+ ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str"");
      skip=true;
    }
    if (!skip) {
      skip=!mService.mIntentFirewall.checkBroadcast(r.intent,r.callingUid,r.callingPid,r.resolvedType,info.activityInfo.applicationInfo.uid);
    }
    boolean isSingleton=false;
    try {
      isSingleton=mService.isSingleton(info.activityInfo.processName,info.activityInfo.applicationInfo,info.activityInfo.name,info.activityInfo.flags);
    }
 catch (    SecurityException e) {
      Slog.w(TAG,e.getMessage());
      skip=true;
    }
    if ((info.activityInfo.flags & ActivityInfo.FLAG_SINGLE_USER) != 0) {
      if (ActivityManager.checkUidPermission(android.Manifest.permission.INTERACT_ACROSS_USERS,info.activityInfo.applicationInfo.uid) != PackageManager.PERMISSION_GRANTED) {
        Slog.w(TAG,""String_Node_Str"" + component.flattenToShortString() + ""String_Node_Str""+ android.Manifest.permission.INTERACT_ACROSS_USERS);
        skip=true;
      }
    }
    if (r.curApp != null && r.curApp.crashing) {
      Slog.w(TAG,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r+ ""String_Node_Str""+ r.curApp+ ""String_Node_Str"");
      skip=true;
    }
    if (!skip) {
      boolean isAvailable=false;
      try {
        isAvailable=AppGlobals.getPackageManager().isPackageAvailable(info.activityInfo.packageName,UserHandle.getUserId(info.activityInfo.applicationInfo.uid));
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + info.activityInfo.packageName,e);
      }
      if (!isAvailable) {
        if (DEBUG_BROADCAST)         Slog.v(TAG_BROADCAST,""String_Node_Str"" + info.activityInfo.packageName + ""String_Node_Str""+ info.activityInfo.applicationInfo.uid+ ""String_Node_Str"");
        skip=true;
      }
    }
    if (Build.PERMISSIONS_REVIEW_REQUIRED && !skip) {
      if (!requestStartTargetPermissionsReviewIfNeededLocked(r,info.activityInfo.packageName,UserHandle.getUserId(info.activityInfo.applicationInfo.uid))) {
        skip=true;
      }
    }
    final int receiverUid=info.activityInfo.applicationInfo.uid;
    if (r.callingUid != Process.SYSTEM_UID && isSingleton && mService.isValidSingletonCall(r.callingUid,receiverUid)) {
      info.activityInfo=mService.getActivityInfoForUser(info.activityInfo,0);
    }
    String targetProcess=info.activityInfo.processName;
    ProcessRecord app=mService.getProcessRecordLocked(targetProcess,info.activityInfo.applicationInfo.uid,false);
    if (!skip) {
      final int allowed=mService.checkAllowBackgroundLocked(info.activityInfo.applicationInfo.uid,info.activityInfo.packageName,-1,false);
      if (allowed != ActivityManager.APP_START_MODE_NORMAL) {
        if (allowed == ActivityManager.APP_START_MODE_DISABLED) {
          Slog.w(TAG,""String_Node_Str"" + r.intent + ""String_Node_Str""+ component.flattenToShortString());
          skip=true;
        }
 else         if (((r.intent.getFlags() & Intent.FLAG_RECEIVER_EXCLUDE_BACKGROUND) != 0) || (r.intent.getComponent() == null && r.intent.getPackage() == null && ((r.intent.getFlags() & Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND) == 0))) {
          Slog.w(TAG,""String_Node_Str"" + r.intent + ""String_Node_Str""+ component.flattenToShortString());
          skip=true;
        }
      }
    }
    if (skip) {
      if (DEBUG_BROADCAST)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r+ ""String_Node_Str"");
      r.delivery[recIdx]=BroadcastRecord.DELIVERY_SKIPPED;
      r.receiver=null;
      r.curFilter=null;
      r.state=BroadcastRecord.IDLE;
      scheduleBroadcastsLocked();
      return;
    }
    r.delivery[recIdx]=BroadcastRecord.DELIVERY_DELIVERED;
    r.state=BroadcastRecord.APP_RECEIVE;
    r.curComponent=component;
    r.curReceiver=info.activityInfo;
    if (DEBUG_MU && r.callingUid > UserHandle.PER_USER_RANGE) {
      Slog.v(TAG_MU,""String_Node_Str"" + info.activityInfo + ""String_Node_Str""+ r.callingUid+ ""String_Node_Str""+ info.activityInfo.applicationInfo.uid);
    }
    if (brOptions != null && brOptions.getTemporaryAppWhitelistDuration() > 0) {
      scheduleTempWhitelistLocked(receiverUid,brOptions.getTemporaryAppWhitelistDuration(),r);
    }
    try {
      AppGlobals.getPackageManager().setPackageStoppedState(r.curComponent.getPackageName(),false,UserHandle.getUserId(r.callingUid));
    }
 catch (    RemoteException e) {
    }
catch (    IllegalArgumentException e) {
      Slog.w(TAG,""String_Node_Str"" + r.curComponent.getPackageName() + ""String_Node_Str""+ e);
    }
    if (app != null && app.thread != null) {
      try {
        app.addPackage(info.activityInfo.packageName,info.activityInfo.applicationInfo.versionCode,mService.mProcessStats);
        processCurBroadcastLocked(r,app);
        return;
      }
 catch (      RemoteException e) {
        Slog.w(TAG,""String_Node_Str"" + r.curComponent,e);
      }
catch (      RuntimeException e) {
        Slog.wtf(TAG,""String_Node_Str"" + r.curComponent + ""String_Node_Str""+ r.intent,e);
        logBroadcastReceiverDiscardLocked(r);
        finishReceiverLocked(r,r.resultCode,r.resultData,r.resultExtras,r.resultAbort,false);
        scheduleBroadcastsLocked();
        r.state=BroadcastRecord.IDLE;
        return;
      }
    }
    if (DEBUG_BROADCAST)     Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ targetProcess+ ""String_Node_Str""+ r);
    if ((r.curApp=mService.startProcessLocked(targetProcess,info.activityInfo.applicationInfo,true,r.intent.getFlags() | Intent.FLAG_FROM_BACKGROUND,""String_Node_Str"",r.curComponent,(r.intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) != 0,false,false)) == null) {
      Slog.w(TAG,""String_Node_Str"" + info.activityInfo.applicationInfo.packageName + ""String_Node_Str""+ info.activityInfo.applicationInfo.uid+ ""String_Node_Str""+ r.intent+ ""String_Node_Str"");
      logBroadcastReceiverDiscardLocked(r);
      finishReceiverLocked(r,r.resultCode,r.resultData,r.resultExtras,r.resultAbort,false);
      scheduleBroadcastsLocked();
      r.state=BroadcastRecord.IDLE;
      return;
    }
    mPendingBroadcast=r;
    mPendingBroadcastRecvIndex=recIdx;
  }
}",0.9991397164250438
192373,"static void dumpCommandHelp(PrintWriter pw){
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
}","static void dumpCommandHelp(PrintWriter pw){
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
  pw.println(""String_Node_Str"");
}",0.953257790368272
192374,"static int onShellCommand(Shell shell,String cmd){
  if (cmd == null) {
    return shell.handleDefaultCommands(cmd);
  }
  PrintWriter pw=shell.getOutPrintWriter();
  PrintWriter err=shell.getErrPrintWriter();
  try {
switch (cmd) {
case ""String_Node_Str"":
{
        int res=shell.parseUserPackageOp(true,err);
        if (res < 0) {
          return res;
        }
        String modeStr=shell.getNextArg();
        if (modeStr == null) {
          err.println(""String_Node_Str"");
          return -1;
        }
        final int mode;
switch (modeStr) {
case ""String_Node_Str"":
          mode=AppOpsManager.MODE_ALLOWED;
        break;
case ""String_Node_Str"":
      mode=AppOpsManager.MODE_ERRORED;
    break;
case ""String_Node_Str"":
  mode=AppOpsManager.MODE_IGNORED;
break;
case ""String_Node_Str"":
mode=AppOpsManager.MODE_DEFAULT;
break;
default :
err.println(""String_Node_Str"" + modeStr + ""String_Node_Str"");
return -1;
}
shell.mInterface.setMode(shell.op,shell.packageUid,shell.packageName,mode);
return 0;
}
case ""String_Node_Str"":
{
int res=shell.parseUserPackageOp(false,err);
if (res < 0) {
return res;
}
List<AppOpsManager.PackageOps> ops=shell.mInterface.getOpsForPackage(shell.packageUid,shell.packageName,shell.op != AppOpsManager.OP_NONE ? new int[]{shell.op} : null);
if (ops == null || ops.size() <= 0) {
pw.println(""String_Node_Str"");
return 0;
}
final long now=System.currentTimeMillis();
for (int i=0; i < ops.size(); i++) {
List<AppOpsManager.OpEntry> entries=ops.get(i).getOps();
for (int j=0; j < entries.size(); j++) {
AppOpsManager.OpEntry ent=entries.get(j);
pw.print(AppOpsManager.opToName(ent.getOp()));
pw.print(""String_Node_Str"");
switch (ent.getMode()) {
case AppOpsManager.MODE_ALLOWED:
pw.print(""String_Node_Str"");
break;
case AppOpsManager.MODE_IGNORED:
pw.print(""String_Node_Str"");
break;
case AppOpsManager.MODE_ERRORED:
pw.print(""String_Node_Str"");
break;
case AppOpsManager.MODE_DEFAULT:
pw.print(""String_Node_Str"");
break;
default :
pw.print(""String_Node_Str"");
pw.print(ent.getMode());
break;
}
if (ent.getTime() != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(now - ent.getTime(),pw);
pw.print(""String_Node_Str"");
}
if (ent.getRejectTime() != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(now - ent.getRejectTime(),pw);
pw.print(""String_Node_Str"");
}
if (ent.getDuration() == -1) {
pw.print(""String_Node_Str"");
}
 else if (ent.getDuration() != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(ent.getDuration(),pw);
}
pw.println();
}
}
return 0;
}
case ""String_Node_Str"":
{
String packageName=null;
int userId=UserHandle.USER_CURRENT;
for (String argument; (argument=shell.getNextArg()) != null; ) {
if (""String_Node_Str"".equals(argument)) {
String userStr=shell.getNextArgRequired();
userId=UserHandle.parseUserArg(userStr);
}
 else {
if (packageName == null) {
packageName=argument;
}
 else {
err.println(""String_Node_Str"" + argument);
return -1;
}
}
}
if (userId == UserHandle.USER_CURRENT) {
userId=ActivityManager.getCurrentUser();
}
shell.mInterface.resetAllModes(userId,packageName);
pw.print(""String_Node_Str"");
if (userId == UserHandle.USER_ALL) {
pw.print(""String_Node_Str"");
}
 else {
pw.print(""String_Node_Str"");
pw.print(userId);
}
pw.print(""String_Node_Str"");
if (packageName == null) {
pw.println(""String_Node_Str"");
}
 else {
pw.print(""String_Node_Str"");
pw.println(packageName);
}
return 0;
}
case ""String_Node_Str"":
{
shell.mInternal.mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,Binder.getCallingPid(),Binder.getCallingUid(),null);
long token=Binder.clearCallingIdentity();
try {
synchronized (shell.mInternal) {
shell.mInternal.mHandler.removeCallbacks(shell.mInternal.mWriteRunner);
}
shell.mInternal.writeState();
pw.println(""String_Node_Str"");
}
  finally {
Binder.restoreCallingIdentity(token);
}
return 0;
}
case ""String_Node_Str"":
{
shell.mInternal.mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,Binder.getCallingPid(),Binder.getCallingUid(),null);
long token=Binder.clearCallingIdentity();
try {
shell.mInternal.readState();
pw.println(""String_Node_Str"");
}
  finally {
Binder.restoreCallingIdentity(token);
}
return 0;
}
default :
return shell.handleDefaultCommands(cmd);
}
}
 catch (RemoteException e) {
pw.println(""String_Node_Str"" + e);
}
return -1;
}","static int onShellCommand(Shell shell,String cmd){
  if (cmd == null) {
    return shell.handleDefaultCommands(cmd);
  }
  PrintWriter pw=shell.getOutPrintWriter();
  PrintWriter err=shell.getErrPrintWriter();
  try {
switch (cmd) {
case ""String_Node_Str"":
{
        int res=shell.parseUserPackageOp(true,err);
        if (res < 0) {
          return res;
        }
        String modeStr=shell.getNextArg();
        if (modeStr == null) {
          err.println(""String_Node_Str"");
          return -1;
        }
        final int mode=shell.strModeToMode(modeStr,err);
        if (mode < 0) {
          return -1;
        }
        shell.mInterface.setMode(shell.op,shell.packageUid,shell.packageName,mode);
        return 0;
      }
case ""String_Node_Str"":
{
      int res=shell.parseUserPackageOp(false,err);
      if (res < 0) {
        return res;
      }
      List<AppOpsManager.PackageOps> ops=shell.mInterface.getOpsForPackage(shell.packageUid,shell.packageName,shell.op != AppOpsManager.OP_NONE ? new int[]{shell.op} : null);
      if (ops == null || ops.size() <= 0) {
        pw.println(""String_Node_Str"");
        return 0;
      }
      final long now=System.currentTimeMillis();
      for (int i=0; i < ops.size(); i++) {
        List<AppOpsManager.OpEntry> entries=ops.get(i).getOps();
        for (int j=0; j < entries.size(); j++) {
          AppOpsManager.OpEntry ent=entries.get(j);
          pw.print(AppOpsManager.opToName(ent.getOp()));
          pw.print(""String_Node_Str"");
switch (ent.getMode()) {
case AppOpsManager.MODE_ALLOWED:
            pw.print(""String_Node_Str"");
          break;
case AppOpsManager.MODE_IGNORED:
        pw.print(""String_Node_Str"");
      break;
case AppOpsManager.MODE_ERRORED:
    pw.print(""String_Node_Str"");
  break;
case AppOpsManager.MODE_DEFAULT:
pw.print(""String_Node_Str"");
break;
default :
pw.print(""String_Node_Str"");
pw.print(ent.getMode());
break;
}
if (ent.getTime() != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(now - ent.getTime(),pw);
pw.print(""String_Node_Str"");
}
if (ent.getRejectTime() != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(now - ent.getRejectTime(),pw);
pw.print(""String_Node_Str"");
}
if (ent.getDuration() == -1) {
pw.print(""String_Node_Str"");
}
 else if (ent.getDuration() != 0) {
pw.print(""String_Node_Str"");
TimeUtils.formatDuration(ent.getDuration(),pw);
}
pw.println();
}
}
return 0;
}
case ""String_Node_Str"":
{
int res=shell.parseUserOpMode(AppOpsManager.MODE_IGNORED,err);
if (res < 0) {
return res;
}
List<AppOpsManager.PackageOps> ops=shell.mInterface.getPackagesForOps(new int[]{shell.op});
if (ops == null || ops.size() <= 0) {
pw.println(""String_Node_Str"");
return 0;
}
for (int i=0; i < ops.size(); i++) {
final AppOpsManager.PackageOps pkg=ops.get(i);
boolean hasMatch=false;
final List<AppOpsManager.OpEntry> entries=ops.get(i).getOps();
for (int j=0; j < entries.size(); j++) {
AppOpsManager.OpEntry ent=entries.get(j);
if (ent.getOp() == shell.op && ent.getMode() == shell.mode) {
hasMatch=true;
break;
}
}
if (hasMatch) {
pw.println(pkg.getPackageName());
}
}
return 0;
}
case ""String_Node_Str"":
{
String packageName=null;
int userId=UserHandle.USER_CURRENT;
for (String argument; (argument=shell.getNextArg()) != null; ) {
if (""String_Node_Str"".equals(argument)) {
String userStr=shell.getNextArgRequired();
userId=UserHandle.parseUserArg(userStr);
}
 else {
if (packageName == null) {
packageName=argument;
}
 else {
err.println(""String_Node_Str"" + argument);
return -1;
}
}
}
if (userId == UserHandle.USER_CURRENT) {
userId=ActivityManager.getCurrentUser();
}
shell.mInterface.resetAllModes(userId,packageName);
pw.print(""String_Node_Str"");
if (userId == UserHandle.USER_ALL) {
pw.print(""String_Node_Str"");
}
 else {
pw.print(""String_Node_Str"");
pw.print(userId);
}
pw.print(""String_Node_Str"");
if (packageName == null) {
pw.println(""String_Node_Str"");
}
 else {
pw.print(""String_Node_Str"");
pw.println(packageName);
}
return 0;
}
case ""String_Node_Str"":
{
shell.mInternal.mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,Binder.getCallingPid(),Binder.getCallingUid(),null);
long token=Binder.clearCallingIdentity();
try {
synchronized (shell.mInternal) {
shell.mInternal.mHandler.removeCallbacks(shell.mInternal.mWriteRunner);
}
shell.mInternal.writeState();
pw.println(""String_Node_Str"");
}
  finally {
Binder.restoreCallingIdentity(token);
}
return 0;
}
case ""String_Node_Str"":
{
shell.mInternal.mContext.enforcePermission(android.Manifest.permission.UPDATE_APP_OPS_STATS,Binder.getCallingPid(),Binder.getCallingUid(),null);
long token=Binder.clearCallingIdentity();
try {
shell.mInternal.readState();
pw.println(""String_Node_Str"");
}
  finally {
Binder.restoreCallingIdentity(token);
}
return 0;
}
default :
return shell.handleDefaultCommands(cmd);
}
}
 catch (RemoteException e) {
pw.println(""String_Node_Str"" + e);
}
return -1;
}",0.853423022675491
192375,"private ServiceLookupResult retrieveServiceLocked(Intent service,String resolvedType,String callingPackage,int callingPid,int callingUid,int userId,boolean createIfNeeded,boolean callingFromFg,boolean isBindExternal){
  ServiceRecord r=null;
  if (DEBUG_SERVICE)   Slog.v(TAG_SERVICE,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ callingUid);
  userId=mAm.mUserController.handleIncomingUser(callingPid,callingUid,userId,false,ActivityManagerService.ALLOW_NON_FULL_IN_PROFILE,""String_Node_Str"",null);
  ServiceMap smap=getServiceMap(userId);
  final ComponentName comp=service.getComponent();
  if (comp != null) {
    r=smap.mServicesByName.get(comp);
  }
  if (r == null && !isBindExternal) {
    Intent.FilterComparison filter=new Intent.FilterComparison(service);
    r=smap.mServicesByIntent.get(filter);
  }
  if (r != null && (r.serviceInfo.flags & ServiceInfo.FLAG_EXTERNAL_SERVICE) != 0 && !callingPackage.equals(r.packageName)) {
    r=null;
  }
  if (r == null) {
    try {
      ResolveInfo rInfo=AppGlobals.getPackageManager().resolveService(service,resolvedType,ActivityManagerService.STOCK_PM_FLAGS | PackageManager.MATCH_DEBUG_TRIAGED_MISSING,userId);
      ServiceInfo sInfo=rInfo != null ? rInfo.serviceInfo : null;
      if (sInfo == null) {
        Slog.w(TAG_SERVICE,""String_Node_Str"" + service + ""String_Node_Str""+ userId+ ""String_Node_Str"");
        return null;
      }
      ComponentName name=new ComponentName(sInfo.applicationInfo.packageName,sInfo.name);
      if ((sInfo.flags & ServiceInfo.FLAG_EXTERNAL_SERVICE) != 0) {
        if (isBindExternal) {
          if (!sInfo.exported) {
            throw new SecurityException(""String_Node_Str"" + name + ""String_Node_Str"");
          }
          if ((sInfo.flags & ServiceInfo.FLAG_ISOLATED_PROCESS) == 0) {
            throw new SecurityException(""String_Node_Str"" + name + ""String_Node_Str"");
          }
          ApplicationInfo aInfo=AppGlobals.getPackageManager().getApplicationInfo(callingPackage,ActivityManagerService.STOCK_PM_FLAGS,userId);
          if (aInfo == null) {
            throw new SecurityException(""String_Node_Str"" + ""String_Node_Str"" + callingPackage);
          }
          sInfo=new ServiceInfo(sInfo);
          sInfo.applicationInfo=new ApplicationInfo(sInfo.applicationInfo);
          sInfo.applicationInfo.packageName=aInfo.packageName;
          sInfo.applicationInfo.uid=aInfo.uid;
          name=new ComponentName(aInfo.packageName,name.getClassName());
          service.setComponent(name);
        }
 else {
          throw new SecurityException(""String_Node_Str"" + name);
        }
      }
 else       if (isBindExternal) {
        throw new SecurityException(""String_Node_Str"" + name + ""String_Node_Str"");
      }
      if (userId > 0) {
        if (mAm.isSingleton(sInfo.processName,sInfo.applicationInfo,sInfo.name,sInfo.flags) && mAm.isValidSingletonCall(callingUid,sInfo.applicationInfo.uid)) {
          userId=0;
          smap=getServiceMap(0);
        }
        sInfo=new ServiceInfo(sInfo);
        sInfo.applicationInfo=mAm.getAppInfoForUser(sInfo.applicationInfo,userId);
      }
      r=smap.mServicesByName.get(name);
      if (r == null && createIfNeeded) {
        final long token=Binder.clearCallingIdentity();
        try {
          final int allowed=mAm.checkAllowBackgroundLocked(sInfo.applicationInfo.uid,sInfo.packageName,callingPid);
          if (allowed != ActivityManager.APP_START_MODE_NORMAL) {
            Slog.w(TAG,""String_Node_Str"" + service + ""String_Node_Str""+ name.flattenToShortString()+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ callingPackage);
            return null;
          }
        }
  finally {
          Binder.restoreCallingIdentity(token);
        }
        Intent.FilterComparison filter=new Intent.FilterComparison(service.cloneFilter());
        ServiceRestarter res=new ServiceRestarter();
        BatteryStatsImpl.Uid.Pkg.Serv ss=null;
        BatteryStatsImpl stats=mAm.mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
          ss=stats.getServiceStatsLocked(sInfo.applicationInfo.uid,sInfo.packageName,sInfo.name);
        }
        r=new ServiceRecord(mAm,ss,name,filter,sInfo,callingFromFg,res);
        res.setService(r);
        smap.mServicesByName.put(name,r);
        smap.mServicesByIntent.put(filter,r);
        for (int i=mPendingServices.size() - 1; i >= 0; i--) {
          ServiceRecord pr=mPendingServices.get(i);
          if (pr.serviceInfo.applicationInfo.uid == sInfo.applicationInfo.uid && pr.name.equals(name)) {
            mPendingServices.remove(i);
          }
        }
      }
    }
 catch (    RemoteException ex) {
    }
  }
  if (r != null) {
    if (mAm.checkComponentPermission(r.permission,callingPid,callingUid,r.appInfo.uid,r.exported) != PackageManager.PERMISSION_GRANTED) {
      if (!r.exported) {
        Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ r.appInfo.uid);
        return new ServiceLookupResult(null,""String_Node_Str"" + r.appInfo.uid);
      }
      Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ r.permission);
      return new ServiceLookupResult(null,r.permission);
    }
 else     if (r.permission != null && callingPackage != null) {
      final int opCode=AppOpsManager.permissionToOpCode(r.permission);
      if (opCode != AppOpsManager.OP_NONE && mAm.mAppOpsService.noteOperation(opCode,callingUid,callingPackage) != AppOpsManager.MODE_ALLOWED) {
        Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ AppOpsManager.opToName(opCode));
        return null;
      }
    }
    if (!mAm.mIntentFirewall.checkService(r.name,service,callingUid,callingPid,resolvedType,r.appInfo)) {
      return null;
    }
    return new ServiceLookupResult(r,null);
  }
  return null;
}","private ServiceLookupResult retrieveServiceLocked(Intent service,String resolvedType,String callingPackage,int callingPid,int callingUid,int userId,boolean createIfNeeded,boolean callingFromFg,boolean isBindExternal){
  ServiceRecord r=null;
  if (DEBUG_SERVICE)   Slog.v(TAG_SERVICE,""String_Node_Str"" + service + ""String_Node_Str""+ resolvedType+ ""String_Node_Str""+ callingUid);
  userId=mAm.mUserController.handleIncomingUser(callingPid,callingUid,userId,false,ActivityManagerService.ALLOW_NON_FULL_IN_PROFILE,""String_Node_Str"",null);
  ServiceMap smap=getServiceMap(userId);
  final ComponentName comp=service.getComponent();
  if (comp != null) {
    r=smap.mServicesByName.get(comp);
  }
  if (r == null && !isBindExternal) {
    Intent.FilterComparison filter=new Intent.FilterComparison(service);
    r=smap.mServicesByIntent.get(filter);
  }
  if (r != null && (r.serviceInfo.flags & ServiceInfo.FLAG_EXTERNAL_SERVICE) != 0 && !callingPackage.equals(r.packageName)) {
    r=null;
  }
  if (r == null) {
    try {
      ResolveInfo rInfo=AppGlobals.getPackageManager().resolveService(service,resolvedType,ActivityManagerService.STOCK_PM_FLAGS | PackageManager.MATCH_DEBUG_TRIAGED_MISSING,userId);
      ServiceInfo sInfo=rInfo != null ? rInfo.serviceInfo : null;
      if (sInfo == null) {
        Slog.w(TAG_SERVICE,""String_Node_Str"" + service + ""String_Node_Str""+ userId+ ""String_Node_Str"");
        return null;
      }
      ComponentName name=new ComponentName(sInfo.applicationInfo.packageName,sInfo.name);
      if ((sInfo.flags & ServiceInfo.FLAG_EXTERNAL_SERVICE) != 0) {
        if (isBindExternal) {
          if (!sInfo.exported) {
            throw new SecurityException(""String_Node_Str"" + name + ""String_Node_Str"");
          }
          if ((sInfo.flags & ServiceInfo.FLAG_ISOLATED_PROCESS) == 0) {
            throw new SecurityException(""String_Node_Str"" + name + ""String_Node_Str"");
          }
          ApplicationInfo aInfo=AppGlobals.getPackageManager().getApplicationInfo(callingPackage,ActivityManagerService.STOCK_PM_FLAGS,userId);
          if (aInfo == null) {
            throw new SecurityException(""String_Node_Str"" + ""String_Node_Str"" + callingPackage);
          }
          sInfo=new ServiceInfo(sInfo);
          sInfo.applicationInfo=new ApplicationInfo(sInfo.applicationInfo);
          sInfo.applicationInfo.packageName=aInfo.packageName;
          sInfo.applicationInfo.uid=aInfo.uid;
          name=new ComponentName(aInfo.packageName,name.getClassName());
          service.setComponent(name);
        }
 else {
          throw new SecurityException(""String_Node_Str"" + name);
        }
      }
 else       if (isBindExternal) {
        throw new SecurityException(""String_Node_Str"" + name + ""String_Node_Str"");
      }
      if (userId > 0) {
        if (mAm.isSingleton(sInfo.processName,sInfo.applicationInfo,sInfo.name,sInfo.flags) && mAm.isValidSingletonCall(callingUid,sInfo.applicationInfo.uid)) {
          userId=0;
          smap=getServiceMap(0);
        }
        sInfo=new ServiceInfo(sInfo);
        sInfo.applicationInfo=mAm.getAppInfoForUser(sInfo.applicationInfo,userId);
      }
      r=smap.mServicesByName.get(name);
      if (r == null && createIfNeeded) {
        final long token=Binder.clearCallingIdentity();
        try {
          final int allowed=mAm.checkAllowBackgroundLocked(sInfo.applicationInfo.uid,sInfo.packageName,callingPid,true);
          if (allowed != ActivityManager.APP_START_MODE_NORMAL) {
            Slog.w(TAG,""String_Node_Str"" + service + ""String_Node_Str""+ name.flattenToShortString()+ ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ callingPackage);
            return null;
          }
        }
  finally {
          Binder.restoreCallingIdentity(token);
        }
        Intent.FilterComparison filter=new Intent.FilterComparison(service.cloneFilter());
        ServiceRestarter res=new ServiceRestarter();
        BatteryStatsImpl.Uid.Pkg.Serv ss=null;
        BatteryStatsImpl stats=mAm.mBatteryStatsService.getActiveStatistics();
synchronized (stats) {
          ss=stats.getServiceStatsLocked(sInfo.applicationInfo.uid,sInfo.packageName,sInfo.name);
        }
        r=new ServiceRecord(mAm,ss,name,filter,sInfo,callingFromFg,res);
        res.setService(r);
        smap.mServicesByName.put(name,r);
        smap.mServicesByIntent.put(filter,r);
        for (int i=mPendingServices.size() - 1; i >= 0; i--) {
          ServiceRecord pr=mPendingServices.get(i);
          if (pr.serviceInfo.applicationInfo.uid == sInfo.applicationInfo.uid && pr.name.equals(name)) {
            mPendingServices.remove(i);
          }
        }
      }
    }
 catch (    RemoteException ex) {
    }
  }
  if (r != null) {
    if (mAm.checkComponentPermission(r.permission,callingPid,callingUid,r.appInfo.uid,r.exported) != PackageManager.PERMISSION_GRANTED) {
      if (!r.exported) {
        Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ r.appInfo.uid);
        return new ServiceLookupResult(null,""String_Node_Str"" + r.appInfo.uid);
      }
      Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ r.permission);
      return new ServiceLookupResult(null,r.permission);
    }
 else     if (r.permission != null && callingPackage != null) {
      final int opCode=AppOpsManager.permissionToOpCode(r.permission);
      if (opCode != AppOpsManager.OP_NONE && mAm.mAppOpsService.noteOperation(opCode,callingUid,callingPackage) != AppOpsManager.MODE_ALLOWED) {
        Slog.w(TAG,""String_Node_Str"" + r.name + ""String_Node_Str""+ callingPid+ ""String_Node_Str""+ callingUid+ ""String_Node_Str""+ AppOpsManager.opToName(opCode));
        return null;
      }
    }
    if (!mAm.mIntentFirewall.checkService(r.name,service,callingUid,callingPid,resolvedType,r.appInfo)) {
      return null;
    }
    return new ServiceLookupResult(r,null);
  }
  return null;
}",0.9995844760242666
192376,"public int getAppStartMode(int uid,String packageName){
synchronized (this) {
    return checkAllowBackgroundLocked(uid,packageName,-1);
  }
}","public int getAppStartMode(int uid,String packageName){
synchronized (this) {
    return checkAllowBackgroundLocked(uid,packageName,-1,true);
  }
}",0.9826989619377162
192377,"int checkAllowBackgroundLocked(int uid,String packageName,int callingPid){
  UidRecord uidRec=mActiveUids.get(uid);
  if (!mLenientBackgroundCheck) {
    if (uidRec == null || uidRec.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
      if (mAppOpsService.noteOperation(AppOpsManager.OP_RUN_IN_BACKGROUND,uid,packageName) != AppOpsManager.MODE_ALLOWED) {
        return ActivityManager.APP_START_MODE_DELAYED;
      }
    }
  }
 else   if (uidRec == null || uidRec.idle) {
    if (callingPid >= 0) {
      ProcessRecord proc;
synchronized (mPidsSelfLocked) {
        proc=mPidsSelfLocked.get(callingPid);
      }
      if (proc != null && proc.curProcState < ActivityManager.PROCESS_STATE_RECEIVER) {
        return ActivityManager.APP_START_MODE_NORMAL;
      }
    }
    if (mAppOpsService.noteOperation(AppOpsManager.OP_RUN_IN_BACKGROUND,uid,packageName) != AppOpsManager.MODE_ALLOWED) {
      return ActivityManager.APP_START_MODE_DELAYED;
    }
  }
  return ActivityManager.APP_START_MODE_NORMAL;
}","int checkAllowBackgroundLocked(int uid,String packageName,int callingPid,boolean allowWhenForeground){
  UidRecord uidRec=mActiveUids.get(uid);
  if (!mLenientBackgroundCheck) {
    if (!allowWhenForeground || uidRec == null || uidRec.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
      if (mAppOpsService.noteOperation(AppOpsManager.OP_RUN_IN_BACKGROUND,uid,packageName) != AppOpsManager.MODE_ALLOWED) {
        return ActivityManager.APP_START_MODE_DELAYED;
      }
    }
  }
 else   if (uidRec == null || uidRec.idle) {
    if (callingPid >= 0) {
      ProcessRecord proc;
synchronized (mPidsSelfLocked) {
        proc=mPidsSelfLocked.get(callingPid);
      }
      if (proc != null && proc.curProcState < ActivityManager.PROCESS_STATE_RECEIVER) {
        return ActivityManager.APP_START_MODE_NORMAL;
      }
    }
    if (mAppOpsService.noteOperation(AppOpsManager.OP_RUN_IN_BACKGROUND,uid,packageName) != AppOpsManager.MODE_ALLOWED) {
      return ActivityManager.APP_START_MODE_DELAYED;
    }
  }
  return ActivityManager.APP_START_MODE_NORMAL;
}",0.9752616555661276
192378,"private void deliverToRegisteredReceiverLocked(BroadcastRecord r,BroadcastFilter filter,boolean ordered,int index){
  boolean skip=false;
  if (filter.requiredPermission != null) {
    int perm=mService.checkComponentPermission(filter.requiredPermission,r.callingPid,r.callingUid,-1,true);
    if (perm != PackageManager.PERMISSION_GRANTED) {
      Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingPid+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ filter.requiredPermission+ ""String_Node_Str""+ filter);
      skip=true;
    }
 else {
      final int opCode=AppOpsManager.permissionToOpCode(filter.requiredPermission);
      if (opCode != AppOpsManager.OP_NONE && mService.mAppOpsService.noteOperation(opCode,r.callingUid,r.callerPackage) != AppOpsManager.MODE_ALLOWED) {
        Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingPid+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ AppOpsManager.permissionToOp(filter.requiredPermission)+ ""String_Node_Str""+ filter);
        skip=true;
      }
    }
  }
  if (!skip && r.requiredPermissions != null && r.requiredPermissions.length > 0) {
    for (int i=0; i < r.requiredPermissions.length; i++) {
      String requiredPermission=r.requiredPermissions[i];
      int perm=mService.checkComponentPermission(requiredPermission,filter.receiverList.pid,filter.receiverList.uid,-1,true);
      if (perm != PackageManager.PERMISSION_GRANTED) {
        Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ filter.receiverList.app+ ""String_Node_Str""+ filter.receiverList.pid+ ""String_Node_Str""+ filter.receiverList.uid+ ""String_Node_Str""+ ""String_Node_Str""+ requiredPermission+ ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str"");
        skip=true;
        break;
      }
      int appOp=AppOpsManager.permissionToOpCode(requiredPermission);
      if (appOp != AppOpsManager.OP_NONE && appOp != r.appOp && mService.mAppOpsService.noteOperation(appOp,filter.receiverList.uid,filter.packageName) != AppOpsManager.MODE_ALLOWED) {
        Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ filter.receiverList.app+ ""String_Node_Str""+ filter.receiverList.pid+ ""String_Node_Str""+ filter.receiverList.uid+ ""String_Node_Str""+ ""String_Node_Str""+ AppOpsManager.permissionToOp(requiredPermission)+ ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str"");
        skip=true;
        break;
      }
    }
  }
  if (!skip && (r.requiredPermissions == null || r.requiredPermissions.length == 0)) {
    int perm=mService.checkComponentPermission(null,filter.receiverList.pid,filter.receiverList.uid,-1,true);
    if (perm != PackageManager.PERMISSION_GRANTED) {
      Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ filter.receiverList.app+ ""String_Node_Str""+ filter.receiverList.pid+ ""String_Node_Str""+ filter.receiverList.uid+ ""String_Node_Str""+ ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str"");
      skip=true;
    }
  }
  if (!skip && r.appOp != AppOpsManager.OP_NONE && mService.mAppOpsService.noteOperation(r.appOp,filter.receiverList.uid,filter.packageName) != AppOpsManager.MODE_ALLOWED) {
    Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ filter.receiverList.app+ ""String_Node_Str""+ filter.receiverList.pid+ ""String_Node_Str""+ filter.receiverList.uid+ ""String_Node_Str""+ ""String_Node_Str""+ AppOpsManager.opToName(r.appOp)+ ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str"");
    skip=true;
  }
  if (!skip) {
    final int allowed=mService.checkAllowBackgroundLocked(filter.receiverList.uid,filter.packageName,-1);
    if (allowed == ActivityManager.APP_START_MODE_DISABLED) {
      Slog.w(TAG,""String_Node_Str"" + r.intent + ""String_Node_Str""+ filter.receiverList.app+ ""String_Node_Str""+ filter.receiverList.pid+ ""String_Node_Str""+ filter.receiverList.uid+ ""String_Node_Str"");
      skip=true;
    }
  }
  if (!mService.mIntentFirewall.checkBroadcast(r.intent,r.callingUid,r.callingPid,r.resolvedType,filter.receiverList.uid)) {
    skip=true;
  }
  if (!skip && (filter.receiverList.app == null || filter.receiverList.app.crashing)) {
    Slog.w(TAG,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r+ ""String_Node_Str""+ filter.receiverList+ ""String_Node_Str"");
    skip=true;
  }
  if (skip) {
    r.delivery[index]=BroadcastRecord.DELIVERY_SKIPPED;
    return;
  }
  if (Build.PERMISSIONS_REVIEW_REQUIRED) {
    if (!requestStartTargetPermissionsReviewIfNeededLocked(r,filter.packageName,filter.owningUserId)) {
      r.delivery[index]=BroadcastRecord.DELIVERY_SKIPPED;
      return;
    }
  }
  r.delivery[index]=BroadcastRecord.DELIVERY_DELIVERED;
  if (ordered) {
    r.receiver=filter.receiverList.receiver.asBinder();
    r.curFilter=filter;
    filter.receiverList.curBroadcast=r;
    r.state=BroadcastRecord.CALL_IN_RECEIVE;
    if (filter.receiverList.app != null) {
      r.curApp=filter.receiverList.app;
      filter.receiverList.app.curReceiver=r;
      mService.updateOomAdjLocked(r.curApp);
    }
  }
  try {
    if (DEBUG_BROADCAST_LIGHT)     Slog.i(TAG_BROADCAST,""String_Node_Str"" + filter + ""String_Node_Str""+ r);
    performReceiveLocked(filter.receiverList.app,filter.receiverList.receiver,new Intent(r.intent),r.resultCode,r.resultData,r.resultExtras,r.ordered,r.initialSticky,r.userId);
    if (ordered) {
      r.state=BroadcastRecord.CALL_DONE_RECEIVE;
    }
  }
 catch (  RemoteException e) {
    Slog.w(TAG,""String_Node_Str"" + r.intent,e);
    if (ordered) {
      r.receiver=null;
      r.curFilter=null;
      filter.receiverList.curBroadcast=null;
      if (filter.receiverList.app != null) {
        filter.receiverList.app.curReceiver=null;
      }
    }
  }
}","private void deliverToRegisteredReceiverLocked(BroadcastRecord r,BroadcastFilter filter,boolean ordered,int index){
  boolean skip=false;
  if (filter.requiredPermission != null) {
    int perm=mService.checkComponentPermission(filter.requiredPermission,r.callingPid,r.callingUid,-1,true);
    if (perm != PackageManager.PERMISSION_GRANTED) {
      Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingPid+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ filter.requiredPermission+ ""String_Node_Str""+ filter);
      skip=true;
    }
 else {
      final int opCode=AppOpsManager.permissionToOpCode(filter.requiredPermission);
      if (opCode != AppOpsManager.OP_NONE && mService.mAppOpsService.noteOperation(opCode,r.callingUid,r.callerPackage) != AppOpsManager.MODE_ALLOWED) {
        Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingPid+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ AppOpsManager.permissionToOp(filter.requiredPermission)+ ""String_Node_Str""+ filter);
        skip=true;
      }
    }
  }
  if (!skip && r.requiredPermissions != null && r.requiredPermissions.length > 0) {
    for (int i=0; i < r.requiredPermissions.length; i++) {
      String requiredPermission=r.requiredPermissions[i];
      int perm=mService.checkComponentPermission(requiredPermission,filter.receiverList.pid,filter.receiverList.uid,-1,true);
      if (perm != PackageManager.PERMISSION_GRANTED) {
        Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ filter.receiverList.app+ ""String_Node_Str""+ filter.receiverList.pid+ ""String_Node_Str""+ filter.receiverList.uid+ ""String_Node_Str""+ ""String_Node_Str""+ requiredPermission+ ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str"");
        skip=true;
        break;
      }
      int appOp=AppOpsManager.permissionToOpCode(requiredPermission);
      if (appOp != AppOpsManager.OP_NONE && appOp != r.appOp && mService.mAppOpsService.noteOperation(appOp,filter.receiverList.uid,filter.packageName) != AppOpsManager.MODE_ALLOWED) {
        Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ filter.receiverList.app+ ""String_Node_Str""+ filter.receiverList.pid+ ""String_Node_Str""+ filter.receiverList.uid+ ""String_Node_Str""+ ""String_Node_Str""+ AppOpsManager.permissionToOp(requiredPermission)+ ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str"");
        skip=true;
        break;
      }
    }
  }
  if (!skip && (r.requiredPermissions == null || r.requiredPermissions.length == 0)) {
    int perm=mService.checkComponentPermission(null,filter.receiverList.pid,filter.receiverList.uid,-1,true);
    if (perm != PackageManager.PERMISSION_GRANTED) {
      Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ filter.receiverList.app+ ""String_Node_Str""+ filter.receiverList.pid+ ""String_Node_Str""+ filter.receiverList.uid+ ""String_Node_Str""+ ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str"");
      skip=true;
    }
  }
  if (!skip && r.appOp != AppOpsManager.OP_NONE && mService.mAppOpsService.noteOperation(r.appOp,filter.receiverList.uid,filter.packageName) != AppOpsManager.MODE_ALLOWED) {
    Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ filter.receiverList.app+ ""String_Node_Str""+ filter.receiverList.pid+ ""String_Node_Str""+ filter.receiverList.uid+ ""String_Node_Str""+ ""String_Node_Str""+ AppOpsManager.opToName(r.appOp)+ ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str"");
    skip=true;
  }
  if (!skip) {
    final int allowed=mService.checkAllowBackgroundLocked(filter.receiverList.uid,filter.packageName,-1,true);
    if (allowed == ActivityManager.APP_START_MODE_DISABLED) {
      Slog.w(TAG,""String_Node_Str"" + r.intent + ""String_Node_Str""+ filter.receiverList.app+ ""String_Node_Str""+ filter.receiverList.pid+ ""String_Node_Str""+ filter.receiverList.uid+ ""String_Node_Str"");
      skip=true;
    }
  }
  if (!mService.mIntentFirewall.checkBroadcast(r.intent,r.callingUid,r.callingPid,r.resolvedType,filter.receiverList.uid)) {
    skip=true;
  }
  if (!skip && (filter.receiverList.app == null || filter.receiverList.app.crashing)) {
    Slog.w(TAG,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r+ ""String_Node_Str""+ filter.receiverList+ ""String_Node_Str"");
    skip=true;
  }
  if (skip) {
    r.delivery[index]=BroadcastRecord.DELIVERY_SKIPPED;
    return;
  }
  if (Build.PERMISSIONS_REVIEW_REQUIRED) {
    if (!requestStartTargetPermissionsReviewIfNeededLocked(r,filter.packageName,filter.owningUserId)) {
      r.delivery[index]=BroadcastRecord.DELIVERY_SKIPPED;
      return;
    }
  }
  r.delivery[index]=BroadcastRecord.DELIVERY_DELIVERED;
  if (ordered) {
    r.receiver=filter.receiverList.receiver.asBinder();
    r.curFilter=filter;
    filter.receiverList.curBroadcast=r;
    r.state=BroadcastRecord.CALL_IN_RECEIVE;
    if (filter.receiverList.app != null) {
      r.curApp=filter.receiverList.app;
      filter.receiverList.app.curReceiver=r;
      mService.updateOomAdjLocked(r.curApp);
    }
  }
  try {
    if (DEBUG_BROADCAST_LIGHT)     Slog.i(TAG_BROADCAST,""String_Node_Str"" + filter + ""String_Node_Str""+ r);
    performReceiveLocked(filter.receiverList.app,filter.receiverList.receiver,new Intent(r.intent),r.resultCode,r.resultData,r.resultExtras,r.ordered,r.initialSticky,r.userId);
    if (ordered) {
      r.state=BroadcastRecord.CALL_DONE_RECEIVE;
    }
  }
 catch (  RemoteException e) {
    Slog.w(TAG,""String_Node_Str"" + r.intent,e);
    if (ordered) {
      r.receiver=null;
      r.curFilter=null;
      filter.receiverList.curBroadcast=null;
      if (filter.receiverList.app != null) {
        filter.receiverList.app.curReceiver=null;
      }
    }
  }
}",0.9995799378307988
192379,"final void processNextBroadcast(boolean fromMsg){
synchronized (mService) {
    BroadcastRecord r;
    if (DEBUG_BROADCAST)     Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ mParallelBroadcasts.size()+ ""String_Node_Str""+ mOrderedBroadcasts.size()+ ""String_Node_Str"");
    mService.updateCpuStats();
    if (fromMsg) {
      mBroadcastsScheduled=false;
    }
    while (mParallelBroadcasts.size() > 0) {
      r=mParallelBroadcasts.remove(0);
      r.dispatchTime=SystemClock.uptimeMillis();
      r.dispatchClockTime=System.currentTimeMillis();
      final int N=r.receivers.size();
      if (DEBUG_BROADCAST_LIGHT)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r);
      for (int i=0; i < N; i++) {
        Object target=r.receivers.get(i);
        if (DEBUG_BROADCAST)         Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ target+ ""String_Node_Str""+ r);
        deliverToRegisteredReceiverLocked(r,(BroadcastFilter)target,false,i);
      }
      addBroadcastToHistoryLocked(r);
      if (DEBUG_BROADCAST_LIGHT)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r);
    }
    if (mPendingBroadcast != null) {
      if (DEBUG_BROADCAST_LIGHT)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ mPendingBroadcast.curApp);
      boolean isDead;
synchronized (mService.mPidsSelfLocked) {
        ProcessRecord proc=mService.mPidsSelfLocked.get(mPendingBroadcast.curApp.pid);
        isDead=proc == null || proc.crashing;
      }
      if (!isDead) {
        return;
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ mPendingBroadcast.curApp+ ""String_Node_Str"");
        mPendingBroadcast.state=BroadcastRecord.IDLE;
        mPendingBroadcast.nextReceiver=mPendingBroadcastRecvIndex;
        mPendingBroadcast=null;
      }
    }
    boolean looped=false;
    do {
      if (mOrderedBroadcasts.size() == 0) {
        mService.scheduleAppGcsLocked();
        if (looped) {
          mService.updateOomAdjLocked();
        }
        return;
      }
      r=mOrderedBroadcasts.get(0);
      boolean forceReceive=false;
      int numReceivers=(r.receivers != null) ? r.receivers.size() : 0;
      if (mService.mProcessesReady && r.dispatchTime > 0) {
        long now=SystemClock.uptimeMillis();
        if ((numReceivers > 0) && (now > r.dispatchTime + (2 * mTimeoutPeriod * numReceivers))) {
          Slog.w(TAG,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ ""String_Node_Str""+ now+ ""String_Node_Str""+ r.dispatchTime+ ""String_Node_Str""+ r.receiverTime+ ""String_Node_Str""+ r.intent+ ""String_Node_Str""+ numReceivers+ ""String_Node_Str""+ r.nextReceiver+ ""String_Node_Str""+ r.state);
          broadcastTimeoutLocked(false);
          forceReceive=true;
          r.state=BroadcastRecord.IDLE;
        }
      }
      if (r.state != BroadcastRecord.IDLE) {
        if (DEBUG_BROADCAST)         Slog.d(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r.state+ ""String_Node_Str"");
        return;
      }
      if (r.receivers == null || r.nextReceiver >= numReceivers || r.resultAbort || forceReceive) {
        if (r.resultTo != null) {
          try {
            if (DEBUG_BROADCAST)             Slog.i(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r.intent.getAction()+ ""String_Node_Str""+ r.callerApp);
            performReceiveLocked(r.callerApp,r.resultTo,new Intent(r.intent),r.resultCode,r.resultData,r.resultExtras,false,false,r.userId);
            r.resultTo=null;
          }
 catch (          RemoteException e) {
            r.resultTo=null;
            Slog.w(TAG,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r.intent,e);
          }
        }
        if (DEBUG_BROADCAST)         Slog.v(TAG_BROADCAST,""String_Node_Str"");
        cancelBroadcastTimeoutLocked();
        if (DEBUG_BROADCAST_LIGHT)         Slog.v(TAG_BROADCAST,""String_Node_Str"" + r);
        addBroadcastToHistoryLocked(r);
        mOrderedBroadcasts.remove(0);
        r=null;
        looped=true;
        continue;
      }
    }
 while (r == null);
    int recIdx=r.nextReceiver++;
    r.receiverTime=SystemClock.uptimeMillis();
    if (recIdx == 0) {
      r.dispatchTime=r.receiverTime;
      r.dispatchClockTime=System.currentTimeMillis();
      if (DEBUG_BROADCAST_LIGHT)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r);
    }
    if (!mPendingBroadcastTimeoutMessage) {
      long timeoutTime=r.receiverTime + mTimeoutPeriod;
      if (DEBUG_BROADCAST)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r+ ""String_Node_Str""+ timeoutTime);
      setBroadcastTimeoutLocked(timeoutTime);
    }
    final BroadcastOptions brOptions=r.options;
    final Object nextReceiver=r.receivers.get(recIdx);
    if (nextReceiver instanceof BroadcastFilter) {
      BroadcastFilter filter=(BroadcastFilter)nextReceiver;
      if (DEBUG_BROADCAST)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ filter+ ""String_Node_Str""+ r);
      deliverToRegisteredReceiverLocked(r,filter,r.ordered,recIdx);
      if (r.receiver == null || !r.ordered) {
        if (DEBUG_BROADCAST)         Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r.ordered+ ""String_Node_Str""+ r.receiver);
        r.state=BroadcastRecord.IDLE;
        scheduleBroadcastsLocked();
      }
 else {
        if (brOptions != null && brOptions.getTemporaryAppWhitelistDuration() > 0) {
          scheduleTempWhitelistLocked(filter.owningUid,brOptions.getTemporaryAppWhitelistDuration(),r);
        }
      }
      return;
    }
    ResolveInfo info=(ResolveInfo)nextReceiver;
    ComponentName component=new ComponentName(info.activityInfo.applicationInfo.packageName,info.activityInfo.name);
    boolean skip=false;
    if (brOptions != null && (info.activityInfo.applicationInfo.targetSdkVersion < brOptions.getMinManifestReceiverApiLevel() || info.activityInfo.applicationInfo.targetSdkVersion > brOptions.getMaxManifestReceiverApiLevel())) {
      skip=true;
    }
    int perm=mService.checkComponentPermission(info.activityInfo.permission,r.callingPid,r.callingUid,info.activityInfo.applicationInfo.uid,info.activityInfo.exported);
    if (!skip && perm != PackageManager.PERMISSION_GRANTED) {
      if (!info.activityInfo.exported) {
        Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingPid+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ info.activityInfo.applicationInfo.uid+ ""String_Node_Str""+ component.flattenToShortString());
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingPid+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ info.activityInfo.permission+ ""String_Node_Str""+ component.flattenToShortString());
      }
      skip=true;
    }
 else     if (!skip && info.activityInfo.permission != null) {
      final int opCode=AppOpsManager.permissionToOpCode(info.activityInfo.permission);
      if (opCode != AppOpsManager.OP_NONE && mService.mAppOpsService.noteOperation(opCode,r.callingUid,r.callerPackage) != AppOpsManager.MODE_ALLOWED) {
        Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingPid+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ AppOpsManager.permissionToOp(info.activityInfo.permission)+ ""String_Node_Str""+ component.flattenToShortString());
        skip=true;
      }
    }
    if (!skip && info.activityInfo.applicationInfo.uid != Process.SYSTEM_UID && r.requiredPermissions != null && r.requiredPermissions.length > 0) {
      for (int i=0; i < r.requiredPermissions.length; i++) {
        String requiredPermission=r.requiredPermissions[i];
        try {
          perm=AppGlobals.getPackageManager().checkPermission(requiredPermission,info.activityInfo.applicationInfo.packageName,UserHandle.getUserId(info.activityInfo.applicationInfo.uid));
        }
 catch (        RemoteException e) {
          perm=PackageManager.PERMISSION_DENIED;
        }
        if (perm != PackageManager.PERMISSION_GRANTED) {
          Slog.w(TAG,""String_Node_Str"" + r.intent + ""String_Node_Str""+ component.flattenToShortString()+ ""String_Node_Str""+ requiredPermission+ ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str"");
          skip=true;
          break;
        }
        int appOp=AppOpsManager.permissionToOpCode(requiredPermission);
        if (appOp != AppOpsManager.OP_NONE && appOp != r.appOp && mService.mAppOpsService.noteOperation(appOp,info.activityInfo.applicationInfo.uid,info.activityInfo.packageName) != AppOpsManager.MODE_ALLOWED) {
          Slog.w(TAG,""String_Node_Str"" + r.intent + ""String_Node_Str""+ component.flattenToShortString()+ ""String_Node_Str""+ AppOpsManager.permissionToOp(requiredPermission)+ ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str"");
          skip=true;
          break;
        }
      }
    }
    if (!skip && r.appOp != AppOpsManager.OP_NONE && mService.mAppOpsService.noteOperation(r.appOp,info.activityInfo.applicationInfo.uid,info.activityInfo.packageName) != AppOpsManager.MODE_ALLOWED) {
      Slog.w(TAG,""String_Node_Str"" + r.intent + ""String_Node_Str""+ component.flattenToShortString()+ ""String_Node_Str""+ AppOpsManager.opToName(r.appOp)+ ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str"");
      skip=true;
    }
    if (!skip) {
      skip=!mService.mIntentFirewall.checkBroadcast(r.intent,r.callingUid,r.callingPid,r.resolvedType,info.activityInfo.applicationInfo.uid);
    }
    boolean isSingleton=false;
    try {
      isSingleton=mService.isSingleton(info.activityInfo.processName,info.activityInfo.applicationInfo,info.activityInfo.name,info.activityInfo.flags);
    }
 catch (    SecurityException e) {
      Slog.w(TAG,e.getMessage());
      skip=true;
    }
    if ((info.activityInfo.flags & ActivityInfo.FLAG_SINGLE_USER) != 0) {
      if (ActivityManager.checkUidPermission(android.Manifest.permission.INTERACT_ACROSS_USERS,info.activityInfo.applicationInfo.uid) != PackageManager.PERMISSION_GRANTED) {
        Slog.w(TAG,""String_Node_Str"" + component.flattenToShortString() + ""String_Node_Str""+ android.Manifest.permission.INTERACT_ACROSS_USERS);
        skip=true;
      }
    }
    if (r.curApp != null && r.curApp.crashing) {
      Slog.w(TAG,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r+ ""String_Node_Str""+ r.curApp+ ""String_Node_Str"");
      skip=true;
    }
    if (!skip) {
      boolean isAvailable=false;
      try {
        isAvailable=AppGlobals.getPackageManager().isPackageAvailable(info.activityInfo.packageName,UserHandle.getUserId(info.activityInfo.applicationInfo.uid));
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + info.activityInfo.packageName,e);
      }
      if (!isAvailable) {
        if (DEBUG_BROADCAST)         Slog.v(TAG_BROADCAST,""String_Node_Str"" + info.activityInfo.packageName + ""String_Node_Str""+ info.activityInfo.applicationInfo.uid+ ""String_Node_Str"");
        skip=true;
      }
    }
    if (Build.PERMISSIONS_REVIEW_REQUIRED && !skip) {
      if (!requestStartTargetPermissionsReviewIfNeededLocked(r,info.activityInfo.packageName,UserHandle.getUserId(info.activityInfo.applicationInfo.uid))) {
        skip=true;
      }
    }
    final int receiverUid=info.activityInfo.applicationInfo.uid;
    if (r.callingUid != Process.SYSTEM_UID && isSingleton && mService.isValidSingletonCall(r.callingUid,receiverUid)) {
      info.activityInfo=mService.getActivityInfoForUser(info.activityInfo,0);
    }
    String targetProcess=info.activityInfo.processName;
    ProcessRecord app=mService.getProcessRecordLocked(targetProcess,info.activityInfo.applicationInfo.uid,false);
    if (!skip) {
      final int allowed=mService.checkAllowBackgroundLocked(info.activityInfo.applicationInfo.uid,info.activityInfo.packageName,-1);
      if (allowed != ActivityManager.APP_START_MODE_NORMAL) {
        if (allowed == ActivityManager.APP_START_MODE_DISABLED) {
          Slog.w(TAG,""String_Node_Str"" + r.intent + ""String_Node_Str""+ component.flattenToShortString());
          skip=true;
        }
        if (((r.intent.getFlags() & Intent.FLAG_RECEIVER_EXCLUDE_BACKGROUND) != 0) || (r.intent.getComponent() == null && r.intent.getPackage() == null && app == null && ((r.intent.getFlags() & Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND) == 0))) {
          Slog.w(TAG,""String_Node_Str"" + r.intent + ""String_Node_Str""+ component.flattenToShortString());
          skip=true;
        }
      }
    }
    if (skip) {
      if (DEBUG_BROADCAST)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r+ ""String_Node_Str"");
      r.delivery[recIdx]=BroadcastRecord.DELIVERY_SKIPPED;
      r.receiver=null;
      r.curFilter=null;
      r.state=BroadcastRecord.IDLE;
      scheduleBroadcastsLocked();
      return;
    }
    r.delivery[recIdx]=BroadcastRecord.DELIVERY_DELIVERED;
    r.state=BroadcastRecord.APP_RECEIVE;
    r.curComponent=component;
    r.curReceiver=info.activityInfo;
    if (DEBUG_MU && r.callingUid > UserHandle.PER_USER_RANGE) {
      Slog.v(TAG_MU,""String_Node_Str"" + info.activityInfo + ""String_Node_Str""+ r.callingUid+ ""String_Node_Str""+ info.activityInfo.applicationInfo.uid);
    }
    if (brOptions != null && brOptions.getTemporaryAppWhitelistDuration() > 0) {
      scheduleTempWhitelistLocked(receiverUid,brOptions.getTemporaryAppWhitelistDuration(),r);
    }
    try {
      AppGlobals.getPackageManager().setPackageStoppedState(r.curComponent.getPackageName(),false,UserHandle.getUserId(r.callingUid));
    }
 catch (    RemoteException e) {
    }
catch (    IllegalArgumentException e) {
      Slog.w(TAG,""String_Node_Str"" + r.curComponent.getPackageName() + ""String_Node_Str""+ e);
    }
    if (app != null && app.thread != null) {
      try {
        app.addPackage(info.activityInfo.packageName,info.activityInfo.applicationInfo.versionCode,mService.mProcessStats);
        processCurBroadcastLocked(r,app);
        return;
      }
 catch (      RemoteException e) {
        Slog.w(TAG,""String_Node_Str"" + r.curComponent,e);
      }
catch (      RuntimeException e) {
        Slog.wtf(TAG,""String_Node_Str"" + r.curComponent + ""String_Node_Str""+ r.intent,e);
        logBroadcastReceiverDiscardLocked(r);
        finishReceiverLocked(r,r.resultCode,r.resultData,r.resultExtras,r.resultAbort,false);
        scheduleBroadcastsLocked();
        r.state=BroadcastRecord.IDLE;
        return;
      }
    }
    if (DEBUG_BROADCAST)     Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ targetProcess+ ""String_Node_Str""+ r);
    if ((r.curApp=mService.startProcessLocked(targetProcess,info.activityInfo.applicationInfo,true,r.intent.getFlags() | Intent.FLAG_FROM_BACKGROUND,""String_Node_Str"",r.curComponent,(r.intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) != 0,false,false)) == null) {
      Slog.w(TAG,""String_Node_Str"" + info.activityInfo.applicationInfo.packageName + ""String_Node_Str""+ info.activityInfo.applicationInfo.uid+ ""String_Node_Str""+ r.intent+ ""String_Node_Str"");
      logBroadcastReceiverDiscardLocked(r);
      finishReceiverLocked(r,r.resultCode,r.resultData,r.resultExtras,r.resultAbort,false);
      scheduleBroadcastsLocked();
      r.state=BroadcastRecord.IDLE;
      return;
    }
    mPendingBroadcast=r;
    mPendingBroadcastRecvIndex=recIdx;
  }
}","final void processNextBroadcast(boolean fromMsg){
synchronized (mService) {
    BroadcastRecord r;
    if (DEBUG_BROADCAST)     Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ mParallelBroadcasts.size()+ ""String_Node_Str""+ mOrderedBroadcasts.size()+ ""String_Node_Str"");
    mService.updateCpuStats();
    if (fromMsg) {
      mBroadcastsScheduled=false;
    }
    while (mParallelBroadcasts.size() > 0) {
      r=mParallelBroadcasts.remove(0);
      r.dispatchTime=SystemClock.uptimeMillis();
      r.dispatchClockTime=System.currentTimeMillis();
      final int N=r.receivers.size();
      if (DEBUG_BROADCAST_LIGHT)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r);
      for (int i=0; i < N; i++) {
        Object target=r.receivers.get(i);
        if (DEBUG_BROADCAST)         Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ target+ ""String_Node_Str""+ r);
        deliverToRegisteredReceiverLocked(r,(BroadcastFilter)target,false,i);
      }
      addBroadcastToHistoryLocked(r);
      if (DEBUG_BROADCAST_LIGHT)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r);
    }
    if (mPendingBroadcast != null) {
      if (DEBUG_BROADCAST_LIGHT)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ mPendingBroadcast.curApp);
      boolean isDead;
synchronized (mService.mPidsSelfLocked) {
        ProcessRecord proc=mService.mPidsSelfLocked.get(mPendingBroadcast.curApp.pid);
        isDead=proc == null || proc.crashing;
      }
      if (!isDead) {
        return;
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ mPendingBroadcast.curApp+ ""String_Node_Str"");
        mPendingBroadcast.state=BroadcastRecord.IDLE;
        mPendingBroadcast.nextReceiver=mPendingBroadcastRecvIndex;
        mPendingBroadcast=null;
      }
    }
    boolean looped=false;
    do {
      if (mOrderedBroadcasts.size() == 0) {
        mService.scheduleAppGcsLocked();
        if (looped) {
          mService.updateOomAdjLocked();
        }
        return;
      }
      r=mOrderedBroadcasts.get(0);
      boolean forceReceive=false;
      int numReceivers=(r.receivers != null) ? r.receivers.size() : 0;
      if (mService.mProcessesReady && r.dispatchTime > 0) {
        long now=SystemClock.uptimeMillis();
        if ((numReceivers > 0) && (now > r.dispatchTime + (2 * mTimeoutPeriod * numReceivers))) {
          Slog.w(TAG,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ ""String_Node_Str""+ now+ ""String_Node_Str""+ r.dispatchTime+ ""String_Node_Str""+ r.receiverTime+ ""String_Node_Str""+ r.intent+ ""String_Node_Str""+ numReceivers+ ""String_Node_Str""+ r.nextReceiver+ ""String_Node_Str""+ r.state);
          broadcastTimeoutLocked(false);
          forceReceive=true;
          r.state=BroadcastRecord.IDLE;
        }
      }
      if (r.state != BroadcastRecord.IDLE) {
        if (DEBUG_BROADCAST)         Slog.d(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r.state+ ""String_Node_Str"");
        return;
      }
      if (r.receivers == null || r.nextReceiver >= numReceivers || r.resultAbort || forceReceive) {
        if (r.resultTo != null) {
          try {
            if (DEBUG_BROADCAST)             Slog.i(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r.intent.getAction()+ ""String_Node_Str""+ r.callerApp);
            performReceiveLocked(r.callerApp,r.resultTo,new Intent(r.intent),r.resultCode,r.resultData,r.resultExtras,false,false,r.userId);
            r.resultTo=null;
          }
 catch (          RemoteException e) {
            r.resultTo=null;
            Slog.w(TAG,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r.intent,e);
          }
        }
        if (DEBUG_BROADCAST)         Slog.v(TAG_BROADCAST,""String_Node_Str"");
        cancelBroadcastTimeoutLocked();
        if (DEBUG_BROADCAST_LIGHT)         Slog.v(TAG_BROADCAST,""String_Node_Str"" + r);
        addBroadcastToHistoryLocked(r);
        mOrderedBroadcasts.remove(0);
        r=null;
        looped=true;
        continue;
      }
    }
 while (r == null);
    int recIdx=r.nextReceiver++;
    r.receiverTime=SystemClock.uptimeMillis();
    if (recIdx == 0) {
      r.dispatchTime=r.receiverTime;
      r.dispatchClockTime=System.currentTimeMillis();
      if (DEBUG_BROADCAST_LIGHT)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r);
    }
    if (!mPendingBroadcastTimeoutMessage) {
      long timeoutTime=r.receiverTime + mTimeoutPeriod;
      if (DEBUG_BROADCAST)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r+ ""String_Node_Str""+ timeoutTime);
      setBroadcastTimeoutLocked(timeoutTime);
    }
    final BroadcastOptions brOptions=r.options;
    final Object nextReceiver=r.receivers.get(recIdx);
    if (nextReceiver instanceof BroadcastFilter) {
      BroadcastFilter filter=(BroadcastFilter)nextReceiver;
      if (DEBUG_BROADCAST)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ filter+ ""String_Node_Str""+ r);
      deliverToRegisteredReceiverLocked(r,filter,r.ordered,recIdx);
      if (r.receiver == null || !r.ordered) {
        if (DEBUG_BROADCAST)         Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r.ordered+ ""String_Node_Str""+ r.receiver);
        r.state=BroadcastRecord.IDLE;
        scheduleBroadcastsLocked();
      }
 else {
        if (brOptions != null && brOptions.getTemporaryAppWhitelistDuration() > 0) {
          scheduleTempWhitelistLocked(filter.owningUid,brOptions.getTemporaryAppWhitelistDuration(),r);
        }
      }
      return;
    }
    ResolveInfo info=(ResolveInfo)nextReceiver;
    ComponentName component=new ComponentName(info.activityInfo.applicationInfo.packageName,info.activityInfo.name);
    boolean skip=false;
    if (brOptions != null && (info.activityInfo.applicationInfo.targetSdkVersion < brOptions.getMinManifestReceiverApiLevel() || info.activityInfo.applicationInfo.targetSdkVersion > brOptions.getMaxManifestReceiverApiLevel())) {
      skip=true;
    }
    int perm=mService.checkComponentPermission(info.activityInfo.permission,r.callingPid,r.callingUid,info.activityInfo.applicationInfo.uid,info.activityInfo.exported);
    if (!skip && perm != PackageManager.PERMISSION_GRANTED) {
      if (!info.activityInfo.exported) {
        Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingPid+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ info.activityInfo.applicationInfo.uid+ ""String_Node_Str""+ component.flattenToShortString());
      }
 else {
        Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingPid+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ info.activityInfo.permission+ ""String_Node_Str""+ component.flattenToShortString());
      }
      skip=true;
    }
 else     if (!skip && info.activityInfo.permission != null) {
      final int opCode=AppOpsManager.permissionToOpCode(info.activityInfo.permission);
      if (opCode != AppOpsManager.OP_NONE && mService.mAppOpsService.noteOperation(opCode,r.callingUid,r.callerPackage) != AppOpsManager.MODE_ALLOWED) {
        Slog.w(TAG,""String_Node_Str"" + r.intent.toString() + ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingPid+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str""+ ""String_Node_Str""+ AppOpsManager.permissionToOp(info.activityInfo.permission)+ ""String_Node_Str""+ component.flattenToShortString());
        skip=true;
      }
    }
    if (!skip && info.activityInfo.applicationInfo.uid != Process.SYSTEM_UID && r.requiredPermissions != null && r.requiredPermissions.length > 0) {
      for (int i=0; i < r.requiredPermissions.length; i++) {
        String requiredPermission=r.requiredPermissions[i];
        try {
          perm=AppGlobals.getPackageManager().checkPermission(requiredPermission,info.activityInfo.applicationInfo.packageName,UserHandle.getUserId(info.activityInfo.applicationInfo.uid));
        }
 catch (        RemoteException e) {
          perm=PackageManager.PERMISSION_DENIED;
        }
        if (perm != PackageManager.PERMISSION_GRANTED) {
          Slog.w(TAG,""String_Node_Str"" + r.intent + ""String_Node_Str""+ component.flattenToShortString()+ ""String_Node_Str""+ requiredPermission+ ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str"");
          skip=true;
          break;
        }
        int appOp=AppOpsManager.permissionToOpCode(requiredPermission);
        if (appOp != AppOpsManager.OP_NONE && appOp != r.appOp && mService.mAppOpsService.noteOperation(appOp,info.activityInfo.applicationInfo.uid,info.activityInfo.packageName) != AppOpsManager.MODE_ALLOWED) {
          Slog.w(TAG,""String_Node_Str"" + r.intent + ""String_Node_Str""+ component.flattenToShortString()+ ""String_Node_Str""+ AppOpsManager.permissionToOp(requiredPermission)+ ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str"");
          skip=true;
          break;
        }
      }
    }
    if (!skip && r.appOp != AppOpsManager.OP_NONE && mService.mAppOpsService.noteOperation(r.appOp,info.activityInfo.applicationInfo.uid,info.activityInfo.packageName) != AppOpsManager.MODE_ALLOWED) {
      Slog.w(TAG,""String_Node_Str"" + r.intent + ""String_Node_Str""+ component.flattenToShortString()+ ""String_Node_Str""+ AppOpsManager.opToName(r.appOp)+ ""String_Node_Str""+ r.callerPackage+ ""String_Node_Str""+ r.callingUid+ ""String_Node_Str"");
      skip=true;
    }
    if (!skip) {
      skip=!mService.mIntentFirewall.checkBroadcast(r.intent,r.callingUid,r.callingPid,r.resolvedType,info.activityInfo.applicationInfo.uid);
    }
    boolean isSingleton=false;
    try {
      isSingleton=mService.isSingleton(info.activityInfo.processName,info.activityInfo.applicationInfo,info.activityInfo.name,info.activityInfo.flags);
    }
 catch (    SecurityException e) {
      Slog.w(TAG,e.getMessage());
      skip=true;
    }
    if ((info.activityInfo.flags & ActivityInfo.FLAG_SINGLE_USER) != 0) {
      if (ActivityManager.checkUidPermission(android.Manifest.permission.INTERACT_ACROSS_USERS,info.activityInfo.applicationInfo.uid) != PackageManager.PERMISSION_GRANTED) {
        Slog.w(TAG,""String_Node_Str"" + component.flattenToShortString() + ""String_Node_Str""+ android.Manifest.permission.INTERACT_ACROSS_USERS);
        skip=true;
      }
    }
    if (r.curApp != null && r.curApp.crashing) {
      Slog.w(TAG,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r+ ""String_Node_Str""+ r.curApp+ ""String_Node_Str"");
      skip=true;
    }
    if (!skip) {
      boolean isAvailable=false;
      try {
        isAvailable=AppGlobals.getPackageManager().isPackageAvailable(info.activityInfo.packageName,UserHandle.getUserId(info.activityInfo.applicationInfo.uid));
      }
 catch (      Exception e) {
        Slog.w(TAG,""String_Node_Str"" + info.activityInfo.packageName,e);
      }
      if (!isAvailable) {
        if (DEBUG_BROADCAST)         Slog.v(TAG_BROADCAST,""String_Node_Str"" + info.activityInfo.packageName + ""String_Node_Str""+ info.activityInfo.applicationInfo.uid+ ""String_Node_Str"");
        skip=true;
      }
    }
    if (Build.PERMISSIONS_REVIEW_REQUIRED && !skip) {
      if (!requestStartTargetPermissionsReviewIfNeededLocked(r,info.activityInfo.packageName,UserHandle.getUserId(info.activityInfo.applicationInfo.uid))) {
        skip=true;
      }
    }
    final int receiverUid=info.activityInfo.applicationInfo.uid;
    if (r.callingUid != Process.SYSTEM_UID && isSingleton && mService.isValidSingletonCall(r.callingUid,receiverUid)) {
      info.activityInfo=mService.getActivityInfoForUser(info.activityInfo,0);
    }
    String targetProcess=info.activityInfo.processName;
    ProcessRecord app=mService.getProcessRecordLocked(targetProcess,info.activityInfo.applicationInfo.uid,false);
    if (!skip) {
      final int allowed=mService.checkAllowBackgroundLocked(info.activityInfo.applicationInfo.uid,info.activityInfo.packageName,-1,false);
      if (allowed != ActivityManager.APP_START_MODE_NORMAL) {
        if (allowed == ActivityManager.APP_START_MODE_DISABLED) {
          Slog.w(TAG,""String_Node_Str"" + r.intent + ""String_Node_Str""+ component.flattenToShortString());
          skip=true;
        }
 else         if (((r.intent.getFlags() & Intent.FLAG_RECEIVER_EXCLUDE_BACKGROUND) != 0) || (r.intent.getComponent() == null && r.intent.getPackage() == null && ((r.intent.getFlags() & Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND) == 0))) {
          Slog.w(TAG,""String_Node_Str"" + r.intent + ""String_Node_Str""+ component.flattenToShortString());
          skip=true;
        }
      }
    }
    if (skip) {
      if (DEBUG_BROADCAST)       Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ r+ ""String_Node_Str"");
      r.delivery[recIdx]=BroadcastRecord.DELIVERY_SKIPPED;
      r.receiver=null;
      r.curFilter=null;
      r.state=BroadcastRecord.IDLE;
      scheduleBroadcastsLocked();
      return;
    }
    r.delivery[recIdx]=BroadcastRecord.DELIVERY_DELIVERED;
    r.state=BroadcastRecord.APP_RECEIVE;
    r.curComponent=component;
    r.curReceiver=info.activityInfo;
    if (DEBUG_MU && r.callingUid > UserHandle.PER_USER_RANGE) {
      Slog.v(TAG_MU,""String_Node_Str"" + info.activityInfo + ""String_Node_Str""+ r.callingUid+ ""String_Node_Str""+ info.activityInfo.applicationInfo.uid);
    }
    if (brOptions != null && brOptions.getTemporaryAppWhitelistDuration() > 0) {
      scheduleTempWhitelistLocked(receiverUid,brOptions.getTemporaryAppWhitelistDuration(),r);
    }
    try {
      AppGlobals.getPackageManager().setPackageStoppedState(r.curComponent.getPackageName(),false,UserHandle.getUserId(r.callingUid));
    }
 catch (    RemoteException e) {
    }
catch (    IllegalArgumentException e) {
      Slog.w(TAG,""String_Node_Str"" + r.curComponent.getPackageName() + ""String_Node_Str""+ e);
    }
    if (app != null && app.thread != null) {
      try {
        app.addPackage(info.activityInfo.packageName,info.activityInfo.applicationInfo.versionCode,mService.mProcessStats);
        processCurBroadcastLocked(r,app);
        return;
      }
 catch (      RemoteException e) {
        Slog.w(TAG,""String_Node_Str"" + r.curComponent,e);
      }
catch (      RuntimeException e) {
        Slog.wtf(TAG,""String_Node_Str"" + r.curComponent + ""String_Node_Str""+ r.intent,e);
        logBroadcastReceiverDiscardLocked(r);
        finishReceiverLocked(r,r.resultCode,r.resultData,r.resultExtras,r.resultAbort,false);
        scheduleBroadcastsLocked();
        r.state=BroadcastRecord.IDLE;
        return;
      }
    }
    if (DEBUG_BROADCAST)     Slog.v(TAG_BROADCAST,""String_Node_Str"" + mQueueName + ""String_Node_Str""+ targetProcess+ ""String_Node_Str""+ r);
    if ((r.curApp=mService.startProcessLocked(targetProcess,info.activityInfo.applicationInfo,true,r.intent.getFlags() | Intent.FLAG_FROM_BACKGROUND,""String_Node_Str"",r.curComponent,(r.intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) != 0,false,false)) == null) {
      Slog.w(TAG,""String_Node_Str"" + info.activityInfo.applicationInfo.packageName + ""String_Node_Str""+ info.activityInfo.applicationInfo.uid+ ""String_Node_Str""+ r.intent+ ""String_Node_Str"");
      logBroadcastReceiverDiscardLocked(r);
      finishReceiverLocked(r,r.resultCode,r.resultData,r.resultExtras,r.resultAbort,false);
      scheduleBroadcastsLocked();
      r.state=BroadcastRecord.IDLE;
      return;
    }
    mPendingBroadcast=r;
    mPendingBroadcastRecvIndex=recIdx;
  }
}",0.9991397164250438
192380,"public TaskStackView(Context context){
  super(context);
  SystemServicesProxy ssp=Recents.getSystemServices();
  Resources res=context.getResources();
  mStack.setCallbacks(this);
  mViewPool=new ViewPool<>(context,this);
  mInflater=LayoutInflater.from(context);
  mLayoutAlgorithm=new TaskStackLayoutAlgorithm(context,this);
  mStackScroller=new TaskStackViewScroller(context,this,mLayoutAlgorithm);
  mTouchHandler=new TaskStackViewTouchHandler(context,this,mStackScroller);
  mAnimationHelper=new TaskStackAnimationHelper(context,this);
  mTaskCornerRadiusPx=res.getDimensionPixelSize(R.dimen.recents_task_view_rounded_corners_radius);
  mDividerSize=ssp.getDockedDividerSize(context);
  int taskBarDismissDozeDelaySeconds=getResources().getInteger(R.integer.recents_task_bar_dismiss_delay_seconds);
  mUIDozeTrigger=new DozeTrigger(taskBarDismissDozeDelaySeconds,new Runnable(){
    @Override public void run(){
      List<TaskView> taskViews=getTaskViews();
      int taskViewCount=taskViews.size();
      for (int i=0; i < taskViewCount; i++) {
        TaskView tv=taskViews.get(i);
        tv.startNoUserInteractionAnimation();
      }
    }
  }
);
  setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_YES);
  mFreeformWorkspaceBackground=(GradientDrawable)getContext().getDrawable(R.drawable.recents_freeform_workspace_bg);
  mFreeformWorkspaceBackground.setCallback(this);
  if (ssp.hasFreeformWorkspaceSupport()) {
    mFreeformWorkspaceBackground.setColor(getContext().getColor(R.color.recents_freeform_workspace_bg_color));
  }
}","public TaskStackView(Context context){
  super(context);
  SystemServicesProxy ssp=Recents.getSystemServices();
  Resources res=context.getResources();
  mStack.setCallbacks(this);
  mViewPool=new ViewPool<>(context,this);
  mInflater=LayoutInflater.from(context);
  mLayoutAlgorithm=new TaskStackLayoutAlgorithm(context,this);
  mStableLayoutAlgorithm=new TaskStackLayoutAlgorithm(context,null);
  mStackScroller=new TaskStackViewScroller(context,this,mLayoutAlgorithm);
  mTouchHandler=new TaskStackViewTouchHandler(context,this,mStackScroller);
  mAnimationHelper=new TaskStackAnimationHelper(context,this);
  mTaskCornerRadiusPx=res.getDimensionPixelSize(R.dimen.recents_task_view_rounded_corners_radius);
  mDividerSize=ssp.getDockedDividerSize(context);
  int taskBarDismissDozeDelaySeconds=getResources().getInteger(R.integer.recents_task_bar_dismiss_delay_seconds);
  mUIDozeTrigger=new DozeTrigger(taskBarDismissDozeDelaySeconds,new Runnable(){
    @Override public void run(){
      List<TaskView> taskViews=getTaskViews();
      int taskViewCount=taskViews.size();
      for (int i=0; i < taskViewCount; i++) {
        TaskView tv=taskViews.get(i);
        tv.startNoUserInteractionAnimation();
      }
    }
  }
);
  setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_YES);
  mFreeformWorkspaceBackground=(GradientDrawable)getContext().getDrawable(R.drawable.recents_freeform_workspace_bg);
  mFreeformWorkspaceBackground.setCallback(this);
  if (ssp.hasFreeformWorkspaceSupport()) {
    mFreeformWorkspaceBackground.setColor(getContext().getColor(R.color.recents_freeform_workspace_bg_color));
  }
}",0.9782813975448535
192381,"public final void onBusEvent(ConfigurationChangedEvent event){
  mLayoutAlgorithm.reloadOnConfigurationChange(getContext());
  mLayoutAlgorithm.initialize(mWindowRect,mStackBounds,TaskStackLayoutAlgorithm.StackState.getStackStateForStack(mStack));
}","public final void onBusEvent(ConfigurationChangedEvent event){
  mStableLayoutAlgorithm.reloadOnConfigurationChange(getContext());
  mLayoutAlgorithm.reloadOnConfigurationChange(getContext());
  mLayoutAlgorithm.initialize(mWindowRect,mStackBounds,TaskStackLayoutAlgorithm.StackState.getStackStateForStack(mStack));
}",0.8798586572438163
192382,"/** 
 * Lays out a TaskView.
 */
private void layoutTaskView(TaskView tv){
  if (tv.getBackground() != null) {
    tv.getBackground().getPadding(mTmpRect);
  }
 else {
    mTmpRect.setEmpty();
  }
  Rect taskRect=mLayoutAlgorithm.mTaskRect;
  tv.cancelTransformAnimation();
  tv.layout(taskRect.left - mTmpRect.left,taskRect.top - mTmpRect.top,taskRect.right + mTmpRect.right,taskRect.bottom + mTmpRect.bottom);
}","/** 
 * Lays out a TaskView.
 */
private void layoutTaskView(TaskView tv){
  if (tv.getBackground() != null) {
    tv.getBackground().getPadding(mTmpRect);
  }
 else {
    mTmpRect.setEmpty();
  }
  Rect taskRect=mStableLayoutAlgorithm.mTaskRect;
  tv.cancelTransformAnimation();
  tv.layout(taskRect.left - mTmpRect.left,taskRect.top - mTmpRect.top,taskRect.right + mTmpRect.right,taskRect.bottom + mTmpRect.bottom);
}",0.9927884615384616
192383,"/** 
 * Measures a TaskView.
 */
private void measureTaskView(TaskView tv){
  if (tv.getBackground() != null) {
    tv.getBackground().getPadding(mTmpRect);
  }
 else {
    mTmpRect.setEmpty();
  }
  tv.measure(MeasureSpec.makeMeasureSpec(mLayoutAlgorithm.mTaskRect.width() + mTmpRect.left + mTmpRect.right,MeasureSpec.EXACTLY),MeasureSpec.makeMeasureSpec(mLayoutAlgorithm.mTaskRect.height() + mTmpRect.top + mTmpRect.bottom,MeasureSpec.EXACTLY));
}","/** 
 * Measures a TaskView.
 */
private void measureTaskView(TaskView tv){
  if (tv.getBackground() != null) {
    tv.getBackground().getPadding(mTmpRect);
  }
 else {
    mTmpRect.setEmpty();
  }
  Rect taskRect=mStableLayoutAlgorithm.mTaskRect;
  tv.measure(MeasureSpec.makeMeasureSpec(taskRect.width() + mTmpRect.left + mTmpRect.right,MeasureSpec.EXACTLY),MeasureSpec.makeMeasureSpec(taskRect.height() + mTmpRect.top + mTmpRect.bottom,MeasureSpec.EXACTLY));
}",0.8552631578947368
192384,"/** 
 * Updates the system insets.
 */
public void setSystemInsets(Rect systemInsets){
  if (!systemInsets.equals(mLayoutAlgorithm.mSystemInsets)) {
    mLayoutAlgorithm.setSystemInsets(systemInsets);
    requestLayout();
  }
}","/** 
 * Updates the system insets.
 */
public void setSystemInsets(Rect systemInsets){
  if (!systemInsets.equals(mLayoutAlgorithm.mSystemInsets)) {
    mStableLayoutAlgorithm.setSystemInsets(systemInsets);
    mLayoutAlgorithm.setSystemInsets(systemInsets);
    requestLayout();
  }
}",0.88671875
192385,"/** 
 * Called from RecentsActivity when it is relaunched.
 */
void onReload(boolean isResumingFromVisible){
  if (!isResumingFromVisible) {
    resetFocusedTask(getFocusedTask());
  }
  List<TaskView> taskViews=new ArrayList<>();
  taskViews.addAll(getTaskViews());
  taskViews.addAll(mViewPool.getViews());
  for (int i=taskViews.size() - 1; i >= 0; i--) {
    taskViews.get(i).onReload(isResumingFromVisible);
  }
  readSystemFlags();
  mTaskViewsClipDirty=true;
  mEnterAnimationComplete=false;
  mUIDozeTrigger.stopDozing();
  if (isResumingFromVisible) {
    int ffBgAlpha=mLayoutAlgorithm.getStackState().freeformBackgroundAlpha;
    animateFreeformWorkspaceBackgroundAlpha(ffBgAlpha,new AnimationProps(150,Interpolators.FAST_OUT_SLOW_IN));
  }
 else {
    mStackScroller.reset();
    mLayoutAlgorithm.reset();
  }
  mAwaitingFirstLayout=true;
  requestLayout();
}","/** 
 * Called from RecentsActivity when it is relaunched.
 */
void onReload(boolean isResumingFromVisible){
  if (!isResumingFromVisible) {
    resetFocusedTask(getFocusedTask());
  }
  List<TaskView> taskViews=new ArrayList<>();
  taskViews.addAll(getTaskViews());
  taskViews.addAll(mViewPool.getViews());
  for (int i=taskViews.size() - 1; i >= 0; i--) {
    taskViews.get(i).onReload(isResumingFromVisible);
  }
  readSystemFlags();
  mTaskViewsClipDirty=true;
  mEnterAnimationComplete=false;
  mUIDozeTrigger.stopDozing();
  if (isResumingFromVisible) {
    int ffBgAlpha=mLayoutAlgorithm.getStackState().freeformBackgroundAlpha;
    animateFreeformWorkspaceBackgroundAlpha(ffBgAlpha,new AnimationProps(150,Interpolators.FAST_OUT_SLOW_IN));
  }
 else {
    mStackScroller.reset();
    mStableLayoutAlgorithm.reset();
    mLayoutAlgorithm.reset();
  }
  mAwaitingFirstLayout=true;
  requestLayout();
}",0.9797525309336332
192386,"/** 
 * This is called with the full window width and height to allow stack view children to perform the full screen transition down.
 */
@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  mInMeasureLayout=true;
  int width=MeasureSpec.getSize(widthMeasureSpec);
  int height=MeasureSpec.getSize(heightMeasureSpec);
  mLayoutAlgorithm.getTaskStackBounds(new Rect(0,0,width,height),mLayoutAlgorithm.mSystemInsets.top,mLayoutAlgorithm.mSystemInsets.right,mTmpRect);
  if (!mTmpRect.equals(mStableStackBounds)) {
    mStableStackBounds.set(mTmpRect);
    mStackBounds.set(mTmpRect);
    mStableWindowRect.set(0,0,width,height);
    mWindowRect.set(0,0,width,height);
  }
  mLayoutAlgorithm.initialize(mWindowRect,mStackBounds,TaskStackLayoutAlgorithm.StackState.getStackStateForStack(mStack));
  updateLayoutAlgorithm(false,EMPTY_TASK_SET);
  if (mAwaitingFirstLayout || (mStackScroller.getStackScroll() == mLayoutAlgorithm.mInitialScrollP)) {
    updateToInitialState();
  }
  bindVisibleTaskViews(mStackScroller.getStackScroll(),EMPTY_TASK_SET,false);
  mTmpTaskViews.clear();
  mTmpTaskViews.addAll(getTaskViews());
  mTmpTaskViews.addAll(mViewPool.getViews());
  int taskViewCount=mTmpTaskViews.size();
  for (int i=0; i < taskViewCount; i++) {
    measureTaskView(mTmpTaskViews.get(i));
  }
  setMeasuredDimension(width,height);
  mInMeasureLayout=false;
}","/** 
 * This is called with the full window width and height to allow stack view children to perform the full screen transition down.
 */
@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  mInMeasureLayout=true;
  int width=MeasureSpec.getSize(widthMeasureSpec);
  int height=MeasureSpec.getSize(heightMeasureSpec);
  mLayoutAlgorithm.getTaskStackBounds(new Rect(0,0,width,height),mLayoutAlgorithm.mSystemInsets.top,mLayoutAlgorithm.mSystemInsets.right,mTmpRect);
  if (!mTmpRect.equals(mStableStackBounds)) {
    mStableStackBounds.set(mTmpRect);
    mStackBounds.set(mTmpRect);
    mStableWindowRect.set(0,0,width,height);
    mWindowRect.set(0,0,width,height);
  }
  mStableLayoutAlgorithm.initialize(mStableWindowRect,mStableStackBounds,TaskStackLayoutAlgorithm.StackState.getStackStateForStack(mStack));
  mLayoutAlgorithm.initialize(mWindowRect,mStackBounds,TaskStackLayoutAlgorithm.StackState.getStackStateForStack(mStack));
  updateLayoutAlgorithm(false,EMPTY_TASK_SET);
  if (mAwaitingFirstLayout || (mStackScroller.getStackScroll() == mLayoutAlgorithm.mInitialScrollP)) {
    updateToInitialState();
  }
  bindVisibleTaskViews(mStackScroller.getStackScroll(),EMPTY_TASK_SET,false);
  mTmpTaskViews.clear();
  mTmpTaskViews.addAll(getTaskViews());
  mTmpTaskViews.addAll(mViewPool.getViews());
  int taskViewCount=mTmpTaskViews.size();
  for (int i=0; i < taskViewCount; i++) {
    measureTaskView(mTmpTaskViews.get(i));
  }
  setMeasuredDimension(width,height);
  mInMeasureLayout=false;
}",0.9516957862281604
192387,"@Override public void run(){
  float pos=getPos(ev);
  float delta=pos - mInitialTouchPos;
  if (mCurrView != null && !mLongPressSent && Math.abs(delta) < mPagingTouchSlop) {
    mLongPressSent=true;
    mCurrView.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_LONG_CLICKED);
    mCurrView.getLocationOnScreen(mTmpPos);
    final int x=(int)ev.getRawX() - mTmpPos[0];
    final int y=(int)ev.getRawY() - mTmpPos[1];
    mLongPressListener.onLongPress(mCurrView,x,y);
  }
}","@Override public void run(){
  if (mCurrView != null && !mLongPressSent) {
    mLongPressSent=true;
    mCurrView.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_LONG_CLICKED);
    mCurrView.getLocationOnScreen(mTmpPos);
    final int x=(int)ev.getRawX() - mTmpPos[0];
    final int y=(int)ev.getRawY() - mTmpPos[1];
    mLongPressListener.onLongPress(mCurrView,x,y);
  }
}",0.882903981264637
192388,"public boolean onInterceptTouchEvent(final MotionEvent ev){
  final int action=ev.getAction();
switch (action) {
case MotionEvent.ACTION_DOWN:
    mTouchAboveFalsingThreshold=false;
  mDragging=false;
mSnappingChild=false;
mLongPressSent=false;
mVelocityTracker.clear();
mCurrView=mCallback.getChildAtPosition(ev);
if (mCurrView != null) {
onDownUpdate(mCurrView);
mCanCurrViewBeDimissed=mCallback.canChildBeDismissed(mCurrView);
mVelocityTracker.addMovement(ev);
mInitialTouchPos=getPos(ev);
mPerpendicularInitialTouchPos=getPerpendicularPos(ev);
mTranslation=getTranslation(mCurrView);
if (mLongPressListener != null) {
if (mWatchLongPress == null) {
mWatchLongPress=new Runnable(){
@Override public void run(){
  float pos=getPos(ev);
  float delta=pos - mInitialTouchPos;
  if (mCurrView != null && !mLongPressSent && Math.abs(delta) < mPagingTouchSlop) {
    mLongPressSent=true;
    mCurrView.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_LONG_CLICKED);
    mCurrView.getLocationOnScreen(mTmpPos);
    final int x=(int)ev.getRawX() - mTmpPos[0];
    final int y=(int)ev.getRawY() - mTmpPos[1];
    mLongPressListener.onLongPress(mCurrView,x,y);
  }
}
}
;
}
mHandler.postDelayed(mWatchLongPress,mLongPressTimeout);
}
}
break;
case MotionEvent.ACTION_MOVE:
if (mCurrView != null && !mLongPressSent) {
mVelocityTracker.addMovement(ev);
float pos=getPos(ev);
float perpendicularPos=getPerpendicularPos(ev);
float delta=pos - mInitialTouchPos;
float deltaPerpendicular=perpendicularPos - mPerpendicularInitialTouchPos;
if (Math.abs(delta) > mPagingTouchSlop && Math.abs(delta) > Math.abs(deltaPerpendicular)) {
mCallback.onBeginDrag(mCurrView);
mDragging=true;
mInitialTouchPos=getPos(ev);
mTranslation=getTranslation(mCurrView);
removeLongPressCallback();
}
}
break;
case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_CANCEL:
final boolean captured=(mDragging || mLongPressSent);
mDragging=false;
mCurrView=null;
mLongPressSent=false;
removeLongPressCallback();
if (captured) return true;
break;
}
return mDragging || mLongPressSent;
}","public boolean onInterceptTouchEvent(final MotionEvent ev){
  final int action=ev.getAction();
switch (action) {
case MotionEvent.ACTION_DOWN:
    mTouchAboveFalsingThreshold=false;
  mDragging=false;
mSnappingChild=false;
mLongPressSent=false;
mVelocityTracker.clear();
mCurrView=mCallback.getChildAtPosition(ev);
if (mCurrView != null) {
onDownUpdate(mCurrView);
mCanCurrViewBeDimissed=mCallback.canChildBeDismissed(mCurrView);
mVelocityTracker.addMovement(ev);
mInitialTouchPos=getPos(ev);
mPerpendicularInitialTouchPos=getPerpendicularPos(ev);
mTranslation=getTranslation(mCurrView);
if (mLongPressListener != null) {
if (mWatchLongPress == null) {
mWatchLongPress=new Runnable(){
@Override public void run(){
  if (mCurrView != null && !mLongPressSent) {
    mLongPressSent=true;
    mCurrView.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_LONG_CLICKED);
    mCurrView.getLocationOnScreen(mTmpPos);
    final int x=(int)ev.getRawX() - mTmpPos[0];
    final int y=(int)ev.getRawY() - mTmpPos[1];
    mLongPressListener.onLongPress(mCurrView,x,y);
  }
}
}
;
}
mHandler.postDelayed(mWatchLongPress,mLongPressTimeout);
}
}
break;
case MotionEvent.ACTION_MOVE:
if (mCurrView != null && !mLongPressSent) {
mVelocityTracker.addMovement(ev);
float pos=getPos(ev);
float perpendicularPos=getPerpendicularPos(ev);
float delta=pos - mInitialTouchPos;
float deltaPerpendicular=perpendicularPos - mPerpendicularInitialTouchPos;
if (Math.abs(delta) > mPagingTouchSlop && Math.abs(delta) > Math.abs(deltaPerpendicular)) {
mCallback.onBeginDrag(mCurrView);
mDragging=true;
mInitialTouchPos=getPos(ev);
mTranslation=getTranslation(mCurrView);
removeLongPressCallback();
}
}
break;
case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_CANCEL:
final boolean captured=(mDragging || mLongPressSent);
mDragging=false;
mCurrView=null;
mLongPressSent=false;
removeLongPressCallback();
if (captured) return true;
break;
}
return mDragging || mLongPressSent;
}",0.9749247743229688
192389,"/** 
 * @param maximum the maximum to return at most
 * @return the maximum keyguard notifications that can fit on the screen
 */
public int computeMaxKeyguardNotifications(int maximum){
  float minPadding=mClockPositionAlgorithm.getMinStackScrollerPadding(getHeight(),mKeyguardStatusView.getHeight());
  int notificationPadding=Math.max(1,getResources().getDimensionPixelSize(R.dimen.notification_divider_height));
  final int overflowheight=getResources().getDimensionPixelSize(R.dimen.notification_summary_height);
  float bottomStackSize=mNotificationStackScroller.getKeyguardBottomStackSize();
  float availableSpace=mNotificationStackScroller.getHeight() - minPadding - overflowheight- bottomStackSize;
  int count=0;
  for (int i=0; i < mNotificationStackScroller.getChildCount(); i++) {
    ExpandableView child=(ExpandableView)mNotificationStackScroller.getChildAt(i);
    if (!(child instanceof ExpandableNotificationRow)) {
      continue;
    }
    availableSpace-=child.getMinHeight() + notificationPadding;
    if (availableSpace >= 0 && count < maximum) {
      count++;
    }
 else {
      return count;
    }
  }
  return count;
}","/** 
 * @param maximum the maximum to return at most
 * @return the maximum keyguard notifications that can fit on the screen
 */
public int computeMaxKeyguardNotifications(int maximum){
  float minPadding=mClockPositionAlgorithm.getMinStackScrollerPadding(getHeight(),mKeyguardStatusView.getHeight());
  int notificationPadding=Math.max(1,getResources().getDimensionPixelSize(R.dimen.notification_divider_height));
  final int overflowheight=getResources().getDimensionPixelSize(R.dimen.notification_summary_height);
  float bottomStackSize=mNotificationStackScroller.getKeyguardBottomStackSize();
  float availableSpace=mNotificationStackScroller.getHeight() - minPadding - overflowheight- bottomStackSize;
  int count=0;
  for (int i=0; i < mNotificationStackScroller.getChildCount(); i++) {
    ExpandableView child=(ExpandableView)mNotificationStackScroller.getChildAt(i);
    if (!(child instanceof ExpandableNotificationRow)) {
      continue;
    }
    boolean suppressedSummary=mGroupManager.isSummaryOfSuppressedGroup(((ExpandableNotificationRow)child).getStatusBarNotification());
    if (suppressedSummary) {
      continue;
    }
    availableSpace-=child.getMinHeight() + notificationPadding;
    if (availableSpace >= 0 && count < maximum) {
      count++;
    }
 else {
      return count;
    }
  }
  return count;
}",0.925
192390,"protected PhoneStatusBarView makeStatusBarView(){
  final Context context=mContext;
  updateDisplaySize();
  updateResources();
  inflateStatusBarWindow(context);
  mStatusBarWindow.setService(this);
  mStatusBarWindow.setOnTouchListener(new View.OnTouchListener(){
    @Override public boolean onTouch(    View v,    MotionEvent event){
      checkUserAutohide(v,event);
      if (event.getAction() == MotionEvent.ACTION_DOWN) {
        if (mExpandedVisible) {
          animateCollapsePanels();
        }
      }
      return mStatusBarWindow.onTouchEvent(event);
    }
  }
);
  mNotificationPanel=(NotificationPanelView)mStatusBarWindow.findViewById(R.id.notification_panel);
  mNotificationPanel.setStatusBar(this);
  mStatusBarView=(PhoneStatusBarView)mStatusBarWindow.findViewById(R.id.status_bar);
  mStatusBarView.setBar(this);
  mStatusBarView.setPanel(mNotificationPanel);
  if (!ActivityManager.isHighEndGfx()) {
    mStatusBarWindow.setBackground(null);
    mNotificationPanel.setBackground(new FastColorDrawable(context.getColor(R.color.notification_panel_solid_background)));
  }
  mHeadsUpManager=new HeadsUpManager(context,mStatusBarWindow,mGroupManager);
  mHeadsUpManager.setBar(this);
  mHeadsUpManager.addListener(this);
  mHeadsUpManager.addListener(mNotificationPanel);
  mHeadsUpManager.addListener(mGroupManager);
  mNotificationPanel.setHeadsUpManager(mHeadsUpManager);
  mNotificationData.setHeadsUpManager(mHeadsUpManager);
  if (MULTIUSER_DEBUG) {
    mNotificationPanelDebugText=(TextView)mNotificationPanel.findViewById(R.id.header_debug_info);
    mNotificationPanelDebugText.setVisibility(View.VISIBLE);
  }
  try {
    boolean showNav=mWindowManagerService.hasNavigationBar();
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + showNav);
    if (showNav) {
      createNavigationBarView(context);
    }
  }
 catch (  RemoteException ex) {
  }
  mAssistManager=new AssistManager(this,context);
  mPixelFormat=PixelFormat.OPAQUE;
  mStackScroller=(NotificationStackScrollLayout)mStatusBarWindow.findViewById(R.id.notification_stack_scroller);
  mStackScroller.setLongPressListener(getNotificationLongClicker());
  mStackScroller.setGearDisplayedListener(getGearDisplayedListener());
  mStackScroller.setPhoneStatusBar(this);
  mStackScroller.setGroupManager(mGroupManager);
  mStackScroller.setHeadsUpManager(mHeadsUpManager);
  mGroupManager.setOnGroupChangeListener(mStackScroller);
  mKeyguardIconOverflowContainer=(NotificationOverflowContainer)LayoutInflater.from(mContext).inflate(R.layout.status_bar_notification_keyguard_overflow,mStackScroller,false);
  mKeyguardIconOverflowContainer.setOnActivatedListener(this);
  mKeyguardIconOverflowContainer.setOnClickListener(mOverflowClickListener);
  mStackScroller.setOverflowContainer(mKeyguardIconOverflowContainer);
  inflateEmptyShadeView();
  inflateDismissView();
  mExpandedContents=mStackScroller;
  mBackdrop=(BackDropView)mStatusBarWindow.findViewById(R.id.backdrop);
  mBackdropFront=(ImageView)mBackdrop.findViewById(R.id.backdrop_front);
  mBackdropBack=(ImageView)mBackdrop.findViewById(R.id.backdrop_back);
  ScrimView scrimBehind=(ScrimView)mStatusBarWindow.findViewById(R.id.scrim_behind);
  ScrimView scrimInFront=(ScrimView)mStatusBarWindow.findViewById(R.id.scrim_in_front);
  View headsUpScrim=mStatusBarWindow.findViewById(R.id.heads_up_scrim);
  mScrimController=SystemUIFactory.getInstance().createScrimController(scrimBehind,scrimInFront,headsUpScrim);
  if (mScrimSrcModeEnabled) {
    Runnable runnable=new Runnable(){
      @Override public void run(){
        boolean asSrc=mBackdrop.getVisibility() != View.VISIBLE;
        mScrimController.setDrawBehindAsSrc(asSrc);
        mStackScroller.setDrawBackgroundAsSrc(asSrc);
      }
    }
;
    mBackdrop.setOnVisibilityChangedRunnable(runnable);
    runnable.run();
  }
  mHeadsUpManager.addListener(mScrimController);
  mStackScroller.setScrimController(mScrimController);
  mStatusBarView.setScrimController(mScrimController);
  mDozeScrimController=new DozeScrimController(mScrimController,context);
  mKeyguardStatusBar=(KeyguardStatusBarView)mStatusBarWindow.findViewById(R.id.keyguard_header);
  mKeyguardStatusView=mStatusBarWindow.findViewById(R.id.keyguard_status_view);
  mKeyguardBottomArea=(KeyguardBottomAreaView)mStatusBarWindow.findViewById(R.id.keyguard_bottom_area);
  mKeyguardBottomArea.setActivityStarter(this);
  mKeyguardBottomArea.setAssistManager(mAssistManager);
  mKeyguardIndicationController=new KeyguardIndicationController(mContext,(KeyguardIndicationTextView)mStatusBarWindow.findViewById(R.id.keyguard_indication_text),mKeyguardBottomArea.getLockIcon());
  mKeyguardBottomArea.setKeyguardIndicationController(mKeyguardIndicationController);
  if (ENABLE_LOCKSCREEN_WALLPAPER) {
    mLockscreenWallpaper=new LockscreenWallpaper(mContext,this,mHandler);
  }
  setAreThereNotifications();
  createIconController();
  mHandlerThread=new HandlerThread(TAG,Process.THREAD_PRIORITY_BACKGROUND);
  mHandlerThread.start();
  mLocationController=new LocationControllerImpl(mContext,mHandlerThread.getLooper());
  mBatteryController=new BatteryController(mContext);
  mBatteryController.addStateChangedCallback(new BatteryStateChangeCallback(){
    @Override public void onPowerSaveChanged(    boolean isPowerSave){
      mHandler.post(mCheckBarModes);
      if (mDozeServiceHost != null) {
        mDozeServiceHost.firePowerSaveChanged(isPowerSave);
      }
    }
    @Override public void onBatteryLevelChanged(    int level,    boolean pluggedIn,    boolean charging){
    }
  }
);
  mNetworkController=new NetworkControllerImpl(mContext,mHandlerThread.getLooper());
  mHotspotController=new HotspotControllerImpl(mContext);
  mBluetoothController=new BluetoothControllerImpl(mContext,mHandlerThread.getLooper());
  mSecurityController=new SecurityControllerImpl(mContext);
  if (mContext.getResources().getBoolean(R.bool.config_showRotationLock)) {
    mRotationLockController=new RotationLockControllerImpl(mContext);
  }
  mUserInfoController=new UserInfoController(mContext);
  mVolumeComponent=getComponent(VolumeComponent.class);
  if (mVolumeComponent != null) {
    mZenModeController=mVolumeComponent.getZenController();
  }
  mCastController=new CastControllerImpl(mContext);
  initSignalCluster(mStatusBarView);
  initSignalCluster(mKeyguardStatusBar);
  mFlashlightController=new FlashlightController(mContext);
  mKeyguardBottomArea.setFlashlightController(mFlashlightController);
  mKeyguardBottomArea.setPhoneStatusBar(this);
  mKeyguardBottomArea.setUserSetupComplete(mUserSetup);
  mAccessibilityController=new AccessibilityController(mContext);
  mKeyguardBottomArea.setAccessibilityController(mAccessibilityController);
  mNextAlarmController=new NextAlarmController(mContext);
  mLightStatusBarController=new LightStatusBarController(mIconController,mBatteryController);
  mKeyguardMonitor=new KeyguardMonitor(mContext);
  if (UserManager.get(mContext).isUserSwitcherEnabled()) {
    mUserSwitcherController=new UserSwitcherController(mContext,mKeyguardMonitor,mHandler,this);
    createUserSwitcher();
  }
  DensityContainer container=(DensityContainer)mStatusBarWindow.findViewById(R.id.qs_density_container);
  if (container != null) {
    final QSTileHost qsh=new QSTileHost(mContext,this,mBluetoothController,mLocationController,mRotationLockController,mNetworkController,mZenModeController,mHotspotController,mCastController,mFlashlightController,mUserSwitcherController,mUserInfoController,mKeyguardMonitor,mSecurityController,mBatteryController,mIconController,mNextAlarmController);
    mBrightnessMirrorController=new BrightnessMirrorController(mStatusBarWindow);
    container.addInflateListener(new InflateListener(){
      @Override public void onInflated(      View v){
        QSContainer qsContainer=(QSContainer)v.findViewById(R.id.quick_settings_container);
        qsContainer.setHost(qsh);
        mQSPanel=qsContainer.getQsPanel();
        mQSPanel.setBrightnessMirror(mBrightnessMirrorController);
        mHeader=qsContainer.getHeader();
        initSignalCluster(mHeader);
        mHeader.setActivityStarter(PhoneStatusBar.this);
      }
    }
);
  }
  mKeyguardStatusBar.setUserInfoController(mUserInfoController);
  mKeyguardStatusBar.setUserSwitcherController(mUserSwitcherController);
  mUserInfoController.reloadUserInfo();
  ((BatteryMeterView)mStatusBarView.findViewById(R.id.battery)).setBatteryController(mBatteryController);
  mKeyguardStatusBar.setBatteryController(mBatteryController);
  PowerManager pm=(PowerManager)mContext.getSystemService(Context.POWER_SERVICE);
  mBroadcastReceiver.onReceive(mContext,new Intent(pm.isScreenOn() ? Intent.ACTION_SCREEN_ON : Intent.ACTION_SCREEN_OFF));
  mGestureWakeLock=pm.newWakeLock(PowerManager.SCREEN_BRIGHT_WAKE_LOCK,""String_Node_Str"");
  mVibrator=mContext.getSystemService(Vibrator.class);
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
  filter.addAction(Intent.ACTION_SCREEN_OFF);
  filter.addAction(Intent.ACTION_SCREEN_ON);
  context.registerReceiverAsUser(mBroadcastReceiver,UserHandle.ALL,filter,null,null);
  IntentFilter demoFilter=new IntentFilter();
  if (DEBUG_MEDIA_FAKE_ARTWORK) {
    demoFilter.addAction(ACTION_FAKE_ARTWORK);
  }
  demoFilter.addAction(ACTION_DEMO);
  context.registerReceiverAsUser(mDemoReceiver,UserHandle.ALL,demoFilter,android.Manifest.permission.DUMP,null);
  resetUserSetupObserver();
  ThreadedRenderer.overrideProperty(""String_Node_Str"",""String_Node_Str"");
  ThreadedRenderer.overrideProperty(""String_Node_Str"",String.valueOf(1.5f));
  return mStatusBarView;
}","protected PhoneStatusBarView makeStatusBarView(){
  final Context context=mContext;
  updateDisplaySize();
  updateResources();
  inflateStatusBarWindow(context);
  mStatusBarWindow.setService(this);
  mStatusBarWindow.setOnTouchListener(new View.OnTouchListener(){
    @Override public boolean onTouch(    View v,    MotionEvent event){
      checkUserAutohide(v,event);
      if (event.getAction() == MotionEvent.ACTION_DOWN) {
        if (mExpandedVisible) {
          animateCollapsePanels();
        }
      }
      return mStatusBarWindow.onTouchEvent(event);
    }
  }
);
  mNotificationPanel=(NotificationPanelView)mStatusBarWindow.findViewById(R.id.notification_panel);
  mNotificationPanel.setStatusBar(this);
  mNotificationPanel.setGroupManager(mGroupManager);
  mStatusBarView=(PhoneStatusBarView)mStatusBarWindow.findViewById(R.id.status_bar);
  mStatusBarView.setBar(this);
  mStatusBarView.setPanel(mNotificationPanel);
  if (!ActivityManager.isHighEndGfx()) {
    mStatusBarWindow.setBackground(null);
    mNotificationPanel.setBackground(new FastColorDrawable(context.getColor(R.color.notification_panel_solid_background)));
  }
  mHeadsUpManager=new HeadsUpManager(context,mStatusBarWindow,mGroupManager);
  mHeadsUpManager.setBar(this);
  mHeadsUpManager.addListener(this);
  mHeadsUpManager.addListener(mNotificationPanel);
  mHeadsUpManager.addListener(mGroupManager);
  mNotificationPanel.setHeadsUpManager(mHeadsUpManager);
  mNotificationData.setHeadsUpManager(mHeadsUpManager);
  if (MULTIUSER_DEBUG) {
    mNotificationPanelDebugText=(TextView)mNotificationPanel.findViewById(R.id.header_debug_info);
    mNotificationPanelDebugText.setVisibility(View.VISIBLE);
  }
  try {
    boolean showNav=mWindowManagerService.hasNavigationBar();
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + showNav);
    if (showNav) {
      createNavigationBarView(context);
    }
  }
 catch (  RemoteException ex) {
  }
  mAssistManager=new AssistManager(this,context);
  mPixelFormat=PixelFormat.OPAQUE;
  mStackScroller=(NotificationStackScrollLayout)mStatusBarWindow.findViewById(R.id.notification_stack_scroller);
  mStackScroller.setLongPressListener(getNotificationLongClicker());
  mStackScroller.setGearDisplayedListener(getGearDisplayedListener());
  mStackScroller.setPhoneStatusBar(this);
  mStackScroller.setGroupManager(mGroupManager);
  mStackScroller.setHeadsUpManager(mHeadsUpManager);
  mGroupManager.setOnGroupChangeListener(mStackScroller);
  mKeyguardIconOverflowContainer=(NotificationOverflowContainer)LayoutInflater.from(mContext).inflate(R.layout.status_bar_notification_keyguard_overflow,mStackScroller,false);
  mKeyguardIconOverflowContainer.setOnActivatedListener(this);
  mKeyguardIconOverflowContainer.setOnClickListener(mOverflowClickListener);
  mStackScroller.setOverflowContainer(mKeyguardIconOverflowContainer);
  inflateEmptyShadeView();
  inflateDismissView();
  mExpandedContents=mStackScroller;
  mBackdrop=(BackDropView)mStatusBarWindow.findViewById(R.id.backdrop);
  mBackdropFront=(ImageView)mBackdrop.findViewById(R.id.backdrop_front);
  mBackdropBack=(ImageView)mBackdrop.findViewById(R.id.backdrop_back);
  ScrimView scrimBehind=(ScrimView)mStatusBarWindow.findViewById(R.id.scrim_behind);
  ScrimView scrimInFront=(ScrimView)mStatusBarWindow.findViewById(R.id.scrim_in_front);
  View headsUpScrim=mStatusBarWindow.findViewById(R.id.heads_up_scrim);
  mScrimController=SystemUIFactory.getInstance().createScrimController(scrimBehind,scrimInFront,headsUpScrim);
  if (mScrimSrcModeEnabled) {
    Runnable runnable=new Runnable(){
      @Override public void run(){
        boolean asSrc=mBackdrop.getVisibility() != View.VISIBLE;
        mScrimController.setDrawBehindAsSrc(asSrc);
        mStackScroller.setDrawBackgroundAsSrc(asSrc);
      }
    }
;
    mBackdrop.setOnVisibilityChangedRunnable(runnable);
    runnable.run();
  }
  mHeadsUpManager.addListener(mScrimController);
  mStackScroller.setScrimController(mScrimController);
  mStatusBarView.setScrimController(mScrimController);
  mDozeScrimController=new DozeScrimController(mScrimController,context);
  mKeyguardStatusBar=(KeyguardStatusBarView)mStatusBarWindow.findViewById(R.id.keyguard_header);
  mKeyguardStatusView=mStatusBarWindow.findViewById(R.id.keyguard_status_view);
  mKeyguardBottomArea=(KeyguardBottomAreaView)mStatusBarWindow.findViewById(R.id.keyguard_bottom_area);
  mKeyguardBottomArea.setActivityStarter(this);
  mKeyguardBottomArea.setAssistManager(mAssistManager);
  mKeyguardIndicationController=new KeyguardIndicationController(mContext,(KeyguardIndicationTextView)mStatusBarWindow.findViewById(R.id.keyguard_indication_text),mKeyguardBottomArea.getLockIcon());
  mKeyguardBottomArea.setKeyguardIndicationController(mKeyguardIndicationController);
  if (ENABLE_LOCKSCREEN_WALLPAPER) {
    mLockscreenWallpaper=new LockscreenWallpaper(mContext,this,mHandler);
  }
  setAreThereNotifications();
  createIconController();
  mHandlerThread=new HandlerThread(TAG,Process.THREAD_PRIORITY_BACKGROUND);
  mHandlerThread.start();
  mLocationController=new LocationControllerImpl(mContext,mHandlerThread.getLooper());
  mBatteryController=new BatteryController(mContext);
  mBatteryController.addStateChangedCallback(new BatteryStateChangeCallback(){
    @Override public void onPowerSaveChanged(    boolean isPowerSave){
      mHandler.post(mCheckBarModes);
      if (mDozeServiceHost != null) {
        mDozeServiceHost.firePowerSaveChanged(isPowerSave);
      }
    }
    @Override public void onBatteryLevelChanged(    int level,    boolean pluggedIn,    boolean charging){
    }
  }
);
  mNetworkController=new NetworkControllerImpl(mContext,mHandlerThread.getLooper());
  mHotspotController=new HotspotControllerImpl(mContext);
  mBluetoothController=new BluetoothControllerImpl(mContext,mHandlerThread.getLooper());
  mSecurityController=new SecurityControllerImpl(mContext);
  if (mContext.getResources().getBoolean(R.bool.config_showRotationLock)) {
    mRotationLockController=new RotationLockControllerImpl(mContext);
  }
  mUserInfoController=new UserInfoController(mContext);
  mVolumeComponent=getComponent(VolumeComponent.class);
  if (mVolumeComponent != null) {
    mZenModeController=mVolumeComponent.getZenController();
  }
  mCastController=new CastControllerImpl(mContext);
  initSignalCluster(mStatusBarView);
  initSignalCluster(mKeyguardStatusBar);
  mFlashlightController=new FlashlightController(mContext);
  mKeyguardBottomArea.setFlashlightController(mFlashlightController);
  mKeyguardBottomArea.setPhoneStatusBar(this);
  mKeyguardBottomArea.setUserSetupComplete(mUserSetup);
  mAccessibilityController=new AccessibilityController(mContext);
  mKeyguardBottomArea.setAccessibilityController(mAccessibilityController);
  mNextAlarmController=new NextAlarmController(mContext);
  mLightStatusBarController=new LightStatusBarController(mIconController,mBatteryController);
  mKeyguardMonitor=new KeyguardMonitor(mContext);
  if (UserManager.get(mContext).isUserSwitcherEnabled()) {
    mUserSwitcherController=new UserSwitcherController(mContext,mKeyguardMonitor,mHandler,this);
    createUserSwitcher();
  }
  DensityContainer container=(DensityContainer)mStatusBarWindow.findViewById(R.id.qs_density_container);
  if (container != null) {
    final QSTileHost qsh=new QSTileHost(mContext,this,mBluetoothController,mLocationController,mRotationLockController,mNetworkController,mZenModeController,mHotspotController,mCastController,mFlashlightController,mUserSwitcherController,mUserInfoController,mKeyguardMonitor,mSecurityController,mBatteryController,mIconController,mNextAlarmController);
    mBrightnessMirrorController=new BrightnessMirrorController(mStatusBarWindow);
    container.addInflateListener(new InflateListener(){
      @Override public void onInflated(      View v){
        QSContainer qsContainer=(QSContainer)v.findViewById(R.id.quick_settings_container);
        qsContainer.setHost(qsh);
        mQSPanel=qsContainer.getQsPanel();
        mQSPanel.setBrightnessMirror(mBrightnessMirrorController);
        mHeader=qsContainer.getHeader();
        initSignalCluster(mHeader);
        mHeader.setActivityStarter(PhoneStatusBar.this);
      }
    }
);
  }
  mKeyguardStatusBar.setUserInfoController(mUserInfoController);
  mKeyguardStatusBar.setUserSwitcherController(mUserSwitcherController);
  mUserInfoController.reloadUserInfo();
  ((BatteryMeterView)mStatusBarView.findViewById(R.id.battery)).setBatteryController(mBatteryController);
  mKeyguardStatusBar.setBatteryController(mBatteryController);
  PowerManager pm=(PowerManager)mContext.getSystemService(Context.POWER_SERVICE);
  mBroadcastReceiver.onReceive(mContext,new Intent(pm.isScreenOn() ? Intent.ACTION_SCREEN_ON : Intent.ACTION_SCREEN_OFF));
  mGestureWakeLock=pm.newWakeLock(PowerManager.SCREEN_BRIGHT_WAKE_LOCK,""String_Node_Str"");
  mVibrator=mContext.getSystemService(Vibrator.class);
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
  filter.addAction(Intent.ACTION_SCREEN_OFF);
  filter.addAction(Intent.ACTION_SCREEN_ON);
  context.registerReceiverAsUser(mBroadcastReceiver,UserHandle.ALL,filter,null,null);
  IntentFilter demoFilter=new IntentFilter();
  if (DEBUG_MEDIA_FAKE_ARTWORK) {
    demoFilter.addAction(ACTION_FAKE_ARTWORK);
  }
  demoFilter.addAction(ACTION_DEMO);
  context.registerReceiverAsUser(mDemoReceiver,UserHandle.ALL,demoFilter,android.Manifest.permission.DUMP,null);
  resetUserSetupObserver();
  ThreadedRenderer.overrideProperty(""String_Node_Str"",""String_Node_Str"");
  ThreadedRenderer.overrideProperty(""String_Node_Str"",String.valueOf(1.5f));
  return mStatusBarView;
}",0.9972580061048166
192391,"/** 
 * @param maximum the maximum to return at most
 * @return the maximum keyguard notifications that can fit on the screen
 */
public int computeMaxKeyguardNotifications(int maximum){
  float minPadding=mClockPositionAlgorithm.getMinStackScrollerPadding(getHeight(),mKeyguardStatusView.getHeight());
  int notificationPadding=Math.max(1,getResources().getDimensionPixelSize(R.dimen.notification_divider_height));
  final int overflowheight=getResources().getDimensionPixelSize(R.dimen.notification_summary_height);
  float bottomStackSize=mNotificationStackScroller.getKeyguardBottomStackSize();
  float availableSpace=mNotificationStackScroller.getHeight() - minPadding - overflowheight- bottomStackSize;
  int count=0;
  for (int i=0; i < mNotificationStackScroller.getChildCount(); i++) {
    ExpandableView child=(ExpandableView)mNotificationStackScroller.getChildAt(i);
    if (!(child instanceof ExpandableNotificationRow)) {
      continue;
    }
    availableSpace-=child.getMinHeight() + notificationPadding;
    if (availableSpace >= 0 && count < maximum) {
      count++;
    }
 else {
      return count;
    }
  }
  return count;
}","/** 
 * @param maximum the maximum to return at most
 * @return the maximum keyguard notifications that can fit on the screen
 */
public int computeMaxKeyguardNotifications(int maximum){
  float minPadding=mClockPositionAlgorithm.getMinStackScrollerPadding(getHeight(),mKeyguardStatusView.getHeight());
  int notificationPadding=Math.max(1,getResources().getDimensionPixelSize(R.dimen.notification_divider_height));
  final int overflowheight=getResources().getDimensionPixelSize(R.dimen.notification_summary_height);
  float bottomStackSize=mNotificationStackScroller.getKeyguardBottomStackSize();
  float availableSpace=mNotificationStackScroller.getHeight() - minPadding - overflowheight- bottomStackSize;
  int count=0;
  for (int i=0; i < mNotificationStackScroller.getChildCount(); i++) {
    ExpandableView child=(ExpandableView)mNotificationStackScroller.getChildAt(i);
    if (!(child instanceof ExpandableNotificationRow)) {
      continue;
    }
    boolean suppressedSummary=mGroupManager.isSummaryOfSuppressedGroup(((ExpandableNotificationRow)child).getStatusBarNotification());
    if (suppressedSummary) {
      continue;
    }
    availableSpace-=child.getMinHeight() + notificationPadding;
    if (availableSpace >= 0 && count < maximum) {
      count++;
    }
 else {
      return count;
    }
  }
  return count;
}",0.925
192392,"protected PhoneStatusBarView makeStatusBarView(){
  final Context context=mContext;
  updateDisplaySize();
  updateResources();
  inflateStatusBarWindow(context);
  mStatusBarWindow.setService(this);
  mStatusBarWindow.setOnTouchListener(new View.OnTouchListener(){
    @Override public boolean onTouch(    View v,    MotionEvent event){
      checkUserAutohide(v,event);
      if (event.getAction() == MotionEvent.ACTION_DOWN) {
        if (mExpandedVisible) {
          animateCollapsePanels();
        }
      }
      return mStatusBarWindow.onTouchEvent(event);
    }
  }
);
  mNotificationPanel=(NotificationPanelView)mStatusBarWindow.findViewById(R.id.notification_panel);
  mNotificationPanel.setStatusBar(this);
  mStatusBarView=(PhoneStatusBarView)mStatusBarWindow.findViewById(R.id.status_bar);
  mStatusBarView.setBar(this);
  mStatusBarView.setPanel(mNotificationPanel);
  if (!ActivityManager.isHighEndGfx()) {
    mStatusBarWindow.setBackground(null);
    mNotificationPanel.setBackground(new FastColorDrawable(context.getColor(R.color.notification_panel_solid_background)));
  }
  mHeadsUpManager=new HeadsUpManager(context,mStatusBarWindow,mGroupManager);
  mHeadsUpManager.setBar(this);
  mHeadsUpManager.addListener(this);
  mHeadsUpManager.addListener(mNotificationPanel);
  mHeadsUpManager.addListener(mGroupManager);
  mNotificationPanel.setHeadsUpManager(mHeadsUpManager);
  mNotificationData.setHeadsUpManager(mHeadsUpManager);
  if (MULTIUSER_DEBUG) {
    mNotificationPanelDebugText=(TextView)mNotificationPanel.findViewById(R.id.header_debug_info);
    mNotificationPanelDebugText.setVisibility(View.VISIBLE);
  }
  try {
    boolean showNav=mWindowManagerService.hasNavigationBar();
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + showNav);
    if (showNav) {
      createNavigationBarView(context);
    }
  }
 catch (  RemoteException ex) {
  }
  mAssistManager=new AssistManager(this,context);
  mPixelFormat=PixelFormat.OPAQUE;
  mStackScroller=(NotificationStackScrollLayout)mStatusBarWindow.findViewById(R.id.notification_stack_scroller);
  mStackScroller.setLongPressListener(getNotificationLongClicker());
  mStackScroller.setGearDisplayedListener(getGearDisplayedListener());
  mStackScroller.setPhoneStatusBar(this);
  mStackScroller.setGroupManager(mGroupManager);
  mStackScroller.setHeadsUpManager(mHeadsUpManager);
  mGroupManager.setOnGroupChangeListener(mStackScroller);
  mKeyguardIconOverflowContainer=(NotificationOverflowContainer)LayoutInflater.from(mContext).inflate(R.layout.status_bar_notification_keyguard_overflow,mStackScroller,false);
  mKeyguardIconOverflowContainer.setOnActivatedListener(this);
  mKeyguardIconOverflowContainer.setOnClickListener(mOverflowClickListener);
  mStackScroller.setOverflowContainer(mKeyguardIconOverflowContainer);
  inflateEmptyShadeView();
  inflateDismissView();
  mExpandedContents=mStackScroller;
  mBackdrop=(BackDropView)mStatusBarWindow.findViewById(R.id.backdrop);
  mBackdropFront=(ImageView)mBackdrop.findViewById(R.id.backdrop_front);
  mBackdropBack=(ImageView)mBackdrop.findViewById(R.id.backdrop_back);
  ScrimView scrimBehind=(ScrimView)mStatusBarWindow.findViewById(R.id.scrim_behind);
  ScrimView scrimInFront=(ScrimView)mStatusBarWindow.findViewById(R.id.scrim_in_front);
  View headsUpScrim=mStatusBarWindow.findViewById(R.id.heads_up_scrim);
  mScrimController=SystemUIFactory.getInstance().createScrimController(scrimBehind,scrimInFront,headsUpScrim);
  if (mScrimSrcModeEnabled) {
    Runnable runnable=new Runnable(){
      @Override public void run(){
        boolean asSrc=mBackdrop.getVisibility() != View.VISIBLE;
        mScrimController.setDrawBehindAsSrc(asSrc);
        mStackScroller.setDrawBackgroundAsSrc(asSrc);
      }
    }
;
    mBackdrop.setOnVisibilityChangedRunnable(runnable);
    runnable.run();
  }
  mHeadsUpManager.addListener(mScrimController);
  mStackScroller.setScrimController(mScrimController);
  mStatusBarView.setScrimController(mScrimController);
  mDozeScrimController=new DozeScrimController(mScrimController,context);
  mKeyguardStatusBar=(KeyguardStatusBarView)mStatusBarWindow.findViewById(R.id.keyguard_header);
  mKeyguardStatusView=mStatusBarWindow.findViewById(R.id.keyguard_status_view);
  mKeyguardBottomArea=(KeyguardBottomAreaView)mStatusBarWindow.findViewById(R.id.keyguard_bottom_area);
  mKeyguardBottomArea.setActivityStarter(this);
  mKeyguardBottomArea.setAssistManager(mAssistManager);
  mKeyguardIndicationController=new KeyguardIndicationController(mContext,(KeyguardIndicationTextView)mStatusBarWindow.findViewById(R.id.keyguard_indication_text),mKeyguardBottomArea.getLockIcon());
  mKeyguardBottomArea.setKeyguardIndicationController(mKeyguardIndicationController);
  if (ENABLE_LOCKSCREEN_WALLPAPER) {
    mLockscreenWallpaper=new LockscreenWallpaper(mContext,this,mHandler);
  }
  setAreThereNotifications();
  createIconController();
  mHandlerThread=new HandlerThread(TAG,Process.THREAD_PRIORITY_BACKGROUND);
  mHandlerThread.start();
  mLocationController=new LocationControllerImpl(mContext,mHandlerThread.getLooper());
  mBatteryController=new BatteryController(mContext);
  mBatteryController.addStateChangedCallback(new BatteryStateChangeCallback(){
    @Override public void onPowerSaveChanged(    boolean isPowerSave){
      mHandler.post(mCheckBarModes);
      if (mDozeServiceHost != null) {
        mDozeServiceHost.firePowerSaveChanged(isPowerSave);
      }
    }
    @Override public void onBatteryLevelChanged(    int level,    boolean pluggedIn,    boolean charging){
    }
  }
);
  mNetworkController=new NetworkControllerImpl(mContext,mHandlerThread.getLooper());
  mHotspotController=new HotspotControllerImpl(mContext);
  mBluetoothController=new BluetoothControllerImpl(mContext,mHandlerThread.getLooper());
  mSecurityController=new SecurityControllerImpl(mContext);
  if (mContext.getResources().getBoolean(R.bool.config_showRotationLock)) {
    mRotationLockController=new RotationLockControllerImpl(mContext);
  }
  mUserInfoController=new UserInfoController(mContext);
  mVolumeComponent=getComponent(VolumeComponent.class);
  if (mVolumeComponent != null) {
    mZenModeController=mVolumeComponent.getZenController();
  }
  mCastController=new CastControllerImpl(mContext);
  initSignalCluster(mStatusBarView);
  initSignalCluster(mKeyguardStatusBar);
  mFlashlightController=new FlashlightController(mContext);
  mKeyguardBottomArea.setFlashlightController(mFlashlightController);
  mKeyguardBottomArea.setPhoneStatusBar(this);
  mKeyguardBottomArea.setUserSetupComplete(mUserSetup);
  mAccessibilityController=new AccessibilityController(mContext);
  mKeyguardBottomArea.setAccessibilityController(mAccessibilityController);
  mNextAlarmController=new NextAlarmController(mContext);
  mLightStatusBarController=new LightStatusBarController(mIconController,mBatteryController);
  mKeyguardMonitor=new KeyguardMonitor(mContext);
  if (UserManager.get(mContext).isUserSwitcherEnabled()) {
    mUserSwitcherController=new UserSwitcherController(mContext,mKeyguardMonitor,mHandler,this);
    createUserSwitcher();
  }
  DensityContainer container=(DensityContainer)mStatusBarWindow.findViewById(R.id.qs_density_container);
  if (container != null) {
    final QSTileHost qsh=new QSTileHost(mContext,this,mBluetoothController,mLocationController,mRotationLockController,mNetworkController,mZenModeController,mHotspotController,mCastController,mFlashlightController,mUserSwitcherController,mUserInfoController,mKeyguardMonitor,mSecurityController,mBatteryController,mIconController,mNextAlarmController);
    mBrightnessMirrorController=new BrightnessMirrorController(mStatusBarWindow);
    container.addInflateListener(new InflateListener(){
      @Override public void onInflated(      View v){
        QSContainer qsContainer=(QSContainer)v.findViewById(R.id.quick_settings_container);
        qsContainer.setHost(qsh);
        mQSPanel=qsContainer.getQsPanel();
        mQSPanel.setBrightnessMirror(mBrightnessMirrorController);
        mHeader=qsContainer.getHeader();
        initSignalCluster(mHeader);
        mHeader.setActivityStarter(PhoneStatusBar.this);
      }
    }
);
  }
  mKeyguardStatusBar.setUserInfoController(mUserInfoController);
  mKeyguardStatusBar.setUserSwitcherController(mUserSwitcherController);
  mUserInfoController.reloadUserInfo();
  ((BatteryMeterView)mStatusBarView.findViewById(R.id.battery)).setBatteryController(mBatteryController);
  mKeyguardStatusBar.setBatteryController(mBatteryController);
  PowerManager pm=(PowerManager)mContext.getSystemService(Context.POWER_SERVICE);
  mBroadcastReceiver.onReceive(mContext,new Intent(pm.isScreenOn() ? Intent.ACTION_SCREEN_ON : Intent.ACTION_SCREEN_OFF));
  mGestureWakeLock=pm.newWakeLock(PowerManager.SCREEN_BRIGHT_WAKE_LOCK,""String_Node_Str"");
  mVibrator=mContext.getSystemService(Vibrator.class);
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
  filter.addAction(Intent.ACTION_SCREEN_OFF);
  filter.addAction(Intent.ACTION_SCREEN_ON);
  context.registerReceiverAsUser(mBroadcastReceiver,UserHandle.ALL,filter,null,null);
  IntentFilter demoFilter=new IntentFilter();
  if (DEBUG_MEDIA_FAKE_ARTWORK) {
    demoFilter.addAction(ACTION_FAKE_ARTWORK);
  }
  demoFilter.addAction(ACTION_DEMO);
  context.registerReceiverAsUser(mDemoReceiver,UserHandle.ALL,demoFilter,android.Manifest.permission.DUMP,null);
  resetUserSetupObserver();
  ThreadedRenderer.overrideProperty(""String_Node_Str"",""String_Node_Str"");
  ThreadedRenderer.overrideProperty(""String_Node_Str"",String.valueOf(1.5f));
  return mStatusBarView;
}","protected PhoneStatusBarView makeStatusBarView(){
  final Context context=mContext;
  updateDisplaySize();
  updateResources();
  inflateStatusBarWindow(context);
  mStatusBarWindow.setService(this);
  mStatusBarWindow.setOnTouchListener(new View.OnTouchListener(){
    @Override public boolean onTouch(    View v,    MotionEvent event){
      checkUserAutohide(v,event);
      if (event.getAction() == MotionEvent.ACTION_DOWN) {
        if (mExpandedVisible) {
          animateCollapsePanels();
        }
      }
      return mStatusBarWindow.onTouchEvent(event);
    }
  }
);
  mNotificationPanel=(NotificationPanelView)mStatusBarWindow.findViewById(R.id.notification_panel);
  mNotificationPanel.setStatusBar(this);
  mNotificationPanel.setGroupManager(mGroupManager);
  mStatusBarView=(PhoneStatusBarView)mStatusBarWindow.findViewById(R.id.status_bar);
  mStatusBarView.setBar(this);
  mStatusBarView.setPanel(mNotificationPanel);
  if (!ActivityManager.isHighEndGfx()) {
    mStatusBarWindow.setBackground(null);
    mNotificationPanel.setBackground(new FastColorDrawable(context.getColor(R.color.notification_panel_solid_background)));
  }
  mHeadsUpManager=new HeadsUpManager(context,mStatusBarWindow,mGroupManager);
  mHeadsUpManager.setBar(this);
  mHeadsUpManager.addListener(this);
  mHeadsUpManager.addListener(mNotificationPanel);
  mHeadsUpManager.addListener(mGroupManager);
  mNotificationPanel.setHeadsUpManager(mHeadsUpManager);
  mNotificationData.setHeadsUpManager(mHeadsUpManager);
  if (MULTIUSER_DEBUG) {
    mNotificationPanelDebugText=(TextView)mNotificationPanel.findViewById(R.id.header_debug_info);
    mNotificationPanelDebugText.setVisibility(View.VISIBLE);
  }
  try {
    boolean showNav=mWindowManagerService.hasNavigationBar();
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + showNav);
    if (showNav) {
      createNavigationBarView(context);
    }
  }
 catch (  RemoteException ex) {
  }
  mAssistManager=new AssistManager(this,context);
  mPixelFormat=PixelFormat.OPAQUE;
  mStackScroller=(NotificationStackScrollLayout)mStatusBarWindow.findViewById(R.id.notification_stack_scroller);
  mStackScroller.setLongPressListener(getNotificationLongClicker());
  mStackScroller.setGearDisplayedListener(getGearDisplayedListener());
  mStackScroller.setPhoneStatusBar(this);
  mStackScroller.setGroupManager(mGroupManager);
  mStackScroller.setHeadsUpManager(mHeadsUpManager);
  mGroupManager.setOnGroupChangeListener(mStackScroller);
  mKeyguardIconOverflowContainer=(NotificationOverflowContainer)LayoutInflater.from(mContext).inflate(R.layout.status_bar_notification_keyguard_overflow,mStackScroller,false);
  mKeyguardIconOverflowContainer.setOnActivatedListener(this);
  mKeyguardIconOverflowContainer.setOnClickListener(mOverflowClickListener);
  mStackScroller.setOverflowContainer(mKeyguardIconOverflowContainer);
  inflateEmptyShadeView();
  inflateDismissView();
  mExpandedContents=mStackScroller;
  mBackdrop=(BackDropView)mStatusBarWindow.findViewById(R.id.backdrop);
  mBackdropFront=(ImageView)mBackdrop.findViewById(R.id.backdrop_front);
  mBackdropBack=(ImageView)mBackdrop.findViewById(R.id.backdrop_back);
  ScrimView scrimBehind=(ScrimView)mStatusBarWindow.findViewById(R.id.scrim_behind);
  ScrimView scrimInFront=(ScrimView)mStatusBarWindow.findViewById(R.id.scrim_in_front);
  View headsUpScrim=mStatusBarWindow.findViewById(R.id.heads_up_scrim);
  mScrimController=SystemUIFactory.getInstance().createScrimController(scrimBehind,scrimInFront,headsUpScrim);
  if (mScrimSrcModeEnabled) {
    Runnable runnable=new Runnable(){
      @Override public void run(){
        boolean asSrc=mBackdrop.getVisibility() != View.VISIBLE;
        mScrimController.setDrawBehindAsSrc(asSrc);
        mStackScroller.setDrawBackgroundAsSrc(asSrc);
      }
    }
;
    mBackdrop.setOnVisibilityChangedRunnable(runnable);
    runnable.run();
  }
  mHeadsUpManager.addListener(mScrimController);
  mStackScroller.setScrimController(mScrimController);
  mStatusBarView.setScrimController(mScrimController);
  mDozeScrimController=new DozeScrimController(mScrimController,context);
  mKeyguardStatusBar=(KeyguardStatusBarView)mStatusBarWindow.findViewById(R.id.keyguard_header);
  mKeyguardStatusView=mStatusBarWindow.findViewById(R.id.keyguard_status_view);
  mKeyguardBottomArea=(KeyguardBottomAreaView)mStatusBarWindow.findViewById(R.id.keyguard_bottom_area);
  mKeyguardBottomArea.setActivityStarter(this);
  mKeyguardBottomArea.setAssistManager(mAssistManager);
  mKeyguardIndicationController=new KeyguardIndicationController(mContext,(KeyguardIndicationTextView)mStatusBarWindow.findViewById(R.id.keyguard_indication_text),mKeyguardBottomArea.getLockIcon());
  mKeyguardBottomArea.setKeyguardIndicationController(mKeyguardIndicationController);
  if (ENABLE_LOCKSCREEN_WALLPAPER) {
    mLockscreenWallpaper=new LockscreenWallpaper(mContext,this,mHandler);
  }
  setAreThereNotifications();
  createIconController();
  mHandlerThread=new HandlerThread(TAG,Process.THREAD_PRIORITY_BACKGROUND);
  mHandlerThread.start();
  mLocationController=new LocationControllerImpl(mContext,mHandlerThread.getLooper());
  mBatteryController=new BatteryController(mContext);
  mBatteryController.addStateChangedCallback(new BatteryStateChangeCallback(){
    @Override public void onPowerSaveChanged(    boolean isPowerSave){
      mHandler.post(mCheckBarModes);
      if (mDozeServiceHost != null) {
        mDozeServiceHost.firePowerSaveChanged(isPowerSave);
      }
    }
    @Override public void onBatteryLevelChanged(    int level,    boolean pluggedIn,    boolean charging){
    }
  }
);
  mNetworkController=new NetworkControllerImpl(mContext,mHandlerThread.getLooper());
  mHotspotController=new HotspotControllerImpl(mContext);
  mBluetoothController=new BluetoothControllerImpl(mContext,mHandlerThread.getLooper());
  mSecurityController=new SecurityControllerImpl(mContext);
  if (mContext.getResources().getBoolean(R.bool.config_showRotationLock)) {
    mRotationLockController=new RotationLockControllerImpl(mContext);
  }
  mUserInfoController=new UserInfoController(mContext);
  mVolumeComponent=getComponent(VolumeComponent.class);
  if (mVolumeComponent != null) {
    mZenModeController=mVolumeComponent.getZenController();
  }
  mCastController=new CastControllerImpl(mContext);
  initSignalCluster(mStatusBarView);
  initSignalCluster(mKeyguardStatusBar);
  mFlashlightController=new FlashlightController(mContext);
  mKeyguardBottomArea.setFlashlightController(mFlashlightController);
  mKeyguardBottomArea.setPhoneStatusBar(this);
  mKeyguardBottomArea.setUserSetupComplete(mUserSetup);
  mAccessibilityController=new AccessibilityController(mContext);
  mKeyguardBottomArea.setAccessibilityController(mAccessibilityController);
  mNextAlarmController=new NextAlarmController(mContext);
  mLightStatusBarController=new LightStatusBarController(mIconController,mBatteryController);
  mKeyguardMonitor=new KeyguardMonitor(mContext);
  if (UserManager.get(mContext).isUserSwitcherEnabled()) {
    mUserSwitcherController=new UserSwitcherController(mContext,mKeyguardMonitor,mHandler,this);
    createUserSwitcher();
  }
  DensityContainer container=(DensityContainer)mStatusBarWindow.findViewById(R.id.qs_density_container);
  if (container != null) {
    final QSTileHost qsh=new QSTileHost(mContext,this,mBluetoothController,mLocationController,mRotationLockController,mNetworkController,mZenModeController,mHotspotController,mCastController,mFlashlightController,mUserSwitcherController,mUserInfoController,mKeyguardMonitor,mSecurityController,mBatteryController,mIconController,mNextAlarmController);
    mBrightnessMirrorController=new BrightnessMirrorController(mStatusBarWindow);
    container.addInflateListener(new InflateListener(){
      @Override public void onInflated(      View v){
        QSContainer qsContainer=(QSContainer)v.findViewById(R.id.quick_settings_container);
        qsContainer.setHost(qsh);
        mQSPanel=qsContainer.getQsPanel();
        mQSPanel.setBrightnessMirror(mBrightnessMirrorController);
        mHeader=qsContainer.getHeader();
        initSignalCluster(mHeader);
        mHeader.setActivityStarter(PhoneStatusBar.this);
      }
    }
);
  }
  mKeyguardStatusBar.setUserInfoController(mUserInfoController);
  mKeyguardStatusBar.setUserSwitcherController(mUserSwitcherController);
  mUserInfoController.reloadUserInfo();
  ((BatteryMeterView)mStatusBarView.findViewById(R.id.battery)).setBatteryController(mBatteryController);
  mKeyguardStatusBar.setBatteryController(mBatteryController);
  PowerManager pm=(PowerManager)mContext.getSystemService(Context.POWER_SERVICE);
  mBroadcastReceiver.onReceive(mContext,new Intent(pm.isScreenOn() ? Intent.ACTION_SCREEN_ON : Intent.ACTION_SCREEN_OFF));
  mGestureWakeLock=pm.newWakeLock(PowerManager.SCREEN_BRIGHT_WAKE_LOCK,""String_Node_Str"");
  mVibrator=mContext.getSystemService(Vibrator.class);
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
  filter.addAction(Intent.ACTION_SCREEN_OFF);
  filter.addAction(Intent.ACTION_SCREEN_ON);
  context.registerReceiverAsUser(mBroadcastReceiver,UserHandle.ALL,filter,null,null);
  IntentFilter demoFilter=new IntentFilter();
  if (DEBUG_MEDIA_FAKE_ARTWORK) {
    demoFilter.addAction(ACTION_FAKE_ARTWORK);
  }
  demoFilter.addAction(ACTION_DEMO);
  context.registerReceiverAsUser(mDemoReceiver,UserHandle.ALL,demoFilter,android.Manifest.permission.DUMP,null);
  resetUserSetupObserver();
  ThreadedRenderer.overrideProperty(""String_Node_Str"",""String_Node_Str"");
  ThreadedRenderer.overrideProperty(""String_Node_Str"",String.valueOf(1.5f));
  return mStatusBarView;
}",0.9972580061048166
192393,"@SuppressWarnings(""String_Node_Str"") public void dumpCheckinLocked(Context context,PrintWriter pw,List<ApplicationInfo> apps,int flags,long histStart){
  prepareForDumpLocked();
  dumpLine(pw,0,""String_Node_Str"",VERSION_DATA,CHECKIN_VERSION,getParcelVersion(),getStartPlatformVersion(),getEndPlatformVersion());
  long now=getHistoryBaseTime() + SystemClock.elapsedRealtime();
  final boolean filtering=(flags & (DUMP_HISTORY_ONLY | DUMP_CHARGED_ONLY | DUMP_DAILY_ONLY)) != 0;
  if ((flags & DUMP_INCLUDE_HISTORY) != 0 || (flags & DUMP_HISTORY_ONLY) != 0) {
    if (startIteratingHistoryLocked()) {
      try {
        for (int i=0; i < getHistoryStringPoolSize(); i++) {
          pw.print(BATTERY_STATS_CHECKIN_VERSION);
          pw.print(',');
          pw.print(HISTORY_STRING_POOL);
          pw.print(',');
          pw.print(i);
          pw.print(""String_Node_Str"");
          pw.print(getHistoryTagPoolUid(i));
          pw.print(""String_Node_Str"");
          String str=getHistoryTagPoolString(i);
          str=str.replace(""String_Node_Str"",""String_Node_Str"");
          str=str.replace(""String_Node_Str"",""String_Node_Str"");
          pw.print(str);
          pw.print(""String_Node_Str"");
          pw.println();
        }
        dumpHistoryLocked(pw,flags,histStart,true);
      }
  finally {
        finishIteratingHistoryLocked();
      }
    }
  }
  if (filtering && (flags & (DUMP_CHARGED_ONLY | DUMP_DAILY_ONLY)) == 0) {
    return;
  }
  if (apps != null) {
    SparseArray<ArrayList<String>> uids=new SparseArray<ArrayList<String>>();
    for (int i=0; i < apps.size(); i++) {
      ApplicationInfo ai=apps.get(i);
      ArrayList<String> pkgs=uids.get(ai.uid);
      if (pkgs == null) {
        pkgs=new ArrayList<String>();
        uids.put(ai.uid,pkgs);
      }
      pkgs.add(ai.packageName);
    }
    SparseArray<? extends Uid> uidStats=getUidStats();
    final int NU=uidStats.size();
    String[] lineArgs=new String[2];
    for (int i=0; i < NU; i++) {
      int uid=uidStats.keyAt(i);
      ArrayList<String> pkgs=uids.get(uid);
      if (pkgs != null) {
        for (int j=0; j < pkgs.size(); j++) {
          lineArgs[0]=Integer.toString(uid);
          lineArgs[1]=pkgs.get(j);
          dumpLine(pw,0,""String_Node_Str"",UID_DATA,(Object[])lineArgs);
        }
      }
    }
  }
  if (!filtering || (flags & DUMP_CHARGED_ONLY) != 0) {
    dumpDurationSteps(pw,""String_Node_Str"",DISCHARGE_STEP_DATA,getDischargeLevelStepTracker(),true);
    String[] lineArgs=new String[1];
    long timeRemaining=computeBatteryTimeRemaining(SystemClock.elapsedRealtime());
    if (timeRemaining >= 0) {
      lineArgs[0]=Long.toString(timeRemaining);
      dumpLine(pw,0,""String_Node_Str"",DISCHARGE_TIME_REMAIN_DATA,(Object[])lineArgs);
    }
    dumpDurationSteps(pw,""String_Node_Str"",CHARGE_STEP_DATA,getChargeLevelStepTracker(),true);
    timeRemaining=computeChargeTimeRemaining(SystemClock.elapsedRealtime());
    if (timeRemaining >= 0) {
      lineArgs[0]=Long.toString(timeRemaining);
      dumpLine(pw,0,""String_Node_Str"",CHARGE_TIME_REMAIN_DATA,(Object[])lineArgs);
    }
    dumpCheckinLocked(context,pw,STATS_SINCE_CHARGED,-1,(flags & DUMP_DEVICE_WIFI_ONLY) != 0);
  }
}","@SuppressWarnings(""String_Node_Str"") public void dumpCheckinLocked(Context context,PrintWriter pw,List<ApplicationInfo> apps,int flags,long histStart){
  prepareForDumpLocked();
  dumpLine(pw,0,""String_Node_Str"",VERSION_DATA,CHECKIN_VERSION,getParcelVersion(),getStartPlatformVersion(),getEndPlatformVersion());
  long now=getHistoryBaseTime() + SystemClock.elapsedRealtime();
  final boolean filtering=(flags & (DUMP_HISTORY_ONLY | DUMP_CHARGED_ONLY | DUMP_DAILY_ONLY)) != 0;
  if ((flags & DUMP_INCLUDE_HISTORY) != 0 || (flags & DUMP_HISTORY_ONLY) != 0) {
    if (startIteratingHistoryLocked()) {
      try {
        for (int i=0; i < getHistoryStringPoolSize(); i++) {
          pw.print(BATTERY_STATS_CHECKIN_VERSION);
          pw.print(',');
          pw.print(HISTORY_STRING_POOL);
          pw.print(',');
          pw.print(i);
          pw.print(""String_Node_Str"");
          pw.print(getHistoryTagPoolUid(i));
          pw.print(""String_Node_Str"");
          String str=getHistoryTagPoolString(i);
          str=str.replace(""String_Node_Str"",""String_Node_Str"");
          str=str.replace(""String_Node_Str"",""String_Node_Str"");
          pw.print(str);
          pw.print(""String_Node_Str"");
          pw.println();
        }
        dumpHistoryLocked(pw,flags,histStart,true);
      }
  finally {
        finishIteratingHistoryLocked();
      }
    }
  }
  if (filtering && (flags & (DUMP_CHARGED_ONLY | DUMP_DAILY_ONLY)) == 0) {
    return;
  }
  if (apps != null) {
    SparseArray<Pair<ArrayList<String>,MutableBoolean>> uids=new SparseArray<>();
    for (int i=0; i < apps.size(); i++) {
      ApplicationInfo ai=apps.get(i);
      Pair<ArrayList<String>,MutableBoolean> pkgs=uids.get(UserHandle.getAppId(ai.uid));
      if (pkgs == null) {
        pkgs=new Pair<>(new ArrayList<String>(),new MutableBoolean(false));
        uids.put(UserHandle.getAppId(ai.uid),pkgs);
      }
      pkgs.first.add(ai.packageName);
    }
    SparseArray<? extends Uid> uidStats=getUidStats();
    final int NU=uidStats.size();
    String[] lineArgs=new String[2];
    for (int i=0; i < NU; i++) {
      int uid=UserHandle.getAppId(uidStats.keyAt(i));
      Pair<ArrayList<String>,MutableBoolean> pkgs=uids.get(uid);
      if (pkgs != null && !pkgs.second.value) {
        pkgs.second.value=true;
        for (int j=0; j < pkgs.first.size(); j++) {
          lineArgs[0]=Integer.toString(uid);
          lineArgs[1]=pkgs.first.get(j);
          dumpLine(pw,0,""String_Node_Str"",UID_DATA,(Object[])lineArgs);
        }
      }
    }
  }
  if (!filtering || (flags & DUMP_CHARGED_ONLY) != 0) {
    dumpDurationSteps(pw,""String_Node_Str"",DISCHARGE_STEP_DATA,getDischargeLevelStepTracker(),true);
    String[] lineArgs=new String[1];
    long timeRemaining=computeBatteryTimeRemaining(SystemClock.elapsedRealtime());
    if (timeRemaining >= 0) {
      lineArgs[0]=Long.toString(timeRemaining);
      dumpLine(pw,0,""String_Node_Str"",DISCHARGE_TIME_REMAIN_DATA,(Object[])lineArgs);
    }
    dumpDurationSteps(pw,""String_Node_Str"",CHARGE_STEP_DATA,getChargeLevelStepTracker(),true);
    timeRemaining=computeChargeTimeRemaining(SystemClock.elapsedRealtime());
    if (timeRemaining >= 0) {
      lineArgs[0]=Long.toString(timeRemaining);
      dumpLine(pw,0,""String_Node_Str"",CHARGE_TIME_REMAIN_DATA,(Object[])lineArgs);
    }
    dumpCheckinLocked(context,pw,STATS_SINCE_CHARGED,-1,(flags & DUMP_DEVICE_WIFI_ONLY) != 0);
  }
}",0.8988662131519274
192394,"@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  int flags=0;
  boolean useCheckinFormat=false;
  boolean isRealCheckin=false;
  boolean noOutput=false;
  boolean writeData=false;
  long historyStart=-1;
  int reqUid=-1;
  if (args != null) {
    for (int i=0; i < args.length; i++) {
      String arg=args[i];
      if (""String_Node_Str"".equals(arg)) {
        useCheckinFormat=true;
        isRealCheckin=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        flags|=BatteryStats.DUMP_HISTORY_ONLY;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        flags|=BatteryStats.DUMP_HISTORY_ONLY;
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        historyStart=Long.parseLong(args[i]);
        writeData=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        useCheckinFormat=true;
        flags|=BatteryStats.DUMP_INCLUDE_HISTORY;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        flags|=BatteryStats.DUMP_CHARGED_ONLY;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        flags|=BatteryStats.DUMP_DAILY_ONLY;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mStats) {
          mStats.resetAllStatsCmdLocked();
          pw.println(""String_Node_Str"");
          noOutput=true;
        }
        updateExternalStats(""String_Node_Str"",BatteryStatsImpl.ExternalStatsSync.UPDATE_ALL);
      }
 else       if (""String_Node_Str"".equals(arg)) {
        updateExternalStats(""String_Node_Str"",BatteryStatsImpl.ExternalStatsSync.UPDATE_ALL);
synchronized (mStats) {
          mStats.writeSyncLocked();
          pw.println(""String_Node_Str"");
          noOutput=true;
        }
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mStats) {
          mStats.recordDailyStatsLocked();
          pw.println(""String_Node_Str"");
          noOutput=true;
        }
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mStats) {
          mStats.readDailyStatsLocked();
          pw.println(""String_Node_Str"");
          noOutput=true;
        }
      }
 else       if (""String_Node_Str"".equals(arg) || ""String_Node_Str"".equals(arg)) {
        i=doEnableOrDisable(pw,i,args,true);
        if (i < 0) {
          return;
        }
        pw.println(""String_Node_Str"" + args[i]);
        return;
      }
 else       if (""String_Node_Str"".equals(arg) || ""String_Node_Str"".equals(arg)) {
        i=doEnableOrDisable(pw,i,args,false);
        if (i < 0) {
          return;
        }
        pw.println(""String_Node_Str"" + args[i]);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        flags|=BatteryStats.DUMP_VERBOSE;
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        dumpHelp(pw);
        return;
      }
 else {
        try {
          reqUid=mContext.getPackageManager().getPackageUidAsUser(arg,UserHandle.getCallingUserId());
        }
 catch (        PackageManager.NameNotFoundException e) {
          pw.println(""String_Node_Str"" + arg);
          dumpHelp(pw);
          return;
        }
      }
    }
  }
  if (noOutput) {
    return;
  }
  long ident=Binder.clearCallingIdentity();
  try {
    if (BatteryStatsHelper.checkWifiOnly(mContext)) {
      flags|=BatteryStats.DUMP_DEVICE_WIFI_ONLY;
    }
    updateExternalStats(""String_Node_Str"",BatteryStatsImpl.ExternalStatsSync.UPDATE_ALL);
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
  if (reqUid >= 0) {
    if ((flags & (BatteryStats.DUMP_HISTORY_ONLY | BatteryStats.DUMP_CHARGED_ONLY)) == 0) {
      flags|=BatteryStats.DUMP_CHARGED_ONLY;
      flags&=~BatteryStats.DUMP_INCLUDE_HISTORY;
    }
  }
  if (useCheckinFormat) {
    List<ApplicationInfo> apps=mContext.getPackageManager().getInstalledApplications(0);
    if (isRealCheckin) {
synchronized (mStats.mCheckinFile) {
        if (mStats.mCheckinFile.exists()) {
          try {
            byte[] raw=mStats.mCheckinFile.readFully();
            if (raw != null) {
              Parcel in=Parcel.obtain();
              in.unmarshall(raw,0,raw.length);
              in.setDataPosition(0);
              BatteryStatsImpl checkinStats=new BatteryStatsImpl(null,mStats.mHandler,null);
              checkinStats.readSummaryFromParcel(in);
              in.recycle();
              checkinStats.dumpCheckinLocked(mContext,pw,apps,flags,historyStart);
              mStats.mCheckinFile.delete();
              return;
            }
          }
 catch (          IOException|ParcelFormatException e) {
            Slog.w(TAG,""String_Node_Str"" + mStats.mCheckinFile.getBaseFile(),e);
          }
        }
      }
    }
synchronized (mStats) {
      mStats.dumpCheckinLocked(mContext,pw,apps,flags,historyStart);
      if (writeData) {
        mStats.writeAsyncLocked();
      }
    }
  }
 else {
synchronized (mStats) {
      mStats.dumpLocked(mContext,pw,flags,reqUid,historyStart);
      if (writeData) {
        mStats.writeAsyncLocked();
      }
    }
  }
}","@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  int flags=0;
  boolean useCheckinFormat=false;
  boolean isRealCheckin=false;
  boolean noOutput=false;
  boolean writeData=false;
  long historyStart=-1;
  int reqUid=-1;
  if (args != null) {
    for (int i=0; i < args.length; i++) {
      String arg=args[i];
      if (""String_Node_Str"".equals(arg)) {
        useCheckinFormat=true;
        isRealCheckin=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        flags|=BatteryStats.DUMP_HISTORY_ONLY;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        flags|=BatteryStats.DUMP_HISTORY_ONLY;
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        historyStart=Long.parseLong(args[i]);
        writeData=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        useCheckinFormat=true;
        flags|=BatteryStats.DUMP_INCLUDE_HISTORY;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        flags|=BatteryStats.DUMP_CHARGED_ONLY;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        flags|=BatteryStats.DUMP_DAILY_ONLY;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mStats) {
          mStats.resetAllStatsCmdLocked();
          pw.println(""String_Node_Str"");
          noOutput=true;
        }
        updateExternalStats(""String_Node_Str"",BatteryStatsImpl.ExternalStatsSync.UPDATE_ALL);
      }
 else       if (""String_Node_Str"".equals(arg)) {
        updateExternalStats(""String_Node_Str"",BatteryStatsImpl.ExternalStatsSync.UPDATE_ALL);
synchronized (mStats) {
          mStats.writeSyncLocked();
          pw.println(""String_Node_Str"");
          noOutput=true;
        }
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mStats) {
          mStats.recordDailyStatsLocked();
          pw.println(""String_Node_Str"");
          noOutput=true;
        }
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mStats) {
          mStats.readDailyStatsLocked();
          pw.println(""String_Node_Str"");
          noOutput=true;
        }
      }
 else       if (""String_Node_Str"".equals(arg) || ""String_Node_Str"".equals(arg)) {
        i=doEnableOrDisable(pw,i,args,true);
        if (i < 0) {
          return;
        }
        pw.println(""String_Node_Str"" + args[i]);
        return;
      }
 else       if (""String_Node_Str"".equals(arg) || ""String_Node_Str"".equals(arg)) {
        i=doEnableOrDisable(pw,i,args,false);
        if (i < 0) {
          return;
        }
        pw.println(""String_Node_Str"" + args[i]);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        flags|=BatteryStats.DUMP_VERBOSE;
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        dumpHelp(pw);
        return;
      }
 else {
        try {
          reqUid=mContext.getPackageManager().getPackageUidAsUser(arg,UserHandle.getCallingUserId());
        }
 catch (        PackageManager.NameNotFoundException e) {
          pw.println(""String_Node_Str"" + arg);
          dumpHelp(pw);
          return;
        }
      }
    }
  }
  if (noOutput) {
    return;
  }
  long ident=Binder.clearCallingIdentity();
  try {
    if (BatteryStatsHelper.checkWifiOnly(mContext)) {
      flags|=BatteryStats.DUMP_DEVICE_WIFI_ONLY;
    }
    updateExternalStats(""String_Node_Str"",BatteryStatsImpl.ExternalStatsSync.UPDATE_ALL);
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
  if (reqUid >= 0) {
    if ((flags & (BatteryStats.DUMP_HISTORY_ONLY | BatteryStats.DUMP_CHARGED_ONLY)) == 0) {
      flags|=BatteryStats.DUMP_CHARGED_ONLY;
      flags&=~BatteryStats.DUMP_INCLUDE_HISTORY;
    }
  }
  if (useCheckinFormat) {
    List<ApplicationInfo> apps=mContext.getPackageManager().getInstalledApplications(PackageManager.MATCH_UNINSTALLED_PACKAGES | PackageManager.MATCH_ALL);
    if (isRealCheckin) {
synchronized (mStats.mCheckinFile) {
        if (mStats.mCheckinFile.exists()) {
          try {
            byte[] raw=mStats.mCheckinFile.readFully();
            if (raw != null) {
              Parcel in=Parcel.obtain();
              in.unmarshall(raw,0,raw.length);
              in.setDataPosition(0);
              BatteryStatsImpl checkinStats=new BatteryStatsImpl(null,mStats.mHandler,null);
              checkinStats.readSummaryFromParcel(in);
              in.recycle();
              checkinStats.dumpCheckinLocked(mContext,pw,apps,flags,historyStart);
              mStats.mCheckinFile.delete();
              return;
            }
          }
 catch (          IOException|ParcelFormatException e) {
            Slog.w(TAG,""String_Node_Str"" + mStats.mCheckinFile.getBaseFile(),e);
          }
        }
      }
    }
synchronized (mStats) {
      mStats.dumpCheckinLocked(mContext,pw,apps,flags,historyStart);
      if (writeData) {
        mStats.writeAsyncLocked();
      }
    }
  }
 else {
synchronized (mStats) {
      mStats.dumpLocked(mContext,pw,flags,reqUid,historyStart);
      if (writeData) {
        mStats.writeAsyncLocked();
      }
    }
  }
}",0.9937821032711543
192395,"void dumpPackageLPr(PrintWriter pw,String prefix,String checkinTag,ArraySet<String> permissionNames,PackageSetting ps,SimpleDateFormat sdf,Date date,List<UserInfo> users,boolean dumpAll){
  if (checkinTag != null) {
    pw.print(checkinTag);
    pw.print(""String_Node_Str"");
    pw.print(ps.realName != null ? ps.realName : ps.name);
    pw.print(""String_Node_Str"");
    pw.print(ps.appId);
    pw.print(""String_Node_Str"");
    pw.print(ps.versionCode);
    pw.print(""String_Node_Str"");
    pw.print(ps.firstInstallTime);
    pw.print(""String_Node_Str"");
    pw.print(ps.lastUpdateTime);
    pw.print(""String_Node_Str"");
    pw.print(ps.installerPackageName != null ? ps.installerPackageName : ""String_Node_Str"");
    pw.println();
    if (ps.pkg != null) {
      pw.print(checkinTag);
      pw.print(""String_Node_Str"");
      pw.print(""String_Node_Str"");
      pw.print(""String_Node_Str"");
      pw.println(ps.pkg.baseRevisionCode);
      if (ps.pkg.splitNames != null) {
        for (int i=0; i < ps.pkg.splitNames.length; i++) {
          pw.print(checkinTag);
          pw.print(""String_Node_Str"");
          pw.print(""String_Node_Str"");
          pw.print(ps.pkg.splitNames[i]);
          pw.print(""String_Node_Str"");
          pw.println(ps.pkg.splitRevisionCodes[i]);
        }
      }
    }
    for (    UserInfo user : users) {
      pw.print(checkinTag);
      pw.print(""String_Node_Str"");
      pw.print(""String_Node_Str"");
      pw.print(""String_Node_Str"");
      pw.print(user.id);
      pw.print(""String_Node_Str"");
      pw.print(ps.getInstalled(user.id) ? ""String_Node_Str"" : ""String_Node_Str"");
      pw.print(ps.getHidden(user.id) ? ""String_Node_Str"" : ""String_Node_Str"");
      pw.print(ps.getSuspended(user.id) ? ""String_Node_Str"" : ""String_Node_Str"");
      pw.print(ps.getStopped(user.id) ? ""String_Node_Str"" : ""String_Node_Str"");
      pw.print(ps.getNotLaunched(user.id) ? ""String_Node_Str"" : ""String_Node_Str"");
      pw.print(""String_Node_Str"");
      pw.print(ps.getEnabled(user.id));
      String lastDisabledAppCaller=ps.getLastDisabledAppCaller(user.id);
      pw.print(""String_Node_Str"");
      pw.print(lastDisabledAppCaller != null ? lastDisabledAppCaller : ""String_Node_Str"");
      pw.println();
    }
    return;
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(ps.realName != null ? ps.realName : ps.name);
  pw.print(""String_Node_Str"");
  pw.print(Integer.toHexString(System.identityHashCode(ps)));
  pw.println(""String_Node_Str"");
  if (ps.frozen) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
  }
  if (ps.realName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(ps.name);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(ps.appId);
  if (ps.sharedUser != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(ps.sharedUser);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(ps.pkg);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(ps.codePathString);
  if (permissionNames == null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(ps.resourcePathString);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(ps.legacyNativeLibraryPathString);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(ps.primaryCpuAbiString);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(ps.secondaryCpuAbiString);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(ps.versionCode);
  if (ps.pkg != null) {
    pw.print(""String_Node_Str"");
    pw.print(ps.pkg.applicationInfo.minSdkVersion);
    pw.print(""String_Node_Str"");
    pw.print(ps.pkg.applicationInfo.targetSdkVersion);
  }
  pw.println();
  if (ps.pkg != null) {
    if (ps.pkg.parentPackage != null) {
      PackageParser.Package parentPkg=ps.pkg.parentPackage;
      PackageSetting pps=mPackages.get(parentPkg.packageName);
      if (pps == null || !pps.codePathString.equals(parentPkg.codePath)) {
        pps=mDisabledSysPackages.get(parentPkg.packageName);
      }
      if (pps != null) {
        pw.print(prefix);
        pw.print(""String_Node_Str"");
        pw.println(pps.realName != null ? pps.realName : pps.name);
      }
    }
 else     if (ps.pkg.childPackages != null) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      final int childCount=ps.pkg.childPackages.size();
      for (int i=0; i < childCount; i++) {
        PackageParser.Package childPkg=ps.pkg.childPackages.get(i);
        PackageSetting cps=mPackages.get(childPkg.packageName);
        if (cps == null || !cps.codePathString.equals(childPkg.codePath)) {
          cps=mDisabledSysPackages.get(childPkg.packageName);
        }
        if (cps != null) {
          if (i > 0) {
            pw.print(""String_Node_Str"");
          }
          pw.print(cps.realName != null ? cps.realName : cps.name);
        }
      }
      pw.println(""String_Node_Str"");
    }
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(ps.pkg.mVersionName);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    dumpSplitNames(pw,ps.pkg);
    pw.println();
    final int apkSigningVersion=PackageParser.getApkSigningVersion(ps.pkg);
    if (apkSigningVersion != PackageParser.APK_SIGNING_UNKNOWN) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(apkSigningVersion);
    }
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(ps.pkg.applicationInfo.toString());
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    printFlags(pw,ps.pkg.applicationInfo.flags,FLAG_DUMP_SPEC);
    pw.println();
    if (ps.pkg.applicationInfo.privateFlags != 0) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      printFlags(pw,ps.pkg.applicationInfo.privateFlags,PRIVATE_FLAG_DUMP_SPEC);
      pw.println();
    }
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(ps.pkg.applicationInfo.dataDir);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    boolean first=true;
    if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_SMALL_SCREENS) != 0) {
      if (!first)       pw.print(""String_Node_Str"");
      first=false;
      pw.print(""String_Node_Str"");
    }
    if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_NORMAL_SCREENS) != 0) {
      if (!first)       pw.print(""String_Node_Str"");
      first=false;
      pw.print(""String_Node_Str"");
    }
    if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_LARGE_SCREENS) != 0) {
      if (!first)       pw.print(""String_Node_Str"");
      first=false;
      pw.print(""String_Node_Str"");
    }
    if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_XLARGE_SCREENS) != 0) {
      if (!first)       pw.print(""String_Node_Str"");
      first=false;
      pw.print(""String_Node_Str"");
    }
    if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_RESIZEABLE_FOR_SCREENS) != 0) {
      if (!first)       pw.print(""String_Node_Str"");
      first=false;
      pw.print(""String_Node_Str"");
    }
    if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES) != 0) {
      if (!first)       pw.print(""String_Node_Str"");
      first=false;
      pw.print(""String_Node_Str"");
    }
    pw.println(""String_Node_Str"");
    if (ps.pkg.libraryNames != null && ps.pkg.libraryNames.size() > 0) {
      pw.print(prefix);
      pw.println(""String_Node_Str"");
      for (int i=0; i < ps.pkg.libraryNames.size(); i++) {
        pw.print(prefix);
        pw.print(""String_Node_Str"");
        pw.println(ps.pkg.libraryNames.get(i));
      }
    }
    if (ps.pkg.usesLibraries != null && ps.pkg.usesLibraries.size() > 0) {
      pw.print(prefix);
      pw.println(""String_Node_Str"");
      for (int i=0; i < ps.pkg.usesLibraries.size(); i++) {
        pw.print(prefix);
        pw.print(""String_Node_Str"");
        pw.println(ps.pkg.usesLibraries.get(i));
      }
    }
    if (ps.pkg.usesOptionalLibraries != null && ps.pkg.usesOptionalLibraries.size() > 0) {
      pw.print(prefix);
      pw.println(""String_Node_Str"");
      for (int i=0; i < ps.pkg.usesOptionalLibraries.size(); i++) {
        pw.print(prefix);
        pw.print(""String_Node_Str"");
        pw.println(ps.pkg.usesOptionalLibraries.get(i));
      }
    }
    if (ps.pkg.usesLibraryFiles != null && ps.pkg.usesLibraryFiles.length > 0) {
      pw.print(prefix);
      pw.println(""String_Node_Str"");
      for (int i=0; i < ps.pkg.usesLibraryFiles.length; i++) {
        pw.print(prefix);
        pw.print(""String_Node_Str"");
        pw.println(ps.pkg.usesLibraryFiles[i]);
      }
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  date.setTime(ps.timeStamp);
  pw.println(sdf.format(date));
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  date.setTime(ps.firstInstallTime);
  pw.println(sdf.format(date));
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  date.setTime(ps.lastUpdateTime);
  pw.println(sdf.format(date));
  if (ps.installerPackageName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(ps.installerPackageName);
  }
  if (ps.volumeUuid != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(ps.volumeUuid);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(ps.signatures);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(ps.installPermissionsFixed);
  pw.print(""String_Node_Str"");
  pw.println(ps.installStatus);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  printFlags(pw,ps.pkgFlags,FLAG_DUMP_SPEC);
  pw.println();
  if (ps.pkg != null && ps.pkg.permissions != null && ps.pkg.permissions.size() > 0) {
    final ArrayList<PackageParser.Permission> perms=ps.pkg.permissions;
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < perms.size(); i++) {
      PackageParser.Permission perm=perms.get(i);
      if (permissionNames != null && !permissionNames.contains(perm.info.name)) {
        continue;
      }
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.print(perm.info.name);
      pw.print(""String_Node_Str"");
      pw.print(PermissionInfo.protectionToString(perm.info.protectionLevel));
      if ((perm.info.flags & PermissionInfo.FLAG_COSTS_MONEY) != 0) {
        pw.print(""String_Node_Str"");
      }
      if ((perm.info.flags & PermissionInfo.FLAG_REMOVED) != 0) {
        pw.print(""String_Node_Str"");
      }
      if ((perm.info.flags & PermissionInfo.FLAG_INSTALLED) != 0) {
        pw.print(""String_Node_Str"");
      }
      pw.println();
    }
  }
  if ((permissionNames != null || dumpAll) && ps.pkg.requestedPermissions != null && ps.pkg.requestedPermissions.size() > 0) {
    final ArrayList<String> perms=ps.pkg.requestedPermissions;
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < perms.size(); i++) {
      String perm=perms.get(i);
      if (permissionNames != null && !permissionNames.contains(perm)) {
        continue;
      }
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(perm);
    }
  }
  if (ps.sharedUser == null || permissionNames != null || dumpAll) {
    PermissionsState permissionsState=ps.getPermissionsState();
    dumpInstallPermissionsLPr(pw,prefix + ""String_Node_Str"",permissionNames,permissionsState);
  }
  for (  UserInfo user : users) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(user.id);
    pw.print(""String_Node_Str"");
    pw.print(""String_Node_Str"");
    pw.print(ps.getInstalled(user.id));
    pw.print(""String_Node_Str"");
    pw.print(ps.getHidden(user.id));
    pw.print(""String_Node_Str"");
    pw.print(ps.getSuspended(user.id));
    pw.print(""String_Node_Str"");
    pw.print(ps.getStopped(user.id));
    pw.print(""String_Node_Str"");
    pw.print(ps.getNotLaunched(user.id));
    pw.print(""String_Node_Str"");
    pw.println(ps.getEnabled(user.id));
    String lastDisabledAppCaller=ps.getLastDisabledAppCaller(user.id);
    if (lastDisabledAppCaller != null) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(lastDisabledAppCaller);
    }
    if (ps.sharedUser == null) {
      PermissionsState permissionsState=ps.getPermissionsState();
      dumpGidsLPr(pw,prefix + ""String_Node_Str"",permissionsState.computeGids(user.id));
      dumpRuntimePermissionsLPr(pw,prefix + ""String_Node_Str"",permissionNames,permissionsState.getRuntimePermissionStates(user.id),dumpAll);
    }
    if (permissionNames == null) {
      ArraySet<String> cmp=ps.getDisabledComponents(user.id);
      if (cmp != null && cmp.size() > 0) {
        pw.print(prefix);
        pw.println(""String_Node_Str"");
        for (        String s : cmp) {
          pw.print(prefix);
          pw.print(""String_Node_Str"");
          pw.println(s);
        }
      }
      cmp=ps.getEnabledComponents(user.id);
      if (cmp != null && cmp.size() > 0) {
        pw.print(prefix);
        pw.println(""String_Node_Str"");
        for (        String s : cmp) {
          pw.print(prefix);
          pw.print(""String_Node_Str"");
          pw.println(s);
        }
      }
    }
  }
}","void dumpPackageLPr(PrintWriter pw,String prefix,String checkinTag,ArraySet<String> permissionNames,PackageSetting ps,SimpleDateFormat sdf,Date date,List<UserInfo> users,boolean dumpAll){
  if (checkinTag != null) {
    pw.print(checkinTag);
    pw.print(""String_Node_Str"");
    pw.print(ps.realName != null ? ps.realName : ps.name);
    pw.print(""String_Node_Str"");
    pw.print(ps.appId);
    pw.print(""String_Node_Str"");
    pw.print(ps.versionCode);
    pw.print(""String_Node_Str"");
    pw.print(ps.firstInstallTime);
    pw.print(""String_Node_Str"");
    pw.print(ps.lastUpdateTime);
    pw.print(""String_Node_Str"");
    pw.print(ps.installerPackageName != null ? ps.installerPackageName : ""String_Node_Str"");
    pw.println();
    if (ps.pkg != null) {
      pw.print(checkinTag);
      pw.print(""String_Node_Str"");
      pw.print(""String_Node_Str"");
      pw.print(""String_Node_Str"");
      pw.println(ps.pkg.baseRevisionCode);
      if (ps.pkg.splitNames != null) {
        for (int i=0; i < ps.pkg.splitNames.length; i++) {
          pw.print(checkinTag);
          pw.print(""String_Node_Str"");
          pw.print(""String_Node_Str"");
          pw.print(ps.pkg.splitNames[i]);
          pw.print(""String_Node_Str"");
          pw.println(ps.pkg.splitRevisionCodes[i]);
        }
      }
    }
    for (    UserInfo user : users) {
      pw.print(checkinTag);
      pw.print(""String_Node_Str"");
      pw.print(""String_Node_Str"");
      pw.print(""String_Node_Str"");
      pw.print(user.id);
      pw.print(""String_Node_Str"");
      pw.print(ps.getInstalled(user.id) ? ""String_Node_Str"" : ""String_Node_Str"");
      pw.print(ps.getHidden(user.id) ? ""String_Node_Str"" : ""String_Node_Str"");
      pw.print(ps.getSuspended(user.id) ? ""String_Node_Str"" : ""String_Node_Str"");
      pw.print(ps.getStopped(user.id) ? ""String_Node_Str"" : ""String_Node_Str"");
      pw.print(ps.getNotLaunched(user.id) ? ""String_Node_Str"" : ""String_Node_Str"");
      pw.print(""String_Node_Str"");
      pw.print(ps.getEnabled(user.id));
      String lastDisabledAppCaller=ps.getLastDisabledAppCaller(user.id);
      pw.print(""String_Node_Str"");
      pw.print(lastDisabledAppCaller != null ? lastDisabledAppCaller : ""String_Node_Str"");
      pw.println();
    }
    return;
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(ps.realName != null ? ps.realName : ps.name);
  pw.print(""String_Node_Str"");
  pw.print(Integer.toHexString(System.identityHashCode(ps)));
  pw.println(""String_Node_Str"");
  if (ps.frozen) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
  }
  if (ps.realName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(ps.name);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(ps.appId);
  if (ps.sharedUser != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(ps.sharedUser);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(ps.pkg);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(ps.codePathString);
  if (permissionNames == null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(ps.resourcePathString);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(ps.legacyNativeLibraryPathString);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(ps.primaryCpuAbiString);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(ps.secondaryCpuAbiString);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(ps.versionCode);
  if (ps.pkg != null) {
    pw.print(""String_Node_Str"");
    pw.print(ps.pkg.applicationInfo.minSdkVersion);
    pw.print(""String_Node_Str"");
    pw.print(ps.pkg.applicationInfo.targetSdkVersion);
  }
  pw.println();
  if (ps.pkg != null) {
    if (ps.pkg.parentPackage != null) {
      PackageParser.Package parentPkg=ps.pkg.parentPackage;
      PackageSetting pps=mPackages.get(parentPkg.packageName);
      if (pps == null || !pps.codePathString.equals(parentPkg.codePath)) {
        pps=mDisabledSysPackages.get(parentPkg.packageName);
      }
      if (pps != null) {
        pw.print(prefix);
        pw.print(""String_Node_Str"");
        pw.println(pps.realName != null ? pps.realName : pps.name);
      }
    }
 else     if (ps.pkg.childPackages != null) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      final int childCount=ps.pkg.childPackages.size();
      for (int i=0; i < childCount; i++) {
        PackageParser.Package childPkg=ps.pkg.childPackages.get(i);
        PackageSetting cps=mPackages.get(childPkg.packageName);
        if (cps == null || !cps.codePathString.equals(childPkg.codePath)) {
          cps=mDisabledSysPackages.get(childPkg.packageName);
        }
        if (cps != null) {
          if (i > 0) {
            pw.print(""String_Node_Str"");
          }
          pw.print(cps.realName != null ? cps.realName : cps.name);
        }
      }
      pw.println(""String_Node_Str"");
    }
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(ps.pkg.mVersionName);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    dumpSplitNames(pw,ps.pkg);
    pw.println();
    final int apkSigningVersion=PackageParser.getApkSigningVersion(ps.pkg);
    if (apkSigningVersion != PackageParser.APK_SIGNING_UNKNOWN) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(apkSigningVersion);
    }
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(ps.pkg.applicationInfo.toString());
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    printFlags(pw,ps.pkg.applicationInfo.flags,FLAG_DUMP_SPEC);
    pw.println();
    if (ps.pkg.applicationInfo.privateFlags != 0) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      printFlags(pw,ps.pkg.applicationInfo.privateFlags,PRIVATE_FLAG_DUMP_SPEC);
      pw.println();
    }
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(ps.pkg.applicationInfo.dataDir);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    boolean first=true;
    if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_SMALL_SCREENS) != 0) {
      if (!first)       pw.print(""String_Node_Str"");
      first=false;
      pw.print(""String_Node_Str"");
    }
    if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_NORMAL_SCREENS) != 0) {
      if (!first)       pw.print(""String_Node_Str"");
      first=false;
      pw.print(""String_Node_Str"");
    }
    if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_LARGE_SCREENS) != 0) {
      if (!first)       pw.print(""String_Node_Str"");
      first=false;
      pw.print(""String_Node_Str"");
    }
    if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_XLARGE_SCREENS) != 0) {
      if (!first)       pw.print(""String_Node_Str"");
      first=false;
      pw.print(""String_Node_Str"");
    }
    if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_RESIZEABLE_FOR_SCREENS) != 0) {
      if (!first)       pw.print(""String_Node_Str"");
      first=false;
      pw.print(""String_Node_Str"");
    }
    if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES) != 0) {
      if (!first)       pw.print(""String_Node_Str"");
      first=false;
      pw.print(""String_Node_Str"");
    }
    pw.println(""String_Node_Str"");
    if (ps.pkg.libraryNames != null && ps.pkg.libraryNames.size() > 0) {
      pw.print(prefix);
      pw.println(""String_Node_Str"");
      for (int i=0; i < ps.pkg.libraryNames.size(); i++) {
        pw.print(prefix);
        pw.print(""String_Node_Str"");
        pw.println(ps.pkg.libraryNames.get(i));
      }
    }
    if (ps.pkg.usesLibraries != null && ps.pkg.usesLibraries.size() > 0) {
      pw.print(prefix);
      pw.println(""String_Node_Str"");
      for (int i=0; i < ps.pkg.usesLibraries.size(); i++) {
        pw.print(prefix);
        pw.print(""String_Node_Str"");
        pw.println(ps.pkg.usesLibraries.get(i));
      }
    }
    if (ps.pkg.usesOptionalLibraries != null && ps.pkg.usesOptionalLibraries.size() > 0) {
      pw.print(prefix);
      pw.println(""String_Node_Str"");
      for (int i=0; i < ps.pkg.usesOptionalLibraries.size(); i++) {
        pw.print(prefix);
        pw.print(""String_Node_Str"");
        pw.println(ps.pkg.usesOptionalLibraries.get(i));
      }
    }
    if (ps.pkg.usesLibraryFiles != null && ps.pkg.usesLibraryFiles.length > 0) {
      pw.print(prefix);
      pw.println(""String_Node_Str"");
      for (int i=0; i < ps.pkg.usesLibraryFiles.length; i++) {
        pw.print(prefix);
        pw.print(""String_Node_Str"");
        pw.println(ps.pkg.usesLibraryFiles[i]);
      }
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  date.setTime(ps.timeStamp);
  pw.println(sdf.format(date));
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  date.setTime(ps.firstInstallTime);
  pw.println(sdf.format(date));
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  date.setTime(ps.lastUpdateTime);
  pw.println(sdf.format(date));
  if (ps.installerPackageName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(ps.installerPackageName);
  }
  if (ps.volumeUuid != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(ps.volumeUuid);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(ps.signatures);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(ps.installPermissionsFixed);
  pw.print(""String_Node_Str"");
  pw.println(ps.installStatus);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  printFlags(pw,ps.pkgFlags,FLAG_DUMP_SPEC);
  pw.println();
  if (ps.pkg != null && ps.pkg.permissions != null && ps.pkg.permissions.size() > 0) {
    final ArrayList<PackageParser.Permission> perms=ps.pkg.permissions;
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < perms.size(); i++) {
      PackageParser.Permission perm=perms.get(i);
      if (permissionNames != null && !permissionNames.contains(perm.info.name)) {
        continue;
      }
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.print(perm.info.name);
      pw.print(""String_Node_Str"");
      pw.print(PermissionInfo.protectionToString(perm.info.protectionLevel));
      if ((perm.info.flags & PermissionInfo.FLAG_COSTS_MONEY) != 0) {
        pw.print(""String_Node_Str"");
      }
      if ((perm.info.flags & PermissionInfo.FLAG_REMOVED) != 0) {
        pw.print(""String_Node_Str"");
      }
      if ((perm.info.flags & PermissionInfo.FLAG_INSTALLED) != 0) {
        pw.print(""String_Node_Str"");
      }
      pw.println();
    }
  }
  if ((permissionNames != null || dumpAll) && ps.pkg != null && ps.pkg.requestedPermissions != null && ps.pkg.requestedPermissions.size() > 0) {
    final ArrayList<String> perms=ps.pkg.requestedPermissions;
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < perms.size(); i++) {
      String perm=perms.get(i);
      if (permissionNames != null && !permissionNames.contains(perm)) {
        continue;
      }
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(perm);
    }
  }
  if (ps.sharedUser == null || permissionNames != null || dumpAll) {
    PermissionsState permissionsState=ps.getPermissionsState();
    dumpInstallPermissionsLPr(pw,prefix + ""String_Node_Str"",permissionNames,permissionsState);
  }
  for (  UserInfo user : users) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(user.id);
    pw.print(""String_Node_Str"");
    pw.print(""String_Node_Str"");
    pw.print(ps.getInstalled(user.id));
    pw.print(""String_Node_Str"");
    pw.print(ps.getHidden(user.id));
    pw.print(""String_Node_Str"");
    pw.print(ps.getSuspended(user.id));
    pw.print(""String_Node_Str"");
    pw.print(ps.getStopped(user.id));
    pw.print(""String_Node_Str"");
    pw.print(ps.getNotLaunched(user.id));
    pw.print(""String_Node_Str"");
    pw.println(ps.getEnabled(user.id));
    String lastDisabledAppCaller=ps.getLastDisabledAppCaller(user.id);
    if (lastDisabledAppCaller != null) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(lastDisabledAppCaller);
    }
    if (ps.sharedUser == null) {
      PermissionsState permissionsState=ps.getPermissionsState();
      dumpGidsLPr(pw,prefix + ""String_Node_Str"",permissionsState.computeGids(user.id));
      dumpRuntimePermissionsLPr(pw,prefix + ""String_Node_Str"",permissionNames,permissionsState.getRuntimePermissionStates(user.id),dumpAll);
    }
    if (permissionNames == null) {
      ArraySet<String> cmp=ps.getDisabledComponents(user.id);
      if (cmp != null && cmp.size() > 0) {
        pw.print(prefix);
        pw.println(""String_Node_Str"");
        for (        String s : cmp) {
          pw.print(prefix);
          pw.print(""String_Node_Str"");
          pw.println(s);
        }
      }
      cmp=ps.getEnabledComponents(user.id);
      if (cmp != null && cmp.size() > 0) {
        pw.print(prefix);
        pw.println(""String_Node_Str"");
        for (        String s : cmp) {
          pw.print(prefix);
          pw.print(""String_Node_Str"");
          pw.println(s);
        }
      }
    }
  }
}",0.9993162133414376
192396,"@SuppressWarnings(""String_Node_Str"") public void dumpCheckinLocked(Context context,PrintWriter pw,List<ApplicationInfo> apps,int flags,long histStart){
  prepareForDumpLocked();
  dumpLine(pw,0,""String_Node_Str"",VERSION_DATA,CHECKIN_VERSION,getParcelVersion(),getStartPlatformVersion(),getEndPlatformVersion());
  long now=getHistoryBaseTime() + SystemClock.elapsedRealtime();
  final boolean filtering=(flags & (DUMP_HISTORY_ONLY | DUMP_CHARGED_ONLY | DUMP_DAILY_ONLY)) != 0;
  if ((flags & DUMP_INCLUDE_HISTORY) != 0 || (flags & DUMP_HISTORY_ONLY) != 0) {
    if (startIteratingHistoryLocked()) {
      try {
        for (int i=0; i < getHistoryStringPoolSize(); i++) {
          pw.print(BATTERY_STATS_CHECKIN_VERSION);
          pw.print(',');
          pw.print(HISTORY_STRING_POOL);
          pw.print(',');
          pw.print(i);
          pw.print(""String_Node_Str"");
          pw.print(getHistoryTagPoolUid(i));
          pw.print(""String_Node_Str"");
          String str=getHistoryTagPoolString(i);
          str=str.replace(""String_Node_Str"",""String_Node_Str"");
          str=str.replace(""String_Node_Str"",""String_Node_Str"");
          pw.print(str);
          pw.print(""String_Node_Str"");
          pw.println();
        }
        dumpHistoryLocked(pw,flags,histStart,true);
      }
  finally {
        finishIteratingHistoryLocked();
      }
    }
  }
  if (filtering && (flags & (DUMP_CHARGED_ONLY | DUMP_DAILY_ONLY)) == 0) {
    return;
  }
  if (apps != null) {
    SparseArray<ArrayList<String>> uids=new SparseArray<ArrayList<String>>();
    for (int i=0; i < apps.size(); i++) {
      ApplicationInfo ai=apps.get(i);
      ArrayList<String> pkgs=uids.get(ai.uid);
      if (pkgs == null) {
        pkgs=new ArrayList<String>();
        uids.put(ai.uid,pkgs);
      }
      pkgs.add(ai.packageName);
    }
    SparseArray<? extends Uid> uidStats=getUidStats();
    final int NU=uidStats.size();
    String[] lineArgs=new String[2];
    for (int i=0; i < NU; i++) {
      int uid=uidStats.keyAt(i);
      ArrayList<String> pkgs=uids.get(uid);
      if (pkgs != null) {
        for (int j=0; j < pkgs.size(); j++) {
          lineArgs[0]=Integer.toString(uid);
          lineArgs[1]=pkgs.get(j);
          dumpLine(pw,0,""String_Node_Str"",UID_DATA,(Object[])lineArgs);
        }
      }
    }
  }
  if (!filtering || (flags & DUMP_CHARGED_ONLY) != 0) {
    dumpDurationSteps(pw,""String_Node_Str"",DISCHARGE_STEP_DATA,getDischargeLevelStepTracker(),true);
    String[] lineArgs=new String[1];
    long timeRemaining=computeBatteryTimeRemaining(SystemClock.elapsedRealtime());
    if (timeRemaining >= 0) {
      lineArgs[0]=Long.toString(timeRemaining);
      dumpLine(pw,0,""String_Node_Str"",DISCHARGE_TIME_REMAIN_DATA,(Object[])lineArgs);
    }
    dumpDurationSteps(pw,""String_Node_Str"",CHARGE_STEP_DATA,getChargeLevelStepTracker(),true);
    timeRemaining=computeChargeTimeRemaining(SystemClock.elapsedRealtime());
    if (timeRemaining >= 0) {
      lineArgs[0]=Long.toString(timeRemaining);
      dumpLine(pw,0,""String_Node_Str"",CHARGE_TIME_REMAIN_DATA,(Object[])lineArgs);
    }
    dumpCheckinLocked(context,pw,STATS_SINCE_CHARGED,-1,(flags & DUMP_DEVICE_WIFI_ONLY) != 0);
  }
}","@SuppressWarnings(""String_Node_Str"") public void dumpCheckinLocked(Context context,PrintWriter pw,List<ApplicationInfo> apps,int flags,long histStart){
  prepareForDumpLocked();
  dumpLine(pw,0,""String_Node_Str"",VERSION_DATA,CHECKIN_VERSION,getParcelVersion(),getStartPlatformVersion(),getEndPlatformVersion());
  long now=getHistoryBaseTime() + SystemClock.elapsedRealtime();
  final boolean filtering=(flags & (DUMP_HISTORY_ONLY | DUMP_CHARGED_ONLY | DUMP_DAILY_ONLY)) != 0;
  if ((flags & DUMP_INCLUDE_HISTORY) != 0 || (flags & DUMP_HISTORY_ONLY) != 0) {
    if (startIteratingHistoryLocked()) {
      try {
        for (int i=0; i < getHistoryStringPoolSize(); i++) {
          pw.print(BATTERY_STATS_CHECKIN_VERSION);
          pw.print(',');
          pw.print(HISTORY_STRING_POOL);
          pw.print(',');
          pw.print(i);
          pw.print(""String_Node_Str"");
          pw.print(getHistoryTagPoolUid(i));
          pw.print(""String_Node_Str"");
          String str=getHistoryTagPoolString(i);
          str=str.replace(""String_Node_Str"",""String_Node_Str"");
          str=str.replace(""String_Node_Str"",""String_Node_Str"");
          pw.print(str);
          pw.print(""String_Node_Str"");
          pw.println();
        }
        dumpHistoryLocked(pw,flags,histStart,true);
      }
  finally {
        finishIteratingHistoryLocked();
      }
    }
  }
  if (filtering && (flags & (DUMP_CHARGED_ONLY | DUMP_DAILY_ONLY)) == 0) {
    return;
  }
  if (apps != null) {
    SparseArray<Pair<ArrayList<String>,MutableBoolean>> uids=new SparseArray<>();
    for (int i=0; i < apps.size(); i++) {
      ApplicationInfo ai=apps.get(i);
      Pair<ArrayList<String>,MutableBoolean> pkgs=uids.get(UserHandle.getAppId(ai.uid));
      if (pkgs == null) {
        pkgs=new Pair<>(new ArrayList<String>(),new MutableBoolean(false));
        uids.put(UserHandle.getAppId(ai.uid),pkgs);
      }
      pkgs.first.add(ai.packageName);
    }
    SparseArray<? extends Uid> uidStats=getUidStats();
    final int NU=uidStats.size();
    String[] lineArgs=new String[2];
    for (int i=0; i < NU; i++) {
      int uid=UserHandle.getAppId(uidStats.keyAt(i));
      Pair<ArrayList<String>,MutableBoolean> pkgs=uids.get(uid);
      if (pkgs != null && !pkgs.second.value) {
        pkgs.second.value=true;
        for (int j=0; j < pkgs.first.size(); j++) {
          lineArgs[0]=Integer.toString(uid);
          lineArgs[1]=pkgs.first.get(j);
          dumpLine(pw,0,""String_Node_Str"",UID_DATA,(Object[])lineArgs);
        }
      }
    }
  }
  if (!filtering || (flags & DUMP_CHARGED_ONLY) != 0) {
    dumpDurationSteps(pw,""String_Node_Str"",DISCHARGE_STEP_DATA,getDischargeLevelStepTracker(),true);
    String[] lineArgs=new String[1];
    long timeRemaining=computeBatteryTimeRemaining(SystemClock.elapsedRealtime());
    if (timeRemaining >= 0) {
      lineArgs[0]=Long.toString(timeRemaining);
      dumpLine(pw,0,""String_Node_Str"",DISCHARGE_TIME_REMAIN_DATA,(Object[])lineArgs);
    }
    dumpDurationSteps(pw,""String_Node_Str"",CHARGE_STEP_DATA,getChargeLevelStepTracker(),true);
    timeRemaining=computeChargeTimeRemaining(SystemClock.elapsedRealtime());
    if (timeRemaining >= 0) {
      lineArgs[0]=Long.toString(timeRemaining);
      dumpLine(pw,0,""String_Node_Str"",CHARGE_TIME_REMAIN_DATA,(Object[])lineArgs);
    }
    dumpCheckinLocked(context,pw,STATS_SINCE_CHARGED,-1,(flags & DUMP_DEVICE_WIFI_ONLY) != 0);
  }
}",0.8988662131519274
192397,"@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  int flags=0;
  boolean useCheckinFormat=false;
  boolean isRealCheckin=false;
  boolean noOutput=false;
  boolean writeData=false;
  long historyStart=-1;
  int reqUid=-1;
  if (args != null) {
    for (int i=0; i < args.length; i++) {
      String arg=args[i];
      if (""String_Node_Str"".equals(arg)) {
        useCheckinFormat=true;
        isRealCheckin=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        flags|=BatteryStats.DUMP_HISTORY_ONLY;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        flags|=BatteryStats.DUMP_HISTORY_ONLY;
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        historyStart=Long.parseLong(args[i]);
        writeData=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        useCheckinFormat=true;
        flags|=BatteryStats.DUMP_INCLUDE_HISTORY;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        flags|=BatteryStats.DUMP_CHARGED_ONLY;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        flags|=BatteryStats.DUMP_DAILY_ONLY;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mStats) {
          mStats.resetAllStatsCmdLocked();
          pw.println(""String_Node_Str"");
          noOutput=true;
        }
        updateExternalStats(""String_Node_Str"",BatteryStatsImpl.ExternalStatsSync.UPDATE_ALL);
      }
 else       if (""String_Node_Str"".equals(arg)) {
        updateExternalStats(""String_Node_Str"",BatteryStatsImpl.ExternalStatsSync.UPDATE_ALL);
synchronized (mStats) {
          mStats.writeSyncLocked();
          pw.println(""String_Node_Str"");
          noOutput=true;
        }
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mStats) {
          mStats.recordDailyStatsLocked();
          pw.println(""String_Node_Str"");
          noOutput=true;
        }
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mStats) {
          mStats.readDailyStatsLocked();
          pw.println(""String_Node_Str"");
          noOutput=true;
        }
      }
 else       if (""String_Node_Str"".equals(arg) || ""String_Node_Str"".equals(arg)) {
        i=doEnableOrDisable(pw,i,args,true);
        if (i < 0) {
          return;
        }
        pw.println(""String_Node_Str"" + args[i]);
        return;
      }
 else       if (""String_Node_Str"".equals(arg) || ""String_Node_Str"".equals(arg)) {
        i=doEnableOrDisable(pw,i,args,false);
        if (i < 0) {
          return;
        }
        pw.println(""String_Node_Str"" + args[i]);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        flags|=BatteryStats.DUMP_VERBOSE;
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        dumpHelp(pw);
        return;
      }
 else {
        try {
          reqUid=mContext.getPackageManager().getPackageUidAsUser(arg,UserHandle.getCallingUserId());
        }
 catch (        PackageManager.NameNotFoundException e) {
          pw.println(""String_Node_Str"" + arg);
          dumpHelp(pw);
          return;
        }
      }
    }
  }
  if (noOutput) {
    return;
  }
  long ident=Binder.clearCallingIdentity();
  try {
    if (BatteryStatsHelper.checkWifiOnly(mContext)) {
      flags|=BatteryStats.DUMP_DEVICE_WIFI_ONLY;
    }
    updateExternalStats(""String_Node_Str"",BatteryStatsImpl.ExternalStatsSync.UPDATE_ALL);
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
  if (reqUid >= 0) {
    if ((flags & (BatteryStats.DUMP_HISTORY_ONLY | BatteryStats.DUMP_CHARGED_ONLY)) == 0) {
      flags|=BatteryStats.DUMP_CHARGED_ONLY;
      flags&=~BatteryStats.DUMP_INCLUDE_HISTORY;
    }
  }
  if (useCheckinFormat) {
    List<ApplicationInfo> apps=mContext.getPackageManager().getInstalledApplications(0);
    if (isRealCheckin) {
synchronized (mStats.mCheckinFile) {
        if (mStats.mCheckinFile.exists()) {
          try {
            byte[] raw=mStats.mCheckinFile.readFully();
            if (raw != null) {
              Parcel in=Parcel.obtain();
              in.unmarshall(raw,0,raw.length);
              in.setDataPosition(0);
              BatteryStatsImpl checkinStats=new BatteryStatsImpl(null,mStats.mHandler,null);
              checkinStats.readSummaryFromParcel(in);
              in.recycle();
              checkinStats.dumpCheckinLocked(mContext,pw,apps,flags,historyStart);
              mStats.mCheckinFile.delete();
              return;
            }
          }
 catch (          IOException|ParcelFormatException e) {
            Slog.w(TAG,""String_Node_Str"" + mStats.mCheckinFile.getBaseFile(),e);
          }
        }
      }
    }
synchronized (mStats) {
      mStats.dumpCheckinLocked(mContext,pw,apps,flags,historyStart);
      if (writeData) {
        mStats.writeAsyncLocked();
      }
    }
  }
 else {
synchronized (mStats) {
      mStats.dumpLocked(mContext,pw,flags,reqUid,historyStart);
      if (writeData) {
        mStats.writeAsyncLocked();
      }
    }
  }
}","@Override protected void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
    pw.println(""String_Node_Str"" + Binder.getCallingPid() + ""String_Node_Str""+ Binder.getCallingUid()+ ""String_Node_Str""+ android.Manifest.permission.DUMP);
    return;
  }
  int flags=0;
  boolean useCheckinFormat=false;
  boolean isRealCheckin=false;
  boolean noOutput=false;
  boolean writeData=false;
  long historyStart=-1;
  int reqUid=-1;
  if (args != null) {
    for (int i=0; i < args.length; i++) {
      String arg=args[i];
      if (""String_Node_Str"".equals(arg)) {
        useCheckinFormat=true;
        isRealCheckin=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        flags|=BatteryStats.DUMP_HISTORY_ONLY;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        flags|=BatteryStats.DUMP_HISTORY_ONLY;
        i++;
        if (i >= args.length) {
          pw.println(""String_Node_Str"");
          dumpHelp(pw);
          return;
        }
        historyStart=Long.parseLong(args[i]);
        writeData=true;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        useCheckinFormat=true;
        flags|=BatteryStats.DUMP_INCLUDE_HISTORY;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        flags|=BatteryStats.DUMP_CHARGED_ONLY;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        flags|=BatteryStats.DUMP_DAILY_ONLY;
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mStats) {
          mStats.resetAllStatsCmdLocked();
          pw.println(""String_Node_Str"");
          noOutput=true;
        }
        updateExternalStats(""String_Node_Str"",BatteryStatsImpl.ExternalStatsSync.UPDATE_ALL);
      }
 else       if (""String_Node_Str"".equals(arg)) {
        updateExternalStats(""String_Node_Str"",BatteryStatsImpl.ExternalStatsSync.UPDATE_ALL);
synchronized (mStats) {
          mStats.writeSyncLocked();
          pw.println(""String_Node_Str"");
          noOutput=true;
        }
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mStats) {
          mStats.recordDailyStatsLocked();
          pw.println(""String_Node_Str"");
          noOutput=true;
        }
      }
 else       if (""String_Node_Str"".equals(arg)) {
synchronized (mStats) {
          mStats.readDailyStatsLocked();
          pw.println(""String_Node_Str"");
          noOutput=true;
        }
      }
 else       if (""String_Node_Str"".equals(arg) || ""String_Node_Str"".equals(arg)) {
        i=doEnableOrDisable(pw,i,args,true);
        if (i < 0) {
          return;
        }
        pw.println(""String_Node_Str"" + args[i]);
        return;
      }
 else       if (""String_Node_Str"".equals(arg) || ""String_Node_Str"".equals(arg)) {
        i=doEnableOrDisable(pw,i,args,false);
        if (i < 0) {
          return;
        }
        pw.println(""String_Node_Str"" + args[i]);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        dumpHelp(pw);
        return;
      }
 else       if (""String_Node_Str"".equals(arg)) {
        flags|=BatteryStats.DUMP_VERBOSE;
      }
 else       if (arg.length() > 0 && arg.charAt(0) == '-') {
        pw.println(""String_Node_Str"" + arg);
        dumpHelp(pw);
        return;
      }
 else {
        try {
          reqUid=mContext.getPackageManager().getPackageUidAsUser(arg,UserHandle.getCallingUserId());
        }
 catch (        PackageManager.NameNotFoundException e) {
          pw.println(""String_Node_Str"" + arg);
          dumpHelp(pw);
          return;
        }
      }
    }
  }
  if (noOutput) {
    return;
  }
  long ident=Binder.clearCallingIdentity();
  try {
    if (BatteryStatsHelper.checkWifiOnly(mContext)) {
      flags|=BatteryStats.DUMP_DEVICE_WIFI_ONLY;
    }
    updateExternalStats(""String_Node_Str"",BatteryStatsImpl.ExternalStatsSync.UPDATE_ALL);
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
  if (reqUid >= 0) {
    if ((flags & (BatteryStats.DUMP_HISTORY_ONLY | BatteryStats.DUMP_CHARGED_ONLY)) == 0) {
      flags|=BatteryStats.DUMP_CHARGED_ONLY;
      flags&=~BatteryStats.DUMP_INCLUDE_HISTORY;
    }
  }
  if (useCheckinFormat) {
    List<ApplicationInfo> apps=mContext.getPackageManager().getInstalledApplications(PackageManager.MATCH_UNINSTALLED_PACKAGES | PackageManager.MATCH_ALL);
    if (isRealCheckin) {
synchronized (mStats.mCheckinFile) {
        if (mStats.mCheckinFile.exists()) {
          try {
            byte[] raw=mStats.mCheckinFile.readFully();
            if (raw != null) {
              Parcel in=Parcel.obtain();
              in.unmarshall(raw,0,raw.length);
              in.setDataPosition(0);
              BatteryStatsImpl checkinStats=new BatteryStatsImpl(null,mStats.mHandler,null);
              checkinStats.readSummaryFromParcel(in);
              in.recycle();
              checkinStats.dumpCheckinLocked(mContext,pw,apps,flags,historyStart);
              mStats.mCheckinFile.delete();
              return;
            }
          }
 catch (          IOException|ParcelFormatException e) {
            Slog.w(TAG,""String_Node_Str"" + mStats.mCheckinFile.getBaseFile(),e);
          }
        }
      }
    }
synchronized (mStats) {
      mStats.dumpCheckinLocked(mContext,pw,apps,flags,historyStart);
      if (writeData) {
        mStats.writeAsyncLocked();
      }
    }
  }
 else {
synchronized (mStats) {
      mStats.dumpLocked(mContext,pw,flags,reqUid,historyStart);
      if (writeData) {
        mStats.writeAsyncLocked();
      }
    }
  }
}",0.9937821032711543
192398,"void dumpPackageLPr(PrintWriter pw,String prefix,String checkinTag,ArraySet<String> permissionNames,PackageSetting ps,SimpleDateFormat sdf,Date date,List<UserInfo> users,boolean dumpAll){
  if (checkinTag != null) {
    pw.print(checkinTag);
    pw.print(""String_Node_Str"");
    pw.print(ps.realName != null ? ps.realName : ps.name);
    pw.print(""String_Node_Str"");
    pw.print(ps.appId);
    pw.print(""String_Node_Str"");
    pw.print(ps.versionCode);
    pw.print(""String_Node_Str"");
    pw.print(ps.firstInstallTime);
    pw.print(""String_Node_Str"");
    pw.print(ps.lastUpdateTime);
    pw.print(""String_Node_Str"");
    pw.print(ps.installerPackageName != null ? ps.installerPackageName : ""String_Node_Str"");
    pw.println();
    if (ps.pkg != null) {
      pw.print(checkinTag);
      pw.print(""String_Node_Str"");
      pw.print(""String_Node_Str"");
      pw.print(""String_Node_Str"");
      pw.println(ps.pkg.baseRevisionCode);
      if (ps.pkg.splitNames != null) {
        for (int i=0; i < ps.pkg.splitNames.length; i++) {
          pw.print(checkinTag);
          pw.print(""String_Node_Str"");
          pw.print(""String_Node_Str"");
          pw.print(ps.pkg.splitNames[i]);
          pw.print(""String_Node_Str"");
          pw.println(ps.pkg.splitRevisionCodes[i]);
        }
      }
    }
    for (    UserInfo user : users) {
      pw.print(checkinTag);
      pw.print(""String_Node_Str"");
      pw.print(""String_Node_Str"");
      pw.print(""String_Node_Str"");
      pw.print(user.id);
      pw.print(""String_Node_Str"");
      pw.print(ps.getInstalled(user.id) ? ""String_Node_Str"" : ""String_Node_Str"");
      pw.print(ps.getHidden(user.id) ? ""String_Node_Str"" : ""String_Node_Str"");
      pw.print(ps.getSuspended(user.id) ? ""String_Node_Str"" : ""String_Node_Str"");
      pw.print(ps.getStopped(user.id) ? ""String_Node_Str"" : ""String_Node_Str"");
      pw.print(ps.getNotLaunched(user.id) ? ""String_Node_Str"" : ""String_Node_Str"");
      pw.print(""String_Node_Str"");
      pw.print(ps.getEnabled(user.id));
      String lastDisabledAppCaller=ps.getLastDisabledAppCaller(user.id);
      pw.print(""String_Node_Str"");
      pw.print(lastDisabledAppCaller != null ? lastDisabledAppCaller : ""String_Node_Str"");
      pw.println();
    }
    return;
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(ps.realName != null ? ps.realName : ps.name);
  pw.print(""String_Node_Str"");
  pw.print(Integer.toHexString(System.identityHashCode(ps)));
  pw.println(""String_Node_Str"");
  if (ps.frozen) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
  }
  if (ps.realName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(ps.name);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(ps.appId);
  if (ps.sharedUser != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(ps.sharedUser);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(ps.pkg);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(ps.codePathString);
  if (permissionNames == null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(ps.resourcePathString);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(ps.legacyNativeLibraryPathString);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(ps.primaryCpuAbiString);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(ps.secondaryCpuAbiString);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(ps.versionCode);
  if (ps.pkg != null) {
    pw.print(""String_Node_Str"");
    pw.print(ps.pkg.applicationInfo.minSdkVersion);
    pw.print(""String_Node_Str"");
    pw.print(ps.pkg.applicationInfo.targetSdkVersion);
  }
  pw.println();
  if (ps.pkg != null) {
    if (ps.pkg.parentPackage != null) {
      PackageParser.Package parentPkg=ps.pkg.parentPackage;
      PackageSetting pps=mPackages.get(parentPkg.packageName);
      if (pps == null || !pps.codePathString.equals(parentPkg.codePath)) {
        pps=mDisabledSysPackages.get(parentPkg.packageName);
      }
      if (pps != null) {
        pw.print(prefix);
        pw.print(""String_Node_Str"");
        pw.println(pps.realName != null ? pps.realName : pps.name);
      }
    }
 else     if (ps.pkg.childPackages != null) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      final int childCount=ps.pkg.childPackages.size();
      for (int i=0; i < childCount; i++) {
        PackageParser.Package childPkg=ps.pkg.childPackages.get(i);
        PackageSetting cps=mPackages.get(childPkg.packageName);
        if (cps == null || !cps.codePathString.equals(childPkg.codePath)) {
          cps=mDisabledSysPackages.get(childPkg.packageName);
        }
        if (cps != null) {
          if (i > 0) {
            pw.print(""String_Node_Str"");
          }
          pw.print(cps.realName != null ? cps.realName : cps.name);
        }
      }
      pw.println(""String_Node_Str"");
    }
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(ps.pkg.mVersionName);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    dumpSplitNames(pw,ps.pkg);
    pw.println();
    final int apkSigningVersion=PackageParser.getApkSigningVersion(ps.pkg);
    if (apkSigningVersion != PackageParser.APK_SIGNING_UNKNOWN) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(apkSigningVersion);
    }
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(ps.pkg.applicationInfo.toString());
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    printFlags(pw,ps.pkg.applicationInfo.flags,FLAG_DUMP_SPEC);
    pw.println();
    if (ps.pkg.applicationInfo.privateFlags != 0) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      printFlags(pw,ps.pkg.applicationInfo.privateFlags,PRIVATE_FLAG_DUMP_SPEC);
      pw.println();
    }
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(ps.pkg.applicationInfo.dataDir);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    boolean first=true;
    if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_SMALL_SCREENS) != 0) {
      if (!first)       pw.print(""String_Node_Str"");
      first=false;
      pw.print(""String_Node_Str"");
    }
    if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_NORMAL_SCREENS) != 0) {
      if (!first)       pw.print(""String_Node_Str"");
      first=false;
      pw.print(""String_Node_Str"");
    }
    if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_LARGE_SCREENS) != 0) {
      if (!first)       pw.print(""String_Node_Str"");
      first=false;
      pw.print(""String_Node_Str"");
    }
    if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_XLARGE_SCREENS) != 0) {
      if (!first)       pw.print(""String_Node_Str"");
      first=false;
      pw.print(""String_Node_Str"");
    }
    if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_RESIZEABLE_FOR_SCREENS) != 0) {
      if (!first)       pw.print(""String_Node_Str"");
      first=false;
      pw.print(""String_Node_Str"");
    }
    if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES) != 0) {
      if (!first)       pw.print(""String_Node_Str"");
      first=false;
      pw.print(""String_Node_Str"");
    }
    pw.println(""String_Node_Str"");
    if (ps.pkg.libraryNames != null && ps.pkg.libraryNames.size() > 0) {
      pw.print(prefix);
      pw.println(""String_Node_Str"");
      for (int i=0; i < ps.pkg.libraryNames.size(); i++) {
        pw.print(prefix);
        pw.print(""String_Node_Str"");
        pw.println(ps.pkg.libraryNames.get(i));
      }
    }
    if (ps.pkg.usesLibraries != null && ps.pkg.usesLibraries.size() > 0) {
      pw.print(prefix);
      pw.println(""String_Node_Str"");
      for (int i=0; i < ps.pkg.usesLibraries.size(); i++) {
        pw.print(prefix);
        pw.print(""String_Node_Str"");
        pw.println(ps.pkg.usesLibraries.get(i));
      }
    }
    if (ps.pkg.usesOptionalLibraries != null && ps.pkg.usesOptionalLibraries.size() > 0) {
      pw.print(prefix);
      pw.println(""String_Node_Str"");
      for (int i=0; i < ps.pkg.usesOptionalLibraries.size(); i++) {
        pw.print(prefix);
        pw.print(""String_Node_Str"");
        pw.println(ps.pkg.usesOptionalLibraries.get(i));
      }
    }
    if (ps.pkg.usesLibraryFiles != null && ps.pkg.usesLibraryFiles.length > 0) {
      pw.print(prefix);
      pw.println(""String_Node_Str"");
      for (int i=0; i < ps.pkg.usesLibraryFiles.length; i++) {
        pw.print(prefix);
        pw.print(""String_Node_Str"");
        pw.println(ps.pkg.usesLibraryFiles[i]);
      }
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  date.setTime(ps.timeStamp);
  pw.println(sdf.format(date));
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  date.setTime(ps.firstInstallTime);
  pw.println(sdf.format(date));
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  date.setTime(ps.lastUpdateTime);
  pw.println(sdf.format(date));
  if (ps.installerPackageName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(ps.installerPackageName);
  }
  if (ps.volumeUuid != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(ps.volumeUuid);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(ps.signatures);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(ps.installPermissionsFixed);
  pw.print(""String_Node_Str"");
  pw.println(ps.installStatus);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  printFlags(pw,ps.pkgFlags,FLAG_DUMP_SPEC);
  pw.println();
  if (ps.pkg != null && ps.pkg.permissions != null && ps.pkg.permissions.size() > 0) {
    final ArrayList<PackageParser.Permission> perms=ps.pkg.permissions;
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < perms.size(); i++) {
      PackageParser.Permission perm=perms.get(i);
      if (permissionNames != null && !permissionNames.contains(perm.info.name)) {
        continue;
      }
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.print(perm.info.name);
      pw.print(""String_Node_Str"");
      pw.print(PermissionInfo.protectionToString(perm.info.protectionLevel));
      if ((perm.info.flags & PermissionInfo.FLAG_COSTS_MONEY) != 0) {
        pw.print(""String_Node_Str"");
      }
      if ((perm.info.flags & PermissionInfo.FLAG_REMOVED) != 0) {
        pw.print(""String_Node_Str"");
      }
      if ((perm.info.flags & PermissionInfo.FLAG_INSTALLED) != 0) {
        pw.print(""String_Node_Str"");
      }
      pw.println();
    }
  }
  if ((permissionNames != null || dumpAll) && ps.pkg.requestedPermissions != null && ps.pkg.requestedPermissions.size() > 0) {
    final ArrayList<String> perms=ps.pkg.requestedPermissions;
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < perms.size(); i++) {
      String perm=perms.get(i);
      if (permissionNames != null && !permissionNames.contains(perm)) {
        continue;
      }
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(perm);
    }
  }
  if (ps.sharedUser == null || permissionNames != null || dumpAll) {
    PermissionsState permissionsState=ps.getPermissionsState();
    dumpInstallPermissionsLPr(pw,prefix + ""String_Node_Str"",permissionNames,permissionsState);
  }
  for (  UserInfo user : users) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(user.id);
    pw.print(""String_Node_Str"");
    pw.print(""String_Node_Str"");
    pw.print(ps.getInstalled(user.id));
    pw.print(""String_Node_Str"");
    pw.print(ps.getHidden(user.id));
    pw.print(""String_Node_Str"");
    pw.print(ps.getSuspended(user.id));
    pw.print(""String_Node_Str"");
    pw.print(ps.getStopped(user.id));
    pw.print(""String_Node_Str"");
    pw.print(ps.getNotLaunched(user.id));
    pw.print(""String_Node_Str"");
    pw.println(ps.getEnabled(user.id));
    String lastDisabledAppCaller=ps.getLastDisabledAppCaller(user.id);
    if (lastDisabledAppCaller != null) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(lastDisabledAppCaller);
    }
    if (ps.sharedUser == null) {
      PermissionsState permissionsState=ps.getPermissionsState();
      dumpGidsLPr(pw,prefix + ""String_Node_Str"",permissionsState.computeGids(user.id));
      dumpRuntimePermissionsLPr(pw,prefix + ""String_Node_Str"",permissionNames,permissionsState.getRuntimePermissionStates(user.id),dumpAll);
    }
    if (permissionNames == null) {
      ArraySet<String> cmp=ps.getDisabledComponents(user.id);
      if (cmp != null && cmp.size() > 0) {
        pw.print(prefix);
        pw.println(""String_Node_Str"");
        for (        String s : cmp) {
          pw.print(prefix);
          pw.print(""String_Node_Str"");
          pw.println(s);
        }
      }
      cmp=ps.getEnabledComponents(user.id);
      if (cmp != null && cmp.size() > 0) {
        pw.print(prefix);
        pw.println(""String_Node_Str"");
        for (        String s : cmp) {
          pw.print(prefix);
          pw.print(""String_Node_Str"");
          pw.println(s);
        }
      }
    }
  }
}","void dumpPackageLPr(PrintWriter pw,String prefix,String checkinTag,ArraySet<String> permissionNames,PackageSetting ps,SimpleDateFormat sdf,Date date,List<UserInfo> users,boolean dumpAll){
  if (checkinTag != null) {
    pw.print(checkinTag);
    pw.print(""String_Node_Str"");
    pw.print(ps.realName != null ? ps.realName : ps.name);
    pw.print(""String_Node_Str"");
    pw.print(ps.appId);
    pw.print(""String_Node_Str"");
    pw.print(ps.versionCode);
    pw.print(""String_Node_Str"");
    pw.print(ps.firstInstallTime);
    pw.print(""String_Node_Str"");
    pw.print(ps.lastUpdateTime);
    pw.print(""String_Node_Str"");
    pw.print(ps.installerPackageName != null ? ps.installerPackageName : ""String_Node_Str"");
    pw.println();
    if (ps.pkg != null) {
      pw.print(checkinTag);
      pw.print(""String_Node_Str"");
      pw.print(""String_Node_Str"");
      pw.print(""String_Node_Str"");
      pw.println(ps.pkg.baseRevisionCode);
      if (ps.pkg.splitNames != null) {
        for (int i=0; i < ps.pkg.splitNames.length; i++) {
          pw.print(checkinTag);
          pw.print(""String_Node_Str"");
          pw.print(""String_Node_Str"");
          pw.print(ps.pkg.splitNames[i]);
          pw.print(""String_Node_Str"");
          pw.println(ps.pkg.splitRevisionCodes[i]);
        }
      }
    }
    for (    UserInfo user : users) {
      pw.print(checkinTag);
      pw.print(""String_Node_Str"");
      pw.print(""String_Node_Str"");
      pw.print(""String_Node_Str"");
      pw.print(user.id);
      pw.print(""String_Node_Str"");
      pw.print(ps.getInstalled(user.id) ? ""String_Node_Str"" : ""String_Node_Str"");
      pw.print(ps.getHidden(user.id) ? ""String_Node_Str"" : ""String_Node_Str"");
      pw.print(ps.getSuspended(user.id) ? ""String_Node_Str"" : ""String_Node_Str"");
      pw.print(ps.getStopped(user.id) ? ""String_Node_Str"" : ""String_Node_Str"");
      pw.print(ps.getNotLaunched(user.id) ? ""String_Node_Str"" : ""String_Node_Str"");
      pw.print(""String_Node_Str"");
      pw.print(ps.getEnabled(user.id));
      String lastDisabledAppCaller=ps.getLastDisabledAppCaller(user.id);
      pw.print(""String_Node_Str"");
      pw.print(lastDisabledAppCaller != null ? lastDisabledAppCaller : ""String_Node_Str"");
      pw.println();
    }
    return;
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(ps.realName != null ? ps.realName : ps.name);
  pw.print(""String_Node_Str"");
  pw.print(Integer.toHexString(System.identityHashCode(ps)));
  pw.println(""String_Node_Str"");
  if (ps.frozen) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
  }
  if (ps.realName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(ps.name);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(ps.appId);
  if (ps.sharedUser != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(ps.sharedUser);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(ps.pkg);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(ps.codePathString);
  if (permissionNames == null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(ps.resourcePathString);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(ps.legacyNativeLibraryPathString);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(ps.primaryCpuAbiString);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(ps.secondaryCpuAbiString);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(ps.versionCode);
  if (ps.pkg != null) {
    pw.print(""String_Node_Str"");
    pw.print(ps.pkg.applicationInfo.minSdkVersion);
    pw.print(""String_Node_Str"");
    pw.print(ps.pkg.applicationInfo.targetSdkVersion);
  }
  pw.println();
  if (ps.pkg != null) {
    if (ps.pkg.parentPackage != null) {
      PackageParser.Package parentPkg=ps.pkg.parentPackage;
      PackageSetting pps=mPackages.get(parentPkg.packageName);
      if (pps == null || !pps.codePathString.equals(parentPkg.codePath)) {
        pps=mDisabledSysPackages.get(parentPkg.packageName);
      }
      if (pps != null) {
        pw.print(prefix);
        pw.print(""String_Node_Str"");
        pw.println(pps.realName != null ? pps.realName : pps.name);
      }
    }
 else     if (ps.pkg.childPackages != null) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      final int childCount=ps.pkg.childPackages.size();
      for (int i=0; i < childCount; i++) {
        PackageParser.Package childPkg=ps.pkg.childPackages.get(i);
        PackageSetting cps=mPackages.get(childPkg.packageName);
        if (cps == null || !cps.codePathString.equals(childPkg.codePath)) {
          cps=mDisabledSysPackages.get(childPkg.packageName);
        }
        if (cps != null) {
          if (i > 0) {
            pw.print(""String_Node_Str"");
          }
          pw.print(cps.realName != null ? cps.realName : cps.name);
        }
      }
      pw.println(""String_Node_Str"");
    }
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(ps.pkg.mVersionName);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    dumpSplitNames(pw,ps.pkg);
    pw.println();
    final int apkSigningVersion=PackageParser.getApkSigningVersion(ps.pkg);
    if (apkSigningVersion != PackageParser.APK_SIGNING_UNKNOWN) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(apkSigningVersion);
    }
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(ps.pkg.applicationInfo.toString());
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    printFlags(pw,ps.pkg.applicationInfo.flags,FLAG_DUMP_SPEC);
    pw.println();
    if (ps.pkg.applicationInfo.privateFlags != 0) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      printFlags(pw,ps.pkg.applicationInfo.privateFlags,PRIVATE_FLAG_DUMP_SPEC);
      pw.println();
    }
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(ps.pkg.applicationInfo.dataDir);
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    boolean first=true;
    if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_SMALL_SCREENS) != 0) {
      if (!first)       pw.print(""String_Node_Str"");
      first=false;
      pw.print(""String_Node_Str"");
    }
    if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_NORMAL_SCREENS) != 0) {
      if (!first)       pw.print(""String_Node_Str"");
      first=false;
      pw.print(""String_Node_Str"");
    }
    if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_LARGE_SCREENS) != 0) {
      if (!first)       pw.print(""String_Node_Str"");
      first=false;
      pw.print(""String_Node_Str"");
    }
    if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_XLARGE_SCREENS) != 0) {
      if (!first)       pw.print(""String_Node_Str"");
      first=false;
      pw.print(""String_Node_Str"");
    }
    if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_RESIZEABLE_FOR_SCREENS) != 0) {
      if (!first)       pw.print(""String_Node_Str"");
      first=false;
      pw.print(""String_Node_Str"");
    }
    if ((ps.pkg.applicationInfo.flags & ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES) != 0) {
      if (!first)       pw.print(""String_Node_Str"");
      first=false;
      pw.print(""String_Node_Str"");
    }
    pw.println(""String_Node_Str"");
    if (ps.pkg.libraryNames != null && ps.pkg.libraryNames.size() > 0) {
      pw.print(prefix);
      pw.println(""String_Node_Str"");
      for (int i=0; i < ps.pkg.libraryNames.size(); i++) {
        pw.print(prefix);
        pw.print(""String_Node_Str"");
        pw.println(ps.pkg.libraryNames.get(i));
      }
    }
    if (ps.pkg.usesLibraries != null && ps.pkg.usesLibraries.size() > 0) {
      pw.print(prefix);
      pw.println(""String_Node_Str"");
      for (int i=0; i < ps.pkg.usesLibraries.size(); i++) {
        pw.print(prefix);
        pw.print(""String_Node_Str"");
        pw.println(ps.pkg.usesLibraries.get(i));
      }
    }
    if (ps.pkg.usesOptionalLibraries != null && ps.pkg.usesOptionalLibraries.size() > 0) {
      pw.print(prefix);
      pw.println(""String_Node_Str"");
      for (int i=0; i < ps.pkg.usesOptionalLibraries.size(); i++) {
        pw.print(prefix);
        pw.print(""String_Node_Str"");
        pw.println(ps.pkg.usesOptionalLibraries.get(i));
      }
    }
    if (ps.pkg.usesLibraryFiles != null && ps.pkg.usesLibraryFiles.length > 0) {
      pw.print(prefix);
      pw.println(""String_Node_Str"");
      for (int i=0; i < ps.pkg.usesLibraryFiles.length; i++) {
        pw.print(prefix);
        pw.print(""String_Node_Str"");
        pw.println(ps.pkg.usesLibraryFiles[i]);
      }
    }
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  date.setTime(ps.timeStamp);
  pw.println(sdf.format(date));
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  date.setTime(ps.firstInstallTime);
  pw.println(sdf.format(date));
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  date.setTime(ps.lastUpdateTime);
  pw.println(sdf.format(date));
  if (ps.installerPackageName != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(ps.installerPackageName);
  }
  if (ps.volumeUuid != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(ps.volumeUuid);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(ps.signatures);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(ps.installPermissionsFixed);
  pw.print(""String_Node_Str"");
  pw.println(ps.installStatus);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  printFlags(pw,ps.pkgFlags,FLAG_DUMP_SPEC);
  pw.println();
  if (ps.pkg != null && ps.pkg.permissions != null && ps.pkg.permissions.size() > 0) {
    final ArrayList<PackageParser.Permission> perms=ps.pkg.permissions;
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < perms.size(); i++) {
      PackageParser.Permission perm=perms.get(i);
      if (permissionNames != null && !permissionNames.contains(perm.info.name)) {
        continue;
      }
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.print(perm.info.name);
      pw.print(""String_Node_Str"");
      pw.print(PermissionInfo.protectionToString(perm.info.protectionLevel));
      if ((perm.info.flags & PermissionInfo.FLAG_COSTS_MONEY) != 0) {
        pw.print(""String_Node_Str"");
      }
      if ((perm.info.flags & PermissionInfo.FLAG_REMOVED) != 0) {
        pw.print(""String_Node_Str"");
      }
      if ((perm.info.flags & PermissionInfo.FLAG_INSTALLED) != 0) {
        pw.print(""String_Node_Str"");
      }
      pw.println();
    }
  }
  if ((permissionNames != null || dumpAll) && ps.pkg != null && ps.pkg.requestedPermissions != null && ps.pkg.requestedPermissions.size() > 0) {
    final ArrayList<String> perms=ps.pkg.requestedPermissions;
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < perms.size(); i++) {
      String perm=perms.get(i);
      if (permissionNames != null && !permissionNames.contains(perm)) {
        continue;
      }
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(perm);
    }
  }
  if (ps.sharedUser == null || permissionNames != null || dumpAll) {
    PermissionsState permissionsState=ps.getPermissionsState();
    dumpInstallPermissionsLPr(pw,prefix + ""String_Node_Str"",permissionNames,permissionsState);
  }
  for (  UserInfo user : users) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(user.id);
    pw.print(""String_Node_Str"");
    pw.print(""String_Node_Str"");
    pw.print(ps.getInstalled(user.id));
    pw.print(""String_Node_Str"");
    pw.print(ps.getHidden(user.id));
    pw.print(""String_Node_Str"");
    pw.print(ps.getSuspended(user.id));
    pw.print(""String_Node_Str"");
    pw.print(ps.getStopped(user.id));
    pw.print(""String_Node_Str"");
    pw.print(ps.getNotLaunched(user.id));
    pw.print(""String_Node_Str"");
    pw.println(ps.getEnabled(user.id));
    String lastDisabledAppCaller=ps.getLastDisabledAppCaller(user.id);
    if (lastDisabledAppCaller != null) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(lastDisabledAppCaller);
    }
    if (ps.sharedUser == null) {
      PermissionsState permissionsState=ps.getPermissionsState();
      dumpGidsLPr(pw,prefix + ""String_Node_Str"",permissionsState.computeGids(user.id));
      dumpRuntimePermissionsLPr(pw,prefix + ""String_Node_Str"",permissionNames,permissionsState.getRuntimePermissionStates(user.id),dumpAll);
    }
    if (permissionNames == null) {
      ArraySet<String> cmp=ps.getDisabledComponents(user.id);
      if (cmp != null && cmp.size() > 0) {
        pw.print(prefix);
        pw.println(""String_Node_Str"");
        for (        String s : cmp) {
          pw.print(prefix);
          pw.print(""String_Node_Str"");
          pw.println(s);
        }
      }
      cmp=ps.getEnabledComponents(user.id);
      if (cmp != null && cmp.size() > 0) {
        pw.print(prefix);
        pw.println(""String_Node_Str"");
        for (        String s : cmp) {
          pw.print(prefix);
          pw.print(""String_Node_Str"");
          pw.println(s);
        }
      }
    }
  }
}",0.9993162133414376
192399,"/** 
 * Called when the fragment is no longer attached to its activity.  This is called after  {@link #onDestroy()}, except in the cases where the fragment instance is retained across Activity re-creation (see   {@link #setRetainInstance(boolean)}), in which case it is called after   {@link #onStop()}.
 */
public void onDetach(){
  mCalled=true;
}","/** 
 * Called when the fragment is no longer attached to its activity.  This is called after  {@link #onDestroy()}, except in the cases where the fragment instance is retained across Activity re-creation (see   {@link #setRetainInstance(boolean)}), in which case it is called after   {@link #onStop()}.
 */
public void onDetach(){
  mCalled=true;
  if (mChildFragmentManager != null) {
    if (!mRetaining) {
      throw new IllegalStateException(""String_Node_Str"" + this + ""String_Node_Str""+ ""String_Node_Str"");
    }
    mChildFragmentManager.dispatchDestroy();
    mChildFragmentManager=null;
  }
}",0.7339642481598317
192400,"/** 
 * Called to do initial creation of a fragment.  This is called after  {@link #onAttach(Activity)} and before{@link #onCreateView(LayoutInflater,ViewGroup,Bundle)}, but is not called if the fragment instance is retained across Activity re-creation (see   {@link #setRetainInstance(boolean)}). <p>Note that this can be called while the fragment's activity is still in the process of being created.  As such, you can not rely on things like the activity's content view hierarchy being initialized at this point.  If you want to do work once the activity itself is created, see   {@link #onActivityCreated(Bundle)}. <p>If your app's <code>targetSdkVersion</code> is 23 or lower, child fragments being restored from the savedInstanceState are restored after <code>onCreate</code> returns. When targeting N or above and running on an N or newer platform version they are restored by <code>Fragment.onCreate</code>.</p>
 * @param savedInstanceState If the fragment is being re-created froma previous saved state, this is the state.
 */
public void onCreate(@Nullable Bundle savedInstanceState){
  mCalled=true;
  final Context context=getContext();
  final int version=context != null ? context.getApplicationInfo().targetSdkVersion : 0;
  if (version >= Build.VERSION_CODES.N) {
    if (savedInstanceState != null) {
      Parcelable p=savedInstanceState.getParcelable(Activity.FRAGMENTS_TAG);
      if (p != null) {
        if (mChildFragmentManager == null) {
          instantiateChildFragmentManager();
        }
        mChildFragmentManager.restoreAllState(p,mChildNonConfig);
        mChildNonConfig=null;
        mChildFragmentManager.dispatchCreate();
      }
    }
  }
}","/** 
 * Called to do initial creation of a fragment.  This is called after  {@link #onAttach(Activity)} and before{@link #onCreateView(LayoutInflater,ViewGroup,Bundle)}, but is not called if the fragment instance is retained across Activity re-creation (see   {@link #setRetainInstance(boolean)}). <p>Note that this can be called while the fragment's activity is still in the process of being created.  As such, you can not rely on things like the activity's content view hierarchy being initialized at this point.  If you want to do work once the activity itself is created, see   {@link #onActivityCreated(Bundle)}. <p>If your app's <code>targetSdkVersion</code> is 23 or lower, child fragments being restored from the savedInstanceState are restored after <code>onCreate</code> returns. When targeting N or above and running on an N or newer platform version they are restored by <code>Fragment.onCreate</code>.</p>
 * @param savedInstanceState If the fragment is being re-created froma previous saved state, this is the state.
 */
public void onCreate(@Nullable Bundle savedInstanceState){
  mCalled=true;
  final Context context=getContext();
  final int version=context != null ? context.getApplicationInfo().targetSdkVersion : 0;
  if (version >= Build.VERSION_CODES.N) {
    restoreChildFragmentState(savedInstanceState,true);
  }
}",0.8675496688741722
192401,"void performCreate(Bundle savedInstanceState){
  if (mChildFragmentManager != null) {
    mChildFragmentManager.noteStateNotSaved();
  }
  mState=CREATED;
  mCalled=false;
  onCreate(savedInstanceState);
  if (!mCalled) {
    throw new SuperNotCalledException(""String_Node_Str"" + this + ""String_Node_Str"");
  }
  final Context context=getContext();
  final int version=context != null ? context.getApplicationInfo().targetSdkVersion : 0;
  if (version < Build.VERSION_CODES.N) {
    if (savedInstanceState != null) {
      Parcelable p=savedInstanceState.getParcelable(Activity.FRAGMENTS_TAG);
      if (p != null) {
        if (mChildFragmentManager == null) {
          instantiateChildFragmentManager();
        }
        mChildFragmentManager.restoreAllState(p,null);
        mChildFragmentManager.dispatchCreate();
      }
    }
  }
}","void performCreate(Bundle savedInstanceState){
  if (mChildFragmentManager != null) {
    mChildFragmentManager.noteStateNotSaved();
  }
  mState=CREATED;
  mCalled=false;
  onCreate(savedInstanceState);
  if (!mCalled) {
    throw new SuperNotCalledException(""String_Node_Str"" + this + ""String_Node_Str"");
  }
  final Context context=getContext();
  final int version=context != null ? context.getApplicationInfo().targetSdkVersion : 0;
  if (version < Build.VERSION_CODES.N) {
    restoreChildFragmentState(savedInstanceState,false);
  }
}",0.7347826086956522
192402,"/** 
 * Called when the fragment is no longer attached to its activity.  This is called after  {@link #onDestroy()}, except in the cases where the fragment instance is retained across Activity re-creation (see   {@link #setRetainInstance(boolean)}), in which case it is called after   {@link #onStop()}.
 */
public void onDetach(){
  mCalled=true;
}","/** 
 * Called when the fragment is no longer attached to its activity.  This is called after  {@link #onDestroy()}, except in the cases where the fragment instance is retained across Activity re-creation (see   {@link #setRetainInstance(boolean)}), in which case it is called after   {@link #onStop()}.
 */
public void onDetach(){
  mCalled=true;
  if (mChildFragmentManager != null) {
    if (!mRetaining) {
      throw new IllegalStateException(""String_Node_Str"" + this + ""String_Node_Str""+ ""String_Node_Str"");
    }
    mChildFragmentManager.dispatchDestroy();
    mChildFragmentManager=null;
  }
}",0.7339642481598317
192403,"/** 
 * Called to do initial creation of a fragment.  This is called after  {@link #onAttach(Activity)} and before{@link #onCreateView(LayoutInflater,ViewGroup,Bundle)}, but is not called if the fragment instance is retained across Activity re-creation (see   {@link #setRetainInstance(boolean)}). <p>Note that this can be called while the fragment's activity is still in the process of being created.  As such, you can not rely on things like the activity's content view hierarchy being initialized at this point.  If you want to do work once the activity itself is created, see   {@link #onActivityCreated(Bundle)}. <p>If your app's <code>targetSdkVersion</code> is 23 or lower, child fragments being restored from the savedInstanceState are restored after <code>onCreate</code> returns. When targeting N or above and running on an N or newer platform version they are restored by <code>Fragment.onCreate</code>.</p>
 * @param savedInstanceState If the fragment is being re-created froma previous saved state, this is the state.
 */
public void onCreate(@Nullable Bundle savedInstanceState){
  mCalled=true;
  final Context context=getContext();
  final int version=context != null ? context.getApplicationInfo().targetSdkVersion : 0;
  if (version >= Build.VERSION_CODES.N) {
    if (savedInstanceState != null) {
      Parcelable p=savedInstanceState.getParcelable(Activity.FRAGMENTS_TAG);
      if (p != null) {
        if (mChildFragmentManager == null) {
          instantiateChildFragmentManager();
        }
        mChildFragmentManager.restoreAllState(p,mChildNonConfig);
        mChildNonConfig=null;
        mChildFragmentManager.dispatchCreate();
      }
    }
  }
}","/** 
 * Called to do initial creation of a fragment.  This is called after  {@link #onAttach(Activity)} and before{@link #onCreateView(LayoutInflater,ViewGroup,Bundle)}, but is not called if the fragment instance is retained across Activity re-creation (see   {@link #setRetainInstance(boolean)}). <p>Note that this can be called while the fragment's activity is still in the process of being created.  As such, you can not rely on things like the activity's content view hierarchy being initialized at this point.  If you want to do work once the activity itself is created, see   {@link #onActivityCreated(Bundle)}. <p>If your app's <code>targetSdkVersion</code> is 23 or lower, child fragments being restored from the savedInstanceState are restored after <code>onCreate</code> returns. When targeting N or above and running on an N or newer platform version they are restored by <code>Fragment.onCreate</code>.</p>
 * @param savedInstanceState If the fragment is being re-created froma previous saved state, this is the state.
 */
public void onCreate(@Nullable Bundle savedInstanceState){
  mCalled=true;
  final Context context=getContext();
  final int version=context != null ? context.getApplicationInfo().targetSdkVersion : 0;
  if (version >= Build.VERSION_CODES.N) {
    restoreChildFragmentState(savedInstanceState,true);
  }
}",0.8675496688741722
192404,"void performCreate(Bundle savedInstanceState){
  if (mChildFragmentManager != null) {
    mChildFragmentManager.noteStateNotSaved();
  }
  mState=CREATED;
  mCalled=false;
  onCreate(savedInstanceState);
  if (!mCalled) {
    throw new SuperNotCalledException(""String_Node_Str"" + this + ""String_Node_Str"");
  }
  final Context context=getContext();
  final int version=context != null ? context.getApplicationInfo().targetSdkVersion : 0;
  if (version < Build.VERSION_CODES.N) {
    if (savedInstanceState != null) {
      Parcelable p=savedInstanceState.getParcelable(Activity.FRAGMENTS_TAG);
      if (p != null) {
        if (mChildFragmentManager == null) {
          instantiateChildFragmentManager();
        }
        mChildFragmentManager.restoreAllState(p,null);
        mChildFragmentManager.dispatchCreate();
      }
    }
  }
}","void performCreate(Bundle savedInstanceState){
  if (mChildFragmentManager != null) {
    mChildFragmentManager.noteStateNotSaved();
  }
  mState=CREATED;
  mCalled=false;
  onCreate(savedInstanceState);
  if (!mCalled) {
    throw new SuperNotCalledException(""String_Node_Str"" + this + ""String_Node_Str"");
  }
  final Context context=getContext();
  final int version=context != null ? context.getApplicationInfo().targetSdkVersion : 0;
  if (version < Build.VERSION_CODES.N) {
    restoreChildFragmentState(savedInstanceState,false);
  }
}",0.7347826086956522
192405,"VectorDrawableAnimatorUI(AnimatedVectorDrawable drawable){
  mDrawable=drawable;
}","VectorDrawableAnimatorUI(@NonNull AnimatedVectorDrawable drawable){
  mDrawable=drawable;
}",0.9479768786127168
192406,"@Override public void init(AnimatorSet set){
  if (mInitialized) {
    throw new UnsupportedOperationException(""String_Node_Str"" + ""String_Node_Str"");
  }
  mShouldIgnoreInvalidAnim=shouldIgnoreInvalidAnimation();
  parseAnimatorSet(set,0);
  mInitialized=true;
  mIsReversible=true;
  if (mContainsSequentialAnimators) {
    mIsReversible=false;
  }
 else {
    for (int i=0; i < mStartDelays.size(); i++) {
      if (mStartDelays.get(i) > 0) {
        mIsReversible=false;
        return;
      }
    }
  }
}","@Override public void init(@NonNull AnimatorSet set){
  if (mInitialized) {
    throw new UnsupportedOperationException(""String_Node_Str"" + ""String_Node_Str"");
  }
  mShouldIgnoreInvalidAnim=shouldIgnoreInvalidAnimation();
  parseAnimatorSet(set,0);
  mInitialized=true;
  mIsReversible=true;
  if (mContainsSequentialAnimators) {
    mIsReversible=false;
  }
 else {
    for (int i=0; i < mStartDelays.size(); i++) {
      if (mStartDelays.get(i) > 0) {
        mIsReversible=false;
        return;
      }
    }
  }
}",0.9912536443148688
192407,"VectorDrawableAnimatorUI(AnimatedVectorDrawable drawable){
  mDrawable=drawable;
}","VectorDrawableAnimatorUI(@NonNull AnimatedVectorDrawable drawable){
  mDrawable=drawable;
}",0.9479768786127168
192408,"@Override public void init(AnimatorSet set){
  if (mInitialized) {
    throw new UnsupportedOperationException(""String_Node_Str"" + ""String_Node_Str"");
  }
  mShouldIgnoreInvalidAnim=shouldIgnoreInvalidAnimation();
  parseAnimatorSet(set,0);
  mInitialized=true;
  mIsReversible=true;
  if (mContainsSequentialAnimators) {
    mIsReversible=false;
  }
 else {
    for (int i=0; i < mStartDelays.size(); i++) {
      if (mStartDelays.get(i) > 0) {
        mIsReversible=false;
        return;
      }
    }
  }
}","@Override public void init(@NonNull AnimatorSet set){
  if (mInitialized) {
    throw new UnsupportedOperationException(""String_Node_Str"" + ""String_Node_Str"");
  }
  mShouldIgnoreInvalidAnim=shouldIgnoreInvalidAnimation();
  parseAnimatorSet(set,0);
  mInitialized=true;
  mIsReversible=true;
  if (mContainsSequentialAnimators) {
    mIsReversible=false;
  }
 else {
    for (int i=0; i < mStartDelays.size(); i++) {
      if (mStartDelays.get(i) > 0) {
        mIsReversible=false;
        return;
      }
    }
  }
}",0.9912536443148688
192409,"VectorDrawableAnimatorUI(AnimatedVectorDrawable drawable){
  mDrawable=drawable;
}","VectorDrawableAnimatorUI(@NonNull AnimatedVectorDrawable drawable){
  mDrawable=drawable;
}",0.9479768786127168
192410,"@Override public void init(AnimatorSet set){
  if (mInitialized) {
    throw new UnsupportedOperationException(""String_Node_Str"" + ""String_Node_Str"");
  }
  mShouldIgnoreInvalidAnim=shouldIgnoreInvalidAnimation();
  parseAnimatorSet(set,0);
  mInitialized=true;
  mIsReversible=true;
  if (mContainsSequentialAnimators) {
    mIsReversible=false;
  }
 else {
    for (int i=0; i < mStartDelays.size(); i++) {
      if (mStartDelays.get(i) > 0) {
        mIsReversible=false;
        return;
      }
    }
  }
}","@Override public void init(@NonNull AnimatorSet set){
  if (mInitialized) {
    throw new UnsupportedOperationException(""String_Node_Str"" + ""String_Node_Str"");
  }
  mShouldIgnoreInvalidAnim=shouldIgnoreInvalidAnimation();
  parseAnimatorSet(set,0);
  mInitialized=true;
  mIsReversible=true;
  if (mContainsSequentialAnimators) {
    mIsReversible=false;
  }
 else {
    for (int i=0; i < mStartDelays.size(); i++) {
      if (mStartDelays.get(i) > 0) {
        mIsReversible=false;
        return;
      }
    }
  }
}",0.9912536443148688
192411,"public void startAnimationToState(StackScrollState state,StackStateAnimator stateAnimator,long baseDelay,long duration){
  int childCount=mChildren.size();
  ViewState tmpState=new ViewState();
  float expandFraction=getChildExpandFraction();
  for (int i=childCount - 1; i >= 0; i--) {
    ExpandableNotificationRow child=mChildren.get(i);
    StackViewState viewState=state.getViewStateForView(child);
    stateAnimator.startStackAnimations(child,viewState,state,-1,baseDelay);
    View divider=mDividers.get(i);
    tmpState.initFrom(divider);
    tmpState.yTranslation=viewState.yTranslation - mDividerHeight;
    float alpha=mChildrenExpanded && viewState.alpha != 0 ? 0.5f : 0;
    if (mUserLocked && viewState.alpha != 0) {
      alpha=NotificationUtils.interpolate(0,0.5f,expandFraction);
    }
    tmpState.alpha=alpha;
    stateAnimator.startViewAnimations(divider,tmpState,baseDelay,duration);
  }
}","public void startAnimationToState(StackScrollState state,StackStateAnimator stateAnimator,long baseDelay,long duration){
  int childCount=mChildren.size();
  ViewState tmpState=new ViewState();
  float expandFraction=getChildExpandFraction();
  for (int i=childCount - 1; i >= 0; i--) {
    ExpandableNotificationRow child=mChildren.get(i);
    StackViewState viewState=state.getViewStateForView(child);
    stateAnimator.startStackAnimations(child,viewState,state,-1,baseDelay);
    View divider=mDividers.get(i);
    tmpState.initFrom(divider);
    tmpState.yTranslation=viewState.yTranslation - mDividerHeight;
    float alpha=mChildrenExpanded && viewState.alpha != 0 ? 0.5f : 0;
    if (mUserLocked && viewState.alpha != 0) {
      alpha=NotificationUtils.interpolate(0,0.5f,expandFraction);
    }
    tmpState.alpha=alpha;
    stateAnimator.startViewAnimations(divider,tmpState,baseDelay,duration);
    child.setFakeShadowIntensity(0.0f,0.0f,0,0);
  }
}",0.9737827715355806
192412,"public void applyState(StackScrollState state){
  int childCount=mChildren.size();
  ViewState tmpState=new ViewState();
  float expandFraction=getChildExpandFraction();
  for (int i=0; i < childCount; i++) {
    ExpandableNotificationRow child=mChildren.get(i);
    StackViewState viewState=state.getViewStateForView(child);
    state.applyState(child,viewState);
    View divider=mDividers.get(i);
    tmpState.initFrom(divider);
    tmpState.yTranslation=viewState.yTranslation - mDividerHeight;
    float alpha=mChildrenExpanded && viewState.alpha != 0 ? 0.5f : 0;
    if (mUserLocked && viewState.alpha != 0) {
      alpha=NotificationUtils.interpolate(0,0.5f,expandFraction);
    }
    tmpState.alpha=alpha;
    state.applyViewState(divider,tmpState);
  }
}","public void applyState(StackScrollState state){
  int childCount=mChildren.size();
  ViewState tmpState=new ViewState();
  float expandFraction=getChildExpandFraction();
  for (int i=0; i < childCount; i++) {
    ExpandableNotificationRow child=mChildren.get(i);
    StackViewState viewState=state.getViewStateForView(child);
    state.applyState(child,viewState);
    View divider=mDividers.get(i);
    tmpState.initFrom(divider);
    tmpState.yTranslation=viewState.yTranslation - mDividerHeight;
    float alpha=mChildrenExpanded && viewState.alpha != 0 ? 0.5f : 0;
    if (mUserLocked && viewState.alpha != 0) {
      alpha=NotificationUtils.interpolate(0,0.5f,expandFraction);
    }
    tmpState.alpha=alpha;
    state.applyViewState(divider,tmpState);
    child.setFakeShadowIntensity(0.0f,0.0f,0,0);
  }
}",0.9688888888888888
192413,"public void startAnimationToState(StackScrollState state,StackStateAnimator stateAnimator,long baseDelay,long duration){
  int childCount=mChildren.size();
  ViewState tmpState=new ViewState();
  float expandFraction=getChildExpandFraction();
  for (int i=childCount - 1; i >= 0; i--) {
    ExpandableNotificationRow child=mChildren.get(i);
    StackViewState viewState=state.getViewStateForView(child);
    stateAnimator.startStackAnimations(child,viewState,state,-1,baseDelay);
    View divider=mDividers.get(i);
    tmpState.initFrom(divider);
    tmpState.yTranslation=viewState.yTranslation - mDividerHeight;
    float alpha=mChildrenExpanded && viewState.alpha != 0 ? 0.5f : 0;
    if (mUserLocked && viewState.alpha != 0) {
      alpha=NotificationUtils.interpolate(0,0.5f,expandFraction);
    }
    tmpState.alpha=alpha;
    stateAnimator.startViewAnimations(divider,tmpState,baseDelay,duration);
  }
}","public void startAnimationToState(StackScrollState state,StackStateAnimator stateAnimator,long baseDelay,long duration){
  int childCount=mChildren.size();
  ViewState tmpState=new ViewState();
  float expandFraction=getChildExpandFraction();
  for (int i=childCount - 1; i >= 0; i--) {
    ExpandableNotificationRow child=mChildren.get(i);
    StackViewState viewState=state.getViewStateForView(child);
    stateAnimator.startStackAnimations(child,viewState,state,-1,baseDelay);
    View divider=mDividers.get(i);
    tmpState.initFrom(divider);
    tmpState.yTranslation=viewState.yTranslation - mDividerHeight;
    float alpha=mChildrenExpanded && viewState.alpha != 0 ? 0.5f : 0;
    if (mUserLocked && viewState.alpha != 0) {
      alpha=NotificationUtils.interpolate(0,0.5f,expandFraction);
    }
    tmpState.alpha=alpha;
    stateAnimator.startViewAnimations(divider,tmpState,baseDelay,duration);
    child.setFakeShadowIntensity(0.0f,0.0f,0,0);
  }
}",0.9737827715355806
192414,"public void applyState(StackScrollState state){
  int childCount=mChildren.size();
  ViewState tmpState=new ViewState();
  float expandFraction=getChildExpandFraction();
  for (int i=0; i < childCount; i++) {
    ExpandableNotificationRow child=mChildren.get(i);
    StackViewState viewState=state.getViewStateForView(child);
    state.applyState(child,viewState);
    View divider=mDividers.get(i);
    tmpState.initFrom(divider);
    tmpState.yTranslation=viewState.yTranslation - mDividerHeight;
    float alpha=mChildrenExpanded && viewState.alpha != 0 ? 0.5f : 0;
    if (mUserLocked && viewState.alpha != 0) {
      alpha=NotificationUtils.interpolate(0,0.5f,expandFraction);
    }
    tmpState.alpha=alpha;
    state.applyViewState(divider,tmpState);
  }
}","public void applyState(StackScrollState state){
  int childCount=mChildren.size();
  ViewState tmpState=new ViewState();
  float expandFraction=getChildExpandFraction();
  for (int i=0; i < childCount; i++) {
    ExpandableNotificationRow child=mChildren.get(i);
    StackViewState viewState=state.getViewStateForView(child);
    state.applyState(child,viewState);
    View divider=mDividers.get(i);
    tmpState.initFrom(divider);
    tmpState.yTranslation=viewState.yTranslation - mDividerHeight;
    float alpha=mChildrenExpanded && viewState.alpha != 0 ? 0.5f : 0;
    if (mUserLocked && viewState.alpha != 0) {
      alpha=NotificationUtils.interpolate(0,0.5f,expandFraction);
    }
    tmpState.alpha=alpha;
    state.applyViewState(divider,tmpState);
    child.setFakeShadowIntensity(0.0f,0.0f,0,0);
  }
}",0.9688888888888888
192415,"/** 
 * Schedule an idle-until alarm, which will keep the alarm manager idle until the given time.
 * @hide
 */
public void setIdleUntil(int type,long triggerAtMillis,PendingIntent operation){
  setImpl(type,triggerAtMillis,WINDOW_EXACT,0,FLAG_IDLE_UNTIL,operation,null,null,null,null,null);
}","/** 
 * Schedule an idle-until alarm, which will keep the alarm manager idle until the given time.
 * @hide
 */
public void setIdleUntil(int type,long triggerAtMillis,String tag,OnAlarmListener listener,Handler targetHandler){
  setImpl(type,triggerAtMillis,WINDOW_EXACT,0,FLAG_IDLE_UNTIL,null,listener,tag,targetHandler,null,null);
}",0.784688995215311
192416,"@Override public long getDeviceIdlingTime(int mode,long elapsedRealtimeUs,int which){
switch (mode) {
case DEVICE_IDLE_MODE_LIGHT:
    return mDeviceLightIdlingTimer.getTotalTimeLocked(elapsedRealtimeUs,which);
case DEVICE_IDLE_MODE_FULL:
  return mDeviceIdlingTimer.getTotalTimeLocked(elapsedRealtimeUs,which);
}
return 0;
}","@Override public long getDeviceIdlingTime(int mode,long elapsedRealtimeUs,int which){
switch (mode) {
case DEVICE_IDLE_MODE_LIGHT:
    return mDeviceLightIdlingTimer.getTotalTimeLocked(elapsedRealtimeUs,which);
case DEVICE_IDLE_MODE_DEEP:
  return mDeviceIdlingTimer.getTotalTimeLocked(elapsedRealtimeUs,which);
}
return 0;
}",0.9876923076923076
192417,"@Override public int getDeviceIdleModeCount(int mode,int which){
switch (mode) {
case DEVICE_IDLE_MODE_LIGHT:
    return mDeviceIdleModeLightTimer.getCountLocked(which);
case DEVICE_IDLE_MODE_FULL:
  return mDeviceIdleModeFullTimer.getCountLocked(which);
}
return 0;
}","@Override public int getDeviceIdleModeCount(int mode,int which){
switch (mode) {
case DEVICE_IDLE_MODE_LIGHT:
    return mDeviceIdleModeLightTimer.getCountLocked(which);
case DEVICE_IDLE_MODE_DEEP:
  return mDeviceIdleModeFullTimer.getCountLocked(which);
}
return 0;
}",0.9850746268656716
192418,"@Override public int getDeviceIdlingCount(int mode,int which){
switch (mode) {
case DEVICE_IDLE_MODE_LIGHT:
    return mDeviceLightIdlingTimer.getCountLocked(which);
case DEVICE_IDLE_MODE_FULL:
  return mDeviceIdlingTimer.getCountLocked(which);
}
return 0;
}","@Override public int getDeviceIdlingCount(int mode,int which){
switch (mode) {
case DEVICE_IDLE_MODE_LIGHT:
    return mDeviceLightIdlingTimer.getCountLocked(which);
case DEVICE_IDLE_MODE_DEEP:
  return mDeviceIdlingTimer.getCountLocked(which);
}
return 0;
}",0.9844961240310076
192419,"@Override public long getDeviceIdleModeTime(int mode,long elapsedRealtimeUs,int which){
switch (mode) {
case DEVICE_IDLE_MODE_LIGHT:
    return mDeviceIdleModeLightTimer.getTotalTimeLocked(elapsedRealtimeUs,which);
case DEVICE_IDLE_MODE_FULL:
  return mDeviceIdleModeFullTimer.getTotalTimeLocked(elapsedRealtimeUs,which);
}
return 0;
}","@Override public long getDeviceIdleModeTime(int mode,long elapsedRealtimeUs,int which){
switch (mode) {
case DEVICE_IDLE_MODE_LIGHT:
    return mDeviceIdleModeLightTimer.getTotalTimeLocked(elapsedRealtimeUs,which);
case DEVICE_IDLE_MODE_DEEP:
  return mDeviceIdleModeFullTimer.getTotalTimeLocked(elapsedRealtimeUs,which);
}
return 0;
}",0.9880597014925372
192420,"@Override public long getLongestDeviceIdleModeTime(int mode){
switch (mode) {
case DEVICE_IDLE_MODE_LIGHT:
    return mLongestLightIdleTime;
case DEVICE_IDLE_MODE_FULL:
  return mLongestFullIdleTime;
}
return 0;
}","@Override public long getLongestDeviceIdleModeTime(int mode){
switch (mode) {
case DEVICE_IDLE_MODE_LIGHT:
    return mLongestLightIdleTime;
case DEVICE_IDLE_MODE_DEEP:
  return mLongestFullIdleTime;
}
return 0;
}",0.9812206572769951
192421,"public void noteDeviceIdleModeLocked(int mode,String activeReason,int activeUid){
  final long elapsedRealtime=mClocks.elapsedRealtime();
  final long uptime=mClocks.uptimeMillis();
  boolean nowIdling=mode == DEVICE_IDLE_MODE_FULL;
  if (mDeviceIdling && !nowIdling && activeReason == null) {
    nowIdling=true;
  }
  boolean nowLightIdling=mode == DEVICE_IDLE_MODE_LIGHT;
  if (mDeviceLightIdling && !nowLightIdling && !nowIdling&& activeReason == null) {
    nowLightIdling=true;
  }
  if (activeReason != null && (mDeviceIdling || mDeviceLightIdling)) {
    addHistoryEventLocked(elapsedRealtime,uptime,HistoryItem.EVENT_ACTIVE,activeReason,activeUid);
  }
  if (mDeviceIdling != nowIdling) {
    mDeviceIdling=nowIdling;
    int stepState=nowIdling ? STEP_LEVEL_MODE_DEVICE_IDLE : 0;
    mModStepMode|=(mCurStepMode & STEP_LEVEL_MODE_DEVICE_IDLE) ^ stepState;
    mCurStepMode=(mCurStepMode & ~STEP_LEVEL_MODE_DEVICE_IDLE) | stepState;
    if (nowIdling) {
      mDeviceIdlingTimer.startRunningLocked(elapsedRealtime);
    }
 else {
      mDeviceIdlingTimer.stopRunningLocked(elapsedRealtime);
    }
  }
  if (mDeviceLightIdling != nowLightIdling) {
    mDeviceLightIdling=nowLightIdling;
    if (nowLightIdling) {
      mDeviceLightIdlingTimer.startRunningLocked(elapsedRealtime);
    }
 else {
      mDeviceLightIdlingTimer.stopRunningLocked(elapsedRealtime);
    }
  }
  if (mDeviceIdleMode != mode) {
    mHistoryCur.states2=(mHistoryCur.states2 & ~HistoryItem.STATE2_DEVICE_IDLE_MASK) | (mode << HistoryItem.STATE2_DEVICE_IDLE_SHIFT);
    if (DEBUG_HISTORY)     Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(mHistoryCur.states2));
    addHistoryRecordLocked(elapsedRealtime,uptime);
    long lastDuration=elapsedRealtime - mLastIdleTimeStart;
    mLastIdleTimeStart=elapsedRealtime;
    if (mDeviceIdleMode == DEVICE_IDLE_MODE_LIGHT) {
      if (lastDuration > mLongestLightIdleTime) {
        mLongestLightIdleTime=lastDuration;
      }
      mDeviceIdleModeLightTimer.stopRunningLocked(elapsedRealtime);
    }
 else     if (mDeviceIdleMode == DEVICE_IDLE_MODE_FULL) {
      if (lastDuration > mLongestFullIdleTime) {
        mLongestFullIdleTime=lastDuration;
      }
      mDeviceIdleModeFullTimer.stopRunningLocked(elapsedRealtime);
    }
    if (mode == DEVICE_IDLE_MODE_LIGHT) {
      mDeviceIdleModeLightTimer.startRunningLocked(elapsedRealtime);
    }
 else     if (mode == DEVICE_IDLE_MODE_FULL) {
      mDeviceIdleModeFullTimer.startRunningLocked(elapsedRealtime);
    }
    mDeviceIdleMode=mode;
  }
}","public void noteDeviceIdleModeLocked(int mode,String activeReason,int activeUid){
  final long elapsedRealtime=mClocks.elapsedRealtime();
  final long uptime=mClocks.uptimeMillis();
  boolean nowIdling=mode == DEVICE_IDLE_MODE_DEEP;
  if (mDeviceIdling && !nowIdling && activeReason == null) {
    nowIdling=true;
  }
  boolean nowLightIdling=mode == DEVICE_IDLE_MODE_LIGHT;
  if (mDeviceLightIdling && !nowLightIdling && !nowIdling&& activeReason == null) {
    nowLightIdling=true;
  }
  if (activeReason != null && (mDeviceIdling || mDeviceLightIdling)) {
    addHistoryEventLocked(elapsedRealtime,uptime,HistoryItem.EVENT_ACTIVE,activeReason,activeUid);
  }
  if (mDeviceIdling != nowIdling) {
    mDeviceIdling=nowIdling;
    int stepState=nowIdling ? STEP_LEVEL_MODE_DEVICE_IDLE : 0;
    mModStepMode|=(mCurStepMode & STEP_LEVEL_MODE_DEVICE_IDLE) ^ stepState;
    mCurStepMode=(mCurStepMode & ~STEP_LEVEL_MODE_DEVICE_IDLE) | stepState;
    if (nowIdling) {
      mDeviceIdlingTimer.startRunningLocked(elapsedRealtime);
    }
 else {
      mDeviceIdlingTimer.stopRunningLocked(elapsedRealtime);
    }
  }
  if (mDeviceLightIdling != nowLightIdling) {
    mDeviceLightIdling=nowLightIdling;
    if (nowLightIdling) {
      mDeviceLightIdlingTimer.startRunningLocked(elapsedRealtime);
    }
 else {
      mDeviceLightIdlingTimer.stopRunningLocked(elapsedRealtime);
    }
  }
  if (mDeviceIdleMode != mode) {
    mHistoryCur.states2=(mHistoryCur.states2 & ~HistoryItem.STATE2_DEVICE_IDLE_MASK) | (mode << HistoryItem.STATE2_DEVICE_IDLE_SHIFT);
    if (DEBUG_HISTORY)     Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(mHistoryCur.states2));
    addHistoryRecordLocked(elapsedRealtime,uptime);
    long lastDuration=elapsedRealtime - mLastIdleTimeStart;
    mLastIdleTimeStart=elapsedRealtime;
    if (mDeviceIdleMode == DEVICE_IDLE_MODE_LIGHT) {
      if (lastDuration > mLongestLightIdleTime) {
        mLongestLightIdleTime=lastDuration;
      }
      mDeviceIdleModeLightTimer.stopRunningLocked(elapsedRealtime);
    }
 else     if (mDeviceIdleMode == DEVICE_IDLE_MODE_DEEP) {
      if (lastDuration > mLongestFullIdleTime) {
        mLongestFullIdleTime=lastDuration;
      }
      mDeviceIdleModeFullTimer.stopRunningLocked(elapsedRealtime);
    }
    if (mode == DEVICE_IDLE_MODE_LIGHT) {
      mDeviceIdleModeLightTimer.startRunningLocked(elapsedRealtime);
    }
 else     if (mode == DEVICE_IDLE_MODE_DEEP) {
      mDeviceIdleModeFullTimer.startRunningLocked(elapsedRealtime);
    }
    mDeviceIdleMode=mode;
  }
}",0.9620253164556962
192422,"@Override public String toString(){
  StringBuilder sb=new StringBuilder(128);
  sb.append(""String_Node_Str"");
  sb.append(Integer.toHexString(System.identityHashCode(this)));
  sb.append(""String_Node_Str"");
  sb.append(type);
  sb.append(""String_Node_Str"");
  sb.append(when);
  sb.append(""String_Node_Str"");
  if (operation != null) {
    sb.append(operation.getTargetPackage());
  }
 else {
    sb.append(listener.asBinder().toString());
  }
  sb.append('}');
  return sb.toString();
}","@Override public String toString(){
  StringBuilder sb=new StringBuilder(128);
  sb.append(""String_Node_Str"");
  sb.append(Integer.toHexString(System.identityHashCode(this)));
  sb.append(""String_Node_Str"");
  sb.append(type);
  sb.append(""String_Node_Str"");
  sb.append(when);
  sb.append(""String_Node_Str"");
  if (operation != null) {
    sb.append(operation.getTargetPackage());
  }
 else {
    sb.append(packageName);
  }
  sb.append('}');
  return sb.toString();
}",0.9571577847439916
192423,"/** 
 * Schedule an idle-until alarm, which will keep the alarm manager idle until the given time.
 * @hide
 */
public void setIdleUntil(int type,long triggerAtMillis,PendingIntent operation){
  setImpl(type,triggerAtMillis,WINDOW_EXACT,0,FLAG_IDLE_UNTIL,operation,null,null,null,null,null);
}","/** 
 * Schedule an idle-until alarm, which will keep the alarm manager idle until the given time.
 * @hide
 */
public void setIdleUntil(int type,long triggerAtMillis,String tag,OnAlarmListener listener,Handler targetHandler){
  setImpl(type,triggerAtMillis,WINDOW_EXACT,0,FLAG_IDLE_UNTIL,null,listener,tag,targetHandler,null,null);
}",0.784688995215311
192424,"@Override public long getDeviceIdlingTime(int mode,long elapsedRealtimeUs,int which){
switch (mode) {
case DEVICE_IDLE_MODE_LIGHT:
    return mDeviceLightIdlingTimer.getTotalTimeLocked(elapsedRealtimeUs,which);
case DEVICE_IDLE_MODE_FULL:
  return mDeviceIdlingTimer.getTotalTimeLocked(elapsedRealtimeUs,which);
}
return 0;
}","@Override public long getDeviceIdlingTime(int mode,long elapsedRealtimeUs,int which){
switch (mode) {
case DEVICE_IDLE_MODE_LIGHT:
    return mDeviceLightIdlingTimer.getTotalTimeLocked(elapsedRealtimeUs,which);
case DEVICE_IDLE_MODE_DEEP:
  return mDeviceIdlingTimer.getTotalTimeLocked(elapsedRealtimeUs,which);
}
return 0;
}",0.9876923076923076
192425,"@Override public int getDeviceIdleModeCount(int mode,int which){
switch (mode) {
case DEVICE_IDLE_MODE_LIGHT:
    return mDeviceIdleModeLightTimer.getCountLocked(which);
case DEVICE_IDLE_MODE_FULL:
  return mDeviceIdleModeFullTimer.getCountLocked(which);
}
return 0;
}","@Override public int getDeviceIdleModeCount(int mode,int which){
switch (mode) {
case DEVICE_IDLE_MODE_LIGHT:
    return mDeviceIdleModeLightTimer.getCountLocked(which);
case DEVICE_IDLE_MODE_DEEP:
  return mDeviceIdleModeFullTimer.getCountLocked(which);
}
return 0;
}",0.9850746268656716
192426,"@Override public int getDeviceIdlingCount(int mode,int which){
switch (mode) {
case DEVICE_IDLE_MODE_LIGHT:
    return mDeviceLightIdlingTimer.getCountLocked(which);
case DEVICE_IDLE_MODE_FULL:
  return mDeviceIdlingTimer.getCountLocked(which);
}
return 0;
}","@Override public int getDeviceIdlingCount(int mode,int which){
switch (mode) {
case DEVICE_IDLE_MODE_LIGHT:
    return mDeviceLightIdlingTimer.getCountLocked(which);
case DEVICE_IDLE_MODE_DEEP:
  return mDeviceIdlingTimer.getCountLocked(which);
}
return 0;
}",0.9844961240310076
192427,"@Override public long getDeviceIdleModeTime(int mode,long elapsedRealtimeUs,int which){
switch (mode) {
case DEVICE_IDLE_MODE_LIGHT:
    return mDeviceIdleModeLightTimer.getTotalTimeLocked(elapsedRealtimeUs,which);
case DEVICE_IDLE_MODE_FULL:
  return mDeviceIdleModeFullTimer.getTotalTimeLocked(elapsedRealtimeUs,which);
}
return 0;
}","@Override public long getDeviceIdleModeTime(int mode,long elapsedRealtimeUs,int which){
switch (mode) {
case DEVICE_IDLE_MODE_LIGHT:
    return mDeviceIdleModeLightTimer.getTotalTimeLocked(elapsedRealtimeUs,which);
case DEVICE_IDLE_MODE_DEEP:
  return mDeviceIdleModeFullTimer.getTotalTimeLocked(elapsedRealtimeUs,which);
}
return 0;
}",0.9880597014925372
192428,"@Override public long getLongestDeviceIdleModeTime(int mode){
switch (mode) {
case DEVICE_IDLE_MODE_LIGHT:
    return mLongestLightIdleTime;
case DEVICE_IDLE_MODE_FULL:
  return mLongestFullIdleTime;
}
return 0;
}","@Override public long getLongestDeviceIdleModeTime(int mode){
switch (mode) {
case DEVICE_IDLE_MODE_LIGHT:
    return mLongestLightIdleTime;
case DEVICE_IDLE_MODE_DEEP:
  return mLongestFullIdleTime;
}
return 0;
}",0.9812206572769951
192429,"public void noteDeviceIdleModeLocked(int mode,String activeReason,int activeUid){
  final long elapsedRealtime=mClocks.elapsedRealtime();
  final long uptime=mClocks.uptimeMillis();
  boolean nowIdling=mode == DEVICE_IDLE_MODE_FULL;
  if (mDeviceIdling && !nowIdling && activeReason == null) {
    nowIdling=true;
  }
  boolean nowLightIdling=mode == DEVICE_IDLE_MODE_LIGHT;
  if (mDeviceLightIdling && !nowLightIdling && !nowIdling&& activeReason == null) {
    nowLightIdling=true;
  }
  if (activeReason != null && (mDeviceIdling || mDeviceLightIdling)) {
    addHistoryEventLocked(elapsedRealtime,uptime,HistoryItem.EVENT_ACTIVE,activeReason,activeUid);
  }
  if (mDeviceIdling != nowIdling) {
    mDeviceIdling=nowIdling;
    int stepState=nowIdling ? STEP_LEVEL_MODE_DEVICE_IDLE : 0;
    mModStepMode|=(mCurStepMode & STEP_LEVEL_MODE_DEVICE_IDLE) ^ stepState;
    mCurStepMode=(mCurStepMode & ~STEP_LEVEL_MODE_DEVICE_IDLE) | stepState;
    if (nowIdling) {
      mDeviceIdlingTimer.startRunningLocked(elapsedRealtime);
    }
 else {
      mDeviceIdlingTimer.stopRunningLocked(elapsedRealtime);
    }
  }
  if (mDeviceLightIdling != nowLightIdling) {
    mDeviceLightIdling=nowLightIdling;
    if (nowLightIdling) {
      mDeviceLightIdlingTimer.startRunningLocked(elapsedRealtime);
    }
 else {
      mDeviceLightIdlingTimer.stopRunningLocked(elapsedRealtime);
    }
  }
  if (mDeviceIdleMode != mode) {
    mHistoryCur.states2=(mHistoryCur.states2 & ~HistoryItem.STATE2_DEVICE_IDLE_MASK) | (mode << HistoryItem.STATE2_DEVICE_IDLE_SHIFT);
    if (DEBUG_HISTORY)     Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(mHistoryCur.states2));
    addHistoryRecordLocked(elapsedRealtime,uptime);
    long lastDuration=elapsedRealtime - mLastIdleTimeStart;
    mLastIdleTimeStart=elapsedRealtime;
    if (mDeviceIdleMode == DEVICE_IDLE_MODE_LIGHT) {
      if (lastDuration > mLongestLightIdleTime) {
        mLongestLightIdleTime=lastDuration;
      }
      mDeviceIdleModeLightTimer.stopRunningLocked(elapsedRealtime);
    }
 else     if (mDeviceIdleMode == DEVICE_IDLE_MODE_FULL) {
      if (lastDuration > mLongestFullIdleTime) {
        mLongestFullIdleTime=lastDuration;
      }
      mDeviceIdleModeFullTimer.stopRunningLocked(elapsedRealtime);
    }
    if (mode == DEVICE_IDLE_MODE_LIGHT) {
      mDeviceIdleModeLightTimer.startRunningLocked(elapsedRealtime);
    }
 else     if (mode == DEVICE_IDLE_MODE_FULL) {
      mDeviceIdleModeFullTimer.startRunningLocked(elapsedRealtime);
    }
    mDeviceIdleMode=mode;
  }
}","public void noteDeviceIdleModeLocked(int mode,String activeReason,int activeUid){
  final long elapsedRealtime=mClocks.elapsedRealtime();
  final long uptime=mClocks.uptimeMillis();
  boolean nowIdling=mode == DEVICE_IDLE_MODE_DEEP;
  if (mDeviceIdling && !nowIdling && activeReason == null) {
    nowIdling=true;
  }
  boolean nowLightIdling=mode == DEVICE_IDLE_MODE_LIGHT;
  if (mDeviceLightIdling && !nowLightIdling && !nowIdling&& activeReason == null) {
    nowLightIdling=true;
  }
  if (activeReason != null && (mDeviceIdling || mDeviceLightIdling)) {
    addHistoryEventLocked(elapsedRealtime,uptime,HistoryItem.EVENT_ACTIVE,activeReason,activeUid);
  }
  if (mDeviceIdling != nowIdling) {
    mDeviceIdling=nowIdling;
    int stepState=nowIdling ? STEP_LEVEL_MODE_DEVICE_IDLE : 0;
    mModStepMode|=(mCurStepMode & STEP_LEVEL_MODE_DEVICE_IDLE) ^ stepState;
    mCurStepMode=(mCurStepMode & ~STEP_LEVEL_MODE_DEVICE_IDLE) | stepState;
    if (nowIdling) {
      mDeviceIdlingTimer.startRunningLocked(elapsedRealtime);
    }
 else {
      mDeviceIdlingTimer.stopRunningLocked(elapsedRealtime);
    }
  }
  if (mDeviceLightIdling != nowLightIdling) {
    mDeviceLightIdling=nowLightIdling;
    if (nowLightIdling) {
      mDeviceLightIdlingTimer.startRunningLocked(elapsedRealtime);
    }
 else {
      mDeviceLightIdlingTimer.stopRunningLocked(elapsedRealtime);
    }
  }
  if (mDeviceIdleMode != mode) {
    mHistoryCur.states2=(mHistoryCur.states2 & ~HistoryItem.STATE2_DEVICE_IDLE_MASK) | (mode << HistoryItem.STATE2_DEVICE_IDLE_SHIFT);
    if (DEBUG_HISTORY)     Slog.v(TAG,""String_Node_Str"" + Integer.toHexString(mHistoryCur.states2));
    addHistoryRecordLocked(elapsedRealtime,uptime);
    long lastDuration=elapsedRealtime - mLastIdleTimeStart;
    mLastIdleTimeStart=elapsedRealtime;
    if (mDeviceIdleMode == DEVICE_IDLE_MODE_LIGHT) {
      if (lastDuration > mLongestLightIdleTime) {
        mLongestLightIdleTime=lastDuration;
      }
      mDeviceIdleModeLightTimer.stopRunningLocked(elapsedRealtime);
    }
 else     if (mDeviceIdleMode == DEVICE_IDLE_MODE_DEEP) {
      if (lastDuration > mLongestFullIdleTime) {
        mLongestFullIdleTime=lastDuration;
      }
      mDeviceIdleModeFullTimer.stopRunningLocked(elapsedRealtime);
    }
    if (mode == DEVICE_IDLE_MODE_LIGHT) {
      mDeviceIdleModeLightTimer.startRunningLocked(elapsedRealtime);
    }
 else     if (mode == DEVICE_IDLE_MODE_DEEP) {
      mDeviceIdleModeFullTimer.startRunningLocked(elapsedRealtime);
    }
    mDeviceIdleMode=mode;
  }
}",0.9620253164556962
192430,"@Override public String toString(){
  StringBuilder sb=new StringBuilder(128);
  sb.append(""String_Node_Str"");
  sb.append(Integer.toHexString(System.identityHashCode(this)));
  sb.append(""String_Node_Str"");
  sb.append(type);
  sb.append(""String_Node_Str"");
  sb.append(when);
  sb.append(""String_Node_Str"");
  if (operation != null) {
    sb.append(operation.getTargetPackage());
  }
 else {
    sb.append(listener.asBinder().toString());
  }
  sb.append('}');
  return sb.toString();
}","@Override public String toString(){
  StringBuilder sb=new StringBuilder(128);
  sb.append(""String_Node_Str"");
  sb.append(Integer.toHexString(System.identityHashCode(this)));
  sb.append(""String_Node_Str"");
  sb.append(type);
  sb.append(""String_Node_Str"");
  sb.append(when);
  sb.append(""String_Node_Str"");
  if (operation != null) {
    sb.append(operation.getTargetPackage());
  }
 else {
    sb.append(packageName);
  }
  sb.append('}');
  return sb.toString();
}",0.9571577847439916
192431,"@Override public GnssNavigationMessage createFromParcel(Parcel parcel){
  GnssNavigationMessage navigationMessage=new GnssNavigationMessage();
  navigationMessage.setType(parcel.readInt());
  navigationMessage.setSvid(parcel.readInt());
  navigationMessage.setMessageId(parcel.readInt());
  navigationMessage.setSubmessageId(parcel.readInt());
  int dataLength=parcel.readInt();
  byte[] data=new byte[dataLength];
  parcel.readByteArray(data);
  navigationMessage.setData(data);
  if (parcel.dataAvail() >= Integer.SIZE) {
    int status=parcel.readInt();
    navigationMessage.setStatus(status);
  }
 else {
    navigationMessage.setStatus(STATUS_UNKNOWN);
  }
  return navigationMessage;
}","@Override public GnssNavigationMessage createFromParcel(Parcel parcel){
  GnssNavigationMessage navigationMessage=new GnssNavigationMessage();
  navigationMessage.setType(parcel.readInt());
  navigationMessage.setSvid(parcel.readInt());
  navigationMessage.setMessageId(parcel.readInt());
  navigationMessage.setSubmessageId(parcel.readInt());
  int dataLength=parcel.readInt();
  byte[] data=new byte[dataLength];
  parcel.readByteArray(data);
  navigationMessage.setData(data);
  navigationMessage.setStatus(parcel.readInt());
  return navigationMessage;
}",0.7856
192432,"@Override public GnssNavigationMessage createFromParcel(Parcel parcel){
  GnssNavigationMessage navigationMessage=new GnssNavigationMessage();
  navigationMessage.setType(parcel.readInt());
  navigationMessage.setSvid(parcel.readInt());
  navigationMessage.setMessageId(parcel.readInt());
  navigationMessage.setSubmessageId(parcel.readInt());
  int dataLength=parcel.readInt();
  byte[] data=new byte[dataLength];
  parcel.readByteArray(data);
  navigationMessage.setData(data);
  if (parcel.dataAvail() >= Integer.SIZE) {
    int status=parcel.readInt();
    navigationMessage.setStatus(status);
  }
 else {
    navigationMessage.setStatus(STATUS_UNKNOWN);
  }
  return navigationMessage;
}","@Override public GnssNavigationMessage createFromParcel(Parcel parcel){
  GnssNavigationMessage navigationMessage=new GnssNavigationMessage();
  navigationMessage.setType(parcel.readInt());
  navigationMessage.setSvid(parcel.readInt());
  navigationMessage.setMessageId(parcel.readInt());
  navigationMessage.setSubmessageId(parcel.readInt());
  int dataLength=parcel.readInt();
  byte[] data=new byte[dataLength];
  parcel.readByteArray(data);
  navigationMessage.setData(data);
  navigationMessage.setStatus(parcel.readInt());
  return navigationMessage;
}",0.7856
192433,"@Override public GnssNavigationMessage createFromParcel(Parcel parcel){
  GnssNavigationMessage navigationMessage=new GnssNavigationMessage();
  navigationMessage.setType(parcel.readInt());
  navigationMessage.setSvid(parcel.readInt());
  navigationMessage.setMessageId(parcel.readInt());
  navigationMessage.setSubmessageId(parcel.readInt());
  int dataLength=parcel.readInt();
  byte[] data=new byte[dataLength];
  parcel.readByteArray(data);
  navigationMessage.setData(data);
  if (parcel.dataAvail() >= Integer.SIZE) {
    int status=parcel.readInt();
    navigationMessage.setStatus(status);
  }
 else {
    navigationMessage.setStatus(STATUS_UNKNOWN);
  }
  return navigationMessage;
}","@Override public GnssNavigationMessage createFromParcel(Parcel parcel){
  GnssNavigationMessage navigationMessage=new GnssNavigationMessage();
  navigationMessage.setType(parcel.readInt());
  navigationMessage.setSvid(parcel.readInt());
  navigationMessage.setMessageId(parcel.readInt());
  navigationMessage.setSubmessageId(parcel.readInt());
  int dataLength=parcel.readInt();
  byte[] data=new byte[dataLength];
  parcel.readByteArray(data);
  navigationMessage.setData(data);
  navigationMessage.setStatus(parcel.readInt());
  return navigationMessage;
}",0.7856
192434,"/** 
 * Updates the limits lists and column map with the given item metadata.
 * @param absoluteChildRect The absolute rectangle for the child view being processed.
 * @param adapterPosition The position of the child view being processed.
 */
private void recordItemData(Rect absoluteChildRect,int adapterPosition){
  if (mColumnBounds.size() != mHelper.getColumnCount()) {
    recordLimits(mColumnBounds,new Limits(absoluteChildRect.left,absoluteChildRect.right));
  }
  if (mRowBounds.size() != mHelper.getRowCount()) {
    recordLimits(mRowBounds,new Limits(absoluteChildRect.top,absoluteChildRect.bottom));
  }
  SparseIntArray columnList=mColumns.get(absoluteChildRect.left);
  if (columnList == null) {
    columnList=new SparseIntArray();
    mColumns.put(absoluteChildRect.left,columnList);
  }
  columnList.put(absoluteChildRect.top,adapterPosition);
}","/** 
 * Updates the limits lists and column map with the given item metadata.
 * @param absoluteChildRect The absolute rectangle for the child view being processed.
 * @param adapterPosition The position of the child view being processed.
 */
private void recordItemData(Rect absoluteChildRect,int adapterPosition){
  if (mColumnBounds.size() != mHelper.getColumnCount()) {
    recordLimits(mColumnBounds,new Limits(absoluteChildRect.left,absoluteChildRect.right));
  }
  recordLimits(mRowBounds,new Limits(absoluteChildRect.top,absoluteChildRect.bottom));
  SparseIntArray columnList=mColumns.get(absoluteChildRect.left);
  if (columnList == null) {
    columnList=new SparseIntArray();
    mColumns.put(absoluteChildRect.left,columnList);
  }
  columnList.put(absoluteChildRect.top,adapterPosition);
}",0.9206730769230768
192435,"@Override public Selection createFromParcel(Parcel in,ClassLoader loader){
  return new Selection(in.readString(),(ArrayList<String>)in.readArrayList(loader));
}","@Override public Selection createFromParcel(Parcel in,ClassLoader loader){
  return new Selection(in.readString(),in.readArrayList(loader));
}",0.9372937293729372
192436,"@Override public String toString(){
  if (size() <= 0) {
    return ""String_Node_Str"";
  }
  StringBuilder buffer=new StringBuilder(size() * 28);
  buffer.append(""String_Node_Str"").append(""String_Node_Str"" + mSelection.size()).append(""String_Node_Str"" + mSelection).append(""String_Node_Str"" + mProvisionalSelection.size()).append(""String_Node_Str"" + mProvisionalSelection).append(""String_Node_Str"");
  return buffer.toString();
}","@Override public String toString(){
  return ""String_Node_Str"" + lowerLimit + ""String_Node_Str""+ upperLimit+ ""String_Node_Str"";
}",0.3906810035842294
192437,"/** 
 * Processes a MotionEvent by starting, ending, or resizing the band select overlay.
 * @param input
 */
private void processInputEvent(InputEvent input){
  assert(input.isMouseEvent());
  if (shouldStop(input)) {
    endBandSelect();
    return;
  }
  if (!isActive()) {
    return;
  }
  mCurrentPosition=input.getOrigin();
  scrollViewIfNecessary();
  resizeBandSelectRectangle();
}","/** 
 * Processes a MotionEvent by starting, ending, or resizing the band select overlay.
 * @param input
 */
private void processInputEvent(InputEvent input){
  assert(input.isMouseEvent());
  if (shouldStop(input)) {
    endBandSelect();
    return;
  }
  if (!isActive()) {
    return;
  }
  mCurrentPosition=input.getOrigin();
  mModel.resizeSelection(input.getOrigin());
  scrollViewIfNecessary();
  resizeBandSelectRectangle();
}",0.9454545454545454
192438,"/** 
 * @return a LongSamplingCounter, measuring time spent in the idle state inmilliseconds.
 */
@Override public LongSamplingCounter getIdleTimeCounter(){
  return mRxTimeMillis;
}","/** 
 * @return a LongSamplingCounter, measuring time spent in the idle state inmilliseconds.
 */
@Override public LongSamplingCounter getIdleTimeCounter(){
  return mIdleTimeMillis;
}",0.9836065573770492
192439,"/** 
 * Updates the limits lists and column map with the given item metadata.
 * @param absoluteChildRect The absolute rectangle for the child view being processed.
 * @param adapterPosition The position of the child view being processed.
 */
private void recordItemData(Rect absoluteChildRect,int adapterPosition){
  if (mColumnBounds.size() != mHelper.getColumnCount()) {
    recordLimits(mColumnBounds,new Limits(absoluteChildRect.left,absoluteChildRect.right));
  }
  if (mRowBounds.size() != mHelper.getRowCount()) {
    recordLimits(mRowBounds,new Limits(absoluteChildRect.top,absoluteChildRect.bottom));
  }
  SparseIntArray columnList=mColumns.get(absoluteChildRect.left);
  if (columnList == null) {
    columnList=new SparseIntArray();
    mColumns.put(absoluteChildRect.left,columnList);
  }
  columnList.put(absoluteChildRect.top,adapterPosition);
}","/** 
 * Updates the limits lists and column map with the given item metadata.
 * @param absoluteChildRect The absolute rectangle for the child view being processed.
 * @param adapterPosition The position of the child view being processed.
 */
private void recordItemData(Rect absoluteChildRect,int adapterPosition){
  if (mColumnBounds.size() != mHelper.getColumnCount()) {
    recordLimits(mColumnBounds,new Limits(absoluteChildRect.left,absoluteChildRect.right));
  }
  recordLimits(mRowBounds,new Limits(absoluteChildRect.top,absoluteChildRect.bottom));
  SparseIntArray columnList=mColumns.get(absoluteChildRect.left);
  if (columnList == null) {
    columnList=new SparseIntArray();
    mColumns.put(absoluteChildRect.left,columnList);
  }
  columnList.put(absoluteChildRect.top,adapterPosition);
}",0.9206730769230768
192440,"@Override public Selection createFromParcel(Parcel in,ClassLoader loader){
  return new Selection(in.readString(),(ArrayList<String>)in.readArrayList(loader));
}","@Override public Selection createFromParcel(Parcel in,ClassLoader loader){
  return new Selection(in.readString(),in.readArrayList(loader));
}",0.9372937293729372
192441,"@Override public String toString(){
  if (size() <= 0) {
    return ""String_Node_Str"";
  }
  StringBuilder buffer=new StringBuilder(size() * 28);
  buffer.append(""String_Node_Str"").append(""String_Node_Str"" + mSelection.size()).append(""String_Node_Str"" + mSelection).append(""String_Node_Str"" + mProvisionalSelection.size()).append(""String_Node_Str"" + mProvisionalSelection).append(""String_Node_Str"");
  return buffer.toString();
}","@Override public String toString(){
  return ""String_Node_Str"" + lowerLimit + ""String_Node_Str""+ upperLimit+ ""String_Node_Str"";
}",0.3906810035842294
192442,"/** 
 * Processes a MotionEvent by starting, ending, or resizing the band select overlay.
 * @param input
 */
private void processInputEvent(InputEvent input){
  assert(input.isMouseEvent());
  if (shouldStop(input)) {
    endBandSelect();
    return;
  }
  if (!isActive()) {
    return;
  }
  mCurrentPosition=input.getOrigin();
  scrollViewIfNecessary();
  resizeBandSelectRectangle();
}","/** 
 * Processes a MotionEvent by starting, ending, or resizing the band select overlay.
 * @param input
 */
private void processInputEvent(InputEvent input){
  assert(input.isMouseEvent());
  if (shouldStop(input)) {
    endBandSelect();
    return;
  }
  if (!isActive()) {
    return;
  }
  mCurrentPosition=input.getOrigin();
  mModel.resizeSelection(input.getOrigin());
  scrollViewIfNecessary();
  resizeBandSelectRectangle();
}",0.9454545454545454
192443,"private void doKeyguardLaterLocked(long timeout){
  long when=SystemClock.elapsedRealtime() + timeout;
  Intent intent=new Intent(DELAYED_KEYGUARD_ACTION);
  intent.putExtra(""String_Node_Str"",mDelayedShowingSequence);
  PendingIntent sender=PendingIntent.getBroadcast(mContext,0,intent,PendingIntent.FLAG_CANCEL_CURRENT);
  mAlarmManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,when,sender);
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + mDelayedShowingSequence);
  doKeyguardLaterForChildProfilesLocked();
}","private void doKeyguardLaterLocked(long timeout){
  long when=SystemClock.elapsedRealtime() + timeout;
  Intent intent=new Intent(DELAYED_KEYGUARD_ACTION);
  intent.putExtra(""String_Node_Str"",mDelayedShowingSequence);
  PendingIntent sender=PendingIntent.getBroadcast(mContext,0,intent,PendingIntent.FLAG_CANCEL_CURRENT);
  mAlarmManager.setExactAndAllowWhileIdle(AlarmManager.ELAPSED_REALTIME_WAKEUP,when,sender);
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + mDelayedShowingSequence);
  doKeyguardLaterForChildProfilesLocked();
}",0.978805394990366
192444,"private void doKeyguardLaterForChildProfilesLocked(){
  UserManager um=UserManager.get(mContext);
  List<UserInfo> profiles=um.getEnabledProfiles(UserHandle.myUserId());
  for (  UserInfo info : profiles) {
    if (mLockPatternUtils.isSeparateProfileChallengeEnabled(info.id)) {
      long userTimeout=getLockTimeout(info.id);
      long userWhen=SystemClock.elapsedRealtime() + userTimeout;
      Intent lockIntent=new Intent(DELAYED_LOCK_PROFILE_ACTION);
      lockIntent.putExtra(Intent.EXTRA_USER_ID,info.id);
      PendingIntent lockSender=PendingIntent.getBroadcast(mContext,0,lockIntent,PendingIntent.FLAG_CANCEL_CURRENT);
      mAlarmManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,userWhen,lockSender);
    }
  }
}","private void doKeyguardLaterForChildProfilesLocked(){
  UserManager um=UserManager.get(mContext);
  List<UserInfo> profiles=um.getEnabledProfiles(UserHandle.myUserId());
  for (  UserInfo info : profiles) {
    if (mLockPatternUtils.isSeparateProfileChallengeEnabled(info.id)) {
      long userTimeout=getLockTimeout(info.id);
      long userWhen=SystemClock.elapsedRealtime() + userTimeout;
      Intent lockIntent=new Intent(DELAYED_LOCK_PROFILE_ACTION);
      lockIntent.putExtra(Intent.EXTRA_USER_ID,info.id);
      PendingIntent lockSender=PendingIntent.getBroadcast(mContext,0,lockIntent,PendingIntent.FLAG_CANCEL_CURRENT);
      mAlarmManager.setExactAndAllowWhileIdle(AlarmManager.ELAPSED_REALTIME_WAKEUP,userWhen,lockSender);
    }
  }
}",0.9251700680272108
192445,"public void clearAnimation(){
  if (animation != null) {
    animation=null;
    animating=true;
  }
  clearThumbnail();
  if (mAppToken.deferClearAllDrawn) {
    mAppToken.allDrawn=false;
    mAppToken.deferClearAllDrawn=false;
  }
  usingTransferredAnimation=false;
}","public void clearAnimation(){
  if (animation != null) {
    animating=true;
  }
  clearThumbnail();
  setNullAnimation();
  if (mAppToken.deferClearAllDrawn) {
    mAppToken.allDrawn=false;
    mAppToken.deferClearAllDrawn=false;
  }
}",0.8475247524752475
192446,"private boolean stepAnimation(long currentTime){
  if (animation == null) {
    return false;
  }
  transformation.clear();
  final long animationFrameTime=getAnimationFrameTime(animation,currentTime);
  boolean hasMoreFrames=animation.getTransformation(animationFrameTime,transformation);
  if (!hasMoreFrames) {
    if (deferThumbnailDestruction && !deferFinalFrameCleanup) {
      deferFinalFrameCleanup=true;
      hasMoreFrames=true;
    }
 else {
      if (false && DEBUG_ANIM)       Slog.v(TAG,""String_Node_Str"" + mAppToken + ""String_Node_Str""+ hasMoreFrames+ ""String_Node_Str""+ transformation+ ""String_Node_Str""+ mProlongAnimation);
      deferFinalFrameCleanup=false;
      if (mProlongAnimation == PROLONG_ANIMATION_AT_END) {
        hasMoreFrames=true;
      }
 else {
        animation=null;
        clearThumbnail();
        if (DEBUG_ANIM)         Slog.v(TAG,""String_Node_Str"" + mAppToken + ""String_Node_Str""+ currentTime);
      }
    }
  }
  hasTransformation=hasMoreFrames;
  return hasMoreFrames;
}","private boolean stepAnimation(long currentTime){
  if (animation == null) {
    return false;
  }
  transformation.clear();
  final long animationFrameTime=getAnimationFrameTime(animation,currentTime);
  boolean hasMoreFrames=animation.getTransformation(animationFrameTime,transformation);
  if (!hasMoreFrames) {
    if (deferThumbnailDestruction && !deferFinalFrameCleanup) {
      deferFinalFrameCleanup=true;
      hasMoreFrames=true;
    }
 else {
      if (false && DEBUG_ANIM)       Slog.v(TAG,""String_Node_Str"" + mAppToken + ""String_Node_Str""+ hasMoreFrames+ ""String_Node_Str""+ transformation+ ""String_Node_Str""+ mProlongAnimation);
      deferFinalFrameCleanup=false;
      if (mProlongAnimation == PROLONG_ANIMATION_AT_END) {
        hasMoreFrames=true;
      }
 else {
        setNullAnimation();
        clearThumbnail();
        if (DEBUG_ANIM)         Slog.v(TAG,""String_Node_Str"" + mAppToken + ""String_Node_Str""+ currentTime);
      }
    }
  }
  hasTransformation=hasMoreFrames;
  return hasMoreFrames;
}",0.9842829076620824
192447,"void transferCurrentAnimation(AppWindowAnimator toAppAnimator,WindowStateAnimator transferWinAnimator){
  if (animation != null) {
    toAppAnimator.animation=animation;
    animation=null;
    toAppAnimator.animating=animating;
    toAppAnimator.animLayerAdjustment=animLayerAdjustment;
    animLayerAdjustment=0;
    toAppAnimator.updateLayers();
    updateLayers();
    toAppAnimator.usingTransferredAnimation=true;
  }
  if (transferWinAnimator != null) {
    mAllAppWinAnimators.remove(transferWinAnimator);
    toAppAnimator.mAllAppWinAnimators.add(transferWinAnimator);
    transferWinAnimator.mAppAnimator=toAppAnimator;
  }
}","void transferCurrentAnimation(AppWindowAnimator toAppAnimator,WindowStateAnimator transferWinAnimator){
  if (animation != null) {
    toAppAnimator.animation=animation;
    toAppAnimator.animating=animating;
    toAppAnimator.animLayerAdjustment=animLayerAdjustment;
    setNullAnimation();
    animLayerAdjustment=0;
    toAppAnimator.updateLayers();
    updateLayers();
    toAppAnimator.usingTransferredAnimation=true;
  }
  if (transferWinAnimator != null) {
    mAllAppWinAnimators.remove(transferWinAnimator);
    toAppAnimator.mAllAppWinAnimators.add(transferWinAnimator);
    transferWinAnimator.mAppAnimator=toAppAnimator;
  }
}",0.9654088050314464
192448,"boolean setTokenVisibilityLocked(AppWindowToken wtoken,WindowManager.LayoutParams lp,boolean visible,int transit,boolean performLayout,boolean isVoiceInteraction){
  boolean delayed=false;
  if (wtoken.clientHidden == visible) {
    wtoken.clientHidden=!visible;
    wtoken.sendAppVisibilityToClients();
  }
  boolean visibilityChanged=false;
  if (wtoken.hidden == visible || (wtoken.hidden && wtoken.mIsExiting) || (visible && wtoken.waitingForReplacement())) {
    boolean changed=false;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG_WM,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ performLayout);
    boolean runningAppAnimation=false;
    if (transit != AppTransition.TRANSIT_UNSET) {
      if (wtoken.mAppAnimator.animation == AppWindowAnimator.sDummyAnimation) {
        wtoken.mAppAnimator.animation=null;
      }
      if (applyAnimationLocked(wtoken,lp,transit,visible,isVoiceInteraction)) {
        delayed=runningAppAnimation=true;
      }
      WindowState window=wtoken.findMainWindow();
      if (window != null && mAccessibilityController != null && window.getDisplayId() == Display.DEFAULT_DISPLAY) {
        mAccessibilityController.onAppWindowTransitionLocked(window,transit);
      }
      changed=true;
    }
    final int windowsCount=wtoken.allAppWindows.size();
    for (int i=0; i < windowsCount; i++) {
      WindowState win=wtoken.allAppWindows.get(i);
      if (win == wtoken.startingWindow) {
        continue;
      }
      if (visible) {
        if (!win.isVisibleNow()) {
          if (!runningAppAnimation) {
            win.mWinAnimator.applyAnimationLocked(WindowManagerPolicy.TRANSIT_ENTER,true);
            if (mAccessibilityController != null && win.getDisplayId() == Display.DEFAULT_DISPLAY) {
              mAccessibilityController.onWindowTransitionLocked(win,WindowManagerPolicy.TRANSIT_ENTER);
            }
          }
          changed=true;
          win.setDisplayLayoutNeeded();
        }
      }
 else       if (win.isVisibleNow()) {
        if (!runningAppAnimation) {
          win.mWinAnimator.applyAnimationLocked(WindowManagerPolicy.TRANSIT_EXIT,false);
          if (mAccessibilityController != null && win.getDisplayId() == Display.DEFAULT_DISPLAY) {
            mAccessibilityController.onWindowTransitionLocked(win,WindowManagerPolicy.TRANSIT_EXIT);
          }
        }
        changed=true;
        win.setDisplayLayoutNeeded();
      }
    }
    wtoken.hidden=wtoken.hiddenRequested=!visible;
    visibilityChanged=true;
    if (!visible) {
      unsetAppFreezingScreenLocked(wtoken,true,true);
    }
 else {
      WindowState swin=wtoken.startingWindow;
      if (swin != null && !swin.isDrawnLw()) {
        swin.mPolicyVisibility=false;
        swin.mPolicyVisibilityAfterAnim=false;
      }
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG_WM,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ wtoken.hiddenRequested);
    if (changed) {
      mInputMonitor.setUpdateInputWindowsNeededLw();
      if (performLayout) {
        updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES,false);
        mWindowPlacerLocked.performSurfacePlacement();
      }
      mInputMonitor.updateInputWindowsLw(false);
    }
  }
  if (wtoken.mAppAnimator.animation != null) {
    delayed=true;
  }
  for (int i=wtoken.allAppWindows.size() - 1; i >= 0 && !delayed; i--) {
    if (wtoken.allAppWindows.get(i).mWinAnimator.isWindowAnimating()) {
      delayed=true;
    }
  }
  if (visibilityChanged && !delayed) {
    if (visible) {
      wtoken.mEnteringAnimation=true;
      mActivityManagerAppTransitionNotifier.onAppTransitionFinishedLocked(wtoken.token);
    }
    getDefaultDisplayContentLocked().getDockedDividerController().notifyAppVisibilityChanged(wtoken,visible);
  }
  return delayed;
}","boolean setTokenVisibilityLocked(AppWindowToken wtoken,WindowManager.LayoutParams lp,boolean visible,int transit,boolean performLayout,boolean isVoiceInteraction){
  boolean delayed=false;
  if (wtoken.clientHidden == visible) {
    wtoken.clientHidden=!visible;
    wtoken.sendAppVisibilityToClients();
  }
  boolean visibilityChanged=false;
  if (wtoken.hidden == visible || (wtoken.hidden && wtoken.mIsExiting) || (visible && wtoken.waitingForReplacement())) {
    boolean changed=false;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG_WM,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ performLayout);
    boolean runningAppAnimation=false;
    if (transit != AppTransition.TRANSIT_UNSET) {
      if (wtoken.mAppAnimator.animation == AppWindowAnimator.sDummyAnimation) {
        wtoken.mAppAnimator.setNullAnimation();
      }
      if (applyAnimationLocked(wtoken,lp,transit,visible,isVoiceInteraction)) {
        delayed=runningAppAnimation=true;
      }
      WindowState window=wtoken.findMainWindow();
      if (window != null && mAccessibilityController != null && window.getDisplayId() == Display.DEFAULT_DISPLAY) {
        mAccessibilityController.onAppWindowTransitionLocked(window,transit);
      }
      changed=true;
    }
    final int windowsCount=wtoken.allAppWindows.size();
    for (int i=0; i < windowsCount; i++) {
      WindowState win=wtoken.allAppWindows.get(i);
      if (win == wtoken.startingWindow) {
        continue;
      }
      if (visible) {
        if (!win.isVisibleNow()) {
          if (!runningAppAnimation) {
            win.mWinAnimator.applyAnimationLocked(WindowManagerPolicy.TRANSIT_ENTER,true);
            if (mAccessibilityController != null && win.getDisplayId() == Display.DEFAULT_DISPLAY) {
              mAccessibilityController.onWindowTransitionLocked(win,WindowManagerPolicy.TRANSIT_ENTER);
            }
          }
          changed=true;
          win.setDisplayLayoutNeeded();
        }
      }
 else       if (win.isVisibleNow()) {
        if (!runningAppAnimation) {
          win.mWinAnimator.applyAnimationLocked(WindowManagerPolicy.TRANSIT_EXIT,false);
          if (mAccessibilityController != null && win.getDisplayId() == Display.DEFAULT_DISPLAY) {
            mAccessibilityController.onWindowTransitionLocked(win,WindowManagerPolicy.TRANSIT_EXIT);
          }
        }
        changed=true;
        win.setDisplayLayoutNeeded();
      }
    }
    wtoken.hidden=wtoken.hiddenRequested=!visible;
    visibilityChanged=true;
    if (!visible) {
      unsetAppFreezingScreenLocked(wtoken,true,true);
    }
 else {
      WindowState swin=wtoken.startingWindow;
      if (swin != null && !swin.isDrawnLw()) {
        swin.mPolicyVisibility=false;
        swin.mPolicyVisibilityAfterAnim=false;
      }
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG_WM,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ wtoken.hiddenRequested);
    if (changed) {
      mInputMonitor.setUpdateInputWindowsNeededLw();
      if (performLayout) {
        updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES,false);
        mWindowPlacerLocked.performSurfacePlacement();
      }
      mInputMonitor.updateInputWindowsLw(false);
    }
  }
  if (wtoken.mAppAnimator.animation != null) {
    delayed=true;
  }
  for (int i=wtoken.allAppWindows.size() - 1; i >= 0 && !delayed; i--) {
    if (wtoken.allAppWindows.get(i).mWinAnimator.isWindowAnimating()) {
      delayed=true;
    }
  }
  if (visibilityChanged && !delayed) {
    if (visible) {
      wtoken.mEnteringAnimation=true;
      mActivityManagerAppTransitionNotifier.onAppTransitionFinishedLocked(wtoken.token);
    }
    getDefaultDisplayContentLocked().getDockedDividerController().notifyAppVisibilityChanged(wtoken,visible);
  }
  return delayed;
}",0.9958148051268636
192449,"void updateTokenInPlaceLocked(AppWindowToken wtoken,int transit){
  if (transit != AppTransition.TRANSIT_UNSET) {
    if (wtoken.mAppAnimator.animation == AppWindowAnimator.sDummyAnimation) {
      wtoken.mAppAnimator.animation=null;
    }
    applyAnimationLocked(wtoken,null,transit,false,false);
  }
}","void updateTokenInPlaceLocked(AppWindowToken wtoken,int transit){
  if (transit != AppTransition.TRANSIT_UNSET) {
    if (wtoken.mAppAnimator.animation == AppWindowAnimator.sDummyAnimation) {
      wtoken.mAppAnimator.setNullAnimation();
    }
    applyAnimationLocked(wtoken,null,transit,false,false);
  }
}",0.9575163398692812
192450,"@Override public void setAppVisibility(IBinder token,boolean visible){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
  AppWindowToken wtoken;
synchronized (mWindowMap) {
    wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Slog.w(TAG_WM,""String_Node_Str"" + token);
      return;
    }
    if (DEBUG_APP_TRANSITIONS || DEBUG_ORIENTATION)     Slog.v(TAG_WM,""String_Node_Str"" + token + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mAppTransition+ ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ wtoken.hiddenRequested+ ""String_Node_Str""+ Debug.getCallers(6));
    mOpeningApps.remove(wtoken);
    mClosingApps.remove(wtoken);
    wtoken.waitingToShow=false;
    wtoken.hiddenRequested=!visible;
    if (!visible && wtoken.appDied) {
      wtoken.appDied=false;
      wtoken.removeAllWindows();
    }
 else     if (visible) {
      if (DEBUG_ADD_REMOVE)       Slog.v(TAG_WM,""String_Node_Str"" + wtoken);
      wtoken.mAppStopped=false;
      wtoken.setWindowsExiting(false);
      mOpeningApps.add(wtoken);
      wtoken.startingMoved=false;
      if (wtoken.hidden) {
        wtoken.allDrawn=false;
        wtoken.deferClearAllDrawn=false;
        wtoken.waitingToShow=true;
        if (wtoken.clientHidden) {
          wtoken.clientHidden=false;
          wtoken.sendAppVisibilityToClients();
        }
      }
    }
    if (okToDisplay() && mAppTransition.isTransitionSet()) {
      if (!wtoken.mAppAnimator.usingTransferredAnimation && (!wtoken.startingDisplayed || mSkipAppTransitionAnimation)) {
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG_WM,""String_Node_Str"" + wtoken);
        wtoken.mAppAnimator.setDummyAnimation();
      }
      wtoken.inPendingTransaction=true;
      if (visible) {
        wtoken.mEnteringAnimation=true;
      }
 else {
        wtoken.setWindowsExiting(true);
        mClosingApps.add(wtoken);
        wtoken.mEnteringAnimation=false;
      }
      if (mAppTransition.getAppTransition() == AppTransition.TRANSIT_TASK_OPEN_BEHIND) {
        final WindowState win=findFocusedWindowLocked(getDefaultDisplayContentLocked());
        if (win != null) {
          final AppWindowToken focusedToken=win.mAppToken;
          if (focusedToken != null) {
            if (DEBUG_APP_TRANSITIONS)             Slog.d(TAG_WM,""String_Node_Str"" + ""String_Node_Str"" + focusedToken + ""String_Node_Str"");
            focusedToken.hidden=true;
            mOpeningApps.add(focusedToken);
          }
        }
      }
      return;
    }
    final long origId=Binder.clearCallingIdentity();
    wtoken.inPendingTransaction=false;
    setTokenVisibilityLocked(wtoken,null,visible,AppTransition.TRANSIT_UNSET,true,wtoken.voiceInteraction);
    wtoken.updateReportedVisibilityLocked();
    Binder.restoreCallingIdentity(origId);
  }
}","@Override public void setAppVisibility(IBinder token,boolean visible){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
  AppWindowToken wtoken;
synchronized (mWindowMap) {
    wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Slog.w(TAG_WM,""String_Node_Str"" + token);
      return;
    }
    if (DEBUG_APP_TRANSITIONS || DEBUG_ORIENTATION)     Slog.v(TAG_WM,""String_Node_Str"" + token + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mAppTransition+ ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ wtoken.hiddenRequested+ ""String_Node_Str""+ Debug.getCallers(6));
    mOpeningApps.remove(wtoken);
    mClosingApps.remove(wtoken);
    wtoken.waitingToShow=false;
    wtoken.hiddenRequested=!visible;
    if (!visible && wtoken.appDied) {
      wtoken.appDied=false;
      wtoken.removeAllWindows();
    }
 else     if (visible) {
      if (DEBUG_ADD_REMOVE)       Slog.v(TAG_WM,""String_Node_Str"" + wtoken);
      wtoken.mAppStopped=false;
      mOpeningApps.add(wtoken);
      wtoken.startingMoved=false;
      if (wtoken.hidden) {
        wtoken.allDrawn=false;
        wtoken.deferClearAllDrawn=false;
        wtoken.waitingToShow=true;
        if (wtoken.clientHidden) {
          wtoken.clientHidden=false;
          wtoken.sendAppVisibilityToClients();
        }
      }
    }
    if (okToDisplay() && mAppTransition.isTransitionSet()) {
      if (wtoken.mAppAnimator.usingTransferredAnimation && wtoken.mAppAnimator.animation == null) {
        Slog.wtf(TAG_WM,""String_Node_Str"" + wtoken + ""String_Node_Str"");
      }
      if (!wtoken.mAppAnimator.usingTransferredAnimation && (!wtoken.startingDisplayed || mSkipAppTransitionAnimation)) {
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG_WM,""String_Node_Str"" + wtoken);
        wtoken.mAppAnimator.setDummyAnimation();
      }
      wtoken.inPendingTransaction=true;
      if (visible) {
        wtoken.mEnteringAnimation=true;
      }
 else {
        mClosingApps.add(wtoken);
        wtoken.mEnteringAnimation=false;
      }
      if (mAppTransition.getAppTransition() == AppTransition.TRANSIT_TASK_OPEN_BEHIND) {
        final WindowState win=findFocusedWindowLocked(getDefaultDisplayContentLocked());
        if (win != null) {
          final AppWindowToken focusedToken=win.mAppToken;
          if (focusedToken != null) {
            if (DEBUG_APP_TRANSITIONS)             Slog.d(TAG_WM,""String_Node_Str"" + ""String_Node_Str"" + focusedToken + ""String_Node_Str"");
            focusedToken.hidden=true;
            mOpeningApps.add(focusedToken);
          }
        }
      }
      return;
    }
    final long origId=Binder.clearCallingIdentity();
    wtoken.inPendingTransaction=false;
    setTokenVisibilityLocked(wtoken,null,visible,AppTransition.TRANSIT_UNSET,true,wtoken.voiceInteraction);
    wtoken.updateReportedVisibilityLocked();
    Binder.restoreCallingIdentity(origId);
  }
}",0.9556162512803004
192451,"private boolean tryStartExitingAnimation(WindowState win,WindowStateAnimator winAnimator,boolean isDefaultDisplay,boolean focusMayChange){
  int transit=WindowManagerPolicy.TRANSIT_EXIT;
  if (win.mAttrs.type == TYPE_APPLICATION_STARTING) {
    transit=WindowManagerPolicy.TRANSIT_PREVIEW_DONE;
  }
  if (win.isWinVisibleLw() && winAnimator.applyAnimationLocked(transit,false)) {
    focusMayChange=isDefaultDisplay;
    win.mAnimatingExit=true;
  }
 else   if (win.mWinAnimator.isAnimating()) {
    win.mAnimatingExit=true;
  }
 else   if (mWallpaperControllerLocked.isWallpaperTarget(win)) {
    win.mAnimatingExit=true;
    win.mWinAnimator.mAnimating=true;
  }
 else {
    if (mInputMethodWindow == win) {
      mInputMethodWindow=null;
    }
    win.destroyOrSaveSurface();
  }
  if (mAccessibilityController != null && win.getDisplayId() == Display.DEFAULT_DISPLAY) {
    mAccessibilityController.onWindowTransitionLocked(win,transit);
  }
  return focusMayChange;
}","private boolean tryStartExitingAnimation(WindowState win,WindowStateAnimator winAnimator,boolean isDefaultDisplay,boolean focusMayChange){
  int transit=WindowManagerPolicy.TRANSIT_EXIT;
  if (win.mAttrs.type == TYPE_APPLICATION_STARTING) {
    transit=WindowManagerPolicy.TRANSIT_PREVIEW_DONE;
  }
  if (win.isWinVisibleLw() && winAnimator.applyAnimationLocked(transit,false)) {
    focusMayChange=isDefaultDisplay;
    win.mAnimatingExit=true;
    win.mWinAnimator.mAnimating=true;
  }
 else   if (win.mWinAnimator.isAnimating()) {
    win.mAnimatingExit=true;
    win.mWinAnimator.mAnimating=true;
  }
 else   if (mWallpaperControllerLocked.isWallpaperTarget(win)) {
    win.mAnimatingExit=true;
    win.mWinAnimator.mAnimating=true;
  }
 else {
    if (mInputMethodWindow == win) {
      mInputMethodWindow=null;
    }
    win.destroyOrSaveSurface();
  }
  if (mAccessibilityController != null && win.getDisplayId() == Display.DEFAULT_DISPLAY) {
    mAccessibilityController.onWindowTransitionLocked(win,transit);
  }
  return focusMayChange;
}",0.9623762376237625
192452,"private AppWindowToken handleOpeningApps(int transit,LayoutParams animLp,boolean voiceInteraction,int topClosingLayer){
  AppWindowToken topOpeningApp=null;
  final int appsCount=mService.mOpeningApps.size();
  for (int i=0; i < appsCount; i++) {
    AppWindowToken wtoken=mService.mOpeningApps.valueAt(i);
    final AppWindowAnimator appAnimator=wtoken.mAppAnimator;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    if (!appAnimator.usingTransferredAnimation) {
      appAnimator.clearThumbnail();
      appAnimator.animation=null;
    }
    wtoken.inPendingTransaction=false;
    if (!mService.setTokenVisibilityLocked(wtoken,animLp,true,transit,false,voiceInteraction)) {
      mService.mNoAnimationNotifyOnTransitionFinished.add(wtoken.token);
    }
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    appAnimator.mAllAppWinAnimators.clear();
    final int windowsCount=wtoken.allAppWindows.size();
    for (int j=0; j < windowsCount; j++) {
      appAnimator.mAllAppWinAnimators.add(wtoken.allAppWindows.get(j).mWinAnimator);
    }
    if (SHOW_LIGHT_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"");
    SurfaceControl.openTransaction();
    try {
      mService.mAnimator.orAnimating(appAnimator.showAllWindowsLocked());
    }
  finally {
      SurfaceControl.closeTransaction();
      if (SHOW_LIGHT_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"");
    }
    mService.mAnimator.mAppWindowAnimating|=appAnimator.isAnimating();
    int topOpeningLayer=0;
    if (animLp != null) {
      int layer=-1;
      for (int j=0; j < wtoken.windows.size(); j++) {
        final WindowState win=wtoken.windows.get(j);
        if (!win.mWillReplaceWindow && !win.mRemoveOnExit) {
          win.mAnimatingExit=false;
        }
        if (win.mWinAnimator.mAnimLayer > layer) {
          layer=win.mWinAnimator.mAnimLayer;
        }
      }
      if (topOpeningApp == null || layer > topOpeningLayer) {
        topOpeningApp=wtoken;
        topOpeningLayer=layer;
      }
    }
    if (mService.mAppTransition.isNextAppTransitionThumbnailUp()) {
      createThumbnailAppAnimator(transit,wtoken,topOpeningLayer,topClosingLayer);
    }
  }
  return topOpeningApp;
}","private AppWindowToken handleOpeningApps(int transit,LayoutParams animLp,boolean voiceInteraction,int topClosingLayer){
  AppWindowToken topOpeningApp=null;
  final int appsCount=mService.mOpeningApps.size();
  for (int i=0; i < appsCount; i++) {
    AppWindowToken wtoken=mService.mOpeningApps.valueAt(i);
    final AppWindowAnimator appAnimator=wtoken.mAppAnimator;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    if (!appAnimator.usingTransferredAnimation) {
      appAnimator.clearThumbnail();
      appAnimator.setNullAnimation();
    }
    wtoken.inPendingTransaction=false;
    if (!mService.setTokenVisibilityLocked(wtoken,animLp,true,transit,false,voiceInteraction)) {
      mService.mNoAnimationNotifyOnTransitionFinished.add(wtoken.token);
    }
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    appAnimator.mAllAppWinAnimators.clear();
    final int windowsCount=wtoken.allAppWindows.size();
    for (int j=0; j < windowsCount; j++) {
      appAnimator.mAllAppWinAnimators.add(wtoken.allAppWindows.get(j).mWinAnimator);
    }
    if (SHOW_LIGHT_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"");
    SurfaceControl.openTransaction();
    try {
      mService.mAnimator.orAnimating(appAnimator.showAllWindowsLocked());
    }
  finally {
      SurfaceControl.closeTransaction();
      if (SHOW_LIGHT_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"");
    }
    mService.mAnimator.mAppWindowAnimating|=appAnimator.isAnimating();
    int topOpeningLayer=0;
    if (animLp != null) {
      int layer=-1;
      for (int j=0; j < wtoken.windows.size(); j++) {
        final WindowState win=wtoken.windows.get(j);
        if (!win.mWillReplaceWindow && !win.mRemoveOnExit) {
          win.mAnimatingExit=false;
        }
        if (win.mWinAnimator.mAnimLayer > layer) {
          layer=win.mWinAnimator.mAnimLayer;
        }
      }
      if (topOpeningApp == null || layer > topOpeningLayer) {
        topOpeningApp=wtoken;
        topOpeningLayer=layer;
      }
    }
    if (mService.mAppTransition.isNextAppTransitionThumbnailUp()) {
      createThumbnailAppAnimator(transit,wtoken,topOpeningLayer,topClosingLayer);
    }
  }
  return topOpeningApp;
}",0.9941415051825148
192453,"private void handleClosingApps(int transit,LayoutParams animLp,boolean voiceInteraction,LayerAndToken layerAndToken){
  final int appsCount;
  appsCount=mService.mClosingApps.size();
  for (int i=0; i < appsCount; i++) {
    AppWindowToken wtoken=mService.mClosingApps.valueAt(i);
    final AppWindowAnimator appAnimator=wtoken.mAppAnimator;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    appAnimator.clearThumbnail();
    appAnimator.animation=null;
    wtoken.inPendingTransaction=false;
    mService.setTokenVisibilityLocked(wtoken,animLp,false,transit,false,voiceInteraction);
    wtoken.updateReportedVisibilityLocked();
    wtoken.allDrawn=true;
    wtoken.deferClearAllDrawn=false;
    if (wtoken.startingWindow != null && !wtoken.startingWindow.mAnimatingExit) {
      mService.scheduleRemoveStartingWindowLocked(wtoken);
    }
    mService.mAnimator.mAppWindowAnimating|=appAnimator.isAnimating();
    if (animLp != null) {
      int layer=-1;
      for (int j=0; j < wtoken.windows.size(); j++) {
        WindowState win=wtoken.windows.get(j);
        if (win.mWinAnimator.mAnimLayer > layer) {
          layer=win.mWinAnimator.mAnimLayer;
        }
      }
      if (layerAndToken.token == null || layer > layerAndToken.layer) {
        layerAndToken.token=wtoken;
        layerAndToken.layer=layer;
      }
    }
    if (mService.mAppTransition.isNextAppTransitionThumbnailDown()) {
      createThumbnailAppAnimator(transit,wtoken,0,layerAndToken.layer);
    }
  }
}","private void handleClosingApps(int transit,LayoutParams animLp,boolean voiceInteraction,LayerAndToken layerAndToken){
  final int appsCount;
  appsCount=mService.mClosingApps.size();
  for (int i=0; i < appsCount; i++) {
    AppWindowToken wtoken=mService.mClosingApps.valueAt(i);
    final AppWindowAnimator appAnimator=wtoken.mAppAnimator;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    appAnimator.clearThumbnail();
    appAnimator.setNullAnimation();
    wtoken.inPendingTransaction=false;
    mService.setTokenVisibilityLocked(wtoken,animLp,false,transit,false,voiceInteraction);
    wtoken.updateReportedVisibilityLocked();
    wtoken.allDrawn=true;
    wtoken.deferClearAllDrawn=false;
    if (wtoken.startingWindow != null && !wtoken.startingWindow.mAnimatingExit) {
      mService.scheduleRemoveStartingWindowLocked(wtoken);
    }
    mService.mAnimator.mAppWindowAnimating|=appAnimator.isAnimating();
    if (animLp != null) {
      int layer=-1;
      for (int j=0; j < wtoken.windows.size(); j++) {
        WindowState win=wtoken.windows.get(j);
        if (win.mWinAnimator.mAnimLayer > layer) {
          layer=win.mWinAnimator.mAnimLayer;
        }
      }
      if (layerAndToken.token == null || layer > layerAndToken.layer) {
        layerAndToken.token=wtoken;
        layerAndToken.layer=layer;
      }
    }
    if (mService.mAppTransition.isNextAppTransitionThumbnailDown()) {
      createThumbnailAppAnimator(transit,wtoken,0,layerAndToken.layer);
    }
  }
}",0.9914021164021164
192454,"private void processApplicationsAnimatingInPlace(int transit){
  if (transit == AppTransition.TRANSIT_TASK_IN_PLACE) {
    final WindowState win=mService.findFocusedWindowLocked(mService.getDefaultDisplayContentLocked());
    if (win != null) {
      final AppWindowToken wtoken=win.mAppToken;
      final AppWindowAnimator appAnimator=wtoken.mAppAnimator;
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + wtoken);
      appAnimator.clearThumbnail();
      appAnimator.animation=null;
      mService.updateTokenInPlaceLocked(wtoken,transit);
      wtoken.updateReportedVisibilityLocked();
      appAnimator.mAllAppWinAnimators.clear();
      final int N=wtoken.allAppWindows.size();
      for (int j=0; j < N; j++) {
        appAnimator.mAllAppWinAnimators.add(wtoken.allAppWindows.get(j).mWinAnimator);
      }
      mService.mAnimator.mAppWindowAnimating|=appAnimator.isAnimating();
      mService.mAnimator.orAnimating(appAnimator.showAllWindowsLocked());
    }
  }
}","private void processApplicationsAnimatingInPlace(int transit){
  if (transit == AppTransition.TRANSIT_TASK_IN_PLACE) {
    final WindowState win=mService.findFocusedWindowLocked(mService.getDefaultDisplayContentLocked());
    if (win != null) {
      final AppWindowToken wtoken=win.mAppToken;
      final AppWindowAnimator appAnimator=wtoken.mAppAnimator;
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + wtoken);
      appAnimator.clearThumbnail();
      appAnimator.setNullAnimation();
      mService.updateTokenInPlaceLocked(wtoken,transit);
      wtoken.updateReportedVisibilityLocked();
      appAnimator.mAllAppWinAnimators.clear();
      final int N=wtoken.allAppWindows.size();
      for (int j=0; j < N; j++) {
        appAnimator.mAllAppWinAnimators.add(wtoken.allAppWindows.get(j).mWinAnimator);
      }
      mService.mAnimator.mAppWindowAnimating|=appAnimator.isAnimating();
      mService.mAnimator.orAnimating(appAnimator.showAllWindowsLocked());
    }
  }
}",0.9869083585095668
192455,"public void clearAnimation(){
  if (animation != null) {
    animation=null;
    animating=true;
  }
  clearThumbnail();
  if (mAppToken.deferClearAllDrawn) {
    mAppToken.allDrawn=false;
    mAppToken.deferClearAllDrawn=false;
  }
  usingTransferredAnimation=false;
}","public void clearAnimation(){
  if (animation != null) {
    animating=true;
  }
  clearThumbnail();
  setNullAnimation();
  if (mAppToken.deferClearAllDrawn) {
    mAppToken.allDrawn=false;
    mAppToken.deferClearAllDrawn=false;
  }
}",0.8475247524752475
192456,"private boolean stepAnimation(long currentTime){
  if (animation == null) {
    return false;
  }
  transformation.clear();
  final long animationFrameTime=getAnimationFrameTime(animation,currentTime);
  boolean hasMoreFrames=animation.getTransformation(animationFrameTime,transformation);
  if (!hasMoreFrames) {
    if (deferThumbnailDestruction && !deferFinalFrameCleanup) {
      deferFinalFrameCleanup=true;
      hasMoreFrames=true;
    }
 else {
      if (false && DEBUG_ANIM)       Slog.v(TAG,""String_Node_Str"" + mAppToken + ""String_Node_Str""+ hasMoreFrames+ ""String_Node_Str""+ transformation+ ""String_Node_Str""+ mProlongAnimation);
      deferFinalFrameCleanup=false;
      if (mProlongAnimation == PROLONG_ANIMATION_AT_END) {
        hasMoreFrames=true;
      }
 else {
        animation=null;
        clearThumbnail();
        if (DEBUG_ANIM)         Slog.v(TAG,""String_Node_Str"" + mAppToken + ""String_Node_Str""+ currentTime);
      }
    }
  }
  hasTransformation=hasMoreFrames;
  return hasMoreFrames;
}","private boolean stepAnimation(long currentTime){
  if (animation == null) {
    return false;
  }
  transformation.clear();
  final long animationFrameTime=getAnimationFrameTime(animation,currentTime);
  boolean hasMoreFrames=animation.getTransformation(animationFrameTime,transformation);
  if (!hasMoreFrames) {
    if (deferThumbnailDestruction && !deferFinalFrameCleanup) {
      deferFinalFrameCleanup=true;
      hasMoreFrames=true;
    }
 else {
      if (false && DEBUG_ANIM)       Slog.v(TAG,""String_Node_Str"" + mAppToken + ""String_Node_Str""+ hasMoreFrames+ ""String_Node_Str""+ transformation+ ""String_Node_Str""+ mProlongAnimation);
      deferFinalFrameCleanup=false;
      if (mProlongAnimation == PROLONG_ANIMATION_AT_END) {
        hasMoreFrames=true;
      }
 else {
        setNullAnimation();
        clearThumbnail();
        if (DEBUG_ANIM)         Slog.v(TAG,""String_Node_Str"" + mAppToken + ""String_Node_Str""+ currentTime);
      }
    }
  }
  hasTransformation=hasMoreFrames;
  return hasMoreFrames;
}",0.9842829076620824
192457,"void transferCurrentAnimation(AppWindowAnimator toAppAnimator,WindowStateAnimator transferWinAnimator){
  if (animation != null) {
    toAppAnimator.animation=animation;
    animation=null;
    toAppAnimator.animating=animating;
    toAppAnimator.animLayerAdjustment=animLayerAdjustment;
    animLayerAdjustment=0;
    toAppAnimator.updateLayers();
    updateLayers();
    toAppAnimator.usingTransferredAnimation=true;
  }
  if (transferWinAnimator != null) {
    mAllAppWinAnimators.remove(transferWinAnimator);
    toAppAnimator.mAllAppWinAnimators.add(transferWinAnimator);
    transferWinAnimator.mAppAnimator=toAppAnimator;
  }
}","void transferCurrentAnimation(AppWindowAnimator toAppAnimator,WindowStateAnimator transferWinAnimator){
  if (animation != null) {
    toAppAnimator.animation=animation;
    toAppAnimator.animating=animating;
    toAppAnimator.animLayerAdjustment=animLayerAdjustment;
    setNullAnimation();
    animLayerAdjustment=0;
    toAppAnimator.updateLayers();
    updateLayers();
    toAppAnimator.usingTransferredAnimation=true;
  }
  if (transferWinAnimator != null) {
    mAllAppWinAnimators.remove(transferWinAnimator);
    toAppAnimator.mAllAppWinAnimators.add(transferWinAnimator);
    transferWinAnimator.mAppAnimator=toAppAnimator;
  }
}",0.9654088050314464
192458,"boolean setTokenVisibilityLocked(AppWindowToken wtoken,WindowManager.LayoutParams lp,boolean visible,int transit,boolean performLayout,boolean isVoiceInteraction){
  boolean delayed=false;
  if (wtoken.clientHidden == visible) {
    wtoken.clientHidden=!visible;
    wtoken.sendAppVisibilityToClients();
  }
  boolean visibilityChanged=false;
  if (wtoken.hidden == visible || (wtoken.hidden && wtoken.mIsExiting) || (visible && wtoken.waitingForReplacement())) {
    boolean changed=false;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG_WM,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ performLayout);
    boolean runningAppAnimation=false;
    if (transit != AppTransition.TRANSIT_UNSET) {
      if (wtoken.mAppAnimator.animation == AppWindowAnimator.sDummyAnimation) {
        wtoken.mAppAnimator.animation=null;
      }
      if (applyAnimationLocked(wtoken,lp,transit,visible,isVoiceInteraction)) {
        delayed=runningAppAnimation=true;
      }
      WindowState window=wtoken.findMainWindow();
      if (window != null && mAccessibilityController != null && window.getDisplayId() == Display.DEFAULT_DISPLAY) {
        mAccessibilityController.onAppWindowTransitionLocked(window,transit);
      }
      changed=true;
    }
    final int windowsCount=wtoken.allAppWindows.size();
    for (int i=0; i < windowsCount; i++) {
      WindowState win=wtoken.allAppWindows.get(i);
      if (win == wtoken.startingWindow) {
        continue;
      }
      if (visible) {
        if (!win.isVisibleNow()) {
          if (!runningAppAnimation) {
            win.mWinAnimator.applyAnimationLocked(WindowManagerPolicy.TRANSIT_ENTER,true);
            if (mAccessibilityController != null && win.getDisplayId() == Display.DEFAULT_DISPLAY) {
              mAccessibilityController.onWindowTransitionLocked(win,WindowManagerPolicy.TRANSIT_ENTER);
            }
          }
          changed=true;
          win.setDisplayLayoutNeeded();
        }
      }
 else       if (win.isVisibleNow()) {
        if (!runningAppAnimation) {
          win.mWinAnimator.applyAnimationLocked(WindowManagerPolicy.TRANSIT_EXIT,false);
          if (mAccessibilityController != null && win.getDisplayId() == Display.DEFAULT_DISPLAY) {
            mAccessibilityController.onWindowTransitionLocked(win,WindowManagerPolicy.TRANSIT_EXIT);
          }
        }
        changed=true;
        win.setDisplayLayoutNeeded();
      }
    }
    wtoken.hidden=wtoken.hiddenRequested=!visible;
    visibilityChanged=true;
    if (!visible) {
      unsetAppFreezingScreenLocked(wtoken,true,true);
    }
 else {
      WindowState swin=wtoken.startingWindow;
      if (swin != null && !swin.isDrawnLw()) {
        swin.mPolicyVisibility=false;
        swin.mPolicyVisibilityAfterAnim=false;
      }
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG_WM,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ wtoken.hiddenRequested);
    if (changed) {
      mInputMonitor.setUpdateInputWindowsNeededLw();
      if (performLayout) {
        updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES,false);
        mWindowPlacerLocked.performSurfacePlacement();
      }
      mInputMonitor.updateInputWindowsLw(false);
    }
  }
  if (wtoken.mAppAnimator.animation != null) {
    delayed=true;
  }
  for (int i=wtoken.allAppWindows.size() - 1; i >= 0 && !delayed; i--) {
    if (wtoken.allAppWindows.get(i).mWinAnimator.isWindowAnimating()) {
      delayed=true;
    }
  }
  if (visibilityChanged && !delayed) {
    if (visible) {
      wtoken.mEnteringAnimation=true;
      mActivityManagerAppTransitionNotifier.onAppTransitionFinishedLocked(wtoken.token);
    }
    getDefaultDisplayContentLocked().getDockedDividerController().notifyAppVisibilityChanged(wtoken,visible);
  }
  return delayed;
}","boolean setTokenVisibilityLocked(AppWindowToken wtoken,WindowManager.LayoutParams lp,boolean visible,int transit,boolean performLayout,boolean isVoiceInteraction){
  boolean delayed=false;
  if (wtoken.clientHidden == visible) {
    wtoken.clientHidden=!visible;
    wtoken.sendAppVisibilityToClients();
  }
  boolean visibilityChanged=false;
  if (wtoken.hidden == visible || (wtoken.hidden && wtoken.mIsExiting) || (visible && wtoken.waitingForReplacement())) {
    boolean changed=false;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG_WM,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ performLayout);
    boolean runningAppAnimation=false;
    if (transit != AppTransition.TRANSIT_UNSET) {
      if (wtoken.mAppAnimator.animation == AppWindowAnimator.sDummyAnimation) {
        wtoken.mAppAnimator.setNullAnimation();
      }
      if (applyAnimationLocked(wtoken,lp,transit,visible,isVoiceInteraction)) {
        delayed=runningAppAnimation=true;
      }
      WindowState window=wtoken.findMainWindow();
      if (window != null && mAccessibilityController != null && window.getDisplayId() == Display.DEFAULT_DISPLAY) {
        mAccessibilityController.onAppWindowTransitionLocked(window,transit);
      }
      changed=true;
    }
    final int windowsCount=wtoken.allAppWindows.size();
    for (int i=0; i < windowsCount; i++) {
      WindowState win=wtoken.allAppWindows.get(i);
      if (win == wtoken.startingWindow) {
        continue;
      }
      if (visible) {
        if (!win.isVisibleNow()) {
          if (!runningAppAnimation) {
            win.mWinAnimator.applyAnimationLocked(WindowManagerPolicy.TRANSIT_ENTER,true);
            if (mAccessibilityController != null && win.getDisplayId() == Display.DEFAULT_DISPLAY) {
              mAccessibilityController.onWindowTransitionLocked(win,WindowManagerPolicy.TRANSIT_ENTER);
            }
          }
          changed=true;
          win.setDisplayLayoutNeeded();
        }
      }
 else       if (win.isVisibleNow()) {
        if (!runningAppAnimation) {
          win.mWinAnimator.applyAnimationLocked(WindowManagerPolicy.TRANSIT_EXIT,false);
          if (mAccessibilityController != null && win.getDisplayId() == Display.DEFAULT_DISPLAY) {
            mAccessibilityController.onWindowTransitionLocked(win,WindowManagerPolicy.TRANSIT_EXIT);
          }
        }
        changed=true;
        win.setDisplayLayoutNeeded();
      }
    }
    wtoken.hidden=wtoken.hiddenRequested=!visible;
    visibilityChanged=true;
    if (!visible) {
      unsetAppFreezingScreenLocked(wtoken,true,true);
    }
 else {
      WindowState swin=wtoken.startingWindow;
      if (swin != null && !swin.isDrawnLw()) {
        swin.mPolicyVisibility=false;
        swin.mPolicyVisibilityAfterAnim=false;
      }
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG_WM,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ wtoken.hiddenRequested);
    if (changed) {
      mInputMonitor.setUpdateInputWindowsNeededLw();
      if (performLayout) {
        updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES,false);
        mWindowPlacerLocked.performSurfacePlacement();
      }
      mInputMonitor.updateInputWindowsLw(false);
    }
  }
  if (wtoken.mAppAnimator.animation != null) {
    delayed=true;
  }
  for (int i=wtoken.allAppWindows.size() - 1; i >= 0 && !delayed; i--) {
    if (wtoken.allAppWindows.get(i).mWinAnimator.isWindowAnimating()) {
      delayed=true;
    }
  }
  if (visibilityChanged && !delayed) {
    if (visible) {
      wtoken.mEnteringAnimation=true;
      mActivityManagerAppTransitionNotifier.onAppTransitionFinishedLocked(wtoken.token);
    }
    getDefaultDisplayContentLocked().getDockedDividerController().notifyAppVisibilityChanged(wtoken,visible);
  }
  return delayed;
}",0.9958148051268636
192459,"void updateTokenInPlaceLocked(AppWindowToken wtoken,int transit){
  if (transit != AppTransition.TRANSIT_UNSET) {
    if (wtoken.mAppAnimator.animation == AppWindowAnimator.sDummyAnimation) {
      wtoken.mAppAnimator.animation=null;
    }
    applyAnimationLocked(wtoken,null,transit,false,false);
  }
}","void updateTokenInPlaceLocked(AppWindowToken wtoken,int transit){
  if (transit != AppTransition.TRANSIT_UNSET) {
    if (wtoken.mAppAnimator.animation == AppWindowAnimator.sDummyAnimation) {
      wtoken.mAppAnimator.setNullAnimation();
    }
    applyAnimationLocked(wtoken,null,transit,false,false);
  }
}",0.9575163398692812
192460,"@Override public void setAppVisibility(IBinder token,boolean visible){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
  AppWindowToken wtoken;
synchronized (mWindowMap) {
    wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Slog.w(TAG_WM,""String_Node_Str"" + token);
      return;
    }
    if (DEBUG_APP_TRANSITIONS || DEBUG_ORIENTATION)     Slog.v(TAG_WM,""String_Node_Str"" + token + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mAppTransition+ ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ wtoken.hiddenRequested+ ""String_Node_Str""+ Debug.getCallers(6));
    mOpeningApps.remove(wtoken);
    mClosingApps.remove(wtoken);
    wtoken.waitingToShow=false;
    wtoken.hiddenRequested=!visible;
    if (!visible && wtoken.appDied) {
      wtoken.appDied=false;
      wtoken.removeAllWindows();
    }
 else     if (visible) {
      if (DEBUG_ADD_REMOVE)       Slog.v(TAG_WM,""String_Node_Str"" + wtoken);
      wtoken.mAppStopped=false;
      wtoken.setWindowsExiting(false);
      mOpeningApps.add(wtoken);
      wtoken.startingMoved=false;
      if (wtoken.hidden) {
        wtoken.allDrawn=false;
        wtoken.deferClearAllDrawn=false;
        wtoken.waitingToShow=true;
        if (wtoken.clientHidden) {
          wtoken.clientHidden=false;
          wtoken.sendAppVisibilityToClients();
        }
      }
    }
    if (okToDisplay() && mAppTransition.isTransitionSet()) {
      if (!wtoken.mAppAnimator.usingTransferredAnimation && (!wtoken.startingDisplayed || mSkipAppTransitionAnimation)) {
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG_WM,""String_Node_Str"" + wtoken);
        wtoken.mAppAnimator.setDummyAnimation();
      }
      wtoken.inPendingTransaction=true;
      if (visible) {
        wtoken.mEnteringAnimation=true;
      }
 else {
        wtoken.setWindowsExiting(true);
        mClosingApps.add(wtoken);
        wtoken.mEnteringAnimation=false;
      }
      if (mAppTransition.getAppTransition() == AppTransition.TRANSIT_TASK_OPEN_BEHIND) {
        final WindowState win=findFocusedWindowLocked(getDefaultDisplayContentLocked());
        if (win != null) {
          final AppWindowToken focusedToken=win.mAppToken;
          if (focusedToken != null) {
            if (DEBUG_APP_TRANSITIONS)             Slog.d(TAG_WM,""String_Node_Str"" + ""String_Node_Str"" + focusedToken + ""String_Node_Str"");
            focusedToken.hidden=true;
            mOpeningApps.add(focusedToken);
          }
        }
      }
      return;
    }
    final long origId=Binder.clearCallingIdentity();
    wtoken.inPendingTransaction=false;
    setTokenVisibilityLocked(wtoken,null,visible,AppTransition.TRANSIT_UNSET,true,wtoken.voiceInteraction);
    wtoken.updateReportedVisibilityLocked();
    Binder.restoreCallingIdentity(origId);
  }
}","@Override public void setAppVisibility(IBinder token,boolean visible){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
  AppWindowToken wtoken;
synchronized (mWindowMap) {
    wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Slog.w(TAG_WM,""String_Node_Str"" + token);
      return;
    }
    if (DEBUG_APP_TRANSITIONS || DEBUG_ORIENTATION)     Slog.v(TAG_WM,""String_Node_Str"" + token + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mAppTransition+ ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ wtoken.hiddenRequested+ ""String_Node_Str""+ Debug.getCallers(6));
    mOpeningApps.remove(wtoken);
    mClosingApps.remove(wtoken);
    wtoken.waitingToShow=false;
    wtoken.hiddenRequested=!visible;
    if (!visible && wtoken.appDied) {
      wtoken.appDied=false;
      wtoken.removeAllWindows();
    }
 else     if (visible) {
      if (DEBUG_ADD_REMOVE)       Slog.v(TAG_WM,""String_Node_Str"" + wtoken);
      wtoken.mAppStopped=false;
      mOpeningApps.add(wtoken);
      wtoken.startingMoved=false;
      if (wtoken.hidden) {
        wtoken.allDrawn=false;
        wtoken.deferClearAllDrawn=false;
        wtoken.waitingToShow=true;
        if (wtoken.clientHidden) {
          wtoken.clientHidden=false;
          wtoken.sendAppVisibilityToClients();
        }
      }
    }
    if (okToDisplay() && mAppTransition.isTransitionSet()) {
      if (wtoken.mAppAnimator.usingTransferredAnimation && wtoken.mAppAnimator.animation == null) {
        Slog.wtf(TAG_WM,""String_Node_Str"" + wtoken + ""String_Node_Str"");
      }
      if (!wtoken.mAppAnimator.usingTransferredAnimation && (!wtoken.startingDisplayed || mSkipAppTransitionAnimation)) {
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG_WM,""String_Node_Str"" + wtoken);
        wtoken.mAppAnimator.setDummyAnimation();
      }
      wtoken.inPendingTransaction=true;
      if (visible) {
        wtoken.mEnteringAnimation=true;
      }
 else {
        mClosingApps.add(wtoken);
        wtoken.mEnteringAnimation=false;
      }
      if (mAppTransition.getAppTransition() == AppTransition.TRANSIT_TASK_OPEN_BEHIND) {
        final WindowState win=findFocusedWindowLocked(getDefaultDisplayContentLocked());
        if (win != null) {
          final AppWindowToken focusedToken=win.mAppToken;
          if (focusedToken != null) {
            if (DEBUG_APP_TRANSITIONS)             Slog.d(TAG_WM,""String_Node_Str"" + ""String_Node_Str"" + focusedToken + ""String_Node_Str"");
            focusedToken.hidden=true;
            mOpeningApps.add(focusedToken);
          }
        }
      }
      return;
    }
    final long origId=Binder.clearCallingIdentity();
    wtoken.inPendingTransaction=false;
    setTokenVisibilityLocked(wtoken,null,visible,AppTransition.TRANSIT_UNSET,true,wtoken.voiceInteraction);
    wtoken.updateReportedVisibilityLocked();
    Binder.restoreCallingIdentity(origId);
  }
}",0.9556162512803004
192461,"private boolean tryStartExitingAnimation(WindowState win,WindowStateAnimator winAnimator,boolean isDefaultDisplay,boolean focusMayChange){
  int transit=WindowManagerPolicy.TRANSIT_EXIT;
  if (win.mAttrs.type == TYPE_APPLICATION_STARTING) {
    transit=WindowManagerPolicy.TRANSIT_PREVIEW_DONE;
  }
  if (win.isWinVisibleLw() && winAnimator.applyAnimationLocked(transit,false)) {
    focusMayChange=isDefaultDisplay;
    win.mAnimatingExit=true;
  }
 else   if (win.mWinAnimator.isAnimating()) {
    win.mAnimatingExit=true;
  }
 else   if (mWallpaperControllerLocked.isWallpaperTarget(win)) {
    win.mAnimatingExit=true;
    win.mWinAnimator.mAnimating=true;
  }
 else {
    if (mInputMethodWindow == win) {
      mInputMethodWindow=null;
    }
    win.destroyOrSaveSurface();
  }
  if (mAccessibilityController != null && win.getDisplayId() == Display.DEFAULT_DISPLAY) {
    mAccessibilityController.onWindowTransitionLocked(win,transit);
  }
  return focusMayChange;
}","private boolean tryStartExitingAnimation(WindowState win,WindowStateAnimator winAnimator,boolean isDefaultDisplay,boolean focusMayChange){
  int transit=WindowManagerPolicy.TRANSIT_EXIT;
  if (win.mAttrs.type == TYPE_APPLICATION_STARTING) {
    transit=WindowManagerPolicy.TRANSIT_PREVIEW_DONE;
  }
  if (win.isWinVisibleLw() && winAnimator.applyAnimationLocked(transit,false)) {
    focusMayChange=isDefaultDisplay;
    win.mAnimatingExit=true;
    win.mWinAnimator.mAnimating=true;
  }
 else   if (win.mWinAnimator.isAnimating()) {
    win.mAnimatingExit=true;
    win.mWinAnimator.mAnimating=true;
  }
 else   if (mWallpaperControllerLocked.isWallpaperTarget(win)) {
    win.mAnimatingExit=true;
    win.mWinAnimator.mAnimating=true;
  }
 else {
    if (mInputMethodWindow == win) {
      mInputMethodWindow=null;
    }
    win.destroyOrSaveSurface();
  }
  if (mAccessibilityController != null && win.getDisplayId() == Display.DEFAULT_DISPLAY) {
    mAccessibilityController.onWindowTransitionLocked(win,transit);
  }
  return focusMayChange;
}",0.9623762376237625
192462,"private AppWindowToken handleOpeningApps(int transit,LayoutParams animLp,boolean voiceInteraction,int topClosingLayer){
  AppWindowToken topOpeningApp=null;
  final int appsCount=mService.mOpeningApps.size();
  for (int i=0; i < appsCount; i++) {
    AppWindowToken wtoken=mService.mOpeningApps.valueAt(i);
    final AppWindowAnimator appAnimator=wtoken.mAppAnimator;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    if (!appAnimator.usingTransferredAnimation) {
      appAnimator.clearThumbnail();
      appAnimator.animation=null;
    }
    wtoken.inPendingTransaction=false;
    if (!mService.setTokenVisibilityLocked(wtoken,animLp,true,transit,false,voiceInteraction)) {
      mService.mNoAnimationNotifyOnTransitionFinished.add(wtoken.token);
    }
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    appAnimator.mAllAppWinAnimators.clear();
    final int windowsCount=wtoken.allAppWindows.size();
    for (int j=0; j < windowsCount; j++) {
      appAnimator.mAllAppWinAnimators.add(wtoken.allAppWindows.get(j).mWinAnimator);
    }
    if (SHOW_LIGHT_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"");
    SurfaceControl.openTransaction();
    try {
      mService.mAnimator.orAnimating(appAnimator.showAllWindowsLocked());
    }
  finally {
      SurfaceControl.closeTransaction();
      if (SHOW_LIGHT_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"");
    }
    mService.mAnimator.mAppWindowAnimating|=appAnimator.isAnimating();
    int topOpeningLayer=0;
    if (animLp != null) {
      int layer=-1;
      for (int j=0; j < wtoken.windows.size(); j++) {
        final WindowState win=wtoken.windows.get(j);
        if (!win.mWillReplaceWindow && !win.mRemoveOnExit) {
          win.mAnimatingExit=false;
        }
        if (win.mWinAnimator.mAnimLayer > layer) {
          layer=win.mWinAnimator.mAnimLayer;
        }
      }
      if (topOpeningApp == null || layer > topOpeningLayer) {
        topOpeningApp=wtoken;
        topOpeningLayer=layer;
      }
    }
    if (mService.mAppTransition.isNextAppTransitionThumbnailUp()) {
      createThumbnailAppAnimator(transit,wtoken,topOpeningLayer,topClosingLayer);
    }
  }
  return topOpeningApp;
}","private AppWindowToken handleOpeningApps(int transit,LayoutParams animLp,boolean voiceInteraction,int topClosingLayer){
  AppWindowToken topOpeningApp=null;
  final int appsCount=mService.mOpeningApps.size();
  for (int i=0; i < appsCount; i++) {
    AppWindowToken wtoken=mService.mOpeningApps.valueAt(i);
    final AppWindowAnimator appAnimator=wtoken.mAppAnimator;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    if (!appAnimator.usingTransferredAnimation) {
      appAnimator.clearThumbnail();
      appAnimator.setNullAnimation();
    }
    wtoken.inPendingTransaction=false;
    if (!mService.setTokenVisibilityLocked(wtoken,animLp,true,transit,false,voiceInteraction)) {
      mService.mNoAnimationNotifyOnTransitionFinished.add(wtoken.token);
    }
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    appAnimator.mAllAppWinAnimators.clear();
    final int windowsCount=wtoken.allAppWindows.size();
    for (int j=0; j < windowsCount; j++) {
      appAnimator.mAllAppWinAnimators.add(wtoken.allAppWindows.get(j).mWinAnimator);
    }
    if (SHOW_LIGHT_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"");
    SurfaceControl.openTransaction();
    try {
      mService.mAnimator.orAnimating(appAnimator.showAllWindowsLocked());
    }
  finally {
      SurfaceControl.closeTransaction();
      if (SHOW_LIGHT_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"");
    }
    mService.mAnimator.mAppWindowAnimating|=appAnimator.isAnimating();
    int topOpeningLayer=0;
    if (animLp != null) {
      int layer=-1;
      for (int j=0; j < wtoken.windows.size(); j++) {
        final WindowState win=wtoken.windows.get(j);
        if (!win.mWillReplaceWindow && !win.mRemoveOnExit) {
          win.mAnimatingExit=false;
        }
        if (win.mWinAnimator.mAnimLayer > layer) {
          layer=win.mWinAnimator.mAnimLayer;
        }
      }
      if (topOpeningApp == null || layer > topOpeningLayer) {
        topOpeningApp=wtoken;
        topOpeningLayer=layer;
      }
    }
    if (mService.mAppTransition.isNextAppTransitionThumbnailUp()) {
      createThumbnailAppAnimator(transit,wtoken,topOpeningLayer,topClosingLayer);
    }
  }
  return topOpeningApp;
}",0.9941415051825148
192463,"private void handleClosingApps(int transit,LayoutParams animLp,boolean voiceInteraction,LayerAndToken layerAndToken){
  final int appsCount;
  appsCount=mService.mClosingApps.size();
  for (int i=0; i < appsCount; i++) {
    AppWindowToken wtoken=mService.mClosingApps.valueAt(i);
    final AppWindowAnimator appAnimator=wtoken.mAppAnimator;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    appAnimator.clearThumbnail();
    appAnimator.animation=null;
    wtoken.inPendingTransaction=false;
    mService.setTokenVisibilityLocked(wtoken,animLp,false,transit,false,voiceInteraction);
    wtoken.updateReportedVisibilityLocked();
    wtoken.allDrawn=true;
    wtoken.deferClearAllDrawn=false;
    if (wtoken.startingWindow != null && !wtoken.startingWindow.mAnimatingExit) {
      mService.scheduleRemoveStartingWindowLocked(wtoken);
    }
    mService.mAnimator.mAppWindowAnimating|=appAnimator.isAnimating();
    if (animLp != null) {
      int layer=-1;
      for (int j=0; j < wtoken.windows.size(); j++) {
        WindowState win=wtoken.windows.get(j);
        if (win.mWinAnimator.mAnimLayer > layer) {
          layer=win.mWinAnimator.mAnimLayer;
        }
      }
      if (layerAndToken.token == null || layer > layerAndToken.layer) {
        layerAndToken.token=wtoken;
        layerAndToken.layer=layer;
      }
    }
    if (mService.mAppTransition.isNextAppTransitionThumbnailDown()) {
      createThumbnailAppAnimator(transit,wtoken,0,layerAndToken.layer);
    }
  }
}","private void handleClosingApps(int transit,LayoutParams animLp,boolean voiceInteraction,LayerAndToken layerAndToken){
  final int appsCount;
  appsCount=mService.mClosingApps.size();
  for (int i=0; i < appsCount; i++) {
    AppWindowToken wtoken=mService.mClosingApps.valueAt(i);
    final AppWindowAnimator appAnimator=wtoken.mAppAnimator;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    appAnimator.clearThumbnail();
    appAnimator.setNullAnimation();
    wtoken.inPendingTransaction=false;
    mService.setTokenVisibilityLocked(wtoken,animLp,false,transit,false,voiceInteraction);
    wtoken.updateReportedVisibilityLocked();
    wtoken.allDrawn=true;
    wtoken.deferClearAllDrawn=false;
    if (wtoken.startingWindow != null && !wtoken.startingWindow.mAnimatingExit) {
      mService.scheduleRemoveStartingWindowLocked(wtoken);
    }
    mService.mAnimator.mAppWindowAnimating|=appAnimator.isAnimating();
    if (animLp != null) {
      int layer=-1;
      for (int j=0; j < wtoken.windows.size(); j++) {
        WindowState win=wtoken.windows.get(j);
        if (win.mWinAnimator.mAnimLayer > layer) {
          layer=win.mWinAnimator.mAnimLayer;
        }
      }
      if (layerAndToken.token == null || layer > layerAndToken.layer) {
        layerAndToken.token=wtoken;
        layerAndToken.layer=layer;
      }
    }
    if (mService.mAppTransition.isNextAppTransitionThumbnailDown()) {
      createThumbnailAppAnimator(transit,wtoken,0,layerAndToken.layer);
    }
  }
}",0.9914021164021164
192464,"private void processApplicationsAnimatingInPlace(int transit){
  if (transit == AppTransition.TRANSIT_TASK_IN_PLACE) {
    final WindowState win=mService.findFocusedWindowLocked(mService.getDefaultDisplayContentLocked());
    if (win != null) {
      final AppWindowToken wtoken=win.mAppToken;
      final AppWindowAnimator appAnimator=wtoken.mAppAnimator;
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + wtoken);
      appAnimator.clearThumbnail();
      appAnimator.animation=null;
      mService.updateTokenInPlaceLocked(wtoken,transit);
      wtoken.updateReportedVisibilityLocked();
      appAnimator.mAllAppWinAnimators.clear();
      final int N=wtoken.allAppWindows.size();
      for (int j=0; j < N; j++) {
        appAnimator.mAllAppWinAnimators.add(wtoken.allAppWindows.get(j).mWinAnimator);
      }
      mService.mAnimator.mAppWindowAnimating|=appAnimator.isAnimating();
      mService.mAnimator.orAnimating(appAnimator.showAllWindowsLocked());
    }
  }
}","private void processApplicationsAnimatingInPlace(int transit){
  if (transit == AppTransition.TRANSIT_TASK_IN_PLACE) {
    final WindowState win=mService.findFocusedWindowLocked(mService.getDefaultDisplayContentLocked());
    if (win != null) {
      final AppWindowToken wtoken=win.mAppToken;
      final AppWindowAnimator appAnimator=wtoken.mAppAnimator;
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + wtoken);
      appAnimator.clearThumbnail();
      appAnimator.setNullAnimation();
      mService.updateTokenInPlaceLocked(wtoken,transit);
      wtoken.updateReportedVisibilityLocked();
      appAnimator.mAllAppWinAnimators.clear();
      final int N=wtoken.allAppWindows.size();
      for (int j=0; j < N; j++) {
        appAnimator.mAllAppWinAnimators.add(wtoken.allAppWindows.get(j).mWinAnimator);
      }
      mService.mAnimator.mAppWindowAnimating|=appAnimator.isAnimating();
      mService.mAnimator.orAnimating(appAnimator.showAllWindowsLocked());
    }
  }
}",0.9869083585095668
192465,"public void clearAnimation(){
  if (animation != null) {
    animation=null;
    animating=true;
  }
  clearThumbnail();
  if (mAppToken.deferClearAllDrawn) {
    mAppToken.allDrawn=false;
    mAppToken.deferClearAllDrawn=false;
  }
  usingTransferredAnimation=false;
}","public void clearAnimation(){
  if (animation != null) {
    animating=true;
  }
  clearThumbnail();
  setNullAnimation();
  if (mAppToken.deferClearAllDrawn) {
    mAppToken.allDrawn=false;
    mAppToken.deferClearAllDrawn=false;
  }
}",0.8475247524752475
192466,"private boolean stepAnimation(long currentTime){
  if (animation == null) {
    return false;
  }
  transformation.clear();
  final long animationFrameTime=getAnimationFrameTime(animation,currentTime);
  boolean hasMoreFrames=animation.getTransformation(animationFrameTime,transformation);
  if (!hasMoreFrames) {
    if (deferThumbnailDestruction && !deferFinalFrameCleanup) {
      deferFinalFrameCleanup=true;
      hasMoreFrames=true;
    }
 else {
      if (false && DEBUG_ANIM)       Slog.v(TAG,""String_Node_Str"" + mAppToken + ""String_Node_Str""+ hasMoreFrames+ ""String_Node_Str""+ transformation+ ""String_Node_Str""+ mProlongAnimation);
      deferFinalFrameCleanup=false;
      if (mProlongAnimation == PROLONG_ANIMATION_AT_END) {
        hasMoreFrames=true;
      }
 else {
        animation=null;
        clearThumbnail();
        if (DEBUG_ANIM)         Slog.v(TAG,""String_Node_Str"" + mAppToken + ""String_Node_Str""+ currentTime);
      }
    }
  }
  hasTransformation=hasMoreFrames;
  return hasMoreFrames;
}","private boolean stepAnimation(long currentTime){
  if (animation == null) {
    return false;
  }
  transformation.clear();
  final long animationFrameTime=getAnimationFrameTime(animation,currentTime);
  boolean hasMoreFrames=animation.getTransformation(animationFrameTime,transformation);
  if (!hasMoreFrames) {
    if (deferThumbnailDestruction && !deferFinalFrameCleanup) {
      deferFinalFrameCleanup=true;
      hasMoreFrames=true;
    }
 else {
      if (false && DEBUG_ANIM)       Slog.v(TAG,""String_Node_Str"" + mAppToken + ""String_Node_Str""+ hasMoreFrames+ ""String_Node_Str""+ transformation+ ""String_Node_Str""+ mProlongAnimation);
      deferFinalFrameCleanup=false;
      if (mProlongAnimation == PROLONG_ANIMATION_AT_END) {
        hasMoreFrames=true;
      }
 else {
        setNullAnimation();
        clearThumbnail();
        if (DEBUG_ANIM)         Slog.v(TAG,""String_Node_Str"" + mAppToken + ""String_Node_Str""+ currentTime);
      }
    }
  }
  hasTransformation=hasMoreFrames;
  return hasMoreFrames;
}",0.9842829076620824
192467,"void transferCurrentAnimation(AppWindowAnimator toAppAnimator,WindowStateAnimator transferWinAnimator){
  if (animation != null) {
    toAppAnimator.animation=animation;
    animation=null;
    toAppAnimator.animating=animating;
    toAppAnimator.animLayerAdjustment=animLayerAdjustment;
    animLayerAdjustment=0;
    toAppAnimator.updateLayers();
    updateLayers();
    toAppAnimator.usingTransferredAnimation=true;
  }
  if (transferWinAnimator != null) {
    mAllAppWinAnimators.remove(transferWinAnimator);
    toAppAnimator.mAllAppWinAnimators.add(transferWinAnimator);
    transferWinAnimator.mAppAnimator=toAppAnimator;
  }
}","void transferCurrentAnimation(AppWindowAnimator toAppAnimator,WindowStateAnimator transferWinAnimator){
  if (animation != null) {
    toAppAnimator.animation=animation;
    toAppAnimator.animating=animating;
    toAppAnimator.animLayerAdjustment=animLayerAdjustment;
    setNullAnimation();
    animLayerAdjustment=0;
    toAppAnimator.updateLayers();
    updateLayers();
    toAppAnimator.usingTransferredAnimation=true;
  }
  if (transferWinAnimator != null) {
    mAllAppWinAnimators.remove(transferWinAnimator);
    toAppAnimator.mAllAppWinAnimators.add(transferWinAnimator);
    transferWinAnimator.mAppAnimator=toAppAnimator;
  }
}",0.9654088050314464
192468,"boolean setTokenVisibilityLocked(AppWindowToken wtoken,WindowManager.LayoutParams lp,boolean visible,int transit,boolean performLayout,boolean isVoiceInteraction){
  boolean delayed=false;
  if (wtoken.clientHidden == visible) {
    wtoken.clientHidden=!visible;
    wtoken.sendAppVisibilityToClients();
  }
  boolean visibilityChanged=false;
  if (wtoken.hidden == visible || (wtoken.hidden && wtoken.mIsExiting) || (visible && wtoken.waitingForReplacement())) {
    boolean changed=false;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG_WM,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ performLayout);
    boolean runningAppAnimation=false;
    if (transit != AppTransition.TRANSIT_UNSET) {
      if (wtoken.mAppAnimator.animation == AppWindowAnimator.sDummyAnimation) {
        wtoken.mAppAnimator.animation=null;
      }
      if (applyAnimationLocked(wtoken,lp,transit,visible,isVoiceInteraction)) {
        delayed=runningAppAnimation=true;
      }
      WindowState window=wtoken.findMainWindow();
      if (window != null && mAccessibilityController != null && window.getDisplayId() == Display.DEFAULT_DISPLAY) {
        mAccessibilityController.onAppWindowTransitionLocked(window,transit);
      }
      changed=true;
    }
    final int windowsCount=wtoken.allAppWindows.size();
    for (int i=0; i < windowsCount; i++) {
      WindowState win=wtoken.allAppWindows.get(i);
      if (win == wtoken.startingWindow) {
        continue;
      }
      if (visible) {
        if (!win.isVisibleNow()) {
          if (!runningAppAnimation) {
            win.mWinAnimator.applyAnimationLocked(WindowManagerPolicy.TRANSIT_ENTER,true);
            if (mAccessibilityController != null && win.getDisplayId() == Display.DEFAULT_DISPLAY) {
              mAccessibilityController.onWindowTransitionLocked(win,WindowManagerPolicy.TRANSIT_ENTER);
            }
          }
          changed=true;
          win.setDisplayLayoutNeeded();
        }
      }
 else       if (win.isVisibleNow()) {
        if (!runningAppAnimation) {
          win.mWinAnimator.applyAnimationLocked(WindowManagerPolicy.TRANSIT_EXIT,false);
          if (mAccessibilityController != null && win.getDisplayId() == Display.DEFAULT_DISPLAY) {
            mAccessibilityController.onWindowTransitionLocked(win,WindowManagerPolicy.TRANSIT_EXIT);
          }
        }
        changed=true;
        win.setDisplayLayoutNeeded();
      }
    }
    wtoken.hidden=wtoken.hiddenRequested=!visible;
    visibilityChanged=true;
    if (!visible) {
      unsetAppFreezingScreenLocked(wtoken,true,true);
    }
 else {
      WindowState swin=wtoken.startingWindow;
      if (swin != null && !swin.isDrawnLw()) {
        swin.mPolicyVisibility=false;
        swin.mPolicyVisibilityAfterAnim=false;
      }
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG_WM,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ wtoken.hiddenRequested);
    if (changed) {
      mInputMonitor.setUpdateInputWindowsNeededLw();
      if (performLayout) {
        updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES,false);
        mWindowPlacerLocked.performSurfacePlacement();
      }
      mInputMonitor.updateInputWindowsLw(false);
    }
  }
  if (wtoken.mAppAnimator.animation != null) {
    delayed=true;
  }
  for (int i=wtoken.allAppWindows.size() - 1; i >= 0 && !delayed; i--) {
    if (wtoken.allAppWindows.get(i).mWinAnimator.isWindowAnimating()) {
      delayed=true;
    }
  }
  if (visibilityChanged && !delayed) {
    if (visible) {
      wtoken.mEnteringAnimation=true;
      mActivityManagerAppTransitionNotifier.onAppTransitionFinishedLocked(wtoken.token);
    }
    getDefaultDisplayContentLocked().getDockedDividerController().notifyAppVisibilityChanged(wtoken,visible);
  }
  return delayed;
}","boolean setTokenVisibilityLocked(AppWindowToken wtoken,WindowManager.LayoutParams lp,boolean visible,int transit,boolean performLayout,boolean isVoiceInteraction){
  boolean delayed=false;
  if (wtoken.clientHidden == visible) {
    wtoken.clientHidden=!visible;
    wtoken.sendAppVisibilityToClients();
  }
  boolean visibilityChanged=false;
  if (wtoken.hidden == visible || (wtoken.hidden && wtoken.mIsExiting) || (visible && wtoken.waitingForReplacement())) {
    boolean changed=false;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG_WM,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ performLayout);
    boolean runningAppAnimation=false;
    if (transit != AppTransition.TRANSIT_UNSET) {
      if (wtoken.mAppAnimator.animation == AppWindowAnimator.sDummyAnimation) {
        wtoken.mAppAnimator.setNullAnimation();
      }
      if (applyAnimationLocked(wtoken,lp,transit,visible,isVoiceInteraction)) {
        delayed=runningAppAnimation=true;
      }
      WindowState window=wtoken.findMainWindow();
      if (window != null && mAccessibilityController != null && window.getDisplayId() == Display.DEFAULT_DISPLAY) {
        mAccessibilityController.onAppWindowTransitionLocked(window,transit);
      }
      changed=true;
    }
    final int windowsCount=wtoken.allAppWindows.size();
    for (int i=0; i < windowsCount; i++) {
      WindowState win=wtoken.allAppWindows.get(i);
      if (win == wtoken.startingWindow) {
        continue;
      }
      if (visible) {
        if (!win.isVisibleNow()) {
          if (!runningAppAnimation) {
            win.mWinAnimator.applyAnimationLocked(WindowManagerPolicy.TRANSIT_ENTER,true);
            if (mAccessibilityController != null && win.getDisplayId() == Display.DEFAULT_DISPLAY) {
              mAccessibilityController.onWindowTransitionLocked(win,WindowManagerPolicy.TRANSIT_ENTER);
            }
          }
          changed=true;
          win.setDisplayLayoutNeeded();
        }
      }
 else       if (win.isVisibleNow()) {
        if (!runningAppAnimation) {
          win.mWinAnimator.applyAnimationLocked(WindowManagerPolicy.TRANSIT_EXIT,false);
          if (mAccessibilityController != null && win.getDisplayId() == Display.DEFAULT_DISPLAY) {
            mAccessibilityController.onWindowTransitionLocked(win,WindowManagerPolicy.TRANSIT_EXIT);
          }
        }
        changed=true;
        win.setDisplayLayoutNeeded();
      }
    }
    wtoken.hidden=wtoken.hiddenRequested=!visible;
    visibilityChanged=true;
    if (!visible) {
      unsetAppFreezingScreenLocked(wtoken,true,true);
    }
 else {
      WindowState swin=wtoken.startingWindow;
      if (swin != null && !swin.isDrawnLw()) {
        swin.mPolicyVisibility=false;
        swin.mPolicyVisibilityAfterAnim=false;
      }
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG_WM,""String_Node_Str"" + wtoken + ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ wtoken.hiddenRequested);
    if (changed) {
      mInputMonitor.setUpdateInputWindowsNeededLw();
      if (performLayout) {
        updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES,false);
        mWindowPlacerLocked.performSurfacePlacement();
      }
      mInputMonitor.updateInputWindowsLw(false);
    }
  }
  if (wtoken.mAppAnimator.animation != null) {
    delayed=true;
  }
  for (int i=wtoken.allAppWindows.size() - 1; i >= 0 && !delayed; i--) {
    if (wtoken.allAppWindows.get(i).mWinAnimator.isWindowAnimating()) {
      delayed=true;
    }
  }
  if (visibilityChanged && !delayed) {
    if (visible) {
      wtoken.mEnteringAnimation=true;
      mActivityManagerAppTransitionNotifier.onAppTransitionFinishedLocked(wtoken.token);
    }
    getDefaultDisplayContentLocked().getDockedDividerController().notifyAppVisibilityChanged(wtoken,visible);
  }
  return delayed;
}",0.9958148051268636
192469,"void updateTokenInPlaceLocked(AppWindowToken wtoken,int transit){
  if (transit != AppTransition.TRANSIT_UNSET) {
    if (wtoken.mAppAnimator.animation == AppWindowAnimator.sDummyAnimation) {
      wtoken.mAppAnimator.animation=null;
    }
    applyAnimationLocked(wtoken,null,transit,false,false);
  }
}","void updateTokenInPlaceLocked(AppWindowToken wtoken,int transit){
  if (transit != AppTransition.TRANSIT_UNSET) {
    if (wtoken.mAppAnimator.animation == AppWindowAnimator.sDummyAnimation) {
      wtoken.mAppAnimator.setNullAnimation();
    }
    applyAnimationLocked(wtoken,null,transit,false,false);
  }
}",0.9575163398692812
192470,"@Override public void setAppVisibility(IBinder token,boolean visible){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
  AppWindowToken wtoken;
synchronized (mWindowMap) {
    wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Slog.w(TAG_WM,""String_Node_Str"" + token);
      return;
    }
    if (DEBUG_APP_TRANSITIONS || DEBUG_ORIENTATION)     Slog.v(TAG_WM,""String_Node_Str"" + token + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mAppTransition+ ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ wtoken.hiddenRequested+ ""String_Node_Str""+ Debug.getCallers(6));
    mOpeningApps.remove(wtoken);
    mClosingApps.remove(wtoken);
    wtoken.waitingToShow=false;
    wtoken.hiddenRequested=!visible;
    if (!visible && wtoken.appDied) {
      wtoken.appDied=false;
      wtoken.removeAllWindows();
    }
 else     if (visible) {
      if (DEBUG_ADD_REMOVE)       Slog.v(TAG_WM,""String_Node_Str"" + wtoken);
      wtoken.mAppStopped=false;
      wtoken.setWindowsExiting(false);
      mOpeningApps.add(wtoken);
      wtoken.startingMoved=false;
      if (wtoken.hidden) {
        wtoken.allDrawn=false;
        wtoken.deferClearAllDrawn=false;
        wtoken.waitingToShow=true;
        if (wtoken.clientHidden) {
          wtoken.clientHidden=false;
          wtoken.sendAppVisibilityToClients();
        }
      }
    }
    if (okToDisplay() && mAppTransition.isTransitionSet()) {
      if (!wtoken.mAppAnimator.usingTransferredAnimation && (!wtoken.startingDisplayed || mSkipAppTransitionAnimation)) {
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG_WM,""String_Node_Str"" + wtoken);
        wtoken.mAppAnimator.setDummyAnimation();
      }
      wtoken.inPendingTransaction=true;
      if (visible) {
        wtoken.mEnteringAnimation=true;
      }
 else {
        wtoken.setWindowsExiting(true);
        mClosingApps.add(wtoken);
        wtoken.mEnteringAnimation=false;
      }
      if (mAppTransition.getAppTransition() == AppTransition.TRANSIT_TASK_OPEN_BEHIND) {
        final WindowState win=findFocusedWindowLocked(getDefaultDisplayContentLocked());
        if (win != null) {
          final AppWindowToken focusedToken=win.mAppToken;
          if (focusedToken != null) {
            if (DEBUG_APP_TRANSITIONS)             Slog.d(TAG_WM,""String_Node_Str"" + ""String_Node_Str"" + focusedToken + ""String_Node_Str"");
            focusedToken.hidden=true;
            mOpeningApps.add(focusedToken);
          }
        }
      }
      return;
    }
    final long origId=Binder.clearCallingIdentity();
    wtoken.inPendingTransaction=false;
    setTokenVisibilityLocked(wtoken,null,visible,AppTransition.TRANSIT_UNSET,true,wtoken.voiceInteraction);
    wtoken.updateReportedVisibilityLocked();
    Binder.restoreCallingIdentity(origId);
  }
}","@Override public void setAppVisibility(IBinder token,boolean visible){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
  AppWindowToken wtoken;
synchronized (mWindowMap) {
    wtoken=findAppWindowToken(token);
    if (wtoken == null) {
      Slog.w(TAG_WM,""String_Node_Str"" + token);
      return;
    }
    if (DEBUG_APP_TRANSITIONS || DEBUG_ORIENTATION)     Slog.v(TAG_WM,""String_Node_Str"" + token + ""String_Node_Str""+ visible+ ""String_Node_Str""+ mAppTransition+ ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ wtoken.hiddenRequested+ ""String_Node_Str""+ Debug.getCallers(6));
    mOpeningApps.remove(wtoken);
    mClosingApps.remove(wtoken);
    wtoken.waitingToShow=false;
    wtoken.hiddenRequested=!visible;
    if (!visible && wtoken.appDied) {
      wtoken.appDied=false;
      wtoken.removeAllWindows();
    }
 else     if (visible) {
      if (DEBUG_ADD_REMOVE)       Slog.v(TAG_WM,""String_Node_Str"" + wtoken);
      wtoken.mAppStopped=false;
      mOpeningApps.add(wtoken);
      wtoken.startingMoved=false;
      if (wtoken.hidden) {
        wtoken.allDrawn=false;
        wtoken.deferClearAllDrawn=false;
        wtoken.waitingToShow=true;
        if (wtoken.clientHidden) {
          wtoken.clientHidden=false;
          wtoken.sendAppVisibilityToClients();
        }
      }
    }
    if (okToDisplay() && mAppTransition.isTransitionSet()) {
      if (wtoken.mAppAnimator.usingTransferredAnimation && wtoken.mAppAnimator.animation == null) {
        Slog.wtf(TAG_WM,""String_Node_Str"" + wtoken + ""String_Node_Str"");
      }
      if (!wtoken.mAppAnimator.usingTransferredAnimation && (!wtoken.startingDisplayed || mSkipAppTransitionAnimation)) {
        if (DEBUG_APP_TRANSITIONS)         Slog.v(TAG_WM,""String_Node_Str"" + wtoken);
        wtoken.mAppAnimator.setDummyAnimation();
      }
      wtoken.inPendingTransaction=true;
      if (visible) {
        wtoken.mEnteringAnimation=true;
      }
 else {
        mClosingApps.add(wtoken);
        wtoken.mEnteringAnimation=false;
      }
      if (mAppTransition.getAppTransition() == AppTransition.TRANSIT_TASK_OPEN_BEHIND) {
        final WindowState win=findFocusedWindowLocked(getDefaultDisplayContentLocked());
        if (win != null) {
          final AppWindowToken focusedToken=win.mAppToken;
          if (focusedToken != null) {
            if (DEBUG_APP_TRANSITIONS)             Slog.d(TAG_WM,""String_Node_Str"" + ""String_Node_Str"" + focusedToken + ""String_Node_Str"");
            focusedToken.hidden=true;
            mOpeningApps.add(focusedToken);
          }
        }
      }
      return;
    }
    final long origId=Binder.clearCallingIdentity();
    wtoken.inPendingTransaction=false;
    setTokenVisibilityLocked(wtoken,null,visible,AppTransition.TRANSIT_UNSET,true,wtoken.voiceInteraction);
    wtoken.updateReportedVisibilityLocked();
    Binder.restoreCallingIdentity(origId);
  }
}",0.9556162512803004
192471,"private boolean tryStartExitingAnimation(WindowState win,WindowStateAnimator winAnimator,boolean isDefaultDisplay,boolean focusMayChange){
  int transit=WindowManagerPolicy.TRANSIT_EXIT;
  if (win.mAttrs.type == TYPE_APPLICATION_STARTING) {
    transit=WindowManagerPolicy.TRANSIT_PREVIEW_DONE;
  }
  if (win.isWinVisibleLw() && winAnimator.applyAnimationLocked(transit,false)) {
    focusMayChange=isDefaultDisplay;
    win.mAnimatingExit=true;
  }
 else   if (win.mWinAnimator.isAnimating()) {
    win.mAnimatingExit=true;
  }
 else   if (mWallpaperControllerLocked.isWallpaperTarget(win)) {
    win.mAnimatingExit=true;
    win.mWinAnimator.mAnimating=true;
  }
 else {
    if (mInputMethodWindow == win) {
      mInputMethodWindow=null;
    }
    win.destroyOrSaveSurface();
  }
  if (mAccessibilityController != null && win.getDisplayId() == Display.DEFAULT_DISPLAY) {
    mAccessibilityController.onWindowTransitionLocked(win,transit);
  }
  return focusMayChange;
}","private boolean tryStartExitingAnimation(WindowState win,WindowStateAnimator winAnimator,boolean isDefaultDisplay,boolean focusMayChange){
  int transit=WindowManagerPolicy.TRANSIT_EXIT;
  if (win.mAttrs.type == TYPE_APPLICATION_STARTING) {
    transit=WindowManagerPolicy.TRANSIT_PREVIEW_DONE;
  }
  if (win.isWinVisibleLw() && winAnimator.applyAnimationLocked(transit,false)) {
    focusMayChange=isDefaultDisplay;
    win.mAnimatingExit=true;
    win.mWinAnimator.mAnimating=true;
  }
 else   if (win.mWinAnimator.isAnimating()) {
    win.mAnimatingExit=true;
    win.mWinAnimator.mAnimating=true;
  }
 else   if (mWallpaperControllerLocked.isWallpaperTarget(win)) {
    win.mAnimatingExit=true;
    win.mWinAnimator.mAnimating=true;
  }
 else {
    if (mInputMethodWindow == win) {
      mInputMethodWindow=null;
    }
    win.destroyOrSaveSurface();
  }
  if (mAccessibilityController != null && win.getDisplayId() == Display.DEFAULT_DISPLAY) {
    mAccessibilityController.onWindowTransitionLocked(win,transit);
  }
  return focusMayChange;
}",0.9623762376237625
192472,"private AppWindowToken handleOpeningApps(int transit,LayoutParams animLp,boolean voiceInteraction,int topClosingLayer){
  AppWindowToken topOpeningApp=null;
  final int appsCount=mService.mOpeningApps.size();
  for (int i=0; i < appsCount; i++) {
    AppWindowToken wtoken=mService.mOpeningApps.valueAt(i);
    final AppWindowAnimator appAnimator=wtoken.mAppAnimator;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    if (!appAnimator.usingTransferredAnimation) {
      appAnimator.clearThumbnail();
      appAnimator.animation=null;
    }
    wtoken.inPendingTransaction=false;
    if (!mService.setTokenVisibilityLocked(wtoken,animLp,true,transit,false,voiceInteraction)) {
      mService.mNoAnimationNotifyOnTransitionFinished.add(wtoken.token);
    }
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    appAnimator.mAllAppWinAnimators.clear();
    final int windowsCount=wtoken.allAppWindows.size();
    for (int j=0; j < windowsCount; j++) {
      appAnimator.mAllAppWinAnimators.add(wtoken.allAppWindows.get(j).mWinAnimator);
    }
    if (SHOW_LIGHT_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"");
    SurfaceControl.openTransaction();
    try {
      mService.mAnimator.orAnimating(appAnimator.showAllWindowsLocked());
    }
  finally {
      SurfaceControl.closeTransaction();
      if (SHOW_LIGHT_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"");
    }
    mService.mAnimator.mAppWindowAnimating|=appAnimator.isAnimating();
    int topOpeningLayer=0;
    if (animLp != null) {
      int layer=-1;
      for (int j=0; j < wtoken.windows.size(); j++) {
        final WindowState win=wtoken.windows.get(j);
        if (!win.mWillReplaceWindow && !win.mRemoveOnExit) {
          win.mAnimatingExit=false;
        }
        if (win.mWinAnimator.mAnimLayer > layer) {
          layer=win.mWinAnimator.mAnimLayer;
        }
      }
      if (topOpeningApp == null || layer > topOpeningLayer) {
        topOpeningApp=wtoken;
        topOpeningLayer=layer;
      }
    }
    if (mService.mAppTransition.isNextAppTransitionThumbnailUp()) {
      createThumbnailAppAnimator(transit,wtoken,topOpeningLayer,topClosingLayer);
    }
  }
  return topOpeningApp;
}","private AppWindowToken handleOpeningApps(int transit,LayoutParams animLp,boolean voiceInteraction,int topClosingLayer){
  AppWindowToken topOpeningApp=null;
  final int appsCount=mService.mOpeningApps.size();
  for (int i=0; i < appsCount; i++) {
    AppWindowToken wtoken=mService.mOpeningApps.valueAt(i);
    final AppWindowAnimator appAnimator=wtoken.mAppAnimator;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    if (!appAnimator.usingTransferredAnimation) {
      appAnimator.clearThumbnail();
      appAnimator.setNullAnimation();
    }
    wtoken.inPendingTransaction=false;
    if (!mService.setTokenVisibilityLocked(wtoken,animLp,true,transit,false,voiceInteraction)) {
      mService.mNoAnimationNotifyOnTransitionFinished.add(wtoken.token);
    }
    wtoken.updateReportedVisibilityLocked();
    wtoken.waitingToShow=false;
    appAnimator.mAllAppWinAnimators.clear();
    final int windowsCount=wtoken.allAppWindows.size();
    for (int j=0; j < windowsCount; j++) {
      appAnimator.mAllAppWinAnimators.add(wtoken.allAppWindows.get(j).mWinAnimator);
    }
    if (SHOW_LIGHT_TRANSACTIONS)     Slog.i(TAG,""String_Node_Str"");
    SurfaceControl.openTransaction();
    try {
      mService.mAnimator.orAnimating(appAnimator.showAllWindowsLocked());
    }
  finally {
      SurfaceControl.closeTransaction();
      if (SHOW_LIGHT_TRANSACTIONS)       Slog.i(TAG,""String_Node_Str"");
    }
    mService.mAnimator.mAppWindowAnimating|=appAnimator.isAnimating();
    int topOpeningLayer=0;
    if (animLp != null) {
      int layer=-1;
      for (int j=0; j < wtoken.windows.size(); j++) {
        final WindowState win=wtoken.windows.get(j);
        if (!win.mWillReplaceWindow && !win.mRemoveOnExit) {
          win.mAnimatingExit=false;
        }
        if (win.mWinAnimator.mAnimLayer > layer) {
          layer=win.mWinAnimator.mAnimLayer;
        }
      }
      if (topOpeningApp == null || layer > topOpeningLayer) {
        topOpeningApp=wtoken;
        topOpeningLayer=layer;
      }
    }
    if (mService.mAppTransition.isNextAppTransitionThumbnailUp()) {
      createThumbnailAppAnimator(transit,wtoken,topOpeningLayer,topClosingLayer);
    }
  }
  return topOpeningApp;
}",0.9941415051825148
192473,"private void handleClosingApps(int transit,LayoutParams animLp,boolean voiceInteraction,LayerAndToken layerAndToken){
  final int appsCount;
  appsCount=mService.mClosingApps.size();
  for (int i=0; i < appsCount; i++) {
    AppWindowToken wtoken=mService.mClosingApps.valueAt(i);
    final AppWindowAnimator appAnimator=wtoken.mAppAnimator;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    appAnimator.clearThumbnail();
    appAnimator.animation=null;
    wtoken.inPendingTransaction=false;
    mService.setTokenVisibilityLocked(wtoken,animLp,false,transit,false,voiceInteraction);
    wtoken.updateReportedVisibilityLocked();
    wtoken.allDrawn=true;
    wtoken.deferClearAllDrawn=false;
    if (wtoken.startingWindow != null && !wtoken.startingWindow.mAnimatingExit) {
      mService.scheduleRemoveStartingWindowLocked(wtoken);
    }
    mService.mAnimator.mAppWindowAnimating|=appAnimator.isAnimating();
    if (animLp != null) {
      int layer=-1;
      for (int j=0; j < wtoken.windows.size(); j++) {
        WindowState win=wtoken.windows.get(j);
        if (win.mWinAnimator.mAnimLayer > layer) {
          layer=win.mWinAnimator.mAnimLayer;
        }
      }
      if (layerAndToken.token == null || layer > layerAndToken.layer) {
        layerAndToken.token=wtoken;
        layerAndToken.layer=layer;
      }
    }
    if (mService.mAppTransition.isNextAppTransitionThumbnailDown()) {
      createThumbnailAppAnimator(transit,wtoken,0,layerAndToken.layer);
    }
  }
}","private void handleClosingApps(int transit,LayoutParams animLp,boolean voiceInteraction,LayerAndToken layerAndToken){
  final int appsCount;
  appsCount=mService.mClosingApps.size();
  for (int i=0; i < appsCount; i++) {
    AppWindowToken wtoken=mService.mClosingApps.valueAt(i);
    final AppWindowAnimator appAnimator=wtoken.mAppAnimator;
    if (DEBUG_APP_TRANSITIONS)     Slog.v(TAG,""String_Node_Str"" + wtoken);
    appAnimator.clearThumbnail();
    appAnimator.setNullAnimation();
    wtoken.inPendingTransaction=false;
    mService.setTokenVisibilityLocked(wtoken,animLp,false,transit,false,voiceInteraction);
    wtoken.updateReportedVisibilityLocked();
    wtoken.allDrawn=true;
    wtoken.deferClearAllDrawn=false;
    if (wtoken.startingWindow != null && !wtoken.startingWindow.mAnimatingExit) {
      mService.scheduleRemoveStartingWindowLocked(wtoken);
    }
    mService.mAnimator.mAppWindowAnimating|=appAnimator.isAnimating();
    if (animLp != null) {
      int layer=-1;
      for (int j=0; j < wtoken.windows.size(); j++) {
        WindowState win=wtoken.windows.get(j);
        if (win.mWinAnimator.mAnimLayer > layer) {
          layer=win.mWinAnimator.mAnimLayer;
        }
      }
      if (layerAndToken.token == null || layer > layerAndToken.layer) {
        layerAndToken.token=wtoken;
        layerAndToken.layer=layer;
      }
    }
    if (mService.mAppTransition.isNextAppTransitionThumbnailDown()) {
      createThumbnailAppAnimator(transit,wtoken,0,layerAndToken.layer);
    }
  }
}",0.9914021164021164
192474,"private void processApplicationsAnimatingInPlace(int transit){
  if (transit == AppTransition.TRANSIT_TASK_IN_PLACE) {
    final WindowState win=mService.findFocusedWindowLocked(mService.getDefaultDisplayContentLocked());
    if (win != null) {
      final AppWindowToken wtoken=win.mAppToken;
      final AppWindowAnimator appAnimator=wtoken.mAppAnimator;
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + wtoken);
      appAnimator.clearThumbnail();
      appAnimator.animation=null;
      mService.updateTokenInPlaceLocked(wtoken,transit);
      wtoken.updateReportedVisibilityLocked();
      appAnimator.mAllAppWinAnimators.clear();
      final int N=wtoken.allAppWindows.size();
      for (int j=0; j < N; j++) {
        appAnimator.mAllAppWinAnimators.add(wtoken.allAppWindows.get(j).mWinAnimator);
      }
      mService.mAnimator.mAppWindowAnimating|=appAnimator.isAnimating();
      mService.mAnimator.orAnimating(appAnimator.showAllWindowsLocked());
    }
  }
}","private void processApplicationsAnimatingInPlace(int transit){
  if (transit == AppTransition.TRANSIT_TASK_IN_PLACE) {
    final WindowState win=mService.findFocusedWindowLocked(mService.getDefaultDisplayContentLocked());
    if (win != null) {
      final AppWindowToken wtoken=win.mAppToken;
      final AppWindowAnimator appAnimator=wtoken.mAppAnimator;
      if (DEBUG_APP_TRANSITIONS)       Slog.v(TAG,""String_Node_Str"" + wtoken);
      appAnimator.clearThumbnail();
      appAnimator.setNullAnimation();
      mService.updateTokenInPlaceLocked(wtoken,transit);
      wtoken.updateReportedVisibilityLocked();
      appAnimator.mAllAppWinAnimators.clear();
      final int N=wtoken.allAppWindows.size();
      for (int j=0; j < N; j++) {
        appAnimator.mAllAppWinAnimators.add(wtoken.allAppWindows.get(j).mWinAnimator);
      }
      mService.mAnimator.mAppWindowAnimating|=appAnimator.isAnimating();
      mService.mAnimator.orAnimating(appAnimator.showAllWindowsLocked());
    }
  }
}",0.9869083585095668
192475,"/** 
 * @return a LongSamplingCounter, measuring time spent in the idle state inmilliseconds.
 */
@Override public LongSamplingCounter getIdleTimeCounter(){
  return mRxTimeMillis;
}","/** 
 * @return a LongSamplingCounter, measuring time spent in the idle state inmilliseconds.
 */
@Override public LongSamplingCounter getIdleTimeCounter(){
  return mIdleTimeMillis;
}",0.9836065573770492
192476,"@Override public boolean onDoubleTap(MotionEvent event){
  mDoubleTapDetected=true;
  return mListener.onDoubleTapStarted();
}","@Override public boolean onDoubleTap(MotionEvent event){
  mDoubleTapDetected=true;
  return false;
}",0.8634361233480177
192477,"/** 
 * Handle a motion event.  If an action is completed, the appropriate callback on mListener is called, and the return value of the callback is passed to the caller.
 * @param event The raw motion event.  It's important that this be the rawevent, before any transformations have been applied, so that measurements can be made in physical units.
 * @param policyFlags Policy flags for the event.
 * @return true if the event is consumed, else false
 */
public boolean onMotionEvent(MotionEvent event,int policyFlags){
  final float x=event.getX();
  final float y=event.getY();
  final long time=event.getEventTime();
  mPolicyFlags=policyFlags;
switch (event.getActionMasked()) {
case MotionEvent.ACTION_DOWN:
    mDoubleTapDetected=false;
  mSecondFingerDoubleTap=false;
mRecognizingGesture=true;
mGestureStarted=false;
mPreviousGestureX=x;
mPreviousGestureY=y;
mStrokeBuffer.clear();
mStrokeBuffer.add(new GesturePoint(x,y,time));
mBaseX=x;
mBaseY=y;
mBaseTime=time;
break;
case MotionEvent.ACTION_MOVE:
if (mRecognizingGesture) {
final float deltaX=mBaseX - x;
final float deltaY=mBaseY - y;
final double moveDelta=Math.hypot(deltaX,deltaY);
if (moveDelta > mGestureDetectionThreshold) {
mBaseX=x;
mBaseY=y;
mBaseTime=time;
if (!mGestureStarted) {
mGestureStarted=true;
return mListener.onGestureStarted();
}
}
 else {
final long timeDelta=time - mBaseTime;
final long threshold=mGestureStarted ? CANCEL_ON_PAUSE_THRESHOLD_STARTED_MS : CANCEL_ON_PAUSE_THRESHOLD_NOT_STARTED_MS;
if (timeDelta > threshold) {
cancelGesture();
return mListener.onGestureCancelled(event,policyFlags);
}
}
final float dX=Math.abs(x - mPreviousGestureX);
final float dY=Math.abs(y - mPreviousGestureY);
if (dX >= TOUCH_TOLERANCE || dY >= TOUCH_TOLERANCE) {
mPreviousGestureX=x;
mPreviousGestureY=y;
mStrokeBuffer.add(new GesturePoint(x,y,time));
}
}
break;
case MotionEvent.ACTION_UP:
if (mDoubleTapDetected) {
return finishDoubleTap(event,policyFlags);
}
if (mGestureStarted) {
mStrokeBuffer.add(new GesturePoint(x,y,time));
return recognizeGesture(event,policyFlags);
}
break;
case MotionEvent.ACTION_POINTER_DOWN:
cancelGesture();
if (event.getPointerCount() == 2) {
mSecondFingerDoubleTap=true;
mSecondPointerDownTime=time;
}
 else {
mSecondFingerDoubleTap=false;
}
break;
case MotionEvent.ACTION_POINTER_UP:
if (mSecondFingerDoubleTap && mDoubleTapDetected) {
return finishDoubleTap(event,policyFlags);
}
break;
case MotionEvent.ACTION_CANCEL:
clear();
break;
}
if (mSecondFingerDoubleTap) {
MotionEvent newEvent=mapSecondPointerToFirstPointer(event);
if (newEvent == null) {
return false;
}
boolean handled=mGestureDetector.onTouchEvent(newEvent);
newEvent.recycle();
return handled;
}
if (!mRecognizingGesture) {
return false;
}
return mGestureDetector.onTouchEvent(event);
}","/** 
 * Handle a motion event.  If an action is completed, the appropriate callback on mListener is called, and the return value of the callback is passed to the caller.
 * @param event The raw motion event.  It's important that this be the rawevent, before any transformations have been applied, so that measurements can be made in physical units.
 * @param policyFlags Policy flags for the event.
 * @return true if the event is consumed, else false
 */
public boolean onMotionEvent(MotionEvent event,int policyFlags){
  final float x=event.getX();
  final float y=event.getY();
  final long time=event.getEventTime();
  mPolicyFlags=policyFlags;
switch (event.getActionMasked()) {
case MotionEvent.ACTION_DOWN:
    mDoubleTapDetected=false;
  mSecondFingerDoubleTap=false;
mRecognizingGesture=true;
mGestureStarted=false;
mPreviousGestureX=x;
mPreviousGestureY=y;
mStrokeBuffer.clear();
mStrokeBuffer.add(new GesturePoint(x,y,time));
mBaseX=x;
mBaseY=y;
mBaseTime=time;
break;
case MotionEvent.ACTION_MOVE:
if (mRecognizingGesture) {
final float deltaX=mBaseX - x;
final float deltaY=mBaseY - y;
final double moveDelta=Math.hypot(deltaX,deltaY);
if (moveDelta > mGestureDetectionThreshold) {
mBaseX=x;
mBaseY=y;
mBaseTime=time;
mFirstTapDetected=false;
mDoubleTapDetected=false;
if (!mGestureStarted) {
mGestureStarted=true;
return mListener.onGestureStarted();
}
}
 else if (!mFirstTapDetected) {
final long timeDelta=time - mBaseTime;
final long threshold=mGestureStarted ? CANCEL_ON_PAUSE_THRESHOLD_STARTED_MS : CANCEL_ON_PAUSE_THRESHOLD_NOT_STARTED_MS;
if (timeDelta > threshold) {
cancelGesture();
return mListener.onGestureCancelled(event,policyFlags);
}
}
final float dX=Math.abs(x - mPreviousGestureX);
final float dY=Math.abs(y - mPreviousGestureY);
if (dX >= TOUCH_TOLERANCE || dY >= TOUCH_TOLERANCE) {
mPreviousGestureX=x;
mPreviousGestureY=y;
mStrokeBuffer.add(new GesturePoint(x,y,time));
}
}
break;
case MotionEvent.ACTION_UP:
if (mDoubleTapDetected) {
return finishDoubleTap(event,policyFlags);
}
if (mGestureStarted) {
mStrokeBuffer.add(new GesturePoint(x,y,time));
return recognizeGesture(event,policyFlags);
}
break;
case MotionEvent.ACTION_POINTER_DOWN:
cancelGesture();
if (event.getPointerCount() == 2) {
mSecondFingerDoubleTap=true;
mSecondPointerDownTime=time;
}
 else {
mSecondFingerDoubleTap=false;
}
break;
case MotionEvent.ACTION_POINTER_UP:
if (mSecondFingerDoubleTap && mDoubleTapDetected) {
return finishDoubleTap(event,policyFlags);
}
break;
case MotionEvent.ACTION_CANCEL:
clear();
break;
}
if (mSecondFingerDoubleTap) {
MotionEvent newEvent=mapSecondPointerToFirstPointer(event);
if (newEvent == null) {
return false;
}
boolean handled=mGestureDetector.onTouchEvent(newEvent);
newEvent.recycle();
return handled;
}
if (!mRecognizingGesture) {
return false;
}
return mGestureDetector.onTouchEvent(event);
}",0.9866238630283574
192478,"/** 
 * Add a new content: URI that will be monitored with a  {@link android.database.ContentObserver}, and will cause the job to execute if changed. If you have any trigger content URIs associated with a job, it will not execute until there has been a change report for one or more of them. <p>Note that trigger URIs can not be used in combination with  {@link #setPeriodic(long)} or {@link #setPersisted(boolean)}.  To continually monitor for content changes, you need to schedule a new JobInfo observing the same URIs before you finish execution of the JobService handling the most recent changes.</p>
 * @param uri The content: URI to monitor.
 */
public Builder addTriggerContentUri(@NonNull TriggerContentUri uri){
  if (mTriggerContentUris == null) {
    mTriggerContentUris=new ArrayList<>();
  }
  mTriggerContentUris.add(uri);
  return this;
}","/** 
 * Add a new content: URI that will be monitored with a  {@link android.database.ContentObserver}, and will cause the job to execute if changed. If you have any trigger content URIs associated with a job, it will not execute until there has been a change report for one or more of them. <p>Note that trigger URIs can not be used in combination with  {@link #setPeriodic(long)} or {@link #setPersisted(boolean)}.  To continually monitor for content changes, you need to schedule a new JobInfo observing the same URIs before you finish execution of the JobService handling the most recent changes.</p> <p>Because because setting this property is not compatible with periodic or persisted jobs, doing so will throw an   {@link java.lang.IllegalArgumentException} when{@link android.app.job.JobInfo.Builder#build()} is called.</p>
 * @param uri The content: URI to monitor.
 */
public Builder addTriggerContentUri(@NonNull TriggerContentUri uri){
  if (mTriggerContentUris == null) {
    mTriggerContentUris=new ArrayList<>();
  }
  mTriggerContentUris.add(uri);
  return this;
}",0.8825659596482152
192479,"@Override public boolean onDoubleTap(MotionEvent event){
  mDoubleTapDetected=true;
  return mListener.onDoubleTapStarted();
}","@Override public boolean onDoubleTap(MotionEvent event){
  mDoubleTapDetected=true;
  return false;
}",0.8634361233480177
192480,"/** 
 * Handle a motion event.  If an action is completed, the appropriate callback on mListener is called, and the return value of the callback is passed to the caller.
 * @param event The raw motion event.  It's important that this be the rawevent, before any transformations have been applied, so that measurements can be made in physical units.
 * @param policyFlags Policy flags for the event.
 * @return true if the event is consumed, else false
 */
public boolean onMotionEvent(MotionEvent event,int policyFlags){
  final float x=event.getX();
  final float y=event.getY();
  final long time=event.getEventTime();
  mPolicyFlags=policyFlags;
switch (event.getActionMasked()) {
case MotionEvent.ACTION_DOWN:
    mDoubleTapDetected=false;
  mSecondFingerDoubleTap=false;
mRecognizingGesture=true;
mGestureStarted=false;
mPreviousGestureX=x;
mPreviousGestureY=y;
mStrokeBuffer.clear();
mStrokeBuffer.add(new GesturePoint(x,y,time));
mBaseX=x;
mBaseY=y;
mBaseTime=time;
break;
case MotionEvent.ACTION_MOVE:
if (mRecognizingGesture) {
final float deltaX=mBaseX - x;
final float deltaY=mBaseY - y;
final double moveDelta=Math.hypot(deltaX,deltaY);
if (moveDelta > mGestureDetectionThreshold) {
mBaseX=x;
mBaseY=y;
mBaseTime=time;
if (!mGestureStarted) {
mGestureStarted=true;
return mListener.onGestureStarted();
}
}
 else {
final long timeDelta=time - mBaseTime;
final long threshold=mGestureStarted ? CANCEL_ON_PAUSE_THRESHOLD_STARTED_MS : CANCEL_ON_PAUSE_THRESHOLD_NOT_STARTED_MS;
if (timeDelta > threshold) {
cancelGesture();
return mListener.onGestureCancelled(event,policyFlags);
}
}
final float dX=Math.abs(x - mPreviousGestureX);
final float dY=Math.abs(y - mPreviousGestureY);
if (dX >= TOUCH_TOLERANCE || dY >= TOUCH_TOLERANCE) {
mPreviousGestureX=x;
mPreviousGestureY=y;
mStrokeBuffer.add(new GesturePoint(x,y,time));
}
}
break;
case MotionEvent.ACTION_UP:
if (mDoubleTapDetected) {
return finishDoubleTap(event,policyFlags);
}
if (mGestureStarted) {
mStrokeBuffer.add(new GesturePoint(x,y,time));
return recognizeGesture(event,policyFlags);
}
break;
case MotionEvent.ACTION_POINTER_DOWN:
cancelGesture();
if (event.getPointerCount() == 2) {
mSecondFingerDoubleTap=true;
mSecondPointerDownTime=time;
}
 else {
mSecondFingerDoubleTap=false;
}
break;
case MotionEvent.ACTION_POINTER_UP:
if (mSecondFingerDoubleTap && mDoubleTapDetected) {
return finishDoubleTap(event,policyFlags);
}
break;
case MotionEvent.ACTION_CANCEL:
clear();
break;
}
if (mSecondFingerDoubleTap) {
MotionEvent newEvent=mapSecondPointerToFirstPointer(event);
if (newEvent == null) {
return false;
}
boolean handled=mGestureDetector.onTouchEvent(newEvent);
newEvent.recycle();
return handled;
}
if (!mRecognizingGesture) {
return false;
}
return mGestureDetector.onTouchEvent(event);
}","/** 
 * Handle a motion event.  If an action is completed, the appropriate callback on mListener is called, and the return value of the callback is passed to the caller.
 * @param event The raw motion event.  It's important that this be the rawevent, before any transformations have been applied, so that measurements can be made in physical units.
 * @param policyFlags Policy flags for the event.
 * @return true if the event is consumed, else false
 */
public boolean onMotionEvent(MotionEvent event,int policyFlags){
  final float x=event.getX();
  final float y=event.getY();
  final long time=event.getEventTime();
  mPolicyFlags=policyFlags;
switch (event.getActionMasked()) {
case MotionEvent.ACTION_DOWN:
    mDoubleTapDetected=false;
  mSecondFingerDoubleTap=false;
mRecognizingGesture=true;
mGestureStarted=false;
mPreviousGestureX=x;
mPreviousGestureY=y;
mStrokeBuffer.clear();
mStrokeBuffer.add(new GesturePoint(x,y,time));
mBaseX=x;
mBaseY=y;
mBaseTime=time;
break;
case MotionEvent.ACTION_MOVE:
if (mRecognizingGesture) {
final float deltaX=mBaseX - x;
final float deltaY=mBaseY - y;
final double moveDelta=Math.hypot(deltaX,deltaY);
if (moveDelta > mGestureDetectionThreshold) {
mBaseX=x;
mBaseY=y;
mBaseTime=time;
mFirstTapDetected=false;
mDoubleTapDetected=false;
if (!mGestureStarted) {
mGestureStarted=true;
return mListener.onGestureStarted();
}
}
 else if (!mFirstTapDetected) {
final long timeDelta=time - mBaseTime;
final long threshold=mGestureStarted ? CANCEL_ON_PAUSE_THRESHOLD_STARTED_MS : CANCEL_ON_PAUSE_THRESHOLD_NOT_STARTED_MS;
if (timeDelta > threshold) {
cancelGesture();
return mListener.onGestureCancelled(event,policyFlags);
}
}
final float dX=Math.abs(x - mPreviousGestureX);
final float dY=Math.abs(y - mPreviousGestureY);
if (dX >= TOUCH_TOLERANCE || dY >= TOUCH_TOLERANCE) {
mPreviousGestureX=x;
mPreviousGestureY=y;
mStrokeBuffer.add(new GesturePoint(x,y,time));
}
}
break;
case MotionEvent.ACTION_UP:
if (mDoubleTapDetected) {
return finishDoubleTap(event,policyFlags);
}
if (mGestureStarted) {
mStrokeBuffer.add(new GesturePoint(x,y,time));
return recognizeGesture(event,policyFlags);
}
break;
case MotionEvent.ACTION_POINTER_DOWN:
cancelGesture();
if (event.getPointerCount() == 2) {
mSecondFingerDoubleTap=true;
mSecondPointerDownTime=time;
}
 else {
mSecondFingerDoubleTap=false;
}
break;
case MotionEvent.ACTION_POINTER_UP:
if (mSecondFingerDoubleTap && mDoubleTapDetected) {
return finishDoubleTap(event,policyFlags);
}
break;
case MotionEvent.ACTION_CANCEL:
clear();
break;
}
if (mSecondFingerDoubleTap) {
MotionEvent newEvent=mapSecondPointerToFirstPointer(event);
if (newEvent == null) {
return false;
}
boolean handled=mGestureDetector.onTouchEvent(newEvent);
newEvent.recycle();
return handled;
}
if (!mRecognizingGesture) {
return false;
}
return mGestureDetector.onTouchEvent(event);
}",0.9866238630283574
192481,"@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return false;
  }
  trackVelocity(ev);
  final int action=ev.getAction();
  if (DEBUG_SCALE)   Log.d(TAG,""String_Node_Str"" + MotionEvent.actionToString(action) + ""String_Node_Str""+ mExpanding+ (0 != (mExpansionStyle & BLINDS) ? ""String_Node_Str"" : ""String_Node_Str"")+ (0 != (mExpansionStyle & PULL) ? ""String_Node_Str"" : ""String_Node_Str"")+ (0 != (mExpansionStyle & STRETCH) ? ""String_Node_Str"" : ""String_Node_Str""));
  mSGD.onTouchEvent(ev);
  final int x=(int)mSGD.getFocusX();
  final int y=(int)mSGD.getFocusY();
  mInitialTouchFocusY=y;
  mInitialTouchSpan=mSGD.getCurrentSpan();
  mLastFocusY=mInitialTouchFocusY;
  mLastSpanY=mInitialTouchSpan;
  if (DEBUG_SCALE)   Log.d(TAG,""String_Node_Str"" + mInitialTouchSpan);
  if (mExpanding) {
    mLastMotionY=ev.getRawY();
    maybeRecycleVelocityTracker(ev);
    return true;
  }
 else {
    if ((action == MotionEvent.ACTION_MOVE) && 0 != (mExpansionStyle & BLINDS)) {
      return true;
    }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_MOVE:
{
        final float xspan=mSGD.getCurrentSpanX();
        if (xspan > mPullGestureMinXSpan && xspan > mSGD.getCurrentSpanY() && !mExpanding) {
          if (DEBUG_SCALE)           Log.v(TAG,""String_Node_Str"" + xspan + ""String_Node_Str"");
          startExpanding(mResizedView,PULL);
          mWatchingForPull=false;
        }
        if (mWatchingForPull) {
          final float yDiff=ev.getRawY() - mInitialTouchY;
          if (yDiff > mTouchSlop) {
            if (DEBUG)             Log.v(TAG,""String_Node_Str"" + yDiff + ""String_Node_Str"");
            mWatchingForPull=false;
            if (mResizedView != null && !isFullyExpanded(mResizedView)) {
              if (startExpanding(mResizedView,BLINDS)) {
                mLastMotionY=ev.getRawY();
                mInitialTouchY=ev.getRawY();
                mHasPopped=false;
              }
            }
          }
        }
        break;
      }
case MotionEvent.ACTION_DOWN:
    mWatchingForPull=mScrollAdapter != null && isInside(mScrollAdapter.getHostView(),x,y) && mScrollAdapter.isScrolledToTop();
  mResizedView=findView(x,y);
if (mResizedView != null && !mCallback.canChildBeExpanded(mResizedView)) {
  mResizedView=null;
  mWatchingForPull=false;
}
mInitialTouchY=ev.getY();
break;
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
finishExpanding(false,getCurrentVelocity());
clearView();
break;
}
mLastMotionY=ev.getRawY();
maybeRecycleVelocityTracker(ev);
return mExpanding;
}
}","@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return false;
  }
  trackVelocity(ev);
  final int action=ev.getAction();
  if (DEBUG_SCALE)   Log.d(TAG,""String_Node_Str"" + MotionEvent.actionToString(action) + ""String_Node_Str""+ mExpanding+ (0 != (mExpansionStyle & BLINDS) ? ""String_Node_Str"" : ""String_Node_Str"")+ (0 != (mExpansionStyle & PULL) ? ""String_Node_Str"" : ""String_Node_Str"")+ (0 != (mExpansionStyle & STRETCH) ? ""String_Node_Str"" : ""String_Node_Str""));
  mSGD.onTouchEvent(ev);
  final int x=(int)mSGD.getFocusX();
  final int y=(int)mSGD.getFocusY();
  mInitialTouchFocusY=y;
  mInitialTouchSpan=mSGD.getCurrentSpan();
  mLastFocusY=mInitialTouchFocusY;
  mLastSpanY=mInitialTouchSpan;
  if (DEBUG_SCALE)   Log.d(TAG,""String_Node_Str"" + mInitialTouchSpan);
  if (mExpanding) {
    mLastMotionY=ev.getRawY();
    maybeRecycleVelocityTracker(ev);
    return true;
  }
 else {
    if ((action == MotionEvent.ACTION_MOVE) && 0 != (mExpansionStyle & BLINDS)) {
      return true;
    }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_MOVE:
{
        final float xspan=mSGD.getCurrentSpanX();
        if (xspan > mPullGestureMinXSpan && xspan > mSGD.getCurrentSpanY() && !mExpanding) {
          if (DEBUG_SCALE)           Log.v(TAG,""String_Node_Str"" + xspan + ""String_Node_Str"");
          startExpanding(mResizedView,PULL);
          mWatchingForPull=false;
        }
        if (mWatchingForPull) {
          final float yDiff=ev.getRawY() - mInitialTouchY;
          final float xDiff=ev.getRawX() - mInitialTouchX;
          if (yDiff > mTouchSlop && yDiff > Math.abs(xDiff)) {
            if (DEBUG)             Log.v(TAG,""String_Node_Str"" + yDiff + ""String_Node_Str"");
            mWatchingForPull=false;
            if (mResizedView != null && !isFullyExpanded(mResizedView)) {
              if (startExpanding(mResizedView,BLINDS)) {
                mLastMotionY=ev.getRawY();
                mInitialTouchY=ev.getRawY();
                mHasPopped=false;
              }
            }
          }
        }
        break;
      }
case MotionEvent.ACTION_DOWN:
    mWatchingForPull=mScrollAdapter != null && isInside(mScrollAdapter.getHostView(),x,y) && mScrollAdapter.isScrolledToTop();
  mResizedView=findView(x,y);
if (mResizedView != null && !mCallback.canChildBeExpanded(mResizedView)) {
  mResizedView=null;
  mWatchingForPull=false;
}
mInitialTouchY=ev.getY();
mInitialTouchX=ev.getX();
break;
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
finishExpanding(false,getCurrentVelocity());
clearView();
break;
}
mLastMotionY=ev.getRawY();
maybeRecycleVelocityTracker(ev);
return mExpanding;
}
}",0.9790575916230366
192482,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return false;
  }
  trackVelocity(ev);
  final int action=ev.getActionMasked();
  if (DEBUG_SCALE)   Log.d(TAG,""String_Node_Str"" + MotionEvent.actionToString(action) + ""String_Node_Str""+ mExpanding+ (0 != (mExpansionStyle & BLINDS) ? ""String_Node_Str"" : ""String_Node_Str"")+ (0 != (mExpansionStyle & PULL) ? ""String_Node_Str"" : ""String_Node_Str"")+ (0 != (mExpansionStyle & STRETCH) ? ""String_Node_Str"" : ""String_Node_Str""));
  mSGD.onTouchEvent(ev);
  final int x=(int)mSGD.getFocusX();
  final int y=(int)mSGD.getFocusY();
  if (mOnlyMovements) {
    mLastMotionY=ev.getRawY();
    return false;
  }
switch (action) {
case MotionEvent.ACTION_DOWN:
    mWatchingForPull=mScrollAdapter != null && isInside(mScrollAdapter.getHostView(),x,y);
  mResizedView=findView(x,y);
mInitialTouchY=ev.getY();
break;
case MotionEvent.ACTION_MOVE:
{
if (mWatchingForPull) {
final float yDiff=ev.getRawY() - mInitialTouchY;
if (yDiff > mTouchSlop) {
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + yDiff + ""String_Node_Str"");
  mWatchingForPull=false;
  if (mResizedView != null && !isFullyExpanded(mResizedView)) {
    if (startExpanding(mResizedView,BLINDS)) {
      mInitialTouchY=ev.getRawY();
      mLastMotionY=ev.getRawY();
      mHasPopped=false;
    }
  }
}
}
if (mExpanding && 0 != (mExpansionStyle & BLINDS)) {
final float rawHeight=ev.getRawY() - mLastMotionY + mCurrentHeight;
final float newHeight=clamp(rawHeight);
boolean isFinished=false;
boolean expanded=false;
if (rawHeight > mNaturalHeight) {
  isFinished=true;
  expanded=true;
}
if (rawHeight < mSmallSize) {
  isFinished=true;
  expanded=false;
}
if (!mHasPopped) {
  if (mEventSource != null) {
    mEventSource.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
  }
  mHasPopped=true;
}
mScaler.setHeight(newHeight);
mLastMotionY=ev.getRawY();
if (isFinished) {
  mCallback.expansionStateChanged(false);
}
 else {
  mCallback.expansionStateChanged(true);
}
return true;
}
if (mExpanding) {
updateExpansion();
mLastMotionY=ev.getRawY();
return true;
}
break;
}
case MotionEvent.ACTION_POINTER_UP:
case MotionEvent.ACTION_POINTER_DOWN:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
mInitialTouchY+=mSGD.getFocusY() - mLastFocusY;
mInitialTouchSpan+=mSGD.getCurrentSpan() - mLastSpanY;
break;
case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_CANCEL:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
finishExpanding(false,getCurrentVelocity());
clearView();
break;
}
mLastMotionY=ev.getRawY();
maybeRecycleVelocityTracker(ev);
return mResizedView != null;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return false;
  }
  trackVelocity(ev);
  final int action=ev.getActionMasked();
  if (DEBUG_SCALE)   Log.d(TAG,""String_Node_Str"" + MotionEvent.actionToString(action) + ""String_Node_Str""+ mExpanding+ (0 != (mExpansionStyle & BLINDS) ? ""String_Node_Str"" : ""String_Node_Str"")+ (0 != (mExpansionStyle & PULL) ? ""String_Node_Str"" : ""String_Node_Str"")+ (0 != (mExpansionStyle & STRETCH) ? ""String_Node_Str"" : ""String_Node_Str""));
  mSGD.onTouchEvent(ev);
  final int x=(int)mSGD.getFocusX();
  final int y=(int)mSGD.getFocusY();
  if (mOnlyMovements) {
    mLastMotionY=ev.getRawY();
    return false;
  }
switch (action) {
case MotionEvent.ACTION_DOWN:
    mWatchingForPull=mScrollAdapter != null && isInside(mScrollAdapter.getHostView(),x,y);
  mResizedView=findView(x,y);
mInitialTouchX=ev.getX();
mInitialTouchY=ev.getY();
break;
case MotionEvent.ACTION_MOVE:
{
if (mWatchingForPull) {
final float yDiff=ev.getRawY() - mInitialTouchY;
final float xDiff=ev.getRawX() - mInitialTouchX;
if (yDiff > mTouchSlop && yDiff > Math.abs(xDiff)) {
if (DEBUG) Log.v(TAG,""String_Node_Str"" + yDiff + ""String_Node_Str"");
mWatchingForPull=false;
if (mResizedView != null && !isFullyExpanded(mResizedView)) {
  if (startExpanding(mResizedView,BLINDS)) {
    mInitialTouchY=ev.getRawY();
    mLastMotionY=ev.getRawY();
    mHasPopped=false;
  }
}
}
}
if (mExpanding && 0 != (mExpansionStyle & BLINDS)) {
final float rawHeight=ev.getRawY() - mLastMotionY + mCurrentHeight;
final float newHeight=clamp(rawHeight);
boolean isFinished=false;
boolean expanded=false;
if (rawHeight > mNaturalHeight) {
isFinished=true;
expanded=true;
}
if (rawHeight < mSmallSize) {
isFinished=true;
expanded=false;
}
if (!mHasPopped) {
if (mEventSource != null) {
  mEventSource.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
}
mHasPopped=true;
}
mScaler.setHeight(newHeight);
mLastMotionY=ev.getRawY();
if (isFinished) {
mCallback.expansionStateChanged(false);
}
 else {
mCallback.expansionStateChanged(true);
}
return true;
}
if (mExpanding) {
updateExpansion();
mLastMotionY=ev.getRawY();
return true;
}
break;
}
case MotionEvent.ACTION_POINTER_UP:
case MotionEvent.ACTION_POINTER_DOWN:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
mInitialTouchY+=mSGD.getFocusY() - mLastFocusY;
mInitialTouchSpan+=mSGD.getCurrentSpan() - mLastSpanY;
break;
case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_CANCEL:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
finishExpanding(false,getCurrentVelocity());
clearView();
break;
}
mLastMotionY=ev.getRawY();
maybeRecycleVelocityTracker(ev);
return mResizedView != null;
}",0.9729007633587786
192483,"public final void onBusEvent(final RecentsActivityStartingEvent event){
  int processUser=sSystemServicesProxy.getProcessUser();
  if (!sSystemServicesProxy.isSystemUser(processUser)) {
    postToSystemUser(new Runnable(){
      @Override public void run(){
        try {
          mUserToSystemCallbacks.sendLaunchRecentsEvent();
        }
 catch (        RemoteException e) {
          Log.e(TAG,""String_Node_Str"",e);
        }
      }
    }
);
  }
}","public final void onBusEvent(ConfigurationChangedEvent event){
  mImpl.onConfigurationChanged();
}",0.2254545454545454
192484,"/** 
 * Creates the activity options for an app->recents transition.
 */
private ActivityOptions getThumbnailTransitionActivityOptions(ActivityManager.RunningTaskInfo topTask,TaskStackView stackView){
  if (topTask.stackId == FREEFORM_WORKSPACE_STACK_ID) {
    ArrayList<AppTransitionAnimationSpec> specs=new ArrayList<>();
    ArrayList<Task> tasks=stackView.getStack().getStackTasks();
    TaskStackLayoutAlgorithm stackLayout=stackView.getStackAlgorithm();
    TaskStackViewScroller stackScroller=stackView.getScroller();
    stackView.updateToInitialState();
    for (int i=tasks.size() - 1; i >= 0; i--) {
      Task task=tasks.get(i);
      if (task.isFreeformTask()) {
        mTmpTransform=stackLayout.getStackTransformScreenCoordinates(task,stackScroller.getStackScroll(),mTmpTransform,null);
        Rect toTaskRect=new Rect();
        mTmpTransform.rect.round(toTaskRect);
        Bitmap thumbnail=getThumbnailBitmap(topTask,task,mTmpTransform);
        specs.add(new AppTransitionAnimationSpec(task.key.id,thumbnail,toTaskRect));
      }
    }
    AppTransitionAnimationSpec[] specsArray=new AppTransitionAnimationSpec[specs.size()];
    specs.toArray(specsArray);
    return ActivityOptions.makeThumbnailAspectScaleDownAnimation(mDummyStackView,specsArray,mHandler,null,this);
  }
 else {
    Task toTask=new Task();
    TaskViewTransform toTransform=getThumbnailTransitionTransform(stackView,toTask);
    RectF toTaskRect=toTransform.rect;
    Bitmap thumbnail=getThumbnailBitmap(topTask,toTask,toTransform);
    if (thumbnail != null) {
      return ActivityOptions.makeThumbnailAspectScaleDownAnimation(mDummyStackView,thumbnail,(int)toTaskRect.left,(int)toTaskRect.top,(int)toTaskRect.width(),(int)toTaskRect.height(),mHandler,null);
    }
    return getUnknownTransitionActivityOptions();
  }
}","/** 
 * Creates the activity options for an app->recents transition.
 */
private ActivityOptions getThumbnailTransitionActivityOptions(ActivityManager.RunningTaskInfo topTask,TaskStackView stackView){
  if (topTask.stackId == FREEFORM_WORKSPACE_STACK_ID) {
    ArrayList<AppTransitionAnimationSpec> specs=new ArrayList<>();
    ArrayList<Task> tasks=stackView.getStack().getStackTasks();
    TaskStackLayoutAlgorithm stackLayout=stackView.getStackAlgorithm();
    TaskStackViewScroller stackScroller=stackView.getScroller();
    stackView.updateLayoutAlgorithm(true);
    stackView.updateToInitialState();
    for (int i=tasks.size() - 1; i >= 0; i--) {
      Task task=tasks.get(i);
      if (task.isFreeformTask()) {
        mTmpTransform=stackLayout.getStackTransformScreenCoordinates(task,stackScroller.getStackScroll(),mTmpTransform,null);
        Rect toTaskRect=new Rect();
        mTmpTransform.rect.round(toTaskRect);
        Bitmap thumbnail=getThumbnailBitmap(topTask,task,mTmpTransform);
        specs.add(new AppTransitionAnimationSpec(task.key.id,thumbnail,toTaskRect));
      }
    }
    AppTransitionAnimationSpec[] specsArray=new AppTransitionAnimationSpec[specs.size()];
    specs.toArray(specsArray);
    return ActivityOptions.makeThumbnailAspectScaleDownAnimation(mDummyStackView,specsArray,mHandler,null,this);
  }
 else {
    Task toTask=new Task();
    TaskViewTransform toTransform=getThumbnailTransitionTransform(stackView,toTask);
    RectF toTaskRect=toTransform.rect;
    Bitmap thumbnail=getThumbnailBitmap(topTask,toTask,toTransform);
    if (thumbnail != null) {
      return ActivityOptions.makeThumbnailAspectScaleDownAnimation(mDummyStackView,thumbnail,(int)toTaskRect.left,(int)toTaskRect.top,(int)toTaskRect.width(),(int)toTaskRect.height(),mHandler,null);
    }
    return getUnknownTransitionActivityOptions();
  }
}",0.988273793291519
192485,"/** 
 * Returns the transition rect for the given task id.
 */
private TaskViewTransform getThumbnailTransitionTransform(TaskStackView stackView,Task runningTaskOut){
  TaskStack stack=stackView.getStack();
  Task launchTask=stack.getLaunchTarget();
  if (launchTask != null) {
    runningTaskOut.copyFrom(launchTask);
  }
 else {
    launchTask=stack.getStackFrontMostTask(true);
    runningTaskOut.copyFrom(launchTask);
  }
  stackView.updateToInitialState();
  mTmpTransform=stackView.getStackAlgorithm().getStackTransformScreenCoordinates(launchTask,stackView.getScroller().getStackScroll(),mTmpTransform,null);
  return mTmpTransform;
}","/** 
 * Returns the transition rect for the given task id.
 */
private TaskViewTransform getThumbnailTransitionTransform(TaskStackView stackView,Task runningTaskOut){
  TaskStack stack=stackView.getStack();
  Task launchTask=stack.getLaunchTarget();
  if (launchTask != null) {
    runningTaskOut.copyFrom(launchTask);
  }
 else {
    launchTask=stack.getStackFrontMostTask(true);
    runningTaskOut.copyFrom(launchTask);
  }
  stackView.updateLayoutAlgorithm(true);
  stackView.updateToInitialState();
  mTmpTransform=stackView.getStackAlgorithm().getStackTransformScreenCoordinates(launchTask,stackView.getScroller().getStackScroll(),mTmpTransform,null);
  return mTmpTransform;
}",0.9690098261526832
192486,"/** 
 * Updates the min and max virtual scroll bounds.
 * @param ignoreTasksSet the set of tasks to ignore in the relayout
 */
void updateLayoutAlgorithm(boolean boundScrollToNewMinMax,ArraySet<Task.TaskKey> ignoreTasksSet){
  mLayoutAlgorithm.update(mStack,ignoreTasksSet);
  SystemServicesProxy ssp=Recents.getSystemServices();
  if (ssp.hasFreeformWorkspaceSupport()) {
    mTmpRect.set(mLayoutAlgorithm.mFreeformRect);
    mFreeformWorkspaceBackground.setBounds(mTmpRect);
  }
  if (boundScrollToNewMinMax) {
    mStackScroller.boundScroll();
  }
}","/** 
 * Updates the min and max virtual scroll bounds.
 * @param ignoreTasksSet the set of tasks to ignore in the relayout
 */
public void updateLayoutAlgorithm(boolean boundScrollToNewMinMax,ArraySet<Task.TaskKey> ignoreTasksSet){
  mLayoutAlgorithm.update(mStack,ignoreTasksSet);
  SystemServicesProxy ssp=Recents.getSystemServices();
  if (ssp.hasFreeformWorkspaceSupport()) {
    mTmpRect.set(mLayoutAlgorithm.mFreeformRect);
    mFreeformWorkspaceBackground.setBounds(mTmpRect);
  }
  if (boundScrollToNewMinMax) {
    mStackScroller.boundScroll();
  }
}",0.9936993699369936
192487,"private void updateScrollPositionOnExpandInBottom(ExpandableView view){
  if (view instanceof ExpandableNotificationRow) {
    ExpandableNotificationRow row=(ExpandableNotificationRow)view;
    if (row.isUserLocked() && row != getFirstChildNotGone()) {
      float endPosition;
      if (row.isChildInGroup()) {
        ExpandableNotificationRow parent=row.getNotificationParent();
        endPosition=parent.getTranslationY() + parent.getActualHeight();
      }
 else {
        endPosition=row.getTranslationY() + row.getActualHeight();
      }
      int stackEnd=mMaxLayoutHeight - mBottomStackPeekSize - mBottomStackSlowDownHeight + (int)mStackTranslation;
      if (endPosition > stackEnd) {
        mOwnScrollY+=endPosition - stackEnd;
        mDisallowScrollingInThisMotion=true;
      }
    }
  }
}","private void updateScrollPositionOnExpandInBottom(ExpandableView view){
  if (view instanceof ExpandableNotificationRow) {
    ExpandableNotificationRow row=(ExpandableNotificationRow)view;
    if (row.isUserLocked() && row != getFirstChildNotGone()) {
      if (row.isSummaryWithChildren()) {
        return;
      }
      float endPosition=row.getTranslationY() + row.getActualHeight();
      if (row.isChildInGroup()) {
        endPosition+=row.getNotificationParent().getTranslationY();
      }
      int stackEnd=mMaxLayoutHeight - mBottomStackPeekSize - mBottomStackSlowDownHeight + (int)mStackTranslation;
      if (endPosition > stackEnd) {
        mOwnScrollY+=endPosition - stackEnd;
        mDisallowScrollingInThisMotion=true;
      }
    }
  }
}",0.7600767754318618
192488,"@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return false;
  }
  trackVelocity(ev);
  final int action=ev.getAction();
  if (DEBUG_SCALE)   Log.d(TAG,""String_Node_Str"" + MotionEvent.actionToString(action) + ""String_Node_Str""+ mExpanding+ (0 != (mExpansionStyle & BLINDS) ? ""String_Node_Str"" : ""String_Node_Str"")+ (0 != (mExpansionStyle & PULL) ? ""String_Node_Str"" : ""String_Node_Str"")+ (0 != (mExpansionStyle & STRETCH) ? ""String_Node_Str"" : ""String_Node_Str""));
  mSGD.onTouchEvent(ev);
  final int x=(int)mSGD.getFocusX();
  final int y=(int)mSGD.getFocusY();
  mInitialTouchFocusY=y;
  mInitialTouchSpan=mSGD.getCurrentSpan();
  mLastFocusY=mInitialTouchFocusY;
  mLastSpanY=mInitialTouchSpan;
  if (DEBUG_SCALE)   Log.d(TAG,""String_Node_Str"" + mInitialTouchSpan);
  if (mExpanding) {
    mLastMotionY=ev.getRawY();
    maybeRecycleVelocityTracker(ev);
    return true;
  }
 else {
    if ((action == MotionEvent.ACTION_MOVE) && 0 != (mExpansionStyle & BLINDS)) {
      return true;
    }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_MOVE:
{
        final float xspan=mSGD.getCurrentSpanX();
        if (xspan > mPullGestureMinXSpan && xspan > mSGD.getCurrentSpanY() && !mExpanding) {
          if (DEBUG_SCALE)           Log.v(TAG,""String_Node_Str"" + xspan + ""String_Node_Str"");
          startExpanding(mResizedView,PULL);
          mWatchingForPull=false;
        }
        if (mWatchingForPull) {
          final float yDiff=ev.getRawY() - mInitialTouchY;
          if (yDiff > mTouchSlop) {
            if (DEBUG)             Log.v(TAG,""String_Node_Str"" + yDiff + ""String_Node_Str"");
            mWatchingForPull=false;
            if (mResizedView != null && !isFullyExpanded(mResizedView)) {
              if (startExpanding(mResizedView,BLINDS)) {
                mLastMotionY=ev.getRawY();
                mInitialTouchY=ev.getRawY();
                mHasPopped=false;
              }
            }
          }
        }
        break;
      }
case MotionEvent.ACTION_DOWN:
    mWatchingForPull=mScrollAdapter != null && isInside(mScrollAdapter.getHostView(),x,y) && mScrollAdapter.isScrolledToTop();
  mResizedView=findView(x,y);
if (mResizedView != null && !mCallback.canChildBeExpanded(mResizedView)) {
  mResizedView=null;
  mWatchingForPull=false;
}
mInitialTouchY=ev.getY();
break;
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
finishExpanding(false,getCurrentVelocity());
clearView();
break;
}
mLastMotionY=ev.getRawY();
maybeRecycleVelocityTracker(ev);
return mExpanding;
}
}","@Override public boolean onInterceptTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return false;
  }
  trackVelocity(ev);
  final int action=ev.getAction();
  if (DEBUG_SCALE)   Log.d(TAG,""String_Node_Str"" + MotionEvent.actionToString(action) + ""String_Node_Str""+ mExpanding+ (0 != (mExpansionStyle & BLINDS) ? ""String_Node_Str"" : ""String_Node_Str"")+ (0 != (mExpansionStyle & PULL) ? ""String_Node_Str"" : ""String_Node_Str"")+ (0 != (mExpansionStyle & STRETCH) ? ""String_Node_Str"" : ""String_Node_Str""));
  mSGD.onTouchEvent(ev);
  final int x=(int)mSGD.getFocusX();
  final int y=(int)mSGD.getFocusY();
  mInitialTouchFocusY=y;
  mInitialTouchSpan=mSGD.getCurrentSpan();
  mLastFocusY=mInitialTouchFocusY;
  mLastSpanY=mInitialTouchSpan;
  if (DEBUG_SCALE)   Log.d(TAG,""String_Node_Str"" + mInitialTouchSpan);
  if (mExpanding) {
    mLastMotionY=ev.getRawY();
    maybeRecycleVelocityTracker(ev);
    return true;
  }
 else {
    if ((action == MotionEvent.ACTION_MOVE) && 0 != (mExpansionStyle & BLINDS)) {
      return true;
    }
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_MOVE:
{
        final float xspan=mSGD.getCurrentSpanX();
        if (xspan > mPullGestureMinXSpan && xspan > mSGD.getCurrentSpanY() && !mExpanding) {
          if (DEBUG_SCALE)           Log.v(TAG,""String_Node_Str"" + xspan + ""String_Node_Str"");
          startExpanding(mResizedView,PULL);
          mWatchingForPull=false;
        }
        if (mWatchingForPull) {
          final float yDiff=ev.getRawY() - mInitialTouchY;
          final float xDiff=ev.getRawX() - mInitialTouchX;
          if (yDiff > mTouchSlop && yDiff > Math.abs(xDiff)) {
            if (DEBUG)             Log.v(TAG,""String_Node_Str"" + yDiff + ""String_Node_Str"");
            mWatchingForPull=false;
            if (mResizedView != null && !isFullyExpanded(mResizedView)) {
              if (startExpanding(mResizedView,BLINDS)) {
                mLastMotionY=ev.getRawY();
                mInitialTouchY=ev.getRawY();
                mHasPopped=false;
              }
            }
          }
        }
        break;
      }
case MotionEvent.ACTION_DOWN:
    mWatchingForPull=mScrollAdapter != null && isInside(mScrollAdapter.getHostView(),x,y) && mScrollAdapter.isScrolledToTop();
  mResizedView=findView(x,y);
if (mResizedView != null && !mCallback.canChildBeExpanded(mResizedView)) {
  mResizedView=null;
  mWatchingForPull=false;
}
mInitialTouchY=ev.getY();
mInitialTouchX=ev.getX();
break;
case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
finishExpanding(false,getCurrentVelocity());
clearView();
break;
}
mLastMotionY=ev.getRawY();
maybeRecycleVelocityTracker(ev);
return mExpanding;
}
}",0.9790575916230366
192489,"@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return false;
  }
  trackVelocity(ev);
  final int action=ev.getActionMasked();
  if (DEBUG_SCALE)   Log.d(TAG,""String_Node_Str"" + MotionEvent.actionToString(action) + ""String_Node_Str""+ mExpanding+ (0 != (mExpansionStyle & BLINDS) ? ""String_Node_Str"" : ""String_Node_Str"")+ (0 != (mExpansionStyle & PULL) ? ""String_Node_Str"" : ""String_Node_Str"")+ (0 != (mExpansionStyle & STRETCH) ? ""String_Node_Str"" : ""String_Node_Str""));
  mSGD.onTouchEvent(ev);
  final int x=(int)mSGD.getFocusX();
  final int y=(int)mSGD.getFocusY();
  if (mOnlyMovements) {
    mLastMotionY=ev.getRawY();
    return false;
  }
switch (action) {
case MotionEvent.ACTION_DOWN:
    mWatchingForPull=mScrollAdapter != null && isInside(mScrollAdapter.getHostView(),x,y);
  mResizedView=findView(x,y);
mInitialTouchY=ev.getY();
break;
case MotionEvent.ACTION_MOVE:
{
if (mWatchingForPull) {
final float yDiff=ev.getRawY() - mInitialTouchY;
if (yDiff > mTouchSlop) {
  if (DEBUG)   Log.v(TAG,""String_Node_Str"" + yDiff + ""String_Node_Str"");
  mWatchingForPull=false;
  if (mResizedView != null && !isFullyExpanded(mResizedView)) {
    if (startExpanding(mResizedView,BLINDS)) {
      mInitialTouchY=ev.getRawY();
      mLastMotionY=ev.getRawY();
      mHasPopped=false;
    }
  }
}
}
if (mExpanding && 0 != (mExpansionStyle & BLINDS)) {
final float rawHeight=ev.getRawY() - mLastMotionY + mCurrentHeight;
final float newHeight=clamp(rawHeight);
boolean isFinished=false;
boolean expanded=false;
if (rawHeight > mNaturalHeight) {
  isFinished=true;
  expanded=true;
}
if (rawHeight < mSmallSize) {
  isFinished=true;
  expanded=false;
}
if (!mHasPopped) {
  if (mEventSource != null) {
    mEventSource.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
  }
  mHasPopped=true;
}
mScaler.setHeight(newHeight);
mLastMotionY=ev.getRawY();
if (isFinished) {
  mCallback.expansionStateChanged(false);
}
 else {
  mCallback.expansionStateChanged(true);
}
return true;
}
if (mExpanding) {
updateExpansion();
mLastMotionY=ev.getRawY();
return true;
}
break;
}
case MotionEvent.ACTION_POINTER_UP:
case MotionEvent.ACTION_POINTER_DOWN:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
mInitialTouchY+=mSGD.getFocusY() - mLastFocusY;
mInitialTouchSpan+=mSGD.getCurrentSpan() - mLastSpanY;
break;
case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_CANCEL:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
finishExpanding(false,getCurrentVelocity());
clearView();
break;
}
mLastMotionY=ev.getRawY();
maybeRecycleVelocityTracker(ev);
return mResizedView != null;
}","@Override public boolean onTouchEvent(MotionEvent ev){
  if (!isEnabled()) {
    return false;
  }
  trackVelocity(ev);
  final int action=ev.getActionMasked();
  if (DEBUG_SCALE)   Log.d(TAG,""String_Node_Str"" + MotionEvent.actionToString(action) + ""String_Node_Str""+ mExpanding+ (0 != (mExpansionStyle & BLINDS) ? ""String_Node_Str"" : ""String_Node_Str"")+ (0 != (mExpansionStyle & PULL) ? ""String_Node_Str"" : ""String_Node_Str"")+ (0 != (mExpansionStyle & STRETCH) ? ""String_Node_Str"" : ""String_Node_Str""));
  mSGD.onTouchEvent(ev);
  final int x=(int)mSGD.getFocusX();
  final int y=(int)mSGD.getFocusY();
  if (mOnlyMovements) {
    mLastMotionY=ev.getRawY();
    return false;
  }
switch (action) {
case MotionEvent.ACTION_DOWN:
    mWatchingForPull=mScrollAdapter != null && isInside(mScrollAdapter.getHostView(),x,y);
  mResizedView=findView(x,y);
mInitialTouchX=ev.getX();
mInitialTouchY=ev.getY();
break;
case MotionEvent.ACTION_MOVE:
{
if (mWatchingForPull) {
final float yDiff=ev.getRawY() - mInitialTouchY;
final float xDiff=ev.getRawX() - mInitialTouchX;
if (yDiff > mTouchSlop && yDiff > Math.abs(xDiff)) {
if (DEBUG) Log.v(TAG,""String_Node_Str"" + yDiff + ""String_Node_Str"");
mWatchingForPull=false;
if (mResizedView != null && !isFullyExpanded(mResizedView)) {
  if (startExpanding(mResizedView,BLINDS)) {
    mInitialTouchY=ev.getRawY();
    mLastMotionY=ev.getRawY();
    mHasPopped=false;
  }
}
}
}
if (mExpanding && 0 != (mExpansionStyle & BLINDS)) {
final float rawHeight=ev.getRawY() - mLastMotionY + mCurrentHeight;
final float newHeight=clamp(rawHeight);
boolean isFinished=false;
boolean expanded=false;
if (rawHeight > mNaturalHeight) {
isFinished=true;
expanded=true;
}
if (rawHeight < mSmallSize) {
isFinished=true;
expanded=false;
}
if (!mHasPopped) {
if (mEventSource != null) {
  mEventSource.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
}
mHasPopped=true;
}
mScaler.setHeight(newHeight);
mLastMotionY=ev.getRawY();
if (isFinished) {
mCallback.expansionStateChanged(false);
}
 else {
mCallback.expansionStateChanged(true);
}
return true;
}
if (mExpanding) {
updateExpansion();
mLastMotionY=ev.getRawY();
return true;
}
break;
}
case MotionEvent.ACTION_POINTER_UP:
case MotionEvent.ACTION_POINTER_DOWN:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
mInitialTouchY+=mSGD.getFocusY() - mLastFocusY;
mInitialTouchSpan+=mSGD.getCurrentSpan() - mLastSpanY;
break;
case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_CANCEL:
if (DEBUG) Log.d(TAG,""String_Node_Str"");
finishExpanding(false,getCurrentVelocity());
clearView();
break;
}
mLastMotionY=ev.getRawY();
maybeRecycleVelocityTracker(ev);
return mResizedView != null;
}",0.9729007633587786
192490,"@Override public void setVisible(boolean visible){
  for (  Integer viewType : mTransformedViews.keySet()) {
    TransformState ownState=getCurrentState(viewType);
    if (ownState != null) {
      ownState.setVisible(visible);
      ownState.recycle();
    }
  }
}","@Override public void setVisible(boolean visible){
  if (mViewTransformationAnimation != null) {
    mViewTransformationAnimation.cancel();
  }
  for (  Integer viewType : mTransformedViews.keySet()) {
    TransformState ownState=getCurrentState(viewType);
    if (ownState != null) {
      ownState.setVisible(visible);
      ownState.recycle();
    }
  }
}",0.8507223113964687
192491,"public final void onBusEvent(final RecentsActivityStartingEvent event){
  int processUser=sSystemServicesProxy.getProcessUser();
  if (!sSystemServicesProxy.isSystemUser(processUser)) {
    postToSystemUser(new Runnable(){
      @Override public void run(){
        try {
          mUserToSystemCallbacks.sendLaunchRecentsEvent();
        }
 catch (        RemoteException e) {
          Log.e(TAG,""String_Node_Str"",e);
        }
      }
    }
);
  }
}","public final void onBusEvent(ConfigurationChangedEvent event){
  mImpl.onConfigurationChanged();
}",0.2254545454545454
192492,"/** 
 * Creates the activity options for an app->recents transition.
 */
private ActivityOptions getThumbnailTransitionActivityOptions(ActivityManager.RunningTaskInfo topTask,TaskStackView stackView){
  if (topTask.stackId == FREEFORM_WORKSPACE_STACK_ID) {
    ArrayList<AppTransitionAnimationSpec> specs=new ArrayList<>();
    ArrayList<Task> tasks=stackView.getStack().getStackTasks();
    TaskStackLayoutAlgorithm stackLayout=stackView.getStackAlgorithm();
    TaskStackViewScroller stackScroller=stackView.getScroller();
    stackView.updateToInitialState();
    for (int i=tasks.size() - 1; i >= 0; i--) {
      Task task=tasks.get(i);
      if (task.isFreeformTask()) {
        mTmpTransform=stackLayout.getStackTransformScreenCoordinates(task,stackScroller.getStackScroll(),mTmpTransform,null);
        Rect toTaskRect=new Rect();
        mTmpTransform.rect.round(toTaskRect);
        Bitmap thumbnail=getThumbnailBitmap(topTask,task,mTmpTransform);
        specs.add(new AppTransitionAnimationSpec(task.key.id,thumbnail,toTaskRect));
      }
    }
    AppTransitionAnimationSpec[] specsArray=new AppTransitionAnimationSpec[specs.size()];
    specs.toArray(specsArray);
    return ActivityOptions.makeThumbnailAspectScaleDownAnimation(mDummyStackView,specsArray,mHandler,null,this);
  }
 else {
    Task toTask=new Task();
    TaskViewTransform toTransform=getThumbnailTransitionTransform(stackView,toTask);
    RectF toTaskRect=toTransform.rect;
    Bitmap thumbnail=getThumbnailBitmap(topTask,toTask,toTransform);
    if (thumbnail != null) {
      return ActivityOptions.makeThumbnailAspectScaleDownAnimation(mDummyStackView,thumbnail,(int)toTaskRect.left,(int)toTaskRect.top,(int)toTaskRect.width(),(int)toTaskRect.height(),mHandler,null);
    }
    return getUnknownTransitionActivityOptions();
  }
}","/** 
 * Creates the activity options for an app->recents transition.
 */
private ActivityOptions getThumbnailTransitionActivityOptions(ActivityManager.RunningTaskInfo topTask,TaskStackView stackView){
  if (topTask.stackId == FREEFORM_WORKSPACE_STACK_ID) {
    ArrayList<AppTransitionAnimationSpec> specs=new ArrayList<>();
    ArrayList<Task> tasks=stackView.getStack().getStackTasks();
    TaskStackLayoutAlgorithm stackLayout=stackView.getStackAlgorithm();
    TaskStackViewScroller stackScroller=stackView.getScroller();
    stackView.updateLayoutAlgorithm(true);
    stackView.updateToInitialState();
    for (int i=tasks.size() - 1; i >= 0; i--) {
      Task task=tasks.get(i);
      if (task.isFreeformTask()) {
        mTmpTransform=stackLayout.getStackTransformScreenCoordinates(task,stackScroller.getStackScroll(),mTmpTransform,null);
        Rect toTaskRect=new Rect();
        mTmpTransform.rect.round(toTaskRect);
        Bitmap thumbnail=getThumbnailBitmap(topTask,task,mTmpTransform);
        specs.add(new AppTransitionAnimationSpec(task.key.id,thumbnail,toTaskRect));
      }
    }
    AppTransitionAnimationSpec[] specsArray=new AppTransitionAnimationSpec[specs.size()];
    specs.toArray(specsArray);
    return ActivityOptions.makeThumbnailAspectScaleDownAnimation(mDummyStackView,specsArray,mHandler,null,this);
  }
 else {
    Task toTask=new Task();
    TaskViewTransform toTransform=getThumbnailTransitionTransform(stackView,toTask);
    RectF toTaskRect=toTransform.rect;
    Bitmap thumbnail=getThumbnailBitmap(topTask,toTask,toTransform);
    if (thumbnail != null) {
      return ActivityOptions.makeThumbnailAspectScaleDownAnimation(mDummyStackView,thumbnail,(int)toTaskRect.left,(int)toTaskRect.top,(int)toTaskRect.width(),(int)toTaskRect.height(),mHandler,null);
    }
    return getUnknownTransitionActivityOptions();
  }
}",0.988273793291519
192493,"/** 
 * Returns the transition rect for the given task id.
 */
private TaskViewTransform getThumbnailTransitionTransform(TaskStackView stackView,Task runningTaskOut){
  TaskStack stack=stackView.getStack();
  Task launchTask=stack.getLaunchTarget();
  if (launchTask != null) {
    runningTaskOut.copyFrom(launchTask);
  }
 else {
    launchTask=stack.getStackFrontMostTask(true);
    runningTaskOut.copyFrom(launchTask);
  }
  stackView.updateToInitialState();
  mTmpTransform=stackView.getStackAlgorithm().getStackTransformScreenCoordinates(launchTask,stackView.getScroller().getStackScroll(),mTmpTransform,null);
  return mTmpTransform;
}","/** 
 * Returns the transition rect for the given task id.
 */
private TaskViewTransform getThumbnailTransitionTransform(TaskStackView stackView,Task runningTaskOut){
  TaskStack stack=stackView.getStack();
  Task launchTask=stack.getLaunchTarget();
  if (launchTask != null) {
    runningTaskOut.copyFrom(launchTask);
  }
 else {
    launchTask=stack.getStackFrontMostTask(true);
    runningTaskOut.copyFrom(launchTask);
  }
  stackView.updateLayoutAlgorithm(true);
  stackView.updateToInitialState();
  mTmpTransform=stackView.getStackAlgorithm().getStackTransformScreenCoordinates(launchTask,stackView.getScroller().getStackScroll(),mTmpTransform,null);
  return mTmpTransform;
}",0.9690098261526832
192494,"/** 
 * Updates the min and max virtual scroll bounds.
 * @param ignoreTasksSet the set of tasks to ignore in the relayout
 */
void updateLayoutAlgorithm(boolean boundScrollToNewMinMax,ArraySet<Task.TaskKey> ignoreTasksSet){
  mLayoutAlgorithm.update(mStack,ignoreTasksSet);
  SystemServicesProxy ssp=Recents.getSystemServices();
  if (ssp.hasFreeformWorkspaceSupport()) {
    mTmpRect.set(mLayoutAlgorithm.mFreeformRect);
    mFreeformWorkspaceBackground.setBounds(mTmpRect);
  }
  if (boundScrollToNewMinMax) {
    mStackScroller.boundScroll();
  }
}","/** 
 * Updates the min and max virtual scroll bounds.
 * @param ignoreTasksSet the set of tasks to ignore in the relayout
 */
public void updateLayoutAlgorithm(boolean boundScrollToNewMinMax,ArraySet<Task.TaskKey> ignoreTasksSet){
  mLayoutAlgorithm.update(mStack,ignoreTasksSet);
  SystemServicesProxy ssp=Recents.getSystemServices();
  if (ssp.hasFreeformWorkspaceSupport()) {
    mTmpRect.set(mLayoutAlgorithm.mFreeformRect);
    mFreeformWorkspaceBackground.setBounds(mTmpRect);
  }
  if (boundScrollToNewMinMax) {
    mStackScroller.boundScroll();
  }
}",0.9936993699369936
192495,"private void updateScrollPositionOnExpandInBottom(ExpandableView view){
  if (view instanceof ExpandableNotificationRow) {
    ExpandableNotificationRow row=(ExpandableNotificationRow)view;
    if (row.isUserLocked() && row != getFirstChildNotGone()) {
      float endPosition;
      if (row.isChildInGroup()) {
        ExpandableNotificationRow parent=row.getNotificationParent();
        endPosition=parent.getTranslationY() + parent.getActualHeight();
      }
 else {
        endPosition=row.getTranslationY() + row.getActualHeight();
      }
      int stackEnd=mMaxLayoutHeight - mBottomStackPeekSize - mBottomStackSlowDownHeight + (int)mStackTranslation;
      if (endPosition > stackEnd) {
        mOwnScrollY+=endPosition - stackEnd;
        mDisallowScrollingInThisMotion=true;
      }
    }
  }
}","private void updateScrollPositionOnExpandInBottom(ExpandableView view){
  if (view instanceof ExpandableNotificationRow) {
    ExpandableNotificationRow row=(ExpandableNotificationRow)view;
    if (row.isUserLocked() && row != getFirstChildNotGone()) {
      if (row.isSummaryWithChildren()) {
        return;
      }
      float endPosition=row.getTranslationY() + row.getActualHeight();
      if (row.isChildInGroup()) {
        endPosition+=row.getNotificationParent().getTranslationY();
      }
      int stackEnd=mMaxLayoutHeight - mBottomStackPeekSize - mBottomStackSlowDownHeight + (int)mStackTranslation;
      if (endPosition > stackEnd) {
        mOwnScrollY+=endPosition - stackEnd;
        mDisallowScrollingInThisMotion=true;
      }
    }
  }
}",0.7600767754318618
192496,"private void updateLimits(){
  boolean customView=getPrivateLayout().getContractedChild().getId() != com.android.internal.R.id.status_bar_latest_event_content;
  boolean beforeN=mEntry.targetSdk < Build.VERSION_CODES.N;
  int minHeight=customView && beforeN && !mIsSummaryWithChildren ? mNotificationMinHeightLegacy : mNotificationMinHeight;
  boolean headsUpCustom=getPrivateLayout().getHeadsUpChild() != null && getPrivateLayout().getHeadsUpChild().getId() != com.android.internal.R.id.status_bar_latest_event_content;
  int headsUpheight=headsUpCustom && beforeN ? mMaxHeadsUpHeightLegacy : mMaxHeadsUpHeight;
  mPrivateLayout.setHeights(minHeight,headsUpheight,mNotificationMaxHeight);
  mPublicLayout.setHeights(minHeight,headsUpheight,mNotificationMaxHeight);
}","private void updateLimits(){
  updateLimitsForView(mPrivateLayout);
  updateLimitsForView(mPublicLayout);
}",0.1670480549199084
192497,"@Override public void setVisible(boolean visible){
  for (  Integer viewType : mTransformedViews.keySet()) {
    TransformState ownState=getCurrentState(viewType);
    if (ownState != null) {
      ownState.setVisible(visible);
      ownState.recycle();
    }
  }
}","@Override public void setVisible(boolean visible){
  if (mViewTransformationAnimation != null) {
    mViewTransformationAnimation.cancel();
  }
  for (  Integer viewType : mTransformedViews.keySet()) {
    TransformState ownState=getCurrentState(viewType);
    if (ownState != null) {
      ownState.setVisible(visible);
      ownState.recycle();
    }
  }
}",0.8507223113964687
192498,"@Override protected boolean sameAs(TransformState otherState){
  if (otherState instanceof TextViewTransformState) {
    TextViewTransformState otherTvs=(TextViewTransformState)otherState;
    if (TextUtils.equals(otherTvs.mText.getText(),mText.getText())) {
      int ownEllipsized=getEllipsisCount();
      int otherEllipsized=otherTvs.getEllipsisCount();
      return ownEllipsized == otherEllipsized;
    }
  }
  return super.sameAs(otherState);
}","@Override protected boolean sameAs(TransformState otherState){
  if (otherState instanceof TextViewTransformState) {
    TextViewTransformState otherTvs=(TextViewTransformState)otherState;
    if (TextUtils.equals(otherTvs.mText.getText(),mText.getText())) {
      int ownEllipsized=getEllipsisCount();
      int otherEllipsized=otherTvs.getEllipsisCount();
      return ownEllipsized == otherEllipsized && mText.getHeight() == otherTvs.mText.getHeight();
    }
  }
  return super.sameAs(otherState);
}",0.9464847848898216
192499,"public void updateResources(){
  int panelWidth=getResources().getDimensionPixelSize(R.dimen.notification_panel_width);
  int panelGravity=getResources().getInteger(R.integer.notification_panel_layout_gravity);
  FrameLayout.LayoutParams lp=(FrameLayout.LayoutParams)mQsContainer.getLayoutParams();
  if (lp.width != panelWidth) {
    lp.width=panelWidth;
    lp.gravity=panelGravity;
    mQsDensityContainer.setLayoutParams(lp);
    mQsContainer.post(mUpdateHeader);
  }
  lp=(FrameLayout.LayoutParams)mNotificationStackScroller.getLayoutParams();
  if (lp.width != panelWidth) {
    lp.width=panelWidth;
    lp.gravity=panelGravity;
    mNotificationStackScroller.setLayoutParams(lp);
  }
}","public void updateResources(){
  int panelWidth=getResources().getDimensionPixelSize(R.dimen.notification_panel_width);
  int panelGravity=getResources().getInteger(R.integer.notification_panel_layout_gravity);
  FrameLayout.LayoutParams lp=(FrameLayout.LayoutParams)mQsDensityContainer.getLayoutParams();
  if (lp.width != panelWidth) {
    lp.width=panelWidth;
    lp.gravity=panelGravity;
    mQsDensityContainer.setLayoutParams(lp);
    mQsContainer.post(mUpdateHeader);
  }
  lp=(FrameLayout.LayoutParams)mNotificationStackScroller.getLayoutParams();
  if (lp.width != panelWidth) {
    lp.width=panelWidth;
    lp.gravity=panelGravity;
    mNotificationStackScroller.setLayoutParams(lp);
  }
}",0.9949676491732566
192500,"public void updateResources(){
  int panelWidth=getResources().getDimensionPixelSize(R.dimen.notification_panel_width);
  int panelGravity=getResources().getInteger(R.integer.notification_panel_layout_gravity);
  FrameLayout.LayoutParams lp=(FrameLayout.LayoutParams)mQsContainer.getLayoutParams();
  if (lp.width != panelWidth) {
    lp.width=panelWidth;
    lp.gravity=panelGravity;
    mQsDensityContainer.setLayoutParams(lp);
    mQsContainer.post(mUpdateHeader);
  }
  lp=(FrameLayout.LayoutParams)mNotificationStackScroller.getLayoutParams();
  if (lp.width != panelWidth) {
    lp.width=panelWidth;
    lp.gravity=panelGravity;
    mNotificationStackScroller.setLayoutParams(lp);
  }
}","public void updateResources(){
  int panelWidth=getResources().getDimensionPixelSize(R.dimen.notification_panel_width);
  int panelGravity=getResources().getInteger(R.integer.notification_panel_layout_gravity);
  FrameLayout.LayoutParams lp=(FrameLayout.LayoutParams)mQsDensityContainer.getLayoutParams();
  if (lp.width != panelWidth) {
    lp.width=panelWidth;
    lp.gravity=panelGravity;
    mQsDensityContainer.setLayoutParams(lp);
    mQsContainer.post(mUpdateHeader);
  }
  lp=(FrameLayout.LayoutParams)mNotificationStackScroller.getLayoutParams();
  if (lp.width != panelWidth) {
    lp.width=panelWidth;
    lp.gravity=panelGravity;
    mNotificationStackScroller.setLayoutParams(lp);
  }
}",0.9949676491732566
192501,"public void updateResources(){
  int panelWidth=getResources().getDimensionPixelSize(R.dimen.notification_panel_width);
  int panelGravity=getResources().getInteger(R.integer.notification_panel_layout_gravity);
  FrameLayout.LayoutParams lp=(FrameLayout.LayoutParams)mQsContainer.getLayoutParams();
  if (lp.width != panelWidth) {
    lp.width=panelWidth;
    lp.gravity=panelGravity;
    mQsDensityContainer.setLayoutParams(lp);
    mQsContainer.post(mUpdateHeader);
  }
  lp=(FrameLayout.LayoutParams)mNotificationStackScroller.getLayoutParams();
  if (lp.width != panelWidth) {
    lp.width=panelWidth;
    lp.gravity=panelGravity;
    mNotificationStackScroller.setLayoutParams(lp);
  }
}","public void updateResources(){
  int panelWidth=getResources().getDimensionPixelSize(R.dimen.notification_panel_width);
  int panelGravity=getResources().getInteger(R.integer.notification_panel_layout_gravity);
  FrameLayout.LayoutParams lp=(FrameLayout.LayoutParams)mQsDensityContainer.getLayoutParams();
  if (lp.width != panelWidth) {
    lp.width=panelWidth;
    lp.gravity=panelGravity;
    mQsDensityContainer.setLayoutParams(lp);
    mQsContainer.post(mUpdateHeader);
  }
  lp=(FrameLayout.LayoutParams)mNotificationStackScroller.getLayoutParams();
  if (lp.width != panelWidth) {
    lp.width=panelWidth;
    lp.gravity=panelGravity;
    mNotificationStackScroller.setLayoutParams(lp);
  }
}",0.9949676491732566
192502,"/** 
 * Hook to low-levels:  Reporting the current status of encryption.
 * @return A value such as {@link DevicePolicyManager#ENCRYPTION_STATUS_UNSUPPORTED},  {@link DevicePolicyManager#ENCRYPTION_STATUS_INACTIVE},  {@link DevicePolicyManager#ENCRYPTION_STATUS_ACTIVE_DEFAULT_KEY}, or  {@link DevicePolicyManager#ENCRYPTION_STATUS_ACTIVE}.
 */
private int getEncryptionStatus(){
  if (!StorageManager.isNonDefaultBlockEncrypted()) {
    return DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE_DEFAULT_KEY;
  }
 else   if (StorageManager.isEncrypted()) {
    return DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE;
  }
 else   if (StorageManager.isEncryptable()) {
    return DevicePolicyManager.ENCRYPTION_STATUS_INACTIVE;
  }
 else {
    return DevicePolicyManager.ENCRYPTION_STATUS_UNSUPPORTED;
  }
}","/** 
 * Hook to low-levels:  Reporting the current status of encryption.
 * @return A value such as {@link DevicePolicyManager#ENCRYPTION_STATUS_UNSUPPORTED},  {@link DevicePolicyManager#ENCRYPTION_STATUS_INACTIVE},  {@link DevicePolicyManager#ENCRYPTION_STATUS_ACTIVE_DEFAULT_KEY}, or  {@link DevicePolicyManager#ENCRYPTION_STATUS_ACTIVE}.
 */
private int getEncryptionStatus(){
  if (StorageManager.isEncrypted()) {
    return StorageManager.isNonDefaultBlockEncrypted() ? DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE : DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE_DEFAULT_KEY;
  }
 else   if (StorageManager.isEncryptable()) {
    return DevicePolicyManager.ENCRYPTION_STATUS_INACTIVE;
  }
 else {
    return DevicePolicyManager.ENCRYPTION_STATUS_UNSUPPORTED;
  }
}",0.8427109974424553
192503,"/** 
 * Hook to low-levels:  Reporting the current status of encryption.
 * @return A value such as {@link DevicePolicyManager#ENCRYPTION_STATUS_UNSUPPORTED},  {@link DevicePolicyManager#ENCRYPTION_STATUS_INACTIVE},  {@link DevicePolicyManager#ENCRYPTION_STATUS_ACTIVE_DEFAULT_KEY}, or  {@link DevicePolicyManager#ENCRYPTION_STATUS_ACTIVE}.
 */
private int getEncryptionStatus(){
  if (!StorageManager.isNonDefaultBlockEncrypted()) {
    return DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE_DEFAULT_KEY;
  }
 else   if (StorageManager.isEncrypted()) {
    return DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE;
  }
 else   if (StorageManager.isEncryptable()) {
    return DevicePolicyManager.ENCRYPTION_STATUS_INACTIVE;
  }
 else {
    return DevicePolicyManager.ENCRYPTION_STATUS_UNSUPPORTED;
  }
}","/** 
 * Hook to low-levels:  Reporting the current status of encryption.
 * @return A value such as {@link DevicePolicyManager#ENCRYPTION_STATUS_UNSUPPORTED},  {@link DevicePolicyManager#ENCRYPTION_STATUS_INACTIVE},  {@link DevicePolicyManager#ENCRYPTION_STATUS_ACTIVE_DEFAULT_KEY}, or  {@link DevicePolicyManager#ENCRYPTION_STATUS_ACTIVE}.
 */
private int getEncryptionStatus(){
  if (StorageManager.isEncrypted()) {
    return StorageManager.isNonDefaultBlockEncrypted() ? DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE : DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE_DEFAULT_KEY;
  }
 else   if (StorageManager.isEncryptable()) {
    return DevicePolicyManager.ENCRYPTION_STATUS_INACTIVE;
  }
 else {
    return DevicePolicyManager.ENCRYPTION_STATUS_UNSUPPORTED;
  }
}",0.8427109974424553
192504,"/** 
 * Add a new content: URI that will be monitored with a  {@link android.database.ContentObserver}, and will cause the job to execute if changed. If you have any trigger content URIs associated with a job, it will not execute until there has been a change report for one or more of them. <p>Note that trigger URIs can not be used in combination with  {@link #setPeriodic(long)} or {@link #setPersisted(boolean)}.  To continually monitor for content changes, you need to schedule a new JobInfo observing the same URIs before you finish execution of the JobService handling the most recent changes.</p>
 * @param uri The content: URI to monitor.
 */
public Builder addTriggerContentUri(@NonNull TriggerContentUri uri){
  if (mTriggerContentUris == null) {
    mTriggerContentUris=new ArrayList<>();
  }
  mTriggerContentUris.add(uri);
  return this;
}","/** 
 * Add a new content: URI that will be monitored with a  {@link android.database.ContentObserver}, and will cause the job to execute if changed. If you have any trigger content URIs associated with a job, it will not execute until there has been a change report for one or more of them. <p>Note that trigger URIs can not be used in combination with  {@link #setPeriodic(long)} or {@link #setPersisted(boolean)}.  To continually monitor for content changes, you need to schedule a new JobInfo observing the same URIs before you finish execution of the JobService handling the most recent changes.</p> <p>Because because setting this property is not compatible with periodic or persisted jobs, doing so will throw an   {@link java.lang.IllegalArgumentException} when{@link android.app.job.JobInfo.Builder#build()} is called.</p>
 * @param uri The content: URI to monitor.
 */
public Builder addTriggerContentUri(@NonNull TriggerContentUri uri){
  if (mTriggerContentUris == null) {
    mTriggerContentUris=new ArrayList<>();
  }
  mTriggerContentUris.add(uri);
  return this;
}",0.8825659596482152
192505,"private String readExifEntryValue(ByteOrderAwarenessDataInputStream dataInputStream,int dataFormat,int numberOfComponents) throws IOException {
switch (dataFormat) {
case IFD_FORMAT_BYTE:
{
      return String.valueOf(dataInputStream.readByte());
    }
case IFD_FORMAT_SBYTE:
{
    return String.valueOf(dataInputStream.readByte() & 0xff);
  }
case IFD_FORMAT_USHORT:
{
  return String.valueOf(dataInputStream.readUnsignedShort());
}
case IFD_FORMAT_SSHORT:
{
return String.valueOf(dataInputStream.readUnsignedInt());
}
case IFD_FORMAT_ULONG:
{
return String.valueOf(dataInputStream.readInt());
}
case IFD_FORMAT_SLONG:
{
return String.valueOf(dataInputStream.readInt());
}
case IFD_FORMAT_URATIONAL:
case IFD_FORMAT_SRATIONAL:
{
int numerator=dataInputStream.readInt();
int denominator=dataInputStream.readInt();
return numerator + ""String_Node_Str"" + denominator;
}
case IFD_FORMAT_SINGLE:
{
return String.valueOf(dataInputStream.readFloat());
}
case IFD_FORMAT_DOUBLE:
{
return String.valueOf(dataInputStream.readDouble());
}
case IFD_FORMAT_UNDEFINED:
case IFD_FORMAT_STRING:
{
byte[] bytes=new byte[numberOfComponents];
dataInputStream.readFully(bytes);
int index=0;
if (numberOfComponents >= EXIF_ASCII_PREFIX.length) {
boolean same=true;
for (int i=0; i < EXIF_ASCII_PREFIX.length; ++i) {
if (bytes[i] != EXIF_ASCII_PREFIX[i]) {
same=false;
break;
}
}
if (same) {
index=EXIF_ASCII_PREFIX.length;
}
}
StringBuilder stringBuilder=new StringBuilder();
while (true) {
int ch=bytes[index];
if (ch < 0) throw new EOFException();
if (ch == 0) break;
if (ch >= 32) stringBuilder.append((char)ch);
 else stringBuilder.append('?');
++index;
if (index == numberOfComponents) break;
}
return stringBuilder.toString();
}
default :
{
return null;
}
}
}","private String readExifEntryValue(ByteOrderAwarenessDataInputStream dataInputStream,int dataFormat,int numberOfComponents) throws IOException {
switch (dataFormat) {
case IFD_FORMAT_BYTE:
{
      return String.valueOf(dataInputStream.readByte());
    }
case IFD_FORMAT_SBYTE:
{
    return String.valueOf(dataInputStream.readByte() & 0xff);
  }
case IFD_FORMAT_USHORT:
{
  return String.valueOf(dataInputStream.readUnsignedShort());
}
case IFD_FORMAT_SSHORT:
{
return String.valueOf(dataInputStream.readUnsignedInt());
}
case IFD_FORMAT_ULONG:
{
return String.valueOf(dataInputStream.readInt());
}
case IFD_FORMAT_SLONG:
{
return String.valueOf(dataInputStream.readInt());
}
case IFD_FORMAT_URATIONAL:
case IFD_FORMAT_SRATIONAL:
{
int numerator=dataInputStream.readInt();
int denominator=dataInputStream.readInt();
return numerator + ""String_Node_Str"" + denominator;
}
case IFD_FORMAT_SINGLE:
{
return String.valueOf(dataInputStream.readFloat());
}
case IFD_FORMAT_DOUBLE:
{
return String.valueOf(dataInputStream.readDouble());
}
case IFD_FORMAT_UNDEFINED:
case IFD_FORMAT_STRING:
{
byte[] bytes=new byte[numberOfComponents];
dataInputStream.readFully(bytes);
int index=0;
if (numberOfComponents >= EXIF_ASCII_PREFIX.length) {
boolean same=true;
for (int i=0; i < EXIF_ASCII_PREFIX.length; ++i) {
if (bytes[i] != EXIF_ASCII_PREFIX[i]) {
same=false;
break;
}
}
if (same) {
index=EXIF_ASCII_PREFIX.length;
}
}
StringBuilder stringBuilder=new StringBuilder();
while (true) {
int ch=bytes[index];
if (ch == 0) break;
if (ch >= 32) stringBuilder.append((char)ch);
 else stringBuilder.append('?');
++index;
if (index == numberOfComponents) break;
}
return stringBuilder.toString();
}
default :
{
return null;
}
}
}",0.9889918887601392
192506,"public Bitmap peekWallpaperBitmap(Context context,boolean returnDefault,int userId){
synchronized (this) {
    if (mService != null) {
      try {
        if (!mService.isWallpaperSupported(context.getOpPackageName())) {
          return null;
        }
      }
 catch (      RemoteException e) {
        throw e.rethrowFromSystemServer();
      }
    }
    if (mWallpaper != null) {
      return mWallpaper;
    }
    if (mDefaultWallpaper != null) {
      return mDefaultWallpaper;
    }
    mWallpaper=null;
    try {
      mWallpaper=getCurrentWallpaperLocked(userId);
    }
 catch (    OutOfMemoryError e) {
      Log.w(TAG,""String_Node_Str"",e);
    }
    if (returnDefault) {
      if (mWallpaper == null) {
        mDefaultWallpaper=getDefaultWallpaperLocked(context);
        return mDefaultWallpaper;
      }
 else {
        mDefaultWallpaper=null;
      }
    }
    return mWallpaper;
  }
}","public Bitmap peekWallpaperBitmap(Context context,boolean returnDefault,int userId){
synchronized (this) {
    if (mService != null) {
      try {
        if (!mService.isWallpaperSupported(context.getOpPackageName())) {
          return null;
        }
      }
 catch (      RemoteException e) {
        throw e.rethrowFromSystemServer();
      }
    }
    if (mCachedWallpaper != null && mCachedWallpaperUserId == userId) {
      return mCachedWallpaper;
    }
    mCachedWallpaper=null;
    mCachedWallpaperUserId=0;
    try {
      mCachedWallpaper=getCurrentWallpaperLocked(userId);
      mCachedWallpaperUserId=userId;
    }
 catch (    OutOfMemoryError e) {
      Log.w(TAG,""String_Node_Str"",e);
    }
    if (mCachedWallpaper != null) {
      return mCachedWallpaper;
    }
    if (returnDefault) {
      if (mDefaultWallpaper == null) {
        mDefaultWallpaper=getDefaultWallpaperLocked(context);
      }
      return mDefaultWallpaper;
    }
    return null;
  }
}",0.6982942430703625
192507,"void finishInstrumentationLocked(ProcessRecord app,int resultCode,Bundle results){
  if (app.instrumentationWatcher != null) {
    try {
      app.instrumentationWatcher.instrumentationFinished(app.instrumentationClass,resultCode,results);
    }
 catch (    RemoteException e) {
    }
  }
  if (app.instrumentationUiAutomationConnection != null) {
    mHandler.obtainMessage(SHUTDOWN_UI_AUTOMATION_CONNECTION_MSG,app.instrumentationUiAutomationConnection).sendToTarget();
  }
  app.instrumentationWatcher=null;
  app.instrumentationUiAutomationConnection=null;
  app.instrumentationClass=null;
  app.instrumentationInfo=null;
  app.instrumentationProfileFile=null;
  app.instrumentationArguments=null;
  forceStopPackageLocked(app.info.packageName,-1,false,false,true,true,false,app.userId,""String_Node_Str"");
}","void finishInstrumentationLocked(ProcessRecord app,int resultCode,Bundle results){
  if (app.instrumentationWatcher != null) {
    mInstrumentationReporter.reportFinished(app.instrumentationWatcher,app.instrumentationClass,resultCode,results);
  }
  if (app.instrumentationUiAutomationConnection != null) {
    mHandler.obtainMessage(SHUTDOWN_UI_AUTOMATION_CONNECTION_MSG,app.instrumentationUiAutomationConnection).sendToTarget();
  }
  app.instrumentationWatcher=null;
  app.instrumentationUiAutomationConnection=null;
  app.instrumentationClass=null;
  app.instrumentationInfo=null;
  app.instrumentationProfileFile=null;
  app.instrumentationArguments=null;
  forceStopPackageLocked(app.info.packageName,-1,false,false,true,true,false,app.userId,""String_Node_Str"");
}",0.922201138519924
192508,"public boolean startInstrumentation(ComponentName className,String profileFile,int flags,Bundle arguments,IInstrumentationWatcher watcher,IUiAutomationConnection uiAutomationConnection,int userId,String abiOverride){
  enforceNotIsolatedCaller(""String_Node_Str"");
  userId=mUserController.handleIncomingUser(Binder.getCallingPid(),Binder.getCallingUid(),userId,false,ALLOW_FULL_ONLY,""String_Node_Str"",null);
  if (arguments != null && arguments.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
synchronized (this) {
    InstrumentationInfo ii=null;
    ApplicationInfo ai=null;
    try {
      ii=mContext.getPackageManager().getInstrumentationInfo(className,STOCK_PM_FLAGS);
      ai=AppGlobals.getPackageManager().getApplicationInfo(ii.targetPackage,STOCK_PM_FLAGS,userId);
    }
 catch (    PackageManager.NameNotFoundException e) {
    }
catch (    RemoteException e) {
    }
    if (ii == null) {
      reportStartInstrumentationFailure(watcher,className,""String_Node_Str"" + className);
      return false;
    }
    if (ai == null) {
      reportStartInstrumentationFailure(watcher,className,""String_Node_Str"" + ii.targetPackage);
      return false;
    }
    if (!ai.hasCode()) {
      reportStartInstrumentationFailure(watcher,className,""String_Node_Str"" + ii.targetPackage);
      return false;
    }
    int match=mContext.getPackageManager().checkSignatures(ii.targetPackage,ii.packageName);
    if (match < 0 && match != PackageManager.SIGNATURE_FIRST_NOT_SIGNED) {
      String msg=""String_Node_Str"" + className + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ ii.packageName+ ""String_Node_Str""+ ii.targetPackage;
      reportStartInstrumentationFailure(watcher,className,msg);
      throw new SecurityException(msg);
    }
    final long origId=Binder.clearCallingIdentity();
    forceStopPackageLocked(ii.targetPackage,-1,true,false,true,true,false,userId,""String_Node_Str"");
    ProcessRecord app=addAppLocked(ai,false,abiOverride);
    app.instrumentationClass=className;
    app.instrumentationInfo=ai;
    app.instrumentationProfileFile=profileFile;
    app.instrumentationArguments=arguments;
    app.instrumentationWatcher=watcher;
    app.instrumentationUiAutomationConnection=uiAutomationConnection;
    app.instrumentationResultClass=className;
    Binder.restoreCallingIdentity(origId);
  }
  return true;
}","public boolean startInstrumentation(ComponentName className,String profileFile,int flags,Bundle arguments,IInstrumentationWatcher watcher,IUiAutomationConnection uiAutomationConnection,int userId,String abiOverride){
  enforceNotIsolatedCaller(""String_Node_Str"");
  userId=mUserController.handleIncomingUser(Binder.getCallingPid(),Binder.getCallingUid(),userId,false,ALLOW_FULL_ONLY,""String_Node_Str"",null);
  if (arguments != null && arguments.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
synchronized (this) {
    InstrumentationInfo ii=null;
    ApplicationInfo ai=null;
    try {
      ii=mContext.getPackageManager().getInstrumentationInfo(className,STOCK_PM_FLAGS);
      ai=AppGlobals.getPackageManager().getApplicationInfo(ii.targetPackage,STOCK_PM_FLAGS,userId);
    }
 catch (    PackageManager.NameNotFoundException e) {
    }
catch (    RemoteException e) {
    }
    if (ii == null) {
      reportStartInstrumentationFailureLocked(watcher,className,""String_Node_Str"" + className);
      return false;
    }
    if (ai == null) {
      reportStartInstrumentationFailureLocked(watcher,className,""String_Node_Str"" + ii.targetPackage);
      return false;
    }
    if (!ai.hasCode()) {
      reportStartInstrumentationFailureLocked(watcher,className,""String_Node_Str"" + ii.targetPackage);
      return false;
    }
    int match=mContext.getPackageManager().checkSignatures(ii.targetPackage,ii.packageName);
    if (match < 0 && match != PackageManager.SIGNATURE_FIRST_NOT_SIGNED) {
      String msg=""String_Node_Str"" + className + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ ii.packageName+ ""String_Node_Str""+ ii.targetPackage;
      reportStartInstrumentationFailureLocked(watcher,className,msg);
      throw new SecurityException(msg);
    }
    final long origId=Binder.clearCallingIdentity();
    forceStopPackageLocked(ii.targetPackage,-1,true,false,true,true,false,userId,""String_Node_Str"");
    ProcessRecord app=addAppLocked(ai,false,abiOverride);
    app.instrumentationClass=className;
    app.instrumentationInfo=ai;
    app.instrumentationProfileFile=profileFile;
    app.instrumentationArguments=arguments;
    app.instrumentationWatcher=watcher;
    app.instrumentationUiAutomationConnection=uiAutomationConnection;
    app.instrumentationResultClass=className;
    Binder.restoreCallingIdentity(origId);
  }
  return true;
}",0.9950839819746006
192509,"private void onFacetClicked(int index){
  Intent intent=mIntents.get(index);
  String packageName=intent.getPackage();
  if (packageName == null) {
    return;
  }
  if (packageName.equals(mCurrentPackageName) && index == mCurrentFacetIndex) {
    return;
  }
  intent.putExtra(EXTRA_FACET_CATEGORIES,mFacetCategories.get(index));
  intent.putExtra(EXTRA_FACET_PACKAGES,mFacetPackages.get(index));
  intent.putExtra(EXTRA_FACET_ID,Integer.toString(index));
  intent.putExtra(EXTRA_FACET_LAUNCH_PICKER,index == mCurrentFacetIndex);
  setCurrentFacet(index);
  startActivity(intent);
}","private void onFacetClicked(int index){
  Intent intent=mIntents.get(index);
  String packageName=intent.getPackage();
  if (packageName == null) {
    return;
  }
  intent.putExtra(EXTRA_FACET_CATEGORIES,mFacetCategories.get(index));
  intent.putExtra(EXTRA_FACET_PACKAGES,mFacetPackages.get(index));
  intent.putExtra(EXTRA_FACET_ID,Integer.toString(index));
  intent.putExtra(EXTRA_FACET_LAUNCH_PICKER,index == mCurrentFacetIndex);
  setCurrentFacet(index);
  startActivity(intent);
}",0.9102803738317756
192510,"public void taskChanged(String packageName){
  mCurrentPackageName=packageName;
  if (mFacetPackageMap.containsKey(packageName)) {
    setCurrentFacet(mFacetPackageMap.get(packageName));
  }
  String category=getPackageCategory(packageName);
  if (category != null) {
    setCurrentFacet(mFacetCategoryMap.get(category));
  }
}","public void taskChanged(String packageName){
  if (mFacetPackageMap.containsKey(packageName)) {
    setCurrentFacet(mFacetPackageMap.get(packageName));
  }
  String category=getPackageCategory(packageName);
  if (category != null) {
    setCurrentFacet(mFacetCategoryMap.get(category));
  }
}",0.9434571890145396
192511,"private void startActivateAnimation(final boolean reverse){
  if (!isAttachedToWindow()) {
    return;
  }
  int widthHalf=mBackgroundNormal.getWidth() / 2;
  int heightHalf=mBackgroundNormal.getActualHeight() / 2;
  float radius=(float)Math.sqrt(widthHalf * widthHalf + heightHalf * heightHalf);
  Animator animator;
  if (reverse) {
    animator=ViewAnimationUtils.createCircularReveal(mBackgroundNormal,widthHalf,heightHalf,radius,0);
  }
 else {
    animator=ViewAnimationUtils.createCircularReveal(mBackgroundNormal,widthHalf,heightHalf,0,radius);
  }
  mBackgroundNormal.setVisibility(View.VISIBLE);
  Interpolator interpolator;
  Interpolator alphaInterpolator;
  if (!reverse) {
    interpolator=Interpolators.LINEAR_OUT_SLOW_IN;
    alphaInterpolator=Interpolators.LINEAR_OUT_SLOW_IN;
  }
 else {
    interpolator=ACTIVATE_INVERSE_INTERPOLATOR;
    alphaInterpolator=ACTIVATE_INVERSE_ALPHA_INTERPOLATOR;
  }
  animator.setInterpolator(interpolator);
  animator.setDuration(ACTIVATE_ANIMATION_LENGTH);
  if (reverse) {
    mBackgroundNormal.setAlpha(1f);
    animator.addListener(new AnimatorListenerAdapter(){
      @Override public void onAnimationEnd(      Animator animation){
        if (mDimmed) {
          mBackgroundNormal.setVisibility(View.INVISIBLE);
        }
      }
    }
);
    animator.start();
  }
 else {
    mBackgroundNormal.setAlpha(0.4f);
    animator.start();
  }
  mBackgroundNormal.animate().alpha(reverse ? 0f : 1f).setInterpolator(alphaInterpolator).setUpdateListener(new ValueAnimator.AnimatorUpdateListener(){
    @Override public void onAnimationUpdate(    ValueAnimator animation){
      float animatedFraction=animation.getAnimatedFraction();
      if (reverse) {
        animatedFraction=1.0f - animatedFraction;
      }
      setNormalBackgroundVisibilityAmount(animatedFraction);
    }
  }
).setDuration(ACTIVATE_ANIMATION_LENGTH);
}","private void startActivateAnimation(final boolean reverse){
  if (!isAttachedToWindow()) {
    return;
  }
  int widthHalf=mBackgroundNormal.getWidth() / 2;
  int heightHalf=mBackgroundNormal.getActualHeight() / 2;
  float radius=(float)Math.sqrt(widthHalf * widthHalf + heightHalf * heightHalf);
  Animator animator;
  if (reverse) {
    animator=ViewAnimationUtils.createCircularReveal(mBackgroundNormal,widthHalf,heightHalf,radius,0);
  }
 else {
    animator=ViewAnimationUtils.createCircularReveal(mBackgroundNormal,widthHalf,heightHalf,0,radius);
  }
  mBackgroundNormal.setVisibility(View.VISIBLE);
  Interpolator interpolator;
  Interpolator alphaInterpolator;
  if (!reverse) {
    interpolator=Interpolators.LINEAR_OUT_SLOW_IN;
    alphaInterpolator=Interpolators.LINEAR_OUT_SLOW_IN;
  }
 else {
    interpolator=ACTIVATE_INVERSE_INTERPOLATOR;
    alphaInterpolator=ACTIVATE_INVERSE_ALPHA_INTERPOLATOR;
  }
  animator.setInterpolator(interpolator);
  animator.setDuration(ACTIVATE_ANIMATION_LENGTH);
  if (reverse) {
    mBackgroundNormal.setAlpha(1f);
    animator.addListener(new AnimatorListenerAdapter(){
      @Override public void onAnimationEnd(      Animator animation){
        updateBackground();
      }
    }
);
    animator.start();
  }
 else {
    mBackgroundNormal.setAlpha(0.4f);
    animator.start();
  }
  mBackgroundNormal.animate().alpha(reverse ? 0f : 1f).setInterpolator(alphaInterpolator).setUpdateListener(new ValueAnimator.AnimatorUpdateListener(){
    @Override public void onAnimationUpdate(    ValueAnimator animation){
      float animatedFraction=animation.getAnimatedFraction();
      if (reverse) {
        animatedFraction=1.0f - animatedFraction;
      }
      setNormalBackgroundVisibilityAmount(animatedFraction);
    }
  }
).setDuration(ACTIVATE_ANIMATION_LENGTH);
}",0.9777777777777776
192512,"public void setDark(boolean dark,boolean fade,long delay){
  super.setDark(dark,fade,delay);
  if (mDark == dark) {
    return;
  }
  mDark=dark;
  if (!dark && fade && !shouldHideBackground()) {
    if (mActivated) {
      mBackgroundDimmed.setVisibility(View.VISIBLE);
      mBackgroundNormal.setVisibility(View.VISIBLE);
    }
 else     if (mDimmed) {
      mBackgroundDimmed.setVisibility(View.VISIBLE);
      mBackgroundNormal.setVisibility(View.INVISIBLE);
    }
 else {
      mBackgroundDimmed.setVisibility(View.INVISIBLE);
      mBackgroundNormal.setVisibility(View.VISIBLE);
    }
    fadeInFromDark(delay);
  }
 else {
    updateBackground();
  }
  updateOutlineAlpha();
}","public void setDark(boolean dark,boolean fade,long delay){
  super.setDark(dark,fade,delay);
  if (mDark == dark) {
    return;
  }
  mDark=dark;
  updateBackground();
  if (!dark && fade && !shouldHideBackground()) {
    fadeInFromDark(delay);
  }
  updateOutlineAlpha();
}",0.4242424242424242
192513,"/** 
 * Cancels the hotspot and makes the notification inactive.
 */
public void makeInactive(boolean animate){
  if (mActivated) {
    if (mDimmed) {
      if (animate) {
        startActivateAnimation(true);
      }
 else {
        mBackgroundNormal.setVisibility(View.INVISIBLE);
      }
    }
    mActivated=false;
  }
  if (mOnActivatedListener != null) {
    mOnActivatedListener.onActivationReset(this);
  }
  removeCallbacks(mTapTimeoutRunnable);
}","/** 
 * Cancels the hotspot and makes the notification inactive.
 */
public void makeInactive(boolean animate){
  if (mActivated) {
    mActivated=false;
    if (mDimmed) {
      if (animate) {
        startActivateAnimation(true);
      }
 else {
        updateBackground();
      }
    }
  }
  if (mOnActivatedListener != null) {
    mOnActivatedListener.onActivationReset(this);
  }
  removeCallbacks(mTapTimeoutRunnable);
}",0.9014722536806342
192514,"/** 
 * Fades in the background when exiting dark mode.
 */
private void fadeInFromDark(long delay){
  final View background=mDimmed ? mBackgroundDimmed : mBackgroundNormal;
  background.setAlpha(0f);
  background.setPivotX(mBackgroundDimmed.getWidth() / 2f);
  background.setPivotY(getActualHeight() / 2f);
  background.setScaleX(DARK_EXIT_SCALE_START);
  background.setScaleY(DARK_EXIT_SCALE_START);
  background.animate().alpha(1f).scaleX(1f).scaleY(1f).setDuration(DARK_ANIMATION_LENGTH).setStartDelay(delay).setInterpolator(Interpolators.LINEAR_OUT_SLOW_IN).setListener(new AnimatorListenerAdapter(){
    @Override public void onAnimationCancel(    Animator animation){
      background.setScaleX(1f);
      background.setScaleY(1f);
      background.setAlpha(1f);
    }
  }
).setUpdateListener(mBackgroundVisibilityUpdater).start();
  mFadeInFromDarkAnimator=TimeAnimator.ofFloat(0.0f,1.0f);
  mFadeInFromDarkAnimator.setDuration(DARK_ANIMATION_LENGTH);
  mFadeInFromDarkAnimator.setStartDelay(delay);
  mFadeInFromDarkAnimator.setInterpolator(Interpolators.LINEAR_OUT_SLOW_IN);
  mFadeInFromDarkAnimator.addListener(mFadeInEndListener);
  mFadeInFromDarkAnimator.addUpdateListener(mUpdateOutlineListener);
  mFadeInFromDarkAnimator.start();
}","/** 
 * Fades in the background when exiting dark mode.
 */
private void fadeInFromDark(long delay){
  final View background=mDimmed ? mBackgroundDimmed : mBackgroundNormal;
  background.setAlpha(0f);
  mBackgroundVisibilityUpdater.onAnimationUpdate(null);
  background.setPivotX(mBackgroundDimmed.getWidth() / 2f);
  background.setPivotY(getActualHeight() / 2f);
  background.setScaleX(DARK_EXIT_SCALE_START);
  background.setScaleY(DARK_EXIT_SCALE_START);
  background.animate().alpha(1f).scaleX(1f).scaleY(1f).setDuration(DARK_ANIMATION_LENGTH).setStartDelay(delay).setInterpolator(Interpolators.LINEAR_OUT_SLOW_IN).setListener(new AnimatorListenerAdapter(){
    @Override public void onAnimationCancel(    Animator animation){
      background.setScaleX(1f);
      background.setScaleY(1f);
      background.setAlpha(1f);
    }
  }
).setUpdateListener(mBackgroundVisibilityUpdater).start();
  mFadeInFromDarkAnimator=TimeAnimator.ofFloat(0.0f,1.0f);
  mFadeInFromDarkAnimator.setDuration(DARK_ANIMATION_LENGTH);
  mFadeInFromDarkAnimator.setStartDelay(delay);
  mFadeInFromDarkAnimator.setInterpolator(Interpolators.LINEAR_OUT_SLOW_IN);
  mFadeInFromDarkAnimator.addListener(mFadeInEndListener);
  mFadeInFromDarkAnimator.addUpdateListener(mUpdateOutlineListener);
  mFadeInFromDarkAnimator.start();
}",0.9780736100234926
192515,"protected void updateBackground(){
  cancelFadeAnimations();
  if (shouldHideBackground()) {
    mBackgroundDimmed.setVisibility(View.INVISIBLE);
    mBackgroundNormal.setVisibility(View.INVISIBLE);
  }
 else   if (mDimmed) {
    mBackgroundDimmed.setVisibility(View.VISIBLE);
    mBackgroundNormal.setVisibility(View.INVISIBLE);
  }
 else {
    mBackgroundDimmed.setVisibility(View.INVISIBLE);
    mBackgroundNormal.setVisibility(View.VISIBLE);
    mBackgroundNormal.setAlpha(1f);
    removeCallbacks(mTapTimeoutRunnable);
  }
  setNormalBackgroundVisibilityAmount(mBackgroundNormal.getVisibility() == View.VISIBLE ? 1.0f : 0.0f);
}","protected void updateBackground(){
  cancelFadeAnimations();
  if (shouldHideBackground()) {
    mBackgroundDimmed.setVisibility(View.INVISIBLE);
    mBackgroundNormal.setVisibility(View.INVISIBLE);
  }
 else   if (mDimmed) {
    mBackgroundDimmed.setVisibility(View.VISIBLE);
    mBackgroundNormal.setVisibility(mActivated ? View.VISIBLE : View.INVISIBLE);
  }
 else {
    mBackgroundDimmed.setVisibility(View.INVISIBLE);
    mBackgroundNormal.setVisibility(View.VISIBLE);
    mBackgroundNormal.setAlpha(1f);
    removeCallbacks(mTapTimeoutRunnable);
    makeInactive(false);
  }
  setNormalBackgroundVisibilityAmount(mBackgroundNormal.getVisibility() == View.VISIBLE ? 1.0f : 0.0f);
}",0.9598180439727066
192516,"/** 
 * Fades the background when the dimmed state changes.
 */
private void fadeDimmedBackground(){
  mBackgroundDimmed.animate().cancel();
  mBackgroundNormal.animate().cancel();
  if (!shouldHideBackground()) {
    if (mDimmed) {
      mBackgroundDimmed.setVisibility(View.VISIBLE);
    }
 else {
      mBackgroundNormal.setVisibility(View.VISIBLE);
    }
  }
  float startAlpha=mDimmed ? 1f : 0;
  float endAlpha=mDimmed ? 0 : 1f;
  int duration=BACKGROUND_ANIMATION_LENGTH_MS;
  if (mBackgroundAnimator != null) {
    startAlpha=(Float)mBackgroundAnimator.getAnimatedValue();
    duration=(int)mBackgroundAnimator.getCurrentPlayTime();
    mBackgroundAnimator.removeAllListeners();
    mBackgroundAnimator.cancel();
    if (duration <= 0) {
      updateBackground();
      return;
    }
  }
  mBackgroundNormal.setAlpha(startAlpha);
  mBackgroundAnimator=ObjectAnimator.ofFloat(mBackgroundNormal,View.ALPHA,startAlpha,endAlpha);
  mBackgroundAnimator.setInterpolator(Interpolators.FAST_OUT_SLOW_IN);
  mBackgroundAnimator.setDuration(duration);
  mBackgroundAnimator.addListener(new AnimatorListenerAdapter(){
    @Override public void onAnimationEnd(    Animator animation){
      if (mDimmed) {
        mBackgroundNormal.setVisibility(View.INVISIBLE);
      }
 else {
        mBackgroundDimmed.setVisibility(View.INVISIBLE);
      }
      mBackgroundAnimator=null;
    }
  }
);
  mBackgroundAnimator.addUpdateListener(mBackgroundVisibilityUpdater);
  mBackgroundAnimator.start();
}","/** 
 * Fades the background when the dimmed state changes.
 */
private void fadeDimmedBackground(){
  mBackgroundDimmed.animate().cancel();
  mBackgroundNormal.animate().cancel();
  if (mActivated) {
    updateBackground();
    return;
  }
  if (!shouldHideBackground()) {
    if (mDimmed) {
      mBackgroundDimmed.setVisibility(View.VISIBLE);
    }
 else {
      mBackgroundNormal.setVisibility(View.VISIBLE);
    }
  }
  float startAlpha=mDimmed ? 1f : 0;
  float endAlpha=mDimmed ? 0 : 1f;
  int duration=BACKGROUND_ANIMATION_LENGTH_MS;
  if (mBackgroundAnimator != null) {
    startAlpha=(Float)mBackgroundAnimator.getAnimatedValue();
    duration=(int)mBackgroundAnimator.getCurrentPlayTime();
    mBackgroundAnimator.removeAllListeners();
    mBackgroundAnimator.cancel();
    if (duration <= 0) {
      updateBackground();
      return;
    }
  }
  mBackgroundNormal.setAlpha(startAlpha);
  mBackgroundAnimator=ObjectAnimator.ofFloat(mBackgroundNormal,View.ALPHA,startAlpha,endAlpha);
  mBackgroundAnimator.setInterpolator(Interpolators.FAST_OUT_SLOW_IN);
  mBackgroundAnimator.setDuration(duration);
  mBackgroundAnimator.addListener(new AnimatorListenerAdapter(){
    @Override public void onAnimationEnd(    Animator animation){
      updateBackground();
      mBackgroundAnimator=null;
    }
  }
);
  mBackgroundAnimator.addUpdateListener(mBackgroundVisibilityUpdater);
  mBackgroundAnimator.start();
}",0.9204271443334482
192517,"void finishInstrumentationLocked(ProcessRecord app,int resultCode,Bundle results){
  if (app.instrumentationWatcher != null) {
    try {
      app.instrumentationWatcher.instrumentationFinished(app.instrumentationClass,resultCode,results);
    }
 catch (    RemoteException e) {
    }
  }
  if (app.instrumentationUiAutomationConnection != null) {
    mHandler.obtainMessage(SHUTDOWN_UI_AUTOMATION_CONNECTION_MSG,app.instrumentationUiAutomationConnection).sendToTarget();
  }
  app.instrumentationWatcher=null;
  app.instrumentationUiAutomationConnection=null;
  app.instrumentationClass=null;
  app.instrumentationInfo=null;
  app.instrumentationProfileFile=null;
  app.instrumentationArguments=null;
  forceStopPackageLocked(app.info.packageName,-1,false,false,true,true,false,app.userId,""String_Node_Str"");
}","void finishInstrumentationLocked(ProcessRecord app,int resultCode,Bundle results){
  if (app.instrumentationWatcher != null) {
    mInstrumentationReporter.reportFinished(app.instrumentationWatcher,app.instrumentationClass,resultCode,results);
  }
  if (app.instrumentationUiAutomationConnection != null) {
    mHandler.obtainMessage(SHUTDOWN_UI_AUTOMATION_CONNECTION_MSG,app.instrumentationUiAutomationConnection).sendToTarget();
  }
  app.instrumentationWatcher=null;
  app.instrumentationUiAutomationConnection=null;
  app.instrumentationClass=null;
  app.instrumentationInfo=null;
  app.instrumentationProfileFile=null;
  app.instrumentationArguments=null;
  forceStopPackageLocked(app.info.packageName,-1,false,false,true,true,false,app.userId,""String_Node_Str"");
}",0.922201138519924
192518,"public boolean startInstrumentation(ComponentName className,String profileFile,int flags,Bundle arguments,IInstrumentationWatcher watcher,IUiAutomationConnection uiAutomationConnection,int userId,String abiOverride){
  enforceNotIsolatedCaller(""String_Node_Str"");
  userId=mUserController.handleIncomingUser(Binder.getCallingPid(),Binder.getCallingUid(),userId,false,ALLOW_FULL_ONLY,""String_Node_Str"",null);
  if (arguments != null && arguments.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
synchronized (this) {
    InstrumentationInfo ii=null;
    ApplicationInfo ai=null;
    try {
      ii=mContext.getPackageManager().getInstrumentationInfo(className,STOCK_PM_FLAGS);
      ai=AppGlobals.getPackageManager().getApplicationInfo(ii.targetPackage,STOCK_PM_FLAGS,userId);
    }
 catch (    PackageManager.NameNotFoundException e) {
    }
catch (    RemoteException e) {
    }
    if (ii == null) {
      reportStartInstrumentationFailure(watcher,className,""String_Node_Str"" + className);
      return false;
    }
    if (ai == null) {
      reportStartInstrumentationFailure(watcher,className,""String_Node_Str"" + ii.targetPackage);
      return false;
    }
    if (!ai.hasCode()) {
      reportStartInstrumentationFailure(watcher,className,""String_Node_Str"" + ii.targetPackage);
      return false;
    }
    int match=mContext.getPackageManager().checkSignatures(ii.targetPackage,ii.packageName);
    if (match < 0 && match != PackageManager.SIGNATURE_FIRST_NOT_SIGNED) {
      String msg=""String_Node_Str"" + className + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ ii.packageName+ ""String_Node_Str""+ ii.targetPackage;
      reportStartInstrumentationFailure(watcher,className,msg);
      throw new SecurityException(msg);
    }
    final long origId=Binder.clearCallingIdentity();
    forceStopPackageLocked(ii.targetPackage,-1,true,false,true,true,false,userId,""String_Node_Str"");
    ProcessRecord app=addAppLocked(ai,false,abiOverride);
    app.instrumentationClass=className;
    app.instrumentationInfo=ai;
    app.instrumentationProfileFile=profileFile;
    app.instrumentationArguments=arguments;
    app.instrumentationWatcher=watcher;
    app.instrumentationUiAutomationConnection=uiAutomationConnection;
    app.instrumentationResultClass=className;
    Binder.restoreCallingIdentity(origId);
  }
  return true;
}","public boolean startInstrumentation(ComponentName className,String profileFile,int flags,Bundle arguments,IInstrumentationWatcher watcher,IUiAutomationConnection uiAutomationConnection,int userId,String abiOverride){
  enforceNotIsolatedCaller(""String_Node_Str"");
  userId=mUserController.handleIncomingUser(Binder.getCallingPid(),Binder.getCallingUid(),userId,false,ALLOW_FULL_ONLY,""String_Node_Str"",null);
  if (arguments != null && arguments.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
synchronized (this) {
    InstrumentationInfo ii=null;
    ApplicationInfo ai=null;
    try {
      ii=mContext.getPackageManager().getInstrumentationInfo(className,STOCK_PM_FLAGS);
      ai=AppGlobals.getPackageManager().getApplicationInfo(ii.targetPackage,STOCK_PM_FLAGS,userId);
    }
 catch (    PackageManager.NameNotFoundException e) {
    }
catch (    RemoteException e) {
    }
    if (ii == null) {
      reportStartInstrumentationFailureLocked(watcher,className,""String_Node_Str"" + className);
      return false;
    }
    if (ai == null) {
      reportStartInstrumentationFailureLocked(watcher,className,""String_Node_Str"" + ii.targetPackage);
      return false;
    }
    if (!ai.hasCode()) {
      reportStartInstrumentationFailureLocked(watcher,className,""String_Node_Str"" + ii.targetPackage);
      return false;
    }
    int match=mContext.getPackageManager().checkSignatures(ii.targetPackage,ii.packageName);
    if (match < 0 && match != PackageManager.SIGNATURE_FIRST_NOT_SIGNED) {
      String msg=""String_Node_Str"" + className + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ ii.packageName+ ""String_Node_Str""+ ii.targetPackage;
      reportStartInstrumentationFailureLocked(watcher,className,msg);
      throw new SecurityException(msg);
    }
    final long origId=Binder.clearCallingIdentity();
    forceStopPackageLocked(ii.targetPackage,-1,true,false,true,true,false,userId,""String_Node_Str"");
    ProcessRecord app=addAppLocked(ai,false,abiOverride);
    app.instrumentationClass=className;
    app.instrumentationInfo=ai;
    app.instrumentationProfileFile=profileFile;
    app.instrumentationArguments=arguments;
    app.instrumentationWatcher=watcher;
    app.instrumentationUiAutomationConnection=uiAutomationConnection;
    app.instrumentationResultClass=className;
    Binder.restoreCallingIdentity(origId);
  }
  return true;
}",0.9950839819746006
192519,"public Bitmap peekWallpaperBitmap(Context context,boolean returnDefault,int userId){
synchronized (this) {
    if (mService != null) {
      try {
        if (!mService.isWallpaperSupported(context.getOpPackageName())) {
          return null;
        }
      }
 catch (      RemoteException e) {
        throw e.rethrowFromSystemServer();
      }
    }
    if (mWallpaper != null) {
      return mWallpaper;
    }
    if (mDefaultWallpaper != null) {
      return mDefaultWallpaper;
    }
    mWallpaper=null;
    try {
      mWallpaper=getCurrentWallpaperLocked(userId);
    }
 catch (    OutOfMemoryError e) {
      Log.w(TAG,""String_Node_Str"",e);
    }
    if (returnDefault) {
      if (mWallpaper == null) {
        mDefaultWallpaper=getDefaultWallpaperLocked(context);
        return mDefaultWallpaper;
      }
 else {
        mDefaultWallpaper=null;
      }
    }
    return mWallpaper;
  }
}","public Bitmap peekWallpaperBitmap(Context context,boolean returnDefault,int userId){
synchronized (this) {
    if (mService != null) {
      try {
        if (!mService.isWallpaperSupported(context.getOpPackageName())) {
          return null;
        }
      }
 catch (      RemoteException e) {
        throw e.rethrowFromSystemServer();
      }
    }
    if (mCachedWallpaper != null && mCachedWallpaperUserId == userId) {
      return mCachedWallpaper;
    }
    mCachedWallpaper=null;
    mCachedWallpaperUserId=0;
    try {
      mCachedWallpaper=getCurrentWallpaperLocked(userId);
      mCachedWallpaperUserId=userId;
    }
 catch (    OutOfMemoryError e) {
      Log.w(TAG,""String_Node_Str"",e);
    }
    if (mCachedWallpaper != null) {
      return mCachedWallpaper;
    }
    if (returnDefault) {
      if (mDefaultWallpaper == null) {
        mDefaultWallpaper=getDefaultWallpaperLocked(context);
      }
      return mDefaultWallpaper;
    }
    return null;
  }
}",0.6982942430703625
192520,"private void handlePulseWhileDozing(@NonNull PulseCallback callback,int reason){
  mDozeScrimController.pulse(callback,reason);
}","private void handlePulseWhileDozing(@NonNull PulseCallback callback,int reason){
  mDozeScrimController.pulse(new PulseCallback(){
    @Override public void onPulseStarted(){
      callback.onPulseStarted();
      mStackScroller.setPulsing(true);
    }
    @Override public void onPulseFinished(){
      callback.onPulseFinished();
      mStackScroller.setPulsing(false);
    }
  }
,reason);
}",0.4636015325670498
192521,"private void updateNotificationAnimationStates(){
  boolean running=mAnimationsEnabled;
  int childCount=getChildCount();
  for (int i=0; i < childCount; i++) {
    View child=getChildAt(i);
    running&=mIsExpanded || isPinnedHeadsUp(child);
    updateAnimationState(running,child);
  }
}","private void updateNotificationAnimationStates(){
  boolean running=mAnimationsEnabled || mPulsing;
  int childCount=getChildCount();
  for (int i=0; i < childCount; i++) {
    View child=getChildAt(i);
    running&=mIsExpanded || isPinnedHeadsUp(child);
    updateAnimationState(running,child);
  }
}",0.9796610169491524
192522,"private void handlePulseWhileDozing(@NonNull PulseCallback callback,int reason){
  mDozeScrimController.pulse(callback,reason);
}","private void handlePulseWhileDozing(@NonNull PulseCallback callback,int reason){
  mDozeScrimController.pulse(new PulseCallback(){
    @Override public void onPulseStarted(){
      callback.onPulseStarted();
      mStackScroller.setPulsing(true);
    }
    @Override public void onPulseFinished(){
      callback.onPulseFinished();
      mStackScroller.setPulsing(false);
    }
  }
,reason);
}",0.4636015325670498
192523,"private void updateNotificationAnimationStates(){
  boolean running=mAnimationsEnabled;
  int childCount=getChildCount();
  for (int i=0; i < childCount; i++) {
    View child=getChildAt(i);
    running&=mIsExpanded || isPinnedHeadsUp(child);
    updateAnimationState(running,child);
  }
}","private void updateNotificationAnimationStates(){
  boolean running=mAnimationsEnabled || mPulsing;
  int childCount=getChildCount();
  for (int i=0; i < childCount; i++) {
    View child=getChildAt(i);
    running&=mIsExpanded || isPinnedHeadsUp(child);
    updateAnimationState(running,child);
  }
}",0.9796610169491524
192524,"private String readExifEntryValue(ByteOrderAwarenessDataInputStream dataInputStream,int dataFormat,int numberOfComponents) throws IOException {
switch (dataFormat) {
case IFD_FORMAT_BYTE:
{
      return String.valueOf(dataInputStream.readByte());
    }
case IFD_FORMAT_SBYTE:
{
    return String.valueOf(dataInputStream.readByte() & 0xff);
  }
case IFD_FORMAT_USHORT:
{
  return String.valueOf(dataInputStream.readUnsignedShort());
}
case IFD_FORMAT_SSHORT:
{
return String.valueOf(dataInputStream.readUnsignedInt());
}
case IFD_FORMAT_ULONG:
{
return String.valueOf(dataInputStream.readInt());
}
case IFD_FORMAT_SLONG:
{
return String.valueOf(dataInputStream.readInt());
}
case IFD_FORMAT_URATIONAL:
case IFD_FORMAT_SRATIONAL:
{
int numerator=dataInputStream.readInt();
int denominator=dataInputStream.readInt();
return numerator + ""String_Node_Str"" + denominator;
}
case IFD_FORMAT_SINGLE:
{
return String.valueOf(dataInputStream.readFloat());
}
case IFD_FORMAT_DOUBLE:
{
return String.valueOf(dataInputStream.readDouble());
}
case IFD_FORMAT_UNDEFINED:
case IFD_FORMAT_STRING:
{
byte[] bytes=new byte[numberOfComponents];
dataInputStream.readFully(bytes);
int index=0;
if (numberOfComponents >= EXIF_ASCII_PREFIX.length) {
boolean same=true;
for (int i=0; i < EXIF_ASCII_PREFIX.length; ++i) {
if (bytes[i] != EXIF_ASCII_PREFIX[i]) {
same=false;
break;
}
}
if (same) {
index=EXIF_ASCII_PREFIX.length;
}
}
StringBuilder stringBuilder=new StringBuilder();
while (true) {
int ch=bytes[index];
if (ch < 0) throw new EOFException();
if (ch == 0) break;
if (ch >= 32) stringBuilder.append((char)ch);
 else stringBuilder.append('?');
++index;
if (index == numberOfComponents) break;
}
return stringBuilder.toString();
}
default :
{
return null;
}
}
}","private String readExifEntryValue(ByteOrderAwarenessDataInputStream dataInputStream,int dataFormat,int numberOfComponents) throws IOException {
switch (dataFormat) {
case IFD_FORMAT_BYTE:
{
      return String.valueOf(dataInputStream.readByte());
    }
case IFD_FORMAT_SBYTE:
{
    return String.valueOf(dataInputStream.readByte() & 0xff);
  }
case IFD_FORMAT_USHORT:
{
  return String.valueOf(dataInputStream.readUnsignedShort());
}
case IFD_FORMAT_SSHORT:
{
return String.valueOf(dataInputStream.readUnsignedInt());
}
case IFD_FORMAT_ULONG:
{
return String.valueOf(dataInputStream.readInt());
}
case IFD_FORMAT_SLONG:
{
return String.valueOf(dataInputStream.readInt());
}
case IFD_FORMAT_URATIONAL:
case IFD_FORMAT_SRATIONAL:
{
int numerator=dataInputStream.readInt();
int denominator=dataInputStream.readInt();
return numerator + ""String_Node_Str"" + denominator;
}
case IFD_FORMAT_SINGLE:
{
return String.valueOf(dataInputStream.readFloat());
}
case IFD_FORMAT_DOUBLE:
{
return String.valueOf(dataInputStream.readDouble());
}
case IFD_FORMAT_UNDEFINED:
case IFD_FORMAT_STRING:
{
byte[] bytes=new byte[numberOfComponents];
dataInputStream.readFully(bytes);
int index=0;
if (numberOfComponents >= EXIF_ASCII_PREFIX.length) {
boolean same=true;
for (int i=0; i < EXIF_ASCII_PREFIX.length; ++i) {
if (bytes[i] != EXIF_ASCII_PREFIX[i]) {
same=false;
break;
}
}
if (same) {
index=EXIF_ASCII_PREFIX.length;
}
}
StringBuilder stringBuilder=new StringBuilder();
while (true) {
int ch=bytes[index];
if (ch == 0) break;
if (ch >= 32) stringBuilder.append((char)ch);
 else stringBuilder.append('?');
++index;
if (index == numberOfComponents) break;
}
return stringBuilder.toString();
}
default :
{
return null;
}
}
}",0.9889918887601392
192525,"void finishInstrumentationLocked(ProcessRecord app,int resultCode,Bundle results){
  if (app.instrumentationWatcher != null) {
    try {
      app.instrumentationWatcher.instrumentationFinished(app.instrumentationClass,resultCode,results);
    }
 catch (    RemoteException e) {
    }
  }
  if (app.instrumentationUiAutomationConnection != null) {
    mHandler.obtainMessage(SHUTDOWN_UI_AUTOMATION_CONNECTION_MSG,app.instrumentationUiAutomationConnection).sendToTarget();
  }
  app.instrumentationWatcher=null;
  app.instrumentationUiAutomationConnection=null;
  app.instrumentationClass=null;
  app.instrumentationInfo=null;
  app.instrumentationProfileFile=null;
  app.instrumentationArguments=null;
  forceStopPackageLocked(app.info.packageName,-1,false,false,true,true,false,app.userId,""String_Node_Str"");
}","void finishInstrumentationLocked(ProcessRecord app,int resultCode,Bundle results){
  if (app.instrumentationWatcher != null) {
    mInstrumentationReporter.reportFinished(app.instrumentationWatcher,app.instrumentationClass,resultCode,results);
  }
  if (app.instrumentationUiAutomationConnection != null) {
    mHandler.obtainMessage(SHUTDOWN_UI_AUTOMATION_CONNECTION_MSG,app.instrumentationUiAutomationConnection).sendToTarget();
  }
  app.instrumentationWatcher=null;
  app.instrumentationUiAutomationConnection=null;
  app.instrumentationClass=null;
  app.instrumentationInfo=null;
  app.instrumentationProfileFile=null;
  app.instrumentationArguments=null;
  forceStopPackageLocked(app.info.packageName,-1,false,false,true,true,false,app.userId,""String_Node_Str"");
}",0.922201138519924
192526,"public boolean startInstrumentation(ComponentName className,String profileFile,int flags,Bundle arguments,IInstrumentationWatcher watcher,IUiAutomationConnection uiAutomationConnection,int userId,String abiOverride){
  enforceNotIsolatedCaller(""String_Node_Str"");
  userId=mUserController.handleIncomingUser(Binder.getCallingPid(),Binder.getCallingUid(),userId,false,ALLOW_FULL_ONLY,""String_Node_Str"",null);
  if (arguments != null && arguments.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
synchronized (this) {
    InstrumentationInfo ii=null;
    ApplicationInfo ai=null;
    try {
      ii=mContext.getPackageManager().getInstrumentationInfo(className,STOCK_PM_FLAGS);
      ai=AppGlobals.getPackageManager().getApplicationInfo(ii.targetPackage,STOCK_PM_FLAGS,userId);
    }
 catch (    PackageManager.NameNotFoundException e) {
    }
catch (    RemoteException e) {
    }
    if (ii == null) {
      reportStartInstrumentationFailure(watcher,className,""String_Node_Str"" + className);
      return false;
    }
    if (ai == null) {
      reportStartInstrumentationFailure(watcher,className,""String_Node_Str"" + ii.targetPackage);
      return false;
    }
    if (!ai.hasCode()) {
      reportStartInstrumentationFailure(watcher,className,""String_Node_Str"" + ii.targetPackage);
      return false;
    }
    int match=mContext.getPackageManager().checkSignatures(ii.targetPackage,ii.packageName);
    if (match < 0 && match != PackageManager.SIGNATURE_FIRST_NOT_SIGNED) {
      String msg=""String_Node_Str"" + className + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ ii.packageName+ ""String_Node_Str""+ ii.targetPackage;
      reportStartInstrumentationFailure(watcher,className,msg);
      throw new SecurityException(msg);
    }
    final long origId=Binder.clearCallingIdentity();
    forceStopPackageLocked(ii.targetPackage,-1,true,false,true,true,false,userId,""String_Node_Str"");
    ProcessRecord app=addAppLocked(ai,false,abiOverride);
    app.instrumentationClass=className;
    app.instrumentationInfo=ai;
    app.instrumentationProfileFile=profileFile;
    app.instrumentationArguments=arguments;
    app.instrumentationWatcher=watcher;
    app.instrumentationUiAutomationConnection=uiAutomationConnection;
    app.instrumentationResultClass=className;
    Binder.restoreCallingIdentity(origId);
  }
  return true;
}","public boolean startInstrumentation(ComponentName className,String profileFile,int flags,Bundle arguments,IInstrumentationWatcher watcher,IUiAutomationConnection uiAutomationConnection,int userId,String abiOverride){
  enforceNotIsolatedCaller(""String_Node_Str"");
  userId=mUserController.handleIncomingUser(Binder.getCallingPid(),Binder.getCallingUid(),userId,false,ALLOW_FULL_ONLY,""String_Node_Str"",null);
  if (arguments != null && arguments.hasFileDescriptors()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
synchronized (this) {
    InstrumentationInfo ii=null;
    ApplicationInfo ai=null;
    try {
      ii=mContext.getPackageManager().getInstrumentationInfo(className,STOCK_PM_FLAGS);
      ai=AppGlobals.getPackageManager().getApplicationInfo(ii.targetPackage,STOCK_PM_FLAGS,userId);
    }
 catch (    PackageManager.NameNotFoundException e) {
    }
catch (    RemoteException e) {
    }
    if (ii == null) {
      reportStartInstrumentationFailureLocked(watcher,className,""String_Node_Str"" + className);
      return false;
    }
    if (ai == null) {
      reportStartInstrumentationFailureLocked(watcher,className,""String_Node_Str"" + ii.targetPackage);
      return false;
    }
    if (!ai.hasCode()) {
      reportStartInstrumentationFailureLocked(watcher,className,""String_Node_Str"" + ii.targetPackage);
      return false;
    }
    int match=mContext.getPackageManager().checkSignatures(ii.targetPackage,ii.packageName);
    if (match < 0 && match != PackageManager.SIGNATURE_FIRST_NOT_SIGNED) {
      String msg=""String_Node_Str"" + className + ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ Binder.getCallingPid()+ ""String_Node_Str""+ ii.packageName+ ""String_Node_Str""+ ii.targetPackage;
      reportStartInstrumentationFailureLocked(watcher,className,msg);
      throw new SecurityException(msg);
    }
    final long origId=Binder.clearCallingIdentity();
    forceStopPackageLocked(ii.targetPackage,-1,true,false,true,true,false,userId,""String_Node_Str"");
    ProcessRecord app=addAppLocked(ai,false,abiOverride);
    app.instrumentationClass=className;
    app.instrumentationInfo=ai;
    app.instrumentationProfileFile=profileFile;
    app.instrumentationArguments=arguments;
    app.instrumentationWatcher=watcher;
    app.instrumentationUiAutomationConnection=uiAutomationConnection;
    app.instrumentationResultClass=className;
    Binder.restoreCallingIdentity(origId);
  }
  return true;
}",0.9950839819746006
192527,"private void onFacetClicked(int index){
  Intent intent=mIntents.get(index);
  String packageName=intent.getPackage();
  if (packageName == null) {
    return;
  }
  if (packageName.equals(mCurrentPackageName) && index == mCurrentFacetIndex) {
    return;
  }
  intent.putExtra(EXTRA_FACET_CATEGORIES,mFacetCategories.get(index));
  intent.putExtra(EXTRA_FACET_PACKAGES,mFacetPackages.get(index));
  intent.putExtra(EXTRA_FACET_ID,Integer.toString(index));
  intent.putExtra(EXTRA_FACET_LAUNCH_PICKER,index == mCurrentFacetIndex);
  setCurrentFacet(index);
  startActivity(intent);
}","private void onFacetClicked(int index){
  Intent intent=mIntents.get(index);
  String packageName=intent.getPackage();
  if (packageName == null) {
    return;
  }
  intent.putExtra(EXTRA_FACET_CATEGORIES,mFacetCategories.get(index));
  intent.putExtra(EXTRA_FACET_PACKAGES,mFacetPackages.get(index));
  intent.putExtra(EXTRA_FACET_ID,Integer.toString(index));
  intent.putExtra(EXTRA_FACET_LAUNCH_PICKER,index == mCurrentFacetIndex);
  setCurrentFacet(index);
  startActivity(intent);
}",0.9102803738317756
192528,"public void taskChanged(String packageName){
  mCurrentPackageName=packageName;
  if (mFacetPackageMap.containsKey(packageName)) {
    setCurrentFacet(mFacetPackageMap.get(packageName));
  }
  String category=getPackageCategory(packageName);
  if (category != null) {
    setCurrentFacet(mFacetCategoryMap.get(category));
  }
}","public void taskChanged(String packageName){
  if (mFacetPackageMap.containsKey(packageName)) {
    setCurrentFacet(mFacetPackageMap.get(packageName));
  }
  String category=getPackageCategory(packageName);
  if (category != null) {
    setCurrentFacet(mFacetCategoryMap.get(category));
  }
}",0.9434571890145396
192529,"/** 
 * Saves the text to the   {@link SharedPreferences}.
 * @param text The text to save
 */
public void setText(String text){
  final boolean wasBlocking=shouldDisableDependents();
  mText=text;
  persistString(text);
  final boolean isBlocking=shouldDisableDependents();
  if (isBlocking != wasBlocking) {
    notifyDependencyChange(isBlocking);
  }
}","/** 
 * Saves the text to the   {@link SharedPreferences}.
 * @param text The text to save
 */
public void setText(String text){
  final boolean changed=!TextUtils.equals(mText,text);
  if (changed || !mTextSet) {
    mText=text;
    mTextSet=true;
    persistString(text);
    if (changed) {
      notifyDependencyChange(shouldDisableDependents());
      notifyChanged();
    }
  }
}",0.543978349120433
192530,"private static CharSequence removeTextSizeSpans(CharSequence charSequence){
  if (charSequence instanceof Spanned) {
    Spanned ss=(Spanned)charSequence;
    Object[] spans=ss.getSpans(0,ss.length(),Object.class);
    SpannableStringBuilder builder=new SpannableStringBuilder(ss.toString());
    for (    Object span : spans) {
      Object resultSpan=span;
      if (span instanceof TextAppearanceSpan) {
        TextAppearanceSpan originalSpan=(TextAppearanceSpan)span;
        resultSpan=new TextAppearanceSpan(originalSpan.getFamily(),originalSpan.getTextStyle(),-1,originalSpan.getTextColor(),originalSpan.getLinkTextColor());
      }
 else       if (span instanceof RelativeSizeSpan || span instanceof AbsoluteSizeSpan) {
        continue;
      }
      builder.setSpan(resultSpan,ss.getSpanStart(span),ss.getSpanEnd(span),ss.getSpanFlags(span));
    }
    return builder;
  }
  return charSequence;
}","private static CharSequence removeTextSizeSpans(CharSequence charSequence){
  if (charSequence instanceof Spanned) {
    Spanned ss=(Spanned)charSequence;
    Object[] spans=ss.getSpans(0,ss.length(),Object.class);
    SpannableStringBuilder builder=new SpannableStringBuilder(ss.toString());
    for (    Object span : spans) {
      Object resultSpan=span;
      if (resultSpan instanceof CharacterStyle) {
        resultSpan=((CharacterStyle)span).getUnderlying();
      }
      if (resultSpan instanceof TextAppearanceSpan) {
        TextAppearanceSpan originalSpan=(TextAppearanceSpan)resultSpan;
        resultSpan=new TextAppearanceSpan(originalSpan.getFamily(),originalSpan.getTextStyle(),-1,originalSpan.getTextColor(),originalSpan.getLinkTextColor());
      }
 else       if (resultSpan instanceof RelativeSizeSpan || resultSpan instanceof AbsoluteSizeSpan) {
        continue;
      }
 else {
        resultSpan=span;
      }
      builder.setSpan(resultSpan,ss.getSpanStart(span),ss.getSpanEnd(span),ss.getSpanFlags(span));
    }
    return builder;
  }
  return charSequence;
}",0.9049049049049048
192531,"public void registerShortcutKey(long shortcutCode,IShortcutService shortcutService) throws RemoteException {
synchronized (mLock) {
    IShortcutService service=mShortcutKeyServices.get(shortcutCode);
    if (service != null && service.asBinder().isBinderAlive()) {
      throw new RemoteException(""String_Node_Str"");
    }
    mShortcutKeyServices.put(shortcutCode,shortcutService);
  }
}","public void registerShortcutKey(long shortcutCode,IShortcutService shortcutService) throws RemoteException {
synchronized (mLock) {
    IShortcutService service=mShortcutKeyServices.get(shortcutCode);
    if (service != null && service.asBinder().pingBinder()) {
      throw new RemoteException(""String_Node_Str"");
    }
    mShortcutKeyServices.put(shortcutCode,shortcutService);
  }
}",0.9858064516129031
192532,"/** 
 * Saves the text to the   {@link SharedPreferences}.
 * @param text The text to save
 */
public void setText(String text){
  final boolean wasBlocking=shouldDisableDependents();
  mText=text;
  persistString(text);
  final boolean isBlocking=shouldDisableDependents();
  if (isBlocking != wasBlocking) {
    notifyDependencyChange(isBlocking);
  }
}","/** 
 * Saves the text to the   {@link SharedPreferences}.
 * @param text The text to save
 */
public void setText(String text){
  final boolean changed=!TextUtils.equals(mText,text);
  if (changed || !mTextSet) {
    mText=text;
    mTextSet=true;
    persistString(text);
    if (changed) {
      notifyDependencyChange(shouldDisableDependents());
      notifyChanged();
    }
  }
}",0.543978349120433
192533,"private static CharSequence removeTextSizeSpans(CharSequence charSequence){
  if (charSequence instanceof Spanned) {
    Spanned ss=(Spanned)charSequence;
    Object[] spans=ss.getSpans(0,ss.length(),Object.class);
    SpannableStringBuilder builder=new SpannableStringBuilder(ss.toString());
    for (    Object span : spans) {
      Object resultSpan=span;
      if (span instanceof TextAppearanceSpan) {
        TextAppearanceSpan originalSpan=(TextAppearanceSpan)span;
        resultSpan=new TextAppearanceSpan(originalSpan.getFamily(),originalSpan.getTextStyle(),-1,originalSpan.getTextColor(),originalSpan.getLinkTextColor());
      }
 else       if (span instanceof RelativeSizeSpan || span instanceof AbsoluteSizeSpan) {
        continue;
      }
      builder.setSpan(resultSpan,ss.getSpanStart(span),ss.getSpanEnd(span),ss.getSpanFlags(span));
    }
    return builder;
  }
  return charSequence;
}","private static CharSequence removeTextSizeSpans(CharSequence charSequence){
  if (charSequence instanceof Spanned) {
    Spanned ss=(Spanned)charSequence;
    Object[] spans=ss.getSpans(0,ss.length(),Object.class);
    SpannableStringBuilder builder=new SpannableStringBuilder(ss.toString());
    for (    Object span : spans) {
      Object resultSpan=span;
      if (resultSpan instanceof CharacterStyle) {
        resultSpan=((CharacterStyle)span).getUnderlying();
      }
      if (resultSpan instanceof TextAppearanceSpan) {
        TextAppearanceSpan originalSpan=(TextAppearanceSpan)resultSpan;
        resultSpan=new TextAppearanceSpan(originalSpan.getFamily(),originalSpan.getTextStyle(),-1,originalSpan.getTextColor(),originalSpan.getLinkTextColor());
      }
 else       if (resultSpan instanceof RelativeSizeSpan || resultSpan instanceof AbsoluteSizeSpan) {
        continue;
      }
 else {
        resultSpan=span;
      }
      builder.setSpan(resultSpan,ss.getSpanStart(span),ss.getSpanEnd(span),ss.getSpanFlags(span));
    }
    return builder;
  }
  return charSequence;
}",0.9049049049049048
192534,"private void resetHeaderIndention(){
  if (mHeader.getPaddingEnd() != mNotificationContentMarginEnd) {
    ViewGroup.MarginLayoutParams headerParams=(MarginLayoutParams)mHeader.getLayoutParams();
    headerParams.setMarginEnd(0);
    mHeader.setPadding(isLayoutRtl() ? mNotificationContentMarginEnd : mHeader.getPaddingLeft(),mHeader.getPaddingTop(),isLayoutRtl() ? mHeader.getPaddingLeft() : mNotificationContentMarginEnd,mHeader.getPaddingBottom());
    mHeader.setLayoutParams(headerParams);
  }
}","private boolean resetHeaderIndention(){
  boolean remeasure=false;
  if (mHeader.getPaddingEnd() != mNotificationContentMarginEnd) {
    mHeader.setPaddingRelative(mHeader.getPaddingStart(),mHeader.getPaddingTop(),mNotificationContentMarginEnd,mHeader.getPaddingBottom());
    remeasure=true;
  }
  ViewGroup.MarginLayoutParams headerParams=(MarginLayoutParams)mHeader.getLayoutParams();
  headerParams.setMarginEnd(0);
  if (headerParams.getMarginEnd() != 0) {
    headerParams.setMarginEnd(0);
    mHeader.setLayoutParams(headerParams);
    remeasure=true;
  }
  return remeasure;
}",0.477859778597786
192535,"@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int mode=MeasureSpec.getMode(widthMeasureSpec);
  boolean hasIcon=mRightIcon.getVisibility() != GONE;
  if (hasIcon && mode != MeasureSpec.UNSPECIFIED) {
    measureChild(mActions,widthMeasureSpec,heightMeasureSpec);
    int size=MeasureSpec.getSize(widthMeasureSpec);
    size=size - mActions.getMeasuredWidth();
    ViewGroup.MarginLayoutParams layoutParams=(MarginLayoutParams)mRightIcon.getLayoutParams();
    int imageEndMargin=layoutParams.getMarginEnd();
    size-=imageEndMargin;
    size=Math.min(size,mMaxImageSize);
    size=Math.max(size,mRightIcon.getMinimumWidth());
    layoutParams.width=size;
    layoutParams.height=size;
    mRightIcon.setLayoutParams(layoutParams);
    ViewGroup.MarginLayoutParams mainParams=(MarginLayoutParams)mMainColumn.getLayoutParams();
    int marginEnd=size + imageEndMargin + mNotificationContentMarginEnd;
    if (marginEnd != mainParams.getMarginEnd()) {
      mainParams.setMarginEnd(marginEnd);
      mMainColumn.setLayoutParams(mainParams);
    }
  }
  super.onMeasure(widthMeasureSpec,heightMeasureSpec);
  ViewGroup.MarginLayoutParams iconParams=(MarginLayoutParams)mRightIcon.getLayoutParams();
  int topMargin=getMeasuredHeight() - mRightIcon.getMeasuredHeight() - iconParams.bottomMargin;
  if (!hasIcon || topMargin >= mImageMinTopMargin) {
    resetHeaderIndention();
  }
 else {
    int paddingEnd=mNotificationContentImageMarginEnd;
    ViewGroup.MarginLayoutParams headerParams=(MarginLayoutParams)mHeader.getLayoutParams();
    headerParams.setMarginEnd(mRightIcon.getMeasuredWidth() + iconParams.getMarginEnd());
    if (mHeader.getPaddingEnd() != paddingEnd) {
      mHeader.setPadding(isLayoutRtl() ? paddingEnd : mHeader.getPaddingLeft(),mHeader.getPaddingTop(),isLayoutRtl() ? mHeader.getPaddingLeft() : paddingEnd,mHeader.getPaddingBottom());
      mHeader.setLayoutParams(headerParams);
    }
  }
}","@Override protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec){
  int mode=MeasureSpec.getMode(widthMeasureSpec);
  boolean hasIcon=mRightIcon.getVisibility() != GONE;
  if (hasIcon && mode != MeasureSpec.UNSPECIFIED) {
    measureChild(mActions,widthMeasureSpec,heightMeasureSpec);
    int size=MeasureSpec.getSize(widthMeasureSpec);
    size=size - mActions.getMeasuredWidth();
    ViewGroup.MarginLayoutParams layoutParams=(MarginLayoutParams)mRightIcon.getLayoutParams();
    int imageEndMargin=layoutParams.getMarginEnd();
    size-=imageEndMargin;
    size=Math.min(size,mMaxImageSize);
    size=Math.max(size,mRightIcon.getMinimumWidth());
    layoutParams.width=size;
    layoutParams.height=size;
    mRightIcon.setLayoutParams(layoutParams);
    ViewGroup.MarginLayoutParams mainParams=(MarginLayoutParams)mMainColumn.getLayoutParams();
    int marginEnd=size + imageEndMargin + mNotificationContentMarginEnd;
    if (marginEnd != mainParams.getMarginEnd()) {
      mainParams.setMarginEnd(marginEnd);
      mMainColumn.setLayoutParams(mainParams);
    }
  }
  super.onMeasure(widthMeasureSpec,heightMeasureSpec);
  ViewGroup.MarginLayoutParams iconParams=(MarginLayoutParams)mRightIcon.getLayoutParams();
  int topMargin=getMeasuredHeight() - mRightIcon.getMeasuredHeight() - iconParams.bottomMargin;
  boolean reMeasure=false;
  if (!hasIcon || topMargin >= mImageMinTopMargin) {
    reMeasure=resetHeaderIndention();
  }
 else {
    int paddingEnd=mNotificationContentImageMarginEnd;
    ViewGroup.MarginLayoutParams headerParams=(MarginLayoutParams)mHeader.getLayoutParams();
    int newMarginEnd=mRightIcon.getMeasuredWidth() + iconParams.getMarginEnd();
    if (headerParams.getMarginEnd() != newMarginEnd) {
      headerParams.setMarginEnd(newMarginEnd);
      mHeader.setLayoutParams(headerParams);
      reMeasure=true;
    }
    if (mHeader.getPaddingEnd() != paddingEnd) {
      mHeader.setPaddingRelative(mHeader.getPaddingStart(),mHeader.getPaddingTop(),paddingEnd,mHeader.getPaddingBottom());
      reMeasure=true;
    }
  }
  if (reMeasure) {
    measureChildWithMargins(mHeader,widthMeasureSpec,0,heightMeasureSpec,0);
  }
}",0.8425655976676385
192536,"/** 
 * Check whether the view state is currently expanded. This is given by the system in   {@link #setSystemExpanded(boolean)} and can be overridden by user expansion orcollapsing in  {@link #setUserExpanded(boolean)}. Note that the visual appearance of this view can differ from this state, if layout params are modified from outside.
 * @return whether the view state is currently expanded.
 */
public boolean isExpanded(){
  return !mOnKeyguard && (!hasUserChangedExpansion() && (isSystemExpanded() || isSystemChildExpanded()) || isUserExpanded());
}","public boolean isExpanded(boolean allowOnKeyguard){
  return (!mOnKeyguard || allowOnKeyguard) && (!hasUserChangedExpansion() && (isSystemExpanded() || isSystemChildExpanded()) || isUserExpanded());
}",0.3496688741721854
192537,"private int getVisualTypeForHeight(float viewHeight){
  boolean noExpandedChild=mExpandedChild == null;
  if (!noExpandedChild && viewHeight == mExpandedChild.getHeight()) {
    return VISIBLE_TYPE_EXPANDED;
  }
  if (!mUserExpanding && mIsChildInGroup && !isGroupExpanded()) {
    return VISIBLE_TYPE_SINGLELINE;
  }
  if (mIsHeadsUp && mHeadsUpChild != null) {
    if (viewHeight <= mHeadsUpChild.getHeight() || noExpandedChild) {
      return VISIBLE_TYPE_HEADSUP;
    }
 else {
      return VISIBLE_TYPE_EXPANDED;
    }
  }
 else {
    if (noExpandedChild || (viewHeight <= mContractedChild.getHeight() && (!mIsChildInGroup || !mContainingNotification.isExpanded()))) {
      return VISIBLE_TYPE_CONTRACTED;
    }
 else {
      return VISIBLE_TYPE_EXPANDED;
    }
  }
}","private int getVisualTypeForHeight(float viewHeight){
  boolean noExpandedChild=mExpandedChild == null;
  if (!noExpandedChild && viewHeight == mExpandedChild.getHeight()) {
    return VISIBLE_TYPE_EXPANDED;
  }
  if (!mUserExpanding && mIsChildInGroup && !isGroupExpanded()) {
    return VISIBLE_TYPE_SINGLELINE;
  }
  if (mIsHeadsUp && mHeadsUpChild != null) {
    if (viewHeight <= mHeadsUpChild.getHeight() || noExpandedChild) {
      return VISIBLE_TYPE_HEADSUP;
    }
 else {
      return VISIBLE_TYPE_EXPANDED;
    }
  }
 else {
    if (noExpandedChild || (viewHeight <= mContractedChild.getHeight() && (!mIsChildInGroup || !mContainingNotification.isExpanded(true)))) {
      return VISIBLE_TYPE_CONTRACTED;
    }
 else {
      return VISIBLE_TYPE_EXPANDED;
    }
  }
}",0.9974193548387096
192538,"/** 
 * @return one of the static enum types in this view, calculated form the current state
 */
private int calculateVisibleType(){
  if (mUserExpanding) {
    int height=!mIsChildInGroup || isGroupExpanded() || mContainingNotification.isExpanded() ? mContainingNotification.getMaxContentHeight() : mContainingNotification.getShowingLayout().getMinHeight();
    if (height == 0) {
      height=mContentHeight;
    }
    int expandedVisualType=getVisualTypeForHeight(height);
    int collapsedVisualType=getVisualTypeForHeight(mContainingNotification.getMinExpandHeight());
    return mTransformationStartVisibleType == collapsedVisualType ? expandedVisualType : collapsedVisualType;
  }
  int intrinsicHeight=mContainingNotification.getIntrinsicHeight();
  int viewHeight=mContentHeight;
  if (intrinsicHeight != 0) {
    viewHeight=Math.min(mContentHeight,intrinsicHeight);
  }
  return getVisualTypeForHeight(viewHeight);
}","/** 
 * @return one of the static enum types in this view, calculated form the current state
 */
private int calculateVisibleType(){
  if (mUserExpanding) {
    int height=!mIsChildInGroup || isGroupExpanded() || mContainingNotification.isExpanded(true) ? mContainingNotification.getMaxContentHeight() : mContainingNotification.getShowingLayout().getMinHeight();
    if (height == 0) {
      height=mContentHeight;
    }
    int expandedVisualType=getVisualTypeForHeight(height);
    int collapsedVisualType=getVisualTypeForHeight(mContainingNotification.getMinExpandHeight());
    return mTransformationStartVisibleType == collapsedVisualType ? expandedVisualType : collapsedVisualType;
  }
  int intrinsicHeight=mContainingNotification.getIntrinsicHeight();
  int viewHeight=mContentHeight;
  if (intrinsicHeight != 0) {
    viewHeight=Math.min(mContentHeight,intrinsicHeight);
  }
  return getVisualTypeForHeight(viewHeight);
}",0.9978448275862069
192539,"public void setActualHeight(int actualHeight){
  if (!mUserLocked) {
    return;
  }
  mActualHeight=actualHeight;
  float fraction=getChildExpandFraction();
  int childCount=mChildren.size();
  for (int i=0; i < childCount; i++) {
    ExpandableNotificationRow child=mChildren.get(i);
    float childHeight=child.isExpanded() ? child.getMaxExpandHeight() : child.getShowingLayout().getMinHeight(true);
    float singleLineHeight=child.getShowingLayout().getMinHeight(false);
    child.setActualHeight((int)NotificationUtils.interpolate(singleLineHeight,childHeight,fraction),false);
  }
}","public void setActualHeight(int actualHeight){
  if (!mUserLocked) {
    return;
  }
  mActualHeight=actualHeight;
  float fraction=getChildExpandFraction();
  int childCount=mChildren.size();
  for (int i=0; i < childCount; i++) {
    ExpandableNotificationRow child=mChildren.get(i);
    float childHeight=child.isExpanded(true) ? child.getMaxExpandHeight() : child.getShowingLayout().getMinHeight(true);
    float singleLineHeight=child.getShowingLayout().getMinHeight(false);
    child.setActualHeight((int)NotificationUtils.interpolate(singleLineHeight,childHeight,fraction),false);
  }
}",0.9966159052453468
192540,"public int getMaxContentHeight(){
  int maxContentHeight=mNotificationHeaderHeight + mNotificatonTopPadding;
  int visibleChildren=0;
  int childCount=mChildren.size();
  for (int i=0; i < childCount; i++) {
    if (visibleChildren >= NUMBER_OF_CHILDREN_WHEN_CHILDREN_EXPANDED) {
      break;
    }
    ExpandableNotificationRow child=mChildren.get(i);
    float childHeight=child.isExpanded() ? child.getMaxExpandHeight() : child.getShowingLayout().getMinHeight(true);
    maxContentHeight+=childHeight;
    visibleChildren++;
  }
  if (visibleChildren > 0) {
    maxContentHeight+=visibleChildren * mDividerHeight;
  }
  return maxContentHeight;
}","public int getMaxContentHeight(){
  int maxContentHeight=mNotificationHeaderHeight + mNotificatonTopPadding;
  int visibleChildren=0;
  int childCount=mChildren.size();
  for (int i=0; i < childCount; i++) {
    if (visibleChildren >= NUMBER_OF_CHILDREN_WHEN_CHILDREN_EXPANDED) {
      break;
    }
    ExpandableNotificationRow child=mChildren.get(i);
    float childHeight=child.isExpanded(true) ? child.getMaxExpandHeight() : child.getShowingLayout().getMinHeight(true);
    maxContentHeight+=childHeight;
    visibleChildren++;
  }
  if (visibleChildren > 0) {
    maxContentHeight+=visibleChildren * mDividerHeight;
  }
  return maxContentHeight;
}",0.9969278033794164
192541,"public ExpandableNotificationRow getViewAtPosition(float y){
  if (!mIsSummaryWithChildren || !mChildrenExpanded || (getNotificationChildren().size() == 1 && isClearable())) {
    return this;
  }
 else {
    ExpandableNotificationRow view=mChildrenContainer.getViewAtPosition(y);
    return view == null ? this : view;
  }
}","public ExpandableNotificationRow getViewAtPosition(float y){
  if (!mIsSummaryWithChildren || !mChildrenExpanded) {
    return this;
  }
 else {
    ExpandableNotificationRow view=mChildrenContainer.getViewAtPosition(y);
    return view == null ? this : view;
  }
}",0.8983050847457628
192542,"private void doKeyguardLaterLocked(long timeout){
  long when=SystemClock.elapsedRealtime() + timeout;
  Intent intent=new Intent(DELAYED_KEYGUARD_ACTION);
  intent.putExtra(""String_Node_Str"",mDelayedShowingSequence);
  PendingIntent sender=PendingIntent.getBroadcast(mContext,0,intent,PendingIntent.FLAG_CANCEL_CURRENT);
  mAlarmManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,when,sender);
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + mDelayedShowingSequence);
  doKeyguardLaterForChildProfilesLocked();
}","private void doKeyguardLaterLocked(long timeout){
  long when=SystemClock.elapsedRealtime() + timeout;
  Intent intent=new Intent(DELAYED_KEYGUARD_ACTION);
  intent.putExtra(""String_Node_Str"",mDelayedShowingSequence);
  PendingIntent sender=PendingIntent.getBroadcast(mContext,0,intent,PendingIntent.FLAG_CANCEL_CURRENT);
  mAlarmManager.setExactAndAllowWhileIdle(AlarmManager.ELAPSED_REALTIME_WAKEUP,when,sender);
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + mDelayedShowingSequence);
  doKeyguardLaterForChildProfilesLocked();
}",0.978805394990366
192543,"private void doKeyguardLaterForChildProfilesLocked(){
  UserManager um=UserManager.get(mContext);
  List<UserInfo> profiles=um.getEnabledProfiles(UserHandle.myUserId());
  for (  UserInfo info : profiles) {
    if (mLockPatternUtils.isSeparateProfileChallengeEnabled(info.id)) {
      long userTimeout=getLockTimeout(info.id);
      long userWhen=SystemClock.elapsedRealtime() + userTimeout;
      Intent lockIntent=new Intent(DELAYED_LOCK_PROFILE_ACTION);
      lockIntent.putExtra(Intent.EXTRA_USER_ID,info.id);
      PendingIntent lockSender=PendingIntent.getBroadcast(mContext,0,lockIntent,PendingIntent.FLAG_CANCEL_CURRENT);
      mAlarmManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,userWhen,lockSender);
    }
  }
}","private void doKeyguardLaterForChildProfilesLocked(){
  UserManager um=UserManager.get(mContext);
  List<UserInfo> profiles=um.getEnabledProfiles(UserHandle.myUserId());
  for (  UserInfo info : profiles) {
    if (mLockPatternUtils.isSeparateProfileChallengeEnabled(info.id)) {
      long userTimeout=getLockTimeout(info.id);
      long userWhen=SystemClock.elapsedRealtime() + userTimeout;
      Intent lockIntent=new Intent(DELAYED_LOCK_PROFILE_ACTION);
      lockIntent.putExtra(Intent.EXTRA_USER_ID,info.id);
      PendingIntent lockSender=PendingIntent.getBroadcast(mContext,0,lockIntent,PendingIntent.FLAG_CANCEL_CURRENT);
      mAlarmManager.setExactAndAllowWhileIdle(AlarmManager.ELAPSED_REALTIME_WAKEUP,userWhen,lockSender);
    }
  }
}",0.9251700680272108
192544,"public void registerShortcutKey(long shortcutCode,IShortcutService shortcutService) throws RemoteException {
synchronized (mLock) {
    IShortcutService service=mShortcutKeyServices.get(shortcutCode);
    if (service != null && service.asBinder().isBinderAlive()) {
      throw new RemoteException(""String_Node_Str"");
    }
    mShortcutKeyServices.put(shortcutCode,shortcutService);
  }
}","public void registerShortcutKey(long shortcutCode,IShortcutService shortcutService) throws RemoteException {
synchronized (mLock) {
    IShortcutService service=mShortcutKeyServices.get(shortcutCode);
    if (service != null && service.asBinder().pingBinder()) {
      throw new RemoteException(""String_Node_Str"");
    }
    mShortcutKeyServices.put(shortcutCode,shortcutService);
  }
}",0.9858064516129031
192545,"public AppErrorDialog(Context context,ActivityManagerService service,Data data){
  super(context);
  Resources res=context.getResources();
  mService=service;
  mProc=data.proc;
  mResult=data.result;
  mRepeating=data.repeating;
  if ((mProc.pkgList.size() == 1) && (mName=context.getPackageManager().getApplicationLabel(mProc.info)) != null) {
    setTitle(res.getString(mRepeating ? com.android.internal.R.string.aerr_application_repeated : com.android.internal.R.string.aerr_application,mName.toString(),mProc.info.processName));
  }
 else {
    mName=mProc.processName;
    setTitle(res.getString(mRepeating ? com.android.internal.R.string.aerr_process_repeated : com.android.internal.R.string.aerr_process,mName.toString()));
  }
  setCancelable(false);
  WindowManager.LayoutParams attrs=getWindow().getAttributes();
  attrs.setTitle(""String_Node_Str"" + mProc.info.processName);
  attrs.privateFlags|=WindowManager.LayoutParams.PRIVATE_FLAG_SYSTEM_ERROR | WindowManager.LayoutParams.PRIVATE_FLAG_SHOW_FOR_ALL_USERS;
  getWindow().setAttributes(attrs);
  if (mProc.persistent) {
    getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ERROR);
  }
  mHandler.sendMessageDelayed(mHandler.obtainMessage(TIMEOUT),DISMISS_TIMEOUT);
}","public AppErrorDialog(Context context,ActivityManagerService service,Data data){
  super(context);
  Resources res=context.getResources();
  mService=service;
  mProc=data.proc;
  mResult=data.result;
  mRepeating=data.repeating;
  BidiFormatter bidi=BidiFormatter.getInstance();
  if ((mProc.pkgList.size() == 1) && (mName=context.getPackageManager().getApplicationLabel(mProc.info)) != null) {
    setTitle(res.getString(mRepeating ? com.android.internal.R.string.aerr_application_repeated : com.android.internal.R.string.aerr_application,bidi.unicodeWrap(mName.toString()),bidi.unicodeWrap(mProc.info.processName)));
  }
 else {
    mName=mProc.processName;
    setTitle(res.getString(mRepeating ? com.android.internal.R.string.aerr_process_repeated : com.android.internal.R.string.aerr_process,bidi.unicodeWrap(mName.toString())));
  }
  setCancelable(false);
  WindowManager.LayoutParams attrs=getWindow().getAttributes();
  attrs.setTitle(""String_Node_Str"" + mProc.info.processName);
  attrs.privateFlags|=WindowManager.LayoutParams.PRIVATE_FLAG_SYSTEM_ERROR | WindowManager.LayoutParams.PRIVATE_FLAG_SHOW_FOR_ALL_USERS;
  getWindow().setAttributes(attrs);
  if (mProc.persistent) {
    getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ERROR);
  }
  mHandler.sendMessageDelayed(mHandler.obtainMessage(TIMEOUT),DISMISS_TIMEOUT);
}",0.959783449342614
192546,"public AppNotRespondingDialog(ActivityManagerService service,Context context,ProcessRecord app,ActivityRecord activity,boolean aboveSystem){
  super(context);
  mService=service;
  mProc=app;
  Resources res=context.getResources();
  setCancelable(false);
  int resid;
  CharSequence name1=activity != null ? activity.info.loadLabel(context.getPackageManager()) : null;
  CharSequence name2=null;
  if ((app.pkgList.size() == 1) && (name2=context.getPackageManager().getApplicationLabel(app.info)) != null) {
    if (name1 != null) {
      resid=com.android.internal.R.string.anr_activity_application;
    }
 else {
      name1=name2;
      name2=app.processName;
      resid=com.android.internal.R.string.anr_application_process;
    }
  }
 else {
    if (name1 != null) {
      name2=app.processName;
      resid=com.android.internal.R.string.anr_activity_process;
    }
 else {
      name1=app.processName;
      resid=com.android.internal.R.string.anr_process;
    }
  }
  setTitle(name2 != null ? res.getString(resid,name1.toString(),name2.toString()) : res.getString(resid,name1.toString()));
  if (aboveSystem) {
    getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ERROR);
  }
  WindowManager.LayoutParams attrs=getWindow().getAttributes();
  attrs.setTitle(""String_Node_Str"" + app.info.processName);
  attrs.privateFlags=WindowManager.LayoutParams.PRIVATE_FLAG_SYSTEM_ERROR | WindowManager.LayoutParams.PRIVATE_FLAG_SHOW_FOR_ALL_USERS;
  getWindow().setAttributes(attrs);
}","public AppNotRespondingDialog(ActivityManagerService service,Context context,ProcessRecord app,ActivityRecord activity,boolean aboveSystem){
  super(context);
  mService=service;
  mProc=app;
  Resources res=context.getResources();
  setCancelable(false);
  int resid;
  CharSequence name1=activity != null ? activity.info.loadLabel(context.getPackageManager()) : null;
  CharSequence name2=null;
  if ((app.pkgList.size() == 1) && (name2=context.getPackageManager().getApplicationLabel(app.info)) != null) {
    if (name1 != null) {
      resid=com.android.internal.R.string.anr_activity_application;
    }
 else {
      name1=name2;
      name2=app.processName;
      resid=com.android.internal.R.string.anr_application_process;
    }
  }
 else {
    if (name1 != null) {
      name2=app.processName;
      resid=com.android.internal.R.string.anr_activity_process;
    }
 else {
      name1=app.processName;
      resid=com.android.internal.R.string.anr_process;
    }
  }
  BidiFormatter bidi=BidiFormatter.getInstance();
  setTitle(name2 != null ? res.getString(resid,bidi.unicodeWrap(name1.toString()),bidi.unicodeWrap(name2.toString())) : res.getString(resid,bidi.unicodeWrap(name1.toString())));
  if (aboveSystem) {
    getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ERROR);
  }
  WindowManager.LayoutParams attrs=getWindow().getAttributes();
  attrs.setTitle(""String_Node_Str"" + app.info.processName);
  attrs.privateFlags=WindowManager.LayoutParams.PRIVATE_FLAG_SYSTEM_ERROR | WindowManager.LayoutParams.PRIVATE_FLAG_SHOW_FOR_ALL_USERS;
  getWindow().setAttributes(attrs);
}",0.966321243523316
192547,"public ScrimController createScrimController(ScrimView scrimBehind,ScrimView scrimInFront,View headsUpScrim,boolean scrimSrcEnabled){
  return new ScrimController(scrimBehind,scrimInFront,headsUpScrim,scrimSrcEnabled);
}","public ScrimController createScrimController(ScrimView scrimBehind,ScrimView scrimInFront,View headsUpScrim){
  return new ScrimController(scrimBehind,scrimInFront,headsUpScrim);
}",0.9
192548,"protected PhoneStatusBarView makeStatusBarView(){
  final Context context=mContext;
  updateDisplaySize();
  updateResources();
  inflateStatusBarWindow(context);
  mStatusBarWindow.setService(this);
  mStatusBarWindow.setOnTouchListener(new View.OnTouchListener(){
    @Override public boolean onTouch(    View v,    MotionEvent event){
      checkUserAutohide(v,event);
      if (event.getAction() == MotionEvent.ACTION_DOWN) {
        if (mExpandedVisible) {
          animateCollapsePanels();
        }
      }
      return mStatusBarWindow.onTouchEvent(event);
    }
  }
);
  mNotificationPanel=(NotificationPanelView)mStatusBarWindow.findViewById(R.id.notification_panel);
  mNotificationPanel.setStatusBar(this);
  mStatusBarView=(PhoneStatusBarView)mStatusBarWindow.findViewById(R.id.status_bar);
  mStatusBarView.setBar(this);
  mStatusBarView.setPanel(mNotificationPanel);
  if (!ActivityManager.isHighEndGfx()) {
    mStatusBarWindow.setBackground(null);
    mNotificationPanel.setBackground(new FastColorDrawable(context.getColor(R.color.notification_panel_solid_background)));
  }
  mHeadsUpManager=new HeadsUpManager(context,mStatusBarWindow,mGroupManager);
  mHeadsUpManager.setBar(this);
  mHeadsUpManager.addListener(this);
  mHeadsUpManager.addListener(mNotificationPanel);
  mHeadsUpManager.addListener(mGroupManager);
  mNotificationPanel.setHeadsUpManager(mHeadsUpManager);
  mNotificationData.setHeadsUpManager(mHeadsUpManager);
  if (MULTIUSER_DEBUG) {
    mNotificationPanelDebugText=(TextView)mNotificationPanel.findViewById(R.id.header_debug_info);
    mNotificationPanelDebugText.setVisibility(View.VISIBLE);
  }
  try {
    boolean showNav=mWindowManagerService.hasNavigationBar();
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + showNav);
    if (showNav) {
      createNavigationBarView(context);
    }
  }
 catch (  RemoteException ex) {
  }
  mAssistManager=new AssistManager(this,context);
  mPixelFormat=PixelFormat.OPAQUE;
  mStackScroller=(NotificationStackScrollLayout)mStatusBarWindow.findViewById(R.id.notification_stack_scroller);
  mStackScroller.setLongPressListener(getNotificationLongClicker());
  mStackScroller.setGearDisplayedListener(getGearDisplayedListener());
  mStackScroller.setPhoneStatusBar(this);
  mStackScroller.setGroupManager(mGroupManager);
  mStackScroller.setHeadsUpManager(mHeadsUpManager);
  mGroupManager.setOnGroupChangeListener(mStackScroller);
  mKeyguardIconOverflowContainer=(NotificationOverflowContainer)LayoutInflater.from(mContext).inflate(R.layout.status_bar_notification_keyguard_overflow,mStackScroller,false);
  mKeyguardIconOverflowContainer.setOnActivatedListener(this);
  mKeyguardIconOverflowContainer.setOnClickListener(mOverflowClickListener);
  mStackScroller.setOverflowContainer(mKeyguardIconOverflowContainer);
  inflateEmptyShadeView();
  inflateDismissView();
  mExpandedContents=mStackScroller;
  mBackdrop=(BackDropView)mStatusBarWindow.findViewById(R.id.backdrop);
  mBackdropFront=(ImageView)mBackdrop.findViewById(R.id.backdrop_front);
  mBackdropBack=(ImageView)mBackdrop.findViewById(R.id.backdrop_back);
  ScrimView scrimBehind=(ScrimView)mStatusBarWindow.findViewById(R.id.scrim_behind);
  ScrimView scrimInFront=(ScrimView)mStatusBarWindow.findViewById(R.id.scrim_in_front);
  View headsUpScrim=mStatusBarWindow.findViewById(R.id.heads_up_scrim);
  mScrimController=SystemUIFactory.getInstance().createScrimController(scrimBehind,scrimInFront,headsUpScrim,mScrimSrcModeEnabled);
  mHeadsUpManager.addListener(mScrimController);
  mStackScroller.setScrimController(mScrimController);
  mScrimController.setBackDropView(mBackdrop);
  mStatusBarView.setScrimController(mScrimController);
  mDozeScrimController=new DozeScrimController(mScrimController,context);
  mKeyguardStatusBar=(KeyguardStatusBarView)mStatusBarWindow.findViewById(R.id.keyguard_header);
  mKeyguardStatusView=mStatusBarWindow.findViewById(R.id.keyguard_status_view);
  mKeyguardBottomArea=(KeyguardBottomAreaView)mStatusBarWindow.findViewById(R.id.keyguard_bottom_area);
  mKeyguardBottomArea.setActivityStarter(this);
  mKeyguardBottomArea.setAssistManager(mAssistManager);
  mKeyguardIndicationController=new KeyguardIndicationController(mContext,(KeyguardIndicationTextView)mStatusBarWindow.findViewById(R.id.keyguard_indication_text),mKeyguardBottomArea.getLockIcon());
  mKeyguardBottomArea.setKeyguardIndicationController(mKeyguardIndicationController);
  if (ENABLE_LOCKSCREEN_WALLPAPER) {
    mLockscreenWallpaper=new LockscreenWallpaper(mContext,this,mHandler);
  }
  setAreThereNotifications();
  mIconController=new StatusBarIconController(mContext,mStatusBarView,mKeyguardStatusBar,this);
  mHandlerThread=new HandlerThread(TAG,Process.THREAD_PRIORITY_BACKGROUND);
  mHandlerThread.start();
  mLocationController=new LocationControllerImpl(mContext,mHandlerThread.getLooper());
  mBatteryController=new BatteryController(mContext);
  mBatteryController.addStateChangedCallback(new BatteryStateChangeCallback(){
    @Override public void onPowerSaveChanged(    boolean isPowerSave){
      mHandler.post(mCheckBarModes);
      if (mDozeServiceHost != null) {
        mDozeServiceHost.firePowerSaveChanged(isPowerSave);
      }
    }
    @Override public void onBatteryLevelChanged(    int level,    boolean pluggedIn,    boolean charging){
    }
  }
);
  mNetworkController=new NetworkControllerImpl(mContext,mHandlerThread.getLooper());
  mHotspotController=new HotspotControllerImpl(mContext);
  mBluetoothController=new BluetoothControllerImpl(mContext,mHandlerThread.getLooper());
  mSecurityController=new SecurityControllerImpl(mContext);
  if (mContext.getResources().getBoolean(R.bool.config_showRotationLock)) {
    mRotationLockController=new RotationLockControllerImpl(mContext);
  }
  mUserInfoController=new UserInfoController(mContext);
  mVolumeComponent=getComponent(VolumeComponent.class);
  if (mVolumeComponent != null) {
    mZenModeController=mVolumeComponent.getZenController();
  }
  mCastController=new CastControllerImpl(mContext);
  initSignalCluster(mStatusBarView);
  initSignalCluster(mKeyguardStatusBar);
  mFlashlightController=new FlashlightController(mContext);
  mKeyguardBottomArea.setFlashlightController(mFlashlightController);
  mKeyguardBottomArea.setPhoneStatusBar(this);
  mKeyguardBottomArea.setUserSetupComplete(mUserSetup);
  mAccessibilityController=new AccessibilityController(mContext);
  mKeyguardBottomArea.setAccessibilityController(mAccessibilityController);
  mNextAlarmController=new NextAlarmController(mContext);
  mLightStatusBarController=new LightStatusBarController(mIconController,mBatteryController);
  mKeyguardMonitor=new KeyguardMonitor(mContext);
  if (UserManager.get(mContext).isUserSwitcherEnabled()) {
    mUserSwitcherController=new UserSwitcherController(mContext,mKeyguardMonitor,mHandler,this);
    createUserSwitcher();
  }
  DensityContainer container=(DensityContainer)mStatusBarWindow.findViewById(R.id.qs_density_container);
  if (container != null) {
    final QSTileHost qsh=new QSTileHost(mContext,this,mBluetoothController,mLocationController,mRotationLockController,mNetworkController,mZenModeController,mHotspotController,mCastController,mFlashlightController,mUserSwitcherController,mUserInfoController,mKeyguardMonitor,mSecurityController,mBatteryController,mIconController,mNextAlarmController);
    mBrightnessMirrorController=new BrightnessMirrorController(mStatusBarWindow);
    container.addInflateListener(new InflateListener(){
      @Override public void onInflated(      View v){
        QSContainer qsContainer=(QSContainer)v.findViewById(R.id.quick_settings_container);
        qsContainer.setHost(qsh);
        mQSPanel=qsContainer.getQsPanel();
        mQSPanel.setBrightnessMirror(mBrightnessMirrorController);
        mHeader=qsContainer.getHeader();
        initSignalCluster(mHeader);
        mHeader.setActivityStarter(PhoneStatusBar.this);
      }
    }
);
  }
  mKeyguardStatusBar.setUserInfoController(mUserInfoController);
  mKeyguardStatusBar.setUserSwitcherController(mUserSwitcherController);
  mUserInfoController.reloadUserInfo();
  ((BatteryMeterView)mStatusBarView.findViewById(R.id.battery)).setBatteryController(mBatteryController);
  mKeyguardStatusBar.setBatteryController(mBatteryController);
  PowerManager pm=(PowerManager)mContext.getSystemService(Context.POWER_SERVICE);
  mBroadcastReceiver.onReceive(mContext,new Intent(pm.isScreenOn() ? Intent.ACTION_SCREEN_ON : Intent.ACTION_SCREEN_OFF));
  mGestureWakeLock=pm.newWakeLock(PowerManager.SCREEN_BRIGHT_WAKE_LOCK,""String_Node_Str"");
  mVibrator=mContext.getSystemService(Vibrator.class);
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
  filter.addAction(Intent.ACTION_SCREEN_OFF);
  filter.addAction(Intent.ACTION_SCREEN_ON);
  context.registerReceiverAsUser(mBroadcastReceiver,UserHandle.ALL,filter,null,null);
  IntentFilter demoFilter=new IntentFilter();
  if (DEBUG_MEDIA_FAKE_ARTWORK) {
    demoFilter.addAction(ACTION_FAKE_ARTWORK);
  }
  demoFilter.addAction(ACTION_DEMO);
  context.registerReceiverAsUser(mDemoReceiver,UserHandle.ALL,demoFilter,android.Manifest.permission.DUMP,null);
  resetUserSetupObserver();
  ThreadedRenderer.overrideProperty(""String_Node_Str"",""String_Node_Str"");
  ThreadedRenderer.overrideProperty(""String_Node_Str"",String.valueOf(1.5f));
  return mStatusBarView;
}","protected PhoneStatusBarView makeStatusBarView(){
  final Context context=mContext;
  updateDisplaySize();
  updateResources();
  inflateStatusBarWindow(context);
  mStatusBarWindow.setService(this);
  mStatusBarWindow.setOnTouchListener(new View.OnTouchListener(){
    @Override public boolean onTouch(    View v,    MotionEvent event){
      checkUserAutohide(v,event);
      if (event.getAction() == MotionEvent.ACTION_DOWN) {
        if (mExpandedVisible) {
          animateCollapsePanels();
        }
      }
      return mStatusBarWindow.onTouchEvent(event);
    }
  }
);
  mNotificationPanel=(NotificationPanelView)mStatusBarWindow.findViewById(R.id.notification_panel);
  mNotificationPanel.setStatusBar(this);
  mStatusBarView=(PhoneStatusBarView)mStatusBarWindow.findViewById(R.id.status_bar);
  mStatusBarView.setBar(this);
  mStatusBarView.setPanel(mNotificationPanel);
  if (!ActivityManager.isHighEndGfx()) {
    mStatusBarWindow.setBackground(null);
    mNotificationPanel.setBackground(new FastColorDrawable(context.getColor(R.color.notification_panel_solid_background)));
  }
  mHeadsUpManager=new HeadsUpManager(context,mStatusBarWindow,mGroupManager);
  mHeadsUpManager.setBar(this);
  mHeadsUpManager.addListener(this);
  mHeadsUpManager.addListener(mNotificationPanel);
  mHeadsUpManager.addListener(mGroupManager);
  mNotificationPanel.setHeadsUpManager(mHeadsUpManager);
  mNotificationData.setHeadsUpManager(mHeadsUpManager);
  if (MULTIUSER_DEBUG) {
    mNotificationPanelDebugText=(TextView)mNotificationPanel.findViewById(R.id.header_debug_info);
    mNotificationPanelDebugText.setVisibility(View.VISIBLE);
  }
  try {
    boolean showNav=mWindowManagerService.hasNavigationBar();
    if (DEBUG)     Log.v(TAG,""String_Node_Str"" + showNav);
    if (showNav) {
      createNavigationBarView(context);
    }
  }
 catch (  RemoteException ex) {
  }
  mAssistManager=new AssistManager(this,context);
  mPixelFormat=PixelFormat.OPAQUE;
  mStackScroller=(NotificationStackScrollLayout)mStatusBarWindow.findViewById(R.id.notification_stack_scroller);
  mStackScroller.setLongPressListener(getNotificationLongClicker());
  mStackScroller.setGearDisplayedListener(getGearDisplayedListener());
  mStackScroller.setPhoneStatusBar(this);
  mStackScroller.setGroupManager(mGroupManager);
  mStackScroller.setHeadsUpManager(mHeadsUpManager);
  mGroupManager.setOnGroupChangeListener(mStackScroller);
  mKeyguardIconOverflowContainer=(NotificationOverflowContainer)LayoutInflater.from(mContext).inflate(R.layout.status_bar_notification_keyguard_overflow,mStackScroller,false);
  mKeyguardIconOverflowContainer.setOnActivatedListener(this);
  mKeyguardIconOverflowContainer.setOnClickListener(mOverflowClickListener);
  mStackScroller.setOverflowContainer(mKeyguardIconOverflowContainer);
  inflateEmptyShadeView();
  inflateDismissView();
  mExpandedContents=mStackScroller;
  mBackdrop=(BackDropView)mStatusBarWindow.findViewById(R.id.backdrop);
  mBackdropFront=(ImageView)mBackdrop.findViewById(R.id.backdrop_front);
  mBackdropBack=(ImageView)mBackdrop.findViewById(R.id.backdrop_back);
  ScrimView scrimBehind=(ScrimView)mStatusBarWindow.findViewById(R.id.scrim_behind);
  ScrimView scrimInFront=(ScrimView)mStatusBarWindow.findViewById(R.id.scrim_in_front);
  View headsUpScrim=mStatusBarWindow.findViewById(R.id.heads_up_scrim);
  mScrimController=SystemUIFactory.getInstance().createScrimController(scrimBehind,scrimInFront,headsUpScrim);
  if (mScrimSrcModeEnabled) {
    Runnable runnable=new Runnable(){
      @Override public void run(){
        boolean asSrc=mBackdrop.getVisibility() != View.VISIBLE;
        mScrimController.setDrawBehindAsSrc(asSrc);
        mStackScroller.setDrawBackgroundAsSrc(asSrc);
      }
    }
;
    mBackdrop.setOnVisibilityChangedRunnable(runnable);
    runnable.run();
  }
  mHeadsUpManager.addListener(mScrimController);
  mStackScroller.setScrimController(mScrimController);
  mStatusBarView.setScrimController(mScrimController);
  mDozeScrimController=new DozeScrimController(mScrimController,context);
  mKeyguardStatusBar=(KeyguardStatusBarView)mStatusBarWindow.findViewById(R.id.keyguard_header);
  mKeyguardStatusView=mStatusBarWindow.findViewById(R.id.keyguard_status_view);
  mKeyguardBottomArea=(KeyguardBottomAreaView)mStatusBarWindow.findViewById(R.id.keyguard_bottom_area);
  mKeyguardBottomArea.setActivityStarter(this);
  mKeyguardBottomArea.setAssistManager(mAssistManager);
  mKeyguardIndicationController=new KeyguardIndicationController(mContext,(KeyguardIndicationTextView)mStatusBarWindow.findViewById(R.id.keyguard_indication_text),mKeyguardBottomArea.getLockIcon());
  mKeyguardBottomArea.setKeyguardIndicationController(mKeyguardIndicationController);
  if (ENABLE_LOCKSCREEN_WALLPAPER) {
    mLockscreenWallpaper=new LockscreenWallpaper(mContext,this,mHandler);
  }
  setAreThereNotifications();
  mIconController=new StatusBarIconController(mContext,mStatusBarView,mKeyguardStatusBar,this);
  mHandlerThread=new HandlerThread(TAG,Process.THREAD_PRIORITY_BACKGROUND);
  mHandlerThread.start();
  mLocationController=new LocationControllerImpl(mContext,mHandlerThread.getLooper());
  mBatteryController=new BatteryController(mContext);
  mBatteryController.addStateChangedCallback(new BatteryStateChangeCallback(){
    @Override public void onPowerSaveChanged(    boolean isPowerSave){
      mHandler.post(mCheckBarModes);
      if (mDozeServiceHost != null) {
        mDozeServiceHost.firePowerSaveChanged(isPowerSave);
      }
    }
    @Override public void onBatteryLevelChanged(    int level,    boolean pluggedIn,    boolean charging){
    }
  }
);
  mNetworkController=new NetworkControllerImpl(mContext,mHandlerThread.getLooper());
  mHotspotController=new HotspotControllerImpl(mContext);
  mBluetoothController=new BluetoothControllerImpl(mContext,mHandlerThread.getLooper());
  mSecurityController=new SecurityControllerImpl(mContext);
  if (mContext.getResources().getBoolean(R.bool.config_showRotationLock)) {
    mRotationLockController=new RotationLockControllerImpl(mContext);
  }
  mUserInfoController=new UserInfoController(mContext);
  mVolumeComponent=getComponent(VolumeComponent.class);
  if (mVolumeComponent != null) {
    mZenModeController=mVolumeComponent.getZenController();
  }
  mCastController=new CastControllerImpl(mContext);
  initSignalCluster(mStatusBarView);
  initSignalCluster(mKeyguardStatusBar);
  mFlashlightController=new FlashlightController(mContext);
  mKeyguardBottomArea.setFlashlightController(mFlashlightController);
  mKeyguardBottomArea.setPhoneStatusBar(this);
  mKeyguardBottomArea.setUserSetupComplete(mUserSetup);
  mAccessibilityController=new AccessibilityController(mContext);
  mKeyguardBottomArea.setAccessibilityController(mAccessibilityController);
  mNextAlarmController=new NextAlarmController(mContext);
  mLightStatusBarController=new LightStatusBarController(mIconController,mBatteryController);
  mKeyguardMonitor=new KeyguardMonitor(mContext);
  if (UserManager.get(mContext).isUserSwitcherEnabled()) {
    mUserSwitcherController=new UserSwitcherController(mContext,mKeyguardMonitor,mHandler,this);
    createUserSwitcher();
  }
  DensityContainer container=(DensityContainer)mStatusBarWindow.findViewById(R.id.qs_density_container);
  if (container != null) {
    final QSTileHost qsh=new QSTileHost(mContext,this,mBluetoothController,mLocationController,mRotationLockController,mNetworkController,mZenModeController,mHotspotController,mCastController,mFlashlightController,mUserSwitcherController,mUserInfoController,mKeyguardMonitor,mSecurityController,mBatteryController,mIconController,mNextAlarmController);
    mBrightnessMirrorController=new BrightnessMirrorController(mStatusBarWindow);
    container.addInflateListener(new InflateListener(){
      @Override public void onInflated(      View v){
        QSContainer qsContainer=(QSContainer)v.findViewById(R.id.quick_settings_container);
        qsContainer.setHost(qsh);
        mQSPanel=qsContainer.getQsPanel();
        mQSPanel.setBrightnessMirror(mBrightnessMirrorController);
        mHeader=qsContainer.getHeader();
        initSignalCluster(mHeader);
        mHeader.setActivityStarter(PhoneStatusBar.this);
      }
    }
);
  }
  mKeyguardStatusBar.setUserInfoController(mUserInfoController);
  mKeyguardStatusBar.setUserSwitcherController(mUserSwitcherController);
  mUserInfoController.reloadUserInfo();
  ((BatteryMeterView)mStatusBarView.findViewById(R.id.battery)).setBatteryController(mBatteryController);
  mKeyguardStatusBar.setBatteryController(mBatteryController);
  PowerManager pm=(PowerManager)mContext.getSystemService(Context.POWER_SERVICE);
  mBroadcastReceiver.onReceive(mContext,new Intent(pm.isScreenOn() ? Intent.ACTION_SCREEN_ON : Intent.ACTION_SCREEN_OFF));
  mGestureWakeLock=pm.newWakeLock(PowerManager.SCREEN_BRIGHT_WAKE_LOCK,""String_Node_Str"");
  mVibrator=mContext.getSystemService(Vibrator.class);
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
  filter.addAction(Intent.ACTION_SCREEN_OFF);
  filter.addAction(Intent.ACTION_SCREEN_ON);
  context.registerReceiverAsUser(mBroadcastReceiver,UserHandle.ALL,filter,null,null);
  IntentFilter demoFilter=new IntentFilter();
  if (DEBUG_MEDIA_FAKE_ARTWORK) {
    demoFilter.addAction(ACTION_FAKE_ARTWORK);
  }
  demoFilter.addAction(ACTION_DEMO);
  context.registerReceiverAsUser(mDemoReceiver,UserHandle.ALL,demoFilter,android.Manifest.permission.DUMP,null);
  resetUserSetupObserver();
  ThreadedRenderer.overrideProperty(""String_Node_Str"",""String_Node_Str"");
  ThreadedRenderer.overrideProperty(""String_Node_Str"",String.valueOf(1.5f));
  return mStatusBarView;
}",0.9790729308360364
192549,"public ScrimController(ScrimView scrimBehind,ScrimView scrimInFront,View headsUpScrim,boolean scrimSrcEnabled){
  mScrimBehind=scrimBehind;
  mScrimInFront=scrimInFront;
  mHeadsUpScrim=headsUpScrim;
  final Context context=scrimBehind.getContext();
  mUnlockMethodCache=UnlockMethodCache.getInstance(context);
  mScrimSrcEnabled=scrimSrcEnabled;
  updateHeadsUpScrim(false);
}","public ScrimController(ScrimView scrimBehind,ScrimView scrimInFront,View headsUpScrim){
  mScrimBehind=scrimBehind;
  mScrimInFront=scrimInFront;
  mHeadsUpScrim=headsUpScrim;
  final Context context=scrimBehind.getContext();
  mUnlockMethodCache=UnlockMethodCache.getInstance(context);
  updateHeadsUpScrim(false);
}",0.9135446685878964
192550,"public NotificationStackScrollLayout(Context context,AttributeSet attrs,int defStyleAttr,int defStyleRes){
  super(context,attrs,defStyleAttr,defStyleRes);
  mBgColor=context.getColor(R.color.notification_shade_background_color);
  int minHeight=getResources().getDimensionPixelSize(R.dimen.notification_min_height);
  int maxHeight=getResources().getDimensionPixelSize(R.dimen.notification_max_height);
  mExpandHelper=new ExpandHelper(getContext(),this,minHeight,maxHeight);
  mExpandHelper.setEventSource(this);
  mExpandHelper.setScrollAdapter(this);
  mSwipeHelper=new NotificationSwipeHelper(SwipeHelper.X,this,getContext());
  mSwipeHelper.setLongPressListener(mLongPressListener);
  mStackScrollAlgorithm=new StackScrollAlgorithm(context);
  initView(context);
  setWillNotDraw(false);
  if (DEBUG) {
    mDebugPaint=new Paint();
    mDebugPaint.setColor(0xffff0000);
    mDebugPaint.setStrokeWidth(2);
    mDebugPaint.setStyle(Paint.Style.STROKE);
  }
  mFalsingManager=FalsingManager.getInstance(context);
  mBackgroundPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC));
}","public NotificationStackScrollLayout(Context context,AttributeSet attrs,int defStyleAttr,int defStyleRes){
  super(context,attrs,defStyleAttr,defStyleRes);
  mBgColor=context.getColor(R.color.notification_shade_background_color);
  int minHeight=getResources().getDimensionPixelSize(R.dimen.notification_min_height);
  int maxHeight=getResources().getDimensionPixelSize(R.dimen.notification_max_height);
  mExpandHelper=new ExpandHelper(getContext(),this,minHeight,maxHeight);
  mExpandHelper.setEventSource(this);
  mExpandHelper.setScrollAdapter(this);
  mSwipeHelper=new NotificationSwipeHelper(SwipeHelper.X,this,getContext());
  mSwipeHelper.setLongPressListener(mLongPressListener);
  mStackScrollAlgorithm=new StackScrollAlgorithm(context);
  initView(context);
  setWillNotDraw(false);
  if (DEBUG) {
    mDebugPaint=new Paint();
    mDebugPaint.setColor(0xffff0000);
    mDebugPaint.setStrokeWidth(2);
    mDebugPaint.setStyle(Paint.Style.STROKE);
  }
  mFalsingManager=FalsingManager.getInstance(context);
}",0.9635243960208432
192551,"public AppErrorDialog(Context context,ActivityManagerService service,Data data){
  super(context);
  Resources res=context.getResources();
  mService=service;
  mProc=data.proc;
  mResult=data.result;
  mRepeating=data.repeating;
  if ((mProc.pkgList.size() == 1) && (mName=context.getPackageManager().getApplicationLabel(mProc.info)) != null) {
    setTitle(res.getString(mRepeating ? com.android.internal.R.string.aerr_application_repeated : com.android.internal.R.string.aerr_application,mName.toString(),mProc.info.processName));
  }
 else {
    mName=mProc.processName;
    setTitle(res.getString(mRepeating ? com.android.internal.R.string.aerr_process_repeated : com.android.internal.R.string.aerr_process,mName.toString()));
  }
  setCancelable(false);
  WindowManager.LayoutParams attrs=getWindow().getAttributes();
  attrs.setTitle(""String_Node_Str"" + mProc.info.processName);
  attrs.privateFlags|=WindowManager.LayoutParams.PRIVATE_FLAG_SYSTEM_ERROR | WindowManager.LayoutParams.PRIVATE_FLAG_SHOW_FOR_ALL_USERS;
  getWindow().setAttributes(attrs);
  if (mProc.persistent) {
    getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ERROR);
  }
  mHandler.sendMessageDelayed(mHandler.obtainMessage(TIMEOUT),DISMISS_TIMEOUT);
}","public AppErrorDialog(Context context,ActivityManagerService service,Data data){
  super(context);
  Resources res=context.getResources();
  mService=service;
  mProc=data.proc;
  mResult=data.result;
  mRepeating=data.repeating;
  BidiFormatter bidi=BidiFormatter.getInstance();
  if ((mProc.pkgList.size() == 1) && (mName=context.getPackageManager().getApplicationLabel(mProc.info)) != null) {
    setTitle(res.getString(mRepeating ? com.android.internal.R.string.aerr_application_repeated : com.android.internal.R.string.aerr_application,bidi.unicodeWrap(mName.toString()),bidi.unicodeWrap(mProc.info.processName)));
  }
 else {
    mName=mProc.processName;
    setTitle(res.getString(mRepeating ? com.android.internal.R.string.aerr_process_repeated : com.android.internal.R.string.aerr_process,bidi.unicodeWrap(mName.toString())));
  }
  setCancelable(false);
  WindowManager.LayoutParams attrs=getWindow().getAttributes();
  attrs.setTitle(""String_Node_Str"" + mProc.info.processName);
  attrs.privateFlags|=WindowManager.LayoutParams.PRIVATE_FLAG_SYSTEM_ERROR | WindowManager.LayoutParams.PRIVATE_FLAG_SHOW_FOR_ALL_USERS;
  getWindow().setAttributes(attrs);
  if (mProc.persistent) {
    getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ERROR);
  }
  mHandler.sendMessageDelayed(mHandler.obtainMessage(TIMEOUT),DISMISS_TIMEOUT);
}",0.959783449342614
192552,"public AppNotRespondingDialog(ActivityManagerService service,Context context,ProcessRecord app,ActivityRecord activity,boolean aboveSystem){
  super(context);
  mService=service;
  mProc=app;
  Resources res=context.getResources();
  setCancelable(false);
  int resid;
  CharSequence name1=activity != null ? activity.info.loadLabel(context.getPackageManager()) : null;
  CharSequence name2=null;
  if ((app.pkgList.size() == 1) && (name2=context.getPackageManager().getApplicationLabel(app.info)) != null) {
    if (name1 != null) {
      resid=com.android.internal.R.string.anr_activity_application;
    }
 else {
      name1=name2;
      name2=app.processName;
      resid=com.android.internal.R.string.anr_application_process;
    }
  }
 else {
    if (name1 != null) {
      name2=app.processName;
      resid=com.android.internal.R.string.anr_activity_process;
    }
 else {
      name1=app.processName;
      resid=com.android.internal.R.string.anr_process;
    }
  }
  setTitle(name2 != null ? res.getString(resid,name1.toString(),name2.toString()) : res.getString(resid,name1.toString()));
  if (aboveSystem) {
    getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ERROR);
  }
  WindowManager.LayoutParams attrs=getWindow().getAttributes();
  attrs.setTitle(""String_Node_Str"" + app.info.processName);
  attrs.privateFlags=WindowManager.LayoutParams.PRIVATE_FLAG_SYSTEM_ERROR | WindowManager.LayoutParams.PRIVATE_FLAG_SHOW_FOR_ALL_USERS;
  getWindow().setAttributes(attrs);
}","public AppNotRespondingDialog(ActivityManagerService service,Context context,ProcessRecord app,ActivityRecord activity,boolean aboveSystem){
  super(context);
  mService=service;
  mProc=app;
  Resources res=context.getResources();
  setCancelable(false);
  int resid;
  CharSequence name1=activity != null ? activity.info.loadLabel(context.getPackageManager()) : null;
  CharSequence name2=null;
  if ((app.pkgList.size() == 1) && (name2=context.getPackageManager().getApplicationLabel(app.info)) != null) {
    if (name1 != null) {
      resid=com.android.internal.R.string.anr_activity_application;
    }
 else {
      name1=name2;
      name2=app.processName;
      resid=com.android.internal.R.string.anr_application_process;
    }
  }
 else {
    if (name1 != null) {
      name2=app.processName;
      resid=com.android.internal.R.string.anr_activity_process;
    }
 else {
      name1=app.processName;
      resid=com.android.internal.R.string.anr_process;
    }
  }
  BidiFormatter bidi=BidiFormatter.getInstance();
  setTitle(name2 != null ? res.getString(resid,bidi.unicodeWrap(name1.toString()),bidi.unicodeWrap(name2.toString())) : res.getString(resid,bidi.unicodeWrap(name1.toString())));
  if (aboveSystem) {
    getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ERROR);
  }
  WindowManager.LayoutParams attrs=getWindow().getAttributes();
  attrs.setTitle(""String_Node_Str"" + app.info.processName);
  attrs.privateFlags=WindowManager.LayoutParams.PRIVATE_FLAG_SYSTEM_ERROR | WindowManager.LayoutParams.PRIVATE_FLAG_SHOW_FOR_ALL_USERS;
  getWindow().setAttributes(attrs);
}",0.966321243523316
192553,"public boolean canChildBeExpanded(View v){
  return v instanceof ExpandableNotificationRow && ((ExpandableNotificationRow)v).isExpandable() && !((ExpandableNotificationRow)v).isHeadsUp();
}","public boolean canChildBeExpanded(View v){
  return v instanceof ExpandableNotificationRow && ((ExpandableNotificationRow)v).isExpandable() && (mIsExpanded || !((ExpandableNotificationRow)v).isPinned());
}",0.9187817258883249
192554,"private void onAdvancedPrintOptionsActivityResult(int resultCode,Intent data){
  if (resultCode != RESULT_OK || data == null) {
    return;
  }
  PrintJobInfo printJobInfo=data.getParcelableExtra(PrintService.EXTRA_PRINT_JOB_INFO);
  if (printJobInfo == null) {
    return;
  }
  mPrintJob.setAdvancedOptions(printJobInfo.getAdvancedOptions());
  mCopiesEditText.setText(String.valueOf(printJobInfo.getCopies()));
  mPrintJob.setCopies(printJobInfo.getCopies());
  PrintAttributes currAttributes=mPrintJob.getAttributes();
  PrintAttributes newAttributes=printJobInfo.getAttributes();
  if (newAttributes != null) {
    MediaSize oldMediaSize=currAttributes.getMediaSize();
    MediaSize newMediaSize=newAttributes.getMediaSize();
    if (!oldMediaSize.equals(newMediaSize)) {
      final int mediaSizeCount=mMediaSizeSpinnerAdapter.getCount();
      MediaSize newMediaSizePortrait=newAttributes.getMediaSize().asPortrait();
      for (int i=0; i < mediaSizeCount; i++) {
        MediaSize supportedSizePortrait=mMediaSizeSpinnerAdapter.getItem(i).value.asPortrait();
        if (supportedSizePortrait.equals(newMediaSizePortrait)) {
          currAttributes.setMediaSize(newMediaSize);
          mMediaSizeSpinner.setSelection(i);
          if (currAttributes.getMediaSize().isPortrait()) {
            if (mOrientationSpinner.getSelectedItemPosition() != 0) {
              mOrientationSpinner.setSelection(0);
            }
          }
 else {
            if (mOrientationSpinner.getSelectedItemPosition() != 1) {
              mOrientationSpinner.setSelection(1);
            }
          }
          break;
        }
      }
    }
    Resolution oldResolution=currAttributes.getResolution();
    Resolution newResolution=newAttributes.getResolution();
    if (!oldResolution.equals(newResolution)) {
      PrinterCapabilitiesInfo capabilities=mCurrentPrinter.getCapabilities();
      if (capabilities != null) {
        List<Resolution> resolutions=capabilities.getResolutions();
        final int resolutionCount=resolutions.size();
        for (int i=0; i < resolutionCount; i++) {
          Resolution resolution=resolutions.get(i);
          if (resolution.equals(newResolution)) {
            currAttributes.setResolution(resolution);
            break;
          }
        }
      }
    }
    final int currColorMode=currAttributes.getColorMode();
    final int newColorMode=newAttributes.getColorMode();
    if (currColorMode != newColorMode) {
      final int colorModeCount=mColorModeSpinner.getCount();
      for (int i=0; i < colorModeCount; i++) {
        final int supportedColorMode=mColorModeSpinnerAdapter.getItem(i).value;
        if (supportedColorMode == newColorMode) {
          currAttributes.setColorMode(newColorMode);
          mColorModeSpinner.setSelection(i);
          break;
        }
      }
    }
    final int currDuplexMode=currAttributes.getDuplexMode();
    final int newDuplexMode=newAttributes.getDuplexMode();
    if (currDuplexMode != newDuplexMode) {
      final int duplexModeCount=mDuplexModeSpinner.getCount();
      for (int i=0; i < duplexModeCount; i++) {
        final int supportedDuplexMode=mDuplexModeSpinnerAdapter.getItem(i).value;
        if (supportedDuplexMode == newDuplexMode) {
          currAttributes.setDuplexMode(newDuplexMode);
          mDuplexModeSpinner.setSelection(i);
          break;
        }
      }
    }
  }
  PrintDocumentInfo info=mPrintedDocument.getDocumentInfo().info;
  final int pageCount=(info != null) ? getAdjustedPageCount(info) : 0;
  PageRange[] pageRanges=printJobInfo.getPages();
  if (pageRanges != null && pageCount > 0) {
    pageRanges=PageRangeUtils.normalize(pageRanges);
    List<PageRange> validatedList=new ArrayList<>();
    final int rangeCount=pageRanges.length;
    for (int i=0; i < rangeCount; i++) {
      PageRange pageRange=pageRanges[i];
      if (pageRange.getEnd() >= pageCount) {
        final int rangeStart=pageRange.getStart();
        final int rangeEnd=pageCount - 1;
        if (rangeStart <= rangeEnd) {
          pageRange=new PageRange(rangeStart,rangeEnd);
          validatedList.add(pageRange);
        }
        break;
      }
      validatedList.add(pageRange);
    }
    if (!validatedList.isEmpty()) {
      PageRange[] validatedArray=new PageRange[validatedList.size()];
      validatedList.toArray(validatedArray);
      updateSelectedPages(validatedArray,pageCount);
    }
  }
  if (canUpdateDocument()) {
    updateDocument(false);
  }
}","private void onAdvancedPrintOptionsActivityResult(int resultCode,Intent data){
  if (resultCode != RESULT_OK || data == null) {
    return;
  }
  PrintJobInfo printJobInfo=data.getParcelableExtra(PrintService.EXTRA_PRINT_JOB_INFO);
  if (printJobInfo == null) {
    return;
  }
  mPrintJob.setAdvancedOptions(printJobInfo.getAdvancedOptions());
  if (printJobInfo.getCopies() < 1) {
    Log.w(LOG_TAG,""String_Node_Str"" + ""String_Node_Str"" + printJobInfo.getCopies() + ""String_Node_Str""+ ""String_Node_Str"");
  }
 else {
    mCopiesEditText.setText(String.valueOf(printJobInfo.getCopies()));
    mPrintJob.setCopies(printJobInfo.getCopies());
  }
  PrintAttributes currAttributes=mPrintJob.getAttributes();
  PrintAttributes newAttributes=printJobInfo.getAttributes();
  if (newAttributes != null) {
    MediaSize oldMediaSize=currAttributes.getMediaSize();
    MediaSize newMediaSize=newAttributes.getMediaSize();
    if (newMediaSize != null && !oldMediaSize.equals(newMediaSize)) {
      final int mediaSizeCount=mMediaSizeSpinnerAdapter.getCount();
      MediaSize newMediaSizePortrait=newAttributes.getMediaSize().asPortrait();
      for (int i=0; i < mediaSizeCount; i++) {
        MediaSize supportedSizePortrait=mMediaSizeSpinnerAdapter.getItem(i).value.asPortrait();
        if (supportedSizePortrait.equals(newMediaSizePortrait)) {
          currAttributes.setMediaSize(newMediaSize);
          mMediaSizeSpinner.setSelection(i);
          if (currAttributes.getMediaSize().isPortrait()) {
            if (mOrientationSpinner.getSelectedItemPosition() != 0) {
              mOrientationSpinner.setSelection(0);
            }
          }
 else {
            if (mOrientationSpinner.getSelectedItemPosition() != 1) {
              mOrientationSpinner.setSelection(1);
            }
          }
          break;
        }
      }
    }
    Resolution oldResolution=currAttributes.getResolution();
    Resolution newResolution=newAttributes.getResolution();
    if (!oldResolution.equals(newResolution)) {
      PrinterCapabilitiesInfo capabilities=mCurrentPrinter.getCapabilities();
      if (capabilities != null) {
        List<Resolution> resolutions=capabilities.getResolutions();
        final int resolutionCount=resolutions.size();
        for (int i=0; i < resolutionCount; i++) {
          Resolution resolution=resolutions.get(i);
          if (resolution.equals(newResolution)) {
            currAttributes.setResolution(resolution);
            break;
          }
        }
      }
    }
    final int currColorMode=currAttributes.getColorMode();
    final int newColorMode=newAttributes.getColorMode();
    if (currColorMode != newColorMode) {
      final int colorModeCount=mColorModeSpinner.getCount();
      for (int i=0; i < colorModeCount; i++) {
        final int supportedColorMode=mColorModeSpinnerAdapter.getItem(i).value;
        if (supportedColorMode == newColorMode) {
          currAttributes.setColorMode(newColorMode);
          mColorModeSpinner.setSelection(i);
          break;
        }
      }
    }
    final int currDuplexMode=currAttributes.getDuplexMode();
    final int newDuplexMode=newAttributes.getDuplexMode();
    if (currDuplexMode != newDuplexMode) {
      final int duplexModeCount=mDuplexModeSpinner.getCount();
      for (int i=0; i < duplexModeCount; i++) {
        final int supportedDuplexMode=mDuplexModeSpinnerAdapter.getItem(i).value;
        if (supportedDuplexMode == newDuplexMode) {
          currAttributes.setDuplexMode(newDuplexMode);
          mDuplexModeSpinner.setSelection(i);
          break;
        }
      }
    }
  }
  PrintDocumentInfo info=mPrintedDocument.getDocumentInfo().info;
  final int pageCount=(info != null) ? getAdjustedPageCount(info) : 0;
  PageRange[] pageRanges=printJobInfo.getPages();
  if (pageRanges != null && pageCount > 0) {
    pageRanges=PageRangeUtils.normalize(pageRanges);
    List<PageRange> validatedList=new ArrayList<>();
    final int rangeCount=pageRanges.length;
    for (int i=0; i < rangeCount; i++) {
      PageRange pageRange=pageRanges[i];
      if (pageRange.getEnd() >= pageCount) {
        final int rangeStart=pageRange.getStart();
        final int rangeEnd=pageCount - 1;
        if (rangeStart <= rangeEnd) {
          pageRange=new PageRange(rangeStart,rangeEnd);
          validatedList.add(pageRange);
        }
        break;
      }
      validatedList.add(pageRange);
    }
    if (!validatedList.isEmpty()) {
      PageRange[] validatedArray=new PageRange[validatedList.size()];
      validatedList.toArray(validatedArray);
      updateSelectedPages(validatedArray,pageCount);
    }
  }
  if (canUpdateDocument()) {
    updateDocument(false);
  }
}",0.9774912587412588
192555,"private void startAdvancedPrintOptionsActivity(PrinterInfo printer){
  ComponentName serviceName=printer.getId().getServiceName();
  String activityName=PrintOptionUtils.getAdvancedOptionsActivityName(this,serviceName);
  if (TextUtils.isEmpty(activityName)) {
    return;
  }
  Intent intent=new Intent(Intent.ACTION_MAIN);
  intent.setComponent(new ComponentName(serviceName.getPackageName(),activityName));
  List<ResolveInfo> resolvedActivities=getPackageManager().queryIntentActivities(intent,0);
  if (resolvedActivities.isEmpty()) {
    return;
  }
  if (resolvedActivities.get(0).activityInfo.exported) {
    intent.putExtra(PrintService.EXTRA_PRINT_JOB_INFO,mPrintJob);
    intent.putExtra(PrintService.EXTRA_PRINTER_INFO,printer);
    intent.putExtra(PrintService.EXTRA_PRINT_DOCUMENT_INFO,mPrintedDocument.getDocumentInfo().info);
    try {
      startActivityForResult(intent,ACTIVITY_REQUEST_POPULATE_ADVANCED_PRINT_OPTIONS);
    }
 catch (    ActivityNotFoundException anfe) {
      Log.e(LOG_TAG,""String_Node_Str"" + intent,anfe);
    }
  }
}","private void startAdvancedPrintOptionsActivity(PrinterInfo printer){
  ComponentName serviceName=printer.getId().getServiceName();
  String activityName=PrintOptionUtils.getAdvancedOptionsActivityName(this,serviceName);
  if (TextUtils.isEmpty(activityName)) {
    return;
  }
  Intent intent=new Intent(Intent.ACTION_MAIN);
  intent.setComponent(new ComponentName(serviceName.getPackageName(),activityName));
  List<ResolveInfo> resolvedActivities=getPackageManager().queryIntentActivities(intent,0);
  if (resolvedActivities.isEmpty()) {
    return;
  }
  if (resolvedActivities.get(0).activityInfo.exported) {
    PrintJobInfo.Builder printJobBuilder=new PrintJobInfo.Builder(mPrintJob);
    printJobBuilder.setPages(mSelectedPages);
    intent.putExtra(PrintService.EXTRA_PRINT_JOB_INFO,printJobBuilder.build());
    intent.putExtra(PrintService.EXTRA_PRINTER_INFO,printer);
    intent.putExtra(PrintService.EXTRA_PRINT_DOCUMENT_INFO,mPrintedDocument.getDocumentInfo().info);
    try {
      startActivityForResult(intent,ACTIVITY_REQUEST_POPULATE_ADVANCED_PRINT_OPTIONS);
    }
 catch (    ActivityNotFoundException anfe) {
      Log.e(LOG_TAG,""String_Node_Str"" + intent,anfe);
    }
  }
}",0.9368888888888888
192556,"public void resetHeight(){
  if (mIsHeadsUp) {
    resetActualHeight();
  }
  mMaxExpandHeight=0;
  mHeadsUpHeight=0;
  mWasReset=true;
  onHeightReset();
  requestLayout();
}","public void resetHeight(){
  mMaxExpandHeight=0;
  mHeadsUpHeight=0;
  onHeightReset();
  requestLayout();
}",0.7632508833922261
192557,"@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  super.onLayout(changed,left,top,right,bottom);
  boolean updateExpandHeight=mMaxExpandHeight == 0 && !mWasReset;
  updateMaxHeights();
  if (updateExpandHeight) {
    applyExpansionToLayout();
  }
  mWasReset=false;
}","@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  super.onLayout(changed,left,top,right,bottom);
  updateMaxHeights();
}",0.6878980891719745
192558,"/** 
 * Resets this view so it can be re-used for an updated notification.
 */
@Override public void reset(){
  super.reset();
  final boolean wasExpanded=isExpanded();
  mExpandable=false;
  mHasUserChangedExpansion=false;
  mUserLocked=false;
  mShowingPublic=false;
  mSensitive=false;
  mShowingPublicInitialized=false;
  mIsSystemExpanded=false;
  mOnKeyguard=false;
  mPublicLayout.reset(mIsHeadsUp);
  mPrivateLayout.reset(mIsHeadsUp);
  resetHeight();
  resetTranslation();
  logExpansionEvent(false,wasExpanded);
}","/** 
 * Resets this view so it can be re-used for an updated notification.
 */
@Override public void reset(){
  super.reset();
  final boolean wasExpanded=isExpanded();
  mExpandable=false;
  mHasUserChangedExpansion=false;
  mUserLocked=false;
  mShowingPublic=false;
  mSensitive=false;
  mShowingPublicInitialized=false;
  mIsSystemExpanded=false;
  mOnKeyguard=false;
  mPublicLayout.reset();
  mPrivateLayout.reset();
  resetHeight();
  resetTranslation();
  logExpansionEvent(false,wasExpanded);
}",0.9805068226120858
192559,"@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  super.onLayout(changed,left,top,right,bottom);
  if (!mActualHeightInitialized && mActualHeight == 0) {
    int initialHeight=getInitialHeight();
    if (initialHeight != 0) {
      setActualHeight(initialHeight);
    }
  }
  updateClipping();
}","@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  super.onLayout(changed,left,top,right,bottom);
  updateClipping();
}",0.6438631790744467
192560,"@Override public void run(){
  hiddenView.setVisible(false);
}","@Override public void run(){
  if (hiddenView != getTransformableViewForVisibleType(mVisibleType)) {
    hiddenView.setVisible(false);
  }
}",0.6138613861386139
192561,"public NotificationContentView(Context context,AttributeSet attrs){
  super(context,attrs);
  mHybridViewManager=new HybridNotificationViewManager(getContext(),this);
  mMinContractedHeight=getResources().getDimensionPixelSize(R.dimen.min_notification_layout_height);
  mNotificationContentMarginEnd=getResources().getDimensionPixelSize(com.android.internal.R.dimen.notification_content_margin_end);
  reset(true);
}","public NotificationContentView(Context context,AttributeSet attrs){
  super(context,attrs);
  mHybridViewManager=new HybridNotificationViewManager(getContext(),this);
  mMinContractedHeight=getResources().getDimensionPixelSize(R.dimen.min_notification_layout_height);
  mNotificationContentMarginEnd=getResources().getDimensionPixelSize(com.android.internal.R.dimen.notification_content_margin_end);
  reset();
}",0.9951690821256038
192562,"public void reset(boolean resetActualHeight){
  if (mContractedChild != null) {
    mContractedChild.animate().cancel();
    removeView(mContractedChild);
  }
  if (mExpandedChild != null) {
    mExpandedChild.animate().cancel();
    removeView(mExpandedChild);
  }
  if (mHeadsUpChild != null) {
    mHeadsUpChild.animate().cancel();
    removeView(mHeadsUpChild);
  }
  mContractedChild=null;
  mExpandedChild=null;
  mHeadsUpChild=null;
  mVisibleType=VISIBLE_TYPE_CONTRACTED;
  if (resetActualHeight) {
    mContentHeight=mSmallHeight;
  }
}","public void reset(){
  if (mContractedChild != null) {
    mContractedChild.animate().cancel();
    removeView(mContractedChild);
  }
  if (mExpandedChild != null) {
    mExpandedChild.animate().cancel();
    removeView(mExpandedChild);
  }
  if (mHeadsUpChild != null) {
    mHeadsUpChild.animate().cancel();
    removeView(mHeadsUpChild);
  }
  mContractedChild=null;
  mExpandedChild=null;
  mHeadsUpChild=null;
}",0.8657648283038502
192563,"/** 
 * @return one of the static enum types in this view, calculated form the current state
 */
private int calculateVisibleType(){
  if (mUserExpanding) {
    int height=!mIsChildInGroup || isGroupExpanded() || mContainingNotification.isExpanded() ? mContainingNotification.getMaxContentHeight() : mContainingNotification.getShowingLayout().getMinHeight();
    int expandedVisualType=getVisualTypeForHeight(height);
    int collapsedVisualType=getVisualTypeForHeight(mContainingNotification.getMinExpandHeight());
    return mTransformationStartVisibleType == collapsedVisualType ? expandedVisualType : collapsedVisualType;
  }
  int viewHeight=Math.min(mContentHeight,mContainingNotification.getIntrinsicHeight());
  return getVisualTypeForHeight(viewHeight);
}","/** 
 * @return one of the static enum types in this view, calculated form the current state
 */
private int calculateVisibleType(){
  if (mUserExpanding) {
    int height=!mIsChildInGroup || isGroupExpanded() || mContainingNotification.isExpanded() ? mContainingNotification.getMaxContentHeight() : mContainingNotification.getShowingLayout().getMinHeight();
    if (height == 0) {
      height=mContentHeight;
    }
    int expandedVisualType=getVisualTypeForHeight(height);
    int collapsedVisualType=getVisualTypeForHeight(mContainingNotification.getMinExpandHeight());
    return mTransformationStartVisibleType == collapsedVisualType ? expandedVisualType : collapsedVisualType;
  }
  int intrinsicHeight=mContainingNotification.getIntrinsicHeight();
  int viewHeight=mContentHeight;
  if (intrinsicHeight != 0) {
    viewHeight=Math.min(mContentHeight,intrinsicHeight);
  }
  return getVisualTypeForHeight(viewHeight);
}",0.8520710059171598
192564,"public void onNotificationUpdated(NotificationData.Entry entry){
  mStatusBarNotification=entry.notification;
  mBeforeN=entry.targetSdk < Build.VERSION_CODES.N;
  updateSingleLineView();
  applyRemoteInput(entry);
  selectLayout(false,true);
  if (mContractedChild != null) {
    mContractedWrapper.notifyContentUpdated(entry.notification);
  }
  if (mExpandedChild != null) {
    mExpandedWrapper.notifyContentUpdated(entry.notification);
  }
  if (mHeadsUpChild != null) {
    mHeadsUpWrapper.notifyContentUpdated(entry.notification);
  }
  setDark(mDark,false,0);
}","public void onNotificationUpdated(NotificationData.Entry entry){
  mStatusBarNotification=entry.notification;
  mBeforeN=entry.targetSdk < Build.VERSION_CODES.N;
  updateSingleLineView();
  applyRemoteInput(entry);
  if (mContractedChild != null) {
    mContractedWrapper.notifyContentUpdated(entry.notification);
  }
  if (mExpandedChild != null) {
    mExpandedWrapper.notifyContentUpdated(entry.notification);
  }
  if (mHeadsUpChild != null) {
    mHeadsUpWrapper.notifyContentUpdated(entry.notification);
  }
  selectLayout(false,true);
  setDark(mDark,false,0);
}",0.9507908611599296
192565,"private void animateToVisibleType(int visibleType){
  final TransformableView shownView=getTransformableViewForVisibleType(visibleType);
  final TransformableView hiddenView=getTransformableViewForVisibleType(mVisibleType);
  shownView.transformFrom(hiddenView);
  getViewForVisibleType(visibleType).setVisibility(View.VISIBLE);
  hiddenView.transformTo(shownView,new Runnable(){
    @Override public void run(){
      hiddenView.setVisible(false);
    }
  }
);
}","private void animateToVisibleType(int visibleType){
  final TransformableView shownView=getTransformableViewForVisibleType(visibleType);
  final TransformableView hiddenView=getTransformableViewForVisibleType(mVisibleType);
  if (shownView == hiddenView) {
    shownView.setVisible(true);
    return;
  }
  shownView.transformFrom(hiddenView);
  getViewForVisibleType(visibleType).setVisibility(View.VISIBLE);
  hiddenView.transformTo(shownView,new Runnable(){
    @Override public void run(){
      if (hiddenView != getTransformableViewForVisibleType(mVisibleType)) {
        hiddenView.setVisible(false);
      }
    }
  }
);
}",0.8417200365965233
192566,"public void resetHeight(){
  if (mIsHeadsUp) {
    resetActualHeight();
  }
  mMaxExpandHeight=0;
  mHeadsUpHeight=0;
  mWasReset=true;
  onHeightReset();
  requestLayout();
}","public void resetHeight(){
  mMaxExpandHeight=0;
  mHeadsUpHeight=0;
  onHeightReset();
  requestLayout();
}",0.7632508833922261
192567,"@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  super.onLayout(changed,left,top,right,bottom);
  boolean updateExpandHeight=mMaxExpandHeight == 0 && !mWasReset;
  updateMaxHeights();
  if (updateExpandHeight) {
    applyExpansionToLayout();
  }
  mWasReset=false;
}","@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  super.onLayout(changed,left,top,right,bottom);
  updateMaxHeights();
}",0.6878980891719745
192568,"/** 
 * Resets this view so it can be re-used for an updated notification.
 */
@Override public void reset(){
  super.reset();
  final boolean wasExpanded=isExpanded();
  mExpandable=false;
  mHasUserChangedExpansion=false;
  mUserLocked=false;
  mShowingPublic=false;
  mSensitive=false;
  mShowingPublicInitialized=false;
  mIsSystemExpanded=false;
  mOnKeyguard=false;
  mPublicLayout.reset(mIsHeadsUp);
  mPrivateLayout.reset(mIsHeadsUp);
  resetHeight();
  resetTranslation();
  logExpansionEvent(false,wasExpanded);
}","/** 
 * Resets this view so it can be re-used for an updated notification.
 */
@Override public void reset(){
  super.reset();
  final boolean wasExpanded=isExpanded();
  mExpandable=false;
  mHasUserChangedExpansion=false;
  mUserLocked=false;
  mShowingPublic=false;
  mSensitive=false;
  mShowingPublicInitialized=false;
  mIsSystemExpanded=false;
  mOnKeyguard=false;
  mPublicLayout.reset();
  mPrivateLayout.reset();
  resetHeight();
  resetTranslation();
  logExpansionEvent(false,wasExpanded);
}",0.9805068226120858
192569,"@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  super.onLayout(changed,left,top,right,bottom);
  if (!mActualHeightInitialized && mActualHeight == 0) {
    int initialHeight=getInitialHeight();
    if (initialHeight != 0) {
      setActualHeight(initialHeight);
    }
  }
  updateClipping();
}","@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  super.onLayout(changed,left,top,right,bottom);
  updateClipping();
}",0.6438631790744467
192570,"@Override public void run(){
  hiddenView.setVisible(false);
}","@Override public void run(){
  if (hiddenView != getTransformableViewForVisibleType(mVisibleType)) {
    hiddenView.setVisible(false);
  }
}",0.6138613861386139
192571,"public NotificationContentView(Context context,AttributeSet attrs){
  super(context,attrs);
  mHybridViewManager=new HybridNotificationViewManager(getContext(),this);
  mMinContractedHeight=getResources().getDimensionPixelSize(R.dimen.min_notification_layout_height);
  mNotificationContentMarginEnd=getResources().getDimensionPixelSize(com.android.internal.R.dimen.notification_content_margin_end);
  reset(true);
}","public NotificationContentView(Context context,AttributeSet attrs){
  super(context,attrs);
  mHybridViewManager=new HybridNotificationViewManager(getContext(),this);
  mMinContractedHeight=getResources().getDimensionPixelSize(R.dimen.min_notification_layout_height);
  mNotificationContentMarginEnd=getResources().getDimensionPixelSize(com.android.internal.R.dimen.notification_content_margin_end);
  reset();
}",0.9951690821256038
192572,"public void reset(boolean resetActualHeight){
  if (mContractedChild != null) {
    mContractedChild.animate().cancel();
    removeView(mContractedChild);
  }
  if (mExpandedChild != null) {
    mExpandedChild.animate().cancel();
    removeView(mExpandedChild);
  }
  if (mHeadsUpChild != null) {
    mHeadsUpChild.animate().cancel();
    removeView(mHeadsUpChild);
  }
  mContractedChild=null;
  mExpandedChild=null;
  mHeadsUpChild=null;
  mVisibleType=VISIBLE_TYPE_CONTRACTED;
  if (resetActualHeight) {
    mContentHeight=mSmallHeight;
  }
}","public void reset(){
  if (mContractedChild != null) {
    mContractedChild.animate().cancel();
    removeView(mContractedChild);
  }
  if (mExpandedChild != null) {
    mExpandedChild.animate().cancel();
    removeView(mExpandedChild);
  }
  if (mHeadsUpChild != null) {
    mHeadsUpChild.animate().cancel();
    removeView(mHeadsUpChild);
  }
  mContractedChild=null;
  mExpandedChild=null;
  mHeadsUpChild=null;
}",0.8657648283038502
192573,"/** 
 * @return one of the static enum types in this view, calculated form the current state
 */
private int calculateVisibleType(){
  if (mUserExpanding) {
    int height=!mIsChildInGroup || isGroupExpanded() || mContainingNotification.isExpanded() ? mContainingNotification.getMaxContentHeight() : mContainingNotification.getShowingLayout().getMinHeight();
    int expandedVisualType=getVisualTypeForHeight(height);
    int collapsedVisualType=getVisualTypeForHeight(mContainingNotification.getMinExpandHeight());
    return mTransformationStartVisibleType == collapsedVisualType ? expandedVisualType : collapsedVisualType;
  }
  int viewHeight=Math.min(mContentHeight,mContainingNotification.getIntrinsicHeight());
  return getVisualTypeForHeight(viewHeight);
}","/** 
 * @return one of the static enum types in this view, calculated form the current state
 */
private int calculateVisibleType(){
  if (mUserExpanding) {
    int height=!mIsChildInGroup || isGroupExpanded() || mContainingNotification.isExpanded() ? mContainingNotification.getMaxContentHeight() : mContainingNotification.getShowingLayout().getMinHeight();
    if (height == 0) {
      height=mContentHeight;
    }
    int expandedVisualType=getVisualTypeForHeight(height);
    int collapsedVisualType=getVisualTypeForHeight(mContainingNotification.getMinExpandHeight());
    return mTransformationStartVisibleType == collapsedVisualType ? expandedVisualType : collapsedVisualType;
  }
  int intrinsicHeight=mContainingNotification.getIntrinsicHeight();
  int viewHeight=mContentHeight;
  if (intrinsicHeight != 0) {
    viewHeight=Math.min(mContentHeight,intrinsicHeight);
  }
  return getVisualTypeForHeight(viewHeight);
}",0.8520710059171598
192574,"public void onNotificationUpdated(NotificationData.Entry entry){
  mStatusBarNotification=entry.notification;
  mBeforeN=entry.targetSdk < Build.VERSION_CODES.N;
  updateSingleLineView();
  applyRemoteInput(entry);
  selectLayout(false,true);
  if (mContractedChild != null) {
    mContractedWrapper.notifyContentUpdated(entry.notification);
  }
  if (mExpandedChild != null) {
    mExpandedWrapper.notifyContentUpdated(entry.notification);
  }
  if (mHeadsUpChild != null) {
    mHeadsUpWrapper.notifyContentUpdated(entry.notification);
  }
  setDark(mDark,false,0);
}","public void onNotificationUpdated(NotificationData.Entry entry){
  mStatusBarNotification=entry.notification;
  mBeforeN=entry.targetSdk < Build.VERSION_CODES.N;
  updateSingleLineView();
  applyRemoteInput(entry);
  if (mContractedChild != null) {
    mContractedWrapper.notifyContentUpdated(entry.notification);
  }
  if (mExpandedChild != null) {
    mExpandedWrapper.notifyContentUpdated(entry.notification);
  }
  if (mHeadsUpChild != null) {
    mHeadsUpWrapper.notifyContentUpdated(entry.notification);
  }
  selectLayout(false,true);
  setDark(mDark,false,0);
}",0.9507908611599296
192575,"private void animateToVisibleType(int visibleType){
  final TransformableView shownView=getTransformableViewForVisibleType(visibleType);
  final TransformableView hiddenView=getTransformableViewForVisibleType(mVisibleType);
  shownView.transformFrom(hiddenView);
  getViewForVisibleType(visibleType).setVisibility(View.VISIBLE);
  hiddenView.transformTo(shownView,new Runnable(){
    @Override public void run(){
      hiddenView.setVisible(false);
    }
  }
);
}","private void animateToVisibleType(int visibleType){
  final TransformableView shownView=getTransformableViewForVisibleType(visibleType);
  final TransformableView hiddenView=getTransformableViewForVisibleType(mVisibleType);
  if (shownView == hiddenView) {
    shownView.setVisible(true);
    return;
  }
  shownView.transformFrom(hiddenView);
  getViewForVisibleType(visibleType).setVisibility(View.VISIBLE);
  hiddenView.transformTo(shownView,new Runnable(){
    @Override public void run(){
      if (hiddenView != getTransformableViewForVisibleType(mVisibleType)) {
        hiddenView.setVisible(false);
      }
    }
  }
);
}",0.8417200365965233
192576,"final void performStart(){
  mActivityTransitionState.setEnterActivityOptions(this,getActivityOptions());
  mFragments.noteStateNotSaved();
  mCalled=false;
  mFragments.execPendingActions();
  mInstrumentation.callActivityOnStart(this);
  if (!mCalled) {
    throw new SuperNotCalledException(""String_Node_Str"" + mComponent.toShortString() + ""String_Node_Str"");
  }
  mFragments.dispatchStart();
  mFragments.reportLoaderStart();
  boolean isDlwarningEnabled=SystemProperties.getInt(""String_Node_Str"",0) == 1;
  boolean isAppDebuggable=(mApplication.getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0;
  if (isAppDebuggable || isDlwarningEnabled) {
    String dlwarning=getDlWarning();
    if (dlwarning != null) {
      String appName=getString(mApplication.getApplicationInfo().labelRes);
      String warning=""String_Node_Str"" + ""String_Node_Str"" + dlwarning;
      if (isAppDebuggable) {
        new AlertDialog.Builder(this).setTitle(appName).setMessage(warning).setPositiveButton(android.R.string.ok,null).setCancelable(false).show();
      }
 else {
        Toast.makeText(this,appName + ""String_Node_Str"" + warning,Toast.LENGTH_LONG).show();
      }
    }
  }
  mActivityTransitionState.enterReady(this);
}","final void performStart(){
  mActivityTransitionState.setEnterActivityOptions(this,getActivityOptions());
  mFragments.noteStateNotSaved();
  mCalled=false;
  mFragments.execPendingActions();
  mInstrumentation.callActivityOnStart(this);
  if (!mCalled) {
    throw new SuperNotCalledException(""String_Node_Str"" + mComponent.toShortString() + ""String_Node_Str"");
  }
  mFragments.dispatchStart();
  mFragments.reportLoaderStart();
  boolean isDlwarningEnabled=SystemProperties.getInt(""String_Node_Str"",0) == 1;
  boolean isAppDebuggable=(mApplication.getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0;
  if (isAppDebuggable || isDlwarningEnabled) {
    String dlwarning=getDlWarning();
    if (dlwarning != null) {
      String appName=getApplicationInfo().loadLabel(getPackageManager()).toString();
      String warning=""String_Node_Str"" + ""String_Node_Str"" + dlwarning;
      if (isAppDebuggable) {
        new AlertDialog.Builder(this).setTitle(appName).setMessage(warning).setPositiveButton(android.R.string.ok,null).setCancelable(false).show();
      }
 else {
        Toast.makeText(this,appName + ""String_Node_Str"" + warning,Toast.LENGTH_LONG).show();
      }
    }
  }
  mActivityTransitionState.enterReady(this);
}",0.9753136382031566
192577,"final void performStart(){
  mActivityTransitionState.setEnterActivityOptions(this,getActivityOptions());
  mFragments.noteStateNotSaved();
  mCalled=false;
  mFragments.execPendingActions();
  mInstrumentation.callActivityOnStart(this);
  if (!mCalled) {
    throw new SuperNotCalledException(""String_Node_Str"" + mComponent.toShortString() + ""String_Node_Str"");
  }
  mFragments.dispatchStart();
  mFragments.reportLoaderStart();
  boolean isDlwarningEnabled=SystemProperties.getInt(""String_Node_Str"",0) == 1;
  boolean isAppDebuggable=(mApplication.getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0;
  if (isAppDebuggable || isDlwarningEnabled) {
    String dlwarning=getDlWarning();
    if (dlwarning != null) {
      String appName=getString(mApplication.getApplicationInfo().labelRes);
      String warning=""String_Node_Str"" + ""String_Node_Str"" + dlwarning;
      if (isAppDebuggable) {
        new AlertDialog.Builder(this).setTitle(appName).setMessage(warning).setPositiveButton(android.R.string.ok,null).setCancelable(false).show();
      }
 else {
        Toast.makeText(this,appName + ""String_Node_Str"" + warning,Toast.LENGTH_LONG).show();
      }
    }
  }
  mActivityTransitionState.enterReady(this);
}","final void performStart(){
  mActivityTransitionState.setEnterActivityOptions(this,getActivityOptions());
  mFragments.noteStateNotSaved();
  mCalled=false;
  mFragments.execPendingActions();
  mInstrumentation.callActivityOnStart(this);
  if (!mCalled) {
    throw new SuperNotCalledException(""String_Node_Str"" + mComponent.toShortString() + ""String_Node_Str"");
  }
  mFragments.dispatchStart();
  mFragments.reportLoaderStart();
  boolean isDlwarningEnabled=SystemProperties.getInt(""String_Node_Str"",0) == 1;
  boolean isAppDebuggable=(mApplication.getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0;
  if (isAppDebuggable || isDlwarningEnabled) {
    String dlwarning=getDlWarning();
    if (dlwarning != null) {
      String appName=getApplicationInfo().loadLabel(getPackageManager()).toString();
      String warning=""String_Node_Str"" + ""String_Node_Str"" + dlwarning;
      if (isAppDebuggable) {
        new AlertDialog.Builder(this).setTitle(appName).setMessage(warning).setPositiveButton(android.R.string.ok,null).setCancelable(false).show();
      }
 else {
        Toast.makeText(this,appName + ""String_Node_Str"" + warning,Toast.LENGTH_LONG).show();
      }
    }
  }
  mActivityTransitionState.enterReady(this);
}",0.9753136382031566
192578,"final void performStart(){
  mActivityTransitionState.setEnterActivityOptions(this,getActivityOptions());
  mFragments.noteStateNotSaved();
  mCalled=false;
  mFragments.execPendingActions();
  mInstrumentation.callActivityOnStart(this);
  if (!mCalled) {
    throw new SuperNotCalledException(""String_Node_Str"" + mComponent.toShortString() + ""String_Node_Str"");
  }
  mFragments.dispatchStart();
  mFragments.reportLoaderStart();
  boolean isDlwarningEnabled=SystemProperties.getInt(""String_Node_Str"",0) == 1;
  boolean isAppDebuggable=(mApplication.getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0;
  if (isAppDebuggable || isDlwarningEnabled) {
    String dlwarning=getDlWarning();
    if (dlwarning != null) {
      String appName=getString(mApplication.getApplicationInfo().labelRes);
      String warning=""String_Node_Str"" + ""String_Node_Str"" + dlwarning;
      if (isAppDebuggable) {
        new AlertDialog.Builder(this).setTitle(appName).setMessage(warning).setPositiveButton(android.R.string.ok,null).setCancelable(false).show();
      }
 else {
        Toast.makeText(this,appName + ""String_Node_Str"" + warning,Toast.LENGTH_LONG).show();
      }
    }
  }
  mActivityTransitionState.enterReady(this);
}","final void performStart(){
  mActivityTransitionState.setEnterActivityOptions(this,getActivityOptions());
  mFragments.noteStateNotSaved();
  mCalled=false;
  mFragments.execPendingActions();
  mInstrumentation.callActivityOnStart(this);
  if (!mCalled) {
    throw new SuperNotCalledException(""String_Node_Str"" + mComponent.toShortString() + ""String_Node_Str"");
  }
  mFragments.dispatchStart();
  mFragments.reportLoaderStart();
  boolean isDlwarningEnabled=SystemProperties.getInt(""String_Node_Str"",0) == 1;
  boolean isAppDebuggable=(mApplication.getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0;
  if (isAppDebuggable || isDlwarningEnabled) {
    String dlwarning=getDlWarning();
    if (dlwarning != null) {
      String appName=getApplicationInfo().loadLabel(getPackageManager()).toString();
      String warning=""String_Node_Str"" + ""String_Node_Str"" + dlwarning;
      if (isAppDebuggable) {
        new AlertDialog.Builder(this).setTitle(appName).setMessage(warning).setPositiveButton(android.R.string.ok,null).setCancelable(false).show();
      }
 else {
        Toast.makeText(this,appName + ""String_Node_Str"" + warning,Toast.LENGTH_LONG).show();
      }
    }
  }
  mActivityTransitionState.enterReady(this);
}",0.9753136382031566
192579,"private void migrateOldData(){
  try {
    if (getString(""String_Node_Str"",null,0) == null) {
      final ContentResolver cr=mContext.getContentResolver();
      for (      String validSetting : VALID_SETTINGS) {
        String value=Settings.Secure.getString(cr,validSetting);
        if (value != null) {
          setString(validSetting,value,0);
        }
      }
      setString(""String_Node_Str"",""String_Node_Str"",0);
      Slog.i(TAG,""String_Node_Str"");
    }
    if (getString(""String_Node_Str"",null,0) == null) {
      final UserManager um=(UserManager)mContext.getSystemService(USER_SERVICE);
      final ContentResolver cr=mContext.getContentResolver();
      List<UserInfo> users=um.getUsers();
      for (int user=0; user < users.size(); user++) {
        final int userId=users.get(user).id;
        final String OWNER_INFO=Secure.LOCK_SCREEN_OWNER_INFO;
        String ownerInfo=Settings.Secure.getStringForUser(cr,OWNER_INFO,userId);
        if (ownerInfo != null) {
          setString(OWNER_INFO,ownerInfo,userId);
          Settings.Secure.putStringForUser(cr,ownerInfo,""String_Node_Str"",userId);
        }
        final String OWNER_INFO_ENABLED=Secure.LOCK_SCREEN_OWNER_INFO_ENABLED;
        boolean enabled;
        try {
          int ivalue=Settings.Secure.getIntForUser(cr,OWNER_INFO_ENABLED,userId);
          enabled=ivalue != 0;
          setLong(OWNER_INFO_ENABLED,enabled ? 1 : 0,userId);
        }
 catch (        SettingNotFoundException e) {
          if (!TextUtils.isEmpty(ownerInfo)) {
            setLong(OWNER_INFO_ENABLED,1,userId);
          }
        }
        Settings.Secure.putIntForUser(cr,OWNER_INFO_ENABLED,0,userId);
      }
      setString(""String_Node_Str"",""String_Node_Str"",0);
      Slog.i(TAG,""String_Node_Str"");
    }
    if (getString(""String_Node_Str"",null,0) == null) {
      final UserManager um=(UserManager)mContext.getSystemService(USER_SERVICE);
      List<UserInfo> users=um.getUsers();
      for (int i=0; i < users.size(); i++) {
        int userId=users.get(i).id;
        long type=getLong(LockPatternUtils.PASSWORD_TYPE_KEY,DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED,userId);
        long alternateType=getLong(LockPatternUtils.PASSWORD_TYPE_ALTERNATE_KEY,DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED,userId);
        if (type == DevicePolicyManager.PASSWORD_QUALITY_BIOMETRIC_WEAK) {
          setLong(LockPatternUtils.PASSWORD_TYPE_KEY,alternateType,userId);
        }
        setLong(LockPatternUtils.PASSWORD_TYPE_ALTERNATE_KEY,DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED,userId);
      }
      setString(""String_Node_Str"",""String_Node_Str"",0);
      Slog.i(TAG,""String_Node_Str"");
    }
    if (getString(""String_Node_Str"",null,0) == null) {
      final UserManager um=(UserManager)mContext.getSystemService(USER_SERVICE);
      final List<UserInfo> users=um.getUsers();
      final int userCount=users.size();
      int switchableUsers=0;
      for (int i=0; i < userCount; i++) {
        if (users.get(i).supportsSwitchTo()) {
          switchableUsers++;
        }
      }
      if (switchableUsers > 1) {
        for (int i=0; i < userCount; i++) {
          int id=users.get(i).id;
          if (getBoolean(LockPatternUtils.DISABLE_LOCKSCREEN_KEY,false,id)) {
            setBoolean(LockPatternUtils.DISABLE_LOCKSCREEN_KEY,false,id);
          }
        }
      }
      setString(""String_Node_Str"",""String_Node_Str"",0);
      Slog.i(TAG,""String_Node_Str"");
    }
  }
 catch (  RemoteException re) {
    Slog.e(TAG,""String_Node_Str"",re);
  }
}","private void migrateOldData(){
  try {
    if (getString(""String_Node_Str"",null,0) == null) {
      final ContentResolver cr=mContext.getContentResolver();
      for (      String validSetting : VALID_SETTINGS) {
        String value=Settings.Secure.getString(cr,validSetting);
        if (value != null) {
          setString(validSetting,value,0);
        }
      }
      setString(""String_Node_Str"",""String_Node_Str"",0);
      Slog.i(TAG,""String_Node_Str"");
    }
    if (getString(""String_Node_Str"",null,0) == null) {
      final UserManager um=(UserManager)mContext.getSystemService(USER_SERVICE);
      final ContentResolver cr=mContext.getContentResolver();
      List<UserInfo> users=um.getUsers();
      for (int user=0; user < users.size(); user++) {
        final int userId=users.get(user).id;
        final String OWNER_INFO=Secure.LOCK_SCREEN_OWNER_INFO;
        String ownerInfo=Settings.Secure.getStringForUser(cr,OWNER_INFO,userId);
        if (!TextUtils.isEmpty(ownerInfo)) {
          setString(OWNER_INFO,ownerInfo,userId);
          Settings.Secure.putStringForUser(cr,OWNER_INFO,""String_Node_Str"",userId);
        }
        final String OWNER_INFO_ENABLED=Secure.LOCK_SCREEN_OWNER_INFO_ENABLED;
        boolean enabled;
        try {
          int ivalue=Settings.Secure.getIntForUser(cr,OWNER_INFO_ENABLED,userId);
          enabled=ivalue != 0;
          setLong(OWNER_INFO_ENABLED,enabled ? 1 : 0,userId);
        }
 catch (        SettingNotFoundException e) {
          if (!TextUtils.isEmpty(ownerInfo)) {
            setLong(OWNER_INFO_ENABLED,1,userId);
          }
        }
        Settings.Secure.putIntForUser(cr,OWNER_INFO_ENABLED,0,userId);
      }
      setString(""String_Node_Str"",""String_Node_Str"",0);
      Slog.i(TAG,""String_Node_Str"");
    }
    if (getString(""String_Node_Str"",null,0) == null) {
      final UserManager um=(UserManager)mContext.getSystemService(USER_SERVICE);
      List<UserInfo> users=um.getUsers();
      for (int i=0; i < users.size(); i++) {
        int userId=users.get(i).id;
        long type=getLong(LockPatternUtils.PASSWORD_TYPE_KEY,DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED,userId);
        long alternateType=getLong(LockPatternUtils.PASSWORD_TYPE_ALTERNATE_KEY,DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED,userId);
        if (type == DevicePolicyManager.PASSWORD_QUALITY_BIOMETRIC_WEAK) {
          setLong(LockPatternUtils.PASSWORD_TYPE_KEY,alternateType,userId);
        }
        setLong(LockPatternUtils.PASSWORD_TYPE_ALTERNATE_KEY,DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED,userId);
      }
      setString(""String_Node_Str"",""String_Node_Str"",0);
      Slog.i(TAG,""String_Node_Str"");
    }
    if (getString(""String_Node_Str"",null,0) == null) {
      final UserManager um=(UserManager)mContext.getSystemService(USER_SERVICE);
      final List<UserInfo> users=um.getUsers();
      final int userCount=users.size();
      int switchableUsers=0;
      for (int i=0; i < userCount; i++) {
        if (users.get(i).supportsSwitchTo()) {
          switchableUsers++;
        }
      }
      if (switchableUsers > 1) {
        for (int i=0; i < userCount; i++) {
          int id=users.get(i).id;
          if (getBoolean(LockPatternUtils.DISABLE_LOCKSCREEN_KEY,false,id)) {
            setBoolean(LockPatternUtils.DISABLE_LOCKSCREEN_KEY,false,id);
          }
        }
      }
      setString(""String_Node_Str"",""String_Node_Str"",0);
      Slog.i(TAG,""String_Node_Str"");
    }
  }
 catch (  RemoteException re) {
    Slog.e(TAG,""String_Node_Str"",re);
  }
}",0.9933643936185232
192580,"@Override public void initFrom(View view){
  super.initFrom(view);
  if (view instanceof TextView) {
    TextView txt=(TextView)view;
    mText=txt.getText();
  }
}","@Override public void initFrom(View view){
  super.initFrom(view);
  if (view instanceof TextView) {
    mText=(TextView)view;
  }
}",0.8851351351351351
192581,"@Override protected boolean sameAs(TransformState otherState){
  if (otherState instanceof TextViewTransformState) {
    TextViewTransformState otherTvs=(TextViewTransformState)otherState;
    return TextUtils.equals(otherTvs.mText,mText);
  }
  return super.sameAs(otherState);
}","@Override protected boolean sameAs(TransformState otherState){
  if (otherState instanceof TextViewTransformState) {
    TextViewTransformState otherTvs=(TextViewTransformState)otherState;
    if (TextUtils.equals(otherTvs.mText.getText(),mText.getText())) {
      int ownEllipsized=getEllipsisCount();
      int otherEllipsized=otherTvs.getEllipsisCount();
      return ownEllipsized == otherEllipsized;
    }
  }
  return super.sameAs(otherState);
}",0.746922024623803
192582,"private void migrateOldData(){
  try {
    if (getString(""String_Node_Str"",null,0) == null) {
      final ContentResolver cr=mContext.getContentResolver();
      for (      String validSetting : VALID_SETTINGS) {
        String value=Settings.Secure.getString(cr,validSetting);
        if (value != null) {
          setString(validSetting,value,0);
        }
      }
      setString(""String_Node_Str"",""String_Node_Str"",0);
      Slog.i(TAG,""String_Node_Str"");
    }
    if (getString(""String_Node_Str"",null,0) == null) {
      final UserManager um=(UserManager)mContext.getSystemService(USER_SERVICE);
      final ContentResolver cr=mContext.getContentResolver();
      List<UserInfo> users=um.getUsers();
      for (int user=0; user < users.size(); user++) {
        final int userId=users.get(user).id;
        final String OWNER_INFO=Secure.LOCK_SCREEN_OWNER_INFO;
        String ownerInfo=Settings.Secure.getStringForUser(cr,OWNER_INFO,userId);
        if (ownerInfo != null) {
          setString(OWNER_INFO,ownerInfo,userId);
          Settings.Secure.putStringForUser(cr,ownerInfo,""String_Node_Str"",userId);
        }
        final String OWNER_INFO_ENABLED=Secure.LOCK_SCREEN_OWNER_INFO_ENABLED;
        boolean enabled;
        try {
          int ivalue=Settings.Secure.getIntForUser(cr,OWNER_INFO_ENABLED,userId);
          enabled=ivalue != 0;
          setLong(OWNER_INFO_ENABLED,enabled ? 1 : 0,userId);
        }
 catch (        SettingNotFoundException e) {
          if (!TextUtils.isEmpty(ownerInfo)) {
            setLong(OWNER_INFO_ENABLED,1,userId);
          }
        }
        Settings.Secure.putIntForUser(cr,OWNER_INFO_ENABLED,0,userId);
      }
      setString(""String_Node_Str"",""String_Node_Str"",0);
      Slog.i(TAG,""String_Node_Str"");
    }
    if (getString(""String_Node_Str"",null,0) == null) {
      final UserManager um=(UserManager)mContext.getSystemService(USER_SERVICE);
      List<UserInfo> users=um.getUsers();
      for (int i=0; i < users.size(); i++) {
        int userId=users.get(i).id;
        long type=getLong(LockPatternUtils.PASSWORD_TYPE_KEY,DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED,userId);
        long alternateType=getLong(LockPatternUtils.PASSWORD_TYPE_ALTERNATE_KEY,DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED,userId);
        if (type == DevicePolicyManager.PASSWORD_QUALITY_BIOMETRIC_WEAK) {
          setLong(LockPatternUtils.PASSWORD_TYPE_KEY,alternateType,userId);
        }
        setLong(LockPatternUtils.PASSWORD_TYPE_ALTERNATE_KEY,DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED,userId);
      }
      setString(""String_Node_Str"",""String_Node_Str"",0);
      Slog.i(TAG,""String_Node_Str"");
    }
    if (getString(""String_Node_Str"",null,0) == null) {
      final UserManager um=(UserManager)mContext.getSystemService(USER_SERVICE);
      final List<UserInfo> users=um.getUsers();
      final int userCount=users.size();
      int switchableUsers=0;
      for (int i=0; i < userCount; i++) {
        if (users.get(i).supportsSwitchTo()) {
          switchableUsers++;
        }
      }
      if (switchableUsers > 1) {
        for (int i=0; i < userCount; i++) {
          int id=users.get(i).id;
          if (getBoolean(LockPatternUtils.DISABLE_LOCKSCREEN_KEY,false,id)) {
            setBoolean(LockPatternUtils.DISABLE_LOCKSCREEN_KEY,false,id);
          }
        }
      }
      setString(""String_Node_Str"",""String_Node_Str"",0);
      Slog.i(TAG,""String_Node_Str"");
    }
  }
 catch (  RemoteException re) {
    Slog.e(TAG,""String_Node_Str"",re);
  }
}","private void migrateOldData(){
  try {
    if (getString(""String_Node_Str"",null,0) == null) {
      final ContentResolver cr=mContext.getContentResolver();
      for (      String validSetting : VALID_SETTINGS) {
        String value=Settings.Secure.getString(cr,validSetting);
        if (value != null) {
          setString(validSetting,value,0);
        }
      }
      setString(""String_Node_Str"",""String_Node_Str"",0);
      Slog.i(TAG,""String_Node_Str"");
    }
    if (getString(""String_Node_Str"",null,0) == null) {
      final UserManager um=(UserManager)mContext.getSystemService(USER_SERVICE);
      final ContentResolver cr=mContext.getContentResolver();
      List<UserInfo> users=um.getUsers();
      for (int user=0; user < users.size(); user++) {
        final int userId=users.get(user).id;
        final String OWNER_INFO=Secure.LOCK_SCREEN_OWNER_INFO;
        String ownerInfo=Settings.Secure.getStringForUser(cr,OWNER_INFO,userId);
        if (!TextUtils.isEmpty(ownerInfo)) {
          setString(OWNER_INFO,ownerInfo,userId);
          Settings.Secure.putStringForUser(cr,OWNER_INFO,""String_Node_Str"",userId);
        }
        final String OWNER_INFO_ENABLED=Secure.LOCK_SCREEN_OWNER_INFO_ENABLED;
        boolean enabled;
        try {
          int ivalue=Settings.Secure.getIntForUser(cr,OWNER_INFO_ENABLED,userId);
          enabled=ivalue != 0;
          setLong(OWNER_INFO_ENABLED,enabled ? 1 : 0,userId);
        }
 catch (        SettingNotFoundException e) {
          if (!TextUtils.isEmpty(ownerInfo)) {
            setLong(OWNER_INFO_ENABLED,1,userId);
          }
        }
        Settings.Secure.putIntForUser(cr,OWNER_INFO_ENABLED,0,userId);
      }
      setString(""String_Node_Str"",""String_Node_Str"",0);
      Slog.i(TAG,""String_Node_Str"");
    }
    if (getString(""String_Node_Str"",null,0) == null) {
      final UserManager um=(UserManager)mContext.getSystemService(USER_SERVICE);
      List<UserInfo> users=um.getUsers();
      for (int i=0; i < users.size(); i++) {
        int userId=users.get(i).id;
        long type=getLong(LockPatternUtils.PASSWORD_TYPE_KEY,DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED,userId);
        long alternateType=getLong(LockPatternUtils.PASSWORD_TYPE_ALTERNATE_KEY,DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED,userId);
        if (type == DevicePolicyManager.PASSWORD_QUALITY_BIOMETRIC_WEAK) {
          setLong(LockPatternUtils.PASSWORD_TYPE_KEY,alternateType,userId);
        }
        setLong(LockPatternUtils.PASSWORD_TYPE_ALTERNATE_KEY,DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED,userId);
      }
      setString(""String_Node_Str"",""String_Node_Str"",0);
      Slog.i(TAG,""String_Node_Str"");
    }
    if (getString(""String_Node_Str"",null,0) == null) {
      final UserManager um=(UserManager)mContext.getSystemService(USER_SERVICE);
      final List<UserInfo> users=um.getUsers();
      final int userCount=users.size();
      int switchableUsers=0;
      for (int i=0; i < userCount; i++) {
        if (users.get(i).supportsSwitchTo()) {
          switchableUsers++;
        }
      }
      if (switchableUsers > 1) {
        for (int i=0; i < userCount; i++) {
          int id=users.get(i).id;
          if (getBoolean(LockPatternUtils.DISABLE_LOCKSCREEN_KEY,false,id)) {
            setBoolean(LockPatternUtils.DISABLE_LOCKSCREEN_KEY,false,id);
          }
        }
      }
      setString(""String_Node_Str"",""String_Node_Str"",0);
      Slog.i(TAG,""String_Node_Str"");
    }
  }
 catch (  RemoteException re) {
    Slog.e(TAG,""String_Node_Str"",re);
  }
}",0.9933643936185232
192583,"/** 
 * Add a child notification to this view.
 * @param row the row to add
 * @param childIndex the index to add it at, if -1 it will be added at the end
 */
public void addNotification(ExpandableNotificationRow row,int childIndex){
  int newIndex=childIndex < 0 ? mChildren.size() : childIndex;
  mChildren.add(newIndex,row);
  addView(row);
  View divider=inflateDivider();
  addView(divider);
  mDividers.add(newIndex,divider);
  updateGroupOverflow();
}","/** 
 * Add a child notification to this view.
 * @param row the row to add
 * @param childIndex the index to add it at, if -1 it will be added at the end
 */
public void addNotification(ExpandableNotificationRow row,int childIndex){
  int newIndex=childIndex < 0 ? mChildren.size() : childIndex;
  mChildren.add(newIndex,row);
  addView(row);
  row.setUserLocked(mUserLocked);
  View divider=inflateDivider();
  addView(divider);
  mDividers.add(newIndex,divider);
  updateGroupOverflow();
}",0.9642105263157896
192584,"public void removeNotification(ExpandableNotificationRow row){
  int childIndex=mChildren.indexOf(row);
  mChildren.remove(row);
  removeView(row);
  final View divider=mDividers.remove(childIndex);
  removeView(divider);
  getOverlay().add(divider);
  CrossFadeHelper.fadeOut(divider,new Runnable(){
    @Override public void run(){
      getOverlay().remove(divider);
    }
  }
);
  row.setSystemChildExpanded(false);
  updateGroupOverflow();
}","public void removeNotification(ExpandableNotificationRow row){
  int childIndex=mChildren.indexOf(row);
  mChildren.remove(row);
  removeView(row);
  final View divider=mDividers.remove(childIndex);
  removeView(divider);
  getOverlay().add(divider);
  CrossFadeHelper.fadeOut(divider,new Runnable(){
    @Override public void run(){
      getOverlay().remove(divider);
    }
  }
);
  row.setSystemChildExpanded(false);
  row.setUserLocked(false);
  updateGroupOverflow();
}",0.9695652173913044
192585,"private void handleExpansion(float heightDelta,ExpandableView child){
  if (heightDelta < 0) {
    heightDelta=0;
  }
  boolean expandable=child.isContentExpandable();
  float rubberbandFactor=expandable ? RUBBERBAND_FACTOR_EXPANDABLE : RUBBERBAND_FACTOR_STATIC;
  float rubberband=heightDelta * rubberbandFactor;
  if (expandable && (rubberband + child.getMinHeight()) > child.getMaxContentHeight()) {
    float overshoot=(rubberband + child.getMinHeight()) - child.getMaxContentHeight();
    overshoot*=(1 - RUBBERBAND_FACTOR_STATIC);
    rubberband-=overshoot;
  }
  child.setActualHeight((int)(child.getMinHeight() + rubberband));
}","private void handleExpansion(float heightDelta,ExpandableView child){
  if (heightDelta < 0) {
    heightDelta=0;
  }
  boolean expandable=child.isContentExpandable();
  float rubberbandFactor=expandable ? RUBBERBAND_FACTOR_EXPANDABLE : RUBBERBAND_FACTOR_STATIC;
  float rubberband=heightDelta * rubberbandFactor;
  if (expandable && (rubberband + child.getMinExpandHeight()) > child.getMaxContentHeight()) {
    float overshoot=(rubberband + child.getMinExpandHeight()) - child.getMaxContentHeight();
    overshoot*=(1 - RUBBERBAND_FACTOR_STATIC);
    rubberband-=overshoot;
  }
  child.setActualHeight((int)(child.getMinExpandHeight() + rubberband));
}",0.986046511627907
192586,"@Override public int getMinExpandHeight(){
  if (mIsSummaryWithChildren && !mOnKeyguard) {
    return mChildrenContainer.getMinExpandHeight();
  }
  return getMinHeight();
}","@Override public int getMinExpandHeight(){
  if (mIsSummaryWithChildren && !mShowingPublic) {
    return mChildrenContainer.getMinExpandHeight(mOnKeyguard);
  }
  return getMinHeight();
}",0.9222222222222224
192587,"public int getMinExpandHeight(){
  return getIntrinsicHeight(getMaxAllowedVisibleChildren(true));
}","public int getMinExpandHeight(boolean onKeyguard){
  int maxAllowedVisibleChildren=onKeyguard ? NUMBER_OF_CHILDREN_WHEN_COLLAPSED : getMaxAllowedVisibleChildren(true);
  int minExpandHeight=mNotificationHeaderHeight;
  int visibleChildren=0;
  boolean firstChild=true;
  int childCount=mChildren.size();
  for (int i=0; i < childCount; i++) {
    if (visibleChildren >= maxAllowedVisibleChildren) {
      break;
    }
    if (!firstChild) {
      minExpandHeight+=mChildPadding;
    }
 else {
      firstChild=false;
    }
    ExpandableNotificationRow child=mChildren.get(i);
    minExpandHeight+=child.getMinHeight();
    visibleChildren++;
  }
  minExpandHeight+=mCollapsedBottompadding;
  return minExpandHeight;
}",0.1101591187270501
192588,"private void onAdvancedPrintOptionsActivityResult(int resultCode,Intent data){
  if (resultCode != RESULT_OK || data == null) {
    return;
  }
  PrintJobInfo printJobInfo=data.getParcelableExtra(PrintService.EXTRA_PRINT_JOB_INFO);
  if (printJobInfo == null) {
    return;
  }
  mPrintJob.setAdvancedOptions(printJobInfo.getAdvancedOptions());
  mCopiesEditText.setText(String.valueOf(printJobInfo.getCopies()));
  mPrintJob.setCopies(printJobInfo.getCopies());
  PrintAttributes currAttributes=mPrintJob.getAttributes();
  PrintAttributes newAttributes=printJobInfo.getAttributes();
  if (newAttributes != null) {
    MediaSize oldMediaSize=currAttributes.getMediaSize();
    MediaSize newMediaSize=newAttributes.getMediaSize();
    if (!oldMediaSize.equals(newMediaSize)) {
      final int mediaSizeCount=mMediaSizeSpinnerAdapter.getCount();
      MediaSize newMediaSizePortrait=newAttributes.getMediaSize().asPortrait();
      for (int i=0; i < mediaSizeCount; i++) {
        MediaSize supportedSizePortrait=mMediaSizeSpinnerAdapter.getItem(i).value.asPortrait();
        if (supportedSizePortrait.equals(newMediaSizePortrait)) {
          currAttributes.setMediaSize(newMediaSize);
          mMediaSizeSpinner.setSelection(i);
          if (currAttributes.getMediaSize().isPortrait()) {
            if (mOrientationSpinner.getSelectedItemPosition() != 0) {
              mOrientationSpinner.setSelection(0);
            }
          }
 else {
            if (mOrientationSpinner.getSelectedItemPosition() != 1) {
              mOrientationSpinner.setSelection(1);
            }
          }
          break;
        }
      }
    }
    Resolution oldResolution=currAttributes.getResolution();
    Resolution newResolution=newAttributes.getResolution();
    if (!oldResolution.equals(newResolution)) {
      PrinterCapabilitiesInfo capabilities=mCurrentPrinter.getCapabilities();
      if (capabilities != null) {
        List<Resolution> resolutions=capabilities.getResolutions();
        final int resolutionCount=resolutions.size();
        for (int i=0; i < resolutionCount; i++) {
          Resolution resolution=resolutions.get(i);
          if (resolution.equals(newResolution)) {
            currAttributes.setResolution(resolution);
            break;
          }
        }
      }
    }
    final int currColorMode=currAttributes.getColorMode();
    final int newColorMode=newAttributes.getColorMode();
    if (currColorMode != newColorMode) {
      final int colorModeCount=mColorModeSpinner.getCount();
      for (int i=0; i < colorModeCount; i++) {
        final int supportedColorMode=mColorModeSpinnerAdapter.getItem(i).value;
        if (supportedColorMode == newColorMode) {
          currAttributes.setColorMode(newColorMode);
          mColorModeSpinner.setSelection(i);
          break;
        }
      }
    }
    final int currDuplexMode=currAttributes.getDuplexMode();
    final int newDuplexMode=newAttributes.getDuplexMode();
    if (currDuplexMode != newDuplexMode) {
      final int duplexModeCount=mDuplexModeSpinner.getCount();
      for (int i=0; i < duplexModeCount; i++) {
        final int supportedDuplexMode=mDuplexModeSpinnerAdapter.getItem(i).value;
        if (supportedDuplexMode == newDuplexMode) {
          currAttributes.setDuplexMode(newDuplexMode);
          mDuplexModeSpinner.setSelection(i);
          break;
        }
      }
    }
  }
  PrintDocumentInfo info=mPrintedDocument.getDocumentInfo().info;
  final int pageCount=(info != null) ? getAdjustedPageCount(info) : 0;
  PageRange[] pageRanges=printJobInfo.getPages();
  if (pageRanges != null && pageCount > 0) {
    pageRanges=PageRangeUtils.normalize(pageRanges);
    List<PageRange> validatedList=new ArrayList<>();
    final int rangeCount=pageRanges.length;
    for (int i=0; i < rangeCount; i++) {
      PageRange pageRange=pageRanges[i];
      if (pageRange.getEnd() >= pageCount) {
        final int rangeStart=pageRange.getStart();
        final int rangeEnd=pageCount - 1;
        if (rangeStart <= rangeEnd) {
          pageRange=new PageRange(rangeStart,rangeEnd);
          validatedList.add(pageRange);
        }
        break;
      }
      validatedList.add(pageRange);
    }
    if (!validatedList.isEmpty()) {
      PageRange[] validatedArray=new PageRange[validatedList.size()];
      validatedList.toArray(validatedArray);
      updateSelectedPages(validatedArray,pageCount);
    }
  }
  if (canUpdateDocument()) {
    updateDocument(false);
  }
}","private void onAdvancedPrintOptionsActivityResult(int resultCode,Intent data){
  if (resultCode != RESULT_OK || data == null) {
    return;
  }
  PrintJobInfo printJobInfo=data.getParcelableExtra(PrintService.EXTRA_PRINT_JOB_INFO);
  if (printJobInfo == null) {
    return;
  }
  mPrintJob.setAdvancedOptions(printJobInfo.getAdvancedOptions());
  if (printJobInfo.getCopies() < 1) {
    Log.w(LOG_TAG,""String_Node_Str"" + ""String_Node_Str"" + printJobInfo.getCopies() + ""String_Node_Str""+ ""String_Node_Str"");
  }
 else {
    mCopiesEditText.setText(String.valueOf(printJobInfo.getCopies()));
    mPrintJob.setCopies(printJobInfo.getCopies());
  }
  PrintAttributes currAttributes=mPrintJob.getAttributes();
  PrintAttributes newAttributes=printJobInfo.getAttributes();
  if (newAttributes != null) {
    MediaSize oldMediaSize=currAttributes.getMediaSize();
    MediaSize newMediaSize=newAttributes.getMediaSize();
    if (newMediaSize != null && !oldMediaSize.equals(newMediaSize)) {
      final int mediaSizeCount=mMediaSizeSpinnerAdapter.getCount();
      MediaSize newMediaSizePortrait=newAttributes.getMediaSize().asPortrait();
      for (int i=0; i < mediaSizeCount; i++) {
        MediaSize supportedSizePortrait=mMediaSizeSpinnerAdapter.getItem(i).value.asPortrait();
        if (supportedSizePortrait.equals(newMediaSizePortrait)) {
          currAttributes.setMediaSize(newMediaSize);
          mMediaSizeSpinner.setSelection(i);
          if (currAttributes.getMediaSize().isPortrait()) {
            if (mOrientationSpinner.getSelectedItemPosition() != 0) {
              mOrientationSpinner.setSelection(0);
            }
          }
 else {
            if (mOrientationSpinner.getSelectedItemPosition() != 1) {
              mOrientationSpinner.setSelection(1);
            }
          }
          break;
        }
      }
    }
    Resolution oldResolution=currAttributes.getResolution();
    Resolution newResolution=newAttributes.getResolution();
    if (!oldResolution.equals(newResolution)) {
      PrinterCapabilitiesInfo capabilities=mCurrentPrinter.getCapabilities();
      if (capabilities != null) {
        List<Resolution> resolutions=capabilities.getResolutions();
        final int resolutionCount=resolutions.size();
        for (int i=0; i < resolutionCount; i++) {
          Resolution resolution=resolutions.get(i);
          if (resolution.equals(newResolution)) {
            currAttributes.setResolution(resolution);
            break;
          }
        }
      }
    }
    final int currColorMode=currAttributes.getColorMode();
    final int newColorMode=newAttributes.getColorMode();
    if (currColorMode != newColorMode) {
      final int colorModeCount=mColorModeSpinner.getCount();
      for (int i=0; i < colorModeCount; i++) {
        final int supportedColorMode=mColorModeSpinnerAdapter.getItem(i).value;
        if (supportedColorMode == newColorMode) {
          currAttributes.setColorMode(newColorMode);
          mColorModeSpinner.setSelection(i);
          break;
        }
      }
    }
    final int currDuplexMode=currAttributes.getDuplexMode();
    final int newDuplexMode=newAttributes.getDuplexMode();
    if (currDuplexMode != newDuplexMode) {
      final int duplexModeCount=mDuplexModeSpinner.getCount();
      for (int i=0; i < duplexModeCount; i++) {
        final int supportedDuplexMode=mDuplexModeSpinnerAdapter.getItem(i).value;
        if (supportedDuplexMode == newDuplexMode) {
          currAttributes.setDuplexMode(newDuplexMode);
          mDuplexModeSpinner.setSelection(i);
          break;
        }
      }
    }
  }
  PrintDocumentInfo info=mPrintedDocument.getDocumentInfo().info;
  final int pageCount=(info != null) ? getAdjustedPageCount(info) : 0;
  PageRange[] pageRanges=printJobInfo.getPages();
  if (pageRanges != null && pageCount > 0) {
    pageRanges=PageRangeUtils.normalize(pageRanges);
    List<PageRange> validatedList=new ArrayList<>();
    final int rangeCount=pageRanges.length;
    for (int i=0; i < rangeCount; i++) {
      PageRange pageRange=pageRanges[i];
      if (pageRange.getEnd() >= pageCount) {
        final int rangeStart=pageRange.getStart();
        final int rangeEnd=pageCount - 1;
        if (rangeStart <= rangeEnd) {
          pageRange=new PageRange(rangeStart,rangeEnd);
          validatedList.add(pageRange);
        }
        break;
      }
      validatedList.add(pageRange);
    }
    if (!validatedList.isEmpty()) {
      PageRange[] validatedArray=new PageRange[validatedList.size()];
      validatedList.toArray(validatedArray);
      updateSelectedPages(validatedArray,pageCount);
    }
  }
  if (canUpdateDocument()) {
    updateDocument(false);
  }
}",0.9774912587412588
192589,"private void startAdvancedPrintOptionsActivity(PrinterInfo printer){
  ComponentName serviceName=printer.getId().getServiceName();
  String activityName=PrintOptionUtils.getAdvancedOptionsActivityName(this,serviceName);
  if (TextUtils.isEmpty(activityName)) {
    return;
  }
  Intent intent=new Intent(Intent.ACTION_MAIN);
  intent.setComponent(new ComponentName(serviceName.getPackageName(),activityName));
  List<ResolveInfo> resolvedActivities=getPackageManager().queryIntentActivities(intent,0);
  if (resolvedActivities.isEmpty()) {
    return;
  }
  if (resolvedActivities.get(0).activityInfo.exported) {
    intent.putExtra(PrintService.EXTRA_PRINT_JOB_INFO,mPrintJob);
    intent.putExtra(PrintService.EXTRA_PRINTER_INFO,printer);
    intent.putExtra(PrintService.EXTRA_PRINT_DOCUMENT_INFO,mPrintedDocument.getDocumentInfo().info);
    try {
      startActivityForResult(intent,ACTIVITY_REQUEST_POPULATE_ADVANCED_PRINT_OPTIONS);
    }
 catch (    ActivityNotFoundException anfe) {
      Log.e(LOG_TAG,""String_Node_Str"" + intent,anfe);
    }
  }
}","private void startAdvancedPrintOptionsActivity(PrinterInfo printer){
  ComponentName serviceName=printer.getId().getServiceName();
  String activityName=PrintOptionUtils.getAdvancedOptionsActivityName(this,serviceName);
  if (TextUtils.isEmpty(activityName)) {
    return;
  }
  Intent intent=new Intent(Intent.ACTION_MAIN);
  intent.setComponent(new ComponentName(serviceName.getPackageName(),activityName));
  List<ResolveInfo> resolvedActivities=getPackageManager().queryIntentActivities(intent,0);
  if (resolvedActivities.isEmpty()) {
    return;
  }
  if (resolvedActivities.get(0).activityInfo.exported) {
    PrintJobInfo.Builder printJobBuilder=new PrintJobInfo.Builder(mPrintJob);
    printJobBuilder.setPages(mSelectedPages);
    intent.putExtra(PrintService.EXTRA_PRINT_JOB_INFO,printJobBuilder.build());
    intent.putExtra(PrintService.EXTRA_PRINTER_INFO,printer);
    intent.putExtra(PrintService.EXTRA_PRINT_DOCUMENT_INFO,mPrintedDocument.getDocumentInfo().info);
    try {
      startActivityForResult(intent,ACTIVITY_REQUEST_POPULATE_ADVANCED_PRINT_OPTIONS);
    }
 catch (    ActivityNotFoundException anfe) {
      Log.e(LOG_TAG,""String_Node_Str"" + intent,anfe);
    }
  }
}",0.9368888888888888
192590,"void run() throws RemoteException {
  try {
    printMessageForState();
    mAm.setActivityController(this);
    mState=STATE_NORMAL;
    InputStreamReader converter=new InputStreamReader(System.in);
    BufferedReader in=new BufferedReader(converter);
    String line;
    while ((line=in.readLine()) != null) {
      boolean addNewline=true;
      if (line.length() <= 0) {
        addNewline=false;
      }
 else       if (""String_Node_Str"".equals(line) || ""String_Node_Str"".equals(line)) {
        resumeController(RESULT_DEFAULT);
        break;
      }
 else       if (mState == STATE_CRASHED) {
        if (""String_Node_Str"".equals(line) || ""String_Node_Str"".equals(line)) {
          resumeController(RESULT_CRASH_DIALOG);
        }
 else         if (""String_Node_Str"".equals(line) || ""String_Node_Str"".equals(line)) {
          resumeController(RESULT_CRASH_KILL);
        }
 else {
          System.out.println(""String_Node_Str"" + line);
        }
      }
 else       if (mState == STATE_ANR) {
        if (""String_Node_Str"".equals(line) || ""String_Node_Str"".equals(line)) {
          resumeController(RESULT_ANR_DIALOG);
        }
 else         if (""String_Node_Str"".equals(line) || ""String_Node_Str"".equals(line)) {
          resumeController(RESULT_ANR_KILL);
        }
 else         if (""String_Node_Str"".equals(line) || ""String_Node_Str"".equals(line)) {
          resumeController(RESULT_ANR_WAIT);
        }
 else {
          System.out.println(""String_Node_Str"" + line);
        }
      }
 else       if (mState == STATE_EARLY_ANR) {
        if (""String_Node_Str"".equals(line) || ""String_Node_Str"".equals(line)) {
          resumeController(RESULT_EARLY_ANR_CONTINUE);
        }
 else         if (""String_Node_Str"".equals(line) || ""String_Node_Str"".equals(line)) {
          resumeController(RESULT_EARLY_ANR_KILL);
        }
 else {
          System.out.println(""String_Node_Str"" + line);
        }
      }
 else {
        System.out.println(""String_Node_Str"" + line);
      }
synchronized (this) {
        if (addNewline) {
          System.out.println(""String_Node_Str"");
        }
        printMessageForState();
      }
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
 finally {
    mAm.setActivityController(null);
  }
}","void run() throws RemoteException {
  try {
    printMessageForState();
    mAm.setActivityController(this,mMonkey);
    mState=STATE_NORMAL;
    InputStreamReader converter=new InputStreamReader(System.in);
    BufferedReader in=new BufferedReader(converter);
    String line;
    while ((line=in.readLine()) != null) {
      boolean addNewline=true;
      if (line.length() <= 0) {
        addNewline=false;
      }
 else       if (""String_Node_Str"".equals(line) || ""String_Node_Str"".equals(line)) {
        resumeController(RESULT_DEFAULT);
        break;
      }
 else       if (mState == STATE_CRASHED) {
        if (""String_Node_Str"".equals(line) || ""String_Node_Str"".equals(line)) {
          resumeController(RESULT_CRASH_DIALOG);
        }
 else         if (""String_Node_Str"".equals(line) || ""String_Node_Str"".equals(line)) {
          resumeController(RESULT_CRASH_KILL);
        }
 else {
          System.out.println(""String_Node_Str"" + line);
        }
      }
 else       if (mState == STATE_ANR) {
        if (""String_Node_Str"".equals(line) || ""String_Node_Str"".equals(line)) {
          resumeController(RESULT_ANR_DIALOG);
        }
 else         if (""String_Node_Str"".equals(line) || ""String_Node_Str"".equals(line)) {
          resumeController(RESULT_ANR_KILL);
        }
 else         if (""String_Node_Str"".equals(line) || ""String_Node_Str"".equals(line)) {
          resumeController(RESULT_ANR_WAIT);
        }
 else {
          System.out.println(""String_Node_Str"" + line);
        }
      }
 else       if (mState == STATE_EARLY_ANR) {
        if (""String_Node_Str"".equals(line) || ""String_Node_Str"".equals(line)) {
          resumeController(RESULT_EARLY_ANR_CONTINUE);
        }
 else         if (""String_Node_Str"".equals(line) || ""String_Node_Str"".equals(line)) {
          resumeController(RESULT_EARLY_ANR_KILL);
        }
 else {
          System.out.println(""String_Node_Str"" + line);
        }
      }
 else {
        System.out.println(""String_Node_Str"" + line);
      }
synchronized (this) {
        if (addNewline) {
          System.out.println(""String_Node_Str"");
        }
        printMessageForState();
      }
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
 finally {
    mAm.setActivityController(null,mMonkey);
  }
}",0.996474217717056
192591,"MyActivityController(String gdbPort){
  mGdbPort=gdbPort;
}","MyActivityController(String gdbPort,boolean monkey){
  mGdbPort=gdbPort;
  mMonkey=monkey;
}",0.7814569536423841
192592,"private void runMonitor() throws Exception {
  String opt;
  String gdbPort=null;
  while ((opt=nextOption()) != null) {
    if (opt.equals(""String_Node_Str"")) {
      gdbPort=nextArgRequired();
    }
 else {
      System.err.println(""String_Node_Str"" + opt);
      return;
    }
  }
  MyActivityController controller=new MyActivityController(gdbPort);
  controller.run();
}","private void runMonitor() throws Exception {
  String opt;
  String gdbPort=null;
  boolean monkey=false;
  while ((opt=nextOption()) != null) {
    if (opt.equals(""String_Node_Str"")) {
      gdbPort=nextArgRequired();
    }
 else     if (opt.equals(""String_Node_Str"")) {
      monkey=true;
    }
 else {
      System.err.println(""String_Node_Str"" + opt);
      return;
    }
  }
  MyActivityController controller=new MyActivityController(gdbPort,monkey);
  controller.run();
}",0.8789659224441834
192593,"/** 
 * Enable or disable monkey test mode. Setting test as ""monkey"" indicates to some applications that a test framework is running as a ""monkey"" type. Such applications may choose not to perform actions that do submits so to avoid allowing monkey tests from doing harm or performing annoying actions such as dialing 911 or posting messages to public forums, etc.
 * @param isSet True to set as monkey test. False to set as regular functional test (default).
 * @see {@link ActivityManager#isUserAMonkey()}
 */
public void setRunAsMonkey(boolean isSet){
  IActivityManager am=ActivityManagerNative.getDefault();
  if (am == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  try {
    if (isSet) {
      am.setActivityController(new DummyActivityController());
    }
 else {
      am.setActivityController(null);
    }
  }
 catch (  RemoteException e) {
    throw new RuntimeException(e);
  }
}","/** 
 * Enable or disable monkey test mode. Setting test as ""monkey"" indicates to some applications that a test framework is running as a ""monkey"" type. Such applications may choose not to perform actions that do submits so to avoid allowing monkey tests from doing harm or performing annoying actions such as dialing 911 or posting messages to public forums, etc.
 * @param isSet True to set as monkey test. False to set as regular functional test (default).
 * @see {@link ActivityManager#isUserAMonkey()}
 */
public void setRunAsMonkey(boolean isSet){
  IActivityManager am=ActivityManagerNative.getDefault();
  if (am == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  try {
    if (isSet) {
      am.setActivityController(new DummyActivityController(),true);
    }
 else {
      am.setActivityController(null,true);
    }
  }
 catch (  RemoteException e) {
    throw new RuntimeException(e);
  }
}",0.9945295404814004
192594,"@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case START_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IActivityManager.descriptor);
      IBinder b=data.readStrongBinder();
      IApplicationThread app=ApplicationThreadNative.asInterface(b);
      String callingPackage=data.readString();
      Intent intent=Intent.CREATOR.createFromParcel(data);
      String resolvedType=data.readString();
      IBinder resultTo=data.readStrongBinder();
      String resultWho=data.readString();
      int requestCode=data.readInt();
      int startFlags=data.readInt();
      ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
      Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
      int result=startActivity(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,profilerInfo,options);
      reply.writeNoException();
      reply.writeInt(result);
      return true;
    }
case START_ACTIVITY_AS_USER_TRANSACTION:
{
    data.enforceInterface(IActivityManager.descriptor);
    IBinder b=data.readStrongBinder();
    IApplicationThread app=ApplicationThreadNative.asInterface(b);
    String callingPackage=data.readString();
    Intent intent=Intent.CREATOR.createFromParcel(data);
    String resolvedType=data.readString();
    IBinder resultTo=data.readStrongBinder();
    String resultWho=data.readString();
    int requestCode=data.readInt();
    int startFlags=data.readInt();
    ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
    Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
    int userId=data.readInt();
    int result=startActivityAsUser(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,profilerInfo,options,userId);
    reply.writeNoException();
    reply.writeInt(result);
    return true;
  }
case START_ACTIVITY_AS_CALLER_TRANSACTION:
{
  data.enforceInterface(IActivityManager.descriptor);
  IBinder b=data.readStrongBinder();
  IApplicationThread app=ApplicationThreadNative.asInterface(b);
  String callingPackage=data.readString();
  Intent intent=Intent.CREATOR.createFromParcel(data);
  String resolvedType=data.readString();
  IBinder resultTo=data.readStrongBinder();
  String resultWho=data.readString();
  int requestCode=data.readInt();
  int startFlags=data.readInt();
  ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
  Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
  boolean ignoreTargetSecurity=data.readInt() != 0;
  int userId=data.readInt();
  int result=startActivityAsCaller(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,profilerInfo,options,ignoreTargetSecurity,userId);
  reply.writeNoException();
  reply.writeInt(result);
  return true;
}
case START_ACTIVITY_AND_WAIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String callingPackage=data.readString();
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder resultTo=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
int startFlags=data.readInt();
ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
WaitResult result=startActivityAndWait(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,profilerInfo,options,userId);
reply.writeNoException();
result.writeToParcel(reply,0);
return true;
}
case START_ACTIVITY_WITH_CONFIG_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String callingPackage=data.readString();
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder resultTo=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
int startFlags=data.readInt();
Configuration config=Configuration.CREATOR.createFromParcel(data);
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
int result=startActivityWithConfig(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,config,options,userId);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case START_ACTIVITY_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IntentSender intent=IntentSender.CREATOR.createFromParcel(data);
Intent fillInIntent=null;
if (data.readInt() != 0) {
fillInIntent=Intent.CREATOR.createFromParcel(data);
}
String resolvedType=data.readString();
IBinder resultTo=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
int flagsMask=data.readInt();
int flagsValues=data.readInt();
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int result=startActivityIntentSender(app,intent,fillInIntent,resolvedType,resultTo,resultWho,requestCode,flagsMask,flagsValues,options);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case START_VOICE_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String callingPackage=data.readString();
int callingPid=data.readInt();
int callingUid=data.readInt();
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IVoiceInteractionSession session=IVoiceInteractionSession.Stub.asInterface(data.readStrongBinder());
IVoiceInteractor interactor=IVoiceInteractor.Stub.asInterface(data.readStrongBinder());
int startFlags=data.readInt();
ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
int result=startVoiceActivity(callingPackage,callingPid,callingUid,intent,resolvedType,session,interactor,startFlags,profilerInfo,options,userId);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case START_LOCAL_VOICE_INTERACTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle options=data.readBundle();
startLocalVoiceInteraction(token,options);
reply.writeNoException();
return true;
}
case STOP_LOCAL_VOICE_INTERACTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
stopLocalVoiceInteraction(token);
reply.writeNoException();
return true;
}
case SUPPORTS_LOCAL_VOICE_INTERACTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean result=supportsLocalVoiceInteraction();
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case START_NEXT_MATCHING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder callingActivity=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
boolean result=startNextMatchingActivity(callingActivity,intent,options);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case START_ACTIVITY_FROM_RECENTS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int taskId=data.readInt();
final Bundle options=data.readInt() == 0 ? null : Bundle.CREATOR.createFromParcel(data);
final int result=startActivityFromRecents(taskId,options);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case FINISH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent resultData=null;
int resultCode=data.readInt();
if (data.readInt() != 0) {
resultData=Intent.CREATOR.createFromParcel(data);
}
int finishTask=data.readInt();
boolean res=finishActivity(token,resultCode,resultData,finishTask);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_SUB_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
finishSubActivity(token,resultWho,requestCode);
reply.writeNoException();
return true;
}
case FINISH_ACTIVITY_AFFINITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean res=finishActivityAffinity(token);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_VOICE_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IVoiceInteractionSession session=IVoiceInteractionSession.Stub.asInterface(data.readStrongBinder());
finishVoiceTask(session);
reply.writeNoException();
return true;
}
case RELEASE_ACTIVITY_INSTANCE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean res=releaseActivityInstance(token);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case RELEASE_SOME_ACTIVITIES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
releaseSomeActivities(app);
reply.writeNoException();
return true;
}
case WILL_ACTIVITY_BE_VISIBLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean res=willActivityBeVisible(token);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
String packageName=data.readString();
b=data.readStrongBinder();
IIntentReceiver rec=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
IntentFilter filter=IntentFilter.CREATOR.createFromParcel(data);
String perm=data.readString();
int userId=data.readInt();
Intent intent=registerReceiver(app,packageName,rec,filter,perm,userId);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case UNREGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
if (b == null) {
return true;
}
IIntentReceiver rec=IIntentReceiver.Stub.asInterface(b);
unregisterReceiver(rec);
reply.writeNoException();
return true;
}
case BROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
IIntentReceiver resultTo=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
String[] perms=data.readStringArray();
int appOp=data.readInt();
Bundle options=data.readBundle();
boolean serialized=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
int userId=data.readInt();
int res=broadcastIntent(app,intent,resolvedType,resultTo,resultCode,resultData,resultExtras,perms,appOp,options,serialized,sticky,userId);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
int userId=data.readInt();
unbroadcastIntent(app,intent,userId);
reply.writeNoException();
return true;
}
case FINISH_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean resultAbort=data.readInt() != 0;
int intentFlags=data.readInt();
if (who != null) {
finishReceiver(who,resultCode,resultData,resultExtras,resultAbort,intentFlags);
}
reply.writeNoException();
return true;
}
case ATTACH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
if (app != null) {
attachApplication(app);
}
reply.writeNoException();
return true;
}
case ACTIVITY_IDLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Configuration config=null;
if (data.readInt() != 0) {
config=Configuration.CREATOR.createFromParcel(data);
}
boolean stopProfiling=data.readInt() != 0;
if (token != null) {
activityIdle(token,config,stopProfiling);
}
reply.writeNoException();
return true;
}
case ACTIVITY_RESUMED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityResumed(token);
reply.writeNoException();
return true;
}
case ACTIVITY_PAUSED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityPaused(token);
reply.writeNoException();
return true;
}
case ACTIVITY_STOPPED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle map=data.readBundle();
PersistableBundle persistentState=data.readPersistableBundle();
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
activityStopped(token,map,persistentState,description);
reply.writeNoException();
return true;
}
case ACTIVITY_SLEPT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activitySlept(token);
reply.writeNoException();
return true;
}
case ACTIVITY_DESTROYED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityDestroyed(token);
reply.writeNoException();
return true;
}
case ACTIVITY_RELAUNCHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityRelaunched(token);
reply.writeNoException();
return true;
}
case GET_CALLING_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=token != null ? getCallingPackage(token) : null;
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_CALLING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getCallingActivity(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_APP_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String callingPackage=data.readString();
List<IAppTask> list=getAppTasks(callingPackage);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
IAppTask task=list.get(i);
reply.writeStrongBinder(task.asBinder());
}
return true;
}
case ADD_APP_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder activityToken=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
ActivityManager.TaskDescription descr=ActivityManager.TaskDescription.CREATOR.createFromParcel(data);
Bitmap thumbnail=Bitmap.CREATOR.createFromParcel(data);
int res=addAppTask(activityToken,intent,descr,thumbnail);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case GET_APP_TASK_THUMBNAIL_SIZE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Point size=getAppTaskThumbnailSize();
reply.writeNoException();
size.writeToParcel(reply,0);
return true;
}
case GET_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RunningTaskInfo> list=getTasks(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningTaskInfo info=list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_RECENT_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
int userId=data.readInt();
List<ActivityManager.RecentTaskInfo> list=getRecentTasks(maxNum,fl,userId);
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_TASK_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int id=data.readInt();
ActivityManager.TaskThumbnail taskThumbnail=getTaskThumbnail(id);
reply.writeNoException();
if (taskThumbnail != null) {
reply.writeInt(1);
taskThumbnail.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GET_SERVICES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RunningServiceInfo> list=getServices(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningServiceInfo info=list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_PROCESSES_IN_ERROR_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.ProcessErrorStateInfo> list=getProcessesInErrorState();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_APP_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.RunningAppProcessInfo> list=getRunningAppProcesses();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_EXTERNAL_APPLICATIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ApplicationInfo> list=getRunningExternalApplications();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case MOVE_TASK_TO_FRONT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
int fl=data.readInt();
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
moveTaskToFront(task,fl,options);
reply.writeNoException();
return true;
}
case MOVE_ACTIVITY_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean nonRoot=data.readInt() != 0;
boolean res=moveActivityTaskToBack(token,nonRoot);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case MOVE_TASK_BACKWARDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskBackwards(task);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
int stackId=data.readInt();
boolean toTop=data.readInt() != 0;
moveTaskToStack(taskId,stackId,toTop);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_DOCKED_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
int createMode=data.readInt();
boolean toTop=data.readInt() != 0;
boolean animate=data.readInt() != 0;
Rect bounds=null;
boolean hasBounds=data.readInt() != 0;
if (hasBounds) {
bounds=Rect.CREATOR.createFromParcel(data);
}
moveTaskToDockedStack(taskId,createMode,toTop,animate,bounds);
reply.writeNoException();
return true;
}
case MOVE_TOP_ACTIVITY_TO_PINNED_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int stackId=data.readInt();
final Rect r=Rect.CREATOR.createFromParcel(data);
final boolean res=moveTopActivityToPinnedStack(stackId,r);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case RESIZE_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int stackId=data.readInt();
final boolean hasRect=data.readInt() != 0;
Rect r=null;
if (hasRect) {
r=Rect.CREATOR.createFromParcel(data);
}
final boolean allowResizeInDockedMode=data.readInt() == 1;
final boolean preserveWindows=data.readInt() == 1;
final boolean animate=data.readInt() == 1;
resizeStack(stackId,r,allowResizeInDockedMode,preserveWindows,animate);
reply.writeNoException();
return true;
}
case RESIZE_DOCKED_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean hasBounds=data.readInt() != 0;
Rect bounds=null;
if (hasBounds) {
bounds=Rect.CREATOR.createFromParcel(data);
}
final boolean hasTempDockedTaskBounds=data.readInt() != 0;
Rect tempDockedTaskBounds=null;
if (hasTempDockedTaskBounds) {
tempDockedTaskBounds=Rect.CREATOR.createFromParcel(data);
}
final boolean hasTempDockedTaskInsetBounds=data.readInt() != 0;
Rect tempDockedTaskInsetBounds=null;
if (hasTempDockedTaskInsetBounds) {
tempDockedTaskInsetBounds=Rect.CREATOR.createFromParcel(data);
}
final boolean hasTempOtherTaskBounds=data.readInt() != 0;
Rect tempOtherTaskBounds=null;
if (hasTempOtherTaskBounds) {
tempOtherTaskBounds=Rect.CREATOR.createFromParcel(data);
}
final boolean hasTempOtherTaskInsetBounds=data.readInt() != 0;
Rect tempOtherTaskInsetBounds=null;
if (hasTempOtherTaskInsetBounds) {
tempOtherTaskInsetBounds=Rect.CREATOR.createFromParcel(data);
}
resizeDockedStack(bounds,tempDockedTaskBounds,tempDockedTaskInsetBounds,tempOtherTaskBounds,tempOtherTaskInsetBounds);
reply.writeNoException();
return true;
}
case POSITION_TASK_IN_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
int stackId=data.readInt();
int position=data.readInt();
positionTaskInStack(taskId,stackId,position);
reply.writeNoException();
return true;
}
case GET_ALL_STACK_INFOS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<StackInfo> list=getAllStackInfos();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_STACK_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int stackId=data.readInt();
StackInfo info=getStackInfo(stackId);
reply.writeNoException();
if (info != null) {
reply.writeInt(1);
info.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case IS_IN_HOME_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
boolean isInHomeStack=isInHomeStack(taskId);
reply.writeNoException();
reply.writeInt(isInHomeStack ? 1 : 0);
return true;
}
case SET_FOCUSED_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int stackId=data.readInt();
setFocusedStack(stackId);
reply.writeNoException();
return true;
}
case GET_FOCUSED_STACK_ID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int focusedStackId=getFocusedStackId();
reply.writeNoException();
reply.writeInt(focusedStackId);
return true;
}
case SET_FOCUSED_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
setFocusedTask(taskId);
reply.writeNoException();
return true;
}
case REGISTER_TASK_STACK_LISTENER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
registerTaskStackListener(ITaskStackListener.Stub.asInterface(token));
reply.writeNoException();
return true;
}
case GET_TASK_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean onlyRoot=data.readInt() != 0;
int res=token != null ? getTaskForActivity(token,onlyRoot) : -1;
reply.writeNoException();
reply.writeInt(res);
return true;
}
case GET_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
int userId=data.readInt();
boolean stable=data.readInt() != 0;
ContentProviderHolder cph=getContentProvider(app,name,userId,stable);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case GET_CONTENT_PROVIDER_EXTERNAL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String name=data.readString();
int userId=data.readInt();
IBinder token=data.readStrongBinder();
ContentProviderHolder cph=getContentProviderExternal(name,userId,token);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case PUBLISH_CONTENT_PROVIDERS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
ArrayList<ContentProviderHolder> providers=data.createTypedArrayList(ContentProviderHolder.CREATOR);
publishContentProviders(app,providers);
reply.writeNoException();
return true;
}
case REF_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
int stable=data.readInt();
int unstable=data.readInt();
boolean res=refContentProvider(b,stable,unstable);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case UNSTABLE_PROVIDER_DIED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
unstableProviderDied(b);
reply.writeNoException();
return true;
}
case APP_NOT_RESPONDING_VIA_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
appNotRespondingViaProvider(b);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
boolean stable=data.readInt() != 0;
removeContentProvider(b,stable);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_EXTERNAL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String name=data.readString();
IBinder token=data.readStrongBinder();
removeContentProviderExternal(name,token);
reply.writeNoException();
return true;
}
case GET_RUNNING_SERVICE_CONTROL_PANEL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName comp=ComponentName.CREATOR.createFromParcel(data);
PendingIntent pi=getRunningServiceControlPanel(comp);
reply.writeNoException();
PendingIntent.writePendingIntentOrNullToParcel(pi,reply);
return true;
}
case START_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
String callingPackage=data.readString();
int userId=data.readInt();
ComponentName cn=startService(app,service,resolvedType,callingPackage,userId);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
int userId=data.readInt();
int res=stopService(app,service,resolvedType,userId);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case STOP_SERVICE_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
boolean res=stopServiceToken(className,token,startId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SET_SERVICE_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int id=data.readInt();
Notification notification=null;
if (data.readInt() != 0) {
notification=Notification.CREATOR.createFromParcel(data);
}
boolean removeNotification=data.readInt() != 0;
setServiceForeground(className,token,id,notification,removeNotification);
reply.writeNoException();
return true;
}
case BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IBinder token=data.readStrongBinder();
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
int fl=data.readInt();
String callingPackage=data.readString();
int userId=data.readInt();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
int res=bindService(app,token,service,resolvedType,conn,fl,callingPackage,userId);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
boolean res=unbindService(conn);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case PUBLISH_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder service=data.readStrongBinder();
publishService(token,intent,service);
reply.writeNoException();
return true;
}
case UNBIND_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean doRebind=data.readInt() != 0;
unbindFinished(token,intent,doRebind);
reply.writeNoException();
return true;
}
case SERVICE_DONE_EXECUTING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int type=data.readInt();
int startId=data.readInt();
int res=data.readInt();
serviceDoneExecuting(token,type,startId,res);
reply.writeNoException();
return true;
}
case START_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
String profileFile=data.readString();
int fl=data.readInt();
Bundle arguments=data.readBundle();
IBinder b=data.readStrongBinder();
IInstrumentationWatcher w=IInstrumentationWatcher.Stub.asInterface(b);
b=data.readStrongBinder();
IUiAutomationConnection c=IUiAutomationConnection.Stub.asInterface(b);
int userId=data.readInt();
String abiOverride=data.readString();
boolean res=startInstrumentation(className,profileFile,fl,arguments,w,c,userId,abiOverride);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int resultCode=data.readInt();
Bundle results=data.readBundle();
finishInstrumentation(app,resultCode,results);
reply.writeNoException();
return true;
}
case GET_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=getConfiguration();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case UPDATE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updateConfiguration(config);
reply.writeNoException();
return true;
}
case SET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int requestedOrientation=data.readInt();
setRequestedOrientation(token,requestedOrientation);
reply.writeNoException();
return true;
}
case GET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int req=getRequestedOrientation(token);
reply.writeNoException();
reply.writeInt(req);
return true;
}
case GET_ACTIVITY_CLASS_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getActivityClassForToken(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_PACKAGE_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reply.writeNoException();
reply.writeString(getPackageForToken(token));
return true;
}
case GET_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int type=data.readInt();
String packageName=data.readString();
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
Intent[] requestIntents;
String[] requestResolvedTypes;
if (data.readInt() != 0) {
requestIntents=data.createTypedArray(Intent.CREATOR);
requestResolvedTypes=data.createStringArray();
}
 else {
requestIntents=null;
requestResolvedTypes=null;
}
int fl=data.readInt();
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
IIntentSender res=getIntentSender(type,packageName,token,resultWho,requestCode,requestIntents,requestResolvedTypes,fl,options,userId);
reply.writeNoException();
reply.writeStrongBinder(res != null ? res.asBinder() : null);
return true;
}
case CANCEL_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
cancelIntentSender(r);
reply.writeNoException();
return true;
}
case GET_PACKAGE_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String res=getPackageForIntentSender(r);
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_UID_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
int res=getUidForIntentSender(r);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case HANDLE_INCOMING_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int callingPid=data.readInt();
int callingUid=data.readInt();
int userId=data.readInt();
boolean allowAll=data.readInt() != 0;
boolean requireFull=data.readInt() != 0;
String name=data.readString();
String callerPackage=data.readString();
int res=handleIncomingUser(callingPid,callingUid,userId,allowAll,requireFull,name,callerPackage);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case SET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int max=data.readInt();
setProcessLimit(max);
reply.writeNoException();
return true;
}
case GET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int limit=getProcessLimit();
reply.writeNoException();
reply.writeInt(limit);
return true;
}
case SET_PROCESS_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int pid=data.readInt();
boolean isForeground=data.readInt() != 0;
setProcessForeground(token,pid,isForeground);
reply.writeNoException();
return true;
}
case CHECK_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
int res=checkPermission(perm,pid,uid);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_PERMISSION_WITH_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
IBinder token=data.readStrongBinder();
int res=checkPermissionWithToken(perm,pid,uid,token);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int pid=data.readInt();
int uid=data.readInt();
int mode=data.readInt();
int userId=data.readInt();
IBinder callerToken=data.readStrongBinder();
int res=checkUriPermission(uri,pid,uid,mode,userId,callerToken);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CLEAR_APP_DATA_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IPackageDataObserver observer=IPackageDataObserver.Stub.asInterface(data.readStrongBinder());
int userId=data.readInt();
boolean res=clearApplicationUserData(packageName,observer,userId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int userId=data.readInt();
grantUriPermission(app,targetPkg,uri,mode,userId);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int userId=data.readInt();
revokeUriPermission(app,uri,mode,userId);
reply.writeNoException();
return true;
}
case TAKE_PERSISTABLE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int userId=data.readInt();
takePersistableUriPermission(uri,mode,userId);
reply.writeNoException();
return true;
}
case RELEASE_PERSISTABLE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int userId=data.readInt();
releasePersistableUriPermission(uri,mode,userId);
reply.writeNoException();
return true;
}
case GET_PERSISTED_URI_PERMISSIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final String packageName=data.readString();
final boolean incoming=data.readInt() != 0;
final ParceledListSlice<UriPermission> perms=getPersistedUriPermissions(packageName,incoming);
reply.writeNoException();
perms.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
return true;
}
case GET_GRANTED_URI_PERMISSIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final String packageName=data.readString();
final int userId=data.readInt();
final ParceledListSlice<UriPermission> perms=getGrantedUriPermissions(packageName,userId);
reply.writeNoException();
perms.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
return true;
}
case CLEAR_GRANTED_URI_PERMISSIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final String packageName=data.readString();
final int userId=data.readInt();
clearGrantedUriPermissions(packageName,userId);
reply.writeNoException();
return true;
}
case SHOW_WAITING_FOR_DEBUGGER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
boolean waiting=data.readInt() != 0;
showWaitingForDebugger(app,waiting);
reply.writeNoException();
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.MemoryInfo mi=new ActivityManager.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
case UNHANDLED_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
unhandledBack();
reply.writeNoException();
return true;
}
case OPEN_CONTENT_URI_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.parse(data.readString());
ParcelFileDescriptor pfd=openContentUri(uri);
reply.writeNoException();
if (pfd != null) {
reply.writeInt(1);
pfd.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case SET_LOCK_SCREEN_SHOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
setLockScreenShown(data.readInt() != 0);
reply.writeNoException();
return true;
}
case SET_DEBUG_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pn=data.readString();
boolean wfd=data.readInt() != 0;
boolean per=data.readInt() != 0;
setDebugApp(pn,wfd,per);
reply.writeNoException();
return true;
}
case SET_ALWAYS_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setAlwaysFinish(enabled);
reply.writeNoException();
return true;
}
case SET_ACTIVITY_CONTROLLER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityController watcher=IActivityController.Stub.asInterface(data.readStrongBinder());
setActivityController(watcher);
reply.writeNoException();
return true;
}
case SET_LENIENT_BACKGROUND_CHECK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setLenientBackgroundCheck(enabled);
reply.writeNoException();
return true;
}
case GET_MEMORY_TRIM_LEVEL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int level=getMemoryTrimLevel();
reply.writeNoException();
reply.writeInt(level);
return true;
}
case ENTER_SAFE_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
enterSafeMode();
reply.writeNoException();
return true;
}
case NOTE_WAKEUP_ALARM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
int sourceUid=data.readInt();
String sourcePkg=data.readString();
String tag=data.readString();
noteWakeupAlarm(is,sourceUid,sourcePkg,tag);
reply.writeNoException();
return true;
}
case NOTE_ALARM_START_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
int sourceUid=data.readInt();
String tag=data.readString();
noteAlarmStart(is,sourceUid,tag);
reply.writeNoException();
return true;
}
case NOTE_ALARM_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
int sourceUid=data.readInt();
String tag=data.readString();
noteAlarmFinish(is,sourceUid,tag);
reply.writeNoException();
return true;
}
case KILL_PIDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
String reason=data.readString();
boolean secure=data.readInt() != 0;
boolean res=killPids(pids,reason,secure);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case KILL_PROCESSES_BELOW_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String reason=data.readString();
boolean res=killProcessesBelowForeground(reason);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case HANDLE_APPLICATION_CRASH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
ApplicationErrorReport.CrashInfo ci=new ApplicationErrorReport.CrashInfo(data);
handleApplicationCrash(app,ci);
reply.writeNoException();
return true;
}
case HANDLE_APPLICATION_WTF_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
String tag=data.readString();
boolean system=data.readInt() != 0;
ApplicationErrorReport.CrashInfo ci=new ApplicationErrorReport.CrashInfo(data);
boolean res=handleApplicationWtf(app,tag,system,ci);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case HANDLE_APPLICATION_STRICT_MODE_VIOLATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
int violationMask=data.readInt();
StrictMode.ViolationInfo info=new StrictMode.ViolationInfo(data);
handleApplicationStrictModeViolation(app,violationMask,info);
reply.writeNoException();
return true;
}
case SIGNAL_PERSISTENT_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int sig=data.readInt();
signalPersistentProcesses(sig);
reply.writeNoException();
return true;
}
case KILL_BACKGROUND_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
int userId=data.readInt();
killBackgroundProcesses(packageName,userId);
reply.writeNoException();
return true;
}
case KILL_ALL_BACKGROUND_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
killAllBackgroundProcesses();
reply.writeNoException();
return true;
}
case KILL_PACKAGE_DEPENDENTS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
int userId=data.readInt();
killPackageDependents(packageName,userId);
reply.writeNoException();
return true;
}
case FORCE_STOP_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
int userId=data.readInt();
forceStopPackage(packageName,userId);
reply.writeNoException();
return true;
}
case GET_MY_MEMORY_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.RunningAppProcessInfo info=new ActivityManager.RunningAppProcessInfo();
getMyMemoryState(info);
reply.writeNoException();
info.writeToParcel(reply,0);
return true;
}
case GET_DEVICE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ConfigurationInfo config=getDeviceConfigurationInfo();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case PROFILE_CONTROL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
int userId=data.readInt();
boolean start=data.readInt() != 0;
int profileType=data.readInt();
ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
boolean res=profileControl(process,userId,start,profilerInfo,profileType);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHUTDOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=shutdown(data.readInt());
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case STOP_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopAppSwitches();
reply.writeNoException();
return true;
}
case RESUME_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
resumeAppSwitches();
reply.writeNoException();
return true;
}
case PEEK_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
String callingPackage=data.readString();
IBinder binder=peekService(service,resolvedType,callingPackage);
reply.writeNoException();
reply.writeStrongBinder(binder);
return true;
}
case START_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
int backupRestoreMode=data.readInt();
boolean success=bindBackupAgent(info,backupRestoreMode);
reply.writeNoException();
reply.writeInt(success ? 1 : 0);
return true;
}
case BACKUP_AGENT_CREATED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IBinder agent=data.readStrongBinder();
backupAgentCreated(packageName,agent);
reply.writeNoException();
return true;
}
case UNBIND_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
unbindBackupAgent(info);
reply.writeNoException();
return true;
}
case ADD_PACKAGE_DEPENDENCY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
addPackageDependency(packageName);
reply.writeNoException();
return true;
}
case KILL_APPLICATION_WITH_APPID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
int appid=data.readInt();
String reason=data.readString();
killApplicationWithAppId(pkg,appid,reason);
reply.writeNoException();
return true;
}
case CLOSE_SYSTEM_DIALOGS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String reason=data.readString();
closeSystemDialogs(reason);
reply.writeNoException();
return true;
}
case GET_PROCESS_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
Debug.MemoryInfo[] res=getProcessMemoryInfo(pids);
reply.writeNoException();
reply.writeTypedArray(res,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
return true;
}
case KILL_APPLICATION_PROCESS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String processName=data.readString();
int uid=data.readInt();
killApplicationProcess(processName,uid);
reply.writeNoException();
return true;
}
case OVERRIDE_PENDING_TRANSITION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String packageName=data.readString();
int enterAnim=data.readInt();
int exitAnim=data.readInt();
overridePendingTransition(token,packageName,enterAnim,exitAnim);
reply.writeNoException();
return true;
}
case IS_USER_A_MONKEY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean areThey=isUserAMonkey();
reply.writeNoException();
reply.writeInt(areThey ? 1 : 0);
return true;
}
case SET_USER_IS_MONKEY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean monkey=(data.readInt() == 1);
setUserIsMonkey(monkey);
reply.writeNoException();
return true;
}
case FINISH_HEAVY_WEIGHT_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
finishHeavyWeightApp();
reply.writeNoException();
return true;
}
case IS_IMMERSIVE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean isit=isImmersive(token);
reply.writeNoException();
reply.writeInt(isit ? 1 : 0);
return true;
}
case IS_TOP_OF_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
final boolean isTopOfTask=isTopOfTask(token);
reply.writeNoException();
reply.writeInt(isTopOfTask ? 1 : 0);
return true;
}
case CONVERT_FROM_TRANSLUCENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean converted=convertFromTranslucent(token);
reply.writeNoException();
reply.writeInt(converted ? 1 : 0);
return true;
}
case CONVERT_TO_TRANSLUCENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
final Bundle bundle;
if (data.readInt() == 0) {
bundle=null;
}
 else {
bundle=data.readBundle();
}
final ActivityOptions options=ActivityOptions.fromBundle(bundle);
boolean converted=convertToTranslucent(token,options);
reply.writeNoException();
reply.writeInt(converted ? 1 : 0);
return true;
}
case GET_ACTIVITY_OPTIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
final ActivityOptions options=getActivityOptions(token);
reply.writeNoException();
reply.writeBundle(options == null ? null : options.toBundle());
return true;
}
case SET_IMMERSIVE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean imm=data.readInt() == 1;
setImmersive(token,imm);
reply.writeNoException();
return true;
}
case IS_TOP_ACTIVITY_IMMERSIVE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean isit=isTopActivityImmersive();
reply.writeNoException();
reply.writeInt(isit ? 1 : 0);
return true;
}
case CRASH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int uid=data.readInt();
int initialPid=data.readInt();
String packageName=data.readString();
String message=data.readString();
crashApplication(uid,initialPid,packageName,message);
reply.writeNoException();
return true;
}
case GET_PROVIDER_MIME_TYPE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int userId=data.readInt();
String type=getProviderMimeType(uri,userId);
reply.writeNoException();
reply.writeString(type);
return true;
}
case NEW_URI_PERMISSION_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String name=data.readString();
IBinder perm=newUriPermissionOwner(name);
reply.writeNoException();
reply.writeStrongBinder(perm);
return true;
}
case GET_URI_PERMISSION_OWNER_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder activityToken=data.readStrongBinder();
IBinder perm=getUriPermissionOwnerForActivity(activityToken);
reply.writeNoException();
reply.writeStrongBinder(perm);
return true;
}
case GRANT_URI_PERMISSION_FROM_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder owner=data.readStrongBinder();
int fromUid=data.readInt();
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int sourceUserId=data.readInt();
int targetUserId=data.readInt();
grantUriPermissionFromOwner(owner,fromUid,targetPkg,uri,mode,sourceUserId,targetUserId);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_FROM_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder owner=data.readStrongBinder();
Uri uri=null;
if (data.readInt() != 0) {
uri=Uri.CREATOR.createFromParcel(data);
}
int mode=data.readInt();
int userId=data.readInt();
revokeUriPermissionFromOwner(owner,uri,mode,userId);
reply.writeNoException();
return true;
}
case CHECK_GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int callingUid=data.readInt();
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int modeFlags=data.readInt();
int userId=data.readInt();
int res=checkGrantUriPermission(callingUid,targetPkg,uri,modeFlags,userId);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case DUMP_HEAP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
int userId=data.readInt();
boolean managed=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? ParcelFileDescriptor.CREATOR.createFromParcel(data) : null;
boolean res=dumpHeap(process,userId,managed,path,fd);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case START_ACTIVITIES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String callingPackage=data.readString();
Intent[] intents=data.createTypedArray(Intent.CREATOR);
String[] resolvedTypes=data.createStringArray();
IBinder resultTo=data.readStrongBinder();
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
int result=startActivities(app,callingPackage,intents,resolvedTypes,resultTo,options,userId);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case GET_FRONT_ACTIVITY_SCREEN_COMPAT_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int mode=getFrontActivityScreenCompatMode();
reply.writeNoException();
reply.writeInt(mode);
return true;
}
case SET_FRONT_ACTIVITY_SCREEN_COMPAT_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int mode=data.readInt();
setFrontActivityScreenCompatMode(mode);
reply.writeNoException();
reply.writeInt(mode);
return true;
}
case GET_PACKAGE_SCREEN_COMPAT_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
int mode=getPackageScreenCompatMode(pkg);
reply.writeNoException();
reply.writeInt(mode);
return true;
}
case SET_PACKAGE_SCREEN_COMPAT_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
int mode=data.readInt();
setPackageScreenCompatMode(pkg,mode);
reply.writeNoException();
return true;
}
case SWITCH_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userid=data.readInt();
boolean result=switchUser(userid);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case START_USER_IN_BACKGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userid=data.readInt();
boolean result=startUserInBackground(userid);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case UNLOCK_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userId=data.readInt();
byte[] token=data.createByteArray();
byte[] secret=data.createByteArray();
boolean result=unlockUser(userId,token,secret);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case STOP_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userid=data.readInt();
boolean force=data.readInt() != 0;
IStopUserCallback callback=IStopUserCallback.Stub.asInterface(data.readStrongBinder());
int result=stopUser(userid,force,callback);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case GET_CURRENT_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
UserInfo userInfo=getCurrentUser();
reply.writeNoException();
userInfo.writeToParcel(reply,0);
return true;
}
case IS_USER_RUNNING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userid=data.readInt();
int _flags=data.readInt();
boolean result=isUserRunning(userid,_flags);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case GET_RUNNING_USER_IDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] result=getRunningUserIds();
reply.writeNoException();
reply.writeIntArray(result);
return true;
}
case REMOVE_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
boolean result=removeTask(taskId);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case REGISTER_PROCESS_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IProcessObserver observer=IProcessObserver.Stub.asInterface(data.readStrongBinder());
registerProcessObserver(observer);
return true;
}
case UNREGISTER_PROCESS_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IProcessObserver observer=IProcessObserver.Stub.asInterface(data.readStrongBinder());
unregisterProcessObserver(observer);
return true;
}
case REGISTER_UID_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IUidObserver observer=IUidObserver.Stub.asInterface(data.readStrongBinder());
int which=data.readInt();
registerUidObserver(observer,which);
return true;
}
case UNREGISTER_UID_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IUidObserver observer=IUidObserver.Stub.asInterface(data.readStrongBinder());
unregisterUidObserver(observer);
return true;
}
case GET_PACKAGE_ASK_SCREEN_COMPAT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
boolean ask=getPackageAskScreenCompat(pkg);
reply.writeNoException();
reply.writeInt(ask ? 1 : 0);
return true;
}
case SET_PACKAGE_ASK_SCREEN_COMPAT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
boolean ask=data.readInt() != 0;
setPackageAskScreenCompat(pkg,ask);
reply.writeNoException();
return true;
}
case IS_INTENT_SENDER_TARGETED_TO_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
boolean res=isIntentSenderTargetedToPackage(r);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case IS_INTENT_SENDER_AN_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
boolean res=isIntentSenderAnActivity(r);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GET_INTENT_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
Intent intent=getIntentForIntentSender(r);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GET_TAG_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String prefix=data.readString();
String tag=getTagForIntentSender(r,prefix);
reply.writeNoException();
reply.writeString(tag);
return true;
}
case UPDATE_PERSISTENT_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updatePersistentConfiguration(config);
reply.writeNoException();
return true;
}
case GET_PROCESS_PSS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
long[] pss=getProcessPss(pids);
reply.writeNoException();
reply.writeLongArray(pss);
return true;
}
case SHOW_BOOT_MESSAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
CharSequence msg=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
boolean always=data.readInt() != 0;
showBootMessage(msg,always);
reply.writeNoException();
return true;
}
case KEYGUARD_WAITING_FOR_ACTIVITY_DRAWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
keyguardWaitingForActivityDrawn();
reply.writeNoException();
return true;
}
case KEYGUARD_GOING_AWAY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
keyguardGoingAway(data.readInt() != 0,data.readInt() != 0);
reply.writeNoException();
return true;
}
case SHOULD_UP_RECREATE_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String destAffinity=data.readString();
boolean res=shouldUpRecreateTask(token,destAffinity);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case NAVIGATE_UP_TO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent target=Intent.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
Intent resultData=null;
if (data.readInt() != 0) {
resultData=Intent.CREATOR.createFromParcel(data);
}
boolean res=navigateUpTo(token,target,resultCode,resultData);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GET_LAUNCHED_FROM_UID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int res=getLaunchedFromUid(token);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case GET_LAUNCHED_FROM_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=getLaunchedFromPackage(token);
reply.writeNoException();
reply.writeString(res);
return true;
}
case REGISTER_USER_SWITCH_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IUserSwitchObserver observer=IUserSwitchObserver.Stub.asInterface(data.readStrongBinder());
registerUserSwitchObserver(observer);
reply.writeNoException();
return true;
}
case UNREGISTER_USER_SWITCH_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IUserSwitchObserver observer=IUserSwitchObserver.Stub.asInterface(data.readStrongBinder());
unregisterUserSwitchObserver(observer);
reply.writeNoException();
return true;
}
case REQUEST_BUG_REPORT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int bugreportType=data.readInt();
requestBugReport(bugreportType);
reply.writeNoException();
return true;
}
case INPUT_DISPATCHING_TIMED_OUT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int pid=data.readInt();
boolean aboveSystem=data.readInt() != 0;
String reason=data.readString();
long res=inputDispatchingTimedOut(pid,aboveSystem,reason);
reply.writeNoException();
reply.writeLong(res);
return true;
}
case GET_ASSIST_CONTEXT_EXTRAS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int requestType=data.readInt();
Bundle res=getAssistContextExtras(requestType);
reply.writeNoException();
reply.writeBundle(res);
return true;
}
case REQUEST_ASSIST_CONTEXT_EXTRAS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int requestType=data.readInt();
IResultReceiver receiver=IResultReceiver.Stub.asInterface(data.readStrongBinder());
IBinder activityToken=data.readStrongBinder();
boolean res=requestAssistContextExtras(requestType,receiver,activityToken);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REPORT_ASSIST_CONTEXT_EXTRAS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle extras=data.readBundle();
AssistStructure structure=AssistStructure.CREATOR.createFromParcel(data);
AssistContent content=AssistContent.CREATOR.createFromParcel(data);
Uri referrer=data.readInt() != 0 ? Uri.CREATOR.createFromParcel(data) : null;
reportAssistContextExtras(token,extras,structure,content,referrer);
reply.writeNoException();
return true;
}
case LAUNCH_ASSIST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
int requestType=data.readInt();
String hint=data.readString();
int userHandle=data.readInt();
Bundle args=data.readBundle();
boolean res=launchAssistIntent(intent,requestType,hint,userHandle,args);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case IS_SCREEN_CAPTURE_ALLOWED_ON_CURRENT_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=isAssistDataAllowedOnCurrentActivity();
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHOW_ASSIST_FROM_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle args=data.readBundle();
boolean res=showAssistFromActivity(token,args);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case KILL_UID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int appId=data.readInt();
int userId=data.readInt();
String reason=data.readString();
killUid(appId,userId,reason);
reply.writeNoException();
return true;
}
case HANG_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
boolean allowRestart=data.readInt() != 0;
hang(who,allowRestart);
reply.writeNoException();
return true;
}
case REPORT_ACTIVITY_FULLY_DRAWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reportActivityFullyDrawn(token);
reply.writeNoException();
return true;
}
case NOTIFY_ACTIVITY_DRAWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
notifyActivityDrawn(token);
reply.writeNoException();
return true;
}
case RESTART_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
restart();
reply.writeNoException();
return true;
}
case PERFORM_IDLE_MAINTENANCE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
performIdleMaintenance();
reply.writeNoException();
return true;
}
case CREATE_VIRTUAL_ACTIVITY_CONTAINER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder parentActivityToken=data.readStrongBinder();
IActivityContainerCallback callback=IActivityContainerCallback.Stub.asInterface(data.readStrongBinder());
IActivityContainer activityContainer=createVirtualActivityContainer(parentActivityToken,callback);
reply.writeNoException();
if (activityContainer != null) {
reply.writeInt(1);
reply.writeStrongBinder(activityContainer.asBinder());
}
 else {
reply.writeInt(0);
}
return true;
}
case DELETE_ACTIVITY_CONTAINER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityContainer activityContainer=IActivityContainer.Stub.asInterface(data.readStrongBinder());
deleteActivityContainer(activityContainer);
reply.writeNoException();
return true;
}
case CREATE_STACK_ON_DISPLAY:
{
data.enforceInterface(IActivityManager.descriptor);
int displayId=data.readInt();
IActivityContainer activityContainer=createStackOnDisplay(displayId);
reply.writeNoException();
if (activityContainer != null) {
reply.writeInt(1);
reply.writeStrongBinder(activityContainer.asBinder());
}
 else {
reply.writeInt(0);
}
return true;
}
case GET_ACTIVITY_DISPLAY_ID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder activityToken=data.readStrongBinder();
int displayId=getActivityDisplayId(activityToken);
reply.writeNoException();
reply.writeInt(displayId);
return true;
}
case START_LOCK_TASK_BY_TASK_ID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int taskId=data.readInt();
startLockTaskMode(taskId);
reply.writeNoException();
return true;
}
case START_LOCK_TASK_BY_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
startLockTaskMode(token);
reply.writeNoException();
return true;
}
case START_LOCK_TASK_BY_CURRENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
startLockTaskModeOnCurrent();
reply.writeNoException();
return true;
}
case STOP_LOCK_TASK_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopLockTaskMode();
reply.writeNoException();
return true;
}
case STOP_LOCK_TASK_BY_CURRENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopLockTaskModeOnCurrent();
reply.writeNoException();
return true;
}
case IS_IN_LOCK_TASK_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean isInLockTaskMode=isInLockTaskMode();
reply.writeNoException();
reply.writeInt(isInLockTaskMode ? 1 : 0);
return true;
}
case GET_LOCK_TASK_MODE_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int lockTaskModeState=getLockTaskModeState();
reply.writeNoException();
reply.writeInt(lockTaskModeState);
return true;
}
case SHOW_LOCK_TASK_ESCAPE_MESSAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
showLockTaskEscapeMessage(token);
reply.writeNoException();
return true;
}
case SET_TASK_DESCRIPTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ActivityManager.TaskDescription values=ActivityManager.TaskDescription.CREATOR.createFromParcel(data);
setTaskDescription(token,values);
reply.writeNoException();
return true;
}
case SET_TASK_RESIZEABLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int taskId=data.readInt();
final int resizeableMode=data.readInt();
setTaskResizeable(taskId,resizeableMode);
reply.writeNoException();
return true;
}
case RESIZE_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
int resizeMode=data.readInt();
Rect r=Rect.CREATOR.createFromParcel(data);
resizeTask(taskId,r,resizeMode);
reply.writeNoException();
return true;
}
case GET_TASK_BOUNDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
Rect r=getTaskBounds(taskId);
reply.writeNoException();
r.writeToParcel(reply,0);
return true;
}
case GET_TASK_DESCRIPTION_ICON_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String filename=data.readString();
int userId=data.readInt();
Bitmap icon=getTaskDescriptionIcon(filename,userId);
reply.writeNoException();
if (icon == null) {
reply.writeInt(0);
}
 else {
reply.writeInt(1);
icon.writeToParcel(reply,0);
}
return true;
}
case START_IN_PLACE_ANIMATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final Bundle bundle;
if (data.readInt() == 0) {
bundle=null;
}
 else {
bundle=data.readBundle();
}
final ActivityOptions options=ActivityOptions.fromBundle(bundle);
startInPlaceAnimationOnFrontMostApplication(options);
reply.writeNoException();
return true;
}
case REQUEST_VISIBLE_BEHIND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean enable=data.readInt() > 0;
boolean success=requestVisibleBehind(token,enable);
reply.writeNoException();
reply.writeInt(success ? 1 : 0);
return true;
}
case IS_BACKGROUND_VISIBLE_BEHIND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
final boolean enabled=isBackgroundVisibleBehind(token);
reply.writeNoException();
reply.writeInt(enabled ? 1 : 0);
return true;
}
case BACKGROUND_RESOURCES_RELEASED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
backgroundResourcesReleased(token);
reply.writeNoException();
return true;
}
case NOTIFY_LAUNCH_TASK_BEHIND_COMPLETE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
notifyLaunchTaskBehindComplete(token);
reply.writeNoException();
return true;
}
case NOTIFY_ENTER_ANIMATION_COMPLETE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
notifyEnterAnimationComplete(token);
reply.writeNoException();
return true;
}
case BOOT_ANIMATION_COMPLETE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
bootAnimationComplete();
reply.writeNoException();
return true;
}
case NOTIFY_CLEARTEXT_NETWORK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int uid=data.readInt();
final byte[] firstPacket=data.createByteArray();
notifyCleartextNetwork(uid,firstPacket);
reply.writeNoException();
return true;
}
case SET_DUMP_HEAP_DEBUG_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String procName=data.readString();
int uid=data.readInt();
long maxMemSize=data.readLong();
String reportPackage=data.readString();
setDumpHeapDebugLimit(procName,uid,maxMemSize,reportPackage);
reply.writeNoException();
return true;
}
case DUMP_HEAP_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String path=data.readString();
dumpHeapFinished(path);
reply.writeNoException();
return true;
}
case SET_VOICE_KEEP_AWAKE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IVoiceInteractionSession session=IVoiceInteractionSession.Stub.asInterface(data.readStrongBinder());
boolean keepAwake=data.readInt() != 0;
setVoiceKeepAwake(session,keepAwake);
reply.writeNoException();
return true;
}
case UPDATE_LOCK_TASK_PACKAGES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userId=data.readInt();
String[] packages=data.readStringArray();
updateLockTaskPackages(userId,packages);
reply.writeNoException();
return true;
}
case UPDATE_DEVICE_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
updateDeviceOwner(packageName);
reply.writeNoException();
return true;
}
case GET_PACKAGE_PROCESS_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
String callingPackage=data.readString();
int res=getPackageProcessState(pkg,callingPackage);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case SET_PROCESS_MEMORY_TRIM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
int userId=data.readInt();
int level=data.readInt();
boolean res=setProcessMemoryTrimLevel(process,userId,level);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case IS_ROOT_VOICE_INTERACTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean res=isRootVoiceInteraction(token);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case START_BINDER_TRACKING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=startBinderTracking();
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case STOP_BINDER_TRACKING_AND_DUMP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ParcelFileDescriptor fd=data.readInt() != 0 ? ParcelFileDescriptor.CREATOR.createFromParcel(data) : null;
boolean res=stopBinderTrackingAndDump(fd);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GET_ACTIVITY_STACK_ID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int stackId=getActivityStackId(token);
reply.writeNoException();
reply.writeInt(stackId);
return true;
}
case EXIT_FREEFORM_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
exitFreeformMode(token);
reply.writeNoException();
return true;
}
case REPORT_SIZE_CONFIGURATIONS:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int[] horizontal=readIntArray(data);
int[] vertical=readIntArray(data);
int[] smallest=readIntArray(data);
reportSizeConfigurations(token,horizontal,vertical,smallest);
return true;
}
case SUPPRESS_RESIZE_CONFIG_CHANGES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean suppress=data.readInt() == 1;
suppressResizeConfigChanges(suppress);
reply.writeNoException();
return true;
}
case MOVE_TASKS_TO_FULLSCREEN_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int stackId=data.readInt();
final boolean onTop=data.readInt() == 1;
moveTasksToFullscreenStack(stackId,onTop);
reply.writeNoException();
return true;
}
case GET_APP_START_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int uid=data.readInt();
final String pkg=data.readString();
int res=getAppStartMode(uid,pkg);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case IN_MULTI_WINDOW_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
final boolean inMultiWindow=inMultiWindow(token);
reply.writeNoException();
reply.writeInt(inMultiWindow ? 1 : 0);
return true;
}
case IN_PICTURE_IN_PICTURE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
final boolean inPip=inPictureInPicture(token);
reply.writeNoException();
reply.writeInt(inPip ? 1 : 0);
return true;
}
case ENTER_PICTURE_IN_PICTURE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
enterPictureInPicture(token);
reply.writeNoException();
return true;
}
case SET_VR_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
final boolean enable=data.readInt() == 1;
setVrMode(token,enable);
reply.writeNoException();
return true;
}
case IS_APP_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int userHandle=data.readInt();
final boolean isForeground=isAppForeground(userHandle);
reply.writeNoException();
reply.writeInt(isForeground ? 1 : 0);
return true;
}
case NOTIFY_PINNED_STACK_ANIMATION_ENDED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
reply.writeNoException();
return true;
}
case REMOVE_STACK:
{
data.enforceInterface(IActivityManager.descriptor);
final int stackId=data.readInt();
removeStack(stackId);
reply.writeNoException();
return true;
}
}
return super.onTransact(code,data,reply,flags);
}","@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case START_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IActivityManager.descriptor);
      IBinder b=data.readStrongBinder();
      IApplicationThread app=ApplicationThreadNative.asInterface(b);
      String callingPackage=data.readString();
      Intent intent=Intent.CREATOR.createFromParcel(data);
      String resolvedType=data.readString();
      IBinder resultTo=data.readStrongBinder();
      String resultWho=data.readString();
      int requestCode=data.readInt();
      int startFlags=data.readInt();
      ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
      Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
      int result=startActivity(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,profilerInfo,options);
      reply.writeNoException();
      reply.writeInt(result);
      return true;
    }
case START_ACTIVITY_AS_USER_TRANSACTION:
{
    data.enforceInterface(IActivityManager.descriptor);
    IBinder b=data.readStrongBinder();
    IApplicationThread app=ApplicationThreadNative.asInterface(b);
    String callingPackage=data.readString();
    Intent intent=Intent.CREATOR.createFromParcel(data);
    String resolvedType=data.readString();
    IBinder resultTo=data.readStrongBinder();
    String resultWho=data.readString();
    int requestCode=data.readInt();
    int startFlags=data.readInt();
    ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
    Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
    int userId=data.readInt();
    int result=startActivityAsUser(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,profilerInfo,options,userId);
    reply.writeNoException();
    reply.writeInt(result);
    return true;
  }
case START_ACTIVITY_AS_CALLER_TRANSACTION:
{
  data.enforceInterface(IActivityManager.descriptor);
  IBinder b=data.readStrongBinder();
  IApplicationThread app=ApplicationThreadNative.asInterface(b);
  String callingPackage=data.readString();
  Intent intent=Intent.CREATOR.createFromParcel(data);
  String resolvedType=data.readString();
  IBinder resultTo=data.readStrongBinder();
  String resultWho=data.readString();
  int requestCode=data.readInt();
  int startFlags=data.readInt();
  ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
  Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
  boolean ignoreTargetSecurity=data.readInt() != 0;
  int userId=data.readInt();
  int result=startActivityAsCaller(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,profilerInfo,options,ignoreTargetSecurity,userId);
  reply.writeNoException();
  reply.writeInt(result);
  return true;
}
case START_ACTIVITY_AND_WAIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String callingPackage=data.readString();
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder resultTo=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
int startFlags=data.readInt();
ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
WaitResult result=startActivityAndWait(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,profilerInfo,options,userId);
reply.writeNoException();
result.writeToParcel(reply,0);
return true;
}
case START_ACTIVITY_WITH_CONFIG_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String callingPackage=data.readString();
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder resultTo=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
int startFlags=data.readInt();
Configuration config=Configuration.CREATOR.createFromParcel(data);
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
int result=startActivityWithConfig(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,config,options,userId);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case START_ACTIVITY_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IntentSender intent=IntentSender.CREATOR.createFromParcel(data);
Intent fillInIntent=null;
if (data.readInt() != 0) {
fillInIntent=Intent.CREATOR.createFromParcel(data);
}
String resolvedType=data.readString();
IBinder resultTo=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
int flagsMask=data.readInt();
int flagsValues=data.readInt();
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int result=startActivityIntentSender(app,intent,fillInIntent,resolvedType,resultTo,resultWho,requestCode,flagsMask,flagsValues,options);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case START_VOICE_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String callingPackage=data.readString();
int callingPid=data.readInt();
int callingUid=data.readInt();
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IVoiceInteractionSession session=IVoiceInteractionSession.Stub.asInterface(data.readStrongBinder());
IVoiceInteractor interactor=IVoiceInteractor.Stub.asInterface(data.readStrongBinder());
int startFlags=data.readInt();
ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
int result=startVoiceActivity(callingPackage,callingPid,callingUid,intent,resolvedType,session,interactor,startFlags,profilerInfo,options,userId);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case START_LOCAL_VOICE_INTERACTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle options=data.readBundle();
startLocalVoiceInteraction(token,options);
reply.writeNoException();
return true;
}
case STOP_LOCAL_VOICE_INTERACTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
stopLocalVoiceInteraction(token);
reply.writeNoException();
return true;
}
case SUPPORTS_LOCAL_VOICE_INTERACTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean result=supportsLocalVoiceInteraction();
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case START_NEXT_MATCHING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder callingActivity=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
boolean result=startNextMatchingActivity(callingActivity,intent,options);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case START_ACTIVITY_FROM_RECENTS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int taskId=data.readInt();
final Bundle options=data.readInt() == 0 ? null : Bundle.CREATOR.createFromParcel(data);
final int result=startActivityFromRecents(taskId,options);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case FINISH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent resultData=null;
int resultCode=data.readInt();
if (data.readInt() != 0) {
resultData=Intent.CREATOR.createFromParcel(data);
}
int finishTask=data.readInt();
boolean res=finishActivity(token,resultCode,resultData,finishTask);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_SUB_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
finishSubActivity(token,resultWho,requestCode);
reply.writeNoException();
return true;
}
case FINISH_ACTIVITY_AFFINITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean res=finishActivityAffinity(token);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_VOICE_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IVoiceInteractionSession session=IVoiceInteractionSession.Stub.asInterface(data.readStrongBinder());
finishVoiceTask(session);
reply.writeNoException();
return true;
}
case RELEASE_ACTIVITY_INSTANCE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean res=releaseActivityInstance(token);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case RELEASE_SOME_ACTIVITIES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
releaseSomeActivities(app);
reply.writeNoException();
return true;
}
case WILL_ACTIVITY_BE_VISIBLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean res=willActivityBeVisible(token);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
String packageName=data.readString();
b=data.readStrongBinder();
IIntentReceiver rec=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
IntentFilter filter=IntentFilter.CREATOR.createFromParcel(data);
String perm=data.readString();
int userId=data.readInt();
Intent intent=registerReceiver(app,packageName,rec,filter,perm,userId);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case UNREGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
if (b == null) {
return true;
}
IIntentReceiver rec=IIntentReceiver.Stub.asInterface(b);
unregisterReceiver(rec);
reply.writeNoException();
return true;
}
case BROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
IIntentReceiver resultTo=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
String[] perms=data.readStringArray();
int appOp=data.readInt();
Bundle options=data.readBundle();
boolean serialized=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
int userId=data.readInt();
int res=broadcastIntent(app,intent,resolvedType,resultTo,resultCode,resultData,resultExtras,perms,appOp,options,serialized,sticky,userId);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
int userId=data.readInt();
unbroadcastIntent(app,intent,userId);
reply.writeNoException();
return true;
}
case FINISH_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean resultAbort=data.readInt() != 0;
int intentFlags=data.readInt();
if (who != null) {
finishReceiver(who,resultCode,resultData,resultExtras,resultAbort,intentFlags);
}
reply.writeNoException();
return true;
}
case ATTACH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
if (app != null) {
attachApplication(app);
}
reply.writeNoException();
return true;
}
case ACTIVITY_IDLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Configuration config=null;
if (data.readInt() != 0) {
config=Configuration.CREATOR.createFromParcel(data);
}
boolean stopProfiling=data.readInt() != 0;
if (token != null) {
activityIdle(token,config,stopProfiling);
}
reply.writeNoException();
return true;
}
case ACTIVITY_RESUMED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityResumed(token);
reply.writeNoException();
return true;
}
case ACTIVITY_PAUSED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityPaused(token);
reply.writeNoException();
return true;
}
case ACTIVITY_STOPPED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle map=data.readBundle();
PersistableBundle persistentState=data.readPersistableBundle();
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
activityStopped(token,map,persistentState,description);
reply.writeNoException();
return true;
}
case ACTIVITY_SLEPT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activitySlept(token);
reply.writeNoException();
return true;
}
case ACTIVITY_DESTROYED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityDestroyed(token);
reply.writeNoException();
return true;
}
case ACTIVITY_RELAUNCHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityRelaunched(token);
reply.writeNoException();
return true;
}
case GET_CALLING_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=token != null ? getCallingPackage(token) : null;
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_CALLING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getCallingActivity(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_APP_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String callingPackage=data.readString();
List<IAppTask> list=getAppTasks(callingPackage);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
IAppTask task=list.get(i);
reply.writeStrongBinder(task.asBinder());
}
return true;
}
case ADD_APP_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder activityToken=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
ActivityManager.TaskDescription descr=ActivityManager.TaskDescription.CREATOR.createFromParcel(data);
Bitmap thumbnail=Bitmap.CREATOR.createFromParcel(data);
int res=addAppTask(activityToken,intent,descr,thumbnail);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case GET_APP_TASK_THUMBNAIL_SIZE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Point size=getAppTaskThumbnailSize();
reply.writeNoException();
size.writeToParcel(reply,0);
return true;
}
case GET_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RunningTaskInfo> list=getTasks(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningTaskInfo info=list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_RECENT_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
int userId=data.readInt();
List<ActivityManager.RecentTaskInfo> list=getRecentTasks(maxNum,fl,userId);
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_TASK_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int id=data.readInt();
ActivityManager.TaskThumbnail taskThumbnail=getTaskThumbnail(id);
reply.writeNoException();
if (taskThumbnail != null) {
reply.writeInt(1);
taskThumbnail.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GET_SERVICES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RunningServiceInfo> list=getServices(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningServiceInfo info=list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_PROCESSES_IN_ERROR_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.ProcessErrorStateInfo> list=getProcessesInErrorState();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_APP_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.RunningAppProcessInfo> list=getRunningAppProcesses();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_EXTERNAL_APPLICATIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ApplicationInfo> list=getRunningExternalApplications();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case MOVE_TASK_TO_FRONT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
int fl=data.readInt();
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
moveTaskToFront(task,fl,options);
reply.writeNoException();
return true;
}
case MOVE_ACTIVITY_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean nonRoot=data.readInt() != 0;
boolean res=moveActivityTaskToBack(token,nonRoot);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case MOVE_TASK_BACKWARDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskBackwards(task);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
int stackId=data.readInt();
boolean toTop=data.readInt() != 0;
moveTaskToStack(taskId,stackId,toTop);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_DOCKED_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
int createMode=data.readInt();
boolean toTop=data.readInt() != 0;
boolean animate=data.readInt() != 0;
Rect bounds=null;
boolean hasBounds=data.readInt() != 0;
if (hasBounds) {
bounds=Rect.CREATOR.createFromParcel(data);
}
moveTaskToDockedStack(taskId,createMode,toTop,animate,bounds);
reply.writeNoException();
return true;
}
case MOVE_TOP_ACTIVITY_TO_PINNED_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int stackId=data.readInt();
final Rect r=Rect.CREATOR.createFromParcel(data);
final boolean res=moveTopActivityToPinnedStack(stackId,r);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case RESIZE_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int stackId=data.readInt();
final boolean hasRect=data.readInt() != 0;
Rect r=null;
if (hasRect) {
r=Rect.CREATOR.createFromParcel(data);
}
final boolean allowResizeInDockedMode=data.readInt() == 1;
final boolean preserveWindows=data.readInt() == 1;
final boolean animate=data.readInt() == 1;
resizeStack(stackId,r,allowResizeInDockedMode,preserveWindows,animate);
reply.writeNoException();
return true;
}
case RESIZE_DOCKED_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean hasBounds=data.readInt() != 0;
Rect bounds=null;
if (hasBounds) {
bounds=Rect.CREATOR.createFromParcel(data);
}
final boolean hasTempDockedTaskBounds=data.readInt() != 0;
Rect tempDockedTaskBounds=null;
if (hasTempDockedTaskBounds) {
tempDockedTaskBounds=Rect.CREATOR.createFromParcel(data);
}
final boolean hasTempDockedTaskInsetBounds=data.readInt() != 0;
Rect tempDockedTaskInsetBounds=null;
if (hasTempDockedTaskInsetBounds) {
tempDockedTaskInsetBounds=Rect.CREATOR.createFromParcel(data);
}
final boolean hasTempOtherTaskBounds=data.readInt() != 0;
Rect tempOtherTaskBounds=null;
if (hasTempOtherTaskBounds) {
tempOtherTaskBounds=Rect.CREATOR.createFromParcel(data);
}
final boolean hasTempOtherTaskInsetBounds=data.readInt() != 0;
Rect tempOtherTaskInsetBounds=null;
if (hasTempOtherTaskInsetBounds) {
tempOtherTaskInsetBounds=Rect.CREATOR.createFromParcel(data);
}
resizeDockedStack(bounds,tempDockedTaskBounds,tempDockedTaskInsetBounds,tempOtherTaskBounds,tempOtherTaskInsetBounds);
reply.writeNoException();
return true;
}
case POSITION_TASK_IN_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
int stackId=data.readInt();
int position=data.readInt();
positionTaskInStack(taskId,stackId,position);
reply.writeNoException();
return true;
}
case GET_ALL_STACK_INFOS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<StackInfo> list=getAllStackInfos();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_STACK_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int stackId=data.readInt();
StackInfo info=getStackInfo(stackId);
reply.writeNoException();
if (info != null) {
reply.writeInt(1);
info.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case IS_IN_HOME_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
boolean isInHomeStack=isInHomeStack(taskId);
reply.writeNoException();
reply.writeInt(isInHomeStack ? 1 : 0);
return true;
}
case SET_FOCUSED_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int stackId=data.readInt();
setFocusedStack(stackId);
reply.writeNoException();
return true;
}
case GET_FOCUSED_STACK_ID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int focusedStackId=getFocusedStackId();
reply.writeNoException();
reply.writeInt(focusedStackId);
return true;
}
case SET_FOCUSED_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
setFocusedTask(taskId);
reply.writeNoException();
return true;
}
case REGISTER_TASK_STACK_LISTENER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
registerTaskStackListener(ITaskStackListener.Stub.asInterface(token));
reply.writeNoException();
return true;
}
case GET_TASK_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean onlyRoot=data.readInt() != 0;
int res=token != null ? getTaskForActivity(token,onlyRoot) : -1;
reply.writeNoException();
reply.writeInt(res);
return true;
}
case GET_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
int userId=data.readInt();
boolean stable=data.readInt() != 0;
ContentProviderHolder cph=getContentProvider(app,name,userId,stable);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case GET_CONTENT_PROVIDER_EXTERNAL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String name=data.readString();
int userId=data.readInt();
IBinder token=data.readStrongBinder();
ContentProviderHolder cph=getContentProviderExternal(name,userId,token);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case PUBLISH_CONTENT_PROVIDERS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
ArrayList<ContentProviderHolder> providers=data.createTypedArrayList(ContentProviderHolder.CREATOR);
publishContentProviders(app,providers);
reply.writeNoException();
return true;
}
case REF_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
int stable=data.readInt();
int unstable=data.readInt();
boolean res=refContentProvider(b,stable,unstable);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case UNSTABLE_PROVIDER_DIED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
unstableProviderDied(b);
reply.writeNoException();
return true;
}
case APP_NOT_RESPONDING_VIA_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
appNotRespondingViaProvider(b);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
boolean stable=data.readInt() != 0;
removeContentProvider(b,stable);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_EXTERNAL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String name=data.readString();
IBinder token=data.readStrongBinder();
removeContentProviderExternal(name,token);
reply.writeNoException();
return true;
}
case GET_RUNNING_SERVICE_CONTROL_PANEL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName comp=ComponentName.CREATOR.createFromParcel(data);
PendingIntent pi=getRunningServiceControlPanel(comp);
reply.writeNoException();
PendingIntent.writePendingIntentOrNullToParcel(pi,reply);
return true;
}
case START_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
String callingPackage=data.readString();
int userId=data.readInt();
ComponentName cn=startService(app,service,resolvedType,callingPackage,userId);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
int userId=data.readInt();
int res=stopService(app,service,resolvedType,userId);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case STOP_SERVICE_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
boolean res=stopServiceToken(className,token,startId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SET_SERVICE_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int id=data.readInt();
Notification notification=null;
if (data.readInt() != 0) {
notification=Notification.CREATOR.createFromParcel(data);
}
boolean removeNotification=data.readInt() != 0;
setServiceForeground(className,token,id,notification,removeNotification);
reply.writeNoException();
return true;
}
case BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IBinder token=data.readStrongBinder();
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
int fl=data.readInt();
String callingPackage=data.readString();
int userId=data.readInt();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
int res=bindService(app,token,service,resolvedType,conn,fl,callingPackage,userId);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
boolean res=unbindService(conn);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case PUBLISH_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder service=data.readStrongBinder();
publishService(token,intent,service);
reply.writeNoException();
return true;
}
case UNBIND_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean doRebind=data.readInt() != 0;
unbindFinished(token,intent,doRebind);
reply.writeNoException();
return true;
}
case SERVICE_DONE_EXECUTING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int type=data.readInt();
int startId=data.readInt();
int res=data.readInt();
serviceDoneExecuting(token,type,startId,res);
reply.writeNoException();
return true;
}
case START_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
String profileFile=data.readString();
int fl=data.readInt();
Bundle arguments=data.readBundle();
IBinder b=data.readStrongBinder();
IInstrumentationWatcher w=IInstrumentationWatcher.Stub.asInterface(b);
b=data.readStrongBinder();
IUiAutomationConnection c=IUiAutomationConnection.Stub.asInterface(b);
int userId=data.readInt();
String abiOverride=data.readString();
boolean res=startInstrumentation(className,profileFile,fl,arguments,w,c,userId,abiOverride);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int resultCode=data.readInt();
Bundle results=data.readBundle();
finishInstrumentation(app,resultCode,results);
reply.writeNoException();
return true;
}
case GET_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=getConfiguration();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case UPDATE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updateConfiguration(config);
reply.writeNoException();
return true;
}
case SET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int requestedOrientation=data.readInt();
setRequestedOrientation(token,requestedOrientation);
reply.writeNoException();
return true;
}
case GET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int req=getRequestedOrientation(token);
reply.writeNoException();
reply.writeInt(req);
return true;
}
case GET_ACTIVITY_CLASS_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getActivityClassForToken(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_PACKAGE_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reply.writeNoException();
reply.writeString(getPackageForToken(token));
return true;
}
case GET_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int type=data.readInt();
String packageName=data.readString();
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
Intent[] requestIntents;
String[] requestResolvedTypes;
if (data.readInt() != 0) {
requestIntents=data.createTypedArray(Intent.CREATOR);
requestResolvedTypes=data.createStringArray();
}
 else {
requestIntents=null;
requestResolvedTypes=null;
}
int fl=data.readInt();
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
IIntentSender res=getIntentSender(type,packageName,token,resultWho,requestCode,requestIntents,requestResolvedTypes,fl,options,userId);
reply.writeNoException();
reply.writeStrongBinder(res != null ? res.asBinder() : null);
return true;
}
case CANCEL_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
cancelIntentSender(r);
reply.writeNoException();
return true;
}
case GET_PACKAGE_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String res=getPackageForIntentSender(r);
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_UID_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
int res=getUidForIntentSender(r);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case HANDLE_INCOMING_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int callingPid=data.readInt();
int callingUid=data.readInt();
int userId=data.readInt();
boolean allowAll=data.readInt() != 0;
boolean requireFull=data.readInt() != 0;
String name=data.readString();
String callerPackage=data.readString();
int res=handleIncomingUser(callingPid,callingUid,userId,allowAll,requireFull,name,callerPackage);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case SET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int max=data.readInt();
setProcessLimit(max);
reply.writeNoException();
return true;
}
case GET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int limit=getProcessLimit();
reply.writeNoException();
reply.writeInt(limit);
return true;
}
case SET_PROCESS_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int pid=data.readInt();
boolean isForeground=data.readInt() != 0;
setProcessForeground(token,pid,isForeground);
reply.writeNoException();
return true;
}
case CHECK_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
int res=checkPermission(perm,pid,uid);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_PERMISSION_WITH_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
IBinder token=data.readStrongBinder();
int res=checkPermissionWithToken(perm,pid,uid,token);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int pid=data.readInt();
int uid=data.readInt();
int mode=data.readInt();
int userId=data.readInt();
IBinder callerToken=data.readStrongBinder();
int res=checkUriPermission(uri,pid,uid,mode,userId,callerToken);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CLEAR_APP_DATA_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IPackageDataObserver observer=IPackageDataObserver.Stub.asInterface(data.readStrongBinder());
int userId=data.readInt();
boolean res=clearApplicationUserData(packageName,observer,userId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int userId=data.readInt();
grantUriPermission(app,targetPkg,uri,mode,userId);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int userId=data.readInt();
revokeUriPermission(app,uri,mode,userId);
reply.writeNoException();
return true;
}
case TAKE_PERSISTABLE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int userId=data.readInt();
takePersistableUriPermission(uri,mode,userId);
reply.writeNoException();
return true;
}
case RELEASE_PERSISTABLE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int userId=data.readInt();
releasePersistableUriPermission(uri,mode,userId);
reply.writeNoException();
return true;
}
case GET_PERSISTED_URI_PERMISSIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final String packageName=data.readString();
final boolean incoming=data.readInt() != 0;
final ParceledListSlice<UriPermission> perms=getPersistedUriPermissions(packageName,incoming);
reply.writeNoException();
perms.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
return true;
}
case GET_GRANTED_URI_PERMISSIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final String packageName=data.readString();
final int userId=data.readInt();
final ParceledListSlice<UriPermission> perms=getGrantedUriPermissions(packageName,userId);
reply.writeNoException();
perms.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
return true;
}
case CLEAR_GRANTED_URI_PERMISSIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final String packageName=data.readString();
final int userId=data.readInt();
clearGrantedUriPermissions(packageName,userId);
reply.writeNoException();
return true;
}
case SHOW_WAITING_FOR_DEBUGGER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
boolean waiting=data.readInt() != 0;
showWaitingForDebugger(app,waiting);
reply.writeNoException();
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.MemoryInfo mi=new ActivityManager.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
case UNHANDLED_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
unhandledBack();
reply.writeNoException();
return true;
}
case OPEN_CONTENT_URI_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.parse(data.readString());
ParcelFileDescriptor pfd=openContentUri(uri);
reply.writeNoException();
if (pfd != null) {
reply.writeInt(1);
pfd.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case SET_LOCK_SCREEN_SHOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
setLockScreenShown(data.readInt() != 0);
reply.writeNoException();
return true;
}
case SET_DEBUG_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pn=data.readString();
boolean wfd=data.readInt() != 0;
boolean per=data.readInt() != 0;
setDebugApp(pn,wfd,per);
reply.writeNoException();
return true;
}
case SET_ALWAYS_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setAlwaysFinish(enabled);
reply.writeNoException();
return true;
}
case SET_ACTIVITY_CONTROLLER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityController watcher=IActivityController.Stub.asInterface(data.readStrongBinder());
boolean imAMonkey=data.readInt() != 0;
setActivityController(watcher,imAMonkey);
reply.writeNoException();
return true;
}
case SET_LENIENT_BACKGROUND_CHECK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setLenientBackgroundCheck(enabled);
reply.writeNoException();
return true;
}
case GET_MEMORY_TRIM_LEVEL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int level=getMemoryTrimLevel();
reply.writeNoException();
reply.writeInt(level);
return true;
}
case ENTER_SAFE_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
enterSafeMode();
reply.writeNoException();
return true;
}
case NOTE_WAKEUP_ALARM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
int sourceUid=data.readInt();
String sourcePkg=data.readString();
String tag=data.readString();
noteWakeupAlarm(is,sourceUid,sourcePkg,tag);
reply.writeNoException();
return true;
}
case NOTE_ALARM_START_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
int sourceUid=data.readInt();
String tag=data.readString();
noteAlarmStart(is,sourceUid,tag);
reply.writeNoException();
return true;
}
case NOTE_ALARM_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
int sourceUid=data.readInt();
String tag=data.readString();
noteAlarmFinish(is,sourceUid,tag);
reply.writeNoException();
return true;
}
case KILL_PIDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
String reason=data.readString();
boolean secure=data.readInt() != 0;
boolean res=killPids(pids,reason,secure);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case KILL_PROCESSES_BELOW_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String reason=data.readString();
boolean res=killProcessesBelowForeground(reason);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case HANDLE_APPLICATION_CRASH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
ApplicationErrorReport.CrashInfo ci=new ApplicationErrorReport.CrashInfo(data);
handleApplicationCrash(app,ci);
reply.writeNoException();
return true;
}
case HANDLE_APPLICATION_WTF_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
String tag=data.readString();
boolean system=data.readInt() != 0;
ApplicationErrorReport.CrashInfo ci=new ApplicationErrorReport.CrashInfo(data);
boolean res=handleApplicationWtf(app,tag,system,ci);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case HANDLE_APPLICATION_STRICT_MODE_VIOLATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
int violationMask=data.readInt();
StrictMode.ViolationInfo info=new StrictMode.ViolationInfo(data);
handleApplicationStrictModeViolation(app,violationMask,info);
reply.writeNoException();
return true;
}
case SIGNAL_PERSISTENT_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int sig=data.readInt();
signalPersistentProcesses(sig);
reply.writeNoException();
return true;
}
case KILL_BACKGROUND_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
int userId=data.readInt();
killBackgroundProcesses(packageName,userId);
reply.writeNoException();
return true;
}
case KILL_ALL_BACKGROUND_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
killAllBackgroundProcesses();
reply.writeNoException();
return true;
}
case KILL_PACKAGE_DEPENDENTS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
int userId=data.readInt();
killPackageDependents(packageName,userId);
reply.writeNoException();
return true;
}
case FORCE_STOP_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
int userId=data.readInt();
forceStopPackage(packageName,userId);
reply.writeNoException();
return true;
}
case GET_MY_MEMORY_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.RunningAppProcessInfo info=new ActivityManager.RunningAppProcessInfo();
getMyMemoryState(info);
reply.writeNoException();
info.writeToParcel(reply,0);
return true;
}
case GET_DEVICE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ConfigurationInfo config=getDeviceConfigurationInfo();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case PROFILE_CONTROL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
int userId=data.readInt();
boolean start=data.readInt() != 0;
int profileType=data.readInt();
ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
boolean res=profileControl(process,userId,start,profilerInfo,profileType);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHUTDOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=shutdown(data.readInt());
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case STOP_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopAppSwitches();
reply.writeNoException();
return true;
}
case RESUME_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
resumeAppSwitches();
reply.writeNoException();
return true;
}
case PEEK_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
String callingPackage=data.readString();
IBinder binder=peekService(service,resolvedType,callingPackage);
reply.writeNoException();
reply.writeStrongBinder(binder);
return true;
}
case START_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
int backupRestoreMode=data.readInt();
boolean success=bindBackupAgent(info,backupRestoreMode);
reply.writeNoException();
reply.writeInt(success ? 1 : 0);
return true;
}
case BACKUP_AGENT_CREATED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IBinder agent=data.readStrongBinder();
backupAgentCreated(packageName,agent);
reply.writeNoException();
return true;
}
case UNBIND_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
unbindBackupAgent(info);
reply.writeNoException();
return true;
}
case ADD_PACKAGE_DEPENDENCY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
addPackageDependency(packageName);
reply.writeNoException();
return true;
}
case KILL_APPLICATION_WITH_APPID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
int appid=data.readInt();
String reason=data.readString();
killApplicationWithAppId(pkg,appid,reason);
reply.writeNoException();
return true;
}
case CLOSE_SYSTEM_DIALOGS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String reason=data.readString();
closeSystemDialogs(reason);
reply.writeNoException();
return true;
}
case GET_PROCESS_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
Debug.MemoryInfo[] res=getProcessMemoryInfo(pids);
reply.writeNoException();
reply.writeTypedArray(res,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
return true;
}
case KILL_APPLICATION_PROCESS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String processName=data.readString();
int uid=data.readInt();
killApplicationProcess(processName,uid);
reply.writeNoException();
return true;
}
case OVERRIDE_PENDING_TRANSITION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String packageName=data.readString();
int enterAnim=data.readInt();
int exitAnim=data.readInt();
overridePendingTransition(token,packageName,enterAnim,exitAnim);
reply.writeNoException();
return true;
}
case IS_USER_A_MONKEY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean areThey=isUserAMonkey();
reply.writeNoException();
reply.writeInt(areThey ? 1 : 0);
return true;
}
case SET_USER_IS_MONKEY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean monkey=(data.readInt() == 1);
setUserIsMonkey(monkey);
reply.writeNoException();
return true;
}
case FINISH_HEAVY_WEIGHT_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
finishHeavyWeightApp();
reply.writeNoException();
return true;
}
case IS_IMMERSIVE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean isit=isImmersive(token);
reply.writeNoException();
reply.writeInt(isit ? 1 : 0);
return true;
}
case IS_TOP_OF_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
final boolean isTopOfTask=isTopOfTask(token);
reply.writeNoException();
reply.writeInt(isTopOfTask ? 1 : 0);
return true;
}
case CONVERT_FROM_TRANSLUCENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean converted=convertFromTranslucent(token);
reply.writeNoException();
reply.writeInt(converted ? 1 : 0);
return true;
}
case CONVERT_TO_TRANSLUCENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
final Bundle bundle;
if (data.readInt() == 0) {
bundle=null;
}
 else {
bundle=data.readBundle();
}
final ActivityOptions options=ActivityOptions.fromBundle(bundle);
boolean converted=convertToTranslucent(token,options);
reply.writeNoException();
reply.writeInt(converted ? 1 : 0);
return true;
}
case GET_ACTIVITY_OPTIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
final ActivityOptions options=getActivityOptions(token);
reply.writeNoException();
reply.writeBundle(options == null ? null : options.toBundle());
return true;
}
case SET_IMMERSIVE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean imm=data.readInt() == 1;
setImmersive(token,imm);
reply.writeNoException();
return true;
}
case IS_TOP_ACTIVITY_IMMERSIVE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean isit=isTopActivityImmersive();
reply.writeNoException();
reply.writeInt(isit ? 1 : 0);
return true;
}
case CRASH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int uid=data.readInt();
int initialPid=data.readInt();
String packageName=data.readString();
String message=data.readString();
crashApplication(uid,initialPid,packageName,message);
reply.writeNoException();
return true;
}
case GET_PROVIDER_MIME_TYPE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int userId=data.readInt();
String type=getProviderMimeType(uri,userId);
reply.writeNoException();
reply.writeString(type);
return true;
}
case NEW_URI_PERMISSION_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String name=data.readString();
IBinder perm=newUriPermissionOwner(name);
reply.writeNoException();
reply.writeStrongBinder(perm);
return true;
}
case GET_URI_PERMISSION_OWNER_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder activityToken=data.readStrongBinder();
IBinder perm=getUriPermissionOwnerForActivity(activityToken);
reply.writeNoException();
reply.writeStrongBinder(perm);
return true;
}
case GRANT_URI_PERMISSION_FROM_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder owner=data.readStrongBinder();
int fromUid=data.readInt();
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int sourceUserId=data.readInt();
int targetUserId=data.readInt();
grantUriPermissionFromOwner(owner,fromUid,targetPkg,uri,mode,sourceUserId,targetUserId);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_FROM_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder owner=data.readStrongBinder();
Uri uri=null;
if (data.readInt() != 0) {
uri=Uri.CREATOR.createFromParcel(data);
}
int mode=data.readInt();
int userId=data.readInt();
revokeUriPermissionFromOwner(owner,uri,mode,userId);
reply.writeNoException();
return true;
}
case CHECK_GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int callingUid=data.readInt();
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int modeFlags=data.readInt();
int userId=data.readInt();
int res=checkGrantUriPermission(callingUid,targetPkg,uri,modeFlags,userId);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case DUMP_HEAP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
int userId=data.readInt();
boolean managed=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? ParcelFileDescriptor.CREATOR.createFromParcel(data) : null;
boolean res=dumpHeap(process,userId,managed,path,fd);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case START_ACTIVITIES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String callingPackage=data.readString();
Intent[] intents=data.createTypedArray(Intent.CREATOR);
String[] resolvedTypes=data.createStringArray();
IBinder resultTo=data.readStrongBinder();
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
int result=startActivities(app,callingPackage,intents,resolvedTypes,resultTo,options,userId);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case GET_FRONT_ACTIVITY_SCREEN_COMPAT_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int mode=getFrontActivityScreenCompatMode();
reply.writeNoException();
reply.writeInt(mode);
return true;
}
case SET_FRONT_ACTIVITY_SCREEN_COMPAT_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int mode=data.readInt();
setFrontActivityScreenCompatMode(mode);
reply.writeNoException();
reply.writeInt(mode);
return true;
}
case GET_PACKAGE_SCREEN_COMPAT_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
int mode=getPackageScreenCompatMode(pkg);
reply.writeNoException();
reply.writeInt(mode);
return true;
}
case SET_PACKAGE_SCREEN_COMPAT_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
int mode=data.readInt();
setPackageScreenCompatMode(pkg,mode);
reply.writeNoException();
return true;
}
case SWITCH_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userid=data.readInt();
boolean result=switchUser(userid);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case START_USER_IN_BACKGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userid=data.readInt();
boolean result=startUserInBackground(userid);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case UNLOCK_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userId=data.readInt();
byte[] token=data.createByteArray();
byte[] secret=data.createByteArray();
boolean result=unlockUser(userId,token,secret);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case STOP_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userid=data.readInt();
boolean force=data.readInt() != 0;
IStopUserCallback callback=IStopUserCallback.Stub.asInterface(data.readStrongBinder());
int result=stopUser(userid,force,callback);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case GET_CURRENT_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
UserInfo userInfo=getCurrentUser();
reply.writeNoException();
userInfo.writeToParcel(reply,0);
return true;
}
case IS_USER_RUNNING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userid=data.readInt();
int _flags=data.readInt();
boolean result=isUserRunning(userid,_flags);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case GET_RUNNING_USER_IDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] result=getRunningUserIds();
reply.writeNoException();
reply.writeIntArray(result);
return true;
}
case REMOVE_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
boolean result=removeTask(taskId);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case REGISTER_PROCESS_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IProcessObserver observer=IProcessObserver.Stub.asInterface(data.readStrongBinder());
registerProcessObserver(observer);
return true;
}
case UNREGISTER_PROCESS_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IProcessObserver observer=IProcessObserver.Stub.asInterface(data.readStrongBinder());
unregisterProcessObserver(observer);
return true;
}
case REGISTER_UID_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IUidObserver observer=IUidObserver.Stub.asInterface(data.readStrongBinder());
int which=data.readInt();
registerUidObserver(observer,which);
return true;
}
case UNREGISTER_UID_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IUidObserver observer=IUidObserver.Stub.asInterface(data.readStrongBinder());
unregisterUidObserver(observer);
return true;
}
case GET_PACKAGE_ASK_SCREEN_COMPAT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
boolean ask=getPackageAskScreenCompat(pkg);
reply.writeNoException();
reply.writeInt(ask ? 1 : 0);
return true;
}
case SET_PACKAGE_ASK_SCREEN_COMPAT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
boolean ask=data.readInt() != 0;
setPackageAskScreenCompat(pkg,ask);
reply.writeNoException();
return true;
}
case IS_INTENT_SENDER_TARGETED_TO_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
boolean res=isIntentSenderTargetedToPackage(r);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case IS_INTENT_SENDER_AN_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
boolean res=isIntentSenderAnActivity(r);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GET_INTENT_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
Intent intent=getIntentForIntentSender(r);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GET_TAG_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String prefix=data.readString();
String tag=getTagForIntentSender(r,prefix);
reply.writeNoException();
reply.writeString(tag);
return true;
}
case UPDATE_PERSISTENT_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updatePersistentConfiguration(config);
reply.writeNoException();
return true;
}
case GET_PROCESS_PSS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
long[] pss=getProcessPss(pids);
reply.writeNoException();
reply.writeLongArray(pss);
return true;
}
case SHOW_BOOT_MESSAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
CharSequence msg=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
boolean always=data.readInt() != 0;
showBootMessage(msg,always);
reply.writeNoException();
return true;
}
case KEYGUARD_WAITING_FOR_ACTIVITY_DRAWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
keyguardWaitingForActivityDrawn();
reply.writeNoException();
return true;
}
case KEYGUARD_GOING_AWAY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
keyguardGoingAway(data.readInt() != 0,data.readInt() != 0);
reply.writeNoException();
return true;
}
case SHOULD_UP_RECREATE_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String destAffinity=data.readString();
boolean res=shouldUpRecreateTask(token,destAffinity);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case NAVIGATE_UP_TO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent target=Intent.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
Intent resultData=null;
if (data.readInt() != 0) {
resultData=Intent.CREATOR.createFromParcel(data);
}
boolean res=navigateUpTo(token,target,resultCode,resultData);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GET_LAUNCHED_FROM_UID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int res=getLaunchedFromUid(token);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case GET_LAUNCHED_FROM_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=getLaunchedFromPackage(token);
reply.writeNoException();
reply.writeString(res);
return true;
}
case REGISTER_USER_SWITCH_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IUserSwitchObserver observer=IUserSwitchObserver.Stub.asInterface(data.readStrongBinder());
registerUserSwitchObserver(observer);
reply.writeNoException();
return true;
}
case UNREGISTER_USER_SWITCH_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IUserSwitchObserver observer=IUserSwitchObserver.Stub.asInterface(data.readStrongBinder());
unregisterUserSwitchObserver(observer);
reply.writeNoException();
return true;
}
case REQUEST_BUG_REPORT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int bugreportType=data.readInt();
requestBugReport(bugreportType);
reply.writeNoException();
return true;
}
case INPUT_DISPATCHING_TIMED_OUT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int pid=data.readInt();
boolean aboveSystem=data.readInt() != 0;
String reason=data.readString();
long res=inputDispatchingTimedOut(pid,aboveSystem,reason);
reply.writeNoException();
reply.writeLong(res);
return true;
}
case GET_ASSIST_CONTEXT_EXTRAS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int requestType=data.readInt();
Bundle res=getAssistContextExtras(requestType);
reply.writeNoException();
reply.writeBundle(res);
return true;
}
case REQUEST_ASSIST_CONTEXT_EXTRAS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int requestType=data.readInt();
IResultReceiver receiver=IResultReceiver.Stub.asInterface(data.readStrongBinder());
IBinder activityToken=data.readStrongBinder();
boolean res=requestAssistContextExtras(requestType,receiver,activityToken);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REPORT_ASSIST_CONTEXT_EXTRAS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle extras=data.readBundle();
AssistStructure structure=AssistStructure.CREATOR.createFromParcel(data);
AssistContent content=AssistContent.CREATOR.createFromParcel(data);
Uri referrer=data.readInt() != 0 ? Uri.CREATOR.createFromParcel(data) : null;
reportAssistContextExtras(token,extras,structure,content,referrer);
reply.writeNoException();
return true;
}
case LAUNCH_ASSIST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
int requestType=data.readInt();
String hint=data.readString();
int userHandle=data.readInt();
Bundle args=data.readBundle();
boolean res=launchAssistIntent(intent,requestType,hint,userHandle,args);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case IS_SCREEN_CAPTURE_ALLOWED_ON_CURRENT_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=isAssistDataAllowedOnCurrentActivity();
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHOW_ASSIST_FROM_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle args=data.readBundle();
boolean res=showAssistFromActivity(token,args);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case KILL_UID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int appId=data.readInt();
int userId=data.readInt();
String reason=data.readString();
killUid(appId,userId,reason);
reply.writeNoException();
return true;
}
case HANG_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
boolean allowRestart=data.readInt() != 0;
hang(who,allowRestart);
reply.writeNoException();
return true;
}
case REPORT_ACTIVITY_FULLY_DRAWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reportActivityFullyDrawn(token);
reply.writeNoException();
return true;
}
case NOTIFY_ACTIVITY_DRAWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
notifyActivityDrawn(token);
reply.writeNoException();
return true;
}
case RESTART_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
restart();
reply.writeNoException();
return true;
}
case PERFORM_IDLE_MAINTENANCE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
performIdleMaintenance();
reply.writeNoException();
return true;
}
case CREATE_VIRTUAL_ACTIVITY_CONTAINER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder parentActivityToken=data.readStrongBinder();
IActivityContainerCallback callback=IActivityContainerCallback.Stub.asInterface(data.readStrongBinder());
IActivityContainer activityContainer=createVirtualActivityContainer(parentActivityToken,callback);
reply.writeNoException();
if (activityContainer != null) {
reply.writeInt(1);
reply.writeStrongBinder(activityContainer.asBinder());
}
 else {
reply.writeInt(0);
}
return true;
}
case DELETE_ACTIVITY_CONTAINER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityContainer activityContainer=IActivityContainer.Stub.asInterface(data.readStrongBinder());
deleteActivityContainer(activityContainer);
reply.writeNoException();
return true;
}
case CREATE_STACK_ON_DISPLAY:
{
data.enforceInterface(IActivityManager.descriptor);
int displayId=data.readInt();
IActivityContainer activityContainer=createStackOnDisplay(displayId);
reply.writeNoException();
if (activityContainer != null) {
reply.writeInt(1);
reply.writeStrongBinder(activityContainer.asBinder());
}
 else {
reply.writeInt(0);
}
return true;
}
case GET_ACTIVITY_DISPLAY_ID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder activityToken=data.readStrongBinder();
int displayId=getActivityDisplayId(activityToken);
reply.writeNoException();
reply.writeInt(displayId);
return true;
}
case START_LOCK_TASK_BY_TASK_ID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int taskId=data.readInt();
startLockTaskMode(taskId);
reply.writeNoException();
return true;
}
case START_LOCK_TASK_BY_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
startLockTaskMode(token);
reply.writeNoException();
return true;
}
case START_LOCK_TASK_BY_CURRENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
startLockTaskModeOnCurrent();
reply.writeNoException();
return true;
}
case STOP_LOCK_TASK_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopLockTaskMode();
reply.writeNoException();
return true;
}
case STOP_LOCK_TASK_BY_CURRENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopLockTaskModeOnCurrent();
reply.writeNoException();
return true;
}
case IS_IN_LOCK_TASK_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean isInLockTaskMode=isInLockTaskMode();
reply.writeNoException();
reply.writeInt(isInLockTaskMode ? 1 : 0);
return true;
}
case GET_LOCK_TASK_MODE_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int lockTaskModeState=getLockTaskModeState();
reply.writeNoException();
reply.writeInt(lockTaskModeState);
return true;
}
case SHOW_LOCK_TASK_ESCAPE_MESSAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
showLockTaskEscapeMessage(token);
reply.writeNoException();
return true;
}
case SET_TASK_DESCRIPTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ActivityManager.TaskDescription values=ActivityManager.TaskDescription.CREATOR.createFromParcel(data);
setTaskDescription(token,values);
reply.writeNoException();
return true;
}
case SET_TASK_RESIZEABLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int taskId=data.readInt();
final int resizeableMode=data.readInt();
setTaskResizeable(taskId,resizeableMode);
reply.writeNoException();
return true;
}
case RESIZE_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
int resizeMode=data.readInt();
Rect r=Rect.CREATOR.createFromParcel(data);
resizeTask(taskId,r,resizeMode);
reply.writeNoException();
return true;
}
case GET_TASK_BOUNDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
Rect r=getTaskBounds(taskId);
reply.writeNoException();
r.writeToParcel(reply,0);
return true;
}
case GET_TASK_DESCRIPTION_ICON_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String filename=data.readString();
int userId=data.readInt();
Bitmap icon=getTaskDescriptionIcon(filename,userId);
reply.writeNoException();
if (icon == null) {
reply.writeInt(0);
}
 else {
reply.writeInt(1);
icon.writeToParcel(reply,0);
}
return true;
}
case START_IN_PLACE_ANIMATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final Bundle bundle;
if (data.readInt() == 0) {
bundle=null;
}
 else {
bundle=data.readBundle();
}
final ActivityOptions options=ActivityOptions.fromBundle(bundle);
startInPlaceAnimationOnFrontMostApplication(options);
reply.writeNoException();
return true;
}
case REQUEST_VISIBLE_BEHIND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean enable=data.readInt() > 0;
boolean success=requestVisibleBehind(token,enable);
reply.writeNoException();
reply.writeInt(success ? 1 : 0);
return true;
}
case IS_BACKGROUND_VISIBLE_BEHIND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
final boolean enabled=isBackgroundVisibleBehind(token);
reply.writeNoException();
reply.writeInt(enabled ? 1 : 0);
return true;
}
case BACKGROUND_RESOURCES_RELEASED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
backgroundResourcesReleased(token);
reply.writeNoException();
return true;
}
case NOTIFY_LAUNCH_TASK_BEHIND_COMPLETE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
notifyLaunchTaskBehindComplete(token);
reply.writeNoException();
return true;
}
case NOTIFY_ENTER_ANIMATION_COMPLETE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
notifyEnterAnimationComplete(token);
reply.writeNoException();
return true;
}
case BOOT_ANIMATION_COMPLETE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
bootAnimationComplete();
reply.writeNoException();
return true;
}
case NOTIFY_CLEARTEXT_NETWORK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int uid=data.readInt();
final byte[] firstPacket=data.createByteArray();
notifyCleartextNetwork(uid,firstPacket);
reply.writeNoException();
return true;
}
case SET_DUMP_HEAP_DEBUG_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String procName=data.readString();
int uid=data.readInt();
long maxMemSize=data.readLong();
String reportPackage=data.readString();
setDumpHeapDebugLimit(procName,uid,maxMemSize,reportPackage);
reply.writeNoException();
return true;
}
case DUMP_HEAP_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String path=data.readString();
dumpHeapFinished(path);
reply.writeNoException();
return true;
}
case SET_VOICE_KEEP_AWAKE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IVoiceInteractionSession session=IVoiceInteractionSession.Stub.asInterface(data.readStrongBinder());
boolean keepAwake=data.readInt() != 0;
setVoiceKeepAwake(session,keepAwake);
reply.writeNoException();
return true;
}
case UPDATE_LOCK_TASK_PACKAGES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userId=data.readInt();
String[] packages=data.readStringArray();
updateLockTaskPackages(userId,packages);
reply.writeNoException();
return true;
}
case UPDATE_DEVICE_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
updateDeviceOwner(packageName);
reply.writeNoException();
return true;
}
case GET_PACKAGE_PROCESS_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
String callingPackage=data.readString();
int res=getPackageProcessState(pkg,callingPackage);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case SET_PROCESS_MEMORY_TRIM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
int userId=data.readInt();
int level=data.readInt();
boolean res=setProcessMemoryTrimLevel(process,userId,level);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case IS_ROOT_VOICE_INTERACTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean res=isRootVoiceInteraction(token);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case START_BINDER_TRACKING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=startBinderTracking();
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case STOP_BINDER_TRACKING_AND_DUMP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ParcelFileDescriptor fd=data.readInt() != 0 ? ParcelFileDescriptor.CREATOR.createFromParcel(data) : null;
boolean res=stopBinderTrackingAndDump(fd);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GET_ACTIVITY_STACK_ID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int stackId=getActivityStackId(token);
reply.writeNoException();
reply.writeInt(stackId);
return true;
}
case EXIT_FREEFORM_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
exitFreeformMode(token);
reply.writeNoException();
return true;
}
case REPORT_SIZE_CONFIGURATIONS:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int[] horizontal=readIntArray(data);
int[] vertical=readIntArray(data);
int[] smallest=readIntArray(data);
reportSizeConfigurations(token,horizontal,vertical,smallest);
return true;
}
case SUPPRESS_RESIZE_CONFIG_CHANGES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean suppress=data.readInt() == 1;
suppressResizeConfigChanges(suppress);
reply.writeNoException();
return true;
}
case MOVE_TASKS_TO_FULLSCREEN_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int stackId=data.readInt();
final boolean onTop=data.readInt() == 1;
moveTasksToFullscreenStack(stackId,onTop);
reply.writeNoException();
return true;
}
case GET_APP_START_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int uid=data.readInt();
final String pkg=data.readString();
int res=getAppStartMode(uid,pkg);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case IN_MULTI_WINDOW_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
final boolean inMultiWindow=inMultiWindow(token);
reply.writeNoException();
reply.writeInt(inMultiWindow ? 1 : 0);
return true;
}
case IN_PICTURE_IN_PICTURE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
final boolean inPip=inPictureInPicture(token);
reply.writeNoException();
reply.writeInt(inPip ? 1 : 0);
return true;
}
case ENTER_PICTURE_IN_PICTURE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
enterPictureInPicture(token);
reply.writeNoException();
return true;
}
case SET_VR_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
final boolean enable=data.readInt() == 1;
setVrMode(token,enable);
reply.writeNoException();
return true;
}
case IS_APP_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int userHandle=data.readInt();
final boolean isForeground=isAppForeground(userHandle);
reply.writeNoException();
reply.writeInt(isForeground ? 1 : 0);
return true;
}
case NOTIFY_PINNED_STACK_ANIMATION_ENDED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
reply.writeNoException();
return true;
}
case REMOVE_STACK:
{
data.enforceInterface(IActivityManager.descriptor);
final int stackId=data.readInt();
removeStack(stackId);
reply.writeNoException();
return true;
}
}
return super.onTransact(code,data,reply,flags);
}",0.9996946564885496
192595,"public void setActivityController(IActivityController watcher) throws RemoteException {
  Parcel data=Parcel.obtain();
  Parcel reply=Parcel.obtain();
  data.writeInterfaceToken(IActivityManager.descriptor);
  data.writeStrongBinder(watcher != null ? watcher.asBinder() : null);
  mRemote.transact(SET_ACTIVITY_CONTROLLER_TRANSACTION,data,reply,0);
  reply.readException();
  data.recycle();
  reply.recycle();
}","public void setActivityController(IActivityController watcher,boolean imAMonkey) throws RemoteException {
  Parcel data=Parcel.obtain();
  Parcel reply=Parcel.obtain();
  data.writeInterfaceToken(IActivityManager.descriptor);
  data.writeStrongBinder(watcher != null ? watcher.asBinder() : null);
  data.writeInt(imAMonkey ? 1 : 0);
  mRemote.transact(SET_ACTIVITY_CONTROLLER_TRANSACTION,data,reply,0);
  reply.readException();
  data.recycle();
  reply.recycle();
}",0.938496583143508
192596,public void setActivityController(IActivityController watcher) throws RemoteException ;,"public void setActivityController(IActivityController watcher,boolean imAMonkey) throws RemoteException ;",0.90625
192597,"void dumpProcessesLocked(FileDescriptor fd,PrintWriter pw,String[] args,int opti,boolean dumpAll,String dumpPackage){
  boolean needSep=false;
  boolean printedAnything=false;
  int numPers=0;
  pw.println(""String_Node_Str"");
  if (dumpAll) {
    final int NP=mProcessNames.getMap().size();
    for (int ip=0; ip < NP; ip++) {
      SparseArray<ProcessRecord> procs=mProcessNames.getMap().valueAt(ip);
      final int NA=procs.size();
      for (int ia=0; ia < NA; ia++) {
        ProcessRecord r=procs.valueAt(ia);
        if (dumpPackage != null && !r.pkgList.containsKey(dumpPackage)) {
          continue;
        }
        if (!needSep) {
          pw.println(""String_Node_Str"");
          needSep=true;
          printedAnything=true;
        }
        pw.print(r.persistent ? ""String_Node_Str"" : ""String_Node_Str"");
        pw.print(""String_Node_Str"");
        pw.print(procs.keyAt(ia));
        pw.print(""String_Node_Str"");
        pw.println(r);
        r.dump(pw,""String_Node_Str"");
        if (r.persistent) {
          numPers++;
        }
      }
    }
  }
  if (mIsolatedProcesses.size() > 0) {
    boolean printed=false;
    for (int i=0; i < mIsolatedProcesses.size(); i++) {
      ProcessRecord r=mIsolatedProcesses.valueAt(i);
      if (dumpPackage != null && !r.pkgList.containsKey(dumpPackage)) {
        continue;
      }
      if (!printed) {
        if (needSep) {
          pw.println();
        }
        pw.println(""String_Node_Str"");
        printedAnything=true;
        printed=true;
        needSep=true;
      }
      pw.println(String.format(""String_Node_Str"",""String_Node_Str"",i,r.toString()));
    }
  }
  if (mActiveUids.size() > 0) {
    if (dumpUids(pw,dumpPackage,mActiveUids,""String_Node_Str"",needSep)) {
      printedAnything=needSep=true;
    }
  }
  if (mValidateUids.size() > 0) {
    if (dumpUids(pw,dumpPackage,mValidateUids,""String_Node_Str"",needSep)) {
      printedAnything=needSep=true;
    }
  }
  if (mLruProcesses.size() > 0) {
    if (needSep) {
      pw.println();
    }
    pw.print(""String_Node_Str"");
    pw.print(mLruProcesses.size());
    pw.print(""String_Node_Str"");
    pw.print(mLruProcesses.size() - mLruProcessActivityStart);
    pw.print(""String_Node_Str"");
    pw.print(mLruProcesses.size() - mLruProcessServiceStart);
    pw.println(""String_Node_Str"");
    dumpProcessOomList(pw,this,mLruProcesses,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false,dumpPackage);
    needSep=true;
    printedAnything=true;
  }
  if (dumpAll || dumpPackage != null) {
synchronized (mPidsSelfLocked) {
      boolean printed=false;
      for (int i=0; i < mPidsSelfLocked.size(); i++) {
        ProcessRecord r=mPidsSelfLocked.valueAt(i);
        if (dumpPackage != null && !r.pkgList.containsKey(dumpPackage)) {
          continue;
        }
        if (!printed) {
          if (needSep)           pw.println();
          needSep=true;
          pw.println(""String_Node_Str"");
          printed=true;
          printedAnything=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(mPidsSelfLocked.keyAt(i));
        pw.print(""String_Node_Str"");
        pw.println(mPidsSelfLocked.valueAt(i));
      }
    }
  }
  if (mForegroundProcesses.size() > 0) {
synchronized (mPidsSelfLocked) {
      boolean printed=false;
      for (int i=0; i < mForegroundProcesses.size(); i++) {
        ProcessRecord r=mPidsSelfLocked.get(mForegroundProcesses.valueAt(i).pid);
        if (dumpPackage != null && (r == null || !r.pkgList.containsKey(dumpPackage))) {
          continue;
        }
        if (!printed) {
          if (needSep)           pw.println();
          needSep=true;
          pw.println(""String_Node_Str"");
          printed=true;
          printedAnything=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(mForegroundProcesses.keyAt(i));
        pw.print(""String_Node_Str"");
        pw.println(mForegroundProcesses.valueAt(i));
      }
    }
  }
  if (mPersistentStartingProcesses.size() > 0) {
    if (needSep)     pw.println();
    needSep=true;
    printedAnything=true;
    pw.println(""String_Node_Str"");
    dumpProcessList(pw,this,mPersistentStartingProcesses,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",dumpPackage);
  }
  if (mRemovedProcesses.size() > 0) {
    if (needSep)     pw.println();
    needSep=true;
    printedAnything=true;
    pw.println(""String_Node_Str"");
    dumpProcessList(pw,this,mRemovedProcesses,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",dumpPackage);
  }
  if (mProcessesOnHold.size() > 0) {
    if (needSep)     pw.println();
    needSep=true;
    printedAnything=true;
    pw.println(""String_Node_Str"");
    dumpProcessList(pw,this,mProcessesOnHold,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",dumpPackage);
  }
  needSep=dumpProcessesToGc(fd,pw,args,opti,needSep,dumpAll,dumpPackage);
  needSep=mAppErrors.dumpLocked(fd,pw,needSep,dumpPackage);
  if (needSep) {
    printedAnything=true;
  }
  if (dumpPackage == null) {
    pw.println();
    needSep=false;
    mUserController.dump(pw,dumpAll);
  }
  if (mHomeProcess != null && (dumpPackage == null || mHomeProcess.pkgList.containsKey(dumpPackage))) {
    if (needSep) {
      pw.println();
      needSep=false;
    }
    pw.println(""String_Node_Str"" + mHomeProcess);
  }
  if (mPreviousProcess != null && (dumpPackage == null || mPreviousProcess.pkgList.containsKey(dumpPackage))) {
    if (needSep) {
      pw.println();
      needSep=false;
    }
    pw.println(""String_Node_Str"" + mPreviousProcess);
  }
  if (dumpAll) {
    StringBuilder sb=new StringBuilder(128);
    sb.append(""String_Node_Str"");
    TimeUtils.formatDuration(mPreviousProcessVisibleTime,sb);
    pw.println(sb);
  }
  if (mHeavyWeightProcess != null && (dumpPackage == null || mHeavyWeightProcess.pkgList.containsKey(dumpPackage))) {
    if (needSep) {
      pw.println();
      needSep=false;
    }
    pw.println(""String_Node_Str"" + mHeavyWeightProcess);
  }
  if (dumpPackage == null) {
    pw.println(""String_Node_Str"" + mConfiguration);
  }
  if (dumpAll) {
    pw.println(""String_Node_Str"" + getFocusedStack().mConfigWillChange);
    if (mCompatModePackages.getPackages().size() > 0) {
      boolean printed=false;
      for (      Map.Entry<String,Integer> entry : mCompatModePackages.getPackages().entrySet()) {
        String pkg=entry.getKey();
        int mode=entry.getValue();
        if (dumpPackage != null && !dumpPackage.equals(pkg)) {
          continue;
        }
        if (!printed) {
          pw.println(""String_Node_Str"");
          printed=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(pkg);
        pw.print(""String_Node_Str"");
        pw.print(mode);
        pw.println();
      }
    }
  }
  if (dumpPackage == null) {
    pw.println(""String_Node_Str"" + PowerManagerInternal.wakefulnessToString(mWakefulness));
    pw.println(""String_Node_Str"" + mSleepTokens);
    pw.println(""String_Node_Str"" + mSleeping + ""String_Node_Str""+ lockScreenShownToString());
    pw.println(""String_Node_Str"" + mShuttingDown + ""String_Node_Str""+ mTestPssMode);
    if (mRunningVoice != null) {
      pw.println(""String_Node_Str"" + mRunningVoice);
      pw.println(""String_Node_Str"" + mVoiceWakeLock);
    }
  }
  if (mDebugApp != null || mOrigDebugApp != null || mDebugTransient || mOrigWaitForDebugger) {
    if (dumpPackage == null || dumpPackage.equals(mDebugApp) || dumpPackage.equals(mOrigDebugApp)) {
      if (needSep) {
        pw.println();
        needSep=false;
      }
      pw.println(""String_Node_Str"" + mDebugApp + ""String_Node_Str""+ mOrigDebugApp+ ""String_Node_Str""+ mDebugTransient+ ""String_Node_Str""+ mOrigWaitForDebugger);
    }
  }
  if (mCurAppTimeTracker != null) {
    mCurAppTimeTracker.dumpWithHeader(pw,""String_Node_Str"",true);
  }
  if (mMemWatchProcesses.getMap().size() > 0) {
    pw.println(""String_Node_Str"");
    final ArrayMap<String,SparseArray<Pair<Long,String>>> procs=mMemWatchProcesses.getMap();
    for (int i=0; i < procs.size(); i++) {
      final String proc=procs.keyAt(i);
      final SparseArray<Pair<Long,String>> uids=procs.valueAt(i);
      for (int j=0; j < uids.size(); j++) {
        if (needSep) {
          pw.println();
          needSep=false;
        }
        StringBuilder sb=new StringBuilder();
        sb.append(""String_Node_Str"").append(proc).append('/');
        UserHandle.formatUid(sb,uids.keyAt(j));
        Pair<Long,String> val=uids.valueAt(j);
        sb.append(""String_Node_Str"");
        DebugUtils.sizeValueToString(val.first,sb);
        if (val.second != null) {
          sb.append(""String_Node_Str"").append(val.second);
        }
        pw.println(sb.toString());
      }
    }
    pw.print(""String_Node_Str"");
    pw.println(mMemWatchDumpProcName);
    pw.print(""String_Node_Str"");
    pw.println(mMemWatchDumpFile);
    pw.print(""String_Node_Str"");
    pw.print(mMemWatchDumpPid);
    pw.print(""String_Node_Str"");
    pw.println(mMemWatchDumpUid);
  }
  if (mTrackAllocationApp != null) {
    if (dumpPackage == null || dumpPackage.equals(mTrackAllocationApp)) {
      if (needSep) {
        pw.println();
        needSep=false;
      }
      pw.println(""String_Node_Str"" + mTrackAllocationApp);
    }
  }
  if (mProfileApp != null || mProfileProc != null || mProfileFile != null || mProfileFd != null) {
    if (dumpPackage == null || dumpPackage.equals(mProfileApp)) {
      if (needSep) {
        pw.println();
        needSep=false;
      }
      pw.println(""String_Node_Str"" + mProfileApp + ""String_Node_Str""+ mProfileProc);
      pw.println(""String_Node_Str"" + mProfileFile + ""String_Node_Str""+ mProfileFd);
      pw.println(""String_Node_Str"" + mSamplingInterval + ""String_Node_Str""+ mAutoStopProfiler);
      pw.println(""String_Node_Str"" + mProfileType);
    }
  }
  if (mNativeDebuggingApp != null) {
    if (dumpPackage == null || dumpPackage.equals(mNativeDebuggingApp)) {
      if (needSep) {
        pw.println();
        needSep=false;
      }
      pw.println(""String_Node_Str"" + mNativeDebuggingApp);
    }
  }
  if (dumpPackage == null) {
    if (mAlwaysFinishActivities || mLenientBackgroundCheck || mController != null) {
      pw.println(""String_Node_Str"" + mAlwaysFinishActivities + ""String_Node_Str""+ mLenientBackgroundCheck+ ""String_Node_Str""+ mController);
    }
    if (dumpAll) {
      pw.println(""String_Node_Str"" + numPers);
      pw.println(""String_Node_Str"" + mProcessesReady + ""String_Node_Str""+ mSystemReady+ ""String_Node_Str""+ mBooted+ ""String_Node_Str""+ mFactoryTest);
      pw.println(""String_Node_Str"" + mBooting + ""String_Node_Str""+ mCallFinishBooting+ ""String_Node_Str""+ mBootAnimationComplete);
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(mLastPowerCheckRealtime,pw);
      pw.println(""String_Node_Str"");
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(mLastPowerCheckUptime,pw);
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"" + mStackSupervisor.mGoingToSleep);
      pw.println(""String_Node_Str"" + mStackSupervisor.mLaunchingActivity);
      pw.println(""String_Node_Str"" + mAdjSeq + ""String_Node_Str""+ mLruSeq);
      pw.println(""String_Node_Str"" + mNumNonCachedProcs + ""String_Node_Str""+ mLruProcesses.size()+ ""String_Node_Str""+ ""String_Node_Str""+ mNumCachedHiddenProcs+ ""String_Node_Str""+ mNumServiceProcs+ ""String_Node_Str""+ mNewNumServiceProcs);
      pw.println(""String_Node_Str"" + mAllowLowerMemLevel + ""String_Node_Str""+ mLastMemoryLevel+ ""String_Node_Str""+ mLastNumProcesses);
      long now=SystemClock.uptimeMillis();
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(now,mLastIdleTime,pw);
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(getLowRamTimeSinceIdle(now),pw);
      pw.println();
    }
  }
  if (!printedAnything) {
    pw.println(""String_Node_Str"");
  }
}","void dumpProcessesLocked(FileDescriptor fd,PrintWriter pw,String[] args,int opti,boolean dumpAll,String dumpPackage){
  boolean needSep=false;
  boolean printedAnything=false;
  int numPers=0;
  pw.println(""String_Node_Str"");
  if (dumpAll) {
    final int NP=mProcessNames.getMap().size();
    for (int ip=0; ip < NP; ip++) {
      SparseArray<ProcessRecord> procs=mProcessNames.getMap().valueAt(ip);
      final int NA=procs.size();
      for (int ia=0; ia < NA; ia++) {
        ProcessRecord r=procs.valueAt(ia);
        if (dumpPackage != null && !r.pkgList.containsKey(dumpPackage)) {
          continue;
        }
        if (!needSep) {
          pw.println(""String_Node_Str"");
          needSep=true;
          printedAnything=true;
        }
        pw.print(r.persistent ? ""String_Node_Str"" : ""String_Node_Str"");
        pw.print(""String_Node_Str"");
        pw.print(procs.keyAt(ia));
        pw.print(""String_Node_Str"");
        pw.println(r);
        r.dump(pw,""String_Node_Str"");
        if (r.persistent) {
          numPers++;
        }
      }
    }
  }
  if (mIsolatedProcesses.size() > 0) {
    boolean printed=false;
    for (int i=0; i < mIsolatedProcesses.size(); i++) {
      ProcessRecord r=mIsolatedProcesses.valueAt(i);
      if (dumpPackage != null && !r.pkgList.containsKey(dumpPackage)) {
        continue;
      }
      if (!printed) {
        if (needSep) {
          pw.println();
        }
        pw.println(""String_Node_Str"");
        printedAnything=true;
        printed=true;
        needSep=true;
      }
      pw.println(String.format(""String_Node_Str"",""String_Node_Str"",i,r.toString()));
    }
  }
  if (mActiveUids.size() > 0) {
    if (dumpUids(pw,dumpPackage,mActiveUids,""String_Node_Str"",needSep)) {
      printedAnything=needSep=true;
    }
  }
  if (mValidateUids.size() > 0) {
    if (dumpUids(pw,dumpPackage,mValidateUids,""String_Node_Str"",needSep)) {
      printedAnything=needSep=true;
    }
  }
  if (mLruProcesses.size() > 0) {
    if (needSep) {
      pw.println();
    }
    pw.print(""String_Node_Str"");
    pw.print(mLruProcesses.size());
    pw.print(""String_Node_Str"");
    pw.print(mLruProcesses.size() - mLruProcessActivityStart);
    pw.print(""String_Node_Str"");
    pw.print(mLruProcesses.size() - mLruProcessServiceStart);
    pw.println(""String_Node_Str"");
    dumpProcessOomList(pw,this,mLruProcesses,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false,dumpPackage);
    needSep=true;
    printedAnything=true;
  }
  if (dumpAll || dumpPackage != null) {
synchronized (mPidsSelfLocked) {
      boolean printed=false;
      for (int i=0; i < mPidsSelfLocked.size(); i++) {
        ProcessRecord r=mPidsSelfLocked.valueAt(i);
        if (dumpPackage != null && !r.pkgList.containsKey(dumpPackage)) {
          continue;
        }
        if (!printed) {
          if (needSep)           pw.println();
          needSep=true;
          pw.println(""String_Node_Str"");
          printed=true;
          printedAnything=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(mPidsSelfLocked.keyAt(i));
        pw.print(""String_Node_Str"");
        pw.println(mPidsSelfLocked.valueAt(i));
      }
    }
  }
  if (mForegroundProcesses.size() > 0) {
synchronized (mPidsSelfLocked) {
      boolean printed=false;
      for (int i=0; i < mForegroundProcesses.size(); i++) {
        ProcessRecord r=mPidsSelfLocked.get(mForegroundProcesses.valueAt(i).pid);
        if (dumpPackage != null && (r == null || !r.pkgList.containsKey(dumpPackage))) {
          continue;
        }
        if (!printed) {
          if (needSep)           pw.println();
          needSep=true;
          pw.println(""String_Node_Str"");
          printed=true;
          printedAnything=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(mForegroundProcesses.keyAt(i));
        pw.print(""String_Node_Str"");
        pw.println(mForegroundProcesses.valueAt(i));
      }
    }
  }
  if (mPersistentStartingProcesses.size() > 0) {
    if (needSep)     pw.println();
    needSep=true;
    printedAnything=true;
    pw.println(""String_Node_Str"");
    dumpProcessList(pw,this,mPersistentStartingProcesses,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",dumpPackage);
  }
  if (mRemovedProcesses.size() > 0) {
    if (needSep)     pw.println();
    needSep=true;
    printedAnything=true;
    pw.println(""String_Node_Str"");
    dumpProcessList(pw,this,mRemovedProcesses,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",dumpPackage);
  }
  if (mProcessesOnHold.size() > 0) {
    if (needSep)     pw.println();
    needSep=true;
    printedAnything=true;
    pw.println(""String_Node_Str"");
    dumpProcessList(pw,this,mProcessesOnHold,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",dumpPackage);
  }
  needSep=dumpProcessesToGc(fd,pw,args,opti,needSep,dumpAll,dumpPackage);
  needSep=mAppErrors.dumpLocked(fd,pw,needSep,dumpPackage);
  if (needSep) {
    printedAnything=true;
  }
  if (dumpPackage == null) {
    pw.println();
    needSep=false;
    mUserController.dump(pw,dumpAll);
  }
  if (mHomeProcess != null && (dumpPackage == null || mHomeProcess.pkgList.containsKey(dumpPackage))) {
    if (needSep) {
      pw.println();
      needSep=false;
    }
    pw.println(""String_Node_Str"" + mHomeProcess);
  }
  if (mPreviousProcess != null && (dumpPackage == null || mPreviousProcess.pkgList.containsKey(dumpPackage))) {
    if (needSep) {
      pw.println();
      needSep=false;
    }
    pw.println(""String_Node_Str"" + mPreviousProcess);
  }
  if (dumpAll) {
    StringBuilder sb=new StringBuilder(128);
    sb.append(""String_Node_Str"");
    TimeUtils.formatDuration(mPreviousProcessVisibleTime,sb);
    pw.println(sb);
  }
  if (mHeavyWeightProcess != null && (dumpPackage == null || mHeavyWeightProcess.pkgList.containsKey(dumpPackage))) {
    if (needSep) {
      pw.println();
      needSep=false;
    }
    pw.println(""String_Node_Str"" + mHeavyWeightProcess);
  }
  if (dumpPackage == null) {
    pw.println(""String_Node_Str"" + mConfiguration);
  }
  if (dumpAll) {
    pw.println(""String_Node_Str"" + getFocusedStack().mConfigWillChange);
    if (mCompatModePackages.getPackages().size() > 0) {
      boolean printed=false;
      for (      Map.Entry<String,Integer> entry : mCompatModePackages.getPackages().entrySet()) {
        String pkg=entry.getKey();
        int mode=entry.getValue();
        if (dumpPackage != null && !dumpPackage.equals(pkg)) {
          continue;
        }
        if (!printed) {
          pw.println(""String_Node_Str"");
          printed=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(pkg);
        pw.print(""String_Node_Str"");
        pw.print(mode);
        pw.println();
      }
    }
  }
  if (dumpPackage == null) {
    pw.println(""String_Node_Str"" + PowerManagerInternal.wakefulnessToString(mWakefulness));
    pw.println(""String_Node_Str"" + mSleepTokens);
    pw.println(""String_Node_Str"" + mSleeping + ""String_Node_Str""+ lockScreenShownToString());
    pw.println(""String_Node_Str"" + mShuttingDown + ""String_Node_Str""+ mTestPssMode);
    if (mRunningVoice != null) {
      pw.println(""String_Node_Str"" + mRunningVoice);
      pw.println(""String_Node_Str"" + mVoiceWakeLock);
    }
  }
  if (mDebugApp != null || mOrigDebugApp != null || mDebugTransient || mOrigWaitForDebugger) {
    if (dumpPackage == null || dumpPackage.equals(mDebugApp) || dumpPackage.equals(mOrigDebugApp)) {
      if (needSep) {
        pw.println();
        needSep=false;
      }
      pw.println(""String_Node_Str"" + mDebugApp + ""String_Node_Str""+ mOrigDebugApp+ ""String_Node_Str""+ mDebugTransient+ ""String_Node_Str""+ mOrigWaitForDebugger);
    }
  }
  if (mCurAppTimeTracker != null) {
    mCurAppTimeTracker.dumpWithHeader(pw,""String_Node_Str"",true);
  }
  if (mMemWatchProcesses.getMap().size() > 0) {
    pw.println(""String_Node_Str"");
    final ArrayMap<String,SparseArray<Pair<Long,String>>> procs=mMemWatchProcesses.getMap();
    for (int i=0; i < procs.size(); i++) {
      final String proc=procs.keyAt(i);
      final SparseArray<Pair<Long,String>> uids=procs.valueAt(i);
      for (int j=0; j < uids.size(); j++) {
        if (needSep) {
          pw.println();
          needSep=false;
        }
        StringBuilder sb=new StringBuilder();
        sb.append(""String_Node_Str"").append(proc).append('/');
        UserHandle.formatUid(sb,uids.keyAt(j));
        Pair<Long,String> val=uids.valueAt(j);
        sb.append(""String_Node_Str"");
        DebugUtils.sizeValueToString(val.first,sb);
        if (val.second != null) {
          sb.append(""String_Node_Str"").append(val.second);
        }
        pw.println(sb.toString());
      }
    }
    pw.print(""String_Node_Str"");
    pw.println(mMemWatchDumpProcName);
    pw.print(""String_Node_Str"");
    pw.println(mMemWatchDumpFile);
    pw.print(""String_Node_Str"");
    pw.print(mMemWatchDumpPid);
    pw.print(""String_Node_Str"");
    pw.println(mMemWatchDumpUid);
  }
  if (mTrackAllocationApp != null) {
    if (dumpPackage == null || dumpPackage.equals(mTrackAllocationApp)) {
      if (needSep) {
        pw.println();
        needSep=false;
      }
      pw.println(""String_Node_Str"" + mTrackAllocationApp);
    }
  }
  if (mProfileApp != null || mProfileProc != null || mProfileFile != null || mProfileFd != null) {
    if (dumpPackage == null || dumpPackage.equals(mProfileApp)) {
      if (needSep) {
        pw.println();
        needSep=false;
      }
      pw.println(""String_Node_Str"" + mProfileApp + ""String_Node_Str""+ mProfileProc);
      pw.println(""String_Node_Str"" + mProfileFile + ""String_Node_Str""+ mProfileFd);
      pw.println(""String_Node_Str"" + mSamplingInterval + ""String_Node_Str""+ mAutoStopProfiler);
      pw.println(""String_Node_Str"" + mProfileType);
    }
  }
  if (mNativeDebuggingApp != null) {
    if (dumpPackage == null || dumpPackage.equals(mNativeDebuggingApp)) {
      if (needSep) {
        pw.println();
        needSep=false;
      }
      pw.println(""String_Node_Str"" + mNativeDebuggingApp);
    }
  }
  if (dumpPackage == null) {
    if (mAlwaysFinishActivities || mLenientBackgroundCheck) {
      pw.println(""String_Node_Str"" + mAlwaysFinishActivities + ""String_Node_Str""+ mLenientBackgroundCheck);
    }
    if (mController != null) {
      pw.println(""String_Node_Str"" + mController + ""String_Node_Str""+ mControllerIsAMonkey);
    }
    if (dumpAll) {
      pw.println(""String_Node_Str"" + numPers);
      pw.println(""String_Node_Str"" + mProcessesReady + ""String_Node_Str""+ mSystemReady+ ""String_Node_Str""+ mBooted+ ""String_Node_Str""+ mFactoryTest);
      pw.println(""String_Node_Str"" + mBooting + ""String_Node_Str""+ mCallFinishBooting+ ""String_Node_Str""+ mBootAnimationComplete);
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(mLastPowerCheckRealtime,pw);
      pw.println(""String_Node_Str"");
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(mLastPowerCheckUptime,pw);
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"" + mStackSupervisor.mGoingToSleep);
      pw.println(""String_Node_Str"" + mStackSupervisor.mLaunchingActivity);
      pw.println(""String_Node_Str"" + mAdjSeq + ""String_Node_Str""+ mLruSeq);
      pw.println(""String_Node_Str"" + mNumNonCachedProcs + ""String_Node_Str""+ mLruProcesses.size()+ ""String_Node_Str""+ ""String_Node_Str""+ mNumCachedHiddenProcs+ ""String_Node_Str""+ mNumServiceProcs+ ""String_Node_Str""+ mNewNumServiceProcs);
      pw.println(""String_Node_Str"" + mAllowLowerMemLevel + ""String_Node_Str""+ mLastMemoryLevel+ ""String_Node_Str""+ mLastNumProcesses);
      long now=SystemClock.uptimeMillis();
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(now,mLastIdleTime,pw);
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(getLowRamTimeSinceIdle(now),pw);
      pw.println();
    }
  }
  if (!printedAnything) {
    pw.println(""String_Node_Str"");
  }
}",0.9488423094766142
192598,"@Override public void setActivityController(IActivityController controller){
  enforceCallingPermission(android.Manifest.permission.SET_ACTIVITY_WATCHER,""String_Node_Str"");
synchronized (this) {
    mController=controller;
    Watchdog.getInstance().setActivityController(controller);
  }
}","@Override public void setActivityController(IActivityController controller,boolean imAMonkey){
  enforceCallingPermission(android.Manifest.permission.SET_ACTIVITY_WATCHER,""String_Node_Str"");
synchronized (this) {
    mController=controller;
    mControllerIsAMonkey=imAMonkey;
    Watchdog.getInstance().setActivityController(controller);
  }
}",0.9148264984227128
192599,"@Override public boolean isUserAMonkey(){
synchronized (this) {
    return (mUserIsMonkey || mController != null);
  }
}","@Override public boolean isUserAMonkey(){
synchronized (this) {
    return (mUserIsMonkey || (mController != null && mControllerIsAMonkey));
  }
}",0.9022556390977444
192600,"@SmallTest public void testSET_ACTIVITY_WATCHER(){
  try {
    mAm.setActivityController(null);
    fail(""String_Node_Str"" + ""String_Node_Str"");
  }
 catch (  SecurityException e) {
  }
catch (  RemoteException e) {
    fail(""String_Node_Str"");
  }
}","@SmallTest public void testSET_ACTIVITY_WATCHER(){
  try {
    mAm.setActivityController(null,false);
    fail(""String_Node_Str"" + ""String_Node_Str"");
  }
 catch (  SecurityException e) {
  }
catch (  RemoteException e) {
    fail(""String_Node_Str"");
  }
}",0.9881422924901184
192601,"public void setHideSensitiveForIntrinsicHeight(boolean hideSensitive){
  mHideSensitiveForIntrinsicHeight=hideSensitive;
}","public void setHideSensitiveForIntrinsicHeight(boolean hideSensitive){
  mHideSensitiveForIntrinsicHeight=hideSensitive;
  if (mIsSummaryWithChildren) {
    List<ExpandableNotificationRow> notificationChildren=mChildrenContainer.getNotificationChildren();
    for (int i=0; i < notificationChildren.size(); i++) {
      ExpandableNotificationRow child=notificationChildren.get(i);
      child.setHideSensitiveForIntrinsicHeight(hideSensitive);
    }
  }
}",0.4228769497400346
192602,"void run() throws RemoteException {
  try {
    printMessageForState();
    mAm.setActivityController(this);
    mState=STATE_NORMAL;
    InputStreamReader converter=new InputStreamReader(System.in);
    BufferedReader in=new BufferedReader(converter);
    String line;
    while ((line=in.readLine()) != null) {
      boolean addNewline=true;
      if (line.length() <= 0) {
        addNewline=false;
      }
 else       if (""String_Node_Str"".equals(line) || ""String_Node_Str"".equals(line)) {
        resumeController(RESULT_DEFAULT);
        break;
      }
 else       if (mState == STATE_CRASHED) {
        if (""String_Node_Str"".equals(line) || ""String_Node_Str"".equals(line)) {
          resumeController(RESULT_CRASH_DIALOG);
        }
 else         if (""String_Node_Str"".equals(line) || ""String_Node_Str"".equals(line)) {
          resumeController(RESULT_CRASH_KILL);
        }
 else {
          System.out.println(""String_Node_Str"" + line);
        }
      }
 else       if (mState == STATE_ANR) {
        if (""String_Node_Str"".equals(line) || ""String_Node_Str"".equals(line)) {
          resumeController(RESULT_ANR_DIALOG);
        }
 else         if (""String_Node_Str"".equals(line) || ""String_Node_Str"".equals(line)) {
          resumeController(RESULT_ANR_KILL);
        }
 else         if (""String_Node_Str"".equals(line) || ""String_Node_Str"".equals(line)) {
          resumeController(RESULT_ANR_WAIT);
        }
 else {
          System.out.println(""String_Node_Str"" + line);
        }
      }
 else       if (mState == STATE_EARLY_ANR) {
        if (""String_Node_Str"".equals(line) || ""String_Node_Str"".equals(line)) {
          resumeController(RESULT_EARLY_ANR_CONTINUE);
        }
 else         if (""String_Node_Str"".equals(line) || ""String_Node_Str"".equals(line)) {
          resumeController(RESULT_EARLY_ANR_KILL);
        }
 else {
          System.out.println(""String_Node_Str"" + line);
        }
      }
 else {
        System.out.println(""String_Node_Str"" + line);
      }
synchronized (this) {
        if (addNewline) {
          System.out.println(""String_Node_Str"");
        }
        printMessageForState();
      }
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
 finally {
    mAm.setActivityController(null);
  }
}","void run() throws RemoteException {
  try {
    printMessageForState();
    mAm.setActivityController(this,mMonkey);
    mState=STATE_NORMAL;
    InputStreamReader converter=new InputStreamReader(System.in);
    BufferedReader in=new BufferedReader(converter);
    String line;
    while ((line=in.readLine()) != null) {
      boolean addNewline=true;
      if (line.length() <= 0) {
        addNewline=false;
      }
 else       if (""String_Node_Str"".equals(line) || ""String_Node_Str"".equals(line)) {
        resumeController(RESULT_DEFAULT);
        break;
      }
 else       if (mState == STATE_CRASHED) {
        if (""String_Node_Str"".equals(line) || ""String_Node_Str"".equals(line)) {
          resumeController(RESULT_CRASH_DIALOG);
        }
 else         if (""String_Node_Str"".equals(line) || ""String_Node_Str"".equals(line)) {
          resumeController(RESULT_CRASH_KILL);
        }
 else {
          System.out.println(""String_Node_Str"" + line);
        }
      }
 else       if (mState == STATE_ANR) {
        if (""String_Node_Str"".equals(line) || ""String_Node_Str"".equals(line)) {
          resumeController(RESULT_ANR_DIALOG);
        }
 else         if (""String_Node_Str"".equals(line) || ""String_Node_Str"".equals(line)) {
          resumeController(RESULT_ANR_KILL);
        }
 else         if (""String_Node_Str"".equals(line) || ""String_Node_Str"".equals(line)) {
          resumeController(RESULT_ANR_WAIT);
        }
 else {
          System.out.println(""String_Node_Str"" + line);
        }
      }
 else       if (mState == STATE_EARLY_ANR) {
        if (""String_Node_Str"".equals(line) || ""String_Node_Str"".equals(line)) {
          resumeController(RESULT_EARLY_ANR_CONTINUE);
        }
 else         if (""String_Node_Str"".equals(line) || ""String_Node_Str"".equals(line)) {
          resumeController(RESULT_EARLY_ANR_KILL);
        }
 else {
          System.out.println(""String_Node_Str"" + line);
        }
      }
 else {
        System.out.println(""String_Node_Str"" + line);
      }
synchronized (this) {
        if (addNewline) {
          System.out.println(""String_Node_Str"");
        }
        printMessageForState();
      }
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
 finally {
    mAm.setActivityController(null,mMonkey);
  }
}",0.996474217717056
192603,"MyActivityController(String gdbPort){
  mGdbPort=gdbPort;
}","MyActivityController(String gdbPort,boolean monkey){
  mGdbPort=gdbPort;
  mMonkey=monkey;
}",0.7814569536423841
192604,"private void runMonitor() throws Exception {
  String opt;
  String gdbPort=null;
  while ((opt=nextOption()) != null) {
    if (opt.equals(""String_Node_Str"")) {
      gdbPort=nextArgRequired();
    }
 else {
      System.err.println(""String_Node_Str"" + opt);
      return;
    }
  }
  MyActivityController controller=new MyActivityController(gdbPort);
  controller.run();
}","private void runMonitor() throws Exception {
  String opt;
  String gdbPort=null;
  boolean monkey=false;
  while ((opt=nextOption()) != null) {
    if (opt.equals(""String_Node_Str"")) {
      gdbPort=nextArgRequired();
    }
 else     if (opt.equals(""String_Node_Str"")) {
      monkey=true;
    }
 else {
      System.err.println(""String_Node_Str"" + opt);
      return;
    }
  }
  MyActivityController controller=new MyActivityController(gdbPort,monkey);
  controller.run();
}",0.8789659224441834
192605,"/** 
 * Enable or disable monkey test mode. Setting test as ""monkey"" indicates to some applications that a test framework is running as a ""monkey"" type. Such applications may choose not to perform actions that do submits so to avoid allowing monkey tests from doing harm or performing annoying actions such as dialing 911 or posting messages to public forums, etc.
 * @param isSet True to set as monkey test. False to set as regular functional test (default).
 * @see {@link ActivityManager#isUserAMonkey()}
 */
public void setRunAsMonkey(boolean isSet){
  IActivityManager am=ActivityManagerNative.getDefault();
  if (am == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  try {
    if (isSet) {
      am.setActivityController(new DummyActivityController());
    }
 else {
      am.setActivityController(null);
    }
  }
 catch (  RemoteException e) {
    throw new RuntimeException(e);
  }
}","/** 
 * Enable or disable monkey test mode. Setting test as ""monkey"" indicates to some applications that a test framework is running as a ""monkey"" type. Such applications may choose not to perform actions that do submits so to avoid allowing monkey tests from doing harm or performing annoying actions such as dialing 911 or posting messages to public forums, etc.
 * @param isSet True to set as monkey test. False to set as regular functional test (default).
 * @see {@link ActivityManager#isUserAMonkey()}
 */
public void setRunAsMonkey(boolean isSet){
  IActivityManager am=ActivityManagerNative.getDefault();
  if (am == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  try {
    if (isSet) {
      am.setActivityController(new DummyActivityController(),true);
    }
 else {
      am.setActivityController(null,true);
    }
  }
 catch (  RemoteException e) {
    throw new RuntimeException(e);
  }
}",0.9945295404814004
192606,"@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case START_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IActivityManager.descriptor);
      IBinder b=data.readStrongBinder();
      IApplicationThread app=ApplicationThreadNative.asInterface(b);
      String callingPackage=data.readString();
      Intent intent=Intent.CREATOR.createFromParcel(data);
      String resolvedType=data.readString();
      IBinder resultTo=data.readStrongBinder();
      String resultWho=data.readString();
      int requestCode=data.readInt();
      int startFlags=data.readInt();
      ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
      Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
      int result=startActivity(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,profilerInfo,options);
      reply.writeNoException();
      reply.writeInt(result);
      return true;
    }
case START_ACTIVITY_AS_USER_TRANSACTION:
{
    data.enforceInterface(IActivityManager.descriptor);
    IBinder b=data.readStrongBinder();
    IApplicationThread app=ApplicationThreadNative.asInterface(b);
    String callingPackage=data.readString();
    Intent intent=Intent.CREATOR.createFromParcel(data);
    String resolvedType=data.readString();
    IBinder resultTo=data.readStrongBinder();
    String resultWho=data.readString();
    int requestCode=data.readInt();
    int startFlags=data.readInt();
    ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
    Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
    int userId=data.readInt();
    int result=startActivityAsUser(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,profilerInfo,options,userId);
    reply.writeNoException();
    reply.writeInt(result);
    return true;
  }
case START_ACTIVITY_AS_CALLER_TRANSACTION:
{
  data.enforceInterface(IActivityManager.descriptor);
  IBinder b=data.readStrongBinder();
  IApplicationThread app=ApplicationThreadNative.asInterface(b);
  String callingPackage=data.readString();
  Intent intent=Intent.CREATOR.createFromParcel(data);
  String resolvedType=data.readString();
  IBinder resultTo=data.readStrongBinder();
  String resultWho=data.readString();
  int requestCode=data.readInt();
  int startFlags=data.readInt();
  ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
  Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
  boolean ignoreTargetSecurity=data.readInt() != 0;
  int userId=data.readInt();
  int result=startActivityAsCaller(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,profilerInfo,options,ignoreTargetSecurity,userId);
  reply.writeNoException();
  reply.writeInt(result);
  return true;
}
case START_ACTIVITY_AND_WAIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String callingPackage=data.readString();
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder resultTo=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
int startFlags=data.readInt();
ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
WaitResult result=startActivityAndWait(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,profilerInfo,options,userId);
reply.writeNoException();
result.writeToParcel(reply,0);
return true;
}
case START_ACTIVITY_WITH_CONFIG_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String callingPackage=data.readString();
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder resultTo=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
int startFlags=data.readInt();
Configuration config=Configuration.CREATOR.createFromParcel(data);
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
int result=startActivityWithConfig(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,config,options,userId);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case START_ACTIVITY_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IntentSender intent=IntentSender.CREATOR.createFromParcel(data);
Intent fillInIntent=null;
if (data.readInt() != 0) {
fillInIntent=Intent.CREATOR.createFromParcel(data);
}
String resolvedType=data.readString();
IBinder resultTo=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
int flagsMask=data.readInt();
int flagsValues=data.readInt();
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int result=startActivityIntentSender(app,intent,fillInIntent,resolvedType,resultTo,resultWho,requestCode,flagsMask,flagsValues,options);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case START_VOICE_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String callingPackage=data.readString();
int callingPid=data.readInt();
int callingUid=data.readInt();
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IVoiceInteractionSession session=IVoiceInteractionSession.Stub.asInterface(data.readStrongBinder());
IVoiceInteractor interactor=IVoiceInteractor.Stub.asInterface(data.readStrongBinder());
int startFlags=data.readInt();
ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
int result=startVoiceActivity(callingPackage,callingPid,callingUid,intent,resolvedType,session,interactor,startFlags,profilerInfo,options,userId);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case START_LOCAL_VOICE_INTERACTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle options=data.readBundle();
startLocalVoiceInteraction(token,options);
reply.writeNoException();
return true;
}
case STOP_LOCAL_VOICE_INTERACTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
stopLocalVoiceInteraction(token);
reply.writeNoException();
return true;
}
case SUPPORTS_LOCAL_VOICE_INTERACTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean result=supportsLocalVoiceInteraction();
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case START_NEXT_MATCHING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder callingActivity=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
boolean result=startNextMatchingActivity(callingActivity,intent,options);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case START_ACTIVITY_FROM_RECENTS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int taskId=data.readInt();
final Bundle options=data.readInt() == 0 ? null : Bundle.CREATOR.createFromParcel(data);
final int result=startActivityFromRecents(taskId,options);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case FINISH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent resultData=null;
int resultCode=data.readInt();
if (data.readInt() != 0) {
resultData=Intent.CREATOR.createFromParcel(data);
}
int finishTask=data.readInt();
boolean res=finishActivity(token,resultCode,resultData,finishTask);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_SUB_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
finishSubActivity(token,resultWho,requestCode);
reply.writeNoException();
return true;
}
case FINISH_ACTIVITY_AFFINITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean res=finishActivityAffinity(token);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_VOICE_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IVoiceInteractionSession session=IVoiceInteractionSession.Stub.asInterface(data.readStrongBinder());
finishVoiceTask(session);
reply.writeNoException();
return true;
}
case RELEASE_ACTIVITY_INSTANCE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean res=releaseActivityInstance(token);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case RELEASE_SOME_ACTIVITIES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
releaseSomeActivities(app);
reply.writeNoException();
return true;
}
case WILL_ACTIVITY_BE_VISIBLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean res=willActivityBeVisible(token);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
String packageName=data.readString();
b=data.readStrongBinder();
IIntentReceiver rec=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
IntentFilter filter=IntentFilter.CREATOR.createFromParcel(data);
String perm=data.readString();
int userId=data.readInt();
Intent intent=registerReceiver(app,packageName,rec,filter,perm,userId);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case UNREGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
if (b == null) {
return true;
}
IIntentReceiver rec=IIntentReceiver.Stub.asInterface(b);
unregisterReceiver(rec);
reply.writeNoException();
return true;
}
case BROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
IIntentReceiver resultTo=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
String[] perms=data.readStringArray();
int appOp=data.readInt();
Bundle options=data.readBundle();
boolean serialized=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
int userId=data.readInt();
int res=broadcastIntent(app,intent,resolvedType,resultTo,resultCode,resultData,resultExtras,perms,appOp,options,serialized,sticky,userId);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
int userId=data.readInt();
unbroadcastIntent(app,intent,userId);
reply.writeNoException();
return true;
}
case FINISH_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean resultAbort=data.readInt() != 0;
int intentFlags=data.readInt();
if (who != null) {
finishReceiver(who,resultCode,resultData,resultExtras,resultAbort,intentFlags);
}
reply.writeNoException();
return true;
}
case ATTACH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
if (app != null) {
attachApplication(app);
}
reply.writeNoException();
return true;
}
case ACTIVITY_IDLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Configuration config=null;
if (data.readInt() != 0) {
config=Configuration.CREATOR.createFromParcel(data);
}
boolean stopProfiling=data.readInt() != 0;
if (token != null) {
activityIdle(token,config,stopProfiling);
}
reply.writeNoException();
return true;
}
case ACTIVITY_RESUMED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityResumed(token);
reply.writeNoException();
return true;
}
case ACTIVITY_PAUSED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityPaused(token);
reply.writeNoException();
return true;
}
case ACTIVITY_STOPPED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle map=data.readBundle();
PersistableBundle persistentState=data.readPersistableBundle();
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
activityStopped(token,map,persistentState,description);
reply.writeNoException();
return true;
}
case ACTIVITY_SLEPT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activitySlept(token);
reply.writeNoException();
return true;
}
case ACTIVITY_DESTROYED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityDestroyed(token);
reply.writeNoException();
return true;
}
case ACTIVITY_RELAUNCHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityRelaunched(token);
reply.writeNoException();
return true;
}
case GET_CALLING_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=token != null ? getCallingPackage(token) : null;
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_CALLING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getCallingActivity(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_APP_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String callingPackage=data.readString();
List<IAppTask> list=getAppTasks(callingPackage);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
IAppTask task=list.get(i);
reply.writeStrongBinder(task.asBinder());
}
return true;
}
case ADD_APP_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder activityToken=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
ActivityManager.TaskDescription descr=ActivityManager.TaskDescription.CREATOR.createFromParcel(data);
Bitmap thumbnail=Bitmap.CREATOR.createFromParcel(data);
int res=addAppTask(activityToken,intent,descr,thumbnail);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case GET_APP_TASK_THUMBNAIL_SIZE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Point size=getAppTaskThumbnailSize();
reply.writeNoException();
size.writeToParcel(reply,0);
return true;
}
case GET_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RunningTaskInfo> list=getTasks(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningTaskInfo info=list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_RECENT_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
int userId=data.readInt();
List<ActivityManager.RecentTaskInfo> list=getRecentTasks(maxNum,fl,userId);
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_TASK_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int id=data.readInt();
ActivityManager.TaskThumbnail taskThumbnail=getTaskThumbnail(id);
reply.writeNoException();
if (taskThumbnail != null) {
reply.writeInt(1);
taskThumbnail.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GET_SERVICES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RunningServiceInfo> list=getServices(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningServiceInfo info=list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_PROCESSES_IN_ERROR_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.ProcessErrorStateInfo> list=getProcessesInErrorState();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_APP_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.RunningAppProcessInfo> list=getRunningAppProcesses();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_EXTERNAL_APPLICATIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ApplicationInfo> list=getRunningExternalApplications();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case MOVE_TASK_TO_FRONT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
int fl=data.readInt();
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
moveTaskToFront(task,fl,options);
reply.writeNoException();
return true;
}
case MOVE_ACTIVITY_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean nonRoot=data.readInt() != 0;
boolean res=moveActivityTaskToBack(token,nonRoot);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case MOVE_TASK_BACKWARDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskBackwards(task);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
int stackId=data.readInt();
boolean toTop=data.readInt() != 0;
moveTaskToStack(taskId,stackId,toTop);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_DOCKED_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
int createMode=data.readInt();
boolean toTop=data.readInt() != 0;
boolean animate=data.readInt() != 0;
Rect bounds=null;
boolean hasBounds=data.readInt() != 0;
if (hasBounds) {
bounds=Rect.CREATOR.createFromParcel(data);
}
moveTaskToDockedStack(taskId,createMode,toTop,animate,bounds);
reply.writeNoException();
return true;
}
case MOVE_TOP_ACTIVITY_TO_PINNED_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int stackId=data.readInt();
final Rect r=Rect.CREATOR.createFromParcel(data);
final boolean res=moveTopActivityToPinnedStack(stackId,r);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case RESIZE_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int stackId=data.readInt();
final boolean hasRect=data.readInt() != 0;
Rect r=null;
if (hasRect) {
r=Rect.CREATOR.createFromParcel(data);
}
final boolean allowResizeInDockedMode=data.readInt() == 1;
final boolean preserveWindows=data.readInt() == 1;
final boolean animate=data.readInt() == 1;
resizeStack(stackId,r,allowResizeInDockedMode,preserveWindows,animate);
reply.writeNoException();
return true;
}
case RESIZE_DOCKED_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean hasBounds=data.readInt() != 0;
Rect bounds=null;
if (hasBounds) {
bounds=Rect.CREATOR.createFromParcel(data);
}
final boolean hasTempDockedTaskBounds=data.readInt() != 0;
Rect tempDockedTaskBounds=null;
if (hasTempDockedTaskBounds) {
tempDockedTaskBounds=Rect.CREATOR.createFromParcel(data);
}
final boolean hasTempDockedTaskInsetBounds=data.readInt() != 0;
Rect tempDockedTaskInsetBounds=null;
if (hasTempDockedTaskInsetBounds) {
tempDockedTaskInsetBounds=Rect.CREATOR.createFromParcel(data);
}
final boolean hasTempOtherTaskBounds=data.readInt() != 0;
Rect tempOtherTaskBounds=null;
if (hasTempOtherTaskBounds) {
tempOtherTaskBounds=Rect.CREATOR.createFromParcel(data);
}
final boolean hasTempOtherTaskInsetBounds=data.readInt() != 0;
Rect tempOtherTaskInsetBounds=null;
if (hasTempOtherTaskInsetBounds) {
tempOtherTaskInsetBounds=Rect.CREATOR.createFromParcel(data);
}
resizeDockedStack(bounds,tempDockedTaskBounds,tempDockedTaskInsetBounds,tempOtherTaskBounds,tempOtherTaskInsetBounds);
reply.writeNoException();
return true;
}
case POSITION_TASK_IN_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
int stackId=data.readInt();
int position=data.readInt();
positionTaskInStack(taskId,stackId,position);
reply.writeNoException();
return true;
}
case GET_ALL_STACK_INFOS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<StackInfo> list=getAllStackInfos();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_STACK_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int stackId=data.readInt();
StackInfo info=getStackInfo(stackId);
reply.writeNoException();
if (info != null) {
reply.writeInt(1);
info.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case IS_IN_HOME_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
boolean isInHomeStack=isInHomeStack(taskId);
reply.writeNoException();
reply.writeInt(isInHomeStack ? 1 : 0);
return true;
}
case SET_FOCUSED_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int stackId=data.readInt();
setFocusedStack(stackId);
reply.writeNoException();
return true;
}
case GET_FOCUSED_STACK_ID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int focusedStackId=getFocusedStackId();
reply.writeNoException();
reply.writeInt(focusedStackId);
return true;
}
case SET_FOCUSED_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
setFocusedTask(taskId);
reply.writeNoException();
return true;
}
case REGISTER_TASK_STACK_LISTENER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
registerTaskStackListener(ITaskStackListener.Stub.asInterface(token));
reply.writeNoException();
return true;
}
case GET_TASK_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean onlyRoot=data.readInt() != 0;
int res=token != null ? getTaskForActivity(token,onlyRoot) : -1;
reply.writeNoException();
reply.writeInt(res);
return true;
}
case GET_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
int userId=data.readInt();
boolean stable=data.readInt() != 0;
ContentProviderHolder cph=getContentProvider(app,name,userId,stable);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case GET_CONTENT_PROVIDER_EXTERNAL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String name=data.readString();
int userId=data.readInt();
IBinder token=data.readStrongBinder();
ContentProviderHolder cph=getContentProviderExternal(name,userId,token);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case PUBLISH_CONTENT_PROVIDERS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
ArrayList<ContentProviderHolder> providers=data.createTypedArrayList(ContentProviderHolder.CREATOR);
publishContentProviders(app,providers);
reply.writeNoException();
return true;
}
case REF_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
int stable=data.readInt();
int unstable=data.readInt();
boolean res=refContentProvider(b,stable,unstable);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case UNSTABLE_PROVIDER_DIED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
unstableProviderDied(b);
reply.writeNoException();
return true;
}
case APP_NOT_RESPONDING_VIA_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
appNotRespondingViaProvider(b);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
boolean stable=data.readInt() != 0;
removeContentProvider(b,stable);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_EXTERNAL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String name=data.readString();
IBinder token=data.readStrongBinder();
removeContentProviderExternal(name,token);
reply.writeNoException();
return true;
}
case GET_RUNNING_SERVICE_CONTROL_PANEL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName comp=ComponentName.CREATOR.createFromParcel(data);
PendingIntent pi=getRunningServiceControlPanel(comp);
reply.writeNoException();
PendingIntent.writePendingIntentOrNullToParcel(pi,reply);
return true;
}
case START_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
String callingPackage=data.readString();
int userId=data.readInt();
ComponentName cn=startService(app,service,resolvedType,callingPackage,userId);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
int userId=data.readInt();
int res=stopService(app,service,resolvedType,userId);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case STOP_SERVICE_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
boolean res=stopServiceToken(className,token,startId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SET_SERVICE_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int id=data.readInt();
Notification notification=null;
if (data.readInt() != 0) {
notification=Notification.CREATOR.createFromParcel(data);
}
boolean removeNotification=data.readInt() != 0;
setServiceForeground(className,token,id,notification,removeNotification);
reply.writeNoException();
return true;
}
case BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IBinder token=data.readStrongBinder();
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
int fl=data.readInt();
String callingPackage=data.readString();
int userId=data.readInt();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
int res=bindService(app,token,service,resolvedType,conn,fl,callingPackage,userId);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
boolean res=unbindService(conn);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case PUBLISH_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder service=data.readStrongBinder();
publishService(token,intent,service);
reply.writeNoException();
return true;
}
case UNBIND_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean doRebind=data.readInt() != 0;
unbindFinished(token,intent,doRebind);
reply.writeNoException();
return true;
}
case SERVICE_DONE_EXECUTING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int type=data.readInt();
int startId=data.readInt();
int res=data.readInt();
serviceDoneExecuting(token,type,startId,res);
reply.writeNoException();
return true;
}
case START_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
String profileFile=data.readString();
int fl=data.readInt();
Bundle arguments=data.readBundle();
IBinder b=data.readStrongBinder();
IInstrumentationWatcher w=IInstrumentationWatcher.Stub.asInterface(b);
b=data.readStrongBinder();
IUiAutomationConnection c=IUiAutomationConnection.Stub.asInterface(b);
int userId=data.readInt();
String abiOverride=data.readString();
boolean res=startInstrumentation(className,profileFile,fl,arguments,w,c,userId,abiOverride);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int resultCode=data.readInt();
Bundle results=data.readBundle();
finishInstrumentation(app,resultCode,results);
reply.writeNoException();
return true;
}
case GET_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=getConfiguration();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case UPDATE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updateConfiguration(config);
reply.writeNoException();
return true;
}
case SET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int requestedOrientation=data.readInt();
setRequestedOrientation(token,requestedOrientation);
reply.writeNoException();
return true;
}
case GET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int req=getRequestedOrientation(token);
reply.writeNoException();
reply.writeInt(req);
return true;
}
case GET_ACTIVITY_CLASS_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getActivityClassForToken(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_PACKAGE_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reply.writeNoException();
reply.writeString(getPackageForToken(token));
return true;
}
case GET_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int type=data.readInt();
String packageName=data.readString();
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
Intent[] requestIntents;
String[] requestResolvedTypes;
if (data.readInt() != 0) {
requestIntents=data.createTypedArray(Intent.CREATOR);
requestResolvedTypes=data.createStringArray();
}
 else {
requestIntents=null;
requestResolvedTypes=null;
}
int fl=data.readInt();
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
IIntentSender res=getIntentSender(type,packageName,token,resultWho,requestCode,requestIntents,requestResolvedTypes,fl,options,userId);
reply.writeNoException();
reply.writeStrongBinder(res != null ? res.asBinder() : null);
return true;
}
case CANCEL_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
cancelIntentSender(r);
reply.writeNoException();
return true;
}
case GET_PACKAGE_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String res=getPackageForIntentSender(r);
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_UID_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
int res=getUidForIntentSender(r);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case HANDLE_INCOMING_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int callingPid=data.readInt();
int callingUid=data.readInt();
int userId=data.readInt();
boolean allowAll=data.readInt() != 0;
boolean requireFull=data.readInt() != 0;
String name=data.readString();
String callerPackage=data.readString();
int res=handleIncomingUser(callingPid,callingUid,userId,allowAll,requireFull,name,callerPackage);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case SET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int max=data.readInt();
setProcessLimit(max);
reply.writeNoException();
return true;
}
case GET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int limit=getProcessLimit();
reply.writeNoException();
reply.writeInt(limit);
return true;
}
case SET_PROCESS_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int pid=data.readInt();
boolean isForeground=data.readInt() != 0;
setProcessForeground(token,pid,isForeground);
reply.writeNoException();
return true;
}
case CHECK_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
int res=checkPermission(perm,pid,uid);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_PERMISSION_WITH_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
IBinder token=data.readStrongBinder();
int res=checkPermissionWithToken(perm,pid,uid,token);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int pid=data.readInt();
int uid=data.readInt();
int mode=data.readInt();
int userId=data.readInt();
IBinder callerToken=data.readStrongBinder();
int res=checkUriPermission(uri,pid,uid,mode,userId,callerToken);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CLEAR_APP_DATA_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IPackageDataObserver observer=IPackageDataObserver.Stub.asInterface(data.readStrongBinder());
int userId=data.readInt();
boolean res=clearApplicationUserData(packageName,observer,userId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int userId=data.readInt();
grantUriPermission(app,targetPkg,uri,mode,userId);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int userId=data.readInt();
revokeUriPermission(app,uri,mode,userId);
reply.writeNoException();
return true;
}
case TAKE_PERSISTABLE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int userId=data.readInt();
takePersistableUriPermission(uri,mode,userId);
reply.writeNoException();
return true;
}
case RELEASE_PERSISTABLE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int userId=data.readInt();
releasePersistableUriPermission(uri,mode,userId);
reply.writeNoException();
return true;
}
case GET_PERSISTED_URI_PERMISSIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final String packageName=data.readString();
final boolean incoming=data.readInt() != 0;
final ParceledListSlice<UriPermission> perms=getPersistedUriPermissions(packageName,incoming);
reply.writeNoException();
perms.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
return true;
}
case GET_GRANTED_URI_PERMISSIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final String packageName=data.readString();
final int userId=data.readInt();
final ParceledListSlice<UriPermission> perms=getGrantedUriPermissions(packageName,userId);
reply.writeNoException();
perms.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
return true;
}
case CLEAR_GRANTED_URI_PERMISSIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final String packageName=data.readString();
final int userId=data.readInt();
clearGrantedUriPermissions(packageName,userId);
reply.writeNoException();
return true;
}
case SHOW_WAITING_FOR_DEBUGGER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
boolean waiting=data.readInt() != 0;
showWaitingForDebugger(app,waiting);
reply.writeNoException();
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.MemoryInfo mi=new ActivityManager.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
case UNHANDLED_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
unhandledBack();
reply.writeNoException();
return true;
}
case OPEN_CONTENT_URI_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.parse(data.readString());
ParcelFileDescriptor pfd=openContentUri(uri);
reply.writeNoException();
if (pfd != null) {
reply.writeInt(1);
pfd.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case SET_LOCK_SCREEN_SHOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
setLockScreenShown(data.readInt() != 0);
reply.writeNoException();
return true;
}
case SET_DEBUG_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pn=data.readString();
boolean wfd=data.readInt() != 0;
boolean per=data.readInt() != 0;
setDebugApp(pn,wfd,per);
reply.writeNoException();
return true;
}
case SET_ALWAYS_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setAlwaysFinish(enabled);
reply.writeNoException();
return true;
}
case SET_ACTIVITY_CONTROLLER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityController watcher=IActivityController.Stub.asInterface(data.readStrongBinder());
setActivityController(watcher);
reply.writeNoException();
return true;
}
case SET_LENIENT_BACKGROUND_CHECK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setLenientBackgroundCheck(enabled);
reply.writeNoException();
return true;
}
case GET_MEMORY_TRIM_LEVEL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int level=getMemoryTrimLevel();
reply.writeNoException();
reply.writeInt(level);
return true;
}
case ENTER_SAFE_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
enterSafeMode();
reply.writeNoException();
return true;
}
case NOTE_WAKEUP_ALARM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
int sourceUid=data.readInt();
String sourcePkg=data.readString();
String tag=data.readString();
noteWakeupAlarm(is,sourceUid,sourcePkg,tag);
reply.writeNoException();
return true;
}
case NOTE_ALARM_START_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
int sourceUid=data.readInt();
String tag=data.readString();
noteAlarmStart(is,sourceUid,tag);
reply.writeNoException();
return true;
}
case NOTE_ALARM_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
int sourceUid=data.readInt();
String tag=data.readString();
noteAlarmFinish(is,sourceUid,tag);
reply.writeNoException();
return true;
}
case KILL_PIDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
String reason=data.readString();
boolean secure=data.readInt() != 0;
boolean res=killPids(pids,reason,secure);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case KILL_PROCESSES_BELOW_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String reason=data.readString();
boolean res=killProcessesBelowForeground(reason);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case HANDLE_APPLICATION_CRASH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
ApplicationErrorReport.CrashInfo ci=new ApplicationErrorReport.CrashInfo(data);
handleApplicationCrash(app,ci);
reply.writeNoException();
return true;
}
case HANDLE_APPLICATION_WTF_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
String tag=data.readString();
boolean system=data.readInt() != 0;
ApplicationErrorReport.CrashInfo ci=new ApplicationErrorReport.CrashInfo(data);
boolean res=handleApplicationWtf(app,tag,system,ci);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case HANDLE_APPLICATION_STRICT_MODE_VIOLATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
int violationMask=data.readInt();
StrictMode.ViolationInfo info=new StrictMode.ViolationInfo(data);
handleApplicationStrictModeViolation(app,violationMask,info);
reply.writeNoException();
return true;
}
case SIGNAL_PERSISTENT_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int sig=data.readInt();
signalPersistentProcesses(sig);
reply.writeNoException();
return true;
}
case KILL_BACKGROUND_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
int userId=data.readInt();
killBackgroundProcesses(packageName,userId);
reply.writeNoException();
return true;
}
case KILL_ALL_BACKGROUND_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
killAllBackgroundProcesses();
reply.writeNoException();
return true;
}
case KILL_PACKAGE_DEPENDENTS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
int userId=data.readInt();
killPackageDependents(packageName,userId);
reply.writeNoException();
return true;
}
case FORCE_STOP_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
int userId=data.readInt();
forceStopPackage(packageName,userId);
reply.writeNoException();
return true;
}
case GET_MY_MEMORY_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.RunningAppProcessInfo info=new ActivityManager.RunningAppProcessInfo();
getMyMemoryState(info);
reply.writeNoException();
info.writeToParcel(reply,0);
return true;
}
case GET_DEVICE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ConfigurationInfo config=getDeviceConfigurationInfo();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case PROFILE_CONTROL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
int userId=data.readInt();
boolean start=data.readInt() != 0;
int profileType=data.readInt();
ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
boolean res=profileControl(process,userId,start,profilerInfo,profileType);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHUTDOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=shutdown(data.readInt());
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case STOP_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopAppSwitches();
reply.writeNoException();
return true;
}
case RESUME_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
resumeAppSwitches();
reply.writeNoException();
return true;
}
case PEEK_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
String callingPackage=data.readString();
IBinder binder=peekService(service,resolvedType,callingPackage);
reply.writeNoException();
reply.writeStrongBinder(binder);
return true;
}
case START_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
int backupRestoreMode=data.readInt();
boolean success=bindBackupAgent(info,backupRestoreMode);
reply.writeNoException();
reply.writeInt(success ? 1 : 0);
return true;
}
case BACKUP_AGENT_CREATED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IBinder agent=data.readStrongBinder();
backupAgentCreated(packageName,agent);
reply.writeNoException();
return true;
}
case UNBIND_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
unbindBackupAgent(info);
reply.writeNoException();
return true;
}
case ADD_PACKAGE_DEPENDENCY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
addPackageDependency(packageName);
reply.writeNoException();
return true;
}
case KILL_APPLICATION_WITH_APPID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
int appid=data.readInt();
String reason=data.readString();
killApplicationWithAppId(pkg,appid,reason);
reply.writeNoException();
return true;
}
case CLOSE_SYSTEM_DIALOGS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String reason=data.readString();
closeSystemDialogs(reason);
reply.writeNoException();
return true;
}
case GET_PROCESS_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
Debug.MemoryInfo[] res=getProcessMemoryInfo(pids);
reply.writeNoException();
reply.writeTypedArray(res,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
return true;
}
case KILL_APPLICATION_PROCESS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String processName=data.readString();
int uid=data.readInt();
killApplicationProcess(processName,uid);
reply.writeNoException();
return true;
}
case OVERRIDE_PENDING_TRANSITION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String packageName=data.readString();
int enterAnim=data.readInt();
int exitAnim=data.readInt();
overridePendingTransition(token,packageName,enterAnim,exitAnim);
reply.writeNoException();
return true;
}
case IS_USER_A_MONKEY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean areThey=isUserAMonkey();
reply.writeNoException();
reply.writeInt(areThey ? 1 : 0);
return true;
}
case SET_USER_IS_MONKEY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean monkey=(data.readInt() == 1);
setUserIsMonkey(monkey);
reply.writeNoException();
return true;
}
case FINISH_HEAVY_WEIGHT_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
finishHeavyWeightApp();
reply.writeNoException();
return true;
}
case IS_IMMERSIVE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean isit=isImmersive(token);
reply.writeNoException();
reply.writeInt(isit ? 1 : 0);
return true;
}
case IS_TOP_OF_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
final boolean isTopOfTask=isTopOfTask(token);
reply.writeNoException();
reply.writeInt(isTopOfTask ? 1 : 0);
return true;
}
case CONVERT_FROM_TRANSLUCENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean converted=convertFromTranslucent(token);
reply.writeNoException();
reply.writeInt(converted ? 1 : 0);
return true;
}
case CONVERT_TO_TRANSLUCENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
final Bundle bundle;
if (data.readInt() == 0) {
bundle=null;
}
 else {
bundle=data.readBundle();
}
final ActivityOptions options=ActivityOptions.fromBundle(bundle);
boolean converted=convertToTranslucent(token,options);
reply.writeNoException();
reply.writeInt(converted ? 1 : 0);
return true;
}
case GET_ACTIVITY_OPTIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
final ActivityOptions options=getActivityOptions(token);
reply.writeNoException();
reply.writeBundle(options == null ? null : options.toBundle());
return true;
}
case SET_IMMERSIVE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean imm=data.readInt() == 1;
setImmersive(token,imm);
reply.writeNoException();
return true;
}
case IS_TOP_ACTIVITY_IMMERSIVE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean isit=isTopActivityImmersive();
reply.writeNoException();
reply.writeInt(isit ? 1 : 0);
return true;
}
case CRASH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int uid=data.readInt();
int initialPid=data.readInt();
String packageName=data.readString();
String message=data.readString();
crashApplication(uid,initialPid,packageName,message);
reply.writeNoException();
return true;
}
case GET_PROVIDER_MIME_TYPE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int userId=data.readInt();
String type=getProviderMimeType(uri,userId);
reply.writeNoException();
reply.writeString(type);
return true;
}
case NEW_URI_PERMISSION_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String name=data.readString();
IBinder perm=newUriPermissionOwner(name);
reply.writeNoException();
reply.writeStrongBinder(perm);
return true;
}
case GET_URI_PERMISSION_OWNER_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder activityToken=data.readStrongBinder();
IBinder perm=getUriPermissionOwnerForActivity(activityToken);
reply.writeNoException();
reply.writeStrongBinder(perm);
return true;
}
case GRANT_URI_PERMISSION_FROM_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder owner=data.readStrongBinder();
int fromUid=data.readInt();
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int sourceUserId=data.readInt();
int targetUserId=data.readInt();
grantUriPermissionFromOwner(owner,fromUid,targetPkg,uri,mode,sourceUserId,targetUserId);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_FROM_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder owner=data.readStrongBinder();
Uri uri=null;
if (data.readInt() != 0) {
uri=Uri.CREATOR.createFromParcel(data);
}
int mode=data.readInt();
int userId=data.readInt();
revokeUriPermissionFromOwner(owner,uri,mode,userId);
reply.writeNoException();
return true;
}
case CHECK_GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int callingUid=data.readInt();
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int modeFlags=data.readInt();
int userId=data.readInt();
int res=checkGrantUriPermission(callingUid,targetPkg,uri,modeFlags,userId);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case DUMP_HEAP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
int userId=data.readInt();
boolean managed=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? ParcelFileDescriptor.CREATOR.createFromParcel(data) : null;
boolean res=dumpHeap(process,userId,managed,path,fd);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case START_ACTIVITIES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String callingPackage=data.readString();
Intent[] intents=data.createTypedArray(Intent.CREATOR);
String[] resolvedTypes=data.createStringArray();
IBinder resultTo=data.readStrongBinder();
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
int result=startActivities(app,callingPackage,intents,resolvedTypes,resultTo,options,userId);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case GET_FRONT_ACTIVITY_SCREEN_COMPAT_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int mode=getFrontActivityScreenCompatMode();
reply.writeNoException();
reply.writeInt(mode);
return true;
}
case SET_FRONT_ACTIVITY_SCREEN_COMPAT_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int mode=data.readInt();
setFrontActivityScreenCompatMode(mode);
reply.writeNoException();
reply.writeInt(mode);
return true;
}
case GET_PACKAGE_SCREEN_COMPAT_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
int mode=getPackageScreenCompatMode(pkg);
reply.writeNoException();
reply.writeInt(mode);
return true;
}
case SET_PACKAGE_SCREEN_COMPAT_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
int mode=data.readInt();
setPackageScreenCompatMode(pkg,mode);
reply.writeNoException();
return true;
}
case SWITCH_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userid=data.readInt();
boolean result=switchUser(userid);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case START_USER_IN_BACKGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userid=data.readInt();
boolean result=startUserInBackground(userid);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case UNLOCK_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userId=data.readInt();
byte[] token=data.createByteArray();
byte[] secret=data.createByteArray();
boolean result=unlockUser(userId,token,secret);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case STOP_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userid=data.readInt();
boolean force=data.readInt() != 0;
IStopUserCallback callback=IStopUserCallback.Stub.asInterface(data.readStrongBinder());
int result=stopUser(userid,force,callback);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case GET_CURRENT_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
UserInfo userInfo=getCurrentUser();
reply.writeNoException();
userInfo.writeToParcel(reply,0);
return true;
}
case IS_USER_RUNNING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userid=data.readInt();
int _flags=data.readInt();
boolean result=isUserRunning(userid,_flags);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case GET_RUNNING_USER_IDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] result=getRunningUserIds();
reply.writeNoException();
reply.writeIntArray(result);
return true;
}
case REMOVE_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
boolean result=removeTask(taskId);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case REGISTER_PROCESS_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IProcessObserver observer=IProcessObserver.Stub.asInterface(data.readStrongBinder());
registerProcessObserver(observer);
return true;
}
case UNREGISTER_PROCESS_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IProcessObserver observer=IProcessObserver.Stub.asInterface(data.readStrongBinder());
unregisterProcessObserver(observer);
return true;
}
case REGISTER_UID_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IUidObserver observer=IUidObserver.Stub.asInterface(data.readStrongBinder());
int which=data.readInt();
registerUidObserver(observer,which);
return true;
}
case UNREGISTER_UID_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IUidObserver observer=IUidObserver.Stub.asInterface(data.readStrongBinder());
unregisterUidObserver(observer);
return true;
}
case GET_PACKAGE_ASK_SCREEN_COMPAT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
boolean ask=getPackageAskScreenCompat(pkg);
reply.writeNoException();
reply.writeInt(ask ? 1 : 0);
return true;
}
case SET_PACKAGE_ASK_SCREEN_COMPAT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
boolean ask=data.readInt() != 0;
setPackageAskScreenCompat(pkg,ask);
reply.writeNoException();
return true;
}
case IS_INTENT_SENDER_TARGETED_TO_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
boolean res=isIntentSenderTargetedToPackage(r);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case IS_INTENT_SENDER_AN_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
boolean res=isIntentSenderAnActivity(r);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GET_INTENT_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
Intent intent=getIntentForIntentSender(r);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GET_TAG_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String prefix=data.readString();
String tag=getTagForIntentSender(r,prefix);
reply.writeNoException();
reply.writeString(tag);
return true;
}
case UPDATE_PERSISTENT_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updatePersistentConfiguration(config);
reply.writeNoException();
return true;
}
case GET_PROCESS_PSS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
long[] pss=getProcessPss(pids);
reply.writeNoException();
reply.writeLongArray(pss);
return true;
}
case SHOW_BOOT_MESSAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
CharSequence msg=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
boolean always=data.readInt() != 0;
showBootMessage(msg,always);
reply.writeNoException();
return true;
}
case KEYGUARD_WAITING_FOR_ACTIVITY_DRAWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
keyguardWaitingForActivityDrawn();
reply.writeNoException();
return true;
}
case KEYGUARD_GOING_AWAY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
keyguardGoingAway(data.readInt() != 0,data.readInt() != 0);
reply.writeNoException();
return true;
}
case SHOULD_UP_RECREATE_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String destAffinity=data.readString();
boolean res=shouldUpRecreateTask(token,destAffinity);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case NAVIGATE_UP_TO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent target=Intent.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
Intent resultData=null;
if (data.readInt() != 0) {
resultData=Intent.CREATOR.createFromParcel(data);
}
boolean res=navigateUpTo(token,target,resultCode,resultData);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GET_LAUNCHED_FROM_UID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int res=getLaunchedFromUid(token);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case GET_LAUNCHED_FROM_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=getLaunchedFromPackage(token);
reply.writeNoException();
reply.writeString(res);
return true;
}
case REGISTER_USER_SWITCH_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IUserSwitchObserver observer=IUserSwitchObserver.Stub.asInterface(data.readStrongBinder());
registerUserSwitchObserver(observer);
reply.writeNoException();
return true;
}
case UNREGISTER_USER_SWITCH_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IUserSwitchObserver observer=IUserSwitchObserver.Stub.asInterface(data.readStrongBinder());
unregisterUserSwitchObserver(observer);
reply.writeNoException();
return true;
}
case REQUEST_BUG_REPORT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int bugreportType=data.readInt();
requestBugReport(bugreportType);
reply.writeNoException();
return true;
}
case INPUT_DISPATCHING_TIMED_OUT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int pid=data.readInt();
boolean aboveSystem=data.readInt() != 0;
String reason=data.readString();
long res=inputDispatchingTimedOut(pid,aboveSystem,reason);
reply.writeNoException();
reply.writeLong(res);
return true;
}
case GET_ASSIST_CONTEXT_EXTRAS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int requestType=data.readInt();
Bundle res=getAssistContextExtras(requestType);
reply.writeNoException();
reply.writeBundle(res);
return true;
}
case REQUEST_ASSIST_CONTEXT_EXTRAS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int requestType=data.readInt();
IResultReceiver receiver=IResultReceiver.Stub.asInterface(data.readStrongBinder());
IBinder activityToken=data.readStrongBinder();
boolean res=requestAssistContextExtras(requestType,receiver,activityToken);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REPORT_ASSIST_CONTEXT_EXTRAS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle extras=data.readBundle();
AssistStructure structure=AssistStructure.CREATOR.createFromParcel(data);
AssistContent content=AssistContent.CREATOR.createFromParcel(data);
Uri referrer=data.readInt() != 0 ? Uri.CREATOR.createFromParcel(data) : null;
reportAssistContextExtras(token,extras,structure,content,referrer);
reply.writeNoException();
return true;
}
case LAUNCH_ASSIST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
int requestType=data.readInt();
String hint=data.readString();
int userHandle=data.readInt();
Bundle args=data.readBundle();
boolean res=launchAssistIntent(intent,requestType,hint,userHandle,args);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case IS_SCREEN_CAPTURE_ALLOWED_ON_CURRENT_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=isAssistDataAllowedOnCurrentActivity();
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHOW_ASSIST_FROM_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle args=data.readBundle();
boolean res=showAssistFromActivity(token,args);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case KILL_UID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int appId=data.readInt();
int userId=data.readInt();
String reason=data.readString();
killUid(appId,userId,reason);
reply.writeNoException();
return true;
}
case HANG_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
boolean allowRestart=data.readInt() != 0;
hang(who,allowRestart);
reply.writeNoException();
return true;
}
case REPORT_ACTIVITY_FULLY_DRAWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reportActivityFullyDrawn(token);
reply.writeNoException();
return true;
}
case NOTIFY_ACTIVITY_DRAWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
notifyActivityDrawn(token);
reply.writeNoException();
return true;
}
case RESTART_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
restart();
reply.writeNoException();
return true;
}
case PERFORM_IDLE_MAINTENANCE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
performIdleMaintenance();
reply.writeNoException();
return true;
}
case CREATE_VIRTUAL_ACTIVITY_CONTAINER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder parentActivityToken=data.readStrongBinder();
IActivityContainerCallback callback=IActivityContainerCallback.Stub.asInterface(data.readStrongBinder());
IActivityContainer activityContainer=createVirtualActivityContainer(parentActivityToken,callback);
reply.writeNoException();
if (activityContainer != null) {
reply.writeInt(1);
reply.writeStrongBinder(activityContainer.asBinder());
}
 else {
reply.writeInt(0);
}
return true;
}
case DELETE_ACTIVITY_CONTAINER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityContainer activityContainer=IActivityContainer.Stub.asInterface(data.readStrongBinder());
deleteActivityContainer(activityContainer);
reply.writeNoException();
return true;
}
case CREATE_STACK_ON_DISPLAY:
{
data.enforceInterface(IActivityManager.descriptor);
int displayId=data.readInt();
IActivityContainer activityContainer=createStackOnDisplay(displayId);
reply.writeNoException();
if (activityContainer != null) {
reply.writeInt(1);
reply.writeStrongBinder(activityContainer.asBinder());
}
 else {
reply.writeInt(0);
}
return true;
}
case GET_ACTIVITY_DISPLAY_ID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder activityToken=data.readStrongBinder();
int displayId=getActivityDisplayId(activityToken);
reply.writeNoException();
reply.writeInt(displayId);
return true;
}
case START_LOCK_TASK_BY_TASK_ID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int taskId=data.readInt();
startLockTaskMode(taskId);
reply.writeNoException();
return true;
}
case START_LOCK_TASK_BY_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
startLockTaskMode(token);
reply.writeNoException();
return true;
}
case START_LOCK_TASK_BY_CURRENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
startLockTaskModeOnCurrent();
reply.writeNoException();
return true;
}
case STOP_LOCK_TASK_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopLockTaskMode();
reply.writeNoException();
return true;
}
case STOP_LOCK_TASK_BY_CURRENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopLockTaskModeOnCurrent();
reply.writeNoException();
return true;
}
case IS_IN_LOCK_TASK_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean isInLockTaskMode=isInLockTaskMode();
reply.writeNoException();
reply.writeInt(isInLockTaskMode ? 1 : 0);
return true;
}
case GET_LOCK_TASK_MODE_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int lockTaskModeState=getLockTaskModeState();
reply.writeNoException();
reply.writeInt(lockTaskModeState);
return true;
}
case SHOW_LOCK_TASK_ESCAPE_MESSAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
showLockTaskEscapeMessage(token);
reply.writeNoException();
return true;
}
case SET_TASK_DESCRIPTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ActivityManager.TaskDescription values=ActivityManager.TaskDescription.CREATOR.createFromParcel(data);
setTaskDescription(token,values);
reply.writeNoException();
return true;
}
case SET_TASK_RESIZEABLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int taskId=data.readInt();
final int resizeableMode=data.readInt();
setTaskResizeable(taskId,resizeableMode);
reply.writeNoException();
return true;
}
case RESIZE_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
int resizeMode=data.readInt();
Rect r=Rect.CREATOR.createFromParcel(data);
resizeTask(taskId,r,resizeMode);
reply.writeNoException();
return true;
}
case GET_TASK_BOUNDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
Rect r=getTaskBounds(taskId);
reply.writeNoException();
r.writeToParcel(reply,0);
return true;
}
case GET_TASK_DESCRIPTION_ICON_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String filename=data.readString();
int userId=data.readInt();
Bitmap icon=getTaskDescriptionIcon(filename,userId);
reply.writeNoException();
if (icon == null) {
reply.writeInt(0);
}
 else {
reply.writeInt(1);
icon.writeToParcel(reply,0);
}
return true;
}
case START_IN_PLACE_ANIMATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final Bundle bundle;
if (data.readInt() == 0) {
bundle=null;
}
 else {
bundle=data.readBundle();
}
final ActivityOptions options=ActivityOptions.fromBundle(bundle);
startInPlaceAnimationOnFrontMostApplication(options);
reply.writeNoException();
return true;
}
case REQUEST_VISIBLE_BEHIND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean enable=data.readInt() > 0;
boolean success=requestVisibleBehind(token,enable);
reply.writeNoException();
reply.writeInt(success ? 1 : 0);
return true;
}
case IS_BACKGROUND_VISIBLE_BEHIND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
final boolean enabled=isBackgroundVisibleBehind(token);
reply.writeNoException();
reply.writeInt(enabled ? 1 : 0);
return true;
}
case BACKGROUND_RESOURCES_RELEASED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
backgroundResourcesReleased(token);
reply.writeNoException();
return true;
}
case NOTIFY_LAUNCH_TASK_BEHIND_COMPLETE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
notifyLaunchTaskBehindComplete(token);
reply.writeNoException();
return true;
}
case NOTIFY_ENTER_ANIMATION_COMPLETE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
notifyEnterAnimationComplete(token);
reply.writeNoException();
return true;
}
case BOOT_ANIMATION_COMPLETE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
bootAnimationComplete();
reply.writeNoException();
return true;
}
case NOTIFY_CLEARTEXT_NETWORK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int uid=data.readInt();
final byte[] firstPacket=data.createByteArray();
notifyCleartextNetwork(uid,firstPacket);
reply.writeNoException();
return true;
}
case SET_DUMP_HEAP_DEBUG_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String procName=data.readString();
int uid=data.readInt();
long maxMemSize=data.readLong();
String reportPackage=data.readString();
setDumpHeapDebugLimit(procName,uid,maxMemSize,reportPackage);
reply.writeNoException();
return true;
}
case DUMP_HEAP_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String path=data.readString();
dumpHeapFinished(path);
reply.writeNoException();
return true;
}
case SET_VOICE_KEEP_AWAKE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IVoiceInteractionSession session=IVoiceInteractionSession.Stub.asInterface(data.readStrongBinder());
boolean keepAwake=data.readInt() != 0;
setVoiceKeepAwake(session,keepAwake);
reply.writeNoException();
return true;
}
case UPDATE_LOCK_TASK_PACKAGES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userId=data.readInt();
String[] packages=data.readStringArray();
updateLockTaskPackages(userId,packages);
reply.writeNoException();
return true;
}
case UPDATE_DEVICE_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
updateDeviceOwner(packageName);
reply.writeNoException();
return true;
}
case GET_PACKAGE_PROCESS_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
String callingPackage=data.readString();
int res=getPackageProcessState(pkg,callingPackage);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case SET_PROCESS_MEMORY_TRIM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
int userId=data.readInt();
int level=data.readInt();
boolean res=setProcessMemoryTrimLevel(process,userId,level);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case IS_ROOT_VOICE_INTERACTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean res=isRootVoiceInteraction(token);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case START_BINDER_TRACKING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=startBinderTracking();
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case STOP_BINDER_TRACKING_AND_DUMP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ParcelFileDescriptor fd=data.readInt() != 0 ? ParcelFileDescriptor.CREATOR.createFromParcel(data) : null;
boolean res=stopBinderTrackingAndDump(fd);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GET_ACTIVITY_STACK_ID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int stackId=getActivityStackId(token);
reply.writeNoException();
reply.writeInt(stackId);
return true;
}
case EXIT_FREEFORM_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
exitFreeformMode(token);
reply.writeNoException();
return true;
}
case REPORT_SIZE_CONFIGURATIONS:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int[] horizontal=readIntArray(data);
int[] vertical=readIntArray(data);
int[] smallest=readIntArray(data);
reportSizeConfigurations(token,horizontal,vertical,smallest);
return true;
}
case SUPPRESS_RESIZE_CONFIG_CHANGES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean suppress=data.readInt() == 1;
suppressResizeConfigChanges(suppress);
reply.writeNoException();
return true;
}
case MOVE_TASKS_TO_FULLSCREEN_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int stackId=data.readInt();
final boolean onTop=data.readInt() == 1;
moveTasksToFullscreenStack(stackId,onTop);
reply.writeNoException();
return true;
}
case GET_APP_START_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int uid=data.readInt();
final String pkg=data.readString();
int res=getAppStartMode(uid,pkg);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case IN_MULTI_WINDOW_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
final boolean inMultiWindow=inMultiWindow(token);
reply.writeNoException();
reply.writeInt(inMultiWindow ? 1 : 0);
return true;
}
case IN_PICTURE_IN_PICTURE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
final boolean inPip=inPictureInPicture(token);
reply.writeNoException();
reply.writeInt(inPip ? 1 : 0);
return true;
}
case ENTER_PICTURE_IN_PICTURE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
enterPictureInPicture(token);
reply.writeNoException();
return true;
}
case SET_VR_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
final boolean enable=data.readInt() == 1;
setVrMode(token,enable);
reply.writeNoException();
return true;
}
case IS_APP_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int userHandle=data.readInt();
final boolean isForeground=isAppForeground(userHandle);
reply.writeNoException();
reply.writeInt(isForeground ? 1 : 0);
return true;
}
case NOTIFY_PINNED_STACK_ANIMATION_ENDED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
reply.writeNoException();
return true;
}
case REMOVE_STACK:
{
data.enforceInterface(IActivityManager.descriptor);
final int stackId=data.readInt();
removeStack(stackId);
reply.writeNoException();
return true;
}
}
return super.onTransact(code,data,reply,flags);
}","@Override public boolean onTransact(int code,Parcel data,Parcel reply,int flags) throws RemoteException {
switch (code) {
case START_ACTIVITY_TRANSACTION:
{
      data.enforceInterface(IActivityManager.descriptor);
      IBinder b=data.readStrongBinder();
      IApplicationThread app=ApplicationThreadNative.asInterface(b);
      String callingPackage=data.readString();
      Intent intent=Intent.CREATOR.createFromParcel(data);
      String resolvedType=data.readString();
      IBinder resultTo=data.readStrongBinder();
      String resultWho=data.readString();
      int requestCode=data.readInt();
      int startFlags=data.readInt();
      ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
      Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
      int result=startActivity(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,profilerInfo,options);
      reply.writeNoException();
      reply.writeInt(result);
      return true;
    }
case START_ACTIVITY_AS_USER_TRANSACTION:
{
    data.enforceInterface(IActivityManager.descriptor);
    IBinder b=data.readStrongBinder();
    IApplicationThread app=ApplicationThreadNative.asInterface(b);
    String callingPackage=data.readString();
    Intent intent=Intent.CREATOR.createFromParcel(data);
    String resolvedType=data.readString();
    IBinder resultTo=data.readStrongBinder();
    String resultWho=data.readString();
    int requestCode=data.readInt();
    int startFlags=data.readInt();
    ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
    Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
    int userId=data.readInt();
    int result=startActivityAsUser(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,profilerInfo,options,userId);
    reply.writeNoException();
    reply.writeInt(result);
    return true;
  }
case START_ACTIVITY_AS_CALLER_TRANSACTION:
{
  data.enforceInterface(IActivityManager.descriptor);
  IBinder b=data.readStrongBinder();
  IApplicationThread app=ApplicationThreadNative.asInterface(b);
  String callingPackage=data.readString();
  Intent intent=Intent.CREATOR.createFromParcel(data);
  String resolvedType=data.readString();
  IBinder resultTo=data.readStrongBinder();
  String resultWho=data.readString();
  int requestCode=data.readInt();
  int startFlags=data.readInt();
  ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
  Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
  boolean ignoreTargetSecurity=data.readInt() != 0;
  int userId=data.readInt();
  int result=startActivityAsCaller(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,profilerInfo,options,ignoreTargetSecurity,userId);
  reply.writeNoException();
  reply.writeInt(result);
  return true;
}
case START_ACTIVITY_AND_WAIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String callingPackage=data.readString();
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder resultTo=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
int startFlags=data.readInt();
ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
WaitResult result=startActivityAndWait(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,profilerInfo,options,userId);
reply.writeNoException();
result.writeToParcel(reply,0);
return true;
}
case START_ACTIVITY_WITH_CONFIG_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String callingPackage=data.readString();
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IBinder resultTo=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
int startFlags=data.readInt();
Configuration config=Configuration.CREATOR.createFromParcel(data);
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
int result=startActivityWithConfig(app,callingPackage,intent,resolvedType,resultTo,resultWho,requestCode,startFlags,config,options,userId);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case START_ACTIVITY_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IntentSender intent=IntentSender.CREATOR.createFromParcel(data);
Intent fillInIntent=null;
if (data.readInt() != 0) {
fillInIntent=Intent.CREATOR.createFromParcel(data);
}
String resolvedType=data.readString();
IBinder resultTo=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
int flagsMask=data.readInt();
int flagsValues=data.readInt();
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int result=startActivityIntentSender(app,intent,fillInIntent,resolvedType,resultTo,resultWho,requestCode,flagsMask,flagsValues,options);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case START_VOICE_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String callingPackage=data.readString();
int callingPid=data.readInt();
int callingUid=data.readInt();
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
IVoiceInteractionSession session=IVoiceInteractionSession.Stub.asInterface(data.readStrongBinder());
IVoiceInteractor interactor=IVoiceInteractor.Stub.asInterface(data.readStrongBinder());
int startFlags=data.readInt();
ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
int result=startVoiceActivity(callingPackage,callingPid,callingUid,intent,resolvedType,session,interactor,startFlags,profilerInfo,options,userId);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case START_LOCAL_VOICE_INTERACTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle options=data.readBundle();
startLocalVoiceInteraction(token,options);
reply.writeNoException();
return true;
}
case STOP_LOCAL_VOICE_INTERACTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
stopLocalVoiceInteraction(token);
reply.writeNoException();
return true;
}
case SUPPORTS_LOCAL_VOICE_INTERACTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean result=supportsLocalVoiceInteraction();
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case START_NEXT_MATCHING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder callingActivity=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
boolean result=startNextMatchingActivity(callingActivity,intent,options);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case START_ACTIVITY_FROM_RECENTS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int taskId=data.readInt();
final Bundle options=data.readInt() == 0 ? null : Bundle.CREATOR.createFromParcel(data);
final int result=startActivityFromRecents(taskId,options);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case FINISH_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent resultData=null;
int resultCode=data.readInt();
if (data.readInt() != 0) {
resultData=Intent.CREATOR.createFromParcel(data);
}
int finishTask=data.readInt();
boolean res=finishActivity(token,resultCode,resultData,finishTask);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_SUB_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
finishSubActivity(token,resultWho,requestCode);
reply.writeNoException();
return true;
}
case FINISH_ACTIVITY_AFFINITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean res=finishActivityAffinity(token);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_VOICE_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IVoiceInteractionSession session=IVoiceInteractionSession.Stub.asInterface(data.readStrongBinder());
finishVoiceTask(session);
reply.writeNoException();
return true;
}
case RELEASE_ACTIVITY_INSTANCE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean res=releaseActivityInstance(token);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case RELEASE_SOME_ACTIVITIES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
releaseSomeActivities(app);
reply.writeNoException();
return true;
}
case WILL_ACTIVITY_BE_VISIBLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean res=willActivityBeVisible(token);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
String packageName=data.readString();
b=data.readStrongBinder();
IIntentReceiver rec=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
IntentFilter filter=IntentFilter.CREATOR.createFromParcel(data);
String perm=data.readString();
int userId=data.readInt();
Intent intent=registerReceiver(app,packageName,rec,filter,perm,userId);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case UNREGISTER_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
if (b == null) {
return true;
}
IIntentReceiver rec=IIntentReceiver.Stub.asInterface(b);
unregisterReceiver(rec);
reply.writeNoException();
return true;
}
case BROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
IIntentReceiver resultTo=b != null ? IIntentReceiver.Stub.asInterface(b) : null;
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
String[] perms=data.readStringArray();
int appOp=data.readInt();
Bundle options=data.readBundle();
boolean serialized=data.readInt() != 0;
boolean sticky=data.readInt() != 0;
int userId=data.readInt();
int res=broadcastIntent(app,intent,resolvedType,resultTo,resultCode,resultData,resultExtras,perms,appOp,options,serialized,sticky,userId);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBROADCAST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=b != null ? ApplicationThreadNative.asInterface(b) : null;
Intent intent=Intent.CREATOR.createFromParcel(data);
int userId=data.readInt();
unbroadcastIntent(app,intent,userId);
reply.writeNoException();
return true;
}
case FINISH_RECEIVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
int resultCode=data.readInt();
String resultData=data.readString();
Bundle resultExtras=data.readBundle();
boolean resultAbort=data.readInt() != 0;
int intentFlags=data.readInt();
if (who != null) {
finishReceiver(who,resultCode,resultData,resultExtras,resultAbort,intentFlags);
}
reply.writeNoException();
return true;
}
case ATTACH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IApplicationThread app=ApplicationThreadNative.asInterface(data.readStrongBinder());
if (app != null) {
attachApplication(app);
}
reply.writeNoException();
return true;
}
case ACTIVITY_IDLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Configuration config=null;
if (data.readInt() != 0) {
config=Configuration.CREATOR.createFromParcel(data);
}
boolean stopProfiling=data.readInt() != 0;
if (token != null) {
activityIdle(token,config,stopProfiling);
}
reply.writeNoException();
return true;
}
case ACTIVITY_RESUMED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityResumed(token);
reply.writeNoException();
return true;
}
case ACTIVITY_PAUSED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityPaused(token);
reply.writeNoException();
return true;
}
case ACTIVITY_STOPPED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle map=data.readBundle();
PersistableBundle persistentState=data.readPersistableBundle();
CharSequence description=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
activityStopped(token,map,persistentState,description);
reply.writeNoException();
return true;
}
case ACTIVITY_SLEPT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activitySlept(token);
reply.writeNoException();
return true;
}
case ACTIVITY_DESTROYED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityDestroyed(token);
reply.writeNoException();
return true;
}
case ACTIVITY_RELAUNCHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
activityRelaunched(token);
reply.writeNoException();
return true;
}
case GET_CALLING_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=token != null ? getCallingPackage(token) : null;
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_CALLING_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getCallingActivity(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_APP_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String callingPackage=data.readString();
List<IAppTask> list=getAppTasks(callingPackage);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
IAppTask task=list.get(i);
reply.writeStrongBinder(task.asBinder());
}
return true;
}
case ADD_APP_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder activityToken=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
ActivityManager.TaskDescription descr=ActivityManager.TaskDescription.CREATOR.createFromParcel(data);
Bitmap thumbnail=Bitmap.CREATOR.createFromParcel(data);
int res=addAppTask(activityToken,intent,descr,thumbnail);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case GET_APP_TASK_THUMBNAIL_SIZE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Point size=getAppTaskThumbnailSize();
reply.writeNoException();
size.writeToParcel(reply,0);
return true;
}
case GET_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RunningTaskInfo> list=getTasks(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningTaskInfo info=list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_RECENT_TASKS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
int userId=data.readInt();
List<ActivityManager.RecentTaskInfo> list=getRecentTasks(maxNum,fl,userId);
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_TASK_THUMBNAIL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int id=data.readInt();
ActivityManager.TaskThumbnail taskThumbnail=getTaskThumbnail(id);
reply.writeNoException();
if (taskThumbnail != null) {
reply.writeInt(1);
taskThumbnail.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GET_SERVICES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int maxNum=data.readInt();
int fl=data.readInt();
List<ActivityManager.RunningServiceInfo> list=getServices(maxNum,fl);
reply.writeNoException();
int N=list != null ? list.size() : -1;
reply.writeInt(N);
int i;
for (i=0; i < N; i++) {
ActivityManager.RunningServiceInfo info=list.get(i);
info.writeToParcel(reply,0);
}
return true;
}
case GET_PROCESSES_IN_ERROR_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.ProcessErrorStateInfo> list=getProcessesInErrorState();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_APP_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ActivityManager.RunningAppProcessInfo> list=getRunningAppProcesses();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_RUNNING_EXTERNAL_APPLICATIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<ApplicationInfo> list=getRunningExternalApplications();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case MOVE_TASK_TO_FRONT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
int fl=data.readInt();
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
moveTaskToFront(task,fl,options);
reply.writeNoException();
return true;
}
case MOVE_ACTIVITY_TASK_TO_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean nonRoot=data.readInt() != 0;
boolean res=moveActivityTaskToBack(token,nonRoot);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case MOVE_TASK_BACKWARDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int task=data.readInt();
moveTaskBackwards(task);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
int stackId=data.readInt();
boolean toTop=data.readInt() != 0;
moveTaskToStack(taskId,stackId,toTop);
reply.writeNoException();
return true;
}
case MOVE_TASK_TO_DOCKED_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
int createMode=data.readInt();
boolean toTop=data.readInt() != 0;
boolean animate=data.readInt() != 0;
Rect bounds=null;
boolean hasBounds=data.readInt() != 0;
if (hasBounds) {
bounds=Rect.CREATOR.createFromParcel(data);
}
moveTaskToDockedStack(taskId,createMode,toTop,animate,bounds);
reply.writeNoException();
return true;
}
case MOVE_TOP_ACTIVITY_TO_PINNED_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int stackId=data.readInt();
final Rect r=Rect.CREATOR.createFromParcel(data);
final boolean res=moveTopActivityToPinnedStack(stackId,r);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case RESIZE_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int stackId=data.readInt();
final boolean hasRect=data.readInt() != 0;
Rect r=null;
if (hasRect) {
r=Rect.CREATOR.createFromParcel(data);
}
final boolean allowResizeInDockedMode=data.readInt() == 1;
final boolean preserveWindows=data.readInt() == 1;
final boolean animate=data.readInt() == 1;
resizeStack(stackId,r,allowResizeInDockedMode,preserveWindows,animate);
reply.writeNoException();
return true;
}
case RESIZE_DOCKED_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean hasBounds=data.readInt() != 0;
Rect bounds=null;
if (hasBounds) {
bounds=Rect.CREATOR.createFromParcel(data);
}
final boolean hasTempDockedTaskBounds=data.readInt() != 0;
Rect tempDockedTaskBounds=null;
if (hasTempDockedTaskBounds) {
tempDockedTaskBounds=Rect.CREATOR.createFromParcel(data);
}
final boolean hasTempDockedTaskInsetBounds=data.readInt() != 0;
Rect tempDockedTaskInsetBounds=null;
if (hasTempDockedTaskInsetBounds) {
tempDockedTaskInsetBounds=Rect.CREATOR.createFromParcel(data);
}
final boolean hasTempOtherTaskBounds=data.readInt() != 0;
Rect tempOtherTaskBounds=null;
if (hasTempOtherTaskBounds) {
tempOtherTaskBounds=Rect.CREATOR.createFromParcel(data);
}
final boolean hasTempOtherTaskInsetBounds=data.readInt() != 0;
Rect tempOtherTaskInsetBounds=null;
if (hasTempOtherTaskInsetBounds) {
tempOtherTaskInsetBounds=Rect.CREATOR.createFromParcel(data);
}
resizeDockedStack(bounds,tempDockedTaskBounds,tempDockedTaskInsetBounds,tempOtherTaskBounds,tempOtherTaskInsetBounds);
reply.writeNoException();
return true;
}
case POSITION_TASK_IN_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
int stackId=data.readInt();
int position=data.readInt();
positionTaskInStack(taskId,stackId,position);
reply.writeNoException();
return true;
}
case GET_ALL_STACK_INFOS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
List<StackInfo> list=getAllStackInfos();
reply.writeNoException();
reply.writeTypedList(list);
return true;
}
case GET_STACK_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int stackId=data.readInt();
StackInfo info=getStackInfo(stackId);
reply.writeNoException();
if (info != null) {
reply.writeInt(1);
info.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case IS_IN_HOME_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
boolean isInHomeStack=isInHomeStack(taskId);
reply.writeNoException();
reply.writeInt(isInHomeStack ? 1 : 0);
return true;
}
case SET_FOCUSED_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int stackId=data.readInt();
setFocusedStack(stackId);
reply.writeNoException();
return true;
}
case GET_FOCUSED_STACK_ID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int focusedStackId=getFocusedStackId();
reply.writeNoException();
reply.writeInt(focusedStackId);
return true;
}
case SET_FOCUSED_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
setFocusedTask(taskId);
reply.writeNoException();
return true;
}
case REGISTER_TASK_STACK_LISTENER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
registerTaskStackListener(ITaskStackListener.Stub.asInterface(token));
reply.writeNoException();
return true;
}
case GET_TASK_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean onlyRoot=data.readInt() != 0;
int res=token != null ? getTaskForActivity(token,onlyRoot) : -1;
reply.writeNoException();
reply.writeInt(res);
return true;
}
case GET_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String name=data.readString();
int userId=data.readInt();
boolean stable=data.readInt() != 0;
ContentProviderHolder cph=getContentProvider(app,name,userId,stable);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case GET_CONTENT_PROVIDER_EXTERNAL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String name=data.readString();
int userId=data.readInt();
IBinder token=data.readStrongBinder();
ContentProviderHolder cph=getContentProviderExternal(name,userId,token);
reply.writeNoException();
if (cph != null) {
reply.writeInt(1);
cph.writeToParcel(reply,0);
}
 else {
reply.writeInt(0);
}
return true;
}
case PUBLISH_CONTENT_PROVIDERS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
ArrayList<ContentProviderHolder> providers=data.createTypedArrayList(ContentProviderHolder.CREATOR);
publishContentProviders(app,providers);
reply.writeNoException();
return true;
}
case REF_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
int stable=data.readInt();
int unstable=data.readInt();
boolean res=refContentProvider(b,stable,unstable);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case UNSTABLE_PROVIDER_DIED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
unstableProviderDied(b);
reply.writeNoException();
return true;
}
case APP_NOT_RESPONDING_VIA_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
appNotRespondingViaProvider(b);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
boolean stable=data.readInt() != 0;
removeContentProvider(b,stable);
reply.writeNoException();
return true;
}
case REMOVE_CONTENT_PROVIDER_EXTERNAL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String name=data.readString();
IBinder token=data.readStrongBinder();
removeContentProviderExternal(name,token);
reply.writeNoException();
return true;
}
case GET_RUNNING_SERVICE_CONTROL_PANEL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName comp=ComponentName.CREATOR.createFromParcel(data);
PendingIntent pi=getRunningServiceControlPanel(comp);
reply.writeNoException();
PendingIntent.writePendingIntentOrNullToParcel(pi,reply);
return true;
}
case START_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
String callingPackage=data.readString();
int userId=data.readInt();
ComponentName cn=startService(app,service,resolvedType,callingPackage,userId);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case STOP_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
int userId=data.readInt();
int res=stopService(app,service,resolvedType,userId);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case STOP_SERVICE_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int startId=data.readInt();
boolean res=stopServiceToken(className,token,startId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SET_SERVICE_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
IBinder token=data.readStrongBinder();
int id=data.readInt();
Notification notification=null;
if (data.readInt() != 0) {
notification=Notification.CREATOR.createFromParcel(data);
}
boolean removeNotification=data.readInt() != 0;
setServiceForeground(className,token,id,notification,removeNotification);
reply.writeNoException();
return true;
}
case BIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
IBinder token=data.readStrongBinder();
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
b=data.readStrongBinder();
int fl=data.readInt();
String callingPackage=data.readString();
int userId=data.readInt();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
int res=bindService(app,token,service,resolvedType,conn,fl,callingPackage,userId);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case UNBIND_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IServiceConnection conn=IServiceConnection.Stub.asInterface(b);
boolean res=unbindService(conn);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case PUBLISH_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
IBinder service=data.readStrongBinder();
publishService(token,intent,service);
reply.writeNoException();
return true;
}
case UNBIND_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent intent=Intent.CREATOR.createFromParcel(data);
boolean doRebind=data.readInt() != 0;
unbindFinished(token,intent,doRebind);
reply.writeNoException();
return true;
}
case SERVICE_DONE_EXECUTING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int type=data.readInt();
int startId=data.readInt();
int res=data.readInt();
serviceDoneExecuting(token,type,startId,res);
reply.writeNoException();
return true;
}
case START_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ComponentName className=ComponentName.readFromParcel(data);
String profileFile=data.readString();
int fl=data.readInt();
Bundle arguments=data.readBundle();
IBinder b=data.readStrongBinder();
IInstrumentationWatcher w=IInstrumentationWatcher.Stub.asInterface(b);
b=data.readStrongBinder();
IUiAutomationConnection c=IUiAutomationConnection.Stub.asInterface(b);
int userId=data.readInt();
String abiOverride=data.readString();
boolean res=startInstrumentation(className,profileFile,fl,arguments,w,c,userId,abiOverride);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case FINISH_INSTRUMENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
int resultCode=data.readInt();
Bundle results=data.readBundle();
finishInstrumentation(app,resultCode,results);
reply.writeNoException();
return true;
}
case GET_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=getConfiguration();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case UPDATE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updateConfiguration(config);
reply.writeNoException();
return true;
}
case SET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int requestedOrientation=data.readInt();
setRequestedOrientation(token,requestedOrientation);
reply.writeNoException();
return true;
}
case GET_REQUESTED_ORIENTATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int req=getRequestedOrientation(token);
reply.writeNoException();
reply.writeInt(req);
return true;
}
case GET_ACTIVITY_CLASS_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ComponentName cn=getActivityClassForToken(token);
reply.writeNoException();
ComponentName.writeToParcel(cn,reply);
return true;
}
case GET_PACKAGE_FOR_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reply.writeNoException();
reply.writeString(getPackageForToken(token));
return true;
}
case GET_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int type=data.readInt();
String packageName=data.readString();
IBinder token=data.readStrongBinder();
String resultWho=data.readString();
int requestCode=data.readInt();
Intent[] requestIntents;
String[] requestResolvedTypes;
if (data.readInt() != 0) {
requestIntents=data.createTypedArray(Intent.CREATOR);
requestResolvedTypes=data.createStringArray();
}
 else {
requestIntents=null;
requestResolvedTypes=null;
}
int fl=data.readInt();
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
IIntentSender res=getIntentSender(type,packageName,token,resultWho,requestCode,requestIntents,requestResolvedTypes,fl,options,userId);
reply.writeNoException();
reply.writeStrongBinder(res != null ? res.asBinder() : null);
return true;
}
case CANCEL_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
cancelIntentSender(r);
reply.writeNoException();
return true;
}
case GET_PACKAGE_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String res=getPackageForIntentSender(r);
reply.writeNoException();
reply.writeString(res);
return true;
}
case GET_UID_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
int res=getUidForIntentSender(r);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case HANDLE_INCOMING_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int callingPid=data.readInt();
int callingUid=data.readInt();
int userId=data.readInt();
boolean allowAll=data.readInt() != 0;
boolean requireFull=data.readInt() != 0;
String name=data.readString();
String callerPackage=data.readString();
int res=handleIncomingUser(callingPid,callingUid,userId,allowAll,requireFull,name,callerPackage);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case SET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int max=data.readInt();
setProcessLimit(max);
reply.writeNoException();
return true;
}
case GET_PROCESS_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int limit=getProcessLimit();
reply.writeNoException();
reply.writeInt(limit);
return true;
}
case SET_PROCESS_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int pid=data.readInt();
boolean isForeground=data.readInt() != 0;
setProcessForeground(token,pid,isForeground);
reply.writeNoException();
return true;
}
case CHECK_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
int res=checkPermission(perm,pid,uid);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_PERMISSION_WITH_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String perm=data.readString();
int pid=data.readInt();
int uid=data.readInt();
IBinder token=data.readStrongBinder();
int res=checkPermissionWithToken(perm,pid,uid,token);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CHECK_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int pid=data.readInt();
int uid=data.readInt();
int mode=data.readInt();
int userId=data.readInt();
IBinder callerToken=data.readStrongBinder();
int res=checkUriPermission(uri,pid,uid,mode,userId,callerToken);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case CLEAR_APP_DATA_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IPackageDataObserver observer=IPackageDataObserver.Stub.asInterface(data.readStrongBinder());
int userId=data.readInt();
boolean res=clearApplicationUserData(packageName,observer,userId);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int userId=data.readInt();
grantUriPermission(app,targetPkg,uri,mode,userId);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int userId=data.readInt();
revokeUriPermission(app,uri,mode,userId);
reply.writeNoException();
return true;
}
case TAKE_PERSISTABLE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int userId=data.readInt();
takePersistableUriPermission(uri,mode,userId);
reply.writeNoException();
return true;
}
case RELEASE_PERSISTABLE_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int userId=data.readInt();
releasePersistableUriPermission(uri,mode,userId);
reply.writeNoException();
return true;
}
case GET_PERSISTED_URI_PERMISSIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final String packageName=data.readString();
final boolean incoming=data.readInt() != 0;
final ParceledListSlice<UriPermission> perms=getPersistedUriPermissions(packageName,incoming);
reply.writeNoException();
perms.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
return true;
}
case GET_GRANTED_URI_PERMISSIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final String packageName=data.readString();
final int userId=data.readInt();
final ParceledListSlice<UriPermission> perms=getGrantedUriPermissions(packageName,userId);
reply.writeNoException();
perms.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
return true;
}
case CLEAR_GRANTED_URI_PERMISSIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final String packageName=data.readString();
final int userId=data.readInt();
clearGrantedUriPermissions(packageName,userId);
reply.writeNoException();
return true;
}
case SHOW_WAITING_FOR_DEBUGGER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
boolean waiting=data.readInt() != 0;
showWaitingForDebugger(app,waiting);
reply.writeNoException();
return true;
}
case GET_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.MemoryInfo mi=new ActivityManager.MemoryInfo();
getMemoryInfo(mi);
reply.writeNoException();
mi.writeToParcel(reply,0);
return true;
}
case UNHANDLED_BACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
unhandledBack();
reply.writeNoException();
return true;
}
case OPEN_CONTENT_URI_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.parse(data.readString());
ParcelFileDescriptor pfd=openContentUri(uri);
reply.writeNoException();
if (pfd != null) {
reply.writeInt(1);
pfd.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case SET_LOCK_SCREEN_SHOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
setLockScreenShown(data.readInt() != 0);
reply.writeNoException();
return true;
}
case SET_DEBUG_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pn=data.readString();
boolean wfd=data.readInt() != 0;
boolean per=data.readInt() != 0;
setDebugApp(pn,wfd,per);
reply.writeNoException();
return true;
}
case SET_ALWAYS_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setAlwaysFinish(enabled);
reply.writeNoException();
return true;
}
case SET_ACTIVITY_CONTROLLER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityController watcher=IActivityController.Stub.asInterface(data.readStrongBinder());
boolean imAMonkey=data.readInt() != 0;
setActivityController(watcher,imAMonkey);
reply.writeNoException();
return true;
}
case SET_LENIENT_BACKGROUND_CHECK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean enabled=data.readInt() != 0;
setLenientBackgroundCheck(enabled);
reply.writeNoException();
return true;
}
case GET_MEMORY_TRIM_LEVEL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int level=getMemoryTrimLevel();
reply.writeNoException();
reply.writeInt(level);
return true;
}
case ENTER_SAFE_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
enterSafeMode();
reply.writeNoException();
return true;
}
case NOTE_WAKEUP_ALARM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
int sourceUid=data.readInt();
String sourcePkg=data.readString();
String tag=data.readString();
noteWakeupAlarm(is,sourceUid,sourcePkg,tag);
reply.writeNoException();
return true;
}
case NOTE_ALARM_START_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
int sourceUid=data.readInt();
String tag=data.readString();
noteAlarmStart(is,sourceUid,tag);
reply.writeNoException();
return true;
}
case NOTE_ALARM_FINISH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender is=IIntentSender.Stub.asInterface(data.readStrongBinder());
int sourceUid=data.readInt();
String tag=data.readString();
noteAlarmFinish(is,sourceUid,tag);
reply.writeNoException();
return true;
}
case KILL_PIDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
String reason=data.readString();
boolean secure=data.readInt() != 0;
boolean res=killPids(pids,reason,secure);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case KILL_PROCESSES_BELOW_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String reason=data.readString();
boolean res=killProcessesBelowForeground(reason);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case HANDLE_APPLICATION_CRASH_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
ApplicationErrorReport.CrashInfo ci=new ApplicationErrorReport.CrashInfo(data);
handleApplicationCrash(app,ci);
reply.writeNoException();
return true;
}
case HANDLE_APPLICATION_WTF_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
String tag=data.readString();
boolean system=data.readInt() != 0;
ApplicationErrorReport.CrashInfo ci=new ApplicationErrorReport.CrashInfo(data);
boolean res=handleApplicationWtf(app,tag,system,ci);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case HANDLE_APPLICATION_STRICT_MODE_VIOLATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder app=data.readStrongBinder();
int violationMask=data.readInt();
StrictMode.ViolationInfo info=new StrictMode.ViolationInfo(data);
handleApplicationStrictModeViolation(app,violationMask,info);
reply.writeNoException();
return true;
}
case SIGNAL_PERSISTENT_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int sig=data.readInt();
signalPersistentProcesses(sig);
reply.writeNoException();
return true;
}
case KILL_BACKGROUND_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
int userId=data.readInt();
killBackgroundProcesses(packageName,userId);
reply.writeNoException();
return true;
}
case KILL_ALL_BACKGROUND_PROCESSES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
killAllBackgroundProcesses();
reply.writeNoException();
return true;
}
case KILL_PACKAGE_DEPENDENTS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
int userId=data.readInt();
killPackageDependents(packageName,userId);
reply.writeNoException();
return true;
}
case FORCE_STOP_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
int userId=data.readInt();
forceStopPackage(packageName,userId);
reply.writeNoException();
return true;
}
case GET_MY_MEMORY_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ActivityManager.RunningAppProcessInfo info=new ActivityManager.RunningAppProcessInfo();
getMyMemoryState(info);
reply.writeNoException();
info.writeToParcel(reply,0);
return true;
}
case GET_DEVICE_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ConfigurationInfo config=getDeviceConfigurationInfo();
reply.writeNoException();
config.writeToParcel(reply,0);
return true;
}
case PROFILE_CONTROL_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
int userId=data.readInt();
boolean start=data.readInt() != 0;
int profileType=data.readInt();
ProfilerInfo profilerInfo=data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null;
boolean res=profileControl(process,userId,start,profilerInfo,profileType);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHUTDOWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=shutdown(data.readInt());
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case STOP_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopAppSwitches();
reply.writeNoException();
return true;
}
case RESUME_APP_SWITCHES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
resumeAppSwitches();
reply.writeNoException();
return true;
}
case PEEK_SERVICE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent service=Intent.CREATOR.createFromParcel(data);
String resolvedType=data.readString();
String callingPackage=data.readString();
IBinder binder=peekService(service,resolvedType,callingPackage);
reply.writeNoException();
reply.writeStrongBinder(binder);
return true;
}
case START_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
int backupRestoreMode=data.readInt();
boolean success=bindBackupAgent(info,backupRestoreMode);
reply.writeNoException();
reply.writeInt(success ? 1 : 0);
return true;
}
case BACKUP_AGENT_CREATED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
IBinder agent=data.readStrongBinder();
backupAgentCreated(packageName,agent);
reply.writeNoException();
return true;
}
case UNBIND_BACKUP_AGENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ApplicationInfo info=ApplicationInfo.CREATOR.createFromParcel(data);
unbindBackupAgent(info);
reply.writeNoException();
return true;
}
case ADD_PACKAGE_DEPENDENCY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
addPackageDependency(packageName);
reply.writeNoException();
return true;
}
case KILL_APPLICATION_WITH_APPID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
int appid=data.readInt();
String reason=data.readString();
killApplicationWithAppId(pkg,appid,reason);
reply.writeNoException();
return true;
}
case CLOSE_SYSTEM_DIALOGS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String reason=data.readString();
closeSystemDialogs(reason);
reply.writeNoException();
return true;
}
case GET_PROCESS_MEMORY_INFO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
Debug.MemoryInfo[] res=getProcessMemoryInfo(pids);
reply.writeNoException();
reply.writeTypedArray(res,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
return true;
}
case KILL_APPLICATION_PROCESS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String processName=data.readString();
int uid=data.readInt();
killApplicationProcess(processName,uid);
reply.writeNoException();
return true;
}
case OVERRIDE_PENDING_TRANSITION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String packageName=data.readString();
int enterAnim=data.readInt();
int exitAnim=data.readInt();
overridePendingTransition(token,packageName,enterAnim,exitAnim);
reply.writeNoException();
return true;
}
case IS_USER_A_MONKEY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean areThey=isUserAMonkey();
reply.writeNoException();
reply.writeInt(areThey ? 1 : 0);
return true;
}
case SET_USER_IS_MONKEY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean monkey=(data.readInt() == 1);
setUserIsMonkey(monkey);
reply.writeNoException();
return true;
}
case FINISH_HEAVY_WEIGHT_APP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
finishHeavyWeightApp();
reply.writeNoException();
return true;
}
case IS_IMMERSIVE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean isit=isImmersive(token);
reply.writeNoException();
reply.writeInt(isit ? 1 : 0);
return true;
}
case IS_TOP_OF_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
final boolean isTopOfTask=isTopOfTask(token);
reply.writeNoException();
reply.writeInt(isTopOfTask ? 1 : 0);
return true;
}
case CONVERT_FROM_TRANSLUCENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean converted=convertFromTranslucent(token);
reply.writeNoException();
reply.writeInt(converted ? 1 : 0);
return true;
}
case CONVERT_TO_TRANSLUCENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
final Bundle bundle;
if (data.readInt() == 0) {
bundle=null;
}
 else {
bundle=data.readBundle();
}
final ActivityOptions options=ActivityOptions.fromBundle(bundle);
boolean converted=convertToTranslucent(token,options);
reply.writeNoException();
reply.writeInt(converted ? 1 : 0);
return true;
}
case GET_ACTIVITY_OPTIONS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
final ActivityOptions options=getActivityOptions(token);
reply.writeNoException();
reply.writeBundle(options == null ? null : options.toBundle());
return true;
}
case SET_IMMERSIVE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean imm=data.readInt() == 1;
setImmersive(token,imm);
reply.writeNoException();
return true;
}
case IS_TOP_ACTIVITY_IMMERSIVE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean isit=isTopActivityImmersive();
reply.writeNoException();
reply.writeInt(isit ? 1 : 0);
return true;
}
case CRASH_APPLICATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int uid=data.readInt();
int initialPid=data.readInt();
String packageName=data.readString();
String message=data.readString();
crashApplication(uid,initialPid,packageName,message);
reply.writeNoException();
return true;
}
case GET_PROVIDER_MIME_TYPE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Uri uri=Uri.CREATOR.createFromParcel(data);
int userId=data.readInt();
String type=getProviderMimeType(uri,userId);
reply.writeNoException();
reply.writeString(type);
return true;
}
case NEW_URI_PERMISSION_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String name=data.readString();
IBinder perm=newUriPermissionOwner(name);
reply.writeNoException();
reply.writeStrongBinder(perm);
return true;
}
case GET_URI_PERMISSION_OWNER_FOR_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder activityToken=data.readStrongBinder();
IBinder perm=getUriPermissionOwnerForActivity(activityToken);
reply.writeNoException();
reply.writeStrongBinder(perm);
return true;
}
case GRANT_URI_PERMISSION_FROM_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder owner=data.readStrongBinder();
int fromUid=data.readInt();
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int mode=data.readInt();
int sourceUserId=data.readInt();
int targetUserId=data.readInt();
grantUriPermissionFromOwner(owner,fromUid,targetPkg,uri,mode,sourceUserId,targetUserId);
reply.writeNoException();
return true;
}
case REVOKE_URI_PERMISSION_FROM_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder owner=data.readStrongBinder();
Uri uri=null;
if (data.readInt() != 0) {
uri=Uri.CREATOR.createFromParcel(data);
}
int mode=data.readInt();
int userId=data.readInt();
revokeUriPermissionFromOwner(owner,uri,mode,userId);
reply.writeNoException();
return true;
}
case CHECK_GRANT_URI_PERMISSION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int callingUid=data.readInt();
String targetPkg=data.readString();
Uri uri=Uri.CREATOR.createFromParcel(data);
int modeFlags=data.readInt();
int userId=data.readInt();
int res=checkGrantUriPermission(callingUid,targetPkg,uri,modeFlags,userId);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case DUMP_HEAP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
int userId=data.readInt();
boolean managed=data.readInt() != 0;
String path=data.readString();
ParcelFileDescriptor fd=data.readInt() != 0 ? ParcelFileDescriptor.CREATOR.createFromParcel(data) : null;
boolean res=dumpHeap(process,userId,managed,path,fd);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case START_ACTIVITIES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder b=data.readStrongBinder();
IApplicationThread app=ApplicationThreadNative.asInterface(b);
String callingPackage=data.readString();
Intent[] intents=data.createTypedArray(Intent.CREATOR);
String[] resolvedTypes=data.createStringArray();
IBinder resultTo=data.readStrongBinder();
Bundle options=data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null;
int userId=data.readInt();
int result=startActivities(app,callingPackage,intents,resolvedTypes,resultTo,options,userId);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case GET_FRONT_ACTIVITY_SCREEN_COMPAT_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int mode=getFrontActivityScreenCompatMode();
reply.writeNoException();
reply.writeInt(mode);
return true;
}
case SET_FRONT_ACTIVITY_SCREEN_COMPAT_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int mode=data.readInt();
setFrontActivityScreenCompatMode(mode);
reply.writeNoException();
reply.writeInt(mode);
return true;
}
case GET_PACKAGE_SCREEN_COMPAT_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
int mode=getPackageScreenCompatMode(pkg);
reply.writeNoException();
reply.writeInt(mode);
return true;
}
case SET_PACKAGE_SCREEN_COMPAT_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
int mode=data.readInt();
setPackageScreenCompatMode(pkg,mode);
reply.writeNoException();
return true;
}
case SWITCH_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userid=data.readInt();
boolean result=switchUser(userid);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case START_USER_IN_BACKGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userid=data.readInt();
boolean result=startUserInBackground(userid);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case UNLOCK_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userId=data.readInt();
byte[] token=data.createByteArray();
byte[] secret=data.createByteArray();
boolean result=unlockUser(userId,token,secret);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case STOP_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userid=data.readInt();
boolean force=data.readInt() != 0;
IStopUserCallback callback=IStopUserCallback.Stub.asInterface(data.readStrongBinder());
int result=stopUser(userid,force,callback);
reply.writeNoException();
reply.writeInt(result);
return true;
}
case GET_CURRENT_USER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
UserInfo userInfo=getCurrentUser();
reply.writeNoException();
userInfo.writeToParcel(reply,0);
return true;
}
case IS_USER_RUNNING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userid=data.readInt();
int _flags=data.readInt();
boolean result=isUserRunning(userid,_flags);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case GET_RUNNING_USER_IDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] result=getRunningUserIds();
reply.writeNoException();
reply.writeIntArray(result);
return true;
}
case REMOVE_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
boolean result=removeTask(taskId);
reply.writeNoException();
reply.writeInt(result ? 1 : 0);
return true;
}
case REGISTER_PROCESS_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IProcessObserver observer=IProcessObserver.Stub.asInterface(data.readStrongBinder());
registerProcessObserver(observer);
return true;
}
case UNREGISTER_PROCESS_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IProcessObserver observer=IProcessObserver.Stub.asInterface(data.readStrongBinder());
unregisterProcessObserver(observer);
return true;
}
case REGISTER_UID_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IUidObserver observer=IUidObserver.Stub.asInterface(data.readStrongBinder());
int which=data.readInt();
registerUidObserver(observer,which);
return true;
}
case UNREGISTER_UID_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IUidObserver observer=IUidObserver.Stub.asInterface(data.readStrongBinder());
unregisterUidObserver(observer);
return true;
}
case GET_PACKAGE_ASK_SCREEN_COMPAT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
boolean ask=getPackageAskScreenCompat(pkg);
reply.writeNoException();
reply.writeInt(ask ? 1 : 0);
return true;
}
case SET_PACKAGE_ASK_SCREEN_COMPAT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
boolean ask=data.readInt() != 0;
setPackageAskScreenCompat(pkg,ask);
reply.writeNoException();
return true;
}
case IS_INTENT_SENDER_TARGETED_TO_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
boolean res=isIntentSenderTargetedToPackage(r);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case IS_INTENT_SENDER_AN_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
boolean res=isIntentSenderAnActivity(r);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GET_INTENT_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
Intent intent=getIntentForIntentSender(r);
reply.writeNoException();
if (intent != null) {
reply.writeInt(1);
intent.writeToParcel(reply,Parcelable.PARCELABLE_WRITE_RETURN_VALUE);
}
 else {
reply.writeInt(0);
}
return true;
}
case GET_TAG_FOR_INTENT_SENDER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IIntentSender r=IIntentSender.Stub.asInterface(data.readStrongBinder());
String prefix=data.readString();
String tag=getTagForIntentSender(r,prefix);
reply.writeNoException();
reply.writeString(tag);
return true;
}
case UPDATE_PERSISTENT_CONFIGURATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Configuration config=Configuration.CREATOR.createFromParcel(data);
updatePersistentConfiguration(config);
reply.writeNoException();
return true;
}
case GET_PROCESS_PSS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int[] pids=data.createIntArray();
long[] pss=getProcessPss(pids);
reply.writeNoException();
reply.writeLongArray(pss);
return true;
}
case SHOW_BOOT_MESSAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
CharSequence msg=TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(data);
boolean always=data.readInt() != 0;
showBootMessage(msg,always);
reply.writeNoException();
return true;
}
case KEYGUARD_WAITING_FOR_ACTIVITY_DRAWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
keyguardWaitingForActivityDrawn();
reply.writeNoException();
return true;
}
case KEYGUARD_GOING_AWAY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
keyguardGoingAway(data.readInt() != 0,data.readInt() != 0);
reply.writeNoException();
return true;
}
case SHOULD_UP_RECREATE_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String destAffinity=data.readString();
boolean res=shouldUpRecreateTask(token,destAffinity);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case NAVIGATE_UP_TO_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Intent target=Intent.CREATOR.createFromParcel(data);
int resultCode=data.readInt();
Intent resultData=null;
if (data.readInt() != 0) {
resultData=Intent.CREATOR.createFromParcel(data);
}
boolean res=navigateUpTo(token,target,resultCode,resultData);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GET_LAUNCHED_FROM_UID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int res=getLaunchedFromUid(token);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case GET_LAUNCHED_FROM_PACKAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
String res=getLaunchedFromPackage(token);
reply.writeNoException();
reply.writeString(res);
return true;
}
case REGISTER_USER_SWITCH_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IUserSwitchObserver observer=IUserSwitchObserver.Stub.asInterface(data.readStrongBinder());
registerUserSwitchObserver(observer);
reply.writeNoException();
return true;
}
case UNREGISTER_USER_SWITCH_OBSERVER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IUserSwitchObserver observer=IUserSwitchObserver.Stub.asInterface(data.readStrongBinder());
unregisterUserSwitchObserver(observer);
reply.writeNoException();
return true;
}
case REQUEST_BUG_REPORT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int bugreportType=data.readInt();
requestBugReport(bugreportType);
reply.writeNoException();
return true;
}
case INPUT_DISPATCHING_TIMED_OUT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int pid=data.readInt();
boolean aboveSystem=data.readInt() != 0;
String reason=data.readString();
long res=inputDispatchingTimedOut(pid,aboveSystem,reason);
reply.writeNoException();
reply.writeLong(res);
return true;
}
case GET_ASSIST_CONTEXT_EXTRAS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int requestType=data.readInt();
Bundle res=getAssistContextExtras(requestType);
reply.writeNoException();
reply.writeBundle(res);
return true;
}
case REQUEST_ASSIST_CONTEXT_EXTRAS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int requestType=data.readInt();
IResultReceiver receiver=IResultReceiver.Stub.asInterface(data.readStrongBinder());
IBinder activityToken=data.readStrongBinder();
boolean res=requestAssistContextExtras(requestType,receiver,activityToken);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case REPORT_ASSIST_CONTEXT_EXTRAS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle extras=data.readBundle();
AssistStructure structure=AssistStructure.CREATOR.createFromParcel(data);
AssistContent content=AssistContent.CREATOR.createFromParcel(data);
Uri referrer=data.readInt() != 0 ? Uri.CREATOR.createFromParcel(data) : null;
reportAssistContextExtras(token,extras,structure,content,referrer);
reply.writeNoException();
return true;
}
case LAUNCH_ASSIST_INTENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
Intent intent=Intent.CREATOR.createFromParcel(data);
int requestType=data.readInt();
String hint=data.readString();
int userHandle=data.readInt();
Bundle args=data.readBundle();
boolean res=launchAssistIntent(intent,requestType,hint,userHandle,args);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case IS_SCREEN_CAPTURE_ALLOWED_ON_CURRENT_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=isAssistDataAllowedOnCurrentActivity();
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case SHOW_ASSIST_FROM_ACTIVITY_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
Bundle args=data.readBundle();
boolean res=showAssistFromActivity(token,args);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case KILL_UID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int appId=data.readInt();
int userId=data.readInt();
String reason=data.readString();
killUid(appId,userId,reason);
reply.writeNoException();
return true;
}
case HANG_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder who=data.readStrongBinder();
boolean allowRestart=data.readInt() != 0;
hang(who,allowRestart);
reply.writeNoException();
return true;
}
case REPORT_ACTIVITY_FULLY_DRAWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
reportActivityFullyDrawn(token);
reply.writeNoException();
return true;
}
case NOTIFY_ACTIVITY_DRAWN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
notifyActivityDrawn(token);
reply.writeNoException();
return true;
}
case RESTART_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
restart();
reply.writeNoException();
return true;
}
case PERFORM_IDLE_MAINTENANCE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
performIdleMaintenance();
reply.writeNoException();
return true;
}
case CREATE_VIRTUAL_ACTIVITY_CONTAINER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder parentActivityToken=data.readStrongBinder();
IActivityContainerCallback callback=IActivityContainerCallback.Stub.asInterface(data.readStrongBinder());
IActivityContainer activityContainer=createVirtualActivityContainer(parentActivityToken,callback);
reply.writeNoException();
if (activityContainer != null) {
reply.writeInt(1);
reply.writeStrongBinder(activityContainer.asBinder());
}
 else {
reply.writeInt(0);
}
return true;
}
case DELETE_ACTIVITY_CONTAINER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IActivityContainer activityContainer=IActivityContainer.Stub.asInterface(data.readStrongBinder());
deleteActivityContainer(activityContainer);
reply.writeNoException();
return true;
}
case CREATE_STACK_ON_DISPLAY:
{
data.enforceInterface(IActivityManager.descriptor);
int displayId=data.readInt();
IActivityContainer activityContainer=createStackOnDisplay(displayId);
reply.writeNoException();
if (activityContainer != null) {
reply.writeInt(1);
reply.writeStrongBinder(activityContainer.asBinder());
}
 else {
reply.writeInt(0);
}
return true;
}
case GET_ACTIVITY_DISPLAY_ID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder activityToken=data.readStrongBinder();
int displayId=getActivityDisplayId(activityToken);
reply.writeNoException();
reply.writeInt(displayId);
return true;
}
case START_LOCK_TASK_BY_TASK_ID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int taskId=data.readInt();
startLockTaskMode(taskId);
reply.writeNoException();
return true;
}
case START_LOCK_TASK_BY_TOKEN_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
startLockTaskMode(token);
reply.writeNoException();
return true;
}
case START_LOCK_TASK_BY_CURRENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
startLockTaskModeOnCurrent();
reply.writeNoException();
return true;
}
case STOP_LOCK_TASK_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopLockTaskMode();
reply.writeNoException();
return true;
}
case STOP_LOCK_TASK_BY_CURRENT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
stopLockTaskModeOnCurrent();
reply.writeNoException();
return true;
}
case IS_IN_LOCK_TASK_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean isInLockTaskMode=isInLockTaskMode();
reply.writeNoException();
reply.writeInt(isInLockTaskMode ? 1 : 0);
return true;
}
case GET_LOCK_TASK_MODE_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int lockTaskModeState=getLockTaskModeState();
reply.writeNoException();
reply.writeInt(lockTaskModeState);
return true;
}
case SHOW_LOCK_TASK_ESCAPE_MESSAGE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
showLockTaskEscapeMessage(token);
reply.writeNoException();
return true;
}
case SET_TASK_DESCRIPTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
ActivityManager.TaskDescription values=ActivityManager.TaskDescription.CREATOR.createFromParcel(data);
setTaskDescription(token,values);
reply.writeNoException();
return true;
}
case SET_TASK_RESIZEABLE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int taskId=data.readInt();
final int resizeableMode=data.readInt();
setTaskResizeable(taskId,resizeableMode);
reply.writeNoException();
return true;
}
case RESIZE_TASK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
int resizeMode=data.readInt();
Rect r=Rect.CREATOR.createFromParcel(data);
resizeTask(taskId,r,resizeMode);
reply.writeNoException();
return true;
}
case GET_TASK_BOUNDS_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int taskId=data.readInt();
Rect r=getTaskBounds(taskId);
reply.writeNoException();
r.writeToParcel(reply,0);
return true;
}
case GET_TASK_DESCRIPTION_ICON_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String filename=data.readString();
int userId=data.readInt();
Bitmap icon=getTaskDescriptionIcon(filename,userId);
reply.writeNoException();
if (icon == null) {
reply.writeInt(0);
}
 else {
reply.writeInt(1);
icon.writeToParcel(reply,0);
}
return true;
}
case START_IN_PLACE_ANIMATION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final Bundle bundle;
if (data.readInt() == 0) {
bundle=null;
}
 else {
bundle=data.readBundle();
}
final ActivityOptions options=ActivityOptions.fromBundle(bundle);
startInPlaceAnimationOnFrontMostApplication(options);
reply.writeNoException();
return true;
}
case REQUEST_VISIBLE_BEHIND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean enable=data.readInt() > 0;
boolean success=requestVisibleBehind(token,enable);
reply.writeNoException();
reply.writeInt(success ? 1 : 0);
return true;
}
case IS_BACKGROUND_VISIBLE_BEHIND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
final boolean enabled=isBackgroundVisibleBehind(token);
reply.writeNoException();
reply.writeInt(enabled ? 1 : 0);
return true;
}
case BACKGROUND_RESOURCES_RELEASED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
backgroundResourcesReleased(token);
reply.writeNoException();
return true;
}
case NOTIFY_LAUNCH_TASK_BEHIND_COMPLETE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
notifyLaunchTaskBehindComplete(token);
reply.writeNoException();
return true;
}
case NOTIFY_ENTER_ANIMATION_COMPLETE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
notifyEnterAnimationComplete(token);
reply.writeNoException();
return true;
}
case BOOT_ANIMATION_COMPLETE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
bootAnimationComplete();
reply.writeNoException();
return true;
}
case NOTIFY_CLEARTEXT_NETWORK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int uid=data.readInt();
final byte[] firstPacket=data.createByteArray();
notifyCleartextNetwork(uid,firstPacket);
reply.writeNoException();
return true;
}
case SET_DUMP_HEAP_DEBUG_LIMIT_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String procName=data.readString();
int uid=data.readInt();
long maxMemSize=data.readLong();
String reportPackage=data.readString();
setDumpHeapDebugLimit(procName,uid,maxMemSize,reportPackage);
reply.writeNoException();
return true;
}
case DUMP_HEAP_FINISHED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String path=data.readString();
dumpHeapFinished(path);
reply.writeNoException();
return true;
}
case SET_VOICE_KEEP_AWAKE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IVoiceInteractionSession session=IVoiceInteractionSession.Stub.asInterface(data.readStrongBinder());
boolean keepAwake=data.readInt() != 0;
setVoiceKeepAwake(session,keepAwake);
reply.writeNoException();
return true;
}
case UPDATE_LOCK_TASK_PACKAGES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
int userId=data.readInt();
String[] packages=data.readStringArray();
updateLockTaskPackages(userId,packages);
reply.writeNoException();
return true;
}
case UPDATE_DEVICE_OWNER_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String packageName=data.readString();
updateDeviceOwner(packageName);
reply.writeNoException();
return true;
}
case GET_PACKAGE_PROCESS_STATE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String pkg=data.readString();
String callingPackage=data.readString();
int res=getPackageProcessState(pkg,callingPackage);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case SET_PROCESS_MEMORY_TRIM_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
String process=data.readString();
int userId=data.readInt();
int level=data.readInt();
boolean res=setProcessMemoryTrimLevel(process,userId,level);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case IS_ROOT_VOICE_INTERACTION_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
boolean res=isRootVoiceInteraction(token);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case START_BINDER_TRACKING_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
boolean res=startBinderTracking();
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case STOP_BINDER_TRACKING_AND_DUMP_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
ParcelFileDescriptor fd=data.readInt() != 0 ? ParcelFileDescriptor.CREATOR.createFromParcel(data) : null;
boolean res=stopBinderTrackingAndDump(fd);
reply.writeNoException();
reply.writeInt(res ? 1 : 0);
return true;
}
case GET_ACTIVITY_STACK_ID_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int stackId=getActivityStackId(token);
reply.writeNoException();
reply.writeInt(stackId);
return true;
}
case EXIT_FREEFORM_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
exitFreeformMode(token);
reply.writeNoException();
return true;
}
case REPORT_SIZE_CONFIGURATIONS:
{
data.enforceInterface(IActivityManager.descriptor);
IBinder token=data.readStrongBinder();
int[] horizontal=readIntArray(data);
int[] vertical=readIntArray(data);
int[] smallest=readIntArray(data);
reportSizeConfigurations(token,horizontal,vertical,smallest);
return true;
}
case SUPPRESS_RESIZE_CONFIG_CHANGES_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final boolean suppress=data.readInt() == 1;
suppressResizeConfigChanges(suppress);
reply.writeNoException();
return true;
}
case MOVE_TASKS_TO_FULLSCREEN_STACK_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int stackId=data.readInt();
final boolean onTop=data.readInt() == 1;
moveTasksToFullscreenStack(stackId,onTop);
reply.writeNoException();
return true;
}
case GET_APP_START_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int uid=data.readInt();
final String pkg=data.readString();
int res=getAppStartMode(uid,pkg);
reply.writeNoException();
reply.writeInt(res);
return true;
}
case IN_MULTI_WINDOW_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
final boolean inMultiWindow=inMultiWindow(token);
reply.writeNoException();
reply.writeInt(inMultiWindow ? 1 : 0);
return true;
}
case IN_PICTURE_IN_PICTURE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
final boolean inPip=inPictureInPicture(token);
reply.writeNoException();
reply.writeInt(inPip ? 1 : 0);
return true;
}
case ENTER_PICTURE_IN_PICTURE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
enterPictureInPicture(token);
reply.writeNoException();
return true;
}
case SET_VR_MODE_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final IBinder token=data.readStrongBinder();
final boolean enable=data.readInt() == 1;
setVrMode(token,enable);
reply.writeNoException();
return true;
}
case IS_APP_FOREGROUND_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
final int userHandle=data.readInt();
final boolean isForeground=isAppForeground(userHandle);
reply.writeNoException();
reply.writeInt(isForeground ? 1 : 0);
return true;
}
case NOTIFY_PINNED_STACK_ANIMATION_ENDED_TRANSACTION:
{
data.enforceInterface(IActivityManager.descriptor);
reply.writeNoException();
return true;
}
case REMOVE_STACK:
{
data.enforceInterface(IActivityManager.descriptor);
final int stackId=data.readInt();
removeStack(stackId);
reply.writeNoException();
return true;
}
}
return super.onTransact(code,data,reply,flags);
}",0.9996946564885496
192607,"public void setActivityController(IActivityController watcher) throws RemoteException {
  Parcel data=Parcel.obtain();
  Parcel reply=Parcel.obtain();
  data.writeInterfaceToken(IActivityManager.descriptor);
  data.writeStrongBinder(watcher != null ? watcher.asBinder() : null);
  mRemote.transact(SET_ACTIVITY_CONTROLLER_TRANSACTION,data,reply,0);
  reply.readException();
  data.recycle();
  reply.recycle();
}","public void setActivityController(IActivityController watcher,boolean imAMonkey) throws RemoteException {
  Parcel data=Parcel.obtain();
  Parcel reply=Parcel.obtain();
  data.writeInterfaceToken(IActivityManager.descriptor);
  data.writeStrongBinder(watcher != null ? watcher.asBinder() : null);
  data.writeInt(imAMonkey ? 1 : 0);
  mRemote.transact(SET_ACTIVITY_CONTROLLER_TRANSACTION,data,reply,0);
  reply.readException();
  data.recycle();
  reply.recycle();
}",0.938496583143508
192608,public void setActivityController(IActivityController watcher) throws RemoteException ;,"public void setActivityController(IActivityController watcher,boolean imAMonkey) throws RemoteException ;",0.90625
192609,"void dumpProcessesLocked(FileDescriptor fd,PrintWriter pw,String[] args,int opti,boolean dumpAll,String dumpPackage){
  boolean needSep=false;
  boolean printedAnything=false;
  int numPers=0;
  pw.println(""String_Node_Str"");
  if (dumpAll) {
    final int NP=mProcessNames.getMap().size();
    for (int ip=0; ip < NP; ip++) {
      SparseArray<ProcessRecord> procs=mProcessNames.getMap().valueAt(ip);
      final int NA=procs.size();
      for (int ia=0; ia < NA; ia++) {
        ProcessRecord r=procs.valueAt(ia);
        if (dumpPackage != null && !r.pkgList.containsKey(dumpPackage)) {
          continue;
        }
        if (!needSep) {
          pw.println(""String_Node_Str"");
          needSep=true;
          printedAnything=true;
        }
        pw.print(r.persistent ? ""String_Node_Str"" : ""String_Node_Str"");
        pw.print(""String_Node_Str"");
        pw.print(procs.keyAt(ia));
        pw.print(""String_Node_Str"");
        pw.println(r);
        r.dump(pw,""String_Node_Str"");
        if (r.persistent) {
          numPers++;
        }
      }
    }
  }
  if (mIsolatedProcesses.size() > 0) {
    boolean printed=false;
    for (int i=0; i < mIsolatedProcesses.size(); i++) {
      ProcessRecord r=mIsolatedProcesses.valueAt(i);
      if (dumpPackage != null && !r.pkgList.containsKey(dumpPackage)) {
        continue;
      }
      if (!printed) {
        if (needSep) {
          pw.println();
        }
        pw.println(""String_Node_Str"");
        printedAnything=true;
        printed=true;
        needSep=true;
      }
      pw.println(String.format(""String_Node_Str"",""String_Node_Str"",i,r.toString()));
    }
  }
  if (mActiveUids.size() > 0) {
    if (dumpUids(pw,dumpPackage,mActiveUids,""String_Node_Str"",needSep)) {
      printedAnything=needSep=true;
    }
  }
  if (mValidateUids.size() > 0) {
    if (dumpUids(pw,dumpPackage,mValidateUids,""String_Node_Str"",needSep)) {
      printedAnything=needSep=true;
    }
  }
  if (mLruProcesses.size() > 0) {
    if (needSep) {
      pw.println();
    }
    pw.print(""String_Node_Str"");
    pw.print(mLruProcesses.size());
    pw.print(""String_Node_Str"");
    pw.print(mLruProcesses.size() - mLruProcessActivityStart);
    pw.print(""String_Node_Str"");
    pw.print(mLruProcesses.size() - mLruProcessServiceStart);
    pw.println(""String_Node_Str"");
    dumpProcessOomList(pw,this,mLruProcesses,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false,dumpPackage);
    needSep=true;
    printedAnything=true;
  }
  if (dumpAll || dumpPackage != null) {
synchronized (mPidsSelfLocked) {
      boolean printed=false;
      for (int i=0; i < mPidsSelfLocked.size(); i++) {
        ProcessRecord r=mPidsSelfLocked.valueAt(i);
        if (dumpPackage != null && !r.pkgList.containsKey(dumpPackage)) {
          continue;
        }
        if (!printed) {
          if (needSep)           pw.println();
          needSep=true;
          pw.println(""String_Node_Str"");
          printed=true;
          printedAnything=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(mPidsSelfLocked.keyAt(i));
        pw.print(""String_Node_Str"");
        pw.println(mPidsSelfLocked.valueAt(i));
      }
    }
  }
  if (mForegroundProcesses.size() > 0) {
synchronized (mPidsSelfLocked) {
      boolean printed=false;
      for (int i=0; i < mForegroundProcesses.size(); i++) {
        ProcessRecord r=mPidsSelfLocked.get(mForegroundProcesses.valueAt(i).pid);
        if (dumpPackage != null && (r == null || !r.pkgList.containsKey(dumpPackage))) {
          continue;
        }
        if (!printed) {
          if (needSep)           pw.println();
          needSep=true;
          pw.println(""String_Node_Str"");
          printed=true;
          printedAnything=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(mForegroundProcesses.keyAt(i));
        pw.print(""String_Node_Str"");
        pw.println(mForegroundProcesses.valueAt(i));
      }
    }
  }
  if (mPersistentStartingProcesses.size() > 0) {
    if (needSep)     pw.println();
    needSep=true;
    printedAnything=true;
    pw.println(""String_Node_Str"");
    dumpProcessList(pw,this,mPersistentStartingProcesses,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",dumpPackage);
  }
  if (mRemovedProcesses.size() > 0) {
    if (needSep)     pw.println();
    needSep=true;
    printedAnything=true;
    pw.println(""String_Node_Str"");
    dumpProcessList(pw,this,mRemovedProcesses,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",dumpPackage);
  }
  if (mProcessesOnHold.size() > 0) {
    if (needSep)     pw.println();
    needSep=true;
    printedAnything=true;
    pw.println(""String_Node_Str"");
    dumpProcessList(pw,this,mProcessesOnHold,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",dumpPackage);
  }
  needSep=dumpProcessesToGc(fd,pw,args,opti,needSep,dumpAll,dumpPackage);
  needSep=mAppErrors.dumpLocked(fd,pw,needSep,dumpPackage);
  if (needSep) {
    printedAnything=true;
  }
  if (dumpPackage == null) {
    pw.println();
    needSep=false;
    mUserController.dump(pw,dumpAll);
  }
  if (mHomeProcess != null && (dumpPackage == null || mHomeProcess.pkgList.containsKey(dumpPackage))) {
    if (needSep) {
      pw.println();
      needSep=false;
    }
    pw.println(""String_Node_Str"" + mHomeProcess);
  }
  if (mPreviousProcess != null && (dumpPackage == null || mPreviousProcess.pkgList.containsKey(dumpPackage))) {
    if (needSep) {
      pw.println();
      needSep=false;
    }
    pw.println(""String_Node_Str"" + mPreviousProcess);
  }
  if (dumpAll) {
    StringBuilder sb=new StringBuilder(128);
    sb.append(""String_Node_Str"");
    TimeUtils.formatDuration(mPreviousProcessVisibleTime,sb);
    pw.println(sb);
  }
  if (mHeavyWeightProcess != null && (dumpPackage == null || mHeavyWeightProcess.pkgList.containsKey(dumpPackage))) {
    if (needSep) {
      pw.println();
      needSep=false;
    }
    pw.println(""String_Node_Str"" + mHeavyWeightProcess);
  }
  if (dumpPackage == null) {
    pw.println(""String_Node_Str"" + mConfiguration);
  }
  if (dumpAll) {
    pw.println(""String_Node_Str"" + getFocusedStack().mConfigWillChange);
    if (mCompatModePackages.getPackages().size() > 0) {
      boolean printed=false;
      for (      Map.Entry<String,Integer> entry : mCompatModePackages.getPackages().entrySet()) {
        String pkg=entry.getKey();
        int mode=entry.getValue();
        if (dumpPackage != null && !dumpPackage.equals(pkg)) {
          continue;
        }
        if (!printed) {
          pw.println(""String_Node_Str"");
          printed=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(pkg);
        pw.print(""String_Node_Str"");
        pw.print(mode);
        pw.println();
      }
    }
  }
  if (dumpPackage == null) {
    pw.println(""String_Node_Str"" + PowerManagerInternal.wakefulnessToString(mWakefulness));
    pw.println(""String_Node_Str"" + mSleepTokens);
    pw.println(""String_Node_Str"" + mSleeping + ""String_Node_Str""+ lockScreenShownToString());
    pw.println(""String_Node_Str"" + mShuttingDown + ""String_Node_Str""+ mTestPssMode);
    if (mRunningVoice != null) {
      pw.println(""String_Node_Str"" + mRunningVoice);
      pw.println(""String_Node_Str"" + mVoiceWakeLock);
    }
  }
  if (mDebugApp != null || mOrigDebugApp != null || mDebugTransient || mOrigWaitForDebugger) {
    if (dumpPackage == null || dumpPackage.equals(mDebugApp) || dumpPackage.equals(mOrigDebugApp)) {
      if (needSep) {
        pw.println();
        needSep=false;
      }
      pw.println(""String_Node_Str"" + mDebugApp + ""String_Node_Str""+ mOrigDebugApp+ ""String_Node_Str""+ mDebugTransient+ ""String_Node_Str""+ mOrigWaitForDebugger);
    }
  }
  if (mCurAppTimeTracker != null) {
    mCurAppTimeTracker.dumpWithHeader(pw,""String_Node_Str"",true);
  }
  if (mMemWatchProcesses.getMap().size() > 0) {
    pw.println(""String_Node_Str"");
    final ArrayMap<String,SparseArray<Pair<Long,String>>> procs=mMemWatchProcesses.getMap();
    for (int i=0; i < procs.size(); i++) {
      final String proc=procs.keyAt(i);
      final SparseArray<Pair<Long,String>> uids=procs.valueAt(i);
      for (int j=0; j < uids.size(); j++) {
        if (needSep) {
          pw.println();
          needSep=false;
        }
        StringBuilder sb=new StringBuilder();
        sb.append(""String_Node_Str"").append(proc).append('/');
        UserHandle.formatUid(sb,uids.keyAt(j));
        Pair<Long,String> val=uids.valueAt(j);
        sb.append(""String_Node_Str"");
        DebugUtils.sizeValueToString(val.first,sb);
        if (val.second != null) {
          sb.append(""String_Node_Str"").append(val.second);
        }
        pw.println(sb.toString());
      }
    }
    pw.print(""String_Node_Str"");
    pw.println(mMemWatchDumpProcName);
    pw.print(""String_Node_Str"");
    pw.println(mMemWatchDumpFile);
    pw.print(""String_Node_Str"");
    pw.print(mMemWatchDumpPid);
    pw.print(""String_Node_Str"");
    pw.println(mMemWatchDumpUid);
  }
  if (mTrackAllocationApp != null) {
    if (dumpPackage == null || dumpPackage.equals(mTrackAllocationApp)) {
      if (needSep) {
        pw.println();
        needSep=false;
      }
      pw.println(""String_Node_Str"" + mTrackAllocationApp);
    }
  }
  if (mProfileApp != null || mProfileProc != null || mProfileFile != null || mProfileFd != null) {
    if (dumpPackage == null || dumpPackage.equals(mProfileApp)) {
      if (needSep) {
        pw.println();
        needSep=false;
      }
      pw.println(""String_Node_Str"" + mProfileApp + ""String_Node_Str""+ mProfileProc);
      pw.println(""String_Node_Str"" + mProfileFile + ""String_Node_Str""+ mProfileFd);
      pw.println(""String_Node_Str"" + mSamplingInterval + ""String_Node_Str""+ mAutoStopProfiler);
      pw.println(""String_Node_Str"" + mProfileType);
    }
  }
  if (mNativeDebuggingApp != null) {
    if (dumpPackage == null || dumpPackage.equals(mNativeDebuggingApp)) {
      if (needSep) {
        pw.println();
        needSep=false;
      }
      pw.println(""String_Node_Str"" + mNativeDebuggingApp);
    }
  }
  if (dumpPackage == null) {
    if (mAlwaysFinishActivities || mLenientBackgroundCheck || mController != null) {
      pw.println(""String_Node_Str"" + mAlwaysFinishActivities + ""String_Node_Str""+ mLenientBackgroundCheck+ ""String_Node_Str""+ mController);
    }
    if (dumpAll) {
      pw.println(""String_Node_Str"" + numPers);
      pw.println(""String_Node_Str"" + mProcessesReady + ""String_Node_Str""+ mSystemReady+ ""String_Node_Str""+ mBooted+ ""String_Node_Str""+ mFactoryTest);
      pw.println(""String_Node_Str"" + mBooting + ""String_Node_Str""+ mCallFinishBooting+ ""String_Node_Str""+ mBootAnimationComplete);
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(mLastPowerCheckRealtime,pw);
      pw.println(""String_Node_Str"");
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(mLastPowerCheckUptime,pw);
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"" + mStackSupervisor.mGoingToSleep);
      pw.println(""String_Node_Str"" + mStackSupervisor.mLaunchingActivity);
      pw.println(""String_Node_Str"" + mAdjSeq + ""String_Node_Str""+ mLruSeq);
      pw.println(""String_Node_Str"" + mNumNonCachedProcs + ""String_Node_Str""+ mLruProcesses.size()+ ""String_Node_Str""+ ""String_Node_Str""+ mNumCachedHiddenProcs+ ""String_Node_Str""+ mNumServiceProcs+ ""String_Node_Str""+ mNewNumServiceProcs);
      pw.println(""String_Node_Str"" + mAllowLowerMemLevel + ""String_Node_Str""+ mLastMemoryLevel+ ""String_Node_Str""+ mLastNumProcesses);
      long now=SystemClock.uptimeMillis();
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(now,mLastIdleTime,pw);
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(getLowRamTimeSinceIdle(now),pw);
      pw.println();
    }
  }
  if (!printedAnything) {
    pw.println(""String_Node_Str"");
  }
}","void dumpProcessesLocked(FileDescriptor fd,PrintWriter pw,String[] args,int opti,boolean dumpAll,String dumpPackage){
  boolean needSep=false;
  boolean printedAnything=false;
  int numPers=0;
  pw.println(""String_Node_Str"");
  if (dumpAll) {
    final int NP=mProcessNames.getMap().size();
    for (int ip=0; ip < NP; ip++) {
      SparseArray<ProcessRecord> procs=mProcessNames.getMap().valueAt(ip);
      final int NA=procs.size();
      for (int ia=0; ia < NA; ia++) {
        ProcessRecord r=procs.valueAt(ia);
        if (dumpPackage != null && !r.pkgList.containsKey(dumpPackage)) {
          continue;
        }
        if (!needSep) {
          pw.println(""String_Node_Str"");
          needSep=true;
          printedAnything=true;
        }
        pw.print(r.persistent ? ""String_Node_Str"" : ""String_Node_Str"");
        pw.print(""String_Node_Str"");
        pw.print(procs.keyAt(ia));
        pw.print(""String_Node_Str"");
        pw.println(r);
        r.dump(pw,""String_Node_Str"");
        if (r.persistent) {
          numPers++;
        }
      }
    }
  }
  if (mIsolatedProcesses.size() > 0) {
    boolean printed=false;
    for (int i=0; i < mIsolatedProcesses.size(); i++) {
      ProcessRecord r=mIsolatedProcesses.valueAt(i);
      if (dumpPackage != null && !r.pkgList.containsKey(dumpPackage)) {
        continue;
      }
      if (!printed) {
        if (needSep) {
          pw.println();
        }
        pw.println(""String_Node_Str"");
        printedAnything=true;
        printed=true;
        needSep=true;
      }
      pw.println(String.format(""String_Node_Str"",""String_Node_Str"",i,r.toString()));
    }
  }
  if (mActiveUids.size() > 0) {
    if (dumpUids(pw,dumpPackage,mActiveUids,""String_Node_Str"",needSep)) {
      printedAnything=needSep=true;
    }
  }
  if (mValidateUids.size() > 0) {
    if (dumpUids(pw,dumpPackage,mValidateUids,""String_Node_Str"",needSep)) {
      printedAnything=needSep=true;
    }
  }
  if (mLruProcesses.size() > 0) {
    if (needSep) {
      pw.println();
    }
    pw.print(""String_Node_Str"");
    pw.print(mLruProcesses.size());
    pw.print(""String_Node_Str"");
    pw.print(mLruProcesses.size() - mLruProcessActivityStart);
    pw.print(""String_Node_Str"");
    pw.print(mLruProcesses.size() - mLruProcessServiceStart);
    pw.println(""String_Node_Str"");
    dumpProcessOomList(pw,this,mLruProcesses,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false,dumpPackage);
    needSep=true;
    printedAnything=true;
  }
  if (dumpAll || dumpPackage != null) {
synchronized (mPidsSelfLocked) {
      boolean printed=false;
      for (int i=0; i < mPidsSelfLocked.size(); i++) {
        ProcessRecord r=mPidsSelfLocked.valueAt(i);
        if (dumpPackage != null && !r.pkgList.containsKey(dumpPackage)) {
          continue;
        }
        if (!printed) {
          if (needSep)           pw.println();
          needSep=true;
          pw.println(""String_Node_Str"");
          printed=true;
          printedAnything=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(mPidsSelfLocked.keyAt(i));
        pw.print(""String_Node_Str"");
        pw.println(mPidsSelfLocked.valueAt(i));
      }
    }
  }
  if (mForegroundProcesses.size() > 0) {
synchronized (mPidsSelfLocked) {
      boolean printed=false;
      for (int i=0; i < mForegroundProcesses.size(); i++) {
        ProcessRecord r=mPidsSelfLocked.get(mForegroundProcesses.valueAt(i).pid);
        if (dumpPackage != null && (r == null || !r.pkgList.containsKey(dumpPackage))) {
          continue;
        }
        if (!printed) {
          if (needSep)           pw.println();
          needSep=true;
          pw.println(""String_Node_Str"");
          printed=true;
          printedAnything=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(mForegroundProcesses.keyAt(i));
        pw.print(""String_Node_Str"");
        pw.println(mForegroundProcesses.valueAt(i));
      }
    }
  }
  if (mPersistentStartingProcesses.size() > 0) {
    if (needSep)     pw.println();
    needSep=true;
    printedAnything=true;
    pw.println(""String_Node_Str"");
    dumpProcessList(pw,this,mPersistentStartingProcesses,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",dumpPackage);
  }
  if (mRemovedProcesses.size() > 0) {
    if (needSep)     pw.println();
    needSep=true;
    printedAnything=true;
    pw.println(""String_Node_Str"");
    dumpProcessList(pw,this,mRemovedProcesses,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",dumpPackage);
  }
  if (mProcessesOnHold.size() > 0) {
    if (needSep)     pw.println();
    needSep=true;
    printedAnything=true;
    pw.println(""String_Node_Str"");
    dumpProcessList(pw,this,mProcessesOnHold,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",dumpPackage);
  }
  needSep=dumpProcessesToGc(fd,pw,args,opti,needSep,dumpAll,dumpPackage);
  needSep=mAppErrors.dumpLocked(fd,pw,needSep,dumpPackage);
  if (needSep) {
    printedAnything=true;
  }
  if (dumpPackage == null) {
    pw.println();
    needSep=false;
    mUserController.dump(pw,dumpAll);
  }
  if (mHomeProcess != null && (dumpPackage == null || mHomeProcess.pkgList.containsKey(dumpPackage))) {
    if (needSep) {
      pw.println();
      needSep=false;
    }
    pw.println(""String_Node_Str"" + mHomeProcess);
  }
  if (mPreviousProcess != null && (dumpPackage == null || mPreviousProcess.pkgList.containsKey(dumpPackage))) {
    if (needSep) {
      pw.println();
      needSep=false;
    }
    pw.println(""String_Node_Str"" + mPreviousProcess);
  }
  if (dumpAll) {
    StringBuilder sb=new StringBuilder(128);
    sb.append(""String_Node_Str"");
    TimeUtils.formatDuration(mPreviousProcessVisibleTime,sb);
    pw.println(sb);
  }
  if (mHeavyWeightProcess != null && (dumpPackage == null || mHeavyWeightProcess.pkgList.containsKey(dumpPackage))) {
    if (needSep) {
      pw.println();
      needSep=false;
    }
    pw.println(""String_Node_Str"" + mHeavyWeightProcess);
  }
  if (dumpPackage == null) {
    pw.println(""String_Node_Str"" + mConfiguration);
  }
  if (dumpAll) {
    pw.println(""String_Node_Str"" + getFocusedStack().mConfigWillChange);
    if (mCompatModePackages.getPackages().size() > 0) {
      boolean printed=false;
      for (      Map.Entry<String,Integer> entry : mCompatModePackages.getPackages().entrySet()) {
        String pkg=entry.getKey();
        int mode=entry.getValue();
        if (dumpPackage != null && !dumpPackage.equals(pkg)) {
          continue;
        }
        if (!printed) {
          pw.println(""String_Node_Str"");
          printed=true;
        }
        pw.print(""String_Node_Str"");
        pw.print(pkg);
        pw.print(""String_Node_Str"");
        pw.print(mode);
        pw.println();
      }
    }
  }
  if (dumpPackage == null) {
    pw.println(""String_Node_Str"" + PowerManagerInternal.wakefulnessToString(mWakefulness));
    pw.println(""String_Node_Str"" + mSleepTokens);
    pw.println(""String_Node_Str"" + mSleeping + ""String_Node_Str""+ lockScreenShownToString());
    pw.println(""String_Node_Str"" + mShuttingDown + ""String_Node_Str""+ mTestPssMode);
    if (mRunningVoice != null) {
      pw.println(""String_Node_Str"" + mRunningVoice);
      pw.println(""String_Node_Str"" + mVoiceWakeLock);
    }
  }
  if (mDebugApp != null || mOrigDebugApp != null || mDebugTransient || mOrigWaitForDebugger) {
    if (dumpPackage == null || dumpPackage.equals(mDebugApp) || dumpPackage.equals(mOrigDebugApp)) {
      if (needSep) {
        pw.println();
        needSep=false;
      }
      pw.println(""String_Node_Str"" + mDebugApp + ""String_Node_Str""+ mOrigDebugApp+ ""String_Node_Str""+ mDebugTransient+ ""String_Node_Str""+ mOrigWaitForDebugger);
    }
  }
  if (mCurAppTimeTracker != null) {
    mCurAppTimeTracker.dumpWithHeader(pw,""String_Node_Str"",true);
  }
  if (mMemWatchProcesses.getMap().size() > 0) {
    pw.println(""String_Node_Str"");
    final ArrayMap<String,SparseArray<Pair<Long,String>>> procs=mMemWatchProcesses.getMap();
    for (int i=0; i < procs.size(); i++) {
      final String proc=procs.keyAt(i);
      final SparseArray<Pair<Long,String>> uids=procs.valueAt(i);
      for (int j=0; j < uids.size(); j++) {
        if (needSep) {
          pw.println();
          needSep=false;
        }
        StringBuilder sb=new StringBuilder();
        sb.append(""String_Node_Str"").append(proc).append('/');
        UserHandle.formatUid(sb,uids.keyAt(j));
        Pair<Long,String> val=uids.valueAt(j);
        sb.append(""String_Node_Str"");
        DebugUtils.sizeValueToString(val.first,sb);
        if (val.second != null) {
          sb.append(""String_Node_Str"").append(val.second);
        }
        pw.println(sb.toString());
      }
    }
    pw.print(""String_Node_Str"");
    pw.println(mMemWatchDumpProcName);
    pw.print(""String_Node_Str"");
    pw.println(mMemWatchDumpFile);
    pw.print(""String_Node_Str"");
    pw.print(mMemWatchDumpPid);
    pw.print(""String_Node_Str"");
    pw.println(mMemWatchDumpUid);
  }
  if (mTrackAllocationApp != null) {
    if (dumpPackage == null || dumpPackage.equals(mTrackAllocationApp)) {
      if (needSep) {
        pw.println();
        needSep=false;
      }
      pw.println(""String_Node_Str"" + mTrackAllocationApp);
    }
  }
  if (mProfileApp != null || mProfileProc != null || mProfileFile != null || mProfileFd != null) {
    if (dumpPackage == null || dumpPackage.equals(mProfileApp)) {
      if (needSep) {
        pw.println();
        needSep=false;
      }
      pw.println(""String_Node_Str"" + mProfileApp + ""String_Node_Str""+ mProfileProc);
      pw.println(""String_Node_Str"" + mProfileFile + ""String_Node_Str""+ mProfileFd);
      pw.println(""String_Node_Str"" + mSamplingInterval + ""String_Node_Str""+ mAutoStopProfiler);
      pw.println(""String_Node_Str"" + mProfileType);
    }
  }
  if (mNativeDebuggingApp != null) {
    if (dumpPackage == null || dumpPackage.equals(mNativeDebuggingApp)) {
      if (needSep) {
        pw.println();
        needSep=false;
      }
      pw.println(""String_Node_Str"" + mNativeDebuggingApp);
    }
  }
  if (dumpPackage == null) {
    if (mAlwaysFinishActivities || mLenientBackgroundCheck) {
      pw.println(""String_Node_Str"" + mAlwaysFinishActivities + ""String_Node_Str""+ mLenientBackgroundCheck);
    }
    if (mController != null) {
      pw.println(""String_Node_Str"" + mController + ""String_Node_Str""+ mControllerIsAMonkey);
    }
    if (dumpAll) {
      pw.println(""String_Node_Str"" + numPers);
      pw.println(""String_Node_Str"" + mProcessesReady + ""String_Node_Str""+ mSystemReady+ ""String_Node_Str""+ mBooted+ ""String_Node_Str""+ mFactoryTest);
      pw.println(""String_Node_Str"" + mBooting + ""String_Node_Str""+ mCallFinishBooting+ ""String_Node_Str""+ mBootAnimationComplete);
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(mLastPowerCheckRealtime,pw);
      pw.println(""String_Node_Str"");
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(mLastPowerCheckUptime,pw);
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"" + mStackSupervisor.mGoingToSleep);
      pw.println(""String_Node_Str"" + mStackSupervisor.mLaunchingActivity);
      pw.println(""String_Node_Str"" + mAdjSeq + ""String_Node_Str""+ mLruSeq);
      pw.println(""String_Node_Str"" + mNumNonCachedProcs + ""String_Node_Str""+ mLruProcesses.size()+ ""String_Node_Str""+ ""String_Node_Str""+ mNumCachedHiddenProcs+ ""String_Node_Str""+ mNumServiceProcs+ ""String_Node_Str""+ mNewNumServiceProcs);
      pw.println(""String_Node_Str"" + mAllowLowerMemLevel + ""String_Node_Str""+ mLastMemoryLevel+ ""String_Node_Str""+ mLastNumProcesses);
      long now=SystemClock.uptimeMillis();
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(now,mLastIdleTime,pw);
      pw.print(""String_Node_Str"");
      TimeUtils.formatDuration(getLowRamTimeSinceIdle(now),pw);
      pw.println();
    }
  }
  if (!printedAnything) {
    pw.println(""String_Node_Str"");
  }
}",0.9488423094766142
192610,"@Override public void setActivityController(IActivityController controller){
  enforceCallingPermission(android.Manifest.permission.SET_ACTIVITY_WATCHER,""String_Node_Str"");
synchronized (this) {
    mController=controller;
    Watchdog.getInstance().setActivityController(controller);
  }
}","@Override public void setActivityController(IActivityController controller,boolean imAMonkey){
  enforceCallingPermission(android.Manifest.permission.SET_ACTIVITY_WATCHER,""String_Node_Str"");
synchronized (this) {
    mController=controller;
    mControllerIsAMonkey=imAMonkey;
    Watchdog.getInstance().setActivityController(controller);
  }
}",0.9148264984227128
192611,"@Override public boolean isUserAMonkey(){
synchronized (this) {
    return (mUserIsMonkey || mController != null);
  }
}","@Override public boolean isUserAMonkey(){
synchronized (this) {
    return (mUserIsMonkey || (mController != null && mControllerIsAMonkey));
  }
}",0.9022556390977444
192612,"@SmallTest public void testSET_ACTIVITY_WATCHER(){
  try {
    mAm.setActivityController(null);
    fail(""String_Node_Str"" + ""String_Node_Str"");
  }
 catch (  SecurityException e) {
  }
catch (  RemoteException e) {
    fail(""String_Node_Str"");
  }
}","@SmallTest public void testSET_ACTIVITY_WATCHER(){
  try {
    mAm.setActivityController(null,false);
    fail(""String_Node_Str"" + ""String_Node_Str"");
  }
 catch (  SecurityException e) {
  }
catch (  RemoteException e) {
    fail(""String_Node_Str"");
  }
}",0.9881422924901184
192613,"public void setDark(boolean dark,boolean fade,long delay,boolean force){
  if ((!force && mDark == dark) || mContractedChild == null) {
    return;
  }
  mDark=dark;
  dark=dark && !mShowingLegacyBackground;
  if (mVisibleType == VISIBLE_TYPE_CONTRACTED || !dark) {
    mContractedWrapper.setDark(dark,fade,delay);
  }
  if (mVisibleType == VISIBLE_TYPE_EXPANDED || (mExpandedChild != null && !dark)) {
    mExpandedWrapper.setDark(dark,fade,delay);
  }
  if (mVisibleType == VISIBLE_TYPE_HEADSUP || (mHeadsUpChild != null && !dark)) {
    mHeadsUpWrapper.setDark(dark,fade,delay);
  }
  if (mSingleLineView != null && (mVisibleType == VISIBLE_TYPE_SINGLELINE || !dark)) {
    mSingleLineView.setDark(dark,fade,delay);
  }
}","public void setDark(boolean dark,boolean fade,long delay){
  if (mContractedChild == null) {
    return;
  }
  mDark=dark;
  dark=dark && !mShowingLegacyBackground;
  if (mVisibleType == VISIBLE_TYPE_CONTRACTED || !dark) {
    mContractedWrapper.setDark(dark,fade,delay);
  }
  if (mVisibleType == VISIBLE_TYPE_EXPANDED || (mExpandedChild != null && !dark)) {
    mExpandedWrapper.setDark(dark,fade,delay);
  }
  if (mVisibleType == VISIBLE_TYPE_HEADSUP || (mHeadsUpChild != null && !dark)) {
    mHeadsUpWrapper.setDark(dark,fade,delay);
  }
  if (mSingleLineView != null && (mVisibleType == VISIBLE_TYPE_SINGLELINE || !dark)) {
    mSingleLineView.setDark(dark,fade,delay);
  }
}",0.9693950177935944
192614,"public void onNotificationUpdated(NotificationData.Entry entry){
  mStatusBarNotification=entry.notification;
  mBeforeN=entry.targetSdk < Build.VERSION_CODES.N;
  updateSingleLineView();
  applyRemoteInput(entry);
  selectLayout(false,true);
  if (mContractedChild != null) {
    mContractedWrapper.notifyContentUpdated(entry.notification);
  }
  if (mExpandedChild != null) {
    mExpandedWrapper.notifyContentUpdated(entry.notification);
  }
  if (mHeadsUpChild != null) {
    mHeadsUpWrapper.notifyContentUpdated(entry.notification);
  }
  setDark(mDark,false,0,true);
}","public void onNotificationUpdated(NotificationData.Entry entry){
  mStatusBarNotification=entry.notification;
  mBeforeN=entry.targetSdk < Build.VERSION_CODES.N;
  updateSingleLineView();
  applyRemoteInput(entry);
  selectLayout(false,true);
  if (mContractedChild != null) {
    mContractedWrapper.notifyContentUpdated(entry.notification);
  }
  if (mExpandedChild != null) {
    mExpandedWrapper.notifyContentUpdated(entry.notification);
  }
  if (mHeadsUpChild != null) {
    mHeadsUpWrapper.notifyContentUpdated(entry.notification);
  }
  setDark(mDark,false,0);
}",0.9956255468066492
192615,"@Override public void setDark(boolean dark,boolean fade,long delay){
  if (dark == mDark) {
    return;
  }
  super.setDark(dark,fade,delay);
  if (fade) {
    mInvertHelper.fade(dark,delay);
  }
 else {
    mInvertHelper.update(dark);
  }
}","@Override public void setDark(boolean dark,boolean fade,long delay){
  if (dark == mDark && mDarkInitialized) {
    return;
  }
  super.setDark(dark,fade,delay);
  if (fade) {
    mInvertHelper.fade(dark,delay);
  }
 else {
    mInvertHelper.update(dark);
  }
}",0.9601593625498008
192616,"@Override public void setDark(boolean dark,boolean fade,long delay){
  if (dark == mDark) {
    return;
  }
  super.setDark(dark,fade,delay);
  if (fade) {
    mInvertHelper.fade(dark,delay);
  }
 else {
    mInvertHelper.update(dark);
  }
  if (mIcon != null) {
    boolean hadColorFilter=mNotificationHeader.getOriginalIconColor() != NotificationHeaderView.NO_COLOR;
    if (fade) {
      if (hadColorFilter) {
        fadeIconColorFilter(mIcon,dark,delay);
        fadeIconAlpha(mIcon,dark,delay);
      }
 else {
        fadeGrayscale(mIcon,dark,delay);
      }
    }
 else {
      if (hadColorFilter) {
        updateIconColorFilter(mIcon,dark);
        updateIconAlpha(mIcon,dark);
      }
 else {
        updateGrayscale(mIcon,dark);
      }
    }
  }
}","@Override public void setDark(boolean dark,boolean fade,long delay){
  if (dark == mDark && mDarkInitialized) {
    return;
  }
  super.setDark(dark,fade,delay);
  if (fade) {
    mInvertHelper.fade(dark,delay);
  }
 else {
    mInvertHelper.update(dark);
  }
  if (mIcon != null) {
    boolean hadColorFilter=mNotificationHeader.getOriginalIconColor() != NotificationHeaderView.NO_COLOR;
    if (fade) {
      if (hadColorFilter) {
        fadeIconColorFilter(mIcon,dark,delay);
        fadeIconAlpha(mIcon,dark,delay);
      }
 else {
        fadeGrayscale(mIcon,dark,delay);
      }
    }
 else {
      if (hadColorFilter) {
        updateIconColorFilter(mIcon,dark);
        updateIconAlpha(mIcon,dark);
      }
 else {
        updateGrayscale(mIcon,dark);
      }
    }
  }
}",0.987012987012987
192617,"@Override public void setDark(boolean dark,boolean fade,long delay){
  if (dark == mDark) {
    return;
  }
  super.setDark(dark,fade,delay);
  setPictureGrayscale(dark,fade,delay);
  setProgressBarDark(dark,fade,delay);
}","@Override public void setDark(boolean dark,boolean fade,long delay){
  if (dark == mDark && mDarkInitialized) {
    return;
  }
  super.setDark(dark,fade,delay);
  setPictureGrayscale(dark,fade,delay);
  setProgressBarDark(dark,fade,delay);
}",0.956896551724138
192618,"/** 
 * In dark mode, we draw as little as possible, assuming a black background.
 * @param dark whether we should display ourselves in dark mode
 * @param fade whether to animate the transition if the mode changes
 * @param delay if fading, the delay of the animation
 */
public void setDark(boolean dark,boolean fade,long delay){
  mDark=dark;
}","/** 
 * In dark mode, we draw as little as possible, assuming a black background.
 * @param dark whether we should display ourselves in dark mode
 * @param fade whether to animate the transition if the mode changes
 * @param delay if fading, the delay of the animation
 */
public void setDark(boolean dark,boolean fade,long delay){
  mDark=dark;
  mDarkInitialized=true;
}",0.965229485396384
192619,"/** 
 * Notifies this wrapper that the content of the view might have changed.
 * @param notification
 */
public void notifyContentUpdated(StatusBarNotification notification){
  mDark=false;
}","/** 
 * Notifies this wrapper that the content of the view might have changed.
 * @param notification
 */
public void notifyContentUpdated(StatusBarNotification notification){
  mDarkInitialized=false;
}",0.9721518987341772
192620,"/** 
 * Distribute WiFi energy info and network traffic to apps.
 * @param info The energy information from the WiFi controller.
 */
public void updateWifiStateLocked(@Nullable final WifiActivityEnergyInfo info){
  if (DEBUG_ENERGY) {
    Slog.d(TAG,""String_Node_Str"");
  }
  final long elapsedRealtimeMs=mClocks.elapsedRealtime();
  NetworkStats delta=null;
  try {
    if (!ArrayUtils.isEmpty(mWifiIfaces)) {
      delta=getNetworkStatsDeltaLocked(mWifiIfaces,mWifiNetworkStats);
    }
  }
 catch (  IOException e) {
    Slog.wtf(TAG,""String_Node_Str"",e);
    return;
  }
  if (!mOnBatteryInternal) {
    return;
  }
  SparseLongArray rxPackets=new SparseLongArray();
  SparseLongArray txPackets=new SparseLongArray();
  long totalTxPackets=0;
  long totalRxPackets=0;
  if (delta != null) {
    final int size=delta.size();
    for (int i=0; i < size; i++) {
      final NetworkStats.Entry entry=delta.getValues(i,mTmpNetworkStatsEntry);
      if (DEBUG_ENERGY) {
        Slog.d(TAG,""String_Node_Str"" + entry.uid + ""String_Node_Str""+ entry.rxBytes+ ""String_Node_Str""+ entry.txBytes+ ""String_Node_Str""+ entry.rxPackets+ ""String_Node_Str""+ entry.txPackets);
      }
      if (entry.rxBytes == 0 || entry.txBytes == 0) {
        continue;
      }
      final Uid u=getUidStatsLocked(mapUid(entry.uid));
      if (entry.rxBytes != 0) {
        u.noteNetworkActivityLocked(NETWORK_WIFI_RX_DATA,entry.rxBytes,entry.rxPackets);
        mNetworkByteActivityCounters[NETWORK_WIFI_RX_DATA].addCountLocked(entry.rxBytes);
        mNetworkPacketActivityCounters[NETWORK_WIFI_RX_DATA].addCountLocked(entry.rxPackets);
        rxPackets.put(u.getUid(),entry.rxPackets);
        totalRxPackets+=entry.rxPackets;
      }
      if (entry.txBytes != 0) {
        u.noteNetworkActivityLocked(NETWORK_WIFI_TX_DATA,entry.txBytes,entry.txPackets);
        mNetworkByteActivityCounters[NETWORK_WIFI_TX_DATA].addCountLocked(entry.txBytes);
        mNetworkPacketActivityCounters[NETWORK_WIFI_TX_DATA].addCountLocked(entry.txPackets);
        txPackets.put(u.getUid(),entry.txPackets);
        totalTxPackets+=entry.txPackets;
      }
    }
  }
  if (info != null) {
    mHasWifiReporting=true;
    final long txTimeMs=info.getControllerTxTimeMillis();
    final long rxTimeMs=info.getControllerRxTimeMillis();
    final long idleTimeMs=info.getControllerIdleTimeMillis();
    final long totalTimeMs=txTimeMs + rxTimeMs + idleTimeMs;
    long leftOverRxTimeMs=rxTimeMs;
    long leftOverTxTimeMs=txTimeMs;
    if (DEBUG_ENERGY) {
      Slog.d(TAG,""String_Node_Str"");
      Slog.d(TAG,""String_Node_Str"" + txTimeMs + ""String_Node_Str"");
      Slog.d(TAG,""String_Node_Str"" + rxTimeMs + ""String_Node_Str"");
      Slog.d(TAG,""String_Node_Str"" + idleTimeMs + ""String_Node_Str"");
      Slog.d(TAG,""String_Node_Str"" + totalTimeMs + ""String_Node_Str"");
    }
    long totalWifiLockTimeMs=0;
    long totalScanTimeMs=0;
    final int uidStatsSize=mUidStats.size();
    for (int i=0; i < uidStatsSize; i++) {
      final Uid uid=mUidStats.valueAt(i);
      totalScanTimeMs+=uid.mWifiScanTimer.getTimeSinceMarkLocked(elapsedRealtimeMs * 1000) / 1000;
      totalWifiLockTimeMs+=uid.mFullWifiLockTimer.getTimeSinceMarkLocked(elapsedRealtimeMs * 1000) / 1000;
    }
    if (DEBUG_ENERGY && totalScanTimeMs > rxTimeMs) {
      Slog.d(TAG,""String_Node_Str"" + totalScanTimeMs + ""String_Node_Str""+ rxTimeMs+ ""String_Node_Str"");
    }
    if (DEBUG_ENERGY && totalScanTimeMs > txTimeMs) {
      Slog.d(TAG,""String_Node_Str"" + totalScanTimeMs + ""String_Node_Str""+ txTimeMs+ ""String_Node_Str"");
    }
    for (int i=0; i < uidStatsSize; i++) {
      final Uid uid=mUidStats.valueAt(i);
      long scanTimeSinceMarkMs=uid.mWifiScanTimer.getTimeSinceMarkLocked(elapsedRealtimeMs * 1000) / 1000;
      if (scanTimeSinceMarkMs > 0) {
        uid.mWifiScanTimer.setMark(elapsedRealtimeMs);
        long scanRxTimeSinceMarkMs=scanTimeSinceMarkMs;
        long scanTxTimeSinceMarkMs=scanTimeSinceMarkMs;
        if (totalScanTimeMs > rxTimeMs) {
          scanRxTimeSinceMarkMs=(rxTimeMs * scanRxTimeSinceMarkMs) / totalScanTimeMs;
        }
        if (totalScanTimeMs > txTimeMs) {
          scanTxTimeSinceMarkMs=(txTimeMs * scanTxTimeSinceMarkMs) / totalScanTimeMs;
        }
        if (DEBUG_ENERGY) {
          Slog.d(TAG,""String_Node_Str"" + uid.getUid() + ""String_Node_Str""+ scanRxTimeSinceMarkMs+ ""String_Node_Str""+ scanTxTimeSinceMarkMs+ ""String_Node_Str"");
        }
        ControllerActivityCounterImpl activityCounter=uid.getOrCreateWifiControllerActivityLocked();
        activityCounter.getRxTimeCounter().addCountLocked(scanRxTimeSinceMarkMs);
        activityCounter.getTxTimeCounters()[0].addCountLocked(scanTxTimeSinceMarkMs);
        leftOverRxTimeMs-=scanRxTimeSinceMarkMs;
        leftOverTxTimeMs-=scanTxTimeSinceMarkMs;
      }
      final long wifiLockTimeSinceMarkMs=uid.mFullWifiLockTimer.getTimeSinceMarkLocked(elapsedRealtimeMs * 1000) / 1000;
      if (wifiLockTimeSinceMarkMs > 0) {
        uid.mFullWifiLockTimer.setMark(elapsedRealtimeMs);
        final long myIdleTimeMs=(wifiLockTimeSinceMarkMs * idleTimeMs) / totalWifiLockTimeMs;
        if (DEBUG_ENERGY) {
          Slog.d(TAG,""String_Node_Str"" + uid.getUid() + ""String_Node_Str""+ myIdleTimeMs+ ""String_Node_Str"");
        }
        uid.getOrCreateWifiControllerActivityLocked().getIdleTimeCounter().addCountLocked(myIdleTimeMs);
      }
    }
    if (DEBUG_ENERGY) {
      Slog.d(TAG,""String_Node_Str"" + leftOverRxTimeMs + ""String_Node_Str"");
      Slog.d(TAG,""String_Node_Str"" + leftOverTxTimeMs + ""String_Node_Str"");
    }
    for (int i=0; i < txPackets.size(); i++) {
      final Uid uid=getUidStatsLocked(txPackets.keyAt(i));
      final long myTxTimeMs=(txPackets.valueAt(i) * leftOverTxTimeMs) / totalTxPackets;
      if (DEBUG_ENERGY) {
        Slog.d(TAG,""String_Node_Str"" + uid.getUid() + ""String_Node_Str""+ myTxTimeMs+ ""String_Node_Str"");
      }
      uid.getOrCreateWifiControllerActivityLocked().getTxTimeCounters()[0].addCountLocked(myTxTimeMs);
    }
    for (int i=0; i < rxPackets.size(); i++) {
      final Uid uid=getUidStatsLocked(rxPackets.keyAt(i));
      final long myRxTimeMs=(rxPackets.valueAt(i) * leftOverRxTimeMs) / totalRxPackets;
      if (DEBUG_ENERGY) {
        Slog.d(TAG,""String_Node_Str"" + uid.getUid() + ""String_Node_Str""+ myRxTimeMs+ ""String_Node_Str"");
      }
      uid.getOrCreateWifiControllerActivityLocked().getRxTimeCounter().addCountLocked(myRxTimeMs);
    }
    mWifiActivity.getRxTimeCounter().addCountLocked(info.getControllerRxTimeMillis());
    mWifiActivity.getTxTimeCounters()[0].addCountLocked(info.getControllerTxTimeMillis());
    mWifiActivity.getIdleTimeCounter().addCountLocked(info.getControllerIdleTimeMillis());
    final double opVolt=mPowerProfile.getAveragePower(PowerProfile.POWER_WIFI_CONTROLLER_OPERATING_VOLTAGE) / 1000.0;
    if (opVolt != 0) {
      mWifiActivity.getPowerCounter().addCountLocked((long)(info.getControllerEnergyUsed() / opVolt));
    }
  }
}","/** 
 * Distribute WiFi energy info and network traffic to apps.
 * @param info The energy information from the WiFi controller.
 */
public void updateWifiStateLocked(@Nullable final WifiActivityEnergyInfo info){
  if (DEBUG_ENERGY) {
    Slog.d(TAG,""String_Node_Str"");
  }
  final long elapsedRealtimeMs=mClocks.elapsedRealtime();
  NetworkStats delta=null;
  try {
    if (!ArrayUtils.isEmpty(mWifiIfaces)) {
      delta=getNetworkStatsDeltaLocked(mWifiIfaces,mWifiNetworkStats);
    }
  }
 catch (  IOException e) {
    Slog.wtf(TAG,""String_Node_Str"",e);
    return;
  }
  if (!mOnBatteryInternal) {
    return;
  }
  SparseLongArray rxPackets=new SparseLongArray();
  SparseLongArray txPackets=new SparseLongArray();
  long totalTxPackets=0;
  long totalRxPackets=0;
  if (delta != null) {
    final int size=delta.size();
    for (int i=0; i < size; i++) {
      final NetworkStats.Entry entry=delta.getValues(i,mTmpNetworkStatsEntry);
      if (DEBUG_ENERGY) {
        Slog.d(TAG,""String_Node_Str"" + entry.uid + ""String_Node_Str""+ entry.rxBytes+ ""String_Node_Str""+ entry.txBytes+ ""String_Node_Str""+ entry.rxPackets+ ""String_Node_Str""+ entry.txPackets);
      }
      if (entry.rxBytes == 0 && entry.txBytes == 0) {
        continue;
      }
      final Uid u=getUidStatsLocked(mapUid(entry.uid));
      if (entry.rxBytes != 0) {
        u.noteNetworkActivityLocked(NETWORK_WIFI_RX_DATA,entry.rxBytes,entry.rxPackets);
        mNetworkByteActivityCounters[NETWORK_WIFI_RX_DATA].addCountLocked(entry.rxBytes);
        mNetworkPacketActivityCounters[NETWORK_WIFI_RX_DATA].addCountLocked(entry.rxPackets);
        rxPackets.put(u.getUid(),entry.rxPackets);
        totalRxPackets+=entry.rxPackets;
      }
      if (entry.txBytes != 0) {
        u.noteNetworkActivityLocked(NETWORK_WIFI_TX_DATA,entry.txBytes,entry.txPackets);
        mNetworkByteActivityCounters[NETWORK_WIFI_TX_DATA].addCountLocked(entry.txBytes);
        mNetworkPacketActivityCounters[NETWORK_WIFI_TX_DATA].addCountLocked(entry.txPackets);
        txPackets.put(u.getUid(),entry.txPackets);
        totalTxPackets+=entry.txPackets;
      }
    }
  }
  if (info != null) {
    mHasWifiReporting=true;
    final long txTimeMs=info.getControllerTxTimeMillis();
    final long rxTimeMs=info.getControllerRxTimeMillis();
    final long idleTimeMs=info.getControllerIdleTimeMillis();
    final long totalTimeMs=txTimeMs + rxTimeMs + idleTimeMs;
    long leftOverRxTimeMs=rxTimeMs;
    long leftOverTxTimeMs=txTimeMs;
    if (DEBUG_ENERGY) {
      Slog.d(TAG,""String_Node_Str"");
      Slog.d(TAG,""String_Node_Str"" + txTimeMs + ""String_Node_Str"");
      Slog.d(TAG,""String_Node_Str"" + rxTimeMs + ""String_Node_Str"");
      Slog.d(TAG,""String_Node_Str"" + idleTimeMs + ""String_Node_Str"");
      Slog.d(TAG,""String_Node_Str"" + totalTimeMs + ""String_Node_Str"");
    }
    long totalWifiLockTimeMs=0;
    long totalScanTimeMs=0;
    final int uidStatsSize=mUidStats.size();
    for (int i=0; i < uidStatsSize; i++) {
      final Uid uid=mUidStats.valueAt(i);
      totalScanTimeMs+=uid.mWifiScanTimer.getTimeSinceMarkLocked(elapsedRealtimeMs * 1000) / 1000;
      totalWifiLockTimeMs+=uid.mFullWifiLockTimer.getTimeSinceMarkLocked(elapsedRealtimeMs * 1000) / 1000;
    }
    if (DEBUG_ENERGY && totalScanTimeMs > rxTimeMs) {
      Slog.d(TAG,""String_Node_Str"" + totalScanTimeMs + ""String_Node_Str""+ rxTimeMs+ ""String_Node_Str"");
    }
    if (DEBUG_ENERGY && totalScanTimeMs > txTimeMs) {
      Slog.d(TAG,""String_Node_Str"" + totalScanTimeMs + ""String_Node_Str""+ txTimeMs+ ""String_Node_Str"");
    }
    for (int i=0; i < uidStatsSize; i++) {
      final Uid uid=mUidStats.valueAt(i);
      long scanTimeSinceMarkMs=uid.mWifiScanTimer.getTimeSinceMarkLocked(elapsedRealtimeMs * 1000) / 1000;
      if (scanTimeSinceMarkMs > 0) {
        uid.mWifiScanTimer.setMark(elapsedRealtimeMs);
        long scanRxTimeSinceMarkMs=scanTimeSinceMarkMs;
        long scanTxTimeSinceMarkMs=scanTimeSinceMarkMs;
        if (totalScanTimeMs > rxTimeMs) {
          scanRxTimeSinceMarkMs=(rxTimeMs * scanRxTimeSinceMarkMs) / totalScanTimeMs;
        }
        if (totalScanTimeMs > txTimeMs) {
          scanTxTimeSinceMarkMs=(txTimeMs * scanTxTimeSinceMarkMs) / totalScanTimeMs;
        }
        if (DEBUG_ENERGY) {
          Slog.d(TAG,""String_Node_Str"" + uid.getUid() + ""String_Node_Str""+ scanRxTimeSinceMarkMs+ ""String_Node_Str""+ scanTxTimeSinceMarkMs+ ""String_Node_Str"");
        }
        ControllerActivityCounterImpl activityCounter=uid.getOrCreateWifiControllerActivityLocked();
        activityCounter.getRxTimeCounter().addCountLocked(scanRxTimeSinceMarkMs);
        activityCounter.getTxTimeCounters()[0].addCountLocked(scanTxTimeSinceMarkMs);
        leftOverRxTimeMs-=scanRxTimeSinceMarkMs;
        leftOverTxTimeMs-=scanTxTimeSinceMarkMs;
      }
      final long wifiLockTimeSinceMarkMs=uid.mFullWifiLockTimer.getTimeSinceMarkLocked(elapsedRealtimeMs * 1000) / 1000;
      if (wifiLockTimeSinceMarkMs > 0) {
        uid.mFullWifiLockTimer.setMark(elapsedRealtimeMs);
        final long myIdleTimeMs=(wifiLockTimeSinceMarkMs * idleTimeMs) / totalWifiLockTimeMs;
        if (DEBUG_ENERGY) {
          Slog.d(TAG,""String_Node_Str"" + uid.getUid() + ""String_Node_Str""+ myIdleTimeMs+ ""String_Node_Str"");
        }
        uid.getOrCreateWifiControllerActivityLocked().getIdleTimeCounter().addCountLocked(myIdleTimeMs);
      }
    }
    if (DEBUG_ENERGY) {
      Slog.d(TAG,""String_Node_Str"" + leftOverRxTimeMs + ""String_Node_Str"");
      Slog.d(TAG,""String_Node_Str"" + leftOverTxTimeMs + ""String_Node_Str"");
    }
    for (int i=0; i < txPackets.size(); i++) {
      final Uid uid=getUidStatsLocked(txPackets.keyAt(i));
      final long myTxTimeMs=(txPackets.valueAt(i) * leftOverTxTimeMs) / totalTxPackets;
      if (DEBUG_ENERGY) {
        Slog.d(TAG,""String_Node_Str"" + uid.getUid() + ""String_Node_Str""+ myTxTimeMs+ ""String_Node_Str"");
      }
      uid.getOrCreateWifiControllerActivityLocked().getTxTimeCounters()[0].addCountLocked(myTxTimeMs);
    }
    for (int i=0; i < rxPackets.size(); i++) {
      final Uid uid=getUidStatsLocked(rxPackets.keyAt(i));
      final long myRxTimeMs=(rxPackets.valueAt(i) * leftOverRxTimeMs) / totalRxPackets;
      if (DEBUG_ENERGY) {
        Slog.d(TAG,""String_Node_Str"" + uid.getUid() + ""String_Node_Str""+ myRxTimeMs+ ""String_Node_Str"");
      }
      uid.getOrCreateWifiControllerActivityLocked().getRxTimeCounter().addCountLocked(myRxTimeMs);
    }
    mWifiActivity.getRxTimeCounter().addCountLocked(info.getControllerRxTimeMillis());
    mWifiActivity.getTxTimeCounters()[0].addCountLocked(info.getControllerTxTimeMillis());
    mWifiActivity.getIdleTimeCounter().addCountLocked(info.getControllerIdleTimeMillis());
    final double opVolt=mPowerProfile.getAveragePower(PowerProfile.POWER_WIFI_CONTROLLER_OPERATING_VOLTAGE) / 1000.0;
    if (opVolt != 0) {
      mWifiActivity.getPowerCounter().addCountLocked((long)(info.getControllerEnergyUsed() / opVolt));
    }
  }
}",0.999713055954089
192621,"/** 
 * Distribute WiFi energy info and network traffic to apps.
 * @param info The energy information from the WiFi controller.
 */
public void updateWifiStateLocked(@Nullable final WifiActivityEnergyInfo info){
  if (DEBUG_ENERGY) {
    Slog.d(TAG,""String_Node_Str"");
  }
  final long elapsedRealtimeMs=SystemClock.elapsedRealtime();
  NetworkStats delta=null;
  try {
    if (!ArrayUtils.isEmpty(mWifiIfaces)) {
      delta=getNetworkStatsDeltaLocked(mWifiIfaces,mWifiNetworkStats);
    }
  }
 catch (  IOException e) {
    Slog.wtf(TAG,""String_Node_Str"",e);
    return;
  }
  if (!mOnBatteryInternal) {
    return;
  }
  SparseLongArray rxPackets=new SparseLongArray();
  SparseLongArray txPackets=new SparseLongArray();
  long totalTxPackets=0;
  long totalRxPackets=0;
  if (delta != null) {
    final int size=delta.size();
    for (int i=0; i < size; i++) {
      final NetworkStats.Entry entry=delta.getValues(i,mTmpNetworkStatsEntry);
      if (DEBUG_ENERGY) {
        Slog.d(TAG,""String_Node_Str"" + entry.uid + ""String_Node_Str""+ entry.rxBytes+ ""String_Node_Str""+ entry.txBytes+ ""String_Node_Str""+ entry.rxPackets+ ""String_Node_Str""+ entry.txPackets);
      }
      if (entry.rxBytes == 0 || entry.txBytes == 0) {
        continue;
      }
      final Uid u=getUidStatsLocked(mapUid(entry.uid));
      if (entry.rxBytes != 0) {
        u.noteNetworkActivityLocked(NETWORK_WIFI_RX_DATA,entry.rxBytes,entry.rxPackets);
        mNetworkByteActivityCounters[NETWORK_WIFI_RX_DATA].addCountLocked(entry.rxBytes);
        mNetworkPacketActivityCounters[NETWORK_WIFI_RX_DATA].addCountLocked(entry.rxPackets);
        rxPackets.put(u.getUid(),entry.rxPackets);
        totalRxPackets+=entry.rxPackets;
      }
      if (entry.txBytes != 0) {
        u.noteNetworkActivityLocked(NETWORK_WIFI_TX_DATA,entry.txBytes,entry.txPackets);
        mNetworkByteActivityCounters[NETWORK_WIFI_TX_DATA].addCountLocked(entry.txBytes);
        mNetworkPacketActivityCounters[NETWORK_WIFI_TX_DATA].addCountLocked(entry.txPackets);
        txPackets.put(u.getUid(),entry.txPackets);
        totalTxPackets+=entry.txPackets;
      }
    }
  }
  if (info != null) {
    mHasWifiReporting=true;
    final long txTimeMs=info.getControllerTxTimeMillis();
    final long rxTimeMs=info.getControllerRxTimeMillis();
    final long idleTimeMs=info.getControllerIdleTimeMillis();
    final long totalTimeMs=txTimeMs + rxTimeMs + idleTimeMs;
    long leftOverRxTimeMs=rxTimeMs;
    long leftOverTxTimeMs=txTimeMs;
    if (DEBUG_ENERGY) {
      Slog.d(TAG,""String_Node_Str"");
      Slog.d(TAG,""String_Node_Str"" + txTimeMs + ""String_Node_Str"");
      Slog.d(TAG,""String_Node_Str"" + rxTimeMs + ""String_Node_Str"");
      Slog.d(TAG,""String_Node_Str"" + idleTimeMs + ""String_Node_Str"");
      Slog.d(TAG,""String_Node_Str"" + totalTimeMs + ""String_Node_Str"");
    }
    long totalWifiLockTimeMs=0;
    long totalScanTimeMs=0;
    final int uidStatsSize=mUidStats.size();
    for (int i=0; i < uidStatsSize; i++) {
      final Uid uid=mUidStats.valueAt(i);
      totalScanTimeMs+=uid.mWifiScanTimer.getTimeSinceMarkLocked(elapsedRealtimeMs * 1000) / 1000;
      totalWifiLockTimeMs+=uid.mFullWifiLockTimer.getTimeSinceMarkLocked(elapsedRealtimeMs * 1000) / 1000;
    }
    if (DEBUG_ENERGY && totalScanTimeMs > rxTimeMs) {
      Slog.d(TAG,""String_Node_Str"" + totalScanTimeMs + ""String_Node_Str""+ rxTimeMs+ ""String_Node_Str"");
    }
    if (DEBUG_ENERGY && totalScanTimeMs > txTimeMs) {
      Slog.d(TAG,""String_Node_Str"" + totalScanTimeMs + ""String_Node_Str""+ txTimeMs+ ""String_Node_Str"");
    }
    for (int i=0; i < uidStatsSize; i++) {
      final Uid uid=mUidStats.valueAt(i);
      long scanTimeSinceMarkMs=uid.mWifiScanTimer.getTimeSinceMarkLocked(elapsedRealtimeMs * 1000) / 1000;
      if (scanTimeSinceMarkMs > 0) {
        uid.mWifiScanTimer.setMark(elapsedRealtimeMs);
        long scanRxTimeSinceMarkMs=scanTimeSinceMarkMs;
        long scanTxTimeSinceMarkMs=scanTimeSinceMarkMs;
        if (totalScanTimeMs > rxTimeMs) {
          scanRxTimeSinceMarkMs=(rxTimeMs * scanRxTimeSinceMarkMs) / totalScanTimeMs;
        }
        if (totalScanTimeMs > txTimeMs) {
          scanTxTimeSinceMarkMs=(txTimeMs * scanTxTimeSinceMarkMs) / totalScanTimeMs;
        }
        if (DEBUG_ENERGY) {
          Slog.d(TAG,""String_Node_Str"" + uid.getUid() + ""String_Node_Str""+ scanRxTimeSinceMarkMs+ ""String_Node_Str""+ scanTxTimeSinceMarkMs+ ""String_Node_Str"");
        }
        ControllerActivityCounterImpl activityCounter=uid.getOrCreateWifiControllerActivityLocked();
        activityCounter.getRxTimeCounter().addCountLocked(scanRxTimeSinceMarkMs);
        activityCounter.getTxTimeCounters()[0].addCountLocked(scanTxTimeSinceMarkMs);
        leftOverRxTimeMs-=scanRxTimeSinceMarkMs;
        leftOverTxTimeMs-=scanTxTimeSinceMarkMs;
      }
      final long wifiLockTimeSinceMarkMs=uid.mFullWifiLockTimer.getTimeSinceMarkLocked(elapsedRealtimeMs * 1000) / 1000;
      if (wifiLockTimeSinceMarkMs > 0) {
        uid.mFullWifiLockTimer.setMark(elapsedRealtimeMs);
        final long myIdleTimeMs=(wifiLockTimeSinceMarkMs * idleTimeMs) / totalWifiLockTimeMs;
        if (DEBUG_ENERGY) {
          Slog.d(TAG,""String_Node_Str"" + uid.getUid() + ""String_Node_Str""+ myIdleTimeMs+ ""String_Node_Str"");
        }
        uid.getOrCreateWifiControllerActivityLocked().getIdleTimeCounter().addCountLocked(myIdleTimeMs);
      }
    }
    if (DEBUG_ENERGY) {
      Slog.d(TAG,""String_Node_Str"" + leftOverRxTimeMs + ""String_Node_Str"");
      Slog.d(TAG,""String_Node_Str"" + leftOverTxTimeMs + ""String_Node_Str"");
    }
    for (int i=0; i < txPackets.size(); i++) {
      final Uid uid=getUidStatsLocked(txPackets.keyAt(i));
      final long myTxTimeMs=(txPackets.valueAt(i) * leftOverTxTimeMs) / totalTxPackets;
      if (DEBUG_ENERGY) {
        Slog.d(TAG,""String_Node_Str"" + uid.getUid() + ""String_Node_Str""+ myTxTimeMs+ ""String_Node_Str"");
      }
      uid.getOrCreateWifiControllerActivityLocked().getTxTimeCounters()[0].addCountLocked(myTxTimeMs);
    }
    for (int i=0; i < rxPackets.size(); i++) {
      final Uid uid=getUidStatsLocked(rxPackets.keyAt(i));
      final long myRxTimeMs=(rxPackets.valueAt(i) * leftOverRxTimeMs) / totalRxPackets;
      if (DEBUG_ENERGY) {
        Slog.d(TAG,""String_Node_Str"" + uid.getUid() + ""String_Node_Str""+ myRxTimeMs+ ""String_Node_Str"");
      }
      uid.getOrCreateWifiControllerActivityLocked().getRxTimeCounter().addCountLocked(myRxTimeMs);
    }
    mWifiActivity.getRxTimeCounter().addCountLocked(info.getControllerRxTimeMillis());
    mWifiActivity.getTxTimeCounters()[0].addCountLocked(info.getControllerTxTimeMillis());
    mWifiActivity.getIdleTimeCounter().addCountLocked(info.getControllerIdleTimeMillis());
    final double opVolt=mPowerProfile.getAveragePower(PowerProfile.POWER_WIFI_CONTROLLER_OPERATING_VOLTAGE) / 1000.0;
    if (opVolt != 0) {
      mWifiActivity.getPowerCounter().addCountLocked((long)(info.getControllerEnergyUsed() / opVolt));
    }
  }
}","/** 
 * Distribute WiFi energy info and network traffic to apps.
 * @param info The energy information from the WiFi controller.
 */
public void updateWifiStateLocked(@Nullable final WifiActivityEnergyInfo info){
  if (DEBUG_ENERGY) {
    Slog.d(TAG,""String_Node_Str"");
  }
  final long elapsedRealtimeMs=SystemClock.elapsedRealtime();
  NetworkStats delta=null;
  try {
    if (!ArrayUtils.isEmpty(mWifiIfaces)) {
      delta=getNetworkStatsDeltaLocked(mWifiIfaces,mWifiNetworkStats);
    }
  }
 catch (  IOException e) {
    Slog.wtf(TAG,""String_Node_Str"",e);
    return;
  }
  if (!mOnBatteryInternal) {
    return;
  }
  SparseLongArray rxPackets=new SparseLongArray();
  SparseLongArray txPackets=new SparseLongArray();
  long totalTxPackets=0;
  long totalRxPackets=0;
  if (delta != null) {
    final int size=delta.size();
    for (int i=0; i < size; i++) {
      final NetworkStats.Entry entry=delta.getValues(i,mTmpNetworkStatsEntry);
      if (DEBUG_ENERGY) {
        Slog.d(TAG,""String_Node_Str"" + entry.uid + ""String_Node_Str""+ entry.rxBytes+ ""String_Node_Str""+ entry.txBytes+ ""String_Node_Str""+ entry.rxPackets+ ""String_Node_Str""+ entry.txPackets);
      }
      if (entry.rxBytes == 0 && entry.txBytes == 0) {
        continue;
      }
      final Uid u=getUidStatsLocked(mapUid(entry.uid));
      if (entry.rxBytes != 0) {
        u.noteNetworkActivityLocked(NETWORK_WIFI_RX_DATA,entry.rxBytes,entry.rxPackets);
        mNetworkByteActivityCounters[NETWORK_WIFI_RX_DATA].addCountLocked(entry.rxBytes);
        mNetworkPacketActivityCounters[NETWORK_WIFI_RX_DATA].addCountLocked(entry.rxPackets);
        rxPackets.put(u.getUid(),entry.rxPackets);
        totalRxPackets+=entry.rxPackets;
      }
      if (entry.txBytes != 0) {
        u.noteNetworkActivityLocked(NETWORK_WIFI_TX_DATA,entry.txBytes,entry.txPackets);
        mNetworkByteActivityCounters[NETWORK_WIFI_TX_DATA].addCountLocked(entry.txBytes);
        mNetworkPacketActivityCounters[NETWORK_WIFI_TX_DATA].addCountLocked(entry.txPackets);
        txPackets.put(u.getUid(),entry.txPackets);
        totalTxPackets+=entry.txPackets;
      }
    }
  }
  if (info != null) {
    mHasWifiReporting=true;
    final long txTimeMs=info.getControllerTxTimeMillis();
    final long rxTimeMs=info.getControllerRxTimeMillis();
    final long idleTimeMs=info.getControllerIdleTimeMillis();
    final long totalTimeMs=txTimeMs + rxTimeMs + idleTimeMs;
    long leftOverRxTimeMs=rxTimeMs;
    long leftOverTxTimeMs=txTimeMs;
    if (DEBUG_ENERGY) {
      Slog.d(TAG,""String_Node_Str"");
      Slog.d(TAG,""String_Node_Str"" + txTimeMs + ""String_Node_Str"");
      Slog.d(TAG,""String_Node_Str"" + rxTimeMs + ""String_Node_Str"");
      Slog.d(TAG,""String_Node_Str"" + idleTimeMs + ""String_Node_Str"");
      Slog.d(TAG,""String_Node_Str"" + totalTimeMs + ""String_Node_Str"");
    }
    long totalWifiLockTimeMs=0;
    long totalScanTimeMs=0;
    final int uidStatsSize=mUidStats.size();
    for (int i=0; i < uidStatsSize; i++) {
      final Uid uid=mUidStats.valueAt(i);
      totalScanTimeMs+=uid.mWifiScanTimer.getTimeSinceMarkLocked(elapsedRealtimeMs * 1000) / 1000;
      totalWifiLockTimeMs+=uid.mFullWifiLockTimer.getTimeSinceMarkLocked(elapsedRealtimeMs * 1000) / 1000;
    }
    if (DEBUG_ENERGY && totalScanTimeMs > rxTimeMs) {
      Slog.d(TAG,""String_Node_Str"" + totalScanTimeMs + ""String_Node_Str""+ rxTimeMs+ ""String_Node_Str"");
    }
    if (DEBUG_ENERGY && totalScanTimeMs > txTimeMs) {
      Slog.d(TAG,""String_Node_Str"" + totalScanTimeMs + ""String_Node_Str""+ txTimeMs+ ""String_Node_Str"");
    }
    for (int i=0; i < uidStatsSize; i++) {
      final Uid uid=mUidStats.valueAt(i);
      long scanTimeSinceMarkMs=uid.mWifiScanTimer.getTimeSinceMarkLocked(elapsedRealtimeMs * 1000) / 1000;
      if (scanTimeSinceMarkMs > 0) {
        uid.mWifiScanTimer.setMark(elapsedRealtimeMs);
        long scanRxTimeSinceMarkMs=scanTimeSinceMarkMs;
        long scanTxTimeSinceMarkMs=scanTimeSinceMarkMs;
        if (totalScanTimeMs > rxTimeMs) {
          scanRxTimeSinceMarkMs=(rxTimeMs * scanRxTimeSinceMarkMs) / totalScanTimeMs;
        }
        if (totalScanTimeMs > txTimeMs) {
          scanTxTimeSinceMarkMs=(txTimeMs * scanTxTimeSinceMarkMs) / totalScanTimeMs;
        }
        if (DEBUG_ENERGY) {
          Slog.d(TAG,""String_Node_Str"" + uid.getUid() + ""String_Node_Str""+ scanRxTimeSinceMarkMs+ ""String_Node_Str""+ scanTxTimeSinceMarkMs+ ""String_Node_Str"");
        }
        ControllerActivityCounterImpl activityCounter=uid.getOrCreateWifiControllerActivityLocked();
        activityCounter.getRxTimeCounter().addCountLocked(scanRxTimeSinceMarkMs);
        activityCounter.getTxTimeCounters()[0].addCountLocked(scanTxTimeSinceMarkMs);
        leftOverRxTimeMs-=scanRxTimeSinceMarkMs;
        leftOverTxTimeMs-=scanTxTimeSinceMarkMs;
      }
      final long wifiLockTimeSinceMarkMs=uid.mFullWifiLockTimer.getTimeSinceMarkLocked(elapsedRealtimeMs * 1000) / 1000;
      if (wifiLockTimeSinceMarkMs > 0) {
        uid.mFullWifiLockTimer.setMark(elapsedRealtimeMs);
        final long myIdleTimeMs=(wifiLockTimeSinceMarkMs * idleTimeMs) / totalWifiLockTimeMs;
        if (DEBUG_ENERGY) {
          Slog.d(TAG,""String_Node_Str"" + uid.getUid() + ""String_Node_Str""+ myIdleTimeMs+ ""String_Node_Str"");
        }
        uid.getOrCreateWifiControllerActivityLocked().getIdleTimeCounter().addCountLocked(myIdleTimeMs);
      }
    }
    if (DEBUG_ENERGY) {
      Slog.d(TAG,""String_Node_Str"" + leftOverRxTimeMs + ""String_Node_Str"");
      Slog.d(TAG,""String_Node_Str"" + leftOverTxTimeMs + ""String_Node_Str"");
    }
    for (int i=0; i < txPackets.size(); i++) {
      final Uid uid=getUidStatsLocked(txPackets.keyAt(i));
      final long myTxTimeMs=(txPackets.valueAt(i) * leftOverTxTimeMs) / totalTxPackets;
      if (DEBUG_ENERGY) {
        Slog.d(TAG,""String_Node_Str"" + uid.getUid() + ""String_Node_Str""+ myTxTimeMs+ ""String_Node_Str"");
      }
      uid.getOrCreateWifiControllerActivityLocked().getTxTimeCounters()[0].addCountLocked(myTxTimeMs);
    }
    for (int i=0; i < rxPackets.size(); i++) {
      final Uid uid=getUidStatsLocked(rxPackets.keyAt(i));
      final long myRxTimeMs=(rxPackets.valueAt(i) * leftOverRxTimeMs) / totalRxPackets;
      if (DEBUG_ENERGY) {
        Slog.d(TAG,""String_Node_Str"" + uid.getUid() + ""String_Node_Str""+ myRxTimeMs+ ""String_Node_Str"");
      }
      uid.getOrCreateWifiControllerActivityLocked().getRxTimeCounter().addCountLocked(myRxTimeMs);
    }
    mWifiActivity.getRxTimeCounter().addCountLocked(info.getControllerRxTimeMillis());
    mWifiActivity.getTxTimeCounters()[0].addCountLocked(info.getControllerTxTimeMillis());
    mWifiActivity.getIdleTimeCounter().addCountLocked(info.getControllerIdleTimeMillis());
    final double opVolt=mPowerProfile.getAveragePower(PowerProfile.POWER_WIFI_CONTROLLER_OPERATING_VOLTAGE) / 1000.0;
    if (opVolt != 0) {
      mWifiActivity.getPowerCounter().addCountLocked((long)(info.getControllerEnergyUsed() / opVolt));
    }
  }
}",0.9997132205334098
192622,"/** 
 * Fling the scroll view
 * @param velocityY The initial velocity in the Y direction. Positivenumbers mean that the finger/cursor is moving down the screen, which means we want to scroll towards the top.
 */
private void fling(int velocityY){
  if (getChildCount() > 0) {
    int scrollRange=getScrollRange();
    float topAmount=getCurrentOverScrollAmount(true);
    float bottomAmount=getCurrentOverScrollAmount(false);
    if (velocityY < 0 && topAmount > 0) {
      mOwnScrollY-=(int)topAmount;
      mDontReportNextOverScroll=true;
      setOverScrollAmount(0,true,false);
      mMaxOverScroll=Math.abs(velocityY) / 1000f * getRubberBandFactor(true) * mOverflingDistance + topAmount;
    }
 else     if (velocityY > 0 && bottomAmount > 0) {
      mOwnScrollY+=bottomAmount;
      setOverScrollAmount(0,false,false);
      mMaxOverScroll=Math.abs(velocityY) / 1000f * getRubberBandFactor(false) * mOverflingDistance + bottomAmount;
    }
 else {
      mMaxOverScroll=0.0f;
    }
    mScroller.fling(mScrollX,mOwnScrollY,1,velocityY,0,0,0,Math.max(0,scrollRange),0,Integer.MAX_VALUE / 2);
    postInvalidateOnAnimation();
  }
}","/** 
 * Fling the scroll view
 * @param velocityY The initial velocity in the Y direction. Positivenumbers mean that the finger/cursor is moving down the screen, which means we want to scroll towards the top.
 */
private void fling(int velocityY){
  if (getChildCount() > 0) {
    int scrollRange=getScrollRange();
    float topAmount=getCurrentOverScrollAmount(true);
    float bottomAmount=getCurrentOverScrollAmount(false);
    if (velocityY < 0 && topAmount > 0) {
      mOwnScrollY-=(int)topAmount;
      mDontReportNextOverScroll=true;
      setOverScrollAmount(0,true,false);
      mMaxOverScroll=Math.abs(velocityY) / 1000f * getRubberBandFactor(true) * mOverflingDistance + topAmount;
    }
 else     if (velocityY > 0 && bottomAmount > 0) {
      mOwnScrollY+=bottomAmount;
      setOverScrollAmount(0,false,false);
      mMaxOverScroll=Math.abs(velocityY) / 1000f * getRubberBandFactor(false) * mOverflingDistance + bottomAmount;
    }
 else {
      mMaxOverScroll=0.0f;
    }
    int minScrollY=Math.max(0,scrollRange);
    if (mExpandedInThisMotion) {
      minScrollY=Math.min(minScrollY,mMaxScrollAfterExpand);
    }
    mScroller.fling(mScrollX,mOwnScrollY,1,velocityY,0,0,0,minScrollY,0,mExpandedInThisMotion && mOwnScrollY >= 0 ? 0 : Integer.MAX_VALUE / 2);
    postInvalidateOnAnimation();
  }
}",0.8991425071457738
192623,"/** 
 * Fling the scroll view
 * @param velocityY The initial velocity in the Y direction. Positivenumbers mean that the finger/cursor is moving down the screen, which means we want to scroll towards the top.
 */
private void fling(int velocityY){
  if (getChildCount() > 0) {
    int scrollRange=getScrollRange();
    float topAmount=getCurrentOverScrollAmount(true);
    float bottomAmount=getCurrentOverScrollAmount(false);
    if (velocityY < 0 && topAmount > 0) {
      mOwnScrollY-=(int)topAmount;
      mDontReportNextOverScroll=true;
      setOverScrollAmount(0,true,false);
      mMaxOverScroll=Math.abs(velocityY) / 1000f * getRubberBandFactor(true) * mOverflingDistance + topAmount;
    }
 else     if (velocityY > 0 && bottomAmount > 0) {
      mOwnScrollY+=bottomAmount;
      setOverScrollAmount(0,false,false);
      mMaxOverScroll=Math.abs(velocityY) / 1000f * getRubberBandFactor(false) * mOverflingDistance + bottomAmount;
    }
 else {
      mMaxOverScroll=0.0f;
    }
    mScroller.fling(mScrollX,mOwnScrollY,1,velocityY,0,0,0,Math.max(0,scrollRange),0,Integer.MAX_VALUE / 2);
    postInvalidateOnAnimation();
  }
}","/** 
 * Fling the scroll view
 * @param velocityY The initial velocity in the Y direction. Positivenumbers mean that the finger/cursor is moving down the screen, which means we want to scroll towards the top.
 */
private void fling(int velocityY){
  if (getChildCount() > 0) {
    int scrollRange=getScrollRange();
    float topAmount=getCurrentOverScrollAmount(true);
    float bottomAmount=getCurrentOverScrollAmount(false);
    if (velocityY < 0 && topAmount > 0) {
      mOwnScrollY-=(int)topAmount;
      mDontReportNextOverScroll=true;
      setOverScrollAmount(0,true,false);
      mMaxOverScroll=Math.abs(velocityY) / 1000f * getRubberBandFactor(true) * mOverflingDistance + topAmount;
    }
 else     if (velocityY > 0 && bottomAmount > 0) {
      mOwnScrollY+=bottomAmount;
      setOverScrollAmount(0,false,false);
      mMaxOverScroll=Math.abs(velocityY) / 1000f * getRubberBandFactor(false) * mOverflingDistance + bottomAmount;
    }
 else {
      mMaxOverScroll=0.0f;
    }
    int minScrollY=Math.max(0,scrollRange);
    if (mExpandedInThisMotion) {
      minScrollY=Math.min(minScrollY,mMaxScrollAfterExpand);
    }
    mScroller.fling(mScrollX,mOwnScrollY,1,velocityY,0,0,0,minScrollY,0,mExpandedInThisMotion && mOwnScrollY >= 0 ? 0 : Integer.MAX_VALUE / 2);
    postInvalidateOnAnimation();
  }
}",0.8991425071457738
192624,"@Override public void performIdleMaintenance(){
  if (checkCallingPermission(android.Manifest.permission.SET_ACTIVITY_WATCHER) != PackageManager.PERMISSION_GRANTED) {
    throw new SecurityException(""String_Node_Str"" + android.Manifest.permission.SET_ACTIVITY_WATCHER);
  }
synchronized (this) {
    final long now=SystemClock.uptimeMillis();
    final long timeSinceLastIdle=now - mLastIdleTime;
    final long lowRamSinceLastIdle=getLowRamTimeSinceIdle(now);
    mLastIdleTime=now;
    mLowRamTimeSinceLastIdle=0;
    if (mLowRamStartTime != 0) {
      mLowRamStartTime=now;
    }
    StringBuilder sb=new StringBuilder(128);
    sb.append(""String_Node_Str"");
    TimeUtils.formatDuration(timeSinceLastIdle,sb);
    sb.append(""String_Node_Str"");
    TimeUtils.formatDuration(lowRamSinceLastIdle,sb);
    Slog.i(TAG,sb.toString());
    boolean doKilling=lowRamSinceLastIdle > (timeSinceLastIdle / 3);
    for (int i=mLruProcesses.size() - 1; i >= 0; i--) {
      ProcessRecord proc=mLruProcesses.get(i);
      if (proc.notCachedSinceIdle) {
        if (proc.setProcState != ActivityManager.PROCESS_STATE_TOP_SLEEPING && proc.setProcState >= ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE && proc.setProcState <= ActivityManager.PROCESS_STATE_SERVICE) {
          if (doKilling && proc.initialIdlePss != 0 && proc.lastPss > ((proc.initialIdlePss * 3) / 2)) {
            sb=new StringBuilder(128);
            sb.append(""String_Node_Str"");
            sb.append(proc.processName);
            sb.append(""String_Node_Str"");
            sb.append(proc.lastPss);
            sb.append(""String_Node_Str"");
            sb.append(proc.lastSwapPss);
            sb.append(""String_Node_Str"");
            sb.append(proc.initialIdlePss);
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(timeSinceLastIdle,sb);
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(lowRamSinceLastIdle,sb);
            Slog.wtfQuiet(TAG,sb.toString());
            proc.kill(""String_Node_Str"" + proc.lastPss + ""String_Node_Str""+ proc.initialIdlePss+ ""String_Node_Str"",true);
          }
        }
      }
 else       if (proc.setProcState < ActivityManager.PROCESS_STATE_HOME) {
        proc.notCachedSinceIdle=true;
        proc.initialIdlePss=0;
        proc.nextPssTime=ProcessList.computeNextPssTime(proc.curProcState,true,mTestPssMode,isSleeping(),now);
      }
    }
    mHandler.removeMessages(REQUEST_ALL_PSS_MSG);
    mHandler.sendEmptyMessageDelayed(REQUEST_ALL_PSS_MSG,2 * 60 * 1000);
  }
}","@Override public void performIdleMaintenance(){
  if (checkCallingPermission(android.Manifest.permission.SET_ACTIVITY_WATCHER) != PackageManager.PERMISSION_GRANTED) {
    throw new SecurityException(""String_Node_Str"" + android.Manifest.permission.SET_ACTIVITY_WATCHER);
  }
synchronized (this) {
    final long now=SystemClock.uptimeMillis();
    final long timeSinceLastIdle=now - mLastIdleTime;
    final long lowRamSinceLastIdle=getLowRamTimeSinceIdle(now);
    mLastIdleTime=now;
    mLowRamTimeSinceLastIdle=0;
    if (mLowRamStartTime != 0) {
      mLowRamStartTime=now;
    }
    StringBuilder sb=new StringBuilder(128);
    sb.append(""String_Node_Str"");
    TimeUtils.formatDuration(timeSinceLastIdle,sb);
    sb.append(""String_Node_Str"");
    TimeUtils.formatDuration(lowRamSinceLastIdle,sb);
    Slog.i(TAG,sb.toString());
    boolean doKilling=lowRamSinceLastIdle > (timeSinceLastIdle / 3);
    for (int i=mLruProcesses.size() - 1; i >= 0; i--) {
      ProcessRecord proc=mLruProcesses.get(i);
      if (proc.notCachedSinceIdle) {
        if (proc.setProcState != ActivityManager.PROCESS_STATE_TOP_SLEEPING && proc.setProcState >= ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE && proc.setProcState <= ActivityManager.PROCESS_STATE_SERVICE) {
          if (doKilling && proc.initialIdlePss != 0 && proc.lastPss > ((proc.initialIdlePss * 3) / 2)) {
            sb=new StringBuilder(128);
            sb.append(""String_Node_Str"");
            sb.append(proc.processName);
            sb.append(""String_Node_Str"");
            sb.append(proc.lastPss);
            sb.append(""String_Node_Str"");
            sb.append(proc.lastSwapPss);
            sb.append(""String_Node_Str"");
            sb.append(proc.initialIdlePss);
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(timeSinceLastIdle,sb);
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(lowRamSinceLastIdle,sb);
            Slog.wtfQuiet(TAG,sb.toString());
            proc.kill(""String_Node_Str"" + proc.lastPss + ""String_Node_Str""+ proc.initialIdlePss+ ""String_Node_Str"",true);
          }
        }
      }
 else       if (proc.setProcState < ActivityManager.PROCESS_STATE_HOME && proc.setProcState > ActivityManager.PROCESS_STATE_NONEXISTENT) {
        proc.notCachedSinceIdle=true;
        proc.initialIdlePss=0;
        proc.nextPssTime=ProcessList.computeNextPssTime(proc.setProcState,true,mTestPssMode,isSleeping(),now);
      }
    }
    mHandler.removeMessages(REQUEST_ALL_PSS_MSG);
    mHandler.sendEmptyMessageDelayed(REQUEST_ALL_PSS_MSG,2 * 60 * 1000);
  }
}",0.98615174566023
192625,"@Override public void performIdleMaintenance(){
  if (checkCallingPermission(android.Manifest.permission.SET_ACTIVITY_WATCHER) != PackageManager.PERMISSION_GRANTED) {
    throw new SecurityException(""String_Node_Str"" + android.Manifest.permission.SET_ACTIVITY_WATCHER);
  }
synchronized (this) {
    final long now=SystemClock.uptimeMillis();
    final long timeSinceLastIdle=now - mLastIdleTime;
    final long lowRamSinceLastIdle=getLowRamTimeSinceIdle(now);
    mLastIdleTime=now;
    mLowRamTimeSinceLastIdle=0;
    if (mLowRamStartTime != 0) {
      mLowRamStartTime=now;
    }
    StringBuilder sb=new StringBuilder(128);
    sb.append(""String_Node_Str"");
    TimeUtils.formatDuration(timeSinceLastIdle,sb);
    sb.append(""String_Node_Str"");
    TimeUtils.formatDuration(lowRamSinceLastIdle,sb);
    Slog.i(TAG,sb.toString());
    boolean doKilling=lowRamSinceLastIdle > (timeSinceLastIdle / 3);
    for (int i=mLruProcesses.size() - 1; i >= 0; i--) {
      ProcessRecord proc=mLruProcesses.get(i);
      if (proc.notCachedSinceIdle) {
        if (proc.setProcState != ActivityManager.PROCESS_STATE_TOP_SLEEPING && proc.setProcState >= ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE && proc.setProcState <= ActivityManager.PROCESS_STATE_SERVICE) {
          if (doKilling && proc.initialIdlePss != 0 && proc.lastPss > ((proc.initialIdlePss * 3) / 2)) {
            sb=new StringBuilder(128);
            sb.append(""String_Node_Str"");
            sb.append(proc.processName);
            sb.append(""String_Node_Str"");
            sb.append(proc.lastPss);
            sb.append(""String_Node_Str"");
            sb.append(proc.lastSwapPss);
            sb.append(""String_Node_Str"");
            sb.append(proc.initialIdlePss);
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(timeSinceLastIdle,sb);
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(lowRamSinceLastIdle,sb);
            Slog.wtfQuiet(TAG,sb.toString());
            proc.kill(""String_Node_Str"" + proc.lastPss + ""String_Node_Str""+ proc.initialIdlePss+ ""String_Node_Str"",true);
          }
        }
      }
 else       if (proc.setProcState < ActivityManager.PROCESS_STATE_HOME) {
        proc.notCachedSinceIdle=true;
        proc.initialIdlePss=0;
        proc.nextPssTime=ProcessList.computeNextPssTime(proc.curProcState,true,mTestPssMode,isSleeping(),now);
      }
    }
    mHandler.removeMessages(REQUEST_ALL_PSS_MSG);
    mHandler.sendEmptyMessageDelayed(REQUEST_ALL_PSS_MSG,2 * 60 * 1000);
  }
}","@Override public void performIdleMaintenance(){
  if (checkCallingPermission(android.Manifest.permission.SET_ACTIVITY_WATCHER) != PackageManager.PERMISSION_GRANTED) {
    throw new SecurityException(""String_Node_Str"" + android.Manifest.permission.SET_ACTIVITY_WATCHER);
  }
synchronized (this) {
    final long now=SystemClock.uptimeMillis();
    final long timeSinceLastIdle=now - mLastIdleTime;
    final long lowRamSinceLastIdle=getLowRamTimeSinceIdle(now);
    mLastIdleTime=now;
    mLowRamTimeSinceLastIdle=0;
    if (mLowRamStartTime != 0) {
      mLowRamStartTime=now;
    }
    StringBuilder sb=new StringBuilder(128);
    sb.append(""String_Node_Str"");
    TimeUtils.formatDuration(timeSinceLastIdle,sb);
    sb.append(""String_Node_Str"");
    TimeUtils.formatDuration(lowRamSinceLastIdle,sb);
    Slog.i(TAG,sb.toString());
    boolean doKilling=lowRamSinceLastIdle > (timeSinceLastIdle / 3);
    for (int i=mLruProcesses.size() - 1; i >= 0; i--) {
      ProcessRecord proc=mLruProcesses.get(i);
      if (proc.notCachedSinceIdle) {
        if (proc.setProcState != ActivityManager.PROCESS_STATE_TOP_SLEEPING && proc.setProcState >= ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE && proc.setProcState <= ActivityManager.PROCESS_STATE_SERVICE) {
          if (doKilling && proc.initialIdlePss != 0 && proc.lastPss > ((proc.initialIdlePss * 3) / 2)) {
            sb=new StringBuilder(128);
            sb.append(""String_Node_Str"");
            sb.append(proc.processName);
            sb.append(""String_Node_Str"");
            sb.append(proc.lastPss);
            sb.append(""String_Node_Str"");
            sb.append(proc.lastSwapPss);
            sb.append(""String_Node_Str"");
            sb.append(proc.initialIdlePss);
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(timeSinceLastIdle,sb);
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(lowRamSinceLastIdle,sb);
            Slog.wtfQuiet(TAG,sb.toString());
            proc.kill(""String_Node_Str"" + proc.lastPss + ""String_Node_Str""+ proc.initialIdlePss+ ""String_Node_Str"",true);
          }
        }
      }
 else       if (proc.setProcState < ActivityManager.PROCESS_STATE_HOME && proc.setProcState > ActivityManager.PROCESS_STATE_NONEXISTENT) {
        proc.notCachedSinceIdle=true;
        proc.initialIdlePss=0;
        proc.nextPssTime=ProcessList.computeNextPssTime(proc.setProcState,true,mTestPssMode,isSleeping(),now);
      }
    }
    mHandler.removeMessages(REQUEST_ALL_PSS_MSG);
    mHandler.sendEmptyMessageDelayed(REQUEST_ALL_PSS_MSG,2 * 60 * 1000);
  }
}",0.98615174566023
192626,"@Override public void performIdleMaintenance(){
  if (checkCallingPermission(android.Manifest.permission.SET_ACTIVITY_WATCHER) != PackageManager.PERMISSION_GRANTED) {
    throw new SecurityException(""String_Node_Str"" + android.Manifest.permission.SET_ACTIVITY_WATCHER);
  }
synchronized (this) {
    final long now=SystemClock.uptimeMillis();
    final long timeSinceLastIdle=now - mLastIdleTime;
    final long lowRamSinceLastIdle=getLowRamTimeSinceIdle(now);
    mLastIdleTime=now;
    mLowRamTimeSinceLastIdle=0;
    if (mLowRamStartTime != 0) {
      mLowRamStartTime=now;
    }
    StringBuilder sb=new StringBuilder(128);
    sb.append(""String_Node_Str"");
    TimeUtils.formatDuration(timeSinceLastIdle,sb);
    sb.append(""String_Node_Str"");
    TimeUtils.formatDuration(lowRamSinceLastIdle,sb);
    Slog.i(TAG,sb.toString());
    boolean doKilling=lowRamSinceLastIdle > (timeSinceLastIdle / 3);
    for (int i=mLruProcesses.size() - 1; i >= 0; i--) {
      ProcessRecord proc=mLruProcesses.get(i);
      if (proc.notCachedSinceIdle) {
        if (proc.setProcState != ActivityManager.PROCESS_STATE_TOP_SLEEPING && proc.setProcState >= ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE && proc.setProcState <= ActivityManager.PROCESS_STATE_SERVICE) {
          if (doKilling && proc.initialIdlePss != 0 && proc.lastPss > ((proc.initialIdlePss * 3) / 2)) {
            sb=new StringBuilder(128);
            sb.append(""String_Node_Str"");
            sb.append(proc.processName);
            sb.append(""String_Node_Str"");
            sb.append(proc.lastPss);
            sb.append(""String_Node_Str"");
            sb.append(proc.lastSwapPss);
            sb.append(""String_Node_Str"");
            sb.append(proc.initialIdlePss);
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(timeSinceLastIdle,sb);
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(lowRamSinceLastIdle,sb);
            Slog.wtfQuiet(TAG,sb.toString());
            proc.kill(""String_Node_Str"" + proc.lastPss + ""String_Node_Str""+ proc.initialIdlePss+ ""String_Node_Str"",true);
          }
        }
      }
 else       if (proc.setProcState < ActivityManager.PROCESS_STATE_HOME) {
        proc.notCachedSinceIdle=true;
        proc.initialIdlePss=0;
        proc.nextPssTime=ProcessList.computeNextPssTime(proc.curProcState,true,mTestPssMode,isSleeping(),now);
      }
    }
    mHandler.removeMessages(REQUEST_ALL_PSS_MSG);
    mHandler.sendEmptyMessageDelayed(REQUEST_ALL_PSS_MSG,2 * 60 * 1000);
  }
}","@Override public void performIdleMaintenance(){
  if (checkCallingPermission(android.Manifest.permission.SET_ACTIVITY_WATCHER) != PackageManager.PERMISSION_GRANTED) {
    throw new SecurityException(""String_Node_Str"" + android.Manifest.permission.SET_ACTIVITY_WATCHER);
  }
synchronized (this) {
    final long now=SystemClock.uptimeMillis();
    final long timeSinceLastIdle=now - mLastIdleTime;
    final long lowRamSinceLastIdle=getLowRamTimeSinceIdle(now);
    mLastIdleTime=now;
    mLowRamTimeSinceLastIdle=0;
    if (mLowRamStartTime != 0) {
      mLowRamStartTime=now;
    }
    StringBuilder sb=new StringBuilder(128);
    sb.append(""String_Node_Str"");
    TimeUtils.formatDuration(timeSinceLastIdle,sb);
    sb.append(""String_Node_Str"");
    TimeUtils.formatDuration(lowRamSinceLastIdle,sb);
    Slog.i(TAG,sb.toString());
    boolean doKilling=lowRamSinceLastIdle > (timeSinceLastIdle / 3);
    for (int i=mLruProcesses.size() - 1; i >= 0; i--) {
      ProcessRecord proc=mLruProcesses.get(i);
      if (proc.notCachedSinceIdle) {
        if (proc.setProcState != ActivityManager.PROCESS_STATE_TOP_SLEEPING && proc.setProcState >= ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE && proc.setProcState <= ActivityManager.PROCESS_STATE_SERVICE) {
          if (doKilling && proc.initialIdlePss != 0 && proc.lastPss > ((proc.initialIdlePss * 3) / 2)) {
            sb=new StringBuilder(128);
            sb.append(""String_Node_Str"");
            sb.append(proc.processName);
            sb.append(""String_Node_Str"");
            sb.append(proc.lastPss);
            sb.append(""String_Node_Str"");
            sb.append(proc.lastSwapPss);
            sb.append(""String_Node_Str"");
            sb.append(proc.initialIdlePss);
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(timeSinceLastIdle,sb);
            sb.append(""String_Node_Str"");
            TimeUtils.formatDuration(lowRamSinceLastIdle,sb);
            Slog.wtfQuiet(TAG,sb.toString());
            proc.kill(""String_Node_Str"" + proc.lastPss + ""String_Node_Str""+ proc.initialIdlePss+ ""String_Node_Str"",true);
          }
        }
      }
 else       if (proc.setProcState < ActivityManager.PROCESS_STATE_HOME && proc.setProcState > ActivityManager.PROCESS_STATE_NONEXISTENT) {
        proc.notCachedSinceIdle=true;
        proc.initialIdlePss=0;
        proc.nextPssTime=ProcessList.computeNextPssTime(proc.setProcState,true,mTestPssMode,isSleeping(),now);
      }
    }
    mHandler.removeMessages(REQUEST_ALL_PSS_MSG);
    mHandler.sendEmptyMessageDelayed(REQUEST_ALL_PSS_MSG,2 * 60 * 1000);
  }
}",0.98615174566023
192627,"private void onQsTouch(MotionEvent event){
  int pointerIndex=event.findPointerIndex(mTrackingPointer);
  if (pointerIndex < 0) {
    pointerIndex=0;
    mTrackingPointer=event.getPointerId(pointerIndex);
  }
  final float y=event.getY(pointerIndex);
  final float x=event.getX(pointerIndex);
  final float h=y - mInitialTouchY;
switch (event.getActionMasked()) {
case MotionEvent.ACTION_DOWN:
    mQsTracking=true;
  mInitialTouchY=y;
mInitialTouchX=x;
onQsExpansionStarted();
mInitialHeightOnTouch=mQsExpansionHeight;
initVelocityTracker();
trackMovement(event);
break;
case MotionEvent.ACTION_POINTER_UP:
final int upPointer=event.getPointerId(event.getActionIndex());
if (mTrackingPointer == upPointer) {
final int newIndex=event.getPointerId(0) != upPointer ? 0 : 1;
final float newY=event.getY(newIndex);
final float newX=event.getX(newIndex);
mTrackingPointer=event.getPointerId(newIndex);
mInitialHeightOnTouch=mQsExpansionHeight;
mInitialTouchY=newY;
mInitialTouchX=newX;
}
break;
case MotionEvent.ACTION_MOVE:
setQsExpansion(h + mInitialHeightOnTouch);
if (h >= getFalsingThreshold()) {
mQsTouchAboveFalsingThreshold=true;
}
trackMovement(event);
break;
case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_CANCEL:
mQsTracking=false;
mTrackingPointer=-1;
trackMovement(event);
flingQsWithCurrentVelocity(y,event.getActionMasked() == MotionEvent.ACTION_CANCEL);
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
break;
}
}","private void onQsTouch(MotionEvent event){
  int pointerIndex=event.findPointerIndex(mTrackingPointer);
  if (pointerIndex < 0) {
    pointerIndex=0;
    mTrackingPointer=event.getPointerId(pointerIndex);
  }
  final float y=event.getY(pointerIndex);
  final float x=event.getX(pointerIndex);
  final float h=y - mInitialTouchY;
switch (event.getActionMasked()) {
case MotionEvent.ACTION_DOWN:
    mQsTracking=true;
  mInitialTouchY=y;
mInitialTouchX=x;
onQsExpansionStarted();
mInitialHeightOnTouch=mQsExpansionHeight;
initVelocityTracker();
trackMovement(event);
break;
case MotionEvent.ACTION_POINTER_UP:
final int upPointer=event.getPointerId(event.getActionIndex());
if (mTrackingPointer == upPointer) {
final int newIndex=event.getPointerId(0) != upPointer ? 0 : 1;
final float newY=event.getY(newIndex);
final float newX=event.getX(newIndex);
mTrackingPointer=event.getPointerId(newIndex);
mInitialHeightOnTouch=mQsExpansionHeight;
mInitialTouchY=newY;
mInitialTouchX=newX;
}
break;
case MotionEvent.ACTION_MOVE:
setQsExpansion(h + mInitialHeightOnTouch);
if (h >= getFalsingThreshold()) {
mQsTouchAboveFalsingThreshold=true;
}
trackMovement(event);
break;
case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_CANCEL:
mQsTracking=false;
mTrackingPointer=-1;
trackMovement(event);
float fraction=getQsExpansionFraction();
if (fraction != 0f || y >= mInitialTouchY) {
flingQsWithCurrentVelocity(y,event.getActionMasked() == MotionEvent.ACTION_CANCEL);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
break;
}
}",0.9708416169648774
192628,"/** 
 * Whether key will, by default, trigger a click on the focused view.
 * @hide
 */
public static final boolean isConfirmKey(int keyCode){
switch (keyCode) {
case KeyEvent.KEYCODE_DPAD_CENTER:
case KeyEvent.KEYCODE_ENTER:
case KeyEvent.KEYCODE_SPACE:
    return true;
default :
  return false;
}
}","/** 
 * Whether key will, by default, trigger a click on the focused view.
 * @hide
 */
public static final boolean isConfirmKey(int keyCode){
switch (keyCode) {
case KeyEvent.KEYCODE_DPAD_CENTER:
case KeyEvent.KEYCODE_ENTER:
case KeyEvent.KEYCODE_SPACE:
case KeyEvent.KEYCODE_NUMPAD_ENTER:
    return true;
default :
  return false;
}
}",0.9435736677115988
192629,"@Override public boolean onKeyDown(int keyCode,KeyEvent event){
  if (KeyEvent.isConfirmKey(keyCode)) {
    performClick(mOkButton);
    return true;
  }
 else   if (keyCode == KeyEvent.KEYCODE_DEL) {
    performClick(mDeleteButton);
    return true;
  }
  if (keyCode >= KeyEvent.KEYCODE_0 && keyCode <= KeyEvent.KEYCODE_9) {
    int number=keyCode - KeyEvent.KEYCODE_0;
    performNumberClick(number);
    return true;
  }
  return super.onKeyDown(keyCode,event);
}","@Override public boolean onKeyDown(int keyCode,KeyEvent event){
  if (KeyEvent.isConfirmKey(keyCode)) {
    performClick(mOkButton);
    return true;
  }
 else   if (keyCode == KeyEvent.KEYCODE_DEL) {
    performClick(mDeleteButton);
    return true;
  }
  if (keyCode >= KeyEvent.KEYCODE_0 && keyCode <= KeyEvent.KEYCODE_9) {
    int number=keyCode - KeyEvent.KEYCODE_0;
    performNumberClick(number);
    return true;
  }
  if (keyCode >= KeyEvent.KEYCODE_NUMPAD_0 && keyCode <= KeyEvent.KEYCODE_NUMPAD_9) {
    int number=keyCode - KeyEvent.KEYCODE_NUMPAD_0;
    performNumberClick(number);
    return true;
  }
  return super.onKeyDown(keyCode,event);
}",0.8302222222222222
192630,"protected void updatePublicContentView(Entry entry,StatusBarNotification sbn){
  final RemoteViews publicContentView=entry.cachedPublicContentView;
  if (publicContentView != null && entry.getPublicContentView() != null) {
    final boolean disabledByPolicy=!adminAllowsUnredactedNotifications(entry.notification.getUserId());
    publicContentView.setTextViewText(android.R.id.title,mContext.getString(disabledByPolicy ? com.android.internal.R.string.notification_hidden_by_policy_text : com.android.internal.R.string.notification_hidden_text));
    publicContentView.reapply(sbn.getPackageContext(mContext),entry.getPublicContentView(),mOnClickHandler);
  }
}","protected void updatePublicContentView(Entry entry,StatusBarNotification sbn){
  final RemoteViews publicContentView=entry.cachedPublicContentView;
  View inflatedView=entry.getPublicContentView();
  if (entry.autoRedacted && publicContentView != null && inflatedView != null) {
    final boolean disabledByPolicy=!adminAllowsUnredactedNotifications(entry.notification.getUserId());
    String notificationHiddenText=mContext.getString(disabledByPolicy ? com.android.internal.R.string.notification_hidden_by_policy_text : com.android.internal.R.string.notification_hidden_text);
    TextView titleView=(TextView)inflatedView.findViewById(android.R.id.title);
    if (titleView != null && !titleView.getText().toString().equals(notificationHiddenText)) {
      publicContentView.setTextViewText(android.R.id.title,notificationHiddenText);
      publicContentView.reapply(sbn.getPackageContext(mContext),inflatedView,mOnClickHandler);
      entry.row.onNotificationUpdated(entry);
    }
  }
}",0.6674742580254391
192631,"public void setDark(boolean dark,boolean fade,long delay){
  if (mDark == dark || mContractedChild == null)   return;
  mDark=dark;
  dark=dark && !mShowingLegacyBackground;
  if (mVisibleType == VISIBLE_TYPE_CONTRACTED || !dark) {
    mContractedWrapper.setDark(dark,fade,delay);
  }
  if (mVisibleType == VISIBLE_TYPE_EXPANDED || (mExpandedChild != null && !dark)) {
    mExpandedWrapper.setDark(dark,fade,delay);
  }
  if (mVisibleType == VISIBLE_TYPE_HEADSUP || (mHeadsUpChild != null && !dark)) {
    mHeadsUpWrapper.setDark(dark,fade,delay);
  }
  if (mSingleLineView != null && (mVisibleType == VISIBLE_TYPE_SINGLELINE || !dark)) {
    mSingleLineView.setDark(dark,fade,delay);
  }
}","public void setDark(boolean dark,boolean fade,long delay,boolean force){
  if ((!force && mDark == dark) || mContractedChild == null) {
    return;
  }
  mDark=dark;
  dark=dark && !mShowingLegacyBackground;
  if (mVisibleType == VISIBLE_TYPE_CONTRACTED || !dark) {
    mContractedWrapper.setDark(dark,fade,delay);
  }
  if (mVisibleType == VISIBLE_TYPE_EXPANDED || (mExpandedChild != null && !dark)) {
    mExpandedWrapper.setDark(dark,fade,delay);
  }
  if (mVisibleType == VISIBLE_TYPE_HEADSUP || (mHeadsUpChild != null && !dark)) {
    mHeadsUpWrapper.setDark(dark,fade,delay);
  }
  if (mSingleLineView != null && (mVisibleType == VISIBLE_TYPE_SINGLELINE || !dark)) {
    mSingleLineView.setDark(dark,fade,delay);
  }
}",0.9575671852899575
192632,"public void onNotificationUpdated(NotificationData.Entry entry){
  mStatusBarNotification=entry.notification;
  mBeforeN=entry.targetSdk < Build.VERSION_CODES.N;
  updateSingleLineView();
  applyRemoteInput(entry);
  selectLayout(false,true);
  if (mContractedChild != null) {
    mContractedWrapper.notifyContentUpdated(entry.notification);
    mContractedWrapper.setDark(mDark,false,0);
  }
  if (mExpandedChild != null) {
    mExpandedWrapper.notifyContentUpdated(entry.notification);
  }
  if (mHeadsUpChild != null) {
    mHeadsUpWrapper.notifyContentUpdated(entry.notification);
  }
}","public void onNotificationUpdated(NotificationData.Entry entry){
  mStatusBarNotification=entry.notification;
  mBeforeN=entry.targetSdk < Build.VERSION_CODES.N;
  updateSingleLineView();
  applyRemoteInput(entry);
  selectLayout(false,true);
  if (mContractedChild != null) {
    mContractedWrapper.notifyContentUpdated(entry.notification);
  }
  if (mExpandedChild != null) {
    mExpandedWrapper.notifyContentUpdated(entry.notification);
  }
  if (mHeadsUpChild != null) {
    mHeadsUpWrapper.notifyContentUpdated(entry.notification);
  }
  setDark(mDark,false,0,true);
}",0.6460481099656358
192633,"private int startActivityUnchecked(final ActivityRecord r,ActivityRecord sourceRecord,IVoiceInteractionSession voiceSession,IVoiceInteractor voiceInteractor,int startFlags,boolean doResume,ActivityOptions options,TaskRecord inTask){
  setInitialState(r,options,inTask,doResume,startFlags,sourceRecord,voiceSession,voiceInteractor);
  computeLaunchingTaskFlags();
  computeSourceStack();
  mIntent.setFlags(mLaunchFlags);
  ActivityRecord intentActivity=getReusableIntentActivity();
  if (intentActivity != null) {
    if (mSupervisor.isLockTaskModeViolation(intentActivity.task,(mLaunchFlags & (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK)) == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK))) {
      mSupervisor.showLockTaskToast();
      Slog.e(TAG,""String_Node_Str"");
      return START_RETURN_LOCK_TASK_MODE_VIOLATION;
    }
    if (mStartActivity.task == null) {
      mStartActivity.task=intentActivity.task;
    }
    if (intentActivity.task.intent == null) {
      intentActivity.task.setIntent(mStartActivity);
    }
    if ((mLaunchFlags & FLAG_ACTIVITY_CLEAR_TOP) != 0 || mLaunchSingleInstance || mLaunchSingleTask) {
      final ActivityRecord top=intentActivity.task.performClearTaskForReuseLocked(mStartActivity,mLaunchFlags);
      if (top != null) {
        if (top.frontOfTask) {
          top.task.setIntent(mStartActivity);
        }
        ActivityStack.logStartActivity(AM_NEW_INTENT,mStartActivity,top.task);
        top.deliverNewIntentLocked(mCallingUid,mStartActivity.intent,mStartActivity.launchedFromPackage);
      }
    }
    intentActivity=setTargetStackAndMoveToFrontIfNeeded(intentActivity);
    if ((mStartFlags & START_FLAG_ONLY_IF_NEEDED) != 0) {
      resumeTargetStackIfNeeded();
      return START_RETURN_INTENT_TO_CALLER;
    }
    setTaskFromIntentActivity(intentActivity);
    if (!mAddingToTask && mReuseTask == null) {
      resumeTargetStackIfNeeded();
      return START_TASK_TO_FRONT;
    }
  }
  if (mStartActivity.packageName == null) {
    if (mStartActivity.resultTo != null && mStartActivity.resultTo.task.stack != null) {
      mStartActivity.resultTo.task.stack.sendActivityResultLocked(-1,mStartActivity.resultTo,mStartActivity.resultWho,mStartActivity.requestCode,RESULT_CANCELED,null);
    }
    ActivityOptions.abort(mOptions);
    return START_CLASS_NOT_FOUND;
  }
  final ActivityStack topStack=mSupervisor.mFocusedStack;
  final ActivityRecord top=topStack.topRunningNonDelayedActivityLocked(mNotTop);
  final boolean dontStart=top != null && mStartActivity.resultTo == null && top.realActivity.equals(mStartActivity.realActivity) && top.userId == mStartActivity.userId && top.app != null && top.app.thread != null && ((mLaunchFlags & FLAG_ACTIVITY_SINGLE_TOP) != 0 || mLaunchSingleTop || mLaunchSingleTask);
  if (dontStart) {
    ActivityStack.logStartActivity(AM_NEW_INTENT,top,top.task);
    topStack.mLastPausedActivity=null;
    if (mDoResume) {
      mSupervisor.resumeFocusedStackTopActivityLocked();
    }
    ActivityOptions.abort(mOptions);
    if ((mStartFlags & START_FLAG_ONLY_IF_NEEDED) != 0) {
      return START_RETURN_INTENT_TO_CALLER;
    }
    top.deliverNewIntentLocked(mCallingUid,mStartActivity.intent,mStartActivity.launchedFromPackage);
    return START_DELIVERED_TO_TOP;
  }
  boolean newTask=false;
  final TaskRecord taskToAffiliate=(mLaunchTaskBehind && mSourceRecord != null) ? mSourceRecord.task : null;
  if (mStartActivity.resultTo == null && mInTask == null && !mAddingToTask && (mLaunchFlags & FLAG_ACTIVITY_NEW_TASK) != 0) {
    newTask=true;
    setTaskFromReuseOrCreateNewTask(taskToAffiliate);
    if (mSupervisor.isLockTaskModeViolation(mStartActivity.task)) {
      Slog.e(TAG,""String_Node_Str"" + mStartActivity);
      return START_RETURN_LOCK_TASK_MODE_VIOLATION;
    }
    if (!mMovedHome) {
      updateTaskReturnToType(mStartActivity.task,mLaunchFlags,topStack);
    }
  }
 else   if (mSourceRecord != null) {
    if (mSupervisor.isLockTaskModeViolation(mSourceRecord.task)) {
      Slog.e(TAG,""String_Node_Str"" + mStartActivity);
      return START_RETURN_LOCK_TASK_MODE_VIOLATION;
    }
    final int result=setTaskFromSourceRecord();
    if (result != START_SUCCESS) {
      return result;
    }
  }
 else   if (mInTask != null) {
    if (mSupervisor.isLockTaskModeViolation(mInTask)) {
      Slog.e(TAG,""String_Node_Str"" + mStartActivity);
      return START_RETURN_LOCK_TASK_MODE_VIOLATION;
    }
    final int result=setTaskFromInTask();
    if (result != START_SUCCESS) {
      return result;
    }
  }
 else {
    setTaskToCurrentTopOrCreateNewTask();
  }
  mService.grantUriPermissionFromIntentLocked(mCallingUid,mStartActivity.packageName,mIntent,mStartActivity.getUriPermissionsLocked(),mStartActivity.userId);
  if (mSourceRecord != null && mSourceRecord.isRecentsActivity()) {
    mStartActivity.task.setTaskToReturnTo(RECENTS_ACTIVITY_TYPE);
  }
  if (newTask) {
    EventLog.writeEvent(EventLogTags.AM_CREATE_TASK,mStartActivity.userId,mStartActivity.task.taskId);
  }
  ActivityStack.logStartActivity(EventLogTags.AM_CREATE_ACTIVITY,mStartActivity,mStartActivity.task);
  mTargetStack.mLastPausedActivity=null;
  mTargetStack.startActivityLocked(mStartActivity,newTask,mKeepCurTransition,mOptions);
  if (mDoResume) {
    if (!mLaunchTaskBehind) {
      mService.setFocusedActivityLocked(mStartActivity,""String_Node_Str"");
    }
    if (mTargetStack.isFocusable()) {
      mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack,mStartActivity,mOptions);
    }
 else {
      mTargetStack.ensureActivitiesVisibleLocked(null,0,!PRESERVE_WINDOWS);
    }
  }
 else {
    mTargetStack.addRecentActivityLocked(mStartActivity);
  }
  mSupervisor.updateUserStackLocked(mStartActivity.userId,mTargetStack);
  final int preferredLaunchStackId=(mOptions != null) ? mOptions.getLaunchStackId() : INVALID_STACK_ID;
  mSupervisor.showNonResizeableDockToastIfNeeded(mStartActivity.task,preferredLaunchStackId,mTargetStack.mStackId);
  return START_SUCCESS;
}","private int startActivityUnchecked(final ActivityRecord r,ActivityRecord sourceRecord,IVoiceInteractionSession voiceSession,IVoiceInteractor voiceInteractor,int startFlags,boolean doResume,ActivityOptions options,TaskRecord inTask){
  setInitialState(r,options,inTask,doResume,startFlags,sourceRecord,voiceSession,voiceInteractor);
  computeLaunchingTaskFlags();
  computeSourceStack();
  mIntent.setFlags(mLaunchFlags);
  ActivityRecord intentActivity=getReusableIntentActivity();
  if (intentActivity != null) {
    if (mSupervisor.isLockTaskModeViolation(intentActivity.task,(mLaunchFlags & (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK)) == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK))) {
      mSupervisor.showLockTaskToast();
      Slog.e(TAG,""String_Node_Str"");
      return START_RETURN_LOCK_TASK_MODE_VIOLATION;
    }
    if (mStartActivity.task == null) {
      mStartActivity.task=intentActivity.task;
    }
    if (intentActivity.task.intent == null) {
      intentActivity.task.setIntent(mStartActivity);
    }
    if ((mLaunchFlags & FLAG_ACTIVITY_CLEAR_TOP) != 0 || mLaunchSingleInstance || mLaunchSingleTask) {
      final ActivityRecord top=intentActivity.task.performClearTaskForReuseLocked(mStartActivity,mLaunchFlags);
      if (top != null) {
        if (top.frontOfTask) {
          top.task.setIntent(mStartActivity);
        }
        ActivityStack.logStartActivity(AM_NEW_INTENT,mStartActivity,top.task);
        top.deliverNewIntentLocked(mCallingUid,mStartActivity.intent,mStartActivity.launchedFromPackage);
      }
    }
    intentActivity=setTargetStackAndMoveToFrontIfNeeded(intentActivity);
    if ((mStartFlags & START_FLAG_ONLY_IF_NEEDED) != 0) {
      resumeTargetStackIfNeeded();
      return START_RETURN_INTENT_TO_CALLER;
    }
    setTaskFromIntentActivity(intentActivity);
    if (!mAddingToTask && mReuseTask == null) {
      resumeTargetStackIfNeeded();
      return START_TASK_TO_FRONT;
    }
  }
  if (mStartActivity.packageName == null) {
    if (mStartActivity.resultTo != null && mStartActivity.resultTo.task.stack != null) {
      mStartActivity.resultTo.task.stack.sendActivityResultLocked(-1,mStartActivity.resultTo,mStartActivity.resultWho,mStartActivity.requestCode,RESULT_CANCELED,null);
    }
    ActivityOptions.abort(mOptions);
    return START_CLASS_NOT_FOUND;
  }
  final ActivityStack topStack=mSupervisor.mFocusedStack;
  final ActivityRecord top=topStack.topRunningNonDelayedActivityLocked(mNotTop);
  final boolean dontStart=top != null && mStartActivity.resultTo == null && top.realActivity.equals(mStartActivity.realActivity) && top.userId == mStartActivity.userId && top.app != null && top.app.thread != null && ((mLaunchFlags & FLAG_ACTIVITY_SINGLE_TOP) != 0 || mLaunchSingleTop || mLaunchSingleTask);
  if (dontStart) {
    ActivityStack.logStartActivity(AM_NEW_INTENT,top,top.task);
    topStack.mLastPausedActivity=null;
    if (mDoResume) {
      mSupervisor.resumeFocusedStackTopActivityLocked();
    }
    ActivityOptions.abort(mOptions);
    if ((mStartFlags & START_FLAG_ONLY_IF_NEEDED) != 0) {
      return START_RETURN_INTENT_TO_CALLER;
    }
    top.deliverNewIntentLocked(mCallingUid,mStartActivity.intent,mStartActivity.launchedFromPackage);
    return START_DELIVERED_TO_TOP;
  }
  boolean newTask=false;
  final TaskRecord taskToAffiliate=(mLaunchTaskBehind && mSourceRecord != null) ? mSourceRecord.task : null;
  if (mStartActivity.resultTo == null && mInTask == null && !mAddingToTask && (mLaunchFlags & FLAG_ACTIVITY_NEW_TASK) != 0) {
    newTask=true;
    setTaskFromReuseOrCreateNewTask(taskToAffiliate);
    if (mSupervisor.isLockTaskModeViolation(mStartActivity.task)) {
      Slog.e(TAG,""String_Node_Str"" + mStartActivity);
      return START_RETURN_LOCK_TASK_MODE_VIOLATION;
    }
    if (!mMovedHome) {
      updateTaskReturnToType(mStartActivity.task,mLaunchFlags,topStack);
    }
  }
 else   if (mSourceRecord != null) {
    if (mSupervisor.isLockTaskModeViolation(mSourceRecord.task)) {
      Slog.e(TAG,""String_Node_Str"" + mStartActivity);
      return START_RETURN_LOCK_TASK_MODE_VIOLATION;
    }
    final int result=setTaskFromSourceRecord();
    if (result != START_SUCCESS) {
      return result;
    }
  }
 else   if (mInTask != null) {
    if (mSupervisor.isLockTaskModeViolation(mInTask)) {
      Slog.e(TAG,""String_Node_Str"" + mStartActivity);
      return START_RETURN_LOCK_TASK_MODE_VIOLATION;
    }
    final int result=setTaskFromInTask();
    if (result != START_SUCCESS) {
      return result;
    }
  }
 else {
    setTaskToCurrentTopOrCreateNewTask();
  }
  mService.grantUriPermissionFromIntentLocked(mCallingUid,mStartActivity.packageName,mIntent,mStartActivity.getUriPermissionsLocked(),mStartActivity.userId);
  if (mSourceRecord != null && mSourceRecord.isRecentsActivity()) {
    mStartActivity.task.setTaskToReturnTo(RECENTS_ACTIVITY_TYPE);
  }
  if (newTask) {
    EventLog.writeEvent(EventLogTags.AM_CREATE_TASK,mStartActivity.userId,mStartActivity.task.taskId);
  }
  ActivityStack.logStartActivity(EventLogTags.AM_CREATE_ACTIVITY,mStartActivity,mStartActivity.task);
  mTargetStack.mLastPausedActivity=null;
  mTargetStack.startActivityLocked(mStartActivity,newTask,mKeepCurTransition,mOptions);
  if (mDoResume) {
    if (!mLaunchTaskBehind) {
      mService.setFocusedActivityLocked(mStartActivity,""String_Node_Str"");
    }
    if (mTargetStack.isFocusable()) {
      mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack,mStartActivity,mOptions);
    }
 else {
      mTargetStack.ensureActivitiesVisibleLocked(null,0,!PRESERVE_WINDOWS);
      mWindowManager.executeAppTransition();
    }
  }
 else {
    mTargetStack.addRecentActivityLocked(mStartActivity);
  }
  mSupervisor.updateUserStackLocked(mStartActivity.userId,mTargetStack);
  final int preferredLaunchStackId=(mOptions != null) ? mOptions.getLaunchStackId() : INVALID_STACK_ID;
  mSupervisor.showNonResizeableDockToastIfNeeded(mStartActivity.task,preferredLaunchStackId,mTargetStack.mStackId);
  return START_SUCCESS;
}",0.9962528103922058
192634,"private void onQsTouch(MotionEvent event){
  int pointerIndex=event.findPointerIndex(mTrackingPointer);
  if (pointerIndex < 0) {
    pointerIndex=0;
    mTrackingPointer=event.getPointerId(pointerIndex);
  }
  final float y=event.getY(pointerIndex);
  final float x=event.getX(pointerIndex);
  final float h=y - mInitialTouchY;
switch (event.getActionMasked()) {
case MotionEvent.ACTION_DOWN:
    mQsTracking=true;
  mInitialTouchY=y;
mInitialTouchX=x;
onQsExpansionStarted();
mInitialHeightOnTouch=mQsExpansionHeight;
initVelocityTracker();
trackMovement(event);
break;
case MotionEvent.ACTION_POINTER_UP:
final int upPointer=event.getPointerId(event.getActionIndex());
if (mTrackingPointer == upPointer) {
final int newIndex=event.getPointerId(0) != upPointer ? 0 : 1;
final float newY=event.getY(newIndex);
final float newX=event.getX(newIndex);
mTrackingPointer=event.getPointerId(newIndex);
mInitialHeightOnTouch=mQsExpansionHeight;
mInitialTouchY=newY;
mInitialTouchX=newX;
}
break;
case MotionEvent.ACTION_MOVE:
setQsExpansion(h + mInitialHeightOnTouch);
if (h >= getFalsingThreshold()) {
mQsTouchAboveFalsingThreshold=true;
}
trackMovement(event);
break;
case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_CANCEL:
mQsTracking=false;
mTrackingPointer=-1;
trackMovement(event);
flingQsWithCurrentVelocity(y,event.getActionMasked() == MotionEvent.ACTION_CANCEL);
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
break;
}
}","private void onQsTouch(MotionEvent event){
  int pointerIndex=event.findPointerIndex(mTrackingPointer);
  if (pointerIndex < 0) {
    pointerIndex=0;
    mTrackingPointer=event.getPointerId(pointerIndex);
  }
  final float y=event.getY(pointerIndex);
  final float x=event.getX(pointerIndex);
  final float h=y - mInitialTouchY;
switch (event.getActionMasked()) {
case MotionEvent.ACTION_DOWN:
    mQsTracking=true;
  mInitialTouchY=y;
mInitialTouchX=x;
onQsExpansionStarted();
mInitialHeightOnTouch=mQsExpansionHeight;
initVelocityTracker();
trackMovement(event);
break;
case MotionEvent.ACTION_POINTER_UP:
final int upPointer=event.getPointerId(event.getActionIndex());
if (mTrackingPointer == upPointer) {
final int newIndex=event.getPointerId(0) != upPointer ? 0 : 1;
final float newY=event.getY(newIndex);
final float newX=event.getX(newIndex);
mTrackingPointer=event.getPointerId(newIndex);
mInitialHeightOnTouch=mQsExpansionHeight;
mInitialTouchY=newY;
mInitialTouchX=newX;
}
break;
case MotionEvent.ACTION_MOVE:
setQsExpansion(h + mInitialHeightOnTouch);
if (h >= getFalsingThreshold()) {
mQsTouchAboveFalsingThreshold=true;
}
trackMovement(event);
break;
case MotionEvent.ACTION_UP:
case MotionEvent.ACTION_CANCEL:
mQsTracking=false;
mTrackingPointer=-1;
trackMovement(event);
float fraction=getQsExpansionFraction();
if (fraction != 0f || y >= mInitialTouchY) {
flingQsWithCurrentVelocity(y,event.getActionMasked() == MotionEvent.ACTION_CANCEL);
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
break;
}
}",0.9708416169648774
192635,"protected void updatePublicContentView(Entry entry,StatusBarNotification sbn){
  final RemoteViews publicContentView=entry.cachedPublicContentView;
  if (publicContentView != null && entry.getPublicContentView() != null) {
    final boolean disabledByPolicy=!adminAllowsUnredactedNotifications(entry.notification.getUserId());
    publicContentView.setTextViewText(android.R.id.title,mContext.getString(disabledByPolicy ? com.android.internal.R.string.notification_hidden_by_policy_text : com.android.internal.R.string.notification_hidden_text));
    publicContentView.reapply(sbn.getPackageContext(mContext),entry.getPublicContentView(),mOnClickHandler);
  }
}","protected void updatePublicContentView(Entry entry,StatusBarNotification sbn){
  final RemoteViews publicContentView=entry.cachedPublicContentView;
  View inflatedView=entry.getPublicContentView();
  if (entry.autoRedacted && publicContentView != null && inflatedView != null) {
    final boolean disabledByPolicy=!adminAllowsUnredactedNotifications(entry.notification.getUserId());
    String notificationHiddenText=mContext.getString(disabledByPolicy ? com.android.internal.R.string.notification_hidden_by_policy_text : com.android.internal.R.string.notification_hidden_text);
    TextView titleView=(TextView)inflatedView.findViewById(android.R.id.title);
    if (titleView != null && !titleView.getText().toString().equals(notificationHiddenText)) {
      publicContentView.setTextViewText(android.R.id.title,notificationHiddenText);
      publicContentView.reapply(sbn.getPackageContext(mContext),inflatedView,mOnClickHandler);
      entry.row.onNotificationUpdated(entry);
    }
  }
}",0.6674742580254391
192636,"public void setDark(boolean dark,boolean fade,long delay){
  if (mDark == dark || mContractedChild == null)   return;
  mDark=dark;
  dark=dark && !mShowingLegacyBackground;
  if (mVisibleType == VISIBLE_TYPE_CONTRACTED || !dark) {
    mContractedWrapper.setDark(dark,fade,delay);
  }
  if (mVisibleType == VISIBLE_TYPE_EXPANDED || (mExpandedChild != null && !dark)) {
    mExpandedWrapper.setDark(dark,fade,delay);
  }
  if (mVisibleType == VISIBLE_TYPE_HEADSUP || (mHeadsUpChild != null && !dark)) {
    mHeadsUpWrapper.setDark(dark,fade,delay);
  }
  if (mSingleLineView != null && (mVisibleType == VISIBLE_TYPE_SINGLELINE || !dark)) {
    mSingleLineView.setDark(dark,fade,delay);
  }
}","public void setDark(boolean dark,boolean fade,long delay,boolean force){
  if ((!force && mDark == dark) || mContractedChild == null) {
    return;
  }
  mDark=dark;
  dark=dark && !mShowingLegacyBackground;
  if (mVisibleType == VISIBLE_TYPE_CONTRACTED || !dark) {
    mContractedWrapper.setDark(dark,fade,delay);
  }
  if (mVisibleType == VISIBLE_TYPE_EXPANDED || (mExpandedChild != null && !dark)) {
    mExpandedWrapper.setDark(dark,fade,delay);
  }
  if (mVisibleType == VISIBLE_TYPE_HEADSUP || (mHeadsUpChild != null && !dark)) {
    mHeadsUpWrapper.setDark(dark,fade,delay);
  }
  if (mSingleLineView != null && (mVisibleType == VISIBLE_TYPE_SINGLELINE || !dark)) {
    mSingleLineView.setDark(dark,fade,delay);
  }
}",0.9575671852899575
192637,"public void onNotificationUpdated(NotificationData.Entry entry){
  mStatusBarNotification=entry.notification;
  mBeforeN=entry.targetSdk < Build.VERSION_CODES.N;
  updateSingleLineView();
  applyRemoteInput(entry);
  selectLayout(false,true);
  if (mContractedChild != null) {
    mContractedWrapper.notifyContentUpdated(entry.notification);
    mContractedWrapper.setDark(mDark,false,0);
  }
  if (mExpandedChild != null) {
    mExpandedWrapper.notifyContentUpdated(entry.notification);
  }
  if (mHeadsUpChild != null) {
    mHeadsUpWrapper.notifyContentUpdated(entry.notification);
  }
}","public void onNotificationUpdated(NotificationData.Entry entry){
  mStatusBarNotification=entry.notification;
  mBeforeN=entry.targetSdk < Build.VERSION_CODES.N;
  updateSingleLineView();
  applyRemoteInput(entry);
  selectLayout(false,true);
  if (mContractedChild != null) {
    mContractedWrapper.notifyContentUpdated(entry.notification);
  }
  if (mExpandedChild != null) {
    mExpandedWrapper.notifyContentUpdated(entry.notification);
  }
  if (mHeadsUpChild != null) {
    mHeadsUpWrapper.notifyContentUpdated(entry.notification);
  }
  setDark(mDark,false,0,true);
}",0.6460481099656358
192638,"/** 
 * Whether key will, by default, trigger a click on the focused view.
 * @hide
 */
public static final boolean isConfirmKey(int keyCode){
switch (keyCode) {
case KeyEvent.KEYCODE_DPAD_CENTER:
case KeyEvent.KEYCODE_ENTER:
case KeyEvent.KEYCODE_SPACE:
    return true;
default :
  return false;
}
}","/** 
 * Whether key will, by default, trigger a click on the focused view.
 * @hide
 */
public static final boolean isConfirmKey(int keyCode){
switch (keyCode) {
case KeyEvent.KEYCODE_DPAD_CENTER:
case KeyEvent.KEYCODE_ENTER:
case KeyEvent.KEYCODE_SPACE:
case KeyEvent.KEYCODE_NUMPAD_ENTER:
    return true;
default :
  return false;
}
}",0.9435736677115988
192639,"@Override public boolean onKeyDown(int keyCode,KeyEvent event){
  if (KeyEvent.isConfirmKey(keyCode)) {
    performClick(mOkButton);
    return true;
  }
 else   if (keyCode == KeyEvent.KEYCODE_DEL) {
    performClick(mDeleteButton);
    return true;
  }
  if (keyCode >= KeyEvent.KEYCODE_0 && keyCode <= KeyEvent.KEYCODE_9) {
    int number=keyCode - KeyEvent.KEYCODE_0;
    performNumberClick(number);
    return true;
  }
  return super.onKeyDown(keyCode,event);
}","@Override public boolean onKeyDown(int keyCode,KeyEvent event){
  if (KeyEvent.isConfirmKey(keyCode)) {
    performClick(mOkButton);
    return true;
  }
 else   if (keyCode == KeyEvent.KEYCODE_DEL) {
    performClick(mDeleteButton);
    return true;
  }
  if (keyCode >= KeyEvent.KEYCODE_0 && keyCode <= KeyEvent.KEYCODE_9) {
    int number=keyCode - KeyEvent.KEYCODE_0;
    performNumberClick(number);
    return true;
  }
  if (keyCode >= KeyEvent.KEYCODE_NUMPAD_0 && keyCode <= KeyEvent.KEYCODE_NUMPAD_9) {
    int number=keyCode - KeyEvent.KEYCODE_NUMPAD_0;
    performNumberClick(number);
    return true;
  }
  return super.onKeyDown(keyCode,event);
}",0.8302222222222222
192640,"private int startActivityUnchecked(final ActivityRecord r,ActivityRecord sourceRecord,IVoiceInteractionSession voiceSession,IVoiceInteractor voiceInteractor,int startFlags,boolean doResume,ActivityOptions options,TaskRecord inTask){
  setInitialState(r,options,inTask,doResume,startFlags,sourceRecord,voiceSession,voiceInteractor);
  computeLaunchingTaskFlags();
  computeSourceStack();
  mIntent.setFlags(mLaunchFlags);
  ActivityRecord intentActivity=getReusableIntentActivity();
  if (intentActivity != null) {
    if (mSupervisor.isLockTaskModeViolation(intentActivity.task,(mLaunchFlags & (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK)) == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK))) {
      mSupervisor.showLockTaskToast();
      Slog.e(TAG,""String_Node_Str"");
      return START_RETURN_LOCK_TASK_MODE_VIOLATION;
    }
    if (mStartActivity.task == null) {
      mStartActivity.task=intentActivity.task;
    }
    if (intentActivity.task.intent == null) {
      intentActivity.task.setIntent(mStartActivity);
    }
    if ((mLaunchFlags & FLAG_ACTIVITY_CLEAR_TOP) != 0 || mLaunchSingleInstance || mLaunchSingleTask) {
      final ActivityRecord top=intentActivity.task.performClearTaskForReuseLocked(mStartActivity,mLaunchFlags);
      if (top != null) {
        if (top.frontOfTask) {
          top.task.setIntent(mStartActivity);
        }
        ActivityStack.logStartActivity(AM_NEW_INTENT,mStartActivity,top.task);
        top.deliverNewIntentLocked(mCallingUid,mStartActivity.intent,mStartActivity.launchedFromPackage);
      }
    }
    intentActivity=setTargetStackAndMoveToFrontIfNeeded(intentActivity);
    if ((mStartFlags & START_FLAG_ONLY_IF_NEEDED) != 0) {
      resumeTargetStackIfNeeded();
      return START_RETURN_INTENT_TO_CALLER;
    }
    setTaskFromIntentActivity(intentActivity);
    if (!mAddingToTask && mReuseTask == null) {
      resumeTargetStackIfNeeded();
      return START_TASK_TO_FRONT;
    }
  }
  if (mStartActivity.packageName == null) {
    if (mStartActivity.resultTo != null && mStartActivity.resultTo.task.stack != null) {
      mStartActivity.resultTo.task.stack.sendActivityResultLocked(-1,mStartActivity.resultTo,mStartActivity.resultWho,mStartActivity.requestCode,RESULT_CANCELED,null);
    }
    ActivityOptions.abort(mOptions);
    return START_CLASS_NOT_FOUND;
  }
  final ActivityStack topStack=mSupervisor.mFocusedStack;
  final ActivityRecord top=topStack.topRunningNonDelayedActivityLocked(mNotTop);
  final boolean dontStart=top != null && mStartActivity.resultTo == null && top.realActivity.equals(mStartActivity.realActivity) && top.userId == mStartActivity.userId && top.app != null && top.app.thread != null && ((mLaunchFlags & FLAG_ACTIVITY_SINGLE_TOP) != 0 || mLaunchSingleTop || mLaunchSingleTask);
  if (dontStart) {
    ActivityStack.logStartActivity(AM_NEW_INTENT,top,top.task);
    topStack.mLastPausedActivity=null;
    if (mDoResume) {
      mSupervisor.resumeFocusedStackTopActivityLocked();
    }
    ActivityOptions.abort(mOptions);
    if ((mStartFlags & START_FLAG_ONLY_IF_NEEDED) != 0) {
      return START_RETURN_INTENT_TO_CALLER;
    }
    top.deliverNewIntentLocked(mCallingUid,mStartActivity.intent,mStartActivity.launchedFromPackage);
    return START_DELIVERED_TO_TOP;
  }
  boolean newTask=false;
  final TaskRecord taskToAffiliate=(mLaunchTaskBehind && mSourceRecord != null) ? mSourceRecord.task : null;
  if (mStartActivity.resultTo == null && mInTask == null && !mAddingToTask && (mLaunchFlags & FLAG_ACTIVITY_NEW_TASK) != 0) {
    newTask=true;
    setTaskFromReuseOrCreateNewTask(taskToAffiliate);
    if (mSupervisor.isLockTaskModeViolation(mStartActivity.task)) {
      Slog.e(TAG,""String_Node_Str"" + mStartActivity);
      return START_RETURN_LOCK_TASK_MODE_VIOLATION;
    }
    if (!mMovedHome) {
      updateTaskReturnToType(mStartActivity.task,mLaunchFlags,topStack);
    }
  }
 else   if (mSourceRecord != null) {
    if (mSupervisor.isLockTaskModeViolation(mSourceRecord.task)) {
      Slog.e(TAG,""String_Node_Str"" + mStartActivity);
      return START_RETURN_LOCK_TASK_MODE_VIOLATION;
    }
    final int result=setTaskFromSourceRecord();
    if (result != START_SUCCESS) {
      return result;
    }
  }
 else   if (mInTask != null) {
    if (mSupervisor.isLockTaskModeViolation(mInTask)) {
      Slog.e(TAG,""String_Node_Str"" + mStartActivity);
      return START_RETURN_LOCK_TASK_MODE_VIOLATION;
    }
    final int result=setTaskFromInTask();
    if (result != START_SUCCESS) {
      return result;
    }
  }
 else {
    setTaskToCurrentTopOrCreateNewTask();
  }
  mService.grantUriPermissionFromIntentLocked(mCallingUid,mStartActivity.packageName,mIntent,mStartActivity.getUriPermissionsLocked(),mStartActivity.userId);
  if (mSourceRecord != null && mSourceRecord.isRecentsActivity()) {
    mStartActivity.task.setTaskToReturnTo(RECENTS_ACTIVITY_TYPE);
  }
  if (newTask) {
    EventLog.writeEvent(EventLogTags.AM_CREATE_TASK,mStartActivity.userId,mStartActivity.task.taskId);
  }
  ActivityStack.logStartActivity(EventLogTags.AM_CREATE_ACTIVITY,mStartActivity,mStartActivity.task);
  mTargetStack.mLastPausedActivity=null;
  mTargetStack.startActivityLocked(mStartActivity,newTask,mKeepCurTransition,mOptions);
  if (mDoResume) {
    if (!mLaunchTaskBehind) {
      mService.setFocusedActivityLocked(mStartActivity,""String_Node_Str"");
    }
    if (mTargetStack.isFocusable()) {
      mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack,mStartActivity,mOptions);
    }
 else {
      mTargetStack.ensureActivitiesVisibleLocked(null,0,!PRESERVE_WINDOWS);
    }
  }
 else {
    mTargetStack.addRecentActivityLocked(mStartActivity);
  }
  mSupervisor.updateUserStackLocked(mStartActivity.userId,mTargetStack);
  final int preferredLaunchStackId=(mOptions != null) ? mOptions.getLaunchStackId() : INVALID_STACK_ID;
  mSupervisor.showNonResizeableDockToastIfNeeded(mStartActivity.task,preferredLaunchStackId,mTargetStack.mStackId);
  return START_SUCCESS;
}","private int startActivityUnchecked(final ActivityRecord r,ActivityRecord sourceRecord,IVoiceInteractionSession voiceSession,IVoiceInteractor voiceInteractor,int startFlags,boolean doResume,ActivityOptions options,TaskRecord inTask){
  setInitialState(r,options,inTask,doResume,startFlags,sourceRecord,voiceSession,voiceInteractor);
  computeLaunchingTaskFlags();
  computeSourceStack();
  mIntent.setFlags(mLaunchFlags);
  ActivityRecord intentActivity=getReusableIntentActivity();
  if (intentActivity != null) {
    if (mSupervisor.isLockTaskModeViolation(intentActivity.task,(mLaunchFlags & (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK)) == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK))) {
      mSupervisor.showLockTaskToast();
      Slog.e(TAG,""String_Node_Str"");
      return START_RETURN_LOCK_TASK_MODE_VIOLATION;
    }
    if (mStartActivity.task == null) {
      mStartActivity.task=intentActivity.task;
    }
    if (intentActivity.task.intent == null) {
      intentActivity.task.setIntent(mStartActivity);
    }
    if ((mLaunchFlags & FLAG_ACTIVITY_CLEAR_TOP) != 0 || mLaunchSingleInstance || mLaunchSingleTask) {
      final ActivityRecord top=intentActivity.task.performClearTaskForReuseLocked(mStartActivity,mLaunchFlags);
      if (top != null) {
        if (top.frontOfTask) {
          top.task.setIntent(mStartActivity);
        }
        ActivityStack.logStartActivity(AM_NEW_INTENT,mStartActivity,top.task);
        top.deliverNewIntentLocked(mCallingUid,mStartActivity.intent,mStartActivity.launchedFromPackage);
      }
    }
    intentActivity=setTargetStackAndMoveToFrontIfNeeded(intentActivity);
    if ((mStartFlags & START_FLAG_ONLY_IF_NEEDED) != 0) {
      resumeTargetStackIfNeeded();
      return START_RETURN_INTENT_TO_CALLER;
    }
    setTaskFromIntentActivity(intentActivity);
    if (!mAddingToTask && mReuseTask == null) {
      resumeTargetStackIfNeeded();
      return START_TASK_TO_FRONT;
    }
  }
  if (mStartActivity.packageName == null) {
    if (mStartActivity.resultTo != null && mStartActivity.resultTo.task.stack != null) {
      mStartActivity.resultTo.task.stack.sendActivityResultLocked(-1,mStartActivity.resultTo,mStartActivity.resultWho,mStartActivity.requestCode,RESULT_CANCELED,null);
    }
    ActivityOptions.abort(mOptions);
    return START_CLASS_NOT_FOUND;
  }
  final ActivityStack topStack=mSupervisor.mFocusedStack;
  final ActivityRecord top=topStack.topRunningNonDelayedActivityLocked(mNotTop);
  final boolean dontStart=top != null && mStartActivity.resultTo == null && top.realActivity.equals(mStartActivity.realActivity) && top.userId == mStartActivity.userId && top.app != null && top.app.thread != null && ((mLaunchFlags & FLAG_ACTIVITY_SINGLE_TOP) != 0 || mLaunchSingleTop || mLaunchSingleTask);
  if (dontStart) {
    ActivityStack.logStartActivity(AM_NEW_INTENT,top,top.task);
    topStack.mLastPausedActivity=null;
    if (mDoResume) {
      mSupervisor.resumeFocusedStackTopActivityLocked();
    }
    ActivityOptions.abort(mOptions);
    if ((mStartFlags & START_FLAG_ONLY_IF_NEEDED) != 0) {
      return START_RETURN_INTENT_TO_CALLER;
    }
    top.deliverNewIntentLocked(mCallingUid,mStartActivity.intent,mStartActivity.launchedFromPackage);
    return START_DELIVERED_TO_TOP;
  }
  boolean newTask=false;
  final TaskRecord taskToAffiliate=(mLaunchTaskBehind && mSourceRecord != null) ? mSourceRecord.task : null;
  if (mStartActivity.resultTo == null && mInTask == null && !mAddingToTask && (mLaunchFlags & FLAG_ACTIVITY_NEW_TASK) != 0) {
    newTask=true;
    setTaskFromReuseOrCreateNewTask(taskToAffiliate);
    if (mSupervisor.isLockTaskModeViolation(mStartActivity.task)) {
      Slog.e(TAG,""String_Node_Str"" + mStartActivity);
      return START_RETURN_LOCK_TASK_MODE_VIOLATION;
    }
    if (!mMovedHome) {
      updateTaskReturnToType(mStartActivity.task,mLaunchFlags,topStack);
    }
  }
 else   if (mSourceRecord != null) {
    if (mSupervisor.isLockTaskModeViolation(mSourceRecord.task)) {
      Slog.e(TAG,""String_Node_Str"" + mStartActivity);
      return START_RETURN_LOCK_TASK_MODE_VIOLATION;
    }
    final int result=setTaskFromSourceRecord();
    if (result != START_SUCCESS) {
      return result;
    }
  }
 else   if (mInTask != null) {
    if (mSupervisor.isLockTaskModeViolation(mInTask)) {
      Slog.e(TAG,""String_Node_Str"" + mStartActivity);
      return START_RETURN_LOCK_TASK_MODE_VIOLATION;
    }
    final int result=setTaskFromInTask();
    if (result != START_SUCCESS) {
      return result;
    }
  }
 else {
    setTaskToCurrentTopOrCreateNewTask();
  }
  mService.grantUriPermissionFromIntentLocked(mCallingUid,mStartActivity.packageName,mIntent,mStartActivity.getUriPermissionsLocked(),mStartActivity.userId);
  if (mSourceRecord != null && mSourceRecord.isRecentsActivity()) {
    mStartActivity.task.setTaskToReturnTo(RECENTS_ACTIVITY_TYPE);
  }
  if (newTask) {
    EventLog.writeEvent(EventLogTags.AM_CREATE_TASK,mStartActivity.userId,mStartActivity.task.taskId);
  }
  ActivityStack.logStartActivity(EventLogTags.AM_CREATE_ACTIVITY,mStartActivity,mStartActivity.task);
  mTargetStack.mLastPausedActivity=null;
  mTargetStack.startActivityLocked(mStartActivity,newTask,mKeepCurTransition,mOptions);
  if (mDoResume) {
    if (!mLaunchTaskBehind) {
      mService.setFocusedActivityLocked(mStartActivity,""String_Node_Str"");
    }
    if (mTargetStack.isFocusable()) {
      mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack,mStartActivity,mOptions);
    }
 else {
      mTargetStack.ensureActivitiesVisibleLocked(null,0,!PRESERVE_WINDOWS);
      mWindowManager.executeAppTransition();
    }
  }
 else {
    mTargetStack.addRecentActivityLocked(mStartActivity);
  }
  mSupervisor.updateUserStackLocked(mStartActivity.userId,mTargetStack);
  final int preferredLaunchStackId=(mOptions != null) ? mOptions.getLaunchStackId() : INVALID_STACK_ID;
  mSupervisor.showNonResizeableDockToastIfNeeded(mStartActivity.task,preferredLaunchStackId,mTargetStack.mStackId);
  return START_SUCCESS;
}",0.9962528103922058
192641,"/** 
 * Draw the tick marks.
 */
void drawTickMarks(Canvas canvas){
  if (mTickMark != null) {
    final int count=getMax();
    if (count > 1) {
      final int w=mTickMark.getIntrinsicWidth();
      final int h=mTickMark.getIntrinsicHeight();
      final int halfW=w >= 0 ? w / 2 : 1;
      final int halfH=h >= 0 ? h / 2 : 1;
      mTickMark.setBounds(-halfW,-halfH,halfW,halfH);
      final int spacing=(getWidth() - mPaddingLeft - mPaddingRight) / count;
      final int saveCount=canvas.save();
      canvas.translate(mPaddingLeft,getHeight() / 2);
      for (int i=0; i <= count; i++) {
        mTickMark.draw(canvas);
        canvas.translate(spacing,0);
      }
      canvas.restoreToCount(saveCount);
    }
  }
}","/** 
 * Draw the tick marks.
 */
void drawTickMarks(Canvas canvas){
  if (mTickMark != null) {
    final int count=getMax();
    if (count > 1) {
      final int w=mTickMark.getIntrinsicWidth();
      final int h=mTickMark.getIntrinsicHeight();
      final int halfW=w >= 0 ? w / 2 : 1;
      final int halfH=h >= 0 ? h / 2 : 1;
      mTickMark.setBounds(-halfW,-halfH,halfW,halfH);
      final float spacing=(getWidth() - mPaddingLeft - mPaddingRight) / (float)count;
      final int saveCount=canvas.save();
      canvas.translate(mPaddingLeft,getHeight() / 2);
      for (int i=0; i <= count; i++) {
        mTickMark.draw(canvas);
        canvas.translate(spacing,0);
      }
      canvas.restoreToCount(saveCount);
    }
  }
}",0.9910529938059188
192642,"/** 
 * Draw the tick marks.
 */
void drawTickMarks(Canvas canvas){
  if (mTickMark != null) {
    final int count=getMax();
    if (count > 1) {
      final int w=mTickMark.getIntrinsicWidth();
      final int h=mTickMark.getIntrinsicHeight();
      final int halfW=w >= 0 ? w / 2 : 1;
      final int halfH=h >= 0 ? h / 2 : 1;
      mTickMark.setBounds(-halfW,-halfH,halfW,halfH);
      final int spacing=(getWidth() - mPaddingLeft - mPaddingRight) / count;
      final int saveCount=canvas.save();
      canvas.translate(mPaddingLeft,getHeight() / 2);
      for (int i=0; i <= count; i++) {
        mTickMark.draw(canvas);
        canvas.translate(spacing,0);
      }
      canvas.restoreToCount(saveCount);
    }
  }
}","/** 
 * Draw the tick marks.
 */
void drawTickMarks(Canvas canvas){
  if (mTickMark != null) {
    final int count=getMax();
    if (count > 1) {
      final int w=mTickMark.getIntrinsicWidth();
      final int h=mTickMark.getIntrinsicHeight();
      final int halfW=w >= 0 ? w / 2 : 1;
      final int halfH=h >= 0 ? h / 2 : 1;
      mTickMark.setBounds(-halfW,-halfH,halfW,halfH);
      final float spacing=(getWidth() - mPaddingLeft - mPaddingRight) / (float)count;
      final int saveCount=canvas.save();
      canvas.translate(mPaddingLeft,getHeight() / 2);
      for (int i=0; i <= count; i++) {
        mTickMark.draw(canvas);
        canvas.translate(spacing,0);
      }
      canvas.restoreToCount(saveCount);
    }
  }
}",0.9910529938059188
192643,"void updateDisplayInfo(Rect bounds){
  mUpdateBoundsAfterRotation=false;
  if (mDisplayContent != null) {
    for (int taskNdx=mTasks.size() - 1; taskNdx >= 0; --taskNdx) {
      mTasks.get(taskNdx).updateDisplayInfo(mDisplayContent);
    }
    if (bounds != null) {
      setBounds(bounds);
    }
 else     if (mFullscreen) {
      setBounds(null);
    }
 else {
      mUpdateBoundsAfterRotation=true;
      mTmpRect2.set(mBounds);
      final int newRotation=mDisplayContent.getDisplayInfo().rotation;
      if (mRotation == newRotation) {
        setBounds(mTmpRect2);
      }
    }
  }
}","void updateDisplayInfo(Rect bounds){
  if (mDisplayContent == null) {
    return;
  }
  for (int taskNdx=mTasks.size() - 1; taskNdx >= 0; --taskNdx) {
    mTasks.get(taskNdx).updateDisplayInfo(mDisplayContent);
  }
  if (bounds != null) {
    setBounds(bounds);
    return;
  }
 else   if (mFullscreen) {
    setBounds(null);
    return;
  }
  mTmpRect2.set(mBounds);
  final int newRotation=mDisplayContent.getDisplayInfo().rotation;
  if (mRotation == newRotation) {
    setBounds(mTmpRect2);
  }
 else {
    mLastUpdateDisplayInfoRotation=newRotation;
    updateBoundsAfterRotation();
  }
}",0.7415540540540541
192644,"/** 
 * Updates the bounds after rotating the screen. We can't handle it in  {@link #updateDisplayInfo} because at that point the configuration might not be fully updatedyet.
 */
void updateBoundsAfterRotation(){
  if (!mUpdateBoundsAfterRotation) {
    return;
  }
  mUpdateBoundsAfterRotation=false;
  final int newRotation=getDisplayInfo().rotation;
  mDisplayContent.rotateBounds(mRotation,newRotation,mTmpRect2);
  if (mStackId == DOCKED_STACK_ID) {
    snapDockedStackAfterRotation(mTmpRect2);
  }
  mService.mH.sendMessage(mService.mH.obtainMessage(RESIZE_STACK,mStackId,0,mTmpRect2));
}","void updateBoundsAfterRotation(){
  if (mLastConfigChangedRotation != mLastUpdateDisplayInfoRotation) {
    return;
  }
  final int newRotation=getDisplayInfo().rotation;
  if (mRotation == newRotation) {
    return;
  }
  mDisplayContent.rotateBounds(mRotation,newRotation,mTmpRect2);
  if (mStackId == DOCKED_STACK_ID) {
    snapDockedStackAfterRotation(mTmpRect2);
  }
  mService.mH.obtainMessage(RESIZE_STACK,mStackId,0,mTmpRect2).sendToTarget();
}",0.4416826003824092
192645,"@Override public void setNewConfiguration(Configuration config){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mWindowMap) {
    final boolean orientationChanged=mCurConfiguration.orientation != config.orientation;
    mCurConfiguration=new Configuration(config);
    if (mWaitingForConfig) {
      mWaitingForConfig=false;
      mLastFinishedFreezeSource=""String_Node_Str"";
    }
    if (orientationChanged) {
      updateTaskStackBoundsAfterRotation();
    }
    mWindowPlacerLocked.performSurfacePlacement();
  }
}","@Override public void setNewConfiguration(Configuration config){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mWindowMap) {
    mCurConfiguration=new Configuration(config);
    if (mWaitingForConfig) {
      mWaitingForConfig=false;
      mLastFinishedFreezeSource=""String_Node_Str"";
    }
    onConfigurationChanged();
    mWindowPlacerLocked.performSurfacePlacement();
  }
}",0.546572934973638
192646,"void updateDisplayInfo(Rect bounds){
  mUpdateBoundsAfterRotation=false;
  if (mDisplayContent != null) {
    for (int taskNdx=mTasks.size() - 1; taskNdx >= 0; --taskNdx) {
      mTasks.get(taskNdx).updateDisplayInfo(mDisplayContent);
    }
    if (bounds != null) {
      setBounds(bounds);
    }
 else     if (mFullscreen) {
      setBounds(null);
    }
 else {
      mUpdateBoundsAfterRotation=true;
      mTmpRect2.set(mBounds);
      final int newRotation=mDisplayContent.getDisplayInfo().rotation;
      if (mRotation == newRotation) {
        setBounds(mTmpRect2);
      }
    }
  }
}","void updateDisplayInfo(Rect bounds){
  if (mDisplayContent == null) {
    return;
  }
  for (int taskNdx=mTasks.size() - 1; taskNdx >= 0; --taskNdx) {
    mTasks.get(taskNdx).updateDisplayInfo(mDisplayContent);
  }
  if (bounds != null) {
    setBounds(bounds);
    return;
  }
 else   if (mFullscreen) {
    setBounds(null);
    return;
  }
  mTmpRect2.set(mBounds);
  final int newRotation=mDisplayContent.getDisplayInfo().rotation;
  if (mRotation == newRotation) {
    setBounds(mTmpRect2);
  }
 else {
    mLastUpdateDisplayInfoRotation=newRotation;
    updateBoundsAfterRotation();
  }
}",0.7415540540540541
192647,"/** 
 * Updates the bounds after rotating the screen. We can't handle it in  {@link #updateDisplayInfo} because at that point the configuration might not be fully updatedyet.
 */
void updateBoundsAfterRotation(){
  if (!mUpdateBoundsAfterRotation) {
    return;
  }
  mUpdateBoundsAfterRotation=false;
  final int newRotation=getDisplayInfo().rotation;
  mDisplayContent.rotateBounds(mRotation,newRotation,mTmpRect2);
  if (mStackId == DOCKED_STACK_ID) {
    snapDockedStackAfterRotation(mTmpRect2);
  }
  mService.mH.sendMessage(mService.mH.obtainMessage(RESIZE_STACK,mStackId,0,mTmpRect2));
}","void updateBoundsAfterRotation(){
  if (mLastConfigChangedRotation != mLastUpdateDisplayInfoRotation) {
    return;
  }
  final int newRotation=getDisplayInfo().rotation;
  if (mRotation == newRotation) {
    return;
  }
  mDisplayContent.rotateBounds(mRotation,newRotation,mTmpRect2);
  if (mStackId == DOCKED_STACK_ID) {
    snapDockedStackAfterRotation(mTmpRect2);
  }
  mService.mH.obtainMessage(RESIZE_STACK,mStackId,0,mTmpRect2).sendToTarget();
}",0.4416826003824092
192648,"@Override public void setNewConfiguration(Configuration config){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mWindowMap) {
    final boolean orientationChanged=mCurConfiguration.orientation != config.orientation;
    mCurConfiguration=new Configuration(config);
    if (mWaitingForConfig) {
      mWaitingForConfig=false;
      mLastFinishedFreezeSource=""String_Node_Str"";
    }
    if (orientationChanged) {
      updateTaskStackBoundsAfterRotation();
    }
    mWindowPlacerLocked.performSurfacePlacement();
  }
}","@Override public void setNewConfiguration(Configuration config){
  if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,""String_Node_Str"")) {
    throw new SecurityException(""String_Node_Str"");
  }
synchronized (mWindowMap) {
    mCurConfiguration=new Configuration(config);
    if (mWaitingForConfig) {
      mWaitingForConfig=false;
      mLastFinishedFreezeSource=""String_Node_Str"";
    }
    onConfigurationChanged();
    mWindowPlacerLocked.performSurfacePlacement();
  }
}",0.546572934973638
192649,"/** 
 * Stops recognition for the given generic sound model.
 * @param modelId The identifier of the generic sound model for whichthe recognition is to be stopped.
 * @param listener The listener for the recognition events related to the given sound model.
 * @return One of {@link #STATUS_ERROR} or {@link #STATUS_OK}.
 */
int stopGenericRecognition(UUID modelId,IRecognitionStatusCallback listener){
  if (listener == null) {
    return STATUS_ERROR;
  }
synchronized (mLock) {
    ModelData modelData=mGenericModelDataMap.get(modelId);
    if (modelData == null) {
      Slog.w(TAG,""String_Node_Str"" + modelId);
      return STATUS_ERROR;
    }
    IRecognitionStatusCallback currentCallback=modelData.getCallback();
    if (DBG) {
      Slog.d(TAG,""String_Node_Str"" + modelId + ""String_Node_Str""+ listener.asBinder());
      Slog.d(TAG,""String_Node_Str"" + (currentCallback == null ? ""String_Node_Str"" : currentCallback.asBinder()));
    }
    if (mModuleProperties == null || mModule == null) {
      Slog.w(TAG,""String_Node_Str"");
      return STATUS_ERROR;
    }
    if (currentCallback == null || !modelData.modelStarted()) {
      Slog.w(TAG,""String_Node_Str"");
      return STATUS_ERROR;
    }
    if (currentCallback.asBinder() != listener.asBinder()) {
      Slog.w(TAG,""String_Node_Str"");
      return STATUS_ERROR;
    }
    int status=stopGenericRecognitionLocked(modelData,false);
    if (status != SoundTrigger.STATUS_OK) {
      return status;
    }
    modelData.clearState();
    modelData.clearCallback();
    if (!computeRecognitionRunning()) {
      internalClearGlobalStateLocked();
    }
    return status;
  }
}","/** 
 * Stops recognition for the given generic sound model.
 * @param modelId The identifier of the generic sound model for whichthe recognition is to be stopped.
 * @param listener The listener for the recognition events related to the given sound model.
 * @return One of {@link #STATUS_ERROR} or {@link #STATUS_OK}.
 */
int stopGenericRecognition(UUID modelId,IRecognitionStatusCallback listener){
  if (listener == null) {
    return STATUS_ERROR;
  }
synchronized (mLock) {
    ModelData modelData=mGenericModelDataMap.get(modelId);
    if (modelData == null) {
      Slog.w(TAG,""String_Node_Str"" + modelId);
      return STATUS_ERROR;
    }
    IRecognitionStatusCallback currentCallback=modelData.getCallback();
    if (DBG) {
      Slog.d(TAG,""String_Node_Str"" + modelId + ""String_Node_Str""+ listener.asBinder());
      Slog.d(TAG,""String_Node_Str"" + (currentCallback == null ? ""String_Node_Str"" : currentCallback.asBinder()));
    }
    if (mModuleProperties == null || mModule == null) {
      Slog.w(TAG,""String_Node_Str"");
      return STATUS_ERROR;
    }
    if (currentCallback == null || !modelData.isModelStarted()) {
      Slog.w(TAG,""String_Node_Str"");
      return STATUS_ERROR;
    }
    if (currentCallback.asBinder() != listener.asBinder()) {
      Slog.w(TAG,""String_Node_Str"");
      return STATUS_ERROR;
    }
    int status=stopGenericRecognitionLocked(modelData,false);
    if (status != SoundTrigger.STATUS_OK) {
      return status;
    }
    modelData.clearState();
    modelData.clearCallback();
    if (!computeRecognitionRunning()) {
      internalClearGlobalStateLocked();
    }
    return status;
  }
}",0.9987782529016492
192650,"/** 
 * Starts recognition for the given generic sound model ID.
 * @param soundModel The sound model to use for recognition.
 * @param listener The listener for the recognition events related to the given keyphrase.
 * @return One of {@link #STATUS_ERROR} or {@link #STATUS_OK}.
 */
int startGenericRecognition(UUID modelId,GenericSoundModel soundModel,IRecognitionStatusCallback callback,RecognitionConfig recognitionConfig){
  if (soundModel == null || callback == null || recognitionConfig == null) {
    Slog.w(TAG,""String_Node_Str"");
    return STATUS_ERROR;
  }
synchronized (mLock) {
    if (mModuleProperties == null) {
      Slog.w(TAG,""String_Node_Str"");
      return STATUS_ERROR;
    }
    if (mModule == null) {
      mModule=SoundTrigger.attachModule(mModuleProperties.id,this,null);
      if (mModule == null) {
        Slog.w(TAG,""String_Node_Str"");
        return STATUS_ERROR;
      }
    }
    if (!mRecognitionRunning) {
      initializeTelephonyAndPowerStateListeners();
    }
    ModelData modelData=getOrCreateGenericModelData(modelId);
    IRecognitionStatusCallback oldCallback=modelData.getCallback();
    if (oldCallback != null) {
      Slog.w(TAG,""String_Node_Str"" + modelId);
      try {
        oldCallback.onError(STATUS_ERROR);
      }
 catch (      RemoteException e) {
        Slog.w(TAG,""String_Node_Str"",e);
      }
      modelData.clearCallback();
    }
    if (!modelData.isModelLoaded()) {
      int[] handle=new int[]{INVALID_VALUE};
      int status=mModule.loadSoundModel(soundModel,handle);
      if (status != SoundTrigger.STATUS_OK) {
        Slog.w(TAG,""String_Node_Str"" + status);
        return status;
      }
      if (handle[0] == INVALID_VALUE) {
        Slog.w(TAG,""String_Node_Str"");
        return STATUS_ERROR;
      }
      modelData.setHandle(handle[0]);
    }
    modelData.setCallback(callback);
    modelData.setRecognitionConfig(recognitionConfig);
    return startGenericRecognitionLocked(modelData,false);
  }
}","/** 
 * Starts recognition for the given generic sound model ID.
 * @param soundModel The sound model to use for recognition.
 * @param listener The listener for the recognition events related to the given keyphrase.
 * @return One of {@link #STATUS_ERROR} or {@link #STATUS_OK}.
 */
int startGenericRecognition(UUID modelId,GenericSoundModel soundModel,IRecognitionStatusCallback callback,RecognitionConfig recognitionConfig){
  if (soundModel == null || callback == null || recognitionConfig == null) {
    Slog.w(TAG,""String_Node_Str"");
    return STATUS_ERROR;
  }
synchronized (mLock) {
    if (mModuleProperties == null) {
      Slog.w(TAG,""String_Node_Str"");
      return STATUS_ERROR;
    }
    if (mModule == null) {
      mModule=SoundTrigger.attachModule(mModuleProperties.id,this,null);
      if (mModule == null) {
        Slog.w(TAG,""String_Node_Str"");
        return STATUS_ERROR;
      }
    }
    if (!mRecognitionRunning) {
      initializeTelephonyAndPowerStateListeners();
    }
    ModelData modelData=getOrCreateGenericModelData(modelId);
    IRecognitionStatusCallback oldCallback=modelData.getCallback();
    if (oldCallback != null) {
      Slog.w(TAG,""String_Node_Str"" + modelId);
      try {
        oldCallback.onError(STATUS_ERROR);
      }
 catch (      RemoteException e) {
        Slog.w(TAG,""String_Node_Str"",e);
      }
      modelData.clearCallback();
    }
    if (!modelData.isModelLoaded()) {
      int[] handle=new int[]{INVALID_VALUE};
      int status=mModule.loadSoundModel(soundModel,handle);
      if (status != SoundTrigger.STATUS_OK) {
        Slog.w(TAG,""String_Node_Str"" + status);
        return status;
      }
      if (handle[0] == INVALID_VALUE) {
        Slog.w(TAG,""String_Node_Str"");
        return STATUS_ERROR;
      }
      modelData.setHandle(handle[0]);
      modelData.setLoaded();
    }
    modelData.setCallback(callback);
    modelData.setRecognitionConfig(recognitionConfig);
    return startGenericRecognitionLocked(modelData,false);
  }
}",0.9927190559879489
192651,"/** 
 * Stops all recognitions active currently and clears the internal state.
 */
void stopAllRecognitions(){
synchronized (mLock) {
    if (mModuleProperties == null || mModule == null) {
      return;
    }
    if (mCurrentKeyphraseModelHandle != INVALID_VALUE) {
      mRequested=false;
      int status=updateRecognitionLocked(false);
      internalClearKeyphraseStateLocked();
    }
    for (    ModelData model : mGenericModelDataMap.values()) {
      if (model.modelStarted()) {
        int status=stopGenericRecognitionLocked(model,false);
        if (status != STATUS_OK) {
          Slog.w(TAG,""String_Node_Str"" + model.getHandle());
        }
        model.clearState();
        model.clearCallback();
      }
    }
    internalClearGlobalStateLocked();
  }
}","/** 
 * Stops all recognitions active currently and clears the internal state.
 */
void stopAllRecognitions(){
synchronized (mLock) {
    if (mModuleProperties == null || mModule == null) {
      return;
    }
    if (mCurrentKeyphraseModelHandle != INVALID_VALUE) {
      mRequested=false;
      int status=updateRecognitionLocked(false);
      internalClearKeyphraseStateLocked();
    }
    for (    ModelData model : mGenericModelDataMap.values()) {
      if (model.isModelStarted()) {
        int status=stopGenericRecognitionLocked(model,false);
        if (status != STATUS_OK) {
          Slog.w(TAG,""String_Node_Str"" + model.getHandle());
        }
        model.clearState();
        model.clearCallback();
      }
    }
    internalClearGlobalStateLocked();
  }
}",0.9974093264248703
192652,"synchronized boolean isModelLoaded(){
  return (mModelState == MODEL_LOADED || mModelState == MODEL_STARTED) && mSoundModel != null;
}","synchronized boolean isModelLoaded(){
  return (mModelState == MODEL_LOADED || mModelState == MODEL_STARTED);
}",0.9061224489795918
192653,"private boolean computeRecognitionRunning(){
synchronized (mLock) {
    if (mModuleProperties == null || mModule == null) {
      mRecognitionRunning=false;
      return mRecognitionRunning;
    }
    if (mKeyphraseListener != null && mKeyphraseStarted && mCurrentKeyphraseModelHandle != INVALID_VALUE && mCurrentSoundModel != null) {
      mRecognitionRunning=true;
      return mRecognitionRunning;
    }
    for (    UUID modelId : mGenericModelDataMap.keySet()) {
      ModelData modelData=mGenericModelDataMap.get(modelId);
      if (modelData.modelStarted()) {
        mRecognitionRunning=true;
        return mRecognitionRunning;
      }
    }
    mRecognitionRunning=false;
  }
  return mRecognitionRunning;
}","private boolean computeRecognitionRunning(){
synchronized (mLock) {
    if (mModuleProperties == null || mModule == null) {
      mRecognitionRunning=false;
      return mRecognitionRunning;
    }
    if (mKeyphraseListener != null && mKeyphraseStarted && mCurrentKeyphraseModelHandle != INVALID_VALUE && mCurrentSoundModel != null) {
      mRecognitionRunning=true;
      return mRecognitionRunning;
    }
    for (    UUID modelId : mGenericModelDataMap.keySet()) {
      ModelData modelData=mGenericModelDataMap.get(modelId);
      if (modelData.isModelStarted()) {
        mRecognitionRunning=true;
        return mRecognitionRunning;
      }
    }
    mRecognitionRunning=false;
  }
  return mRecognitionRunning;
}",0.9972144846796658
192654,"synchronized void clearState(){
  mModelState=MODEL_NOTLOADED;
  mSoundModel=null;
  mModelHandle=INVALID_VALUE;
}","synchronized void clearState(){
  mModelState=MODEL_NOTLOADED;
  mModelHandle=INVALID_VALUE;
}",0.903846153846154
192655,"@Override protected boolean disallowSingleClick(MotionEvent event){
  float x=event.getX();
  float y=event.getY();
  NotificationHeaderView header=getNotificationHeader();
  if (header != null) {
    return header.isInTouchRect(x,y);
  }
  return super.disallowSingleClick(event);
}","@Override protected boolean disallowSingleClick(MotionEvent event){
  float x=event.getX();
  float y=event.getY();
  NotificationHeaderView header=getVisibleNotificationHeader();
  if (header != null) {
    return header.isInTouchRect(x,y);
  }
  return super.disallowSingleClick(event);
}",0.987783595113438
192656,"/** 
 * Stops recognition for the given generic sound model.
 * @param modelId The identifier of the generic sound model for whichthe recognition is to be stopped.
 * @param listener The listener for the recognition events related to the given sound model.
 * @return One of {@link #STATUS_ERROR} or {@link #STATUS_OK}.
 */
int stopGenericRecognition(UUID modelId,IRecognitionStatusCallback listener){
  if (listener == null) {
    return STATUS_ERROR;
  }
synchronized (mLock) {
    ModelData modelData=mGenericModelDataMap.get(modelId);
    if (modelData == null) {
      Slog.w(TAG,""String_Node_Str"" + modelId);
      return STATUS_ERROR;
    }
    IRecognitionStatusCallback currentCallback=modelData.getCallback();
    if (DBG) {
      Slog.d(TAG,""String_Node_Str"" + modelId + ""String_Node_Str""+ listener.asBinder());
      Slog.d(TAG,""String_Node_Str"" + (currentCallback == null ? ""String_Node_Str"" : currentCallback.asBinder()));
    }
    if (mModuleProperties == null || mModule == null) {
      Slog.w(TAG,""String_Node_Str"");
      return STATUS_ERROR;
    }
    if (currentCallback == null || !modelData.modelStarted()) {
      Slog.w(TAG,""String_Node_Str"");
      return STATUS_ERROR;
    }
    if (currentCallback.asBinder() != listener.asBinder()) {
      Slog.w(TAG,""String_Node_Str"");
      return STATUS_ERROR;
    }
    int status=stopGenericRecognitionLocked(modelData,false);
    if (status != SoundTrigger.STATUS_OK) {
      return status;
    }
    modelData.clearState();
    modelData.clearCallback();
    if (!computeRecognitionRunning()) {
      internalClearGlobalStateLocked();
    }
    return status;
  }
}","/** 
 * Stops recognition for the given generic sound model.
 * @param modelId The identifier of the generic sound model for whichthe recognition is to be stopped.
 * @param listener The listener for the recognition events related to the given sound model.
 * @return One of {@link #STATUS_ERROR} or {@link #STATUS_OK}.
 */
int stopGenericRecognition(UUID modelId,IRecognitionStatusCallback listener){
  if (listener == null) {
    return STATUS_ERROR;
  }
synchronized (mLock) {
    ModelData modelData=mGenericModelDataMap.get(modelId);
    if (modelData == null) {
      Slog.w(TAG,""String_Node_Str"" + modelId);
      return STATUS_ERROR;
    }
    IRecognitionStatusCallback currentCallback=modelData.getCallback();
    if (DBG) {
      Slog.d(TAG,""String_Node_Str"" + modelId + ""String_Node_Str""+ listener.asBinder());
      Slog.d(TAG,""String_Node_Str"" + (currentCallback == null ? ""String_Node_Str"" : currentCallback.asBinder()));
    }
    if (mModuleProperties == null || mModule == null) {
      Slog.w(TAG,""String_Node_Str"");
      return STATUS_ERROR;
    }
    if (currentCallback == null || !modelData.isModelStarted()) {
      Slog.w(TAG,""String_Node_Str"");
      return STATUS_ERROR;
    }
    if (currentCallback.asBinder() != listener.asBinder()) {
      Slog.w(TAG,""String_Node_Str"");
      return STATUS_ERROR;
    }
    int status=stopGenericRecognitionLocked(modelData,false);
    if (status != SoundTrigger.STATUS_OK) {
      return status;
    }
    modelData.clearState();
    modelData.clearCallback();
    if (!computeRecognitionRunning()) {
      internalClearGlobalStateLocked();
    }
    return status;
  }
}",0.9987782529016492
192657,"/** 
 * Starts recognition for the given generic sound model ID.
 * @param soundModel The sound model to use for recognition.
 * @param listener The listener for the recognition events related to the given keyphrase.
 * @return One of {@link #STATUS_ERROR} or {@link #STATUS_OK}.
 */
int startGenericRecognition(UUID modelId,GenericSoundModel soundModel,IRecognitionStatusCallback callback,RecognitionConfig recognitionConfig){
  if (soundModel == null || callback == null || recognitionConfig == null) {
    Slog.w(TAG,""String_Node_Str"");
    return STATUS_ERROR;
  }
synchronized (mLock) {
    if (mModuleProperties == null) {
      Slog.w(TAG,""String_Node_Str"");
      return STATUS_ERROR;
    }
    if (mModule == null) {
      mModule=SoundTrigger.attachModule(mModuleProperties.id,this,null);
      if (mModule == null) {
        Slog.w(TAG,""String_Node_Str"");
        return STATUS_ERROR;
      }
    }
    if (!mRecognitionRunning) {
      initializeTelephonyAndPowerStateListeners();
    }
    ModelData modelData=getOrCreateGenericModelData(modelId);
    IRecognitionStatusCallback oldCallback=modelData.getCallback();
    if (oldCallback != null) {
      Slog.w(TAG,""String_Node_Str"" + modelId);
      try {
        oldCallback.onError(STATUS_ERROR);
      }
 catch (      RemoteException e) {
        Slog.w(TAG,""String_Node_Str"",e);
      }
      modelData.clearCallback();
    }
    if (!modelData.isModelLoaded()) {
      int[] handle=new int[]{INVALID_VALUE};
      int status=mModule.loadSoundModel(soundModel,handle);
      if (status != SoundTrigger.STATUS_OK) {
        Slog.w(TAG,""String_Node_Str"" + status);
        return status;
      }
      if (handle[0] == INVALID_VALUE) {
        Slog.w(TAG,""String_Node_Str"");
        return STATUS_ERROR;
      }
      modelData.setHandle(handle[0]);
    }
    modelData.setCallback(callback);
    modelData.setRecognitionConfig(recognitionConfig);
    return startGenericRecognitionLocked(modelData,false);
  }
}","/** 
 * Starts recognition for the given generic sound model ID.
 * @param soundModel The sound model to use for recognition.
 * @param listener The listener for the recognition events related to the given keyphrase.
 * @return One of {@link #STATUS_ERROR} or {@link #STATUS_OK}.
 */
int startGenericRecognition(UUID modelId,GenericSoundModel soundModel,IRecognitionStatusCallback callback,RecognitionConfig recognitionConfig){
  if (soundModel == null || callback == null || recognitionConfig == null) {
    Slog.w(TAG,""String_Node_Str"");
    return STATUS_ERROR;
  }
synchronized (mLock) {
    if (mModuleProperties == null) {
      Slog.w(TAG,""String_Node_Str"");
      return STATUS_ERROR;
    }
    if (mModule == null) {
      mModule=SoundTrigger.attachModule(mModuleProperties.id,this,null);
      if (mModule == null) {
        Slog.w(TAG,""String_Node_Str"");
        return STATUS_ERROR;
      }
    }
    if (!mRecognitionRunning) {
      initializeTelephonyAndPowerStateListeners();
    }
    ModelData modelData=getOrCreateGenericModelData(modelId);
    IRecognitionStatusCallback oldCallback=modelData.getCallback();
    if (oldCallback != null) {
      Slog.w(TAG,""String_Node_Str"" + modelId);
      try {
        oldCallback.onError(STATUS_ERROR);
      }
 catch (      RemoteException e) {
        Slog.w(TAG,""String_Node_Str"",e);
      }
      modelData.clearCallback();
    }
    if (!modelData.isModelLoaded()) {
      int[] handle=new int[]{INVALID_VALUE};
      int status=mModule.loadSoundModel(soundModel,handle);
      if (status != SoundTrigger.STATUS_OK) {
        Slog.w(TAG,""String_Node_Str"" + status);
        return status;
      }
      if (handle[0] == INVALID_VALUE) {
        Slog.w(TAG,""String_Node_Str"");
        return STATUS_ERROR;
      }
      modelData.setHandle(handle[0]);
      modelData.setLoaded();
    }
    modelData.setCallback(callback);
    modelData.setRecognitionConfig(recognitionConfig);
    return startGenericRecognitionLocked(modelData,false);
  }
}",0.9927190559879489
192658,"/** 
 * Stops all recognitions active currently and clears the internal state.
 */
void stopAllRecognitions(){
synchronized (mLock) {
    if (mModuleProperties == null || mModule == null) {
      return;
    }
    if (mCurrentKeyphraseModelHandle != INVALID_VALUE) {
      mRequested=false;
      int status=updateRecognitionLocked(false);
      internalClearKeyphraseStateLocked();
    }
    for (    ModelData model : mGenericModelDataMap.values()) {
      if (model.modelStarted()) {
        int status=stopGenericRecognitionLocked(model,false);
        if (status != STATUS_OK) {
          Slog.w(TAG,""String_Node_Str"" + model.getHandle());
        }
        model.clearState();
        model.clearCallback();
      }
    }
    internalClearGlobalStateLocked();
  }
}","/** 
 * Stops all recognitions active currently and clears the internal state.
 */
void stopAllRecognitions(){
synchronized (mLock) {
    if (mModuleProperties == null || mModule == null) {
      return;
    }
    if (mCurrentKeyphraseModelHandle != INVALID_VALUE) {
      mRequested=false;
      int status=updateRecognitionLocked(false);
      internalClearKeyphraseStateLocked();
    }
    for (    ModelData model : mGenericModelDataMap.values()) {
      if (model.isModelStarted()) {
        int status=stopGenericRecognitionLocked(model,false);
        if (status != STATUS_OK) {
          Slog.w(TAG,""String_Node_Str"" + model.getHandle());
        }
        model.clearState();
        model.clearCallback();
      }
    }
    internalClearGlobalStateLocked();
  }
}",0.9974093264248703
192659,"synchronized boolean isModelLoaded(){
  return (mModelState == MODEL_LOADED || mModelState == MODEL_STARTED) && mSoundModel != null;
}","synchronized boolean isModelLoaded(){
  return (mModelState == MODEL_LOADED || mModelState == MODEL_STARTED);
}",0.9061224489795918
192660,"private boolean computeRecognitionRunning(){
synchronized (mLock) {
    if (mModuleProperties == null || mModule == null) {
      mRecognitionRunning=false;
      return mRecognitionRunning;
    }
    if (mKeyphraseListener != null && mKeyphraseStarted && mCurrentKeyphraseModelHandle != INVALID_VALUE && mCurrentSoundModel != null) {
      mRecognitionRunning=true;
      return mRecognitionRunning;
    }
    for (    UUID modelId : mGenericModelDataMap.keySet()) {
      ModelData modelData=mGenericModelDataMap.get(modelId);
      if (modelData.modelStarted()) {
        mRecognitionRunning=true;
        return mRecognitionRunning;
      }
    }
    mRecognitionRunning=false;
  }
  return mRecognitionRunning;
}","private boolean computeRecognitionRunning(){
synchronized (mLock) {
    if (mModuleProperties == null || mModule == null) {
      mRecognitionRunning=false;
      return mRecognitionRunning;
    }
    if (mKeyphraseListener != null && mKeyphraseStarted && mCurrentKeyphraseModelHandle != INVALID_VALUE && mCurrentSoundModel != null) {
      mRecognitionRunning=true;
      return mRecognitionRunning;
    }
    for (    UUID modelId : mGenericModelDataMap.keySet()) {
      ModelData modelData=mGenericModelDataMap.get(modelId);
      if (modelData.isModelStarted()) {
        mRecognitionRunning=true;
        return mRecognitionRunning;
      }
    }
    mRecognitionRunning=false;
  }
  return mRecognitionRunning;
}",0.9972144846796658
192661,"synchronized void clearState(){
  mModelState=MODEL_NOTLOADED;
  mSoundModel=null;
  mModelHandle=INVALID_VALUE;
}","synchronized void clearState(){
  mModelState=MODEL_NOTLOADED;
  mModelHandle=INVALID_VALUE;
}",0.903846153846154
192662,"@Override protected boolean disallowSingleClick(MotionEvent event){
  float x=event.getX();
  float y=event.getY();
  NotificationHeaderView header=getNotificationHeader();
  if (header != null) {
    return header.isInTouchRect(x,y);
  }
  return super.disallowSingleClick(event);
}","@Override protected boolean disallowSingleClick(MotionEvent event){
  float x=event.getX();
  float y=event.getY();
  NotificationHeaderView header=getVisibleNotificationHeader();
  if (header != null) {
    return header.isInTouchRect(x,y);
  }
  return super.disallowSingleClick(event);
}",0.987783595113438
192663,"/** 
 * We didn't use to persist user restrictions for each owners but only persisted in user manager.
 */
private void migrateUserRestrictionsIfNecessaryLocked(){
  boolean migrated=false;
  if (mOwners.getDeviceOwnerUserRestrictionsNeedsMigration()) {
    if (VERBOSE_LOG) {
      Log.v(LOG_TAG,""String_Node_Str"");
    }
    migrated=true;
    final ActiveAdmin deviceOwnerAdmin=getDeviceOwnerAdminLocked();
    migrateUserRestrictionsForUser(UserHandle.SYSTEM,deviceOwnerAdmin,null);
    pushUserRestrictions(UserHandle.USER_SYSTEM);
    mOwners.setDeviceOwnerUserRestrictionsMigrated();
  }
  final Set<String> normalExceptionList=Sets.newArraySet(UserManager.DISALLOW_OUTGOING_CALLS,UserManager.DISALLOW_SMS);
  final Set<String> managedExceptionList=new ArraySet<>(normalExceptionList.size() + 1);
  managedExceptionList.addAll(normalExceptionList);
  managedExceptionList.add(UserManager.DISALLOW_WALLPAPER);
  for (  UserInfo ui : mUserManager.getUsers()) {
    final int userId=ui.id;
    if (mOwners.getProfileOwnerUserRestrictionsNeedsMigration(userId)) {
      if (userId != UserHandle.USER_SYSTEM) {
        if (VERBOSE_LOG) {
          Log.v(LOG_TAG,""String_Node_Str"" + userId);
        }
        migrated=true;
        final ActiveAdmin profileOwnerAdmin=getProfileOwnerAdminLocked(userId);
        final Set<String> exceptionList=ui.isManagedProfile() ? managedExceptionList : normalExceptionList;
        migrateUserRestrictionsForUser(ui.getUserHandle(),profileOwnerAdmin,exceptionList);
        pushUserRestrictions(userId);
      }
      mOwners.setProfileOwnerUserRestrictionsMigrated(userId);
    }
  }
  if (VERBOSE_LOG && migrated) {
    Log.v(LOG_TAG,""String_Node_Str"");
  }
}","/** 
 * We didn't use to persist user restrictions for each owners but only persisted in user manager.
 */
private void migrateUserRestrictionsIfNecessaryLocked(){
  boolean migrated=false;
  if (mOwners.getDeviceOwnerUserRestrictionsNeedsMigration()) {
    if (VERBOSE_LOG) {
      Log.v(LOG_TAG,""String_Node_Str"");
    }
    migrated=true;
    final ActiveAdmin deviceOwnerAdmin=getDeviceOwnerAdminLocked();
    migrateUserRestrictionsForUser(UserHandle.SYSTEM,deviceOwnerAdmin,null,true);
    pushUserRestrictions(UserHandle.USER_SYSTEM);
    mOwners.setDeviceOwnerUserRestrictionsMigrated();
  }
  final Set<String> secondaryUserExceptionList=Sets.newArraySet(UserManager.DISALLOW_OUTGOING_CALLS,UserManager.DISALLOW_SMS);
  for (  UserInfo ui : mUserManager.getUsers()) {
    final int userId=ui.id;
    if (mOwners.getProfileOwnerUserRestrictionsNeedsMigration(userId)) {
      if (VERBOSE_LOG) {
        Log.v(LOG_TAG,""String_Node_Str"" + userId);
      }
      migrated=true;
      final ActiveAdmin profileOwnerAdmin=getProfileOwnerAdminLocked(userId);
      final Set<String> exceptionList=(userId == UserHandle.USER_SYSTEM) ? null : secondaryUserExceptionList;
      migrateUserRestrictionsForUser(ui.getUserHandle(),profileOwnerAdmin,exceptionList,false);
      pushUserRestrictions(userId);
      mOwners.setProfileOwnerUserRestrictionsMigrated(userId);
    }
  }
  if (VERBOSE_LOG && migrated) {
    Log.v(LOG_TAG,""String_Node_Str"");
  }
}",0.7808436409768474
192664,"private void migrateUserRestrictionsForUser(UserHandle user,ActiveAdmin admin,Set<String> exceptionList){
  final Bundle origRestrictions=mUserManagerInternal.getBaseUserRestrictions(user.getIdentifier());
  final Bundle newBaseRestrictions=new Bundle();
  final Bundle newOwnerRestrictions=new Bundle();
  for (  String key : origRestrictions.keySet()) {
    if (!origRestrictions.getBoolean(key)) {
      continue;
    }
    if (exceptionList != null && exceptionList.contains(key)) {
      newBaseRestrictions.putBoolean(key,true);
    }
 else {
      newOwnerRestrictions.putBoolean(key,true);
    }
  }
  if (VERBOSE_LOG) {
    Log.v(LOG_TAG,""String_Node_Str"" + origRestrictions);
    Log.v(LOG_TAG,""String_Node_Str"" + newBaseRestrictions);
    Log.v(LOG_TAG,""String_Node_Str"" + newOwnerRestrictions);
  }
  mUserManagerInternal.setBaseUserRestrictionsByDpmsForMigration(user.getIdentifier(),newBaseRestrictions);
  if (admin != null) {
    admin.ensureUserRestrictions().clear();
    admin.ensureUserRestrictions().putAll(newOwnerRestrictions);
  }
 else {
    Slog.w(LOG_TAG,""String_Node_Str"" + user.getIdentifier());
  }
  saveSettingsLocked(user.getIdentifier());
}","private void migrateUserRestrictionsForUser(UserHandle user,ActiveAdmin admin,Set<String> exceptionList,boolean isDeviceOwner){
  final Bundle origRestrictions=mUserManagerInternal.getBaseUserRestrictions(user.getIdentifier());
  final Bundle newBaseRestrictions=new Bundle();
  final Bundle newOwnerRestrictions=new Bundle();
  for (  String key : origRestrictions.keySet()) {
    if (!origRestrictions.getBoolean(key)) {
      continue;
    }
    final boolean canOwnerChange=isDeviceOwner ? UserRestrictionsUtils.canDeviceOwnerChange(key) : UserRestrictionsUtils.canProfileOwnerChange(key,user.getIdentifier());
    if (!canOwnerChange || (exceptionList != null && exceptionList.contains(key))) {
      newBaseRestrictions.putBoolean(key,true);
    }
 else {
      newOwnerRestrictions.putBoolean(key,true);
    }
  }
  if (VERBOSE_LOG) {
    Log.v(LOG_TAG,""String_Node_Str"" + origRestrictions);
    Log.v(LOG_TAG,""String_Node_Str"" + newBaseRestrictions);
    Log.v(LOG_TAG,""String_Node_Str"" + newOwnerRestrictions);
  }
  mUserManagerInternal.setBaseUserRestrictionsByDpmsForMigration(user.getIdentifier(),newBaseRestrictions);
  if (admin != null) {
    admin.ensureUserRestrictions().clear();
    admin.ensureUserRestrictions().putAll(newOwnerRestrictions);
  }
 else {
    Slog.w(LOG_TAG,""String_Node_Str"" + user.getIdentifier());
  }
  saveSettingsLocked(user.getIdentifier());
}",0.915267473643108
192665,"/** 
 * We didn't use to persist user restrictions for each owners but only persisted in user manager.
 */
private void migrateUserRestrictionsIfNecessaryLocked(){
  boolean migrated=false;
  if (mOwners.getDeviceOwnerUserRestrictionsNeedsMigration()) {
    if (VERBOSE_LOG) {
      Log.v(LOG_TAG,""String_Node_Str"");
    }
    migrated=true;
    final ActiveAdmin deviceOwnerAdmin=getDeviceOwnerAdminLocked();
    migrateUserRestrictionsForUser(UserHandle.SYSTEM,deviceOwnerAdmin,null);
    pushUserRestrictions(UserHandle.USER_SYSTEM);
    mOwners.setDeviceOwnerUserRestrictionsMigrated();
  }
  final Set<String> normalExceptionList=Sets.newArraySet(UserManager.DISALLOW_OUTGOING_CALLS,UserManager.DISALLOW_SMS);
  final Set<String> managedExceptionList=new ArraySet<>(normalExceptionList.size() + 1);
  managedExceptionList.addAll(normalExceptionList);
  managedExceptionList.add(UserManager.DISALLOW_WALLPAPER);
  for (  UserInfo ui : mUserManager.getUsers()) {
    final int userId=ui.id;
    if (mOwners.getProfileOwnerUserRestrictionsNeedsMigration(userId)) {
      if (userId != UserHandle.USER_SYSTEM) {
        if (VERBOSE_LOG) {
          Log.v(LOG_TAG,""String_Node_Str"" + userId);
        }
        migrated=true;
        final ActiveAdmin profileOwnerAdmin=getProfileOwnerAdminLocked(userId);
        final Set<String> exceptionList=ui.isManagedProfile() ? managedExceptionList : normalExceptionList;
        migrateUserRestrictionsForUser(ui.getUserHandle(),profileOwnerAdmin,exceptionList);
        pushUserRestrictions(userId);
      }
      mOwners.setProfileOwnerUserRestrictionsMigrated(userId);
    }
  }
  if (VERBOSE_LOG && migrated) {
    Log.v(LOG_TAG,""String_Node_Str"");
  }
}","/** 
 * We didn't use to persist user restrictions for each owners but only persisted in user manager.
 */
private void migrateUserRestrictionsIfNecessaryLocked(){
  boolean migrated=false;
  if (mOwners.getDeviceOwnerUserRestrictionsNeedsMigration()) {
    if (VERBOSE_LOG) {
      Log.v(LOG_TAG,""String_Node_Str"");
    }
    migrated=true;
    final ActiveAdmin deviceOwnerAdmin=getDeviceOwnerAdminLocked();
    migrateUserRestrictionsForUser(UserHandle.SYSTEM,deviceOwnerAdmin,null,true);
    pushUserRestrictions(UserHandle.USER_SYSTEM);
    mOwners.setDeviceOwnerUserRestrictionsMigrated();
  }
  final Set<String> secondaryUserExceptionList=Sets.newArraySet(UserManager.DISALLOW_OUTGOING_CALLS,UserManager.DISALLOW_SMS);
  for (  UserInfo ui : mUserManager.getUsers()) {
    final int userId=ui.id;
    if (mOwners.getProfileOwnerUserRestrictionsNeedsMigration(userId)) {
      if (VERBOSE_LOG) {
        Log.v(LOG_TAG,""String_Node_Str"" + userId);
      }
      migrated=true;
      final ActiveAdmin profileOwnerAdmin=getProfileOwnerAdminLocked(userId);
      final Set<String> exceptionList=(userId == UserHandle.USER_SYSTEM) ? null : secondaryUserExceptionList;
      migrateUserRestrictionsForUser(ui.getUserHandle(),profileOwnerAdmin,exceptionList,false);
      pushUserRestrictions(userId);
      mOwners.setProfileOwnerUserRestrictionsMigrated(userId);
    }
  }
  if (VERBOSE_LOG && migrated) {
    Log.v(LOG_TAG,""String_Node_Str"");
  }
}",0.7808436409768474
192666,"private void migrateUserRestrictionsForUser(UserHandle user,ActiveAdmin admin,Set<String> exceptionList){
  final Bundle origRestrictions=mUserManagerInternal.getBaseUserRestrictions(user.getIdentifier());
  final Bundle newBaseRestrictions=new Bundle();
  final Bundle newOwnerRestrictions=new Bundle();
  for (  String key : origRestrictions.keySet()) {
    if (!origRestrictions.getBoolean(key)) {
      continue;
    }
    if (exceptionList != null && exceptionList.contains(key)) {
      newBaseRestrictions.putBoolean(key,true);
    }
 else {
      newOwnerRestrictions.putBoolean(key,true);
    }
  }
  if (VERBOSE_LOG) {
    Log.v(LOG_TAG,""String_Node_Str"" + origRestrictions);
    Log.v(LOG_TAG,""String_Node_Str"" + newBaseRestrictions);
    Log.v(LOG_TAG,""String_Node_Str"" + newOwnerRestrictions);
  }
  mUserManagerInternal.setBaseUserRestrictionsByDpmsForMigration(user.getIdentifier(),newBaseRestrictions);
  if (admin != null) {
    admin.ensureUserRestrictions().clear();
    admin.ensureUserRestrictions().putAll(newOwnerRestrictions);
  }
 else {
    Slog.w(LOG_TAG,""String_Node_Str"" + user.getIdentifier());
  }
  saveSettingsLocked(user.getIdentifier());
}","private void migrateUserRestrictionsForUser(UserHandle user,ActiveAdmin admin,Set<String> exceptionList,boolean isDeviceOwner){
  final Bundle origRestrictions=mUserManagerInternal.getBaseUserRestrictions(user.getIdentifier());
  final Bundle newBaseRestrictions=new Bundle();
  final Bundle newOwnerRestrictions=new Bundle();
  for (  String key : origRestrictions.keySet()) {
    if (!origRestrictions.getBoolean(key)) {
      continue;
    }
    final boolean canOwnerChange=isDeviceOwner ? UserRestrictionsUtils.canDeviceOwnerChange(key) : UserRestrictionsUtils.canProfileOwnerChange(key,user.getIdentifier());
    if (!canOwnerChange || (exceptionList != null && exceptionList.contains(key))) {
      newBaseRestrictions.putBoolean(key,true);
    }
 else {
      newOwnerRestrictions.putBoolean(key,true);
    }
  }
  if (VERBOSE_LOG) {
    Log.v(LOG_TAG,""String_Node_Str"" + origRestrictions);
    Log.v(LOG_TAG,""String_Node_Str"" + newBaseRestrictions);
    Log.v(LOG_TAG,""String_Node_Str"" + newOwnerRestrictions);
  }
  mUserManagerInternal.setBaseUserRestrictionsByDpmsForMigration(user.getIdentifier(),newBaseRestrictions);
  if (admin != null) {
    admin.ensureUserRestrictions().clear();
    admin.ensureUserRestrictions().putAll(newOwnerRestrictions);
  }
 else {
    Slog.w(LOG_TAG,""String_Node_Str"" + user.getIdentifier());
  }
  saveSettingsLocked(user.getIdentifier());
}",0.915267473643108
192667,"@Override public void run(){
  updateRecentsIcon(exists);
}","@Override public void run(){
  mDockedStackExists=exists;
  updateRecentsIcon();
}",0.75177304964539
192668,"private void updateRecentsIcon(boolean dockedStackExists){
  getRecentsButton().setImageResource(dockedStackExists ? R.drawable.ic_sysbar_docked : R.drawable.ic_sysbar_recent);
}","private void updateRecentsIcon(){
  getRecentsButton().setImageDrawable(mDockedStackExists ? mDockedIcon : mRecentIcon);
}",0.6866666666666666
192669,"@Override public void onDockedStackExistsChanged(final boolean exists) throws RemoteException {
  mHandler.post(new Runnable(){
    @Override public void run(){
      updateRecentsIcon(exists);
    }
  }
);
}","@Override public void onDockedStackExistsChanged(final boolean exists) throws RemoteException {
  mHandler.post(new Runnable(){
    @Override public void run(){
      mDockedStackExists=exists;
      updateRecentsIcon();
    }
  }
);
}",0.91196388261851
192670,"@Override public void onFinishInflate(){
  mRotatedViews[Surface.ROTATION_0]=mRotatedViews[Surface.ROTATION_180]=findViewById(R.id.rot0);
  mRotatedViews[Surface.ROTATION_90]=findViewById(R.id.rot90);
  mRotatedViews[Surface.ROTATION_270]=mRotatedViews[Surface.ROTATION_90];
  mCurrentView=mRotatedViews[Surface.ROTATION_0];
  for (int i=0; i < mButtonDisatchers.size(); i++) {
    mButtonDisatchers.valueAt(i).setCurrentView(mCurrentView);
  }
  ((NavigationBarInflaterView)findViewById(R.id.navigation_inflater)).setButtonDispatchers(mButtonDisatchers);
  getImeSwitchButton().setOnClickListener(mImeSwitcherClickListener);
  try {
    WindowManagerGlobal.getWindowManagerService().registerDockedStackListener(new Stub(){
      @Override public void onDividerVisibilityChanged(      boolean visible) throws RemoteException {
      }
      @Override public void onDockedStackExistsChanged(      final boolean exists) throws RemoteException {
        mHandler.post(new Runnable(){
          @Override public void run(){
            updateRecentsIcon(exists);
          }
        }
);
      }
    }
);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","@Override public void onFinishInflate(){
  mRotatedViews[Surface.ROTATION_0]=mRotatedViews[Surface.ROTATION_180]=findViewById(R.id.rot0);
  mRotatedViews[Surface.ROTATION_90]=findViewById(R.id.rot90);
  mRotatedViews[Surface.ROTATION_270]=mRotatedViews[Surface.ROTATION_90];
  mCurrentView=mRotatedViews[Surface.ROTATION_0];
  for (int i=0; i < mButtonDisatchers.size(); i++) {
    mButtonDisatchers.valueAt(i).setCurrentView(mCurrentView);
  }
  ((NavigationBarInflaterView)findViewById(R.id.navigation_inflater)).setButtonDispatchers(mButtonDisatchers);
  getImeSwitchButton().setOnClickListener(mImeSwitcherClickListener);
  try {
    WindowManagerGlobal.getWindowManagerService().registerDockedStackListener(new Stub(){
      @Override public void onDividerVisibilityChanged(      boolean visible) throws RemoteException {
      }
      @Override public void onDockedStackExistsChanged(      final boolean exists) throws RemoteException {
        mHandler.post(new Runnable(){
          @Override public void run(){
            mDockedStackExists=exists;
            updateRecentsIcon();
          }
        }
);
      }
    }
);
  }
 catch (  RemoteException e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}",0.9811478843736908
192671,"public void setNavigationIconHints(int hints,boolean force){
  if (!force && hints == mNavigationIconHints)   return;
  final boolean backAlt=(hints & StatusBarManager.NAVIGATION_HINT_BACK_ALT) != 0;
  if ((mNavigationIconHints & StatusBarManager.NAVIGATION_HINT_BACK_ALT) != 0 && !backAlt) {
    mTransitionListener.onBackAltCleared();
  }
  if (DEBUG) {
    android.widget.Toast.makeText(getContext(),""String_Node_Str"" + hints,500).show();
  }
  mNavigationIconHints=hints;
  Drawable backIcon=(backAlt) ? getBackIconWithAlt(mCarMode,mVertical) : getBackIcon(mCarMode,mVertical);
  getBackButton().setImageDrawable(backIcon);
  getRecentsButton().setImageDrawable(mVertical ? mRecentLandIcon : mRecentIcon);
  if (mCarMode) {
    getHomeButton().setImageDrawable(mHomeCarModeIcon);
  }
 else {
    getHomeButton().setImageDrawable(mHomeDefaultIcon);
  }
  final boolean showImeButton=((hints & StatusBarManager.NAVIGATION_HINT_IME_SHOWN) != 0);
  getImeSwitchButton().setVisibility(showImeButton ? View.VISIBLE : View.INVISIBLE);
  setMenuVisibility(mShowMenu,true);
  setDisabledFlags(mDisabledFlags,true);
}","public void setNavigationIconHints(int hints,boolean force){
  if (!force && hints == mNavigationIconHints)   return;
  final boolean backAlt=(hints & StatusBarManager.NAVIGATION_HINT_BACK_ALT) != 0;
  if ((mNavigationIconHints & StatusBarManager.NAVIGATION_HINT_BACK_ALT) != 0 && !backAlt) {
    mTransitionListener.onBackAltCleared();
  }
  if (DEBUG) {
    android.widget.Toast.makeText(getContext(),""String_Node_Str"" + hints,500).show();
  }
  mNavigationIconHints=hints;
  Drawable backIcon=(backAlt) ? getBackIconWithAlt(mCarMode,mVertical) : getBackIcon(mCarMode,mVertical);
  getBackButton().setImageDrawable(backIcon);
  updateRecentsIcon();
  if (mCarMode) {
    getHomeButton().setImageDrawable(mHomeCarModeIcon);
  }
 else {
    getHomeButton().setImageDrawable(mHomeDefaultIcon);
  }
  final boolean showImeButton=((hints & StatusBarManager.NAVIGATION_HINT_IME_SHOWN) != 0);
  getImeSwitchButton().setVisibility(showImeButton ? View.VISIBLE : View.INVISIBLE);
  setMenuVisibility(mShowMenu,true);
  setDisabledFlags(mDisabledFlags,true);
}",0.9625520110957004
192672,"private void getIcons(Context ctx){
  mBackIcon=ctx.getDrawable(R.drawable.ic_sysbar_back);
  mBackLandIcon=mBackIcon;
  mBackAltIcon=ctx.getDrawable(R.drawable.ic_sysbar_back_ime);
  mBackAltLandIcon=mBackAltIcon;
  mHomeDefaultIcon=ctx.getDrawable(R.drawable.ic_sysbar_home);
  mRecentIcon=ctx.getDrawable(R.drawable.ic_sysbar_recent);
  mRecentLandIcon=mRecentIcon;
  getCarModeIcons(ctx);
}","private void getIcons(Context ctx){
  mBackIcon=ctx.getDrawable(R.drawable.ic_sysbar_back);
  mBackLandIcon=mBackIcon;
  mBackAltIcon=ctx.getDrawable(R.drawable.ic_sysbar_back_ime);
  mBackAltLandIcon=mBackAltIcon;
  mHomeDefaultIcon=ctx.getDrawable(R.drawable.ic_sysbar_home);
  mRecentIcon=ctx.getDrawable(R.drawable.ic_sysbar_recent);
  mDockedIcon=ctx.getDrawable(R.drawable.ic_sysbar_docked);
  getCarModeIcons(ctx);
}",0.9008567931456548
192673,"public List<InputMethodInfo> getEnabledInputMethodListLocked(){
  return createEnabledInputMethodListLocked(getEnabledInputMethodsAndSubtypeListLocked());
}","public ArrayList<InputMethodInfo> getEnabledInputMethodListLocked(){
  return createEnabledInputMethodListLocked(getEnabledInputMethodsAndSubtypeListLocked());
}",0.9842271293375394
192674,"private List<InputMethodInfo> createEnabledInputMethodListLocked(List<Pair<String,ArrayList<String>>> imsList){
  final ArrayList<InputMethodInfo> res=new ArrayList<>();
  for (  Pair<String,ArrayList<String>> ims : imsList) {
    InputMethodInfo info=mMethodMap.get(ims.first);
    if (info != null) {
      res.add(info);
    }
  }
  return res;
}","private ArrayList<InputMethodInfo> createEnabledInputMethodListLocked(List<Pair<String,ArrayList<String>>> imsList){
  final ArrayList<InputMethodInfo> res=new ArrayList<>();
  for (  Pair<String,ArrayList<String>> ims : imsList) {
    InputMethodInfo info=mMethodMap.get(ims.first);
    if (info != null) {
      res.add(info);
    }
  }
  return res;
}",0.992887624466572
192675,"private void resetDefaultImeLocked(Context context){
  if (mCurMethodId != null && !InputMethodUtils.isSystemIme(mMethodMap.get(mCurMethodId))) {
    return;
  }
  InputMethodInfo defIm=null;
  for (  InputMethodInfo imi : mMethodList) {
    if (defIm == null && mSystemReady) {
      final Locale systemLocale=context.getResources().getConfiguration().locale;
      if (InputMethodUtils.isSystemImeThatHasSubtypeOf(imi,context,true,systemLocale,false,InputMethodUtils.SUBTYPE_MODE_ANY)) {
        defIm=imi;
        Slog.i(TAG,""String_Node_Str"" + imi.getId());
      }
    }
  }
  if (defIm == null && mMethodList.size() > 0) {
    defIm=InputMethodUtils.getMostApplicableDefaultIME(mSettings.getEnabledInputMethodListLocked());
    if (defIm != null) {
      Slog.i(TAG,""String_Node_Str"" + defIm.getId());
    }
 else {
      Slog.i(TAG,""String_Node_Str"");
    }
  }
  if (defIm != null) {
    setSelectedInputMethodAndSubtypeLocked(defIm,NOT_A_SUBTYPE_ID,false);
  }
}","private void resetDefaultImeLocked(Context context){
  if (mCurMethodId != null && !InputMethodUtils.isSystemIme(mMethodMap.get(mCurMethodId))) {
    return;
  }
  final List<InputMethodInfo> suitableImes=InputMethodUtils.getDefaultEnabledImes(context,mSystemReady,mSettings.getEnabledInputMethodListLocked());
  if (suitableImes.isEmpty()) {
    Slog.i(TAG,""String_Node_Str"");
    return;
  }
  final InputMethodInfo defIm=suitableImes.get(0);
  Slog.i(TAG,""String_Node_Str"" + defIm.getId());
  setSelectedInputMethodAndSubtypeLocked(defIm,NOT_A_SUBTYPE_ID,false);
}",0.2717815344603381
192676,"public List<InputMethodInfo> getEnabledInputMethodListLocked(){
  return createEnabledInputMethodListLocked(getEnabledInputMethodsAndSubtypeListLocked());
}","public ArrayList<InputMethodInfo> getEnabledInputMethodListLocked(){
  return createEnabledInputMethodListLocked(getEnabledInputMethodsAndSubtypeListLocked());
}",0.9842271293375394
192677,"private List<InputMethodInfo> createEnabledInputMethodListLocked(List<Pair<String,ArrayList<String>>> imsList){
  final ArrayList<InputMethodInfo> res=new ArrayList<>();
  for (  Pair<String,ArrayList<String>> ims : imsList) {
    InputMethodInfo info=mMethodMap.get(ims.first);
    if (info != null) {
      res.add(info);
    }
  }
  return res;
}","private ArrayList<InputMethodInfo> createEnabledInputMethodListLocked(List<Pair<String,ArrayList<String>>> imsList){
  final ArrayList<InputMethodInfo> res=new ArrayList<>();
  for (  Pair<String,ArrayList<String>> ims : imsList) {
    InputMethodInfo info=mMethodMap.get(ims.first);
    if (info != null) {
      res.add(info);
    }
  }
  return res;
}",0.992887624466572
192678,"private void resetDefaultImeLocked(Context context){
  if (mCurMethodId != null && !InputMethodUtils.isSystemIme(mMethodMap.get(mCurMethodId))) {
    return;
  }
  InputMethodInfo defIm=null;
  for (  InputMethodInfo imi : mMethodList) {
    if (defIm == null && mSystemReady) {
      final Locale systemLocale=context.getResources().getConfiguration().locale;
      if (InputMethodUtils.isSystemImeThatHasSubtypeOf(imi,context,true,systemLocale,false,InputMethodUtils.SUBTYPE_MODE_ANY)) {
        defIm=imi;
        Slog.i(TAG,""String_Node_Str"" + imi.getId());
      }
    }
  }
  if (defIm == null && mMethodList.size() > 0) {
    defIm=InputMethodUtils.getMostApplicableDefaultIME(mSettings.getEnabledInputMethodListLocked());
    if (defIm != null) {
      Slog.i(TAG,""String_Node_Str"" + defIm.getId());
    }
 else {
      Slog.i(TAG,""String_Node_Str"");
    }
  }
  if (defIm != null) {
    setSelectedInputMethodAndSubtypeLocked(defIm,NOT_A_SUBTYPE_ID,false);
  }
}","private void resetDefaultImeLocked(Context context){
  if (mCurMethodId != null && !InputMethodUtils.isSystemIme(mMethodMap.get(mCurMethodId))) {
    return;
  }
  final List<InputMethodInfo> suitableImes=InputMethodUtils.getDefaultEnabledImes(context,mSystemReady,mSettings.getEnabledInputMethodListLocked());
  if (suitableImes.isEmpty()) {
    Slog.i(TAG,""String_Node_Str"");
    return;
  }
  final InputMethodInfo defIm=suitableImes.get(0);
  Slog.i(TAG,""String_Node_Str"" + defIm.getId());
  setSelectedInputMethodAndSubtypeLocked(defIm,NOT_A_SUBTYPE_ID,false);
}",0.2717815344603381
192679,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  final View view=inflater.inflate(R.layout.fragment_directory,container,false);
  mMessageBar=MessageBar.create(getChildFragmentManager());
  mProgressBar=view.findViewById(R.id.progressbar);
  mEmptyView=view.findViewById(android.R.id.empty);
  mRecView=(RecyclerView)view.findViewById(R.id.dir_list);
  mRecView.setRecyclerListener(new RecyclerListener(){
    @Override public void onViewRecycled(    ViewHolder holder){
      cancelThumbnailTask(holder.itemView);
    }
  }
);
  mRecView.setItemAnimator(new DirectoryItemAnimator(getActivity()));
  mRecView.setFocusable(false);
  if (DEBUG_ENABLE_DND) {
    setupDragAndDropOnDirectoryView(mRecView);
  }
  return view;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  final View view=inflater.inflate(R.layout.fragment_directory,container,false);
  mMessageBar=MessageBar.create(getChildFragmentManager());
  mProgressBar=view.findViewById(R.id.progressbar);
  mEmptyView=view.findViewById(android.R.id.empty);
  mRecView=(RecyclerView)view.findViewById(R.id.dir_list);
  mRecView.setRecyclerListener(new RecyclerListener(){
    @Override public void onViewRecycled(    ViewHolder holder){
      cancelThumbnailTask(holder.itemView);
    }
  }
);
  mRecView.setItemAnimator(new DirectoryItemAnimator(getActivity()));
  if (DEBUG_ENABLE_DND) {
    setupDragAndDropOnDirectoryView(mRecView);
  }
  return view;
}",0.9791395045632334
192680,"/** 
 * Finds the destination position where the focus should land for a given navigation event.
 * @param view The view that received the event.
 * @param keyCode The key code for the event.
 * @param event
 * @return The adapter position of the destination item. Could be RecyclerView.NO_POSITION.
 */
private int findTargetPosition(View view,int keyCode,KeyEvent event){
switch (keyCode) {
case KeyEvent.KEYCODE_MOVE_HOME:
    return 0;
case KeyEvent.KEYCODE_MOVE_END:
  return mAdapter.getItemCount() - 1;
case KeyEvent.KEYCODE_PAGE_UP:
case KeyEvent.KEYCODE_PAGE_DOWN:
return findPagedTargetPosition(view,keyCode,event);
}
int searchDir=-1;
switch (keyCode) {
case KeyEvent.KEYCODE_DPAD_UP:
searchDir=View.FOCUS_UP;
break;
case KeyEvent.KEYCODE_DPAD_DOWN:
searchDir=View.FOCUS_DOWN;
break;
}
if (inGridMode()) {
int currentPosition=mView.getChildAdapterPosition(view);
switch (keyCode) {
case KeyEvent.KEYCODE_DPAD_LEFT:
if (currentPosition > 0) {
searchDir=View.FOCUS_BACKWARD;
}
break;
case KeyEvent.KEYCODE_DPAD_RIGHT:
if (currentPosition < mAdapter.getItemCount() - 1) {
searchDir=View.FOCUS_FORWARD;
}
break;
}
}
if (searchDir != -1) {
View targetView=view.focusSearch(searchDir);
if (targetView != null) {
if (targetView.getParent() == mView) {
return mView.getChildAdapterPosition(targetView);
}
}
}
return RecyclerView.NO_POSITION;
}","/** 
 * Finds the destination position where the focus should land for a given navigation event.
 * @param view The view that received the event.
 * @param keyCode The key code for the event.
 * @param event
 * @return The adapter position of the destination item. Could be RecyclerView.NO_POSITION.
 */
private int findTargetPosition(View view,int keyCode,KeyEvent event){
switch (keyCode) {
case KeyEvent.KEYCODE_MOVE_HOME:
    return 0;
case KeyEvent.KEYCODE_MOVE_END:
  return mAdapter.getItemCount() - 1;
case KeyEvent.KEYCODE_PAGE_UP:
case KeyEvent.KEYCODE_PAGE_DOWN:
return findPagedTargetPosition(view,keyCode,event);
}
int searchDir=-1;
switch (keyCode) {
case KeyEvent.KEYCODE_DPAD_UP:
searchDir=View.FOCUS_UP;
break;
case KeyEvent.KEYCODE_DPAD_DOWN:
searchDir=View.FOCUS_DOWN;
break;
}
if (inGridMode()) {
int currentPosition=mView.getChildAdapterPosition(view);
switch (keyCode) {
case KeyEvent.KEYCODE_DPAD_LEFT:
if (currentPosition > 0) {
searchDir=View.FOCUS_BACKWARD;
}
break;
case KeyEvent.KEYCODE_DPAD_RIGHT:
if (currentPosition < mAdapter.getItemCount() - 1) {
searchDir=View.FOCUS_FORWARD;
}
break;
}
}
if (searchDir != -1) {
mView.setFocusable(false);
View targetView=view.focusSearch(searchDir);
mView.setFocusable(true);
if (targetView != null) {
if (targetView.getParent() == mView) {
return mView.getChildAdapterPosition(targetView);
}
}
}
return RecyclerView.NO_POSITION;
}",0.9806921675774136
192681,"void onTimeChanged(long oldTime,long newTime,boolean resetBeginIdleTime){
  persistActiveStats();
  mDatabase.onTimeChanged(newTime - oldTime);
  loadActiveStats(newTime,true,resetBeginIdleTime);
}","void onTimeChanged(long oldTime,long newTime,boolean resetBeginIdleTime){
  persistActiveStats();
  mDatabase.onTimeChanged(newTime - oldTime);
  loadActiveStats(newTime,true,resetBeginIdleTime);
  refreshAppIdleRollingWindow(newTime);
}",0.9078341013824884
192682,"long getBeginIdleTime(String packageName){
  final IntervalStats yearly=mCurrentStats[UsageStatsManager.INTERVAL_YEARLY];
  UsageStats packageUsage;
  if ((packageUsage=yearly.packageStats.get(packageName)) == null) {
    return -1;
  }
 else {
    return packageUsage.getBeginIdleTime();
  }
}","long getBeginIdleTime(String packageName){
  UsageStats packageUsage;
  if ((packageUsage=mAppIdleRollingWindow.packageStats.get(packageName)) == null) {
    return -1;
  }
 else {
    return packageUsage.getBeginIdleTime();
  }
}",0.6374045801526718
192683,"void dump(IndentingPrintWriter pw,final long screenOnTime){
  for (int interval=0; interval < mCurrentStats.length; interval++) {
    pw.print(""String_Node_Str"");
    pw.print(intervalToString(interval));
    pw.println(""String_Node_Str"");
    printIntervalStats(pw,mCurrentStats[interval],screenOnTime,true);
  }
}","void dump(IndentingPrintWriter pw,final long screenOnTime){
  for (int interval=0; interval < mCurrentStats.length; interval++) {
    pw.print(""String_Node_Str"");
    pw.print(intervalToString(interval));
    pw.println(""String_Node_Str"");
    printIntervalStats(pw,mCurrentStats[interval],screenOnTime,true);
  }
  pw.println(""String_Node_Str"");
  printIntervalStats(pw,mAppIdleRollingWindow,screenOnTime,true);
}",0.8641975308641975
192684,"void setSystemLastUsedTime(String packageName,long lastUsedTime){
  for (  IntervalStats stats : mCurrentStats) {
    stats.updateSystemLastUsedTime(packageName,lastUsedTime);
  }
  notifyStatsChanged();
}","void setSystemLastUsedTime(String packageName,long lastUsedTime){
  for (  IntervalStats stats : mCurrentStats) {
    stats.updateSystemLastUsedTime(packageName,lastUsedTime);
  }
  mAppIdleRollingWindow.updateSystemLastUsedTime(packageName,lastUsedTime);
  notifyStatsChanged();
}",0.8436213991769548
192685,"@Override public void combine(IntervalStats stats,boolean mutable,List<UsageEvents.Event> accumulatedResult){
  if (stats.events == null) {
    return;
  }
  final int startIndex=stats.events.closestIndexOnOrAfter(beginTime);
  if (startIndex < 0) {
    return;
  }
  final int size=stats.events.size();
  for (int i=startIndex; i < size; i++) {
    if (stats.events.keyAt(i) >= endTime) {
      return;
    }
    final UsageEvents.Event event=stats.events.valueAt(i);
    names.add(event.mPackage);
    if (event.mClass != null) {
      names.add(event.mClass);
    }
    accumulatedResult.add(event);
  }
}","@Override public void combine(IntervalStats stats,boolean mutable,List<IntervalStats> accumulatedResult){
  IntervalStats accum;
  if (accumulatedResult.isEmpty()) {
    accum=new IntervalStats();
    accum.beginTime=stats.beginTime;
    accumulatedResult.add(accum);
  }
 else {
    accum=accumulatedResult.get(0);
  }
  mergePackageStats(accum,stats);
}",0.2159916926272066
192686,"void init(final long currentTimeMillis,final long deviceUsageTime){
  mDatabase.init(currentTimeMillis);
  int nullCount=0;
  for (int i=0; i < mCurrentStats.length; i++) {
    mCurrentStats[i]=mDatabase.getLatestUsageStats(i);
    if (mCurrentStats[i] == null) {
      nullCount++;
    }
  }
  if (nullCount > 0) {
    if (nullCount != mCurrentStats.length) {
      Slog.w(TAG,mLogPrefix + ""String_Node_Str"");
    }
 else {
    }
    loadActiveStats(currentTimeMillis,false,false);
  }
 else {
    mDailyExpiryDate.setTimeInMillis(mCurrentStats[UsageStatsManager.INTERVAL_DAILY].beginTime);
    mDailyExpiryDate.addDays(1);
    mDailyExpiryDate.truncateToDay();
    Slog.i(TAG,mLogPrefix + ""String_Node_Str"" + sDateFormat.format(mDailyExpiryDate.getTimeInMillis())+ ""String_Node_Str""+ mDailyExpiryDate.getTimeInMillis()+ ""String_Node_Str"");
  }
  for (  IntervalStats stat : mCurrentStats) {
    final int pkgCount=stat.packageStats.size();
    for (int i=0; i < pkgCount; i++) {
      UsageStats pkgStats=stat.packageStats.valueAt(i);
      if (pkgStats.mLastEvent == UsageEvents.Event.MOVE_TO_FOREGROUND || pkgStats.mLastEvent == UsageEvents.Event.CONTINUE_PREVIOUS_DAY) {
        stat.update(pkgStats.mPackageName,stat.lastTimeSaved,UsageEvents.Event.END_OF_DAY);
        notifyStatsChanged();
      }
    }
    stat.updateConfigurationStats(null,stat.lastTimeSaved);
  }
  if (mDatabase.isNewUpdate()) {
    initializeDefaultsForApps(currentTimeMillis,deviceUsageTime,mDatabase.isFirstUpdate());
  }
}","void init(final long currentTimeMillis,final long deviceUsageTime){
  mDatabase.init(currentTimeMillis);
  int nullCount=0;
  for (int i=0; i < mCurrentStats.length; i++) {
    mCurrentStats[i]=mDatabase.getLatestUsageStats(i);
    if (mCurrentStats[i] == null) {
      nullCount++;
    }
  }
  if (nullCount > 0) {
    if (nullCount != mCurrentStats.length) {
      Slog.w(TAG,mLogPrefix + ""String_Node_Str"");
    }
 else {
    }
    loadActiveStats(currentTimeMillis,false,false);
  }
 else {
    mDailyExpiryDate.setTimeInMillis(mCurrentStats[UsageStatsManager.INTERVAL_DAILY].beginTime);
    mDailyExpiryDate.addDays(1);
    mDailyExpiryDate.truncateToDay();
    Slog.i(TAG,mLogPrefix + ""String_Node_Str"" + sDateFormat.format(mDailyExpiryDate.getTimeInMillis())+ ""String_Node_Str""+ mDailyExpiryDate.getTimeInMillis()+ ""String_Node_Str"");
  }
  for (  IntervalStats stat : mCurrentStats) {
    final int pkgCount=stat.packageStats.size();
    for (int i=0; i < pkgCount; i++) {
      UsageStats pkgStats=stat.packageStats.valueAt(i);
      if (pkgStats.mLastEvent == UsageEvents.Event.MOVE_TO_FOREGROUND || pkgStats.mLastEvent == UsageEvents.Event.CONTINUE_PREVIOUS_DAY) {
        stat.update(pkgStats.mPackageName,stat.lastTimeSaved,UsageEvents.Event.END_OF_DAY);
        notifyStatsChanged();
      }
    }
    stat.updateConfigurationStats(null,stat.lastTimeSaved);
  }
  if (mDatabase.isNewUpdate()) {
    initializeDefaultsForApps(currentTimeMillis,deviceUsageTime,mDatabase.isFirstUpdate());
  }
  refreshAppIdleRollingWindow(currentTimeMillis);
}",0.983670803396473
192687,"void reportEvent(UsageEvents.Event event,long deviceUsageTime){
  if (DEBUG) {
    Slog.d(TAG,mLogPrefix + ""String_Node_Str"" + event.mPackage+ ""String_Node_Str""+ event.mTimeStamp+ ""String_Node_Str""+ eventToString(event.mEventType));
  }
  if (event.mTimeStamp >= mDailyExpiryDate.getTimeInMillis()) {
    rolloverStats(event.mTimeStamp);
  }
  final IntervalStats currentDailyStats=mCurrentStats[UsageStatsManager.INTERVAL_DAILY];
  final Configuration newFullConfig=event.mConfiguration;
  if (event.mEventType == UsageEvents.Event.CONFIGURATION_CHANGE && currentDailyStats.activeConfiguration != null) {
    event.mConfiguration=Configuration.generateDelta(currentDailyStats.activeConfiguration,newFullConfig);
  }
  if (currentDailyStats.events == null) {
    currentDailyStats.events=new TimeSparseArray<>();
  }
  if (event.mEventType != UsageEvents.Event.SYSTEM_INTERACTION) {
    currentDailyStats.events.put(event.mTimeStamp,event);
  }
  for (  IntervalStats stats : mCurrentStats) {
    if (event.mEventType == UsageEvents.Event.CONFIGURATION_CHANGE) {
      stats.updateConfigurationStats(newFullConfig,event.mTimeStamp);
    }
 else {
      stats.update(event.mPackage,event.mTimeStamp,event.mEventType);
      stats.updateBeginIdleTime(event.mPackage,deviceUsageTime);
    }
  }
  notifyStatsChanged();
}","void reportEvent(UsageEvents.Event event,long deviceUsageTime){
  if (DEBUG) {
    Slog.d(TAG,mLogPrefix + ""String_Node_Str"" + event.mPackage+ ""String_Node_Str""+ event.mTimeStamp+ ""String_Node_Str""+ eventToString(event.mEventType));
  }
  if (event.mTimeStamp >= mDailyExpiryDate.getTimeInMillis()) {
    rolloverStats(event.mTimeStamp);
  }
  final IntervalStats currentDailyStats=mCurrentStats[UsageStatsManager.INTERVAL_DAILY];
  final Configuration newFullConfig=event.mConfiguration;
  if (event.mEventType == UsageEvents.Event.CONFIGURATION_CHANGE && currentDailyStats.activeConfiguration != null) {
    event.mConfiguration=Configuration.generateDelta(currentDailyStats.activeConfiguration,newFullConfig);
  }
  if (currentDailyStats.events == null) {
    currentDailyStats.events=new TimeSparseArray<>();
  }
  if (event.mEventType != UsageEvents.Event.SYSTEM_INTERACTION) {
    currentDailyStats.events.put(event.mTimeStamp,event);
  }
  for (  IntervalStats stats : mCurrentStats) {
    if (event.mEventType == UsageEvents.Event.CONFIGURATION_CHANGE) {
      stats.updateConfigurationStats(newFullConfig,event.mTimeStamp);
    }
 else {
      stats.update(event.mPackage,event.mTimeStamp,event.mEventType);
      stats.updateBeginIdleTime(event.mPackage,deviceUsageTime);
    }
  }
  if (event.mEventType != Event.CONFIGURATION_CHANGE) {
    mAppIdleRollingWindow.update(event.mPackage,event.mTimeStamp,event.mEventType);
    mAppIdleRollingWindow.updateBeginIdleTime(event.mPackage,deviceUsageTime);
  }
  notifyStatsChanged();
}",0.9219460973048652
192688,"long getSystemLastUsedTime(String packageName){
  final IntervalStats yearly=mCurrentStats[UsageStatsManager.INTERVAL_YEARLY];
  UsageStats packageUsage;
  if ((packageUsage=yearly.packageStats.get(packageName)) == null) {
    return -1;
  }
 else {
    return packageUsage.getLastTimeSystemUsed();
  }
}","long getSystemLastUsedTime(String packageName){
  UsageStats packageUsage;
  if ((packageUsage=mAppIdleRollingWindow.packageStats.get(packageName)) == null) {
    return -1;
  }
 else {
    return packageUsage.getLastTimeSystemUsed();
  }
}",0.6507352941176471
192689,"/** 
 * Sets the beginIdleTime for each of the intervals.
 * @param beginIdleTime
 */
void setBeginIdleTime(String packageName,long beginIdleTime){
  for (  IntervalStats stats : mCurrentStats) {
    stats.updateBeginIdleTime(packageName,beginIdleTime);
  }
  notifyStatsChanged();
}","/** 
 * Sets the beginIdleTime for each of the intervals.
 * @param beginIdleTime
 */
void setBeginIdleTime(String packageName,long beginIdleTime){
  for (  IntervalStats stats : mCurrentStats) {
    stats.updateBeginIdleTime(packageName,beginIdleTime);
  }
  mAppIdleRollingWindow.updateBeginIdleTime(packageName,beginIdleTime);
  notifyStatsChanged();
}",0.8871473354231975
192690,"private void rolloverStats(final long currentTimeMillis){
  final long startTime=SystemClock.elapsedRealtime();
  Slog.i(TAG,mLogPrefix + ""String_Node_Str"");
  final Configuration previousConfig=mCurrentStats[UsageStatsManager.INTERVAL_DAILY].activeConfiguration;
  ArraySet<String> continuePreviousDay=new ArraySet<>();
  for (  IntervalStats stat : mCurrentStats) {
    final int pkgCount=stat.packageStats.size();
    for (int i=0; i < pkgCount; i++) {
      UsageStats pkgStats=stat.packageStats.valueAt(i);
      if (pkgStats.mLastEvent == UsageEvents.Event.MOVE_TO_FOREGROUND || pkgStats.mLastEvent == UsageEvents.Event.CONTINUE_PREVIOUS_DAY) {
        continuePreviousDay.add(pkgStats.mPackageName);
        stat.update(pkgStats.mPackageName,mDailyExpiryDate.getTimeInMillis() - 1,UsageEvents.Event.END_OF_DAY);
        notifyStatsChanged();
      }
    }
    stat.updateConfigurationStats(null,mDailyExpiryDate.getTimeInMillis() - 1);
  }
  persistActiveStats();
  mDatabase.prune(currentTimeMillis);
  loadActiveStats(currentTimeMillis,false,false);
  final int continueCount=continuePreviousDay.size();
  for (int i=0; i < continueCount; i++) {
    String name=continuePreviousDay.valueAt(i);
    final long beginTime=mCurrentStats[UsageStatsManager.INTERVAL_DAILY].beginTime;
    for (    IntervalStats stat : mCurrentStats) {
      stat.update(name,beginTime,UsageEvents.Event.CONTINUE_PREVIOUS_DAY);
      stat.updateConfigurationStats(previousConfig,beginTime);
      notifyStatsChanged();
    }
  }
  persistActiveStats();
  final long totalTime=SystemClock.elapsedRealtime() - startTime;
  Slog.i(TAG,mLogPrefix + ""String_Node_Str"" + totalTime+ ""String_Node_Str"");
}","private void rolloverStats(final long currentTimeMillis){
  final long startTime=SystemClock.elapsedRealtime();
  Slog.i(TAG,mLogPrefix + ""String_Node_Str"");
  final Configuration previousConfig=mCurrentStats[UsageStatsManager.INTERVAL_DAILY].activeConfiguration;
  ArraySet<String> continuePreviousDay=new ArraySet<>();
  for (  IntervalStats stat : mCurrentStats) {
    final int pkgCount=stat.packageStats.size();
    for (int i=0; i < pkgCount; i++) {
      UsageStats pkgStats=stat.packageStats.valueAt(i);
      if (pkgStats.mLastEvent == UsageEvents.Event.MOVE_TO_FOREGROUND || pkgStats.mLastEvent == UsageEvents.Event.CONTINUE_PREVIOUS_DAY) {
        continuePreviousDay.add(pkgStats.mPackageName);
        stat.update(pkgStats.mPackageName,mDailyExpiryDate.getTimeInMillis() - 1,UsageEvents.Event.END_OF_DAY);
        notifyStatsChanged();
      }
    }
    stat.updateConfigurationStats(null,mDailyExpiryDate.getTimeInMillis() - 1);
  }
  persistActiveStats();
  mDatabase.prune(currentTimeMillis);
  loadActiveStats(currentTimeMillis,false,false);
  final int continueCount=continuePreviousDay.size();
  for (int i=0; i < continueCount; i++) {
    String name=continuePreviousDay.valueAt(i);
    final long beginTime=mCurrentStats[UsageStatsManager.INTERVAL_DAILY].beginTime;
    for (    IntervalStats stat : mCurrentStats) {
      stat.update(name,beginTime,UsageEvents.Event.CONTINUE_PREVIOUS_DAY);
      stat.updateConfigurationStats(previousConfig,beginTime);
      notifyStatsChanged();
    }
  }
  persistActiveStats();
  refreshAppIdleRollingWindow(currentTimeMillis);
  final long totalTime=SystemClock.elapsedRealtime() - startTime;
  Slog.i(TAG,mLogPrefix + ""String_Node_Str"" + totalTime+ ""String_Node_Str"");
}",0.9853544229642648
192691,"/** 
 * This should be the only way to get the time from the system.
 */
private long checkAndGetTimeLocked(){
  final long actualSystemTime=System.currentTimeMillis();
  final long actualRealtime=SystemClock.elapsedRealtime();
  final long expectedSystemTime=(actualRealtime - mRealTimeSnapshot) + mSystemTimeSnapshot;
  boolean resetBeginIdleTime=false;
  if (Math.abs(actualSystemTime - expectedSystemTime) > TIME_CHANGE_THRESHOLD_MILLIS) {
    if (Math.abs(actualSystemTime - expectedSystemTime) > mAppIdleDurationMillis) {
      mScreenOnSystemTimeSnapshot=actualSystemTime;
      mScreenOnTime=0;
      resetBeginIdleTime=true;
    }
    final int userCount=mUserState.size();
    for (int i=0; i < userCount; i++) {
      final UserUsageStatsService service=mUserState.valueAt(i);
      service.onTimeChanged(expectedSystemTime,actualSystemTime,resetBeginIdleTime);
    }
    mRealTimeSnapshot=actualRealtime;
    mSystemTimeSnapshot=actualSystemTime;
  }
  return actualSystemTime;
}","/** 
 * This should be the only way to get the time from the system.
 */
private long checkAndGetTimeLocked(){
  final long actualSystemTime=System.currentTimeMillis();
  final long actualRealtime=SystemClock.elapsedRealtime();
  final long expectedSystemTime=(actualRealtime - mRealTimeSnapshot) + mSystemTimeSnapshot;
  boolean resetBeginIdleTime=false;
  if (Math.abs(actualSystemTime - expectedSystemTime) > TIME_CHANGE_THRESHOLD_MILLIS) {
    if (Math.abs(actualSystemTime - expectedSystemTime) > mAppIdleDurationMillis) {
      mScreenOnSystemTimeSnapshot=actualSystemTime;
      mScreenOnTime=0;
      resetBeginIdleTime=true;
    }
    final int userCount=mUserState.size();
    for (int i=0; i < userCount; i++) {
      final UserUsageStatsService service=mUserState.valueAt(i);
      service.onTimeChanged(expectedSystemTime,actualSystemTime,mScreenOnTime,resetBeginIdleTime);
    }
    mRealTimeSnapshot=actualRealtime;
    mSystemTimeSnapshot=actualSystemTime;
  }
  return actualSystemTime;
}",0.9929859719438878
192692,"void onTimeChanged(long oldTime,long newTime,boolean resetBeginIdleTime){
  persistActiveStats();
  mDatabase.onTimeChanged(newTime - oldTime);
  loadActiveStats(newTime,true,resetBeginIdleTime);
  refreshAppIdleRollingWindow(newTime);
}","void onTimeChanged(long oldTime,long newTime,long deviceUsageTime,boolean resetBeginIdleTime){
  persistActiveStats();
  mDatabase.onTimeChanged(newTime - oldTime);
  loadActiveStats(newTime,true,resetBeginIdleTime);
  refreshAppIdleRollingWindow(newTime,deviceUsageTime);
}",0.9275929549902152
192693,"/** 
 * If any of the apps don't have a last-used entry, add one now.
 * @param currentTimeMillis the current time
 * @param firstUpdate if it is the first update, touch all installed apps, otherwise onlytouch the system apps
 */
private void initializeDefaultsForApps(long currentTimeMillis,long deviceUsageTime,boolean firstUpdate){
  PackageManager pm=mContext.getPackageManager();
  List<PackageInfo> packages=pm.getInstalledPackages(0,mUserId);
  final int packageCount=packages.size();
  for (int i=0; i < packageCount; i++) {
    final PackageInfo pi=packages.get(i);
    String packageName=pi.packageName;
    if (pi.applicationInfo != null && (firstUpdate || pi.applicationInfo.isSystemApp()) && getBeginIdleTime(packageName) == -1) {
      for (      IntervalStats stats : mCurrentStats) {
        stats.update(packageName,currentTimeMillis,Event.SYSTEM_INTERACTION);
        stats.updateBeginIdleTime(packageName,deviceUsageTime);
        mStatsChanged=true;
      }
    }
  }
  persistActiveStats();
}","/** 
 * If any of the apps don't have a last-used entry, add one now.
 * @param currentTimeMillis the current time
 * @param firstUpdate if it is the first update, touch all installed apps, otherwise onlytouch the system apps
 */
private void initializeDefaultsForApps(long currentTimeMillis,long deviceUsageTime,boolean firstUpdate){
  PackageManager pm=mContext.getPackageManager();
  List<PackageInfo> packages=pm.getInstalledPackages(0,mUserId);
  final int packageCount=packages.size();
  for (int i=0; i < packageCount; i++) {
    final PackageInfo pi=packages.get(i);
    String packageName=pi.packageName;
    if (pi.applicationInfo != null && (firstUpdate || pi.applicationInfo.isSystemApp()) && getBeginIdleTime(packageName) == -1) {
      for (      IntervalStats stats : mCurrentStats) {
        stats.update(packageName,currentTimeMillis,Event.SYSTEM_INTERACTION);
        stats.updateBeginIdleTime(packageName,deviceUsageTime);
      }
      mAppIdleRollingWindow.update(packageName,currentTimeMillis,Event.SYSTEM_INTERACTION);
      mAppIdleRollingWindow.updateBeginIdleTime(packageName,deviceUsageTime);
      mStatsChanged=true;
    }
  }
  persistActiveStats();
}",0.8960802187784868
192694,"private static void mergePackageStats(IntervalStats dst,IntervalStats src){
  dst.endTime=Math.max(dst.endTime,src.endTime);
  final int srcPackageCount=src.packageStats.size();
  for (int i=0; i < srcPackageCount; i++) {
    final String packageName=src.packageStats.keyAt(i);
    final UsageStats srcStats=src.packageStats.valueAt(i);
    final UsageStats dstStats=dst.packageStats.get(packageName);
    if (dstStats == null) {
      dst.packageStats.put(packageName,new UsageStats(srcStats));
    }
 else {
      dstStats.add(src.packageStats.valueAt(i));
    }
  }
}","private static void mergePackageStats(IntervalStats dst,IntervalStats src,final long deviceUsageTime){
  dst.endTime=Math.max(dst.endTime,src.endTime);
  final int srcPackageCount=src.packageStats.size();
  for (int i=0; i < srcPackageCount; i++) {
    final String packageName=src.packageStats.keyAt(i);
    final UsageStats srcStats=src.packageStats.valueAt(i);
    UsageStats dstStats=dst.packageStats.get(packageName);
    if (dstStats == null) {
      dstStats=new UsageStats(srcStats);
      dst.packageStats.put(packageName,dstStats);
    }
 else {
      dstStats.add(src.packageStats.valueAt(i));
    }
    if (dstStats.mBeginIdleTime > deviceUsageTime) {
      dstStats.mBeginIdleTime=deviceUsageTime;
    }
  }
}",0.6408668730650154
192695,"@Override public void combine(IntervalStats stats,boolean mutable,List<IntervalStats> accumulatedResult){
  IntervalStats accum;
  if (accumulatedResult.isEmpty()) {
    accum=new IntervalStats();
    accum.beginTime=stats.beginTime;
    accumulatedResult.add(accum);
  }
 else {
    accum=accumulatedResult.get(0);
  }
  mergePackageStats(accum,stats);
}","@Override public void combine(IntervalStats stats,boolean mutable,List<IntervalStats> accumulatedResult){
  IntervalStats accum;
  if (accumulatedResult.isEmpty()) {
    accum=new IntervalStats();
    accum.beginTime=stats.beginTime;
    accumulatedResult.add(accum);
  }
 else {
    accum=accumulatedResult.get(0);
  }
  mergePackageStats(accum,stats,deviceUsageTime);
}",0.977961432506887
192696,"void init(final long currentTimeMillis,final long deviceUsageTime){
  mDatabase.init(currentTimeMillis);
  int nullCount=0;
  for (int i=0; i < mCurrentStats.length; i++) {
    mCurrentStats[i]=mDatabase.getLatestUsageStats(i);
    if (mCurrentStats[i] == null) {
      nullCount++;
    }
  }
  if (nullCount > 0) {
    if (nullCount != mCurrentStats.length) {
      Slog.w(TAG,mLogPrefix + ""String_Node_Str"");
    }
 else {
    }
    loadActiveStats(currentTimeMillis,false,false);
  }
 else {
    mDailyExpiryDate.setTimeInMillis(mCurrentStats[UsageStatsManager.INTERVAL_DAILY].beginTime);
    mDailyExpiryDate.addDays(1);
    mDailyExpiryDate.truncateToDay();
    Slog.i(TAG,mLogPrefix + ""String_Node_Str"" + sDateFormat.format(mDailyExpiryDate.getTimeInMillis())+ ""String_Node_Str""+ mDailyExpiryDate.getTimeInMillis()+ ""String_Node_Str"");
  }
  for (  IntervalStats stat : mCurrentStats) {
    final int pkgCount=stat.packageStats.size();
    for (int i=0; i < pkgCount; i++) {
      UsageStats pkgStats=stat.packageStats.valueAt(i);
      if (pkgStats.mLastEvent == UsageEvents.Event.MOVE_TO_FOREGROUND || pkgStats.mLastEvent == UsageEvents.Event.CONTINUE_PREVIOUS_DAY) {
        stat.update(pkgStats.mPackageName,stat.lastTimeSaved,UsageEvents.Event.END_OF_DAY);
        notifyStatsChanged();
      }
    }
    stat.updateConfigurationStats(null,stat.lastTimeSaved);
  }
  if (mDatabase.isNewUpdate()) {
    initializeDefaultsForApps(currentTimeMillis,deviceUsageTime,mDatabase.isFirstUpdate());
  }
  refreshAppIdleRollingWindow(currentTimeMillis);
}","void init(final long currentTimeMillis,final long deviceUsageTime){
  mDatabase.init(currentTimeMillis);
  int nullCount=0;
  for (int i=0; i < mCurrentStats.length; i++) {
    mCurrentStats[i]=mDatabase.getLatestUsageStats(i);
    if (mCurrentStats[i] == null) {
      nullCount++;
    }
  }
  if (nullCount > 0) {
    if (nullCount != mCurrentStats.length) {
      Slog.w(TAG,mLogPrefix + ""String_Node_Str"");
    }
 else {
    }
    loadActiveStats(currentTimeMillis,false,false);
  }
 else {
    mDailyExpiryDate.setTimeInMillis(mCurrentStats[UsageStatsManager.INTERVAL_DAILY].beginTime);
    mDailyExpiryDate.addDays(1);
    mDailyExpiryDate.truncateToDay();
    Slog.i(TAG,mLogPrefix + ""String_Node_Str"" + sDateFormat.format(mDailyExpiryDate.getTimeInMillis())+ ""String_Node_Str""+ mDailyExpiryDate.getTimeInMillis()+ ""String_Node_Str"");
  }
  for (  IntervalStats stat : mCurrentStats) {
    final int pkgCount=stat.packageStats.size();
    for (int i=0; i < pkgCount; i++) {
      UsageStats pkgStats=stat.packageStats.valueAt(i);
      if (pkgStats.mLastEvent == UsageEvents.Event.MOVE_TO_FOREGROUND || pkgStats.mLastEvent == UsageEvents.Event.CONTINUE_PREVIOUS_DAY) {
        stat.update(pkgStats.mPackageName,stat.lastTimeSaved,UsageEvents.Event.END_OF_DAY);
        notifyStatsChanged();
      }
    }
    stat.updateConfigurationStats(null,stat.lastTimeSaved);
  }
  refreshAppIdleRollingWindow(currentTimeMillis,deviceUsageTime);
  if (mDatabase.isNewUpdate()) {
    initializeDefaultsForApps(currentTimeMillis,deviceUsageTime,mDatabase.isFirstUpdate());
  }
}",0.962915601023018
192697,"void reportEvent(UsageEvents.Event event,long deviceUsageTime){
  if (DEBUG) {
    Slog.d(TAG,mLogPrefix + ""String_Node_Str"" + event.mPackage+ ""String_Node_Str""+ event.mTimeStamp+ ""String_Node_Str""+ eventToString(event.mEventType));
  }
  if (event.mTimeStamp >= mDailyExpiryDate.getTimeInMillis()) {
    rolloverStats(event.mTimeStamp);
  }
  final IntervalStats currentDailyStats=mCurrentStats[UsageStatsManager.INTERVAL_DAILY];
  final Configuration newFullConfig=event.mConfiguration;
  if (event.mEventType == UsageEvents.Event.CONFIGURATION_CHANGE && currentDailyStats.activeConfiguration != null) {
    event.mConfiguration=Configuration.generateDelta(currentDailyStats.activeConfiguration,newFullConfig);
  }
  if (currentDailyStats.events == null) {
    currentDailyStats.events=new TimeSparseArray<>();
  }
  if (event.mEventType != UsageEvents.Event.SYSTEM_INTERACTION) {
    currentDailyStats.events.put(event.mTimeStamp,event);
  }
  for (  IntervalStats stats : mCurrentStats) {
    if (event.mEventType == UsageEvents.Event.CONFIGURATION_CHANGE) {
      stats.updateConfigurationStats(newFullConfig,event.mTimeStamp);
    }
 else {
      stats.update(event.mPackage,event.mTimeStamp,event.mEventType);
      stats.updateBeginIdleTime(event.mPackage,deviceUsageTime);
    }
  }
  if (event.mEventType != Event.CONFIGURATION_CHANGE) {
    mAppIdleRollingWindow.update(event.mPackage,event.mTimeStamp,event.mEventType);
    mAppIdleRollingWindow.updateBeginIdleTime(event.mPackage,deviceUsageTime);
  }
  notifyStatsChanged();
}","void reportEvent(UsageEvents.Event event,long deviceUsageTime){
  if (DEBUG) {
    Slog.d(TAG,mLogPrefix + ""String_Node_Str"" + event.mPackage+ ""String_Node_Str""+ event.mTimeStamp+ ""String_Node_Str""+ eventToString(event.mEventType));
  }
  if (event.mTimeStamp >= mDailyExpiryDate.getTimeInMillis()) {
    rolloverStats(event.mTimeStamp,deviceUsageTime);
  }
  final IntervalStats currentDailyStats=mCurrentStats[UsageStatsManager.INTERVAL_DAILY];
  final Configuration newFullConfig=event.mConfiguration;
  if (event.mEventType == UsageEvents.Event.CONFIGURATION_CHANGE && currentDailyStats.activeConfiguration != null) {
    event.mConfiguration=Configuration.generateDelta(currentDailyStats.activeConfiguration,newFullConfig);
  }
  if (currentDailyStats.events == null) {
    currentDailyStats.events=new TimeSparseArray<>();
  }
  if (event.mEventType != UsageEvents.Event.SYSTEM_INTERACTION) {
    currentDailyStats.events.put(event.mTimeStamp,event);
  }
  for (  IntervalStats stats : mCurrentStats) {
    if (event.mEventType == UsageEvents.Event.CONFIGURATION_CHANGE) {
      stats.updateConfigurationStats(newFullConfig,event.mTimeStamp);
    }
 else {
      stats.update(event.mPackage,event.mTimeStamp,event.mEventType);
      stats.updateBeginIdleTime(event.mPackage,deviceUsageTime);
    }
  }
  if (event.mEventType != Event.CONFIGURATION_CHANGE) {
    mAppIdleRollingWindow.update(event.mPackage,event.mTimeStamp,event.mEventType);
    mAppIdleRollingWindow.updateBeginIdleTime(event.mPackage,deviceUsageTime);
  }
  notifyStatsChanged();
}",0.9948320413436692
192698,"/** 
 * App idle operates on a rolling window of time. When we roll over time, we end up with a period of time where in-memory stats are empty and we don't hit the disk for older stats for performance reasons. Suddenly all apps will become idle. Instead, at times we do a deep query to find all the apps that have run in the past few days and keep the cached data up to date.
 * @param currentTimeMillis
 */
void refreshAppIdleRollingWindow(long currentTimeMillis){
  List<IntervalStats> stats=mDatabase.queryUsageStats(UsageStatsManager.INTERVAL_DAILY,currentTimeMillis - (1000 * 60 * 60* 24* 2),currentTimeMillis,sPackageStatsMerger);
  if (stats == null || stats.isEmpty()) {
    mAppIdleRollingWindow=new IntervalStats();
    mergePackageStats(mAppIdleRollingWindow,mCurrentStats[UsageStatsManager.INTERVAL_YEARLY]);
  }
 else {
    mAppIdleRollingWindow=stats.get(0);
  }
}","/** 
 * App idle operates on a rolling window of time. When we roll over time, we end up with a period of time where in-memory stats are empty and we don't hit the disk for older stats for performance reasons. Suddenly all apps will become idle. Instead, at times we do a deep query to find all the apps that have run in the past few days and keep the cached data up to date.
 * @param currentTimeMillis
 */
void refreshAppIdleRollingWindow(final long currentTimeMillis,final long deviceUsageTime){
  List<IntervalStats> stats=mDatabase.queryUsageStats(UsageStatsManager.INTERVAL_DAILY,currentTimeMillis - (1000 * 60 * 60* 24* 2),currentTimeMillis,new StatCombiner<IntervalStats>(){
    @Override public void combine(    IntervalStats stats,    boolean mutable,    List<IntervalStats> accumulatedResult){
      IntervalStats accum;
      if (accumulatedResult.isEmpty()) {
        accum=new IntervalStats();
        accum.beginTime=stats.beginTime;
        accumulatedResult.add(accum);
      }
 else {
        accum=accumulatedResult.get(0);
      }
      mergePackageStats(accum,stats,deviceUsageTime);
    }
  }
);
  if (stats == null || stats.isEmpty()) {
    mAppIdleRollingWindow=new IntervalStats();
    mergePackageStats(mAppIdleRollingWindow,mCurrentStats[UsageStatsManager.INTERVAL_YEARLY],deviceUsageTime);
  }
 else {
    mAppIdleRollingWindow=stats.get(0);
  }
}",0.7731913004882379
192699,"private void rolloverStats(final long currentTimeMillis){
  final long startTime=SystemClock.elapsedRealtime();
  Slog.i(TAG,mLogPrefix + ""String_Node_Str"");
  final Configuration previousConfig=mCurrentStats[UsageStatsManager.INTERVAL_DAILY].activeConfiguration;
  ArraySet<String> continuePreviousDay=new ArraySet<>();
  for (  IntervalStats stat : mCurrentStats) {
    final int pkgCount=stat.packageStats.size();
    for (int i=0; i < pkgCount; i++) {
      UsageStats pkgStats=stat.packageStats.valueAt(i);
      if (pkgStats.mLastEvent == UsageEvents.Event.MOVE_TO_FOREGROUND || pkgStats.mLastEvent == UsageEvents.Event.CONTINUE_PREVIOUS_DAY) {
        continuePreviousDay.add(pkgStats.mPackageName);
        stat.update(pkgStats.mPackageName,mDailyExpiryDate.getTimeInMillis() - 1,UsageEvents.Event.END_OF_DAY);
        notifyStatsChanged();
      }
    }
    stat.updateConfigurationStats(null,mDailyExpiryDate.getTimeInMillis() - 1);
  }
  persistActiveStats();
  mDatabase.prune(currentTimeMillis);
  loadActiveStats(currentTimeMillis,false,false);
  final int continueCount=continuePreviousDay.size();
  for (int i=0; i < continueCount; i++) {
    String name=continuePreviousDay.valueAt(i);
    final long beginTime=mCurrentStats[UsageStatsManager.INTERVAL_DAILY].beginTime;
    for (    IntervalStats stat : mCurrentStats) {
      stat.update(name,beginTime,UsageEvents.Event.CONTINUE_PREVIOUS_DAY);
      stat.updateConfigurationStats(previousConfig,beginTime);
      notifyStatsChanged();
    }
  }
  persistActiveStats();
  refreshAppIdleRollingWindow(currentTimeMillis);
  final long totalTime=SystemClock.elapsedRealtime() - startTime;
  Slog.i(TAG,mLogPrefix + ""String_Node_Str"" + totalTime+ ""String_Node_Str"");
}","private void rolloverStats(final long currentTimeMillis,final long deviceUsageTime){
  final long startTime=SystemClock.elapsedRealtime();
  Slog.i(TAG,mLogPrefix + ""String_Node_Str"");
  final Configuration previousConfig=mCurrentStats[UsageStatsManager.INTERVAL_DAILY].activeConfiguration;
  ArraySet<String> continuePreviousDay=new ArraySet<>();
  for (  IntervalStats stat : mCurrentStats) {
    final int pkgCount=stat.packageStats.size();
    for (int i=0; i < pkgCount; i++) {
      UsageStats pkgStats=stat.packageStats.valueAt(i);
      if (pkgStats.mLastEvent == UsageEvents.Event.MOVE_TO_FOREGROUND || pkgStats.mLastEvent == UsageEvents.Event.CONTINUE_PREVIOUS_DAY) {
        continuePreviousDay.add(pkgStats.mPackageName);
        stat.update(pkgStats.mPackageName,mDailyExpiryDate.getTimeInMillis() - 1,UsageEvents.Event.END_OF_DAY);
        notifyStatsChanged();
      }
    }
    stat.updateConfigurationStats(null,mDailyExpiryDate.getTimeInMillis() - 1);
  }
  persistActiveStats();
  mDatabase.prune(currentTimeMillis);
  loadActiveStats(currentTimeMillis,false,false);
  final int continueCount=continuePreviousDay.size();
  for (int i=0; i < continueCount; i++) {
    String name=continuePreviousDay.valueAt(i);
    final long beginTime=mCurrentStats[UsageStatsManager.INTERVAL_DAILY].beginTime;
    for (    IntervalStats stat : mCurrentStats) {
      stat.update(name,beginTime,UsageEvents.Event.CONTINUE_PREVIOUS_DAY);
      stat.updateConfigurationStats(previousConfig,beginTime);
      notifyStatsChanged();
    }
  }
  persistActiveStats();
  refreshAppIdleRollingWindow(currentTimeMillis,deviceUsageTime);
  final long totalTime=SystemClock.elapsedRealtime() - startTime;
  Slog.i(TAG,mLogPrefix + ""String_Node_Str"" + totalTime+ ""String_Node_Str"");
}",0.9877388080980896
192700,"@Override public X509Certificate[] getAcceptedIssuers(){
  return mDelegate.getAcceptedIssuers();
}","@Override public X509Certificate[] getAcceptedIssuers(){
synchronized (mIssuersLock) {
    if (mIssuers == null) {
      Set<TrustAnchor> anchors=mNetworkSecurityConfig.getTrustAnchors();
      X509Certificate[] issuers=new X509Certificate[anchors.size()];
      int i=0;
      for (      TrustAnchor anchor : anchors) {
        issuers[i++]=anchor.certificate;
      }
      mIssuers=issuers;
    }
    return mIssuers.clone();
  }
}",0.273921200750469
192701,"@Override public X509Certificate[] getAcceptedIssuers(){
  return mDelegate.getAcceptedIssuers();
}","@Override public X509Certificate[] getAcceptedIssuers(){
synchronized (mIssuersLock) {
    if (mIssuers == null) {
      Set<TrustAnchor> anchors=mNetworkSecurityConfig.getTrustAnchors();
      X509Certificate[] issuers=new X509Certificate[anchors.size()];
      int i=0;
      for (      TrustAnchor anchor : anchors) {
        issuers[i++]=anchor.certificate;
      }
      mIssuers=issuers;
    }
    return mIssuers.clone();
  }
}",0.273921200750469
192702,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  final View view=inflater.inflate(R.layout.fragment_directory,container,false);
  mMessageBar=MessageBar.create(getChildFragmentManager());
  mProgressBar=view.findViewById(R.id.progressbar);
  mEmptyView=view.findViewById(android.R.id.empty);
  mRecView=(RecyclerView)view.findViewById(R.id.dir_list);
  mRecView.setRecyclerListener(new RecyclerListener(){
    @Override public void onViewRecycled(    ViewHolder holder){
      cancelThumbnailTask(holder.itemView);
    }
  }
);
  mRecView.setItemAnimator(new DirectoryItemAnimator(getActivity()));
  mRecView.setFocusable(false);
  if (DEBUG_ENABLE_DND) {
    setupDragAndDropOnDirectoryView(mRecView);
  }
  return view;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  final View view=inflater.inflate(R.layout.fragment_directory,container,false);
  mMessageBar=MessageBar.create(getChildFragmentManager());
  mProgressBar=view.findViewById(R.id.progressbar);
  mEmptyView=view.findViewById(android.R.id.empty);
  mRecView=(RecyclerView)view.findViewById(R.id.dir_list);
  mRecView.setRecyclerListener(new RecyclerListener(){
    @Override public void onViewRecycled(    ViewHolder holder){
      cancelThumbnailTask(holder.itemView);
    }
  }
);
  mRecView.setItemAnimator(new DirectoryItemAnimator(getActivity()));
  if (DEBUG_ENABLE_DND) {
    setupDragAndDropOnDirectoryView(mRecView);
  }
  return view;
}",0.9791395045632334
192703,"/** 
 * Finds the destination position where the focus should land for a given navigation event.
 * @param view The view that received the event.
 * @param keyCode The key code for the event.
 * @param event
 * @return The adapter position of the destination item. Could be RecyclerView.NO_POSITION.
 */
private int findTargetPosition(View view,int keyCode,KeyEvent event){
switch (keyCode) {
case KeyEvent.KEYCODE_MOVE_HOME:
    return 0;
case KeyEvent.KEYCODE_MOVE_END:
  return mAdapter.getItemCount() - 1;
case KeyEvent.KEYCODE_PAGE_UP:
case KeyEvent.KEYCODE_PAGE_DOWN:
return findPagedTargetPosition(view,keyCode,event);
}
int searchDir=-1;
switch (keyCode) {
case KeyEvent.KEYCODE_DPAD_UP:
searchDir=View.FOCUS_UP;
break;
case KeyEvent.KEYCODE_DPAD_DOWN:
searchDir=View.FOCUS_DOWN;
break;
}
if (inGridMode()) {
int currentPosition=mView.getChildAdapterPosition(view);
switch (keyCode) {
case KeyEvent.KEYCODE_DPAD_LEFT:
if (currentPosition > 0) {
searchDir=View.FOCUS_BACKWARD;
}
break;
case KeyEvent.KEYCODE_DPAD_RIGHT:
if (currentPosition < mAdapter.getItemCount() - 1) {
searchDir=View.FOCUS_FORWARD;
}
break;
}
}
if (searchDir != -1) {
View targetView=view.focusSearch(searchDir);
if (targetView != null) {
if (targetView.getParent() == mView) {
return mView.getChildAdapterPosition(targetView);
}
}
}
return RecyclerView.NO_POSITION;
}","/** 
 * Finds the destination position where the focus should land for a given navigation event.
 * @param view The view that received the event.
 * @param keyCode The key code for the event.
 * @param event
 * @return The adapter position of the destination item. Could be RecyclerView.NO_POSITION.
 */
private int findTargetPosition(View view,int keyCode,KeyEvent event){
switch (keyCode) {
case KeyEvent.KEYCODE_MOVE_HOME:
    return 0;
case KeyEvent.KEYCODE_MOVE_END:
  return mAdapter.getItemCount() - 1;
case KeyEvent.KEYCODE_PAGE_UP:
case KeyEvent.KEYCODE_PAGE_DOWN:
return findPagedTargetPosition(view,keyCode,event);
}
int searchDir=-1;
switch (keyCode) {
case KeyEvent.KEYCODE_DPAD_UP:
searchDir=View.FOCUS_UP;
break;
case KeyEvent.KEYCODE_DPAD_DOWN:
searchDir=View.FOCUS_DOWN;
break;
}
if (inGridMode()) {
int currentPosition=mView.getChildAdapterPosition(view);
switch (keyCode) {
case KeyEvent.KEYCODE_DPAD_LEFT:
if (currentPosition > 0) {
searchDir=View.FOCUS_BACKWARD;
}
break;
case KeyEvent.KEYCODE_DPAD_RIGHT:
if (currentPosition < mAdapter.getItemCount() - 1) {
searchDir=View.FOCUS_FORWARD;
}
break;
}
}
if (searchDir != -1) {
mView.setFocusable(false);
View targetView=view.focusSearch(searchDir);
mView.setFocusable(true);
if (targetView != null) {
if (targetView.getParent() == mView) {
return mView.getChildAdapterPosition(targetView);
}
}
}
return RecyclerView.NO_POSITION;
}",0.9806921675774136
192704,"@Override public X509Certificate[] getAcceptedIssuers(){
  return mDelegate.getAcceptedIssuers();
}","@Override public X509Certificate[] getAcceptedIssuers(){
synchronized (mIssuersLock) {
    if (mIssuers == null) {
      Set<TrustAnchor> anchors=mNetworkSecurityConfig.getTrustAnchors();
      X509Certificate[] issuers=new X509Certificate[anchors.size()];
      int i=0;
      for (      TrustAnchor anchor : anchors) {
        issuers[i++]=anchor.certificate;
      }
      mIssuers=issuers;
    }
    return mIssuers.clone();
  }
}",0.273921200750469
192705,"public void preloadRecents(){
  SystemServicesProxy ssp=Recents.getSystemServices();
  ActivityManager.RunningTaskInfo topTask=ssp.getTopMostTask();
  MutableBoolean topTaskHome=new MutableBoolean(true);
  RecentsTaskLoader loader=Recents.getTaskLoader();
  sInstanceLoadPlan=loader.createLoadPlan(mContext);
  if (topTask != null && !ssp.isRecentsTopMost(topTask,topTaskHome)) {
    sInstanceLoadPlan.preloadRawTasks(topTaskHome.value);
    loader.preloadTasks(sInstanceLoadPlan,topTask.id,topTaskHome.value);
    TaskStack stack=sInstanceLoadPlan.getTaskStack();
    if (stack.getTaskCount() > 0) {
      preCacheThumbnailTransitionBitmapAsync(topTask,stack,mDummyStackView);
    }
  }
}","public void preloadRecents(){
  SystemServicesProxy ssp=Recents.getSystemServices();
  ActivityManager.RunningTaskInfo topTask=ssp.getTopMostTask();
  MutableBoolean topTaskHome=new MutableBoolean(true);
  if (topTask != null && !ssp.isRecentsTopMost(topTask,topTaskHome)) {
    RecentsTaskLoader loader=Recents.getTaskLoader();
    sInstanceLoadPlan=loader.createLoadPlan(mContext);
    sInstanceLoadPlan.preloadRawTasks(topTaskHome.value);
    loader.preloadTasks(sInstanceLoadPlan,topTask.id,topTaskHome.value);
    TaskStack stack=sInstanceLoadPlan.getTaskStack();
    if (stack.getTaskCount() > 0) {
      preCacheThumbnailTransitionBitmapAsync(topTask,stack,mDummyStackView);
    }
  }
}",0.894356005788712
192706,"private void setTaskFromIntentActivity(ActivityRecord intentActivity){
  if ((mLaunchFlags & (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK)) == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK)) {
    mReuseTask=intentActivity.task;
    mReuseTask.performClearTaskLocked();
    mReuseTask.setIntent(mStartActivity);
  }
 else   if ((mLaunchFlags & FLAG_ACTIVITY_CLEAR_TOP) != 0 || mLaunchSingleInstance || mLaunchSingleTask) {
    ActivityRecord top=intentActivity.task.performClearTaskLocked(mStartActivity,mLaunchFlags);
    if (top == null) {
      mAddingToTask=true;
      mSourceRecord=intentActivity;
      final TaskRecord task=mSourceRecord.task;
      if (task != null && task.stack == null) {
        mTargetStack=computeStackFocus(mSourceRecord,false,null,mLaunchFlags,mOptions);
        mTargetStack.addTask(task,!mLaunchTaskBehind,""String_Node_Str"");
      }
    }
  }
 else   if (mStartActivity.realActivity.equals(intentActivity.task.realActivity)) {
    if (((mLaunchFlags & FLAG_ACTIVITY_SINGLE_TOP) != 0 || mLaunchSingleTop) && intentActivity.realActivity.equals(mStartActivity.realActivity)) {
      ActivityStack.logStartActivity(AM_NEW_INTENT,mStartActivity,intentActivity.task);
      if (intentActivity.frontOfTask) {
        intentActivity.task.setIntent(mStartActivity);
      }
      intentActivity.deliverNewIntentLocked(mCallingUid,mStartActivity.intent,mStartActivity.launchedFromPackage);
    }
 else     if (!mStartActivity.intent.filterEquals(intentActivity.task.intent)) {
      mAddingToTask=true;
      mSourceRecord=intentActivity;
    }
  }
 else   if ((mLaunchFlags & FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) == 0) {
    mAddingToTask=true;
    mSourceRecord=intentActivity;
  }
 else   if (!intentActivity.task.rootWasReset) {
    intentActivity.task.setIntent(mStartActivity);
  }
}","private void setTaskFromIntentActivity(ActivityRecord intentActivity){
  if ((mLaunchFlags & (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK)) == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK)) {
    mReuseTask=intentActivity.task;
    mReuseTask.performClearTaskLocked();
    mReuseTask.setIntent(mStartActivity);
  }
 else   if ((mLaunchFlags & FLAG_ACTIVITY_CLEAR_TOP) != 0 || mLaunchSingleInstance || mLaunchSingleTask) {
    ActivityRecord top=intentActivity.task.performClearTaskLocked(mStartActivity,mLaunchFlags);
    if (top == null) {
      mAddingToTask=true;
      mSourceRecord=intentActivity;
      final TaskRecord task=mSourceRecord.task;
      if (task != null && task.stack == null) {
        mTargetStack=computeStackFocus(mSourceRecord,false,null,mLaunchFlags,mOptions);
        mTargetStack.addTask(task,!mLaunchTaskBehind,""String_Node_Str"");
      }
    }
  }
 else   if (mStartActivity.realActivity.equals(intentActivity.task.realActivity)) {
    if (((mLaunchFlags & FLAG_ACTIVITY_SINGLE_TOP) != 0 || mLaunchSingleTop) && intentActivity.realActivity.equals(mStartActivity.realActivity)) {
      ActivityStack.logStartActivity(AM_NEW_INTENT,mStartActivity,intentActivity.task);
      if (intentActivity.frontOfTask) {
        intentActivity.task.setIntent(mStartActivity);
      }
      intentActivity.deliverNewIntentLocked(mCallingUid,mStartActivity.intent,mStartActivity.launchedFromPackage);
    }
 else     if (!mStartActivity.intent.filterEquals(intentActivity.intent)) {
      mAddingToTask=true;
      mSourceRecord=intentActivity;
    }
  }
 else   if ((mLaunchFlags & FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) == 0) {
    mAddingToTask=true;
    mSourceRecord=intentActivity;
  }
 else   if (!intentActivity.task.rootWasReset) {
    intentActivity.task.setIntent(mStartActivity);
  }
}",0.9986282578875172
192707,"private void setTaskFromIntentActivity(ActivityRecord intentActivity){
  if ((mLaunchFlags & (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK)) == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK)) {
    mReuseTask=intentActivity.task;
    mReuseTask.performClearTaskLocked();
    mReuseTask.setIntent(mStartActivity);
  }
 else   if ((mLaunchFlags & FLAG_ACTIVITY_CLEAR_TOP) != 0 || mLaunchSingleInstance || mLaunchSingleTask) {
    ActivityRecord top=intentActivity.task.performClearTaskLocked(mStartActivity,mLaunchFlags);
    if (top == null) {
      mAddingToTask=true;
      mSourceRecord=intentActivity;
      final TaskRecord task=mSourceRecord.task;
      if (task != null && task.stack == null) {
        mTargetStack=computeStackFocus(mSourceRecord,false,null,mLaunchFlags,mOptions);
        mTargetStack.addTask(task,!mLaunchTaskBehind,""String_Node_Str"");
      }
    }
  }
 else   if (mStartActivity.realActivity.equals(intentActivity.task.realActivity)) {
    if (((mLaunchFlags & FLAG_ACTIVITY_SINGLE_TOP) != 0 || mLaunchSingleTop) && intentActivity.realActivity.equals(mStartActivity.realActivity)) {
      ActivityStack.logStartActivity(AM_NEW_INTENT,mStartActivity,intentActivity.task);
      if (intentActivity.frontOfTask) {
        intentActivity.task.setIntent(mStartActivity);
      }
      intentActivity.deliverNewIntentLocked(mCallingUid,mStartActivity.intent,mStartActivity.launchedFromPackage);
    }
 else     if (!mStartActivity.intent.filterEquals(intentActivity.task.intent)) {
      mAddingToTask=true;
      mSourceRecord=intentActivity;
    }
  }
 else   if ((mLaunchFlags & FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) == 0) {
    mAddingToTask=true;
    mSourceRecord=intentActivity;
  }
 else   if (!intentActivity.task.rootWasReset) {
    intentActivity.task.setIntent(mStartActivity);
  }
}","private void setTaskFromIntentActivity(ActivityRecord intentActivity){
  if ((mLaunchFlags & (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK)) == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK)) {
    mReuseTask=intentActivity.task;
    mReuseTask.performClearTaskLocked();
    mReuseTask.setIntent(mStartActivity);
  }
 else   if ((mLaunchFlags & FLAG_ACTIVITY_CLEAR_TOP) != 0 || mLaunchSingleInstance || mLaunchSingleTask) {
    ActivityRecord top=intentActivity.task.performClearTaskLocked(mStartActivity,mLaunchFlags);
    if (top == null) {
      mAddingToTask=true;
      mSourceRecord=intentActivity;
      final TaskRecord task=mSourceRecord.task;
      if (task != null && task.stack == null) {
        mTargetStack=computeStackFocus(mSourceRecord,false,null,mLaunchFlags,mOptions);
        mTargetStack.addTask(task,!mLaunchTaskBehind,""String_Node_Str"");
      }
    }
  }
 else   if (mStartActivity.realActivity.equals(intentActivity.task.realActivity)) {
    if (((mLaunchFlags & FLAG_ACTIVITY_SINGLE_TOP) != 0 || mLaunchSingleTop) && intentActivity.realActivity.equals(mStartActivity.realActivity)) {
      ActivityStack.logStartActivity(AM_NEW_INTENT,mStartActivity,intentActivity.task);
      if (intentActivity.frontOfTask) {
        intentActivity.task.setIntent(mStartActivity);
      }
      intentActivity.deliverNewIntentLocked(mCallingUid,mStartActivity.intent,mStartActivity.launchedFromPackage);
    }
 else     if (!mStartActivity.intent.filterEquals(intentActivity.intent)) {
      mAddingToTask=true;
      mSourceRecord=intentActivity;
    }
  }
 else   if ((mLaunchFlags & FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) == 0) {
    mAddingToTask=true;
    mSourceRecord=intentActivity;
  }
 else   if (!intentActivity.task.rootWasReset) {
    intentActivity.task.setIntent(mStartActivity);
  }
}",0.9986282578875172
192708,"public final int copyFrom(LayoutParams o){
  int changes=0;
  if (width != o.width) {
    width=o.width;
    changes|=LAYOUT_CHANGED;
  }
  if (height != o.height) {
    height=o.height;
    changes|=LAYOUT_CHANGED;
  }
  if (x != o.x) {
    x=o.x;
    changes|=LAYOUT_CHANGED;
  }
  if (y != o.y) {
    y=o.y;
    changes|=LAYOUT_CHANGED;
  }
  if (horizontalWeight != o.horizontalWeight) {
    horizontalWeight=o.horizontalWeight;
    changes|=LAYOUT_CHANGED;
  }
  if (verticalWeight != o.verticalWeight) {
    verticalWeight=o.verticalWeight;
    changes|=LAYOUT_CHANGED;
  }
  if (horizontalMargin != o.horizontalMargin) {
    horizontalMargin=o.horizontalMargin;
    changes|=LAYOUT_CHANGED;
  }
  if (verticalMargin != o.verticalMargin) {
    verticalMargin=o.verticalMargin;
    changes|=LAYOUT_CHANGED;
  }
  if (type != o.type) {
    type=o.type;
    changes|=TYPE_CHANGED;
  }
  if (flags != o.flags) {
    final int diff=flags ^ o.flags;
    if ((diff & (FLAG_TRANSLUCENT_STATUS | FLAG_TRANSLUCENT_NAVIGATION)) != 0) {
      changes|=TRANSLUCENT_FLAGS_CHANGED;
    }
    flags=o.flags;
    changes|=FLAGS_CHANGED;
  }
  if (privateFlags != o.privateFlags) {
    privateFlags=o.privateFlags;
    changes|=PRIVATE_FLAGS_CHANGED;
  }
  if (softInputMode != o.softInputMode) {
    softInputMode=o.softInputMode;
    changes|=SOFT_INPUT_MODE_CHANGED;
  }
  if (gravity != o.gravity) {
    gravity=o.gravity;
    changes|=LAYOUT_CHANGED;
  }
  if (format != o.format) {
    format=o.format;
    changes|=FORMAT_CHANGED;
  }
  if (windowAnimations != o.windowAnimations) {
    windowAnimations=o.windowAnimations;
    changes|=ANIMATION_CHANGED;
  }
  if (token == null) {
    token=o.token;
  }
  if (packageName == null) {
    packageName=o.packageName;
  }
  if (!mTitle.equals(o.mTitle)) {
    mTitle=o.mTitle;
    changes|=TITLE_CHANGED;
  }
  if (alpha != o.alpha) {
    alpha=o.alpha;
    changes|=ALPHA_CHANGED;
  }
  if (dimAmount != o.dimAmount) {
    dimAmount=o.dimAmount;
    changes|=DIM_AMOUNT_CHANGED;
  }
  if (screenBrightness != o.screenBrightness) {
    screenBrightness=o.screenBrightness;
    changes|=SCREEN_BRIGHTNESS_CHANGED;
  }
  if (buttonBrightness != o.buttonBrightness) {
    buttonBrightness=o.buttonBrightness;
    changes|=BUTTON_BRIGHTNESS_CHANGED;
  }
  if (rotationAnimation != o.rotationAnimation) {
    rotationAnimation=o.rotationAnimation;
    changes|=ROTATION_ANIMATION_CHANGED;
  }
  if (screenOrientation != o.screenOrientation) {
    screenOrientation=o.screenOrientation;
    changes|=SCREEN_ORIENTATION_CHANGED;
  }
  if (preferredRefreshRate != o.preferredRefreshRate) {
    preferredRefreshRate=o.preferredRefreshRate;
    changes|=PREFERRED_REFRESH_RATE_CHANGED;
  }
  if (preferredDisplayModeId != o.preferredDisplayModeId) {
    preferredDisplayModeId=o.preferredDisplayModeId;
    changes|=PREFERRED_DISPLAY_MODE_ID;
  }
  if (systemUiVisibility != o.systemUiVisibility || subtreeSystemUiVisibility != o.subtreeSystemUiVisibility) {
    systemUiVisibility=o.systemUiVisibility;
    subtreeSystemUiVisibility=o.subtreeSystemUiVisibility;
    changes|=SYSTEM_UI_VISIBILITY_CHANGED;
  }
  if (hasSystemUiListeners != o.hasSystemUiListeners) {
    hasSystemUiListeners=o.hasSystemUiListeners;
    changes|=SYSTEM_UI_LISTENER_CHANGED;
  }
  if (inputFeatures != o.inputFeatures) {
    inputFeatures=o.inputFeatures;
    changes|=INPUT_FEATURES_CHANGED;
  }
  if (userActivityTimeout != o.userActivityTimeout) {
    userActivityTimeout=o.userActivityTimeout;
    changes|=USER_ACTIVITY_TIMEOUT_CHANGED;
  }
  if (!surfaceInsets.equals(o.surfaceInsets)) {
    surfaceInsets.set(o.surfaceInsets);
    changes|=SURFACE_INSETS_CHANGED;
  }
  if (hasManualSurfaceInsets != o.hasManualSurfaceInsets) {
    hasManualSurfaceInsets=o.hasManualSurfaceInsets;
    changes|=SURFACE_INSETS_CHANGED;
  }
  if (needsMenuKey != o.needsMenuKey) {
    needsMenuKey=o.needsMenuKey;
    changes|=NEEDS_MENU_KEY_CHANGED;
  }
  return changes;
}","public final int copyFrom(LayoutParams o){
  int changes=0;
  if (width != o.width) {
    width=o.width;
    changes|=LAYOUT_CHANGED;
  }
  if (height != o.height) {
    height=o.height;
    changes|=LAYOUT_CHANGED;
  }
  if (x != o.x) {
    x=o.x;
    changes|=LAYOUT_CHANGED;
  }
  if (y != o.y) {
    y=o.y;
    changes|=LAYOUT_CHANGED;
  }
  if (horizontalWeight != o.horizontalWeight) {
    horizontalWeight=o.horizontalWeight;
    changes|=LAYOUT_CHANGED;
  }
  if (verticalWeight != o.verticalWeight) {
    verticalWeight=o.verticalWeight;
    changes|=LAYOUT_CHANGED;
  }
  if (horizontalMargin != o.horizontalMargin) {
    horizontalMargin=o.horizontalMargin;
    changes|=LAYOUT_CHANGED;
  }
  if (verticalMargin != o.verticalMargin) {
    verticalMargin=o.verticalMargin;
    changes|=LAYOUT_CHANGED;
  }
  if (type != o.type) {
    type=o.type;
    changes|=TYPE_CHANGED;
  }
  if (flags != o.flags) {
    final int diff=flags ^ o.flags;
    if ((diff & (FLAG_TRANSLUCENT_STATUS | FLAG_TRANSLUCENT_NAVIGATION)) != 0) {
      changes|=TRANSLUCENT_FLAGS_CHANGED;
    }
    flags=o.flags;
    changes|=FLAGS_CHANGED;
  }
  if (privateFlags != o.privateFlags) {
    privateFlags=o.privateFlags;
    changes|=PRIVATE_FLAGS_CHANGED;
  }
  if (softInputMode != o.softInputMode) {
    softInputMode=o.softInputMode;
    changes|=SOFT_INPUT_MODE_CHANGED;
  }
  if (gravity != o.gravity) {
    gravity=o.gravity;
    changes|=LAYOUT_CHANGED;
  }
  if (format != o.format) {
    format=o.format;
    changes|=FORMAT_CHANGED;
  }
  if (windowAnimations != o.windowAnimations) {
    windowAnimations=o.windowAnimations;
    changes|=ANIMATION_CHANGED;
  }
  if (token == null) {
    token=o.token;
  }
  if (packageName == null) {
    packageName=o.packageName;
  }
  if (o.mTitle != null) {
    mTitle=o.mTitle;
    changes|=TITLE_CHANGED;
  }
  if (alpha != o.alpha) {
    alpha=o.alpha;
    changes|=ALPHA_CHANGED;
  }
  if (dimAmount != o.dimAmount) {
    dimAmount=o.dimAmount;
    changes|=DIM_AMOUNT_CHANGED;
  }
  if (screenBrightness != o.screenBrightness) {
    screenBrightness=o.screenBrightness;
    changes|=SCREEN_BRIGHTNESS_CHANGED;
  }
  if (buttonBrightness != o.buttonBrightness) {
    buttonBrightness=o.buttonBrightness;
    changes|=BUTTON_BRIGHTNESS_CHANGED;
  }
  if (rotationAnimation != o.rotationAnimation) {
    rotationAnimation=o.rotationAnimation;
    changes|=ROTATION_ANIMATION_CHANGED;
  }
  if (screenOrientation != o.screenOrientation) {
    screenOrientation=o.screenOrientation;
    changes|=SCREEN_ORIENTATION_CHANGED;
  }
  if (preferredRefreshRate != o.preferredRefreshRate) {
    preferredRefreshRate=o.preferredRefreshRate;
    changes|=PREFERRED_REFRESH_RATE_CHANGED;
  }
  if (preferredDisplayModeId != o.preferredDisplayModeId) {
    preferredDisplayModeId=o.preferredDisplayModeId;
    changes|=PREFERRED_DISPLAY_MODE_ID;
  }
  if (systemUiVisibility != o.systemUiVisibility || subtreeSystemUiVisibility != o.subtreeSystemUiVisibility) {
    systemUiVisibility=o.systemUiVisibility;
    subtreeSystemUiVisibility=o.subtreeSystemUiVisibility;
    changes|=SYSTEM_UI_VISIBILITY_CHANGED;
  }
  if (hasSystemUiListeners != o.hasSystemUiListeners) {
    hasSystemUiListeners=o.hasSystemUiListeners;
    changes|=SYSTEM_UI_LISTENER_CHANGED;
  }
  if (inputFeatures != o.inputFeatures) {
    inputFeatures=o.inputFeatures;
    changes|=INPUT_FEATURES_CHANGED;
  }
  if (userActivityTimeout != o.userActivityTimeout) {
    userActivityTimeout=o.userActivityTimeout;
    changes|=USER_ACTIVITY_TIMEOUT_CHANGED;
  }
  if (!surfaceInsets.equals(o.surfaceInsets)) {
    surfaceInsets.set(o.surfaceInsets);
    changes|=SURFACE_INSETS_CHANGED;
  }
  if (hasManualSurfaceInsets != o.hasManualSurfaceInsets) {
    hasManualSurfaceInsets=o.hasManualSurfaceInsets;
    changes|=SURFACE_INSETS_CHANGED;
  }
  if (needsMenuKey != o.needsMenuKey) {
    needsMenuKey=o.needsMenuKey;
    changes|=NEEDS_MENU_KEY_CHANGED;
  }
  return changes;
}",0.9952165156092648
192709,"public final CharSequence getTitle(){
  return mTitle;
}","public final CharSequence getTitle(){
  return mTitle != null ? mTitle : ""String_Node_Str"";
}",0.7516778523489933
192710,"private void readPermissionsFromXml(File permFile,int permissionFlag){
  FileReader permReader=null;
  try {
    permReader=new FileReader(permFile);
  }
 catch (  FileNotFoundException e) {
    Slog.w(TAG,""String_Node_Str"" + permFile);
    return;
  }
  final boolean lowRam=ActivityManager.isLowRamDeviceStatic();
  try {
    XmlPullParser parser=Xml.newPullParser();
    parser.setInput(permReader);
    int type;
    while ((type=parser.next()) != parser.START_TAG && type != parser.END_DOCUMENT) {
      ;
    }
    if (type != parser.START_TAG) {
      throw new XmlPullParserException(""String_Node_Str"");
    }
    if (!parser.getName().equals(""String_Node_Str"") && !parser.getName().equals(""String_Node_Str"")) {
      throw new XmlPullParserException(""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getName()+ ""String_Node_Str"");
    }
    boolean allowAll=permissionFlag == ALLOW_ALL;
    boolean allowLibs=(permissionFlag & ALLOW_LIBS) != 0;
    boolean allowFeatures=(permissionFlag & ALLOW_FEATURES) != 0;
    boolean allowPermissions=(permissionFlag & ALLOW_PERMISSIONS) != 0;
    boolean allowAppConfigs=(permissionFlag & ALLOW_APP_CONFIGS) != 0;
    while (true) {
      XmlUtils.nextElement(parser);
      if (parser.getEventType() == XmlPullParser.END_DOCUMENT) {
        break;
      }
      String name=parser.getName();
      if (""String_Node_Str"".equals(name) && allowAll) {
        String gidStr=parser.getAttributeValue(null,""String_Node_Str"");
        if (gidStr != null) {
          int gid=android.os.Process.getGidForName(gidStr);
          mGlobalGids=appendInt(mGlobalGids,gid);
        }
 else {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else       if (""String_Node_Str"".equals(name) && allowPermissions) {
        String perm=parser.getAttributeValue(null,""String_Node_Str"");
        if (perm == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        perm=perm.intern();
        readPermission(parser,perm);
      }
 else       if (""String_Node_Str"".equals(name) && allowPermissions) {
        String perm=parser.getAttributeValue(null,""String_Node_Str"");
        if (perm == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        String uidStr=parser.getAttributeValue(null,""String_Node_Str"");
        if (uidStr == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        int uid=Process.getUidForName(uidStr);
        if (uid < 0) {
          Slog.w(TAG,""String_Node_Str"" + uidStr + ""String_Node_Str""+ permFile+ ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        perm=perm.intern();
        ArraySet<String> perms=mSystemPermissions.get(uid);
        if (perms == null) {
          perms=new ArraySet<String>();
          mSystemPermissions.put(uid,perms);
        }
        perms.add(perm);
        XmlUtils.skipCurrentTag(parser);
      }
 else       if (""String_Node_Str"".equals(name) && allowLibs) {
        String lname=parser.getAttributeValue(null,""String_Node_Str"");
        String lfile=parser.getAttributeValue(null,""String_Node_Str"");
        if (lname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else         if (lfile == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          mSharedLibraries.put(lname,lfile);
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else       if (""String_Node_Str"".equals(name) && allowFeatures) {
        String fname=parser.getAttributeValue(null,""String_Node_Str"");
        int fversion=XmlUtils.readIntAttribute(null,""String_Node_Str"",0);
        boolean allowed;
        if (!lowRam) {
          allowed=true;
        }
 else {
          String notLowRam=parser.getAttributeValue(null,""String_Node_Str"");
          allowed=!""String_Node_Str"".equals(notLowRam);
        }
        if (fname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else         if (allowed) {
          addFeature(fname,fversion);
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else       if (""String_Node_Str"".equals(name) && allowFeatures) {
        String fname=parser.getAttributeValue(null,""String_Node_Str"");
        if (fname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          mUnavailableFeatures.add(fname);
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else       if (""String_Node_Str"".equals(name) && allowAll) {
        String pkgname=parser.getAttributeValue(null,""String_Node_Str"");
        if (pkgname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          mAllowInPowerSaveExceptIdle.add(pkgname);
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else       if (""String_Node_Str"".equals(name) && allowAll) {
        String pkgname=parser.getAttributeValue(null,""String_Node_Str"");
        if (pkgname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          mAllowInPowerSave.add(pkgname);
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else       if (""String_Node_Str"".equals(name) && allowAll) {
        String pkgname=parser.getAttributeValue(null,""String_Node_Str"");
        if (pkgname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          mFixedImeApps.add(pkgname);
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else       if (""String_Node_Str"".equals(name) && allowAppConfigs) {
        String pkgname=parser.getAttributeValue(null,""String_Node_Str"");
        if (pkgname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          mLinkedApps.add(pkgname);
        }
        XmlUtils.skipCurrentTag(parser);
      }
 else       if (""String_Node_Str"".equals(name) && allowAppConfigs) {
        String pkgname=parser.getAttributeValue(null,""String_Node_Str"");
        if (pkgname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          mSystemUserWhitelistedApps.add(pkgname);
        }
        XmlUtils.skipCurrentTag(parser);
      }
 else       if (""String_Node_Str"".equals(name) && allowAppConfigs) {
        String pkgname=parser.getAttributeValue(null,""String_Node_Str"");
        if (pkgname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          mSystemUserBlacklistedApps.add(pkgname);
        }
        XmlUtils.skipCurrentTag(parser);
      }
 else {
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
    }
  }
 catch (  XmlPullParserException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
catch (  IOException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
 finally {
    IoUtils.closeQuietly(permReader);
  }
  if (StorageManager.isNativeFileBasedEncryptionEnabled()) {
    addFeature(PackageManager.FEATURE_FILE_BASED_ENCRYPTION,0);
    addFeature(PackageManager.FEATURE_SECURELY_REMOVES_USERS,0);
  }
  for (  String featureName : mUnavailableFeatures) {
    removeFeature(featureName);
  }
}","private void readPermissionsFromXml(File permFile,int permissionFlag){
  FileReader permReader=null;
  try {
    permReader=new FileReader(permFile);
  }
 catch (  FileNotFoundException e) {
    Slog.w(TAG,""String_Node_Str"" + permFile);
    return;
  }
  final boolean lowRam=ActivityManager.isLowRamDeviceStatic();
  try {
    XmlPullParser parser=Xml.newPullParser();
    parser.setInput(permReader);
    int type;
    while ((type=parser.next()) != parser.START_TAG && type != parser.END_DOCUMENT) {
      ;
    }
    if (type != parser.START_TAG) {
      throw new XmlPullParserException(""String_Node_Str"");
    }
    if (!parser.getName().equals(""String_Node_Str"") && !parser.getName().equals(""String_Node_Str"")) {
      throw new XmlPullParserException(""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getName()+ ""String_Node_Str"");
    }
    boolean allowAll=permissionFlag == ALLOW_ALL;
    boolean allowLibs=(permissionFlag & ALLOW_LIBS) != 0;
    boolean allowFeatures=(permissionFlag & ALLOW_FEATURES) != 0;
    boolean allowPermissions=(permissionFlag & ALLOW_PERMISSIONS) != 0;
    boolean allowAppConfigs=(permissionFlag & ALLOW_APP_CONFIGS) != 0;
    while (true) {
      XmlUtils.nextElement(parser);
      if (parser.getEventType() == XmlPullParser.END_DOCUMENT) {
        break;
      }
      String name=parser.getName();
      if (""String_Node_Str"".equals(name) && allowAll) {
        String gidStr=parser.getAttributeValue(null,""String_Node_Str"");
        if (gidStr != null) {
          int gid=android.os.Process.getGidForName(gidStr);
          mGlobalGids=appendInt(mGlobalGids,gid);
        }
 else {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else       if (""String_Node_Str"".equals(name) && allowPermissions) {
        String perm=parser.getAttributeValue(null,""String_Node_Str"");
        if (perm == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        perm=perm.intern();
        readPermission(parser,perm);
      }
 else       if (""String_Node_Str"".equals(name) && allowPermissions) {
        String perm=parser.getAttributeValue(null,""String_Node_Str"");
        if (perm == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        String uidStr=parser.getAttributeValue(null,""String_Node_Str"");
        if (uidStr == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        int uid=Process.getUidForName(uidStr);
        if (uid < 0) {
          Slog.w(TAG,""String_Node_Str"" + uidStr + ""String_Node_Str""+ permFile+ ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        perm=perm.intern();
        ArraySet<String> perms=mSystemPermissions.get(uid);
        if (perms == null) {
          perms=new ArraySet<String>();
          mSystemPermissions.put(uid,perms);
        }
        perms.add(perm);
        XmlUtils.skipCurrentTag(parser);
      }
 else       if (""String_Node_Str"".equals(name) && allowLibs) {
        String lname=parser.getAttributeValue(null,""String_Node_Str"");
        String lfile=parser.getAttributeValue(null,""String_Node_Str"");
        if (lname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else         if (lfile == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          mSharedLibraries.put(lname,lfile);
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else       if (""String_Node_Str"".equals(name) && allowFeatures) {
        String fname=parser.getAttributeValue(null,""String_Node_Str"");
        int fversion=XmlUtils.readIntAttribute(parser,""String_Node_Str"",0);
        boolean allowed;
        if (!lowRam) {
          allowed=true;
        }
 else {
          String notLowRam=parser.getAttributeValue(null,""String_Node_Str"");
          allowed=!""String_Node_Str"".equals(notLowRam);
        }
        if (fname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else         if (allowed) {
          addFeature(fname,fversion);
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else       if (""String_Node_Str"".equals(name) && allowFeatures) {
        String fname=parser.getAttributeValue(null,""String_Node_Str"");
        if (fname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          mUnavailableFeatures.add(fname);
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else       if (""String_Node_Str"".equals(name) && allowAll) {
        String pkgname=parser.getAttributeValue(null,""String_Node_Str"");
        if (pkgname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          mAllowInPowerSaveExceptIdle.add(pkgname);
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else       if (""String_Node_Str"".equals(name) && allowAll) {
        String pkgname=parser.getAttributeValue(null,""String_Node_Str"");
        if (pkgname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          mAllowInPowerSave.add(pkgname);
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else       if (""String_Node_Str"".equals(name) && allowAll) {
        String pkgname=parser.getAttributeValue(null,""String_Node_Str"");
        if (pkgname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          mFixedImeApps.add(pkgname);
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else       if (""String_Node_Str"".equals(name) && allowAppConfigs) {
        String pkgname=parser.getAttributeValue(null,""String_Node_Str"");
        if (pkgname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          mLinkedApps.add(pkgname);
        }
        XmlUtils.skipCurrentTag(parser);
      }
 else       if (""String_Node_Str"".equals(name) && allowAppConfigs) {
        String pkgname=parser.getAttributeValue(null,""String_Node_Str"");
        if (pkgname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          mSystemUserWhitelistedApps.add(pkgname);
        }
        XmlUtils.skipCurrentTag(parser);
      }
 else       if (""String_Node_Str"".equals(name) && allowAppConfigs) {
        String pkgname=parser.getAttributeValue(null,""String_Node_Str"");
        if (pkgname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          mSystemUserBlacklistedApps.add(pkgname);
        }
        XmlUtils.skipCurrentTag(parser);
      }
 else {
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
    }
  }
 catch (  XmlPullParserException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
catch (  IOException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
 finally {
    IoUtils.closeQuietly(permReader);
  }
  if (StorageManager.isNativeFileBasedEncryptionEnabled()) {
    addFeature(PackageManager.FEATURE_FILE_BASED_ENCRYPTION,0);
    addFeature(PackageManager.FEATURE_SECURELY_REMOVES_USERS,0);
  }
  for (  String featureName : mUnavailableFeatures) {
    removeFeature(featureName);
  }
}",0.9993900951451572
192711,"public TaskStackHorizontalViewAdapter(List tasks){
  mTaskList=new ArrayList<>(tasks);
}","public TaskStackHorizontalViewAdapter(List tasks){
  mTaskList=new ArrayList<Task>(tasks);
}",0.9777777777777776
192712,"public TaskStackHorizontalViewAdapter(List tasks){
  mTaskList=new ArrayList<>(tasks);
}","public TaskStackHorizontalViewAdapter(List tasks){
  mTaskList=new ArrayList<Task>(tasks);
}",0.9777777777777776
192713,"private void readPermissionsFromXml(File permFile,int permissionFlag){
  FileReader permReader=null;
  try {
    permReader=new FileReader(permFile);
  }
 catch (  FileNotFoundException e) {
    Slog.w(TAG,""String_Node_Str"" + permFile);
    return;
  }
  final boolean lowRam=ActivityManager.isLowRamDeviceStatic();
  try {
    XmlPullParser parser=Xml.newPullParser();
    parser.setInput(permReader);
    int type;
    while ((type=parser.next()) != parser.START_TAG && type != parser.END_DOCUMENT) {
      ;
    }
    if (type != parser.START_TAG) {
      throw new XmlPullParserException(""String_Node_Str"");
    }
    if (!parser.getName().equals(""String_Node_Str"") && !parser.getName().equals(""String_Node_Str"")) {
      throw new XmlPullParserException(""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getName()+ ""String_Node_Str"");
    }
    boolean allowAll=permissionFlag == ALLOW_ALL;
    boolean allowLibs=(permissionFlag & ALLOW_LIBS) != 0;
    boolean allowFeatures=(permissionFlag & ALLOW_FEATURES) != 0;
    boolean allowPermissions=(permissionFlag & ALLOW_PERMISSIONS) != 0;
    boolean allowAppConfigs=(permissionFlag & ALLOW_APP_CONFIGS) != 0;
    while (true) {
      XmlUtils.nextElement(parser);
      if (parser.getEventType() == XmlPullParser.END_DOCUMENT) {
        break;
      }
      String name=parser.getName();
      if (""String_Node_Str"".equals(name) && allowAll) {
        String gidStr=parser.getAttributeValue(null,""String_Node_Str"");
        if (gidStr != null) {
          int gid=android.os.Process.getGidForName(gidStr);
          mGlobalGids=appendInt(mGlobalGids,gid);
        }
 else {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else       if (""String_Node_Str"".equals(name) && allowPermissions) {
        String perm=parser.getAttributeValue(null,""String_Node_Str"");
        if (perm == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        perm=perm.intern();
        readPermission(parser,perm);
      }
 else       if (""String_Node_Str"".equals(name) && allowPermissions) {
        String perm=parser.getAttributeValue(null,""String_Node_Str"");
        if (perm == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        String uidStr=parser.getAttributeValue(null,""String_Node_Str"");
        if (uidStr == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        int uid=Process.getUidForName(uidStr);
        if (uid < 0) {
          Slog.w(TAG,""String_Node_Str"" + uidStr + ""String_Node_Str""+ permFile+ ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        perm=perm.intern();
        ArraySet<String> perms=mSystemPermissions.get(uid);
        if (perms == null) {
          perms=new ArraySet<String>();
          mSystemPermissions.put(uid,perms);
        }
        perms.add(perm);
        XmlUtils.skipCurrentTag(parser);
      }
 else       if (""String_Node_Str"".equals(name) && allowLibs) {
        String lname=parser.getAttributeValue(null,""String_Node_Str"");
        String lfile=parser.getAttributeValue(null,""String_Node_Str"");
        if (lname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else         if (lfile == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          mSharedLibraries.put(lname,lfile);
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else       if (""String_Node_Str"".equals(name) && allowFeatures) {
        String fname=parser.getAttributeValue(null,""String_Node_Str"");
        int fversion=XmlUtils.readIntAttribute(null,""String_Node_Str"",0);
        boolean allowed;
        if (!lowRam) {
          allowed=true;
        }
 else {
          String notLowRam=parser.getAttributeValue(null,""String_Node_Str"");
          allowed=!""String_Node_Str"".equals(notLowRam);
        }
        if (fname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else         if (allowed) {
          addFeature(fname,fversion);
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else       if (""String_Node_Str"".equals(name) && allowFeatures) {
        String fname=parser.getAttributeValue(null,""String_Node_Str"");
        if (fname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          mUnavailableFeatures.add(fname);
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else       if (""String_Node_Str"".equals(name) && allowAll) {
        String pkgname=parser.getAttributeValue(null,""String_Node_Str"");
        if (pkgname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          mAllowInPowerSaveExceptIdle.add(pkgname);
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else       if (""String_Node_Str"".equals(name) && allowAll) {
        String pkgname=parser.getAttributeValue(null,""String_Node_Str"");
        if (pkgname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          mAllowInPowerSave.add(pkgname);
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else       if (""String_Node_Str"".equals(name) && allowAll) {
        String pkgname=parser.getAttributeValue(null,""String_Node_Str"");
        if (pkgname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          mFixedImeApps.add(pkgname);
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else       if (""String_Node_Str"".equals(name) && allowAppConfigs) {
        String pkgname=parser.getAttributeValue(null,""String_Node_Str"");
        if (pkgname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          mLinkedApps.add(pkgname);
        }
        XmlUtils.skipCurrentTag(parser);
      }
 else       if (""String_Node_Str"".equals(name) && allowAppConfigs) {
        String pkgname=parser.getAttributeValue(null,""String_Node_Str"");
        if (pkgname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          mSystemUserWhitelistedApps.add(pkgname);
        }
        XmlUtils.skipCurrentTag(parser);
      }
 else       if (""String_Node_Str"".equals(name) && allowAppConfigs) {
        String pkgname=parser.getAttributeValue(null,""String_Node_Str"");
        if (pkgname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          mSystemUserBlacklistedApps.add(pkgname);
        }
        XmlUtils.skipCurrentTag(parser);
      }
 else {
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
    }
  }
 catch (  XmlPullParserException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
catch (  IOException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
 finally {
    IoUtils.closeQuietly(permReader);
  }
  if (StorageManager.isNativeFileBasedEncryptionEnabled()) {
    addFeature(PackageManager.FEATURE_FILE_BASED_ENCRYPTION,0);
    addFeature(PackageManager.FEATURE_SECURELY_REMOVES_USERS,0);
  }
  for (  String featureName : mUnavailableFeatures) {
    removeFeature(featureName);
  }
}","private void readPermissionsFromXml(File permFile,int permissionFlag){
  FileReader permReader=null;
  try {
    permReader=new FileReader(permFile);
  }
 catch (  FileNotFoundException e) {
    Slog.w(TAG,""String_Node_Str"" + permFile);
    return;
  }
  final boolean lowRam=ActivityManager.isLowRamDeviceStatic();
  try {
    XmlPullParser parser=Xml.newPullParser();
    parser.setInput(permReader);
    int type;
    while ((type=parser.next()) != parser.START_TAG && type != parser.END_DOCUMENT) {
      ;
    }
    if (type != parser.START_TAG) {
      throw new XmlPullParserException(""String_Node_Str"");
    }
    if (!parser.getName().equals(""String_Node_Str"") && !parser.getName().equals(""String_Node_Str"")) {
      throw new XmlPullParserException(""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getName()+ ""String_Node_Str"");
    }
    boolean allowAll=permissionFlag == ALLOW_ALL;
    boolean allowLibs=(permissionFlag & ALLOW_LIBS) != 0;
    boolean allowFeatures=(permissionFlag & ALLOW_FEATURES) != 0;
    boolean allowPermissions=(permissionFlag & ALLOW_PERMISSIONS) != 0;
    boolean allowAppConfigs=(permissionFlag & ALLOW_APP_CONFIGS) != 0;
    while (true) {
      XmlUtils.nextElement(parser);
      if (parser.getEventType() == XmlPullParser.END_DOCUMENT) {
        break;
      }
      String name=parser.getName();
      if (""String_Node_Str"".equals(name) && allowAll) {
        String gidStr=parser.getAttributeValue(null,""String_Node_Str"");
        if (gidStr != null) {
          int gid=android.os.Process.getGidForName(gidStr);
          mGlobalGids=appendInt(mGlobalGids,gid);
        }
 else {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else       if (""String_Node_Str"".equals(name) && allowPermissions) {
        String perm=parser.getAttributeValue(null,""String_Node_Str"");
        if (perm == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        perm=perm.intern();
        readPermission(parser,perm);
      }
 else       if (""String_Node_Str"".equals(name) && allowPermissions) {
        String perm=parser.getAttributeValue(null,""String_Node_Str"");
        if (perm == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        String uidStr=parser.getAttributeValue(null,""String_Node_Str"");
        if (uidStr == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        int uid=Process.getUidForName(uidStr);
        if (uid < 0) {
          Slog.w(TAG,""String_Node_Str"" + uidStr + ""String_Node_Str""+ permFile+ ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        perm=perm.intern();
        ArraySet<String> perms=mSystemPermissions.get(uid);
        if (perms == null) {
          perms=new ArraySet<String>();
          mSystemPermissions.put(uid,perms);
        }
        perms.add(perm);
        XmlUtils.skipCurrentTag(parser);
      }
 else       if (""String_Node_Str"".equals(name) && allowLibs) {
        String lname=parser.getAttributeValue(null,""String_Node_Str"");
        String lfile=parser.getAttributeValue(null,""String_Node_Str"");
        if (lname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else         if (lfile == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          mSharedLibraries.put(lname,lfile);
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else       if (""String_Node_Str"".equals(name) && allowFeatures) {
        String fname=parser.getAttributeValue(null,""String_Node_Str"");
        int fversion=XmlUtils.readIntAttribute(parser,""String_Node_Str"",0);
        boolean allowed;
        if (!lowRam) {
          allowed=true;
        }
 else {
          String notLowRam=parser.getAttributeValue(null,""String_Node_Str"");
          allowed=!""String_Node_Str"".equals(notLowRam);
        }
        if (fname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else         if (allowed) {
          addFeature(fname,fversion);
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else       if (""String_Node_Str"".equals(name) && allowFeatures) {
        String fname=parser.getAttributeValue(null,""String_Node_Str"");
        if (fname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          mUnavailableFeatures.add(fname);
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else       if (""String_Node_Str"".equals(name) && allowAll) {
        String pkgname=parser.getAttributeValue(null,""String_Node_Str"");
        if (pkgname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          mAllowInPowerSaveExceptIdle.add(pkgname);
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else       if (""String_Node_Str"".equals(name) && allowAll) {
        String pkgname=parser.getAttributeValue(null,""String_Node_Str"");
        if (pkgname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          mAllowInPowerSave.add(pkgname);
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else       if (""String_Node_Str"".equals(name) && allowAll) {
        String pkgname=parser.getAttributeValue(null,""String_Node_Str"");
        if (pkgname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          mFixedImeApps.add(pkgname);
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else       if (""String_Node_Str"".equals(name) && allowAppConfigs) {
        String pkgname=parser.getAttributeValue(null,""String_Node_Str"");
        if (pkgname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          mLinkedApps.add(pkgname);
        }
        XmlUtils.skipCurrentTag(parser);
      }
 else       if (""String_Node_Str"".equals(name) && allowAppConfigs) {
        String pkgname=parser.getAttributeValue(null,""String_Node_Str"");
        if (pkgname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          mSystemUserWhitelistedApps.add(pkgname);
        }
        XmlUtils.skipCurrentTag(parser);
      }
 else       if (""String_Node_Str"".equals(name) && allowAppConfigs) {
        String pkgname=parser.getAttributeValue(null,""String_Node_Str"");
        if (pkgname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          mSystemUserBlacklistedApps.add(pkgname);
        }
        XmlUtils.skipCurrentTag(parser);
      }
 else {
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
    }
  }
 catch (  XmlPullParserException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
catch (  IOException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
 finally {
    IoUtils.closeQuietly(permReader);
  }
  if (StorageManager.isNativeFileBasedEncryptionEnabled()) {
    addFeature(PackageManager.FEATURE_FILE_BASED_ENCRYPTION,0);
    addFeature(PackageManager.FEATURE_SECURELY_REMOVES_USERS,0);
  }
  for (  String featureName : mUnavailableFeatures) {
    removeFeature(featureName);
  }
}",0.9993900951451572
192714,"private void readPermissionsFromXml(File permFile,int permissionFlag){
  FileReader permReader=null;
  try {
    permReader=new FileReader(permFile);
  }
 catch (  FileNotFoundException e) {
    Slog.w(TAG,""String_Node_Str"" + permFile);
    return;
  }
  final boolean lowRam=ActivityManager.isLowRamDeviceStatic();
  try {
    XmlPullParser parser=Xml.newPullParser();
    parser.setInput(permReader);
    int type;
    while ((type=parser.next()) != parser.START_TAG && type != parser.END_DOCUMENT) {
      ;
    }
    if (type != parser.START_TAG) {
      throw new XmlPullParserException(""String_Node_Str"");
    }
    if (!parser.getName().equals(""String_Node_Str"") && !parser.getName().equals(""String_Node_Str"")) {
      throw new XmlPullParserException(""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getName()+ ""String_Node_Str"");
    }
    boolean allowAll=permissionFlag == ALLOW_ALL;
    boolean allowLibs=(permissionFlag & ALLOW_LIBS) != 0;
    boolean allowFeatures=(permissionFlag & ALLOW_FEATURES) != 0;
    boolean allowPermissions=(permissionFlag & ALLOW_PERMISSIONS) != 0;
    boolean allowAppConfigs=(permissionFlag & ALLOW_APP_CONFIGS) != 0;
    while (true) {
      XmlUtils.nextElement(parser);
      if (parser.getEventType() == XmlPullParser.END_DOCUMENT) {
        break;
      }
      String name=parser.getName();
      if (""String_Node_Str"".equals(name) && allowAll) {
        String gidStr=parser.getAttributeValue(null,""String_Node_Str"");
        if (gidStr != null) {
          int gid=android.os.Process.getGidForName(gidStr);
          mGlobalGids=appendInt(mGlobalGids,gid);
        }
 else {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else       if (""String_Node_Str"".equals(name) && allowPermissions) {
        String perm=parser.getAttributeValue(null,""String_Node_Str"");
        if (perm == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        perm=perm.intern();
        readPermission(parser,perm);
      }
 else       if (""String_Node_Str"".equals(name) && allowPermissions) {
        String perm=parser.getAttributeValue(null,""String_Node_Str"");
        if (perm == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        String uidStr=parser.getAttributeValue(null,""String_Node_Str"");
        if (uidStr == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        int uid=Process.getUidForName(uidStr);
        if (uid < 0) {
          Slog.w(TAG,""String_Node_Str"" + uidStr + ""String_Node_Str""+ permFile+ ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        perm=perm.intern();
        ArraySet<String> perms=mSystemPermissions.get(uid);
        if (perms == null) {
          perms=new ArraySet<String>();
          mSystemPermissions.put(uid,perms);
        }
        perms.add(perm);
        XmlUtils.skipCurrentTag(parser);
      }
 else       if (""String_Node_Str"".equals(name) && allowLibs) {
        String lname=parser.getAttributeValue(null,""String_Node_Str"");
        String lfile=parser.getAttributeValue(null,""String_Node_Str"");
        if (lname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else         if (lfile == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          mSharedLibraries.put(lname,lfile);
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else       if (""String_Node_Str"".equals(name) && allowFeatures) {
        String fname=parser.getAttributeValue(null,""String_Node_Str"");
        int fversion=XmlUtils.readIntAttribute(null,""String_Node_Str"",0);
        boolean allowed;
        if (!lowRam) {
          allowed=true;
        }
 else {
          String notLowRam=parser.getAttributeValue(null,""String_Node_Str"");
          allowed=!""String_Node_Str"".equals(notLowRam);
        }
        if (fname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else         if (allowed) {
          addFeature(fname,fversion);
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else       if (""String_Node_Str"".equals(name) && allowFeatures) {
        String fname=parser.getAttributeValue(null,""String_Node_Str"");
        if (fname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          mUnavailableFeatures.add(fname);
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else       if (""String_Node_Str"".equals(name) && allowAll) {
        String pkgname=parser.getAttributeValue(null,""String_Node_Str"");
        if (pkgname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          mAllowInPowerSaveExceptIdle.add(pkgname);
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else       if (""String_Node_Str"".equals(name) && allowAll) {
        String pkgname=parser.getAttributeValue(null,""String_Node_Str"");
        if (pkgname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          mAllowInPowerSave.add(pkgname);
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else       if (""String_Node_Str"".equals(name) && allowAll) {
        String pkgname=parser.getAttributeValue(null,""String_Node_Str"");
        if (pkgname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          mFixedImeApps.add(pkgname);
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else       if (""String_Node_Str"".equals(name) && allowAppConfigs) {
        String pkgname=parser.getAttributeValue(null,""String_Node_Str"");
        if (pkgname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          mLinkedApps.add(pkgname);
        }
        XmlUtils.skipCurrentTag(parser);
      }
 else       if (""String_Node_Str"".equals(name) && allowAppConfigs) {
        String pkgname=parser.getAttributeValue(null,""String_Node_Str"");
        if (pkgname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          mSystemUserWhitelistedApps.add(pkgname);
        }
        XmlUtils.skipCurrentTag(parser);
      }
 else       if (""String_Node_Str"".equals(name) && allowAppConfigs) {
        String pkgname=parser.getAttributeValue(null,""String_Node_Str"");
        if (pkgname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          mSystemUserBlacklistedApps.add(pkgname);
        }
        XmlUtils.skipCurrentTag(parser);
      }
 else {
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
    }
  }
 catch (  XmlPullParserException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
catch (  IOException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
 finally {
    IoUtils.closeQuietly(permReader);
  }
  if (StorageManager.isNativeFileBasedEncryptionEnabled()) {
    addFeature(PackageManager.FEATURE_FILE_BASED_ENCRYPTION,0);
    addFeature(PackageManager.FEATURE_SECURELY_REMOVES_USERS,0);
  }
  for (  String featureName : mUnavailableFeatures) {
    removeFeature(featureName);
  }
}","private void readPermissionsFromXml(File permFile,int permissionFlag){
  FileReader permReader=null;
  try {
    permReader=new FileReader(permFile);
  }
 catch (  FileNotFoundException e) {
    Slog.w(TAG,""String_Node_Str"" + permFile);
    return;
  }
  final boolean lowRam=ActivityManager.isLowRamDeviceStatic();
  try {
    XmlPullParser parser=Xml.newPullParser();
    parser.setInput(permReader);
    int type;
    while ((type=parser.next()) != parser.START_TAG && type != parser.END_DOCUMENT) {
      ;
    }
    if (type != parser.START_TAG) {
      throw new XmlPullParserException(""String_Node_Str"");
    }
    if (!parser.getName().equals(""String_Node_Str"") && !parser.getName().equals(""String_Node_Str"")) {
      throw new XmlPullParserException(""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getName()+ ""String_Node_Str"");
    }
    boolean allowAll=permissionFlag == ALLOW_ALL;
    boolean allowLibs=(permissionFlag & ALLOW_LIBS) != 0;
    boolean allowFeatures=(permissionFlag & ALLOW_FEATURES) != 0;
    boolean allowPermissions=(permissionFlag & ALLOW_PERMISSIONS) != 0;
    boolean allowAppConfigs=(permissionFlag & ALLOW_APP_CONFIGS) != 0;
    while (true) {
      XmlUtils.nextElement(parser);
      if (parser.getEventType() == XmlPullParser.END_DOCUMENT) {
        break;
      }
      String name=parser.getName();
      if (""String_Node_Str"".equals(name) && allowAll) {
        String gidStr=parser.getAttributeValue(null,""String_Node_Str"");
        if (gidStr != null) {
          int gid=android.os.Process.getGidForName(gidStr);
          mGlobalGids=appendInt(mGlobalGids,gid);
        }
 else {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else       if (""String_Node_Str"".equals(name) && allowPermissions) {
        String perm=parser.getAttributeValue(null,""String_Node_Str"");
        if (perm == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        perm=perm.intern();
        readPermission(parser,perm);
      }
 else       if (""String_Node_Str"".equals(name) && allowPermissions) {
        String perm=parser.getAttributeValue(null,""String_Node_Str"");
        if (perm == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        String uidStr=parser.getAttributeValue(null,""String_Node_Str"");
        if (uidStr == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        int uid=Process.getUidForName(uidStr);
        if (uid < 0) {
          Slog.w(TAG,""String_Node_Str"" + uidStr + ""String_Node_Str""+ permFile+ ""String_Node_Str""+ parser.getPositionDescription());
          XmlUtils.skipCurrentTag(parser);
          continue;
        }
        perm=perm.intern();
        ArraySet<String> perms=mSystemPermissions.get(uid);
        if (perms == null) {
          perms=new ArraySet<String>();
          mSystemPermissions.put(uid,perms);
        }
        perms.add(perm);
        XmlUtils.skipCurrentTag(parser);
      }
 else       if (""String_Node_Str"".equals(name) && allowLibs) {
        String lname=parser.getAttributeValue(null,""String_Node_Str"");
        String lfile=parser.getAttributeValue(null,""String_Node_Str"");
        if (lname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else         if (lfile == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          mSharedLibraries.put(lname,lfile);
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else       if (""String_Node_Str"".equals(name) && allowFeatures) {
        String fname=parser.getAttributeValue(null,""String_Node_Str"");
        int fversion=XmlUtils.readIntAttribute(parser,""String_Node_Str"",0);
        boolean allowed;
        if (!lowRam) {
          allowed=true;
        }
 else {
          String notLowRam=parser.getAttributeValue(null,""String_Node_Str"");
          allowed=!""String_Node_Str"".equals(notLowRam);
        }
        if (fname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else         if (allowed) {
          addFeature(fname,fversion);
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else       if (""String_Node_Str"".equals(name) && allowFeatures) {
        String fname=parser.getAttributeValue(null,""String_Node_Str"");
        if (fname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          mUnavailableFeatures.add(fname);
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else       if (""String_Node_Str"".equals(name) && allowAll) {
        String pkgname=parser.getAttributeValue(null,""String_Node_Str"");
        if (pkgname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          mAllowInPowerSaveExceptIdle.add(pkgname);
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else       if (""String_Node_Str"".equals(name) && allowAll) {
        String pkgname=parser.getAttributeValue(null,""String_Node_Str"");
        if (pkgname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          mAllowInPowerSave.add(pkgname);
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else       if (""String_Node_Str"".equals(name) && allowAll) {
        String pkgname=parser.getAttributeValue(null,""String_Node_Str"");
        if (pkgname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          mFixedImeApps.add(pkgname);
        }
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else       if (""String_Node_Str"".equals(name) && allowAppConfigs) {
        String pkgname=parser.getAttributeValue(null,""String_Node_Str"");
        if (pkgname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          mLinkedApps.add(pkgname);
        }
        XmlUtils.skipCurrentTag(parser);
      }
 else       if (""String_Node_Str"".equals(name) && allowAppConfigs) {
        String pkgname=parser.getAttributeValue(null,""String_Node_Str"");
        if (pkgname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          mSystemUserWhitelistedApps.add(pkgname);
        }
        XmlUtils.skipCurrentTag(parser);
      }
 else       if (""String_Node_Str"".equals(name) && allowAppConfigs) {
        String pkgname=parser.getAttributeValue(null,""String_Node_Str"");
        if (pkgname == null) {
          Slog.w(TAG,""String_Node_Str"" + permFile + ""String_Node_Str""+ parser.getPositionDescription());
        }
 else {
          mSystemUserBlacklistedApps.add(pkgname);
        }
        XmlUtils.skipCurrentTag(parser);
      }
 else {
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
    }
  }
 catch (  XmlPullParserException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
catch (  IOException e) {
    Slog.w(TAG,""String_Node_Str"",e);
  }
 finally {
    IoUtils.closeQuietly(permReader);
  }
  if (StorageManager.isNativeFileBasedEncryptionEnabled()) {
    addFeature(PackageManager.FEATURE_FILE_BASED_ENCRYPTION,0);
    addFeature(PackageManager.FEATURE_SECURELY_REMOVES_USERS,0);
  }
  for (  String featureName : mUnavailableFeatures) {
    removeFeature(featureName);
  }
}",0.9993900951451572
192715,"@Override public void setVisible(boolean visible){
  mView.setVisibility(visible ? View.VISIBLE : View.INVISIBLE);
}","@Override public void setVisible(boolean visible){
  mView.animate().cancel();
  mView.setVisibility(visible ? View.VISIBLE : View.INVISIBLE);
}",0.8923076923076924
192716,"public void setVisible(boolean visible){
  if (mTransformedView.getVisibility() == View.GONE) {
    return;
  }
  mTransformedView.animate().cancel();
  mTransformedView.setVisibility(visible ? View.VISIBLE : View.INVISIBLE);
  mTransformedView.setAlpha(visible ? 1.0f : 0.0f);
  if (visible) {
    mTransformedView.setTranslationX(0);
    mTransformedView.setTranslationY(0);
    mTransformedView.setScaleX(1.0f);
    mTransformedView.setScaleY(1.0f);
  }
}","public void setVisible(boolean visible){
  if (mTransformedView.getVisibility() == View.GONE) {
    return;
  }
  mTransformedView.animate().cancel();
  mTransformedView.setVisibility(visible ? View.VISIBLE : View.INVISIBLE);
  mTransformedView.setAlpha(visible ? 1.0f : 0.0f);
  if (visible) {
    resetTransformedView();
  }
}",0.7811704834605598
192717,"public void prepareFadeIn(){
}","public void prepareFadeIn(){
  resetTransformedView();
}",0.6976744186046512
192718,"public void reInflateViews(){
  initDimens();
  if (mIsSummaryWithChildren) {
    removeView(mNotificationHeader);
    mNotificationHeader=null;
    recreateNotificationHeader();
    if (mChildrenContainer != null) {
      mChildrenContainer.reInflateViews();
    }
  }
  if (mGuts != null) {
    View oldGuts=mGuts;
    int index=indexOfChild(oldGuts);
    removeView(oldGuts);
    mGuts=(NotificationGuts)LayoutInflater.from(mContext).inflate(R.layout.notification_guts,this,false);
    mGuts.setVisibility(oldGuts.getVisibility());
    addView(mGuts,index);
  }
}","public void reInflateViews(){
  initDimens();
  if (mIsSummaryWithChildren) {
    removeView(mNotificationHeader);
    mNotificationHeader=null;
    recreateNotificationHeader();
    if (mChildrenContainer != null) {
      mChildrenContainer.reInflateViews();
    }
  }
  if (mGuts != null) {
    View oldGuts=mGuts;
    int index=indexOfChild(oldGuts);
    removeView(oldGuts);
    mGuts=(NotificationGuts)LayoutInflater.from(mContext).inflate(R.layout.notification_guts,this,false);
    mGuts.setVisibility(oldGuts.getVisibility());
    addView(mGuts,index);
  }
  mPrivateLayout.reInflateViews();
  mPublicLayout.reInflateViews();
}",0.9425478767693588
192719,"public void reset(boolean resetActualHeight){
  if (mContractedChild != null) {
    mContractedChild.animate().cancel();
  }
  if (mExpandedChild != null) {
    mExpandedChild.animate().cancel();
  }
  if (mHeadsUpChild != null) {
    mHeadsUpChild.animate().cancel();
  }
  removeAllViews();
  mContractedChild=null;
  mExpandedChild=null;
  mHeadsUpChild=null;
  mVisibleType=VISIBLE_TYPE_CONTRACTED;
  if (resetActualHeight) {
    mContentHeight=mSmallHeight;
  }
}","public void reset(boolean resetActualHeight){
  if (mContractedChild != null) {
    mContractedChild.animate().cancel();
    removeView(mContractedChild);
  }
  if (mExpandedChild != null) {
    mExpandedChild.animate().cancel();
    removeView(mExpandedChild);
  }
  if (mHeadsUpChild != null) {
    mHeadsUpChild.animate().cancel();
    removeView(mHeadsUpChild);
  }
  mContractedChild=null;
  mExpandedChild=null;
  mHeadsUpChild=null;
  mVisibleType=VISIBLE_TYPE_CONTRACTED;
  if (resetActualHeight) {
    mContentHeight=mSmallHeight;
  }
}",0.8845014807502468
192720,"private void updateSingleLineView(){
  if (mIsChildInGroup) {
    mSingleLineView=mHybridViewManager.bindFromNotification(mSingleLineView,mStatusBarNotification.getNotification());
  }
}","private void updateSingleLineView(){
  if (mIsChildInGroup) {
    mSingleLineView=mHybridViewManager.bindFromNotification(mSingleLineView,mStatusBarNotification.getNotification());
  }
 else   if (mSingleLineView != null) {
    removeView(mSingleLineView);
    mSingleLineView=null;
  }
}",0.7848101265822784
192721,"@Override public void maybeEscalateHeadsUp(){
  TreeSet<HeadsUpManager.HeadsUpEntry> entries=mHeadsUpManager.getSortedEntries();
  for (  HeadsUpManager.HeadsUpEntry entry : entries) {
    final StatusBarNotification sbn=entry.entry.notification;
    final Notification notification=sbn.getNotification();
    if (notification.fullScreenIntent != null) {
      if (DEBUG) {
        Log.d(TAG,""String_Node_Str"");
      }
      try {
        EventLog.writeEvent(EventLogTags.SYSUI_HEADS_UP_ESCALATION,sbn.getKey());
        notification.fullScreenIntent.send();
        entry.entry.notifyFullScreenIntentLaunched();
      }
 catch (      PendingIntent.CanceledException e) {
      }
    }
  }
  mHeadsUpManager.releaseAllImmediately();
}","@Override public void maybeEscalateHeadsUp(){
  Collection<HeadsUpManager.HeadsUpEntry> entries=mHeadsUpManager.getAllEntries();
  for (  HeadsUpManager.HeadsUpEntry entry : entries) {
    final StatusBarNotification sbn=entry.entry.notification;
    final Notification notification=sbn.getNotification();
    if (notification.fullScreenIntent != null) {
      if (DEBUG) {
        Log.d(TAG,""String_Node_Str"");
      }
      try {
        EventLog.writeEvent(EventLogTags.SYSUI_HEADS_UP_ESCALATION,sbn.getKey());
        notification.fullScreenIntent.send();
        entry.entry.notifyFullScreenIntentLaunched();
      }
 catch (      PendingIntent.CanceledException e) {
      }
    }
  }
  mHeadsUpManager.releaseAllImmediately();
}",0.982312925170068
192722,"@Override public int compareTo(HeadsUpEntry o){
  boolean selfFullscreen=hasFullScreenIntent(entry);
  boolean otherFullscreen=hasFullScreenIntent(o.entry);
  if (selfFullscreen && !otherFullscreen) {
    return -1;
  }
 else   if (!selfFullscreen && otherFullscreen) {
    return 1;
  }
  return postTime < o.postTime ? 1 : postTime == o.postTime ? entry.key.compareTo(o.entry.key) : -1;
}","@Override public int compareTo(HeadsUpEntry o){
  boolean isPinned=entry.row.isPinned();
  boolean otherPinned=o.entry.row.isPinned();
  if (isPinned && !otherPinned) {
    return -1;
  }
 else   if (!isPinned && otherPinned) {
    return 1;
  }
  boolean selfFullscreen=hasFullScreenIntent(entry);
  boolean otherFullscreen=hasFullScreenIntent(o.entry);
  if (selfFullscreen && !otherFullscreen) {
    return -1;
  }
 else   if (!selfFullscreen && otherFullscreen) {
    return 1;
  }
  return postTime < o.postTime ? 1 : postTime == o.postTime ? entry.key.compareTo(o.entry.key) : -1;
}",0.5746421267893661
192723,"private void removeHeadsUpEntry(NotificationData.Entry entry){
  HeadsUpEntry remove=mHeadsUpEntries.remove(entry.key);
  mSortedEntries.remove(remove);
  entry.row.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED);
  entry.row.setHeadsUp(false);
  setEntryPinned(remove,false);
  for (  OnHeadsUpChangedListener listener : mListeners) {
    listener.onHeadsUpStateChanged(entry,false);
  }
  mEntryPool.release(remove);
}","private void removeHeadsUpEntry(NotificationData.Entry entry){
  HeadsUpEntry remove=mHeadsUpEntries.remove(entry.key);
  entry.row.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED);
  entry.row.setHeadsUp(false);
  setEntryPinned(remove,false);
  for (  OnHeadsUpChangedListener listener : mListeners) {
    listener.onHeadsUpStateChanged(entry,false);
  }
  mEntryPool.release(remove);
}",0.9613130128956624
192724,"public HeadsUpEntry getTopEntry(){
  return mSortedEntries.isEmpty() ? null : mSortedEntries.first();
}","public HeadsUpEntry getTopEntry(){
  if (mHeadsUpEntries.isEmpty()) {
    return null;
  }
  HeadsUpEntry topEntry=null;
  for (  HeadsUpEntry entry : mHeadsUpEntries.values()) {
    if (topEntry == null || entry.compareTo(topEntry) == -1) {
      topEntry=entry;
    }
  }
  return topEntry;
}",0.3375314861460957
192725,"public void updateEntry(boolean updatePostTime){
  mSortedEntries.remove(HeadsUpEntry.this);
  long currentTime=mClock.currentTimeMillis();
  earliestRemovaltime=currentTime + mMinimumDisplayTime;
  if (updatePostTime) {
    postTime=Math.max(postTime,currentTime);
  }
  removeAutoRemovalCallbacks();
  if (mEntriesToRemoveAfterExpand.contains(entry)) {
    mEntriesToRemoveAfterExpand.remove(entry);
  }
  if (!isSticky()) {
    long finishTime=postTime + mHeadsUpNotificationDecay;
    long removeDelay=Math.max(finishTime - currentTime,mMinimumDisplayTime);
    mHandler.postDelayed(mRemoveHeadsUpRunnable,removeDelay);
  }
  mSortedEntries.add(HeadsUpEntry.this);
}","public void updateEntry(boolean updatePostTime){
  long currentTime=mClock.currentTimeMillis();
  earliestRemovaltime=currentTime + mMinimumDisplayTime;
  if (updatePostTime) {
    postTime=Math.max(postTime,currentTime);
  }
  removeAutoRemovalCallbacks();
  if (mEntriesToRemoveAfterExpand.contains(entry)) {
    mEntriesToRemoveAfterExpand.remove(entry);
  }
  if (!isSticky()) {
    long finishTime=postTime + mHeadsUpNotificationDecay;
    long removeDelay=Math.max(finishTime - currentTime,mMinimumDisplayTime);
    mHandler.postDelayed(mRemoveHeadsUpRunnable,removeDelay);
  }
}",0.9322709163346612
192726,"public void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  pw.println(""String_Node_Str"");
  pw.print(""String_Node_Str"");
  pw.println(mTouchAcceptanceDelay);
  pw.print(""String_Node_Str"");
  pw.println(mSnoozeLengthMs);
  pw.print(""String_Node_Str"");
  pw.println(SystemClock.elapsedRealtime());
  pw.print(""String_Node_Str"");
  pw.println(mUser);
  for (  HeadsUpEntry entry : mSortedEntries) {
    pw.print(""String_Node_Str"");
    pw.println(entry.entry);
  }
  int N=mSnoozedPackages.size();
  pw.println(""String_Node_Str"" + N);
  for (int i=0; i < N; i++) {
    pw.print(""String_Node_Str"");
    pw.print(mSnoozedPackages.valueAt(i));
    pw.print(""String_Node_Str"");
    pw.println(mSnoozedPackages.keyAt(i));
  }
}","public void dump(FileDescriptor fd,PrintWriter pw,String[] args){
  pw.println(""String_Node_Str"");
  pw.print(""String_Node_Str"");
  pw.println(mTouchAcceptanceDelay);
  pw.print(""String_Node_Str"");
  pw.println(mSnoozeLengthMs);
  pw.print(""String_Node_Str"");
  pw.println(SystemClock.elapsedRealtime());
  pw.print(""String_Node_Str"");
  pw.println(mUser);
  for (  HeadsUpEntry entry : mHeadsUpEntries.values()) {
    pw.print(""String_Node_Str"");
    pw.println(entry.entry);
  }
  int N=mSnoozedPackages.size();
  pw.println(""String_Node_Str"" + N);
  for (int i=0; i < N; i++) {
    pw.print(""String_Node_Str"");
    pw.print(mSnoozedPackages.valueAt(i));
    pw.print(""String_Node_Str"");
    pw.println(mSnoozedPackages.keyAt(i));
  }
}",0.984993178717599
192727,"public void onComputeInternalInsets(ViewTreeObserver.InternalInsetsInfo info){
  if (mIsExpanded) {
    return;
  }
  if (mHasPinnedNotification) {
    int minX=0;
    int maxX=0;
    int maxY=0;
    for (    HeadsUpEntry entry : mSortedEntries) {
      ExpandableNotificationRow row=entry.entry.row;
      if (row.isPinned()) {
        if (row.isChildInGroup()) {
          final ExpandableNotificationRow groupSummary=mGroupManager.getGroupSummary(row.getStatusBarNotification());
          if (groupSummary != null) {
            row=groupSummary;
          }
        }
        row.getLocationOnScreen(mTmpTwoArray);
        minX=mTmpTwoArray[0];
        maxX=mTmpTwoArray[0] + row.getWidth();
        maxY=row.getIntrinsicHeight();
        break;
      }
    }
    info.setTouchableInsets(ViewTreeObserver.InternalInsetsInfo.TOUCHABLE_INSETS_REGION);
    info.touchableRegion.set(minX,0,maxX,maxY);
  }
 else   if (mHeadsUpGoingAway || mWaitingOnCollapseWhenGoingAway) {
    info.setTouchableInsets(ViewTreeObserver.InternalInsetsInfo.TOUCHABLE_INSETS_REGION);
    info.touchableRegion.set(0,0,mStatusBarWindowView.getWidth(),mStatusBarHeight);
  }
}","public void onComputeInternalInsets(ViewTreeObserver.InternalInsetsInfo info){
  if (mIsExpanded) {
    return;
  }
  if (mHasPinnedNotification) {
    ExpandableNotificationRow topEntry=getTopEntry().entry.row;
    if (topEntry.isChildInGroup()) {
      final ExpandableNotificationRow groupSummary=mGroupManager.getGroupSummary(topEntry.getStatusBarNotification());
      if (groupSummary != null) {
        topEntry=groupSummary;
      }
    }
    topEntry.getLocationOnScreen(mTmpTwoArray);
    int minX=mTmpTwoArray[0];
    int maxX=mTmpTwoArray[0] + topEntry.getWidth();
    int maxY=topEntry.getIntrinsicHeight();
    info.setTouchableInsets(ViewTreeObserver.InternalInsetsInfo.TOUCHABLE_INSETS_REGION);
    info.touchableRegion.set(minX,0,maxX,maxY);
  }
 else   if (mHeadsUpGoingAway || mWaitingOnCollapseWhenGoingAway) {
    info.setTouchableInsets(ViewTreeObserver.InternalInsetsInfo.TOUCHABLE_INSETS_REGION);
    info.touchableRegion.set(0,0,mStatusBarWindowView.getWidth(),mStatusBarHeight);
  }
}",0.5415896487985212
192728,"@Override public void setFocusedStack(int stackId){
  if (DEBUG_FOCUS)   Slog.d(TAG_FOCUS,""String_Node_Str"" + stackId);
synchronized (ActivityManagerService.this) {
    ActivityStack stack=mStackSupervisor.getStack(stackId);
    if (stack != null) {
      ActivityRecord r=stack.topRunningActivityLocked();
      if (r != null) {
        setFocusedActivityLocked(r,""String_Node_Str"");
        mStackSupervisor.resumeFocusedStackTopActivityLocked();
      }
    }
  }
}","@Override public void setFocusedStack(int stackId){
  enforceCallingPermission(MANAGE_ACTIVITY_STACKS,""String_Node_Str"");
  if (DEBUG_FOCUS)   Slog.d(TAG_FOCUS,""String_Node_Str"" + stackId);
  final long callingId=Binder.clearCallingIdentity();
  try {
synchronized (this) {
      final ActivityStack stack=mStackSupervisor.getStack(stackId);
      if (stack == null) {
        return;
      }
      final ActivityRecord r=stack.topRunningActivityLocked();
      if (setFocusedActivityLocked(r,""String_Node_Str"")) {
        mStackSupervisor.resumeFocusedStackTopActivityLocked();
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(callingId);
  }
}",0.7304964539007093
192729,"@Override public void setFocusedTask(int taskId){
  if (DEBUG_FOCUS)   Slog.d(TAG_FOCUS,""String_Node_Str"" + taskId);
  long callingId=Binder.clearCallingIdentity();
  try {
synchronized (ActivityManagerService.this) {
      TaskRecord task=mStackSupervisor.anyTaskForIdLocked(taskId);
      if (task != null) {
        final ActivityRecord r=task.topRunningActivityLocked();
        if (setFocusedActivityLocked(r,""String_Node_Str"")) {
          mStackSupervisor.resumeFocusedStackTopActivityLocked();
        }
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(callingId);
  }
}","@Override public void setFocusedTask(int taskId){
  enforceCallingPermission(MANAGE_ACTIVITY_STACKS,""String_Node_Str"");
  if (DEBUG_FOCUS)   Slog.d(TAG_FOCUS,""String_Node_Str"" + taskId);
  final long callingId=Binder.clearCallingIdentity();
  try {
synchronized (this) {
      final TaskRecord task=mStackSupervisor.anyTaskForIdLocked(taskId);
      if (task == null) {
        return;
      }
      final ActivityRecord r=task.topRunningActivityLocked();
      if (setFocusedActivityLocked(r,""String_Node_Str"")) {
        mStackSupervisor.resumeFocusedStackTopActivityLocked();
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(callingId);
  }
}",0.7932960893854749
192730,"@Override public void setFocusedStack(int stackId){
  if (DEBUG_FOCUS)   Slog.d(TAG_FOCUS,""String_Node_Str"" + stackId);
synchronized (ActivityManagerService.this) {
    ActivityStack stack=mStackSupervisor.getStack(stackId);
    if (stack != null) {
      ActivityRecord r=stack.topRunningActivityLocked();
      if (r != null) {
        setFocusedActivityLocked(r,""String_Node_Str"");
        mStackSupervisor.resumeFocusedStackTopActivityLocked();
      }
    }
  }
}","@Override public void setFocusedStack(int stackId){
  enforceCallingPermission(MANAGE_ACTIVITY_STACKS,""String_Node_Str"");
  if (DEBUG_FOCUS)   Slog.d(TAG_FOCUS,""String_Node_Str"" + stackId);
  final long callingId=Binder.clearCallingIdentity();
  try {
synchronized (this) {
      final ActivityStack stack=mStackSupervisor.getStack(stackId);
      if (stack == null) {
        return;
      }
      final ActivityRecord r=stack.topRunningActivityLocked();
      if (setFocusedActivityLocked(r,""String_Node_Str"")) {
        mStackSupervisor.resumeFocusedStackTopActivityLocked();
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(callingId);
  }
}",0.7304964539007093
192731,"@Override public void setFocusedTask(int taskId){
  if (DEBUG_FOCUS)   Slog.d(TAG_FOCUS,""String_Node_Str"" + taskId);
  long callingId=Binder.clearCallingIdentity();
  try {
synchronized (ActivityManagerService.this) {
      TaskRecord task=mStackSupervisor.anyTaskForIdLocked(taskId);
      if (task != null) {
        final ActivityRecord r=task.topRunningActivityLocked();
        if (setFocusedActivityLocked(r,""String_Node_Str"")) {
          mStackSupervisor.resumeFocusedStackTopActivityLocked();
        }
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(callingId);
  }
}","@Override public void setFocusedTask(int taskId){
  enforceCallingPermission(MANAGE_ACTIVITY_STACKS,""String_Node_Str"");
  if (DEBUG_FOCUS)   Slog.d(TAG_FOCUS,""String_Node_Str"" + taskId);
  final long callingId=Binder.clearCallingIdentity();
  try {
synchronized (this) {
      final TaskRecord task=mStackSupervisor.anyTaskForIdLocked(taskId);
      if (task == null) {
        return;
      }
      final ActivityRecord r=task.topRunningActivityLocked();
      if (setFocusedActivityLocked(r,""String_Node_Str"")) {
        mStackSupervisor.resumeFocusedStackTopActivityLocked();
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(callingId);
  }
}",0.7932960893854749
192732,"@Override public void onAnimationUpdate(ValueAnimator animation){
  final float value=(Float)animation.getAnimatedValue();
  final float remains=1 - value;
  mTmpRect.left=(int)(mFrom.left * remains + mTo.left * value);
  mTmpRect.top=(int)(mFrom.top * remains + mTo.top * value);
  mTmpRect.right=(int)(mFrom.right * remains + mTo.right * value);
  mTmpRect.bottom=(int)(mFrom.bottom * remains + mTo.bottom * value);
  if (DEBUG_ANIM)   Slog.d(TAG,""String_Node_Str"" + mTarget + ""String_Node_Str""+ mTmpRect+ ""String_Node_Str""+ mFrom+ ""String_Node_Str""+ mTo+ ""String_Node_Str""+ value+ ""String_Node_Str""+ remains);
  if (!mTarget.setSize(mTmpRect)) {
    animation.cancel();
  }
}","@Override public void onAnimationUpdate(ValueAnimator animation){
  final float value=(Float)animation.getAnimatedValue();
  final float remains=1 - value;
  mTmpRect.left=(int)(mFrom.left * remains + mTo.left * value + 0.5f);
  mTmpRect.top=(int)(mFrom.top * remains + mTo.top * value + 0.5f);
  mTmpRect.right=(int)(mFrom.right * remains + mTo.right * value + 0.5f);
  mTmpRect.bottom=(int)(mFrom.bottom * remains + mTo.bottom * value + 0.5f);
  if (DEBUG_ANIM)   Slog.d(TAG,""String_Node_Str"" + mTarget + ""String_Node_Str""+ mTmpRect+ ""String_Node_Str""+ mFrom+ ""String_Node_Str""+ mTo+ ""String_Node_Str""+ value+ ""String_Node_Str""+ remains);
  if (!mTarget.setSize(mTmpRect)) {
    animation.cancel();
  }
}",0.9797687861271676
192733,"BoundsAnimator(AnimateBoundsUser target,Rect from,Rect to,boolean moveToFullScreen){
  super();
  mTarget=target;
  mFrom=from;
  mTo=to;
  mTmpRect=new Rect();
  mMoveToFullScreen=moveToFullScreen;
  addUpdateListener(this);
  addListener(this);
}","BoundsAnimator(AnimateBoundsUser target,Rect from,Rect to,boolean moveToFullScreen,boolean replacement){
  super();
  mTarget=target;
  mFrom=from;
  mTo=to;
  mTmpRect=new Rect();
  mMoveToFullScreen=moveToFullScreen;
  mReplacement=replacement;
  addUpdateListener(this);
  addListener(this);
}",0.9117647058823528
192734,"@Override public void onAnimationEnd(Animator animation){
  finishAnimation();
  if (mMoveToFullScreen) {
    mTarget.moveToFullscreen();
  }
}","/** 
 * Callback for the target to inform it that the animation has ended, so it can do some necessary cleanup.
 */
void onAnimationEnd();",0.2206405693950178
192735,"private void finishAnimation(){
  mTarget.finishBoundsAnimation();
  removeListener(this);
  removeUpdateListener(this);
  mRunningAnimations.remove(mTarget);
}","private void finishAnimation(){
  if (!mWillReplace) {
    mTarget.onAnimationEnd();
  }
  removeListener(this);
  removeUpdateListener(this);
  mRunningAnimations.remove(mTarget);
}",0.8713450292397661
192736,"void animateBounds(final AnimateBoundsUser target,Rect from,Rect to){
  boolean moveToFullscreen=false;
  if (to == null) {
    to=new Rect();
    target.getFullScreenBounds(to);
    moveToFullscreen=true;
  }
  final BoundsAnimator existing=mRunningAnimations.get(target);
  if (existing != null) {
    existing.cancel();
  }
  BoundsAnimator animator=new BoundsAnimator(target,from,to,moveToFullscreen);
  mRunningAnimations.put(target,animator);
  animator.setFloatValues(0f,1f);
  animator.setDuration(DEFAULT_APP_TRANSITION_DURATION);
  animator.setInterpolator(new LinearInterpolator());
  animator.start();
}","void animateBounds(final AnimateBoundsUser target,Rect from,Rect to){
  boolean moveToFullscreen=false;
  if (to == null) {
    to=new Rect();
    target.getFullScreenBounds(to);
    moveToFullscreen=true;
  }
  final BoundsAnimator existing=mRunningAnimations.get(target);
  final boolean replacing=existing != null;
  if (replacing) {
    existing.cancel();
  }
  final BoundsAnimator animator=new BoundsAnimator(target,from,to,moveToFullscreen,replacing);
  mRunningAnimations.put(target,animator);
  animator.setFloatValues(0f,1f);
  animator.setDuration(DEFAULT_APP_TRANSITION_DURATION * DEBUG_ANIMATION_SLOW_DOWN_FACTOR);
  animator.setInterpolator(new LinearInterpolator());
  animator.start();
}",0.9271623672230652
192737,"@Override public void onAnimationStart(Animator animation){
}",void onAnimationStart();,0.5411764705882353
192738,"boolean isDragResizing(){
  return mDragResizing;
}","boolean isDragResizing(){
  return mDragResizing || (mStack != null && mStack.isDragResizing());
}",0.6845637583892618
192739,"public void animateResizePinnedStack(final Rect bounds){
synchronized (mWindowMap) {
    final TaskStack stack=mStackIdToStack.get(PINNED_STACK_ID);
    if (stack == null) {
      Slog.w(TAG,""String_Node_Str"" + PINNED_STACK_ID + ""String_Node_Str"");
      return;
    }
    final ArrayList<Task> tasks=stack.getTasks();
    if (tasks.isEmpty()) {
      Slog.w(TAG,""String_Node_Str"");
      return;
    }
    final Task task=tasks.get(tasks.size() - 1);
    task.setDragResizing(true);
    final Rect originalBounds=new Rect();
    stack.getBounds(originalBounds);
    UiThread.getHandler().post(new Runnable(){
      @Override public void run(){
        mBoundsAnimationController.animateBounds(stack,originalBounds,bounds);
      }
    }
);
  }
}","public void animateResizePinnedStack(final Rect bounds){
synchronized (mWindowMap) {
    final TaskStack stack=mStackIdToStack.get(PINNED_STACK_ID);
    if (stack == null) {
      Slog.w(TAG,""String_Node_Str"" + PINNED_STACK_ID + ""String_Node_Str"");
      return;
    }
    final Rect originalBounds=new Rect();
    stack.getBounds(originalBounds);
    UiThread.getHandler().post(new Runnable(){
      @Override public void run(){
        mBoundsAnimationController.animateBounds(stack,originalBounds,bounds);
      }
    }
);
  }
}",0.831636648394675
192740,"@Override protected void applyRestoredPayload(String key,byte[] payload){
  if (KEY_USAGE_STATS.equals(key)) {
    UsageStatsManagerInternal localUsageStatsManager=LocalServices.getService(UsageStatsManagerInternal.class);
    DataInputStream in=new DataInputStream(new ByteArrayInputStream(payload));
    try {
      int user=in.readInt();
      byte[] restoreData=new byte[payload.length - 4];
      in.read(restoreData,0,payload.length - 4);
      localUsageStatsManager.applyRestoredPayload(user,key,restoreData);
    }
 catch (    IOException ioe) {
      if (DEBUG)       Log.e(TAG,""String_Node_Str"",ioe);
    }
  }
}","@Override protected void applyRestoredPayload(String key,byte[] payload){
  if (KEY_USAGE_STATS.equals(key)) {
    UsageStatsManagerInternal localUsageStatsManager=LocalServices.getService(UsageStatsManagerInternal.class);
    DataInputStream in=new DataInputStream(new ByteArrayInputStream(payload));
    try {
      int user=in.readInt();
      byte[] restoreData=new byte[payload.length - 4];
      in.read(restoreData,0,restoreData.length);
      localUsageStatsManager.applyRestoredPayload(user,key,restoreData);
    }
 catch (    IOException ioe) {
      if (DEBUG)       Log.e(TAG,""String_Node_Str"",ioe);
    }
  }
}",0.9823434991974318
192741,"/** 
 * Get the Configuration Statistics from the current device statistics and merge them with the backed up usage statistics.
 */
private IntervalStats mergeStats(IntervalStats beingRestored,IntervalStats onDevice){
  beingRestored.activeConfiguration=onDevice.activeConfiguration;
  beingRestored.configurations.putAll(onDevice.configurations);
  beingRestored.events=onDevice.events;
  return beingRestored;
}","/** 
 * Get the Configuration Statistics from the current device statistics and merge them with the backed up usage statistics.
 */
private IntervalStats mergeStats(IntervalStats beingRestored,IntervalStats onDevice){
  if (onDevice == null)   return beingRestored;
  if (beingRestored == null)   return null;
  beingRestored.activeConfiguration=onDevice.activeConfiguration;
  beingRestored.configurations.putAll(onDevice.configurations);
  beingRestored.events=onDevice.events;
  return beingRestored;
}",0.8997821350762527
192742,"protected void applyRestoredPayload(String key,byte[] payload){
synchronized (mLock) {
    if (KEY_USAGE_STATS.equals(key)) {
      IntervalStats dailyConfigSource=getLatestUsageStats(UsageStatsManager.INTERVAL_DAILY);
      IntervalStats weeklyConfigSource=getLatestUsageStats(UsageStatsManager.INTERVAL_WEEKLY);
      IntervalStats monthlyConfigSource=getLatestUsageStats(UsageStatsManager.INTERVAL_MONTHLY);
      IntervalStats yearlyConfigSource=getLatestUsageStats(UsageStatsManager.INTERVAL_YEARLY);
      for (int i=0; i < mIntervalDirs.length; i++) {
        deleteDirectoryContents(mIntervalDirs[i]);
      }
      try {
        DataInputStream in=new DataInputStream(new ByteArrayInputStream(payload));
        int stateVersion=in.readInt();
        int fileCount=in.readInt();
        for (int i=0; i < fileCount; i++) {
          IntervalStats stats=deserializeIntervalStats(getIntervalStatsBytes(in));
          stats=mergeStats(stats,dailyConfigSource);
          putUsageStats(UsageStatsManager.INTERVAL_DAILY,stats);
        }
        fileCount=in.readInt();
        for (int i=0; i < fileCount; i++) {
          IntervalStats stats=deserializeIntervalStats(getIntervalStatsBytes(in));
          stats=mergeStats(stats,weeklyConfigSource);
          putUsageStats(UsageStatsManager.INTERVAL_WEEKLY,stats);
        }
        fileCount=in.readInt();
        for (int i=0; i < fileCount; i++) {
          IntervalStats stats=deserializeIntervalStats(getIntervalStatsBytes(in));
          stats=mergeStats(stats,monthlyConfigSource);
          putUsageStats(UsageStatsManager.INTERVAL_MONTHLY,stats);
        }
        fileCount=in.readInt();
        for (int i=0; i < fileCount; i++) {
          IntervalStats stats=deserializeIntervalStats(getIntervalStatsBytes(in));
          stats=mergeStats(stats,yearlyConfigSource);
          putUsageStats(UsageStatsManager.INTERVAL_YEARLY,stats);
        }
        if (DEBUG)         Slog.i(TAG,""String_Node_Str"");
      }
 catch (      IOException ioe) {
        Slog.d(TAG,""String_Node_Str"",ioe);
      }
 finally {
        indexFilesLocked();
      }
    }
  }
}","void applyRestoredPayload(String key,byte[] payload){
synchronized (mLock) {
    if (KEY_USAGE_STATS.equals(key)) {
      IntervalStats dailyConfigSource=getLatestUsageStats(UsageStatsManager.INTERVAL_DAILY);
      IntervalStats weeklyConfigSource=getLatestUsageStats(UsageStatsManager.INTERVAL_WEEKLY);
      IntervalStats monthlyConfigSource=getLatestUsageStats(UsageStatsManager.INTERVAL_MONTHLY);
      IntervalStats yearlyConfigSource=getLatestUsageStats(UsageStatsManager.INTERVAL_YEARLY);
      try {
        DataInputStream in=new DataInputStream(new ByteArrayInputStream(payload));
        int backupDataVersion=in.readInt();
        if (backupDataVersion < 1 || backupDataVersion > BACKUP_VERSION)         return;
        for (int i=0; i < mIntervalDirs.length; i++) {
          deleteDirectoryContents(mIntervalDirs[i]);
        }
        int fileCount=in.readInt();
        for (int i=0; i < fileCount; i++) {
          IntervalStats stats=deserializeIntervalStats(getIntervalStatsBytes(in));
          stats=mergeStats(stats,dailyConfigSource);
          putUsageStats(UsageStatsManager.INTERVAL_DAILY,stats);
        }
        fileCount=in.readInt();
        for (int i=0; i < fileCount; i++) {
          IntervalStats stats=deserializeIntervalStats(getIntervalStatsBytes(in));
          stats=mergeStats(stats,weeklyConfigSource);
          putUsageStats(UsageStatsManager.INTERVAL_WEEKLY,stats);
        }
        fileCount=in.readInt();
        for (int i=0; i < fileCount; i++) {
          IntervalStats stats=deserializeIntervalStats(getIntervalStatsBytes(in));
          stats=mergeStats(stats,monthlyConfigSource);
          putUsageStats(UsageStatsManager.INTERVAL_MONTHLY,stats);
        }
        fileCount=in.readInt();
        for (int i=0; i < fileCount; i++) {
          IntervalStats stats=deserializeIntervalStats(getIntervalStatsBytes(in));
          stats=mergeStats(stats,yearlyConfigSource);
          putUsageStats(UsageStatsManager.INTERVAL_YEARLY,stats);
        }
        if (DEBUG)         Slog.i(TAG,""String_Node_Str"");
      }
 catch (      IOException ioe) {
        Slog.d(TAG,""String_Node_Str"",ioe);
      }
 finally {
        indexFilesLocked();
      }
    }
  }
}",0.91270207852194
192743,"protected byte[] getBackupPayload(String key){
synchronized (mLock) {
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    if (KEY_USAGE_STATS.equals(key)) {
      prune(System.currentTimeMillis());
      DataOutputStream out=new DataOutputStream(baos);
      try {
        out.writeInt(BACKUP_STATE_VERSION);
        out.writeInt(mSortedStatFiles[UsageStatsManager.INTERVAL_DAILY].size());
        for (int i=0; i < mSortedStatFiles[UsageStatsManager.INTERVAL_DAILY].size(); i++) {
          writeIntervalStatsToStream(out,mSortedStatFiles[UsageStatsManager.INTERVAL_DAILY].valueAt(i));
        }
        out.writeInt(mSortedStatFiles[UsageStatsManager.INTERVAL_WEEKLY].size());
        for (int i=0; i < mSortedStatFiles[UsageStatsManager.INTERVAL_WEEKLY].size(); i++) {
          writeIntervalStatsToStream(out,mSortedStatFiles[UsageStatsManager.INTERVAL_WEEKLY].valueAt(i));
        }
        out.writeInt(mSortedStatFiles[UsageStatsManager.INTERVAL_MONTHLY].size());
        for (int i=0; i < mSortedStatFiles[UsageStatsManager.INTERVAL_MONTHLY].size(); i++) {
          writeIntervalStatsToStream(out,mSortedStatFiles[UsageStatsManager.INTERVAL_MONTHLY].valueAt(i));
        }
        out.writeInt(mSortedStatFiles[UsageStatsManager.INTERVAL_YEARLY].size());
        for (int i=0; i < mSortedStatFiles[UsageStatsManager.INTERVAL_YEARLY].size(); i++) {
          writeIntervalStatsToStream(out,mSortedStatFiles[UsageStatsManager.INTERVAL_YEARLY].valueAt(i));
        }
        if (DEBUG)         Slog.i(TAG,""String_Node_Str"" + baos.size() + ""String_Node_Str"");
      }
 catch (      IOException ioe) {
        Slog.d(TAG,""String_Node_Str"",ioe);
        baos.reset();
      }
    }
    return baos.toByteArray();
  }
}","byte[] getBackupPayload(String key){
synchronized (mLock) {
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    if (KEY_USAGE_STATS.equals(key)) {
      prune(System.currentTimeMillis());
      DataOutputStream out=new DataOutputStream(baos);
      try {
        out.writeInt(BACKUP_VERSION);
        out.writeInt(mSortedStatFiles[UsageStatsManager.INTERVAL_DAILY].size());
        for (int i=0; i < mSortedStatFiles[UsageStatsManager.INTERVAL_DAILY].size(); i++) {
          writeIntervalStatsToStream(out,mSortedStatFiles[UsageStatsManager.INTERVAL_DAILY].valueAt(i));
        }
        out.writeInt(mSortedStatFiles[UsageStatsManager.INTERVAL_WEEKLY].size());
        for (int i=0; i < mSortedStatFiles[UsageStatsManager.INTERVAL_WEEKLY].size(); i++) {
          writeIntervalStatsToStream(out,mSortedStatFiles[UsageStatsManager.INTERVAL_WEEKLY].valueAt(i));
        }
        out.writeInt(mSortedStatFiles[UsageStatsManager.INTERVAL_MONTHLY].size());
        for (int i=0; i < mSortedStatFiles[UsageStatsManager.INTERVAL_MONTHLY].size(); i++) {
          writeIntervalStatsToStream(out,mSortedStatFiles[UsageStatsManager.INTERVAL_MONTHLY].valueAt(i));
        }
        out.writeInt(mSortedStatFiles[UsageStatsManager.INTERVAL_YEARLY].size());
        for (int i=0; i < mSortedStatFiles[UsageStatsManager.INTERVAL_YEARLY].size(); i++) {
          writeIntervalStatsToStream(out,mSortedStatFiles[UsageStatsManager.INTERVAL_YEARLY].valueAt(i));
        }
        if (DEBUG)         Slog.i(TAG,""String_Node_Str"" + baos.size() + ""String_Node_Str"");
      }
 catch (      IOException ioe) {
        Slog.d(TAG,""String_Node_Str"",ioe);
        baos.reset();
      }
    }
    return baos.toByteArray();
  }
}",0.9953623188405796
192744,"/** 
 * Update the stats in the database. They may not be written to disk immediately.
 */
public void putUsageStats(int intervalType,IntervalStats stats) throws IOException {
synchronized (mLock) {
    if (intervalType < 0 || intervalType >= mIntervalDirs.length) {
      throw new IllegalArgumentException(""String_Node_Str"" + intervalType);
    }
    AtomicFile f=mSortedStatFiles[intervalType].get(stats.beginTime);
    if (f == null) {
      f=new AtomicFile(new File(mIntervalDirs[intervalType],Long.toString(stats.beginTime)));
      mSortedStatFiles[intervalType].put(stats.beginTime,f);
    }
    UsageStatsXml.write(f,stats);
    stats.lastTimeSaved=f.getLastModifiedTime();
  }
}","/** 
 * Update the stats in the database. They may not be written to disk immediately.
 */
public void putUsageStats(int intervalType,IntervalStats stats) throws IOException {
  if (stats == null)   return;
synchronized (mLock) {
    if (intervalType < 0 || intervalType >= mIntervalDirs.length) {
      throw new IllegalArgumentException(""String_Node_Str"" + intervalType);
    }
    AtomicFile f=mSortedStatFiles[intervalType].get(stats.beginTime);
    if (f == null) {
      f=new AtomicFile(new File(mIntervalDirs[intervalType],Long.toString(stats.beginTime)));
      mSortedStatFiles[intervalType].put(stats.beginTime,f);
    }
    UsageStatsXml.write(f,stats);
    stats.lastTimeSaved=f.getLastModifiedTime();
  }
}",0.977998580553584
192745,"private static void deleteDirectory(File directory){
  File[] files=directory.listFiles();
  for (  File file : files) {
    if (!file.isDirectory()) {
      file.delete();
    }
 else {
      deleteDirectory(file);
    }
  }
  directory.delete();
}","private static void deleteDirectory(File directory){
  File[] files=directory.listFiles();
  if (files != null) {
    for (    File file : files) {
      if (!file.isDirectory()) {
        file.delete();
      }
 else {
        deleteDirectory(file);
      }
    }
  }
  directory.delete();
}",0.6876155268022182
192746,"public void startListening(){
  mListening=true;
  mContext.getContentResolver().registerContentObserver(Settings.System.getUriFor(SHOW_PERCENT_SETTING),false,mSettingObserver);
  if (mDemoMode)   return;
  mBatteryController.addStateChangedCallback(this);
}","public void startListening(){
  mListening=true;
  mContext.getContentResolver().registerContentObserver(Settings.System.getUriFor(SHOW_PERCENT_SETTING),false,mSettingObserver);
  updateShowPercent();
  if (mDemoMode)   return;
  mBatteryController.addStateChangedCallback(this);
}",0.9573283858998144
192747,"private void bindView(){
  mDrawable.onBatteryLevelChanged(100,false,false);
  mDrawable.onPowerSaveChanged(true);
  ((ImageView)mCurrentView.findViewById(android.R.id.icon)).setImageDrawable(mDrawable);
  Checkable checkbox=(Checkable)mCurrentView.findViewById(android.R.id.toggle);
  checkbox.setChecked(mPowerSave);
  if (mCharging) {
    BatteryInfo.getBatteryInfo(mContext,new BatteryInfo.Callback(){
      @Override public void onBatteryInfoLoaded(      BatteryInfo info){
        if (mCurrentView != null && mCharging) {
          ((TextView)mCurrentView.findViewById(android.R.id.title)).setText(info.mChargeLabelString);
        }
      }
    }
);
    ((TextView)mCurrentView.findViewById(android.R.id.summary)).setText(R.string.battery_detail_charging_summary);
    mCurrentView.setClickable(false);
    mCurrentView.findViewById(android.R.id.icon).setVisibility(View.INVISIBLE);
    mCurrentView.findViewById(android.R.id.toggle).setVisibility(View.INVISIBLE);
  }
 else {
    ((TextView)mCurrentView.findViewById(android.R.id.title)).setText(R.string.battery_detail_switch_title);
    ((TextView)mCurrentView.findViewById(android.R.id.summary)).setText(R.string.battery_detail_switch_summary);
    mCurrentView.setClickable(true);
    mCurrentView.findViewById(android.R.id.icon).setVisibility(View.VISIBLE);
    mCurrentView.findViewById(android.R.id.toggle).setVisibility(View.VISIBLE);
    mCurrentView.setOnClickListener(this);
  }
}","private void bindView(){
  mDrawable.onBatteryLevelChanged(100,false,false);
  mDrawable.onPowerSaveChanged(true);
  mDrawable.disableShowPercent();
  ((ImageView)mCurrentView.findViewById(android.R.id.icon)).setImageDrawable(mDrawable);
  Checkable checkbox=(Checkable)mCurrentView.findViewById(android.R.id.toggle);
  checkbox.setChecked(mPowerSave);
  if (mCharging) {
    BatteryInfo.getBatteryInfo(mContext,new BatteryInfo.Callback(){
      @Override public void onBatteryInfoLoaded(      BatteryInfo info){
        if (mCurrentView != null && mCharging) {
          ((TextView)mCurrentView.findViewById(android.R.id.title)).setText(info.mChargeLabelString);
        }
      }
    }
);
    ((TextView)mCurrentView.findViewById(android.R.id.summary)).setText(R.string.battery_detail_charging_summary);
    mCurrentView.setClickable(false);
    mCurrentView.findViewById(android.R.id.icon).setVisibility(View.INVISIBLE);
    mCurrentView.findViewById(android.R.id.toggle).setVisibility(View.INVISIBLE);
  }
 else {
    ((TextView)mCurrentView.findViewById(android.R.id.title)).setText(R.string.battery_detail_switch_title);
    ((TextView)mCurrentView.findViewById(android.R.id.summary)).setText(R.string.battery_detail_switch_summary);
    mCurrentView.setClickable(true);
    mCurrentView.findViewById(android.R.id.icon).setVisibility(View.VISIBLE);
    mCurrentView.findViewById(android.R.id.toggle).setVisibility(View.VISIBLE);
    mCurrentView.setOnClickListener(this);
  }
}",0.9884038199181446
192748,"@Override public void onServiceConnected(int profile,BluetoothProfile proxy){
  ((BluetoothPan)proxy).setBluetoothTethering(enable);
  int result=((BluetoothPan)proxy).isTetheringOn() ? ConnectivityManager.TETHER_ERROR_NO_ERROR : ConnectivityManager.TETHER_ERROR_MASTER_ERROR;
  sendTetherResult(receiver,result);
  if (enable && isTetherProvisioningRequired()) {
    scheduleProvisioningRechecks(ConnectivityManager.TETHERING_BLUETOOTH);
  }
  adapter.closeProfileProxy(BluetoothProfile.PAN,proxy);
}","@Override public void onServiceConnected(int profile,BluetoothProfile proxy){
  ((BluetoothPan)proxy).setBluetoothTethering(enable);
  int result=((BluetoothPan)proxy).isTetheringOn() == enable ? ConnectivityManager.TETHER_ERROR_NO_ERROR : ConnectivityManager.TETHER_ERROR_MASTER_ERROR;
  sendTetherResult(receiver,result);
  if (enable && isTetherProvisioningRequired()) {
    scheduleProvisioningRechecks(ConnectivityManager.TETHERING_BLUETOOTH);
  }
  adapter.closeProfileProxy(BluetoothProfile.PAN,proxy);
}",0.9901185770750988
192749,"private void setBluetoothTethering(final boolean enable,final ResultReceiver receiver){
  final BluetoothAdapter adapter=BluetoothAdapter.getDefaultAdapter();
  if (adapter == null || !adapter.isEnabled()) {
    Log.w(TAG,""String_Node_Str"" + (adapter == null));
    sendTetherResult(receiver,ConnectivityManager.TETHER_ERROR_SERVICE_UNAVAIL);
    return;
  }
  adapter.getProfileProxy(mContext,new ServiceListener(){
    @Override public void onServiceDisconnected(    int profile){
    }
    @Override public void onServiceConnected(    int profile,    BluetoothProfile proxy){
      ((BluetoothPan)proxy).setBluetoothTethering(enable);
      int result=((BluetoothPan)proxy).isTetheringOn() ? ConnectivityManager.TETHER_ERROR_NO_ERROR : ConnectivityManager.TETHER_ERROR_MASTER_ERROR;
      sendTetherResult(receiver,result);
      if (enable && isTetherProvisioningRequired()) {
        scheduleProvisioningRechecks(ConnectivityManager.TETHERING_BLUETOOTH);
      }
      adapter.closeProfileProxy(BluetoothProfile.PAN,proxy);
    }
  }
,BluetoothProfile.PAN);
}","private void setBluetoothTethering(final boolean enable,final ResultReceiver receiver){
  final BluetoothAdapter adapter=BluetoothAdapter.getDefaultAdapter();
  if (adapter == null || !adapter.isEnabled()) {
    Log.w(TAG,""String_Node_Str"" + (adapter == null));
    sendTetherResult(receiver,ConnectivityManager.TETHER_ERROR_SERVICE_UNAVAIL);
    return;
  }
  adapter.getProfileProxy(mContext,new ServiceListener(){
    @Override public void onServiceDisconnected(    int profile){
    }
    @Override public void onServiceConnected(    int profile,    BluetoothProfile proxy){
      ((BluetoothPan)proxy).setBluetoothTethering(enable);
      int result=((BluetoothPan)proxy).isTetheringOn() == enable ? ConnectivityManager.TETHER_ERROR_NO_ERROR : ConnectivityManager.TETHER_ERROR_MASTER_ERROR;
      sendTetherResult(receiver,result);
      if (enable && isTetherProvisioningRequired()) {
        scheduleProvisioningRechecks(ConnectivityManager.TETHERING_BLUETOOTH);
      }
      adapter.closeProfileProxy(BluetoothProfile.PAN,proxy);
    }
  }
,BluetoothProfile.PAN);
}",0.9953227315247896
192750,"public void startListening(){
  mListening=true;
  mContext.getContentResolver().registerContentObserver(Settings.System.getUriFor(SHOW_PERCENT_SETTING),false,mSettingObserver);
  if (mDemoMode)   return;
  mBatteryController.addStateChangedCallback(this);
}","public void startListening(){
  mListening=true;
  mContext.getContentResolver().registerContentObserver(Settings.System.getUriFor(SHOW_PERCENT_SETTING),false,mSettingObserver);
  updateShowPercent();
  if (mDemoMode)   return;
  mBatteryController.addStateChangedCallback(this);
}",0.9573283858998144
192751,"private void bindView(){
  mDrawable.onBatteryLevelChanged(100,false,false);
  mDrawable.onPowerSaveChanged(true);
  ((ImageView)mCurrentView.findViewById(android.R.id.icon)).setImageDrawable(mDrawable);
  Checkable checkbox=(Checkable)mCurrentView.findViewById(android.R.id.toggle);
  checkbox.setChecked(mPowerSave);
  if (mCharging) {
    BatteryInfo.getBatteryInfo(mContext,new BatteryInfo.Callback(){
      @Override public void onBatteryInfoLoaded(      BatteryInfo info){
        if (mCurrentView != null && mCharging) {
          ((TextView)mCurrentView.findViewById(android.R.id.title)).setText(info.mChargeLabelString);
        }
      }
    }
);
    ((TextView)mCurrentView.findViewById(android.R.id.summary)).setText(R.string.battery_detail_charging_summary);
    mCurrentView.setClickable(false);
    mCurrentView.findViewById(android.R.id.icon).setVisibility(View.INVISIBLE);
    mCurrentView.findViewById(android.R.id.toggle).setVisibility(View.INVISIBLE);
  }
 else {
    ((TextView)mCurrentView.findViewById(android.R.id.title)).setText(R.string.battery_detail_switch_title);
    ((TextView)mCurrentView.findViewById(android.R.id.summary)).setText(R.string.battery_detail_switch_summary);
    mCurrentView.setClickable(true);
    mCurrentView.findViewById(android.R.id.icon).setVisibility(View.VISIBLE);
    mCurrentView.findViewById(android.R.id.toggle).setVisibility(View.VISIBLE);
    mCurrentView.setOnClickListener(this);
  }
}","private void bindView(){
  mDrawable.onBatteryLevelChanged(100,false,false);
  mDrawable.onPowerSaveChanged(true);
  mDrawable.disableShowPercent();
  ((ImageView)mCurrentView.findViewById(android.R.id.icon)).setImageDrawable(mDrawable);
  Checkable checkbox=(Checkable)mCurrentView.findViewById(android.R.id.toggle);
  checkbox.setChecked(mPowerSave);
  if (mCharging) {
    BatteryInfo.getBatteryInfo(mContext,new BatteryInfo.Callback(){
      @Override public void onBatteryInfoLoaded(      BatteryInfo info){
        if (mCurrentView != null && mCharging) {
          ((TextView)mCurrentView.findViewById(android.R.id.title)).setText(info.mChargeLabelString);
        }
      }
    }
);
    ((TextView)mCurrentView.findViewById(android.R.id.summary)).setText(R.string.battery_detail_charging_summary);
    mCurrentView.setClickable(false);
    mCurrentView.findViewById(android.R.id.icon).setVisibility(View.INVISIBLE);
    mCurrentView.findViewById(android.R.id.toggle).setVisibility(View.INVISIBLE);
  }
 else {
    ((TextView)mCurrentView.findViewById(android.R.id.title)).setText(R.string.battery_detail_switch_title);
    ((TextView)mCurrentView.findViewById(android.R.id.summary)).setText(R.string.battery_detail_switch_summary);
    mCurrentView.setClickable(true);
    mCurrentView.findViewById(android.R.id.icon).setVisibility(View.VISIBLE);
    mCurrentView.findViewById(android.R.id.toggle).setVisibility(View.VISIBLE);
    mCurrentView.setOnClickListener(this);
  }
}",0.9884038199181446
192752,"@Override public void onServiceConnected(int profile,BluetoothProfile proxy){
  ((BluetoothPan)proxy).setBluetoothTethering(enable);
  int result=((BluetoothPan)proxy).isTetheringOn() ? ConnectivityManager.TETHER_ERROR_NO_ERROR : ConnectivityManager.TETHER_ERROR_MASTER_ERROR;
  sendTetherResult(receiver,result);
  if (enable && isTetherProvisioningRequired()) {
    scheduleProvisioningRechecks(ConnectivityManager.TETHERING_BLUETOOTH);
  }
  adapter.closeProfileProxy(BluetoothProfile.PAN,proxy);
}","@Override public void onServiceConnected(int profile,BluetoothProfile proxy){
  ((BluetoothPan)proxy).setBluetoothTethering(enable);
  int result=((BluetoothPan)proxy).isTetheringOn() == enable ? ConnectivityManager.TETHER_ERROR_NO_ERROR : ConnectivityManager.TETHER_ERROR_MASTER_ERROR;
  sendTetherResult(receiver,result);
  if (enable && isTetherProvisioningRequired()) {
    scheduleProvisioningRechecks(ConnectivityManager.TETHERING_BLUETOOTH);
  }
  adapter.closeProfileProxy(BluetoothProfile.PAN,proxy);
}",0.9901185770750988
192753,"private void setBluetoothTethering(final boolean enable,final ResultReceiver receiver){
  final BluetoothAdapter adapter=BluetoothAdapter.getDefaultAdapter();
  if (adapter == null || !adapter.isEnabled()) {
    Log.w(TAG,""String_Node_Str"" + (adapter == null));
    sendTetherResult(receiver,ConnectivityManager.TETHER_ERROR_SERVICE_UNAVAIL);
    return;
  }
  adapter.getProfileProxy(mContext,new ServiceListener(){
    @Override public void onServiceDisconnected(    int profile){
    }
    @Override public void onServiceConnected(    int profile,    BluetoothProfile proxy){
      ((BluetoothPan)proxy).setBluetoothTethering(enable);
      int result=((BluetoothPan)proxy).isTetheringOn() ? ConnectivityManager.TETHER_ERROR_NO_ERROR : ConnectivityManager.TETHER_ERROR_MASTER_ERROR;
      sendTetherResult(receiver,result);
      if (enable && isTetherProvisioningRequired()) {
        scheduleProvisioningRechecks(ConnectivityManager.TETHERING_BLUETOOTH);
      }
      adapter.closeProfileProxy(BluetoothProfile.PAN,proxy);
    }
  }
,BluetoothProfile.PAN);
}","private void setBluetoothTethering(final boolean enable,final ResultReceiver receiver){
  final BluetoothAdapter adapter=BluetoothAdapter.getDefaultAdapter();
  if (adapter == null || !adapter.isEnabled()) {
    Log.w(TAG,""String_Node_Str"" + (adapter == null));
    sendTetherResult(receiver,ConnectivityManager.TETHER_ERROR_SERVICE_UNAVAIL);
    return;
  }
  adapter.getProfileProxy(mContext,new ServiceListener(){
    @Override public void onServiceDisconnected(    int profile){
    }
    @Override public void onServiceConnected(    int profile,    BluetoothProfile proxy){
      ((BluetoothPan)proxy).setBluetoothTethering(enable);
      int result=((BluetoothPan)proxy).isTetheringOn() == enable ? ConnectivityManager.TETHER_ERROR_NO_ERROR : ConnectivityManager.TETHER_ERROR_MASTER_ERROR;
      sendTetherResult(receiver,result);
      if (enable && isTetherProvisioningRequired()) {
        scheduleProvisioningRechecks(ConnectivityManager.TETHERING_BLUETOOTH);
      }
      adapter.closeProfileProxy(BluetoothProfile.PAN,proxy);
    }
  }
,BluetoothProfile.PAN);
}",0.9953227315247896
192754,"@Override public void onViewRecycled(ViewHolder holder){
  RecentsTaskLoader loader=Recents.getTaskLoader();
  int position=holder.getAdapterPosition();
  if (position != RecyclerView.NO_POSITION) {
    Row row=mRows.get(position);
    int viewType=row.getViewType();
    if (viewType == TASK_ROW_VIEW_TYPE) {
      TaskRow taskRow=(TaskRow)row;
      loader.unloadTaskData(taskRow.task);
      taskRow.task.removeCallback(holder);
    }
  }
}","@Override public void onViewRecycled(ViewHolder holder){
  RecentsTaskLoader loader=Recents.getTaskLoader();
  int position=holder.getAdapterPosition();
  if (position != RecyclerView.NO_POSITION) {
    Row row=mRows.get(position);
    int viewType=row.getViewType();
    if (viewType == TASK_ROW_VIEW_TYPE) {
      TaskRow taskRow=(TaskRow)row;
      loader.unloadTaskData(taskRow.task);
      holder.unbindFromTask();
    }
  }
}",0.9382151029748284
192755,"@Override public void onBindViewHolder(ViewHolder holder,int position){
  RecentsTaskLoader loader=Recents.getTaskLoader();
  Row row=mRows.get(position);
  int viewType=row.getViewType();
switch (viewType) {
case DATE_ROW_VIEW_TYPE:
{
      TextView tv=(TextView)holder.content;
      tv.setText(((DateRow)row).date);
      break;
    }
case TASK_ROW_VIEW_TYPE:
{
    TaskRow taskRow=(TaskRow)row;
    taskRow.task.addCallback(holder);
    TextView tv=(TextView)holder.content.findViewById(R.id.description);
    tv.setText(taskRow.task.title);
    ImageView iv=(ImageView)holder.content.findViewById(R.id.icon);
    iv.setAlpha(0f);
    holder.content.setOnClickListener(taskRow);
    loader.loadTaskData(taskRow.task,false);
    break;
  }
}
}","@Override public void onBindViewHolder(ViewHolder holder,int position){
  RecentsTaskLoader loader=Recents.getTaskLoader();
  Row row=mRows.get(position);
  int viewType=row.getViewType();
switch (viewType) {
case DATE_ROW_VIEW_TYPE:
{
      TextView tv=(TextView)holder.content;
      tv.setText(((DateRow)row).date);
      break;
    }
case TASK_ROW_VIEW_TYPE:
{
    TaskRow taskRow=(TaskRow)row;
    TextView tv=(TextView)holder.content.findViewById(R.id.description);
    tv.setText(taskRow.task.title);
    ImageView iv=(ImageView)holder.content.findViewById(R.id.icon);
    iv.setAlpha(0f);
    holder.content.setOnClickListener(taskRow);
    holder.bindToTask(taskRow.task);
    loader.loadTaskData(taskRow.task,false);
    break;
  }
}
}",0.9496981891348087
192756,"public ViewHolder(View v){
  super(v);
  content=v;
}","public ViewHolder(View content){
  super(content);
  this.content=content;
}",0.7751937984496124
192757,"/** 
 * Update/get the transform.
 * @param ignoreSingleTaskCase When set, will ensure that the transform computed does not takeinto account the special single-task case.  This is only used internally to ensure that we can calculate the transform for any position in the stack.
 */
public TaskViewTransform getStackTransform(float taskProgress,float stackScroll,TaskViewTransform transformOut,TaskViewTransform frontTransform,boolean ignoreSingleTaskCase){
  SystemServicesProxy ssp=Recents.getSystemServices();
  mUnfocusedRange.offset(stackScroll);
  float p=mUnfocusedRange.getNormalizedX(taskProgress);
  float yp=mUnfocusedCurveInterpolator.getInterpolation(p);
  float unfocusedP=p;
  int unFocusedY=(int)(Math.max(0f,(1f - yp)) * mStackRect.height());
  boolean unfocusedVisible=mUnfocusedRange.isInRange(taskProgress);
  int focusedY=0;
  boolean focusedVisible=true;
  if (mFocusState > 0f) {
    mFocusedRange.offset(stackScroll);
    p=mFocusedRange.getNormalizedX(taskProgress);
    yp=mFocusedCurveInterpolator.getInterpolation(p);
    focusedY=(int)(Math.max(0f,(1f - yp)) * mStackRect.height());
    focusedVisible=mFocusedRange.isInRange(taskProgress);
  }
  if (!unfocusedVisible && !focusedVisible) {
    transformOut.reset();
    return transformOut;
  }
  int x=(mStackRect.width() - mTaskRect.width()) / 2;
  int y;
  float z;
  float relP;
  if (!ssp.hasFreeformWorkspaceSupport() && mNumStackTasks == 1 && !ignoreSingleTaskCase) {
    p=(mMinScrollP - stackScroll) / mNumStackTasks;
    int centerYOffset=(mStackRect.top - mTaskRect.top) + (mStackRect.height() - mTaskRect.height()) / 2;
    y=centerYOffset + getYForDeltaP(p,0);
    z=mMaxTranslationZ;
    relP=1f;
  }
 else {
    y=unFocusedY + (int)(mFocusState * (focusedY - unFocusedY));
    y+=(mStackRect.top - mTaskRect.top);
    z=Math.max(mMinTranslationZ,Math.min(mMaxTranslationZ,mMinTranslationZ + (p * (mMaxTranslationZ - mMinTranslationZ))));
    if (mNumStackTasks == 1) {
      relP=1f;
    }
 else {
      relP=Math.min(mMaxScrollP,unfocusedP);
    }
  }
  transformOut.scale=1f;
  transformOut.alpha=1f;
  transformOut.translationZ=z;
  transformOut.rect.set(mTaskRect);
  transformOut.rect.offset(x,y);
  Utilities.scaleRectAboutCenter(transformOut.rect,transformOut.scale);
  transformOut.visible=(transformOut.rect.top < mStackRect.bottom) && (frontTransform == null || transformOut.rect.top != frontTransform.rect.top);
  transformOut.p=relP;
  return transformOut;
}","/** 
 * Update/get the transform.
 * @param ignoreSingleTaskCase When set, will ensure that the transform computed does not takeinto account the special single-task case.  This is only used internally to ensure that we can calculate the transform for any position in the stack.
 */
public void getStackTransform(float taskProgress,float stackScroll,TaskViewTransform transformOut,TaskViewTransform frontTransform,boolean ignoreSingleTaskCase,boolean forceUpdate){
  SystemServicesProxy ssp=Recents.getSystemServices();
  mUnfocusedRange.offset(stackScroll);
  float p=mUnfocusedRange.getNormalizedX(taskProgress);
  float yp=mUnfocusedCurveInterpolator.getInterpolation(p);
  float unfocusedP=p;
  int unFocusedY=(int)(Math.max(0f,(1f - yp)) * mStackRect.height());
  boolean unfocusedVisible=mUnfocusedRange.isInRange(taskProgress);
  int focusedY=0;
  boolean focusedVisible=true;
  if (mFocusState > 0f) {
    mFocusedRange.offset(stackScroll);
    p=mFocusedRange.getNormalizedX(taskProgress);
    yp=mFocusedCurveInterpolator.getInterpolation(p);
    focusedY=(int)(Math.max(0f,(1f - yp)) * mStackRect.height());
    focusedVisible=mFocusedRange.isInRange(taskProgress);
  }
  if (!forceUpdate && !unfocusedVisible && !focusedVisible) {
    transformOut.reset();
    return;
  }
  int x=(mStackRect.width() - mTaskRect.width()) / 2;
  int y;
  float z;
  float relP;
  if (!ssp.hasFreeformWorkspaceSupport() && mNumStackTasks == 1 && !ignoreSingleTaskCase) {
    p=(mMinScrollP - stackScroll) / mNumStackTasks;
    int centerYOffset=(mStackRect.top - mTaskRect.top) + (mStackRect.height() - mTaskRect.height()) / 2;
    y=centerYOffset + getYForDeltaP(p,0);
    z=mMaxTranslationZ;
    relP=1f;
  }
 else {
    y=unFocusedY + (int)(mFocusState * (focusedY - unFocusedY));
    y+=(mStackRect.top - mTaskRect.top);
    z=Math.max(mMinTranslationZ,Math.min(mMaxTranslationZ,mMinTranslationZ + (p * (mMaxTranslationZ - mMinTranslationZ))));
    if (mNumStackTasks == 1) {
      relP=1f;
    }
 else {
      relP=Math.min(mMaxScrollP,unfocusedP);
    }
  }
  transformOut.scale=1f;
  transformOut.alpha=1f;
  transformOut.translationZ=z;
  transformOut.rect.set(mTaskRect);
  transformOut.rect.offset(x,y);
  Utilities.scaleRectAboutCenter(transformOut.rect,transformOut.scale);
  transformOut.visible=(transformOut.rect.top < mStackRect.bottom) && (frontTransform == null || transformOut.rect.top != frontTransform.rect.top);
  transformOut.p=relP;
}",0.9749745676500507
192758,"/** 
 * Updates the current transforms that would put a TaskView at the front and back of the stack.
 */
private void updateFrontBackTransforms(){
  if (mStackRect.isEmpty()) {
    return;
  }
  float min=mUnfocusedRange.relativeMin + mFocusState * (mFocusedRange.relativeMin - mUnfocusedRange.relativeMin);
  float max=mUnfocusedRange.relativeMax + mFocusState * (mFocusedRange.relativeMax - mUnfocusedRange.relativeMax);
  getStackTransform(min,0f,mBackOfStackTransform,null,true);
  getStackTransform(max,0f,mFrontOfStackTransform,null,true);
  mBackOfStackTransform.visible=true;
  mFrontOfStackTransform.visible=true;
}","/** 
 * Updates the current transforms that would put a TaskView at the front and back of the stack.
 */
private void updateFrontBackTransforms(){
  if (mStackRect.isEmpty()) {
    return;
  }
  float min=mUnfocusedRange.relativeMin + mFocusState * (mFocusedRange.relativeMin - mUnfocusedRange.relativeMin);
  float max=mUnfocusedRange.relativeMax + mFocusState * (mFocusedRange.relativeMax - mUnfocusedRange.relativeMax);
  getStackTransform(min,0f,mBackOfStackTransform,null,true,true);
  getStackTransform(max,0f,mFrontOfStackTransform,null,true,true);
  mBackOfStackTransform.visible=true;
  mFrontOfStackTransform.visible=true;
}",0.9920508744038156
192759,"/** 
 * Computes the maximum number of visible tasks and thumbnails when the scroll is at the initial stack scroll.  Requires that update() is called first.
 */
public VisibilityReport computeStackVisibilityReport(ArrayList<Task> tasks){
  if (tasks.size() <= 1) {
    return new VisibilityReport(1,1);
  }
  if (mNumStackTasks == 0) {
    return new VisibilityReport(Math.max(mNumFreeformTasks,1),Math.max(mNumFreeformTasks,1));
  }
  TaskViewTransform tmpTransform=new TaskViewTransform();
  Range currentRange=getDefaultFocusState() > 0f ? mFocusedRange : mUnfocusedRange;
  currentRange.offset(mInitialScrollP);
  int taskBarHeight=mContext.getResources().getDimensionPixelSize(R.dimen.recents_task_bar_height);
  int numVisibleTasks=Math.max(mNumFreeformTasks,1);
  int numVisibleThumbnails=Math.max(mNumFreeformTasks,1);
  float prevScreenY=Integer.MAX_VALUE;
  for (int i=tasks.size() - 1; i >= 0; i--) {
    Task task=tasks.get(i);
    if (task.isFreeformTask()) {
      continue;
    }
    float taskProgress=getStackScrollForTask(task);
    if (!currentRange.isInRange(taskProgress)) {
      continue;
    }
    boolean isFrontMostTaskInGroup=task.group == null || task.group.isFrontMostTask(task);
    if (isFrontMostTaskInGroup) {
      getStackTransform(taskProgress,mInitialScrollP,tmpTransform,null,false);
      float screenY=tmpTransform.rect.top;
      boolean hasVisibleThumbnail=(prevScreenY - screenY) > taskBarHeight;
      if (hasVisibleThumbnail) {
        numVisibleThumbnails++;
        numVisibleTasks++;
        prevScreenY=screenY;
      }
 else {
        for (int j=i; j >= 0; j--) {
          numVisibleTasks++;
          taskProgress=getStackScrollForTask(tasks.get(j));
          if (!currentRange.isInRange(taskProgress)) {
            continue;
          }
        }
        break;
      }
    }
 else     if (!isFrontMostTaskInGroup) {
      numVisibleTasks++;
    }
  }
  return new VisibilityReport(numVisibleTasks,numVisibleThumbnails);
}","/** 
 * Computes the maximum number of visible tasks and thumbnails when the scroll is at the initial stack scroll.  Requires that update() is called first.
 */
public VisibilityReport computeStackVisibilityReport(ArrayList<Task> tasks){
  if (tasks.size() <= 1) {
    return new VisibilityReport(1,1);
  }
  if (mNumStackTasks == 0) {
    return new VisibilityReport(Math.max(mNumFreeformTasks,1),Math.max(mNumFreeformTasks,1));
  }
  TaskViewTransform tmpTransform=new TaskViewTransform();
  Range currentRange=getDefaultFocusState() > 0f ? mFocusedRange : mUnfocusedRange;
  currentRange.offset(mInitialScrollP);
  int taskBarHeight=mContext.getResources().getDimensionPixelSize(R.dimen.recents_task_bar_height);
  int numVisibleTasks=Math.max(mNumFreeformTasks,1);
  int numVisibleThumbnails=Math.max(mNumFreeformTasks,1);
  float prevScreenY=Integer.MAX_VALUE;
  for (int i=tasks.size() - 1; i >= 0; i--) {
    Task task=tasks.get(i);
    if (task.isFreeformTask()) {
      continue;
    }
    float taskProgress=getStackScrollForTask(task);
    if (!currentRange.isInRange(taskProgress)) {
      continue;
    }
    boolean isFrontMostTaskInGroup=task.group == null || task.group.isFrontMostTask(task);
    if (isFrontMostTaskInGroup) {
      getStackTransform(taskProgress,mInitialScrollP,tmpTransform,null,false,false);
      float screenY=tmpTransform.rect.top;
      boolean hasVisibleThumbnail=(prevScreenY - screenY) > taskBarHeight;
      if (hasVisibleThumbnail) {
        numVisibleThumbnails++;
        numVisibleTasks++;
        prevScreenY=screenY;
      }
 else {
        for (int j=i; j >= 0; j--) {
          numVisibleTasks++;
          taskProgress=getStackScrollForTask(tasks.get(j));
          if (!currentRange.isInRange(taskProgress)) {
            continue;
          }
        }
        break;
      }
    }
 else     if (!isFrontMostTaskInGroup) {
      numVisibleTasks++;
    }
  }
  return new VisibilityReport(numVisibleTasks,numVisibleThumbnails);
}",0.9984848484848484
192760,"/** 
 * Returns the current task transforms of all tasks, falling back to the stack layout if there is no   {@link TaskView} for the task.
 */
public void getCurrentTaskTransforms(ArrayList<Task> tasks,ArrayList<TaskViewTransform> transformsOut){
  Utilities.matchTaskListSize(tasks,transformsOut);
  for (int i=tasks.size() - 1; i >= 0; i--) {
    Task task=tasks.get(i);
    TaskViewTransform transform=transformsOut.get(i);
    TaskView tv=getChildViewForTask(task);
    if (tv != null) {
      transform.fillIn(tv);
    }
 else {
      mLayoutAlgorithm.getStackTransform(task,mStackScroller.getStackScroll(),transform,null);
    }
    transform.visible=true;
  }
}","/** 
 * Returns the current task transforms of all tasks, falling back to the stack layout if there is no   {@link TaskView} for the task.
 */
public void getCurrentTaskTransforms(ArrayList<Task> tasks,ArrayList<TaskViewTransform> transformsOut){
  Utilities.matchTaskListSize(tasks,transformsOut);
  for (int i=tasks.size() - 1; i >= 0; i--) {
    Task task=tasks.get(i);
    TaskViewTransform transform=transformsOut.get(i);
    TaskView tv=getChildViewForTask(task);
    if (tv != null) {
      transform.fillIn(tv);
    }
 else {
      mLayoutAlgorithm.getStackTransform(task,mStackScroller.getStackScroll(),transform,null,true);
    }
    transform.visible=true;
  }
}",0.9962714392244594
192761,"/** 
 * Called after the   {@link TaskView} is finished animating back into the list.onChildDismissed() calls.
 */
@Override public void onChildSnappedBack(View v){
  TaskView tv=(TaskView)v;
  tv.setClipViewInStack(true);
  tv.setTouchEnabled(true);
  mSv.removeIgnoreTask(tv.getTask());
  mSv.updateLayoutAlgorithm(false);
  mSwipeHelperAnimations.remove(v);
}","/** 
 * Called after the   {@link TaskView} is finished animating back into the list.onChildDismissed() calls.
 */
@Override public void onChildSnappedBack(View v){
  TaskView tv=(TaskView)v;
  tv.setClipViewInStack(true);
  tv.setTouchEnabled(true);
  mSv.removeIgnoreTask(tv.getTask());
  mSv.updateLayoutAlgorithm(false);
  mSv.relayoutTaskViews(AnimationProps.IMMEDIATE);
  mSwipeHelperAnimations.remove(v);
}",0.9341935483870968
192762,"public void dispatchResized(Rect frame,Rect overscanInsets,Rect contentInsets,Rect visibleInsets,Rect stableInsets,Rect outsets,boolean reportDraw,Configuration newConfig,Rect backDropFrame,boolean forceLayout){
  if (DEBUG_LAYOUT)   Log.v(mTag,""String_Node_Str"" + this + ""String_Node_Str""+ frame.toShortString()+ ""String_Node_Str""+ contentInsets.toShortString()+ ""String_Node_Str""+ visibleInsets.toShortString()+ ""String_Node_Str""+ reportDraw+ ""String_Node_Str""+ backDropFrame);
  if (mDragResizing) {
synchronized (mWindowCallbacks) {
      for (int i=mWindowCallbacks.size() - 1; i >= 0; i--) {
        mWindowCallbacks.get(i).onWindowSizeIsChanging(backDropFrame);
      }
    }
  }
  Message msg=mHandler.obtainMessage(reportDraw ? MSG_RESIZED_REPORT : MSG_RESIZED);
  if (mTranslator != null) {
    mTranslator.translateRectInScreenToAppWindow(frame);
    mTranslator.translateRectInScreenToAppWindow(overscanInsets);
    mTranslator.translateRectInScreenToAppWindow(contentInsets);
    mTranslator.translateRectInScreenToAppWindow(visibleInsets);
  }
  SomeArgs args=SomeArgs.obtain();
  final boolean sameProcessCall=(Binder.getCallingPid() == android.os.Process.myPid());
  args.arg1=sameProcessCall ? new Rect(frame) : frame;
  args.arg2=sameProcessCall ? new Rect(contentInsets) : contentInsets;
  args.arg3=sameProcessCall ? new Rect(visibleInsets) : visibleInsets;
  args.arg4=sameProcessCall && newConfig != null ? new Configuration(newConfig) : newConfig;
  args.arg5=sameProcessCall ? new Rect(overscanInsets) : overscanInsets;
  args.arg6=sameProcessCall ? new Rect(stableInsets) : stableInsets;
  args.arg7=sameProcessCall ? new Rect(outsets) : outsets;
  args.arg8=sameProcessCall ? new Rect(backDropFrame) : backDropFrame;
  args.argi1=forceLayout ? 1 : 0;
  msg.obj=args;
  mHandler.sendMessage(msg);
}","public void dispatchResized(Rect frame,Rect overscanInsets,Rect contentInsets,Rect visibleInsets,Rect stableInsets,Rect outsets,boolean reportDraw,Configuration newConfig,Rect backDropFrame,boolean forceLayout){
  if (DEBUG_LAYOUT)   Log.v(mTag,""String_Node_Str"" + this + ""String_Node_Str""+ frame.toShortString()+ ""String_Node_Str""+ contentInsets.toShortString()+ ""String_Node_Str""+ visibleInsets.toShortString()+ ""String_Node_Str""+ reportDraw+ ""String_Node_Str""+ backDropFrame);
  if (mDragResizing) {
    boolean fullscreen=frame.equals(backDropFrame);
synchronized (mWindowCallbacks) {
      for (int i=mWindowCallbacks.size() - 1; i >= 0; i--) {
        mWindowCallbacks.get(i).onWindowSizeIsChanging(backDropFrame,fullscreen,visibleInsets,stableInsets);
      }
    }
  }
  Message msg=mHandler.obtainMessage(reportDraw ? MSG_RESIZED_REPORT : MSG_RESIZED);
  if (mTranslator != null) {
    mTranslator.translateRectInScreenToAppWindow(frame);
    mTranslator.translateRectInScreenToAppWindow(overscanInsets);
    mTranslator.translateRectInScreenToAppWindow(contentInsets);
    mTranslator.translateRectInScreenToAppWindow(visibleInsets);
  }
  SomeArgs args=SomeArgs.obtain();
  final boolean sameProcessCall=(Binder.getCallingPid() == android.os.Process.myPid());
  args.arg1=sameProcessCall ? new Rect(frame) : frame;
  args.arg2=sameProcessCall ? new Rect(contentInsets) : contentInsets;
  args.arg3=sameProcessCall ? new Rect(visibleInsets) : visibleInsets;
  args.arg4=sameProcessCall && newConfig != null ? new Configuration(newConfig) : newConfig;
  args.arg5=sameProcessCall ? new Rect(overscanInsets) : overscanInsets;
  args.arg6=sameProcessCall ? new Rect(stableInsets) : stableInsets;
  args.arg7=sameProcessCall ? new Rect(outsets) : outsets;
  args.arg8=sameProcessCall ? new Rect(backDropFrame) : backDropFrame;
  args.argi1=forceLayout ? 1 : 0;
  msg.obj=args;
  mHandler.sendMessage(msg);
}",0.9759100642398288
192763,"/** 
 * Start a drag resizing which will inform all listeners that a window resize is taking place.
 */
private void startDragResizing(Rect initialBounds){
  if (!mDragResizing) {
    mDragResizing=true;
synchronized (mWindowCallbacks) {
      for (int i=mWindowCallbacks.size() - 1; i >= 0; i--) {
        mWindowCallbacks.get(i).onWindowDragResizeStart(initialBounds);
      }
    }
    mFullRedrawNeeded=true;
  }
}","/** 
 * Start a drag resizing which will inform all listeners that a window resize is taking place.
 */
private void startDragResizing(Rect initialBounds,boolean fullscreen,Rect systemInsets,Rect stableInsets){
  if (!mDragResizing) {
    mDragResizing=true;
synchronized (mWindowCallbacks) {
      for (int i=mWindowCallbacks.size() - 1; i >= 0; i--) {
        mWindowCallbacks.get(i).onWindowDragResizeStart(initialBounds,fullscreen,systemInsets,stableInsets);
      }
    }
    mFullRedrawNeeded=true;
  }
}",0.9008620689655172
192764,"private void performTraversals(){
  final View host=mView;
  if (DBG) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    host.debug();
  }
  if (host == null || !mAdded)   return;
  mIsInTraversal=true;
  mWillDrawSoon=true;
  boolean windowSizeMayChange=false;
  boolean newSurface=false;
  boolean surfaceChanged=false;
  WindowManager.LayoutParams lp=mWindowAttributes;
  int desiredWindowWidth;
  int desiredWindowHeight;
  final int viewVisibility=getHostVisibility();
  final boolean viewVisibilityChanged=!mFirst && (mViewVisibility != viewVisibility || mNewSurfaceNeeded);
  WindowManager.LayoutParams params=null;
  if (mWindowAttributesChanged) {
    mWindowAttributesChanged=false;
    surfaceChanged=true;
    params=lp;
  }
  CompatibilityInfo compatibilityInfo=mDisplayAdjustments.getCompatibilityInfo();
  if (compatibilityInfo.supportsScreen() == mLastInCompatMode) {
    params=lp;
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (mLastInCompatMode) {
      params.privateFlags&=~WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=false;
    }
 else {
      params.privateFlags|=WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=true;
    }
  }
  mWindowAttributesChangesFlag=0;
  Rect frame=mWinFrame;
  if (mFirst) {
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (shouldUseDisplaySize(lp)) {
      Point size=new Point();
      mDisplay.getRealSize(size);
      desiredWindowWidth=size.x;
      desiredWindowHeight=size.y;
    }
 else {
      Configuration config=mContext.getResources().getConfiguration();
      desiredWindowWidth=dipToPx(config.screenWidthDp);
      desiredWindowHeight=dipToPx(config.screenHeightDp);
    }
    mAttachInfo.mUse32BitDrawingCache=true;
    mAttachInfo.mHasWindowFocus=false;
    mAttachInfo.mWindowVisibility=viewVisibility;
    mAttachInfo.mRecomputeGlobalAttributes=false;
    mLastConfiguration.setTo(host.getResources().getConfiguration());
    mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
    if (mViewLayoutDirectionInitial == View.LAYOUT_DIRECTION_INHERIT) {
      host.setLayoutDirection(mLastConfiguration.getLayoutDirection());
    }
    host.dispatchAttachedToWindow(mAttachInfo,0);
    mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(true);
    dispatchApplyInsets(host);
  }
 else {
    desiredWindowWidth=frame.width();
    desiredWindowHeight=frame.height();
    if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) {
      if (DEBUG_ORIENTATION)       Log.v(mTag,""String_Node_Str"" + host + ""String_Node_Str""+ frame);
      mFullRedrawNeeded=true;
      mLayoutRequested=true;
      windowSizeMayChange=true;
    }
  }
  if (viewVisibilityChanged) {
    mAttachInfo.mWindowVisibility=viewVisibility;
    host.dispatchWindowVisibilityChanged(viewVisibility);
    if (viewVisibility != View.VISIBLE || mNewSurfaceNeeded) {
      endDragResizing();
      destroyHardwareResources();
    }
    if (viewVisibility == View.GONE) {
      mHasHadWindowFocus=false;
    }
  }
  if (mAttachInfo.mWindowVisibility != View.VISIBLE) {
    host.clearAccessibilityFocus();
  }
  getRunQueue().executeActions(mAttachInfo.mHandler);
  boolean insetsChanged=false;
  boolean layoutRequested=mLayoutRequested && (!mStopped || mReportNextDraw);
  if (layoutRequested) {
    final Resources res=mView.getContext().getResources();
    if (mFirst) {
      mAttachInfo.mInTouchMode=!mAddedTouchMode;
      ensureTouchModeLocally(mAddedTouchMode);
    }
 else {
      if (!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets)) {
        insetsChanged=true;
      }
      if (!mPendingContentInsets.equals(mAttachInfo.mContentInsets)) {
        insetsChanged=true;
      }
      if (!mPendingStableInsets.equals(mAttachInfo.mStableInsets)) {
        insetsChanged=true;
      }
      if (!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets)) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (!mPendingOutsets.equals(mAttachInfo.mOutsets)) {
        insetsChanged=true;
      }
      if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
        windowSizeMayChange=true;
        if (shouldUseDisplaySize(lp)) {
          Point size=new Point();
          mDisplay.getRealSize(size);
          desiredWindowWidth=size.x;
          desiredWindowHeight=size.y;
        }
 else {
          Configuration config=res.getConfiguration();
          desiredWindowWidth=dipToPx(config.screenWidthDp);
          desiredWindowHeight=dipToPx(config.screenHeightDp);
        }
      }
    }
    windowSizeMayChange|=measureHierarchy(host,lp,res,desiredWindowWidth,desiredWindowHeight);
  }
  if (collectViewAttributes()) {
    params=lp;
  }
  if (mAttachInfo.mForceReportNewAttributes) {
    mAttachInfo.mForceReportNewAttributes=false;
    params=lp;
  }
  if (mFirst || mAttachInfo.mViewVisibilityChanged) {
    mAttachInfo.mViewVisibilityChanged=false;
    int resizeMode=mSoftInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST;
    if (resizeMode == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) {
      final int N=mAttachInfo.mScrollContainers.size();
      for (int i=0; i < N; i++) {
        if (mAttachInfo.mScrollContainers.get(i).isShown()) {
          resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
        }
      }
      if (resizeMode == 0) {
        resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;
      }
      if ((lp.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) != resizeMode) {
        lp.softInputMode=(lp.softInputMode & ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) | resizeMode;
        params=lp;
      }
    }
  }
  if (params != null) {
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      if (!PixelFormat.formatHasAlpha(params.format)) {
        params.format=PixelFormat.TRANSLUCENT;
      }
    }
    mAttachInfo.mOverscanRequested=(params.flags & WindowManager.LayoutParams.FLAG_LAYOUT_IN_OVERSCAN) != 0;
  }
  if (mApplyInsetsRequested) {
    mApplyInsetsRequested=false;
    mLastOverscanRequested=mAttachInfo.mOverscanRequested;
    dispatchApplyInsets(host);
    if (mLayoutRequested) {
      windowSizeMayChange|=measureHierarchy(host,lp,mView.getContext().getResources(),desiredWindowWidth,desiredWindowHeight);
    }
  }
  if (layoutRequested) {
    mLayoutRequested=false;
  }
  boolean windowShouldResize=layoutRequested && windowSizeMayChange && ((mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight()) || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT && frame.width() < desiredWindowWidth && frame.width() != mWidth) || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT && frame.height() < desiredWindowHeight && frame.height() != mHeight));
  windowShouldResize|=mDragResizing && mResizeMode == RESIZE_MODE_FREEFORM;
  windowShouldResize|=!mPendingBackDropFrame.equals(mWinFrame);
  windowShouldResize|=mActivityRelaunched;
  final boolean computesInternalInsets=mAttachInfo.mTreeObserver.hasComputeInternalInsetsListeners() || mAttachInfo.mHasNonEmptyGivenInternalInsets;
  boolean insetsPending=false;
  int relayoutResult=0;
  final boolean isViewVisible=viewVisibility == View.VISIBLE;
  if (mFirst || windowShouldResize || insetsChanged|| viewVisibilityChanged|| params != null || mForceNextWindowRelayout) {
    mForceNextWindowRelayout=false;
    if (isViewVisible) {
      insetsPending=computesInternalInsets && (mFirst || viewVisibilityChanged);
    }
    if (mSurfaceHolder != null) {
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
    }
    boolean hwInitialized=false;
    boolean contentInsetsChanged=false;
    boolean hadSurface=mSurface.isValid();
    try {
      if (DEBUG_LAYOUT) {
        Log.i(mTag,""String_Node_Str"" + host.getMeasuredWidth() + ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str""+ params);
      }
      if (mAttachInfo.mHardwareRenderer != null) {
        if (mAttachInfo.mHardwareRenderer.pauseSurface(mSurface)) {
          mDirty.set(0,0,mWidth,mHeight);
        }
        mChoreographer.mFrameInfo.addFlags(FrameInfo.FLAG_WINDOW_LAYOUT_CHANGED);
      }
      final int surfaceGenerationId=mSurface.getGenerationId();
      relayoutResult=relayoutWindow(params,viewVisibility,insetsPending);
      if (DEBUG_LAYOUT)       Log.v(mTag,""String_Node_Str"" + frame.toShortString() + ""String_Node_Str""+ mPendingOverscanInsets.toShortString()+ ""String_Node_Str""+ mPendingContentInsets.toShortString()+ ""String_Node_Str""+ mPendingVisibleInsets.toShortString()+ ""String_Node_Str""+ mPendingStableInsets.toShortString()+ ""String_Node_Str""+ mPendingOutsets.toShortString()+ ""String_Node_Str""+ mSurface);
      if (mPendingConfiguration.seq != 0) {
        if (DEBUG_CONFIGURATION)         Log.v(mTag,""String_Node_Str"" + mPendingConfiguration);
        updateConfiguration(new Configuration(mPendingConfiguration),!mFirst);
        mPendingConfiguration.seq=0;
      }
      final boolean overscanInsetsChanged=!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets);
      contentInsetsChanged=!mPendingContentInsets.equals(mAttachInfo.mContentInsets);
      final boolean visibleInsetsChanged=!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets);
      final boolean stableInsetsChanged=!mPendingStableInsets.equals(mAttachInfo.mStableInsets);
      final boolean outsetsChanged=!mPendingOutsets.equals(mAttachInfo.mOutsets);
      final boolean surfaceSizeChanged=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_SURFACE_RESIZED) != 0;
      if (contentInsetsChanged) {
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (overscanInsetsChanged) {
        mAttachInfo.mOverscanInsets.set(mPendingOverscanInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mOverscanInsets);
        contentInsetsChanged=true;
      }
      if (stableInsetsChanged) {
        mAttachInfo.mStableInsets.set(mPendingStableInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mStableInsets);
        contentInsetsChanged=true;
      }
      if (contentInsetsChanged || mLastSystemUiVisibility != mAttachInfo.mSystemUiVisibility || mApplyInsetsRequested || mLastOverscanRequested != mAttachInfo.mOverscanRequested || outsetsChanged) {
        mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
        mLastOverscanRequested=mAttachInfo.mOverscanRequested;
        mAttachInfo.mOutsets.set(mPendingOutsets);
        mApplyInsetsRequested=false;
        dispatchApplyInsets(host);
      }
      if (visibleInsetsChanged) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (!hadSurface) {
        if (mSurface.isValid()) {
          newSurface=true;
          mFullRedrawNeeded=true;
          mPreviousTransparentRegion.setEmpty();
          if (mAttachInfo.mHardwareRenderer != null) {
            try {
              hwInitialized=mAttachInfo.mHardwareRenderer.initialize(mSurface);
              if (hwInitialized && (host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) == 0) {
                mSurface.allocateBuffers();
              }
            }
 catch (            OutOfResourcesException e) {
              handleOutOfResourcesException(e);
              return;
            }
          }
        }
      }
 else       if (!mSurface.isValid()) {
        if (mLastScrolledFocus != null) {
          mLastScrolledFocus.clear();
        }
        mScrollY=mCurScrollY=0;
        if (mView instanceof RootViewSurfaceTaker) {
          ((RootViewSurfaceTaker)mView).onRootViewScrollYChanged(mCurScrollY);
        }
        if (mScroller != null) {
          mScroller.abortAnimation();
        }
        if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
          mAttachInfo.mHardwareRenderer.destroy();
        }
      }
 else       if ((surfaceGenerationId != mSurface.getGenerationId() || surfaceSizeChanged) && mSurfaceHolder == null && mAttachInfo.mHardwareRenderer != null) {
        mFullRedrawNeeded=true;
        try {
          mAttachInfo.mHardwareRenderer.updateSurface(mSurface);
        }
 catch (        OutOfResourcesException e) {
          handleOutOfResourcesException(e);
          return;
        }
      }
      final boolean freeformResizing=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_DRAG_RESIZING_FREEFORM) != 0;
      final boolean dockedResizing=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_DRAG_RESIZING_DOCKED) != 0;
      final boolean dragResizing=freeformResizing || dockedResizing;
      if (mDragResizing != dragResizing) {
        if (dragResizing) {
          startDragResizing(mPendingBackDropFrame);
          mResizeMode=freeformResizing ? RESIZE_MODE_FREEFORM : RESIZE_MODE_DOCKED_DIVIDER;
        }
 else {
          endDragResizing();
        }
      }
      if (!USE_MT_RENDERER) {
        if (dragResizing) {
          mCanvasOffsetX=mWinFrame.left;
          mCanvasOffsetY=mWinFrame.top;
        }
 else {
          mCanvasOffsetX=mCanvasOffsetY=0;
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + frame + ""String_Node_Str""+ mSurface);
    mAttachInfo.mWindowLeft=frame.left;
    mAttachInfo.mWindowTop=frame.top;
    if (mWidth != frame.width() || mHeight != frame.height()) {
      mWidth=frame.width();
      mHeight=frame.height();
    }
    if (mSurfaceHolder != null) {
      if (mSurface.isValid()) {
        mSurfaceHolder.mSurface=mSurface;
      }
      mSurfaceHolder.setSurfaceFrameSize(mWidth,mHeight);
      mSurfaceHolder.mSurfaceLock.unlock();
      if (mSurface.isValid()) {
        if (!hadSurface) {
          mSurfaceHolder.ungetCallbacks();
          mIsCreating=true;
          mSurfaceHolderCallback.surfaceCreated(mSurfaceHolder);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          surfaceChanged=true;
        }
        if (surfaceChanged) {
          mSurfaceHolderCallback.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
            }
          }
        }
        mIsCreating=false;
      }
 else       if (hadSurface) {
        mSurfaceHolder.ungetCallbacks();
        SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
        mSurfaceHolderCallback.surfaceDestroyed(mSurfaceHolder);
        if (callbacks != null) {
          for (          SurfaceHolder.Callback c : callbacks) {
            c.surfaceDestroyed(mSurfaceHolder);
          }
        }
        mSurfaceHolder.mSurfaceLock.lock();
        try {
          mSurfaceHolder.mSurface=new Surface();
        }
  finally {
          mSurfaceHolder.mSurfaceLock.unlock();
        }
      }
    }
    final ThreadedRenderer hardwareRenderer=mAttachInfo.mHardwareRenderer;
    if (hardwareRenderer != null && hardwareRenderer.isEnabled()) {
      if (hwInitialized || mWidth != hardwareRenderer.getWidth() || mHeight != hardwareRenderer.getHeight()) {
        hardwareRenderer.setup(mWidth,mHeight,mAttachInfo,mWindowAttributes.surfaceInsets);
      }
    }
    if (!mStopped || mReportNextDraw) {
      boolean focusChangedDueToTouchMode=ensureTouchModeLocally((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0);
      if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight() || contentInsetsChanged) {
        int childWidthMeasureSpec=getRootMeasureSpec(mWidth,lp.width);
        int childHeightMeasureSpec=getRootMeasureSpec(mHeight,lp.height);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mWidth + ""String_Node_Str""+ host.getMeasuredWidth()+ ""String_Node_Str""+ mHeight+ ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str""+ contentInsetsChanged);
        performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        int width=host.getMeasuredWidth();
        int height=host.getMeasuredHeight();
        boolean measureAgain=false;
        if (lp.horizontalWeight > 0.0f) {
          width+=(int)((mWidth - width) * lp.horizontalWeight);
          childWidthMeasureSpec=MeasureSpec.makeMeasureSpec(width,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (lp.verticalWeight > 0.0f) {
          height+=(int)((mHeight - height) * lp.verticalWeight);
          childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(height,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (measureAgain) {
          if (DEBUG_LAYOUT)           Log.v(mTag,""String_Node_Str"" + width + ""String_Node_Str""+ height);
          performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        }
        layoutRequested=true;
      }
    }
  }
 else {
    maybeHandleWindowMove(frame);
  }
  final boolean didLayout=layoutRequested && (!mStopped || mReportNextDraw);
  boolean triggerGlobalLayoutListener=didLayout || mAttachInfo.mRecomputeGlobalAttributes;
  if (didLayout) {
    performLayout(lp,desiredWindowWidth,desiredWindowHeight);
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      host.getLocationInWindow(mTmpLocation);
      mTransparentRegion.set(mTmpLocation[0],mTmpLocation[1],mTmpLocation[0] + host.mRight - host.mLeft,mTmpLocation[1] + host.mBottom - host.mTop);
      host.gatherTransparentRegion(mTransparentRegion);
      if (mTranslator != null) {
        mTranslator.translateRegionInWindowToScreen(mTransparentRegion);
      }
      if (!mTransparentRegion.equals(mPreviousTransparentRegion)) {
        mPreviousTransparentRegion.set(mTransparentRegion);
        mFullRedrawNeeded=true;
        try {
          mWindowSession.setTransparentRegion(mWindow,mTransparentRegion);
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (triggerGlobalLayoutListener) {
    mAttachInfo.mRecomputeGlobalAttributes=false;
    mAttachInfo.mTreeObserver.dispatchOnGlobalLayout();
  }
  if (computesInternalInsets) {
    final ViewTreeObserver.InternalInsetsInfo insets=mAttachInfo.mGivenInternalInsets;
    insets.reset();
    mAttachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);
    mAttachInfo.mHasNonEmptyGivenInternalInsets=!insets.isEmpty();
    if (insetsPending || !mLastGivenInsets.equals(insets)) {
      mLastGivenInsets.set(insets);
      final Rect contentInsets;
      final Rect visibleInsets;
      final Region touchableRegion;
      if (mTranslator != null) {
        contentInsets=mTranslator.getTranslatedContentInsets(insets.contentInsets);
        visibleInsets=mTranslator.getTranslatedVisibleInsets(insets.visibleInsets);
        touchableRegion=mTranslator.getTranslatedTouchableArea(insets.touchableRegion);
      }
 else {
        contentInsets=insets.contentInsets;
        visibleInsets=insets.visibleInsets;
        touchableRegion=insets.touchableRegion;
      }
      try {
        mWindowSession.setInsets(mWindow,insets.mTouchableInsets,contentInsets,visibleInsets,touchableRegion);
      }
 catch (      RemoteException e) {
      }
    }
  }
  if (mFirst) {
    if (DEBUG_INPUT_RESIZE)     Log.v(mTag,""String_Node_Str"" + mView.hasFocus());
    if (mView != null) {
      if (!mView.hasFocus()) {
        mView.requestFocus(View.FOCUS_FORWARD);
        if (DEBUG_INPUT_RESIZE)         Log.v(mTag,""String_Node_Str"" + mView.findFocus());
      }
 else {
        if (DEBUG_INPUT_RESIZE)         Log.v(mTag,""String_Node_Str"" + mView.findFocus());
      }
    }
  }
  final boolean changedVisibility=(viewVisibilityChanged || mFirst) && isViewVisible;
  final boolean hasWindowFocus=mAttachInfo.mHasWindowFocus && isViewVisible;
  final boolean regainedFocus=hasWindowFocus && mLostWindowFocus;
  if (regainedFocus) {
    mLostWindowFocus=false;
  }
 else   if (!hasWindowFocus && mHadWindowFocus) {
    mLostWindowFocus=true;
  }
  if (changedVisibility || regainedFocus) {
    host.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
  }
  mFirst=false;
  mWillDrawSoon=false;
  mNewSurfaceNeeded=false;
  mActivityRelaunched=false;
  mViewVisibility=viewVisibility;
  mHadWindowFocus=hasWindowFocus;
  if (hasWindowFocus && !isInLocalFocusMode()) {
    final boolean imTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
    if (imTarget != mLastWasImTarget) {
      mLastWasImTarget=imTarget;
      InputMethodManager imm=InputMethodManager.peekInstance();
      if (imm != null && imTarget) {
        imm.onPreWindowFocus(mView,hasWindowFocus);
        imm.onPostWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
      }
    }
  }
  if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {
    mReportNextDraw=true;
  }
  boolean cancelDraw=mAttachInfo.mTreeObserver.dispatchOnPreDraw() || !isViewVisible;
  if (!cancelDraw) {
    if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
      for (int i=0; i < mPendingTransitions.size(); ++i) {
        mPendingTransitions.get(i).startChangingAnimations();
      }
      mPendingTransitions.clear();
    }
    performDraw();
  }
 else {
    if (isViewVisible) {
      scheduleTraversals();
    }
 else     if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
      for (int i=0; i < mPendingTransitions.size(); ++i) {
        mPendingTransitions.get(i).endChangingAnimations();
      }
      mPendingTransitions.clear();
    }
  }
  mIsInTraversal=false;
}","private void performTraversals(){
  final View host=mView;
  if (DBG) {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    host.debug();
  }
  if (host == null || !mAdded)   return;
  mIsInTraversal=true;
  mWillDrawSoon=true;
  boolean windowSizeMayChange=false;
  boolean newSurface=false;
  boolean surfaceChanged=false;
  WindowManager.LayoutParams lp=mWindowAttributes;
  int desiredWindowWidth;
  int desiredWindowHeight;
  final int viewVisibility=getHostVisibility();
  final boolean viewVisibilityChanged=!mFirst && (mViewVisibility != viewVisibility || mNewSurfaceNeeded);
  WindowManager.LayoutParams params=null;
  if (mWindowAttributesChanged) {
    mWindowAttributesChanged=false;
    surfaceChanged=true;
    params=lp;
  }
  CompatibilityInfo compatibilityInfo=mDisplayAdjustments.getCompatibilityInfo();
  if (compatibilityInfo.supportsScreen() == mLastInCompatMode) {
    params=lp;
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (mLastInCompatMode) {
      params.privateFlags&=~WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=false;
    }
 else {
      params.privateFlags|=WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
      mLastInCompatMode=true;
    }
  }
  mWindowAttributesChangesFlag=0;
  Rect frame=mWinFrame;
  if (mFirst) {
    mFullRedrawNeeded=true;
    mLayoutRequested=true;
    if (shouldUseDisplaySize(lp)) {
      Point size=new Point();
      mDisplay.getRealSize(size);
      desiredWindowWidth=size.x;
      desiredWindowHeight=size.y;
    }
 else {
      Configuration config=mContext.getResources().getConfiguration();
      desiredWindowWidth=dipToPx(config.screenWidthDp);
      desiredWindowHeight=dipToPx(config.screenHeightDp);
    }
    mAttachInfo.mUse32BitDrawingCache=true;
    mAttachInfo.mHasWindowFocus=false;
    mAttachInfo.mWindowVisibility=viewVisibility;
    mAttachInfo.mRecomputeGlobalAttributes=false;
    mLastConfiguration.setTo(host.getResources().getConfiguration());
    mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
    if (mViewLayoutDirectionInitial == View.LAYOUT_DIRECTION_INHERIT) {
      host.setLayoutDirection(mLastConfiguration.getLayoutDirection());
    }
    host.dispatchAttachedToWindow(mAttachInfo,0);
    mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(true);
    dispatchApplyInsets(host);
  }
 else {
    desiredWindowWidth=frame.width();
    desiredWindowHeight=frame.height();
    if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) {
      if (DEBUG_ORIENTATION)       Log.v(mTag,""String_Node_Str"" + host + ""String_Node_Str""+ frame);
      mFullRedrawNeeded=true;
      mLayoutRequested=true;
      windowSizeMayChange=true;
    }
  }
  if (viewVisibilityChanged) {
    mAttachInfo.mWindowVisibility=viewVisibility;
    host.dispatchWindowVisibilityChanged(viewVisibility);
    if (viewVisibility != View.VISIBLE || mNewSurfaceNeeded) {
      endDragResizing();
      destroyHardwareResources();
    }
    if (viewVisibility == View.GONE) {
      mHasHadWindowFocus=false;
    }
  }
  if (mAttachInfo.mWindowVisibility != View.VISIBLE) {
    host.clearAccessibilityFocus();
  }
  getRunQueue().executeActions(mAttachInfo.mHandler);
  boolean insetsChanged=false;
  boolean layoutRequested=mLayoutRequested && (!mStopped || mReportNextDraw);
  if (layoutRequested) {
    final Resources res=mView.getContext().getResources();
    if (mFirst) {
      mAttachInfo.mInTouchMode=!mAddedTouchMode;
      ensureTouchModeLocally(mAddedTouchMode);
    }
 else {
      if (!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets)) {
        insetsChanged=true;
      }
      if (!mPendingContentInsets.equals(mAttachInfo.mContentInsets)) {
        insetsChanged=true;
      }
      if (!mPendingStableInsets.equals(mAttachInfo.mStableInsets)) {
        insetsChanged=true;
      }
      if (!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets)) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (!mPendingOutsets.equals(mAttachInfo.mOutsets)) {
        insetsChanged=true;
      }
      if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
        windowSizeMayChange=true;
        if (shouldUseDisplaySize(lp)) {
          Point size=new Point();
          mDisplay.getRealSize(size);
          desiredWindowWidth=size.x;
          desiredWindowHeight=size.y;
        }
 else {
          Configuration config=res.getConfiguration();
          desiredWindowWidth=dipToPx(config.screenWidthDp);
          desiredWindowHeight=dipToPx(config.screenHeightDp);
        }
      }
    }
    windowSizeMayChange|=measureHierarchy(host,lp,res,desiredWindowWidth,desiredWindowHeight);
  }
  if (collectViewAttributes()) {
    params=lp;
  }
  if (mAttachInfo.mForceReportNewAttributes) {
    mAttachInfo.mForceReportNewAttributes=false;
    params=lp;
  }
  if (mFirst || mAttachInfo.mViewVisibilityChanged) {
    mAttachInfo.mViewVisibilityChanged=false;
    int resizeMode=mSoftInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST;
    if (resizeMode == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) {
      final int N=mAttachInfo.mScrollContainers.size();
      for (int i=0; i < N; i++) {
        if (mAttachInfo.mScrollContainers.get(i).isShown()) {
          resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
        }
      }
      if (resizeMode == 0) {
        resizeMode=WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;
      }
      if ((lp.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) != resizeMode) {
        lp.softInputMode=(lp.softInputMode & ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) | resizeMode;
        params=lp;
      }
    }
  }
  if (params != null) {
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      if (!PixelFormat.formatHasAlpha(params.format)) {
        params.format=PixelFormat.TRANSLUCENT;
      }
    }
    mAttachInfo.mOverscanRequested=(params.flags & WindowManager.LayoutParams.FLAG_LAYOUT_IN_OVERSCAN) != 0;
  }
  if (mApplyInsetsRequested) {
    mApplyInsetsRequested=false;
    mLastOverscanRequested=mAttachInfo.mOverscanRequested;
    dispatchApplyInsets(host);
    if (mLayoutRequested) {
      windowSizeMayChange|=measureHierarchy(host,lp,mView.getContext().getResources(),desiredWindowWidth,desiredWindowHeight);
    }
  }
  if (layoutRequested) {
    mLayoutRequested=false;
  }
  boolean windowShouldResize=layoutRequested && windowSizeMayChange && ((mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight()) || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT && frame.width() < desiredWindowWidth && frame.width() != mWidth) || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT && frame.height() < desiredWindowHeight && frame.height() != mHeight));
  windowShouldResize|=mDragResizing && mResizeMode == RESIZE_MODE_FREEFORM;
  windowShouldResize|=!mPendingBackDropFrame.equals(mWinFrame);
  windowShouldResize|=mActivityRelaunched;
  final boolean computesInternalInsets=mAttachInfo.mTreeObserver.hasComputeInternalInsetsListeners() || mAttachInfo.mHasNonEmptyGivenInternalInsets;
  boolean insetsPending=false;
  int relayoutResult=0;
  final boolean isViewVisible=viewVisibility == View.VISIBLE;
  if (mFirst || windowShouldResize || insetsChanged|| viewVisibilityChanged|| params != null || mForceNextWindowRelayout) {
    mForceNextWindowRelayout=false;
    if (isViewVisible) {
      insetsPending=computesInternalInsets && (mFirst || viewVisibilityChanged);
    }
    if (mSurfaceHolder != null) {
      mSurfaceHolder.mSurfaceLock.lock();
      mDrawingAllowed=true;
    }
    boolean hwInitialized=false;
    boolean contentInsetsChanged=false;
    boolean hadSurface=mSurface.isValid();
    try {
      if (DEBUG_LAYOUT) {
        Log.i(mTag,""String_Node_Str"" + host.getMeasuredWidth() + ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str""+ params);
      }
      if (mAttachInfo.mHardwareRenderer != null) {
        if (mAttachInfo.mHardwareRenderer.pauseSurface(mSurface)) {
          mDirty.set(0,0,mWidth,mHeight);
        }
        mChoreographer.mFrameInfo.addFlags(FrameInfo.FLAG_WINDOW_LAYOUT_CHANGED);
      }
      final int surfaceGenerationId=mSurface.getGenerationId();
      relayoutResult=relayoutWindow(params,viewVisibility,insetsPending);
      if (DEBUG_LAYOUT)       Log.v(mTag,""String_Node_Str"" + frame.toShortString() + ""String_Node_Str""+ mPendingOverscanInsets.toShortString()+ ""String_Node_Str""+ mPendingContentInsets.toShortString()+ ""String_Node_Str""+ mPendingVisibleInsets.toShortString()+ ""String_Node_Str""+ mPendingStableInsets.toShortString()+ ""String_Node_Str""+ mPendingOutsets.toShortString()+ ""String_Node_Str""+ mSurface);
      if (mPendingConfiguration.seq != 0) {
        if (DEBUG_CONFIGURATION)         Log.v(mTag,""String_Node_Str"" + mPendingConfiguration);
        updateConfiguration(new Configuration(mPendingConfiguration),!mFirst);
        mPendingConfiguration.seq=0;
      }
      final boolean overscanInsetsChanged=!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets);
      contentInsetsChanged=!mPendingContentInsets.equals(mAttachInfo.mContentInsets);
      final boolean visibleInsetsChanged=!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets);
      final boolean stableInsetsChanged=!mPendingStableInsets.equals(mAttachInfo.mStableInsets);
      final boolean outsetsChanged=!mPendingOutsets.equals(mAttachInfo.mOutsets);
      final boolean surfaceSizeChanged=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_SURFACE_RESIZED) != 0;
      if (contentInsetsChanged) {
        mAttachInfo.mContentInsets.set(mPendingContentInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mContentInsets);
      }
      if (overscanInsetsChanged) {
        mAttachInfo.mOverscanInsets.set(mPendingOverscanInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mOverscanInsets);
        contentInsetsChanged=true;
      }
      if (stableInsetsChanged) {
        mAttachInfo.mStableInsets.set(mPendingStableInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mStableInsets);
        contentInsetsChanged=true;
      }
      if (contentInsetsChanged || mLastSystemUiVisibility != mAttachInfo.mSystemUiVisibility || mApplyInsetsRequested || mLastOverscanRequested != mAttachInfo.mOverscanRequested || outsetsChanged) {
        mLastSystemUiVisibility=mAttachInfo.mSystemUiVisibility;
        mLastOverscanRequested=mAttachInfo.mOverscanRequested;
        mAttachInfo.mOutsets.set(mPendingOutsets);
        mApplyInsetsRequested=false;
        dispatchApplyInsets(host);
      }
      if (visibleInsetsChanged) {
        mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mAttachInfo.mVisibleInsets);
      }
      if (!hadSurface) {
        if (mSurface.isValid()) {
          newSurface=true;
          mFullRedrawNeeded=true;
          mPreviousTransparentRegion.setEmpty();
          if (mAttachInfo.mHardwareRenderer != null) {
            try {
              hwInitialized=mAttachInfo.mHardwareRenderer.initialize(mSurface);
              if (hwInitialized && (host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) == 0) {
                mSurface.allocateBuffers();
              }
            }
 catch (            OutOfResourcesException e) {
              handleOutOfResourcesException(e);
              return;
            }
          }
        }
      }
 else       if (!mSurface.isValid()) {
        if (mLastScrolledFocus != null) {
          mLastScrolledFocus.clear();
        }
        mScrollY=mCurScrollY=0;
        if (mView instanceof RootViewSurfaceTaker) {
          ((RootViewSurfaceTaker)mView).onRootViewScrollYChanged(mCurScrollY);
        }
        if (mScroller != null) {
          mScroller.abortAnimation();
        }
        if (mAttachInfo.mHardwareRenderer != null && mAttachInfo.mHardwareRenderer.isEnabled()) {
          mAttachInfo.mHardwareRenderer.destroy();
        }
      }
 else       if ((surfaceGenerationId != mSurface.getGenerationId() || surfaceSizeChanged) && mSurfaceHolder == null && mAttachInfo.mHardwareRenderer != null) {
        mFullRedrawNeeded=true;
        try {
          mAttachInfo.mHardwareRenderer.updateSurface(mSurface);
        }
 catch (        OutOfResourcesException e) {
          handleOutOfResourcesException(e);
          return;
        }
      }
      final boolean freeformResizing=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_DRAG_RESIZING_FREEFORM) != 0;
      final boolean dockedResizing=(relayoutResult & WindowManagerGlobal.RELAYOUT_RES_DRAG_RESIZING_DOCKED) != 0;
      final boolean dragResizing=freeformResizing || dockedResizing;
      if (mDragResizing != dragResizing) {
        if (dragResizing) {
          startDragResizing(mPendingBackDropFrame,mWinFrame.equals(mPendingBackDropFrame),mPendingVisibleInsets,mPendingStableInsets);
          mResizeMode=freeformResizing ? RESIZE_MODE_FREEFORM : RESIZE_MODE_DOCKED_DIVIDER;
        }
 else {
          endDragResizing();
        }
      }
      if (!USE_MT_RENDERER) {
        if (dragResizing) {
          mCanvasOffsetX=mWinFrame.left;
          mCanvasOffsetY=mWinFrame.top;
        }
 else {
          mCanvasOffsetX=mCanvasOffsetY=0;
        }
      }
    }
 catch (    RemoteException e) {
    }
    if (DEBUG_ORIENTATION)     Log.v(TAG,""String_Node_Str"" + frame + ""String_Node_Str""+ mSurface);
    mAttachInfo.mWindowLeft=frame.left;
    mAttachInfo.mWindowTop=frame.top;
    if (mWidth != frame.width() || mHeight != frame.height()) {
      mWidth=frame.width();
      mHeight=frame.height();
    }
    if (mSurfaceHolder != null) {
      if (mSurface.isValid()) {
        mSurfaceHolder.mSurface=mSurface;
      }
      mSurfaceHolder.setSurfaceFrameSize(mWidth,mHeight);
      mSurfaceHolder.mSurfaceLock.unlock();
      if (mSurface.isValid()) {
        if (!hadSurface) {
          mSurfaceHolder.ungetCallbacks();
          mIsCreating=true;
          mSurfaceHolderCallback.surfaceCreated(mSurfaceHolder);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceCreated(mSurfaceHolder);
            }
          }
          surfaceChanged=true;
        }
        if (surfaceChanged) {
          mSurfaceHolderCallback.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
          SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
          if (callbacks != null) {
            for (            SurfaceHolder.Callback c : callbacks) {
              c.surfaceChanged(mSurfaceHolder,lp.format,mWidth,mHeight);
            }
          }
        }
        mIsCreating=false;
      }
 else       if (hadSurface) {
        mSurfaceHolder.ungetCallbacks();
        SurfaceHolder.Callback callbacks[]=mSurfaceHolder.getCallbacks();
        mSurfaceHolderCallback.surfaceDestroyed(mSurfaceHolder);
        if (callbacks != null) {
          for (          SurfaceHolder.Callback c : callbacks) {
            c.surfaceDestroyed(mSurfaceHolder);
          }
        }
        mSurfaceHolder.mSurfaceLock.lock();
        try {
          mSurfaceHolder.mSurface=new Surface();
        }
  finally {
          mSurfaceHolder.mSurfaceLock.unlock();
        }
      }
    }
    final ThreadedRenderer hardwareRenderer=mAttachInfo.mHardwareRenderer;
    if (hardwareRenderer != null && hardwareRenderer.isEnabled()) {
      if (hwInitialized || mWidth != hardwareRenderer.getWidth() || mHeight != hardwareRenderer.getHeight()) {
        hardwareRenderer.setup(mWidth,mHeight,mAttachInfo,mWindowAttributes.surfaceInsets);
      }
    }
    if (!mStopped || mReportNextDraw) {
      boolean focusChangedDueToTouchMode=ensureTouchModeLocally((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0);
      if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight() || contentInsetsChanged) {
        int childWidthMeasureSpec=getRootMeasureSpec(mWidth,lp.width);
        int childHeightMeasureSpec=getRootMeasureSpec(mHeight,lp.height);
        if (DEBUG_LAYOUT)         Log.v(mTag,""String_Node_Str"" + mWidth + ""String_Node_Str""+ host.getMeasuredWidth()+ ""String_Node_Str""+ mHeight+ ""String_Node_Str""+ host.getMeasuredHeight()+ ""String_Node_Str""+ contentInsetsChanged);
        performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        int width=host.getMeasuredWidth();
        int height=host.getMeasuredHeight();
        boolean measureAgain=false;
        if (lp.horizontalWeight > 0.0f) {
          width+=(int)((mWidth - width) * lp.horizontalWeight);
          childWidthMeasureSpec=MeasureSpec.makeMeasureSpec(width,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (lp.verticalWeight > 0.0f) {
          height+=(int)((mHeight - height) * lp.verticalWeight);
          childHeightMeasureSpec=MeasureSpec.makeMeasureSpec(height,MeasureSpec.EXACTLY);
          measureAgain=true;
        }
        if (measureAgain) {
          if (DEBUG_LAYOUT)           Log.v(mTag,""String_Node_Str"" + width + ""String_Node_Str""+ height);
          performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);
        }
        layoutRequested=true;
      }
    }
  }
 else {
    maybeHandleWindowMove(frame);
  }
  final boolean didLayout=layoutRequested && (!mStopped || mReportNextDraw);
  boolean triggerGlobalLayoutListener=didLayout || mAttachInfo.mRecomputeGlobalAttributes;
  if (didLayout) {
    performLayout(lp,desiredWindowWidth,desiredWindowHeight);
    if ((host.mPrivateFlags & View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) {
      host.getLocationInWindow(mTmpLocation);
      mTransparentRegion.set(mTmpLocation[0],mTmpLocation[1],mTmpLocation[0] + host.mRight - host.mLeft,mTmpLocation[1] + host.mBottom - host.mTop);
      host.gatherTransparentRegion(mTransparentRegion);
      if (mTranslator != null) {
        mTranslator.translateRegionInWindowToScreen(mTransparentRegion);
      }
      if (!mTransparentRegion.equals(mPreviousTransparentRegion)) {
        mPreviousTransparentRegion.set(mTransparentRegion);
        mFullRedrawNeeded=true;
        try {
          mWindowSession.setTransparentRegion(mWindow,mTransparentRegion);
        }
 catch (        RemoteException e) {
        }
      }
    }
    if (DBG) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      host.debug();
    }
  }
  if (triggerGlobalLayoutListener) {
    mAttachInfo.mRecomputeGlobalAttributes=false;
    mAttachInfo.mTreeObserver.dispatchOnGlobalLayout();
  }
  if (computesInternalInsets) {
    final ViewTreeObserver.InternalInsetsInfo insets=mAttachInfo.mGivenInternalInsets;
    insets.reset();
    mAttachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);
    mAttachInfo.mHasNonEmptyGivenInternalInsets=!insets.isEmpty();
    if (insetsPending || !mLastGivenInsets.equals(insets)) {
      mLastGivenInsets.set(insets);
      final Rect contentInsets;
      final Rect visibleInsets;
      final Region touchableRegion;
      if (mTranslator != null) {
        contentInsets=mTranslator.getTranslatedContentInsets(insets.contentInsets);
        visibleInsets=mTranslator.getTranslatedVisibleInsets(insets.visibleInsets);
        touchableRegion=mTranslator.getTranslatedTouchableArea(insets.touchableRegion);
      }
 else {
        contentInsets=insets.contentInsets;
        visibleInsets=insets.visibleInsets;
        touchableRegion=insets.touchableRegion;
      }
      try {
        mWindowSession.setInsets(mWindow,insets.mTouchableInsets,contentInsets,visibleInsets,touchableRegion);
      }
 catch (      RemoteException e) {
      }
    }
  }
  if (mFirst) {
    if (DEBUG_INPUT_RESIZE)     Log.v(mTag,""String_Node_Str"" + mView.hasFocus());
    if (mView != null) {
      if (!mView.hasFocus()) {
        mView.requestFocus(View.FOCUS_FORWARD);
        if (DEBUG_INPUT_RESIZE)         Log.v(mTag,""String_Node_Str"" + mView.findFocus());
      }
 else {
        if (DEBUG_INPUT_RESIZE)         Log.v(mTag,""String_Node_Str"" + mView.findFocus());
      }
    }
  }
  final boolean changedVisibility=(viewVisibilityChanged || mFirst) && isViewVisible;
  final boolean hasWindowFocus=mAttachInfo.mHasWindowFocus && isViewVisible;
  final boolean regainedFocus=hasWindowFocus && mLostWindowFocus;
  if (regainedFocus) {
    mLostWindowFocus=false;
  }
 else   if (!hasWindowFocus && mHadWindowFocus) {
    mLostWindowFocus=true;
  }
  if (changedVisibility || regainedFocus) {
    host.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
  }
  mFirst=false;
  mWillDrawSoon=false;
  mNewSurfaceNeeded=false;
  mActivityRelaunched=false;
  mViewVisibility=viewVisibility;
  mHadWindowFocus=hasWindowFocus;
  if (hasWindowFocus && !isInLocalFocusMode()) {
    final boolean imTarget=WindowManager.LayoutParams.mayUseInputMethod(mWindowAttributes.flags);
    if (imTarget != mLastWasImTarget) {
      mLastWasImTarget=imTarget;
      InputMethodManager imm=InputMethodManager.peekInstance();
      if (imm != null && imTarget) {
        imm.onPreWindowFocus(mView,hasWindowFocus);
        imm.onPostWindowFocus(mView,mView.findFocus(),mWindowAttributes.softInputMode,!mHasHadWindowFocus,mWindowAttributes.flags);
      }
    }
  }
  if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {
    mReportNextDraw=true;
  }
  boolean cancelDraw=mAttachInfo.mTreeObserver.dispatchOnPreDraw() || !isViewVisible;
  if (!cancelDraw) {
    if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
      for (int i=0; i < mPendingTransitions.size(); ++i) {
        mPendingTransitions.get(i).startChangingAnimations();
      }
      mPendingTransitions.clear();
    }
    performDraw();
  }
 else {
    if (isViewVisible) {
      scheduleTraversals();
    }
 else     if (mPendingTransitions != null && mPendingTransitions.size() > 0) {
      for (int i=0; i < mPendingTransitions.size(); ++i) {
        mPendingTransitions.get(i).endChangingAnimations();
      }
      mPendingTransitions.clear();
    }
  }
  mIsInTraversal=false;
}",0.9981552685973374
192765,"/** 
 * Called by the system when the window got changed by the user, before the layouter got called. It can be used to perform a ""quick and dirty"" resize which should never take more then 4ms to complete. <p>At the time the layouting has not happened yet.
 * @param newBounds The new window frame bounds.
 */
void onWindowSizeIsChanging(Rect newBounds);","/** 
 * Called by the system when the window got changed by the user, before the layouter got called. It also gets called when the insets changed, or when the window switched between a fullscreen layout or a non-fullscreen layout. It can be used to perform a ""quick and dirty"" resize which should never take more then 4ms to complete. <p>At the time the layouting has not happened yet.
 * @param newBounds The new window frame bounds.
 * @param fullscreen Whether the window is currently drawing in fullscreen.
 * @param systemInsets The current visible system insets for the window.
 * @param stableInsets The stable insets for the window.
 */
void onWindowSizeIsChanging(Rect newBounds,boolean fullscreen,Rect systemInsets,Rect stableInsets);",0.644808743169399
192766,"/** 
 * Called when a drag resize starts.
 * @param initialBounds The initial bounds where the window will be.
 */
void onWindowDragResizeStart(Rect initialBounds);","/** 
 * Called when a drag resize starts.
 * @param initialBounds The initial bounds where the window will be.
 * @param fullscreen Whether the window is currently drawing in fullscreen.
 * @param systemInsets The current visible system insets for the window.
 * @param stableInsets The stable insets for the window.
 */
void onWindowDragResizeStart(Rect initialBounds,boolean fullscreen,Rect systemInsets,Rect stableInsets);",0.5568760611205433
192767,"void onResourcesLoaded(DecorView decorView,Drawable resizingBackgroundDrawable,Drawable captionBackgroundDrawableDrawable,Drawable userCaptionBackgroundDrawable,int statusBarColor){
  mDecorView=decorView;
  mResizingBackgroundDrawable=resizingBackgroundDrawable;
  mCaptionBackgroundDrawable=captionBackgroundDrawableDrawable;
  mUserCaptionBackgroundDrawable=userCaptionBackgroundDrawable;
  if (mCaptionBackgroundDrawable == null) {
    mCaptionBackgroundDrawable=mResizingBackgroundDrawable;
  }
  if (statusBarColor != 0) {
    mStatusBarColor=new ColorDrawable(statusBarColor);
    addSystemBarNodeIfNeeded();
  }
 else {
    mStatusBarColor=null;
  }
}","void onResourcesLoaded(DecorView decorView,Drawable resizingBackgroundDrawable,Drawable captionBackgroundDrawableDrawable,Drawable userCaptionBackgroundDrawable,int statusBarColor,int navigationBarColor){
  mDecorView=decorView;
  mResizingBackgroundDrawable=resizingBackgroundDrawable;
  mCaptionBackgroundDrawable=captionBackgroundDrawableDrawable;
  mUserCaptionBackgroundDrawable=userCaptionBackgroundDrawable;
  if (mCaptionBackgroundDrawable == null) {
    mCaptionBackgroundDrawable=mResizingBackgroundDrawable;
  }
  if (statusBarColor != 0) {
    mStatusBarColor=new ColorDrawable(statusBarColor);
    addSystemBarNodeIfNeeded();
  }
 else {
    mStatusBarColor=null;
  }
  if (navigationBarColor != 0) {
    mNavigationBarColor=new ColorDrawable(navigationBarColor);
    addSystemBarNodeIfNeeded();
  }
 else {
    mNavigationBarColor=null;
  }
}",0.8699669966996699
192768,"/** 
 * The content is about to be drawn and we got the location of where it will be shown. If a ""changeWindowSizeLocked"" call has already been processed, we will re-issue the call if the previous call was ignored since the size was unknown.
 * @param xOffset The x offset where the content is drawn to.
 * @param yOffset The y offset where the content is drawn to.
 * @param xSize The width size of the content. This should not be 0.
 * @param ySize The height of the content.
 * @return true if a frame should be requested after the content is drawn; false otherwise.
 */
public boolean onContentDrawn(int xOffset,int yOffset,int xSize,int ySize){
synchronized (this) {
    final boolean firstCall=mLastContentWidth == 0;
    mLastContentWidth=xSize;
    mLastContentHeight=ySize - mLastCaptionHeight;
    mLastXOffset=xOffset;
    mLastYOffset=yOffset;
    mRenderer.setContentDrawBounds(mLastXOffset,mLastYOffset,mLastXOffset + mLastContentWidth,mLastYOffset + mLastCaptionHeight + mLastContentHeight);
    return firstCall && (mLastCaptionHeight != 0 || !mDecorView.isShowingCaption());
  }
}","/** 
 * The content is about to be drawn and we got the location of where it will be shown. If a ""redrawLocked"" call has already been processed, we will re-issue the call if the previous call was ignored since the size was unknown.
 * @param xOffset The x offset where the content is drawn to.
 * @param yOffset The y offset where the content is drawn to.
 * @param xSize The width size of the content. This should not be 0.
 * @param ySize The height of the content.
 * @return true if a frame should be requested after the content is drawn; false otherwise.
 */
public boolean onContentDrawn(int xOffset,int yOffset,int xSize,int ySize){
synchronized (this) {
    final boolean firstCall=mLastContentWidth == 0;
    mLastContentWidth=xSize;
    mLastContentHeight=ySize - mLastCaptionHeight;
    mLastXOffset=xOffset;
    mLastYOffset=yOffset;
    mRenderer.setContentDrawBounds(mLastXOffset,mLastYOffset,mLastXOffset + mLastContentWidth,mLastYOffset + mLastCaptionHeight + mLastContentHeight);
    return firstCall && (mLastCaptionHeight != 0 || !mDecorView.isShowingCaption());
  }
}",0.98992673992674
192769,"/** 
 * The implementation of the FrameCallback.
 * @param frameTimeNanos The time in nanoseconds when the frame started being rendered,in the  {@link System#nanoTime()} timebase.  Divide this value by {@code 1000000}
 */
@Override public void doFrame(long frameTimeNanos){
synchronized (this) {
    if (mRenderer == null) {
      reportDrawIfNeeded();
      Looper.myLooper().quit();
      return;
    }
    mNewTargetRect.set(mTargetRect);
    if (!mNewTargetRect.equals(mOldTargetRect) || mReportNextDraw) {
      mOldTargetRect.set(mNewTargetRect);
      changeWindowSizeLocked(mNewTargetRect);
    }
  }
}","/** 
 * The implementation of the FrameCallback.
 * @param frameTimeNanos The time in nanoseconds when the frame started being rendered,in the  {@link System#nanoTime()} timebase.  Divide this value by {@code 1000000}
 */
@Override public void doFrame(long frameTimeNanos){
synchronized (this) {
    if (mRenderer == null) {
      reportDrawIfNeeded();
      Looper.myLooper().quit();
      return;
    }
    mNewTargetRect.set(mTargetRect);
    if (!mNewTargetRect.equals(mOldTargetRect) || mOldFullscreen != mFullscreen || !mStableInsets.equals(mOldStableInsets) || !mSystemInsets.equals(mOldSystemInsets) || mReportNextDraw) {
      mOldFullscreen=mFullscreen;
      mOldTargetRect.set(mNewTargetRect);
      mOldSystemInsets.set(mSystemInsets);
      mOldStableInsets.set(mStableInsets);
      redrawLocked(mNewTargetRect,mFullscreen,mSystemInsets,mStableInsets);
    }
  }
}",0.7790463398253862
192770,"public BackdropFrameRenderer(DecorView decorView,ThreadedRenderer renderer,Rect initialBounds,Drawable resizingBackgroundDrawable,Drawable captionBackgroundDrawable,Drawable userCaptionBackgroundDrawable,int statusBarColor){
  setName(""String_Node_Str"");
  mRenderer=renderer;
  onResourcesLoaded(decorView,resizingBackgroundDrawable,captionBackgroundDrawable,userCaptionBackgroundDrawable,statusBarColor);
  mFrameAndBackdropNode=RenderNode.create(""String_Node_Str"",null);
  mRenderer.addRenderNode(mFrameAndBackdropNode,true);
  mTargetRect.set(initialBounds);
synchronized (this) {
    changeWindowSizeLocked(initialBounds);
  }
  start();
}","public BackdropFrameRenderer(DecorView decorView,ThreadedRenderer renderer,Rect initialBounds,Drawable resizingBackgroundDrawable,Drawable captionBackgroundDrawable,Drawable userCaptionBackgroundDrawable,int statusBarColor,int navigationBarColor,boolean fullscreen,Rect systemInsets,Rect stableInsets){
  setName(""String_Node_Str"");
  mRenderer=renderer;
  onResourcesLoaded(decorView,resizingBackgroundDrawable,captionBackgroundDrawable,userCaptionBackgroundDrawable,statusBarColor,navigationBarColor);
  mFrameAndBackdropNode=RenderNode.create(""String_Node_Str"",null);
  mRenderer.addRenderNode(mFrameAndBackdropNode,true);
  mTargetRect.set(initialBounds);
  mFullscreen=fullscreen;
  mOldFullscreen=fullscreen;
  mSystemInsets.set(systemInsets);
  mStableInsets.set(stableInsets);
  mOldSystemInsets.set(systemInsets);
  mOldStableInsets.set(stableInsets);
synchronized (this) {
    redrawLocked(initialBounds,fullscreen,mSystemInsets,mStableInsets);
  }
  start();
}",0.7541795665634675
192771,"/** 
 * Call this function asynchronously when the window size has been changed. The change will be picked up once per frame and the frame will be re-rendered accordingly.
 * @param newTargetBounds The new target bounds.
 */
public void setTargetRect(Rect newTargetBounds){
synchronized (this) {
    mTargetRect.set(newTargetBounds);
    pingRenderLocked();
  }
}","/** 
 * Call this function asynchronously when the window size has been changed or when the insets have changed or whether window switched between a fullscreen or non-fullscreen layout. The change will be picked up once per frame and the frame will be re-rendered accordingly.
 * @param newTargetBounds The new target bounds.
 * @param fullscreen Whether the window is currently drawing in fullscreen.
 * @param systemInsets The current visible system insets for the window.
 * @param stableInsets The stable insets for the window.
 */
public void setTargetRect(Rect newTargetBounds,boolean fullscreen,Rect systemInsets,Rect stableInsets){
synchronized (this) {
    mFullscreen=fullscreen;
    mTargetRect.set(newTargetBounds);
    mSystemInsets.set(systemInsets);
    mStableInsets.set(stableInsets);
    pingRenderLocked();
  }
}",0.6080402010050251
192772,"public static NotificationViewWrapper wrap(Context ctx,View v){
  if (v.getId() == com.android.internal.R.id.status_bar_latest_event_content) {
    if (""String_Node_Str"".equals(v.getTag())) {
      return new NotificationBigPictureTemplateViewWrapper(ctx,v);
    }
    return new NotificationTemplateViewWrapper(ctx,v);
  }
 else   if (v instanceof NotificationHeaderView) {
    return new NotificationHeaderViewWrapper(ctx,v);
  }
 else {
    return new NotificationCustomViewWrapper(v);
  }
}","public static NotificationViewWrapper wrap(Context ctx,View v){
  if (v.getId() == com.android.internal.R.id.status_bar_latest_event_content) {
    if (""String_Node_Str"".equals(v.getTag())) {
      return new NotificationBigPictureTemplateViewWrapper(ctx,v);
    }
 else     if (""String_Node_Str"".equals(v.getTag())) {
      return new NotificationBigTextTemplateViewWrapper(ctx,v);
    }
    return new NotificationTemplateViewWrapper(ctx,v);
  }
 else   if (v instanceof NotificationHeaderView) {
    return new NotificationHeaderViewWrapper(ctx,v);
  }
 else {
    return new NotificationCustomViewWrapper(v);
  }
}",0.6924460431654677
192773,"public static NotificationViewWrapper wrap(Context ctx,View v){
  if (v.getId() == com.android.internal.R.id.status_bar_latest_event_content) {
    if (""String_Node_Str"".equals(v.getTag())) {
      return new NotificationBigPictureTemplateViewWrapper(ctx,v);
    }
    return new NotificationTemplateViewWrapper(ctx,v);
  }
 else   if (v instanceof NotificationHeaderView) {
    return new NotificationHeaderViewWrapper(ctx,v);
  }
 else {
    return new NotificationCustomViewWrapper(v);
  }
}","public static NotificationViewWrapper wrap(Context ctx,View v){
  if (v.getId() == com.android.internal.R.id.status_bar_latest_event_content) {
    if (""String_Node_Str"".equals(v.getTag())) {
      return new NotificationBigPictureTemplateViewWrapper(ctx,v);
    }
 else     if (""String_Node_Str"".equals(v.getTag())) {
      return new NotificationBigTextTemplateViewWrapper(ctx,v);
    }
    return new NotificationTemplateViewWrapper(ctx,v);
  }
 else   if (v instanceof NotificationHeaderView) {
    return new NotificationHeaderViewWrapper(ctx,v);
  }
 else {
    return new NotificationCustomViewWrapper(v);
  }
}",0.6924460431654677
192774,"@Override protected void applyRestoredPayload(String key,byte[] payload){
  if (KEY_USAGE_STATS.equals(key)) {
    UsageStatsManagerInternal localUsageStatsManager=LocalServices.getService(UsageStatsManagerInternal.class);
    DataInputStream in=new DataInputStream(new ByteArrayInputStream(payload));
    try {
      int user=in.readInt();
      byte[] restoreData=new byte[payload.length - 4];
      in.read(restoreData,0,payload.length - 4);
      localUsageStatsManager.applyRestoredPayload(user,key,restoreData);
    }
 catch (    IOException ioe) {
      if (DEBUG)       Log.e(TAG,""String_Node_Str"",ioe);
    }
  }
}","@Override protected void applyRestoredPayload(String key,byte[] payload){
  if (KEY_USAGE_STATS.equals(key)) {
    UsageStatsManagerInternal localUsageStatsManager=LocalServices.getService(UsageStatsManagerInternal.class);
    DataInputStream in=new DataInputStream(new ByteArrayInputStream(payload));
    try {
      int user=in.readInt();
      byte[] restoreData=new byte[payload.length - 4];
      in.read(restoreData,0,restoreData.length);
      localUsageStatsManager.applyRestoredPayload(user,key,restoreData);
    }
 catch (    IOException ioe) {
      if (DEBUG)       Log.e(TAG,""String_Node_Str"",ioe);
    }
  }
}",0.9823434991974318
192775,"/** 
 * Get the Configuration Statistics from the current device statistics and merge them with the backed up usage statistics.
 */
private IntervalStats mergeStats(IntervalStats beingRestored,IntervalStats onDevice){
  beingRestored.activeConfiguration=onDevice.activeConfiguration;
  beingRestored.configurations.putAll(onDevice.configurations);
  beingRestored.events=onDevice.events;
  return beingRestored;
}","/** 
 * Get the Configuration Statistics from the current device statistics and merge them with the backed up usage statistics.
 */
private IntervalStats mergeStats(IntervalStats beingRestored,IntervalStats onDevice){
  if (onDevice == null)   return beingRestored;
  if (beingRestored == null)   return null;
  beingRestored.activeConfiguration=onDevice.activeConfiguration;
  beingRestored.configurations.putAll(onDevice.configurations);
  beingRestored.events=onDevice.events;
  return beingRestored;
}",0.8997821350762527
192776,"protected void applyRestoredPayload(String key,byte[] payload){
synchronized (mLock) {
    if (KEY_USAGE_STATS.equals(key)) {
      IntervalStats dailyConfigSource=getLatestUsageStats(UsageStatsManager.INTERVAL_DAILY);
      IntervalStats weeklyConfigSource=getLatestUsageStats(UsageStatsManager.INTERVAL_WEEKLY);
      IntervalStats monthlyConfigSource=getLatestUsageStats(UsageStatsManager.INTERVAL_MONTHLY);
      IntervalStats yearlyConfigSource=getLatestUsageStats(UsageStatsManager.INTERVAL_YEARLY);
      for (int i=0; i < mIntervalDirs.length; i++) {
        deleteDirectoryContents(mIntervalDirs[i]);
      }
      try {
        DataInputStream in=new DataInputStream(new ByteArrayInputStream(payload));
        int stateVersion=in.readInt();
        int fileCount=in.readInt();
        for (int i=0; i < fileCount; i++) {
          IntervalStats stats=deserializeIntervalStats(getIntervalStatsBytes(in));
          stats=mergeStats(stats,dailyConfigSource);
          putUsageStats(UsageStatsManager.INTERVAL_DAILY,stats);
        }
        fileCount=in.readInt();
        for (int i=0; i < fileCount; i++) {
          IntervalStats stats=deserializeIntervalStats(getIntervalStatsBytes(in));
          stats=mergeStats(stats,weeklyConfigSource);
          putUsageStats(UsageStatsManager.INTERVAL_WEEKLY,stats);
        }
        fileCount=in.readInt();
        for (int i=0; i < fileCount; i++) {
          IntervalStats stats=deserializeIntervalStats(getIntervalStatsBytes(in));
          stats=mergeStats(stats,monthlyConfigSource);
          putUsageStats(UsageStatsManager.INTERVAL_MONTHLY,stats);
        }
        fileCount=in.readInt();
        for (int i=0; i < fileCount; i++) {
          IntervalStats stats=deserializeIntervalStats(getIntervalStatsBytes(in));
          stats=mergeStats(stats,yearlyConfigSource);
          putUsageStats(UsageStatsManager.INTERVAL_YEARLY,stats);
        }
        if (DEBUG)         Slog.i(TAG,""String_Node_Str"");
      }
 catch (      IOException ioe) {
        Slog.d(TAG,""String_Node_Str"",ioe);
      }
 finally {
        indexFilesLocked();
      }
    }
  }
}","void applyRestoredPayload(String key,byte[] payload){
synchronized (mLock) {
    if (KEY_USAGE_STATS.equals(key)) {
      IntervalStats dailyConfigSource=getLatestUsageStats(UsageStatsManager.INTERVAL_DAILY);
      IntervalStats weeklyConfigSource=getLatestUsageStats(UsageStatsManager.INTERVAL_WEEKLY);
      IntervalStats monthlyConfigSource=getLatestUsageStats(UsageStatsManager.INTERVAL_MONTHLY);
      IntervalStats yearlyConfigSource=getLatestUsageStats(UsageStatsManager.INTERVAL_YEARLY);
      try {
        DataInputStream in=new DataInputStream(new ByteArrayInputStream(payload));
        int backupDataVersion=in.readInt();
        if (backupDataVersion < 1 || backupDataVersion > BACKUP_VERSION)         return;
        for (int i=0; i < mIntervalDirs.length; i++) {
          deleteDirectoryContents(mIntervalDirs[i]);
        }
        int fileCount=in.readInt();
        for (int i=0; i < fileCount; i++) {
          IntervalStats stats=deserializeIntervalStats(getIntervalStatsBytes(in));
          stats=mergeStats(stats,dailyConfigSource);
          putUsageStats(UsageStatsManager.INTERVAL_DAILY,stats);
        }
        fileCount=in.readInt();
        for (int i=0; i < fileCount; i++) {
          IntervalStats stats=deserializeIntervalStats(getIntervalStatsBytes(in));
          stats=mergeStats(stats,weeklyConfigSource);
          putUsageStats(UsageStatsManager.INTERVAL_WEEKLY,stats);
        }
        fileCount=in.readInt();
        for (int i=0; i < fileCount; i++) {
          IntervalStats stats=deserializeIntervalStats(getIntervalStatsBytes(in));
          stats=mergeStats(stats,monthlyConfigSource);
          putUsageStats(UsageStatsManager.INTERVAL_MONTHLY,stats);
        }
        fileCount=in.readInt();
        for (int i=0; i < fileCount; i++) {
          IntervalStats stats=deserializeIntervalStats(getIntervalStatsBytes(in));
          stats=mergeStats(stats,yearlyConfigSource);
          putUsageStats(UsageStatsManager.INTERVAL_YEARLY,stats);
        }
        if (DEBUG)         Slog.i(TAG,""String_Node_Str"");
      }
 catch (      IOException ioe) {
        Slog.d(TAG,""String_Node_Str"",ioe);
      }
 finally {
        indexFilesLocked();
      }
    }
  }
}",0.91270207852194
192777,"protected byte[] getBackupPayload(String key){
synchronized (mLock) {
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    if (KEY_USAGE_STATS.equals(key)) {
      prune(System.currentTimeMillis());
      DataOutputStream out=new DataOutputStream(baos);
      try {
        out.writeInt(BACKUP_STATE_VERSION);
        out.writeInt(mSortedStatFiles[UsageStatsManager.INTERVAL_DAILY].size());
        for (int i=0; i < mSortedStatFiles[UsageStatsManager.INTERVAL_DAILY].size(); i++) {
          writeIntervalStatsToStream(out,mSortedStatFiles[UsageStatsManager.INTERVAL_DAILY].valueAt(i));
        }
        out.writeInt(mSortedStatFiles[UsageStatsManager.INTERVAL_WEEKLY].size());
        for (int i=0; i < mSortedStatFiles[UsageStatsManager.INTERVAL_WEEKLY].size(); i++) {
          writeIntervalStatsToStream(out,mSortedStatFiles[UsageStatsManager.INTERVAL_WEEKLY].valueAt(i));
        }
        out.writeInt(mSortedStatFiles[UsageStatsManager.INTERVAL_MONTHLY].size());
        for (int i=0; i < mSortedStatFiles[UsageStatsManager.INTERVAL_MONTHLY].size(); i++) {
          writeIntervalStatsToStream(out,mSortedStatFiles[UsageStatsManager.INTERVAL_MONTHLY].valueAt(i));
        }
        out.writeInt(mSortedStatFiles[UsageStatsManager.INTERVAL_YEARLY].size());
        for (int i=0; i < mSortedStatFiles[UsageStatsManager.INTERVAL_YEARLY].size(); i++) {
          writeIntervalStatsToStream(out,mSortedStatFiles[UsageStatsManager.INTERVAL_YEARLY].valueAt(i));
        }
        if (DEBUG)         Slog.i(TAG,""String_Node_Str"" + baos.size() + ""String_Node_Str"");
      }
 catch (      IOException ioe) {
        Slog.d(TAG,""String_Node_Str"",ioe);
        baos.reset();
      }
    }
    return baos.toByteArray();
  }
}","byte[] getBackupPayload(String key){
synchronized (mLock) {
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    if (KEY_USAGE_STATS.equals(key)) {
      prune(System.currentTimeMillis());
      DataOutputStream out=new DataOutputStream(baos);
      try {
        out.writeInt(BACKUP_VERSION);
        out.writeInt(mSortedStatFiles[UsageStatsManager.INTERVAL_DAILY].size());
        for (int i=0; i < mSortedStatFiles[UsageStatsManager.INTERVAL_DAILY].size(); i++) {
          writeIntervalStatsToStream(out,mSortedStatFiles[UsageStatsManager.INTERVAL_DAILY].valueAt(i));
        }
        out.writeInt(mSortedStatFiles[UsageStatsManager.INTERVAL_WEEKLY].size());
        for (int i=0; i < mSortedStatFiles[UsageStatsManager.INTERVAL_WEEKLY].size(); i++) {
          writeIntervalStatsToStream(out,mSortedStatFiles[UsageStatsManager.INTERVAL_WEEKLY].valueAt(i));
        }
        out.writeInt(mSortedStatFiles[UsageStatsManager.INTERVAL_MONTHLY].size());
        for (int i=0; i < mSortedStatFiles[UsageStatsManager.INTERVAL_MONTHLY].size(); i++) {
          writeIntervalStatsToStream(out,mSortedStatFiles[UsageStatsManager.INTERVAL_MONTHLY].valueAt(i));
        }
        out.writeInt(mSortedStatFiles[UsageStatsManager.INTERVAL_YEARLY].size());
        for (int i=0; i < mSortedStatFiles[UsageStatsManager.INTERVAL_YEARLY].size(); i++) {
          writeIntervalStatsToStream(out,mSortedStatFiles[UsageStatsManager.INTERVAL_YEARLY].valueAt(i));
        }
        if (DEBUG)         Slog.i(TAG,""String_Node_Str"" + baos.size() + ""String_Node_Str"");
      }
 catch (      IOException ioe) {
        Slog.d(TAG,""String_Node_Str"",ioe);
        baos.reset();
      }
    }
    return baos.toByteArray();
  }
}",0.9953623188405796
192778,"/** 
 * Update the stats in the database. They may not be written to disk immediately.
 */
public void putUsageStats(int intervalType,IntervalStats stats) throws IOException {
synchronized (mLock) {
    if (intervalType < 0 || intervalType >= mIntervalDirs.length) {
      throw new IllegalArgumentException(""String_Node_Str"" + intervalType);
    }
    AtomicFile f=mSortedStatFiles[intervalType].get(stats.beginTime);
    if (f == null) {
      f=new AtomicFile(new File(mIntervalDirs[intervalType],Long.toString(stats.beginTime)));
      mSortedStatFiles[intervalType].put(stats.beginTime,f);
    }
    UsageStatsXml.write(f,stats);
    stats.lastTimeSaved=f.getLastModifiedTime();
  }
}","/** 
 * Update the stats in the database. They may not be written to disk immediately.
 */
public void putUsageStats(int intervalType,IntervalStats stats) throws IOException {
  if (stats == null)   return;
synchronized (mLock) {
    if (intervalType < 0 || intervalType >= mIntervalDirs.length) {
      throw new IllegalArgumentException(""String_Node_Str"" + intervalType);
    }
    AtomicFile f=mSortedStatFiles[intervalType].get(stats.beginTime);
    if (f == null) {
      f=new AtomicFile(new File(mIntervalDirs[intervalType],Long.toString(stats.beginTime)));
      mSortedStatFiles[intervalType].put(stats.beginTime,f);
    }
    UsageStatsXml.write(f,stats);
    stats.lastTimeSaved=f.getLastModifiedTime();
  }
}",0.977998580553584
192779,"private static void deleteDirectory(File directory){
  File[] files=directory.listFiles();
  for (  File file : files) {
    if (!file.isDirectory()) {
      file.delete();
    }
 else {
      deleteDirectory(file);
    }
  }
  directory.delete();
}","private static void deleteDirectory(File directory){
  File[] files=directory.listFiles();
  if (files != null) {
    for (    File file : files) {
      if (!file.isDirectory()) {
        file.delete();
      }
 else {
        deleteDirectory(file);
      }
    }
  }
  directory.delete();
}",0.6876155268022182
192780,"private void collectSpecialWindows(WindowState w){
  if (w.mAttrs.type == TYPE_DOCK_DIVIDER) {
    mDockDivider=w;
  }
 else {
    final TaskStack stack=w.getStack();
    if (stack == null) {
      return;
    }
    if (stack.mStackId == StackId.PINNED_STACK_ID) {
      mPinnedWindow=w;
    }
 else     if (stack.mStackId == StackId.DOCKED_STACK_ID) {
      mDockedWindow=w;
    }
  }
}","private void collectSpecialWindows(WindowState w){
  if (w.mAttrs.type == TYPE_DOCK_DIVIDER) {
    mDockDivider=w;
    return;
  }
  if (w.mWillReplaceWindow) {
    mReplacingWindows.add(w);
  }
  final TaskStack stack=w.getStack();
  if (stack == null) {
    return;
  }
  if (stack.mStackId == PINNED_STACK_ID) {
    mPinnedWindows.add(w);
  }
 else   if (stack.mStackId == DOCKED_STACK_ID) {
    mDockedWindows.add(w);
  }
}",0.6167076167076168
192781,"private void clear(){
  mHighestApplicationLayer=0;
  mPinnedWindow=null;
  mDockedWindow=null;
  mDockDivider=null;
}","private void clear(){
  mHighestApplicationLayer=0;
  mPinnedWindows.clear();
  mDockedWindows.clear();
  mReplacingWindows.clear();
  mDockDivider=null;
}",0.8131868131868132
192782,"private void adjustSpecialWindows(){
  int layer=mHighestApplicationLayer + 1;
  layer=assignAndIncreaseLayerIfNeeded(mDockedWindow,layer);
  layer++;
  layer=assignAndIncreaseLayerIfNeeded(mDockDivider,layer);
  layer=assignAndIncreaseLayerIfNeeded(mReplacingWindow,layer);
  layer=assignAndIncreaseLayerIfNeeded(mPinnedWindow,layer);
}","private void adjustSpecialWindows(){
  int layer=mHighestApplicationLayer + 1;
  while (!mDockedWindows.isEmpty()) {
    layer=assignAndIncreaseLayerIfNeeded(mDockedWindows.remove(),layer);
  }
  layer++;
  layer=assignAndIncreaseLayerIfNeeded(mDockDivider,layer);
  while (!mReplacingWindows.isEmpty()) {
    layer=assignAndIncreaseLayerIfNeeded(mReplacingWindows.remove(),layer);
  }
  while (!mPinnedWindows.isEmpty()) {
    layer=assignAndIncreaseLayerIfNeeded(mPinnedWindows.remove(),layer);
  }
}",0.8033373063170441
192783,"private void collectSpecialWindows(WindowState w){
  if (w.mAttrs.type == TYPE_DOCK_DIVIDER) {
    mDockDivider=w;
  }
 else {
    final TaskStack stack=w.getStack();
    if (stack == null) {
      return;
    }
    if (stack.mStackId == StackId.PINNED_STACK_ID) {
      mPinnedWindow=w;
    }
 else     if (stack.mStackId == StackId.DOCKED_STACK_ID) {
      mDockedWindow=w;
    }
  }
}","private void collectSpecialWindows(WindowState w){
  if (w.mAttrs.type == TYPE_DOCK_DIVIDER) {
    mDockDivider=w;
    return;
  }
  if (w.mWillReplaceWindow) {
    mReplacingWindows.add(w);
  }
  final TaskStack stack=w.getStack();
  if (stack == null) {
    return;
  }
  if (stack.mStackId == PINNED_STACK_ID) {
    mPinnedWindows.add(w);
  }
 else   if (stack.mStackId == DOCKED_STACK_ID) {
    mDockedWindows.add(w);
  }
}",0.6167076167076168
192784,"private void clear(){
  mHighestApplicationLayer=0;
  mPinnedWindow=null;
  mDockedWindow=null;
  mDockDivider=null;
}","private void clear(){
  mHighestApplicationLayer=0;
  mPinnedWindows.clear();
  mDockedWindows.clear();
  mReplacingWindows.clear();
  mDockDivider=null;
}",0.8131868131868132
192785,"private void adjustSpecialWindows(){
  int layer=mHighestApplicationLayer + 1;
  layer=assignAndIncreaseLayerIfNeeded(mDockedWindow,layer);
  layer++;
  layer=assignAndIncreaseLayerIfNeeded(mDockDivider,layer);
  layer=assignAndIncreaseLayerIfNeeded(mReplacingWindow,layer);
  layer=assignAndIncreaseLayerIfNeeded(mPinnedWindow,layer);
}","private void adjustSpecialWindows(){
  int layer=mHighestApplicationLayer + 1;
  while (!mDockedWindows.isEmpty()) {
    layer=assignAndIncreaseLayerIfNeeded(mDockedWindows.remove(),layer);
  }
  layer++;
  layer=assignAndIncreaseLayerIfNeeded(mDockDivider,layer);
  while (!mReplacingWindows.isEmpty()) {
    layer=assignAndIncreaseLayerIfNeeded(mReplacingWindows.remove(),layer);
  }
  while (!mPinnedWindows.isEmpty()) {
    layer=assignAndIncreaseLayerIfNeeded(mPinnedWindows.remove(),layer);
  }
}",0.8033373063170441
192786,"public void updateRunningAccounts(){
  if (Log.isLoggable(TAG,Log.VERBOSE))   Log.v(TAG,""String_Node_Str"");
  mSyncHandler.sendEmptyMessage(SyncHandler.MESSAGE_ACCOUNTS_UPDATED);
}","private void updateRunningAccounts(boolean resyncAllTargets){
  if (Log.isLoggable(TAG,Log.VERBOSE))   Log.v(TAG,""String_Node_Str"");
  Message m=mSyncHandler.obtainMessage(SyncHandler.MESSAGE_ACCOUNTS_UPDATED);
  m.arg1=resyncAllTargets ? 1 : 0;
  m.sendToTarget();
}",0.7427293064876958
192787,"private void onUserRemoved(int userId){
  updateRunningAccounts();
  mSyncStorageEngine.doDatabaseCleanup(new Account[0],userId);
synchronized (mSyncQueue) {
    mSyncQueue.removeUserLocked(userId);
  }
}","private void onUserRemoved(int userId){
  updateRunningAccounts(false);
  mSyncStorageEngine.doDatabaseCleanup(new Account[0],userId);
synchronized (mSyncQueue) {
    mSyncQueue.removeUserLocked(userId);
  }
}",0.9878934624697336
192788,"private void onUserStopping(int userId){
  updateRunningAccounts();
  cancelActiveSync(new SyncStorageEngine.EndPoint(null,null,userId),null);
}","private void onUserStopping(int userId){
  updateRunningAccounts(false);
  cancelActiveSync(new SyncStorageEngine.EndPoint(null,null,userId),null);
}",0.9829351535836176
192789,"private void onUserUnlocked(int userId){
  AccountManagerService.getSingleton().validateAccounts(userId);
  mSyncAdapters.invalidateCache(userId);
  updateRunningAccounts();
synchronized (mSyncQueue) {
    mSyncQueue.addPendingOperations(userId);
  }
  final Account[] accounts=AccountManagerService.getSingleton().getAccounts(userId,mContext.getOpPackageName());
  for (  Account account : accounts) {
    scheduleSync(account,userId,SyncOperation.REASON_USER_START,null,null,0,0,true);
  }
  sendCheckAlarmsMessage();
}","private void onUserUnlocked(int userId){
  AccountManagerService.getSingleton().validateAccounts(userId);
  mSyncAdapters.invalidateCache(userId);
  updateRunningAccounts(false);
synchronized (mSyncQueue) {
    mSyncQueue.addPendingOperations(userId);
  }
  final Account[] accounts=AccountManagerService.getSingleton().getAccounts(userId,mContext.getOpPackageName());
  for (  Account account : accounts) {
    scheduleSync(account,userId,SyncOperation.REASON_USER_START,null,null,0,0,true);
  }
  sendCheckAlarmsMessage();
}",0.9952244508118434
192790,"private void updateRunningAccountsH(){
  mRunningAccounts=AccountManagerService.getSingleton().getRunningAccounts();
  if (mBootCompleted) {
    doDatabaseCleanup();
  }
  AccountAndUser[] accounts=mRunningAccounts;
  for (  ActiveSyncContext currentSyncContext : mActiveSyncContexts) {
    if (!containsAccountAndUser(accounts,currentSyncContext.mSyncOperation.target.account,currentSyncContext.mSyncOperation.target.userId)) {
      Log.d(TAG,""String_Node_Str"");
      sendSyncFinishedOrCanceledMessage(currentSyncContext,null);
    }
  }
  sendCheckAlarmsMessage();
}","private void updateRunningAccountsH(boolean resyncAll){
  mRunningAccounts=AccountManagerService.getSingleton().getRunningAccounts();
  if (mBootCompleted) {
    doDatabaseCleanup();
  }
  AccountAndUser[] accounts=mRunningAccounts;
  for (  ActiveSyncContext currentSyncContext : mActiveSyncContexts) {
    if (!containsAccountAndUser(accounts,currentSyncContext.mSyncOperation.target.account,currentSyncContext.mSyncOperation.target.userId)) {
      Log.d(TAG,""String_Node_Str"");
      sendSyncFinishedOrCanceledMessage(currentSyncContext,null);
    }
  }
  if (resyncAll) {
    scheduleSync(null,UserHandle.USER_ALL,SyncOperation.REASON_ACCOUNTS_UPDATED,null,null,0,0,false);
  }
 else {
    sendCheckAlarmsMessage();
  }
}",0.8719135802469136
192791,"public void handleMessage(Message msg){
  if (tryEnqueueMessageUntilReadyToRun(msg)) {
    return;
  }
  long earliestFuturePollTime=Long.MAX_VALUE;
  long nextPendingSyncTime=Long.MAX_VALUE;
  try {
    mDataConnectionIsConnected=readDataConnectionState();
    mSyncManagerWakeLock.acquire();
    earliestFuturePollTime=scheduleReadyPeriodicSyncs();
switch (msg.what) {
case SyncHandler.MESSAGE_ACCOUNTS_UPDATED:
      if (Log.isLoggable(TAG,Log.VERBOSE)) {
        Log.v(TAG,""String_Node_Str"");
      }
    updateRunningAccountsH();
  break;
case SyncHandler.MESSAGE_CANCEL:
SyncStorageEngine.EndPoint endpoint=(SyncStorageEngine.EndPoint)msg.obj;
Bundle extras=msg.peekData();
if (Log.isLoggable(TAG,Log.DEBUG)) {
Log.d(TAG,""String_Node_Str"" + endpoint + ""String_Node_Str""+ extras);
}
cancelActiveSyncH(endpoint,extras);
nextPendingSyncTime=maybeStartNextSyncH();
break;
case SyncHandler.MESSAGE_SYNC_FINISHED:
if (Log.isLoggable(TAG,Log.VERBOSE)) {
Log.v(TAG,""String_Node_Str"");
}
SyncHandlerMessagePayload payload=(SyncHandlerMessagePayload)msg.obj;
if (!isSyncStillActiveH(payload.activeSyncContext)) {
Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + payload.activeSyncContext);
break;
}
runSyncFinishedOrCanceledH(payload.syncResult,payload.activeSyncContext);
nextPendingSyncTime=maybeStartNextSyncH();
break;
case SyncHandler.MESSAGE_SERVICE_CONNECTED:
{
ServiceConnectionData msgData=(ServiceConnectionData)msg.obj;
if (Log.isLoggable(TAG,Log.VERBOSE)) {
Log.d(TAG,""String_Node_Str"" + msgData.activeSyncContext);
}
if (isSyncStillActiveH(msgData.activeSyncContext)) {
runBoundToAdapter(msgData.activeSyncContext,msgData.adapter);
}
break;
}
case SyncHandler.MESSAGE_SERVICE_DISCONNECTED:
{
final ActiveSyncContext currentSyncContext=((ServiceConnectionData)msg.obj).activeSyncContext;
if (Log.isLoggable(TAG,Log.VERBOSE)) {
Log.d(TAG,""String_Node_Str"" + currentSyncContext);
}
if (isSyncStillActiveH(currentSyncContext)) {
try {
if (currentSyncContext.mSyncAdapter != null) {
currentSyncContext.mSyncAdapter.cancelSync(currentSyncContext);
}
 else if (currentSyncContext.mSyncServiceAdapter != null) {
currentSyncContext.mSyncServiceAdapter.cancelSync(currentSyncContext);
}
}
 catch (RemoteException e) {
}
SyncResult syncResult=new SyncResult();
syncResult.stats.numIoExceptions++;
runSyncFinishedOrCanceledH(syncResult,currentSyncContext);
nextPendingSyncTime=maybeStartNextSyncH();
}
break;
}
case SyncHandler.MESSAGE_SYNC_ALARM:
{
boolean isLoggable=Log.isLoggable(TAG,Log.VERBOSE);
if (isLoggable) {
Log.v(TAG,""String_Node_Str"");
}
mAlarmScheduleTime=null;
try {
nextPendingSyncTime=maybeStartNextSyncH();
}
  finally {
mHandleAlarmWakeLock.release();
}
break;
}
case SyncHandler.MESSAGE_CHECK_ALARMS:
if (Log.isLoggable(TAG,Log.VERBOSE)) {
Log.v(TAG,""String_Node_Str"");
}
nextPendingSyncTime=maybeStartNextSyncH();
break;
case SyncHandler.MESSAGE_SYNC_EXPIRED:
ActiveSyncContext expiredContext=(ActiveSyncContext)msg.obj;
if (Log.isLoggable(TAG,Log.DEBUG)) {
Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + expiredContext);
}
runSyncFinishedOrCanceledH(null,expiredContext);
nextPendingSyncTime=maybeStartNextSyncH();
break;
case SyncHandler.MESSAGE_MONITOR_SYNC:
ActiveSyncContext monitoredSyncContext=(ActiveSyncContext)msg.obj;
if (Log.isLoggable(TAG,Log.DEBUG)) {
Log.d(TAG,""String_Node_Str"" + monitoredSyncContext.mSyncOperation.target);
}
if (isSyncNotUsingNetworkH(monitoredSyncContext)) {
Log.w(TAG,String.format(""String_Node_Str"",monitoredSyncContext));
runSyncFinishedOrCanceledH(null,monitoredSyncContext);
}
 else {
postMonitorSyncProgressMessage(monitoredSyncContext);
}
break;
}
}
  finally {
manageSyncAlarmLocked(earliestFuturePollTime,nextPendingSyncTime);
mSyncTimeTracker.update();
mSyncManagerWakeLock.release();
}
}","public void handleMessage(Message msg){
  if (tryEnqueueMessageUntilReadyToRun(msg)) {
    return;
  }
  long earliestFuturePollTime=Long.MAX_VALUE;
  long nextPendingSyncTime=Long.MAX_VALUE;
  try {
    mDataConnectionIsConnected=readDataConnectionState();
    mSyncManagerWakeLock.acquire();
    earliestFuturePollTime=scheduleReadyPeriodicSyncs();
switch (msg.what) {
case SyncHandler.MESSAGE_ACCOUNTS_UPDATED:
      if (Log.isLoggable(TAG,Log.VERBOSE)) {
        Log.v(TAG,""String_Node_Str"");
      }
    boolean resyncAllTargets=msg.arg1 == 0 ? false : true;
  updateRunningAccountsH(resyncAllTargets);
break;
case SyncHandler.MESSAGE_CANCEL:
SyncStorageEngine.EndPoint endpoint=(SyncStorageEngine.EndPoint)msg.obj;
Bundle extras=msg.peekData();
if (Log.isLoggable(TAG,Log.DEBUG)) {
Log.d(TAG,""String_Node_Str"" + endpoint + ""String_Node_Str""+ extras);
}
cancelActiveSyncH(endpoint,extras);
nextPendingSyncTime=maybeStartNextSyncH();
break;
case SyncHandler.MESSAGE_SYNC_FINISHED:
if (Log.isLoggable(TAG,Log.VERBOSE)) {
Log.v(TAG,""String_Node_Str"");
}
SyncHandlerMessagePayload payload=(SyncHandlerMessagePayload)msg.obj;
if (!isSyncStillActiveH(payload.activeSyncContext)) {
Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + payload.activeSyncContext);
break;
}
runSyncFinishedOrCanceledH(payload.syncResult,payload.activeSyncContext);
nextPendingSyncTime=maybeStartNextSyncH();
break;
case SyncHandler.MESSAGE_SERVICE_CONNECTED:
{
ServiceConnectionData msgData=(ServiceConnectionData)msg.obj;
if (Log.isLoggable(TAG,Log.VERBOSE)) {
Log.d(TAG,""String_Node_Str"" + msgData.activeSyncContext);
}
if (isSyncStillActiveH(msgData.activeSyncContext)) {
runBoundToAdapter(msgData.activeSyncContext,msgData.adapter);
}
break;
}
case SyncHandler.MESSAGE_SERVICE_DISCONNECTED:
{
final ActiveSyncContext currentSyncContext=((ServiceConnectionData)msg.obj).activeSyncContext;
if (Log.isLoggable(TAG,Log.VERBOSE)) {
Log.d(TAG,""String_Node_Str"" + currentSyncContext);
}
if (isSyncStillActiveH(currentSyncContext)) {
try {
if (currentSyncContext.mSyncAdapter != null) {
currentSyncContext.mSyncAdapter.cancelSync(currentSyncContext);
}
 else if (currentSyncContext.mSyncServiceAdapter != null) {
currentSyncContext.mSyncServiceAdapter.cancelSync(currentSyncContext);
}
}
 catch (RemoteException e) {
}
SyncResult syncResult=new SyncResult();
syncResult.stats.numIoExceptions++;
runSyncFinishedOrCanceledH(syncResult,currentSyncContext);
nextPendingSyncTime=maybeStartNextSyncH();
}
break;
}
case SyncHandler.MESSAGE_SYNC_ALARM:
{
boolean isLoggable=Log.isLoggable(TAG,Log.VERBOSE);
if (isLoggable) {
Log.v(TAG,""String_Node_Str"");
}
mAlarmScheduleTime=null;
try {
nextPendingSyncTime=maybeStartNextSyncH();
}
  finally {
mHandleAlarmWakeLock.release();
}
break;
}
case SyncHandler.MESSAGE_CHECK_ALARMS:
if (Log.isLoggable(TAG,Log.VERBOSE)) {
Log.v(TAG,""String_Node_Str"");
}
nextPendingSyncTime=maybeStartNextSyncH();
break;
case SyncHandler.MESSAGE_SYNC_EXPIRED:
ActiveSyncContext expiredContext=(ActiveSyncContext)msg.obj;
if (Log.isLoggable(TAG,Log.DEBUG)) {
Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + expiredContext);
}
runSyncFinishedOrCanceledH(null,expiredContext);
nextPendingSyncTime=maybeStartNextSyncH();
break;
case SyncHandler.MESSAGE_MONITOR_SYNC:
ActiveSyncContext monitoredSyncContext=(ActiveSyncContext)msg.obj;
if (Log.isLoggable(TAG,Log.DEBUG)) {
Log.d(TAG,""String_Node_Str"" + monitoredSyncContext.mSyncOperation.target);
}
if (isSyncNotUsingNetworkH(monitoredSyncContext)) {
Log.w(TAG,String.format(""String_Node_Str"",monitoredSyncContext));
runSyncFinishedOrCanceledH(null,monitoredSyncContext);
}
 else {
postMonitorSyncProgressMessage(monitoredSyncContext);
}
break;
}
}
  finally {
manageSyncAlarmLocked(earliestFuturePollTime,nextPendingSyncTime);
mSyncTimeTracker.update();
mSyncManagerWakeLock.release();
}
}",0.9893210283454186
192792,"private void updateRunningAccounts(boolean resyncAllTargets){
  if (Log.isLoggable(TAG,Log.VERBOSE))   Log.v(TAG,""String_Node_Str"");
  Message m=mSyncHandler.obtainMessage(SyncHandler.MESSAGE_ACCOUNTS_UPDATED);
  m.arg1=resyncAllTargets ? 1 : 0;
  m.sendToTarget();
}","public void updateRunningAccounts(){
  if (Log.isLoggable(TAG,Log.VERBOSE))   Log.v(TAG,""String_Node_Str"");
  mSyncHandler.sendEmptyMessage(SyncHandler.MESSAGE_ACCOUNTS_UPDATED);
}",0.7516778523489933
192793,"private void onUserRemoved(int userId){
  updateRunningAccounts(false);
  mSyncStorageEngine.doDatabaseCleanup(new Account[0],userId);
synchronized (mSyncQueue) {
    mSyncQueue.removeUserLocked(userId);
  }
}","private void onUserRemoved(int userId){
  updateRunningAccounts();
  mSyncStorageEngine.doDatabaseCleanup(new Account[0],userId);
synchronized (mSyncQueue) {
    mSyncQueue.removeUserLocked(userId);
  }
}",0.9878934624697336
192794,"private void onUserStopping(int userId){
  updateRunningAccounts(false);
  cancelActiveSync(new SyncStorageEngine.EndPoint(null,null,userId),null);
}","private void onUserStopping(int userId){
  updateRunningAccounts();
  cancelActiveSync(new SyncStorageEngine.EndPoint(null,null,userId),null);
}",0.9829351535836176
192795,"private void onUserUnlocked(int userId){
  AccountManagerService.getSingleton().validateAccounts(userId);
  mSyncAdapters.invalidateCache(userId);
  updateRunningAccounts(false);
synchronized (mSyncQueue) {
    mSyncQueue.addPendingOperations(userId);
  }
  final Account[] accounts=AccountManagerService.getSingleton().getAccounts(userId,mContext.getOpPackageName());
  for (  Account account : accounts) {
    scheduleSync(account,userId,SyncOperation.REASON_USER_START,null,null,0,0,true);
  }
  sendCheckAlarmsMessage();
}","private void onUserUnlocked(int userId){
  AccountManagerService.getSingleton().validateAccounts(userId);
  mSyncAdapters.invalidateCache(userId);
  updateRunningAccounts();
synchronized (mSyncQueue) {
    mSyncQueue.addPendingOperations(userId);
  }
  final Account[] accounts=AccountManagerService.getSingleton().getAccounts(userId,mContext.getOpPackageName());
  for (  Account account : accounts) {
    scheduleSync(account,userId,SyncOperation.REASON_USER_START,null,null,0,0,true);
  }
  sendCheckAlarmsMessage();
}",0.9952244508118434
192796,"private void updateRunningAccountsH(boolean resyncAll){
  mRunningAccounts=AccountManagerService.getSingleton().getRunningAccounts();
  if (mBootCompleted) {
    doDatabaseCleanup();
  }
  AccountAndUser[] accounts=mRunningAccounts;
  for (  ActiveSyncContext currentSyncContext : mActiveSyncContexts) {
    if (!containsAccountAndUser(accounts,currentSyncContext.mSyncOperation.target.account,currentSyncContext.mSyncOperation.target.userId)) {
      Log.d(TAG,""String_Node_Str"");
      sendSyncFinishedOrCanceledMessage(currentSyncContext,null);
    }
  }
  if (resyncAll) {
    scheduleSync(null,UserHandle.USER_ALL,SyncOperation.REASON_ACCOUNTS_UPDATED,null,null,0,0,false);
  }
 else {
    sendCheckAlarmsMessage();
  }
}","private void updateRunningAccountsH(){
  mRunningAccounts=AccountManagerService.getSingleton().getRunningAccounts();
  if (mBootCompleted) {
    doDatabaseCleanup();
  }
  AccountAndUser[] accounts=mRunningAccounts;
  for (  ActiveSyncContext currentSyncContext : mActiveSyncContexts) {
    if (!containsAccountAndUser(accounts,currentSyncContext.mSyncOperation.target.account,currentSyncContext.mSyncOperation.target.userId)) {
      Log.d(TAG,""String_Node_Str"");
      sendSyncFinishedOrCanceledMessage(currentSyncContext,null);
    }
  }
  sendCheckAlarmsMessage();
}",0.8472222222222222
192797,"public void handleMessage(Message msg){
  if (tryEnqueueMessageUntilReadyToRun(msg)) {
    return;
  }
  long earliestFuturePollTime=Long.MAX_VALUE;
  long nextPendingSyncTime=Long.MAX_VALUE;
  try {
    mDataConnectionIsConnected=readDataConnectionState();
    mSyncManagerWakeLock.acquire();
    earliestFuturePollTime=scheduleReadyPeriodicSyncs();
switch (msg.what) {
case SyncHandler.MESSAGE_ACCOUNTS_UPDATED:
      if (Log.isLoggable(TAG,Log.VERBOSE)) {
        Log.v(TAG,""String_Node_Str"");
      }
    boolean resyncAllTargets=msg.arg1 == 0 ? false : true;
  updateRunningAccountsH(resyncAllTargets);
break;
case SyncHandler.MESSAGE_CANCEL:
SyncStorageEngine.EndPoint endpoint=(SyncStorageEngine.EndPoint)msg.obj;
Bundle extras=msg.peekData();
if (Log.isLoggable(TAG,Log.DEBUG)) {
Log.d(TAG,""String_Node_Str"" + endpoint + ""String_Node_Str""+ extras);
}
cancelActiveSyncH(endpoint,extras);
nextPendingSyncTime=maybeStartNextSyncH();
break;
case SyncHandler.MESSAGE_SYNC_FINISHED:
if (Log.isLoggable(TAG,Log.VERBOSE)) {
Log.v(TAG,""String_Node_Str"");
}
SyncHandlerMessagePayload payload=(SyncHandlerMessagePayload)msg.obj;
if (!isSyncStillActiveH(payload.activeSyncContext)) {
Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + payload.activeSyncContext);
break;
}
runSyncFinishedOrCanceledH(payload.syncResult,payload.activeSyncContext);
nextPendingSyncTime=maybeStartNextSyncH();
break;
case SyncHandler.MESSAGE_SERVICE_CONNECTED:
{
ServiceConnectionData msgData=(ServiceConnectionData)msg.obj;
if (Log.isLoggable(TAG,Log.VERBOSE)) {
Log.d(TAG,""String_Node_Str"" + msgData.activeSyncContext);
}
if (isSyncStillActiveH(msgData.activeSyncContext)) {
runBoundToAdapter(msgData.activeSyncContext,msgData.adapter);
}
break;
}
case SyncHandler.MESSAGE_SERVICE_DISCONNECTED:
{
final ActiveSyncContext currentSyncContext=((ServiceConnectionData)msg.obj).activeSyncContext;
if (Log.isLoggable(TAG,Log.VERBOSE)) {
Log.d(TAG,""String_Node_Str"" + currentSyncContext);
}
if (isSyncStillActiveH(currentSyncContext)) {
try {
if (currentSyncContext.mSyncAdapter != null) {
currentSyncContext.mSyncAdapter.cancelSync(currentSyncContext);
}
 else if (currentSyncContext.mSyncServiceAdapter != null) {
currentSyncContext.mSyncServiceAdapter.cancelSync(currentSyncContext);
}
}
 catch (RemoteException e) {
}
SyncResult syncResult=new SyncResult();
syncResult.stats.numIoExceptions++;
runSyncFinishedOrCanceledH(syncResult,currentSyncContext);
nextPendingSyncTime=maybeStartNextSyncH();
}
break;
}
case SyncHandler.MESSAGE_SYNC_ALARM:
{
boolean isLoggable=Log.isLoggable(TAG,Log.VERBOSE);
if (isLoggable) {
Log.v(TAG,""String_Node_Str"");
}
mAlarmScheduleTime=null;
try {
nextPendingSyncTime=maybeStartNextSyncH();
}
  finally {
mHandleAlarmWakeLock.release();
}
break;
}
case SyncHandler.MESSAGE_CHECK_ALARMS:
if (Log.isLoggable(TAG,Log.VERBOSE)) {
Log.v(TAG,""String_Node_Str"");
}
nextPendingSyncTime=maybeStartNextSyncH();
break;
case SyncHandler.MESSAGE_SYNC_EXPIRED:
ActiveSyncContext expiredContext=(ActiveSyncContext)msg.obj;
if (Log.isLoggable(TAG,Log.DEBUG)) {
Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + expiredContext);
}
runSyncFinishedOrCanceledH(null,expiredContext);
nextPendingSyncTime=maybeStartNextSyncH();
break;
case SyncHandler.MESSAGE_MONITOR_SYNC:
ActiveSyncContext monitoredSyncContext=(ActiveSyncContext)msg.obj;
if (Log.isLoggable(TAG,Log.DEBUG)) {
Log.d(TAG,""String_Node_Str"" + monitoredSyncContext.mSyncOperation.target);
}
if (isSyncNotUsingNetworkH(monitoredSyncContext)) {
Log.w(TAG,String.format(""String_Node_Str"",monitoredSyncContext));
runSyncFinishedOrCanceledH(null,monitoredSyncContext);
}
 else {
postMonitorSyncProgressMessage(monitoredSyncContext);
}
break;
}
}
  finally {
manageSyncAlarmLocked(earliestFuturePollTime,nextPendingSyncTime);
mSyncTimeTracker.update();
mSyncManagerWakeLock.release();
}
}","public void handleMessage(Message msg){
  if (tryEnqueueMessageUntilReadyToRun(msg)) {
    return;
  }
  long earliestFuturePollTime=Long.MAX_VALUE;
  long nextPendingSyncTime=Long.MAX_VALUE;
  try {
    mDataConnectionIsConnected=readDataConnectionState();
    mSyncManagerWakeLock.acquire();
    earliestFuturePollTime=scheduleReadyPeriodicSyncs();
switch (msg.what) {
case SyncHandler.MESSAGE_ACCOUNTS_UPDATED:
      if (Log.isLoggable(TAG,Log.VERBOSE)) {
        Log.v(TAG,""String_Node_Str"");
      }
    updateRunningAccountsH();
  break;
case SyncHandler.MESSAGE_CANCEL:
SyncStorageEngine.EndPoint endpoint=(SyncStorageEngine.EndPoint)msg.obj;
Bundle extras=msg.peekData();
if (Log.isLoggable(TAG,Log.DEBUG)) {
Log.d(TAG,""String_Node_Str"" + endpoint + ""String_Node_Str""+ extras);
}
cancelActiveSyncH(endpoint,extras);
nextPendingSyncTime=maybeStartNextSyncH();
break;
case SyncHandler.MESSAGE_SYNC_FINISHED:
if (Log.isLoggable(TAG,Log.VERBOSE)) {
Log.v(TAG,""String_Node_Str"");
}
SyncHandlerMessagePayload payload=(SyncHandlerMessagePayload)msg.obj;
if (!isSyncStillActiveH(payload.activeSyncContext)) {
Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + payload.activeSyncContext);
break;
}
runSyncFinishedOrCanceledH(payload.syncResult,payload.activeSyncContext);
nextPendingSyncTime=maybeStartNextSyncH();
break;
case SyncHandler.MESSAGE_SERVICE_CONNECTED:
{
ServiceConnectionData msgData=(ServiceConnectionData)msg.obj;
if (Log.isLoggable(TAG,Log.VERBOSE)) {
Log.d(TAG,""String_Node_Str"" + msgData.activeSyncContext);
}
if (isSyncStillActiveH(msgData.activeSyncContext)) {
runBoundToAdapter(msgData.activeSyncContext,msgData.adapter);
}
break;
}
case SyncHandler.MESSAGE_SERVICE_DISCONNECTED:
{
final ActiveSyncContext currentSyncContext=((ServiceConnectionData)msg.obj).activeSyncContext;
if (Log.isLoggable(TAG,Log.VERBOSE)) {
Log.d(TAG,""String_Node_Str"" + currentSyncContext);
}
if (isSyncStillActiveH(currentSyncContext)) {
try {
if (currentSyncContext.mSyncAdapter != null) {
currentSyncContext.mSyncAdapter.cancelSync(currentSyncContext);
}
 else if (currentSyncContext.mSyncServiceAdapter != null) {
currentSyncContext.mSyncServiceAdapter.cancelSync(currentSyncContext);
}
}
 catch (RemoteException e) {
}
SyncResult syncResult=new SyncResult();
syncResult.stats.numIoExceptions++;
runSyncFinishedOrCanceledH(syncResult,currentSyncContext);
nextPendingSyncTime=maybeStartNextSyncH();
}
break;
}
case SyncHandler.MESSAGE_SYNC_ALARM:
{
boolean isLoggable=Log.isLoggable(TAG,Log.VERBOSE);
if (isLoggable) {
Log.v(TAG,""String_Node_Str"");
}
mAlarmScheduleTime=null;
try {
nextPendingSyncTime=maybeStartNextSyncH();
}
  finally {
mHandleAlarmWakeLock.release();
}
break;
}
case SyncHandler.MESSAGE_CHECK_ALARMS:
if (Log.isLoggable(TAG,Log.VERBOSE)) {
Log.v(TAG,""String_Node_Str"");
}
nextPendingSyncTime=maybeStartNextSyncH();
break;
case SyncHandler.MESSAGE_SYNC_EXPIRED:
ActiveSyncContext expiredContext=(ActiveSyncContext)msg.obj;
if (Log.isLoggable(TAG,Log.DEBUG)) {
Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + expiredContext);
}
runSyncFinishedOrCanceledH(null,expiredContext);
nextPendingSyncTime=maybeStartNextSyncH();
break;
case SyncHandler.MESSAGE_MONITOR_SYNC:
ActiveSyncContext monitoredSyncContext=(ActiveSyncContext)msg.obj;
if (Log.isLoggable(TAG,Log.DEBUG)) {
Log.d(TAG,""String_Node_Str"" + monitoredSyncContext.mSyncOperation.target);
}
if (isSyncNotUsingNetworkH(monitoredSyncContext)) {
Log.w(TAG,String.format(""String_Node_Str"",monitoredSyncContext));
runSyncFinishedOrCanceledH(null,monitoredSyncContext);
}
 else {
postMonitorSyncProgressMessage(monitoredSyncContext);
}
break;
}
}
  finally {
manageSyncAlarmLocked(earliestFuturePollTime,nextPendingSyncTime);
mSyncTimeTracker.update();
mSyncManagerWakeLock.release();
}
}",0.9893210283454186
192798,"private void updateRunningAccounts(boolean resyncAllTargets){
  if (Log.isLoggable(TAG,Log.VERBOSE))   Log.v(TAG,""String_Node_Str"");
  Message m=mSyncHandler.obtainMessage(SyncHandler.MESSAGE_ACCOUNTS_UPDATED);
  m.arg1=resyncAllTargets ? 1 : 0;
  m.sendToTarget();
}","public void updateRunningAccounts(){
  if (Log.isLoggable(TAG,Log.VERBOSE))   Log.v(TAG,""String_Node_Str"");
  mSyncHandler.sendEmptyMessage(SyncHandler.MESSAGE_ACCOUNTS_UPDATED);
}",0.7516778523489933
192799,"private void onUserRemoved(int userId){
  updateRunningAccounts(false);
  mSyncStorageEngine.doDatabaseCleanup(new Account[0],userId);
synchronized (mSyncQueue) {
    mSyncQueue.removeUserLocked(userId);
  }
}","private void onUserRemoved(int userId){
  updateRunningAccounts();
  mSyncStorageEngine.doDatabaseCleanup(new Account[0],userId);
synchronized (mSyncQueue) {
    mSyncQueue.removeUserLocked(userId);
  }
}",0.9878934624697336
192800,"private void onUserStopping(int userId){
  updateRunningAccounts(false);
  cancelActiveSync(new SyncStorageEngine.EndPoint(null,null,userId),null);
}","private void onUserStopping(int userId){
  updateRunningAccounts();
  cancelActiveSync(new SyncStorageEngine.EndPoint(null,null,userId),null);
}",0.9829351535836176
192801,"private void onUserUnlocked(int userId){
  AccountManagerService.getSingleton().validateAccounts(userId);
  mSyncAdapters.invalidateCache(userId);
  updateRunningAccounts(false);
synchronized (mSyncQueue) {
    mSyncQueue.addPendingOperations(userId);
  }
  final Account[] accounts=AccountManagerService.getSingleton().getAccounts(userId,mContext.getOpPackageName());
  for (  Account account : accounts) {
    scheduleSync(account,userId,SyncOperation.REASON_USER_START,null,null,0,0,true);
  }
  sendCheckAlarmsMessage();
}","private void onUserUnlocked(int userId){
  AccountManagerService.getSingleton().validateAccounts(userId);
  mSyncAdapters.invalidateCache(userId);
  updateRunningAccounts();
synchronized (mSyncQueue) {
    mSyncQueue.addPendingOperations(userId);
  }
  final Account[] accounts=AccountManagerService.getSingleton().getAccounts(userId,mContext.getOpPackageName());
  for (  Account account : accounts) {
    scheduleSync(account,userId,SyncOperation.REASON_USER_START,null,null,0,0,true);
  }
  sendCheckAlarmsMessage();
}",0.9952244508118434
192802,"private void updateRunningAccountsH(boolean resyncAll){
  mRunningAccounts=AccountManagerService.getSingleton().getRunningAccounts();
  if (mBootCompleted) {
    doDatabaseCleanup();
  }
  AccountAndUser[] accounts=mRunningAccounts;
  for (  ActiveSyncContext currentSyncContext : mActiveSyncContexts) {
    if (!containsAccountAndUser(accounts,currentSyncContext.mSyncOperation.target.account,currentSyncContext.mSyncOperation.target.userId)) {
      Log.d(TAG,""String_Node_Str"");
      sendSyncFinishedOrCanceledMessage(currentSyncContext,null);
    }
  }
  if (resyncAll) {
    scheduleSync(null,UserHandle.USER_ALL,SyncOperation.REASON_ACCOUNTS_UPDATED,null,null,0,0,false);
  }
 else {
    sendCheckAlarmsMessage();
  }
}","private void updateRunningAccountsH(){
  mRunningAccounts=AccountManagerService.getSingleton().getRunningAccounts();
  if (mBootCompleted) {
    doDatabaseCleanup();
  }
  AccountAndUser[] accounts=mRunningAccounts;
  for (  ActiveSyncContext currentSyncContext : mActiveSyncContexts) {
    if (!containsAccountAndUser(accounts,currentSyncContext.mSyncOperation.target.account,currentSyncContext.mSyncOperation.target.userId)) {
      Log.d(TAG,""String_Node_Str"");
      sendSyncFinishedOrCanceledMessage(currentSyncContext,null);
    }
  }
  sendCheckAlarmsMessage();
}",0.8472222222222222
192803,"public void handleMessage(Message msg){
  if (tryEnqueueMessageUntilReadyToRun(msg)) {
    return;
  }
  long earliestFuturePollTime=Long.MAX_VALUE;
  long nextPendingSyncTime=Long.MAX_VALUE;
  try {
    mDataConnectionIsConnected=readDataConnectionState();
    mSyncManagerWakeLock.acquire();
    earliestFuturePollTime=scheduleReadyPeriodicSyncs();
switch (msg.what) {
case SyncHandler.MESSAGE_ACCOUNTS_UPDATED:
      if (Log.isLoggable(TAG,Log.VERBOSE)) {
        Log.v(TAG,""String_Node_Str"");
      }
    boolean resyncAllTargets=msg.arg1 == 0 ? false : true;
  updateRunningAccountsH(resyncAllTargets);
break;
case SyncHandler.MESSAGE_CANCEL:
SyncStorageEngine.EndPoint endpoint=(SyncStorageEngine.EndPoint)msg.obj;
Bundle extras=msg.peekData();
if (Log.isLoggable(TAG,Log.DEBUG)) {
Log.d(TAG,""String_Node_Str"" + endpoint + ""String_Node_Str""+ extras);
}
cancelActiveSyncH(endpoint,extras);
nextPendingSyncTime=maybeStartNextSyncH();
break;
case SyncHandler.MESSAGE_SYNC_FINISHED:
if (Log.isLoggable(TAG,Log.VERBOSE)) {
Log.v(TAG,""String_Node_Str"");
}
SyncHandlerMessagePayload payload=(SyncHandlerMessagePayload)msg.obj;
if (!isSyncStillActiveH(payload.activeSyncContext)) {
Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + payload.activeSyncContext);
break;
}
runSyncFinishedOrCanceledH(payload.syncResult,payload.activeSyncContext);
nextPendingSyncTime=maybeStartNextSyncH();
break;
case SyncHandler.MESSAGE_SERVICE_CONNECTED:
{
ServiceConnectionData msgData=(ServiceConnectionData)msg.obj;
if (Log.isLoggable(TAG,Log.VERBOSE)) {
Log.d(TAG,""String_Node_Str"" + msgData.activeSyncContext);
}
if (isSyncStillActiveH(msgData.activeSyncContext)) {
runBoundToAdapter(msgData.activeSyncContext,msgData.adapter);
}
break;
}
case SyncHandler.MESSAGE_SERVICE_DISCONNECTED:
{
final ActiveSyncContext currentSyncContext=((ServiceConnectionData)msg.obj).activeSyncContext;
if (Log.isLoggable(TAG,Log.VERBOSE)) {
Log.d(TAG,""String_Node_Str"" + currentSyncContext);
}
if (isSyncStillActiveH(currentSyncContext)) {
try {
if (currentSyncContext.mSyncAdapter != null) {
currentSyncContext.mSyncAdapter.cancelSync(currentSyncContext);
}
 else if (currentSyncContext.mSyncServiceAdapter != null) {
currentSyncContext.mSyncServiceAdapter.cancelSync(currentSyncContext);
}
}
 catch (RemoteException e) {
}
SyncResult syncResult=new SyncResult();
syncResult.stats.numIoExceptions++;
runSyncFinishedOrCanceledH(syncResult,currentSyncContext);
nextPendingSyncTime=maybeStartNextSyncH();
}
break;
}
case SyncHandler.MESSAGE_SYNC_ALARM:
{
boolean isLoggable=Log.isLoggable(TAG,Log.VERBOSE);
if (isLoggable) {
Log.v(TAG,""String_Node_Str"");
}
mAlarmScheduleTime=null;
try {
nextPendingSyncTime=maybeStartNextSyncH();
}
  finally {
mHandleAlarmWakeLock.release();
}
break;
}
case SyncHandler.MESSAGE_CHECK_ALARMS:
if (Log.isLoggable(TAG,Log.VERBOSE)) {
Log.v(TAG,""String_Node_Str"");
}
nextPendingSyncTime=maybeStartNextSyncH();
break;
case SyncHandler.MESSAGE_SYNC_EXPIRED:
ActiveSyncContext expiredContext=(ActiveSyncContext)msg.obj;
if (Log.isLoggable(TAG,Log.DEBUG)) {
Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + expiredContext);
}
runSyncFinishedOrCanceledH(null,expiredContext);
nextPendingSyncTime=maybeStartNextSyncH();
break;
case SyncHandler.MESSAGE_MONITOR_SYNC:
ActiveSyncContext monitoredSyncContext=(ActiveSyncContext)msg.obj;
if (Log.isLoggable(TAG,Log.DEBUG)) {
Log.d(TAG,""String_Node_Str"" + monitoredSyncContext.mSyncOperation.target);
}
if (isSyncNotUsingNetworkH(monitoredSyncContext)) {
Log.w(TAG,String.format(""String_Node_Str"",monitoredSyncContext));
runSyncFinishedOrCanceledH(null,monitoredSyncContext);
}
 else {
postMonitorSyncProgressMessage(monitoredSyncContext);
}
break;
}
}
  finally {
manageSyncAlarmLocked(earliestFuturePollTime,nextPendingSyncTime);
mSyncTimeTracker.update();
mSyncManagerWakeLock.release();
}
}","public void handleMessage(Message msg){
  if (tryEnqueueMessageUntilReadyToRun(msg)) {
    return;
  }
  long earliestFuturePollTime=Long.MAX_VALUE;
  long nextPendingSyncTime=Long.MAX_VALUE;
  try {
    mDataConnectionIsConnected=readDataConnectionState();
    mSyncManagerWakeLock.acquire();
    earliestFuturePollTime=scheduleReadyPeriodicSyncs();
switch (msg.what) {
case SyncHandler.MESSAGE_ACCOUNTS_UPDATED:
      if (Log.isLoggable(TAG,Log.VERBOSE)) {
        Log.v(TAG,""String_Node_Str"");
      }
    updateRunningAccountsH();
  break;
case SyncHandler.MESSAGE_CANCEL:
SyncStorageEngine.EndPoint endpoint=(SyncStorageEngine.EndPoint)msg.obj;
Bundle extras=msg.peekData();
if (Log.isLoggable(TAG,Log.DEBUG)) {
Log.d(TAG,""String_Node_Str"" + endpoint + ""String_Node_Str""+ extras);
}
cancelActiveSyncH(endpoint,extras);
nextPendingSyncTime=maybeStartNextSyncH();
break;
case SyncHandler.MESSAGE_SYNC_FINISHED:
if (Log.isLoggable(TAG,Log.VERBOSE)) {
Log.v(TAG,""String_Node_Str"");
}
SyncHandlerMessagePayload payload=(SyncHandlerMessagePayload)msg.obj;
if (!isSyncStillActiveH(payload.activeSyncContext)) {
Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + payload.activeSyncContext);
break;
}
runSyncFinishedOrCanceledH(payload.syncResult,payload.activeSyncContext);
nextPendingSyncTime=maybeStartNextSyncH();
break;
case SyncHandler.MESSAGE_SERVICE_CONNECTED:
{
ServiceConnectionData msgData=(ServiceConnectionData)msg.obj;
if (Log.isLoggable(TAG,Log.VERBOSE)) {
Log.d(TAG,""String_Node_Str"" + msgData.activeSyncContext);
}
if (isSyncStillActiveH(msgData.activeSyncContext)) {
runBoundToAdapter(msgData.activeSyncContext,msgData.adapter);
}
break;
}
case SyncHandler.MESSAGE_SERVICE_DISCONNECTED:
{
final ActiveSyncContext currentSyncContext=((ServiceConnectionData)msg.obj).activeSyncContext;
if (Log.isLoggable(TAG,Log.VERBOSE)) {
Log.d(TAG,""String_Node_Str"" + currentSyncContext);
}
if (isSyncStillActiveH(currentSyncContext)) {
try {
if (currentSyncContext.mSyncAdapter != null) {
currentSyncContext.mSyncAdapter.cancelSync(currentSyncContext);
}
 else if (currentSyncContext.mSyncServiceAdapter != null) {
currentSyncContext.mSyncServiceAdapter.cancelSync(currentSyncContext);
}
}
 catch (RemoteException e) {
}
SyncResult syncResult=new SyncResult();
syncResult.stats.numIoExceptions++;
runSyncFinishedOrCanceledH(syncResult,currentSyncContext);
nextPendingSyncTime=maybeStartNextSyncH();
}
break;
}
case SyncHandler.MESSAGE_SYNC_ALARM:
{
boolean isLoggable=Log.isLoggable(TAG,Log.VERBOSE);
if (isLoggable) {
Log.v(TAG,""String_Node_Str"");
}
mAlarmScheduleTime=null;
try {
nextPendingSyncTime=maybeStartNextSyncH();
}
  finally {
mHandleAlarmWakeLock.release();
}
break;
}
case SyncHandler.MESSAGE_CHECK_ALARMS:
if (Log.isLoggable(TAG,Log.VERBOSE)) {
Log.v(TAG,""String_Node_Str"");
}
nextPendingSyncTime=maybeStartNextSyncH();
break;
case SyncHandler.MESSAGE_SYNC_EXPIRED:
ActiveSyncContext expiredContext=(ActiveSyncContext)msg.obj;
if (Log.isLoggable(TAG,Log.DEBUG)) {
Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + expiredContext);
}
runSyncFinishedOrCanceledH(null,expiredContext);
nextPendingSyncTime=maybeStartNextSyncH();
break;
case SyncHandler.MESSAGE_MONITOR_SYNC:
ActiveSyncContext monitoredSyncContext=(ActiveSyncContext)msg.obj;
if (Log.isLoggable(TAG,Log.DEBUG)) {
Log.d(TAG,""String_Node_Str"" + monitoredSyncContext.mSyncOperation.target);
}
if (isSyncNotUsingNetworkH(monitoredSyncContext)) {
Log.w(TAG,String.format(""String_Node_Str"",monitoredSyncContext));
runSyncFinishedOrCanceledH(null,monitoredSyncContext);
}
 else {
postMonitorSyncProgressMessage(monitoredSyncContext);
}
break;
}
}
  finally {
manageSyncAlarmLocked(earliestFuturePollTime,nextPendingSyncTime);
mSyncTimeTracker.update();
mSyncManagerWakeLock.release();
}
}",0.9893210283454186
192804,"protected boolean inflateViews(Entry entry,ViewGroup parent){
  PackageManager pmUser=getPackageManagerForUser(mContext,entry.notification.getUser().getIdentifier());
  final StatusBarNotification sbn=entry.notification;
  entry.cacheContentViews(mContext,null);
  final RemoteViews contentView=entry.cachedContentView;
  final RemoteViews bigContentView=entry.cachedBigContentView;
  final RemoteViews headsUpContentView=entry.cachedHeadsUpContentView;
  final RemoteViews publicContentView=entry.cachedPublicContentView;
  if (contentView == null) {
    Log.v(TAG,""String_Node_Str"" + sbn.getNotification());
    return false;
  }
  if (DEBUG) {
    Log.v(TAG,""String_Node_Str"" + publicContentView);
  }
  ExpandableNotificationRow row;
  boolean hasUserChangedExpansion=false;
  boolean userExpanded=false;
  boolean userLocked=false;
  if (entry.row != null) {
    row=entry.row;
    hasUserChangedExpansion=row.hasUserChangedExpansion();
    userExpanded=row.isUserExpanded();
    userLocked=row.isUserLocked();
    entry.reset();
    if (hasUserChangedExpansion) {
      row.setUserExpanded(userExpanded);
    }
  }
 else {
    LayoutInflater inflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    row=(ExpandableNotificationRow)inflater.inflate(R.layout.status_bar_notification_row,parent,false);
    row.setExpansionLogger(this,entry.notification.getKey());
    row.setGroupManager(mGroupManager);
    row.setHeadsUpManager(mHeadsUpManager);
    row.setRemoteInputController(mRemoteInputController);
    row.setOnExpandClickListener(this);
  }
  workAroundBadLayerDrawableOpacity(row);
  View vetoButton=updateNotificationVetoButton(row,sbn);
  vetoButton.setContentDescription(mContext.getString(R.string.accessibility_remove_notification));
  NotificationContentView contentContainer=row.getPrivateLayout();
  NotificationContentView contentContainerPublic=row.getPublicLayout();
  row.setDescendantFocusability(ViewGroup.FOCUS_BLOCK_DESCENDANTS);
  if (ENABLE_REMOTE_INPUT) {
    row.setDescendantFocusability(ViewGroup.FOCUS_BEFORE_DESCENDANTS);
  }
  mNotificationClicker.register(row,sbn);
  View contentViewLocal=null;
  View bigContentViewLocal=null;
  View headsUpContentViewLocal=null;
  View publicViewLocal=null;
  try {
    contentViewLocal=contentView.apply(sbn.getPackageContext(mContext),contentContainer,mOnClickHandler);
    if (bigContentView != null) {
      bigContentViewLocal=bigContentView.apply(sbn.getPackageContext(mContext),contentContainer,mOnClickHandler);
    }
    if (headsUpContentView != null) {
      headsUpContentViewLocal=headsUpContentView.apply(sbn.getPackageContext(mContext),contentContainer,mOnClickHandler);
    }
    if (publicContentView != null) {
      publicViewLocal=publicContentView.apply(sbn.getPackageContext(mContext),contentContainerPublic,mOnClickHandler);
    }
  }
 catch (  RuntimeException e) {
    final String ident=sbn.getPackageName() + ""String_Node_Str"" + Integer.toHexString(sbn.getId());
    Log.e(TAG,""String_Node_Str"" + ident,e);
    return false;
  }
  if (contentViewLocal != null) {
    contentViewLocal.setIsRootNamespace(true);
    contentContainer.setContractedChild(contentViewLocal);
  }
  if (bigContentViewLocal != null) {
    bigContentViewLocal.setIsRootNamespace(true);
    contentContainer.setExpandedChild(bigContentViewLocal);
  }
  if (headsUpContentViewLocal != null) {
    headsUpContentViewLocal.setIsRootNamespace(true);
    contentContainer.setHeadsUpChild(headsUpContentViewLocal);
  }
  if (publicViewLocal != null) {
    publicViewLocal.setIsRootNamespace(true);
    contentContainerPublic.setContractedChild(publicViewLocal);
  }
  try {
    ApplicationInfo info=pmUser.getApplicationInfo(sbn.getPackageName(),0);
    entry.targetSdk=info.targetSdkVersion;
  }
 catch (  NameNotFoundException ex) {
    Log.e(TAG,""String_Node_Str"" + sbn.getPackageName(),ex);
  }
  entry.autoRedacted=entry.notification.getNotification().publicVersion == null;
  if (MULTIUSER_DEBUG) {
    TextView debug=(TextView)row.findViewById(R.id.debug_info);
    if (debug != null) {
      debug.setVisibility(View.VISIBLE);
      debug.setText(""String_Node_Str"" + mCurrentUserId + ""String_Node_Str""+ entry.notification.getUserId());
    }
  }
  entry.row=row;
  entry.row.setOnActivatedListener(this);
  entry.row.setExpandable(bigContentViewLocal != null);
  applyColorsAndBackgrounds(sbn,entry);
  if (hasUserChangedExpansion) {
    row.setUserExpanded(userExpanded);
  }
  row.setUserLocked(userLocked);
  row.onNotificationUpdated(entry);
  return true;
}","protected boolean inflateViews(Entry entry,ViewGroup parent){
  PackageManager pmUser=getPackageManagerForUser(mContext,entry.notification.getUser().getIdentifier());
  final StatusBarNotification sbn=entry.notification;
  entry.cacheContentViews(mContext,null);
  final RemoteViews contentView=entry.cachedContentView;
  final RemoteViews bigContentView=entry.cachedBigContentView;
  final RemoteViews headsUpContentView=entry.cachedHeadsUpContentView;
  final RemoteViews publicContentView=entry.cachedPublicContentView;
  if (contentView == null) {
    Log.v(TAG,""String_Node_Str"" + sbn.getNotification());
    return false;
  }
  if (DEBUG) {
    Log.v(TAG,""String_Node_Str"" + publicContentView);
  }
  ExpandableNotificationRow row;
  boolean hasUserChangedExpansion=false;
  boolean userExpanded=false;
  boolean userLocked=false;
  if (entry.row != null) {
    row=entry.row;
    hasUserChangedExpansion=row.hasUserChangedExpansion();
    userExpanded=row.isUserExpanded();
    userLocked=row.isUserLocked();
    entry.reset();
    if (hasUserChangedExpansion) {
      row.setUserExpanded(userExpanded);
    }
  }
 else {
    LayoutInflater inflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    row=(ExpandableNotificationRow)inflater.inflate(R.layout.status_bar_notification_row,parent,false);
    row.setExpansionLogger(this,entry.notification.getKey());
    row.setGroupManager(mGroupManager);
    row.setHeadsUpManager(mHeadsUpManager);
    row.setRemoteInputController(mRemoteInputController);
    row.setOnExpandClickListener(this);
  }
  workAroundBadLayerDrawableOpacity(row);
  View vetoButton=bindVetoButtonClickListener(row,sbn);
  vetoButton.setContentDescription(mContext.getString(R.string.accessibility_remove_notification));
  NotificationContentView contentContainer=row.getPrivateLayout();
  NotificationContentView contentContainerPublic=row.getPublicLayout();
  row.setDescendantFocusability(ViewGroup.FOCUS_BLOCK_DESCENDANTS);
  if (ENABLE_REMOTE_INPUT) {
    row.setDescendantFocusability(ViewGroup.FOCUS_BEFORE_DESCENDANTS);
  }
  mNotificationClicker.register(row,sbn);
  View contentViewLocal=null;
  View bigContentViewLocal=null;
  View headsUpContentViewLocal=null;
  View publicViewLocal=null;
  try {
    contentViewLocal=contentView.apply(sbn.getPackageContext(mContext),contentContainer,mOnClickHandler);
    if (bigContentView != null) {
      bigContentViewLocal=bigContentView.apply(sbn.getPackageContext(mContext),contentContainer,mOnClickHandler);
    }
    if (headsUpContentView != null) {
      headsUpContentViewLocal=headsUpContentView.apply(sbn.getPackageContext(mContext),contentContainer,mOnClickHandler);
    }
    if (publicContentView != null) {
      publicViewLocal=publicContentView.apply(sbn.getPackageContext(mContext),contentContainerPublic,mOnClickHandler);
    }
  }
 catch (  RuntimeException e) {
    final String ident=sbn.getPackageName() + ""String_Node_Str"" + Integer.toHexString(sbn.getId());
    Log.e(TAG,""String_Node_Str"" + ident,e);
    return false;
  }
  if (contentViewLocal != null) {
    contentViewLocal.setIsRootNamespace(true);
    contentContainer.setContractedChild(contentViewLocal);
  }
  if (bigContentViewLocal != null) {
    bigContentViewLocal.setIsRootNamespace(true);
    contentContainer.setExpandedChild(bigContentViewLocal);
  }
  if (headsUpContentViewLocal != null) {
    headsUpContentViewLocal.setIsRootNamespace(true);
    contentContainer.setHeadsUpChild(headsUpContentViewLocal);
  }
  if (publicViewLocal != null) {
    publicViewLocal.setIsRootNamespace(true);
    contentContainerPublic.setContractedChild(publicViewLocal);
  }
  try {
    ApplicationInfo info=pmUser.getApplicationInfo(sbn.getPackageName(),0);
    entry.targetSdk=info.targetSdkVersion;
  }
 catch (  NameNotFoundException ex) {
    Log.e(TAG,""String_Node_Str"" + sbn.getPackageName(),ex);
  }
  entry.autoRedacted=entry.notification.getNotification().publicVersion == null;
  if (MULTIUSER_DEBUG) {
    TextView debug=(TextView)row.findViewById(R.id.debug_info);
    if (debug != null) {
      debug.setVisibility(View.VISIBLE);
      debug.setText(""String_Node_Str"" + mCurrentUserId + ""String_Node_Str""+ entry.notification.getUserId());
    }
  }
  entry.row=row;
  entry.row.setOnActivatedListener(this);
  entry.row.setExpandable(bigContentViewLocal != null);
  applyColorsAndBackgrounds(sbn,entry);
  if (hasUserChangedExpansion) {
    row.setUserExpanded(userExpanded);
  }
  row.setUserLocked(userLocked);
  row.onNotificationUpdated(entry);
  return true;
}",0.9961719348135184
192805,"public void updateNotification(StatusBarNotification notification,RankingMap ranking){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + notification + ""String_Node_Str"");
  final String key=notification.getKey();
  Entry entry=mNotificationData.get(key);
  if (entry == null) {
    return;
  }
 else   if (mHeadsUpEntriesToRemoveOnSwitch.contains(entry)) {
    mHeadsUpEntriesToRemoveOnSwitch.remove(entry);
  }
  Notification n=notification.getNotification();
  mNotificationData.updateRanking(ranking);
  boolean applyInPlace=entry.cacheContentViews(mContext,notification.getNotification());
  boolean shouldPeek=shouldPeek(entry,notification);
  boolean alertAgain=alertAgain(entry,n);
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + applyInPlace + ""String_Node_Str""+ shouldPeek+ ""String_Node_Str""+ alertAgain);
  }
  final StatusBarNotification oldNotification=entry.notification;
  entry.notification=notification;
  mGroupManager.onEntryUpdated(entry,oldNotification);
  boolean updateSuccessful=false;
  if (applyInPlace) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + key);
    try {
      if (entry.icon != null) {
        final StatusBarIcon ic=new StatusBarIcon(notification.getUser(),notification.getPackageName(),n.getSmallIcon(),n.iconLevel,n.number,n.tickerText);
        entry.icon.setNotification(n);
        if (!entry.icon.set(ic)) {
          handleNotificationError(notification,""String_Node_Str"" + ic);
          return;
        }
      }
      updateNotificationViews(entry,notification);
      updateSuccessful=true;
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + notification.getPackageName(),e);
    }
  }
  if (!updateSuccessful) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + key);
    final StatusBarIcon ic=new StatusBarIcon(notification.getUser(),notification.getPackageName(),n.getSmallIcon(),n.iconLevel,n.number,n.tickerText);
    entry.icon.setNotification(n);
    entry.icon.set(ic);
    inflateViews(entry,mStackScroller);
  }
  updateHeadsUp(key,entry,shouldPeek,alertAgain);
  updateNotifications();
  updateNotificationVetoButton(entry.row,notification);
  if (DEBUG) {
    boolean isForCurrentUser=isNotificationForCurrentProfiles(notification);
    Log.d(TAG,""String_Node_Str"" + (isForCurrentUser ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
  }
  setAreThereNotifications();
}","public void updateNotification(StatusBarNotification notification,RankingMap ranking){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + notification + ""String_Node_Str"");
  final String key=notification.getKey();
  Entry entry=mNotificationData.get(key);
  if (entry == null) {
    return;
  }
 else   if (mHeadsUpEntriesToRemoveOnSwitch.contains(entry)) {
    mHeadsUpEntriesToRemoveOnSwitch.remove(entry);
  }
  Notification n=notification.getNotification();
  mNotificationData.updateRanking(ranking);
  boolean applyInPlace=entry.cacheContentViews(mContext,notification.getNotification());
  boolean shouldPeek=shouldPeek(entry,notification);
  boolean alertAgain=alertAgain(entry,n);
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + applyInPlace + ""String_Node_Str""+ shouldPeek+ ""String_Node_Str""+ alertAgain);
  }
  final StatusBarNotification oldNotification=entry.notification;
  entry.notification=notification;
  mGroupManager.onEntryUpdated(entry,oldNotification);
  boolean updateSuccessful=false;
  if (applyInPlace) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + key);
    try {
      if (entry.icon != null) {
        final StatusBarIcon ic=new StatusBarIcon(notification.getUser(),notification.getPackageName(),n.getSmallIcon(),n.iconLevel,n.number,n.tickerText);
        entry.icon.setNotification(n);
        if (!entry.icon.set(ic)) {
          handleNotificationError(notification,""String_Node_Str"" + ic);
          return;
        }
      }
      updateNotificationViews(entry,notification);
      updateSuccessful=true;
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + notification.getPackageName(),e);
    }
  }
  if (!updateSuccessful) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + key);
    final StatusBarIcon ic=new StatusBarIcon(notification.getUser(),notification.getPackageName(),n.getSmallIcon(),n.iconLevel,n.number,n.tickerText);
    entry.icon.setNotification(n);
    entry.icon.set(ic);
    inflateViews(entry,mStackScroller);
  }
  updateHeadsUp(key,entry,shouldPeek,alertAgain);
  updateNotifications();
  bindVetoButtonClickListener(entry.row,notification);
  if (DEBUG) {
    boolean isForCurrentUser=isNotificationForCurrentProfiles(notification);
    Log.d(TAG,""String_Node_Str"" + (isForCurrentUser ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
  }
  setAreThereNotifications();
}",0.99261759122548
192806,"public void onNotificationUpdated(NotificationData.Entry entry){
  mEntry=entry;
  mStatusBarNotification=entry.notification;
  mPrivateLayout.onNotificationUpdated(entry);
  mPublicLayout.onNotificationUpdated(entry);
  updateVetoButton();
  if (mIsSummaryWithChildren) {
    recreateNotificationHeader();
  }
  if (mIconAnimationRunning) {
    setIconAnimationRunning(true);
  }
  if (mNotificationParent != null) {
    mNotificationParent.updateChildrenHeaderAppearance();
  }
  onChildrenCountChanged();
  mPublicLayout.updateExpandButtons(true);
  updateLimits();
}","public void onNotificationUpdated(NotificationData.Entry entry){
  mEntry=entry;
  mStatusBarNotification=entry.notification;
  mPrivateLayout.onNotificationUpdated(entry);
  mPublicLayout.onNotificationUpdated(entry);
  mShowingPublicInitialized=false;
  updateClearability();
  if (mIsSummaryWithChildren) {
    recreateNotificationHeader();
  }
  if (mIconAnimationRunning) {
    setIconAnimationRunning(true);
  }
  if (mNotificationParent != null) {
    mNotificationParent.updateChildrenHeaderAppearance();
  }
  onChildrenCountChanged();
  mPublicLayout.updateExpandButtons(true);
  updateLimits();
}",0.9413763806287172
192807,"public void setHideSensitive(boolean hideSensitive,boolean animated,long delay,long duration){
  boolean oldShowingPublic=mShowingPublic;
  mShowingPublic=mSensitive && hideSensitive;
  if (mShowingPublicInitialized && mShowingPublic == oldShowingPublic) {
    return;
  }
  if (mPublicLayout.getChildCount() == 0)   return;
  if (!animated) {
    mPublicLayout.animate().cancel();
    mPrivateLayout.animate().cancel();
    mPublicLayout.setAlpha(1f);
    mPrivateLayout.setAlpha(1f);
    mPublicLayout.setVisibility(mShowingPublic ? View.VISIBLE : View.INVISIBLE);
    updateChildrenVisibility();
  }
 else {
    animateShowingPublic(delay,duration);
  }
  mPrivateLayout.updateExpandButtons(isExpandable());
  updateVetoButton();
  mShowingPublicInitialized=true;
}","public void setHideSensitive(boolean hideSensitive,boolean animated,long delay,long duration){
  boolean oldShowingPublic=mShowingPublic;
  mShowingPublic=mSensitive && hideSensitive;
  if (mShowingPublicInitialized && mShowingPublic == oldShowingPublic) {
    return;
  }
  if (mPublicLayout.getChildCount() == 0)   return;
  if (!animated) {
    mPublicLayout.animate().cancel();
    mPrivateLayout.animate().cancel();
    mPublicLayout.setAlpha(1f);
    mPrivateLayout.setAlpha(1f);
    mPublicLayout.setVisibility(mShowingPublic ? View.VISIBLE : View.INVISIBLE);
    updateChildrenVisibility();
  }
 else {
    animateShowingPublic(delay,duration);
  }
  mPrivateLayout.updateExpandButtons(isExpandable());
  updateClearability();
  mShowingPublicInitialized=true;
}",0.9856957087126138
192808,"/** 
 * Distribute Cell radio energy info and network traffic to apps.
 */
public void updateMobileRadioStateLocked(final long elapsedRealtimeMs,final ModemActivityInfo activityInfo){
  if (DEBUG_ENERGY) {
    Slog.d(TAG,""String_Node_Str"" + activityInfo);
  }
  NetworkStats delta=null;
  try {
    if (!ArrayUtils.isEmpty(mMobileIfaces)) {
      delta=getNetworkStatsDeltaLocked(mMobileIfaces,mMobileNetworkStats);
    }
  }
 catch (  IOException e) {
    Slog.wtf(TAG,""String_Node_Str"",e);
    return;
  }
  if (!mOnBatteryInternal) {
    return;
  }
  long radioTime=mMobileRadioActivePerAppTimer.getTimeSinceMarkLocked(elapsedRealtimeMs * 1000);
  mMobileRadioActivePerAppTimer.setMark(elapsedRealtimeMs);
  long totalRxPackets=0;
  long totalTxPackets=0;
  if (delta != null) {
    final int size=delta.size();
    for (int i=0; i < size; i++) {
      final NetworkStats.Entry entry=delta.getValues(i,mTmpNetworkStatsEntry);
      if (entry.rxPackets == 0 || entry.txPackets == 0) {
        continue;
      }
      if (DEBUG_ENERGY) {
        Slog.d(TAG,""String_Node_Str"" + entry.uid + ""String_Node_Str""+ entry.rxBytes+ ""String_Node_Str""+ entry.txBytes+ ""String_Node_Str""+ entry.rxPackets+ ""String_Node_Str""+ entry.txPackets);
      }
      totalRxPackets+=entry.rxPackets;
      totalTxPackets+=entry.txPackets;
      final Uid u=getUidStatsLocked(mapUid(entry.uid));
      u.noteNetworkActivityLocked(NETWORK_MOBILE_RX_DATA,entry.rxBytes,entry.rxPackets);
      u.noteNetworkActivityLocked(NETWORK_MOBILE_TX_DATA,entry.txBytes,entry.txPackets);
      mNetworkByteActivityCounters[NETWORK_MOBILE_RX_DATA].addCountLocked(entry.rxBytes);
      mNetworkByteActivityCounters[NETWORK_MOBILE_TX_DATA].addCountLocked(entry.txBytes);
      mNetworkPacketActivityCounters[NETWORK_MOBILE_RX_DATA].addCountLocked(entry.rxPackets);
      mNetworkPacketActivityCounters[NETWORK_MOBILE_TX_DATA].addCountLocked(entry.txPackets);
    }
    long totalPackets=totalRxPackets + totalTxPackets;
    if (totalPackets > 0) {
      for (int i=0; i < size; i++) {
        final NetworkStats.Entry entry=delta.getValues(i,mTmpNetworkStatsEntry);
        if (entry.rxPackets == 0 && entry.txPackets == 0) {
          continue;
        }
        final Uid u=getUidStatsLocked(mapUid(entry.uid));
        final long appPackets=entry.rxPackets + entry.txPackets;
        final long appRadioTime=(radioTime * appPackets) / totalPackets;
        u.noteMobileRadioActiveTimeLocked(appRadioTime);
        radioTime-=appRadioTime;
        totalPackets-=appPackets;
        if (activityInfo != null) {
          ControllerActivityCounterImpl activityCounter=u.getOrCreateModemControllerActivityLocked();
          if (entry.rxPackets != 0) {
            final long rxMs=(entry.rxPackets * activityInfo.getRxTimeMillis()) / totalRxPackets;
            activityCounter.getRxTimeCounter().addCountLocked(rxMs);
          }
          if (entry.txPackets != 0) {
            for (int lvl=0; lvl < ModemActivityInfo.TX_POWER_LEVELS; lvl++) {
              long txMs=entry.txPackets * activityInfo.getTxTimeMillis()[lvl];
              txMs/=totalTxPackets;
              activityCounter.getTxTimeCounters()[lvl].addCountLocked(txMs);
            }
          }
        }
      }
    }
    if (radioTime > 0) {
      mMobileRadioActiveUnknownTime.addCountLocked(radioTime);
      mMobileRadioActiveUnknownCount.addCountLocked(1);
    }
  }
  if (activityInfo != null) {
    mHasModemReporting=true;
    mModemActivity.getIdleTimeCounter().addCountLocked(activityInfo.getIdleTimeMillis());
    mModemActivity.getRxTimeCounter().addCountLocked(activityInfo.getRxTimeMillis());
    for (int lvl=0; lvl < ModemActivityInfo.TX_POWER_LEVELS; lvl++) {
      mModemActivity.getTxTimeCounters()[lvl].addCountLocked(activityInfo.getTxTimeMillis()[lvl]);
    }
    final double opVolt=mPowerProfile.getAveragePower(PowerProfile.POWER_MODEM_CONTROLLER_OPERATING_VOLTAGE) / 1000.0;
    if (opVolt != 0) {
      mModemActivity.getPowerCounter().addCountLocked((long)(activityInfo.getEnergyUsed() / opVolt));
    }
  }
}","/** 
 * Distribute Cell radio energy info and network traffic to apps.
 */
public void updateMobileRadioStateLocked(final long elapsedRealtimeMs,final ModemActivityInfo activityInfo){
  if (DEBUG_ENERGY) {
    Slog.d(TAG,""String_Node_Str"" + activityInfo);
  }
  NetworkStats delta=null;
  try {
    if (!ArrayUtils.isEmpty(mMobileIfaces)) {
      delta=getNetworkStatsDeltaLocked(mMobileIfaces,mMobileNetworkStats);
    }
  }
 catch (  IOException e) {
    Slog.wtf(TAG,""String_Node_Str"",e);
    return;
  }
  if (!mOnBatteryInternal) {
    return;
  }
  long radioTime=mMobileRadioActivePerAppTimer.getTimeSinceMarkLocked(elapsedRealtimeMs * 1000);
  mMobileRadioActivePerAppTimer.setMark(elapsedRealtimeMs);
  long totalRxPackets=0;
  long totalTxPackets=0;
  if (delta != null) {
    final int size=delta.size();
    for (int i=0; i < size; i++) {
      final NetworkStats.Entry entry=delta.getValues(i,mTmpNetworkStatsEntry);
      if (entry.rxPackets == 0 && entry.txPackets == 0) {
        continue;
      }
      if (DEBUG_ENERGY) {
        Slog.d(TAG,""String_Node_Str"" + entry.uid + ""String_Node_Str""+ entry.rxBytes+ ""String_Node_Str""+ entry.txBytes+ ""String_Node_Str""+ entry.rxPackets+ ""String_Node_Str""+ entry.txPackets);
      }
      totalRxPackets+=entry.rxPackets;
      totalTxPackets+=entry.txPackets;
      final Uid u=getUidStatsLocked(mapUid(entry.uid));
      u.noteNetworkActivityLocked(NETWORK_MOBILE_RX_DATA,entry.rxBytes,entry.rxPackets);
      u.noteNetworkActivityLocked(NETWORK_MOBILE_TX_DATA,entry.txBytes,entry.txPackets);
      mNetworkByteActivityCounters[NETWORK_MOBILE_RX_DATA].addCountLocked(entry.rxBytes);
      mNetworkByteActivityCounters[NETWORK_MOBILE_TX_DATA].addCountLocked(entry.txBytes);
      mNetworkPacketActivityCounters[NETWORK_MOBILE_RX_DATA].addCountLocked(entry.rxPackets);
      mNetworkPacketActivityCounters[NETWORK_MOBILE_TX_DATA].addCountLocked(entry.txPackets);
    }
    long totalPackets=totalRxPackets + totalTxPackets;
    if (totalPackets > 0) {
      for (int i=0; i < size; i++) {
        final NetworkStats.Entry entry=delta.getValues(i,mTmpNetworkStatsEntry);
        if (entry.rxPackets == 0 && entry.txPackets == 0) {
          continue;
        }
        final Uid u=getUidStatsLocked(mapUid(entry.uid));
        final long appPackets=entry.rxPackets + entry.txPackets;
        final long appRadioTime=(radioTime * appPackets) / totalPackets;
        u.noteMobileRadioActiveTimeLocked(appRadioTime);
        radioTime-=appRadioTime;
        totalPackets-=appPackets;
        if (activityInfo != null) {
          ControllerActivityCounterImpl activityCounter=u.getOrCreateModemControllerActivityLocked();
          if (totalRxPackets > 0 && entry.rxPackets > 0) {
            final long rxMs=(entry.rxPackets * activityInfo.getRxTimeMillis()) / totalRxPackets;
            activityCounter.getRxTimeCounter().addCountLocked(rxMs);
          }
          if (totalTxPackets > 0 && entry.txPackets > 0) {
            for (int lvl=0; lvl < ModemActivityInfo.TX_POWER_LEVELS; lvl++) {
              long txMs=entry.txPackets * activityInfo.getTxTimeMillis()[lvl];
              txMs/=totalTxPackets;
              activityCounter.getTxTimeCounters()[lvl].addCountLocked(txMs);
            }
          }
        }
      }
    }
    if (radioTime > 0) {
      mMobileRadioActiveUnknownTime.addCountLocked(radioTime);
      mMobileRadioActiveUnknownCount.addCountLocked(1);
    }
  }
  if (activityInfo != null) {
    mHasModemReporting=true;
    mModemActivity.getIdleTimeCounter().addCountLocked(activityInfo.getIdleTimeMillis());
    mModemActivity.getRxTimeCounter().addCountLocked(activityInfo.getRxTimeMillis());
    for (int lvl=0; lvl < ModemActivityInfo.TX_POWER_LEVELS; lvl++) {
      mModemActivity.getTxTimeCounters()[lvl].addCountLocked(activityInfo.getTxTimeMillis()[lvl]);
    }
    final double opVolt=mPowerProfile.getAveragePower(PowerProfile.POWER_MODEM_CONTROLLER_OPERATING_VOLTAGE) / 1000.0;
    if (opVolt != 0) {
      mModemActivity.getPowerCounter().addCountLocked((long)(activityInfo.getEnergyUsed() / opVolt));
    }
  }
}",0.937882122768403
192809,"/** 
 * Distribute Cell radio energy info and network traffic to apps.
 */
public void updateMobileRadioStateLocked(final long elapsedRealtimeMs,final ModemActivityInfo activityInfo){
  if (DEBUG_ENERGY) {
    Slog.d(TAG,""String_Node_Str"" + activityInfo);
  }
  NetworkStats delta=null;
  try {
    if (!ArrayUtils.isEmpty(mMobileIfaces)) {
      delta=getNetworkStatsDeltaLocked(mMobileIfaces,mMobileNetworkStats);
    }
  }
 catch (  IOException e) {
    Slog.wtf(TAG,""String_Node_Str"",e);
    return;
  }
  if (!mOnBatteryInternal) {
    return;
  }
  long radioTime=mMobileRadioActivePerAppTimer.getTimeSinceMarkLocked(elapsedRealtimeMs * 1000);
  mMobileRadioActivePerAppTimer.setMark(elapsedRealtimeMs);
  long totalRxPackets=0;
  long totalTxPackets=0;
  if (delta != null) {
    final int size=delta.size();
    for (int i=0; i < size; i++) {
      final NetworkStats.Entry entry=delta.getValues(i,mTmpNetworkStatsEntry);
      if (entry.rxPackets == 0 || entry.txPackets == 0) {
        continue;
      }
      if (DEBUG_ENERGY) {
        Slog.d(TAG,""String_Node_Str"" + entry.uid + ""String_Node_Str""+ entry.rxBytes+ ""String_Node_Str""+ entry.txBytes+ ""String_Node_Str""+ entry.rxPackets+ ""String_Node_Str""+ entry.txPackets);
      }
      totalRxPackets+=entry.rxPackets;
      totalTxPackets+=entry.txPackets;
      final Uid u=getUidStatsLocked(mapUid(entry.uid));
      u.noteNetworkActivityLocked(NETWORK_MOBILE_RX_DATA,entry.rxBytes,entry.rxPackets);
      u.noteNetworkActivityLocked(NETWORK_MOBILE_TX_DATA,entry.txBytes,entry.txPackets);
      mNetworkByteActivityCounters[NETWORK_MOBILE_RX_DATA].addCountLocked(entry.rxBytes);
      mNetworkByteActivityCounters[NETWORK_MOBILE_TX_DATA].addCountLocked(entry.txBytes);
      mNetworkPacketActivityCounters[NETWORK_MOBILE_RX_DATA].addCountLocked(entry.rxPackets);
      mNetworkPacketActivityCounters[NETWORK_MOBILE_TX_DATA].addCountLocked(entry.txPackets);
    }
    long totalPackets=totalRxPackets + totalTxPackets;
    if (totalPackets > 0) {
      for (int i=0; i < size; i++) {
        final NetworkStats.Entry entry=delta.getValues(i,mTmpNetworkStatsEntry);
        if (entry.rxPackets == 0 && entry.txPackets == 0) {
          continue;
        }
        final Uid u=getUidStatsLocked(mapUid(entry.uid));
        final long appPackets=entry.rxPackets + entry.txPackets;
        final long appRadioTime=(radioTime * appPackets) / totalPackets;
        u.noteMobileRadioActiveTimeLocked(appRadioTime);
        radioTime-=appRadioTime;
        totalPackets-=appPackets;
        if (activityInfo != null) {
          ControllerActivityCounterImpl activityCounter=u.getOrCreateModemControllerActivityLocked();
          if (entry.rxPackets != 0) {
            final long rxMs=(entry.rxPackets * activityInfo.getRxTimeMillis()) / totalRxPackets;
            activityCounter.getRxTimeCounter().addCountLocked(rxMs);
          }
          if (entry.txPackets != 0) {
            for (int lvl=0; lvl < ModemActivityInfo.TX_POWER_LEVELS; lvl++) {
              long txMs=entry.txPackets * activityInfo.getTxTimeMillis()[lvl];
              txMs/=totalTxPackets;
              activityCounter.getTxTimeCounters()[lvl].addCountLocked(txMs);
            }
          }
        }
      }
    }
    if (radioTime > 0) {
      mMobileRadioActiveUnknownTime.addCountLocked(radioTime);
      mMobileRadioActiveUnknownCount.addCountLocked(1);
    }
  }
  if (activityInfo != null) {
    mHasModemReporting=true;
    mModemActivity.getIdleTimeCounter().addCountLocked(activityInfo.getIdleTimeMillis());
    mModemActivity.getRxTimeCounter().addCountLocked(activityInfo.getRxTimeMillis());
    for (int lvl=0; lvl < ModemActivityInfo.TX_POWER_LEVELS; lvl++) {
      mModemActivity.getTxTimeCounters()[lvl].addCountLocked(activityInfo.getTxTimeMillis()[lvl]);
    }
    final double opVolt=mPowerProfile.getAveragePower(PowerProfile.POWER_MODEM_CONTROLLER_OPERATING_VOLTAGE) / 1000.0;
    if (opVolt != 0) {
      mModemActivity.getPowerCounter().addCountLocked((long)(activityInfo.getEnergyUsed() / opVolt));
    }
  }
}","/** 
 * Distribute Cell radio energy info and network traffic to apps.
 */
public void updateMobileRadioStateLocked(final long elapsedRealtimeMs,final ModemActivityInfo activityInfo){
  if (DEBUG_ENERGY) {
    Slog.d(TAG,""String_Node_Str"" + activityInfo);
  }
  NetworkStats delta=null;
  try {
    if (!ArrayUtils.isEmpty(mMobileIfaces)) {
      delta=getNetworkStatsDeltaLocked(mMobileIfaces,mMobileNetworkStats);
    }
  }
 catch (  IOException e) {
    Slog.wtf(TAG,""String_Node_Str"",e);
    return;
  }
  if (!mOnBatteryInternal) {
    return;
  }
  long radioTime=mMobileRadioActivePerAppTimer.getTimeSinceMarkLocked(elapsedRealtimeMs * 1000);
  mMobileRadioActivePerAppTimer.setMark(elapsedRealtimeMs);
  long totalRxPackets=0;
  long totalTxPackets=0;
  if (delta != null) {
    final int size=delta.size();
    for (int i=0; i < size; i++) {
      final NetworkStats.Entry entry=delta.getValues(i,mTmpNetworkStatsEntry);
      if (entry.rxPackets == 0 && entry.txPackets == 0) {
        continue;
      }
      if (DEBUG_ENERGY) {
        Slog.d(TAG,""String_Node_Str"" + entry.uid + ""String_Node_Str""+ entry.rxBytes+ ""String_Node_Str""+ entry.txBytes+ ""String_Node_Str""+ entry.rxPackets+ ""String_Node_Str""+ entry.txPackets);
      }
      totalRxPackets+=entry.rxPackets;
      totalTxPackets+=entry.txPackets;
      final Uid u=getUidStatsLocked(mapUid(entry.uid));
      u.noteNetworkActivityLocked(NETWORK_MOBILE_RX_DATA,entry.rxBytes,entry.rxPackets);
      u.noteNetworkActivityLocked(NETWORK_MOBILE_TX_DATA,entry.txBytes,entry.txPackets);
      mNetworkByteActivityCounters[NETWORK_MOBILE_RX_DATA].addCountLocked(entry.rxBytes);
      mNetworkByteActivityCounters[NETWORK_MOBILE_TX_DATA].addCountLocked(entry.txBytes);
      mNetworkPacketActivityCounters[NETWORK_MOBILE_RX_DATA].addCountLocked(entry.rxPackets);
      mNetworkPacketActivityCounters[NETWORK_MOBILE_TX_DATA].addCountLocked(entry.txPackets);
    }
    long totalPackets=totalRxPackets + totalTxPackets;
    if (totalPackets > 0) {
      for (int i=0; i < size; i++) {
        final NetworkStats.Entry entry=delta.getValues(i,mTmpNetworkStatsEntry);
        if (entry.rxPackets == 0 && entry.txPackets == 0) {
          continue;
        }
        final Uid u=getUidStatsLocked(mapUid(entry.uid));
        final long appPackets=entry.rxPackets + entry.txPackets;
        final long appRadioTime=(radioTime * appPackets) / totalPackets;
        u.noteMobileRadioActiveTimeLocked(appRadioTime);
        radioTime-=appRadioTime;
        totalPackets-=appPackets;
        if (activityInfo != null) {
          ControllerActivityCounterImpl activityCounter=u.getOrCreateModemControllerActivityLocked();
          if (totalRxPackets > 0 && entry.rxPackets > 0) {
            final long rxMs=(entry.rxPackets * activityInfo.getRxTimeMillis()) / totalRxPackets;
            activityCounter.getRxTimeCounter().addCountLocked(rxMs);
          }
          if (totalTxPackets > 0 && entry.txPackets > 0) {
            for (int lvl=0; lvl < ModemActivityInfo.TX_POWER_LEVELS; lvl++) {
              long txMs=entry.txPackets * activityInfo.getTxTimeMillis()[lvl];
              txMs/=totalTxPackets;
              activityCounter.getTxTimeCounters()[lvl].addCountLocked(txMs);
            }
          }
        }
      }
    }
    if (radioTime > 0) {
      mMobileRadioActiveUnknownTime.addCountLocked(radioTime);
      mMobileRadioActiveUnknownCount.addCountLocked(1);
    }
  }
  if (activityInfo != null) {
    mHasModemReporting=true;
    mModemActivity.getIdleTimeCounter().addCountLocked(activityInfo.getIdleTimeMillis());
    mModemActivity.getRxTimeCounter().addCountLocked(activityInfo.getRxTimeMillis());
    for (int lvl=0; lvl < ModemActivityInfo.TX_POWER_LEVELS; lvl++) {
      mModemActivity.getTxTimeCounters()[lvl].addCountLocked(activityInfo.getTxTimeMillis()[lvl]);
    }
    final double opVolt=mPowerProfile.getAveragePower(PowerProfile.POWER_MODEM_CONTROLLER_OPERATING_VOLTAGE) / 1000.0;
    if (opVolt != 0) {
      mModemActivity.getPowerCounter().addCountLocked((long)(activityInfo.getEnergyUsed() / opVolt));
    }
  }
}",0.937882122768403
192810,"/** 
 * Distribute Cell radio energy info and network traffic to apps.
 */
public void updateMobileRadioStateLocked(final long elapsedRealtimeMs,final ModemActivityInfo activityInfo){
  if (DEBUG_ENERGY) {
    Slog.d(TAG,""String_Node_Str"" + activityInfo);
  }
  NetworkStats delta=null;
  try {
    if (!ArrayUtils.isEmpty(mMobileIfaces)) {
      delta=getNetworkStatsDeltaLocked(mMobileIfaces,mMobileNetworkStats);
    }
  }
 catch (  IOException e) {
    Slog.wtf(TAG,""String_Node_Str"",e);
    return;
  }
  if (!mOnBatteryInternal) {
    return;
  }
  long radioTime=mMobileRadioActivePerAppTimer.getTimeSinceMarkLocked(elapsedRealtimeMs * 1000);
  mMobileRadioActivePerAppTimer.setMark(elapsedRealtimeMs);
  long totalRxPackets=0;
  long totalTxPackets=0;
  if (delta != null) {
    final int size=delta.size();
    for (int i=0; i < size; i++) {
      final NetworkStats.Entry entry=delta.getValues(i,mTmpNetworkStatsEntry);
      if (entry.rxPackets == 0 || entry.txPackets == 0) {
        continue;
      }
      if (DEBUG_ENERGY) {
        Slog.d(TAG,""String_Node_Str"" + entry.uid + ""String_Node_Str""+ entry.rxBytes+ ""String_Node_Str""+ entry.txBytes+ ""String_Node_Str""+ entry.rxPackets+ ""String_Node_Str""+ entry.txPackets);
      }
      totalRxPackets+=entry.rxPackets;
      totalTxPackets+=entry.txPackets;
      final Uid u=getUidStatsLocked(mapUid(entry.uid));
      u.noteNetworkActivityLocked(NETWORK_MOBILE_RX_DATA,entry.rxBytes,entry.rxPackets);
      u.noteNetworkActivityLocked(NETWORK_MOBILE_TX_DATA,entry.txBytes,entry.txPackets);
      mNetworkByteActivityCounters[NETWORK_MOBILE_RX_DATA].addCountLocked(entry.rxBytes);
      mNetworkByteActivityCounters[NETWORK_MOBILE_TX_DATA].addCountLocked(entry.txBytes);
      mNetworkPacketActivityCounters[NETWORK_MOBILE_RX_DATA].addCountLocked(entry.rxPackets);
      mNetworkPacketActivityCounters[NETWORK_MOBILE_TX_DATA].addCountLocked(entry.txPackets);
    }
    long totalPackets=totalRxPackets + totalTxPackets;
    if (totalPackets > 0) {
      for (int i=0; i < size; i++) {
        final NetworkStats.Entry entry=delta.getValues(i,mTmpNetworkStatsEntry);
        if (entry.rxPackets == 0 && entry.txPackets == 0) {
          continue;
        }
        final Uid u=getUidStatsLocked(mapUid(entry.uid));
        final long appPackets=entry.rxPackets + entry.txPackets;
        final long appRadioTime=(radioTime * appPackets) / totalPackets;
        u.noteMobileRadioActiveTimeLocked(appRadioTime);
        radioTime-=appRadioTime;
        totalPackets-=appPackets;
        if (activityInfo != null) {
          ControllerActivityCounterImpl activityCounter=u.getOrCreateModemControllerActivityLocked();
          if (entry.rxPackets != 0) {
            final long rxMs=(entry.rxPackets * activityInfo.getRxTimeMillis()) / totalRxPackets;
            activityCounter.getRxTimeCounter().addCountLocked(rxMs);
          }
          if (entry.txPackets != 0) {
            for (int lvl=0; lvl < ModemActivityInfo.TX_POWER_LEVELS; lvl++) {
              long txMs=entry.txPackets * activityInfo.getTxTimeMillis()[lvl];
              txMs/=totalTxPackets;
              activityCounter.getTxTimeCounters()[lvl].addCountLocked(txMs);
            }
          }
        }
      }
    }
    if (radioTime > 0) {
      mMobileRadioActiveUnknownTime.addCountLocked(radioTime);
      mMobileRadioActiveUnknownCount.addCountLocked(1);
    }
  }
  if (activityInfo != null) {
    mHasModemReporting=true;
    mModemActivity.getIdleTimeCounter().addCountLocked(activityInfo.getIdleTimeMillis());
    mModemActivity.getRxTimeCounter().addCountLocked(activityInfo.getRxTimeMillis());
    for (int lvl=0; lvl < ModemActivityInfo.TX_POWER_LEVELS; lvl++) {
      mModemActivity.getTxTimeCounters()[lvl].addCountLocked(activityInfo.getTxTimeMillis()[lvl]);
    }
    final double opVolt=mPowerProfile.getAveragePower(PowerProfile.POWER_MODEM_CONTROLLER_OPERATING_VOLTAGE) / 1000.0;
    if (opVolt != 0) {
      mModemActivity.getPowerCounter().addCountLocked((long)(activityInfo.getEnergyUsed() / opVolt));
    }
  }
}","/** 
 * Distribute Cell radio energy info and network traffic to apps.
 */
public void updateMobileRadioStateLocked(final long elapsedRealtimeMs,final ModemActivityInfo activityInfo){
  if (DEBUG_ENERGY) {
    Slog.d(TAG,""String_Node_Str"" + activityInfo);
  }
  NetworkStats delta=null;
  try {
    if (!ArrayUtils.isEmpty(mMobileIfaces)) {
      delta=getNetworkStatsDeltaLocked(mMobileIfaces,mMobileNetworkStats);
    }
  }
 catch (  IOException e) {
    Slog.wtf(TAG,""String_Node_Str"",e);
    return;
  }
  if (!mOnBatteryInternal) {
    return;
  }
  long radioTime=mMobileRadioActivePerAppTimer.getTimeSinceMarkLocked(elapsedRealtimeMs * 1000);
  mMobileRadioActivePerAppTimer.setMark(elapsedRealtimeMs);
  long totalRxPackets=0;
  long totalTxPackets=0;
  if (delta != null) {
    final int size=delta.size();
    for (int i=0; i < size; i++) {
      final NetworkStats.Entry entry=delta.getValues(i,mTmpNetworkStatsEntry);
      if (entry.rxPackets == 0 && entry.txPackets == 0) {
        continue;
      }
      if (DEBUG_ENERGY) {
        Slog.d(TAG,""String_Node_Str"" + entry.uid + ""String_Node_Str""+ entry.rxBytes+ ""String_Node_Str""+ entry.txBytes+ ""String_Node_Str""+ entry.rxPackets+ ""String_Node_Str""+ entry.txPackets);
      }
      totalRxPackets+=entry.rxPackets;
      totalTxPackets+=entry.txPackets;
      final Uid u=getUidStatsLocked(mapUid(entry.uid));
      u.noteNetworkActivityLocked(NETWORK_MOBILE_RX_DATA,entry.rxBytes,entry.rxPackets);
      u.noteNetworkActivityLocked(NETWORK_MOBILE_TX_DATA,entry.txBytes,entry.txPackets);
      mNetworkByteActivityCounters[NETWORK_MOBILE_RX_DATA].addCountLocked(entry.rxBytes);
      mNetworkByteActivityCounters[NETWORK_MOBILE_TX_DATA].addCountLocked(entry.txBytes);
      mNetworkPacketActivityCounters[NETWORK_MOBILE_RX_DATA].addCountLocked(entry.rxPackets);
      mNetworkPacketActivityCounters[NETWORK_MOBILE_TX_DATA].addCountLocked(entry.txPackets);
    }
    long totalPackets=totalRxPackets + totalTxPackets;
    if (totalPackets > 0) {
      for (int i=0; i < size; i++) {
        final NetworkStats.Entry entry=delta.getValues(i,mTmpNetworkStatsEntry);
        if (entry.rxPackets == 0 && entry.txPackets == 0) {
          continue;
        }
        final Uid u=getUidStatsLocked(mapUid(entry.uid));
        final long appPackets=entry.rxPackets + entry.txPackets;
        final long appRadioTime=(radioTime * appPackets) / totalPackets;
        u.noteMobileRadioActiveTimeLocked(appRadioTime);
        radioTime-=appRadioTime;
        totalPackets-=appPackets;
        if (activityInfo != null) {
          ControllerActivityCounterImpl activityCounter=u.getOrCreateModemControllerActivityLocked();
          if (totalRxPackets > 0 && entry.rxPackets > 0) {
            final long rxMs=(entry.rxPackets * activityInfo.getRxTimeMillis()) / totalRxPackets;
            activityCounter.getRxTimeCounter().addCountLocked(rxMs);
          }
          if (totalTxPackets > 0 && entry.txPackets > 0) {
            for (int lvl=0; lvl < ModemActivityInfo.TX_POWER_LEVELS; lvl++) {
              long txMs=entry.txPackets * activityInfo.getTxTimeMillis()[lvl];
              txMs/=totalTxPackets;
              activityCounter.getTxTimeCounters()[lvl].addCountLocked(txMs);
            }
          }
        }
      }
    }
    if (radioTime > 0) {
      mMobileRadioActiveUnknownTime.addCountLocked(radioTime);
      mMobileRadioActiveUnknownCount.addCountLocked(1);
    }
  }
  if (activityInfo != null) {
    mHasModemReporting=true;
    mModemActivity.getIdleTimeCounter().addCountLocked(activityInfo.getIdleTimeMillis());
    mModemActivity.getRxTimeCounter().addCountLocked(activityInfo.getRxTimeMillis());
    for (int lvl=0; lvl < ModemActivityInfo.TX_POWER_LEVELS; lvl++) {
      mModemActivity.getTxTimeCounters()[lvl].addCountLocked(activityInfo.getTxTimeMillis()[lvl]);
    }
    final double opVolt=mPowerProfile.getAveragePower(PowerProfile.POWER_MODEM_CONTROLLER_OPERATING_VOLTAGE) / 1000.0;
    if (opVolt != 0) {
      mModemActivity.getPowerCounter().addCountLocked((long)(activityInfo.getEnergyUsed() / opVolt));
    }
  }
}",0.937882122768403
192811,"public DragStartInitializeDropTargetsEvent(Task task,RecentsViewTouchHandler handler){
  this.task=task;
  this.handler=handler;
}","public DragStartInitializeDropTargetsEvent(Task task,TaskView taskView,RecentsViewTouchHandler handler){
  this.task=task;
  this.taskView=taskView;
  this.handler=handler;
}",0.8552631578947368
192812,"/** 
 * Returns the task stack bounds with the given   {@param width} and{@param height}.
 */
public Rect getDockedTaskStackBounds(int width,int height,int dividerSize,Rect insets,Resources res){
  RecentsConfiguration config=Recents.getConfiguration();
  boolean isHorizontalDivision=res.getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT;
  int position=DockedDividerUtils.calculateMiddlePosition(isHorizontalDivision,insets,width,height,dividerSize);
  Rect newWindowBounds=new Rect();
  DockedDividerUtils.calculateBoundsForPosition(position,DockedDividerUtils.invertDockSide(dockSide),newWindowBounds,width,height,dividerSize);
  Rect searchBarSpaceBounds=new Rect();
  Rect taskStackBounds=new Rect();
  config.getTaskStackBounds(newWindowBounds,insets.top,insets.right,searchBarSpaceBounds,taskStackBounds);
  return taskStackBounds;
}","/** 
 * Returns the task stack bounds with the given   {@param width} and{@param height}.
 */
public Rect getDockedTaskStackBounds(int width,int height,int dividerSize,Rect insets,Resources res){
  RecentsConfiguration config=Recents.getConfiguration();
  boolean isHorizontalDivision=res.getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT;
  int position=DockedDividerUtils.calculateMiddlePosition(isHorizontalDivision,insets,width,height,dividerSize);
  Rect newWindowBounds=new Rect();
  DockedDividerUtils.calculateBoundsForPosition(position,DockedDividerUtils.invertDockSide(dockSide),newWindowBounds,width,height,dividerSize);
  Rect searchBarSpaceBounds=new Rect();
  Rect taskStackBounds=new Rect();
  int top=dockArea.bottom < 1f ? 0 : insets.top;
  config.getTaskStackBounds(newWindowBounds,top,insets.right,searchBarSpaceBounds,taskStackBounds);
  return taskStackBounds;
}",0.9648127128263336
192813,"@Override public void run(){
  setVisibility(View.INVISIBLE);
}","@Override public void run(){
  mStackScroller.animateScroll(mLayoutAlgorithm.mMaxScrollP,null);
}",0.525
192814,"public final void onBusEvent(HideHistoryEvent event){
  setVisibility(View.VISIBLE);
  mAnimationHelper.startHideHistoryAnimation();
}","public final void onBusEvent(TaskStackUpdatedEvent event){
  event.addPostAnimationCallback(new Runnable(){
    @Override public void run(){
      mStackScroller.animateScroll(mLayoutAlgorithm.mMaxScrollP,null);
    }
  }
);
}",0.2277777777777777
192815,"/** 
 * Sets the focused task to the provided (bounded taskIndex).
 * @return whether or not the stack will scroll as a part of this focus change
 */
private boolean setFocusedTask(int taskIndex,boolean scrollToTask,final boolean requestViewFocus,final int timerIndicatorDuration){
  int newFocusedTaskIndex=mStack.getTaskCount() > 0 ? Math.max(0,Math.min(mStack.getTaskCount() - 1,taskIndex)) : -1;
  final Task newFocusedTask=(newFocusedTaskIndex != -1) ? mStack.getStackTasks().get(newFocusedTaskIndex) : null;
  if (mFocusedTask != null) {
    if (timerIndicatorDuration > 0) {
      final TaskView tv=getChildViewForTask(mFocusedTask);
      if (tv != null) {
        tv.getHeaderView().cancelFocusTimerIndicator();
      }
    }
    resetFocusedTask(mFocusedTask);
  }
  boolean willScroll=false;
  mFocusedTask=newFocusedTask;
  if (newFocusedTask != null) {
    if (timerIndicatorDuration > 0) {
      final TaskView tv=getChildViewForTask(mFocusedTask);
      if (tv != null) {
        tv.getHeaderView().startFocusTimerIndicator(timerIndicatorDuration);
      }
 else {
        mStartTimerIndicatorDuration=timerIndicatorDuration;
      }
    }
    Runnable focusTaskRunnable=new Runnable(){
      @Override public void run(){
        final TaskView tv=getChildViewForTask(newFocusedTask);
        if (tv != null) {
          tv.setFocusedState(true,requestViewFocus);
        }
      }
    }
;
    if (scrollToTask) {
      if (!mEnterAnimationComplete) {
        cancelAllTaskViewAnimations();
      }
      float newScroll=mLayoutAlgorithm.getStackScrollForTask(newFocusedTask);
      if (Float.compare(newScroll,mStackScroller.getStackScroll()) != 0) {
        mStackScroller.animateScroll(mStackScroller.getStackScroll(),newScroll,focusTaskRunnable);
        willScroll=true;
      }
 else {
        focusTaskRunnable.run();
      }
      mLayoutAlgorithm.animateFocusState(TaskStackLayoutAlgorithm.STATE_FOCUSED);
    }
 else {
      focusTaskRunnable.run();
    }
  }
  return willScroll;
}","/** 
 * Sets the focused task to the provided (bounded taskIndex).
 * @return whether or not the stack will scroll as a part of this focus change
 */
private boolean setFocusedTask(int taskIndex,boolean scrollToTask,final boolean requestViewFocus,final int timerIndicatorDuration){
  int newFocusedTaskIndex=mStack.getTaskCount() > 0 ? Math.max(0,Math.min(mStack.getTaskCount() - 1,taskIndex)) : -1;
  final Task newFocusedTask=(newFocusedTaskIndex != -1) ? mStack.getStackTasks().get(newFocusedTaskIndex) : null;
  if (mFocusedTask != null) {
    if (timerIndicatorDuration > 0) {
      final TaskView tv=getChildViewForTask(mFocusedTask);
      if (tv != null) {
        tv.getHeaderView().cancelFocusTimerIndicator();
      }
    }
    resetFocusedTask(mFocusedTask);
  }
  boolean willScroll=false;
  mFocusedTask=newFocusedTask;
  if (newFocusedTask != null) {
    if (timerIndicatorDuration > 0) {
      final TaskView tv=getChildViewForTask(mFocusedTask);
      if (tv != null) {
        tv.getHeaderView().startFocusTimerIndicator(timerIndicatorDuration);
      }
 else {
        mStartTimerIndicatorDuration=timerIndicatorDuration;
      }
    }
    Runnable focusTaskRunnable=new Runnable(){
      @Override public void run(){
        final TaskView tv=getChildViewForTask(newFocusedTask);
        if (tv != null) {
          tv.setFocusedState(true,requestViewFocus);
        }
      }
    }
;
    if (scrollToTask) {
      if (!mEnterAnimationComplete) {
        cancelAllTaskViewAnimations();
      }
      float newScroll=mLayoutAlgorithm.getStackScrollForTask(newFocusedTask);
      if (Float.compare(newScroll,mStackScroller.getStackScroll()) != 0) {
        mStackScroller.animateScroll(newScroll,focusTaskRunnable);
        willScroll=true;
      }
 else {
        focusTaskRunnable.run();
      }
      mLayoutAlgorithm.animateFocusState(TaskStackLayoutAlgorithm.STATE_FOCUSED);
    }
 else {
      focusTaskRunnable.run();
    }
  }
  return willScroll;
}",0.9919638372677048
192816,"/** 
 * Animates the stack scroll 
 */
void animateScroll(float curScroll,float newScroll,final Runnable postRunnable){
  if (mScrollAnimator != null && mScrollAnimator.isRunning()) {
    setStackScroll(mFinalAnimatedScroll);
    mScroller.startScroll(0,progressToScrollRange(mFinalAnimatedScroll),0,0,0);
  }
  stopScroller();
  stopBoundScrollAnimation();
  mFinalAnimatedScroll=newScroll;
  mScrollAnimator=ObjectAnimator.ofFloat(this,STACK_SCROLL,curScroll,newScroll);
  mScrollAnimator.setDuration(mContext.getResources().getInteger(R.integer.recents_animate_task_stack_scroll_duration));
  mScrollAnimator.setInterpolator(Interpolators.LINEAR_OUT_SLOW_IN);
  mScrollAnimator.addListener(new AnimatorListenerAdapter(){
    @Override public void onAnimationEnd(    Animator animation){
      if (postRunnable != null) {
        postRunnable.run();
      }
      mScrollAnimator.removeAllListeners();
    }
  }
);
  mScrollAnimator.start();
}","/** 
 * Animates the stack scroll 
 */
void animateScroll(float newScroll,final Runnable postRunnable){
  if (mScrollAnimator != null && mScrollAnimator.isRunning()) {
    setStackScroll(mFinalAnimatedScroll);
    mScroller.startScroll(0,progressToScrollRange(mFinalAnimatedScroll),0,0,0);
  }
  stopScroller();
  stopBoundScrollAnimation();
  mFinalAnimatedScroll=newScroll;
  mScrollAnimator=ObjectAnimator.ofFloat(this,STACK_SCROLL,getStackScroll(),newScroll);
  mScrollAnimator.setDuration(mContext.getResources().getInteger(R.integer.recents_animate_task_stack_scroll_duration));
  mScrollAnimator.setInterpolator(Interpolators.LINEAR_OUT_SLOW_IN);
  mScrollAnimator.addListener(new AnimatorListenerAdapter(){
    @Override public void onAnimationEnd(    Animator animation){
      if (postRunnable != null) {
        postRunnable.run();
      }
      mScrollAnimator.removeAllListeners();
    }
  }
);
  mScrollAnimator.start();
}",0.9782030834662414
192817,"/** 
 * Sets the current stack scroll to the initial state when you first enter recents.
 * @return whether the stack progress changed.
 */
public boolean setStackScrollToInitialState(){
  float prevStackScrollP=mStackScrollP;
  setStackScroll(getBoundedStackScroll(mLayoutAlgorithm.mInitialScrollP));
  return Float.compare(prevStackScrollP,mStackScrollP) != 0;
}","/** 
 * Sets the current stack scroll to the initial state when you first enter recents.
 * @return whether the stack progress changed.
 */
public boolean setStackScrollToInitialState(){
  SystemServicesProxy ssp=Recents.getSystemServices();
  float prevStackScrollP=mStackScrollP;
  if (ssp.hasDockedTask()) {
    setStackScroll(mLayoutAlgorithm.mMaxScrollP);
  }
 else {
    setStackScroll(mLayoutAlgorithm.mInitialScrollP);
  }
  return Float.compare(prevStackScrollP,mStackScrollP) != 0;
}",0.7911318553092183
192818,"/** 
 * Animates the stack scroll into bounds 
 */
ObjectAnimator animateBoundScroll(){
  float curScroll=getStackScroll();
  float newScroll=getBoundedStackScroll(curScroll);
  if (Float.compare(newScroll,curScroll) != 0) {
    animateScroll(curScroll,newScroll,null);
  }
  return mScrollAnimator;
}","/** 
 * Animates the stack scroll into bounds 
 */
ObjectAnimator animateBoundScroll(){
  float curScroll=getStackScroll();
  float newScroll=getBoundedStackScroll(curScroll);
  if (Float.compare(newScroll,curScroll) != 0) {
    animateScroll(newScroll,null);
  }
  return mScrollAnimator;
}",0.972972972972973
192819,"public DragStartInitializeDropTargetsEvent(Task task,RecentsViewTouchHandler handler){
  this.task=task;
  this.handler=handler;
}","public DragStartInitializeDropTargetsEvent(Task task,TaskView taskView,RecentsViewTouchHandler handler){
  this.task=task;
  this.taskView=taskView;
  this.handler=handler;
}",0.8552631578947368
192820,"/** 
 * Returns the task stack bounds with the given   {@param width} and{@param height}.
 */
public Rect getDockedTaskStackBounds(int width,int height,int dividerSize,Rect insets,Resources res){
  RecentsConfiguration config=Recents.getConfiguration();
  boolean isHorizontalDivision=res.getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT;
  int position=DockedDividerUtils.calculateMiddlePosition(isHorizontalDivision,insets,width,height,dividerSize);
  Rect newWindowBounds=new Rect();
  DockedDividerUtils.calculateBoundsForPosition(position,DockedDividerUtils.invertDockSide(dockSide),newWindowBounds,width,height,dividerSize);
  Rect searchBarSpaceBounds=new Rect();
  Rect taskStackBounds=new Rect();
  config.getTaskStackBounds(newWindowBounds,insets.top,insets.right,searchBarSpaceBounds,taskStackBounds);
  return taskStackBounds;
}","/** 
 * Returns the task stack bounds with the given   {@param width} and{@param height}.
 */
public Rect getDockedTaskStackBounds(int width,int height,int dividerSize,Rect insets,Resources res){
  RecentsConfiguration config=Recents.getConfiguration();
  boolean isHorizontalDivision=res.getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT;
  int position=DockedDividerUtils.calculateMiddlePosition(isHorizontalDivision,insets,width,height,dividerSize);
  Rect newWindowBounds=new Rect();
  DockedDividerUtils.calculateBoundsForPosition(position,DockedDividerUtils.invertDockSide(dockSide),newWindowBounds,width,height,dividerSize);
  Rect searchBarSpaceBounds=new Rect();
  Rect taskStackBounds=new Rect();
  int top=dockArea.bottom < 1f ? 0 : insets.top;
  config.getTaskStackBounds(newWindowBounds,top,insets.right,searchBarSpaceBounds,taskStackBounds);
  return taskStackBounds;
}",0.9648127128263336
192821,"@Override public void run(){
  setVisibility(View.INVISIBLE);
}","@Override public void run(){
  mStackScroller.animateScroll(mLayoutAlgorithm.mMaxScrollP,null);
}",0.525
192822,"public final void onBusEvent(HideHistoryEvent event){
  setVisibility(View.VISIBLE);
  mAnimationHelper.startHideHistoryAnimation();
}","public final void onBusEvent(TaskStackUpdatedEvent event){
  event.addPostAnimationCallback(new Runnable(){
    @Override public void run(){
      mStackScroller.animateScroll(mLayoutAlgorithm.mMaxScrollP,null);
    }
  }
);
}",0.2277777777777777
192823,"/** 
 * Sets the focused task to the provided (bounded taskIndex).
 * @return whether or not the stack will scroll as a part of this focus change
 */
private boolean setFocusedTask(int taskIndex,boolean scrollToTask,final boolean requestViewFocus,final int timerIndicatorDuration){
  int newFocusedTaskIndex=mStack.getTaskCount() > 0 ? Math.max(0,Math.min(mStack.getTaskCount() - 1,taskIndex)) : -1;
  final Task newFocusedTask=(newFocusedTaskIndex != -1) ? mStack.getStackTasks().get(newFocusedTaskIndex) : null;
  if (mFocusedTask != null) {
    if (timerIndicatorDuration > 0) {
      final TaskView tv=getChildViewForTask(mFocusedTask);
      if (tv != null) {
        tv.getHeaderView().cancelFocusTimerIndicator();
      }
    }
    resetFocusedTask(mFocusedTask);
  }
  boolean willScroll=false;
  mFocusedTask=newFocusedTask;
  if (newFocusedTask != null) {
    if (timerIndicatorDuration > 0) {
      final TaskView tv=getChildViewForTask(mFocusedTask);
      if (tv != null) {
        tv.getHeaderView().startFocusTimerIndicator(timerIndicatorDuration);
      }
 else {
        mStartTimerIndicatorDuration=timerIndicatorDuration;
      }
    }
    Runnable focusTaskRunnable=new Runnable(){
      @Override public void run(){
        final TaskView tv=getChildViewForTask(newFocusedTask);
        if (tv != null) {
          tv.setFocusedState(true,requestViewFocus);
        }
      }
    }
;
    if (scrollToTask) {
      if (!mEnterAnimationComplete) {
        cancelAllTaskViewAnimations();
      }
      float newScroll=mLayoutAlgorithm.getStackScrollForTask(newFocusedTask);
      if (Float.compare(newScroll,mStackScroller.getStackScroll()) != 0) {
        mStackScroller.animateScroll(mStackScroller.getStackScroll(),newScroll,focusTaskRunnable);
        willScroll=true;
      }
 else {
        focusTaskRunnable.run();
      }
      mLayoutAlgorithm.animateFocusState(TaskStackLayoutAlgorithm.STATE_FOCUSED);
    }
 else {
      focusTaskRunnable.run();
    }
  }
  return willScroll;
}","/** 
 * Sets the focused task to the provided (bounded taskIndex).
 * @return whether or not the stack will scroll as a part of this focus change
 */
private boolean setFocusedTask(int taskIndex,boolean scrollToTask,final boolean requestViewFocus,final int timerIndicatorDuration){
  int newFocusedTaskIndex=mStack.getTaskCount() > 0 ? Math.max(0,Math.min(mStack.getTaskCount() - 1,taskIndex)) : -1;
  final Task newFocusedTask=(newFocusedTaskIndex != -1) ? mStack.getStackTasks().get(newFocusedTaskIndex) : null;
  if (mFocusedTask != null) {
    if (timerIndicatorDuration > 0) {
      final TaskView tv=getChildViewForTask(mFocusedTask);
      if (tv != null) {
        tv.getHeaderView().cancelFocusTimerIndicator();
      }
    }
    resetFocusedTask(mFocusedTask);
  }
  boolean willScroll=false;
  mFocusedTask=newFocusedTask;
  if (newFocusedTask != null) {
    if (timerIndicatorDuration > 0) {
      final TaskView tv=getChildViewForTask(mFocusedTask);
      if (tv != null) {
        tv.getHeaderView().startFocusTimerIndicator(timerIndicatorDuration);
      }
 else {
        mStartTimerIndicatorDuration=timerIndicatorDuration;
      }
    }
    Runnable focusTaskRunnable=new Runnable(){
      @Override public void run(){
        final TaskView tv=getChildViewForTask(newFocusedTask);
        if (tv != null) {
          tv.setFocusedState(true,requestViewFocus);
        }
      }
    }
;
    if (scrollToTask) {
      if (!mEnterAnimationComplete) {
        cancelAllTaskViewAnimations();
      }
      float newScroll=mLayoutAlgorithm.getStackScrollForTask(newFocusedTask);
      if (Float.compare(newScroll,mStackScroller.getStackScroll()) != 0) {
        mStackScroller.animateScroll(newScroll,focusTaskRunnable);
        willScroll=true;
      }
 else {
        focusTaskRunnable.run();
      }
      mLayoutAlgorithm.animateFocusState(TaskStackLayoutAlgorithm.STATE_FOCUSED);
    }
 else {
      focusTaskRunnable.run();
    }
  }
  return willScroll;
}",0.9919638372677048
192824,"/** 
 * Animates the stack scroll 
 */
void animateScroll(float curScroll,float newScroll,final Runnable postRunnable){
  if (mScrollAnimator != null && mScrollAnimator.isRunning()) {
    setStackScroll(mFinalAnimatedScroll);
    mScroller.startScroll(0,progressToScrollRange(mFinalAnimatedScroll),0,0,0);
  }
  stopScroller();
  stopBoundScrollAnimation();
  mFinalAnimatedScroll=newScroll;
  mScrollAnimator=ObjectAnimator.ofFloat(this,STACK_SCROLL,curScroll,newScroll);
  mScrollAnimator.setDuration(mContext.getResources().getInteger(R.integer.recents_animate_task_stack_scroll_duration));
  mScrollAnimator.setInterpolator(Interpolators.LINEAR_OUT_SLOW_IN);
  mScrollAnimator.addListener(new AnimatorListenerAdapter(){
    @Override public void onAnimationEnd(    Animator animation){
      if (postRunnable != null) {
        postRunnable.run();
      }
      mScrollAnimator.removeAllListeners();
    }
  }
);
  mScrollAnimator.start();
}","/** 
 * Animates the stack scroll 
 */
void animateScroll(float newScroll,final Runnable postRunnable){
  if (mScrollAnimator != null && mScrollAnimator.isRunning()) {
    setStackScroll(mFinalAnimatedScroll);
    mScroller.startScroll(0,progressToScrollRange(mFinalAnimatedScroll),0,0,0);
  }
  stopScroller();
  stopBoundScrollAnimation();
  mFinalAnimatedScroll=newScroll;
  mScrollAnimator=ObjectAnimator.ofFloat(this,STACK_SCROLL,getStackScroll(),newScroll);
  mScrollAnimator.setDuration(mContext.getResources().getInteger(R.integer.recents_animate_task_stack_scroll_duration));
  mScrollAnimator.setInterpolator(Interpolators.LINEAR_OUT_SLOW_IN);
  mScrollAnimator.addListener(new AnimatorListenerAdapter(){
    @Override public void onAnimationEnd(    Animator animation){
      if (postRunnable != null) {
        postRunnable.run();
      }
      mScrollAnimator.removeAllListeners();
    }
  }
);
  mScrollAnimator.start();
}",0.9782030834662414
192825,"/** 
 * Sets the current stack scroll to the initial state when you first enter recents.
 * @return whether the stack progress changed.
 */
public boolean setStackScrollToInitialState(){
  float prevStackScrollP=mStackScrollP;
  setStackScroll(getBoundedStackScroll(mLayoutAlgorithm.mInitialScrollP));
  return Float.compare(prevStackScrollP,mStackScrollP) != 0;
}","/** 
 * Sets the current stack scroll to the initial state when you first enter recents.
 * @return whether the stack progress changed.
 */
public boolean setStackScrollToInitialState(){
  SystemServicesProxy ssp=Recents.getSystemServices();
  float prevStackScrollP=mStackScrollP;
  if (ssp.hasDockedTask()) {
    setStackScroll(mLayoutAlgorithm.mMaxScrollP);
  }
 else {
    setStackScroll(mLayoutAlgorithm.mInitialScrollP);
  }
  return Float.compare(prevStackScrollP,mStackScrollP) != 0;
}",0.7911318553092183
192826,"/** 
 * Animates the stack scroll into bounds 
 */
ObjectAnimator animateBoundScroll(){
  float curScroll=getStackScroll();
  float newScroll=getBoundedStackScroll(curScroll);
  if (Float.compare(newScroll,curScroll) != 0) {
    animateScroll(curScroll,newScroll,null);
  }
  return mScrollAnimator;
}","/** 
 * Animates the stack scroll into bounds 
 */
ObjectAnimator animateBoundScroll(){
  float curScroll=getStackScroll();
  float newScroll=getBoundedStackScroll(curScroll);
  if (Float.compare(newScroll,curScroll) != 0) {
    animateScroll(newScroll,null);
  }
  return mScrollAnimator;
}",0.972972972972973
192827,"protected boolean inflateViews(Entry entry,ViewGroup parent){
  PackageManager pmUser=getPackageManagerForUser(mContext,entry.notification.getUser().getIdentifier());
  final StatusBarNotification sbn=entry.notification;
  entry.cacheContentViews(mContext,null);
  final RemoteViews contentView=entry.cachedContentView;
  final RemoteViews bigContentView=entry.cachedBigContentView;
  final RemoteViews headsUpContentView=entry.cachedHeadsUpContentView;
  final RemoteViews publicContentView=entry.cachedPublicContentView;
  if (contentView == null) {
    Log.v(TAG,""String_Node_Str"" + sbn.getNotification());
    return false;
  }
  if (DEBUG) {
    Log.v(TAG,""String_Node_Str"" + publicContentView);
  }
  ExpandableNotificationRow row;
  boolean hasUserChangedExpansion=false;
  boolean userExpanded=false;
  boolean userLocked=false;
  if (entry.row != null) {
    row=entry.row;
    hasUserChangedExpansion=row.hasUserChangedExpansion();
    userExpanded=row.isUserExpanded();
    userLocked=row.isUserLocked();
    entry.reset();
    if (hasUserChangedExpansion) {
      row.setUserExpanded(userExpanded);
    }
  }
 else {
    LayoutInflater inflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    row=(ExpandableNotificationRow)inflater.inflate(R.layout.status_bar_notification_row,parent,false);
    row.setExpansionLogger(this,entry.notification.getKey());
    row.setGroupManager(mGroupManager);
    row.setHeadsUpManager(mHeadsUpManager);
    row.setRemoteInputController(mRemoteInputController);
    row.setOnExpandClickListener(this);
  }
  workAroundBadLayerDrawableOpacity(row);
  View vetoButton=updateNotificationVetoButton(row,sbn);
  vetoButton.setContentDescription(mContext.getString(R.string.accessibility_remove_notification));
  NotificationContentView contentContainer=row.getPrivateLayout();
  NotificationContentView contentContainerPublic=row.getPublicLayout();
  row.setDescendantFocusability(ViewGroup.FOCUS_BLOCK_DESCENDANTS);
  if (ENABLE_REMOTE_INPUT) {
    row.setDescendantFocusability(ViewGroup.FOCUS_BEFORE_DESCENDANTS);
  }
  mNotificationClicker.register(row,sbn);
  View contentViewLocal=null;
  View bigContentViewLocal=null;
  View headsUpContentViewLocal=null;
  View publicViewLocal=null;
  try {
    contentViewLocal=contentView.apply(sbn.getPackageContext(mContext),contentContainer,mOnClickHandler);
    if (bigContentView != null) {
      bigContentViewLocal=bigContentView.apply(sbn.getPackageContext(mContext),contentContainer,mOnClickHandler);
    }
    if (headsUpContentView != null) {
      headsUpContentViewLocal=headsUpContentView.apply(sbn.getPackageContext(mContext),contentContainer,mOnClickHandler);
    }
    if (publicContentView != null) {
      publicViewLocal=publicContentView.apply(sbn.getPackageContext(mContext),contentContainerPublic,mOnClickHandler);
    }
  }
 catch (  RuntimeException e) {
    final String ident=sbn.getPackageName() + ""String_Node_Str"" + Integer.toHexString(sbn.getId());
    Log.e(TAG,""String_Node_Str"" + ident,e);
    return false;
  }
  if (contentViewLocal != null) {
    contentViewLocal.setIsRootNamespace(true);
    contentContainer.setContractedChild(contentViewLocal);
  }
  if (bigContentViewLocal != null) {
    bigContentViewLocal.setIsRootNamespace(true);
    contentContainer.setExpandedChild(bigContentViewLocal);
  }
  if (headsUpContentViewLocal != null) {
    headsUpContentViewLocal.setIsRootNamespace(true);
    contentContainer.setHeadsUpChild(headsUpContentViewLocal);
  }
  if (publicViewLocal != null) {
    publicViewLocal.setIsRootNamespace(true);
    contentContainerPublic.setContractedChild(publicViewLocal);
  }
  try {
    ApplicationInfo info=pmUser.getApplicationInfo(sbn.getPackageName(),0);
    entry.targetSdk=info.targetSdkVersion;
  }
 catch (  NameNotFoundException ex) {
    Log.e(TAG,""String_Node_Str"" + sbn.getPackageName(),ex);
  }
  entry.autoRedacted=entry.notification.getNotification().publicVersion == null;
  if (MULTIUSER_DEBUG) {
    TextView debug=(TextView)row.findViewById(R.id.debug_info);
    if (debug != null) {
      debug.setVisibility(View.VISIBLE);
      debug.setText(""String_Node_Str"" + mCurrentUserId + ""String_Node_Str""+ entry.notification.getUserId());
    }
  }
  entry.row=row;
  entry.row.setOnActivatedListener(this);
  entry.row.setExpandable(bigContentViewLocal != null);
  applyColorsAndBackgrounds(sbn,entry);
  if (hasUserChangedExpansion) {
    row.setUserExpanded(userExpanded);
  }
  row.setUserLocked(userLocked);
  row.onNotificationUpdated(entry);
  return true;
}","protected boolean inflateViews(Entry entry,ViewGroup parent){
  PackageManager pmUser=getPackageManagerForUser(mContext,entry.notification.getUser().getIdentifier());
  final StatusBarNotification sbn=entry.notification;
  entry.cacheContentViews(mContext,null);
  final RemoteViews contentView=entry.cachedContentView;
  final RemoteViews bigContentView=entry.cachedBigContentView;
  final RemoteViews headsUpContentView=entry.cachedHeadsUpContentView;
  final RemoteViews publicContentView=entry.cachedPublicContentView;
  if (contentView == null) {
    Log.v(TAG,""String_Node_Str"" + sbn.getNotification());
    return false;
  }
  if (DEBUG) {
    Log.v(TAG,""String_Node_Str"" + publicContentView);
  }
  ExpandableNotificationRow row;
  boolean hasUserChangedExpansion=false;
  boolean userExpanded=false;
  boolean userLocked=false;
  if (entry.row != null) {
    row=entry.row;
    hasUserChangedExpansion=row.hasUserChangedExpansion();
    userExpanded=row.isUserExpanded();
    userLocked=row.isUserLocked();
    entry.reset();
    if (hasUserChangedExpansion) {
      row.setUserExpanded(userExpanded);
    }
  }
 else {
    LayoutInflater inflater=(LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    row=(ExpandableNotificationRow)inflater.inflate(R.layout.status_bar_notification_row,parent,false);
    row.setExpansionLogger(this,entry.notification.getKey());
    row.setGroupManager(mGroupManager);
    row.setHeadsUpManager(mHeadsUpManager);
    row.setRemoteInputController(mRemoteInputController);
    row.setOnExpandClickListener(this);
  }
  workAroundBadLayerDrawableOpacity(row);
  View vetoButton=bindVetoButtonClickListener(row,sbn);
  vetoButton.setContentDescription(mContext.getString(R.string.accessibility_remove_notification));
  NotificationContentView contentContainer=row.getPrivateLayout();
  NotificationContentView contentContainerPublic=row.getPublicLayout();
  row.setDescendantFocusability(ViewGroup.FOCUS_BLOCK_DESCENDANTS);
  if (ENABLE_REMOTE_INPUT) {
    row.setDescendantFocusability(ViewGroup.FOCUS_BEFORE_DESCENDANTS);
  }
  mNotificationClicker.register(row,sbn);
  View contentViewLocal=null;
  View bigContentViewLocal=null;
  View headsUpContentViewLocal=null;
  View publicViewLocal=null;
  try {
    contentViewLocal=contentView.apply(sbn.getPackageContext(mContext),contentContainer,mOnClickHandler);
    if (bigContentView != null) {
      bigContentViewLocal=bigContentView.apply(sbn.getPackageContext(mContext),contentContainer,mOnClickHandler);
    }
    if (headsUpContentView != null) {
      headsUpContentViewLocal=headsUpContentView.apply(sbn.getPackageContext(mContext),contentContainer,mOnClickHandler);
    }
    if (publicContentView != null) {
      publicViewLocal=publicContentView.apply(sbn.getPackageContext(mContext),contentContainerPublic,mOnClickHandler);
    }
  }
 catch (  RuntimeException e) {
    final String ident=sbn.getPackageName() + ""String_Node_Str"" + Integer.toHexString(sbn.getId());
    Log.e(TAG,""String_Node_Str"" + ident,e);
    return false;
  }
  if (contentViewLocal != null) {
    contentViewLocal.setIsRootNamespace(true);
    contentContainer.setContractedChild(contentViewLocal);
  }
  if (bigContentViewLocal != null) {
    bigContentViewLocal.setIsRootNamespace(true);
    contentContainer.setExpandedChild(bigContentViewLocal);
  }
  if (headsUpContentViewLocal != null) {
    headsUpContentViewLocal.setIsRootNamespace(true);
    contentContainer.setHeadsUpChild(headsUpContentViewLocal);
  }
  if (publicViewLocal != null) {
    publicViewLocal.setIsRootNamespace(true);
    contentContainerPublic.setContractedChild(publicViewLocal);
  }
  try {
    ApplicationInfo info=pmUser.getApplicationInfo(sbn.getPackageName(),0);
    entry.targetSdk=info.targetSdkVersion;
  }
 catch (  NameNotFoundException ex) {
    Log.e(TAG,""String_Node_Str"" + sbn.getPackageName(),ex);
  }
  entry.autoRedacted=entry.notification.getNotification().publicVersion == null;
  if (MULTIUSER_DEBUG) {
    TextView debug=(TextView)row.findViewById(R.id.debug_info);
    if (debug != null) {
      debug.setVisibility(View.VISIBLE);
      debug.setText(""String_Node_Str"" + mCurrentUserId + ""String_Node_Str""+ entry.notification.getUserId());
    }
  }
  entry.row=row;
  entry.row.setOnActivatedListener(this);
  entry.row.setExpandable(bigContentViewLocal != null);
  applyColorsAndBackgrounds(sbn,entry);
  if (hasUserChangedExpansion) {
    row.setUserExpanded(userExpanded);
  }
  row.setUserLocked(userLocked);
  row.onNotificationUpdated(entry);
  return true;
}",0.9961719348135184
192828,"public void updateNotification(StatusBarNotification notification,RankingMap ranking){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + notification + ""String_Node_Str"");
  final String key=notification.getKey();
  Entry entry=mNotificationData.get(key);
  if (entry == null) {
    return;
  }
 else   if (mHeadsUpEntriesToRemoveOnSwitch.contains(entry)) {
    mHeadsUpEntriesToRemoveOnSwitch.remove(entry);
  }
  Notification n=notification.getNotification();
  mNotificationData.updateRanking(ranking);
  boolean applyInPlace=entry.cacheContentViews(mContext,notification.getNotification());
  boolean shouldPeek=shouldPeek(entry,notification);
  boolean alertAgain=alertAgain(entry,n);
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + applyInPlace + ""String_Node_Str""+ shouldPeek+ ""String_Node_Str""+ alertAgain);
  }
  final StatusBarNotification oldNotification=entry.notification;
  entry.notification=notification;
  mGroupManager.onEntryUpdated(entry,oldNotification);
  boolean updateSuccessful=false;
  if (applyInPlace) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + key);
    try {
      if (entry.icon != null) {
        final StatusBarIcon ic=new StatusBarIcon(notification.getUser(),notification.getPackageName(),n.getSmallIcon(),n.iconLevel,n.number,n.tickerText);
        entry.icon.setNotification(n);
        if (!entry.icon.set(ic)) {
          handleNotificationError(notification,""String_Node_Str"" + ic);
          return;
        }
      }
      updateNotificationViews(entry,notification);
      updateSuccessful=true;
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + notification.getPackageName(),e);
    }
  }
  if (!updateSuccessful) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + key);
    final StatusBarIcon ic=new StatusBarIcon(notification.getUser(),notification.getPackageName(),n.getSmallIcon(),n.iconLevel,n.number,n.tickerText);
    entry.icon.setNotification(n);
    entry.icon.set(ic);
    inflateViews(entry,mStackScroller);
  }
  updateHeadsUp(key,entry,shouldPeek,alertAgain);
  updateNotifications();
  updateNotificationVetoButton(entry.row,notification);
  if (DEBUG) {
    boolean isForCurrentUser=isNotificationForCurrentProfiles(notification);
    Log.d(TAG,""String_Node_Str"" + (isForCurrentUser ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
  }
  setAreThereNotifications();
}","public void updateNotification(StatusBarNotification notification,RankingMap ranking){
  if (DEBUG)   Log.d(TAG,""String_Node_Str"" + notification + ""String_Node_Str"");
  final String key=notification.getKey();
  Entry entry=mNotificationData.get(key);
  if (entry == null) {
    return;
  }
 else   if (mHeadsUpEntriesToRemoveOnSwitch.contains(entry)) {
    mHeadsUpEntriesToRemoveOnSwitch.remove(entry);
  }
  Notification n=notification.getNotification();
  mNotificationData.updateRanking(ranking);
  boolean applyInPlace=entry.cacheContentViews(mContext,notification.getNotification());
  boolean shouldPeek=shouldPeek(entry,notification);
  boolean alertAgain=alertAgain(entry,n);
  if (DEBUG) {
    Log.d(TAG,""String_Node_Str"" + applyInPlace + ""String_Node_Str""+ shouldPeek+ ""String_Node_Str""+ alertAgain);
  }
  final StatusBarNotification oldNotification=entry.notification;
  entry.notification=notification;
  mGroupManager.onEntryUpdated(entry,oldNotification);
  boolean updateSuccessful=false;
  if (applyInPlace) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + key);
    try {
      if (entry.icon != null) {
        final StatusBarIcon ic=new StatusBarIcon(notification.getUser(),notification.getPackageName(),n.getSmallIcon(),n.iconLevel,n.number,n.tickerText);
        entry.icon.setNotification(n);
        if (!entry.icon.set(ic)) {
          handleNotificationError(notification,""String_Node_Str"" + ic);
          return;
        }
      }
      updateNotificationViews(entry,notification);
      updateSuccessful=true;
    }
 catch (    RuntimeException e) {
      Log.w(TAG,""String_Node_Str"" + notification.getPackageName(),e);
    }
  }
  if (!updateSuccessful) {
    if (DEBUG)     Log.d(TAG,""String_Node_Str"" + key);
    final StatusBarIcon ic=new StatusBarIcon(notification.getUser(),notification.getPackageName(),n.getSmallIcon(),n.iconLevel,n.number,n.tickerText);
    entry.icon.setNotification(n);
    entry.icon.set(ic);
    inflateViews(entry,mStackScroller);
  }
  updateHeadsUp(key,entry,shouldPeek,alertAgain);
  updateNotifications();
  bindVetoButtonClickListener(entry.row,notification);
  if (DEBUG) {
    boolean isForCurrentUser=isNotificationForCurrentProfiles(notification);
    Log.d(TAG,""String_Node_Str"" + (isForCurrentUser ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
  }
  setAreThereNotifications();
}",0.99261759122548
192829,"public void onNotificationUpdated(NotificationData.Entry entry){
  mEntry=entry;
  mStatusBarNotification=entry.notification;
  mPrivateLayout.onNotificationUpdated(entry);
  mPublicLayout.onNotificationUpdated(entry);
  updateVetoButton();
  if (mIsSummaryWithChildren) {
    recreateNotificationHeader();
  }
  if (mIconAnimationRunning) {
    setIconAnimationRunning(true);
  }
  if (mNotificationParent != null) {
    mNotificationParent.updateChildrenHeaderAppearance();
  }
  onChildrenCountChanged();
  mPublicLayout.updateExpandButtons(true);
  updateLimits();
}","public void onNotificationUpdated(NotificationData.Entry entry){
  mEntry=entry;
  mStatusBarNotification=entry.notification;
  mPrivateLayout.onNotificationUpdated(entry);
  mPublicLayout.onNotificationUpdated(entry);
  mShowingPublicInitialized=false;
  updateClearability();
  if (mIsSummaryWithChildren) {
    recreateNotificationHeader();
  }
  if (mIconAnimationRunning) {
    setIconAnimationRunning(true);
  }
  if (mNotificationParent != null) {
    mNotificationParent.updateChildrenHeaderAppearance();
  }
  onChildrenCountChanged();
  mPublicLayout.updateExpandButtons(true);
  updateLimits();
}",0.9413763806287172
192830,"public void setHideSensitive(boolean hideSensitive,boolean animated,long delay,long duration){
  boolean oldShowingPublic=mShowingPublic;
  mShowingPublic=mSensitive && hideSensitive;
  if (mShowingPublicInitialized && mShowingPublic == oldShowingPublic) {
    return;
  }
  if (mPublicLayout.getChildCount() == 0)   return;
  if (!animated) {
    mPublicLayout.animate().cancel();
    mPrivateLayout.animate().cancel();
    mPublicLayout.setAlpha(1f);
    mPrivateLayout.setAlpha(1f);
    mPublicLayout.setVisibility(mShowingPublic ? View.VISIBLE : View.INVISIBLE);
    updateChildrenVisibility();
  }
 else {
    animateShowingPublic(delay,duration);
  }
  mPrivateLayout.updateExpandButtons(isExpandable());
  updateVetoButton();
  mShowingPublicInitialized=true;
}","public void setHideSensitive(boolean hideSensitive,boolean animated,long delay,long duration){
  boolean oldShowingPublic=mShowingPublic;
  mShowingPublic=mSensitive && hideSensitive;
  if (mShowingPublicInitialized && mShowingPublic == oldShowingPublic) {
    return;
  }
  if (mPublicLayout.getChildCount() == 0)   return;
  if (!animated) {
    mPublicLayout.animate().cancel();
    mPrivateLayout.animate().cancel();
    mPublicLayout.setAlpha(1f);
    mPrivateLayout.setAlpha(1f);
    mPublicLayout.setVisibility(mShowingPublic ? View.VISIBLE : View.INVISIBLE);
    updateChildrenVisibility();
  }
 else {
    animateShowingPublic(delay,duration);
  }
  mPrivateLayout.updateExpandButtons(isExpandable());
  updateClearability();
  mShowingPublicInitialized=true;
}",0.9856957087126138
192831,"@Override protected void onLayout(boolean changed,int l,int t,int r,int b){
  super.onLayout(changed,l,t,r,b);
  if (mProfileBadge.getVisibility() != View.GONE) {
    int paddingEnd=getPaddingEnd();
    if (getLayoutDirection() == LAYOUT_DIRECTION_RTL) {
      mProfileBadge.layout(paddingEnd,mProfileBadge.getTop(),paddingEnd + mProfileBadge.getMeasuredWidth(),mProfileBadge.getBottom());
    }
 else {
      mProfileBadge.layout(getWidth() - paddingEnd - mProfileBadge.getMeasuredWidth(),mProfileBadge.getTop(),getWidth() - paddingEnd,mProfileBadge.getBottom());
    }
  }
  updateTouchListener();
}","@Override protected void onLayout(boolean changed,int l,int t,int r,int b){
  super.onLayout(changed,l,t,r,b);
  if (mProfileBadge.getVisibility() != View.GONE) {
    int paddingEnd=getPaddingEnd();
    if (mShowWorkBadgeAtEnd) {
      paddingEnd=mContentEndMargin;
    }
    if (getLayoutDirection() == LAYOUT_DIRECTION_RTL) {
      mProfileBadge.layout(paddingEnd,mProfileBadge.getTop(),paddingEnd + mProfileBadge.getMeasuredWidth(),mProfileBadge.getBottom());
    }
 else {
      mProfileBadge.layout(getWidth() - paddingEnd - mProfileBadge.getMeasuredWidth(),mProfileBadge.getTop(),getWidth() - paddingEnd,mProfileBadge.getBottom());
    }
  }
  updateTouchListener();
}",0.9427450980392156
192832,"public NotificationHeaderView(Context context,AttributeSet attrs,int defStyleAttr,int defStyleRes){
  super(context,attrs,defStyleAttr,defStyleRes);
  mHeaderMinWidth=getResources().getDimensionPixelSize(com.android.internal.R.dimen.notification_header_shrink_min_width);
  mExpandTopPadding=(int)(1 * getResources().getDisplayMetrics().density);
}","public NotificationHeaderView(Context context,AttributeSet attrs,int defStyleAttr,int defStyleRes){
  super(context,attrs,defStyleAttr,defStyleRes);
  mHeaderMinWidth=getResources().getDimensionPixelSize(com.android.internal.R.dimen.notification_header_shrink_min_width);
  mContentEndMargin=getResources().getDimensionPixelSize(com.android.internal.R.dimen.notification_content_margin_end);
  mExpandTopPadding=(int)(1 * getResources().getDisplayMetrics().density);
}",0.8529411764705882
192833,"@Override protected void onLayout(boolean changed,int l,int t,int r,int b){
  super.onLayout(changed,l,t,r,b);
  if (mProfileBadge.getVisibility() != View.GONE) {
    int paddingEnd=getPaddingEnd();
    if (getLayoutDirection() == LAYOUT_DIRECTION_RTL) {
      mProfileBadge.layout(paddingEnd,mProfileBadge.getTop(),paddingEnd + mProfileBadge.getMeasuredWidth(),mProfileBadge.getBottom());
    }
 else {
      mProfileBadge.layout(getWidth() - paddingEnd - mProfileBadge.getMeasuredWidth(),mProfileBadge.getTop(),getWidth() - paddingEnd,mProfileBadge.getBottom());
    }
  }
  updateTouchListener();
}","@Override protected void onLayout(boolean changed,int l,int t,int r,int b){
  super.onLayout(changed,l,t,r,b);
  if (mProfileBadge.getVisibility() != View.GONE) {
    int paddingEnd=getPaddingEnd();
    if (mShowWorkBadgeAtEnd) {
      paddingEnd=mContentEndMargin;
    }
    if (getLayoutDirection() == LAYOUT_DIRECTION_RTL) {
      mProfileBadge.layout(paddingEnd,mProfileBadge.getTop(),paddingEnd + mProfileBadge.getMeasuredWidth(),mProfileBadge.getBottom());
    }
 else {
      mProfileBadge.layout(getWidth() - paddingEnd - mProfileBadge.getMeasuredWidth(),mProfileBadge.getTop(),getWidth() - paddingEnd,mProfileBadge.getBottom());
    }
  }
  updateTouchListener();
}",0.9427450980392156
192834,"public NotificationHeaderView(Context context,AttributeSet attrs,int defStyleAttr,int defStyleRes){
  super(context,attrs,defStyleAttr,defStyleRes);
  mHeaderMinWidth=getResources().getDimensionPixelSize(com.android.internal.R.dimen.notification_header_shrink_min_width);
  mExpandTopPadding=(int)(1 * getResources().getDisplayMetrics().density);
}","public NotificationHeaderView(Context context,AttributeSet attrs,int defStyleAttr,int defStyleRes){
  super(context,attrs,defStyleAttr,defStyleRes);
  mHeaderMinWidth=getResources().getDimensionPixelSize(com.android.internal.R.dimen.notification_header_shrink_min_width);
  mContentEndMargin=getResources().getDimensionPixelSize(com.android.internal.R.dimen.notification_content_margin_end);
  mExpandTopPadding=(int)(1 * getResources().getDisplayMetrics().density);
}",0.8529411764705882
192835,"private Activity parseActivityAlias(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivityAlias);
  String targetActivity=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivityAlias_targetActivity,Configuration.NATIVE_CONFIG_VERSION);
  if (targetActivity == null) {
    outError[0]=""String_Node_Str"";
    sa.recycle();
    return null;
  }
  targetActivity=buildClassName(owner.applicationInfo.packageName,targetActivity,outError);
  if (targetActivity == null) {
    sa.recycle();
    return null;
  }
  if (mParseActivityAliasArgs == null) {
    mParseActivityAliasArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivityAlias_name,com.android.internal.R.styleable.AndroidManifestActivityAlias_label,com.android.internal.R.styleable.AndroidManifestActivityAlias_icon,com.android.internal.R.styleable.AndroidManifestActivityAlias_logo,com.android.internal.R.styleable.AndroidManifestActivityAlias_banner,mSeparateProcesses,0,com.android.internal.R.styleable.AndroidManifestActivityAlias_description,com.android.internal.R.styleable.AndroidManifestActivityAlias_enabled);
    mParseActivityAliasArgs.tag=""String_Node_Str"";
  }
  mParseActivityAliasArgs.sa=sa;
  mParseActivityAliasArgs.flags=flags;
  Activity target=null;
  final int NA=owner.activities.size();
  for (int i=0; i < NA; i++) {
    Activity t=owner.activities.get(i);
    if (targetActivity.equals(t.info.name)) {
      target=t;
      break;
    }
  }
  if (target == null) {
    outError[0]=""String_Node_Str"" + targetActivity + ""String_Node_Str"";
    sa.recycle();
    return null;
  }
  ActivityInfo info=new ActivityInfo();
  info.targetActivity=targetActivity;
  info.configChanges=target.info.configChanges;
  info.flags=target.info.flags;
  info.icon=target.info.icon;
  info.logo=target.info.logo;
  info.banner=target.info.banner;
  info.labelRes=target.info.labelRes;
  info.nonLocalizedLabel=target.info.nonLocalizedLabel;
  info.launchMode=target.info.launchMode;
  info.lockTaskLaunchMode=target.info.lockTaskLaunchMode;
  info.processName=target.info.processName;
  if (info.descriptionRes == 0) {
    info.descriptionRes=target.info.descriptionRes;
  }
  info.screenOrientation=target.info.screenOrientation;
  info.taskAffinity=target.info.taskAffinity;
  info.theme=target.info.theme;
  info.softInputMode=target.info.softInputMode;
  info.uiOptions=target.info.uiOptions;
  info.parentActivityName=target.info.parentActivityName;
  info.maxRecents=target.info.maxRecents;
  info.layout=target.info.layout;
  info.resizeMode=target.info.resizeMode;
  Activity a=new Activity(mParseActivityAliasArgs,info);
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported,false);
  }
  String str;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivityAlias_permission,0);
  if (str != null) {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  String parentName=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivityAlias_parentActivityName,Configuration.NATIVE_CONFIG_VERSION);
  if (parentName != null) {
    String parentClassName=buildClassName(a.info.packageName,parentName,outError);
    if (outError[0] == null) {
      a.info.parentActivityName=parentClassName;
    }
 else {
      Log.e(TAG,""String_Node_Str"" + a.info.name + ""String_Node_Str""+ parentName);
      outError[0]=null;
    }
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,true,true,intent,outError)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Slog.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str""+ parser.getPositionDescription());
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Slog.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + parser.getName();
        return null;
      }
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}","private Activity parseActivityAlias(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivityAlias);
  String targetActivity=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivityAlias_targetActivity,Configuration.NATIVE_CONFIG_VERSION);
  if (targetActivity == null) {
    outError[0]=""String_Node_Str"";
    sa.recycle();
    return null;
  }
  targetActivity=buildClassName(owner.applicationInfo.packageName,targetActivity,outError);
  if (targetActivity == null) {
    sa.recycle();
    return null;
  }
  if (mParseActivityAliasArgs == null) {
    mParseActivityAliasArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivityAlias_name,com.android.internal.R.styleable.AndroidManifestActivityAlias_label,com.android.internal.R.styleable.AndroidManifestActivityAlias_icon,com.android.internal.R.styleable.AndroidManifestActivityAlias_logo,com.android.internal.R.styleable.AndroidManifestActivityAlias_banner,mSeparateProcesses,0,com.android.internal.R.styleable.AndroidManifestActivityAlias_description,com.android.internal.R.styleable.AndroidManifestActivityAlias_enabled);
    mParseActivityAliasArgs.tag=""String_Node_Str"";
  }
  mParseActivityAliasArgs.sa=sa;
  mParseActivityAliasArgs.flags=flags;
  Activity target=null;
  final int NA=owner.activities.size();
  for (int i=0; i < NA; i++) {
    Activity t=owner.activities.get(i);
    if (targetActivity.equals(t.info.name)) {
      target=t;
      break;
    }
  }
  if (target == null) {
    outError[0]=""String_Node_Str"" + targetActivity + ""String_Node_Str"";
    sa.recycle();
    return null;
  }
  ActivityInfo info=new ActivityInfo();
  info.targetActivity=targetActivity;
  info.configChanges=target.info.configChanges;
  info.flags=target.info.flags;
  info.icon=target.info.icon;
  info.logo=target.info.logo;
  info.banner=target.info.banner;
  info.labelRes=target.info.labelRes;
  info.nonLocalizedLabel=target.info.nonLocalizedLabel;
  info.launchMode=target.info.launchMode;
  info.lockTaskLaunchMode=target.info.lockTaskLaunchMode;
  info.processName=target.info.processName;
  if (info.descriptionRes == 0) {
    info.descriptionRes=target.info.descriptionRes;
  }
  info.screenOrientation=target.info.screenOrientation;
  info.taskAffinity=target.info.taskAffinity;
  info.theme=target.info.theme;
  info.softInputMode=target.info.softInputMode;
  info.uiOptions=target.info.uiOptions;
  info.parentActivityName=target.info.parentActivityName;
  info.maxRecents=target.info.maxRecents;
  info.layout=target.info.layout;
  info.resizeMode=target.info.resizeMode;
  info.encryptionAware=target.info.encryptionAware;
  Activity a=new Activity(mParseActivityAliasArgs,info);
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported,false);
  }
  String str;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivityAlias_permission,0);
  if (str != null) {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  String parentName=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivityAlias_parentActivityName,Configuration.NATIVE_CONFIG_VERSION);
  if (parentName != null) {
    String parentClassName=buildClassName(a.info.packageName,parentName,outError);
    if (outError[0] == null) {
      a.info.parentActivityName=parentClassName;
    }
 else {
      Log.e(TAG,""String_Node_Str"" + a.info.name + ""String_Node_Str""+ parentName);
      outError[0]=null;
    }
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,true,true,intent,outError)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Slog.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str""+ parser.getPositionDescription());
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Slog.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + parser.getName();
        return null;
      }
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}",0.9950878518798412
192836,"private Activity parseActivityAlias(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivityAlias);
  String targetActivity=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivityAlias_targetActivity,Configuration.NATIVE_CONFIG_VERSION);
  if (targetActivity == null) {
    outError[0]=""String_Node_Str"";
    sa.recycle();
    return null;
  }
  targetActivity=buildClassName(owner.applicationInfo.packageName,targetActivity,outError);
  if (targetActivity == null) {
    sa.recycle();
    return null;
  }
  if (mParseActivityAliasArgs == null) {
    mParseActivityAliasArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivityAlias_name,com.android.internal.R.styleable.AndroidManifestActivityAlias_label,com.android.internal.R.styleable.AndroidManifestActivityAlias_icon,com.android.internal.R.styleable.AndroidManifestActivityAlias_logo,com.android.internal.R.styleable.AndroidManifestActivityAlias_banner,mSeparateProcesses,0,com.android.internal.R.styleable.AndroidManifestActivityAlias_description,com.android.internal.R.styleable.AndroidManifestActivityAlias_enabled);
    mParseActivityAliasArgs.tag=""String_Node_Str"";
  }
  mParseActivityAliasArgs.sa=sa;
  mParseActivityAliasArgs.flags=flags;
  Activity target=null;
  final int NA=owner.activities.size();
  for (int i=0; i < NA; i++) {
    Activity t=owner.activities.get(i);
    if (targetActivity.equals(t.info.name)) {
      target=t;
      break;
    }
  }
  if (target == null) {
    outError[0]=""String_Node_Str"" + targetActivity + ""String_Node_Str"";
    sa.recycle();
    return null;
  }
  ActivityInfo info=new ActivityInfo();
  info.targetActivity=targetActivity;
  info.configChanges=target.info.configChanges;
  info.flags=target.info.flags;
  info.icon=target.info.icon;
  info.logo=target.info.logo;
  info.banner=target.info.banner;
  info.labelRes=target.info.labelRes;
  info.nonLocalizedLabel=target.info.nonLocalizedLabel;
  info.launchMode=target.info.launchMode;
  info.lockTaskLaunchMode=target.info.lockTaskLaunchMode;
  info.processName=target.info.processName;
  if (info.descriptionRes == 0) {
    info.descriptionRes=target.info.descriptionRes;
  }
  info.screenOrientation=target.info.screenOrientation;
  info.taskAffinity=target.info.taskAffinity;
  info.theme=target.info.theme;
  info.softInputMode=target.info.softInputMode;
  info.uiOptions=target.info.uiOptions;
  info.parentActivityName=target.info.parentActivityName;
  info.maxRecents=target.info.maxRecents;
  info.layout=target.info.layout;
  info.resizeMode=target.info.resizeMode;
  Activity a=new Activity(mParseActivityAliasArgs,info);
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported,false);
  }
  String str;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivityAlias_permission,0);
  if (str != null) {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  String parentName=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivityAlias_parentActivityName,Configuration.NATIVE_CONFIG_VERSION);
  if (parentName != null) {
    String parentClassName=buildClassName(a.info.packageName,parentName,outError);
    if (outError[0] == null) {
      a.info.parentActivityName=parentClassName;
    }
 else {
      Log.e(TAG,""String_Node_Str"" + a.info.name + ""String_Node_Str""+ parentName);
      outError[0]=null;
    }
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,true,true,intent,outError)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Slog.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str""+ parser.getPositionDescription());
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Slog.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + parser.getName();
        return null;
      }
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}","private Activity parseActivityAlias(Package owner,Resources res,XmlPullParser parser,AttributeSet attrs,int flags,String[] outError) throws XmlPullParserException, IOException {
  TypedArray sa=res.obtainAttributes(attrs,com.android.internal.R.styleable.AndroidManifestActivityAlias);
  String targetActivity=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivityAlias_targetActivity,Configuration.NATIVE_CONFIG_VERSION);
  if (targetActivity == null) {
    outError[0]=""String_Node_Str"";
    sa.recycle();
    return null;
  }
  targetActivity=buildClassName(owner.applicationInfo.packageName,targetActivity,outError);
  if (targetActivity == null) {
    sa.recycle();
    return null;
  }
  if (mParseActivityAliasArgs == null) {
    mParseActivityAliasArgs=new ParseComponentArgs(owner,outError,com.android.internal.R.styleable.AndroidManifestActivityAlias_name,com.android.internal.R.styleable.AndroidManifestActivityAlias_label,com.android.internal.R.styleable.AndroidManifestActivityAlias_icon,com.android.internal.R.styleable.AndroidManifestActivityAlias_logo,com.android.internal.R.styleable.AndroidManifestActivityAlias_banner,mSeparateProcesses,0,com.android.internal.R.styleable.AndroidManifestActivityAlias_description,com.android.internal.R.styleable.AndroidManifestActivityAlias_enabled);
    mParseActivityAliasArgs.tag=""String_Node_Str"";
  }
  mParseActivityAliasArgs.sa=sa;
  mParseActivityAliasArgs.flags=flags;
  Activity target=null;
  final int NA=owner.activities.size();
  for (int i=0; i < NA; i++) {
    Activity t=owner.activities.get(i);
    if (targetActivity.equals(t.info.name)) {
      target=t;
      break;
    }
  }
  if (target == null) {
    outError[0]=""String_Node_Str"" + targetActivity + ""String_Node_Str"";
    sa.recycle();
    return null;
  }
  ActivityInfo info=new ActivityInfo();
  info.targetActivity=targetActivity;
  info.configChanges=target.info.configChanges;
  info.flags=target.info.flags;
  info.icon=target.info.icon;
  info.logo=target.info.logo;
  info.banner=target.info.banner;
  info.labelRes=target.info.labelRes;
  info.nonLocalizedLabel=target.info.nonLocalizedLabel;
  info.launchMode=target.info.launchMode;
  info.lockTaskLaunchMode=target.info.lockTaskLaunchMode;
  info.processName=target.info.processName;
  if (info.descriptionRes == 0) {
    info.descriptionRes=target.info.descriptionRes;
  }
  info.screenOrientation=target.info.screenOrientation;
  info.taskAffinity=target.info.taskAffinity;
  info.theme=target.info.theme;
  info.softInputMode=target.info.softInputMode;
  info.uiOptions=target.info.uiOptions;
  info.parentActivityName=target.info.parentActivityName;
  info.maxRecents=target.info.maxRecents;
  info.layout=target.info.layout;
  info.resizeMode=target.info.resizeMode;
  info.encryptionAware=target.info.encryptionAware;
  Activity a=new Activity(mParseActivityAliasArgs,info);
  if (outError[0] != null) {
    sa.recycle();
    return null;
  }
  final boolean setExported=sa.hasValue(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported);
  if (setExported) {
    a.info.exported=sa.getBoolean(com.android.internal.R.styleable.AndroidManifestActivityAlias_exported,false);
  }
  String str;
  str=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivityAlias_permission,0);
  if (str != null) {
    a.info.permission=str.length() > 0 ? str.toString().intern() : null;
  }
  String parentName=sa.getNonConfigurationString(com.android.internal.R.styleable.AndroidManifestActivityAlias_parentActivityName,Configuration.NATIVE_CONFIG_VERSION);
  if (parentName != null) {
    String parentClassName=buildClassName(a.info.packageName,parentName,outError);
    if (outError[0] == null) {
      a.info.parentActivityName=parentClassName;
    }
 else {
      Log.e(TAG,""String_Node_Str"" + a.info.name + ""String_Node_Str""+ parentName);
      outError[0]=null;
    }
  }
  sa.recycle();
  if (outError[0] != null) {
    return null;
  }
  int outerDepth=parser.getDepth();
  int type;
  while ((type=parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
      continue;
    }
    if (parser.getName().equals(""String_Node_Str"")) {
      ActivityIntentInfo intent=new ActivityIntentInfo(a);
      if (!parseIntent(res,parser,attrs,true,true,intent,outError)) {
        return null;
      }
      if (intent.countActions() == 0) {
        Slog.w(TAG,""String_Node_Str"" + mArchiveSourcePath + ""String_Node_Str""+ parser.getPositionDescription());
      }
 else {
        a.intents.add(intent);
      }
    }
 else     if (parser.getName().equals(""String_Node_Str"")) {
      if ((a.metaData=parseMetaData(res,parser,attrs,a.metaData,outError)) == null) {
        return null;
      }
    }
 else {
      if (!RIGID_PARSER) {
        Slog.w(TAG,""String_Node_Str"" + parser.getName() + ""String_Node_Str""+ mArchiveSourcePath+ ""String_Node_Str""+ parser.getPositionDescription());
        XmlUtils.skipCurrentTag(parser);
        continue;
      }
 else {
        outError[0]=""String_Node_Str"" + parser.getName();
        return null;
      }
    }
  }
  if (!setExported) {
    a.info.exported=a.intents.size() > 0;
  }
  return a;
}",0.9950878518798412
192837,"private void maybeComputeTransitionDurationScale(){
  if (mMainPanelSize == null || mOverflowPanel == null) {
    int w=mMainPanelSize.getWidth() - mOverflowPanelSize.getWidth();
    int h=mOverflowPanelSize.getHeight() - mMainPanelSize.getHeight();
    mTransitionDurationScale=(int)(Math.sqrt(w * w + h * h) / mContentContainer.getContext().getResources().getDisplayMetrics().density);
  }
}","private void maybeComputeTransitionDurationScale(){
  if (mMainPanelSize != null && mOverflowPanelSize != null) {
    int w=mMainPanelSize.getWidth() - mOverflowPanelSize.getWidth();
    int h=mOverflowPanelSize.getHeight() - mMainPanelSize.getHeight();
    mTransitionDurationScale=(int)(Math.sqrt(w * w + h * h) / mContentContainer.getContext().getResources().getDisplayMetrics().density);
  }
}",0.9645569620253164
192838,"private void maybeComputeTransitionDurationScale(){
  if (mMainPanelSize == null || mOverflowPanel == null) {
    int w=mMainPanelSize.getWidth() - mOverflowPanelSize.getWidth();
    int h=mOverflowPanelSize.getHeight() - mMainPanelSize.getHeight();
    mTransitionDurationScale=(int)(Math.sqrt(w * w + h * h) / mContentContainer.getContext().getResources().getDisplayMetrics().density);
  }
}","private void maybeComputeTransitionDurationScale(){
  if (mMainPanelSize != null && mOverflowPanelSize != null) {
    int w=mMainPanelSize.getWidth() - mOverflowPanelSize.getWidth();
    int h=mOverflowPanelSize.getHeight() - mMainPanelSize.getHeight();
    mTransitionDurationScale=(int)(Math.sqrt(w * w + h * h) / mContentContainer.getContext().getResources().getDisplayMetrics().density);
  }
}",0.9645569620253164
192839,"/** 
 * Prepares a local set of mutable animators based on the constant state. <p> If there are any pending uninflated animators, attempts to inflate them immediately against the provided resources object.
 * @param animatorSet the animator set to which the animators shouldbe added
 * @param res the resources against which to inflate any pendinganimators, or  {@code null} if not available
 */
public void prepareLocalAnimators(@NonNull AnimatorSet animatorSet,@NonNull ValueAnimator.AnimatorUpdateListener updateListener,@Nullable Resources res){
  if (mPendingAnims != null) {
    if (res != null) {
      inflatePendingAnimators(res,null);
    }
 else {
      Log.e(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    }
    mPendingAnims=null;
  }
  final int count=mAnimators == null ? 0 : mAnimators.size();
  if (count > 0) {
    final Animator firstAnim=prepareLocalAnimator(0);
    final AnimatorSet.Builder builder=animatorSet.play(firstAnim);
    for (int i=1; i < count; ++i) {
      final Animator nextAnim=prepareLocalAnimator(i);
      builder.with(nextAnim);
    }
    long totalDuration=animatorSet.getTotalDuration();
    ValueAnimator updateAnim=ValueAnimator.ofFloat(0f,1f);
    if (totalDuration == ValueAnimator.DURATION_INFINITE) {
      updateAnim.setRepeatCount(ValueAnimator.INFINITE);
    }
 else {
      updateAnim.setDuration(totalDuration);
    }
    updateAnim.addUpdateListener(updateListener);
    builder.with(updateAnim);
  }
}","/** 
 * Prepares a local set of mutable animators based on the constant state. <p> If there are any pending uninflated animators, attempts to inflate them immediately against the provided resources object.
 * @param animatorSet the animator set to which the animators shouldbe added
 * @param res the resources against which to inflate any pendinganimators, or  {@code null} if not available
 */
public void prepareLocalAnimators(@NonNull AnimatorSet animatorSet,@Nullable Resources res){
  if (mPendingAnims != null) {
    if (res != null) {
      inflatePendingAnimators(res,null);
    }
 else {
      Log.e(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    }
    mPendingAnims=null;
  }
  final int count=mAnimators == null ? 0 : mAnimators.size();
  if (count > 0) {
    final Animator firstAnim=prepareLocalAnimator(0);
    final AnimatorSet.Builder builder=animatorSet.play(firstAnim);
    for (int i=1; i < count; ++i) {
      final Animator nextAnim=prepareLocalAnimator(i);
      builder.with(nextAnim);
    }
  }
}",0.8270676691729323
192840,"@Override public void draw(Canvas canvas){
  mAnimatedVectorState.mVectorDrawable.draw(canvas);
}","@Override public void draw(Canvas canvas){
  mAnimatedVectorState.mVectorDrawable.draw(canvas);
  if (isStarted()) {
    invalidateSelf();
  }
}",0.8049792531120332
192841,"@NonNull private void ensureAnimatorSet(){
  if (!mHasAnimatorSet) {
    mAnimatedVectorState.prepareLocalAnimators(mAnimatorSet,mUpdateListener,mRes);
    mHasAnimatorSet=true;
    mRes=null;
  }
}","@NonNull private void ensureAnimatorSet(){
  if (!mHasAnimatorSet) {
    mAnimatedVectorState.prepareLocalAnimators(mAnimatorSet,mRes);
    mHasAnimatorSet=true;
    mRes=null;
  }
}",0.9578947368421052
192842,"/** 
 * Prepares a local set of mutable animators based on the constant state. <p> If there are any pending uninflated animators, attempts to inflate them immediately against the provided resources object.
 * @param animatorSet the animator set to which the animators shouldbe added
 * @param res the resources against which to inflate any pendinganimators, or  {@code null} if not available
 */
public void prepareLocalAnimators(@NonNull AnimatorSet animatorSet,@NonNull ValueAnimator.AnimatorUpdateListener updateListener,@Nullable Resources res){
  if (mPendingAnims != null) {
    if (res != null) {
      inflatePendingAnimators(res,null);
    }
 else {
      Log.e(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    }
    mPendingAnims=null;
  }
  final int count=mAnimators == null ? 0 : mAnimators.size();
  if (count > 0) {
    final Animator firstAnim=prepareLocalAnimator(0);
    final AnimatorSet.Builder builder=animatorSet.play(firstAnim);
    for (int i=1; i < count; ++i) {
      final Animator nextAnim=prepareLocalAnimator(i);
      builder.with(nextAnim);
    }
    long totalDuration=animatorSet.getTotalDuration();
    ValueAnimator updateAnim=ValueAnimator.ofFloat(0f,1f);
    if (totalDuration == ValueAnimator.DURATION_INFINITE) {
      updateAnim.setRepeatCount(ValueAnimator.INFINITE);
    }
 else {
      updateAnim.setDuration(totalDuration);
    }
    updateAnim.addUpdateListener(updateListener);
    builder.with(updateAnim);
  }
}","/** 
 * Prepares a local set of mutable animators based on the constant state. <p> If there are any pending uninflated animators, attempts to inflate them immediately against the provided resources object.
 * @param animatorSet the animator set to which the animators shouldbe added
 * @param res the resources against which to inflate any pendinganimators, or  {@code null} if not available
 */
public void prepareLocalAnimators(@NonNull AnimatorSet animatorSet,@Nullable Resources res){
  if (mPendingAnims != null) {
    if (res != null) {
      inflatePendingAnimators(res,null);
    }
 else {
      Log.e(LOGTAG,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    }
    mPendingAnims=null;
  }
  final int count=mAnimators == null ? 0 : mAnimators.size();
  if (count > 0) {
    final Animator firstAnim=prepareLocalAnimator(0);
    final AnimatorSet.Builder builder=animatorSet.play(firstAnim);
    for (int i=1; i < count; ++i) {
      final Animator nextAnim=prepareLocalAnimator(i);
      builder.with(nextAnim);
    }
  }
}",0.8270676691729323
192843,"@Override public void draw(Canvas canvas){
  mAnimatedVectorState.mVectorDrawable.draw(canvas);
}","@Override public void draw(Canvas canvas){
  mAnimatedVectorState.mVectorDrawable.draw(canvas);
  if (isStarted()) {
    invalidateSelf();
  }
}",0.8049792531120332
192844,"@NonNull private void ensureAnimatorSet(){
  if (!mHasAnimatorSet) {
    mAnimatedVectorState.prepareLocalAnimators(mAnimatorSet,mUpdateListener,mRes);
    mHasAnimatorSet=true;
    mRes=null;
  }
}","@NonNull private void ensureAnimatorSet(){
  if (!mHasAnimatorSet) {
    mAnimatedVectorState.prepareLocalAnimators(mAnimatorSet,mRes);
    mHasAnimatorSet=true;
    mRes=null;
  }
}",0.9578947368421052
192845,"public float getAlpha(){
  return mAlpha;
}","public float getAlpha(){
  return mAlpha != null ? mAlpha : 1;
}",0.8037383177570093
192846,"public int getVisibility(){
  return mVisibility;
}","public int getVisibility(){
  return mVisibility != null ? mVisibility : View.VISIBLE;
}",0.7338129496402878
192847,"public float getAlpha(){
  return mAlpha;
}","public float getAlpha(){
  return mAlpha != null ? mAlpha : 1;
}",0.8037383177570093
192848,"public int getVisibility(){
  return mVisibility;
}","public int getVisibility(){
  return mVisibility != null ? mVisibility : View.VISIBLE;
}",0.7338129496402878
192849,"public float getAlpha(){
  return mAlpha;
}","public float getAlpha(){
  return mAlpha != null ? mAlpha : 1;
}",0.8037383177570093
192850,"public int getVisibility(){
  return mVisibility;
}","public int getVisibility(){
  return mVisibility != null ? mVisibility : View.VISIBLE;
}",0.7338129496402878
192851,"@Override public void prepareViewToLeavePool(TaskView tv,Task task,boolean isNewView){
  tv.onTaskBound(task);
  Recents.getTaskLoader().loadTaskData(task);
  tv.setNoUserInteractionState();
  int taskIndex=mStack.indexOfStackTask(task);
  int insertIndex=findTaskViewInsertIndex(task,taskIndex);
  if (isNewView) {
    addView(tv,insertIndex);
  }
 else {
    attachViewToParent(tv,insertIndex,tv.getLayoutParams());
  }
  updateTaskViewsList();
  tv.setCallbacks(this);
  tv.setTouchEnabled(true);
  tv.setClipViewInStack(true);
  if (mFocusedTask == task) {
    tv.setFocusedState(true,false);
    if (mStartTimerIndicator) {
      tv.getHeaderView().startFocusTimerIndicator();
      mStartTimerIndicator=false;
    }
  }
  if (mScreenPinningEnabled && tv.getTask() == mStack.getStackFrontMostTask(false)) {
    tv.showActionButton(false,0);
  }
}","@Override public void prepareViewToLeavePool(TaskView tv,Task task,boolean isNewView){
  int taskIndex=mStack.indexOfStackTask(task);
  int insertIndex=findTaskViewInsertIndex(task,taskIndex);
  if (isNewView) {
    addView(tv,insertIndex);
  }
 else {
    attachViewToParent(tv,insertIndex,tv.getLayoutParams());
  }
  updateTaskViewsList();
  tv.onTaskBound(task);
  Recents.getTaskLoader().loadTaskData(task);
  tv.setNoUserInteractionState();
  tv.setCallbacks(this);
  tv.setTouchEnabled(true);
  tv.setClipViewInStack(true);
  if (mFocusedTask == task) {
    tv.setFocusedState(true,false);
    if (mStartTimerIndicator) {
      tv.getHeaderView().startFocusTimerIndicator();
      mStartTimerIndicator=false;
    }
  }
  if (mScreenPinningEnabled && tv.getTask() == mStack.getStackFrontMostTask(false)) {
    tv.showActionButton(false,0);
  }
}",0.8777908343125734
192852,"@Override public void prepareViewToEnterPool(TaskView tv){
  final Task task=tv.getTask();
  Recents.getTaskLoader().unloadTaskData(task);
  detachViewFromParent(tv);
  updateTaskViewsList();
  tv.resetViewProperties();
  tv.setFocusedState(false,false);
  tv.setClipViewInStack(false);
  if (mScreenPinningEnabled) {
    tv.hideActionButton(false,0,false,null);
  }
}","@Override public void prepareViewToEnterPool(TaskView tv){
  final Task task=tv.getTask();
  Recents.getTaskLoader().unloadTaskData(task);
  tv.resetViewProperties();
  tv.setFocusedState(false,false);
  tv.setClipViewInStack(false);
  if (mScreenPinningEnabled) {
    tv.hideActionButton(false,0,false,null);
  }
  detachViewFromParent(tv);
  updateTaskViewsList();
}",0.8559782608695652
192853,"/** 
 * Called when the task view frame changes, allowing us to move the contents of the header to match the frame changes.
 */
public void onTaskViewSizeChanged(int width,int height){
  if (mTaskViewRect.width() == width && mTaskViewRect.height() == height) {
    return;
  }
  mTaskViewRect.set(0,0,width,height);
  boolean updateMoveTaskButton=mMoveTaskButton.getVisibility() != View.GONE;
  boolean isFreeformTask=(mTask != null) && mTask.isFreeformTask();
  int appIconWidth=mIconView.getMeasuredWidth();
  int activityDescWidth=(mTask != null) ? (int)mTitleView.getPaint().measureText(mTask.title) : mTitleView.getMeasuredWidth();
  int dismissIconWidth=mDismissButton.getMeasuredWidth();
  int moveTaskIconWidth=mMoveTaskButton.getVisibility() == View.VISIBLE ? mMoveTaskButton.getMeasuredWidth() : 0;
  if (isFreeformTask && width < (appIconWidth + dismissIconWidth)) {
    mTitleView.setVisibility(View.INVISIBLE);
    if (updateMoveTaskButton) {
      mMoveTaskButton.setVisibility(View.INVISIBLE);
    }
    mDismissButton.setVisibility(View.INVISIBLE);
  }
 else   if (isFreeformTask && width < (appIconWidth + dismissIconWidth + moveTaskIconWidth)) {
    mTitleView.setVisibility(View.INVISIBLE);
    if (updateMoveTaskButton) {
      mMoveTaskButton.setVisibility(View.INVISIBLE);
    }
    mDismissButton.setVisibility(View.VISIBLE);
  }
 else   if (isFreeformTask && width < (appIconWidth + dismissIconWidth + moveTaskIconWidth+ activityDescWidth)) {
    mTitleView.setVisibility(View.INVISIBLE);
    if (updateMoveTaskButton) {
      mMoveTaskButton.setVisibility(View.VISIBLE);
    }
    mDismissButton.setVisibility(View.VISIBLE);
  }
 else {
    mTitleView.setVisibility(View.VISIBLE);
    if (updateMoveTaskButton) {
      mMoveTaskButton.setVisibility(View.VISIBLE);
    }
    mDismissButton.setVisibility(View.VISIBLE);
  }
  if (updateMoveTaskButton) {
    mMoveTaskButton.setTranslationX(width - getMeasuredWidth());
  }
  mDismissButton.setTranslationX(width - getMeasuredWidth());
  invalidate();
}","/** 
 * Called when the task view frame changes, allowing us to move the contents of the header to match the frame changes.
 */
public void onTaskViewSizeChanged(int width,int height){
  mTaskViewRect.set(0,0,width,height);
  boolean updateMoveTaskButton=mMoveTaskButton.getVisibility() != View.GONE;
  boolean isFreeformTask=(mTask != null) && mTask.isFreeformTask();
  int appIconWidth=mIconView.getMeasuredWidth();
  int activityDescWidth=(mTask != null) ? (int)mTitleView.getPaint().measureText(mTask.title) : mTitleView.getMeasuredWidth();
  int dismissIconWidth=mDismissButton.getMeasuredWidth();
  int moveTaskIconWidth=mMoveTaskButton.getVisibility() == View.VISIBLE ? mMoveTaskButton.getMeasuredWidth() : 0;
  if (isFreeformTask && width < (appIconWidth + dismissIconWidth)) {
    mTitleView.setVisibility(View.INVISIBLE);
    if (updateMoveTaskButton) {
      mMoveTaskButton.setVisibility(View.INVISIBLE);
    }
    mDismissButton.setVisibility(View.INVISIBLE);
  }
 else   if (isFreeformTask && width < (appIconWidth + dismissIconWidth + moveTaskIconWidth)) {
    mTitleView.setVisibility(View.INVISIBLE);
    if (updateMoveTaskButton) {
      mMoveTaskButton.setVisibility(View.INVISIBLE);
    }
    mDismissButton.setVisibility(View.VISIBLE);
  }
 else   if (isFreeformTask && width < (appIconWidth + dismissIconWidth + moveTaskIconWidth+ activityDescWidth)) {
    mTitleView.setVisibility(View.INVISIBLE);
    if (updateMoveTaskButton) {
      mMoveTaskButton.setVisibility(View.VISIBLE);
    }
    mDismissButton.setVisibility(View.VISIBLE);
  }
 else {
    mTitleView.setVisibility(View.VISIBLE);
    if (updateMoveTaskButton) {
      mMoveTaskButton.setVisibility(View.VISIBLE);
    }
    mDismissButton.setVisibility(View.VISIBLE);
  }
  if (updateMoveTaskButton) {
    mMoveTaskButton.setTranslationX(width - getMeasuredWidth());
  }
  mDismissButton.setTranslationX(width - getMeasuredWidth());
  invalidate();
}",0.976755937342092
192854,"/** 
 * Updates the visibility of the the thumbnail. 
 */
void updateThumbnailVisibility(int clipBottom){
  boolean invisible=mTaskBar != null && (getHeight() - clipBottom) <= mTaskBar.getHeight();
  if (invisible != mInvisible) {
    mInvisible=invisible;
    if (!mInvisible) {
      updateThumbnailPaintFilter();
    }
    invalidate();
  }
}","/** 
 * Updates the visibility of the the thumbnail. 
 */
void updateThumbnailVisibility(int clipBottom){
  boolean invisible=mTaskBar != null && (getHeight() - clipBottom) <= mTaskBar.getHeight();
  if (invisible != mInvisible) {
    mInvisible=invisible;
    if (!mInvisible) {
      updateThumbnailPaintFilter();
    }
  }
}",0.9732142857142856
192855,"@Override public void setClipToActualHeight(boolean clipToActualHeight){
  super.setClipToActualHeight(clipToActualHeight);
  getShowingLayout().setClipToActualHeight(clipToActualHeight);
}","@Override public void setClipToActualHeight(boolean clipToActualHeight){
  super.setClipToActualHeight(clipToActualHeight || isUserLocked());
  getShowingLayout().setClipToActualHeight(clipToActualHeight || isUserLocked());
}",0.9130434782608696
192856,"/** 
 * Sets the focused state.
 */
public void setFocusState(float focusState){
  mFocusState=focusState;
  updateFrontBackTransforms();
}","/** 
 * Sets the focused state.
 */
public void setFocusState(float focusState){
  float prevFocusState=mFocusState;
  mFocusState=focusState;
  updateFrontBackTransforms();
  if (mCb != null) {
    mCb.onFocusStateChanged(prevFocusState,focusState);
  }
}",0.7037974683544304
192857,"public TaskStackLayoutAlgorithm(Context context){
  Resources res=context.getResources();
  mFocusedRange=new Range(res.getFloat(R.integer.recents_layout_focused_range_min),res.getFloat(R.integer.recents_layout_focused_range_max));
  mUnfocusedRange=new Range(res.getFloat(R.integer.recents_layout_unfocused_range_min),res.getFloat(R.integer.recents_layout_unfocused_range_max));
  mFocusState=getDefaultFocusState();
  mFocusedPeekHeight=res.getDimensionPixelSize(R.dimen.recents_layout_focused_peek_size);
  mMinTranslationZ=res.getDimensionPixelSize(R.dimen.recents_task_view_z_min);
  mMaxTranslationZ=res.getDimensionPixelSize(R.dimen.recents_task_view_z_max);
  mContext=context;
  mFreeformLayoutAlgorithm=new FreeformWorkspaceLayoutAlgorithm(context);
  mLinearOutSlowInInterpolator=AnimationUtils.loadInterpolator(context,com.android.internal.R.interpolator.linear_out_slow_in);
}","public TaskStackLayoutAlgorithm(Context context,TaskStackLayoutAlgorithmCallbacks cb){
  Resources res=context.getResources();
  mContext=context;
  mCb=cb;
  mFocusedRange=new Range(res.getFloat(R.integer.recents_layout_focused_range_min),res.getFloat(R.integer.recents_layout_focused_range_max));
  mUnfocusedRange=new Range(res.getFloat(R.integer.recents_layout_unfocused_range_min),res.getFloat(R.integer.recents_layout_unfocused_range_max));
  mFocusState=getDefaultFocusState();
  mFocusedPeekHeight=res.getDimensionPixelSize(R.dimen.recents_layout_focused_peek_size);
  mMinTranslationZ=res.getDimensionPixelSize(R.dimen.recents_task_view_z_min);
  mMaxTranslationZ=res.getDimensionPixelSize(R.dimen.recents_task_view_z_max);
  mFreeformLayoutAlgorithm=new FreeformWorkspaceLayoutAlgorithm(context);
  mLinearOutSlowInInterpolator=AnimationUtils.loadInterpolator(context,com.android.internal.R.interpolator.linear_out_slow_in);
}",0.9523287671232876
192858,"public TaskStackView(Context context,TaskStack stack){
  super(context);
  SystemServicesProxy ssp=Recents.getSystemServices();
  Resources res=context.getResources();
  setStack(stack);
  mViewPool=new ViewPool<>(context,this);
  mInflater=LayoutInflater.from(context);
  mLayoutAlgorithm=new TaskStackLayoutAlgorithm(context);
  mStackScroller=new TaskStackViewScroller(context,mLayoutAlgorithm);
  mStackScroller.setCallbacks(this);
  mTouchHandler=new TaskStackViewTouchHandler(context,this,mStackScroller);
  mAnimationHelper=new TaskStackAnimationHelper(context,this);
  mFastOutSlowInInterpolator=AnimationUtils.loadInterpolator(context,com.android.internal.R.interpolator.fast_out_slow_in);
  mTaskCornerRadiusPx=res.getDimensionPixelSize(R.dimen.recents_task_view_rounded_corners_radius);
  mDividerSize=ssp.getDockedDividerSize(context);
  int taskBarDismissDozeDelaySeconds=getResources().getInteger(R.integer.recents_task_bar_dismiss_delay_seconds);
  mUIDozeTrigger=new DozeTrigger(taskBarDismissDozeDelaySeconds,new Runnable(){
    @Override public void run(){
      List<TaskView> taskViews=getTaskViews();
      int taskViewCount=taskViews.size();
      for (int i=0; i < taskViewCount; i++) {
        TaskView tv=taskViews.get(i);
        tv.startNoUserInteractionAnimation();
      }
    }
  }
);
  setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_YES);
  mFreeformWorkspaceBackground=(GradientDrawable)getContext().getDrawable(R.drawable.recents_freeform_workspace_bg);
  mFreeformWorkspaceBackground.setCallback(this);
  if (ssp.hasFreeformWorkspaceSupport()) {
    mFreeformWorkspaceBackground.setColor(getContext().getColor(R.color.recents_freeform_workspace_bg_color));
  }
}","public TaskStackView(Context context,TaskStack stack){
  super(context);
  SystemServicesProxy ssp=Recents.getSystemServices();
  Resources res=context.getResources();
  setStack(stack);
  mViewPool=new ViewPool<>(context,this);
  mInflater=LayoutInflater.from(context);
  mLayoutAlgorithm=new TaskStackLayoutAlgorithm(context,this);
  mStackScroller=new TaskStackViewScroller(context,this,mLayoutAlgorithm);
  mTouchHandler=new TaskStackViewTouchHandler(context,this,mStackScroller);
  mAnimationHelper=new TaskStackAnimationHelper(context,this);
  mFastOutSlowInInterpolator=AnimationUtils.loadInterpolator(context,com.android.internal.R.interpolator.fast_out_slow_in);
  mTaskCornerRadiusPx=res.getDimensionPixelSize(R.dimen.recents_task_view_rounded_corners_radius);
  mDividerSize=ssp.getDockedDividerSize(context);
  int taskBarDismissDozeDelaySeconds=getResources().getInteger(R.integer.recents_task_bar_dismiss_delay_seconds);
  mUIDozeTrigger=new DozeTrigger(taskBarDismissDozeDelaySeconds,new Runnable(){
    @Override public void run(){
      List<TaskView> taskViews=getTaskViews();
      int taskViewCount=taskViews.size();
      for (int i=0; i < taskViewCount; i++) {
        TaskView tv=taskViews.get(i);
        tv.startNoUserInteractionAnimation();
      }
    }
  }
);
  setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_YES);
  mFreeformWorkspaceBackground=(GradientDrawable)getContext().getDrawable(R.drawable.recents_freeform_workspace_bg);
  mFreeformWorkspaceBackground.setCallback(this);
  if (ssp.hasFreeformWorkspaceSupport()) {
    mFreeformWorkspaceBackground.setColor(getContext().getColor(R.color.recents_freeform_workspace_bg_color));
  }
}",0.986156111929308
192859,"/** 
 * Sets the focused task to the provided (bounded taskIndex).
 * @return whether or not the stack will scroll as a part of this focus change
 */
private boolean setFocusedTask(int taskIndex,boolean scrollToTask,final boolean requestViewFocus,final boolean showTimerIndicator){
  int newFocusedTaskIndex=mStack.getTaskCount() > 0 ? Math.max(0,Math.min(mStack.getTaskCount() - 1,taskIndex)) : -1;
  final Task newFocusedTask=(newFocusedTaskIndex != -1) ? mStack.getStackTasks().get(newFocusedTaskIndex) : null;
  if (mFocusedTask != null) {
    if (showTimerIndicator) {
      final TaskView tv=getChildViewForTask(mFocusedTask);
      if (tv != null) {
        tv.getHeaderView().cancelFocusTimerIndicator();
      }
    }
    resetFocusedTask(mFocusedTask);
  }
  boolean willScroll=false;
  mFocusedTask=newFocusedTask;
  if (newFocusedTask != null) {
    if (showTimerIndicator) {
      final TaskView tv=getChildViewForTask(mFocusedTask);
      if (tv != null) {
        tv.getHeaderView().startFocusTimerIndicator();
      }
 else {
        mStartTimerIndicator=true;
      }
    }
    Runnable focusTaskRunnable=new Runnable(){
      @Override public void run(){
        final TaskView tv=getChildViewForTask(newFocusedTask);
        if (tv != null) {
          tv.setFocusedState(true,requestViewFocus);
        }
      }
    }
;
    if (scrollToTask) {
      float newScroll=mLayoutAlgorithm.getStackScrollForTask(newFocusedTask);
      if (Float.compare(newScroll,mStackScroller.getStackScroll()) != 0) {
        mStackScroller.animateScroll(mStackScroller.getStackScroll(),newScroll,focusTaskRunnable);
        willScroll=true;
        if (!mEnterAnimationComplete) {
          cancelAllTaskViewAnimations();
        }
      }
 else {
        focusTaskRunnable.run();
      }
      mLayoutAlgorithm.animateFocusState(TaskStackLayoutAlgorithm.STATE_FOCUSED);
    }
 else {
      focusTaskRunnable.run();
    }
  }
  return willScroll;
}","/** 
 * Sets the focused task to the provided (bounded taskIndex).
 * @return whether or not the stack will scroll as a part of this focus change
 */
private boolean setFocusedTask(int taskIndex,boolean scrollToTask,final boolean requestViewFocus,final boolean showTimerIndicator){
  int newFocusedTaskIndex=mStack.getTaskCount() > 0 ? Math.max(0,Math.min(mStack.getTaskCount() - 1,taskIndex)) : -1;
  final Task newFocusedTask=(newFocusedTaskIndex != -1) ? mStack.getStackTasks().get(newFocusedTaskIndex) : null;
  if (mFocusedTask != null) {
    if (showTimerIndicator) {
      final TaskView tv=getChildViewForTask(mFocusedTask);
      if (tv != null) {
        tv.getHeaderView().cancelFocusTimerIndicator();
      }
    }
    resetFocusedTask(mFocusedTask);
  }
  boolean willScroll=false;
  mFocusedTask=newFocusedTask;
  if (newFocusedTask != null) {
    if (showTimerIndicator) {
      final TaskView tv=getChildViewForTask(mFocusedTask);
      if (tv != null) {
        tv.getHeaderView().startFocusTimerIndicator();
      }
 else {
        mStartTimerIndicator=true;
      }
    }
    Runnable focusTaskRunnable=new Runnable(){
      @Override public void run(){
        final TaskView tv=getChildViewForTask(newFocusedTask);
        if (tv != null) {
          tv.setFocusedState(true,requestViewFocus);
        }
      }
    }
;
    if (scrollToTask) {
      if (!mEnterAnimationComplete) {
        cancelAllTaskViewAnimations();
      }
      float newScroll=mLayoutAlgorithm.getStackScrollForTask(newFocusedTask);
      if (Float.compare(newScroll,mStackScroller.getStackScroll()) != 0) {
        mStackScroller.animateScroll(mStackScroller.getStackScroll(),newScroll,focusTaskRunnable);
        willScroll=true;
      }
 else {
        focusTaskRunnable.run();
      }
      mLayoutAlgorithm.animateFocusState(TaskStackLayoutAlgorithm.STATE_FOCUSED);
    }
 else {
      focusTaskRunnable.run();
    }
  }
  return willScroll;
}",0.9547790339157246
192860,"/** 
 * Posts an update to synchronize the   {@link TaskView}s with the stack on the next frame.
 */
void relayoutTaskViewsOnNextFrame(TaskViewAnimation animation){
  mDeferredTaskViewLayoutAnimation=animation;
  postInvalidateOnAnimation();
}","/** 
 * Posts an update to synchronize the   {@link TaskView}s with the stack on the next frame.
 */
void relayoutTaskViewsOnNextFrame(TaskViewAnimation animation){
  mDeferredTaskViewLayoutAnimation=animation;
  invalidate();
}",0.9639065817409768
192861,"public TaskStackViewScroller(Context context,TaskStackLayoutAlgorithm layoutAlgorithm){
  mContext=context;
  mScroller=new OverScroller(context);
  mLayoutAlgorithm=layoutAlgorithm;
  mLinearOutSlowInInterpolator=AnimationUtils.loadInterpolator(context,com.android.internal.R.interpolator.linear_out_slow_in);
}","public TaskStackViewScroller(Context context,TaskStackViewScrollerCallbacks cb,TaskStackLayoutAlgorithm layoutAlgorithm){
  mContext=context;
  mCb=cb;
  mScroller=new OverScroller(context);
  mLayoutAlgorithm=layoutAlgorithm;
  mLinearOutSlowInInterpolator=AnimationUtils.loadInterpolator(context,com.android.internal.R.interpolator.linear_out_slow_in);
}",0.934131736526946
192862,"/** 
 * Animates the stack scroll 
 */
void animateScroll(float curScroll,float newScroll,final Runnable postRunnable){
  if (mScrollAnimator != null && mScrollAnimator.isRunning()) {
    setStackScroll(mFinalAnimatedScroll);
    mScroller.startScroll(0,progressToScrollRange(mFinalAnimatedScroll),0,0,0);
  }
  stopScroller();
  stopBoundScrollAnimation();
  mFinalAnimatedScroll=newScroll;
  mScrollAnimator=ObjectAnimator.ofFloat(this,""String_Node_Str"",curScroll,newScroll);
  mScrollAnimator.setDuration(mContext.getResources().getInteger(R.integer.recents_animate_task_stack_scroll_duration));
  mScrollAnimator.setInterpolator(mLinearOutSlowInInterpolator);
  mScrollAnimator.addListener(new AnimatorListenerAdapter(){
    @Override public void onAnimationEnd(    Animator animation){
      if (postRunnable != null) {
        postRunnable.run();
      }
      mScrollAnimator.removeAllListeners();
    }
  }
);
  mScrollAnimator.start();
}","/** 
 * Animates the stack scroll 
 */
void animateScroll(float curScroll,float newScroll,final Runnable postRunnable){
  if (mScrollAnimator != null && mScrollAnimator.isRunning()) {
    setStackScroll(mFinalAnimatedScroll);
    mScroller.startScroll(0,progressToScrollRange(mFinalAnimatedScroll),0,0,0);
  }
  stopScroller();
  stopBoundScrollAnimation();
  mFinalAnimatedScroll=newScroll;
  mScrollAnimator=ObjectAnimator.ofFloat(this,STACK_SCROLL,curScroll,newScroll);
  mScrollAnimator.setDuration(mContext.getResources().getInteger(R.integer.recents_animate_task_stack_scroll_duration));
  mScrollAnimator.setInterpolator(mLinearOutSlowInInterpolator);
  mScrollAnimator.addListener(new AnimatorListenerAdapter(){
    @Override public void onAnimationEnd(    Animator animation){
      if (postRunnable != null) {
        postRunnable.run();
      }
      mScrollAnimator.removeAllListeners();
    }
  }
);
  mScrollAnimator.start();
}",0.985691573926868
192863,"/** 
 * Sets the focused state.
 */
public void setFocusState(float focusState){
  mFocusState=focusState;
  updateFrontBackTransforms();
}","/** 
 * Sets the focused state.
 */
public void setFocusState(float focusState){
  float prevFocusState=mFocusState;
  mFocusState=focusState;
  updateFrontBackTransforms();
  if (mCb != null) {
    mCb.onFocusStateChanged(prevFocusState,focusState);
  }
}",0.7037974683544304
192864,"public TaskStackLayoutAlgorithm(Context context){
  Resources res=context.getResources();
  mFocusedRange=new Range(res.getFloat(R.integer.recents_layout_focused_range_min),res.getFloat(R.integer.recents_layout_focused_range_max));
  mUnfocusedRange=new Range(res.getFloat(R.integer.recents_layout_unfocused_range_min),res.getFloat(R.integer.recents_layout_unfocused_range_max));
  mFocusState=getDefaultFocusState();
  mFocusedPeekHeight=res.getDimensionPixelSize(R.dimen.recents_layout_focused_peek_size);
  mMinTranslationZ=res.getDimensionPixelSize(R.dimen.recents_task_view_z_min);
  mMaxTranslationZ=res.getDimensionPixelSize(R.dimen.recents_task_view_z_max);
  mContext=context;
  mFreeformLayoutAlgorithm=new FreeformWorkspaceLayoutAlgorithm(context);
  mLinearOutSlowInInterpolator=AnimationUtils.loadInterpolator(context,com.android.internal.R.interpolator.linear_out_slow_in);
}","public TaskStackLayoutAlgorithm(Context context,TaskStackLayoutAlgorithmCallbacks cb){
  Resources res=context.getResources();
  mContext=context;
  mCb=cb;
  mFocusedRange=new Range(res.getFloat(R.integer.recents_layout_focused_range_min),res.getFloat(R.integer.recents_layout_focused_range_max));
  mUnfocusedRange=new Range(res.getFloat(R.integer.recents_layout_unfocused_range_min),res.getFloat(R.integer.recents_layout_unfocused_range_max));
  mFocusState=getDefaultFocusState();
  mFocusedPeekHeight=res.getDimensionPixelSize(R.dimen.recents_layout_focused_peek_size);
  mMinTranslationZ=res.getDimensionPixelSize(R.dimen.recents_task_view_z_min);
  mMaxTranslationZ=res.getDimensionPixelSize(R.dimen.recents_task_view_z_max);
  mFreeformLayoutAlgorithm=new FreeformWorkspaceLayoutAlgorithm(context);
  mLinearOutSlowInInterpolator=AnimationUtils.loadInterpolator(context,com.android.internal.R.interpolator.linear_out_slow_in);
}",0.9523287671232876
192865,"public TaskStackView(Context context,TaskStack stack){
  super(context);
  SystemServicesProxy ssp=Recents.getSystemServices();
  Resources res=context.getResources();
  setStack(stack);
  mViewPool=new ViewPool<>(context,this);
  mInflater=LayoutInflater.from(context);
  mLayoutAlgorithm=new TaskStackLayoutAlgorithm(context);
  mStackScroller=new TaskStackViewScroller(context,mLayoutAlgorithm);
  mStackScroller.setCallbacks(this);
  mTouchHandler=new TaskStackViewTouchHandler(context,this,mStackScroller);
  mAnimationHelper=new TaskStackAnimationHelper(context,this);
  mFastOutSlowInInterpolator=AnimationUtils.loadInterpolator(context,com.android.internal.R.interpolator.fast_out_slow_in);
  mTaskCornerRadiusPx=res.getDimensionPixelSize(R.dimen.recents_task_view_rounded_corners_radius);
  mDividerSize=ssp.getDockedDividerSize(context);
  int taskBarDismissDozeDelaySeconds=getResources().getInteger(R.integer.recents_task_bar_dismiss_delay_seconds);
  mUIDozeTrigger=new DozeTrigger(taskBarDismissDozeDelaySeconds,new Runnable(){
    @Override public void run(){
      List<TaskView> taskViews=getTaskViews();
      int taskViewCount=taskViews.size();
      for (int i=0; i < taskViewCount; i++) {
        TaskView tv=taskViews.get(i);
        tv.startNoUserInteractionAnimation();
      }
    }
  }
);
  setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_YES);
  mFreeformWorkspaceBackground=(GradientDrawable)getContext().getDrawable(R.drawable.recents_freeform_workspace_bg);
  mFreeformWorkspaceBackground.setCallback(this);
  if (ssp.hasFreeformWorkspaceSupport()) {
    mFreeformWorkspaceBackground.setColor(getContext().getColor(R.color.recents_freeform_workspace_bg_color));
  }
}","public TaskStackView(Context context,TaskStack stack){
  super(context);
  SystemServicesProxy ssp=Recents.getSystemServices();
  Resources res=context.getResources();
  setStack(stack);
  mViewPool=new ViewPool<>(context,this);
  mInflater=LayoutInflater.from(context);
  mLayoutAlgorithm=new TaskStackLayoutAlgorithm(context,this);
  mStackScroller=new TaskStackViewScroller(context,this,mLayoutAlgorithm);
  mTouchHandler=new TaskStackViewTouchHandler(context,this,mStackScroller);
  mAnimationHelper=new TaskStackAnimationHelper(context,this);
  mFastOutSlowInInterpolator=AnimationUtils.loadInterpolator(context,com.android.internal.R.interpolator.fast_out_slow_in);
  mTaskCornerRadiusPx=res.getDimensionPixelSize(R.dimen.recents_task_view_rounded_corners_radius);
  mDividerSize=ssp.getDockedDividerSize(context);
  int taskBarDismissDozeDelaySeconds=getResources().getInteger(R.integer.recents_task_bar_dismiss_delay_seconds);
  mUIDozeTrigger=new DozeTrigger(taskBarDismissDozeDelaySeconds,new Runnable(){
    @Override public void run(){
      List<TaskView> taskViews=getTaskViews();
      int taskViewCount=taskViews.size();
      for (int i=0; i < taskViewCount; i++) {
        TaskView tv=taskViews.get(i);
        tv.startNoUserInteractionAnimation();
      }
    }
  }
);
  setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_YES);
  mFreeformWorkspaceBackground=(GradientDrawable)getContext().getDrawable(R.drawable.recents_freeform_workspace_bg);
  mFreeformWorkspaceBackground.setCallback(this);
  if (ssp.hasFreeformWorkspaceSupport()) {
    mFreeformWorkspaceBackground.setColor(getContext().getColor(R.color.recents_freeform_workspace_bg_color));
  }
}",0.986156111929308
192866,"/** 
 * Sets the focused task to the provided (bounded taskIndex).
 * @return whether or not the stack will scroll as a part of this focus change
 */
private boolean setFocusedTask(int taskIndex,boolean scrollToTask,final boolean requestViewFocus,final boolean showTimerIndicator){
  int newFocusedTaskIndex=mStack.getTaskCount() > 0 ? Math.max(0,Math.min(mStack.getTaskCount() - 1,taskIndex)) : -1;
  final Task newFocusedTask=(newFocusedTaskIndex != -1) ? mStack.getStackTasks().get(newFocusedTaskIndex) : null;
  if (mFocusedTask != null) {
    if (showTimerIndicator) {
      final TaskView tv=getChildViewForTask(mFocusedTask);
      if (tv != null) {
        tv.getHeaderView().cancelFocusTimerIndicator();
      }
    }
    resetFocusedTask(mFocusedTask);
  }
  boolean willScroll=false;
  mFocusedTask=newFocusedTask;
  if (newFocusedTask != null) {
    if (showTimerIndicator) {
      final TaskView tv=getChildViewForTask(mFocusedTask);
      if (tv != null) {
        tv.getHeaderView().startFocusTimerIndicator();
      }
 else {
        mStartTimerIndicator=true;
      }
    }
    Runnable focusTaskRunnable=new Runnable(){
      @Override public void run(){
        final TaskView tv=getChildViewForTask(newFocusedTask);
        if (tv != null) {
          tv.setFocusedState(true,requestViewFocus);
        }
      }
    }
;
    if (scrollToTask) {
      float newScroll=mLayoutAlgorithm.getStackScrollForTask(newFocusedTask);
      if (Float.compare(newScroll,mStackScroller.getStackScroll()) != 0) {
        mStackScroller.animateScroll(mStackScroller.getStackScroll(),newScroll,focusTaskRunnable);
        willScroll=true;
        if (!mEnterAnimationComplete) {
          cancelAllTaskViewAnimations();
        }
      }
 else {
        focusTaskRunnable.run();
      }
      mLayoutAlgorithm.animateFocusState(TaskStackLayoutAlgorithm.STATE_FOCUSED);
    }
 else {
      focusTaskRunnable.run();
    }
  }
  return willScroll;
}","/** 
 * Sets the focused task to the provided (bounded taskIndex).
 * @return whether or not the stack will scroll as a part of this focus change
 */
private boolean setFocusedTask(int taskIndex,boolean scrollToTask,final boolean requestViewFocus,final boolean showTimerIndicator){
  int newFocusedTaskIndex=mStack.getTaskCount() > 0 ? Math.max(0,Math.min(mStack.getTaskCount() - 1,taskIndex)) : -1;
  final Task newFocusedTask=(newFocusedTaskIndex != -1) ? mStack.getStackTasks().get(newFocusedTaskIndex) : null;
  if (mFocusedTask != null) {
    if (showTimerIndicator) {
      final TaskView tv=getChildViewForTask(mFocusedTask);
      if (tv != null) {
        tv.getHeaderView().cancelFocusTimerIndicator();
      }
    }
    resetFocusedTask(mFocusedTask);
  }
  boolean willScroll=false;
  mFocusedTask=newFocusedTask;
  if (newFocusedTask != null) {
    if (showTimerIndicator) {
      final TaskView tv=getChildViewForTask(mFocusedTask);
      if (tv != null) {
        tv.getHeaderView().startFocusTimerIndicator();
      }
 else {
        mStartTimerIndicator=true;
      }
    }
    Runnable focusTaskRunnable=new Runnable(){
      @Override public void run(){
        final TaskView tv=getChildViewForTask(newFocusedTask);
        if (tv != null) {
          tv.setFocusedState(true,requestViewFocus);
        }
      }
    }
;
    if (scrollToTask) {
      if (!mEnterAnimationComplete) {
        cancelAllTaskViewAnimations();
      }
      float newScroll=mLayoutAlgorithm.getStackScrollForTask(newFocusedTask);
      if (Float.compare(newScroll,mStackScroller.getStackScroll()) != 0) {
        mStackScroller.animateScroll(mStackScroller.getStackScroll(),newScroll,focusTaskRunnable);
        willScroll=true;
      }
 else {
        focusTaskRunnable.run();
      }
      mLayoutAlgorithm.animateFocusState(TaskStackLayoutAlgorithm.STATE_FOCUSED);
    }
 else {
      focusTaskRunnable.run();
    }
  }
  return willScroll;
}",0.9547790339157246
192867,"/** 
 * Posts an update to synchronize the   {@link TaskView}s with the stack on the next frame.
 */
void relayoutTaskViewsOnNextFrame(TaskViewAnimation animation){
  mDeferredTaskViewLayoutAnimation=animation;
  postInvalidateOnAnimation();
}","/** 
 * Posts an update to synchronize the   {@link TaskView}s with the stack on the next frame.
 */
void relayoutTaskViewsOnNextFrame(TaskViewAnimation animation){
  mDeferredTaskViewLayoutAnimation=animation;
  invalidate();
}",0.9639065817409768
192868,"public TaskStackViewScroller(Context context,TaskStackLayoutAlgorithm layoutAlgorithm){
  mContext=context;
  mScroller=new OverScroller(context);
  mLayoutAlgorithm=layoutAlgorithm;
  mLinearOutSlowInInterpolator=AnimationUtils.loadInterpolator(context,com.android.internal.R.interpolator.linear_out_slow_in);
}","public TaskStackViewScroller(Context context,TaskStackViewScrollerCallbacks cb,TaskStackLayoutAlgorithm layoutAlgorithm){
  mContext=context;
  mCb=cb;
  mScroller=new OverScroller(context);
  mLayoutAlgorithm=layoutAlgorithm;
  mLinearOutSlowInInterpolator=AnimationUtils.loadInterpolator(context,com.android.internal.R.interpolator.linear_out_slow_in);
}",0.934131736526946
192869,"/** 
 * Animates the stack scroll 
 */
void animateScroll(float curScroll,float newScroll,final Runnable postRunnable){
  if (mScrollAnimator != null && mScrollAnimator.isRunning()) {
    setStackScroll(mFinalAnimatedScroll);
    mScroller.startScroll(0,progressToScrollRange(mFinalAnimatedScroll),0,0,0);
  }
  stopScroller();
  stopBoundScrollAnimation();
  mFinalAnimatedScroll=newScroll;
  mScrollAnimator=ObjectAnimator.ofFloat(this,""String_Node_Str"",curScroll,newScroll);
  mScrollAnimator.setDuration(mContext.getResources().getInteger(R.integer.recents_animate_task_stack_scroll_duration));
  mScrollAnimator.setInterpolator(mLinearOutSlowInInterpolator);
  mScrollAnimator.addListener(new AnimatorListenerAdapter(){
    @Override public void onAnimationEnd(    Animator animation){
      if (postRunnable != null) {
        postRunnable.run();
      }
      mScrollAnimator.removeAllListeners();
    }
  }
);
  mScrollAnimator.start();
}","/** 
 * Animates the stack scroll 
 */
void animateScroll(float curScroll,float newScroll,final Runnable postRunnable){
  if (mScrollAnimator != null && mScrollAnimator.isRunning()) {
    setStackScroll(mFinalAnimatedScroll);
    mScroller.startScroll(0,progressToScrollRange(mFinalAnimatedScroll),0,0,0);
  }
  stopScroller();
  stopBoundScrollAnimation();
  mFinalAnimatedScroll=newScroll;
  mScrollAnimator=ObjectAnimator.ofFloat(this,STACK_SCROLL,curScroll,newScroll);
  mScrollAnimator.setDuration(mContext.getResources().getInteger(R.integer.recents_animate_task_stack_scroll_duration));
  mScrollAnimator.setInterpolator(mLinearOutSlowInInterpolator);
  mScrollAnimator.addListener(new AnimatorListenerAdapter(){
    @Override public void onAnimationEnd(    Animator animation){
      if (postRunnable != null) {
        postRunnable.run();
      }
      mScrollAnimator.removeAllListeners();
    }
  }
);
  mScrollAnimator.start();
}",0.985691573926868
192870,"@Override public void onAnimationEnd(Animator animation){
  if (onFinishedRunnable != null) {
    onFinishedRunnable.run();
  }
  if (!mWasCancelled) {
    mAppearAnimationFraction=-1;
    setOutlineRect(null);
    enableAppearDrawing(false);
  }
}","@Override public void onAnimationEnd(Animator animation){
  if (onFinishedRunnable != null) {
    onFinishedRunnable.run();
  }
  if (!mWasCancelled) {
    enableAppearDrawing(false);
  }
}",0.8649885583524027
192871,"private void cancelAppearAnimation(){
  if (mAppearAnimator != null) {
    mAppearAnimator.cancel();
  }
}","private void cancelAppearAnimation(){
  if (mAppearAnimator != null) {
    mAppearAnimator.cancel();
    mAppearAnimator=null;
  }
}",0.8907563025210085
192872,"private void startAppearAnimation(boolean isAppearing,float translationDirection,long delay,long duration,final Runnable onFinishedRunnable){
  cancelAppearAnimation();
  mAnimationTranslationY=translationDirection * getActualHeight();
  if (mAppearAnimationFraction == -1.0f) {
    if (isAppearing) {
      mAppearAnimationFraction=0.0f;
      mAppearAnimationTranslation=mAnimationTranslationY;
    }
 else {
      mAppearAnimationFraction=1.0f;
      mAppearAnimationTranslation=0;
    }
  }
  float targetValue;
  if (isAppearing) {
    mCurrentAppearInterpolator=mSlowOutFastInInterpolator;
    mCurrentAlphaInterpolator=mLinearOutSlowInInterpolator;
    targetValue=1.0f;
  }
 else {
    mCurrentAppearInterpolator=mFastOutSlowInInterpolator;
    mCurrentAlphaInterpolator=mSlowOutLinearInInterpolator;
    targetValue=0.0f;
  }
  mAppearAnimator=ValueAnimator.ofFloat(mAppearAnimationFraction,targetValue);
  mAppearAnimator.setInterpolator(mLinearInterpolator);
  mAppearAnimator.setDuration((long)(duration * Math.abs(mAppearAnimationFraction - targetValue)));
  mAppearAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener(){
    @Override public void onAnimationUpdate(    ValueAnimator animation){
      mAppearAnimationFraction=(float)animation.getAnimatedValue();
      updateAppearAnimationAlpha();
      updateAppearRect();
      invalidate();
    }
  }
);
  if (delay > 0) {
    updateAppearAnimationAlpha();
    updateAppearRect();
    mAppearAnimator.setStartDelay(delay);
  }
  mAppearAnimator.addListener(new AnimatorListenerAdapter(){
    private boolean mWasCancelled;
    @Override public void onAnimationEnd(    Animator animation){
      if (onFinishedRunnable != null) {
        onFinishedRunnable.run();
      }
      if (!mWasCancelled) {
        mAppearAnimationFraction=-1;
        setOutlineRect(null);
        enableAppearDrawing(false);
      }
    }
    @Override public void onAnimationStart(    Animator animation){
      mWasCancelled=false;
    }
    @Override public void onAnimationCancel(    Animator animation){
      mWasCancelled=true;
    }
  }
);
  mAppearAnimator.start();
}","private void startAppearAnimation(boolean isAppearing,float translationDirection,long delay,long duration,final Runnable onFinishedRunnable){
  cancelAppearAnimation();
  mAnimationTranslationY=translationDirection * getActualHeight();
  if (mAppearAnimationFraction == -1.0f) {
    if (isAppearing) {
      mAppearAnimationFraction=0.0f;
      mAppearAnimationTranslation=mAnimationTranslationY;
    }
 else {
      mAppearAnimationFraction=1.0f;
      mAppearAnimationTranslation=0;
    }
  }
  float targetValue;
  if (isAppearing) {
    mCurrentAppearInterpolator=mSlowOutFastInInterpolator;
    mCurrentAlphaInterpolator=mLinearOutSlowInInterpolator;
    targetValue=1.0f;
  }
 else {
    mCurrentAppearInterpolator=mFastOutSlowInInterpolator;
    mCurrentAlphaInterpolator=mSlowOutLinearInInterpolator;
    targetValue=0.0f;
  }
  mAppearAnimator=ValueAnimator.ofFloat(mAppearAnimationFraction,targetValue);
  mAppearAnimator.setInterpolator(mLinearInterpolator);
  mAppearAnimator.setDuration((long)(duration * Math.abs(mAppearAnimationFraction - targetValue)));
  mAppearAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener(){
    @Override public void onAnimationUpdate(    ValueAnimator animation){
      mAppearAnimationFraction=(float)animation.getAnimatedValue();
      updateAppearAnimationAlpha();
      updateAppearRect();
      invalidate();
    }
  }
);
  if (delay > 0) {
    updateAppearAnimationAlpha();
    updateAppearRect();
    mAppearAnimator.setStartDelay(delay);
  }
  mAppearAnimator.addListener(new AnimatorListenerAdapter(){
    private boolean mWasCancelled;
    @Override public void onAnimationEnd(    Animator animation){
      if (onFinishedRunnable != null) {
        onFinishedRunnable.run();
      }
      if (!mWasCancelled) {
        enableAppearDrawing(false);
      }
    }
    @Override public void onAnimationStart(    Animator animation){
      mWasCancelled=false;
    }
    @Override public void onAnimationCancel(    Animator animation){
      mWasCancelled=true;
    }
  }
);
  mAppearAnimator.start();
}",0.9840665873959572
192873,"/** 
 * When we draw the appear animation, we render the view in a bitmap and render this bitmap as a shader of a rect. This call creates the Bitmap and switches the drawing mode, such that the normal drawing of the views does not happen anymore.
 * @param enable Should it be enabled.
 */
private void enableAppearDrawing(boolean enable){
  if (enable != mDrawingAppearAnimation) {
    mDrawingAppearAnimation=enable;
    if (!enable) {
      setContentAlpha(1.0f);
    }
    invalidate();
  }
}","/** 
 * When we draw the appear animation, we render the view in a bitmap and render this bitmap as a shader of a rect. This call creates the Bitmap and switches the drawing mode, such that the normal drawing of the views does not happen anymore.
 * @param enable Should it be enabled.
 */
private void enableAppearDrawing(boolean enable){
  if (enable != mDrawingAppearAnimation) {
    mDrawingAppearAnimation=enable;
    if (!enable) {
      setContentAlpha(1.0f);
      mAppearAnimationFraction=-1;
      setOutlineRect(null);
    }
    invalidate();
  }
}",0.9402843601895736
192874,"/** 
 * Computes the selection given the previously-computed start- and end-indices for each row and column.
 */
private void updateSelection(int columnStartIndex,int columnEndIndex,int rowStartIndex,int rowEndIndex){
  mSelection.clear();
  for (int column=columnStartIndex; column <= columnEndIndex; column++) {
    SparseIntArray items=mColumns.get(mColumnBounds.get(column).lowerLimit);
    for (int row=rowStartIndex; row <= rowEndIndex; row++) {
      int position=items.get(items.keyAt(row),NOT_SET);
      if (position != NOT_SET) {
        String id=mAdapter.getModelId(position);
        if (id != null) {
          mSelection.add(id);
        }
        if (isPossiblePositionNearestOrigin(column,columnStartIndex,columnEndIndex,row,rowStartIndex,rowEndIndex)) {
          mPositionNearestOrigin=position;
        }
      }
    }
  }
}","/** 
 * Computes the selection given the previously-computed start- and end-indices for each row and column.
 */
private void updateSelection(int columnStartIndex,int columnEndIndex,int rowStartIndex,int rowEndIndex){
  if (DEBUG)   Log.d(TAG,String.format(""String_Node_Str"",columnStartIndex,columnEndIndex,rowStartIndex,rowEndIndex));
  mSelection.clear();
  for (int column=columnStartIndex; column <= columnEndIndex; column++) {
    SparseIntArray items=mColumns.get(mColumnBounds.get(column).lowerLimit);
    for (int row=rowStartIndex; row <= rowEndIndex; row++) {
      final int rowKey=mRowBounds.get(row).lowerLimit;
      int position=items.get(rowKey,NOT_SET);
      if (position != NOT_SET) {
        String id=mAdapter.getModelId(position);
        if (id != null) {
          mSelection.add(id);
        }
        if (isPossiblePositionNearestOrigin(column,columnStartIndex,columnEndIndex,row,rowStartIndex,rowEndIndex)) {
          mPositionNearestOrigin=position;
        }
      }
    }
  }
}",0.8969239071775499
192875,"/** 
 * Queries the view for all children and records their location metadata.
 */
private void recordVisibleChildren(){
  for (int i=0; i < mHelper.getVisibleChildCount(); i++) {
    int adapterPosition=mHelper.getAdapterPositionAt(i);
    if (!mKnownPositions.get(adapterPosition)) {
      mKnownPositions.put(adapterPosition,true);
      recordItemData(mHelper.getAbsoluteRectForChildViewAt(i),adapterPosition);
    }
  }
}","/** 
 * Queries the view for all children and records their location metadata.
 */
private void recordVisibleChildren(){
  for (int i=0; i < mHelper.getVisibleChildCount(); i++) {
    int adapterPosition=mHelper.getAdapterPositionAt(i);
    if (!mHelper.isLayoutItem(adapterPosition) && !mKnownPositions.get(adapterPosition)) {
      mKnownPositions.put(adapterPosition,true);
      recordItemData(mHelper.getAbsoluteRectForChildViewAt(i),adapterPosition);
    }
  }
}",0.953020134228188
192876,"/** 
 * Computes the selection given the previously-computed start- and end-indices for each row and column.
 */
private void updateSelection(int columnStartIndex,int columnEndIndex,int rowStartIndex,int rowEndIndex){
  mSelection.clear();
  for (int column=columnStartIndex; column <= columnEndIndex; column++) {
    SparseIntArray items=mColumns.get(mColumnBounds.get(column).lowerLimit);
    for (int row=rowStartIndex; row <= rowEndIndex; row++) {
      int position=items.get(items.keyAt(row),NOT_SET);
      if (position != NOT_SET) {
        String id=mAdapter.getModelId(position);
        if (id != null) {
          mSelection.add(id);
        }
        if (isPossiblePositionNearestOrigin(column,columnStartIndex,columnEndIndex,row,rowStartIndex,rowEndIndex)) {
          mPositionNearestOrigin=position;
        }
      }
    }
  }
}","/** 
 * Computes the selection given the previously-computed start- and end-indices for each row and column.
 */
private void updateSelection(int columnStartIndex,int columnEndIndex,int rowStartIndex,int rowEndIndex){
  if (DEBUG)   Log.d(TAG,String.format(""String_Node_Str"",columnStartIndex,columnEndIndex,rowStartIndex,rowEndIndex));
  mSelection.clear();
  for (int column=columnStartIndex; column <= columnEndIndex; column++) {
    SparseIntArray items=mColumns.get(mColumnBounds.get(column).lowerLimit);
    for (int row=rowStartIndex; row <= rowEndIndex; row++) {
      final int rowKey=mRowBounds.get(row).lowerLimit;
      int position=items.get(rowKey,NOT_SET);
      if (position != NOT_SET) {
        String id=mAdapter.getModelId(position);
        if (id != null) {
          mSelection.add(id);
        }
        if (isPossiblePositionNearestOrigin(column,columnStartIndex,columnEndIndex,row,rowStartIndex,rowEndIndex)) {
          mPositionNearestOrigin=position;
        }
      }
    }
  }
}",0.8969239071775499
192877,"/** 
 * Queries the view for all children and records their location metadata.
 */
private void recordVisibleChildren(){
  for (int i=0; i < mHelper.getVisibleChildCount(); i++) {
    int adapterPosition=mHelper.getAdapterPositionAt(i);
    if (!mKnownPositions.get(adapterPosition)) {
      mKnownPositions.put(adapterPosition,true);
      recordItemData(mHelper.getAbsoluteRectForChildViewAt(i),adapterPosition);
    }
  }
}","/** 
 * Queries the view for all children and records their location metadata.
 */
private void recordVisibleChildren(){
  for (int i=0; i < mHelper.getVisibleChildCount(); i++) {
    int adapterPosition=mHelper.getAdapterPositionAt(i);
    if (!mHelper.isLayoutItem(adapterPosition) && !mKnownPositions.get(adapterPosition)) {
      mKnownPositions.put(adapterPosition,true);
      recordItemData(mHelper.getAbsoluteRectForChildViewAt(i),adapterPosition);
    }
  }
}",0.953020134228188
192878,"@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  super.onLayout(changed,left,top,right,bottom);
  if (mLayoutHeight != getHeight()) {
    mLayoutHeight=getHeight();
    mStatusBar.onPanelHeightChanged();
  }
  requestPanelHeightUpdate();
  mHasLayoutedSinceDown=true;
  if (mUpdateFlingOnLayout) {
    abortAnimations();
    fling(mUpdateFlingVelocity,true);
    mUpdateFlingOnLayout=false;
  }
}","@Override protected void onLayout(boolean changed,int left,int top,int right,int bottom){
  super.onLayout(changed,left,top,right,bottom);
  mStatusBar.onPanelLaidOut();
  requestPanelHeightUpdate();
  mHasLayoutedSinceDown=true;
  if (mUpdateFlingOnLayout) {
    abortAnimations();
    fling(mUpdateFlingVelocity,true);
    mUpdateFlingOnLayout=false;
  }
}",0.4140526976160602
192879,"public void setContractedChild(View child){
  if (mContractedChild != null) {
    mContractedChild.animate().cancel();
    removeView(mContractedChild);
  }
  addView(child);
  mContractedChild=child;
  mContractedWrapper=NotificationViewWrapper.wrap(getContext(),child);
  selectLayout(false,true);
  mContractedWrapper.setDark(mDark,false,0);
  updateRoundRectClipping();
}","public void setContractedChild(View child){
  if (mContractedChild != null) {
    mContractedChild.animate().cancel();
    mContractedChild.removeOnLayoutChangeListener(mLayoutUpdater);
    removeView(mContractedChild);
  }
  addView(child);
  mContractedChild=child;
  mContractedChild.addOnLayoutChangeListener(mLayoutUpdater);
  mContractedWrapper=NotificationViewWrapper.wrap(getContext(),child);
  selectLayout(false,true);
  mContractedWrapper.setDark(mDark,false,0);
  updateRoundRectClipping();
}",0.8532423208191127
192880,"public void setDark(boolean dark,boolean fade,long delay){
  if (mDark == dark || mContractedChild == null)   return;
  mDark=dark;
  mContractedWrapper.setDark(dark && !mShowingLegacyBackground,fade,delay);
  if (mSingleLineView != null) {
    mSingleLineView.setDark(dark,fade,delay);
  }
}","public void setDark(boolean dark,boolean fade,long delay){
  if (mDark == dark || mContractedChild == null)   return;
  mDark=dark;
  dark=dark && !mShowingLegacyBackground;
  if (mVisibleType == VISIBLE_TYPE_CONTRACTED) {
    mContractedWrapper.setDark(dark,fade,delay);
  }
  if (mVisibleType == VISIBLE_TYPE_EXPANDED) {
    mExpandedWrapper.setDark(dark,fade,delay);
  }
  if (mVisibleType == VISIBLE_TYPE_HEADSUP) {
    mHeadsUpWrapper.setDark(dark,fade,delay);
  }
  if (mSingleLineView != null && mVisibleType == VISIBLE_TYPE_SINGLELINE) {
    mSingleLineView.setDark(dark,fade,delay);
  }
}",0.5669291338582677
192881,"public void setExpandedChild(View child){
  if (mExpandedChild != null) {
    mExpandedChild.animate().cancel();
    removeView(mExpandedChild);
  }
  addView(child);
  mExpandedChild=child;
  mExpandedWrapper=NotificationViewWrapper.wrap(getContext(),child);
  selectLayout(false,true);
  updateRoundRectClipping();
}","public void setExpandedChild(View child){
  if (mExpandedChild != null) {
    mExpandedChild.animate().cancel();
    mExpandedChild.removeOnLayoutChangeListener(mLayoutUpdater);
    removeView(mExpandedChild);
  }
  addView(child);
  mExpandedChild=child;
  mExpandedChild.addOnLayoutChangeListener(mLayoutUpdater);
  mExpandedWrapper=NotificationViewWrapper.wrap(getContext(),child);
  selectLayout(false,true);
  updateRoundRectClipping();
}",0.835742444152431
192882,"public void setHeadsUpChild(View child){
  if (mHeadsUpChild != null) {
    mHeadsUpChild.animate().cancel();
    removeView(mHeadsUpChild);
  }
  addView(child);
  mHeadsUpChild=child;
  mHeadsUpWrapper=NotificationViewWrapper.wrap(getContext(),child);
  selectLayout(false,true);
  updateRoundRectClipping();
}","public void setHeadsUpChild(View child){
  if (mHeadsUpChild != null) {
    mHeadsUpChild.animate().cancel();
    mHeadsUpChild.removeOnLayoutChangeListener(mLayoutUpdater);
    removeView(mHeadsUpChild);
  }
  addView(child);
  mHeadsUpChild=child;
  mHeadsUpChild.addOnLayoutChangeListener(mLayoutUpdater);
  mHeadsUpWrapper=NotificationViewWrapper.wrap(getContext(),child);
  selectLayout(false,true);
  updateRoundRectClipping();
}",0.8353413654618473
192883,"public HybridNotificationView bindFromNotification(HybridNotificationView reusableView,Notification notification){
  CharSequence titleText=resolveTitle(notification);
  if (titleText == null) {
    if (reusableView != null) {
      mParent.removeView(reusableView);
    }
    return null;
  }
  if (reusableView == null) {
    reusableView=inflateHybridView();
  }
  CharSequence contentText=resolveText(notification);
  reusableView.bind(titleText,contentText);
  return reusableView;
}","public HybridNotificationView bindFromNotification(HybridNotificationView reusableView,Notification notification){
  if (reusableView == null) {
    reusableView=inflateHybridView();
  }
  CharSequence titleText=resolveTitle(notification);
  CharSequence contentText=resolveText(notification);
  reusableView.bind(titleText,contentText);
  return reusableView;
}",0.6823529411764706
192884,"/** 
 * Sets the focused task to the provided (bounded taskIndex).
 * @return whether or not the stack will scroll as a part of this focus change
 */
private boolean setFocusedTask(int taskIndex,boolean scrollToTask,final boolean requestViewFocus,final boolean showTimerIndicator){
  int newFocusedTaskIndex=mStack.getTaskCount() > 0 ? Math.max(0,Math.min(mStack.getTaskCount() - 1,taskIndex)) : -1;
  final Task newFocusedTask=(newFocusedTaskIndex != -1) ? mStack.getStackTasks().get(newFocusedTaskIndex) : null;
  if (mFocusedTask != null) {
    resetFocusedTask(mFocusedTask);
    if (showTimerIndicator) {
      final TaskView tv=getChildViewForTask(mFocusedTask);
      if (tv != null) {
        tv.getHeaderView().cancelFocusTimerIndicator();
      }
    }
  }
  boolean willScroll=false;
  mFocusedTask=newFocusedTask;
  if (newFocusedTask != null) {
    if (showTimerIndicator) {
      final TaskView tv=getChildViewForTask(mFocusedTask);
      if (tv != null) {
        tv.getHeaderView().startFocusTimerIndicator();
      }
 else {
        mStartTimerIndicator=true;
      }
    }
    Runnable focusTaskRunnable=new Runnable(){
      @Override public void run(){
        final TaskView tv=getChildViewForTask(newFocusedTask);
        if (tv != null) {
          tv.setFocusedState(true,requestViewFocus);
        }
      }
    }
;
    if (scrollToTask) {
      float newScroll=mLayoutAlgorithm.getStackScrollForTask(newFocusedTask);
      if (Float.compare(newScroll,mStackScroller.getStackScroll()) != 0) {
        mStackScroller.animateScroll(mStackScroller.getStackScroll(),newScroll,focusTaskRunnable);
        willScroll=true;
        if (!mEnterAnimationComplete) {
          cancelAllTaskViewAnimations();
        }
      }
 else {
        focusTaskRunnable.run();
      }
      mLayoutAlgorithm.animateFocusState(TaskStackLayoutAlgorithm.STATE_FOCUSED);
    }
 else {
      focusTaskRunnable.run();
    }
  }
  return willScroll;
}","/** 
 * Sets the focused task to the provided (bounded taskIndex).
 * @return whether or not the stack will scroll as a part of this focus change
 */
private boolean setFocusedTask(int taskIndex,boolean scrollToTask,final boolean requestViewFocus,final boolean showTimerIndicator){
  int newFocusedTaskIndex=mStack.getTaskCount() > 0 ? Math.max(0,Math.min(mStack.getTaskCount() - 1,taskIndex)) : -1;
  final Task newFocusedTask=(newFocusedTaskIndex != -1) ? mStack.getStackTasks().get(newFocusedTaskIndex) : null;
  if (mFocusedTask != null) {
    if (showTimerIndicator) {
      final TaskView tv=getChildViewForTask(mFocusedTask);
      if (tv != null) {
        tv.getHeaderView().cancelFocusTimerIndicator();
      }
    }
    resetFocusedTask(mFocusedTask);
  }
  boolean willScroll=false;
  mFocusedTask=newFocusedTask;
  if (newFocusedTask != null) {
    if (showTimerIndicator) {
      final TaskView tv=getChildViewForTask(mFocusedTask);
      if (tv != null) {
        tv.getHeaderView().startFocusTimerIndicator();
      }
 else {
        mStartTimerIndicator=true;
      }
    }
    Runnable focusTaskRunnable=new Runnable(){
      @Override public void run(){
        final TaskView tv=getChildViewForTask(newFocusedTask);
        if (tv != null) {
          tv.setFocusedState(true,requestViewFocus);
        }
      }
    }
;
    if (scrollToTask) {
      float newScroll=mLayoutAlgorithm.getStackScrollForTask(newFocusedTask);
      if (Float.compare(newScroll,mStackScroller.getStackScroll()) != 0) {
        mStackScroller.animateScroll(mStackScroller.getStackScroll(),newScroll,focusTaskRunnable);
        willScroll=true;
        if (!mEnterAnimationComplete) {
          cancelAllTaskViewAnimations();
        }
      }
 else {
        focusTaskRunnable.run();
      }
      mLayoutAlgorithm.animateFocusState(TaskStackLayoutAlgorithm.STATE_FOCUSED);
    }
 else {
      focusTaskRunnable.run();
    }
  }
  return willScroll;
}",0.9815289892252436
192885,"@Override public void run(){
  if (DEBUG_ATLAS)   Log.d(LOG_TAG,""String_Node_Str"" + Thread.currentThread().getName());
  Atlas.Entry entry=new Atlas.Entry();
  for (  Atlas.Type type : Atlas.Type.values()) {
    for (int width=mEnd; width > mStart; width-=mStep) {
      for (int height=MAX_SIZE; height > MIN_SIZE; height-=STEP) {
        if (width * height <= mThreshold)         continue;
        final int count=packBitmaps(type,width,height,entry);
        if (count > 0) {
          mResults.add(new WorkerResult(type,width,height,count));
          if (count == mBitmaps.size()) {
            break;
          }
        }
      }
    }
  }
  if (mSignal != null) {
    mSignal.countDown();
  }
}","@Override public void run(){
  if (DEBUG_ATLAS)   Log.d(LOG_TAG,""String_Node_Str"" + Thread.currentThread().getName());
  Atlas.Entry entry=new Atlas.Entry();
  for (int width=mEnd; width > mStart; width-=mStep) {
    for (int height=MAX_SIZE; height > MIN_SIZE; height-=STEP) {
      if (width * height <= mThreshold)       continue;
      boolean packSuccess=false;
      for (      Atlas.Type type : Atlas.Type.values()) {
        final int count=packBitmaps(type,width,height,entry);
        if (count > 0) {
          mResults.add(new WorkerResult(type,width,height,count));
          if (count == mBitmaps.size()) {
            packSuccess=true;
            break;
          }
        }
      }
      if (!packSuccess) {
        break;
      }
    }
  }
  if (mSignal != null) {
    mSignal.countDown();
  }
}",0.7796833773087071
192886,"@Override public void run(){
  if (DEBUG_ATLAS)   Log.d(LOG_TAG,""String_Node_Str"" + Thread.currentThread().getName());
  Atlas.Entry entry=new Atlas.Entry();
  for (  Atlas.Type type : Atlas.Type.values()) {
    for (int width=mEnd; width > mStart; width-=mStep) {
      for (int height=MAX_SIZE; height > MIN_SIZE; height-=STEP) {
        if (width * height <= mThreshold)         continue;
        final int count=packBitmaps(type,width,height,entry);
        if (count > 0) {
          mResults.add(new WorkerResult(type,width,height,count));
          if (count == mBitmaps.size()) {
            break;
          }
        }
      }
    }
  }
  if (mSignal != null) {
    mSignal.countDown();
  }
}","@Override public void run(){
  if (DEBUG_ATLAS)   Log.d(LOG_TAG,""String_Node_Str"" + Thread.currentThread().getName());
  Atlas.Entry entry=new Atlas.Entry();
  for (int width=mEnd; width > mStart; width-=mStep) {
    for (int height=MAX_SIZE; height > MIN_SIZE; height-=STEP) {
      if (width * height <= mThreshold)       continue;
      boolean packSuccess=false;
      for (      Atlas.Type type : Atlas.Type.values()) {
        final int count=packBitmaps(type,width,height,entry);
        if (count > 0) {
          mResults.add(new WorkerResult(type,width,height,count));
          if (count == mBitmaps.size()) {
            packSuccess=true;
            break;
          }
        }
      }
      if (!packSuccess) {
        break;
      }
    }
  }
  if (mSignal != null) {
    mSignal.countDown();
  }
}",0.7796833773087071
192887,"@Override public void run(){
  if (DEBUG_ATLAS)   Log.d(LOG_TAG,""String_Node_Str"" + Thread.currentThread().getName());
  Atlas.Entry entry=new Atlas.Entry();
  for (  Atlas.Type type : Atlas.Type.values()) {
    for (int width=mEnd; width > mStart; width-=mStep) {
      for (int height=MAX_SIZE; height > MIN_SIZE; height-=STEP) {
        if (width * height <= mThreshold)         continue;
        final int count=packBitmaps(type,width,height,entry);
        if (count > 0) {
          mResults.add(new WorkerResult(type,width,height,count));
          if (count == mBitmaps.size()) {
            break;
          }
        }
      }
    }
  }
  if (mSignal != null) {
    mSignal.countDown();
  }
}","@Override public void run(){
  if (DEBUG_ATLAS)   Log.d(LOG_TAG,""String_Node_Str"" + Thread.currentThread().getName());
  Atlas.Entry entry=new Atlas.Entry();
  for (int width=mEnd; width > mStart; width-=mStep) {
    for (int height=MAX_SIZE; height > MIN_SIZE; height-=STEP) {
      if (width * height <= mThreshold)       continue;
      boolean packSuccess=false;
      for (      Atlas.Type type : Atlas.Type.values()) {
        final int count=packBitmaps(type,width,height,entry);
        if (count > 0) {
          mResults.add(new WorkerResult(type,width,height,count));
          if (count == mBitmaps.size()) {
            packSuccess=true;
            break;
          }
        }
      }
      if (!packSuccess) {
        break;
      }
    }
  }
  if (mSignal != null) {
    mSignal.countDown();
  }
}",0.7796833773087071
192888,"@Override public void exitIdle(String reason){
  getContext().enforceCallingOrSelfPermission(Manifest.permission.DEVICE_POWER,null);
  exitIdleInternal(reason);
}","@Override public void exitIdle(String reason){
  getContext().enforceCallingOrSelfPermission(Manifest.permission.DEVICE_POWER,null);
  long ident=Binder.clearCallingIdentity();
  try {
    exitIdleInternal(reason);
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.7363636363636363
192889,"@Override public void addPowerSaveWhitelistApp(String name){
  getContext().enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER,null);
  addPowerSaveWhitelistAppInternal(name);
}","@Override public void addPowerSaveWhitelistApp(String name){
  getContext().enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER,null);
  long ident=Binder.clearCallingIdentity();
  try {
    addPowerSaveWhitelistAppInternal(name);
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.7734375
192890,"@Override public void removePowerSaveWhitelistApp(String name){
  getContext().enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER,null);
  removePowerSaveWhitelistAppInternal(name);
}","@Override public void removePowerSaveWhitelistApp(String name){
  getContext().enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER,null);
  long ident=Binder.clearCallingIdentity();
  try {
    removePowerSaveWhitelistAppInternal(name);
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.7786259541984732
192891,"@Override public void run(){
  if (DEBUG_ATLAS)   Log.d(LOG_TAG,""String_Node_Str"" + Thread.currentThread().getName());
  Atlas.Entry entry=new Atlas.Entry();
  for (  Atlas.Type type : Atlas.Type.values()) {
    for (int width=mEnd; width > mStart; width-=mStep) {
      for (int height=MAX_SIZE; height > MIN_SIZE; height-=STEP) {
        if (width * height <= mThreshold)         continue;
        final int count=packBitmaps(type,width,height,entry);
        if (count > 0) {
          mResults.add(new WorkerResult(type,width,height,count));
          if (count == mBitmaps.size()) {
            break;
          }
        }
      }
    }
  }
  if (mSignal != null) {
    mSignal.countDown();
  }
}","@Override public void run(){
  if (DEBUG_ATLAS)   Log.d(LOG_TAG,""String_Node_Str"" + Thread.currentThread().getName());
  Atlas.Entry entry=new Atlas.Entry();
  for (int width=mEnd; width > mStart; width-=mStep) {
    for (int height=MAX_SIZE; height > MIN_SIZE; height-=STEP) {
      if (width * height <= mThreshold)       continue;
      boolean packSuccess=false;
      for (      Atlas.Type type : Atlas.Type.values()) {
        final int count=packBitmaps(type,width,height,entry);
        if (count > 0) {
          mResults.add(new WorkerResult(type,width,height,count));
          if (count == mBitmaps.size()) {
            packSuccess=true;
            break;
          }
        }
      }
      if (!packSuccess) {
        break;
      }
    }
  }
  if (mSignal != null) {
    mSignal.countDown();
  }
}",0.7796833773087071
192892,"@Override public void run(){
  if (DEBUG_ATLAS)   Log.d(LOG_TAG,""String_Node_Str"" + Thread.currentThread().getName());
  Atlas.Entry entry=new Atlas.Entry();
  for (  Atlas.Type type : Atlas.Type.values()) {
    for (int width=mEnd; width > mStart; width-=mStep) {
      for (int height=MAX_SIZE; height > MIN_SIZE; height-=STEP) {
        if (width * height <= mThreshold)         continue;
        final int count=packBitmaps(type,width,height,entry);
        if (count > 0) {
          mResults.add(new WorkerResult(type,width,height,count));
          if (count == mBitmaps.size()) {
            break;
          }
        }
      }
    }
  }
  if (mSignal != null) {
    mSignal.countDown();
  }
}","@Override public void run(){
  if (DEBUG_ATLAS)   Log.d(LOG_TAG,""String_Node_Str"" + Thread.currentThread().getName());
  Atlas.Entry entry=new Atlas.Entry();
  for (int width=mEnd; width > mStart; width-=mStep) {
    for (int height=MAX_SIZE; height > MIN_SIZE; height-=STEP) {
      if (width * height <= mThreshold)       continue;
      boolean packSuccess=false;
      for (      Atlas.Type type : Atlas.Type.values()) {
        final int count=packBitmaps(type,width,height,entry);
        if (count > 0) {
          mResults.add(new WorkerResult(type,width,height,count));
          if (count == mBitmaps.size()) {
            packSuccess=true;
            break;
          }
        }
      }
      if (!packSuccess) {
        break;
      }
    }
  }
  if (mSignal != null) {
    mSignal.countDown();
  }
}",0.7796833773087071
192893,"@Override public void run(){
  if (DEBUG_ATLAS)   Log.d(LOG_TAG,""String_Node_Str"" + Thread.currentThread().getName());
  Atlas.Entry entry=new Atlas.Entry();
  for (  Atlas.Type type : Atlas.Type.values()) {
    for (int width=mEnd; width > mStart; width-=mStep) {
      for (int height=MAX_SIZE; height > MIN_SIZE; height-=STEP) {
        if (width * height <= mThreshold)         continue;
        final int count=packBitmaps(type,width,height,entry);
        if (count > 0) {
          mResults.add(new WorkerResult(type,width,height,count));
          if (count == mBitmaps.size()) {
            break;
          }
        }
      }
    }
  }
  if (mSignal != null) {
    mSignal.countDown();
  }
}","@Override public void run(){
  if (DEBUG_ATLAS)   Log.d(LOG_TAG,""String_Node_Str"" + Thread.currentThread().getName());
  Atlas.Entry entry=new Atlas.Entry();
  for (int width=mEnd; width > mStart; width-=mStep) {
    for (int height=MAX_SIZE; height > MIN_SIZE; height-=STEP) {
      if (width * height <= mThreshold)       continue;
      boolean packSuccess=false;
      for (      Atlas.Type type : Atlas.Type.values()) {
        final int count=packBitmaps(type,width,height,entry);
        if (count > 0) {
          mResults.add(new WorkerResult(type,width,height,count));
          if (count == mBitmaps.size()) {
            packSuccess=true;
            break;
          }
        }
      }
      if (!packSuccess) {
        break;
      }
    }
  }
  if (mSignal != null) {
    mSignal.countDown();
  }
}",0.7796833773087071
192894,"@Override public void exitIdle(String reason){
  getContext().enforceCallingOrSelfPermission(Manifest.permission.DEVICE_POWER,null);
  exitIdleInternal(reason);
}","@Override public void exitIdle(String reason){
  getContext().enforceCallingOrSelfPermission(Manifest.permission.DEVICE_POWER,null);
  long ident=Binder.clearCallingIdentity();
  try {
    exitIdleInternal(reason);
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.7363636363636363
192895,"@Override public void addPowerSaveWhitelistApp(String name){
  getContext().enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER,null);
  addPowerSaveWhitelistAppInternal(name);
}","@Override public void addPowerSaveWhitelistApp(String name){
  getContext().enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER,null);
  long ident=Binder.clearCallingIdentity();
  try {
    addPowerSaveWhitelistAppInternal(name);
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.7734375
192896,"@Override public void removePowerSaveWhitelistApp(String name){
  getContext().enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER,null);
  removePowerSaveWhitelistAppInternal(name);
}","@Override public void removePowerSaveWhitelistApp(String name){
  getContext().enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER,null);
  long ident=Binder.clearCallingIdentity();
  try {
    removePowerSaveWhitelistAppInternal(name);
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.7786259541984732
192897,"@Override public void exitIdle(String reason){
  getContext().enforceCallingOrSelfPermission(Manifest.permission.DEVICE_POWER,null);
  exitIdleInternal(reason);
}","@Override public void exitIdle(String reason){
  getContext().enforceCallingOrSelfPermission(Manifest.permission.DEVICE_POWER,null);
  long ident=Binder.clearCallingIdentity();
  try {
    exitIdleInternal(reason);
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.7363636363636363
192898,"@Override public void addPowerSaveWhitelistApp(String name){
  getContext().enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER,null);
  addPowerSaveWhitelistAppInternal(name);
}","@Override public void addPowerSaveWhitelistApp(String name){
  getContext().enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER,null);
  long ident=Binder.clearCallingIdentity();
  try {
    addPowerSaveWhitelistAppInternal(name);
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.7734375
192899,"@Override public void removePowerSaveWhitelistApp(String name){
  getContext().enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER,null);
  removePowerSaveWhitelistAppInternal(name);
}","@Override public void removePowerSaveWhitelistApp(String name){
  getContext().enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER,null);
  long ident=Binder.clearCallingIdentity();
  try {
    removePowerSaveWhitelistAppInternal(name);
  }
  finally {
    Binder.restoreCallingIdentity(ident);
  }
}",0.7786259541984732
192900,"@Override protected void createPopupWindow(){
  mPopupWindow=new CustomPopupWindow(mTextView.getContext(),com.android.internal.R.attr.textSuggestionsWindowStyle);
  mPopupWindow.setInputMethodMode(PopupWindow.INPUT_METHOD_NOT_NEEDED);
  mPopupWindow.setFocusable(true);
  mPopupWindow.setClippingEnabled(false);
}","@Override protected void createPopupWindow(){
  mPopupWindow=new CustomPopupWindow();
  mPopupWindow.setInputMethodMode(PopupWindow.INPUT_METHOD_NOT_NEEDED);
  mPopupWindow.setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));
  mPopupWindow.setFocusable(true);
  mPopupWindow.setClippingEnabled(false);
}",0.7552
192901,"@Override protected void createPopupWindow(){
  mPopupWindow=new CustomPopupWindow(mTextView.getContext(),com.android.internal.R.attr.textSuggestionsWindowStyle);
  mPopupWindow.setInputMethodMode(PopupWindow.INPUT_METHOD_NOT_NEEDED);
  mPopupWindow.setFocusable(true);
  mPopupWindow.setClippingEnabled(false);
}","@Override protected void createPopupWindow(){
  mPopupWindow=new CustomPopupWindow();
  mPopupWindow.setInputMethodMode(PopupWindow.INPUT_METHOD_NOT_NEEDED);
  mPopupWindow.setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));
  mPopupWindow.setFocusable(true);
  mPopupWindow.setClippingEnabled(false);
}",0.7552
192902,"public void updateRunningAccounts(){
  if (Log.isLoggable(TAG,Log.VERBOSE))   Log.v(TAG,""String_Node_Str"");
  mSyncHandler.sendEmptyMessage(SyncHandler.MESSAGE_ACCOUNTS_UPDATED);
}","private void updateRunningAccounts(boolean resyncAllTargets){
  if (Log.isLoggable(TAG,Log.VERBOSE))   Log.v(TAG,""String_Node_Str"");
  Message m=mSyncHandler.obtainMessage(SyncHandler.MESSAGE_ACCOUNTS_UPDATED);
  m.arg1=resyncAllTargets ? 1 : 0;
  m.sendToTarget();
}",0.7427293064876958
192903,"private void onUserRemoved(int userId){
  updateRunningAccounts();
  mSyncStorageEngine.doDatabaseCleanup(new Account[0],userId);
synchronized (mSyncQueue) {
    mSyncQueue.removeUserLocked(userId);
  }
}","private void onUserRemoved(int userId){
  updateRunningAccounts(false);
  mSyncStorageEngine.doDatabaseCleanup(new Account[0],userId);
synchronized (mSyncQueue) {
    mSyncQueue.removeUserLocked(userId);
  }
}",0.9878934624697336
192904,"private void onUserStopping(int userId){
  updateRunningAccounts();
  cancelActiveSync(new SyncStorageEngine.EndPoint(null,null,userId),null);
}","private void onUserStopping(int userId){
  updateRunningAccounts(false);
  cancelActiveSync(new SyncStorageEngine.EndPoint(null,null,userId),null);
}",0.9829351535836176
192905,"private void onUserUnlocked(int userId){
  AccountManagerService.getSingleton().validateAccounts(userId);
  mSyncAdapters.invalidateCache(userId);
  updateRunningAccounts();
synchronized (mSyncQueue) {
    mSyncQueue.addPendingOperations(userId);
  }
  final Account[] accounts=AccountManagerService.getSingleton().getAccounts(userId,mContext.getOpPackageName());
  for (  Account account : accounts) {
    scheduleSync(account,userId,SyncOperation.REASON_USER_START,null,null,0,0,true);
  }
  sendCheckAlarmsMessage();
}","private void onUserUnlocked(int userId){
  AccountManagerService.getSingleton().validateAccounts(userId);
  mSyncAdapters.invalidateCache(userId);
  updateRunningAccounts(false);
synchronized (mSyncQueue) {
    mSyncQueue.addPendingOperations(userId);
  }
  final Account[] accounts=AccountManagerService.getSingleton().getAccounts(userId,mContext.getOpPackageName());
  for (  Account account : accounts) {
    scheduleSync(account,userId,SyncOperation.REASON_USER_START,null,null,0,0,true);
  }
  sendCheckAlarmsMessage();
}",0.9952244508118434
192906,"private void updateRunningAccountsH(){
  mRunningAccounts=AccountManagerService.getSingleton().getRunningAccounts();
  if (mBootCompleted) {
    doDatabaseCleanup();
  }
  AccountAndUser[] accounts=mRunningAccounts;
  for (  ActiveSyncContext currentSyncContext : mActiveSyncContexts) {
    if (!containsAccountAndUser(accounts,currentSyncContext.mSyncOperation.target.account,currentSyncContext.mSyncOperation.target.userId)) {
      Log.d(TAG,""String_Node_Str"");
      sendSyncFinishedOrCanceledMessage(currentSyncContext,null);
    }
  }
  sendCheckAlarmsMessage();
}","private void updateRunningAccountsH(boolean resyncAll){
  mRunningAccounts=AccountManagerService.getSingleton().getRunningAccounts();
  if (mBootCompleted) {
    doDatabaseCleanup();
  }
  AccountAndUser[] accounts=mRunningAccounts;
  for (  ActiveSyncContext currentSyncContext : mActiveSyncContexts) {
    if (!containsAccountAndUser(accounts,currentSyncContext.mSyncOperation.target.account,currentSyncContext.mSyncOperation.target.userId)) {
      Log.d(TAG,""String_Node_Str"");
      sendSyncFinishedOrCanceledMessage(currentSyncContext,null);
    }
  }
  if (resyncAll) {
    scheduleSync(null,UserHandle.USER_ALL,SyncOperation.REASON_ACCOUNTS_UPDATED,null,null,0,0,false);
  }
 else {
    sendCheckAlarmsMessage();
  }
}",0.8719135802469136
192907,"public void handleMessage(Message msg){
  if (tryEnqueueMessageUntilReadyToRun(msg)) {
    return;
  }
  long earliestFuturePollTime=Long.MAX_VALUE;
  long nextPendingSyncTime=Long.MAX_VALUE;
  try {
    mDataConnectionIsConnected=readDataConnectionState();
    mSyncManagerWakeLock.acquire();
    earliestFuturePollTime=scheduleReadyPeriodicSyncs();
switch (msg.what) {
case SyncHandler.MESSAGE_ACCOUNTS_UPDATED:
      if (Log.isLoggable(TAG,Log.VERBOSE)) {
        Log.v(TAG,""String_Node_Str"");
      }
    updateRunningAccountsH();
  break;
case SyncHandler.MESSAGE_CANCEL:
SyncStorageEngine.EndPoint endpoint=(SyncStorageEngine.EndPoint)msg.obj;
Bundle extras=msg.peekData();
if (Log.isLoggable(TAG,Log.DEBUG)) {
Log.d(TAG,""String_Node_Str"" + endpoint + ""String_Node_Str""+ extras);
}
cancelActiveSyncH(endpoint,extras);
nextPendingSyncTime=maybeStartNextSyncH();
break;
case SyncHandler.MESSAGE_SYNC_FINISHED:
if (Log.isLoggable(TAG,Log.VERBOSE)) {
Log.v(TAG,""String_Node_Str"");
}
SyncHandlerMessagePayload payload=(SyncHandlerMessagePayload)msg.obj;
if (!isSyncStillActiveH(payload.activeSyncContext)) {
Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + payload.activeSyncContext);
break;
}
runSyncFinishedOrCanceledH(payload.syncResult,payload.activeSyncContext);
nextPendingSyncTime=maybeStartNextSyncH();
break;
case SyncHandler.MESSAGE_SERVICE_CONNECTED:
{
ServiceConnectionData msgData=(ServiceConnectionData)msg.obj;
if (Log.isLoggable(TAG,Log.VERBOSE)) {
Log.d(TAG,""String_Node_Str"" + msgData.activeSyncContext);
}
if (isSyncStillActiveH(msgData.activeSyncContext)) {
runBoundToAdapter(msgData.activeSyncContext,msgData.adapter);
}
break;
}
case SyncHandler.MESSAGE_SERVICE_DISCONNECTED:
{
final ActiveSyncContext currentSyncContext=((ServiceConnectionData)msg.obj).activeSyncContext;
if (Log.isLoggable(TAG,Log.VERBOSE)) {
Log.d(TAG,""String_Node_Str"" + currentSyncContext);
}
if (isSyncStillActiveH(currentSyncContext)) {
try {
if (currentSyncContext.mSyncAdapter != null) {
currentSyncContext.mSyncAdapter.cancelSync(currentSyncContext);
}
 else if (currentSyncContext.mSyncServiceAdapter != null) {
currentSyncContext.mSyncServiceAdapter.cancelSync(currentSyncContext);
}
}
 catch (RemoteException e) {
}
SyncResult syncResult=new SyncResult();
syncResult.stats.numIoExceptions++;
runSyncFinishedOrCanceledH(syncResult,currentSyncContext);
nextPendingSyncTime=maybeStartNextSyncH();
}
break;
}
case SyncHandler.MESSAGE_SYNC_ALARM:
{
boolean isLoggable=Log.isLoggable(TAG,Log.VERBOSE);
if (isLoggable) {
Log.v(TAG,""String_Node_Str"");
}
mAlarmScheduleTime=null;
try {
nextPendingSyncTime=maybeStartNextSyncH();
}
  finally {
mHandleAlarmWakeLock.release();
}
break;
}
case SyncHandler.MESSAGE_CHECK_ALARMS:
if (Log.isLoggable(TAG,Log.VERBOSE)) {
Log.v(TAG,""String_Node_Str"");
}
nextPendingSyncTime=maybeStartNextSyncH();
break;
case SyncHandler.MESSAGE_SYNC_EXPIRED:
ActiveSyncContext expiredContext=(ActiveSyncContext)msg.obj;
if (Log.isLoggable(TAG,Log.DEBUG)) {
Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + expiredContext);
}
runSyncFinishedOrCanceledH(null,expiredContext);
nextPendingSyncTime=maybeStartNextSyncH();
break;
case SyncHandler.MESSAGE_MONITOR_SYNC:
ActiveSyncContext monitoredSyncContext=(ActiveSyncContext)msg.obj;
if (Log.isLoggable(TAG,Log.DEBUG)) {
Log.d(TAG,""String_Node_Str"" + monitoredSyncContext.mSyncOperation.target);
}
if (isSyncNotUsingNetworkH(monitoredSyncContext)) {
Log.w(TAG,String.format(""String_Node_Str"",monitoredSyncContext));
runSyncFinishedOrCanceledH(null,monitoredSyncContext);
}
 else {
postMonitorSyncProgressMessage(monitoredSyncContext);
}
break;
}
}
  finally {
manageSyncAlarmLocked(earliestFuturePollTime,nextPendingSyncTime);
mSyncTimeTracker.update();
mSyncManagerWakeLock.release();
}
}","public void handleMessage(Message msg){
  if (tryEnqueueMessageUntilReadyToRun(msg)) {
    return;
  }
  long earliestFuturePollTime=Long.MAX_VALUE;
  long nextPendingSyncTime=Long.MAX_VALUE;
  try {
    mDataConnectionIsConnected=readDataConnectionState();
    mSyncManagerWakeLock.acquire();
    earliestFuturePollTime=scheduleReadyPeriodicSyncs();
switch (msg.what) {
case SyncHandler.MESSAGE_ACCOUNTS_UPDATED:
      if (Log.isLoggable(TAG,Log.VERBOSE)) {
        Log.v(TAG,""String_Node_Str"");
      }
    boolean resyncAllTargets=msg.arg1 == 0 ? false : true;
  updateRunningAccountsH(resyncAllTargets);
break;
case SyncHandler.MESSAGE_CANCEL:
SyncStorageEngine.EndPoint endpoint=(SyncStorageEngine.EndPoint)msg.obj;
Bundle extras=msg.peekData();
if (Log.isLoggable(TAG,Log.DEBUG)) {
Log.d(TAG,""String_Node_Str"" + endpoint + ""String_Node_Str""+ extras);
}
cancelActiveSyncH(endpoint,extras);
nextPendingSyncTime=maybeStartNextSyncH();
break;
case SyncHandler.MESSAGE_SYNC_FINISHED:
if (Log.isLoggable(TAG,Log.VERBOSE)) {
Log.v(TAG,""String_Node_Str"");
}
SyncHandlerMessagePayload payload=(SyncHandlerMessagePayload)msg.obj;
if (!isSyncStillActiveH(payload.activeSyncContext)) {
Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + payload.activeSyncContext);
break;
}
runSyncFinishedOrCanceledH(payload.syncResult,payload.activeSyncContext);
nextPendingSyncTime=maybeStartNextSyncH();
break;
case SyncHandler.MESSAGE_SERVICE_CONNECTED:
{
ServiceConnectionData msgData=(ServiceConnectionData)msg.obj;
if (Log.isLoggable(TAG,Log.VERBOSE)) {
Log.d(TAG,""String_Node_Str"" + msgData.activeSyncContext);
}
if (isSyncStillActiveH(msgData.activeSyncContext)) {
runBoundToAdapter(msgData.activeSyncContext,msgData.adapter);
}
break;
}
case SyncHandler.MESSAGE_SERVICE_DISCONNECTED:
{
final ActiveSyncContext currentSyncContext=((ServiceConnectionData)msg.obj).activeSyncContext;
if (Log.isLoggable(TAG,Log.VERBOSE)) {
Log.d(TAG,""String_Node_Str"" + currentSyncContext);
}
if (isSyncStillActiveH(currentSyncContext)) {
try {
if (currentSyncContext.mSyncAdapter != null) {
currentSyncContext.mSyncAdapter.cancelSync(currentSyncContext);
}
 else if (currentSyncContext.mSyncServiceAdapter != null) {
currentSyncContext.mSyncServiceAdapter.cancelSync(currentSyncContext);
}
}
 catch (RemoteException e) {
}
SyncResult syncResult=new SyncResult();
syncResult.stats.numIoExceptions++;
runSyncFinishedOrCanceledH(syncResult,currentSyncContext);
nextPendingSyncTime=maybeStartNextSyncH();
}
break;
}
case SyncHandler.MESSAGE_SYNC_ALARM:
{
boolean isLoggable=Log.isLoggable(TAG,Log.VERBOSE);
if (isLoggable) {
Log.v(TAG,""String_Node_Str"");
}
mAlarmScheduleTime=null;
try {
nextPendingSyncTime=maybeStartNextSyncH();
}
  finally {
mHandleAlarmWakeLock.release();
}
break;
}
case SyncHandler.MESSAGE_CHECK_ALARMS:
if (Log.isLoggable(TAG,Log.VERBOSE)) {
Log.v(TAG,""String_Node_Str"");
}
nextPendingSyncTime=maybeStartNextSyncH();
break;
case SyncHandler.MESSAGE_SYNC_EXPIRED:
ActiveSyncContext expiredContext=(ActiveSyncContext)msg.obj;
if (Log.isLoggable(TAG,Log.DEBUG)) {
Log.d(TAG,""String_Node_Str"" + ""String_Node_Str"" + expiredContext);
}
runSyncFinishedOrCanceledH(null,expiredContext);
nextPendingSyncTime=maybeStartNextSyncH();
break;
case SyncHandler.MESSAGE_MONITOR_SYNC:
ActiveSyncContext monitoredSyncContext=(ActiveSyncContext)msg.obj;
if (Log.isLoggable(TAG,Log.DEBUG)) {
Log.d(TAG,""String_Node_Str"" + monitoredSyncContext.mSyncOperation.target);
}
if (isSyncNotUsingNetworkH(monitoredSyncContext)) {
Log.w(TAG,String.format(""String_Node_Str"",monitoredSyncContext));
runSyncFinishedOrCanceledH(null,monitoredSyncContext);
}
 else {
postMonitorSyncProgressMessage(monitoredSyncContext);
}
break;
}
}
  finally {
manageSyncAlarmLocked(earliestFuturePollTime,nextPendingSyncTime);
mSyncTimeTracker.update();
mSyncManagerWakeLock.release();
}
}",0.9893210283454186
192908,"private static long registerMethod(Class<?> targetClass,String methodName,Class[] types,int nArgs){
  String methodIndexName=String.format(""String_Node_Str"",methodName,nArgs);
synchronized (sMethodIndexLock) {
    Long methodId=METHOD_NAME_TO_ID.get(methodIndexName);
    if (methodId != null) {
      return methodId;
    }
    Class[] args=new Class[nArgs];
    Method method=null;
    for (    Class typeVariant : types) {
      for (int i=0; i < nArgs; i++) {
        args[i]=typeVariant;
      }
      try {
        method=targetClass.getDeclaredMethod(methodName,args);
      }
 catch (      NoSuchMethodException ignore) {
      }
    }
    if (method != null) {
      methodId=sNextId++;
      ID_TO_METHOD.put(methodId,method);
      METHOD_NAME_TO_ID.put(methodIndexName,methodId);
      return methodId;
    }
  }
  return 0;
}","private static long registerMethod(Class<?> targetClass,String methodName,Class[] types,int nArgs){
  String methodIndexName=String.format(""String_Node_Str"",targetClass.getSimpleName(),methodName,nArgs);
synchronized (sMethodIndexLock) {
    Long methodId=METHOD_NAME_TO_ID.get(methodIndexName);
    if (methodId != null) {
      return methodId;
    }
    Class[] args=new Class[nArgs];
    Method method=null;
    for (    Class typeVariant : types) {
      for (int i=0; i < nArgs; i++) {
        args[i]=typeVariant;
      }
      try {
        method=targetClass.getDeclaredMethod(methodName,args);
      }
 catch (      NoSuchMethodException ignore) {
      }
    }
    if (method != null) {
      methodId=sNextId++;
      ID_TO_METHOD.put(methodId,method);
      METHOD_NAME_TO_ID.put(methodIndexName,methodId);
      return methodId;
    }
  }
  return 0;
}",0.9835680751173708
192909,"private void stepThumbnailAnimation(long currentTime){
  thumbnailTransformation.clear();
  final long animationFrameTime=getAnimationFrameTime(thumbnailAnimation,currentTime);
  thumbnailAnimation.getTransformation(animationFrameTime,thumbnailTransformation);
  thumbnailTransformation.getMatrix().preTranslate(thumbnailX,thumbnailY);
  ScreenRotationAnimation screenRotationAnimation=mAnimator.getScreenRotationAnimationLocked(Display.DEFAULT_DISPLAY);
  final boolean screenAnimation=screenRotationAnimation != null && screenRotationAnimation.isAnimating();
  if (screenAnimation) {
    thumbnailTransformation.postCompose(screenRotationAnimation.getEnterTransformation());
  }
  final float tmpFloats[]=mService.mTmpFloats;
  thumbnailTransformation.getMatrix().getValues(tmpFloats);
  if (SHOW_TRANSACTIONS)   WindowManagerService.logSurface(thumbnail,""String_Node_Str"",""String_Node_Str"" + tmpFloats[Matrix.MTRANS_X] + ""String_Node_Str""+ tmpFloats[Matrix.MTRANS_Y],null);
  thumbnail.setPosition(tmpFloats[Matrix.MTRANS_X],tmpFloats[Matrix.MTRANS_Y]);
  if (SHOW_TRANSACTIONS)   WindowManagerService.logSurface(thumbnail,""String_Node_Str"",""String_Node_Str"" + thumbnailTransformation.getAlpha() + ""String_Node_Str""+ thumbnailLayer+ ""String_Node_Str""+ tmpFloats[Matrix.MSCALE_X]+ ""String_Node_Str""+ tmpFloats[Matrix.MSKEW_Y]+ ""String_Node_Str""+ tmpFloats[Matrix.MSKEW_X]+ ""String_Node_Str""+ tmpFloats[Matrix.MSCALE_Y]+ ""String_Node_Str"",null);
  thumbnail.setAlpha(thumbnailTransformation.getAlpha());
  if (thumbnailForceAboveLayer > 0) {
    thumbnail.setLayer(thumbnailForceAboveLayer + 1);
  }
 else {
    thumbnail.setLayer(thumbnailLayer + WindowManagerService.WINDOW_LAYER_MULTIPLIER - WindowManagerService.LAYER_OFFSET_THUMBNAIL);
  }
  thumbnail.setMatrix(tmpFloats[Matrix.MSCALE_X],tmpFloats[Matrix.MSKEW_Y],tmpFloats[Matrix.MSKEW_X],tmpFloats[Matrix.MSCALE_Y]);
}","private void stepThumbnailAnimation(long currentTime){
  thumbnailTransformation.clear();
  final long animationFrameTime=getAnimationFrameTime(thumbnailAnimation,currentTime);
  thumbnailAnimation.getTransformation(animationFrameTime,thumbnailTransformation);
  thumbnailTransformation.getMatrix().preTranslate(thumbnailX,thumbnailY);
  ScreenRotationAnimation screenRotationAnimation=mAnimator.getScreenRotationAnimationLocked(Display.DEFAULT_DISPLAY);
  final boolean screenAnimation=screenRotationAnimation != null && screenRotationAnimation.isAnimating();
  if (screenAnimation) {
    thumbnailTransformation.postCompose(screenRotationAnimation.getEnterTransformation());
  }
  final float tmpFloats[]=mService.mTmpFloats;
  thumbnailTransformation.getMatrix().getValues(tmpFloats);
  if (SHOW_TRANSACTIONS)   WindowManagerService.logSurface(thumbnail,""String_Node_Str"",""String_Node_Str"" + tmpFloats[Matrix.MTRANS_X] + ""String_Node_Str""+ tmpFloats[Matrix.MTRANS_Y]);
  thumbnail.setPosition(tmpFloats[Matrix.MTRANS_X],tmpFloats[Matrix.MTRANS_Y]);
  if (SHOW_TRANSACTIONS)   WindowManagerService.logSurface(thumbnail,""String_Node_Str"",""String_Node_Str"" + thumbnailTransformation.getAlpha() + ""String_Node_Str""+ thumbnailLayer+ ""String_Node_Str""+ tmpFloats[Matrix.MSCALE_X]+ ""String_Node_Str""+ tmpFloats[Matrix.MSKEW_Y]+ ""String_Node_Str""+ tmpFloats[Matrix.MSKEW_X]+ ""String_Node_Str""+ tmpFloats[Matrix.MSCALE_Y]+ ""String_Node_Str"");
  thumbnail.setAlpha(thumbnailTransformation.getAlpha());
  if (thumbnailForceAboveLayer > 0) {
    thumbnail.setLayer(thumbnailForceAboveLayer + 1);
  }
 else {
    thumbnail.setLayer(thumbnailLayer + WindowManagerService.WINDOW_LAYER_MULTIPLIER - WindowManagerService.LAYER_OFFSET_THUMBNAIL);
  }
  thumbnail.setMatrix(tmpFloats[Matrix.MSCALE_X],tmpFloats[Matrix.MSKEW_Y],tmpFloats[Matrix.MSKEW_X],tmpFloats[Matrix.MSCALE_Y]);
}",0.9973290598290598
192910,"/** 
 * Dig through the WindowStates and find the one that the Input Method will target.
 * @param willMove
 * @return The index+1 in mWindows of the discovered target.
 */
int findDesiredInputMethodWindowIndexLocked(boolean willMove){
  WindowList windows=getDefaultWindowListLocked();
  WindowState w=null;
  int i;
  for (i=windows.size() - 1; i >= 0; --i) {
    WindowState win=windows.get(i);
    if (DEBUG_INPUT_METHOD && willMove)     Slog.i(TAG_WM,""String_Node_Str"" + i + ""String_Node_Str""+ win+ ""String_Node_Str""+ Integer.toHexString(win.mAttrs.flags));
    if (canBeImeTarget(win)) {
      w=win;
      if (!willMove && w.mAttrs.type == TYPE_APPLICATION_STARTING && i > 0) {
        WindowState wb=windows.get(i - 1);
        if (wb.mAppToken == w.mAppToken && canBeImeTarget(wb)) {
          i--;
          w=wb;
        }
      }
      break;
    }
  }
  if (DEBUG_INPUT_METHOD && willMove)   Slog.v(TAG_WM,""String_Node_Str"" + w);
  final WindowState curTarget=mInputMethodTarget;
  if (curTarget != null && curTarget.isDisplayedLw() && curTarget.isClosing() && (w == null || curTarget.mWinAnimator.mAnimLayer > w.mWinAnimator.mAnimLayer)) {
    if (DEBUG_INPUT_METHOD)     Slog.v(TAG_WM,""String_Node_Str"");
    return windows.indexOf(curTarget) + 1;
  }
  if (DEBUG_INPUT_METHOD)   Slog.v(TAG_WM,""String_Node_Str"" + w + ""String_Node_Str""+ willMove);
  if (willMove && w != null) {
    AppWindowToken token=curTarget == null ? null : curTarget.mAppToken;
    if (token != null) {
      WindowState highestTarget=null;
      int highestPos=0;
      if (token.mAppAnimator.animating || token.mAppAnimator.animation != null) {
        WindowList curWindows=curTarget.getWindowList();
        int pos=curWindows.indexOf(curTarget);
        while (pos >= 0) {
          WindowState win=curWindows.get(pos);
          if (win.mAppToken != token) {
            break;
          }
          if (!win.mRemoved) {
            if (highestTarget == null || win.mWinAnimator.mAnimLayer > highestTarget.mWinAnimator.mAnimLayer) {
              highestTarget=win;
              highestPos=pos;
            }
          }
          pos--;
        }
      }
      if (highestTarget != null) {
        if (DEBUG_INPUT_METHOD)         Slog.v(TAG_WM,mAppTransition + ""String_Node_Str"" + highestTarget+ ""String_Node_Str""+ highestTarget.mWinAnimator.isAnimating()+ ""String_Node_Str""+ highestTarget.mWinAnimator.mAnimLayer+ ""String_Node_Str""+ w.mWinAnimator.mAnimLayer);
        if (mAppTransition.isTransitionSet()) {
          mInputMethodTargetWaitingAnim=true;
          mInputMethodTarget=highestTarget;
          return highestPos + 1;
        }
 else         if (highestTarget.mWinAnimator.isAnimating() && highestTarget.mWinAnimator.mAnimLayer > w.mWinAnimator.mAnimLayer) {
          mInputMethodTargetWaitingAnim=true;
          mInputMethodTarget=highestTarget;
          return highestPos + 1;
        }
      }
    }
  }
  if (w != null) {
    if (willMove) {
      if (DEBUG_INPUT_METHOD)       Slog.w(TAG_WM,""String_Node_Str"" + curTarget + ""String_Node_Str""+ w+ (HIDE_STACK_CRAWLS ? ""String_Node_Str"" : ""String_Node_Str"" + Debug.getCallers(4)));
      mInputMethodTarget=w;
      mInputMethodTargetWaitingAnim=false;
      if (w.mAppToken != null) {
        mLayersController.setInputMethodAnimLayerAdjustment(w.mAppToken.mAppAnimator.animLayerAdjustment);
      }
 else {
        mLayersController.setInputMethodAnimLayerAdjustment(0);
      }
    }
    return i + 1;
  }
  if (willMove) {
    if (DEBUG_INPUT_METHOD)     Slog.w(TAG_WM,""String_Node_Str"" + curTarget + ""String_Node_Str""+ (HIDE_STACK_CRAWLS ? ""String_Node_Str"" : ""String_Node_Str"" + Debug.getCallers(4)));
    mInputMethodTarget=null;
    mLayersController.setInputMethodAnimLayerAdjustment(0);
  }
  return -1;
}","/** 
 * Dig through the WindowStates and find the one that the Input Method will target.
 * @param willMove
 * @return The index+1 in mWindows of the discovered target.
 */
int findDesiredInputMethodWindowIndexLocked(boolean willMove){
  WindowList windows=getDefaultWindowListLocked();
  WindowState w=null;
  int i;
  for (i=windows.size() - 1; i >= 0; --i) {
    WindowState win=windows.get(i);
    if (DEBUG_INPUT_METHOD && willMove)     Slog.i(TAG_WM,""String_Node_Str"" + i + ""String_Node_Str""+ win+ ""String_Node_Str""+ Integer.toHexString(win.mAttrs.flags));
    if (canBeImeTarget(win)) {
      w=win;
      if (!willMove && w.mAttrs.type == TYPE_APPLICATION_STARTING && i > 0) {
        WindowState wb=windows.get(i - 1);
        if (wb.mAppToken == w.mAppToken && canBeImeTarget(wb)) {
          i--;
          w=wb;
        }
      }
      break;
    }
  }
  if (DEBUG_INPUT_METHOD && willMove)   Slog.v(TAG_WM,""String_Node_Str"" + w);
  final WindowState curTarget=mInputMethodTarget;
  if (curTarget != null && curTarget.isDisplayedLw() && curTarget.isClosing() && (w == null || curTarget.mWinAnimator.mAnimLayer > w.mWinAnimator.mAnimLayer)) {
    if (DEBUG_INPUT_METHOD)     Slog.v(TAG_WM,""String_Node_Str"");
    return windows.indexOf(curTarget) + 1;
  }
  if (DEBUG_INPUT_METHOD)   Slog.v(TAG_WM,""String_Node_Str"" + w + ""String_Node_Str""+ willMove);
  if (willMove && w != null) {
    AppWindowToken token=curTarget == null ? null : curTarget.mAppToken;
    if (token != null) {
      WindowState highestTarget=null;
      int highestPos=0;
      if (token.mAppAnimator.animating || token.mAppAnimator.animation != null) {
        WindowList curWindows=curTarget.getWindowList();
        int pos=curWindows.indexOf(curTarget);
        while (pos >= 0) {
          WindowState win=curWindows.get(pos);
          if (win.mAppToken != token) {
            break;
          }
          if (!win.mRemoved) {
            if (highestTarget == null || win.mWinAnimator.mAnimLayer > highestTarget.mWinAnimator.mAnimLayer) {
              highestTarget=win;
              highestPos=pos;
            }
          }
          pos--;
        }
      }
      if (highestTarget != null) {
        if (DEBUG_INPUT_METHOD)         Slog.v(TAG_WM,mAppTransition + ""String_Node_Str"" + highestTarget+ ""String_Node_Str""+ highestTarget.mWinAnimator.isAnimating()+ ""String_Node_Str""+ highestTarget.mWinAnimator.mAnimLayer+ ""String_Node_Str""+ w.mWinAnimator.mAnimLayer);
        if (mAppTransition.isTransitionSet()) {
          mInputMethodTargetWaitingAnim=true;
          mInputMethodTarget=highestTarget;
          return highestPos + 1;
        }
 else         if (highestTarget.mWinAnimator.isAnimating() && highestTarget.mWinAnimator.mAnimLayer > w.mWinAnimator.mAnimLayer) {
          mInputMethodTargetWaitingAnim=true;
          mInputMethodTarget=highestTarget;
          return highestPos + 1;
        }
      }
    }
  }
  if (w != null) {
    if (willMove) {
      if (DEBUG_INPUT_METHOD)       Slog.w(TAG_WM,""String_Node_Str"" + curTarget + ""String_Node_Str""+ w+ (SHOW_STACK_CRAWLS ? ""String_Node_Str"" + Debug.getCallers(4) : ""String_Node_Str""));
      mInputMethodTarget=w;
      mInputMethodTargetWaitingAnim=false;
      if (w.mAppToken != null) {
        mLayersController.setInputMethodAnimLayerAdjustment(w.mAppToken.mAppAnimator.animLayerAdjustment);
      }
 else {
        mLayersController.setInputMethodAnimLayerAdjustment(0);
      }
    }
    return i + 1;
  }
  if (willMove) {
    if (DEBUG_INPUT_METHOD)     Slog.w(TAG_WM,""String_Node_Str"" + curTarget + ""String_Node_Str""+ (SHOW_STACK_CRAWLS ? ""String_Node_Str"" + Debug.getCallers(4) : ""String_Node_Str""));
    mInputMethodTarget=null;
    mLayersController.setInputMethodAnimLayerAdjustment(0);
  }
  return -1;
}",0.9867794817556848
192911,"private boolean applyAnimationLocked(AppWindowToken atoken,WindowManager.LayoutParams lp,int transit,boolean enter,boolean isVoiceInteraction){
  if (okToDisplay()) {
    DisplayInfo displayInfo=getDefaultDisplayInfoLocked();
    final int width=displayInfo.appWidth;
    final int height=displayInfo.appHeight;
    if (DEBUG_APP_TRANSITIONS || DEBUG_ANIM)     Slog.v(TAG_WM,""String_Node_Str"" + atoken);
    final WindowState win=atoken.findMainWindow();
    final Rect frame=new Rect(0,0,width,height);
    final Rect insets=new Rect();
    Rect surfaceInsets=null;
    final boolean fullscreen=win != null && win.isFrameFullscreen(displayInfo);
    final boolean freeform=win != null && win.inFreeformWorkspace();
    final boolean docked=win != null && win.inDockedWorkspace();
    if (win != null) {
      if (freeform) {
        frame.set(win.mFrame);
      }
 else {
        frame.set(win.mContainingFrame);
      }
      surfaceInsets=win.getAttrs().surfaceInsets;
      if (fullscreen || docked) {
        insets.set(win.mContentInsets);
      }
    }
    if (atoken.mLaunchTaskBehind) {
      enter=false;
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.d(TAG_WM,""String_Node_Str"" + ""String_Node_Str"" + AppTransition.appTransitionToString(transit) + ""String_Node_Str""+ enter+ ""String_Node_Str""+ frame+ ""String_Node_Str""+ insets+ ""String_Node_Str""+ surfaceInsets);
    Animation a=mAppTransition.loadAnimation(lp,transit,enter,mCurConfiguration.orientation,frame,insets,surfaceInsets,isVoiceInteraction,!fullscreen,atoken.mTask.mTaskId);
    if (a != null) {
      if (DEBUG_ANIM) {
        RuntimeException e=null;
        if (!HIDE_STACK_CRAWLS) {
          e=new RuntimeException();
          e.fillInStackTrace();
        }
        Slog.v(TAG_WM,""String_Node_Str"" + a + ""String_Node_Str""+ atoken,e);
      }
      final int containingWidth=frame.width();
      final int containingHeight=frame.height();
      atoken.mAppAnimator.setAnimation(a,containingWidth,containingHeight,mAppTransition.canSkipFirstFrame());
    }
  }
 else {
    atoken.mAppAnimator.clearAnimation();
  }
  return atoken.mAppAnimator.animation != null;
}","private boolean applyAnimationLocked(AppWindowToken atoken,WindowManager.LayoutParams lp,int transit,boolean enter,boolean isVoiceInteraction){
  if (okToDisplay()) {
    DisplayInfo displayInfo=getDefaultDisplayInfoLocked();
    final int width=displayInfo.appWidth;
    final int height=displayInfo.appHeight;
    if (DEBUG_APP_TRANSITIONS || DEBUG_ANIM)     Slog.v(TAG_WM,""String_Node_Str"" + atoken);
    final WindowState win=atoken.findMainWindow();
    final Rect frame=new Rect(0,0,width,height);
    final Rect insets=new Rect();
    Rect surfaceInsets=null;
    final boolean fullscreen=win != null && win.isFrameFullscreen(displayInfo);
    final boolean freeform=win != null && win.inFreeformWorkspace();
    final boolean docked=win != null && win.inDockedWorkspace();
    if (win != null) {
      if (freeform) {
        frame.set(win.mFrame);
      }
 else {
        frame.set(win.mContainingFrame);
      }
      surfaceInsets=win.getAttrs().surfaceInsets;
      if (fullscreen || docked) {
        insets.set(win.mContentInsets);
      }
    }
    if (atoken.mLaunchTaskBehind) {
      enter=false;
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.d(TAG_WM,""String_Node_Str"" + ""String_Node_Str"" + AppTransition.appTransitionToString(transit) + ""String_Node_Str""+ enter+ ""String_Node_Str""+ frame+ ""String_Node_Str""+ insets+ ""String_Node_Str""+ surfaceInsets);
    Animation a=mAppTransition.loadAnimation(lp,transit,enter,mCurConfiguration.orientation,frame,insets,surfaceInsets,isVoiceInteraction,!fullscreen,atoken.mTask.mTaskId);
    if (a != null) {
      if (DEBUG_ANIM)       logWithStack(TAG,""String_Node_Str"" + a + ""String_Node_Str""+ atoken);
      final int containingWidth=frame.width();
      final int containingHeight=frame.height();
      atoken.mAppAnimator.setAnimation(a,containingWidth,containingHeight,mAppTransition.canSkipFirstFrame());
    }
  }
 else {
    atoken.mAppAnimator.clearAnimation();
  }
  return atoken.mAppAnimator.animation != null;
}",0.8038834951456311
192912,"boolean reclaimSomeSurfaceMemoryLocked(WindowStateAnimator winAnimator,String operation,boolean secure){
  final WindowSurfaceController surfaceController=winAnimator.mSurfaceController;
  boolean leakedSurface=false;
  boolean killedApps=false;
  EventLog.writeEvent(EventLogTags.WM_NO_SURFACE_MEMORY,winAnimator.mWin.toString(),winAnimator.mSession.mPid,operation);
  long callingIdentity=Binder.clearCallingIdentity();
  try {
    Slog.i(TAG_WM,""String_Node_Str"");
    final int numDisplays=mDisplayContents.size();
    for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
      final WindowList windows=mDisplayContents.valueAt(displayNdx).getWindowList();
      final int numWindows=windows.size();
      for (int winNdx=0; winNdx < numWindows; ++winNdx) {
        final WindowState ws=windows.get(winNdx);
        WindowStateAnimator wsa=ws.mWinAnimator;
        if (wsa.mSurfaceController != null) {
          if (!mSessions.contains(wsa.mSession)) {
            Slog.w(TAG_WM,""String_Node_Str"" + ws + ""String_Node_Str""+ wsa.mSurfaceController+ ""String_Node_Str""+ ws.mToken+ ""String_Node_Str""+ ws.mSession.mPid+ ""String_Node_Str""+ ws.mSession.mUid);
            wsa.destroySurface();
            ws.setHasSurface(false);
            mForceRemoves.add(ws);
            leakedSurface=true;
          }
 else           if (ws.mAppToken != null && ws.mAppToken.clientHidden) {
            Slog.w(TAG_WM,""String_Node_Str"" + ws + ""String_Node_Str""+ wsa.mSurfaceController+ ""String_Node_Str""+ ws.mAppToken+ ""String_Node_Str""+ ws.mAppToken.hasSavedSurface());
            if (SHOW_TRANSACTIONS)             logSurface(ws,""String_Node_Str"",null);
            wsa.destroySurface();
            ws.setHasSurface(false);
            leakedSurface=true;
          }
        }
      }
    }
    if (!leakedSurface) {
      Slog.w(TAG_WM,""String_Node_Str"");
      SparseIntArray pidCandidates=new SparseIntArray();
      for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
        final WindowList windows=mDisplayContents.valueAt(displayNdx).getWindowList();
        final int numWindows=windows.size();
        for (int winNdx=0; winNdx < numWindows; ++winNdx) {
          final WindowState ws=windows.get(winNdx);
          if (mForceRemoves.contains(ws)) {
            continue;
          }
          WindowStateAnimator wsa=ws.mWinAnimator;
          if (wsa.mSurfaceController != null) {
            pidCandidates.append(wsa.mSession.mPid,wsa.mSession.mPid);
          }
        }
        if (pidCandidates.size() > 0) {
          int[] pids=new int[pidCandidates.size()];
          for (int i=0; i < pids.length; i++) {
            pids[i]=pidCandidates.keyAt(i);
          }
          try {
            if (mActivityManager.killPids(pids,""String_Node_Str"",secure)) {
              killedApps=true;
            }
          }
 catch (          RemoteException e) {
          }
        }
      }
    }
    if (leakedSurface || killedApps) {
      Slog.w(TAG_WM,""String_Node_Str"");
      if (surfaceController != null) {
        if (SHOW_TRANSACTIONS || SHOW_SURFACE_ALLOC)         logSurface(winAnimator.mWin,""String_Node_Str"",null);
        surfaceController.destroyInTransaction();
        winAnimator.mWin.setHasSurface(false);
        scheduleRemoveStartingWindowLocked(winAnimator.mWin.mAppToken);
      }
      try {
        winAnimator.mWin.mClient.dispatchGetNewSurface();
      }
 catch (      RemoteException e) {
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(callingIdentity);
  }
  return leakedSurface || killedApps;
}","boolean reclaimSomeSurfaceMemoryLocked(WindowStateAnimator winAnimator,String operation,boolean secure){
  final WindowSurfaceController surfaceController=winAnimator.mSurfaceController;
  boolean leakedSurface=false;
  boolean killedApps=false;
  EventLog.writeEvent(EventLogTags.WM_NO_SURFACE_MEMORY,winAnimator.mWin.toString(),winAnimator.mSession.mPid,operation);
  long callingIdentity=Binder.clearCallingIdentity();
  try {
    Slog.i(TAG_WM,""String_Node_Str"");
    final int numDisplays=mDisplayContents.size();
    for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
      final WindowList windows=mDisplayContents.valueAt(displayNdx).getWindowList();
      final int numWindows=windows.size();
      for (int winNdx=0; winNdx < numWindows; ++winNdx) {
        final WindowState ws=windows.get(winNdx);
        WindowStateAnimator wsa=ws.mWinAnimator;
        if (wsa.mSurfaceController != null) {
          if (!mSessions.contains(wsa.mSession)) {
            Slog.w(TAG_WM,""String_Node_Str"" + ws + ""String_Node_Str""+ wsa.mSurfaceController+ ""String_Node_Str""+ ws.mToken+ ""String_Node_Str""+ ws.mSession.mPid+ ""String_Node_Str""+ ws.mSession.mUid);
            wsa.destroySurface();
            ws.setHasSurface(false);
            mForceRemoves.add(ws);
            leakedSurface=true;
          }
 else           if (ws.mAppToken != null && ws.mAppToken.clientHidden) {
            Slog.w(TAG_WM,""String_Node_Str"" + ws + ""String_Node_Str""+ wsa.mSurfaceController+ ""String_Node_Str""+ ws.mAppToken+ ""String_Node_Str""+ ws.mAppToken.hasSavedSurface());
            if (SHOW_TRANSACTIONS)             logSurface(ws,""String_Node_Str"",false);
            wsa.destroySurface();
            ws.setHasSurface(false);
            leakedSurface=true;
          }
        }
      }
    }
    if (!leakedSurface) {
      Slog.w(TAG_WM,""String_Node_Str"");
      SparseIntArray pidCandidates=new SparseIntArray();
      for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
        final WindowList windows=mDisplayContents.valueAt(displayNdx).getWindowList();
        final int numWindows=windows.size();
        for (int winNdx=0; winNdx < numWindows; ++winNdx) {
          final WindowState ws=windows.get(winNdx);
          if (mForceRemoves.contains(ws)) {
            continue;
          }
          WindowStateAnimator wsa=ws.mWinAnimator;
          if (wsa.mSurfaceController != null) {
            pidCandidates.append(wsa.mSession.mPid,wsa.mSession.mPid);
          }
        }
        if (pidCandidates.size() > 0) {
          int[] pids=new int[pidCandidates.size()];
          for (int i=0; i < pids.length; i++) {
            pids[i]=pidCandidates.keyAt(i);
          }
          try {
            if (mActivityManager.killPids(pids,""String_Node_Str"",secure)) {
              killedApps=true;
            }
          }
 catch (          RemoteException e) {
          }
        }
      }
    }
    if (leakedSurface || killedApps) {
      Slog.w(TAG_WM,""String_Node_Str"");
      if (surfaceController != null) {
        if (SHOW_TRANSACTIONS || SHOW_SURFACE_ALLOC)         logSurface(winAnimator.mWin,""String_Node_Str"",false);
        surfaceController.destroyInTransaction();
        winAnimator.mWin.setHasSurface(false);
        scheduleRemoveStartingWindowLocked(winAnimator.mWin.mAppToken);
      }
      try {
        winAnimator.mWin.mClient.dispatchGetNewSurface();
      }
 catch (      RemoteException e) {
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(callingIdentity);
  }
  return leakedSurface || killedApps;
}",0.9974804031354984
192913,"void setTransparentRegionWindow(Session session,IWindow client,Region region){
  long origId=Binder.clearCallingIdentity();
  try {
synchronized (mWindowMap) {
      WindowState w=windowForClientLocked(session,client,false);
      if (SHOW_TRANSACTIONS)       WindowManagerService.logSurface(w,""String_Node_Str"" + region,null);
      if ((w != null) && w.mHasSurface) {
        w.mWinAnimator.setTransparentRegionHintLocked(region);
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}","void setTransparentRegionWindow(Session session,IWindow client,Region region){
  long origId=Binder.clearCallingIdentity();
  try {
synchronized (mWindowMap) {
      WindowState w=windowForClientLocked(session,client,false);
      if (SHOW_TRANSACTIONS)       WindowManagerService.logSurface(w,""String_Node_Str"" + region,false);
      if ((w != null) && w.mHasSurface) {
        w.mWinAnimator.setTransparentRegionHintLocked(region);
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}",0.9912023460410556
192914,"private void startAppFreezingScreenLocked(AppWindowToken wtoken){
  if (DEBUG_ORIENTATION) {
    RuntimeException e=null;
    if (!HIDE_STACK_CRAWLS) {
      e=new RuntimeException();
      e.fillInStackTrace();
    }
    Slog.i(TAG_WM,""String_Node_Str"" + wtoken.appToken + ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ wtoken.mAppAnimator.freezingScreen,e);
  }
  if (!wtoken.hiddenRequested) {
    if (!wtoken.mAppAnimator.freezingScreen) {
      wtoken.mAppAnimator.freezingScreen=true;
      wtoken.mAppAnimator.lastFreezeDuration=0;
      mAppsFreezingScreen++;
      if (mAppsFreezingScreen == 1) {
        startFreezingDisplayLocked(false,0,0);
        mH.removeMessages(H.APP_FREEZE_TIMEOUT);
        mH.sendEmptyMessageDelayed(H.APP_FREEZE_TIMEOUT,2000);
      }
    }
    final int N=wtoken.allAppWindows.size();
    for (int i=0; i < N; i++) {
      WindowState w=wtoken.allAppWindows.get(i);
      w.mAppFreezing=true;
    }
  }
}","private void startAppFreezingScreenLocked(AppWindowToken wtoken){
  if (DEBUG_ORIENTATION)   logWithStack(TAG,""String_Node_Str"" + wtoken.appToken + ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ wtoken.mAppAnimator.freezingScreen);
  if (!wtoken.hiddenRequested) {
    if (!wtoken.mAppAnimator.freezingScreen) {
      wtoken.mAppAnimator.freezingScreen=true;
      wtoken.mAppAnimator.lastFreezeDuration=0;
      mAppsFreezingScreen++;
      if (mAppsFreezingScreen == 1) {
        startFreezingDisplayLocked(false,0,0);
        mH.removeMessages(H.APP_FREEZE_TIMEOUT);
        mH.sendEmptyMessageDelayed(H.APP_FREEZE_TIMEOUT,2000);
      }
    }
    final int N=wtoken.allAppWindows.size();
    for (int i=0; i < N; i++) {
      WindowState w=wtoken.allAppWindows.get(i);
      w.mAppFreezing=true;
    }
  }
}",0.9071347678369196
192915,"static void logSurface(SurfaceControl s,String title,String msg,RuntimeException where){
  String str=""String_Node_Str"" + s + ""String_Node_Str""+ msg+ ""String_Node_Str""+ title;
  if (where != null) {
    Slog.i(TAG_WM,str,where);
  }
 else {
    Slog.i(TAG_WM,str);
  }
}","static void logSurface(SurfaceControl s,String title,String msg){
  String str=""String_Node_Str"" + s + ""String_Node_Str""+ msg+ ""String_Node_Str""+ title;
  Slog.i(TAG_WM,str);
}",0.7892376681614349
192916,"void destroySurfaceLocked(){
  final AppWindowToken wtoken=mWin.mAppToken;
  if (wtoken != null) {
    wtoken.mAnimatingWithSavedSurface=false;
    if (mWin == wtoken.startingWindow) {
      wtoken.startingDisplayed=false;
    }
  }
  mWin.mSurfaceSaved=false;
  if (mSurfaceController != null) {
    int i=mWin.mChildWindows.size();
    while (!mDestroyPreservedSurfaceUponRedraw && i > 0) {
      i--;
      WindowState c=mWin.mChildWindows.get(i);
      c.mAttachedHidden=true;
    }
    try {
      if (DEBUG_VISIBILITY) {
        RuntimeException e=null;
        if (!HIDE_STACK_CRAWLS) {
          e=new RuntimeException();
          e.fillInStackTrace();
        }
        Slog.w(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mSurfaceController+ ""String_Node_Str""+ mSession,e);
      }
      if (mSurfaceDestroyDeferred) {
        if (mSurfaceController != null && mPendingDestroySurface != mSurfaceController) {
          if (mPendingDestroySurface != null) {
            if (SHOW_TRANSACTIONS || SHOW_SURFACE_ALLOC) {
              RuntimeException e=null;
              if (!HIDE_STACK_CRAWLS) {
                e=new RuntimeException();
                e.fillInStackTrace();
              }
              WindowManagerService.logSurface(mWin,""String_Node_Str"",e);
            }
            mPendingDestroySurface.destroyInTransaction();
          }
          mPendingDestroySurface=mSurfaceController;
        }
      }
 else {
        if (SHOW_TRANSACTIONS || SHOW_SURFACE_ALLOC) {
          RuntimeException e=null;
          if (!HIDE_STACK_CRAWLS) {
            e=new RuntimeException();
            e.fillInStackTrace();
          }
          WindowManagerService.logSurface(mWin,""String_Node_Str"",null);
        }
        destroySurface();
      }
      if (!(mSurfaceDestroyDeferred && mDestroyPreservedSurfaceUponRedraw)) {
        mWallpaperControllerLocked.hideWallpapers(mWin);
      }
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mSurfaceController+ ""String_Node_Str""+ mSession+ ""String_Node_Str""+ e.toString());
    }
    mWin.setHasSurface(false);
    if (mSurfaceController != null) {
      mSurfaceController.setShown(false);
    }
    mSurfaceController=null;
    mDrawState=NO_SURFACE;
  }
}","void destroySurfaceLocked(){
  final AppWindowToken wtoken=mWin.mAppToken;
  if (wtoken != null) {
    wtoken.mAnimatingWithSavedSurface=false;
    if (mWin == wtoken.startingWindow) {
      wtoken.startingDisplayed=false;
    }
  }
  mWin.mSurfaceSaved=false;
  if (mSurfaceController != null) {
    int i=mWin.mChildWindows.size();
    while (!mDestroyPreservedSurfaceUponRedraw && i > 0) {
      i--;
      WindowState c=mWin.mChildWindows.get(i);
      c.mAttachedHidden=true;
    }
    try {
      if (DEBUG_VISIBILITY)       logWithStack(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mSurfaceController+ ""String_Node_Str""+ mSession);
      if (mSurfaceDestroyDeferred) {
        if (mSurfaceController != null && mPendingDestroySurface != mSurfaceController) {
          if (mPendingDestroySurface != null) {
            if (SHOW_TRANSACTIONS || SHOW_SURFACE_ALLOC) {
              WindowManagerService.logSurface(mWin,""String_Node_Str"",true);
            }
            mPendingDestroySurface.destroyInTransaction();
          }
          mPendingDestroySurface=mSurfaceController;
        }
      }
 else {
        if (SHOW_TRANSACTIONS || SHOW_SURFACE_ALLOC) {
          WindowManagerService.logSurface(mWin,""String_Node_Str"",true);
        }
        destroySurface();
      }
      if (!(mSurfaceDestroyDeferred && mDestroyPreservedSurfaceUponRedraw)) {
        mWallpaperControllerLocked.hideWallpapers(mWin);
      }
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mSurfaceController+ ""String_Node_Str""+ mSession+ ""String_Node_Str""+ e.toString());
    }
    mWin.setHasSurface(false);
    if (mSurfaceController != null) {
      mSurfaceController.setShown(false);
    }
    mSurfaceController=null;
    mDrawState=NO_SURFACE;
  }
}",0.871694417238002
192917,"WindowSurfaceController createSurfaceLocked(){
  final WindowState w=mWin;
  if (mSurfaceController == null) {
    if (DEBUG_ANIM || DEBUG_ORIENTATION)     Slog.i(TAG,""String_Node_Str"" + this + ""String_Node_Str"");
    mDrawState=DRAW_PENDING;
    if (w.mAppToken != null) {
      if (w.mAppToken.mAppAnimator.animation == null) {
        w.mAppToken.allDrawn=false;
        w.mAppToken.deferClearAllDrawn=false;
      }
 else {
        w.mAppToken.deferClearAllDrawn=true;
      }
    }
    mService.makeWindowFreezingScreenIfNeededLocked(w);
    int flags=SurfaceControl.HIDDEN;
    final WindowManager.LayoutParams attrs=w.mAttrs;
    if (mService.isSecureLocked(w)) {
      flags|=SurfaceControl.SECURE;
    }
    mTmpSize.set(w.mFrame.left + w.mXOffset,w.mFrame.top + w.mYOffset,0,0);
    calculateSurfaceBounds(w,attrs);
    final int width=mTmpSize.width();
    final int height=mTmpSize.height();
    if (DEBUG_VISIBILITY) {
      Slog.v(TAG,""String_Node_Str"" + mSession.mSurfaceSession + ""String_Node_Str""+ this+ ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ mTmpSize.left+ ""String_Node_Str""+ mTmpSize.top+ ""String_Node_Str""+ attrs.format+ ""String_Node_Str""+ flags);
    }
    mLastSystemDecorRect.set(0,0,0,0);
    mHasClipRect=false;
    mClipRect.set(0,0,0,0);
    mLastClipRect.set(0,0,0,0);
    try {
      final boolean isHwAccelerated=(attrs.flags & FLAG_HARDWARE_ACCELERATED) != 0;
      final int format=isHwAccelerated ? PixelFormat.TRANSLUCENT : attrs.format;
      if (!PixelFormat.formatHasAlpha(attrs.format) && attrs.surfaceInsets.left == 0 && attrs.surfaceInsets.top == 0 && attrs.surfaceInsets.right == 0 && attrs.surfaceInsets.bottom == 0 && !w.isDragResizing()) {
        flags|=SurfaceControl.OPAQUE;
      }
      mSurfaceController=new WindowSurfaceController(mSession.mSurfaceSession,attrs.getTitle().toString(),width,height,format,flags,this);
      w.setHasSurface(true);
      if (SHOW_TRANSACTIONS || SHOW_SURFACE_ALLOC) {
        Slog.i(TAG,""String_Node_Str"" + mSurfaceController + ""String_Node_Str""+ mSession.mSurfaceSession+ ""String_Node_Str""+ mSession.mPid+ ""String_Node_Str""+ attrs.format+ ""String_Node_Str""+ Integer.toHexString(flags)+ ""String_Node_Str""+ this);
      }
    }
 catch (    OutOfResourcesException e) {
      w.setHasSurface(false);
      Slog.w(TAG,""String_Node_Str"");
      mService.reclaimSomeSurfaceMemoryLocked(this,""String_Node_Str"",true);
      mDrawState=NO_SURFACE;
      return null;
    }
catch (    Exception e) {
      w.setHasSurface(false);
      Slog.e(TAG,""String_Node_Str"",e);
      mDrawState=NO_SURFACE;
      return null;
    }
    if (WindowManagerService.localLOGV) {
      Slog.v(TAG,""String_Node_Str"" + mSurfaceController + ""String_Node_Str""+ w.mFrame.left+ ""String_Node_Str""+ w.mFrame.top+ ""String_Node_Str""+ mAnimLayer);
    }
    if (SHOW_LIGHT_TRANSACTIONS) {
      Slog.i(TAG,""String_Node_Str"");
      WindowManagerService.logSurface(w,""String_Node_Str"" + w.mFrame.left + ""String_Node_Str""+ w.mFrame.top+ ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ mAnimLayer+ ""String_Node_Str"",null);
    }
    final int layerStack=w.getDisplayContent().getDisplay().getLayerStack();
    if (SHOW_TRANSACTIONS)     WindowManagerService.logSurface(w,""String_Node_Str"" + mTmpSize.left + ""String_Node_Str""+ mTmpSize.top,null);
    mSurfaceController.setPositionAndLayer(mTmpSize.left,mTmpSize.top,layerStack,mAnimLayer);
    mLastHidden=true;
    if (WindowManagerService.localLOGV)     Slog.v(TAG,""String_Node_Str"" + this);
  }
  return mSurfaceController;
}","WindowSurfaceController createSurfaceLocked(){
  final WindowState w=mWin;
  if (mSurfaceController == null) {
    if (DEBUG_ANIM || DEBUG_ORIENTATION)     Slog.i(TAG,""String_Node_Str"" + this + ""String_Node_Str"");
    mDrawState=DRAW_PENDING;
    if (w.mAppToken != null) {
      if (w.mAppToken.mAppAnimator.animation == null) {
        w.mAppToken.allDrawn=false;
        w.mAppToken.deferClearAllDrawn=false;
      }
 else {
        w.mAppToken.deferClearAllDrawn=true;
      }
    }
    mService.makeWindowFreezingScreenIfNeededLocked(w);
    int flags=SurfaceControl.HIDDEN;
    final WindowManager.LayoutParams attrs=w.mAttrs;
    if (mService.isSecureLocked(w)) {
      flags|=SurfaceControl.SECURE;
    }
    mTmpSize.set(w.mFrame.left + w.mXOffset,w.mFrame.top + w.mYOffset,0,0);
    calculateSurfaceBounds(w,attrs);
    final int width=mTmpSize.width();
    final int height=mTmpSize.height();
    if (DEBUG_VISIBILITY) {
      Slog.v(TAG,""String_Node_Str"" + mSession.mSurfaceSession + ""String_Node_Str""+ this+ ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ mTmpSize.left+ ""String_Node_Str""+ mTmpSize.top+ ""String_Node_Str""+ attrs.format+ ""String_Node_Str""+ flags);
    }
    mLastSystemDecorRect.set(0,0,0,0);
    mHasClipRect=false;
    mClipRect.set(0,0,0,0);
    mLastClipRect.set(0,0,0,0);
    try {
      final boolean isHwAccelerated=(attrs.flags & FLAG_HARDWARE_ACCELERATED) != 0;
      final int format=isHwAccelerated ? PixelFormat.TRANSLUCENT : attrs.format;
      if (!PixelFormat.formatHasAlpha(attrs.format) && attrs.surfaceInsets.left == 0 && attrs.surfaceInsets.top == 0 && attrs.surfaceInsets.right == 0 && attrs.surfaceInsets.bottom == 0 && !w.isDragResizing()) {
        flags|=SurfaceControl.OPAQUE;
      }
      mSurfaceController=new WindowSurfaceController(mSession.mSurfaceSession,attrs.getTitle().toString(),width,height,format,flags,this);
      w.setHasSurface(true);
      if (SHOW_TRANSACTIONS || SHOW_SURFACE_ALLOC) {
        Slog.i(TAG,""String_Node_Str"" + mSurfaceController + ""String_Node_Str""+ mSession.mSurfaceSession+ ""String_Node_Str""+ mSession.mPid+ ""String_Node_Str""+ attrs.format+ ""String_Node_Str""+ Integer.toHexString(flags)+ ""String_Node_Str""+ this);
      }
    }
 catch (    OutOfResourcesException e) {
      w.setHasSurface(false);
      Slog.w(TAG,""String_Node_Str"");
      mService.reclaimSomeSurfaceMemoryLocked(this,""String_Node_Str"",true);
      mDrawState=NO_SURFACE;
      return null;
    }
catch (    Exception e) {
      w.setHasSurface(false);
      Slog.e(TAG,""String_Node_Str"",e);
      mDrawState=NO_SURFACE;
      return null;
    }
    if (WindowManagerService.localLOGV) {
      Slog.v(TAG,""String_Node_Str"" + mSurfaceController + ""String_Node_Str""+ w.mFrame.left+ ""String_Node_Str""+ w.mFrame.top+ ""String_Node_Str""+ mAnimLayer);
    }
    if (SHOW_LIGHT_TRANSACTIONS) {
      Slog.i(TAG,""String_Node_Str"");
      WindowManagerService.logSurface(w,""String_Node_Str"" + w.mFrame.left + ""String_Node_Str""+ w.mFrame.top+ ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ mAnimLayer+ ""String_Node_Str"",false);
    }
    final int layerStack=w.getDisplayContent().getDisplay().getLayerStack();
    if (SHOW_TRANSACTIONS)     WindowManagerService.logSurface(w,""String_Node_Str"" + mTmpSize.left + ""String_Node_Str""+ mTmpSize.top,false);
    mSurfaceController.setPositionAndLayer(mTmpSize.left,mTmpSize.top,layerStack,mAnimLayer);
    mLastHidden=true;
    if (WindowManagerService.localLOGV)     Slog.v(TAG,""String_Node_Str"" + this);
  }
  return mSurfaceController;
}",0.9974867355487294
192918,"/** 
 * Choose the correct animation and set it to the passed WindowState.
 * @param transit If AppTransition.TRANSIT_PREVIEW_DONE and the app window has been drawnthen the animation will be app_starting_exit. Any other value loads the animation from the switch statement below.
 * @param isEntrance The animation type the last time this was called. Used to keep fromloading the same animation twice.
 * @return true if an animation has been loaded.
 */
boolean applyAnimationLocked(int transit,boolean isEntrance){
  if ((mLocalAnimating && mAnimationIsEntrance == isEntrance) || mKeyguardGoingAwayAnimation) {
    if (mAnimation != null && mKeyguardGoingAwayAnimation && transit == WindowManagerPolicy.TRANSIT_PREVIEW_DONE) {
      applyFadeoutDuringKeyguardExitAnimation();
    }
    return true;
  }
  if (mService.okToDisplay()) {
    int anim=mPolicy.selectAnimationLw(mWin,transit);
    int attr=-1;
    Animation a=null;
    if (anim != 0) {
      a=anim != -1 ? AnimationUtils.loadAnimation(mContext,anim) : null;
    }
 else {
switch (transit) {
case WindowManagerPolicy.TRANSIT_ENTER:
        attr=com.android.internal.R.styleable.WindowAnimation_windowEnterAnimation;
      break;
case WindowManagerPolicy.TRANSIT_EXIT:
    attr=com.android.internal.R.styleable.WindowAnimation_windowExitAnimation;
  break;
case WindowManagerPolicy.TRANSIT_SHOW:
attr=com.android.internal.R.styleable.WindowAnimation_windowShowAnimation;
break;
case WindowManagerPolicy.TRANSIT_HIDE:
attr=com.android.internal.R.styleable.WindowAnimation_windowHideAnimation;
break;
}
if (attr >= 0) {
a=mService.mAppTransition.loadAnimationAttr(mWin.mAttrs,attr);
}
}
if (DEBUG_ANIM) Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ anim+ ""String_Node_Str""+ Integer.toHexString(attr)+ ""String_Node_Str""+ a+ ""String_Node_Str""+ transit+ ""String_Node_Str""+ isEntrance+ ""String_Node_Str""+ Debug.getCallers(3));
if (a != null) {
if (DEBUG_ANIM) {
RuntimeException e=null;
if (!HIDE_STACK_CRAWLS) {
e=new RuntimeException();
e.fillInStackTrace();
}
Slog.v(TAG,""String_Node_Str"" + a + ""String_Node_Str""+ this,e);
}
setAnimation(a);
mAnimationIsEntrance=isEntrance;
}
}
 else {
clearAnimation();
}
return mAnimation != null;
}","/** 
 * Choose the correct animation and set it to the passed WindowState.
 * @param transit If AppTransition.TRANSIT_PREVIEW_DONE and the app window has been drawnthen the animation will be app_starting_exit. Any other value loads the animation from the switch statement below.
 * @param isEntrance The animation type the last time this was called. Used to keep fromloading the same animation twice.
 * @return true if an animation has been loaded.
 */
boolean applyAnimationLocked(int transit,boolean isEntrance){
  if ((mLocalAnimating && mAnimationIsEntrance == isEntrance) || mKeyguardGoingAwayAnimation) {
    if (mAnimation != null && mKeyguardGoingAwayAnimation && transit == WindowManagerPolicy.TRANSIT_PREVIEW_DONE) {
      applyFadeoutDuringKeyguardExitAnimation();
    }
    return true;
  }
  if (mService.okToDisplay()) {
    int anim=mPolicy.selectAnimationLw(mWin,transit);
    int attr=-1;
    Animation a=null;
    if (anim != 0) {
      a=anim != -1 ? AnimationUtils.loadAnimation(mContext,anim) : null;
    }
 else {
switch (transit) {
case WindowManagerPolicy.TRANSIT_ENTER:
        attr=com.android.internal.R.styleable.WindowAnimation_windowEnterAnimation;
      break;
case WindowManagerPolicy.TRANSIT_EXIT:
    attr=com.android.internal.R.styleable.WindowAnimation_windowExitAnimation;
  break;
case WindowManagerPolicy.TRANSIT_SHOW:
attr=com.android.internal.R.styleable.WindowAnimation_windowShowAnimation;
break;
case WindowManagerPolicy.TRANSIT_HIDE:
attr=com.android.internal.R.styleable.WindowAnimation_windowHideAnimation;
break;
}
if (attr >= 0) {
a=mService.mAppTransition.loadAnimationAttr(mWin.mAttrs,attr);
}
}
if (DEBUG_ANIM) Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ anim+ ""String_Node_Str""+ Integer.toHexString(attr)+ ""String_Node_Str""+ a+ ""String_Node_Str""+ transit+ ""String_Node_Str""+ isEntrance+ ""String_Node_Str""+ Debug.getCallers(3));
if (a != null) {
if (DEBUG_ANIM) logWithStack(TAG,""String_Node_Str"" + a + ""String_Node_Str""+ this);
setAnimation(a);
mAnimationIsEntrance=isEntrance;
}
}
 else {
clearAnimation();
}
return mAnimation != null;
}",0.9130132219902576
192919,"void preserveSurfaceLocked(){
  if (mDestroyPreservedSurfaceUponRedraw) {
    return;
  }
  if (SHOW_TRANSACTIONS)   WindowManagerService.logSurface(mWin,""String_Node_Str"",null);
  if (mSurfaceController != null) {
    mSurfaceController.setLayer(mAnimLayer + 1);
  }
  mDestroyPreservedSurfaceUponRedraw=true;
  mSurfaceDestroyDeferred=true;
  destroySurfaceLocked();
}","void preserveSurfaceLocked(){
  if (mDestroyPreservedSurfaceUponRedraw) {
    return;
  }
  if (SHOW_TRANSACTIONS)   WindowManagerService.logSurface(mWin,""String_Node_Str"",false);
  if (mSurfaceController != null) {
    mSurfaceController.setLayer(mAnimLayer + 1);
  }
  mDestroyPreservedSurfaceUponRedraw=true;
  mSurfaceDestroyDeferred=true;
  destroySurfaceLocked();
}",0.9878542510121456
192920,"void prepareSurfaceLocked(final boolean recoveringMemory){
  final WindowState w=mWin;
  if (mSurfaceController == null || !mSurfaceController.hasSurface()) {
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION) {
        Slog.v(TAG,""String_Node_Str"" + w);
      }
      w.mOrientationChanging=false;
    }
    return;
  }
  boolean displayed=false;
  computeShownFrameLocked();
  setSurfaceBoundariesLocked(recoveringMemory);
  if (mIsWallpaper && !mWin.mWallpaperVisible) {
    hide(""String_Node_Str"");
  }
 else   if (w.mAttachedHidden || !w.isOnScreen()) {
    hide(""String_Node_Str"");
    mWallpaperControllerLocked.hideWallpapers(w);
    if (w.mOrientationChanging) {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
  }
 else   if (mLastLayer != mAnimLayer || mLastAlpha != mShownAlpha || mLastDsDx != mDsDx || mLastDtDx != mDtDx || mLastDsDy != mDsDy || mLastDtDy != mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || mLastHidden) {
    displayed=true;
    mLastAlpha=mShownAlpha;
    mLastLayer=mAnimLayer;
    mLastDsDx=mDsDx;
    mLastDtDx=mDtDx;
    mLastDsDy=mDsDy;
    mLastDtDy=mDtDy;
    w.mLastHScale=w.mHScale;
    w.mLastVScale=w.mVScale;
    if (SHOW_TRANSACTIONS)     WindowManagerService.logSurface(w,""String_Node_Str"" + mSurfaceController + ""String_Node_Str""+ mShownAlpha+ ""String_Node_Str""+ mAnimLayer+ ""String_Node_Str""+ mDsDx+ ""String_Node_Str""+ w.mHScale+ ""String_Node_Str""+ mDtDx+ ""String_Node_Str""+ w.mVScale+ ""String_Node_Str""+ mDsDy+ ""String_Node_Str""+ w.mHScale+ ""String_Node_Str""+ mDtDy+ ""String_Node_Str""+ w.mVScale+ ""String_Node_Str"",null);
    boolean prepared=mSurfaceController.prepareToShowInTransaction(mShownAlpha,mAnimLayer,mDsDx * w.mHScale,mDtDx * w.mVScale,mDsDy * w.mHScale,mDtDy * w.mVScale,recoveringMemory);
    if (prepared && mLastHidden && mDrawState == HAS_DRAWN) {
      if (showSurfaceRobustlyLocked()) {
        mAnimator.requestRemovalOfReplacedWindows(w);
        mLastHidden=false;
        if (mIsWallpaper) {
          mWallpaperControllerLocked.dispatchWallpaperVisibility(w,true);
        }
        mAnimator.setPendingLayoutChanges(w.getDisplayId(),WindowManagerPolicy.FINISH_LAYOUT_REDO_ANIM);
      }
 else {
        w.mOrientationChanging=false;
      }
    }
    if (mSurfaceController != null && mSurfaceController.hasSurface()) {
      w.mToken.hasVisible=true;
    }
  }
 else {
    if (DEBUG_ANIM && isAnimating()) {
      Slog.v(TAG,""String_Node_Str"" + this);
    }
    displayed=true;
  }
  if (displayed) {
    if (w.mOrientationChanging) {
      if (!w.isDrawnLw()) {
        mAnimator.mBulkUpdateParams&=~SET_ORIENTATION_CHANGE_COMPLETE;
        mAnimator.mLastWindowFreezeSource=w;
        if (DEBUG_ORIENTATION)         Slog.v(TAG,""String_Node_Str"" + w);
      }
 else {
        w.mOrientationChanging=false;
        if (DEBUG_ORIENTATION)         Slog.v(TAG,""String_Node_Str"" + w);
      }
    }
    w.mToken.hasVisible=true;
    final Task task=w.getTask();
    if (task != null) {
      task.scheduleShowNonResizeableDockToastIfNeeded();
    }
  }
}","void prepareSurfaceLocked(final boolean recoveringMemory){
  final WindowState w=mWin;
  if (mSurfaceController == null || !mSurfaceController.hasSurface()) {
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION) {
        Slog.v(TAG,""String_Node_Str"" + w);
      }
      w.mOrientationChanging=false;
    }
    return;
  }
  boolean displayed=false;
  computeShownFrameLocked();
  setSurfaceBoundariesLocked(recoveringMemory);
  if (mIsWallpaper && !mWin.mWallpaperVisible) {
    hide(""String_Node_Str"");
  }
 else   if (w.mAttachedHidden || !w.isOnScreen()) {
    hide(""String_Node_Str"");
    mWallpaperControllerLocked.hideWallpapers(w);
    if (w.mOrientationChanging) {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
  }
 else   if (mLastLayer != mAnimLayer || mLastAlpha != mShownAlpha || mLastDsDx != mDsDx || mLastDtDx != mDtDx || mLastDsDy != mDsDy || mLastDtDy != mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || mLastHidden) {
    displayed=true;
    mLastAlpha=mShownAlpha;
    mLastLayer=mAnimLayer;
    mLastDsDx=mDsDx;
    mLastDtDx=mDtDx;
    mLastDsDy=mDsDy;
    mLastDtDy=mDtDy;
    w.mLastHScale=w.mHScale;
    w.mLastVScale=w.mVScale;
    if (SHOW_TRANSACTIONS)     WindowManagerService.logSurface(w,""String_Node_Str"" + mSurfaceController + ""String_Node_Str""+ mShownAlpha+ ""String_Node_Str""+ mAnimLayer+ ""String_Node_Str""+ mDsDx+ ""String_Node_Str""+ w.mHScale+ ""String_Node_Str""+ mDtDx+ ""String_Node_Str""+ w.mVScale+ ""String_Node_Str""+ mDsDy+ ""String_Node_Str""+ w.mHScale+ ""String_Node_Str""+ mDtDy+ ""String_Node_Str""+ w.mVScale+ ""String_Node_Str"",false);
    boolean prepared=mSurfaceController.prepareToShowInTransaction(mShownAlpha,mAnimLayer,mDsDx * w.mHScale,mDtDx * w.mVScale,mDsDy * w.mHScale,mDtDy * w.mVScale,recoveringMemory);
    if (prepared && mLastHidden && mDrawState == HAS_DRAWN) {
      if (showSurfaceRobustlyLocked()) {
        mAnimator.requestRemovalOfReplacedWindows(w);
        mLastHidden=false;
        if (mIsWallpaper) {
          mWallpaperControllerLocked.dispatchWallpaperVisibility(w,true);
        }
        mAnimator.setPendingLayoutChanges(w.getDisplayId(),WindowManagerPolicy.FINISH_LAYOUT_REDO_ANIM);
      }
 else {
        w.mOrientationChanging=false;
      }
    }
    if (mSurfaceController != null && mSurfaceController.hasSurface()) {
      w.mToken.hasVisible=true;
    }
  }
 else {
    if (DEBUG_ANIM && isAnimating()) {
      Slog.v(TAG,""String_Node_Str"" + this);
    }
    displayed=true;
  }
  if (displayed) {
    if (w.mOrientationChanging) {
      if (!w.isDrawnLw()) {
        mAnimator.mBulkUpdateParams&=~SET_ORIENTATION_CHANGE_COMPLETE;
        mAnimator.mLastWindowFreezeSource=w;
        if (DEBUG_ORIENTATION)         Slog.v(TAG,""String_Node_Str"" + w);
      }
 else {
        w.mOrientationChanging=false;
        if (DEBUG_ORIENTATION)         Slog.v(TAG,""String_Node_Str"" + w);
      }
    }
    w.mToken.hasVisible=true;
    final Task task=w.getTask();
    if (task != null) {
      task.scheduleShowNonResizeableDockToastIfNeeded();
    }
  }
}",0.9985583853916388
192921,"void destroyDeferredSurfaceLocked(){
  try {
    if (mPendingDestroySurface != null) {
      if (SHOW_TRANSACTIONS || SHOW_SURFACE_ALLOC) {
        RuntimeException e=null;
        if (!HIDE_STACK_CRAWLS) {
          e=new RuntimeException();
          e.fillInStackTrace();
        }
        WindowManagerService.logSurface(mWin,""String_Node_Str"",e);
      }
      mPendingDestroySurface.destroyInTransaction();
      if (!mDestroyPreservedSurfaceUponRedraw) {
        mWallpaperControllerLocked.hideWallpapers(mWin);
      }
    }
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mPendingDestroySurface+ ""String_Node_Str""+ mSession+ ""String_Node_Str""+ e.toString());
  }
  mSurfaceDestroyDeferred=false;
  mPendingDestroySurface=null;
}","void destroyDeferredSurfaceLocked(){
  try {
    if (mPendingDestroySurface != null) {
      if (SHOW_TRANSACTIONS || SHOW_SURFACE_ALLOC) {
        WindowManagerService.logSurface(mWin,""String_Node_Str"",true);
      }
      mPendingDestroySurface.destroyInTransaction();
      if (!mDestroyPreservedSurfaceUponRedraw) {
        mWallpaperControllerLocked.hideWallpapers(mWin);
      }
    }
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mPendingDestroySurface+ ""String_Node_Str""+ mSession+ ""String_Node_Str""+ e.toString());
  }
  mSurfaceDestroyDeferred=false;
  mPendingDestroySurface=null;
}",0.8965034965034965
192922,"private static long registerMethod(Class<?> targetClass,String methodName,Class[] types,int nArgs){
  String methodIndexName=String.format(""String_Node_Str"",methodName,nArgs);
synchronized (sMethodIndexLock) {
    Long methodId=METHOD_NAME_TO_ID.get(methodIndexName);
    if (methodId != null) {
      return methodId;
    }
    Class[] args=new Class[nArgs];
    Method method=null;
    for (    Class typeVariant : types) {
      for (int i=0; i < nArgs; i++) {
        args[i]=typeVariant;
      }
      try {
        method=targetClass.getDeclaredMethod(methodName,args);
      }
 catch (      NoSuchMethodException ignore) {
      }
    }
    if (method != null) {
      methodId=sNextId++;
      ID_TO_METHOD.put(methodId,method);
      METHOD_NAME_TO_ID.put(methodIndexName,methodId);
      return methodId;
    }
  }
  return 0;
}","private static long registerMethod(Class<?> targetClass,String methodName,Class[] types,int nArgs){
  String methodIndexName=String.format(""String_Node_Str"",targetClass.getSimpleName(),methodName,nArgs);
synchronized (sMethodIndexLock) {
    Long methodId=METHOD_NAME_TO_ID.get(methodIndexName);
    if (methodId != null) {
      return methodId;
    }
    Class[] args=new Class[nArgs];
    Method method=null;
    for (    Class typeVariant : types) {
      for (int i=0; i < nArgs; i++) {
        args[i]=typeVariant;
      }
      try {
        method=targetClass.getDeclaredMethod(methodName,args);
      }
 catch (      NoSuchMethodException ignore) {
      }
    }
    if (method != null) {
      methodId=sNextId++;
      ID_TO_METHOD.put(methodId,method);
      METHOD_NAME_TO_ID.put(methodIndexName,methodId);
      return methodId;
    }
  }
  return 0;
}",0.9835680751173708
192923,"private void stepThumbnailAnimation(long currentTime){
  thumbnailTransformation.clear();
  final long animationFrameTime=getAnimationFrameTime(thumbnailAnimation,currentTime);
  thumbnailAnimation.getTransformation(animationFrameTime,thumbnailTransformation);
  thumbnailTransformation.getMatrix().preTranslate(thumbnailX,thumbnailY);
  ScreenRotationAnimation screenRotationAnimation=mAnimator.getScreenRotationAnimationLocked(Display.DEFAULT_DISPLAY);
  final boolean screenAnimation=screenRotationAnimation != null && screenRotationAnimation.isAnimating();
  if (screenAnimation) {
    thumbnailTransformation.postCompose(screenRotationAnimation.getEnterTransformation());
  }
  final float tmpFloats[]=mService.mTmpFloats;
  thumbnailTransformation.getMatrix().getValues(tmpFloats);
  if (SHOW_TRANSACTIONS)   WindowManagerService.logSurface(thumbnail,""String_Node_Str"",""String_Node_Str"" + tmpFloats[Matrix.MTRANS_X] + ""String_Node_Str""+ tmpFloats[Matrix.MTRANS_Y],null);
  thumbnail.setPosition(tmpFloats[Matrix.MTRANS_X],tmpFloats[Matrix.MTRANS_Y]);
  if (SHOW_TRANSACTIONS)   WindowManagerService.logSurface(thumbnail,""String_Node_Str"",""String_Node_Str"" + thumbnailTransformation.getAlpha() + ""String_Node_Str""+ thumbnailLayer+ ""String_Node_Str""+ tmpFloats[Matrix.MSCALE_X]+ ""String_Node_Str""+ tmpFloats[Matrix.MSKEW_Y]+ ""String_Node_Str""+ tmpFloats[Matrix.MSKEW_X]+ ""String_Node_Str""+ tmpFloats[Matrix.MSCALE_Y]+ ""String_Node_Str"",null);
  thumbnail.setAlpha(thumbnailTransformation.getAlpha());
  if (thumbnailForceAboveLayer > 0) {
    thumbnail.setLayer(thumbnailForceAboveLayer + 1);
  }
 else {
    thumbnail.setLayer(thumbnailLayer + WindowManagerService.WINDOW_LAYER_MULTIPLIER - WindowManagerService.LAYER_OFFSET_THUMBNAIL);
  }
  thumbnail.setMatrix(tmpFloats[Matrix.MSCALE_X],tmpFloats[Matrix.MSKEW_Y],tmpFloats[Matrix.MSKEW_X],tmpFloats[Matrix.MSCALE_Y]);
}","private void stepThumbnailAnimation(long currentTime){
  thumbnailTransformation.clear();
  final long animationFrameTime=getAnimationFrameTime(thumbnailAnimation,currentTime);
  thumbnailAnimation.getTransformation(animationFrameTime,thumbnailTransformation);
  thumbnailTransformation.getMatrix().preTranslate(thumbnailX,thumbnailY);
  ScreenRotationAnimation screenRotationAnimation=mAnimator.getScreenRotationAnimationLocked(Display.DEFAULT_DISPLAY);
  final boolean screenAnimation=screenRotationAnimation != null && screenRotationAnimation.isAnimating();
  if (screenAnimation) {
    thumbnailTransformation.postCompose(screenRotationAnimation.getEnterTransformation());
  }
  final float tmpFloats[]=mService.mTmpFloats;
  thumbnailTransformation.getMatrix().getValues(tmpFloats);
  if (SHOW_TRANSACTIONS)   WindowManagerService.logSurface(thumbnail,""String_Node_Str"",""String_Node_Str"" + tmpFloats[Matrix.MTRANS_X] + ""String_Node_Str""+ tmpFloats[Matrix.MTRANS_Y]);
  thumbnail.setPosition(tmpFloats[Matrix.MTRANS_X],tmpFloats[Matrix.MTRANS_Y]);
  if (SHOW_TRANSACTIONS)   WindowManagerService.logSurface(thumbnail,""String_Node_Str"",""String_Node_Str"" + thumbnailTransformation.getAlpha() + ""String_Node_Str""+ thumbnailLayer+ ""String_Node_Str""+ tmpFloats[Matrix.MSCALE_X]+ ""String_Node_Str""+ tmpFloats[Matrix.MSKEW_Y]+ ""String_Node_Str""+ tmpFloats[Matrix.MSKEW_X]+ ""String_Node_Str""+ tmpFloats[Matrix.MSCALE_Y]+ ""String_Node_Str"");
  thumbnail.setAlpha(thumbnailTransformation.getAlpha());
  if (thumbnailForceAboveLayer > 0) {
    thumbnail.setLayer(thumbnailForceAboveLayer + 1);
  }
 else {
    thumbnail.setLayer(thumbnailLayer + WindowManagerService.WINDOW_LAYER_MULTIPLIER - WindowManagerService.LAYER_OFFSET_THUMBNAIL);
  }
  thumbnail.setMatrix(tmpFloats[Matrix.MSCALE_X],tmpFloats[Matrix.MSKEW_Y],tmpFloats[Matrix.MSKEW_X],tmpFloats[Matrix.MSCALE_Y]);
}",0.9973290598290598
192924,"/** 
 * Dig through the WindowStates and find the one that the Input Method will target.
 * @param willMove
 * @return The index+1 in mWindows of the discovered target.
 */
int findDesiredInputMethodWindowIndexLocked(boolean willMove){
  WindowList windows=getDefaultWindowListLocked();
  WindowState w=null;
  int i;
  for (i=windows.size() - 1; i >= 0; --i) {
    WindowState win=windows.get(i);
    if (DEBUG_INPUT_METHOD && willMove)     Slog.i(TAG_WM,""String_Node_Str"" + i + ""String_Node_Str""+ win+ ""String_Node_Str""+ Integer.toHexString(win.mAttrs.flags));
    if (canBeImeTarget(win)) {
      w=win;
      if (!willMove && w.mAttrs.type == TYPE_APPLICATION_STARTING && i > 0) {
        WindowState wb=windows.get(i - 1);
        if (wb.mAppToken == w.mAppToken && canBeImeTarget(wb)) {
          i--;
          w=wb;
        }
      }
      break;
    }
  }
  if (DEBUG_INPUT_METHOD && willMove)   Slog.v(TAG_WM,""String_Node_Str"" + w);
  final WindowState curTarget=mInputMethodTarget;
  if (curTarget != null && curTarget.isDisplayedLw() && curTarget.isClosing() && (w == null || curTarget.mWinAnimator.mAnimLayer > w.mWinAnimator.mAnimLayer)) {
    if (DEBUG_INPUT_METHOD)     Slog.v(TAG_WM,""String_Node_Str"");
    return windows.indexOf(curTarget) + 1;
  }
  if (DEBUG_INPUT_METHOD)   Slog.v(TAG_WM,""String_Node_Str"" + w + ""String_Node_Str""+ willMove);
  if (willMove && w != null) {
    AppWindowToken token=curTarget == null ? null : curTarget.mAppToken;
    if (token != null) {
      WindowState highestTarget=null;
      int highestPos=0;
      if (token.mAppAnimator.animating || token.mAppAnimator.animation != null) {
        WindowList curWindows=curTarget.getWindowList();
        int pos=curWindows.indexOf(curTarget);
        while (pos >= 0) {
          WindowState win=curWindows.get(pos);
          if (win.mAppToken != token) {
            break;
          }
          if (!win.mRemoved) {
            if (highestTarget == null || win.mWinAnimator.mAnimLayer > highestTarget.mWinAnimator.mAnimLayer) {
              highestTarget=win;
              highestPos=pos;
            }
          }
          pos--;
        }
      }
      if (highestTarget != null) {
        if (DEBUG_INPUT_METHOD)         Slog.v(TAG_WM,mAppTransition + ""String_Node_Str"" + highestTarget+ ""String_Node_Str""+ highestTarget.mWinAnimator.isAnimating()+ ""String_Node_Str""+ highestTarget.mWinAnimator.mAnimLayer+ ""String_Node_Str""+ w.mWinAnimator.mAnimLayer);
        if (mAppTransition.isTransitionSet()) {
          mInputMethodTargetWaitingAnim=true;
          mInputMethodTarget=highestTarget;
          return highestPos + 1;
        }
 else         if (highestTarget.mWinAnimator.isAnimating() && highestTarget.mWinAnimator.mAnimLayer > w.mWinAnimator.mAnimLayer) {
          mInputMethodTargetWaitingAnim=true;
          mInputMethodTarget=highestTarget;
          return highestPos + 1;
        }
      }
    }
  }
  if (w != null) {
    if (willMove) {
      if (DEBUG_INPUT_METHOD)       Slog.w(TAG_WM,""String_Node_Str"" + curTarget + ""String_Node_Str""+ w+ (HIDE_STACK_CRAWLS ? ""String_Node_Str"" : ""String_Node_Str"" + Debug.getCallers(4)));
      mInputMethodTarget=w;
      mInputMethodTargetWaitingAnim=false;
      if (w.mAppToken != null) {
        mLayersController.setInputMethodAnimLayerAdjustment(w.mAppToken.mAppAnimator.animLayerAdjustment);
      }
 else {
        mLayersController.setInputMethodAnimLayerAdjustment(0);
      }
    }
    return i + 1;
  }
  if (willMove) {
    if (DEBUG_INPUT_METHOD)     Slog.w(TAG_WM,""String_Node_Str"" + curTarget + ""String_Node_Str""+ (HIDE_STACK_CRAWLS ? ""String_Node_Str"" : ""String_Node_Str"" + Debug.getCallers(4)));
    mInputMethodTarget=null;
    mLayersController.setInputMethodAnimLayerAdjustment(0);
  }
  return -1;
}","/** 
 * Dig through the WindowStates and find the one that the Input Method will target.
 * @param willMove
 * @return The index+1 in mWindows of the discovered target.
 */
int findDesiredInputMethodWindowIndexLocked(boolean willMove){
  WindowList windows=getDefaultWindowListLocked();
  WindowState w=null;
  int i;
  for (i=windows.size() - 1; i >= 0; --i) {
    WindowState win=windows.get(i);
    if (DEBUG_INPUT_METHOD && willMove)     Slog.i(TAG_WM,""String_Node_Str"" + i + ""String_Node_Str""+ win+ ""String_Node_Str""+ Integer.toHexString(win.mAttrs.flags));
    if (canBeImeTarget(win)) {
      w=win;
      if (!willMove && w.mAttrs.type == TYPE_APPLICATION_STARTING && i > 0) {
        WindowState wb=windows.get(i - 1);
        if (wb.mAppToken == w.mAppToken && canBeImeTarget(wb)) {
          i--;
          w=wb;
        }
      }
      break;
    }
  }
  if (DEBUG_INPUT_METHOD && willMove)   Slog.v(TAG_WM,""String_Node_Str"" + w);
  final WindowState curTarget=mInputMethodTarget;
  if (curTarget != null && curTarget.isDisplayedLw() && curTarget.isClosing() && (w == null || curTarget.mWinAnimator.mAnimLayer > w.mWinAnimator.mAnimLayer)) {
    if (DEBUG_INPUT_METHOD)     Slog.v(TAG_WM,""String_Node_Str"");
    return windows.indexOf(curTarget) + 1;
  }
  if (DEBUG_INPUT_METHOD)   Slog.v(TAG_WM,""String_Node_Str"" + w + ""String_Node_Str""+ willMove);
  if (willMove && w != null) {
    AppWindowToken token=curTarget == null ? null : curTarget.mAppToken;
    if (token != null) {
      WindowState highestTarget=null;
      int highestPos=0;
      if (token.mAppAnimator.animating || token.mAppAnimator.animation != null) {
        WindowList curWindows=curTarget.getWindowList();
        int pos=curWindows.indexOf(curTarget);
        while (pos >= 0) {
          WindowState win=curWindows.get(pos);
          if (win.mAppToken != token) {
            break;
          }
          if (!win.mRemoved) {
            if (highestTarget == null || win.mWinAnimator.mAnimLayer > highestTarget.mWinAnimator.mAnimLayer) {
              highestTarget=win;
              highestPos=pos;
            }
          }
          pos--;
        }
      }
      if (highestTarget != null) {
        if (DEBUG_INPUT_METHOD)         Slog.v(TAG_WM,mAppTransition + ""String_Node_Str"" + highestTarget+ ""String_Node_Str""+ highestTarget.mWinAnimator.isAnimating()+ ""String_Node_Str""+ highestTarget.mWinAnimator.mAnimLayer+ ""String_Node_Str""+ w.mWinAnimator.mAnimLayer);
        if (mAppTransition.isTransitionSet()) {
          mInputMethodTargetWaitingAnim=true;
          mInputMethodTarget=highestTarget;
          return highestPos + 1;
        }
 else         if (highestTarget.mWinAnimator.isAnimating() && highestTarget.mWinAnimator.mAnimLayer > w.mWinAnimator.mAnimLayer) {
          mInputMethodTargetWaitingAnim=true;
          mInputMethodTarget=highestTarget;
          return highestPos + 1;
        }
      }
    }
  }
  if (w != null) {
    if (willMove) {
      if (DEBUG_INPUT_METHOD)       Slog.w(TAG_WM,""String_Node_Str"" + curTarget + ""String_Node_Str""+ w+ (SHOW_STACK_CRAWLS ? ""String_Node_Str"" + Debug.getCallers(4) : ""String_Node_Str""));
      mInputMethodTarget=w;
      mInputMethodTargetWaitingAnim=false;
      if (w.mAppToken != null) {
        mLayersController.setInputMethodAnimLayerAdjustment(w.mAppToken.mAppAnimator.animLayerAdjustment);
      }
 else {
        mLayersController.setInputMethodAnimLayerAdjustment(0);
      }
    }
    return i + 1;
  }
  if (willMove) {
    if (DEBUG_INPUT_METHOD)     Slog.w(TAG_WM,""String_Node_Str"" + curTarget + ""String_Node_Str""+ (SHOW_STACK_CRAWLS ? ""String_Node_Str"" + Debug.getCallers(4) : ""String_Node_Str""));
    mInputMethodTarget=null;
    mLayersController.setInputMethodAnimLayerAdjustment(0);
  }
  return -1;
}",0.9867794817556848
192925,"private boolean applyAnimationLocked(AppWindowToken atoken,WindowManager.LayoutParams lp,int transit,boolean enter,boolean isVoiceInteraction){
  if (okToDisplay()) {
    DisplayInfo displayInfo=getDefaultDisplayInfoLocked();
    final int width=displayInfo.appWidth;
    final int height=displayInfo.appHeight;
    if (DEBUG_APP_TRANSITIONS || DEBUG_ANIM)     Slog.v(TAG_WM,""String_Node_Str"" + atoken);
    final WindowState win=atoken.findMainWindow();
    final Rect frame=new Rect(0,0,width,height);
    final Rect insets=new Rect();
    Rect surfaceInsets=null;
    final boolean fullscreen=win != null && win.isFrameFullscreen(displayInfo);
    final boolean freeform=win != null && win.inFreeformWorkspace();
    final boolean docked=win != null && win.inDockedWorkspace();
    if (win != null) {
      if (freeform) {
        frame.set(win.mFrame);
      }
 else {
        frame.set(win.mContainingFrame);
      }
      surfaceInsets=win.getAttrs().surfaceInsets;
      if (fullscreen || docked) {
        insets.set(win.mContentInsets);
      }
    }
    if (atoken.mLaunchTaskBehind) {
      enter=false;
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.d(TAG_WM,""String_Node_Str"" + ""String_Node_Str"" + AppTransition.appTransitionToString(transit) + ""String_Node_Str""+ enter+ ""String_Node_Str""+ frame+ ""String_Node_Str""+ insets+ ""String_Node_Str""+ surfaceInsets);
    Animation a=mAppTransition.loadAnimation(lp,transit,enter,mCurConfiguration.orientation,frame,insets,surfaceInsets,isVoiceInteraction,!fullscreen,atoken.mTask.mTaskId);
    if (a != null) {
      if (DEBUG_ANIM) {
        RuntimeException e=null;
        if (!HIDE_STACK_CRAWLS) {
          e=new RuntimeException();
          e.fillInStackTrace();
        }
        Slog.v(TAG_WM,""String_Node_Str"" + a + ""String_Node_Str""+ atoken,e);
      }
      final int containingWidth=frame.width();
      final int containingHeight=frame.height();
      atoken.mAppAnimator.setAnimation(a,containingWidth,containingHeight,mAppTransition.canSkipFirstFrame());
    }
  }
 else {
    atoken.mAppAnimator.clearAnimation();
  }
  return atoken.mAppAnimator.animation != null;
}","private boolean applyAnimationLocked(AppWindowToken atoken,WindowManager.LayoutParams lp,int transit,boolean enter,boolean isVoiceInteraction){
  if (okToDisplay()) {
    DisplayInfo displayInfo=getDefaultDisplayInfoLocked();
    final int width=displayInfo.appWidth;
    final int height=displayInfo.appHeight;
    if (DEBUG_APP_TRANSITIONS || DEBUG_ANIM)     Slog.v(TAG_WM,""String_Node_Str"" + atoken);
    final WindowState win=atoken.findMainWindow();
    final Rect frame=new Rect(0,0,width,height);
    final Rect insets=new Rect();
    Rect surfaceInsets=null;
    final boolean fullscreen=win != null && win.isFrameFullscreen(displayInfo);
    final boolean freeform=win != null && win.inFreeformWorkspace();
    final boolean docked=win != null && win.inDockedWorkspace();
    if (win != null) {
      if (freeform) {
        frame.set(win.mFrame);
      }
 else {
        frame.set(win.mContainingFrame);
      }
      surfaceInsets=win.getAttrs().surfaceInsets;
      if (fullscreen || docked) {
        insets.set(win.mContentInsets);
      }
    }
    if (atoken.mLaunchTaskBehind) {
      enter=false;
    }
    if (DEBUG_APP_TRANSITIONS)     Slog.d(TAG_WM,""String_Node_Str"" + ""String_Node_Str"" + AppTransition.appTransitionToString(transit) + ""String_Node_Str""+ enter+ ""String_Node_Str""+ frame+ ""String_Node_Str""+ insets+ ""String_Node_Str""+ surfaceInsets);
    Animation a=mAppTransition.loadAnimation(lp,transit,enter,mCurConfiguration.orientation,frame,insets,surfaceInsets,isVoiceInteraction,!fullscreen,atoken.mTask.mTaskId);
    if (a != null) {
      if (DEBUG_ANIM)       logWithStack(TAG,""String_Node_Str"" + a + ""String_Node_Str""+ atoken);
      final int containingWidth=frame.width();
      final int containingHeight=frame.height();
      atoken.mAppAnimator.setAnimation(a,containingWidth,containingHeight,mAppTransition.canSkipFirstFrame());
    }
  }
 else {
    atoken.mAppAnimator.clearAnimation();
  }
  return atoken.mAppAnimator.animation != null;
}",0.8038834951456311
192926,"boolean reclaimSomeSurfaceMemoryLocked(WindowStateAnimator winAnimator,String operation,boolean secure){
  final WindowSurfaceController surfaceController=winAnimator.mSurfaceController;
  boolean leakedSurface=false;
  boolean killedApps=false;
  EventLog.writeEvent(EventLogTags.WM_NO_SURFACE_MEMORY,winAnimator.mWin.toString(),winAnimator.mSession.mPid,operation);
  long callingIdentity=Binder.clearCallingIdentity();
  try {
    Slog.i(TAG_WM,""String_Node_Str"");
    final int numDisplays=mDisplayContents.size();
    for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
      final WindowList windows=mDisplayContents.valueAt(displayNdx).getWindowList();
      final int numWindows=windows.size();
      for (int winNdx=0; winNdx < numWindows; ++winNdx) {
        final WindowState ws=windows.get(winNdx);
        WindowStateAnimator wsa=ws.mWinAnimator;
        if (wsa.mSurfaceController != null) {
          if (!mSessions.contains(wsa.mSession)) {
            Slog.w(TAG_WM,""String_Node_Str"" + ws + ""String_Node_Str""+ wsa.mSurfaceController+ ""String_Node_Str""+ ws.mToken+ ""String_Node_Str""+ ws.mSession.mPid+ ""String_Node_Str""+ ws.mSession.mUid);
            wsa.destroySurface();
            ws.setHasSurface(false);
            mForceRemoves.add(ws);
            leakedSurface=true;
          }
 else           if (ws.mAppToken != null && ws.mAppToken.clientHidden) {
            Slog.w(TAG_WM,""String_Node_Str"" + ws + ""String_Node_Str""+ wsa.mSurfaceController+ ""String_Node_Str""+ ws.mAppToken+ ""String_Node_Str""+ ws.mAppToken.hasSavedSurface());
            if (SHOW_TRANSACTIONS)             logSurface(ws,""String_Node_Str"",null);
            wsa.destroySurface();
            ws.setHasSurface(false);
            leakedSurface=true;
          }
        }
      }
    }
    if (!leakedSurface) {
      Slog.w(TAG_WM,""String_Node_Str"");
      SparseIntArray pidCandidates=new SparseIntArray();
      for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
        final WindowList windows=mDisplayContents.valueAt(displayNdx).getWindowList();
        final int numWindows=windows.size();
        for (int winNdx=0; winNdx < numWindows; ++winNdx) {
          final WindowState ws=windows.get(winNdx);
          if (mForceRemoves.contains(ws)) {
            continue;
          }
          WindowStateAnimator wsa=ws.mWinAnimator;
          if (wsa.mSurfaceController != null) {
            pidCandidates.append(wsa.mSession.mPid,wsa.mSession.mPid);
          }
        }
        if (pidCandidates.size() > 0) {
          int[] pids=new int[pidCandidates.size()];
          for (int i=0; i < pids.length; i++) {
            pids[i]=pidCandidates.keyAt(i);
          }
          try {
            if (mActivityManager.killPids(pids,""String_Node_Str"",secure)) {
              killedApps=true;
            }
          }
 catch (          RemoteException e) {
          }
        }
      }
    }
    if (leakedSurface || killedApps) {
      Slog.w(TAG_WM,""String_Node_Str"");
      if (surfaceController != null) {
        if (SHOW_TRANSACTIONS || SHOW_SURFACE_ALLOC)         logSurface(winAnimator.mWin,""String_Node_Str"",null);
        surfaceController.destroyInTransaction();
        winAnimator.mWin.setHasSurface(false);
        scheduleRemoveStartingWindowLocked(winAnimator.mWin.mAppToken);
      }
      try {
        winAnimator.mWin.mClient.dispatchGetNewSurface();
      }
 catch (      RemoteException e) {
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(callingIdentity);
  }
  return leakedSurface || killedApps;
}","boolean reclaimSomeSurfaceMemoryLocked(WindowStateAnimator winAnimator,String operation,boolean secure){
  final WindowSurfaceController surfaceController=winAnimator.mSurfaceController;
  boolean leakedSurface=false;
  boolean killedApps=false;
  EventLog.writeEvent(EventLogTags.WM_NO_SURFACE_MEMORY,winAnimator.mWin.toString(),winAnimator.mSession.mPid,operation);
  long callingIdentity=Binder.clearCallingIdentity();
  try {
    Slog.i(TAG_WM,""String_Node_Str"");
    final int numDisplays=mDisplayContents.size();
    for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
      final WindowList windows=mDisplayContents.valueAt(displayNdx).getWindowList();
      final int numWindows=windows.size();
      for (int winNdx=0; winNdx < numWindows; ++winNdx) {
        final WindowState ws=windows.get(winNdx);
        WindowStateAnimator wsa=ws.mWinAnimator;
        if (wsa.mSurfaceController != null) {
          if (!mSessions.contains(wsa.mSession)) {
            Slog.w(TAG_WM,""String_Node_Str"" + ws + ""String_Node_Str""+ wsa.mSurfaceController+ ""String_Node_Str""+ ws.mToken+ ""String_Node_Str""+ ws.mSession.mPid+ ""String_Node_Str""+ ws.mSession.mUid);
            wsa.destroySurface();
            ws.setHasSurface(false);
            mForceRemoves.add(ws);
            leakedSurface=true;
          }
 else           if (ws.mAppToken != null && ws.mAppToken.clientHidden) {
            Slog.w(TAG_WM,""String_Node_Str"" + ws + ""String_Node_Str""+ wsa.mSurfaceController+ ""String_Node_Str""+ ws.mAppToken+ ""String_Node_Str""+ ws.mAppToken.hasSavedSurface());
            if (SHOW_TRANSACTIONS)             logSurface(ws,""String_Node_Str"",false);
            wsa.destroySurface();
            ws.setHasSurface(false);
            leakedSurface=true;
          }
        }
      }
    }
    if (!leakedSurface) {
      Slog.w(TAG_WM,""String_Node_Str"");
      SparseIntArray pidCandidates=new SparseIntArray();
      for (int displayNdx=0; displayNdx < numDisplays; ++displayNdx) {
        final WindowList windows=mDisplayContents.valueAt(displayNdx).getWindowList();
        final int numWindows=windows.size();
        for (int winNdx=0; winNdx < numWindows; ++winNdx) {
          final WindowState ws=windows.get(winNdx);
          if (mForceRemoves.contains(ws)) {
            continue;
          }
          WindowStateAnimator wsa=ws.mWinAnimator;
          if (wsa.mSurfaceController != null) {
            pidCandidates.append(wsa.mSession.mPid,wsa.mSession.mPid);
          }
        }
        if (pidCandidates.size() > 0) {
          int[] pids=new int[pidCandidates.size()];
          for (int i=0; i < pids.length; i++) {
            pids[i]=pidCandidates.keyAt(i);
          }
          try {
            if (mActivityManager.killPids(pids,""String_Node_Str"",secure)) {
              killedApps=true;
            }
          }
 catch (          RemoteException e) {
          }
        }
      }
    }
    if (leakedSurface || killedApps) {
      Slog.w(TAG_WM,""String_Node_Str"");
      if (surfaceController != null) {
        if (SHOW_TRANSACTIONS || SHOW_SURFACE_ALLOC)         logSurface(winAnimator.mWin,""String_Node_Str"",false);
        surfaceController.destroyInTransaction();
        winAnimator.mWin.setHasSurface(false);
        scheduleRemoveStartingWindowLocked(winAnimator.mWin.mAppToken);
      }
      try {
        winAnimator.mWin.mClient.dispatchGetNewSurface();
      }
 catch (      RemoteException e) {
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(callingIdentity);
  }
  return leakedSurface || killedApps;
}",0.9974804031354984
192927,"void setTransparentRegionWindow(Session session,IWindow client,Region region){
  long origId=Binder.clearCallingIdentity();
  try {
synchronized (mWindowMap) {
      WindowState w=windowForClientLocked(session,client,false);
      if (SHOW_TRANSACTIONS)       WindowManagerService.logSurface(w,""String_Node_Str"" + region,null);
      if ((w != null) && w.mHasSurface) {
        w.mWinAnimator.setTransparentRegionHintLocked(region);
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}","void setTransparentRegionWindow(Session session,IWindow client,Region region){
  long origId=Binder.clearCallingIdentity();
  try {
synchronized (mWindowMap) {
      WindowState w=windowForClientLocked(session,client,false);
      if (SHOW_TRANSACTIONS)       WindowManagerService.logSurface(w,""String_Node_Str"" + region,false);
      if ((w != null) && w.mHasSurface) {
        w.mWinAnimator.setTransparentRegionHintLocked(region);
      }
    }
  }
  finally {
    Binder.restoreCallingIdentity(origId);
  }
}",0.9912023460410556
192928,"private void startAppFreezingScreenLocked(AppWindowToken wtoken){
  if (DEBUG_ORIENTATION) {
    RuntimeException e=null;
    if (!HIDE_STACK_CRAWLS) {
      e=new RuntimeException();
      e.fillInStackTrace();
    }
    Slog.i(TAG_WM,""String_Node_Str"" + wtoken.appToken + ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ wtoken.mAppAnimator.freezingScreen,e);
  }
  if (!wtoken.hiddenRequested) {
    if (!wtoken.mAppAnimator.freezingScreen) {
      wtoken.mAppAnimator.freezingScreen=true;
      wtoken.mAppAnimator.lastFreezeDuration=0;
      mAppsFreezingScreen++;
      if (mAppsFreezingScreen == 1) {
        startFreezingDisplayLocked(false,0,0);
        mH.removeMessages(H.APP_FREEZE_TIMEOUT);
        mH.sendEmptyMessageDelayed(H.APP_FREEZE_TIMEOUT,2000);
      }
    }
    final int N=wtoken.allAppWindows.size();
    for (int i=0; i < N; i++) {
      WindowState w=wtoken.allAppWindows.get(i);
      w.mAppFreezing=true;
    }
  }
}","private void startAppFreezingScreenLocked(AppWindowToken wtoken){
  if (DEBUG_ORIENTATION)   logWithStack(TAG,""String_Node_Str"" + wtoken.appToken + ""String_Node_Str""+ wtoken.hidden+ ""String_Node_Str""+ wtoken.mAppAnimator.freezingScreen);
  if (!wtoken.hiddenRequested) {
    if (!wtoken.mAppAnimator.freezingScreen) {
      wtoken.mAppAnimator.freezingScreen=true;
      wtoken.mAppAnimator.lastFreezeDuration=0;
      mAppsFreezingScreen++;
      if (mAppsFreezingScreen == 1) {
        startFreezingDisplayLocked(false,0,0);
        mH.removeMessages(H.APP_FREEZE_TIMEOUT);
        mH.sendEmptyMessageDelayed(H.APP_FREEZE_TIMEOUT,2000);
      }
    }
    final int N=wtoken.allAppWindows.size();
    for (int i=0; i < N; i++) {
      WindowState w=wtoken.allAppWindows.get(i);
      w.mAppFreezing=true;
    }
  }
}",0.9071347678369196
192929,"static void logSurface(SurfaceControl s,String title,String msg,RuntimeException where){
  String str=""String_Node_Str"" + s + ""String_Node_Str""+ msg+ ""String_Node_Str""+ title;
  if (where != null) {
    Slog.i(TAG_WM,str,where);
  }
 else {
    Slog.i(TAG_WM,str);
  }
}","static void logSurface(SurfaceControl s,String title,String msg){
  String str=""String_Node_Str"" + s + ""String_Node_Str""+ msg+ ""String_Node_Str""+ title;
  Slog.i(TAG_WM,str);
}",0.7892376681614349
192930,"void destroySurfaceLocked(){
  final AppWindowToken wtoken=mWin.mAppToken;
  if (wtoken != null) {
    wtoken.mAnimatingWithSavedSurface=false;
    if (mWin == wtoken.startingWindow) {
      wtoken.startingDisplayed=false;
    }
  }
  mWin.mSurfaceSaved=false;
  if (mSurfaceController != null) {
    int i=mWin.mChildWindows.size();
    while (!mDestroyPreservedSurfaceUponRedraw && i > 0) {
      i--;
      WindowState c=mWin.mChildWindows.get(i);
      c.mAttachedHidden=true;
    }
    try {
      if (DEBUG_VISIBILITY) {
        RuntimeException e=null;
        if (!HIDE_STACK_CRAWLS) {
          e=new RuntimeException();
          e.fillInStackTrace();
        }
        Slog.w(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mSurfaceController+ ""String_Node_Str""+ mSession,e);
      }
      if (mSurfaceDestroyDeferred) {
        if (mSurfaceController != null && mPendingDestroySurface != mSurfaceController) {
          if (mPendingDestroySurface != null) {
            if (SHOW_TRANSACTIONS || SHOW_SURFACE_ALLOC) {
              RuntimeException e=null;
              if (!HIDE_STACK_CRAWLS) {
                e=new RuntimeException();
                e.fillInStackTrace();
              }
              WindowManagerService.logSurface(mWin,""String_Node_Str"",e);
            }
            mPendingDestroySurface.destroyInTransaction();
          }
          mPendingDestroySurface=mSurfaceController;
        }
      }
 else {
        if (SHOW_TRANSACTIONS || SHOW_SURFACE_ALLOC) {
          RuntimeException e=null;
          if (!HIDE_STACK_CRAWLS) {
            e=new RuntimeException();
            e.fillInStackTrace();
          }
          WindowManagerService.logSurface(mWin,""String_Node_Str"",null);
        }
        destroySurface();
      }
      if (!(mSurfaceDestroyDeferred && mDestroyPreservedSurfaceUponRedraw)) {
        mWallpaperControllerLocked.hideWallpapers(mWin);
      }
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mSurfaceController+ ""String_Node_Str""+ mSession+ ""String_Node_Str""+ e.toString());
    }
    mWin.setHasSurface(false);
    if (mSurfaceController != null) {
      mSurfaceController.setShown(false);
    }
    mSurfaceController=null;
    mDrawState=NO_SURFACE;
  }
}","void destroySurfaceLocked(){
  final AppWindowToken wtoken=mWin.mAppToken;
  if (wtoken != null) {
    wtoken.mAnimatingWithSavedSurface=false;
    if (mWin == wtoken.startingWindow) {
      wtoken.startingDisplayed=false;
    }
  }
  mWin.mSurfaceSaved=false;
  if (mSurfaceController != null) {
    int i=mWin.mChildWindows.size();
    while (!mDestroyPreservedSurfaceUponRedraw && i > 0) {
      i--;
      WindowState c=mWin.mChildWindows.get(i);
      c.mAttachedHidden=true;
    }
    try {
      if (DEBUG_VISIBILITY)       logWithStack(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mSurfaceController+ ""String_Node_Str""+ mSession);
      if (mSurfaceDestroyDeferred) {
        if (mSurfaceController != null && mPendingDestroySurface != mSurfaceController) {
          if (mPendingDestroySurface != null) {
            if (SHOW_TRANSACTIONS || SHOW_SURFACE_ALLOC) {
              WindowManagerService.logSurface(mWin,""String_Node_Str"",true);
            }
            mPendingDestroySurface.destroyInTransaction();
          }
          mPendingDestroySurface=mSurfaceController;
        }
      }
 else {
        if (SHOW_TRANSACTIONS || SHOW_SURFACE_ALLOC) {
          WindowManagerService.logSurface(mWin,""String_Node_Str"",true);
        }
        destroySurface();
      }
      if (!(mSurfaceDestroyDeferred && mDestroyPreservedSurfaceUponRedraw)) {
        mWallpaperControllerLocked.hideWallpapers(mWin);
      }
    }
 catch (    RuntimeException e) {
      Slog.w(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mSurfaceController+ ""String_Node_Str""+ mSession+ ""String_Node_Str""+ e.toString());
    }
    mWin.setHasSurface(false);
    if (mSurfaceController != null) {
      mSurfaceController.setShown(false);
    }
    mSurfaceController=null;
    mDrawState=NO_SURFACE;
  }
}",0.871694417238002
192931,"WindowSurfaceController createSurfaceLocked(){
  final WindowState w=mWin;
  if (mSurfaceController == null) {
    if (DEBUG_ANIM || DEBUG_ORIENTATION)     Slog.i(TAG,""String_Node_Str"" + this + ""String_Node_Str"");
    mDrawState=DRAW_PENDING;
    if (w.mAppToken != null) {
      if (w.mAppToken.mAppAnimator.animation == null) {
        w.mAppToken.allDrawn=false;
        w.mAppToken.deferClearAllDrawn=false;
      }
 else {
        w.mAppToken.deferClearAllDrawn=true;
      }
    }
    mService.makeWindowFreezingScreenIfNeededLocked(w);
    int flags=SurfaceControl.HIDDEN;
    final WindowManager.LayoutParams attrs=w.mAttrs;
    if (mService.isSecureLocked(w)) {
      flags|=SurfaceControl.SECURE;
    }
    mTmpSize.set(w.mFrame.left + w.mXOffset,w.mFrame.top + w.mYOffset,0,0);
    calculateSurfaceBounds(w,attrs);
    final int width=mTmpSize.width();
    final int height=mTmpSize.height();
    if (DEBUG_VISIBILITY) {
      Slog.v(TAG,""String_Node_Str"" + mSession.mSurfaceSession + ""String_Node_Str""+ this+ ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ mTmpSize.left+ ""String_Node_Str""+ mTmpSize.top+ ""String_Node_Str""+ attrs.format+ ""String_Node_Str""+ flags);
    }
    mLastSystemDecorRect.set(0,0,0,0);
    mHasClipRect=false;
    mClipRect.set(0,0,0,0);
    mLastClipRect.set(0,0,0,0);
    try {
      final boolean isHwAccelerated=(attrs.flags & FLAG_HARDWARE_ACCELERATED) != 0;
      final int format=isHwAccelerated ? PixelFormat.TRANSLUCENT : attrs.format;
      if (!PixelFormat.formatHasAlpha(attrs.format) && attrs.surfaceInsets.left == 0 && attrs.surfaceInsets.top == 0 && attrs.surfaceInsets.right == 0 && attrs.surfaceInsets.bottom == 0 && !w.isDragResizing()) {
        flags|=SurfaceControl.OPAQUE;
      }
      mSurfaceController=new WindowSurfaceController(mSession.mSurfaceSession,attrs.getTitle().toString(),width,height,format,flags,this);
      w.setHasSurface(true);
      if (SHOW_TRANSACTIONS || SHOW_SURFACE_ALLOC) {
        Slog.i(TAG,""String_Node_Str"" + mSurfaceController + ""String_Node_Str""+ mSession.mSurfaceSession+ ""String_Node_Str""+ mSession.mPid+ ""String_Node_Str""+ attrs.format+ ""String_Node_Str""+ Integer.toHexString(flags)+ ""String_Node_Str""+ this);
      }
    }
 catch (    OutOfResourcesException e) {
      w.setHasSurface(false);
      Slog.w(TAG,""String_Node_Str"");
      mService.reclaimSomeSurfaceMemoryLocked(this,""String_Node_Str"",true);
      mDrawState=NO_SURFACE;
      return null;
    }
catch (    Exception e) {
      w.setHasSurface(false);
      Slog.e(TAG,""String_Node_Str"",e);
      mDrawState=NO_SURFACE;
      return null;
    }
    if (WindowManagerService.localLOGV) {
      Slog.v(TAG,""String_Node_Str"" + mSurfaceController + ""String_Node_Str""+ w.mFrame.left+ ""String_Node_Str""+ w.mFrame.top+ ""String_Node_Str""+ mAnimLayer);
    }
    if (SHOW_LIGHT_TRANSACTIONS) {
      Slog.i(TAG,""String_Node_Str"");
      WindowManagerService.logSurface(w,""String_Node_Str"" + w.mFrame.left + ""String_Node_Str""+ w.mFrame.top+ ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ mAnimLayer+ ""String_Node_Str"",null);
    }
    final int layerStack=w.getDisplayContent().getDisplay().getLayerStack();
    if (SHOW_TRANSACTIONS)     WindowManagerService.logSurface(w,""String_Node_Str"" + mTmpSize.left + ""String_Node_Str""+ mTmpSize.top,null);
    mSurfaceController.setPositionAndLayer(mTmpSize.left,mTmpSize.top,layerStack,mAnimLayer);
    mLastHidden=true;
    if (WindowManagerService.localLOGV)     Slog.v(TAG,""String_Node_Str"" + this);
  }
  return mSurfaceController;
}","WindowSurfaceController createSurfaceLocked(){
  final WindowState w=mWin;
  if (mSurfaceController == null) {
    if (DEBUG_ANIM || DEBUG_ORIENTATION)     Slog.i(TAG,""String_Node_Str"" + this + ""String_Node_Str"");
    mDrawState=DRAW_PENDING;
    if (w.mAppToken != null) {
      if (w.mAppToken.mAppAnimator.animation == null) {
        w.mAppToken.allDrawn=false;
        w.mAppToken.deferClearAllDrawn=false;
      }
 else {
        w.mAppToken.deferClearAllDrawn=true;
      }
    }
    mService.makeWindowFreezingScreenIfNeededLocked(w);
    int flags=SurfaceControl.HIDDEN;
    final WindowManager.LayoutParams attrs=w.mAttrs;
    if (mService.isSecureLocked(w)) {
      flags|=SurfaceControl.SECURE;
    }
    mTmpSize.set(w.mFrame.left + w.mXOffset,w.mFrame.top + w.mYOffset,0,0);
    calculateSurfaceBounds(w,attrs);
    final int width=mTmpSize.width();
    final int height=mTmpSize.height();
    if (DEBUG_VISIBILITY) {
      Slog.v(TAG,""String_Node_Str"" + mSession.mSurfaceSession + ""String_Node_Str""+ this+ ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ mTmpSize.left+ ""String_Node_Str""+ mTmpSize.top+ ""String_Node_Str""+ attrs.format+ ""String_Node_Str""+ flags);
    }
    mLastSystemDecorRect.set(0,0,0,0);
    mHasClipRect=false;
    mClipRect.set(0,0,0,0);
    mLastClipRect.set(0,0,0,0);
    try {
      final boolean isHwAccelerated=(attrs.flags & FLAG_HARDWARE_ACCELERATED) != 0;
      final int format=isHwAccelerated ? PixelFormat.TRANSLUCENT : attrs.format;
      if (!PixelFormat.formatHasAlpha(attrs.format) && attrs.surfaceInsets.left == 0 && attrs.surfaceInsets.top == 0 && attrs.surfaceInsets.right == 0 && attrs.surfaceInsets.bottom == 0 && !w.isDragResizing()) {
        flags|=SurfaceControl.OPAQUE;
      }
      mSurfaceController=new WindowSurfaceController(mSession.mSurfaceSession,attrs.getTitle().toString(),width,height,format,flags,this);
      w.setHasSurface(true);
      if (SHOW_TRANSACTIONS || SHOW_SURFACE_ALLOC) {
        Slog.i(TAG,""String_Node_Str"" + mSurfaceController + ""String_Node_Str""+ mSession.mSurfaceSession+ ""String_Node_Str""+ mSession.mPid+ ""String_Node_Str""+ attrs.format+ ""String_Node_Str""+ Integer.toHexString(flags)+ ""String_Node_Str""+ this);
      }
    }
 catch (    OutOfResourcesException e) {
      w.setHasSurface(false);
      Slog.w(TAG,""String_Node_Str"");
      mService.reclaimSomeSurfaceMemoryLocked(this,""String_Node_Str"",true);
      mDrawState=NO_SURFACE;
      return null;
    }
catch (    Exception e) {
      w.setHasSurface(false);
      Slog.e(TAG,""String_Node_Str"",e);
      mDrawState=NO_SURFACE;
      return null;
    }
    if (WindowManagerService.localLOGV) {
      Slog.v(TAG,""String_Node_Str"" + mSurfaceController + ""String_Node_Str""+ w.mFrame.left+ ""String_Node_Str""+ w.mFrame.top+ ""String_Node_Str""+ mAnimLayer);
    }
    if (SHOW_LIGHT_TRANSACTIONS) {
      Slog.i(TAG,""String_Node_Str"");
      WindowManagerService.logSurface(w,""String_Node_Str"" + w.mFrame.left + ""String_Node_Str""+ w.mFrame.top+ ""String_Node_Str""+ width+ ""String_Node_Str""+ height+ ""String_Node_Str""+ mAnimLayer+ ""String_Node_Str"",false);
    }
    final int layerStack=w.getDisplayContent().getDisplay().getLayerStack();
    if (SHOW_TRANSACTIONS)     WindowManagerService.logSurface(w,""String_Node_Str"" + mTmpSize.left + ""String_Node_Str""+ mTmpSize.top,false);
    mSurfaceController.setPositionAndLayer(mTmpSize.left,mTmpSize.top,layerStack,mAnimLayer);
    mLastHidden=true;
    if (WindowManagerService.localLOGV)     Slog.v(TAG,""String_Node_Str"" + this);
  }
  return mSurfaceController;
}",0.9974867355487294
192932,"/** 
 * Choose the correct animation and set it to the passed WindowState.
 * @param transit If AppTransition.TRANSIT_PREVIEW_DONE and the app window has been drawnthen the animation will be app_starting_exit. Any other value loads the animation from the switch statement below.
 * @param isEntrance The animation type the last time this was called. Used to keep fromloading the same animation twice.
 * @return true if an animation has been loaded.
 */
boolean applyAnimationLocked(int transit,boolean isEntrance){
  if ((mLocalAnimating && mAnimationIsEntrance == isEntrance) || mKeyguardGoingAwayAnimation) {
    if (mAnimation != null && mKeyguardGoingAwayAnimation && transit == WindowManagerPolicy.TRANSIT_PREVIEW_DONE) {
      applyFadeoutDuringKeyguardExitAnimation();
    }
    return true;
  }
  if (mService.okToDisplay()) {
    int anim=mPolicy.selectAnimationLw(mWin,transit);
    int attr=-1;
    Animation a=null;
    if (anim != 0) {
      a=anim != -1 ? AnimationUtils.loadAnimation(mContext,anim) : null;
    }
 else {
switch (transit) {
case WindowManagerPolicy.TRANSIT_ENTER:
        attr=com.android.internal.R.styleable.WindowAnimation_windowEnterAnimation;
      break;
case WindowManagerPolicy.TRANSIT_EXIT:
    attr=com.android.internal.R.styleable.WindowAnimation_windowExitAnimation;
  break;
case WindowManagerPolicy.TRANSIT_SHOW:
attr=com.android.internal.R.styleable.WindowAnimation_windowShowAnimation;
break;
case WindowManagerPolicy.TRANSIT_HIDE:
attr=com.android.internal.R.styleable.WindowAnimation_windowHideAnimation;
break;
}
if (attr >= 0) {
a=mService.mAppTransition.loadAnimationAttr(mWin.mAttrs,attr);
}
}
if (DEBUG_ANIM) Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ anim+ ""String_Node_Str""+ Integer.toHexString(attr)+ ""String_Node_Str""+ a+ ""String_Node_Str""+ transit+ ""String_Node_Str""+ isEntrance+ ""String_Node_Str""+ Debug.getCallers(3));
if (a != null) {
if (DEBUG_ANIM) {
RuntimeException e=null;
if (!HIDE_STACK_CRAWLS) {
e=new RuntimeException();
e.fillInStackTrace();
}
Slog.v(TAG,""String_Node_Str"" + a + ""String_Node_Str""+ this,e);
}
setAnimation(a);
mAnimationIsEntrance=isEntrance;
}
}
 else {
clearAnimation();
}
return mAnimation != null;
}","/** 
 * Choose the correct animation and set it to the passed WindowState.
 * @param transit If AppTransition.TRANSIT_PREVIEW_DONE and the app window has been drawnthen the animation will be app_starting_exit. Any other value loads the animation from the switch statement below.
 * @param isEntrance The animation type the last time this was called. Used to keep fromloading the same animation twice.
 * @return true if an animation has been loaded.
 */
boolean applyAnimationLocked(int transit,boolean isEntrance){
  if ((mLocalAnimating && mAnimationIsEntrance == isEntrance) || mKeyguardGoingAwayAnimation) {
    if (mAnimation != null && mKeyguardGoingAwayAnimation && transit == WindowManagerPolicy.TRANSIT_PREVIEW_DONE) {
      applyFadeoutDuringKeyguardExitAnimation();
    }
    return true;
  }
  if (mService.okToDisplay()) {
    int anim=mPolicy.selectAnimationLw(mWin,transit);
    int attr=-1;
    Animation a=null;
    if (anim != 0) {
      a=anim != -1 ? AnimationUtils.loadAnimation(mContext,anim) : null;
    }
 else {
switch (transit) {
case WindowManagerPolicy.TRANSIT_ENTER:
        attr=com.android.internal.R.styleable.WindowAnimation_windowEnterAnimation;
      break;
case WindowManagerPolicy.TRANSIT_EXIT:
    attr=com.android.internal.R.styleable.WindowAnimation_windowExitAnimation;
  break;
case WindowManagerPolicy.TRANSIT_SHOW:
attr=com.android.internal.R.styleable.WindowAnimation_windowShowAnimation;
break;
case WindowManagerPolicy.TRANSIT_HIDE:
attr=com.android.internal.R.styleable.WindowAnimation_windowHideAnimation;
break;
}
if (attr >= 0) {
a=mService.mAppTransition.loadAnimationAttr(mWin.mAttrs,attr);
}
}
if (DEBUG_ANIM) Slog.v(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ anim+ ""String_Node_Str""+ Integer.toHexString(attr)+ ""String_Node_Str""+ a+ ""String_Node_Str""+ transit+ ""String_Node_Str""+ isEntrance+ ""String_Node_Str""+ Debug.getCallers(3));
if (a != null) {
if (DEBUG_ANIM) logWithStack(TAG,""String_Node_Str"" + a + ""String_Node_Str""+ this);
setAnimation(a);
mAnimationIsEntrance=isEntrance;
}
}
 else {
clearAnimation();
}
return mAnimation != null;
}",0.9130132219902576
192933,"void preserveSurfaceLocked(){
  if (mDestroyPreservedSurfaceUponRedraw) {
    return;
  }
  if (SHOW_TRANSACTIONS)   WindowManagerService.logSurface(mWin,""String_Node_Str"",null);
  if (mSurfaceController != null) {
    mSurfaceController.setLayer(mAnimLayer + 1);
  }
  mDestroyPreservedSurfaceUponRedraw=true;
  mSurfaceDestroyDeferred=true;
  destroySurfaceLocked();
}","void preserveSurfaceLocked(){
  if (mDestroyPreservedSurfaceUponRedraw) {
    return;
  }
  if (SHOW_TRANSACTIONS)   WindowManagerService.logSurface(mWin,""String_Node_Str"",false);
  if (mSurfaceController != null) {
    mSurfaceController.setLayer(mAnimLayer + 1);
  }
  mDestroyPreservedSurfaceUponRedraw=true;
  mSurfaceDestroyDeferred=true;
  destroySurfaceLocked();
}",0.9878542510121456
192934,"void prepareSurfaceLocked(final boolean recoveringMemory){
  final WindowState w=mWin;
  if (mSurfaceController == null || !mSurfaceController.hasSurface()) {
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION) {
        Slog.v(TAG,""String_Node_Str"" + w);
      }
      w.mOrientationChanging=false;
    }
    return;
  }
  boolean displayed=false;
  computeShownFrameLocked();
  setSurfaceBoundariesLocked(recoveringMemory);
  if (mIsWallpaper && !mWin.mWallpaperVisible) {
    hide(""String_Node_Str"");
  }
 else   if (w.mAttachedHidden || !w.isOnScreen()) {
    hide(""String_Node_Str"");
    mWallpaperControllerLocked.hideWallpapers(w);
    if (w.mOrientationChanging) {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
  }
 else   if (mLastLayer != mAnimLayer || mLastAlpha != mShownAlpha || mLastDsDx != mDsDx || mLastDtDx != mDtDx || mLastDsDy != mDsDy || mLastDtDy != mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || mLastHidden) {
    displayed=true;
    mLastAlpha=mShownAlpha;
    mLastLayer=mAnimLayer;
    mLastDsDx=mDsDx;
    mLastDtDx=mDtDx;
    mLastDsDy=mDsDy;
    mLastDtDy=mDtDy;
    w.mLastHScale=w.mHScale;
    w.mLastVScale=w.mVScale;
    if (SHOW_TRANSACTIONS)     WindowManagerService.logSurface(w,""String_Node_Str"" + mSurfaceController + ""String_Node_Str""+ mShownAlpha+ ""String_Node_Str""+ mAnimLayer+ ""String_Node_Str""+ mDsDx+ ""String_Node_Str""+ w.mHScale+ ""String_Node_Str""+ mDtDx+ ""String_Node_Str""+ w.mVScale+ ""String_Node_Str""+ mDsDy+ ""String_Node_Str""+ w.mHScale+ ""String_Node_Str""+ mDtDy+ ""String_Node_Str""+ w.mVScale+ ""String_Node_Str"",null);
    boolean prepared=mSurfaceController.prepareToShowInTransaction(mShownAlpha,mAnimLayer,mDsDx * w.mHScale,mDtDx * w.mVScale,mDsDy * w.mHScale,mDtDy * w.mVScale,recoveringMemory);
    if (prepared && mLastHidden && mDrawState == HAS_DRAWN) {
      if (showSurfaceRobustlyLocked()) {
        mAnimator.requestRemovalOfReplacedWindows(w);
        mLastHidden=false;
        if (mIsWallpaper) {
          mWallpaperControllerLocked.dispatchWallpaperVisibility(w,true);
        }
        mAnimator.setPendingLayoutChanges(w.getDisplayId(),WindowManagerPolicy.FINISH_LAYOUT_REDO_ANIM);
      }
 else {
        w.mOrientationChanging=false;
      }
    }
    if (mSurfaceController != null && mSurfaceController.hasSurface()) {
      w.mToken.hasVisible=true;
    }
  }
 else {
    if (DEBUG_ANIM && isAnimating()) {
      Slog.v(TAG,""String_Node_Str"" + this);
    }
    displayed=true;
  }
  if (displayed) {
    if (w.mOrientationChanging) {
      if (!w.isDrawnLw()) {
        mAnimator.mBulkUpdateParams&=~SET_ORIENTATION_CHANGE_COMPLETE;
        mAnimator.mLastWindowFreezeSource=w;
        if (DEBUG_ORIENTATION)         Slog.v(TAG,""String_Node_Str"" + w);
      }
 else {
        w.mOrientationChanging=false;
        if (DEBUG_ORIENTATION)         Slog.v(TAG,""String_Node_Str"" + w);
      }
    }
    w.mToken.hasVisible=true;
    final Task task=w.getTask();
    if (task != null) {
      task.scheduleShowNonResizeableDockToastIfNeeded();
    }
  }
}","void prepareSurfaceLocked(final boolean recoveringMemory){
  final WindowState w=mWin;
  if (mSurfaceController == null || !mSurfaceController.hasSurface()) {
    if (w.mOrientationChanging) {
      if (DEBUG_ORIENTATION) {
        Slog.v(TAG,""String_Node_Str"" + w);
      }
      w.mOrientationChanging=false;
    }
    return;
  }
  boolean displayed=false;
  computeShownFrameLocked();
  setSurfaceBoundariesLocked(recoveringMemory);
  if (mIsWallpaper && !mWin.mWallpaperVisible) {
    hide(""String_Node_Str"");
  }
 else   if (w.mAttachedHidden || !w.isOnScreen()) {
    hide(""String_Node_Str"");
    mWallpaperControllerLocked.hideWallpapers(w);
    if (w.mOrientationChanging) {
      w.mOrientationChanging=false;
      if (DEBUG_ORIENTATION)       Slog.v(TAG,""String_Node_Str"" + w);
    }
  }
 else   if (mLastLayer != mAnimLayer || mLastAlpha != mShownAlpha || mLastDsDx != mDsDx || mLastDtDx != mDtDx || mLastDsDy != mDsDy || mLastDtDy != mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || mLastHidden) {
    displayed=true;
    mLastAlpha=mShownAlpha;
    mLastLayer=mAnimLayer;
    mLastDsDx=mDsDx;
    mLastDtDx=mDtDx;
    mLastDsDy=mDsDy;
    mLastDtDy=mDtDy;
    w.mLastHScale=w.mHScale;
    w.mLastVScale=w.mVScale;
    if (SHOW_TRANSACTIONS)     WindowManagerService.logSurface(w,""String_Node_Str"" + mSurfaceController + ""String_Node_Str""+ mShownAlpha+ ""String_Node_Str""+ mAnimLayer+ ""String_Node_Str""+ mDsDx+ ""String_Node_Str""+ w.mHScale+ ""String_Node_Str""+ mDtDx+ ""String_Node_Str""+ w.mVScale+ ""String_Node_Str""+ mDsDy+ ""String_Node_Str""+ w.mHScale+ ""String_Node_Str""+ mDtDy+ ""String_Node_Str""+ w.mVScale+ ""String_Node_Str"",false);
    boolean prepared=mSurfaceController.prepareToShowInTransaction(mShownAlpha,mAnimLayer,mDsDx * w.mHScale,mDtDx * w.mVScale,mDsDy * w.mHScale,mDtDy * w.mVScale,recoveringMemory);
    if (prepared && mLastHidden && mDrawState == HAS_DRAWN) {
      if (showSurfaceRobustlyLocked()) {
        mAnimator.requestRemovalOfReplacedWindows(w);
        mLastHidden=false;
        if (mIsWallpaper) {
          mWallpaperControllerLocked.dispatchWallpaperVisibility(w,true);
        }
        mAnimator.setPendingLayoutChanges(w.getDisplayId(),WindowManagerPolicy.FINISH_LAYOUT_REDO_ANIM);
      }
 else {
        w.mOrientationChanging=false;
      }
    }
    if (mSurfaceController != null && mSurfaceController.hasSurface()) {
      w.mToken.hasVisible=true;
    }
  }
 else {
    if (DEBUG_ANIM && isAnimating()) {
      Slog.v(TAG,""String_Node_Str"" + this);
    }
    displayed=true;
  }
  if (displayed) {
    if (w.mOrientationChanging) {
      if (!w.isDrawnLw()) {
        mAnimator.mBulkUpdateParams&=~SET_ORIENTATION_CHANGE_COMPLETE;
        mAnimator.mLastWindowFreezeSource=w;
        if (DEBUG_ORIENTATION)         Slog.v(TAG,""String_Node_Str"" + w);
      }
 else {
        w.mOrientationChanging=false;
        if (DEBUG_ORIENTATION)         Slog.v(TAG,""String_Node_Str"" + w);
      }
    }
    w.mToken.hasVisible=true;
    final Task task=w.getTask();
    if (task != null) {
      task.scheduleShowNonResizeableDockToastIfNeeded();
    }
  }
}",0.9985583853916388
192935,"void destroyDeferredSurfaceLocked(){
  try {
    if (mPendingDestroySurface != null) {
      if (SHOW_TRANSACTIONS || SHOW_SURFACE_ALLOC) {
        RuntimeException e=null;
        if (!HIDE_STACK_CRAWLS) {
          e=new RuntimeException();
          e.fillInStackTrace();
        }
        WindowManagerService.logSurface(mWin,""String_Node_Str"",e);
      }
      mPendingDestroySurface.destroyInTransaction();
      if (!mDestroyPreservedSurfaceUponRedraw) {
        mWallpaperControllerLocked.hideWallpapers(mWin);
      }
    }
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mPendingDestroySurface+ ""String_Node_Str""+ mSession+ ""String_Node_Str""+ e.toString());
  }
  mSurfaceDestroyDeferred=false;
  mPendingDestroySurface=null;
}","void destroyDeferredSurfaceLocked(){
  try {
    if (mPendingDestroySurface != null) {
      if (SHOW_TRANSACTIONS || SHOW_SURFACE_ALLOC) {
        WindowManagerService.logSurface(mWin,""String_Node_Str"",true);
      }
      mPendingDestroySurface.destroyInTransaction();
      if (!mDestroyPreservedSurfaceUponRedraw) {
        mWallpaperControllerLocked.hideWallpapers(mWin);
      }
    }
  }
 catch (  RuntimeException e) {
    Slog.w(TAG,""String_Node_Str"" + this + ""String_Node_Str""+ mPendingDestroySurface+ ""String_Node_Str""+ mSession+ ""String_Node_Str""+ e.toString());
  }
  mSurfaceDestroyDeferred=false;
  mPendingDestroySurface=null;
}",0.8965034965034965
192936,"private static long registerMethod(Class<?> targetClass,String methodName,Class[] types,int nArgs){
  String methodIndexName=String.format(""String_Node_Str"",methodName,nArgs);
synchronized (sMethodIndexLock) {
    Long methodId=METHOD_NAME_TO_ID.get(methodIndexName);
    if (methodId != null) {
      return methodId;
    }
    Class[] args=new Class[nArgs];
    Method method=null;
    for (    Class typeVariant : types) {
      for (int i=0; i < nArgs; i++) {
        args[i]=typeVariant;
      }
      try {
        method=targetClass.getDeclaredMethod(methodName,args);
      }
 catch (      NoSuchMethodException ignore) {
      }
    }
    if (method != null) {
      methodId=sNextId++;
      ID_TO_METHOD.put(methodId,method);
      METHOD_NAME_TO_ID.put(methodIndexName,methodId);
      return methodId;
    }
  }
  return 0;
}","private static long registerMethod(Class<?> targetClass,String methodName,Class[] types,int nArgs){
  String methodIndexName=String.format(""String_Node_Str"",targetClass.getSimpleName(),methodName,nArgs);
synchronized (sMethodIndexLock) {
    Long methodId=METHOD_NAME_TO_ID.get(methodIndexName);
    if (methodId != null) {
      return methodId;
    }
    Class[] args=new Class[nArgs];
    Method method=null;
    for (    Class typeVariant : types) {
      for (int i=0; i < nArgs; i++) {
        args[i]=typeVariant;
      }
      try {
        method=targetClass.getDeclaredMethod(methodName,args);
      }
 catch (      NoSuchMethodException ignore) {
      }
    }
    if (method != null) {
      methodId=sNextId++;
      ID_TO_METHOD.put(methodId,method);
      METHOD_NAME_TO_ID.put(methodIndexName,methodId);
      return methodId;
    }
  }
  return 0;
}",0.9835680751173708
192937,"void resizeDockedStackLocked(Rect dockedBounds,Rect tempDockedTaskBounds,Rect tempDockedTaskInsetBounds,Rect tempOtherTaskBounds,Rect tempOtherTaskInsetBounds,boolean preserveWindows){
  final ActivityStack stack=getStack(DOCKED_STACK_ID);
  if (stack == null) {
    Slog.w(TAG,""String_Node_Str"");
    return;
  }
  Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER,""String_Node_Str"");
  mWindowManager.deferSurfaceLayout();
  try {
    ActivityRecord r=stack.topRunningActivityLocked();
    resizeStackUncheckedLocked(stack,dockedBounds,tempDockedTaskBounds,tempDockedTaskInsetBounds);
    if (stack.mFullscreen) {
      for (int i=FIRST_STATIC_STACK_ID; i <= LAST_STATIC_STACK_ID; i++) {
        if (StackId.isResizeableByDockedStack(i) && getStack(i) != null) {
          resizeStackLocked(i,null,null,null,preserveWindows,true);
        }
      }
      ArrayList<TaskRecord> tasks=stack.getAllTasks();
      final int count=tasks.size();
      for (int i=0; i < count; i++) {
        moveTaskToStackLocked(tasks.get(i).taskId,FULLSCREEN_WORKSPACE_STACK_ID,ON_TOP,FORCE_FOCUS,""String_Node_Str"",false);
      }
      r=null;
    }
 else {
      mWindowManager.getStackDockedModeBounds(HOME_STACK_ID,tempRect);
      for (int i=FIRST_STATIC_STACK_ID; i <= LAST_STATIC_STACK_ID; i++) {
        if (StackId.isResizeableByDockedStack(i)) {
          ActivityStack otherStack=getStack(i);
          if (otherStack != null) {
            resizeStackLocked(i,tempRect,tempOtherTaskBounds,tempOtherTaskInsetBounds,preserveWindows,true);
          }
        }
      }
    }
    ensureConfigurationAndResume(stack,r,preserveWindows);
  }
  finally {
    mWindowManager.continueSurfaceLayout();
    Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);
  }
  mResizeDockedStackTimeout.notifyResizing(dockedBounds,tempDockedTaskBounds != null || tempDockedTaskInsetBounds != null || tempOtherTaskBounds != null || tempOtherTaskInsetBounds != null);
}","void resizeDockedStackLocked(Rect dockedBounds,Rect tempDockedTaskBounds,Rect tempDockedTaskInsetBounds,Rect tempOtherTaskBounds,Rect tempOtherTaskInsetBounds,boolean preserveWindows){
  final ActivityStack stack=getStack(DOCKED_STACK_ID);
  if (stack == null) {
    Slog.w(TAG,""String_Node_Str"");
    return;
  }
  Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER,""String_Node_Str"");
  mWindowManager.deferSurfaceLayout();
  try {
    ActivityRecord r=stack.topRunningActivityLocked();
    resizeStackUncheckedLocked(stack,dockedBounds,tempDockedTaskBounds,tempDockedTaskInsetBounds);
    if (stack.mFullscreen) {
      for (int i=FIRST_STATIC_STACK_ID; i <= LAST_STATIC_STACK_ID; i++) {
        if (StackId.isResizeableByDockedStack(i) && getStack(i) != null) {
          resizeStackLocked(i,null,null,null,preserveWindows,true);
        }
      }
      ArrayList<TaskRecord> tasks=stack.getAllTasks();
      final int count=tasks.size();
      for (int i=0; i < count; i++) {
        moveTaskToStackLocked(tasks.get(i).taskId,FULLSCREEN_WORKSPACE_STACK_ID,ON_TOP,FORCE_FOCUS,""String_Node_Str"",false);
      }
      r=null;
    }
 else {
      mWindowManager.getStackDockedModeBounds(HOME_STACK_ID,tempRect,true);
      for (int i=FIRST_STATIC_STACK_ID; i <= LAST_STATIC_STACK_ID; i++) {
        if (StackId.isResizeableByDockedStack(i)) {
          ActivityStack otherStack=getStack(i);
          if (otherStack != null) {
            resizeStackLocked(i,tempRect,tempOtherTaskBounds,tempOtherTaskInsetBounds,preserveWindows,true);
          }
        }
      }
    }
    ensureConfigurationAndResume(stack,r,preserveWindows);
  }
  finally {
    mWindowManager.continueSurfaceLayout();
    Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);
  }
  mResizeDockedStackTimeout.notifyResizing(dockedBounds,tempDockedTaskBounds != null || tempDockedTaskInsetBounds != null || tempOtherTaskBounds != null || tempOtherTaskInsetBounds != null);
}",0.9987023098883988
192938,"/** 
 * Original bounds of the task if applicable, otherwise fullscreen rect. 
 */
public void getBounds(Rect out){
  if (useCurrentBounds()) {
    out.set(mBounds);
    return;
  }
  mStack.getDisplayContent().getLogicalDisplayRect(out);
}","/** 
 * Original bounds of the task if applicable, otherwise fullscreen rect. 
 */
void getBounds(Rect out){
  if (useCurrentBounds()) {
    out.set(mBounds);
    return;
  }
  mStack.getDisplayContent().getLogicalDisplayRect(out);
}",0.985200845665962
192939,"void getStackDockedModeBoundsLocked(Rect outBounds){
  if (!StackId.isResizeableByDockedStack(mStackId) || mDisplayContent == null) {
    outBounds.set(mBounds);
    return;
  }
  final TaskStack dockedStack=mService.mStackIdToStack.get(DOCKED_STACK_ID);
  if (dockedStack == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (!dockedStack.isVisibleLocked()) {
    mDisplayContent.getLogicalDisplayRect(mTmpRect);
    return;
  }
  final int dockedSide=dockedStack.getDockSide();
  if (dockedSide == DOCKED_INVALID) {
    Slog.e(TAG_WM,""String_Node_Str"" + dockedStack);
    outBounds.set(mBounds);
    return;
  }
  mDisplayContent.getLogicalDisplayRect(mTmpRect);
  dockedStack.getRawBounds(mTmpRect2);
  final boolean dockedOnTopOrLeft=dockedSide == DOCKED_TOP || dockedSide == DOCKED_LEFT;
  getStackDockedModeBounds(mTmpRect,outBounds,mStackId,mTmpRect2,mDisplayContent.mDividerControllerLocked.getContentWidth(),dockedOnTopOrLeft);
}","void getStackDockedModeBoundsLocked(Rect outBounds,boolean ignoreVisibilityOnKeyguardShowing){
  if (!StackId.isResizeableByDockedStack(mStackId) || mDisplayContent == null) {
    outBounds.set(mBounds);
    return;
  }
  final TaskStack dockedStack=mService.mStackIdToStack.get(DOCKED_STACK_ID);
  if (dockedStack == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (!dockedStack.isVisibleLocked(ignoreVisibilityOnKeyguardShowing)) {
    mDisplayContent.getLogicalDisplayRect(outBounds);
    return;
  }
  final int dockedSide=dockedStack.getDockSide();
  if (dockedSide == DOCKED_INVALID) {
    Slog.e(TAG_WM,""String_Node_Str"" + dockedStack);
    outBounds.set(mBounds);
    return;
  }
  mDisplayContent.getLogicalDisplayRect(mTmpRect);
  dockedStack.getRawBounds(mTmpRect2);
  final boolean dockedOnTopOrLeft=dockedSide == DOCKED_TOP || dockedSide == DOCKED_LEFT;
  getStackDockedModeBounds(mTmpRect,outBounds,mStackId,mTmpRect2,mDisplayContent.mDividerControllerLocked.getContentWidth(),dockedOnTopOrLeft);
}",0.953953953953954
192940,"boolean isVisibleLocked(){
  final boolean keyguardOn=mService.mPolicy.isKeyguardShowingOrOccluded();
  if (keyguardOn && !StackId.isAllowedOverLockscreen(mStackId)) {
    return false;
  }
  for (int i=mTasks.size() - 1; i >= 0; i--) {
    Task task=mTasks.get(i);
    for (int j=task.mAppTokens.size() - 1; j >= 0; j--) {
      if (!task.mAppTokens.get(j).hidden) {
        return true;
      }
    }
  }
  return false;
}","boolean isVisibleLocked(boolean ignoreVisibilityOnKeyguardShowing){
  final boolean keyguardOn=mService.mPolicy.isKeyguardShowingOrOccluded();
  if (keyguardOn && !StackId.isAllowedOverLockscreen(mStackId)) {
    return ignoreVisibilityOnKeyguardShowing;
  }
  for (int i=mTasks.size() - 1; i >= 0; i--) {
    Task task=mTasks.get(i);
    for (int j=task.mAppTokens.size() - 1; j >= 0; j--) {
      if (!task.mAppTokens.get(j).hidden) {
        return true;
      }
    }
  }
  return false;
}",0.9138495092693566
192941,"public void getStackDockedModeBounds(int stackId,Rect bounds){
synchronized (mWindowMap) {
    final TaskStack stack=mStackIdToStack.get(stackId);
    if (stack != null) {
      stack.getStackDockedModeBoundsLocked(bounds);
      return;
    }
    bounds.setEmpty();
  }
}","public void getStackDockedModeBounds(int stackId,Rect bounds,boolean ignoreVisibilityOnKeyguardShowing){
synchronized (mWindowMap) {
    final TaskStack stack=mStackIdToStack.get(stackId);
    if (stack != null) {
      stack.getStackDockedModeBoundsLocked(bounds,ignoreVisibilityOnKeyguardShowing);
      return;
    }
    bounds.setEmpty();
  }
}",0.8774193548387097
192942,"void resizeDockedStackLocked(Rect dockedBounds,Rect tempDockedTaskBounds,Rect tempDockedTaskInsetBounds,Rect tempOtherTaskBounds,Rect tempOtherTaskInsetBounds,boolean preserveWindows){
  final ActivityStack stack=getStack(DOCKED_STACK_ID);
  if (stack == null) {
    Slog.w(TAG,""String_Node_Str"");
    return;
  }
  Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER,""String_Node_Str"");
  mWindowManager.deferSurfaceLayout();
  try {
    ActivityRecord r=stack.topRunningActivityLocked();
    resizeStackUncheckedLocked(stack,dockedBounds,tempDockedTaskBounds,tempDockedTaskInsetBounds);
    if (stack.mFullscreen) {
      for (int i=FIRST_STATIC_STACK_ID; i <= LAST_STATIC_STACK_ID; i++) {
        if (StackId.isResizeableByDockedStack(i) && getStack(i) != null) {
          resizeStackLocked(i,null,null,null,preserveWindows,true);
        }
      }
      ArrayList<TaskRecord> tasks=stack.getAllTasks();
      final int count=tasks.size();
      for (int i=0; i < count; i++) {
        moveTaskToStackLocked(tasks.get(i).taskId,FULLSCREEN_WORKSPACE_STACK_ID,ON_TOP,FORCE_FOCUS,""String_Node_Str"",false);
      }
      r=null;
    }
 else {
      mWindowManager.getStackDockedModeBounds(HOME_STACK_ID,tempRect);
      for (int i=FIRST_STATIC_STACK_ID; i <= LAST_STATIC_STACK_ID; i++) {
        if (StackId.isResizeableByDockedStack(i)) {
          ActivityStack otherStack=getStack(i);
          if (otherStack != null) {
            resizeStackLocked(i,tempRect,tempOtherTaskBounds,tempOtherTaskInsetBounds,preserveWindows,true);
          }
        }
      }
    }
    ensureConfigurationAndResume(stack,r,preserveWindows);
  }
  finally {
    mWindowManager.continueSurfaceLayout();
    Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);
  }
  mResizeDockedStackTimeout.notifyResizing(dockedBounds,tempDockedTaskBounds != null || tempDockedTaskInsetBounds != null || tempOtherTaskBounds != null || tempOtherTaskInsetBounds != null);
}","void resizeDockedStackLocked(Rect dockedBounds,Rect tempDockedTaskBounds,Rect tempDockedTaskInsetBounds,Rect tempOtherTaskBounds,Rect tempOtherTaskInsetBounds,boolean preserveWindows){
  final ActivityStack stack=getStack(DOCKED_STACK_ID);
  if (stack == null) {
    Slog.w(TAG,""String_Node_Str"");
    return;
  }
  Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER,""String_Node_Str"");
  mWindowManager.deferSurfaceLayout();
  try {
    ActivityRecord r=stack.topRunningActivityLocked();
    resizeStackUncheckedLocked(stack,dockedBounds,tempDockedTaskBounds,tempDockedTaskInsetBounds);
    if (stack.mFullscreen) {
      for (int i=FIRST_STATIC_STACK_ID; i <= LAST_STATIC_STACK_ID; i++) {
        if (StackId.isResizeableByDockedStack(i) && getStack(i) != null) {
          resizeStackLocked(i,null,null,null,preserveWindows,true);
        }
      }
      ArrayList<TaskRecord> tasks=stack.getAllTasks();
      final int count=tasks.size();
      for (int i=0; i < count; i++) {
        moveTaskToStackLocked(tasks.get(i).taskId,FULLSCREEN_WORKSPACE_STACK_ID,ON_TOP,FORCE_FOCUS,""String_Node_Str"",false);
      }
      r=null;
    }
 else {
      mWindowManager.getStackDockedModeBounds(HOME_STACK_ID,tempRect,true);
      for (int i=FIRST_STATIC_STACK_ID; i <= LAST_STATIC_STACK_ID; i++) {
        if (StackId.isResizeableByDockedStack(i)) {
          ActivityStack otherStack=getStack(i);
          if (otherStack != null) {
            resizeStackLocked(i,tempRect,tempOtherTaskBounds,tempOtherTaskInsetBounds,preserveWindows,true);
          }
        }
      }
    }
    ensureConfigurationAndResume(stack,r,preserveWindows);
  }
  finally {
    mWindowManager.continueSurfaceLayout();
    Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);
  }
  mResizeDockedStackTimeout.notifyResizing(dockedBounds,tempDockedTaskBounds != null || tempDockedTaskInsetBounds != null || tempOtherTaskBounds != null || tempOtherTaskInsetBounds != null);
}",0.9987023098883988
192943,"/** 
 * Original bounds of the task if applicable, otherwise fullscreen rect. 
 */
public void getBounds(Rect out){
  if (useCurrentBounds()) {
    out.set(mBounds);
    return;
  }
  mStack.getDisplayContent().getLogicalDisplayRect(out);
}","/** 
 * Original bounds of the task if applicable, otherwise fullscreen rect. 
 */
void getBounds(Rect out){
  if (useCurrentBounds()) {
    out.set(mBounds);
    return;
  }
  mStack.getDisplayContent().getLogicalDisplayRect(out);
}",0.985200845665962
192944,"void getStackDockedModeBoundsLocked(Rect outBounds){
  if (!StackId.isResizeableByDockedStack(mStackId) || mDisplayContent == null) {
    outBounds.set(mBounds);
    return;
  }
  final TaskStack dockedStack=mService.mStackIdToStack.get(DOCKED_STACK_ID);
  if (dockedStack == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (!dockedStack.isVisibleLocked()) {
    mDisplayContent.getLogicalDisplayRect(mTmpRect);
    return;
  }
  final int dockedSide=dockedStack.getDockSide();
  if (dockedSide == DOCKED_INVALID) {
    Slog.e(TAG_WM,""String_Node_Str"" + dockedStack);
    outBounds.set(mBounds);
    return;
  }
  mDisplayContent.getLogicalDisplayRect(mTmpRect);
  dockedStack.getRawBounds(mTmpRect2);
  final boolean dockedOnTopOrLeft=dockedSide == DOCKED_TOP || dockedSide == DOCKED_LEFT;
  getStackDockedModeBounds(mTmpRect,outBounds,mStackId,mTmpRect2,mDisplayContent.mDividerControllerLocked.getContentWidth(),dockedOnTopOrLeft);
}","void getStackDockedModeBoundsLocked(Rect outBounds,boolean ignoreVisibilityOnKeyguardShowing){
  if (!StackId.isResizeableByDockedStack(mStackId) || mDisplayContent == null) {
    outBounds.set(mBounds);
    return;
  }
  final TaskStack dockedStack=mService.mStackIdToStack.get(DOCKED_STACK_ID);
  if (dockedStack == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (!dockedStack.isVisibleLocked(ignoreVisibilityOnKeyguardShowing)) {
    mDisplayContent.getLogicalDisplayRect(outBounds);
    return;
  }
  final int dockedSide=dockedStack.getDockSide();
  if (dockedSide == DOCKED_INVALID) {
    Slog.e(TAG_WM,""String_Node_Str"" + dockedStack);
    outBounds.set(mBounds);
    return;
  }
  mDisplayContent.getLogicalDisplayRect(mTmpRect);
  dockedStack.getRawBounds(mTmpRect2);
  final boolean dockedOnTopOrLeft=dockedSide == DOCKED_TOP || dockedSide == DOCKED_LEFT;
  getStackDockedModeBounds(mTmpRect,outBounds,mStackId,mTmpRect2,mDisplayContent.mDividerControllerLocked.getContentWidth(),dockedOnTopOrLeft);
}",0.953953953953954
192945,"boolean isVisibleLocked(){
  final boolean keyguardOn=mService.mPolicy.isKeyguardShowingOrOccluded();
  if (keyguardOn && !StackId.isAllowedOverLockscreen(mStackId)) {
    return false;
  }
  for (int i=mTasks.size() - 1; i >= 0; i--) {
    Task task=mTasks.get(i);
    for (int j=task.mAppTokens.size() - 1; j >= 0; j--) {
      if (!task.mAppTokens.get(j).hidden) {
        return true;
      }
    }
  }
  return false;
}","boolean isVisibleLocked(boolean ignoreVisibilityOnKeyguardShowing){
  final boolean keyguardOn=mService.mPolicy.isKeyguardShowingOrOccluded();
  if (keyguardOn && !StackId.isAllowedOverLockscreen(mStackId)) {
    return ignoreVisibilityOnKeyguardShowing;
  }
  for (int i=mTasks.size() - 1; i >= 0; i--) {
    Task task=mTasks.get(i);
    for (int j=task.mAppTokens.size() - 1; j >= 0; j--) {
      if (!task.mAppTokens.get(j).hidden) {
        return true;
      }
    }
  }
  return false;
}",0.9138495092693566
192946,"public void getStackDockedModeBounds(int stackId,Rect bounds){
synchronized (mWindowMap) {
    final TaskStack stack=mStackIdToStack.get(stackId);
    if (stack != null) {
      stack.getStackDockedModeBoundsLocked(bounds);
      return;
    }
    bounds.setEmpty();
  }
}","public void getStackDockedModeBounds(int stackId,Rect bounds,boolean ignoreVisibilityOnKeyguardShowing){
synchronized (mWindowMap) {
    final TaskStack stack=mStackIdToStack.get(stackId);
    if (stack != null) {
      stack.getStackDockedModeBoundsLocked(bounds,ignoreVisibilityOnKeyguardShowing);
      return;
    }
    bounds.setEmpty();
  }
}",0.8774193548387097
192947,"/** 
 * @return whether there are any docked tasks.
 */
public boolean hasDockedTask(){
  if (mIam == null)   return false;
  ActivityManager.StackInfo stackInfo=null;
  try {
    stackInfo=mIam.getStackInfo(DOCKED_STACK_ID);
  }
 catch (  RemoteException e) {
    e.printStackTrace();
  }
  return stackInfo != null;
}","/** 
 * @return whether there are any docked tasks for the current user.
 */
public boolean hasDockedTask(){
  if (mIam == null)   return false;
  ActivityManager.StackInfo stackInfo=null;
  try {
    stackInfo=mIam.getStackInfo(DOCKED_STACK_ID);
    if (stackInfo != null && stackInfo.userId != getCurrentUser()) {
      return false;
    }
  }
 catch (  RemoteException e) {
    e.printStackTrace();
  }
  return stackInfo != null;
}",0.8461538461538461
192948,"void updateDisplayInfo(final DisplayContent displayContent){
  if (displayContent == null) {
    return;
  }
  if (mFullscreen) {
    setBounds(null,Configuration.EMPTY);
    return;
  }
  final int newRotation=displayContent.getDisplayInfo().rotation;
  if (mRotation == newRotation) {
    return;
  }
  mTmpRect2.set(mPreScrollBounds);
  displayContent.rotateBounds(mRotation,newRotation,mTmpRect2);
  if (setBounds(mTmpRect2,mOverrideConfig) != BOUNDS_CHANGE_NONE) {
    if (mStack.mStackId == FREEFORM_WORKSPACE_STACK_ID) {
      mService.mH.sendMessage(mService.mH.obtainMessage(RESIZE_TASK,mTaskId,RESIZE_MODE_SYSTEM_SCREEN_ROTATION,mPreScrollBounds));
    }
  }
}","void updateDisplayInfo(final DisplayContent displayContent){
  if (displayContent == null) {
    return;
  }
  if (mFullscreen) {
    setBounds(null,Configuration.EMPTY);
    return;
  }
  final int newRotation=displayContent.getDisplayInfo().rotation;
  if (mRotation == newRotation) {
    return;
  }
  mTmpRect2.set(mPreScrollBounds);
  if (!StackId.isTaskResizeAllowed(mStack.mStackId)) {
    setBounds(mTmpRect2,mOverrideConfig);
    return;
  }
  displayContent.rotateBounds(mRotation,newRotation,mTmpRect2);
  if (setBounds(mTmpRect2,mOverrideConfig) != BOUNDS_CHANGE_NONE) {
    mService.mH.obtainMessage(RESIZE_TASK,mTaskId,RESIZE_MODE_SYSTEM_SCREEN_ROTATION,mPreScrollBounds).sendToTarget();
  }
}",0.8380537400145244
192949,"void updateDisplayInfo(final DisplayContent displayContent){
  if (displayContent == null) {
    return;
  }
  if (mFullscreen) {
    setBounds(null,Configuration.EMPTY);
    return;
  }
  final int newRotation=displayContent.getDisplayInfo().rotation;
  if (mRotation == newRotation) {
    return;
  }
  mTmpRect2.set(mPreScrollBounds);
  displayContent.rotateBounds(mRotation,newRotation,mTmpRect2);
  if (setBounds(mTmpRect2,mOverrideConfig) != BOUNDS_CHANGE_NONE) {
    if (mStack.mStackId == FREEFORM_WORKSPACE_STACK_ID) {
      mService.mH.sendMessage(mService.mH.obtainMessage(RESIZE_TASK,mTaskId,RESIZE_MODE_SYSTEM_SCREEN_ROTATION,mPreScrollBounds));
    }
  }
}","void updateDisplayInfo(final DisplayContent displayContent){
  if (displayContent == null) {
    return;
  }
  if (mFullscreen) {
    setBounds(null,Configuration.EMPTY);
    return;
  }
  final int newRotation=displayContent.getDisplayInfo().rotation;
  if (mRotation == newRotation) {
    return;
  }
  mTmpRect2.set(mPreScrollBounds);
  if (!StackId.isTaskResizeAllowed(mStack.mStackId)) {
    setBounds(mTmpRect2,mOverrideConfig);
    return;
  }
  displayContent.rotateBounds(mRotation,newRotation,mTmpRect2);
  if (setBounds(mTmpRect2,mOverrideConfig) != BOUNDS_CHANGE_NONE) {
    mService.mH.obtainMessage(RESIZE_TASK,mTaskId,RESIZE_MODE_SYSTEM_SCREEN_ROTATION,mPreScrollBounds).sendToTarget();
  }
}",0.8380537400145244
192950,"/** 
 * This should be the only way to get the time from the system.
 */
private long checkAndGetTimeLocked(){
  final long actualSystemTime=System.currentTimeMillis();
  final long actualRealtime=SystemClock.elapsedRealtime();
  final long expectedSystemTime=(actualRealtime - mRealTimeSnapshot) + mSystemTimeSnapshot;
  boolean resetBeginIdleTime=false;
  if (Math.abs(actualSystemTime - expectedSystemTime) > TIME_CHANGE_THRESHOLD_MILLIS) {
    if (Math.abs(actualSystemTime - expectedSystemTime) > mAppIdleDurationMillis) {
      mScreenOnSystemTimeSnapshot=actualSystemTime;
      mScreenOnTime=0;
      resetBeginIdleTime=true;
    }
    final int userCount=mUserState.size();
    for (int i=0; i < userCount; i++) {
      final UserUsageStatsService service=mUserState.valueAt(i);
      service.onTimeChanged(expectedSystemTime,actualSystemTime,resetBeginIdleTime);
    }
    mRealTimeSnapshot=actualRealtime;
    mSystemTimeSnapshot=actualSystemTime;
  }
  return actualSystemTime;
}","/** 
 * This should be the only way to get the time from the system.
 */
private long checkAndGetTimeLocked(){
  final long actualSystemTime=System.currentTimeMillis();
  final long actualRealtime=SystemClock.elapsedRealtime();
  final long expectedSystemTime=(actualRealtime - mRealTimeSnapshot) + mSystemTimeSnapshot;
  boolean resetBeginIdleTime=false;
  if (Math.abs(actualSystemTime - expectedSystemTime) > TIME_CHANGE_THRESHOLD_MILLIS) {
    if (Math.abs(actualSystemTime - expectedSystemTime) > mAppIdleDurationMillis) {
      mScreenOnSystemTimeSnapshot=actualSystemTime;
      mScreenOnTime=0;
      resetBeginIdleTime=true;
    }
    final int userCount=mUserState.size();
    for (int i=0; i < userCount; i++) {
      final UserUsageStatsService service=mUserState.valueAt(i);
      service.onTimeChanged(expectedSystemTime,actualSystemTime,mScreenOnTime,resetBeginIdleTime);
    }
    mRealTimeSnapshot=actualRealtime;
    mSystemTimeSnapshot=actualSystemTime;
  }
  return actualSystemTime;
}",0.9929859719438878
192951,"void onTimeChanged(long oldTime,long newTime,boolean resetBeginIdleTime){
  persistActiveStats();
  mDatabase.onTimeChanged(newTime - oldTime);
  loadActiveStats(newTime,resetBeginIdleTime);
  refreshAppIdleRollingWindow(newTime);
}","void onTimeChanged(long oldTime,long newTime,long deviceUsageTime,boolean resetBeginIdleTime){
  persistActiveStats();
  mDatabase.onTimeChanged(newTime - oldTime);
  loadActiveStats(newTime,resetBeginIdleTime);
  refreshAppIdleRollingWindow(newTime,deviceUsageTime);
}",0.9261477045908184
192952,"/** 
 * If any of the apps don't have a last-used entry, add one now.
 * @param currentTimeMillis the current time
 * @param firstUpdate if it is the first update, touch all installed apps, otherwise onlytouch the system apps
 */
private void initializeDefaultsForApps(long currentTimeMillis,long deviceUsageTime,boolean firstUpdate){
  PackageManager pm=mContext.getPackageManager();
  List<PackageInfo> packages=pm.getInstalledPackagesAsUser(0,mUserId);
  final int packageCount=packages.size();
  for (int i=0; i < packageCount; i++) {
    final PackageInfo pi=packages.get(i);
    String packageName=pi.packageName;
    if (pi.applicationInfo != null && (firstUpdate || pi.applicationInfo.isSystemApp()) && getBeginIdleTime(packageName) == -1) {
      for (      IntervalStats stats : mCurrentStats) {
        stats.update(packageName,currentTimeMillis,Event.SYSTEM_INTERACTION);
        stats.updateBeginIdleTime(packageName,deviceUsageTime);
        mStatsChanged=true;
      }
    }
  }
  persistActiveStats();
}","/** 
 * If any of the apps don't have a last-used entry, add one now.
 * @param currentTimeMillis the current time
 * @param firstUpdate if it is the first update, touch all installed apps, otherwise onlytouch the system apps
 */
private void initializeDefaultsForApps(long currentTimeMillis,long deviceUsageTime,boolean firstUpdate){
  PackageManager pm=mContext.getPackageManager();
  List<PackageInfo> packages=pm.getInstalledPackagesAsUser(0,mUserId);
  final int packageCount=packages.size();
  for (int i=0; i < packageCount; i++) {
    final PackageInfo pi=packages.get(i);
    String packageName=pi.packageName;
    if (pi.applicationInfo != null && (firstUpdate || pi.applicationInfo.isSystemApp()) && getBeginIdleTime(packageName) == -1) {
      for (      IntervalStats stats : mCurrentStats) {
        stats.update(packageName,currentTimeMillis,Event.SYSTEM_INTERACTION);
        stats.updateBeginIdleTime(packageName,deviceUsageTime);
      }
      mAppIdleRollingWindow.update(packageName,currentTimeMillis,Event.SYSTEM_INTERACTION);
      mAppIdleRollingWindow.updateBeginIdleTime(packageName,deviceUsageTime);
      mStatsChanged=true;
    }
  }
  persistActiveStats();
}",0.8966455122393472
192953,"private static void mergePackageStats(IntervalStats dst,IntervalStats src){
  dst.endTime=Math.max(dst.endTime,src.endTime);
  final int srcPackageCount=src.packageStats.size();
  for (int i=0; i < srcPackageCount; i++) {
    final String packageName=src.packageStats.keyAt(i);
    final UsageStats srcStats=src.packageStats.valueAt(i);
    final UsageStats dstStats=dst.packageStats.get(packageName);
    if (dstStats == null) {
      dst.packageStats.put(packageName,new UsageStats(srcStats));
    }
 else {
      dstStats.add(src.packageStats.valueAt(i));
    }
  }
}","private static void mergePackageStats(IntervalStats dst,IntervalStats src,final long deviceUsageTime){
  dst.endTime=Math.max(dst.endTime,src.endTime);
  final int srcPackageCount=src.packageStats.size();
  for (int i=0; i < srcPackageCount; i++) {
    final String packageName=src.packageStats.keyAt(i);
    final UsageStats srcStats=src.packageStats.valueAt(i);
    UsageStats dstStats=dst.packageStats.get(packageName);
    if (dstStats == null) {
      dstStats=new UsageStats(srcStats);
      dst.packageStats.put(packageName,dstStats);
    }
 else {
      dstStats.add(src.packageStats.valueAt(i));
    }
    if (dstStats.mBeginIdleTime > deviceUsageTime) {
      dstStats.mBeginIdleTime=deviceUsageTime;
    }
  }
}",0.6408668730650154
192954,"@Override public void combine(IntervalStats stats,boolean mutable,List<IntervalStats> accumulatedResult){
  IntervalStats accum;
  if (accumulatedResult.isEmpty()) {
    accum=new IntervalStats();
    accum.beginTime=stats.beginTime;
    accumulatedResult.add(accum);
  }
 else {
    accum=accumulatedResult.get(0);
  }
  mergePackageStats(accum,stats);
}","@Override public void combine(IntervalStats stats,boolean mutable,List<IntervalStats> accumulatedResult){
  IntervalStats accum;
  if (accumulatedResult.isEmpty()) {
    accum=new IntervalStats();
    accum.beginTime=stats.beginTime;
    accumulatedResult.add(accum);
  }
 else {
    accum=accumulatedResult.get(0);
  }
  mergePackageStats(accum,stats,deviceUsageTime);
}",0.977961432506887
192955,"void init(final long currentTimeMillis,final long deviceUsageTime){
  mDatabase.init(currentTimeMillis);
  int nullCount=0;
  for (int i=0; i < mCurrentStats.length; i++) {
    mCurrentStats[i]=mDatabase.getLatestUsageStats(i);
    if (mCurrentStats[i] == null) {
      nullCount++;
    }
  }
  if (nullCount > 0) {
    if (nullCount != mCurrentStats.length) {
      Slog.w(TAG,mLogPrefix + ""String_Node_Str"");
    }
 else {
    }
    loadActiveStats(currentTimeMillis,false);
  }
 else {
    updateRolloverDeadline();
  }
  for (  IntervalStats stat : mCurrentStats) {
    final int pkgCount=stat.packageStats.size();
    for (int i=0; i < pkgCount; i++) {
      UsageStats pkgStats=stat.packageStats.valueAt(i);
      if (pkgStats.mLastEvent == UsageEvents.Event.MOVE_TO_FOREGROUND || pkgStats.mLastEvent == UsageEvents.Event.CONTINUE_PREVIOUS_DAY) {
        stat.update(pkgStats.mPackageName,stat.lastTimeSaved,UsageEvents.Event.END_OF_DAY);
        notifyStatsChanged();
      }
    }
    stat.updateConfigurationStats(null,stat.lastTimeSaved);
  }
  if (mDatabase.isNewUpdate()) {
    initializeDefaultsForApps(currentTimeMillis,deviceUsageTime,mDatabase.isFirstUpdate());
  }
  refreshAppIdleRollingWindow(currentTimeMillis);
}","void init(final long currentTimeMillis,final long deviceUsageTime){
  mDatabase.init(currentTimeMillis);
  int nullCount=0;
  for (int i=0; i < mCurrentStats.length; i++) {
    mCurrentStats[i]=mDatabase.getLatestUsageStats(i);
    if (mCurrentStats[i] == null) {
      nullCount++;
    }
  }
  if (nullCount > 0) {
    if (nullCount != mCurrentStats.length) {
      Slog.w(TAG,mLogPrefix + ""String_Node_Str"");
    }
 else {
    }
    loadActiveStats(currentTimeMillis,false);
  }
 else {
    updateRolloverDeadline();
  }
  for (  IntervalStats stat : mCurrentStats) {
    final int pkgCount=stat.packageStats.size();
    for (int i=0; i < pkgCount; i++) {
      UsageStats pkgStats=stat.packageStats.valueAt(i);
      if (pkgStats.mLastEvent == UsageEvents.Event.MOVE_TO_FOREGROUND || pkgStats.mLastEvent == UsageEvents.Event.CONTINUE_PREVIOUS_DAY) {
        stat.update(pkgStats.mPackageName,stat.lastTimeSaved,UsageEvents.Event.END_OF_DAY);
        notifyStatsChanged();
      }
    }
    stat.updateConfigurationStats(null,stat.lastTimeSaved);
  }
  refreshAppIdleRollingWindow(currentTimeMillis,deviceUsageTime);
  if (mDatabase.isNewUpdate()) {
    initializeDefaultsForApps(currentTimeMillis,deviceUsageTime,mDatabase.isFirstUpdate());
  }
}",0.9532634971796938
192956,"void reportEvent(UsageEvents.Event event,long deviceUsageTime){
  if (DEBUG) {
    Slog.d(TAG,mLogPrefix + ""String_Node_Str"" + event.mPackage+ ""String_Node_Str""+ event.mTimeStamp+ ""String_Node_Str""+ eventToString(event.mEventType));
  }
  if (event.mTimeStamp >= mDailyExpiryDate.getTimeInMillis()) {
    rolloverStats(event.mTimeStamp);
  }
  final IntervalStats currentDailyStats=mCurrentStats[UsageStatsManager.INTERVAL_DAILY];
  final Configuration newFullConfig=event.mConfiguration;
  if (event.mEventType == UsageEvents.Event.CONFIGURATION_CHANGE && currentDailyStats.activeConfiguration != null) {
    event.mConfiguration=Configuration.generateDelta(currentDailyStats.activeConfiguration,newFullConfig);
  }
  if (currentDailyStats.events == null) {
    currentDailyStats.events=new TimeSparseArray<>();
  }
  if (event.mEventType != UsageEvents.Event.SYSTEM_INTERACTION) {
    currentDailyStats.events.put(event.mTimeStamp,event);
  }
  for (  IntervalStats stats : mCurrentStats) {
    if (event.mEventType == UsageEvents.Event.CONFIGURATION_CHANGE) {
      stats.updateConfigurationStats(newFullConfig,event.mTimeStamp);
    }
 else {
      stats.update(event.mPackage,event.mTimeStamp,event.mEventType);
      stats.updateBeginIdleTime(event.mPackage,deviceUsageTime);
    }
  }
  if (event.mEventType != Event.CONFIGURATION_CHANGE) {
    mAppIdleRollingWindow.update(event.mPackage,event.mTimeStamp,event.mEventType);
    mAppIdleRollingWindow.updateBeginIdleTime(event.mPackage,deviceUsageTime);
  }
  notifyStatsChanged();
}","void reportEvent(UsageEvents.Event event,long deviceUsageTime){
  if (DEBUG) {
    Slog.d(TAG,mLogPrefix + ""String_Node_Str"" + event.mPackage+ ""String_Node_Str""+ event.mTimeStamp+ ""String_Node_Str""+ eventToString(event.mEventType));
  }
  if (event.mTimeStamp >= mDailyExpiryDate.getTimeInMillis()) {
    rolloverStats(event.mTimeStamp,deviceUsageTime);
  }
  final IntervalStats currentDailyStats=mCurrentStats[UsageStatsManager.INTERVAL_DAILY];
  final Configuration newFullConfig=event.mConfiguration;
  if (event.mEventType == UsageEvents.Event.CONFIGURATION_CHANGE && currentDailyStats.activeConfiguration != null) {
    event.mConfiguration=Configuration.generateDelta(currentDailyStats.activeConfiguration,newFullConfig);
  }
  if (currentDailyStats.events == null) {
    currentDailyStats.events=new TimeSparseArray<>();
  }
  if (event.mEventType != UsageEvents.Event.SYSTEM_INTERACTION) {
    currentDailyStats.events.put(event.mTimeStamp,event);
  }
  for (  IntervalStats stats : mCurrentStats) {
    if (event.mEventType == UsageEvents.Event.CONFIGURATION_CHANGE) {
      stats.updateConfigurationStats(newFullConfig,event.mTimeStamp);
    }
 else {
      stats.update(event.mPackage,event.mTimeStamp,event.mEventType);
      stats.updateBeginIdleTime(event.mPackage,deviceUsageTime);
    }
  }
  if (event.mEventType != Event.CONFIGURATION_CHANGE) {
    mAppIdleRollingWindow.update(event.mPackage,event.mTimeStamp,event.mEventType);
    mAppIdleRollingWindow.updateBeginIdleTime(event.mPackage,deviceUsageTime);
  }
  notifyStatsChanged();
}",0.9948320413436692
192957,"/** 
 * App idle operates on a rolling window of time. When we roll over time, we end up with a period of time where in-memory stats are empty and we don't hit the disk for older stats for performance reasons. Suddenly all apps will become idle. Instead, at times we do a deep query to find all the apps that have run in the past few days and keep the cached data up to date.
 * @param currentTimeMillis
 */
void refreshAppIdleRollingWindow(long currentTimeMillis){
  List<IntervalStats> stats=mDatabase.queryUsageStats(UsageStatsManager.INTERVAL_DAILY,currentTimeMillis - (1000 * 60 * 60* 24* 2),currentTimeMillis,sPackageStatsMerger);
  if (stats == null || stats.isEmpty()) {
    mAppIdleRollingWindow=new IntervalStats();
    mergePackageStats(mAppIdleRollingWindow,mCurrentStats[UsageStatsManager.INTERVAL_YEARLY]);
  }
 else {
    mAppIdleRollingWindow=stats.get(0);
  }
}","/** 
 * App idle operates on a rolling window of time. When we roll over time, we end up with a period of time where in-memory stats are empty and we don't hit the disk for older stats for performance reasons. Suddenly all apps will become idle. Instead, at times we do a deep query to find all the apps that have run in the past few days and keep the cached data up to date.
 * @param currentTimeMillis
 */
void refreshAppIdleRollingWindow(final long currentTimeMillis,final long deviceUsageTime){
  List<IntervalStats> stats=mDatabase.queryUsageStats(UsageStatsManager.INTERVAL_DAILY,currentTimeMillis - (1000 * 60 * 60* 24* 2),currentTimeMillis,new StatCombiner<IntervalStats>(){
    @Override public void combine(    IntervalStats stats,    boolean mutable,    List<IntervalStats> accumulatedResult){
      IntervalStats accum;
      if (accumulatedResult.isEmpty()) {
        accum=new IntervalStats();
        accum.beginTime=stats.beginTime;
        accumulatedResult.add(accum);
      }
 else {
        accum=accumulatedResult.get(0);
      }
      mergePackageStats(accum,stats,deviceUsageTime);
    }
  }
);
  if (stats == null || stats.isEmpty()) {
    mAppIdleRollingWindow=new IntervalStats();
    mergePackageStats(mAppIdleRollingWindow,mCurrentStats[UsageStatsManager.INTERVAL_YEARLY],deviceUsageTime);
  }
 else {
    mAppIdleRollingWindow=stats.get(0);
  }
}",0.7731913004882379
192958,"private void rolloverStats(final long currentTimeMillis){
  final long startTime=SystemClock.elapsedRealtime();
  Slog.i(TAG,mLogPrefix + ""String_Node_Str"");
  final Configuration previousConfig=mCurrentStats[UsageStatsManager.INTERVAL_DAILY].activeConfiguration;
  ArraySet<String> continuePreviousDay=new ArraySet<>();
  for (  IntervalStats stat : mCurrentStats) {
    final int pkgCount=stat.packageStats.size();
    for (int i=0; i < pkgCount; i++) {
      UsageStats pkgStats=stat.packageStats.valueAt(i);
      if (pkgStats.mLastEvent == UsageEvents.Event.MOVE_TO_FOREGROUND || pkgStats.mLastEvent == UsageEvents.Event.CONTINUE_PREVIOUS_DAY) {
        continuePreviousDay.add(pkgStats.mPackageName);
        stat.update(pkgStats.mPackageName,mDailyExpiryDate.getTimeInMillis() - 1,UsageEvents.Event.END_OF_DAY);
        notifyStatsChanged();
      }
    }
    stat.updateConfigurationStats(null,mDailyExpiryDate.getTimeInMillis() - 1);
  }
  persistActiveStats();
  mDatabase.prune(currentTimeMillis);
  loadActiveStats(currentTimeMillis,false);
  final int continueCount=continuePreviousDay.size();
  for (int i=0; i < continueCount; i++) {
    String name=continuePreviousDay.valueAt(i);
    final long beginTime=mCurrentStats[UsageStatsManager.INTERVAL_DAILY].beginTime;
    for (    IntervalStats stat : mCurrentStats) {
      stat.update(name,beginTime,UsageEvents.Event.CONTINUE_PREVIOUS_DAY);
      stat.updateConfigurationStats(previousConfig,beginTime);
      notifyStatsChanged();
    }
  }
  persistActiveStats();
  refreshAppIdleRollingWindow(currentTimeMillis);
  final long totalTime=SystemClock.elapsedRealtime() - startTime;
  Slog.i(TAG,mLogPrefix + ""String_Node_Str"" + totalTime+ ""String_Node_Str"");
}","private void rolloverStats(final long currentTimeMillis,final long deviceUsageTime){
  final long startTime=SystemClock.elapsedRealtime();
  Slog.i(TAG,mLogPrefix + ""String_Node_Str"");
  final Configuration previousConfig=mCurrentStats[UsageStatsManager.INTERVAL_DAILY].activeConfiguration;
  ArraySet<String> continuePreviousDay=new ArraySet<>();
  for (  IntervalStats stat : mCurrentStats) {
    final int pkgCount=stat.packageStats.size();
    for (int i=0; i < pkgCount; i++) {
      UsageStats pkgStats=stat.packageStats.valueAt(i);
      if (pkgStats.mLastEvent == UsageEvents.Event.MOVE_TO_FOREGROUND || pkgStats.mLastEvent == UsageEvents.Event.CONTINUE_PREVIOUS_DAY) {
        continuePreviousDay.add(pkgStats.mPackageName);
        stat.update(pkgStats.mPackageName,mDailyExpiryDate.getTimeInMillis() - 1,UsageEvents.Event.END_OF_DAY);
        notifyStatsChanged();
      }
    }
    stat.updateConfigurationStats(null,mDailyExpiryDate.getTimeInMillis() - 1);
  }
  persistActiveStats();
  mDatabase.prune(currentTimeMillis);
  loadActiveStats(currentTimeMillis,false);
  final int continueCount=continuePreviousDay.size();
  for (int i=0; i < continueCount; i++) {
    String name=continuePreviousDay.valueAt(i);
    final long beginTime=mCurrentStats[UsageStatsManager.INTERVAL_DAILY].beginTime;
    for (    IntervalStats stat : mCurrentStats) {
      stat.update(name,beginTime,UsageEvents.Event.CONTINUE_PREVIOUS_DAY);
      stat.updateConfigurationStats(previousConfig,beginTime);
      notifyStatsChanged();
    }
  }
  persistActiveStats();
  refreshAppIdleRollingWindow(currentTimeMillis,deviceUsageTime);
  final long totalTime=SystemClock.elapsedRealtime() - startTime;
  Slog.i(TAG,mLogPrefix + ""String_Node_Str"" + totalTime+ ""String_Node_Str"");
}",0.9876967095851216
192959,"/** 
 * This should be the only way to get the time from the system.
 */
private long checkAndGetTimeLocked(){
  final long actualSystemTime=System.currentTimeMillis();
  final long actualRealtime=SystemClock.elapsedRealtime();
  final long expectedSystemTime=(actualRealtime - mRealTimeSnapshot) + mSystemTimeSnapshot;
  boolean resetBeginIdleTime=false;
  if (Math.abs(actualSystemTime - expectedSystemTime) > TIME_CHANGE_THRESHOLD_MILLIS) {
    if (Math.abs(actualSystemTime - expectedSystemTime) > mAppIdleDurationMillis) {
      mScreenOnSystemTimeSnapshot=actualSystemTime;
      mScreenOnTime=0;
      resetBeginIdleTime=true;
    }
    final int userCount=mUserState.size();
    for (int i=0; i < userCount; i++) {
      final UserUsageStatsService service=mUserState.valueAt(i);
      service.onTimeChanged(expectedSystemTime,actualSystemTime,resetBeginIdleTime);
    }
    mRealTimeSnapshot=actualRealtime;
    mSystemTimeSnapshot=actualSystemTime;
  }
  return actualSystemTime;
}","/** 
 * This should be the only way to get the time from the system.
 */
private long checkAndGetTimeLocked(){
  final long actualSystemTime=System.currentTimeMillis();
  final long actualRealtime=SystemClock.elapsedRealtime();
  final long expectedSystemTime=(actualRealtime - mRealTimeSnapshot) + mSystemTimeSnapshot;
  boolean resetBeginIdleTime=false;
  if (Math.abs(actualSystemTime - expectedSystemTime) > TIME_CHANGE_THRESHOLD_MILLIS) {
    if (Math.abs(actualSystemTime - expectedSystemTime) > mAppIdleDurationMillis) {
      mScreenOnSystemTimeSnapshot=actualSystemTime;
      mScreenOnTime=0;
      resetBeginIdleTime=true;
    }
    final int userCount=mUserState.size();
    for (int i=0; i < userCount; i++) {
      final UserUsageStatsService service=mUserState.valueAt(i);
      service.onTimeChanged(expectedSystemTime,actualSystemTime,mScreenOnTime,resetBeginIdleTime);
    }
    mRealTimeSnapshot=actualRealtime;
    mSystemTimeSnapshot=actualSystemTime;
  }
  return actualSystemTime;
}",0.9929859719438878
192960,"void onTimeChanged(long oldTime,long newTime,boolean resetBeginIdleTime){
  persistActiveStats();
  mDatabase.onTimeChanged(newTime - oldTime);
  loadActiveStats(newTime,resetBeginIdleTime);
  refreshAppIdleRollingWindow(newTime);
}","void onTimeChanged(long oldTime,long newTime,long deviceUsageTime,boolean resetBeginIdleTime){
  persistActiveStats();
  mDatabase.onTimeChanged(newTime - oldTime);
  loadActiveStats(newTime,resetBeginIdleTime);
  refreshAppIdleRollingWindow(newTime,deviceUsageTime);
}",0.9261477045908184
192961,"/** 
 * If any of the apps don't have a last-used entry, add one now.
 * @param currentTimeMillis the current time
 * @param firstUpdate if it is the first update, touch all installed apps, otherwise onlytouch the system apps
 */
private void initializeDefaultsForApps(long currentTimeMillis,long deviceUsageTime,boolean firstUpdate){
  PackageManager pm=mContext.getPackageManager();
  List<PackageInfo> packages=pm.getInstalledPackagesAsUser(0,mUserId);
  final int packageCount=packages.size();
  for (int i=0; i < packageCount; i++) {
    final PackageInfo pi=packages.get(i);
    String packageName=pi.packageName;
    if (pi.applicationInfo != null && (firstUpdate || pi.applicationInfo.isSystemApp()) && getBeginIdleTime(packageName) == -1) {
      for (      IntervalStats stats : mCurrentStats) {
        stats.update(packageName,currentTimeMillis,Event.SYSTEM_INTERACTION);
        stats.updateBeginIdleTime(packageName,deviceUsageTime);
        mStatsChanged=true;
      }
    }
  }
  persistActiveStats();
}","/** 
 * If any of the apps don't have a last-used entry, add one now.
 * @param currentTimeMillis the current time
 * @param firstUpdate if it is the first update, touch all installed apps, otherwise onlytouch the system apps
 */
private void initializeDefaultsForApps(long currentTimeMillis,long deviceUsageTime,boolean firstUpdate){
  PackageManager pm=mContext.getPackageManager();
  List<PackageInfo> packages=pm.getInstalledPackagesAsUser(0,mUserId);
  final int packageCount=packages.size();
  for (int i=0; i < packageCount; i++) {
    final PackageInfo pi=packages.get(i);
    String packageName=pi.packageName;
    if (pi.applicationInfo != null && (firstUpdate || pi.applicationInfo.isSystemApp()) && getBeginIdleTime(packageName) == -1) {
      for (      IntervalStats stats : mCurrentStats) {
        stats.update(packageName,currentTimeMillis,Event.SYSTEM_INTERACTION);
        stats.updateBeginIdleTime(packageName,deviceUsageTime);
      }
      mAppIdleRollingWindow.update(packageName,currentTimeMillis,Event.SYSTEM_INTERACTION);
      mAppIdleRollingWindow.updateBeginIdleTime(packageName,deviceUsageTime);
      mStatsChanged=true;
    }
  }
  persistActiveStats();
}",0.8966455122393472
192962,"private static void mergePackageStats(IntervalStats dst,IntervalStats src){
  dst.endTime=Math.max(dst.endTime,src.endTime);
  final int srcPackageCount=src.packageStats.size();
  for (int i=0; i < srcPackageCount; i++) {
    final String packageName=src.packageStats.keyAt(i);
    final UsageStats srcStats=src.packageStats.valueAt(i);
    final UsageStats dstStats=dst.packageStats.get(packageName);
    if (dstStats == null) {
      dst.packageStats.put(packageName,new UsageStats(srcStats));
    }
 else {
      dstStats.add(src.packageStats.valueAt(i));
    }
  }
}","private static void mergePackageStats(IntervalStats dst,IntervalStats src,final long deviceUsageTime){
  dst.endTime=Math.max(dst.endTime,src.endTime);
  final int srcPackageCount=src.packageStats.size();
  for (int i=0; i < srcPackageCount; i++) {
    final String packageName=src.packageStats.keyAt(i);
    final UsageStats srcStats=src.packageStats.valueAt(i);
    UsageStats dstStats=dst.packageStats.get(packageName);
    if (dstStats == null) {
      dstStats=new UsageStats(srcStats);
      dst.packageStats.put(packageName,dstStats);
    }
 else {
      dstStats.add(src.packageStats.valueAt(i));
    }
    if (dstStats.mBeginIdleTime > deviceUsageTime) {
      dstStats.mBeginIdleTime=deviceUsageTime;
    }
  }
}",0.6408668730650154
192963,"@Override public void combine(IntervalStats stats,boolean mutable,List<IntervalStats> accumulatedResult){
  IntervalStats accum;
  if (accumulatedResult.isEmpty()) {
    accum=new IntervalStats();
    accum.beginTime=stats.beginTime;
    accumulatedResult.add(accum);
  }
 else {
    accum=accumulatedResult.get(0);
  }
  mergePackageStats(accum,stats);
}","@Override public void combine(IntervalStats stats,boolean mutable,List<IntervalStats> accumulatedResult){
  IntervalStats accum;
  if (accumulatedResult.isEmpty()) {
    accum=new IntervalStats();
    accum.beginTime=stats.beginTime;
    accumulatedResult.add(accum);
  }
 else {
    accum=accumulatedResult.get(0);
  }
  mergePackageStats(accum,stats,deviceUsageTime);
}",0.977961432506887
192964,"void init(final long currentTimeMillis,final long deviceUsageTime){
  mDatabase.init(currentTimeMillis);
  int nullCount=0;
  for (int i=0; i < mCurrentStats.length; i++) {
    mCurrentStats[i]=mDatabase.getLatestUsageStats(i);
    if (mCurrentStats[i] == null) {
      nullCount++;
    }
  }
  if (nullCount > 0) {
    if (nullCount != mCurrentStats.length) {
      Slog.w(TAG,mLogPrefix + ""String_Node_Str"");
    }
 else {
    }
    loadActiveStats(currentTimeMillis,false);
  }
 else {
    updateRolloverDeadline();
  }
  for (  IntervalStats stat : mCurrentStats) {
    final int pkgCount=stat.packageStats.size();
    for (int i=0; i < pkgCount; i++) {
      UsageStats pkgStats=stat.packageStats.valueAt(i);
      if (pkgStats.mLastEvent == UsageEvents.Event.MOVE_TO_FOREGROUND || pkgStats.mLastEvent == UsageEvents.Event.CONTINUE_PREVIOUS_DAY) {
        stat.update(pkgStats.mPackageName,stat.lastTimeSaved,UsageEvents.Event.END_OF_DAY);
        notifyStatsChanged();
      }
    }
    stat.updateConfigurationStats(null,stat.lastTimeSaved);
  }
  if (mDatabase.isNewUpdate()) {
    initializeDefaultsForApps(currentTimeMillis,deviceUsageTime,mDatabase.isFirstUpdate());
  }
  refreshAppIdleRollingWindow(currentTimeMillis);
}","void init(final long currentTimeMillis,final long deviceUsageTime){
  mDatabase.init(currentTimeMillis);
  int nullCount=0;
  for (int i=0; i < mCurrentStats.length; i++) {
    mCurrentStats[i]=mDatabase.getLatestUsageStats(i);
    if (mCurrentStats[i] == null) {
      nullCount++;
    }
  }
  if (nullCount > 0) {
    if (nullCount != mCurrentStats.length) {
      Slog.w(TAG,mLogPrefix + ""String_Node_Str"");
    }
 else {
    }
    loadActiveStats(currentTimeMillis,false);
  }
 else {
    updateRolloverDeadline();
  }
  for (  IntervalStats stat : mCurrentStats) {
    final int pkgCount=stat.packageStats.size();
    for (int i=0; i < pkgCount; i++) {
      UsageStats pkgStats=stat.packageStats.valueAt(i);
      if (pkgStats.mLastEvent == UsageEvents.Event.MOVE_TO_FOREGROUND || pkgStats.mLastEvent == UsageEvents.Event.CONTINUE_PREVIOUS_DAY) {
        stat.update(pkgStats.mPackageName,stat.lastTimeSaved,UsageEvents.Event.END_OF_DAY);
        notifyStatsChanged();
      }
    }
    stat.updateConfigurationStats(null,stat.lastTimeSaved);
  }
  refreshAppIdleRollingWindow(currentTimeMillis,deviceUsageTime);
  if (mDatabase.isNewUpdate()) {
    initializeDefaultsForApps(currentTimeMillis,deviceUsageTime,mDatabase.isFirstUpdate());
  }
}",0.9532634971796938
192965,"void reportEvent(UsageEvents.Event event,long deviceUsageTime){
  if (DEBUG) {
    Slog.d(TAG,mLogPrefix + ""String_Node_Str"" + event.mPackage+ ""String_Node_Str""+ event.mTimeStamp+ ""String_Node_Str""+ eventToString(event.mEventType));
  }
  if (event.mTimeStamp >= mDailyExpiryDate.getTimeInMillis()) {
    rolloverStats(event.mTimeStamp);
  }
  final IntervalStats currentDailyStats=mCurrentStats[UsageStatsManager.INTERVAL_DAILY];
  final Configuration newFullConfig=event.mConfiguration;
  if (event.mEventType == UsageEvents.Event.CONFIGURATION_CHANGE && currentDailyStats.activeConfiguration != null) {
    event.mConfiguration=Configuration.generateDelta(currentDailyStats.activeConfiguration,newFullConfig);
  }
  if (currentDailyStats.events == null) {
    currentDailyStats.events=new TimeSparseArray<>();
  }
  if (event.mEventType != UsageEvents.Event.SYSTEM_INTERACTION) {
    currentDailyStats.events.put(event.mTimeStamp,event);
  }
  for (  IntervalStats stats : mCurrentStats) {
    if (event.mEventType == UsageEvents.Event.CONFIGURATION_CHANGE) {
      stats.updateConfigurationStats(newFullConfig,event.mTimeStamp);
    }
 else {
      stats.update(event.mPackage,event.mTimeStamp,event.mEventType);
      stats.updateBeginIdleTime(event.mPackage,deviceUsageTime);
    }
  }
  if (event.mEventType != Event.CONFIGURATION_CHANGE) {
    mAppIdleRollingWindow.update(event.mPackage,event.mTimeStamp,event.mEventType);
    mAppIdleRollingWindow.updateBeginIdleTime(event.mPackage,deviceUsageTime);
  }
  notifyStatsChanged();
}","void reportEvent(UsageEvents.Event event,long deviceUsageTime){
  if (DEBUG) {
    Slog.d(TAG,mLogPrefix + ""String_Node_Str"" + event.mPackage+ ""String_Node_Str""+ event.mTimeStamp+ ""String_Node_Str""+ eventToString(event.mEventType));
  }
  if (event.mTimeStamp >= mDailyExpiryDate.getTimeInMillis()) {
    rolloverStats(event.mTimeStamp,deviceUsageTime);
  }
  final IntervalStats currentDailyStats=mCurrentStats[UsageStatsManager.INTERVAL_DAILY];
  final Configuration newFullConfig=event.mConfiguration;
  if (event.mEventType == UsageEvents.Event.CONFIGURATION_CHANGE && currentDailyStats.activeConfiguration != null) {
    event.mConfiguration=Configuration.generateDelta(currentDailyStats.activeConfiguration,newFullConfig);
  }
  if (currentDailyStats.events == null) {
    currentDailyStats.events=new TimeSparseArray<>();
  }
  if (event.mEventType != UsageEvents.Event.SYSTEM_INTERACTION) {
    currentDailyStats.events.put(event.mTimeStamp,event);
  }
  for (  IntervalStats stats : mCurrentStats) {
    if (event.mEventType == UsageEvents.Event.CONFIGURATION_CHANGE) {
      stats.updateConfigurationStats(newFullConfig,event.mTimeStamp);
    }
 else {
      stats.update(event.mPackage,event.mTimeStamp,event.mEventType);
      stats.updateBeginIdleTime(event.mPackage,deviceUsageTime);
    }
  }
  if (event.mEventType != Event.CONFIGURATION_CHANGE) {
    mAppIdleRollingWindow.update(event.mPackage,event.mTimeStamp,event.mEventType);
    mAppIdleRollingWindow.updateBeginIdleTime(event.mPackage,deviceUsageTime);
  }
  notifyStatsChanged();
}",0.9948320413436692
192966,"/** 
 * App idle operates on a rolling window of time. When we roll over time, we end up with a period of time where in-memory stats are empty and we don't hit the disk for older stats for performance reasons. Suddenly all apps will become idle. Instead, at times we do a deep query to find all the apps that have run in the past few days and keep the cached data up to date.
 * @param currentTimeMillis
 */
void refreshAppIdleRollingWindow(long currentTimeMillis){
  List<IntervalStats> stats=mDatabase.queryUsageStats(UsageStatsManager.INTERVAL_DAILY,currentTimeMillis - (1000 * 60 * 60* 24* 2),currentTimeMillis,sPackageStatsMerger);
  if (stats == null || stats.isEmpty()) {
    mAppIdleRollingWindow=new IntervalStats();
    mergePackageStats(mAppIdleRollingWindow,mCurrentStats[UsageStatsManager.INTERVAL_YEARLY]);
  }
 else {
    mAppIdleRollingWindow=stats.get(0);
  }
}","/** 
 * App idle operates on a rolling window of time. When we roll over time, we end up with a period of time where in-memory stats are empty and we don't hit the disk for older stats for performance reasons. Suddenly all apps will become idle. Instead, at times we do a deep query to find all the apps that have run in the past few days and keep the cached data up to date.
 * @param currentTimeMillis
 */
void refreshAppIdleRollingWindow(final long currentTimeMillis,final long deviceUsageTime){
  List<IntervalStats> stats=mDatabase.queryUsageStats(UsageStatsManager.INTERVAL_DAILY,currentTimeMillis - (1000 * 60 * 60* 24* 2),currentTimeMillis,new StatCombiner<IntervalStats>(){
    @Override public void combine(    IntervalStats stats,    boolean mutable,    List<IntervalStats> accumulatedResult){
      IntervalStats accum;
      if (accumulatedResult.isEmpty()) {
        accum=new IntervalStats();
        accum.beginTime=stats.beginTime;
        accumulatedResult.add(accum);
      }
 else {
        accum=accumulatedResult.get(0);
      }
      mergePackageStats(accum,stats,deviceUsageTime);
    }
  }
);
  if (stats == null || stats.isEmpty()) {
    mAppIdleRollingWindow=new IntervalStats();
    mergePackageStats(mAppIdleRollingWindow,mCurrentStats[UsageStatsManager.INTERVAL_YEARLY],deviceUsageTime);
  }
 else {
    mAppIdleRollingWindow=stats.get(0);
  }
}",0.7731913004882379
192967,"private void rolloverStats(final long currentTimeMillis){
  final long startTime=SystemClock.elapsedRealtime();
  Slog.i(TAG,mLogPrefix + ""String_Node_Str"");
  final Configuration previousConfig=mCurrentStats[UsageStatsManager.INTERVAL_DAILY].activeConfiguration;
  ArraySet<String> continuePreviousDay=new ArraySet<>();
  for (  IntervalStats stat : mCurrentStats) {
    final int pkgCount=stat.packageStats.size();
    for (int i=0; i < pkgCount; i++) {
      UsageStats pkgStats=stat.packageStats.valueAt(i);
      if (pkgStats.mLastEvent == UsageEvents.Event.MOVE_TO_FOREGROUND || pkgStats.mLastEvent == UsageEvents.Event.CONTINUE_PREVIOUS_DAY) {
        continuePreviousDay.add(pkgStats.mPackageName);
        stat.update(pkgStats.mPackageName,mDailyExpiryDate.getTimeInMillis() - 1,UsageEvents.Event.END_OF_DAY);
        notifyStatsChanged();
      }
    }
    stat.updateConfigurationStats(null,mDailyExpiryDate.getTimeInMillis() - 1);
  }
  persistActiveStats();
  mDatabase.prune(currentTimeMillis);
  loadActiveStats(currentTimeMillis,false);
  final int continueCount=continuePreviousDay.size();
  for (int i=0; i < continueCount; i++) {
    String name=continuePreviousDay.valueAt(i);
    final long beginTime=mCurrentStats[UsageStatsManager.INTERVAL_DAILY].beginTime;
    for (    IntervalStats stat : mCurrentStats) {
      stat.update(name,beginTime,UsageEvents.Event.CONTINUE_PREVIOUS_DAY);
      stat.updateConfigurationStats(previousConfig,beginTime);
      notifyStatsChanged();
    }
  }
  persistActiveStats();
  refreshAppIdleRollingWindow(currentTimeMillis);
  final long totalTime=SystemClock.elapsedRealtime() - startTime;
  Slog.i(TAG,mLogPrefix + ""String_Node_Str"" + totalTime+ ""String_Node_Str"");
}","private void rolloverStats(final long currentTimeMillis,final long deviceUsageTime){
  final long startTime=SystemClock.elapsedRealtime();
  Slog.i(TAG,mLogPrefix + ""String_Node_Str"");
  final Configuration previousConfig=mCurrentStats[UsageStatsManager.INTERVAL_DAILY].activeConfiguration;
  ArraySet<String> continuePreviousDay=new ArraySet<>();
  for (  IntervalStats stat : mCurrentStats) {
    final int pkgCount=stat.packageStats.size();
    for (int i=0; i < pkgCount; i++) {
      UsageStats pkgStats=stat.packageStats.valueAt(i);
      if (pkgStats.mLastEvent == UsageEvents.Event.MOVE_TO_FOREGROUND || pkgStats.mLastEvent == UsageEvents.Event.CONTINUE_PREVIOUS_DAY) {
        continuePreviousDay.add(pkgStats.mPackageName);
        stat.update(pkgStats.mPackageName,mDailyExpiryDate.getTimeInMillis() - 1,UsageEvents.Event.END_OF_DAY);
        notifyStatsChanged();
      }
    }
    stat.updateConfigurationStats(null,mDailyExpiryDate.getTimeInMillis() - 1);
  }
  persistActiveStats();
  mDatabase.prune(currentTimeMillis);
  loadActiveStats(currentTimeMillis,false);
  final int continueCount=continuePreviousDay.size();
  for (int i=0; i < continueCount; i++) {
    String name=continuePreviousDay.valueAt(i);
    final long beginTime=mCurrentStats[UsageStatsManager.INTERVAL_DAILY].beginTime;
    for (    IntervalStats stat : mCurrentStats) {
      stat.update(name,beginTime,UsageEvents.Event.CONTINUE_PREVIOUS_DAY);
      stat.updateConfigurationStats(previousConfig,beginTime);
      notifyStatsChanged();
    }
  }
  persistActiveStats();
  refreshAppIdleRollingWindow(currentTimeMillis,deviceUsageTime);
  final long totalTime=SystemClock.elapsedRealtime() - startTime;
  Slog.i(TAG,mLogPrefix + ""String_Node_Str"" + totalTime+ ""String_Node_Str"");
}",0.9876967095851216
192968,"/** 
 * This should be the only way to get the time from the system.
 */
private long checkAndGetTimeLocked(){
  final long actualSystemTime=System.currentTimeMillis();
  final long actualRealtime=SystemClock.elapsedRealtime();
  final long expectedSystemTime=(actualRealtime - mRealTimeSnapshot) + mSystemTimeSnapshot;
  boolean resetBeginIdleTime=false;
  if (Math.abs(actualSystemTime - expectedSystemTime) > TIME_CHANGE_THRESHOLD_MILLIS) {
    if (Math.abs(actualSystemTime - expectedSystemTime) > mAppIdleDurationMillis) {
      mScreenOnSystemTimeSnapshot=actualSystemTime;
      mScreenOnTime=0;
      resetBeginIdleTime=true;
    }
    final int userCount=mUserState.size();
    for (int i=0; i < userCount; i++) {
      final UserUsageStatsService service=mUserState.valueAt(i);
      service.onTimeChanged(expectedSystemTime,actualSystemTime,resetBeginIdleTime);
    }
    mRealTimeSnapshot=actualRealtime;
    mSystemTimeSnapshot=actualSystemTime;
  }
  return actualSystemTime;
}","/** 
 * This should be the only way to get the time from the system.
 */
private long checkAndGetTimeLocked(){
  final long actualSystemTime=System.currentTimeMillis();
  final long actualRealtime=SystemClock.elapsedRealtime();
  final long expectedSystemTime=(actualRealtime - mRealTimeSnapshot) + mSystemTimeSnapshot;
  boolean resetBeginIdleTime=false;
  if (Math.abs(actualSystemTime - expectedSystemTime) > TIME_CHANGE_THRESHOLD_MILLIS) {
    if (Math.abs(actualSystemTime - expectedSystemTime) > mAppIdleDurationMillis) {
      mScreenOnSystemTimeSnapshot=actualSystemTime;
      mScreenOnTime=0;
      resetBeginIdleTime=true;
    }
    final int userCount=mUserState.size();
    for (int i=0; i < userCount; i++) {
      final UserUsageStatsService service=mUserState.valueAt(i);
      service.onTimeChanged(expectedSystemTime,actualSystemTime,mScreenOnTime,resetBeginIdleTime);
    }
    mRealTimeSnapshot=actualRealtime;
    mSystemTimeSnapshot=actualSystemTime;
  }
  return actualSystemTime;
}",0.9929859719438878
192969,"void onTimeChanged(long oldTime,long newTime,boolean resetBeginIdleTime){
  persistActiveStats();
  mDatabase.onTimeChanged(newTime - oldTime);
  loadActiveStats(newTime,resetBeginIdleTime);
  refreshAppIdleRollingWindow(newTime);
}","void onTimeChanged(long oldTime,long newTime,long deviceUsageTime,boolean resetBeginIdleTime){
  persistActiveStats();
  mDatabase.onTimeChanged(newTime - oldTime);
  loadActiveStats(newTime,resetBeginIdleTime);
  refreshAppIdleRollingWindow(newTime,deviceUsageTime);
}",0.9261477045908184
192970,"/** 
 * If any of the apps don't have a last-used entry, add one now.
 * @param currentTimeMillis the current time
 * @param firstUpdate if it is the first update, touch all installed apps, otherwise onlytouch the system apps
 */
private void initializeDefaultsForApps(long currentTimeMillis,long deviceUsageTime,boolean firstUpdate){
  PackageManager pm=mContext.getPackageManager();
  List<PackageInfo> packages=pm.getInstalledPackagesAsUser(0,mUserId);
  final int packageCount=packages.size();
  for (int i=0; i < packageCount; i++) {
    final PackageInfo pi=packages.get(i);
    String packageName=pi.packageName;
    if (pi.applicationInfo != null && (firstUpdate || pi.applicationInfo.isSystemApp()) && getBeginIdleTime(packageName) == -1) {
      for (      IntervalStats stats : mCurrentStats) {
        stats.update(packageName,currentTimeMillis,Event.SYSTEM_INTERACTION);
        stats.updateBeginIdleTime(packageName,deviceUsageTime);
        mStatsChanged=true;
      }
    }
  }
  persistActiveStats();
}","/** 
 * If any of the apps don't have a last-used entry, add one now.
 * @param currentTimeMillis the current time
 * @param firstUpdate if it is the first update, touch all installed apps, otherwise onlytouch the system apps
 */
private void initializeDefaultsForApps(long currentTimeMillis,long deviceUsageTime,boolean firstUpdate){
  PackageManager pm=mContext.getPackageManager();
  List<PackageInfo> packages=pm.getInstalledPackagesAsUser(0,mUserId);
  final int packageCount=packages.size();
  for (int i=0; i < packageCount; i++) {
    final PackageInfo pi=packages.get(i);
    String packageName=pi.packageName;
    if (pi.applicationInfo != null && (firstUpdate || pi.applicationInfo.isSystemApp()) && getBeginIdleTime(packageName) == -1) {
      for (      IntervalStats stats : mCurrentStats) {
        stats.update(packageName,currentTimeMillis,Event.SYSTEM_INTERACTION);
        stats.updateBeginIdleTime(packageName,deviceUsageTime);
      }
      mAppIdleRollingWindow.update(packageName,currentTimeMillis,Event.SYSTEM_INTERACTION);
      mAppIdleRollingWindow.updateBeginIdleTime(packageName,deviceUsageTime);
      mStatsChanged=true;
    }
  }
  persistActiveStats();
}",0.8966455122393472
192971,"private static void mergePackageStats(IntervalStats dst,IntervalStats src){
  dst.endTime=Math.max(dst.endTime,src.endTime);
  final int srcPackageCount=src.packageStats.size();
  for (int i=0; i < srcPackageCount; i++) {
    final String packageName=src.packageStats.keyAt(i);
    final UsageStats srcStats=src.packageStats.valueAt(i);
    final UsageStats dstStats=dst.packageStats.get(packageName);
    if (dstStats == null) {
      dst.packageStats.put(packageName,new UsageStats(srcStats));
    }
 else {
      dstStats.add(src.packageStats.valueAt(i));
    }
  }
}","private static void mergePackageStats(IntervalStats dst,IntervalStats src,final long deviceUsageTime){
  dst.endTime=Math.max(dst.endTime,src.endTime);
  final int srcPackageCount=src.packageStats.size();
  for (int i=0; i < srcPackageCount; i++) {
    final String packageName=src.packageStats.keyAt(i);
    final UsageStats srcStats=src.packageStats.valueAt(i);
    UsageStats dstStats=dst.packageStats.get(packageName);
    if (dstStats == null) {
      dstStats=new UsageStats(srcStats);
      dst.packageStats.put(packageName,dstStats);
    }
 else {
      dstStats.add(src.packageStats.valueAt(i));
    }
    if (dstStats.mBeginIdleTime > deviceUsageTime) {
      dstStats.mBeginIdleTime=deviceUsageTime;
    }
  }
}",0.6408668730650154
192972,"@Override public void combine(IntervalStats stats,boolean mutable,List<IntervalStats> accumulatedResult){
  IntervalStats accum;
  if (accumulatedResult.isEmpty()) {
    accum=new IntervalStats();
    accum.beginTime=stats.beginTime;
    accumulatedResult.add(accum);
  }
 else {
    accum=accumulatedResult.get(0);
  }
  mergePackageStats(accum,stats);
}","@Override public void combine(IntervalStats stats,boolean mutable,List<IntervalStats> accumulatedResult){
  IntervalStats accum;
  if (accumulatedResult.isEmpty()) {
    accum=new IntervalStats();
    accum.beginTime=stats.beginTime;
    accumulatedResult.add(accum);
  }
 else {
    accum=accumulatedResult.get(0);
  }
  mergePackageStats(accum,stats,deviceUsageTime);
}",0.977961432506887
192973,"void init(final long currentTimeMillis,final long deviceUsageTime){
  mDatabase.init(currentTimeMillis);
  int nullCount=0;
  for (int i=0; i < mCurrentStats.length; i++) {
    mCurrentStats[i]=mDatabase.getLatestUsageStats(i);
    if (mCurrentStats[i] == null) {
      nullCount++;
    }
  }
  if (nullCount > 0) {
    if (nullCount != mCurrentStats.length) {
      Slog.w(TAG,mLogPrefix + ""String_Node_Str"");
    }
 else {
    }
    loadActiveStats(currentTimeMillis,false);
  }
 else {
    updateRolloverDeadline();
  }
  for (  IntervalStats stat : mCurrentStats) {
    final int pkgCount=stat.packageStats.size();
    for (int i=0; i < pkgCount; i++) {
      UsageStats pkgStats=stat.packageStats.valueAt(i);
      if (pkgStats.mLastEvent == UsageEvents.Event.MOVE_TO_FOREGROUND || pkgStats.mLastEvent == UsageEvents.Event.CONTINUE_PREVIOUS_DAY) {
        stat.update(pkgStats.mPackageName,stat.lastTimeSaved,UsageEvents.Event.END_OF_DAY);
        notifyStatsChanged();
      }
    }
    stat.updateConfigurationStats(null,stat.lastTimeSaved);
  }
  if (mDatabase.isNewUpdate()) {
    initializeDefaultsForApps(currentTimeMillis,deviceUsageTime,mDatabase.isFirstUpdate());
  }
  refreshAppIdleRollingWindow(currentTimeMillis);
}","void init(final long currentTimeMillis,final long deviceUsageTime){
  mDatabase.init(currentTimeMillis);
  int nullCount=0;
  for (int i=0; i < mCurrentStats.length; i++) {
    mCurrentStats[i]=mDatabase.getLatestUsageStats(i);
    if (mCurrentStats[i] == null) {
      nullCount++;
    }
  }
  if (nullCount > 0) {
    if (nullCount != mCurrentStats.length) {
      Slog.w(TAG,mLogPrefix + ""String_Node_Str"");
    }
 else {
    }
    loadActiveStats(currentTimeMillis,false);
  }
 else {
    updateRolloverDeadline();
  }
  for (  IntervalStats stat : mCurrentStats) {
    final int pkgCount=stat.packageStats.size();
    for (int i=0; i < pkgCount; i++) {
      UsageStats pkgStats=stat.packageStats.valueAt(i);
      if (pkgStats.mLastEvent == UsageEvents.Event.MOVE_TO_FOREGROUND || pkgStats.mLastEvent == UsageEvents.Event.CONTINUE_PREVIOUS_DAY) {
        stat.update(pkgStats.mPackageName,stat.lastTimeSaved,UsageEvents.Event.END_OF_DAY);
        notifyStatsChanged();
      }
    }
    stat.updateConfigurationStats(null,stat.lastTimeSaved);
  }
  refreshAppIdleRollingWindow(currentTimeMillis,deviceUsageTime);
  if (mDatabase.isNewUpdate()) {
    initializeDefaultsForApps(currentTimeMillis,deviceUsageTime,mDatabase.isFirstUpdate());
  }
}",0.9532634971796938
192974,"void reportEvent(UsageEvents.Event event,long deviceUsageTime){
  if (DEBUG) {
    Slog.d(TAG,mLogPrefix + ""String_Node_Str"" + event.mPackage+ ""String_Node_Str""+ event.mTimeStamp+ ""String_Node_Str""+ eventToString(event.mEventType));
  }
  if (event.mTimeStamp >= mDailyExpiryDate.getTimeInMillis()) {
    rolloverStats(event.mTimeStamp);
  }
  final IntervalStats currentDailyStats=mCurrentStats[UsageStatsManager.INTERVAL_DAILY];
  final Configuration newFullConfig=event.mConfiguration;
  if (event.mEventType == UsageEvents.Event.CONFIGURATION_CHANGE && currentDailyStats.activeConfiguration != null) {
    event.mConfiguration=Configuration.generateDelta(currentDailyStats.activeConfiguration,newFullConfig);
  }
  if (currentDailyStats.events == null) {
    currentDailyStats.events=new TimeSparseArray<>();
  }
  if (event.mEventType != UsageEvents.Event.SYSTEM_INTERACTION) {
    currentDailyStats.events.put(event.mTimeStamp,event);
  }
  for (  IntervalStats stats : mCurrentStats) {
    if (event.mEventType == UsageEvents.Event.CONFIGURATION_CHANGE) {
      stats.updateConfigurationStats(newFullConfig,event.mTimeStamp);
    }
 else {
      stats.update(event.mPackage,event.mTimeStamp,event.mEventType);
      stats.updateBeginIdleTime(event.mPackage,deviceUsageTime);
    }
  }
  if (event.mEventType != Event.CONFIGURATION_CHANGE) {
    mAppIdleRollingWindow.update(event.mPackage,event.mTimeStamp,event.mEventType);
    mAppIdleRollingWindow.updateBeginIdleTime(event.mPackage,deviceUsageTime);
  }
  notifyStatsChanged();
}","void reportEvent(UsageEvents.Event event,long deviceUsageTime){
  if (DEBUG) {
    Slog.d(TAG,mLogPrefix + ""String_Node_Str"" + event.mPackage+ ""String_Node_Str""+ event.mTimeStamp+ ""String_Node_Str""+ eventToString(event.mEventType));
  }
  if (event.mTimeStamp >= mDailyExpiryDate.getTimeInMillis()) {
    rolloverStats(event.mTimeStamp,deviceUsageTime);
  }
  final IntervalStats currentDailyStats=mCurrentStats[UsageStatsManager.INTERVAL_DAILY];
  final Configuration newFullConfig=event.mConfiguration;
  if (event.mEventType == UsageEvents.Event.CONFIGURATION_CHANGE && currentDailyStats.activeConfiguration != null) {
    event.mConfiguration=Configuration.generateDelta(currentDailyStats.activeConfiguration,newFullConfig);
  }
  if (currentDailyStats.events == null) {
    currentDailyStats.events=new TimeSparseArray<>();
  }
  if (event.mEventType != UsageEvents.Event.SYSTEM_INTERACTION) {
    currentDailyStats.events.put(event.mTimeStamp,event);
  }
  for (  IntervalStats stats : mCurrentStats) {
    if (event.mEventType == UsageEvents.Event.CONFIGURATION_CHANGE) {
      stats.updateConfigurationStats(newFullConfig,event.mTimeStamp);
    }
 else {
      stats.update(event.mPackage,event.mTimeStamp,event.mEventType);
      stats.updateBeginIdleTime(event.mPackage,deviceUsageTime);
    }
  }
  if (event.mEventType != Event.CONFIGURATION_CHANGE) {
    mAppIdleRollingWindow.update(event.mPackage,event.mTimeStamp,event.mEventType);
    mAppIdleRollingWindow.updateBeginIdleTime(event.mPackage,deviceUsageTime);
  }
  notifyStatsChanged();
}",0.9948320413436692
192975,"/** 
 * App idle operates on a rolling window of time. When we roll over time, we end up with a period of time where in-memory stats are empty and we don't hit the disk for older stats for performance reasons. Suddenly all apps will become idle. Instead, at times we do a deep query to find all the apps that have run in the past few days and keep the cached data up to date.
 * @param currentTimeMillis
 */
void refreshAppIdleRollingWindow(long currentTimeMillis){
  List<IntervalStats> stats=mDatabase.queryUsageStats(UsageStatsManager.INTERVAL_DAILY,currentTimeMillis - (1000 * 60 * 60* 24* 2),currentTimeMillis,sPackageStatsMerger);
  if (stats == null || stats.isEmpty()) {
    mAppIdleRollingWindow=new IntervalStats();
    mergePackageStats(mAppIdleRollingWindow,mCurrentStats[UsageStatsManager.INTERVAL_YEARLY]);
  }
 else {
    mAppIdleRollingWindow=stats.get(0);
  }
}","/** 
 * App idle operates on a rolling window of time. When we roll over time, we end up with a period of time where in-memory stats are empty and we don't hit the disk for older stats for performance reasons. Suddenly all apps will become idle. Instead, at times we do a deep query to find all the apps that have run in the past few days and keep the cached data up to date.
 * @param currentTimeMillis
 */
void refreshAppIdleRollingWindow(final long currentTimeMillis,final long deviceUsageTime){
  List<IntervalStats> stats=mDatabase.queryUsageStats(UsageStatsManager.INTERVAL_DAILY,currentTimeMillis - (1000 * 60 * 60* 24* 2),currentTimeMillis,new StatCombiner<IntervalStats>(){
    @Override public void combine(    IntervalStats stats,    boolean mutable,    List<IntervalStats> accumulatedResult){
      IntervalStats accum;
      if (accumulatedResult.isEmpty()) {
        accum=new IntervalStats();
        accum.beginTime=stats.beginTime;
        accumulatedResult.add(accum);
      }
 else {
        accum=accumulatedResult.get(0);
      }
      mergePackageStats(accum,stats,deviceUsageTime);
    }
  }
);
  if (stats == null || stats.isEmpty()) {
    mAppIdleRollingWindow=new IntervalStats();
    mergePackageStats(mAppIdleRollingWindow,mCurrentStats[UsageStatsManager.INTERVAL_YEARLY],deviceUsageTime);
  }
 else {
    mAppIdleRollingWindow=stats.get(0);
  }
}",0.7731913004882379
192976,"private void rolloverStats(final long currentTimeMillis){
  final long startTime=SystemClock.elapsedRealtime();
  Slog.i(TAG,mLogPrefix + ""String_Node_Str"");
  final Configuration previousConfig=mCurrentStats[UsageStatsManager.INTERVAL_DAILY].activeConfiguration;
  ArraySet<String> continuePreviousDay=new ArraySet<>();
  for (  IntervalStats stat : mCurrentStats) {
    final int pkgCount=stat.packageStats.size();
    for (int i=0; i < pkgCount; i++) {
      UsageStats pkgStats=stat.packageStats.valueAt(i);
      if (pkgStats.mLastEvent == UsageEvents.Event.MOVE_TO_FOREGROUND || pkgStats.mLastEvent == UsageEvents.Event.CONTINUE_PREVIOUS_DAY) {
        continuePreviousDay.add(pkgStats.mPackageName);
        stat.update(pkgStats.mPackageName,mDailyExpiryDate.getTimeInMillis() - 1,UsageEvents.Event.END_OF_DAY);
        notifyStatsChanged();
      }
    }
    stat.updateConfigurationStats(null,mDailyExpiryDate.getTimeInMillis() - 1);
  }
  persistActiveStats();
  mDatabase.prune(currentTimeMillis);
  loadActiveStats(currentTimeMillis,false);
  final int continueCount=continuePreviousDay.size();
  for (int i=0; i < continueCount; i++) {
    String name=continuePreviousDay.valueAt(i);
    final long beginTime=mCurrentStats[UsageStatsManager.INTERVAL_DAILY].beginTime;
    for (    IntervalStats stat : mCurrentStats) {
      stat.update(name,beginTime,UsageEvents.Event.CONTINUE_PREVIOUS_DAY);
      stat.updateConfigurationStats(previousConfig,beginTime);
      notifyStatsChanged();
    }
  }
  persistActiveStats();
  refreshAppIdleRollingWindow(currentTimeMillis);
  final long totalTime=SystemClock.elapsedRealtime() - startTime;
  Slog.i(TAG,mLogPrefix + ""String_Node_Str"" + totalTime+ ""String_Node_Str"");
}","private void rolloverStats(final long currentTimeMillis,final long deviceUsageTime){
  final long startTime=SystemClock.elapsedRealtime();
  Slog.i(TAG,mLogPrefix + ""String_Node_Str"");
  final Configuration previousConfig=mCurrentStats[UsageStatsManager.INTERVAL_DAILY].activeConfiguration;
  ArraySet<String> continuePreviousDay=new ArraySet<>();
  for (  IntervalStats stat : mCurrentStats) {
    final int pkgCount=stat.packageStats.size();
    for (int i=0; i < pkgCount; i++) {
      UsageStats pkgStats=stat.packageStats.valueAt(i);
      if (pkgStats.mLastEvent == UsageEvents.Event.MOVE_TO_FOREGROUND || pkgStats.mLastEvent == UsageEvents.Event.CONTINUE_PREVIOUS_DAY) {
        continuePreviousDay.add(pkgStats.mPackageName);
        stat.update(pkgStats.mPackageName,mDailyExpiryDate.getTimeInMillis() - 1,UsageEvents.Event.END_OF_DAY);
        notifyStatsChanged();
      }
    }
    stat.updateConfigurationStats(null,mDailyExpiryDate.getTimeInMillis() - 1);
  }
  persistActiveStats();
  mDatabase.prune(currentTimeMillis);
  loadActiveStats(currentTimeMillis,false);
  final int continueCount=continuePreviousDay.size();
  for (int i=0; i < continueCount; i++) {
    String name=continuePreviousDay.valueAt(i);
    final long beginTime=mCurrentStats[UsageStatsManager.INTERVAL_DAILY].beginTime;
    for (    IntervalStats stat : mCurrentStats) {
      stat.update(name,beginTime,UsageEvents.Event.CONTINUE_PREVIOUS_DAY);
      stat.updateConfigurationStats(previousConfig,beginTime);
      notifyStatsChanged();
    }
  }
  persistActiveStats();
  refreshAppIdleRollingWindow(currentTimeMillis,deviceUsageTime);
  final long totalTime=SystemClock.elapsedRealtime() - startTime;
  Slog.i(TAG,mLogPrefix + ""String_Node_Str"" + totalTime+ ""String_Node_Str"");
}",0.9876967095851216
192977,"ActivityRecord(ActivityManagerService _service,ProcessRecord _caller,int _launchedFromUid,String _launchedFromPackage,Intent _intent,String _resolvedType,ActivityInfo aInfo,Configuration _configuration,ActivityRecord _resultTo,String _resultWho,int _reqCode,boolean _componentSpecified,boolean _rootVoiceInteraction,ActivityStackSupervisor supervisor,ActivityContainer container,ActivityOptions options){
  service=_service;
  appToken=new Token(this,service);
  info=aInfo;
  launchedFromUid=_launchedFromUid;
  launchedFromPackage=_launchedFromPackage;
  userId=UserHandle.getUserId(aInfo.applicationInfo.uid);
  intent=_intent;
  shortComponentName=_intent.getComponent().flattenToShortString();
  resolvedType=_resolvedType;
  componentSpecified=_componentSpecified;
  rootVoiceInteraction=_rootVoiceInteraction;
  configuration=_configuration;
  taskConfigOverride=Configuration.EMPTY;
  resultTo=_resultTo;
  resultWho=_resultWho;
  requestCode=_reqCode;
  state=ActivityState.INITIALIZING;
  frontOfTask=false;
  launchFailed=false;
  stopped=false;
  delayedResume=false;
  finishing=false;
  configDestroy=false;
  keysPaused=false;
  inHistory=false;
  visible=false;
  nowVisible=false;
  idle=false;
  hasBeenLaunched=false;
  mStackSupervisor=supervisor;
  mInitialActivityContainer=container;
  if (options != null) {
    pendingOptions=options;
    mLaunchTaskBehind=pendingOptions.getLaunchTaskBehind();
    PendingIntent usageReport=pendingOptions.getUsageTimeReport();
    if (usageReport != null) {
      appTimeTracker=new AppTimeTracker(usageReport);
    }
  }
  haveState=true;
  if (aInfo != null) {
    if (aInfo.targetActivity == null || aInfo.launchMode == ActivityInfo.LAUNCH_MULTIPLE || aInfo.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP) {
      realActivity=_intent.getComponent();
    }
 else {
      realActivity=new ComponentName(aInfo.packageName,aInfo.targetActivity);
    }
    taskAffinity=aInfo.taskAffinity;
    stateNotNeeded=(aInfo.flags & ActivityInfo.FLAG_STATE_NOT_NEEDED) != 0;
    appInfo=aInfo.applicationInfo;
    nonLocalizedLabel=aInfo.nonLocalizedLabel;
    labelRes=aInfo.labelRes;
    if (nonLocalizedLabel == null && labelRes == 0) {
      ApplicationInfo app=aInfo.applicationInfo;
      nonLocalizedLabel=app.nonLocalizedLabel;
      labelRes=app.labelRes;
    }
    icon=aInfo.getIconResource();
    logo=aInfo.getLogoResource();
    theme=aInfo.getThemeResource();
    realTheme=theme;
    if (realTheme == 0) {
      realTheme=aInfo.applicationInfo.targetSdkVersion < Build.VERSION_CODES.HONEYCOMB ? android.R.style.Theme : android.R.style.Theme_Holo;
    }
    if ((aInfo.flags & ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0) {
      windowFlags|=WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
    }
    if ((aInfo.flags & ActivityInfo.FLAG_MULTIPROCESS) != 0 && _caller != null && (aInfo.applicationInfo.uid == Process.SYSTEM_UID || aInfo.applicationInfo.uid == _caller.info.uid)) {
      processName=_caller.processName;
    }
 else {
      processName=aInfo.processName;
    }
    if (intent != null && (aInfo.flags & ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS) != 0) {
      intent.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
    }
    packageName=aInfo.applicationInfo.packageName;
    launchMode=aInfo.launchMode;
    AttributeCache.Entry ent=AttributeCache.instance().get(packageName,realTheme,com.android.internal.R.styleable.Window,userId);
    final boolean translucent=ent != null && (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent,false) || (!ent.array.hasValue(com.android.internal.R.styleable.Window_windowIsTranslucent) && ent.array.getBoolean(com.android.internal.R.styleable.Window_windowSwipeToDismiss,false)));
    fullscreen=ent != null && !ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating,false) && !translucent;
    noDisplay=ent != null && ent.array.getBoolean(com.android.internal.R.styleable.Window_windowNoDisplay,false);
    if ((!_componentSpecified || _launchedFromUid == Process.myUid() || _launchedFromUid == 0) && Intent.ACTION_MAIN.equals(_intent.getAction()) && _intent.hasCategory(Intent.CATEGORY_HOME)&& _intent.getCategories().size() == 1 && _intent.getData() == null && _intent.getType() == null && (intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK) != 0 && !isResolverActivity()) {
      mActivityType=HOME_ACTIVITY_TYPE;
    }
 else     if (realActivity.getClassName().contains(RECENTS_PACKAGE_NAME)) {
      mActivityType=RECENTS_ACTIVITY_TYPE;
    }
 else {
      mActivityType=APPLICATION_ACTIVITY_TYPE;
    }
    immersive=(aInfo.flags & ActivityInfo.FLAG_IMMERSIVE) != 0;
    isVrActivity=(aInfo.flags & ActivityInfo.FLAG_ENABLE_VR_MODE) != 0;
  }
 else {
    realActivity=null;
    taskAffinity=null;
    stateNotNeeded=false;
    appInfo=null;
    processName=null;
    packageName=null;
    fullscreen=true;
    noDisplay=false;
    mActivityType=APPLICATION_ACTIVITY_TYPE;
    immersive=false;
    isVrActivity=false;
  }
}","ActivityRecord(ActivityManagerService _service,ProcessRecord _caller,int _launchedFromUid,String _launchedFromPackage,Intent _intent,String _resolvedType,ActivityInfo aInfo,Configuration _configuration,ActivityRecord _resultTo,String _resultWho,int _reqCode,boolean _componentSpecified,boolean _rootVoiceInteraction,ActivityStackSupervisor supervisor,ActivityContainer container,ActivityOptions options){
  service=_service;
  appToken=new Token(this,service);
  info=aInfo;
  launchedFromUid=_launchedFromUid;
  launchedFromPackage=_launchedFromPackage;
  userId=UserHandle.getUserId(aInfo.applicationInfo.uid);
  intent=_intent;
  shortComponentName=_intent.getComponent().flattenToShortString();
  resolvedType=_resolvedType;
  componentSpecified=_componentSpecified;
  rootVoiceInteraction=_rootVoiceInteraction;
  configuration=_configuration;
  taskConfigOverride=Configuration.EMPTY;
  resultTo=_resultTo;
  resultWho=_resultWho;
  requestCode=_reqCode;
  state=ActivityState.INITIALIZING;
  frontOfTask=false;
  launchFailed=false;
  stopped=false;
  delayedResume=false;
  finishing=false;
  deferRelaunchUntilPaused=false;
  keysPaused=false;
  inHistory=false;
  visible=false;
  nowVisible=false;
  idle=false;
  hasBeenLaunched=false;
  mStackSupervisor=supervisor;
  mInitialActivityContainer=container;
  if (options != null) {
    pendingOptions=options;
    mLaunchTaskBehind=pendingOptions.getLaunchTaskBehind();
    PendingIntent usageReport=pendingOptions.getUsageTimeReport();
    if (usageReport != null) {
      appTimeTracker=new AppTimeTracker(usageReport);
    }
  }
  haveState=true;
  if (aInfo != null) {
    if (aInfo.targetActivity == null || aInfo.launchMode == ActivityInfo.LAUNCH_MULTIPLE || aInfo.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP) {
      realActivity=_intent.getComponent();
    }
 else {
      realActivity=new ComponentName(aInfo.packageName,aInfo.targetActivity);
    }
    taskAffinity=aInfo.taskAffinity;
    stateNotNeeded=(aInfo.flags & ActivityInfo.FLAG_STATE_NOT_NEEDED) != 0;
    appInfo=aInfo.applicationInfo;
    nonLocalizedLabel=aInfo.nonLocalizedLabel;
    labelRes=aInfo.labelRes;
    if (nonLocalizedLabel == null && labelRes == 0) {
      ApplicationInfo app=aInfo.applicationInfo;
      nonLocalizedLabel=app.nonLocalizedLabel;
      labelRes=app.labelRes;
    }
    icon=aInfo.getIconResource();
    logo=aInfo.getLogoResource();
    theme=aInfo.getThemeResource();
    realTheme=theme;
    if (realTheme == 0) {
      realTheme=aInfo.applicationInfo.targetSdkVersion < Build.VERSION_CODES.HONEYCOMB ? android.R.style.Theme : android.R.style.Theme_Holo;
    }
    if ((aInfo.flags & ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0) {
      windowFlags|=WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
    }
    if ((aInfo.flags & ActivityInfo.FLAG_MULTIPROCESS) != 0 && _caller != null && (aInfo.applicationInfo.uid == Process.SYSTEM_UID || aInfo.applicationInfo.uid == _caller.info.uid)) {
      processName=_caller.processName;
    }
 else {
      processName=aInfo.processName;
    }
    if (intent != null && (aInfo.flags & ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS) != 0) {
      intent.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
    }
    packageName=aInfo.applicationInfo.packageName;
    launchMode=aInfo.launchMode;
    AttributeCache.Entry ent=AttributeCache.instance().get(packageName,realTheme,com.android.internal.R.styleable.Window,userId);
    final boolean translucent=ent != null && (ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent,false) || (!ent.array.hasValue(com.android.internal.R.styleable.Window_windowIsTranslucent) && ent.array.getBoolean(com.android.internal.R.styleable.Window_windowSwipeToDismiss,false)));
    fullscreen=ent != null && !ent.array.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating,false) && !translucent;
    noDisplay=ent != null && ent.array.getBoolean(com.android.internal.R.styleable.Window_windowNoDisplay,false);
    if ((!_componentSpecified || _launchedFromUid == Process.myUid() || _launchedFromUid == 0) && Intent.ACTION_MAIN.equals(_intent.getAction()) && _intent.hasCategory(Intent.CATEGORY_HOME)&& _intent.getCategories().size() == 1 && _intent.getData() == null && _intent.getType() == null && (intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK) != 0 && !isResolverActivity()) {
      mActivityType=HOME_ACTIVITY_TYPE;
    }
 else     if (realActivity.getClassName().contains(RECENTS_PACKAGE_NAME)) {
      mActivityType=RECENTS_ACTIVITY_TYPE;
    }
 else {
      mActivityType=APPLICATION_ACTIVITY_TYPE;
    }
    immersive=(aInfo.flags & ActivityInfo.FLAG_IMMERSIVE) != 0;
    isVrActivity=(aInfo.flags & ActivityInfo.FLAG_ENABLE_VR_MODE) != 0;
  }
 else {
    realActivity=null;
    taskAffinity=null;
    stateNotNeeded=false;
    appInfo=null;
    processName=null;
    packageName=null;
    fullscreen=true;
    noDisplay=false;
    mActivityType=APPLICATION_ACTIVITY_TYPE;
    immersive=false;
    isVrActivity=false;
  }
}",0.996309963099631
192978,"void dump(PrintWriter pw,String prefix){
  final long now=SystemClock.uptimeMillis();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(packageName);
  pw.print(""String_Node_Str"");
  pw.println(processName);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(launchedFromUid);
  pw.print(""String_Node_Str"");
  pw.print(launchedFromPackage);
  pw.print(""String_Node_Str"");
  pw.println(userId);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(app);
  pw.print(prefix);
  pw.println(intent.toInsecureStringWithClip());
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(frontOfTask);
  pw.print(""String_Node_Str"");
  pw.println(task);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(taskAffinity);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(realActivity.flattenToShortString());
  if (appInfo != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(appInfo.sourceDir);
    if (!Objects.equals(appInfo.sourceDir,appInfo.publicSourceDir)) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(appInfo.publicSourceDir);
    }
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(appInfo.dataDir);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(stateNotNeeded);
  pw.print(""String_Node_Str"");
  pw.print(componentSpecified);
  pw.print(""String_Node_Str"");
  pw.println(mActivityType);
  if (rootVoiceInteraction) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(rootVoiceInteraction);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(compat);
  pw.print(""String_Node_Str"");
  pw.print(Integer.toHexString(labelRes));
  pw.print(""String_Node_Str"");
  pw.print(Integer.toHexString(icon));
  pw.print(""String_Node_Str"");
  pw.println(Integer.toHexString(theme));
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(configuration);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(taskConfigOverride);
  if (resultTo != null || resultWho != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(resultTo);
    pw.print(""String_Node_Str"");
    pw.print(resultWho);
    pw.print(""String_Node_Str"");
    pw.println(requestCode);
  }
  if (taskDescription != null) {
    final String iconFilename=taskDescription.getIconFilename();
    if (iconFilename != null || taskDescription.getLabel() != null || taskDescription.getPrimaryColor() != 0) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.print(""String_Node_Str"");
      pw.print(taskDescription.getIconFilename());
      pw.print(""String_Node_Str"");
      pw.print(taskDescription.getLabel());
      pw.print(""String_Node_Str"");
      pw.print(""String_Node_Str"");
      pw.println(Integer.toHexString(taskDescription.getPrimaryColor()));
    }
    if (iconFilename == null && taskDescription.getIcon() != null) {
      pw.print(prefix);
      pw.println(""String_Node_Str"");
    }
  }
  if (results != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(results);
  }
  if (pendingResults != null && pendingResults.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (    WeakReference<PendingIntentRecord> wpir : pendingResults) {
      PendingIntentRecord pir=wpir != null ? wpir.get() : null;
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      if (pir == null) {
        pw.println(""String_Node_Str"");
      }
 else {
        pw.println(pir);
        pir.dump(pw,prefix + ""String_Node_Str"");
      }
    }
  }
  if (newIntents != null && newIntents.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < newIntents.size(); i++) {
      Intent intent=newIntents.get(i);
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      if (intent == null) {
        pw.println(""String_Node_Str"");
      }
 else {
        pw.println(intent.toShortString(false,true,false,true));
      }
    }
  }
  if (pendingOptions != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(pendingOptions);
  }
  if (appTimeTracker != null) {
    appTimeTracker.dumpWithHeader(pw,prefix,false);
  }
  if (uriPermissions != null) {
    uriPermissions.dump(pw,prefix);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(launchFailed);
  pw.print(""String_Node_Str"");
  pw.print(launchCount);
  pw.print(""String_Node_Str"");
  if (lastLaunchTime == 0)   pw.print(""String_Node_Str"");
 else   TimeUtils.formatDuration(lastLaunchTime,now,pw);
  pw.println();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(haveState);
  pw.print(""String_Node_Str"");
  pw.println(icicle);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(state);
  pw.print(""String_Node_Str"");
  pw.print(stopped);
  pw.print(""String_Node_Str"");
  pw.print(delayedResume);
  pw.print(""String_Node_Str"");
  pw.println(finishing);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(keysPaused);
  pw.print(""String_Node_Str"");
  pw.print(inHistory);
  pw.print(""String_Node_Str"");
  pw.print(visible);
  pw.print(""String_Node_Str"");
  pw.print(sleeping);
  pw.print(""String_Node_Str"");
  pw.println(idle);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(fullscreen);
  pw.print(""String_Node_Str"");
  pw.print(noDisplay);
  pw.print(""String_Node_Str"");
  pw.print(immersive);
  pw.print(""String_Node_Str"");
  pw.println(launchMode);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(frozenBeforeDestroy);
  pw.print(""String_Node_Str"");
  pw.println(forceNewConfig);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(activityTypeToString(mActivityType));
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(isVrActivity);
  if (displayStartTime != 0 || startTime != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    if (displayStartTime == 0)     pw.print(""String_Node_Str"");
 else     TimeUtils.formatDuration(displayStartTime,now,pw);
    pw.print(""String_Node_Str"");
    if (startTime == 0)     pw.print(""String_Node_Str"");
 else     TimeUtils.formatDuration(startTime,now,pw);
    pw.println();
  }
  final boolean waitingVisible=mStackSupervisor.mWaitingVisibleActivities.contains(this);
  if (lastVisibleTime != 0 || waitingVisible || nowVisible) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(waitingVisible);
    pw.print(""String_Node_Str"");
    pw.print(nowVisible);
    pw.print(""String_Node_Str"");
    if (lastVisibleTime == 0)     pw.print(""String_Node_Str"");
 else     TimeUtils.formatDuration(lastVisibleTime,now,pw);
    pw.println();
  }
  if (configDestroy || configChangeFlags != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(configDestroy);
    pw.print(""String_Node_Str"");
    pw.println(Integer.toHexString(configChangeFlags));
  }
  if (connections != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(connections);
  }
}","void dump(PrintWriter pw,String prefix){
  final long now=SystemClock.uptimeMillis();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(packageName);
  pw.print(""String_Node_Str"");
  pw.println(processName);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(launchedFromUid);
  pw.print(""String_Node_Str"");
  pw.print(launchedFromPackage);
  pw.print(""String_Node_Str"");
  pw.println(userId);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(app);
  pw.print(prefix);
  pw.println(intent.toInsecureStringWithClip());
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(frontOfTask);
  pw.print(""String_Node_Str"");
  pw.println(task);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(taskAffinity);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(realActivity.flattenToShortString());
  if (appInfo != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(appInfo.sourceDir);
    if (!Objects.equals(appInfo.sourceDir,appInfo.publicSourceDir)) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.println(appInfo.publicSourceDir);
    }
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(appInfo.dataDir);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(stateNotNeeded);
  pw.print(""String_Node_Str"");
  pw.print(componentSpecified);
  pw.print(""String_Node_Str"");
  pw.println(mActivityType);
  if (rootVoiceInteraction) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(rootVoiceInteraction);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(compat);
  pw.print(""String_Node_Str"");
  pw.print(Integer.toHexString(labelRes));
  pw.print(""String_Node_Str"");
  pw.print(Integer.toHexString(icon));
  pw.print(""String_Node_Str"");
  pw.println(Integer.toHexString(theme));
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(configuration);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(taskConfigOverride);
  if (resultTo != null || resultWho != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(resultTo);
    pw.print(""String_Node_Str"");
    pw.print(resultWho);
    pw.print(""String_Node_Str"");
    pw.println(requestCode);
  }
  if (taskDescription != null) {
    final String iconFilename=taskDescription.getIconFilename();
    if (iconFilename != null || taskDescription.getLabel() != null || taskDescription.getPrimaryColor() != 0) {
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      pw.print(""String_Node_Str"");
      pw.print(taskDescription.getIconFilename());
      pw.print(""String_Node_Str"");
      pw.print(taskDescription.getLabel());
      pw.print(""String_Node_Str"");
      pw.print(""String_Node_Str"");
      pw.println(Integer.toHexString(taskDescription.getPrimaryColor()));
    }
    if (iconFilename == null && taskDescription.getIcon() != null) {
      pw.print(prefix);
      pw.println(""String_Node_Str"");
    }
  }
  if (results != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(results);
  }
  if (pendingResults != null && pendingResults.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (    WeakReference<PendingIntentRecord> wpir : pendingResults) {
      PendingIntentRecord pir=wpir != null ? wpir.get() : null;
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      if (pir == null) {
        pw.println(""String_Node_Str"");
      }
 else {
        pw.println(pir);
        pir.dump(pw,prefix + ""String_Node_Str"");
      }
    }
  }
  if (newIntents != null && newIntents.size() > 0) {
    pw.print(prefix);
    pw.println(""String_Node_Str"");
    for (int i=0; i < newIntents.size(); i++) {
      Intent intent=newIntents.get(i);
      pw.print(prefix);
      pw.print(""String_Node_Str"");
      if (intent == null) {
        pw.println(""String_Node_Str"");
      }
 else {
        pw.println(intent.toShortString(false,true,false,true));
      }
    }
  }
  if (pendingOptions != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(pendingOptions);
  }
  if (appTimeTracker != null) {
    appTimeTracker.dumpWithHeader(pw,prefix,false);
  }
  if (uriPermissions != null) {
    uriPermissions.dump(pw,prefix);
  }
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(launchFailed);
  pw.print(""String_Node_Str"");
  pw.print(launchCount);
  pw.print(""String_Node_Str"");
  if (lastLaunchTime == 0)   pw.print(""String_Node_Str"");
 else   TimeUtils.formatDuration(lastLaunchTime,now,pw);
  pw.println();
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(haveState);
  pw.print(""String_Node_Str"");
  pw.println(icicle);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(state);
  pw.print(""String_Node_Str"");
  pw.print(stopped);
  pw.print(""String_Node_Str"");
  pw.print(delayedResume);
  pw.print(""String_Node_Str"");
  pw.println(finishing);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(keysPaused);
  pw.print(""String_Node_Str"");
  pw.print(inHistory);
  pw.print(""String_Node_Str"");
  pw.print(visible);
  pw.print(""String_Node_Str"");
  pw.print(sleeping);
  pw.print(""String_Node_Str"");
  pw.println(idle);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(fullscreen);
  pw.print(""String_Node_Str"");
  pw.print(noDisplay);
  pw.print(""String_Node_Str"");
  pw.print(immersive);
  pw.print(""String_Node_Str"");
  pw.println(launchMode);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.print(frozenBeforeDestroy);
  pw.print(""String_Node_Str"");
  pw.println(forceNewConfig);
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(activityTypeToString(mActivityType));
  pw.print(prefix);
  pw.print(""String_Node_Str"");
  pw.println(isVrActivity);
  if (displayStartTime != 0 || startTime != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    if (displayStartTime == 0)     pw.print(""String_Node_Str"");
 else     TimeUtils.formatDuration(displayStartTime,now,pw);
    pw.print(""String_Node_Str"");
    if (startTime == 0)     pw.print(""String_Node_Str"");
 else     TimeUtils.formatDuration(startTime,now,pw);
    pw.println();
  }
  final boolean waitingVisible=mStackSupervisor.mWaitingVisibleActivities.contains(this);
  if (lastVisibleTime != 0 || waitingVisible || nowVisible) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(waitingVisible);
    pw.print(""String_Node_Str"");
    pw.print(nowVisible);
    pw.print(""String_Node_Str"");
    if (lastVisibleTime == 0)     pw.print(""String_Node_Str"");
 else     TimeUtils.formatDuration(lastVisibleTime,now,pw);
    pw.println();
  }
  if (deferRelaunchUntilPaused || configChangeFlags != 0) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.print(deferRelaunchUntilPaused);
    pw.print(""String_Node_Str"");
    pw.println(Integer.toHexString(configChangeFlags));
  }
  if (connections != null) {
    pw.print(prefix);
    pw.print(""String_Node_Str"");
    pw.println(connections);
  }
}",0.9950269963057686
192979,"private void insertTaskAtTop(TaskRecord task,ActivityRecord newActivity){
  if (task.isOverHomeStack()) {
    final TaskRecord nextTask=getNextTask(task);
    if (nextTask != null) {
      nextTask.setTaskToReturnTo(task.getTaskToReturnTo());
    }
  }
  if (isOnHomeDisplay()) {
    ActivityStack lastStack=mStackSupervisor.getLastStack();
    final boolean fromHome=lastStack.isHomeStack();
    if (!isHomeStack() && (fromHome || topTask() != task)) {
      task.setTaskToReturnTo(fromHome ? lastStack.topTask() == null ? HOME_ACTIVITY_TYPE : lastStack.topTask().taskType : APPLICATION_ACTIVITY_TYPE);
    }
  }
 else {
    task.setTaskToReturnTo(APPLICATION_ACTIVITY_TYPE);
  }
  mTaskHistory.remove(task);
  int taskNdx=mTaskHistory.size();
  final boolean notShownWhenLocked=(newActivity != null && (newActivity.info.flags & FLAG_SHOW_FOR_ALL_USERS) == 0) || (newActivity == null && task.topRunningActivityLocked() == null);
  if (!mStackSupervisor.isCurrentProfileLocked(task.userId) && notShownWhenLocked) {
    while (--taskNdx >= 0) {
      final TaskRecord tmpTask=mTaskHistory.get(taskNdx);
      if (!mStackSupervisor.isCurrentProfileLocked(tmpTask.userId) || tmpTask.topRunningActivityLocked() == null) {
        break;
      }
    }
    ++taskNdx;
  }
  mTaskHistory.add(taskNdx,task);
  updateTaskMovement(task,true);
}","private void insertTaskAtTop(TaskRecord task,ActivityRecord newActivity){
  if (task.isOverHomeStack()) {
    final TaskRecord nextTask=getNextTask(task);
    if (nextTask != null) {
      nextTask.setTaskToReturnTo(task.getTaskToReturnTo());
    }
  }
  if (isOnHomeDisplay()) {
    ActivityStack lastStack=mStackSupervisor.getLastStack();
    final boolean fromHome=lastStack.isHomeStack();
    if (!isHomeStack() && (fromHome || topTask() != task)) {
      int returnToType=APPLICATION_ACTIVITY_TYPE;
      if (fromHome && StackId.allowTopTaskToReturnHome(mStackId)) {
        returnToType=lastStack.topTask() == null ? HOME_ACTIVITY_TYPE : lastStack.topTask().taskType;
      }
      task.setTaskToReturnTo(returnToType);
    }
  }
 else {
    task.setTaskToReturnTo(APPLICATION_ACTIVITY_TYPE);
  }
  mTaskHistory.remove(task);
  int taskNdx=mTaskHistory.size();
  final boolean notShownWhenLocked=(newActivity != null && (newActivity.info.flags & FLAG_SHOW_FOR_ALL_USERS) == 0) || (newActivity == null && task.topRunningActivityLocked() == null);
  if (!mStackSupervisor.isCurrentProfileLocked(task.userId) && notShownWhenLocked) {
    while (--taskNdx >= 0) {
      final TaskRecord tmpTask=mTaskHistory.get(taskNdx);
      if (!mStackSupervisor.isCurrentProfileLocked(tmpTask.userId) || tmpTask.topRunningActivityLocked() == null) {
        break;
      }
    }
    ++taskNdx;
  }
  mTaskHistory.add(taskNdx,task);
  updateTaskMovement(task,true);
}",0.9232974910394264
192980,"/** 
 * Make sure the given activity matches the current configuration.  Returns false if the activity had to be destroyed.  Returns true if the configuration is the same, or the activity will remain running as-is for whatever reason.  Ensures the HistoryRecord is updated with the correct configuration and all other bookkeeping is handled.
 */
final boolean ensureActivityConfigurationLocked(ActivityRecord r,int globalChanges,boolean preserveWindow){
  if (mConfigWillChange) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG_CONFIGURATION,""String_Node_Str"" + r);
    return true;
  }
  if (DEBUG_SWITCH || DEBUG_CONFIGURATION)   Slog.v(TAG_CONFIGURATION,""String_Node_Str"" + r);
  final Configuration newConfig=mService.mConfiguration;
  final Configuration taskConfig=r.task.mOverrideConfig;
  if (r.configuration == newConfig && r.taskConfigOverride == taskConfig && !r.forceNewConfig) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG_CONFIGURATION,""String_Node_Str"" + r);
    return true;
  }
  if (r.finishing) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG_CONFIGURATION,""String_Node_Str"" + r);
    r.stopFreezingScreenLocked(false);
    return true;
  }
  final Configuration oldConfig=r.configuration;
  final Configuration oldTaskOverride=r.taskConfigOverride;
  r.configuration=newConfig;
  r.taskConfigOverride=taskConfig;
  int taskChanges=getTaskConfigurationChanges(r,taskConfig,oldTaskOverride);
  final int changes=oldConfig.diff(newConfig) | taskChanges;
  if (changes == 0 && !r.forceNewConfig) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG_CONFIGURATION,""String_Node_Str"" + r);
    r.scheduleConfigurationChanged(taskConfig,false);
    return true;
  }
  if (DEBUG_SWITCH || DEBUG_CONFIGURATION)   Slog.v(TAG_CONFIGURATION,""String_Node_Str"" + r + ""String_Node_Str""+ Configuration.configurationDiffToString(taskChanges)+ ""String_Node_Str""+ Configuration.configurationDiffToString(changes));
  if (r.app == null || r.app.thread == null) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG_CONFIGURATION,""String_Node_Str"" + r);
    r.stopFreezingScreenLocked(false);
    r.forceNewConfig=false;
    return true;
  }
  if (DEBUG_SWITCH || DEBUG_CONFIGURATION)   Slog.v(TAG_CONFIGURATION,""String_Node_Str"" + r.info.name + ""String_Node_Str""+ Integer.toHexString(changes)+ ""String_Node_Str""+ Integer.toHexString(r.info.getRealConfigChanged())+ ""String_Node_Str""+ newConfig+ ""String_Node_Str""+ taskConfig);
  if ((changes & (~r.info.getRealConfigChanged())) != 0 || r.forceNewConfig) {
    r.configChangeFlags|=changes;
    r.startFreezingScreenLocked(r.app,globalChanges);
    r.forceNewConfig=false;
    if (r.app == null || r.app.thread == null) {
      if (DEBUG_SWITCH || DEBUG_CONFIGURATION)       Slog.v(TAG_CONFIGURATION,""String_Node_Str"" + r);
      destroyActivityLocked(r,true,""String_Node_Str"");
    }
 else     if (r.state == ActivityState.PAUSING) {
      if (DEBUG_SWITCH || DEBUG_CONFIGURATION)       Slog.v(TAG_CONFIGURATION,""String_Node_Str"" + r);
      r.configDestroy=true;
      return true;
    }
 else     if (r.state == ActivityState.RESUMED) {
      if (DEBUG_SWITCH || DEBUG_CONFIGURATION)       Slog.v(TAG_CONFIGURATION,""String_Node_Str"" + r);
      relaunchActivityLocked(r,r.configChangeFlags,true,preserveWindow && isResizeOnlyChange(changes));
      r.configChangeFlags=0;
    }
 else {
      if (DEBUG_SWITCH || DEBUG_CONFIGURATION)       Slog.v(TAG_CONFIGURATION,""String_Node_Str"" + r);
      relaunchActivityLocked(r,r.configChangeFlags,false,preserveWindow && isResizeOnlyChange(changes));
      r.configChangeFlags=0;
    }
    return false;
  }
  r.scheduleConfigurationChanged(taskConfig,true);
  r.stopFreezingScreenLocked(false);
  return true;
}","/** 
 * Make sure the given activity matches the current configuration.  Returns false if the activity had to be destroyed.  Returns true if the configuration is the same, or the activity will remain running as-is for whatever reason.  Ensures the HistoryRecord is updated with the correct configuration and all other bookkeeping is handled.
 */
final boolean ensureActivityConfigurationLocked(ActivityRecord r,int globalChanges,boolean preserveWindow){
  if (mConfigWillChange) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG_CONFIGURATION,""String_Node_Str"" + r);
    return true;
  }
  if (DEBUG_SWITCH || DEBUG_CONFIGURATION)   Slog.v(TAG_CONFIGURATION,""String_Node_Str"" + r);
  final Configuration newConfig=mService.mConfiguration;
  final Configuration taskConfig=r.task.mOverrideConfig;
  if (r.configuration == newConfig && r.taskConfigOverride == taskConfig && !r.forceNewConfig) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG_CONFIGURATION,""String_Node_Str"" + r);
    return true;
  }
  if (r.finishing) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG_CONFIGURATION,""String_Node_Str"" + r);
    r.stopFreezingScreenLocked(false);
    return true;
  }
  final Configuration oldConfig=r.configuration;
  final Configuration oldTaskOverride=r.taskConfigOverride;
  r.configuration=newConfig;
  r.taskConfigOverride=taskConfig;
  int taskChanges=getTaskConfigurationChanges(r,taskConfig,oldTaskOverride);
  final int changes=oldConfig.diff(newConfig) | taskChanges;
  if (changes == 0 && !r.forceNewConfig) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG_CONFIGURATION,""String_Node_Str"" + r);
    r.scheduleConfigurationChanged(taskConfig,false);
    return true;
  }
  if (DEBUG_SWITCH || DEBUG_CONFIGURATION)   Slog.v(TAG_CONFIGURATION,""String_Node_Str"" + r + ""String_Node_Str""+ Configuration.configurationDiffToString(taskChanges)+ ""String_Node_Str""+ Configuration.configurationDiffToString(changes));
  if (r.app == null || r.app.thread == null) {
    if (DEBUG_SWITCH || DEBUG_CONFIGURATION)     Slog.v(TAG_CONFIGURATION,""String_Node_Str"" + r);
    r.stopFreezingScreenLocked(false);
    r.forceNewConfig=false;
    return true;
  }
  if (DEBUG_SWITCH || DEBUG_CONFIGURATION)   Slog.v(TAG_CONFIGURATION,""String_Node_Str"" + r.info.name + ""String_Node_Str""+ Integer.toHexString(changes)+ ""String_Node_Str""+ Integer.toHexString(r.info.getRealConfigChanged())+ ""String_Node_Str""+ newConfig+ ""String_Node_Str""+ taskConfig);
  if ((changes & (~r.info.getRealConfigChanged())) != 0 || r.forceNewConfig) {
    r.configChangeFlags|=changes;
    r.startFreezingScreenLocked(r.app,globalChanges);
    r.forceNewConfig=false;
    preserveWindow&=isResizeOnlyChange(changes);
    if (r.app == null || r.app.thread == null) {
      if (DEBUG_SWITCH || DEBUG_CONFIGURATION)       Slog.v(TAG_CONFIGURATION,""String_Node_Str"" + r);
      destroyActivityLocked(r,true,""String_Node_Str"");
    }
 else     if (r.state == ActivityState.PAUSING) {
      if (DEBUG_SWITCH || DEBUG_CONFIGURATION)       Slog.v(TAG_CONFIGURATION,""String_Node_Str"" + r);
      r.deferRelaunchUntilPaused=true;
      r.preserveWindowOnDeferredRelaunch=preserveWindow;
      return true;
    }
 else     if (r.state == ActivityState.RESUMED) {
      if (DEBUG_SWITCH || DEBUG_CONFIGURATION)       Slog.v(TAG_CONFIGURATION,""String_Node_Str"" + r);
      relaunchActivityLocked(r,r.configChangeFlags,true,preserveWindow);
    }
 else {
      if (DEBUG_SWITCH || DEBUG_CONFIGURATION)       Slog.v(TAG_CONFIGURATION,""String_Node_Str"" + r);
      relaunchActivityLocked(r,r.configChangeFlags,false,preserveWindow);
    }
    return false;
  }
  r.scheduleConfigurationChanged(taskConfig,true);
  r.stopFreezingScreenLocked(false);
  return true;
}",0.9639962800584564
192981,"final void stopActivityLocked(ActivityRecord r){
  if (DEBUG_SWITCH)   Slog.d(TAG_SWITCH,""String_Node_Str"" + r);
  if ((r.intent.getFlags() & Intent.FLAG_ACTIVITY_NO_HISTORY) != 0 || (r.info.flags & ActivityInfo.FLAG_NO_HISTORY) != 0) {
    if (!r.finishing) {
      if (!mService.isSleeping()) {
        if (DEBUG_STATES)         Slog.d(TAG_STATES,""String_Node_Str"" + r);
        if (requestFinishActivityLocked(r.appToken,Activity.RESULT_CANCELED,null,""String_Node_Str"",false)) {
          adjustFocusedActivityLocked(r,""String_Node_Str"");
          r.resumeKeyDispatchingLocked();
          return;
        }
      }
 else {
        if (DEBUG_STATES)         Slog.d(TAG_STATES,""String_Node_Str"" + r + ""String_Node_Str"");
      }
    }
  }
  if (r.app != null && r.app.thread != null) {
    adjustFocusedActivityLocked(r,""String_Node_Str"");
    r.resumeKeyDispatchingLocked();
    try {
      r.stopped=false;
      if (DEBUG_STATES)       Slog.v(TAG_STATES,""String_Node_Str"" + r + ""String_Node_Str"");
      r.state=ActivityState.STOPPING;
      if (DEBUG_VISIBILITY)       Slog.v(TAG_VISIBILITY,""String_Node_Str"" + r.visible + ""String_Node_Str""+ r);
      if (!r.visible) {
        mWindowManager.setAppVisibility(r.appToken,false);
      }
      r.app.thread.scheduleStopActivity(r.appToken,r.visible,r.configChangeFlags);
      if (mService.isSleepingOrShuttingDown()) {
        r.setSleeping(true);
      }
      Message msg=mHandler.obtainMessage(STOP_TIMEOUT_MSG,r);
      mHandler.sendMessageDelayed(msg,STOP_TIMEOUT);
    }
 catch (    Exception e) {
      Slog.w(TAG,""String_Node_Str"",e);
      r.stopped=true;
      if (DEBUG_STATES)       Slog.v(TAG_STATES,""String_Node_Str"" + r);
      r.state=ActivityState.STOPPED;
      if (r.configDestroy) {
        destroyActivityLocked(r,true,""String_Node_Str"");
      }
    }
  }
}","final void stopActivityLocked(ActivityRecord r){
  if (DEBUG_SWITCH)   Slog.d(TAG_SWITCH,""String_Node_Str"" + r);
  if ((r.intent.getFlags() & Intent.FLAG_ACTIVITY_NO_HISTORY) != 0 || (r.info.flags & ActivityInfo.FLAG_NO_HISTORY) != 0) {
    if (!r.finishing) {
      if (!mService.isSleeping()) {
        if (DEBUG_STATES)         Slog.d(TAG_STATES,""String_Node_Str"" + r);
        if (requestFinishActivityLocked(r.appToken,Activity.RESULT_CANCELED,null,""String_Node_Str"",false)) {
          adjustFocusedActivityLocked(r,""String_Node_Str"");
          r.resumeKeyDispatchingLocked();
          return;
        }
      }
 else {
        if (DEBUG_STATES)         Slog.d(TAG_STATES,""String_Node_Str"" + r + ""String_Node_Str"");
      }
    }
  }
  if (r.app != null && r.app.thread != null) {
    adjustFocusedActivityLocked(r,""String_Node_Str"");
    r.resumeKeyDispatchingLocked();
    try {
      r.stopped=false;
      if (DEBUG_STATES)       Slog.v(TAG_STATES,""String_Node_Str"" + r + ""String_Node_Str"");
      r.state=ActivityState.STOPPING;
      if (DEBUG_VISIBILITY)       Slog.v(TAG_VISIBILITY,""String_Node_Str"" + r.visible + ""String_Node_Str""+ r);
      if (!r.visible) {
        mWindowManager.setAppVisibility(r.appToken,false);
      }
      r.app.thread.scheduleStopActivity(r.appToken,r.visible,r.configChangeFlags);
      if (mService.isSleepingOrShuttingDown()) {
        r.setSleeping(true);
      }
      Message msg=mHandler.obtainMessage(STOP_TIMEOUT_MSG,r);
      mHandler.sendMessageDelayed(msg,STOP_TIMEOUT);
    }
 catch (    Exception e) {
      Slog.w(TAG,""String_Node_Str"",e);
      r.stopped=true;
      if (DEBUG_STATES)       Slog.v(TAG_STATES,""String_Node_Str"" + r);
      r.state=ActivityState.STOPPED;
      if (r.deferRelaunchUntilPaused) {
        destroyActivityLocked(r,true,""String_Node_Str"");
      }
    }
  }
}",0.9899538419766496
192982,"final void activityStoppedLocked(ActivityRecord r,Bundle icicle,PersistableBundle persistentState,CharSequence description){
  if (r.state != ActivityState.STOPPING) {
    Slog.i(TAG,""String_Node_Str"" + r);
    mHandler.removeMessages(STOP_TIMEOUT_MSG,r);
    return;
  }
  if (persistentState != null) {
    r.persistentState=persistentState;
    mService.notifyTaskPersisterLocked(r.task,false);
  }
  if (DEBUG_SAVED_STATE)   Slog.i(TAG_SAVED_STATE,""String_Node_Str"" + r + ""String_Node_Str""+ icicle);
  if (icicle != null) {
    r.icicle=icicle;
    r.haveState=true;
    r.launchCount=0;
    r.updateThumbnailLocked(null,description);
  }
  if (!r.stopped) {
    if (DEBUG_STATES)     Slog.v(TAG_STATES,""String_Node_Str"" + r + ""String_Node_Str"");
    mHandler.removeMessages(STOP_TIMEOUT_MSG,r);
    r.stopped=true;
    r.state=ActivityState.STOPPED;
    if (getVisibleBehindActivity() == r) {
      mStackSupervisor.requestVisibleBehindLocked(r,false);
    }
    if (r.finishing) {
      r.clearOptionsLocked();
    }
 else {
      if (r.configDestroy) {
        destroyActivityLocked(r,true,""String_Node_Str"");
        mStackSupervisor.resumeFocusedStackTopActivityLocked();
      }
 else {
        mStackSupervisor.updatePreviousProcessLocked(r);
      }
    }
  }
}","final void activityStoppedLocked(ActivityRecord r,Bundle icicle,PersistableBundle persistentState,CharSequence description){
  if (r.state != ActivityState.STOPPING) {
    Slog.i(TAG,""String_Node_Str"" + r);
    mHandler.removeMessages(STOP_TIMEOUT_MSG,r);
    return;
  }
  if (persistentState != null) {
    r.persistentState=persistentState;
    mService.notifyTaskPersisterLocked(r.task,false);
  }
  if (DEBUG_SAVED_STATE)   Slog.i(TAG_SAVED_STATE,""String_Node_Str"" + r + ""String_Node_Str""+ icicle);
  if (icicle != null) {
    r.icicle=icicle;
    r.haveState=true;
    r.launchCount=0;
    r.updateThumbnailLocked(null,description);
  }
  if (!r.stopped) {
    if (DEBUG_STATES)     Slog.v(TAG_STATES,""String_Node_Str"" + r + ""String_Node_Str"");
    mHandler.removeMessages(STOP_TIMEOUT_MSG,r);
    r.stopped=true;
    r.state=ActivityState.STOPPED;
    if (getVisibleBehindActivity() == r) {
      mStackSupervisor.requestVisibleBehindLocked(r,false);
    }
    if (r.finishing) {
      r.clearOptionsLocked();
    }
 else {
      if (r.deferRelaunchUntilPaused) {
        destroyActivityLocked(r,true,""String_Node_Str"");
        mStackSupervisor.resumeFocusedStackTopActivityLocked();
      }
 else {
        mStackSupervisor.updatePreviousProcessLocked(r);
      }
    }
  }
}",0.9855299178725068
192983,"/** 
 * Perform the common clean-up of an activity record.  This is called both as part of destroyActivityLocked() (when destroying the client-side representation) and cleaning things up as a result of its hosting processing going away, in which case there is no remaining client-side state to destroy so only the cleanup here is needed. Note: Call before #removeActivityFromHistoryLocked.
 */
final void cleanUpActivityLocked(ActivityRecord r,boolean cleanServices,boolean setState){
  if (mResumedActivity == r) {
    mResumedActivity=null;
  }
  if (mPausingActivity == r) {
    mPausingActivity=null;
  }
  mService.resetFocusedActivityIfNeededLocked(r);
  r.configDestroy=false;
  r.frozenBeforeDestroy=false;
  if (setState) {
    if (DEBUG_STATES)     Slog.v(TAG_STATES,""String_Node_Str"" + r + ""String_Node_Str"");
    r.state=ActivityState.DESTROYED;
    if (DEBUG_APP)     Slog.v(TAG_APP,""String_Node_Str"" + r);
    r.app=null;
  }
  mStackSupervisor.mFinishingActivities.remove(r);
  mStackSupervisor.mWaitingVisibleActivities.remove(r);
  if (r.finishing && r.pendingResults != null) {
    for (    WeakReference<PendingIntentRecord> apr : r.pendingResults) {
      PendingIntentRecord rec=apr.get();
      if (rec != null) {
        mService.cancelIntentSenderLocked(rec,false);
      }
    }
    r.pendingResults=null;
  }
  if (cleanServices) {
    cleanUpActivityServicesLocked(r);
  }
  removeTimeoutsForActivityLocked(r);
  if (getVisibleBehindActivity() == r) {
    mStackSupervisor.requestVisibleBehindLocked(r,false);
  }
}","/** 
 * Perform the common clean-up of an activity record.  This is called both as part of destroyActivityLocked() (when destroying the client-side representation) and cleaning things up as a result of its hosting processing going away, in which case there is no remaining client-side state to destroy so only the cleanup here is needed. Note: Call before #removeActivityFromHistoryLocked.
 */
final void cleanUpActivityLocked(ActivityRecord r,boolean cleanServices,boolean setState){
  if (mResumedActivity == r) {
    mResumedActivity=null;
  }
  if (mPausingActivity == r) {
    mPausingActivity=null;
  }
  mService.resetFocusedActivityIfNeededLocked(r);
  r.deferRelaunchUntilPaused=false;
  r.frozenBeforeDestroy=false;
  if (setState) {
    if (DEBUG_STATES)     Slog.v(TAG_STATES,""String_Node_Str"" + r + ""String_Node_Str"");
    r.state=ActivityState.DESTROYED;
    if (DEBUG_APP)     Slog.v(TAG_APP,""String_Node_Str"" + r);
    r.app=null;
  }
  mStackSupervisor.mFinishingActivities.remove(r);
  mStackSupervisor.mWaitingVisibleActivities.remove(r);
  if (r.finishing && r.pendingResults != null) {
    for (    WeakReference<PendingIntentRecord> apr : r.pendingResults) {
      PendingIntentRecord rec=apr.get();
      if (rec != null) {
        mService.cancelIntentSenderLocked(rec,false);
      }
    }
    r.pendingResults=null;
  }
  if (cleanServices) {
    cleanUpActivityServicesLocked(r);
  }
  removeTimeoutsForActivityLocked(r);
  if (getVisibleBehindActivity() == r) {
    mStackSupervisor.requestVisibleBehindLocked(r,false);
  }
}",0.9880452342487884
192984,"private void relaunchActivityLocked(ActivityRecord r,int changes,boolean andResume,boolean preserveWindow){
  if (mService.mSuppressResizeConfigChanges && preserveWindow) {
    return;
  }
  List<ResultInfo> results=null;
  List<ReferrerIntent> newIntents=null;
  if (andResume) {
    results=r.results;
    newIntents=r.newIntents;
  }
  if (DEBUG_SWITCH)   Slog.v(TAG_SWITCH,""String_Node_Str"" + r + ""String_Node_Str""+ results+ ""String_Node_Str""+ newIntents+ ""String_Node_Str""+ andResume+ ""String_Node_Str""+ preserveWindow);
  EventLog.writeEvent(andResume ? EventLogTags.AM_RELAUNCH_RESUME_ACTIVITY : EventLogTags.AM_RELAUNCH_ACTIVITY,r.userId,System.identityHashCode(r),r.task.taskId,r.shortComponentName);
  r.startFreezingScreenLocked(r.app,0);
  mStackSupervisor.removeChildActivityContainers(r);
  try {
    if (DEBUG_SWITCH || DEBUG_STATES)     Slog.i(TAG_SWITCH,""String_Node_Str"" + (andResume ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ r);
    r.forceNewConfig=false;
    r.app.thread.scheduleRelaunchActivity(r.appToken,results,newIntents,changes,!andResume,new Configuration(mService.mConfiguration),new Configuration(r.task.mOverrideConfig),preserveWindow);
    mStackSupervisor.activityRelaunchingLocked(r);
  }
 catch (  RemoteException e) {
    if (DEBUG_SWITCH || DEBUG_STATES)     Slog.i(TAG_SWITCH,""String_Node_Str"",e);
  }
  if (andResume) {
    r.results=null;
    r.newIntents=null;
    r.state=ActivityState.RESUMED;
  }
 else {
    mHandler.removeMessages(PAUSE_TIMEOUT_MSG,r);
    r.state=ActivityState.PAUSED;
  }
}","private void relaunchActivityLocked(ActivityRecord r,int changes,boolean andResume,boolean preserveWindow){
  if (mService.mSuppressResizeConfigChanges && preserveWindow) {
    r.configChangeFlags=0;
    return;
  }
  List<ResultInfo> results=null;
  List<ReferrerIntent> newIntents=null;
  if (andResume) {
    results=r.results;
    newIntents=r.newIntents;
  }
  if (DEBUG_SWITCH)   Slog.v(TAG_SWITCH,""String_Node_Str"" + r + ""String_Node_Str""+ results+ ""String_Node_Str""+ newIntents+ ""String_Node_Str""+ andResume+ ""String_Node_Str""+ preserveWindow);
  EventLog.writeEvent(andResume ? EventLogTags.AM_RELAUNCH_RESUME_ACTIVITY : EventLogTags.AM_RELAUNCH_ACTIVITY,r.userId,System.identityHashCode(r),r.task.taskId,r.shortComponentName);
  r.startFreezingScreenLocked(r.app,0);
  mStackSupervisor.removeChildActivityContainers(r);
  try {
    if (DEBUG_SWITCH || DEBUG_STATES)     Slog.i(TAG_SWITCH,""String_Node_Str"" + (andResume ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ r);
    r.forceNewConfig=false;
    r.app.thread.scheduleRelaunchActivity(r.appToken,results,newIntents,changes,!andResume,new Configuration(mService.mConfiguration),new Configuration(r.task.mOverrideConfig),preserveWindow);
    mStackSupervisor.activityRelaunchingLocked(r);
  }
 catch (  RemoteException e) {
    if (DEBUG_SWITCH || DEBUG_STATES)     Slog.i(TAG_SWITCH,""String_Node_Str"",e);
  }
  if (andResume) {
    r.results=null;
    r.newIntents=null;
    r.state=ActivityState.RESUMED;
  }
 else {
    mHandler.removeMessages(PAUSE_TIMEOUT_MSG,r);
    r.state=ActivityState.PAUSED;
  }
  r.configChangeFlags=0;
}",0.983596214511041
192985,"private void completePauseLocked(boolean resumeNext){
  ActivityRecord prev=mPausingActivity;
  if (DEBUG_PAUSE)   Slog.v(TAG_PAUSE,""String_Node_Str"" + prev);
  if (prev != null) {
    final boolean wasStopping=prev.state == ActivityState.STOPPING;
    prev.state=ActivityState.PAUSED;
    if (prev.finishing) {
      if (DEBUG_PAUSE)       Slog.v(TAG_PAUSE,""String_Node_Str"" + prev);
      prev=finishCurrentActivityLocked(prev,FINISH_AFTER_VISIBLE,false);
    }
 else     if (prev.app != null) {
      if (DEBUG_PAUSE)       Slog.v(TAG_PAUSE,""String_Node_Str"" + prev);
      if (mStackSupervisor.mWaitingVisibleActivities.remove(prev)) {
        if (DEBUG_SWITCH || DEBUG_PAUSE)         Slog.v(TAG_PAUSE,""String_Node_Str"" + prev);
      }
      if (prev.configDestroy) {
        if (DEBUG_PAUSE)         Slog.v(TAG_PAUSE,""String_Node_Str"" + prev);
        destroyActivityLocked(prev,true,""String_Node_Str"");
      }
 else       if (wasStopping) {
        prev.state=ActivityState.STOPPING;
      }
 else       if (!hasVisibleBehindActivity() || mService.isSleepingOrShuttingDown()) {
        addToStopping(prev);
      }
    }
 else {
      if (DEBUG_PAUSE)       Slog.v(TAG_PAUSE,""String_Node_Str"" + prev);
      prev=null;
    }
    prev.stopFreezingScreenLocked(true);
    mPausingActivity=null;
  }
  if (resumeNext) {
    final ActivityStack topStack=mStackSupervisor.getFocusedStack();
    if (!mService.isSleepingOrShuttingDown()) {
      mStackSupervisor.resumeFocusedStackTopActivityLocked(topStack,prev,null);
    }
 else {
      mStackSupervisor.checkReadyForSleepLocked();
      ActivityRecord top=topStack.topRunningActivityLocked();
      if (top == null || (prev != null && top != prev)) {
        mStackSupervisor.resumeFocusedStackTopActivityLocked();
      }
    }
  }
  if (prev != null) {
    prev.resumeKeyDispatchingLocked();
    if (prev.app != null && prev.cpuTimeAtResume > 0 && mService.mBatteryStatsService.isOnBattery()) {
      long diff=mService.mProcessCpuTracker.getCpuTimeForPid(prev.app.pid) - prev.cpuTimeAtResume;
      if (diff > 0) {
        BatteryStatsImpl bsi=mService.mBatteryStatsService.getActiveStatistics();
synchronized (bsi) {
          BatteryStatsImpl.Uid.Proc ps=bsi.getProcessStatsLocked(prev.info.applicationInfo.uid,prev.info.packageName);
          if (ps != null) {
            ps.addForegroundTimeLocked(diff);
          }
        }
      }
    }
    prev.cpuTimeAtResume=0;
  }
  mService.notifyTaskStackChangedLocked();
}","private void completePauseLocked(boolean resumeNext){
  ActivityRecord prev=mPausingActivity;
  if (DEBUG_PAUSE)   Slog.v(TAG_PAUSE,""String_Node_Str"" + prev);
  if (prev != null) {
    final boolean wasStopping=prev.state == ActivityState.STOPPING;
    prev.state=ActivityState.PAUSED;
    if (prev.finishing) {
      if (DEBUG_PAUSE)       Slog.v(TAG_PAUSE,""String_Node_Str"" + prev);
      prev=finishCurrentActivityLocked(prev,FINISH_AFTER_VISIBLE,false);
    }
 else     if (prev.app != null) {
      if (DEBUG_PAUSE)       Slog.v(TAG_PAUSE,""String_Node_Str"" + prev);
      if (mStackSupervisor.mWaitingVisibleActivities.remove(prev)) {
        if (DEBUG_SWITCH || DEBUG_PAUSE)         Slog.v(TAG_PAUSE,""String_Node_Str"" + prev);
      }
      if (prev.deferRelaunchUntilPaused) {
        if (DEBUG_PAUSE)         Slog.v(TAG_PAUSE,""String_Node_Str"" + prev);
        relaunchActivityLocked(prev,prev.configChangeFlags,false,prev.preserveWindowOnDeferredRelaunch);
      }
 else       if (wasStopping) {
        prev.state=ActivityState.STOPPING;
      }
 else       if (!hasVisibleBehindActivity() || mService.isSleepingOrShuttingDown()) {
        addToStopping(prev);
      }
    }
 else {
      if (DEBUG_PAUSE)       Slog.v(TAG_PAUSE,""String_Node_Str"" + prev);
      prev=null;
    }
    prev.stopFreezingScreenLocked(true);
    mPausingActivity=null;
  }
  if (resumeNext) {
    final ActivityStack topStack=mStackSupervisor.getFocusedStack();
    if (!mService.isSleepingOrShuttingDown()) {
      mStackSupervisor.resumeFocusedStackTopActivityLocked(topStack,prev,null);
    }
 else {
      mStackSupervisor.checkReadyForSleepLocked();
      ActivityRecord top=topStack.topRunningActivityLocked();
      if (top == null || (prev != null && top != prev)) {
        mStackSupervisor.resumeFocusedStackTopActivityLocked();
      }
    }
  }
  if (prev != null) {
    prev.resumeKeyDispatchingLocked();
    if (prev.app != null && prev.cpuTimeAtResume > 0 && mService.mBatteryStatsService.isOnBattery()) {
      long diff=mService.mProcessCpuTracker.getCpuTimeForPid(prev.app.pid) - prev.cpuTimeAtResume;
      if (diff > 0) {
        BatteryStatsImpl bsi=mService.mBatteryStatsService.getActiveStatistics();
synchronized (bsi) {
          BatteryStatsImpl.Uid.Proc ps=bsi.getProcessStatsLocked(prev.info.applicationInfo.uid,prev.info.packageName);
          if (ps != null) {
            ps.addForegroundTimeLocked(diff);
          }
        }
      }
    }
    prev.cpuTimeAtResume=0;
  }
  mService.notifyTaskStackChangedLocked();
}",0.9725099601593624
192986,"final ArrayList<ActivityRecord> processStoppingActivitiesLocked(boolean remove){
  ArrayList<ActivityRecord> stops=null;
  final boolean nowVisible=allResumedActivitiesVisible();
  for (int activityNdx=mStoppingActivities.size() - 1; activityNdx >= 0; --activityNdx) {
    ActivityRecord s=mStoppingActivities.get(activityNdx);
    final boolean waitingVisible=mWaitingVisibleActivities.contains(s);
    if (DEBUG_ALL)     Slog.v(TAG,""String_Node_Str"" + s + ""String_Node_Str""+ nowVisible+ ""String_Node_Str""+ waitingVisible+ ""String_Node_Str""+ s.finishing);
    if (waitingVisible && nowVisible) {
      mWaitingVisibleActivities.remove(s);
      if (s.finishing) {
        if (DEBUG_ALL)         Slog.v(TAG,""String_Node_Str"" + s);
        mWindowManager.setAppVisibility(s.appToken,false);
      }
    }
    if ((!waitingVisible || mService.isSleepingOrShuttingDown()) && remove) {
      if (DEBUG_ALL)       Slog.v(TAG,""String_Node_Str"" + s);
      if (stops == null) {
        stops=new ArrayList<>();
      }
      stops.add(s);
      mStoppingActivities.remove(activityNdx);
    }
  }
  return stops;
}","final ArrayList<ActivityRecord> processStoppingActivitiesLocked(boolean remove){
  ArrayList<ActivityRecord> stops=null;
  final boolean nowVisible=allResumedActivitiesVisible();
  for (int activityNdx=mStoppingActivities.size() - 1; activityNdx >= 0; --activityNdx) {
    ActivityRecord s=mStoppingActivities.get(activityNdx);
    final boolean waitingVisible=mWaitingVisibleActivities.contains(s);
    if (DEBUG_STATES)     Slog.v(TAG,""String_Node_Str"" + s + ""String_Node_Str""+ nowVisible+ ""String_Node_Str""+ waitingVisible+ ""String_Node_Str""+ s.finishing);
    if (waitingVisible && nowVisible) {
      mWaitingVisibleActivities.remove(s);
      if (s.finishing) {
        if (DEBUG_STATES)         Slog.v(TAG,""String_Node_Str"" + s);
        mWindowManager.setAppVisibility(s.appToken,false);
      }
    }
    if ((!waitingVisible || mService.isSleepingOrShuttingDown()) && remove) {
      if (DEBUG_STATES)       Slog.v(TAG,""String_Node_Str"" + s);
      if (stops == null) {
        stops=new ArrayList<>();
      }
      stops.add(s);
      mStoppingActivities.remove(activityNdx);
    }
  }
  return stops;
}",0.9878433138226024
192987,"/** 
 * This should be the only way to get the time from the system.
 */
private long checkAndGetTimeLocked(){
  final long actualSystemTime=System.currentTimeMillis();
  final long actualRealtime=SystemClock.elapsedRealtime();
  final long expectedSystemTime=(actualRealtime - mRealTimeSnapshot) + mSystemTimeSnapshot;
  boolean resetBeginIdleTime=false;
  if (Math.abs(actualSystemTime - expectedSystemTime) > TIME_CHANGE_THRESHOLD_MILLIS) {
    if (Math.abs(actualSystemTime - expectedSystemTime) > mAppIdleDurationMillis) {
      mScreenOnSystemTimeSnapshot=actualSystemTime;
      mScreenOnTime=0;
      resetBeginIdleTime=true;
    }
    final int userCount=mUserState.size();
    for (int i=0; i < userCount; i++) {
      final UserUsageStatsService service=mUserState.valueAt(i);
      service.onTimeChanged(expectedSystemTime,actualSystemTime,resetBeginIdleTime);
    }
    mRealTimeSnapshot=actualRealtime;
    mSystemTimeSnapshot=actualSystemTime;
  }
  return actualSystemTime;
}","/** 
 * This should be the only way to get the time from the system.
 */
private long checkAndGetTimeLocked(){
  final long actualSystemTime=System.currentTimeMillis();
  final long actualRealtime=SystemClock.elapsedRealtime();
  final long expectedSystemTime=(actualRealtime - mRealTimeSnapshot) + mSystemTimeSnapshot;
  boolean resetBeginIdleTime=false;
  if (Math.abs(actualSystemTime - expectedSystemTime) > TIME_CHANGE_THRESHOLD_MILLIS) {
    if (Math.abs(actualSystemTime - expectedSystemTime) > mAppIdleDurationMillis) {
      mScreenOnSystemTimeSnapshot=actualSystemTime;
      mScreenOnTime=0;
      resetBeginIdleTime=true;
    }
    final int userCount=mUserState.size();
    for (int i=0; i < userCount; i++) {
      final UserUsageStatsService service=mUserState.valueAt(i);
      service.onTimeChanged(expectedSystemTime,actualSystemTime,mScreenOnTime,resetBeginIdleTime);
    }
    mRealTimeSnapshot=actualRealtime;
    mSystemTimeSnapshot=actualSystemTime;
  }
  return actualSystemTime;
}",0.9929859719438878
192988,"void onTimeChanged(long oldTime,long newTime,boolean resetBeginIdleTime){
  persistActiveStats();
  mDatabase.onTimeChanged(newTime - oldTime);
  loadActiveStats(newTime,true,resetBeginIdleTime);
  refreshAppIdleRollingWindow(newTime);
}","void onTimeChanged(long oldTime,long newTime,long deviceUsageTime,boolean resetBeginIdleTime){
  persistActiveStats();
  mDatabase.onTimeChanged(newTime - oldTime);
  loadActiveStats(newTime,true,resetBeginIdleTime);
  refreshAppIdleRollingWindow(newTime,deviceUsageTime);
}",0.9275929549902152
192989,"/** 
 * If any of the apps don't have a last-used entry, add one now.
 * @param currentTimeMillis the current time
 * @param firstUpdate if it is the first update, touch all installed apps, otherwise onlytouch the system apps
 */
private void initializeDefaultsForApps(long currentTimeMillis,long deviceUsageTime,boolean firstUpdate){
  PackageManager pm=mContext.getPackageManager();
  List<PackageInfo> packages=pm.getInstalledPackages(0,mUserId);
  final int packageCount=packages.size();
  for (int i=0; i < packageCount; i++) {
    final PackageInfo pi=packages.get(i);
    String packageName=pi.packageName;
    if (pi.applicationInfo != null && (firstUpdate || pi.applicationInfo.isSystemApp()) && getBeginIdleTime(packageName) == -1) {
      for (      IntervalStats stats : mCurrentStats) {
        stats.update(packageName,currentTimeMillis,Event.SYSTEM_INTERACTION);
        stats.updateBeginIdleTime(packageName,deviceUsageTime);
        mStatsChanged=true;
      }
    }
  }
  persistActiveStats();
}","/** 
 * If any of the apps don't have a last-used entry, add one now.
 * @param currentTimeMillis the current time
 * @param firstUpdate if it is the first update, touch all installed apps, otherwise onlytouch the system apps
 */
private void initializeDefaultsForApps(long currentTimeMillis,long deviceUsageTime,boolean firstUpdate){
  PackageManager pm=mContext.getPackageManager();
  List<PackageInfo> packages=pm.getInstalledPackages(0,mUserId);
  final int packageCount=packages.size();
  for (int i=0; i < packageCount; i++) {
    final PackageInfo pi=packages.get(i);
    String packageName=pi.packageName;
    if (pi.applicationInfo != null && (firstUpdate || pi.applicationInfo.isSystemApp()) && getBeginIdleTime(packageName) == -1) {
      for (      IntervalStats stats : mCurrentStats) {
        stats.update(packageName,currentTimeMillis,Event.SYSTEM_INTERACTION);
        stats.updateBeginIdleTime(packageName,deviceUsageTime);
      }
      mAppIdleRollingWindow.update(packageName,currentTimeMillis,Event.SYSTEM_INTERACTION);
      mAppIdleRollingWindow.updateBeginIdleTime(packageName,deviceUsageTime);
      mStatsChanged=true;
    }
  }
  persistActiveStats();
}",0.8960802187784868
192990,"private static void mergePackageStats(IntervalStats dst,IntervalStats src){
  dst.endTime=Math.max(dst.endTime,src.endTime);
  final int srcPackageCount=src.packageStats.size();
  for (int i=0; i < srcPackageCount; i++) {
    final String packageName=src.packageStats.keyAt(i);
    final UsageStats srcStats=src.packageStats.valueAt(i);
    final UsageStats dstStats=dst.packageStats.get(packageName);
    if (dstStats == null) {
      dst.packageStats.put(packageName,new UsageStats(srcStats));
    }
 else {
      dstStats.add(src.packageStats.valueAt(i));
    }
  }
}","private static void mergePackageStats(IntervalStats dst,IntervalStats src,final long deviceUsageTime){
  dst.endTime=Math.max(dst.endTime,src.endTime);
  final int srcPackageCount=src.packageStats.size();
  for (int i=0; i < srcPackageCount; i++) {
    final String packageName=src.packageStats.keyAt(i);
    final UsageStats srcStats=src.packageStats.valueAt(i);
    UsageStats dstStats=dst.packageStats.get(packageName);
    if (dstStats == null) {
      dstStats=new UsageStats(srcStats);
      dst.packageStats.put(packageName,dstStats);
    }
 else {
      dstStats.add(src.packageStats.valueAt(i));
    }
    if (dstStats.mBeginIdleTime > deviceUsageTime) {
      dstStats.mBeginIdleTime=deviceUsageTime;
    }
  }
}",0.6408668730650154
192991,"@Override public void combine(IntervalStats stats,boolean mutable,List<IntervalStats> accumulatedResult){
  IntervalStats accum;
  if (accumulatedResult.isEmpty()) {
    accum=new IntervalStats();
    accum.beginTime=stats.beginTime;
    accumulatedResult.add(accum);
  }
 else {
    accum=accumulatedResult.get(0);
  }
  mergePackageStats(accum,stats);
}","@Override public void combine(IntervalStats stats,boolean mutable,List<IntervalStats> accumulatedResult){
  IntervalStats accum;
  if (accumulatedResult.isEmpty()) {
    accum=new IntervalStats();
    accum.beginTime=stats.beginTime;
    accumulatedResult.add(accum);
  }
 else {
    accum=accumulatedResult.get(0);
  }
  mergePackageStats(accum,stats,deviceUsageTime);
}",0.977961432506887
192992,"void init(final long currentTimeMillis,final long deviceUsageTime){
  mDatabase.init(currentTimeMillis);
  int nullCount=0;
  for (int i=0; i < mCurrentStats.length; i++) {
    mCurrentStats[i]=mDatabase.getLatestUsageStats(i);
    if (mCurrentStats[i] == null) {
      nullCount++;
    }
  }
  if (nullCount > 0) {
    if (nullCount != mCurrentStats.length) {
      Slog.w(TAG,mLogPrefix + ""String_Node_Str"");
    }
 else {
    }
    loadActiveStats(currentTimeMillis,false,false);
  }
 else {
    mDailyExpiryDate.setTimeInMillis(mCurrentStats[UsageStatsManager.INTERVAL_DAILY].beginTime);
    mDailyExpiryDate.addDays(1);
    mDailyExpiryDate.truncateToDay();
    Slog.i(TAG,mLogPrefix + ""String_Node_Str"" + sDateFormat.format(mDailyExpiryDate.getTimeInMillis())+ ""String_Node_Str""+ mDailyExpiryDate.getTimeInMillis()+ ""String_Node_Str"");
  }
  for (  IntervalStats stat : mCurrentStats) {
    final int pkgCount=stat.packageStats.size();
    for (int i=0; i < pkgCount; i++) {
      UsageStats pkgStats=stat.packageStats.valueAt(i);
      if (pkgStats.mLastEvent == UsageEvents.Event.MOVE_TO_FOREGROUND || pkgStats.mLastEvent == UsageEvents.Event.CONTINUE_PREVIOUS_DAY) {
        stat.update(pkgStats.mPackageName,stat.lastTimeSaved,UsageEvents.Event.END_OF_DAY);
        notifyStatsChanged();
      }
    }
    stat.updateConfigurationStats(null,stat.lastTimeSaved);
  }
  if (mDatabase.isNewUpdate()) {
    initializeDefaultsForApps(currentTimeMillis,deviceUsageTime,mDatabase.isFirstUpdate());
  }
  refreshAppIdleRollingWindow(currentTimeMillis);
}","void init(final long currentTimeMillis,final long deviceUsageTime){
  mDatabase.init(currentTimeMillis);
  int nullCount=0;
  for (int i=0; i < mCurrentStats.length; i++) {
    mCurrentStats[i]=mDatabase.getLatestUsageStats(i);
    if (mCurrentStats[i] == null) {
      nullCount++;
    }
  }
  if (nullCount > 0) {
    if (nullCount != mCurrentStats.length) {
      Slog.w(TAG,mLogPrefix + ""String_Node_Str"");
    }
 else {
    }
    loadActiveStats(currentTimeMillis,false,false);
  }
 else {
    mDailyExpiryDate.setTimeInMillis(mCurrentStats[UsageStatsManager.INTERVAL_DAILY].beginTime);
    mDailyExpiryDate.addDays(1);
    mDailyExpiryDate.truncateToDay();
    Slog.i(TAG,mLogPrefix + ""String_Node_Str"" + sDateFormat.format(mDailyExpiryDate.getTimeInMillis())+ ""String_Node_Str""+ mDailyExpiryDate.getTimeInMillis()+ ""String_Node_Str"");
  }
  for (  IntervalStats stat : mCurrentStats) {
    final int pkgCount=stat.packageStats.size();
    for (int i=0; i < pkgCount; i++) {
      UsageStats pkgStats=stat.packageStats.valueAt(i);
      if (pkgStats.mLastEvent == UsageEvents.Event.MOVE_TO_FOREGROUND || pkgStats.mLastEvent == UsageEvents.Event.CONTINUE_PREVIOUS_DAY) {
        stat.update(pkgStats.mPackageName,stat.lastTimeSaved,UsageEvents.Event.END_OF_DAY);
        notifyStatsChanged();
      }
    }
    stat.updateConfigurationStats(null,stat.lastTimeSaved);
  }
  refreshAppIdleRollingWindow(currentTimeMillis,deviceUsageTime);
  if (mDatabase.isNewUpdate()) {
    initializeDefaultsForApps(currentTimeMillis,deviceUsageTime,mDatabase.isFirstUpdate());
  }
}",0.962915601023018
192993,"void reportEvent(UsageEvents.Event event,long deviceUsageTime){
  if (DEBUG) {
    Slog.d(TAG,mLogPrefix + ""String_Node_Str"" + event.mPackage+ ""String_Node_Str""+ event.mTimeStamp+ ""String_Node_Str""+ eventToString(event.mEventType));
  }
  if (event.mTimeStamp >= mDailyExpiryDate.getTimeInMillis()) {
    rolloverStats(event.mTimeStamp);
  }
  final IntervalStats currentDailyStats=mCurrentStats[UsageStatsManager.INTERVAL_DAILY];
  final Configuration newFullConfig=event.mConfiguration;
  if (event.mEventType == UsageEvents.Event.CONFIGURATION_CHANGE && currentDailyStats.activeConfiguration != null) {
    event.mConfiguration=Configuration.generateDelta(currentDailyStats.activeConfiguration,newFullConfig);
  }
  if (currentDailyStats.events == null) {
    currentDailyStats.events=new TimeSparseArray<>();
  }
  if (event.mEventType != UsageEvents.Event.SYSTEM_INTERACTION) {
    currentDailyStats.events.put(event.mTimeStamp,event);
  }
  for (  IntervalStats stats : mCurrentStats) {
    if (event.mEventType == UsageEvents.Event.CONFIGURATION_CHANGE) {
      stats.updateConfigurationStats(newFullConfig,event.mTimeStamp);
    }
 else {
      stats.update(event.mPackage,event.mTimeStamp,event.mEventType);
      stats.updateBeginIdleTime(event.mPackage,deviceUsageTime);
    }
  }
  if (event.mEventType != Event.CONFIGURATION_CHANGE) {
    mAppIdleRollingWindow.update(event.mPackage,event.mTimeStamp,event.mEventType);
    mAppIdleRollingWindow.updateBeginIdleTime(event.mPackage,deviceUsageTime);
  }
  notifyStatsChanged();
}","void reportEvent(UsageEvents.Event event,long deviceUsageTime){
  if (DEBUG) {
    Slog.d(TAG,mLogPrefix + ""String_Node_Str"" + event.mPackage+ ""String_Node_Str""+ event.mTimeStamp+ ""String_Node_Str""+ eventToString(event.mEventType));
  }
  if (event.mTimeStamp >= mDailyExpiryDate.getTimeInMillis()) {
    rolloverStats(event.mTimeStamp,deviceUsageTime);
  }
  final IntervalStats currentDailyStats=mCurrentStats[UsageStatsManager.INTERVAL_DAILY];
  final Configuration newFullConfig=event.mConfiguration;
  if (event.mEventType == UsageEvents.Event.CONFIGURATION_CHANGE && currentDailyStats.activeConfiguration != null) {
    event.mConfiguration=Configuration.generateDelta(currentDailyStats.activeConfiguration,newFullConfig);
  }
  if (currentDailyStats.events == null) {
    currentDailyStats.events=new TimeSparseArray<>();
  }
  if (event.mEventType != UsageEvents.Event.SYSTEM_INTERACTION) {
    currentDailyStats.events.put(event.mTimeStamp,event);
  }
  for (  IntervalStats stats : mCurrentStats) {
    if (event.mEventType == UsageEvents.Event.CONFIGURATION_CHANGE) {
      stats.updateConfigurationStats(newFullConfig,event.mTimeStamp);
    }
 else {
      stats.update(event.mPackage,event.mTimeStamp,event.mEventType);
      stats.updateBeginIdleTime(event.mPackage,deviceUsageTime);
    }
  }
  if (event.mEventType != Event.CONFIGURATION_CHANGE) {
    mAppIdleRollingWindow.update(event.mPackage,event.mTimeStamp,event.mEventType);
    mAppIdleRollingWindow.updateBeginIdleTime(event.mPackage,deviceUsageTime);
  }
  notifyStatsChanged();
}",0.9948320413436692
192994,"/** 
 * App idle operates on a rolling window of time. When we roll over time, we end up with a period of time where in-memory stats are empty and we don't hit the disk for older stats for performance reasons. Suddenly all apps will become idle. Instead, at times we do a deep query to find all the apps that have run in the past few days and keep the cached data up to date.
 * @param currentTimeMillis
 */
void refreshAppIdleRollingWindow(long currentTimeMillis){
  List<IntervalStats> stats=mDatabase.queryUsageStats(UsageStatsManager.INTERVAL_DAILY,currentTimeMillis - (1000 * 60 * 60* 24* 2),currentTimeMillis,sPackageStatsMerger);
  if (stats == null || stats.isEmpty()) {
    mAppIdleRollingWindow=new IntervalStats();
    mergePackageStats(mAppIdleRollingWindow,mCurrentStats[UsageStatsManager.INTERVAL_YEARLY]);
  }
 else {
    mAppIdleRollingWindow=stats.get(0);
  }
}","/** 
 * App idle operates on a rolling window of time. When we roll over time, we end up with a period of time where in-memory stats are empty and we don't hit the disk for older stats for performance reasons. Suddenly all apps will become idle. Instead, at times we do a deep query to find all the apps that have run in the past few days and keep the cached data up to date.
 * @param currentTimeMillis
 */
void refreshAppIdleRollingWindow(final long currentTimeMillis,final long deviceUsageTime){
  List<IntervalStats> stats=mDatabase.queryUsageStats(UsageStatsManager.INTERVAL_DAILY,currentTimeMillis - (1000 * 60 * 60* 24* 2),currentTimeMillis,new StatCombiner<IntervalStats>(){
    @Override public void combine(    IntervalStats stats,    boolean mutable,    List<IntervalStats> accumulatedResult){
      IntervalStats accum;
      if (accumulatedResult.isEmpty()) {
        accum=new IntervalStats();
        accum.beginTime=stats.beginTime;
        accumulatedResult.add(accum);
      }
 else {
        accum=accumulatedResult.get(0);
      }
      mergePackageStats(accum,stats,deviceUsageTime);
    }
  }
);
  if (stats == null || stats.isEmpty()) {
    mAppIdleRollingWindow=new IntervalStats();
    mergePackageStats(mAppIdleRollingWindow,mCurrentStats[UsageStatsManager.INTERVAL_YEARLY],deviceUsageTime);
  }
 else {
    mAppIdleRollingWindow=stats.get(0);
  }
}",0.7731913004882379
192995,"private void rolloverStats(final long currentTimeMillis){
  final long startTime=SystemClock.elapsedRealtime();
  Slog.i(TAG,mLogPrefix + ""String_Node_Str"");
  final Configuration previousConfig=mCurrentStats[UsageStatsManager.INTERVAL_DAILY].activeConfiguration;
  ArraySet<String> continuePreviousDay=new ArraySet<>();
  for (  IntervalStats stat : mCurrentStats) {
    final int pkgCount=stat.packageStats.size();
    for (int i=0; i < pkgCount; i++) {
      UsageStats pkgStats=stat.packageStats.valueAt(i);
      if (pkgStats.mLastEvent == UsageEvents.Event.MOVE_TO_FOREGROUND || pkgStats.mLastEvent == UsageEvents.Event.CONTINUE_PREVIOUS_DAY) {
        continuePreviousDay.add(pkgStats.mPackageName);
        stat.update(pkgStats.mPackageName,mDailyExpiryDate.getTimeInMillis() - 1,UsageEvents.Event.END_OF_DAY);
        notifyStatsChanged();
      }
    }
    stat.updateConfigurationStats(null,mDailyExpiryDate.getTimeInMillis() - 1);
  }
  persistActiveStats();
  mDatabase.prune(currentTimeMillis);
  loadActiveStats(currentTimeMillis,false,false);
  final int continueCount=continuePreviousDay.size();
  for (int i=0; i < continueCount; i++) {
    String name=continuePreviousDay.valueAt(i);
    final long beginTime=mCurrentStats[UsageStatsManager.INTERVAL_DAILY].beginTime;
    for (    IntervalStats stat : mCurrentStats) {
      stat.update(name,beginTime,UsageEvents.Event.CONTINUE_PREVIOUS_DAY);
      stat.updateConfigurationStats(previousConfig,beginTime);
      notifyStatsChanged();
    }
  }
  persistActiveStats();
  refreshAppIdleRollingWindow(currentTimeMillis);
  final long totalTime=SystemClock.elapsedRealtime() - startTime;
  Slog.i(TAG,mLogPrefix + ""String_Node_Str"" + totalTime+ ""String_Node_Str"");
}","private void rolloverStats(final long currentTimeMillis,final long deviceUsageTime){
  final long startTime=SystemClock.elapsedRealtime();
  Slog.i(TAG,mLogPrefix + ""String_Node_Str"");
  final Configuration previousConfig=mCurrentStats[UsageStatsManager.INTERVAL_DAILY].activeConfiguration;
  ArraySet<String> continuePreviousDay=new ArraySet<>();
  for (  IntervalStats stat : mCurrentStats) {
    final int pkgCount=stat.packageStats.size();
    for (int i=0; i < pkgCount; i++) {
      UsageStats pkgStats=stat.packageStats.valueAt(i);
      if (pkgStats.mLastEvent == UsageEvents.Event.MOVE_TO_FOREGROUND || pkgStats.mLastEvent == UsageEvents.Event.CONTINUE_PREVIOUS_DAY) {
        continuePreviousDay.add(pkgStats.mPackageName);
        stat.update(pkgStats.mPackageName,mDailyExpiryDate.getTimeInMillis() - 1,UsageEvents.Event.END_OF_DAY);
        notifyStatsChanged();
      }
    }
    stat.updateConfigurationStats(null,mDailyExpiryDate.getTimeInMillis() - 1);
  }
  persistActiveStats();
  mDatabase.prune(currentTimeMillis);
  loadActiveStats(currentTimeMillis,false,false);
  final int continueCount=continuePreviousDay.size();
  for (int i=0; i < continueCount; i++) {
    String name=continuePreviousDay.valueAt(i);
    final long beginTime=mCurrentStats[UsageStatsManager.INTERVAL_DAILY].beginTime;
    for (    IntervalStats stat : mCurrentStats) {
      stat.update(name,beginTime,UsageEvents.Event.CONTINUE_PREVIOUS_DAY);
      stat.updateConfigurationStats(previousConfig,beginTime);
      notifyStatsChanged();
    }
  }
  persistActiveStats();
  refreshAppIdleRollingWindow(currentTimeMillis,deviceUsageTime);
  final long totalTime=SystemClock.elapsedRealtime() - startTime;
  Slog.i(TAG,mLogPrefix + ""String_Node_Str"" + totalTime+ ""String_Node_Str"");
}",0.9877388080980896
192996,"/** 
 * This should be the only way to get the time from the system.
 */
private long checkAndGetTimeLocked(){
  final long actualSystemTime=System.currentTimeMillis();
  final long actualRealtime=SystemClock.elapsedRealtime();
  final long expectedSystemTime=(actualRealtime - mRealTimeSnapshot) + mSystemTimeSnapshot;
  boolean resetBeginIdleTime=false;
  if (Math.abs(actualSystemTime - expectedSystemTime) > TIME_CHANGE_THRESHOLD_MILLIS) {
    if (Math.abs(actualSystemTime - expectedSystemTime) > mAppIdleDurationMillis) {
      mScreenOnSystemTimeSnapshot=actualSystemTime;
      mScreenOnTime=0;
      resetBeginIdleTime=true;
    }
    final int userCount=mUserState.size();
    for (int i=0; i < userCount; i++) {
      final UserUsageStatsService service=mUserState.valueAt(i);
      service.onTimeChanged(expectedSystemTime,actualSystemTime,resetBeginIdleTime);
    }
    mRealTimeSnapshot=actualRealtime;
    mSystemTimeSnapshot=actualSystemTime;
  }
  return actualSystemTime;
}","/** 
 * This should be the only way to get the time from the system.
 */
private long checkAndGetTimeLocked(){
  final long actualSystemTime=System.currentTimeMillis();
  final long actualRealtime=SystemClock.elapsedRealtime();
  final long expectedSystemTime=(actualRealtime - mRealTimeSnapshot) + mSystemTimeSnapshot;
  boolean resetBeginIdleTime=false;
  if (Math.abs(actualSystemTime - expectedSystemTime) > TIME_CHANGE_THRESHOLD_MILLIS) {
    if (Math.abs(actualSystemTime - expectedSystemTime) > mAppIdleDurationMillis) {
      mScreenOnSystemTimeSnapshot=actualSystemTime;
      mScreenOnTime=0;
      resetBeginIdleTime=true;
    }
    final int userCount=mUserState.size();
    for (int i=0; i < userCount; i++) {
      final UserUsageStatsService service=mUserState.valueAt(i);
      service.onTimeChanged(expectedSystemTime,actualSystemTime,mScreenOnTime,resetBeginIdleTime);
    }
    mRealTimeSnapshot=actualRealtime;
    mSystemTimeSnapshot=actualSystemTime;
  }
  return actualSystemTime;
}",0.9929859719438878
192997,"void onTimeChanged(long oldTime,long newTime,boolean resetBeginIdleTime){
  persistActiveStats();
  mDatabase.onTimeChanged(newTime - oldTime);
  loadActiveStats(newTime,true,resetBeginIdleTime);
  refreshAppIdleRollingWindow(newTime);
}","void onTimeChanged(long oldTime,long newTime,long deviceUsageTime,boolean resetBeginIdleTime){
  persistActiveStats();
  mDatabase.onTimeChanged(newTime - oldTime);
  loadActiveStats(newTime,true,resetBeginIdleTime);
  refreshAppIdleRollingWindow(newTime,deviceUsageTime);
}",0.9275929549902152
192998,"/** 
 * If any of the apps don't have a last-used entry, add one now.
 * @param currentTimeMillis the current time
 * @param firstUpdate if it is the first update, touch all installed apps, otherwise onlytouch the system apps
 */
private void initializeDefaultsForApps(long currentTimeMillis,long deviceUsageTime,boolean firstUpdate){
  PackageManager pm=mContext.getPackageManager();
  List<PackageInfo> packages=pm.getInstalledPackages(0,mUserId);
  final int packageCount=packages.size();
  for (int i=0; i < packageCount; i++) {
    final PackageInfo pi=packages.get(i);
    String packageName=pi.packageName;
    if (pi.applicationInfo != null && (firstUpdate || pi.applicationInfo.isSystemApp()) && getBeginIdleTime(packageName) == -1) {
      for (      IntervalStats stats : mCurrentStats) {
        stats.update(packageName,currentTimeMillis,Event.SYSTEM_INTERACTION);
        stats.updateBeginIdleTime(packageName,deviceUsageTime);
        mStatsChanged=true;
      }
    }
  }
  persistActiveStats();
}","/** 
 * If any of the apps don't have a last-used entry, add one now.
 * @param currentTimeMillis the current time
 * @param firstUpdate if it is the first update, touch all installed apps, otherwise onlytouch the system apps
 */
private void initializeDefaultsForApps(long currentTimeMillis,long deviceUsageTime,boolean firstUpdate){
  PackageManager pm=mContext.getPackageManager();
  List<PackageInfo> packages=pm.getInstalledPackages(0,mUserId);
  final int packageCount=packages.size();
  for (int i=0; i < packageCount; i++) {
    final PackageInfo pi=packages.get(i);
    String packageName=pi.packageName;
    if (pi.applicationInfo != null && (firstUpdate || pi.applicationInfo.isSystemApp()) && getBeginIdleTime(packageName) == -1) {
      for (      IntervalStats stats : mCurrentStats) {
        stats.update(packageName,currentTimeMillis,Event.SYSTEM_INTERACTION);
        stats.updateBeginIdleTime(packageName,deviceUsageTime);
      }
      mAppIdleRollingWindow.update(packageName,currentTimeMillis,Event.SYSTEM_INTERACTION);
      mAppIdleRollingWindow.updateBeginIdleTime(packageName,deviceUsageTime);
      mStatsChanged=true;
    }
  }
  persistActiveStats();
}",0.8960802187784868
192999,"private static void mergePackageStats(IntervalStats dst,IntervalStats src){
  dst.endTime=Math.max(dst.endTime,src.endTime);
  final int srcPackageCount=src.packageStats.size();
  for (int i=0; i < srcPackageCount; i++) {
    final String packageName=src.packageStats.keyAt(i);
    final UsageStats srcStats=src.packageStats.valueAt(i);
    final UsageStats dstStats=dst.packageStats.get(packageName);
    if (dstStats == null) {
      dst.packageStats.put(packageName,new UsageStats(srcStats));
    }
 else {
      dstStats.add(src.packageStats.valueAt(i));
    }
  }
}","private static void mergePackageStats(IntervalStats dst,IntervalStats src,final long deviceUsageTime){
  dst.endTime=Math.max(dst.endTime,src.endTime);
  final int srcPackageCount=src.packageStats.size();
  for (int i=0; i < srcPackageCount; i++) {
    final String packageName=src.packageStats.keyAt(i);
    final UsageStats srcStats=src.packageStats.valueAt(i);
    UsageStats dstStats=dst.packageStats.get(packageName);
    if (dstStats == null) {
      dstStats=new UsageStats(srcStats);
      dst.packageStats.put(packageName,dstStats);
    }
 else {
      dstStats.add(src.packageStats.valueAt(i));
    }
    if (dstStats.mBeginIdleTime > deviceUsageTime) {
      dstStats.mBeginIdleTime=deviceUsageTime;
    }
  }
}",0.6408668730650154
193000,"@Override public void combine(IntervalStats stats,boolean mutable,List<IntervalStats> accumulatedResult){
  IntervalStats accum;
  if (accumulatedResult.isEmpty()) {
    accum=new IntervalStats();
    accum.beginTime=stats.beginTime;
    accumulatedResult.add(accum);
  }
 else {
    accum=accumulatedResult.get(0);
  }
  mergePackageStats(accum,stats);
}","@Override public void combine(IntervalStats stats,boolean mutable,List<IntervalStats> accumulatedResult){
  IntervalStats accum;
  if (accumulatedResult.isEmpty()) {
    accum=new IntervalStats();
    accum.beginTime=stats.beginTime;
    accumulatedResult.add(accum);
  }
 else {
    accum=accumulatedResult.get(0);
  }
  mergePackageStats(accum,stats,deviceUsageTime);
}",0.977961432506887
