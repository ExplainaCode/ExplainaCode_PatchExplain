record_number,buggy_code,fixed_code,code_similarity
49001,"private void clearMigrationData(int partitionId){
  Iterator<Entry<String,QueueContainer>> iterator=containerMap.entrySet().iterator();
  while (iterator.hasNext()) {
    QueueContainer container=iterator.next().getValue();
    if (container.getPartitionId() == partitionId) {
      container.destroy();
      iterator.remove();
    }
  }
}","private void clearMigrationData(int partitionId){
  Iterator<Entry<String,QueueContainer>> iterator=containerMap.entrySet().iterator();
  while (iterator.hasNext()) {
    final Entry<String,QueueContainer> entry=iterator.next();
    final String name=entry.getKey();
    final QueueContainer container=entry.getValue();
    int containerPartitionId=nodeEngine.getPartitionService().getPartitionId(StringPartitioningStrategy.getPartitionKey(name));
    if (containerPartitionId == partitionId) {
      container.destroy();
      iterator.remove();
    }
  }
}",0.7216035634743875
49002,"public Operation prepareReplicationOperation(PartitionReplicationEvent event){
  Map<String,QueueContainer> migrationData=new HashMap<String,QueueContainer>();
  for (  Entry<String,QueueContainer> entry : containerMap.entrySet()) {
    String name=entry.getKey();
    QueueContainer container=entry.getValue();
    if (container.getPartitionId() == event.getPartitionId() && container.getConfig().getTotalBackupCount() >= event.getReplicaIndex()) {
      migrationData.put(name,container);
    }
  }
  return migrationData.isEmpty() ? null : new QueueReplicationOperation(migrationData,event.getPartitionId(),event.getReplicaIndex());
}","public Operation prepareReplicationOperation(PartitionReplicationEvent event){
  Map<String,QueueContainer> migrationData=new HashMap<String,QueueContainer>();
  for (  Entry<String,QueueContainer> entry : containerMap.entrySet()) {
    String name=entry.getKey();
    int partitionId=nodeEngine.getPartitionService().getPartitionId(StringPartitioningStrategy.getPartitionKey(name));
    QueueContainer container=entry.getValue();
    if (partitionId == event.getPartitionId() && container.getConfig().getTotalBackupCount() >= event.getReplicaIndex()) {
      migrationData.put(name,container);
    }
  }
  return migrationData.isEmpty() ? null : new QueueReplicationOperation(migrationData,event.getPartitionId(),event.getReplicaIndex());
}",0.8272859216255443
49003,"public QueueContainer getOrCreateContainer(final String name,boolean fromBackup) throws Exception {
  QueueContainer container=containerMap.get(name);
  if (container == null) {
    container=new QueueContainer(name,nodeEngine.getPartitionService().getPartitionId(nodeEngine.toData(name)),nodeEngine.getConfig().getQueueConfig(name),nodeEngine,this);
    QueueContainer existing=containerMap.putIfAbsent(name,container);
    if (existing != null) {
      container=existing;
    }
 else {
      container.init(fromBackup);
    }
  }
  container.cancelEvictionIfExists();
  return container;
}","public QueueContainer getOrCreateContainer(final String name,boolean fromBackup) throws Exception {
  QueueContainer container=containerMap.get(name);
  if (container == null) {
    container=new QueueContainer(name,nodeEngine.getConfig().getQueueConfig(name),nodeEngine,this);
    QueueContainer existing=containerMap.putIfAbsent(name,container);
    if (existing != null) {
      container=existing;
    }
 else {
      container.init(fromBackup);
    }
  }
  container.cancelEvictionIfExists();
  return container;
}",0.9342934293429342
49004,"public Object getKey(){
  return itemId;
}","public Object getKey(){
  return new TransactionLogKey(itemId,name);
}",0.75
49005,"public Object getKey(){
  return itemId;
}","public Object getKey(){
  return new TransactionLogKey(itemId,name);
}",0.75
49006,"private void _sendAndHandle(ConnectionFactory connectionFactory,Object obj,ResponseHandler handler) throws IOException {
  ResponseStream stream=null;
  while (stream == null) {
    Connection conn=null;
    try {
      conn=connectionFactory.create();
      final SerializationService serializationService=getSerializationService();
      final Data request=serializationService.toData(obj);
      conn.write(request);
      stream=new ResponseStreamImpl(serializationService,conn);
    }
 catch (    Exception e) {
      if (e instanceof IOException) {
        if (logger.isFinestEnabled()) {
          logger.finest(""String_Node_Str"" + conn + ""String_Node_Str""+ e);
        }
      }
      if (conn != null) {
        IOUtil.closeResource(conn);
      }
      if (ErrorHandler.isRetryable(e)) {
        if (redoOperation || obj instanceof RetryableRequest) {
          if (logger.isFinestEnabled()) {
            logger.finest(""String_Node_Str"" + obj + ""String_Node_Str""+ conn+ ""String_Node_Str""+ e);
          }
          beforeRetry();
          continue;
        }
      }
      throw ExceptionUtil.rethrow(e,IOException.class);
    }
  }
  try {
    handler.handle(stream);
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e,IOException.class);
  }
 finally {
    stream.end();
  }
}","private void _sendAndHandle(ConnectionFactory connectionFactory,Object obj,ResponseHandler handler) throws IOException {
  ResponseStream stream=null;
  while (stream == null) {
    if (!active) {
      throw new HazelcastInstanceNotActiveException();
    }
    Connection conn=null;
    try {
      conn=connectionFactory.create();
      final SerializationService serializationService=getSerializationService();
      final Data request=serializationService.toData(obj);
      conn.write(request);
      stream=new ResponseStreamImpl(serializationService,conn);
    }
 catch (    Exception e) {
      if (e instanceof IOException) {
        if (logger.isFinestEnabled()) {
          logger.finest(""String_Node_Str"" + conn + ""String_Node_Str""+ e);
        }
      }
      if (conn != null) {
        IOUtil.closeResource(conn);
      }
      if (ErrorHandler.isRetryable(e)) {
        if (redoOperation || obj instanceof RetryableRequest) {
          if (logger.isFinestEnabled()) {
            logger.finest(""String_Node_Str"" + obj + ""String_Node_Str""+ conn+ ""String_Node_Str""+ e);
          }
          beforeRetry();
          continue;
        }
      }
      throw ExceptionUtil.rethrow(e,IOException.class);
    }
  }
  try {
    handler.handle(stream);
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e,IOException.class);
  }
 finally {
    stream.end();
  }
}",0.970193740685544
49007,"public void start(){
  final Future<Connection> f=client.getClientExecutionService().submit(new InitialConnectionCall());
  try {
    final Connection connection=f.get(30,TimeUnit.SECONDS);
    clusterThread.setInitialConn(connection);
  }
 catch (  Throwable e) {
    if (e instanceof ExecutionException && e.getCause() != null) {
      e=e.getCause();
      fixRemoteStackTrace(e,Thread.currentThread().getStackTrace());
    }
    if (e instanceof RuntimeException) {
      throw (RuntimeException)e;
    }
    throw new HazelcastException(e);
  }
  clusterThread.start();
  while (membersRef.get() == null) {
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
      throw new HazelcastException(e);
    }
  }
}","public void start(){
  final Future<Connection> f=client.getClientExecutionService().submit(new InitialConnectionCall());
  try {
    final Connection connection=f.get(30,TimeUnit.SECONDS);
    clusterThread.setInitialConn(connection);
  }
 catch (  Throwable e) {
    if (e instanceof ExecutionException && e.getCause() != null) {
      e=e.getCause();
      fixRemoteStackTrace(e,Thread.currentThread().getStackTrace());
    }
    if (e instanceof RuntimeException) {
      throw (RuntimeException)e;
    }
    throw new HazelcastException(e);
  }
  clusterThread.start();
  while (membersRef.get() == null) {
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
      throw new HazelcastException(e);
    }
  }
  active=true;
}",0.9899799599198396
49008,"public void stop(){
  clusterThread.shutdown();
}","public void stop(){
  active=false;
  clusterThread.shutdown();
}",0.8596491228070176
49009,"private <T>T _sendAndReceive(ConnectionFactory connectionFactory,Object obj) throws IOException {
  while (true) {
    Connection conn=null;
    boolean release=true;
    try {
      conn=connectionFactory.create();
      final SerializationService serializationService=getSerializationService();
      final Data request=serializationService.toData(obj);
      conn.write(request);
      final Data response=conn.read();
      final Object result=serializationService.toObject(response);
      return ErrorHandler.returnResultOrThrowException(result);
    }
 catch (    Exception e) {
      if (e instanceof IOException) {
        if (logger.isFinestEnabled()) {
          logger.finest(""String_Node_Str"" + conn + ""String_Node_Str""+ e);
        }
        IOUtil.closeResource(conn);
        release=false;
      }
      if (ErrorHandler.isRetryable(e)) {
        if (redoOperation || obj instanceof RetryableRequest) {
          if (logger.isFinestEnabled()) {
            logger.finest(""String_Node_Str"" + obj + ""String_Node_Str""+ conn+ ""String_Node_Str""+ e);
          }
          beforeRetry();
          continue;
        }
      }
      throw ExceptionUtil.rethrow(e,IOException.class);
    }
 finally {
      if (release && conn != null) {
        conn.release();
      }
    }
  }
}","private <T>T _sendAndReceive(ConnectionFactory connectionFactory,Object obj) throws IOException {
  while (active) {
    Connection conn=null;
    boolean release=true;
    try {
      conn=connectionFactory.create();
      final SerializationService serializationService=getSerializationService();
      final Data request=serializationService.toData(obj);
      conn.write(request);
      final Data response=conn.read();
      final Object result=serializationService.toObject(response);
      return ErrorHandler.returnResultOrThrowException(result);
    }
 catch (    Exception e) {
      if (e instanceof IOException) {
        if (logger.isFinestEnabled()) {
          logger.finest(""String_Node_Str"" + conn + ""String_Node_Str""+ e);
        }
        IOUtil.closeResource(conn);
        release=false;
      }
      if (ErrorHandler.isRetryable(e)) {
        if (redoOperation || obj instanceof RetryableRequest) {
          if (logger.isFinestEnabled()) {
            logger.finest(""String_Node_Str"" + obj + ""String_Node_Str""+ conn+ ""String_Node_Str""+ e);
          }
          beforeRetry();
          continue;
        }
      }
      throw ExceptionUtil.rethrow(e,IOException.class);
    }
 finally {
      if (release && conn != null) {
        conn.release();
      }
    }
  }
  throw new HazelcastInstanceNotActiveException();
}",0.9775921002658564
49010,"private void _sendAndHandle(ConnectionFactory connectionFactory,Object obj,ResponseHandler handler) throws IOException {
  ResponseStream stream=null;
  while (stream == null) {
    Connection conn=null;
    try {
      conn=connectionFactory.create();
      final SerializationService serializationService=getSerializationService();
      final Data request=serializationService.toData(obj);
      conn.write(request);
      stream=new ResponseStreamImpl(serializationService,conn);
    }
 catch (    Exception e) {
      if (e instanceof IOException) {
        if (logger.isFinestEnabled()) {
          logger.finest(""String_Node_Str"" + conn + ""String_Node_Str""+ e);
        }
      }
      if (conn != null) {
        IOUtil.closeResource(conn);
      }
      if (ErrorHandler.isRetryable(e)) {
        if (redoOperation || obj instanceof RetryableRequest) {
          if (logger.isFinestEnabled()) {
            logger.finest(""String_Node_Str"" + obj + ""String_Node_Str""+ conn+ ""String_Node_Str""+ e);
          }
          beforeRetry();
          continue;
        }
      }
      throw ExceptionUtil.rethrow(e,IOException.class);
    }
  }
  try {
    handler.handle(stream);
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e,IOException.class);
  }
 finally {
    stream.end();
  }
}","private void _sendAndHandle(ConnectionFactory connectionFactory,Object obj,ResponseHandler handler) throws IOException {
  ResponseStream stream=null;
  while (stream == null) {
    if (!active) {
      throw new HazelcastInstanceNotActiveException();
    }
    Connection conn=null;
    try {
      conn=connectionFactory.create();
      final SerializationService serializationService=getSerializationService();
      final Data request=serializationService.toData(obj);
      conn.write(request);
      stream=new ResponseStreamImpl(serializationService,conn);
    }
 catch (    Exception e) {
      if (e instanceof IOException) {
        if (logger.isFinestEnabled()) {
          logger.finest(""String_Node_Str"" + conn + ""String_Node_Str""+ e);
        }
      }
      if (conn != null) {
        IOUtil.closeResource(conn);
      }
      if (ErrorHandler.isRetryable(e)) {
        if (redoOperation || obj instanceof RetryableRequest) {
          if (logger.isFinestEnabled()) {
            logger.finest(""String_Node_Str"" + obj + ""String_Node_Str""+ conn+ ""String_Node_Str""+ e);
          }
          beforeRetry();
          continue;
        }
      }
      throw ExceptionUtil.rethrow(e,IOException.class);
    }
  }
  try {
    handler.handle(stream);
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e,IOException.class);
  }
 finally {
    stream.end();
  }
}",0.970193740685544
49011,"public void start(){
  final Future<Connection> f=client.getClientExecutionService().submit(new InitialConnectionCall());
  try {
    final Connection connection=f.get(30,TimeUnit.SECONDS);
    clusterThread.setInitialConn(connection);
  }
 catch (  Throwable e) {
    if (e instanceof ExecutionException && e.getCause() != null) {
      e=e.getCause();
      fixRemoteStackTrace(e,Thread.currentThread().getStackTrace());
    }
    if (e instanceof RuntimeException) {
      throw (RuntimeException)e;
    }
    throw new HazelcastException(e);
  }
  clusterThread.start();
  while (membersRef.get() == null) {
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
      throw new HazelcastException(e);
    }
  }
}","public void start(){
  final Future<Connection> f=client.getClientExecutionService().submit(new InitialConnectionCall());
  try {
    final Connection connection=f.get(30,TimeUnit.SECONDS);
    clusterThread.setInitialConn(connection);
  }
 catch (  Throwable e) {
    if (e instanceof ExecutionException && e.getCause() != null) {
      e=e.getCause();
      fixRemoteStackTrace(e,Thread.currentThread().getStackTrace());
    }
    if (e instanceof RuntimeException) {
      throw (RuntimeException)e;
    }
    throw new HazelcastException(e);
  }
  clusterThread.start();
  while (membersRef.get() == null) {
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
      throw new HazelcastException(e);
    }
  }
  active=true;
}",0.9899799599198396
49012,"public void stop(){
  clusterThread.shutdown();
}","public void stop(){
  active=false;
  clusterThread.shutdown();
}",0.8596491228070176
49013,"private <T>T _sendAndReceive(ConnectionFactory connectionFactory,Object obj) throws IOException {
  while (true) {
    Connection conn=null;
    boolean release=true;
    try {
      conn=connectionFactory.create();
      final SerializationService serializationService=getSerializationService();
      final Data request=serializationService.toData(obj);
      conn.write(request);
      final Data response=conn.read();
      final Object result=serializationService.toObject(response);
      return ErrorHandler.returnResultOrThrowException(result);
    }
 catch (    Exception e) {
      if (e instanceof IOException) {
        if (logger.isFinestEnabled()) {
          logger.finest(""String_Node_Str"" + conn + ""String_Node_Str""+ e);
        }
        IOUtil.closeResource(conn);
        release=false;
      }
      if (ErrorHandler.isRetryable(e)) {
        if (redoOperation || obj instanceof RetryableRequest) {
          if (logger.isFinestEnabled()) {
            logger.finest(""String_Node_Str"" + obj + ""String_Node_Str""+ conn+ ""String_Node_Str""+ e);
          }
          beforeRetry();
          continue;
        }
      }
      throw ExceptionUtil.rethrow(e,IOException.class);
    }
 finally {
      if (release && conn != null) {
        conn.release();
      }
    }
  }
}","private <T>T _sendAndReceive(ConnectionFactory connectionFactory,Object obj) throws IOException {
  while (active) {
    Connection conn=null;
    boolean release=true;
    try {
      conn=connectionFactory.create();
      final SerializationService serializationService=getSerializationService();
      final Data request=serializationService.toData(obj);
      conn.write(request);
      final Data response=conn.read();
      final Object result=serializationService.toObject(response);
      return ErrorHandler.returnResultOrThrowException(result);
    }
 catch (    Exception e) {
      if (e instanceof IOException) {
        if (logger.isFinestEnabled()) {
          logger.finest(""String_Node_Str"" + conn + ""String_Node_Str""+ e);
        }
        IOUtil.closeResource(conn);
        release=false;
      }
      if (ErrorHandler.isRetryable(e)) {
        if (redoOperation || obj instanceof RetryableRequest) {
          if (logger.isFinestEnabled()) {
            logger.finest(""String_Node_Str"" + obj + ""String_Node_Str""+ conn+ ""String_Node_Str""+ e);
          }
          beforeRetry();
          continue;
        }
      }
      throw ExceptionUtil.rethrow(e,IOException.class);
    }
 finally {
      if (release && conn != null) {
        conn.release();
      }
    }
  }
  throw new HazelcastInstanceNotActiveException();
}",0.9775921002658564
49014,"private void _sendAndHandle(ConnectionFactory connectionFactory,Object obj,ResponseHandler handler) throws IOException {
  ResponseStream stream=null;
  while (stream == null) {
    Connection conn=null;
    try {
      conn=connectionFactory.create();
      final SerializationService serializationService=getSerializationService();
      final Data request=serializationService.toData(obj);
      conn.write(request);
      stream=new ResponseStreamImpl(serializationService,conn);
    }
 catch (    Exception e) {
      if (e instanceof IOException) {
        if (logger.isFinestEnabled()) {
          logger.finest(""String_Node_Str"" + conn + ""String_Node_Str""+ e);
        }
      }
      if (conn != null) {
        IOUtil.closeResource(conn);
      }
      if (ErrorHandler.isRetryable(e)) {
        if (redoOperation || obj instanceof RetryableRequest) {
          if (logger.isFinestEnabled()) {
            logger.finest(""String_Node_Str"" + obj + ""String_Node_Str""+ conn+ ""String_Node_Str""+ e);
          }
          beforeRetry();
          continue;
        }
      }
      throw ExceptionUtil.rethrow(e,IOException.class);
    }
  }
  try {
    handler.handle(stream);
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e,IOException.class);
  }
 finally {
    stream.end();
  }
}","private void _sendAndHandle(ConnectionFactory connectionFactory,Object obj,ResponseHandler handler) throws IOException {
  ResponseStream stream=null;
  while (stream == null) {
    if (active) {
      throw new HazelcastInstanceNotActiveException();
    }
    Connection conn=null;
    try {
      conn=connectionFactory.create();
      final SerializationService serializationService=getSerializationService();
      final Data request=serializationService.toData(obj);
      conn.write(request);
      stream=new ResponseStreamImpl(serializationService,conn);
    }
 catch (    Exception e) {
      if (e instanceof IOException) {
        if (logger.isFinestEnabled()) {
          logger.finest(""String_Node_Str"" + conn + ""String_Node_Str""+ e);
        }
      }
      if (conn != null) {
        IOUtil.closeResource(conn);
      }
      if (ErrorHandler.isRetryable(e)) {
        if (redoOperation || obj instanceof RetryableRequest) {
          if (logger.isFinestEnabled()) {
            logger.finest(""String_Node_Str"" + obj + ""String_Node_Str""+ conn+ ""String_Node_Str""+ e);
          }
          beforeRetry();
          continue;
        }
      }
      throw ExceptionUtil.rethrow(e,IOException.class);
    }
  }
  try {
    handler.handle(stream);
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e,IOException.class);
  }
 finally {
    stream.end();
  }
}",0.9705553484904956
49015,"public void start(){
  final Future<Connection> f=client.getClientExecutionService().submit(new InitialConnectionCall());
  try {
    final Connection connection=f.get(30,TimeUnit.SECONDS);
    clusterThread.setInitialConn(connection);
  }
 catch (  Throwable e) {
    if (e instanceof ExecutionException && e.getCause() != null) {
      e=e.getCause();
      fixRemoteStackTrace(e,Thread.currentThread().getStackTrace());
    }
    if (e instanceof RuntimeException) {
      throw (RuntimeException)e;
    }
    throw new HazelcastException(e);
  }
  clusterThread.start();
  while (membersRef.get() == null) {
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
      throw new HazelcastException(e);
    }
  }
}","public void start(){
  final Future<Connection> f=client.getClientExecutionService().submit(new InitialConnectionCall());
  try {
    final Connection connection=f.get(30,TimeUnit.SECONDS);
    clusterThread.setInitialConn(connection);
  }
 catch (  Throwable e) {
    if (e instanceof ExecutionException && e.getCause() != null) {
      e=e.getCause();
      fixRemoteStackTrace(e,Thread.currentThread().getStackTrace());
    }
    if (e instanceof RuntimeException) {
      throw (RuntimeException)e;
    }
    throw new HazelcastException(e);
  }
  clusterThread.start();
  while (membersRef.get() == null) {
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
      throw new HazelcastException(e);
    }
  }
  active=true;
}",0.9899799599198396
49016,"public void stop(){
  clusterThread.shutdown();
}","public void stop(){
  active=false;
  clusterThread.shutdown();
}",0.8596491228070176
49017,"private <T>T _sendAndReceive(ConnectionFactory connectionFactory,Object obj) throws IOException {
  while (true) {
    Connection conn=null;
    boolean release=true;
    try {
      conn=connectionFactory.create();
      final SerializationService serializationService=getSerializationService();
      final Data request=serializationService.toData(obj);
      conn.write(request);
      final Data response=conn.read();
      final Object result=serializationService.toObject(response);
      return ErrorHandler.returnResultOrThrowException(result);
    }
 catch (    Exception e) {
      if (e instanceof IOException) {
        if (logger.isFinestEnabled()) {
          logger.finest(""String_Node_Str"" + conn + ""String_Node_Str""+ e);
        }
        IOUtil.closeResource(conn);
        release=false;
      }
      if (ErrorHandler.isRetryable(e)) {
        if (redoOperation || obj instanceof RetryableRequest) {
          if (logger.isFinestEnabled()) {
            logger.finest(""String_Node_Str"" + obj + ""String_Node_Str""+ conn+ ""String_Node_Str""+ e);
          }
          beforeRetry();
          continue;
        }
      }
      throw ExceptionUtil.rethrow(e,IOException.class);
    }
 finally {
      if (release && conn != null) {
        conn.release();
      }
    }
  }
}","private <T>T _sendAndReceive(ConnectionFactory connectionFactory,Object obj) throws IOException {
  while (active) {
    Connection conn=null;
    boolean release=true;
    try {
      conn=connectionFactory.create();
      final SerializationService serializationService=getSerializationService();
      final Data request=serializationService.toData(obj);
      conn.write(request);
      final Data response=conn.read();
      final Object result=serializationService.toObject(response);
      return ErrorHandler.returnResultOrThrowException(result);
    }
 catch (    Exception e) {
      if (e instanceof IOException) {
        if (logger.isFinestEnabled()) {
          logger.finest(""String_Node_Str"" + conn + ""String_Node_Str""+ e);
        }
        IOUtil.closeResource(conn);
        release=false;
      }
      if (ErrorHandler.isRetryable(e)) {
        if (redoOperation || obj instanceof RetryableRequest) {
          if (logger.isFinestEnabled()) {
            logger.finest(""String_Node_Str"" + obj + ""String_Node_Str""+ conn+ ""String_Node_Str""+ e);
          }
          beforeRetry();
          continue;
        }
      }
      throw ExceptionUtil.rethrow(e,IOException.class);
    }
 finally {
      if (release && conn != null) {
        conn.release();
      }
    }
  }
  throw new HazelcastInstanceNotActiveException();
}",0.9775921002658564
49018,"@SuppressWarnings(""String_Node_Str"") public TransactionalObject getTransactionalObject(String serviceName,Object id){
  if (transaction.getState() != Transaction.State.ACTIVE) {
    throw new TransactionNotActiveException(""String_Node_Str"" + ""String_Node_Str"" + serviceName + ""String_Node_Str""+ id+ ""String_Node_Str"");
  }
  TransactionalObjectKey key=new TransactionalObjectKey(serviceName,id);
  TransactionalObject obj=txnObjectMap.get(key);
  if (obj == null) {
    final Object service=nodeEngine.getService(serviceName);
    if (service instanceof TransactionalService) {
      obj=((TransactionalService)service).createTransactionalObject(id,transaction);
      txnObjectMap.put(key,obj);
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + serviceName + ""String_Node_Str"");
    }
  }
  return obj;
}","@SuppressWarnings(""String_Node_Str"") public TransactionalObject getTransactionalObject(String serviceName,Object id){
  if (transaction.getState() != Transaction.State.ACTIVE) {
    throw new TransactionNotActiveException(""String_Node_Str"" + ""String_Node_Str"" + serviceName + ""String_Node_Str""+ id+ ""String_Node_Str"");
  }
  TransactionalObjectKey key=new TransactionalObjectKey(serviceName,id);
  TransactionalObject obj=txnObjectMap.get(key);
  if (obj == null) {
    final Object service=nodeEngine.getService(serviceName);
    if (service instanceof TransactionalService) {
      nodeEngine.getProxyService().initializeDistributedObject(serviceName,id);
      obj=((TransactionalService)service).createTransactionalObject(id,transaction);
      txnObjectMap.put(key,obj);
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + serviceName + ""String_Node_Str"");
    }
  }
  return obj;
}",0.9540229885057472
49019,"@SuppressWarnings(""String_Node_Str"") public TransactionalObject getTransactionalObject(String serviceName,Object id){
  if (transaction.getState() != Transaction.State.ACTIVE) {
    throw new TransactionNotActiveException(""String_Node_Str"" + ""String_Node_Str"" + serviceName + ""String_Node_Str""+ id+ ""String_Node_Str"");
  }
  TransactionalObjectKey key=new TransactionalObjectKey(serviceName,id);
  TransactionalObject obj=txnObjectMap.get(key);
  if (obj == null) {
    final Object service=nodeEngine.getService(serviceName);
    if (service instanceof TransactionalService) {
      obj=((TransactionalService)service).createTransactionalObject(id,transaction);
      txnObjectMap.put(key,obj);
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + serviceName + ""String_Node_Str"");
    }
  }
  return obj;
}","@SuppressWarnings(""String_Node_Str"") public TransactionalObject getTransactionalObject(String serviceName,Object id){
  if (transaction.getState() != Transaction.State.ACTIVE) {
    throw new TransactionNotActiveException(""String_Node_Str"" + ""String_Node_Str"" + serviceName + ""String_Node_Str""+ id+ ""String_Node_Str"");
  }
  TransactionalObjectKey key=new TransactionalObjectKey(serviceName,id);
  TransactionalObject obj=txnObjectMap.get(key);
  if (obj == null) {
    final Object service=nodeEngine.getService(serviceName);
    if (service instanceof TransactionalService) {
      nodeEngine.getProxyService().initializeDistributedObject(serviceName,id);
      obj=((TransactionalService)service).createTransactionalObject(id,transaction);
      txnObjectMap.put(key,obj);
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + serviceName + ""String_Node_Str"");
    }
  }
  return obj;
}",0.9540229885057472
49020,"private void _sendAndHandle(ConnectionFactory connectionFactory,Object obj,ResponseHandler handler) throws IOException {
  ResponseStream stream=null;
  while (stream == null) {
    Connection conn=null;
    try {
      conn=connectionFactory.create();
      final SerializationService serializationService=getSerializationService();
      final Data request=serializationService.toData(obj);
      conn.write(request);
      stream=new ResponseStreamImpl(serializationService,conn);
    }
 catch (    Exception e) {
      if (e instanceof IOException) {
        if (logger.isFinestEnabled()) {
          logger.finest(""String_Node_Str"" + conn + ""String_Node_Str""+ e);
        }
      }
      if (conn != null) {
        IOUtil.closeResource(conn);
      }
      if (ErrorHandler.isRetryable(e)) {
        if (redoOperation || obj instanceof RetryableRequest) {
          if (logger.isFinestEnabled()) {
            logger.finest(""String_Node_Str"" + obj + ""String_Node_Str""+ conn+ ""String_Node_Str""+ e);
          }
          beforeRetry();
          continue;
        }
      }
      throw ExceptionUtil.rethrow(e,IOException.class);
    }
  }
  try {
    handler.handle(stream);
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e,IOException.class);
  }
 finally {
    stream.end();
  }
}","private void _sendAndHandle(ConnectionFactory connectionFactory,Object obj,ResponseHandler handler) throws IOException {
  ResponseStream stream=null;
  while (stream == null) {
    if (active) {
      throw new HazelcastInstanceNotActiveException();
    }
    Connection conn=null;
    try {
      conn=connectionFactory.create();
      final SerializationService serializationService=getSerializationService();
      final Data request=serializationService.toData(obj);
      conn.write(request);
      stream=new ResponseStreamImpl(serializationService,conn);
    }
 catch (    Exception e) {
      if (e instanceof IOException) {
        if (logger.isFinestEnabled()) {
          logger.finest(""String_Node_Str"" + conn + ""String_Node_Str""+ e);
        }
      }
      if (conn != null) {
        IOUtil.closeResource(conn);
      }
      if (ErrorHandler.isRetryable(e)) {
        if (redoOperation || obj instanceof RetryableRequest) {
          if (logger.isFinestEnabled()) {
            logger.finest(""String_Node_Str"" + obj + ""String_Node_Str""+ conn+ ""String_Node_Str""+ e);
          }
          beforeRetry();
          continue;
        }
      }
      throw ExceptionUtil.rethrow(e,IOException.class);
    }
  }
  try {
    handler.handle(stream);
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e,IOException.class);
  }
 finally {
    stream.end();
  }
}",0.9705553484904956
49021,"public void start(){
  final Future<Connection> f=client.getClientExecutionService().submit(new InitialConnectionCall());
  try {
    final Connection connection=f.get(30,TimeUnit.SECONDS);
    clusterThread.setInitialConn(connection);
  }
 catch (  Throwable e) {
    if (e instanceof ExecutionException && e.getCause() != null) {
      e=e.getCause();
      fixRemoteStackTrace(e,Thread.currentThread().getStackTrace());
    }
    if (e instanceof RuntimeException) {
      throw (RuntimeException)e;
    }
    throw new HazelcastException(e);
  }
  clusterThread.start();
  while (membersRef.get() == null) {
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
      throw new HazelcastException(e);
    }
  }
}","public void start(){
  final Future<Connection> f=client.getClientExecutionService().submit(new InitialConnectionCall());
  try {
    final Connection connection=f.get(30,TimeUnit.SECONDS);
    clusterThread.setInitialConn(connection);
  }
 catch (  Throwable e) {
    if (e instanceof ExecutionException && e.getCause() != null) {
      e=e.getCause();
      fixRemoteStackTrace(e,Thread.currentThread().getStackTrace());
    }
    if (e instanceof RuntimeException) {
      throw (RuntimeException)e;
    }
    throw new HazelcastException(e);
  }
  clusterThread.start();
  while (membersRef.get() == null) {
    try {
      Thread.sleep(100);
    }
 catch (    InterruptedException e) {
      throw new HazelcastException(e);
    }
  }
  active=true;
}",0.9899799599198396
49022,"public void stop(){
  clusterThread.shutdown();
}","public void stop(){
  active=false;
  clusterThread.shutdown();
}",0.8596491228070176
49023,"private <T>T _sendAndReceive(ConnectionFactory connectionFactory,Object obj) throws IOException {
  while (true) {
    Connection conn=null;
    boolean release=true;
    try {
      conn=connectionFactory.create();
      final SerializationService serializationService=getSerializationService();
      final Data request=serializationService.toData(obj);
      conn.write(request);
      final Data response=conn.read();
      final Object result=serializationService.toObject(response);
      return ErrorHandler.returnResultOrThrowException(result);
    }
 catch (    Exception e) {
      if (e instanceof IOException) {
        if (logger.isFinestEnabled()) {
          logger.finest(""String_Node_Str"" + conn + ""String_Node_Str""+ e);
        }
        IOUtil.closeResource(conn);
        release=false;
      }
      if (ErrorHandler.isRetryable(e)) {
        if (redoOperation || obj instanceof RetryableRequest) {
          if (logger.isFinestEnabled()) {
            logger.finest(""String_Node_Str"" + obj + ""String_Node_Str""+ conn+ ""String_Node_Str""+ e);
          }
          beforeRetry();
          continue;
        }
      }
      throw ExceptionUtil.rethrow(e,IOException.class);
    }
 finally {
      if (release && conn != null) {
        conn.release();
      }
    }
  }
}","private <T>T _sendAndReceive(ConnectionFactory connectionFactory,Object obj) throws IOException {
  while (active) {
    Connection conn=null;
    boolean release=true;
    try {
      conn=connectionFactory.create();
      final SerializationService serializationService=getSerializationService();
      final Data request=serializationService.toData(obj);
      conn.write(request);
      final Data response=conn.read();
      final Object result=serializationService.toObject(response);
      return ErrorHandler.returnResultOrThrowException(result);
    }
 catch (    Exception e) {
      if (e instanceof IOException) {
        if (logger.isFinestEnabled()) {
          logger.finest(""String_Node_Str"" + conn + ""String_Node_Str""+ e);
        }
        IOUtil.closeResource(conn);
        release=false;
      }
      if (ErrorHandler.isRetryable(e)) {
        if (redoOperation || obj instanceof RetryableRequest) {
          if (logger.isFinestEnabled()) {
            logger.finest(""String_Node_Str"" + obj + ""String_Node_Str""+ conn+ ""String_Node_Str""+ e);
          }
          beforeRetry();
          continue;
        }
      }
      throw ExceptionUtil.rethrow(e,IOException.class);
    }
 finally {
      if (release && conn != null) {
        conn.release();
      }
    }
  }
  throw new HazelcastInstanceNotActiveException();
}",0.9775921002658564
49024,"public void run(){
  int partitionId=getPartitionId();
  RecordStore recordStore=mapService.getRecordStore(partitionId,name);
  entrySet=new MapEntrySet();
  for (  Data key : keys) {
    if (partitionId == getNodeEngine().getPartitionService().getPartitionId(key)) {
      Object value=recordStore.get(key);
      if (value != null) {
        entrySet.add(new AbstractMap.SimpleImmutableEntry(key,mapService.toData(value)));
      }
    }
  }
}","public void run(){
  int partitionId=getPartitionId();
  RecordStore recordStore=mapService.getRecordStore(partitionId,name);
  Set<Data> partitionKeySet=new HashSet<Data>();
  for (  Data key : keys) {
    if (partitionId == getNodeEngine().getPartitionService().getPartitionId(key)) {
      partitionKeySet.add(key);
    }
  }
  entrySet=recordStore.getAll(partitionKeySet);
}",0.3596597812879708
49025,"@Override public Collection<DistributedObject> getDistributedObjects(){
  try {
    GetDistributedObjectsRequest request=new GetDistributedObjectsRequest();
    final SerializableCollection serializableCollection=(SerializableCollection)invocationService.invokeOnRandomTarget(request);
    final ArrayList<DistributedObject> coll=new ArrayList<DistributedObject>(serializableCollection.size());
    for (    Data data : serializableCollection) {
      final DistributedObjectInfo o=(DistributedObjectInfo)serializationService.toObject(data);
      coll.add(getDistributedObject(o.getServiceName(),o.getId()));
    }
    return coll;
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e);
  }
}","@Override public Collection<DistributedObject> getDistributedObjects(){
  try {
    GetDistributedObjectsRequest request=new GetDistributedObjectsRequest();
    final SerializableCollection serializableCollection=(SerializableCollection)invocationService.invokeOnRandomTarget(request);
    for (    Data data : serializableCollection) {
      final DistributedObjectInfo o=(DistributedObjectInfo)serializationService.toObject(data);
      getDistributedObject(o.getServiceName(),o.getId());
    }
    return (Collection<DistributedObject>)proxyManager.getDistributedObjects();
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e);
  }
}",0.6666666666666666
49026,"public void shutdown(){
  final Collection<MemberImpl> memberList=getContext().getClusterService().getMemberList();
  for (  MemberImpl member : memberList) {
    ShutdownRequest request=new ShutdownRequest(name,member.getAddress());
    invoke(request,member.getAddress());
  }
}","public void shutdown(){
  ShutdownRequest request=new ShutdownRequest(name);
  invoke(request);
}",0.5145888594164456
49027,"protected void onDestroy(){
  LockDestroyRequest request=new LockDestroyRequest(getKeyData());
  invoke(request);
}","protected void onDestroy(){
  LockDestroyRequest request=new LockDestroyRequest(getId());
  invoke(request);
}",0.96
49028,"public Object call() throws Exception {
  final CollectionService service=getService();
  service.destroyDistributedObject(proxyId);
  return null;
}","public Object call() throws Exception {
  getClientEngine().getProxyService().destroyDistributedObject(getServiceName(),proxyId);
  return null;
}",0.7186440677966102
49029,"public Object call() throws Exception {
  final AtomicLongService service=getService();
  service.destroyDistributedObject(name);
  return null;
}","public Object call() throws Exception {
  getClientEngine().getProxyService().destroyDistributedObject(getServiceName(),name);
  return null;
}",0.71280276816609
49030,"public Object call() throws Exception {
  return null;
}","public Object call() throws Exception {
  getClientEngine().getProxyService().destroyDistributedObject(getServiceName(),name);
  return null;
}",0.5628140703517588
49031,"public Object call() throws Exception {
  final LockServiceImpl service=getService();
  service.destroyDistributedObject(keyData);
  return null;
}","public Object call() throws Exception {
  getClientEngine().getProxyService().destroyDistributedObject(getServiceName(),objectId);
  return null;
}",0.6938775510204082
49032,"public LockDestroyRequest(Data keyData){
  this.keyData=keyData;
}","public LockDestroyRequest(Object objectId){
  this.objectId=objectId;
}",0.7007299270072993
49033,"public void writePortable(PortableWriter writer) throws IOException {
  keyData.writeData(writer.getRawDataOutput());
}","public void writePortable(PortableWriter writer) throws IOException {
  writer.getRawDataOutput().writeObject(objectId);
}",0.8381742738589212
49034,"public void readPortable(PortableReader reader) throws IOException {
  keyData=new Data();
  keyData.readData(reader.getRawDataInput());
}","public void readPortable(PortableReader reader) throws IOException {
  objectId=reader.getRawDataInput().readObject();
}",0.7906976744186046
49035,"public Object call() throws Exception {
  SemaphoreService service=getService();
  service.destroyDistributedObject(name);
  return null;
}","public Object call() throws Exception {
  getClientEngine().getProxyService().destroyDistributedObject(getServiceName(),name);
  return null;
}",0.7304964539007093
49036,"public ShutdownRequest(String name,Address target){
  this.name=name;
  this.target=target;
}","public ShutdownRequest(String name){
  this.name=name;
}",0.7516778523489933
49037,"@Override public Object call(){
  final MapService mapService=getService();
  mapService.destroyDistributedObject(name);
  return true;
}","@Override public Object call(){
  getClientEngine().getProxyService().destroyDistributedObject(getServiceName(),name);
  return true;
}",0.6985294117647058
49038,"public Object call() throws Exception {
  final QueueService service=getService();
  service.destroyDistributedObject(name);
  return null;
}","public Object call() throws Exception {
  getClientEngine().getProxyService().destroyDistributedObject(getServiceName(),name);
  return null;
}",0.7253521126760564
49039,"public Object call() throws Exception {
  final TopicService service=getService();
  service.destroyDistributedObject(name);
  return null;
}","public Object call() throws Exception {
  getClientEngine().getProxyService().destroyDistributedObject(getServiceName(),name);
  return null;
}",0.7253521126760564
49040,"@Override public Collection<DistributedObject> getDistributedObjects(){
  try {
    GetDistributedObjectsRequest request=new GetDistributedObjectsRequest();
    final SerializableCollection serializableCollection=(SerializableCollection)invocationService.invokeOnRandomTarget(request);
    final ArrayList<DistributedObject> coll=new ArrayList<DistributedObject>(serializableCollection.size());
    for (    Data data : serializableCollection) {
      final DistributedObjectInfo o=(DistributedObjectInfo)serializationService.toObject(data);
      coll.add(getDistributedObject(o.getServiceName(),o.getId()));
    }
    return coll;
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e);
  }
}","@Override public Collection<DistributedObject> getDistributedObjects(){
  try {
    GetDistributedObjectsRequest request=new GetDistributedObjectsRequest();
    final SerializableCollection serializableCollection=(SerializableCollection)invocationService.invokeOnRandomTarget(request);
    for (    Data data : serializableCollection) {
      final DistributedObjectInfo o=(DistributedObjectInfo)serializationService.toObject(data);
      getDistributedObject(o.getServiceName(),o.getId());
    }
    return (Collection<DistributedObject>)proxyManager.getDistributedObjects();
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e);
  }
}",0.6666666666666666
49041,"public void shutdown(){
  final Collection<MemberImpl> memberList=getContext().getClusterService().getMemberList();
  for (  MemberImpl member : memberList) {
    ShutdownRequest request=new ShutdownRequest(name,member.getAddress());
    invoke(request,member.getAddress());
  }
}","public void shutdown(){
  ShutdownRequest request=new ShutdownRequest(name);
  invoke(request);
}",0.5145888594164456
49042,"protected void onDestroy(){
  LockDestroyRequest request=new LockDestroyRequest(getKeyData());
  invoke(request);
}","protected void onDestroy(){
  LockDestroyRequest request=new LockDestroyRequest(getId());
  invoke(request);
}",0.96
49043,"public Object call() throws Exception {
  final CollectionService service=getService();
  service.destroyDistributedObject(proxyId);
  return null;
}","public Object call() throws Exception {
  getClientEngine().getProxyService().destroyDistributedObject(getServiceName(),proxyId);
  return null;
}",0.7186440677966102
49044,"public Object call() throws Exception {
  final AtomicLongService service=getService();
  service.destroyDistributedObject(name);
  return null;
}","public Object call() throws Exception {
  getClientEngine().getProxyService().destroyDistributedObject(getServiceName(),name);
  return null;
}",0.71280276816609
49045,"public Object call() throws Exception {
  return null;
}","public Object call() throws Exception {
  getClientEngine().getProxyService().destroyDistributedObject(getServiceName(),name);
  return null;
}",0.5628140703517588
49046,"public Object call() throws Exception {
  final LockServiceImpl service=getService();
  service.destroyDistributedObject(keyData);
  return null;
}","public Object call() throws Exception {
  getClientEngine().getProxyService().destroyDistributedObject(getServiceName(),objectId);
  return null;
}",0.6938775510204082
49047,"public LockDestroyRequest(Data keyData){
  this.keyData=keyData;
}","public LockDestroyRequest(Object objectId){
  this.objectId=objectId;
}",0.7007299270072993
49048,"public void writePortable(PortableWriter writer) throws IOException {
  keyData.writeData(writer.getRawDataOutput());
}","public void writePortable(PortableWriter writer) throws IOException {
  writer.getRawDataOutput().writeObject(objectId);
}",0.8381742738589212
49049,"public void readPortable(PortableReader reader) throws IOException {
  keyData=new Data();
  keyData.readData(reader.getRawDataInput());
}","public void readPortable(PortableReader reader) throws IOException {
  objectId=reader.getRawDataInput().readObject();
}",0.7906976744186046
49050,"public Object call() throws Exception {
  SemaphoreService service=getService();
  service.destroyDistributedObject(name);
  return null;
}","public Object call() throws Exception {
  getClientEngine().getProxyService().destroyDistributedObject(getServiceName(),name);
  return null;
}",0.7304964539007093
49051,"public ShutdownRequest(String name,Address target){
  this.name=name;
  this.target=target;
}","public ShutdownRequest(String name){
  this.name=name;
}",0.7516778523489933
49052,"@Override public Object call(){
  final MapService mapService=getService();
  mapService.destroyDistributedObject(name);
  return true;
}","@Override public Object call(){
  getClientEngine().getProxyService().destroyDistributedObject(getServiceName(),name);
  return true;
}",0.6985294117647058
49053,"public Object call() throws Exception {
  final QueueService service=getService();
  service.destroyDistributedObject(name);
  return null;
}","public Object call() throws Exception {
  getClientEngine().getProxyService().destroyDistributedObject(getServiceName(),name);
  return null;
}",0.7253521126760564
49054,"public Object call() throws Exception {
  final TopicService service=getService();
  service.destroyDistributedObject(name);
  return null;
}","public Object call() throws Exception {
  getClientEngine().getProxyService().destroyDistributedObject(getServiceName(),name);
  return null;
}",0.7253521126760564
49055,"private boolean checkLimits(MapContainer mapContainer){
  MaxSizeConfig maxSizeConfig=mapContainer.getMapConfig().getMaxSizeConfig();
  MaxSizeConfig.MaxSizePolicy maxSizePolicy=maxSizeConfig.getMaxSizePolicy();
  String mapName=mapContainer.getName();
  int maxSize=maxSizeConfig.getSize() * 95 / 100;
  if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_NODE || maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_PARTITION) {
    int totalSize=0;
    for (int i=0; i < nodeEngine.getPartitionService().getPartitionCount(); i++) {
      Address owner=nodeEngine.getPartitionService().getPartitionOwner(i);
      if (nodeEngine.getThisAddress().equals(owner)) {
        final PartitionContainer container=partitionContainers[i];
        if (container == null) {
          return false;
        }
        int size=container.getRecordStore(mapName).getRecords().size();
        if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_PARTITION) {
          if (size >= maxSize) {
            return true;
          }
        }
 else {
          totalSize+=size;
        }
      }
    }
    return maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_NODE && totalSize >= maxSize;
  }
  if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.USED_HEAP_SIZE || maxSizePolicy == MaxSizeConfig.MaxSizePolicy.USED_HEAP_PERCENTAGE) {
    long total=Runtime.getRuntime().totalMemory();
    long used=(total - Runtime.getRuntime().freeMemory());
    if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.USED_HEAP_SIZE) {
      return maxSize > (used / 1024 / 1024);
    }
 else {
      return maxSize > (used / total);
    }
  }
  return false;
}","private boolean checkLimits(MapContainer mapContainer){
  MaxSizeConfig maxSizeConfig=mapContainer.getMapConfig().getMaxSizeConfig();
  MaxSizeConfig.MaxSizePolicy maxSizePolicy=maxSizeConfig.getMaxSizePolicy();
  String mapName=mapContainer.getName();
  int maxSize=maxSizeConfig.getSize() * 95 / 100;
  if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_NODE || maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_PARTITION) {
    int totalSize=0;
    for (int i=0; i < nodeEngine.getPartitionService().getPartitionCount(); i++) {
      Address owner=nodeEngine.getPartitionService().getPartitionOwner(i);
      if (nodeEngine.getThisAddress().equals(owner)) {
        final PartitionContainer container=partitionContainers[i];
        if (container == null) {
          return false;
        }
        int size=container.getRecordStore(mapName).getRecords().size();
        if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_PARTITION) {
          if (size >= maxSize) {
            return true;
          }
        }
 else {
          totalSize+=size;
        }
      }
    }
    return maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_NODE && totalSize >= maxSize;
  }
  if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.USED_HEAP_SIZE || maxSizePolicy == MaxSizeConfig.MaxSizePolicy.USED_HEAP_PERCENTAGE) {
    long total=Runtime.getRuntime().totalMemory();
    long used=(total - Runtime.getRuntime().freeMemory());
    if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.USED_HEAP_SIZE) {
      return maxSize < (used / 1024 / 1024);
    }
 else {
      return maxSize < (used / total);
    }
  }
  return false;
}",0.9987646695491044
49056,"private boolean checkLimits(MapContainer mapContainer){
  MaxSizeConfig maxSizeConfig=mapContainer.getMapConfig().getMaxSizeConfig();
  MaxSizeConfig.MaxSizePolicy maxSizePolicy=maxSizeConfig.getMaxSizePolicy();
  String mapName=mapContainer.getName();
  int maxSize=maxSizeConfig.getSize() * 95 / 100;
  if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_NODE || maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_PARTITION) {
    int totalSize=0;
    for (int i=0; i < nodeEngine.getPartitionService().getPartitionCount(); i++) {
      Address owner=nodeEngine.getPartitionService().getPartitionOwner(i);
      if (nodeEngine.getThisAddress().equals(owner)) {
        final PartitionContainer container=partitionContainers[i];
        if (container == null) {
          return false;
        }
        int size=container.getRecordStore(mapName).getRecords().size();
        if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_PARTITION) {
          if (size >= maxSize) {
            return true;
          }
        }
 else {
          totalSize+=size;
        }
      }
    }
    return maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_NODE && totalSize >= maxSize;
  }
  if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.USED_HEAP_SIZE || maxSizePolicy == MaxSizeConfig.MaxSizePolicy.USED_HEAP_PERCENTAGE) {
    long total=Runtime.getRuntime().totalMemory();
    long used=(total - Runtime.getRuntime().freeMemory());
    if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.USED_HEAP_SIZE) {
      return maxSize > (used / 1024 / 1024);
    }
 else {
      return maxSize > (used / total);
    }
  }
  return false;
}","private boolean checkLimits(MapContainer mapContainer){
  MaxSizeConfig maxSizeConfig=mapContainer.getMapConfig().getMaxSizeConfig();
  MaxSizeConfig.MaxSizePolicy maxSizePolicy=maxSizeConfig.getMaxSizePolicy();
  String mapName=mapContainer.getName();
  int maxSize=maxSizeConfig.getSize() * 95 / 100;
  if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_NODE || maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_PARTITION) {
    int totalSize=0;
    for (int i=0; i < nodeEngine.getPartitionService().getPartitionCount(); i++) {
      Address owner=nodeEngine.getPartitionService().getPartitionOwner(i);
      if (nodeEngine.getThisAddress().equals(owner)) {
        final PartitionContainer container=partitionContainers[i];
        if (container == null) {
          return false;
        }
        int size=container.getRecordStore(mapName).getRecords().size();
        if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_PARTITION) {
          if (size >= maxSize) {
            return true;
          }
        }
 else {
          totalSize+=size;
        }
      }
    }
    return maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_NODE && totalSize >= maxSize;
  }
  if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.USED_HEAP_SIZE || maxSizePolicy == MaxSizeConfig.MaxSizePolicy.USED_HEAP_PERCENTAGE) {
    long total=Runtime.getRuntime().totalMemory();
    long used=(total - Runtime.getRuntime().freeMemory());
    if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.USED_HEAP_SIZE) {
      return maxSize < (used / 1024 / 1024);
    }
 else {
      return maxSize < (used / total);
    }
  }
  return false;
}",0.9987646695491044
49057,"public void run(){
  int partitionId=getPartitionId();
  RecordStore recordStore=mapService.getRecordStore(partitionId,name);
  entrySet=new MapEntrySet();
  for (  Data key : keys) {
    if (partitionId == getNodeEngine().getPartitionService().getPartitionId(key)) {
      Object value=recordStore.get(key);
      if (value != null) {
        entrySet.add(new AbstractMap.SimpleImmutableEntry(key,mapService.toData(value)));
      }
    }
  }
}","public void run(){
  int partitionId=getPartitionId();
  RecordStore recordStore=mapService.getRecordStore(partitionId,name);
  Set<Data> partitionKeySet=new HashSet<Data>();
  for (  Data key : keys) {
    if (partitionId == getNodeEngine().getPartitionService().getPartitionId(key)) {
      partitionKeySet.add(key);
    }
  }
  entrySet=recordStore.getAll(partitionKeySet);
}",0.3596597812879708
49058,"protected Set query(final Predicate predicate,final IterationType iterationType,final boolean dataResult){
  final NodeEngine nodeEngine=getNodeEngine();
  OperationService operationService=nodeEngine.getOperationService();
  Collection<MemberImpl> members=nodeEngine.getClusterService().getMemberList();
  int partitionCount=nodeEngine.getPartitionService().getPartitionCount();
  Set<Integer> plist=new HashSet<Integer>(partitionCount);
  QueryResultSet result=new QueryResultSet(nodeEngine.getSerializationService(),iterationType,dataResult);
  try {
    List<Future> flist=new ArrayList<Future>();
    for (    MemberImpl member : members) {
      Invocation invocation=operationService.createInvocationBuilder(SERVICE_NAME,new QueryOperation(name,predicate),member.getAddress()).build();
      Future future=invocation.invoke();
      flist.add(future);
    }
    for (    Future future : flist) {
      QueryResult queryResult=(QueryResult)future.get();
      if (queryResult != null) {
        final List<Integer> partitionIds=queryResult.getPartitionIds();
        if (partitionIds != null) {
          plist.addAll(partitionIds);
          result.addAll(queryResult.getResult());
        }
      }
    }
    if (plist.size() == partitionCount) {
      return result;
    }
    List<Integer> missingList=new ArrayList<Integer>();
    for (int i=0; i < partitionCount; i++) {
      if (!plist.contains(i)) {
        missingList.add(i);
      }
    }
    List<Future> futures=new ArrayList<Future>(missingList.size());
    for (    Integer pid : missingList) {
      QueryPartitionOperation queryPartitionOperation=new QueryPartitionOperation(name,predicate);
      queryPartitionOperation.setPartitionId(pid);
      try {
        Future f=operationService.createInvocationBuilder(SERVICE_NAME,queryPartitionOperation,pid).build().invoke();
        futures.add(f);
      }
 catch (      Throwable t) {
        throw ExceptionUtil.rethrow(t);
      }
    }
    for (    Future future : futures) {
      QueryResult queryResult=(QueryResult)future.get();
      result.addAll(queryResult.getResult());
    }
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
  return result;
}","protected Set query(final Predicate predicate,final IterationType iterationType,final boolean dataResult){
  final NodeEngine nodeEngine=getNodeEngine();
  OperationService operationService=nodeEngine.getOperationService();
  Collection<MemberImpl> members=nodeEngine.getClusterService().getMemberList();
  int partitionCount=nodeEngine.getPartitionService().getPartitionCount();
  Set<Integer> plist=new HashSet<Integer>(partitionCount);
  QueryResultSet result=new QueryResultSet(nodeEngine.getSerializationService(),iterationType,dataResult);
  List<Integer> missingList=new ArrayList<Integer>();
  try {
    List<Future> flist=new ArrayList<Future>();
    for (    MemberImpl member : members) {
      Invocation invocation=operationService.createInvocationBuilder(SERVICE_NAME,new QueryOperation(name,predicate),member.getAddress()).build();
      Future future=invocation.invoke();
      flist.add(future);
    }
    for (    Future future : flist) {
      QueryResult queryResult=(QueryResult)future.get();
      if (queryResult != null) {
        final List<Integer> partitionIds=queryResult.getPartitionIds();
        if (partitionIds != null) {
          plist.addAll(partitionIds);
          result.addAll(queryResult.getResult());
        }
      }
    }
    if (plist.size() == partitionCount) {
      return result;
    }
    for (int i=0; i < partitionCount; i++) {
      if (!plist.contains(i)) {
        missingList.add(i);
      }
    }
  }
 catch (  Throwable t) {
    missingList.clear();
    for (int i=0; i < partitionCount; i++) {
      if (!plist.contains(i)) {
        missingList.add(i);
      }
    }
  }
  try {
    List<Future> futures=new ArrayList<Future>(missingList.size());
    for (    Integer pid : missingList) {
      QueryPartitionOperation queryPartitionOperation=new QueryPartitionOperation(name,predicate);
      queryPartitionOperation.setPartitionId(pid);
      try {
        Future f=operationService.createInvocationBuilder(SERVICE_NAME,queryPartitionOperation,pid).build().invoke();
        futures.add(f);
      }
 catch (      Throwable t) {
        throw ExceptionUtil.rethrow(t);
      }
    }
    for (    Future future : futures) {
      QueryResult queryResult=(QueryResult)future.get();
      result.addAll(queryResult.getResult());
    }
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
  return result;
}",0.9355754531557108
49059,"public SocketAddress getSocketAddress(){
  if (conn instanceof TcpIpConnection) {
    return ((TcpIpConnection)conn).getSocketChannelWrapper().socket().getRemoteSocketAddress();
  }
  return null;
}","public SocketAddress getSocketAddress(){
  return socketAddress;
}",0.5
49060,"ClientEndpoint(ClientEngine clientEngine,Connection conn,String uuid){
  this.clientEngine=clientEngine;
  this.conn=conn;
  this.uuid=uuid;
}","ClientEndpoint(ClientEngine clientEngine,Connection conn,String uuid){
  this.clientEngine=clientEngine;
  this.conn=conn;
  socketAddress=conn instanceof TcpIpConnection ? ((TcpIpConnection)conn).getSocketChannelWrapper().socket().getRemoteSocketAddress() : null;
  this.uuid=uuid;
}",0.6666666666666666
49061,"public SocketAddress getSocketAddress(){
  if (conn instanceof TcpIpConnection) {
    return ((TcpIpConnection)conn).getSocketChannelWrapper().socket().getRemoteSocketAddress();
  }
  return null;
}","public SocketAddress getSocketAddress(){
  return socketAddress;
}",0.5
49062,"ClientEndpoint(ClientEngine clientEngine,Connection conn,String uuid){
  this.clientEngine=clientEngine;
  this.conn=conn;
  this.uuid=uuid;
}","ClientEndpoint(ClientEngine clientEngine,Connection conn,String uuid){
  this.clientEngine=clientEngine;
  this.conn=conn;
  socketAddress=conn instanceof TcpIpConnection ? ((TcpIpConnection)conn).getSocketChannelWrapper().socket().getRemoteSocketAddress() : null;
  this.uuid=uuid;
}",0.6666666666666666
49063,"protected Set query(final Predicate predicate,final IterationType iterationType,final boolean dataResult){
  final NodeEngine nodeEngine=getNodeEngine();
  OperationService operationService=nodeEngine.getOperationService();
  Collection<MemberImpl> members=nodeEngine.getClusterService().getMemberList();
  int partitionCount=nodeEngine.getPartitionService().getPartitionCount();
  Set<Integer> plist=new HashSet<Integer>(partitionCount);
  QueryResultSet result=new QueryResultSet(nodeEngine.getSerializationService(),iterationType,dataResult);
  try {
    List<Future> flist=new ArrayList<Future>();
    for (    MemberImpl member : members) {
      Invocation invocation=operationService.createInvocationBuilder(SERVICE_NAME,new QueryOperation(name,predicate),member.getAddress()).build();
      Future future=invocation.invoke();
      flist.add(future);
    }
    for (    Future future : flist) {
      QueryResult queryResult=(QueryResult)future.get();
      if (queryResult != null) {
        final List<Integer> partitionIds=queryResult.getPartitionIds();
        if (partitionIds != null) {
          plist.addAll(partitionIds);
          result.addAll(queryResult.getResult());
        }
      }
    }
    if (plist.size() == partitionCount) {
      return result;
    }
    List<Integer> missingList=new ArrayList<Integer>();
    for (int i=0; i < partitionCount; i++) {
      if (!plist.contains(i)) {
        missingList.add(i);
      }
    }
    List<Future> futures=new ArrayList<Future>(missingList.size());
    for (    Integer pid : missingList) {
      QueryPartitionOperation queryPartitionOperation=new QueryPartitionOperation(name,predicate);
      queryPartitionOperation.setPartitionId(pid);
      try {
        Future f=operationService.createInvocationBuilder(SERVICE_NAME,queryPartitionOperation,pid).build().invoke();
        futures.add(f);
      }
 catch (      Throwable t) {
        throw ExceptionUtil.rethrow(t);
      }
    }
    for (    Future future : futures) {
      QueryResult queryResult=(QueryResult)future.get();
      result.addAll(queryResult.getResult());
    }
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
  return result;
}","protected Set query(final Predicate predicate,final IterationType iterationType,final boolean dataResult){
  final NodeEngine nodeEngine=getNodeEngine();
  OperationService operationService=nodeEngine.getOperationService();
  Collection<MemberImpl> members=nodeEngine.getClusterService().getMemberList();
  int partitionCount=nodeEngine.getPartitionService().getPartitionCount();
  Set<Integer> plist=new HashSet<Integer>(partitionCount);
  QueryResultSet result=new QueryResultSet(nodeEngine.getSerializationService(),iterationType,dataResult);
  List<Integer> missingList=new ArrayList<Integer>();
  try {
    List<Future> flist=new ArrayList<Future>();
    for (    MemberImpl member : members) {
      Invocation invocation=operationService.createInvocationBuilder(SERVICE_NAME,new QueryOperation(name,predicate),member.getAddress()).build();
      Future future=invocation.invoke();
      flist.add(future);
    }
    for (    Future future : flist) {
      QueryResult queryResult=(QueryResult)future.get();
      if (queryResult != null) {
        final List<Integer> partitionIds=queryResult.getPartitionIds();
        if (partitionIds != null) {
          plist.addAll(partitionIds);
          result.addAll(queryResult.getResult());
        }
      }
    }
    if (plist.size() == partitionCount) {
      return result;
    }
    for (int i=0; i < partitionCount; i++) {
      if (!plist.contains(i)) {
        missingList.add(i);
      }
    }
  }
 catch (  Throwable t) {
    missingList.clear();
    for (int i=0; i < partitionCount; i++) {
      if (!plist.contains(i)) {
        missingList.add(i);
      }
    }
  }
  try {
    List<Future> futures=new ArrayList<Future>(missingList.size());
    for (    Integer pid : missingList) {
      QueryPartitionOperation queryPartitionOperation=new QueryPartitionOperation(name,predicate);
      queryPartitionOperation.setPartitionId(pid);
      try {
        Future f=operationService.createInvocationBuilder(SERVICE_NAME,queryPartitionOperation,pid).build().invoke();
        futures.add(f);
      }
 catch (      Throwable t) {
        throw ExceptionUtil.rethrow(t);
      }
    }
    for (    Future future : futures) {
      QueryResult queryResult=(QueryResult)future.get();
      result.addAll(queryResult.getResult());
    }
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
  return result;
}",0.9355754531557108
49064,"public ClassLoader getClassLoader(){
  return classLoader;
}","/** 
 * Returns the class-loader that will be used in serialization. <p> If null, then thread context class-loader will be used instead.
 * @return the class-loader
 */
public ClassLoader getClassLoader(){
  return classLoader;
}",0.4152249134948096
49065,"public Config setClassLoader(ClassLoader classLoader){
  this.classLoader=classLoader;
  return this;
}","/** 
 * Sets the class-loader to be used during de-serialization and as context class-loader of Hazelcast internal threads. <p> If not set (or set to null); thread context class-loader will be used in required places. <p> Default value is null.
 * @param classLoader class-loader to be used during de-serialization
 * @return Config instance
 */
public Config setClassLoader(ClassLoader classLoader){
  this.classLoader=classLoader;
  return this;
}",0.3731884057971014
49066,"public final Thread newThread(Runnable r){
  final Thread t=createThread(r);
  t.setContextClassLoader(classLoader);
  if (t.isDaemon()) {
    t.setDaemon(false);
  }
  if (t.getPriority() != Thread.NORM_PRIORITY) {
    t.setPriority(Thread.NORM_PRIORITY);
  }
  return t;
}","public final Thread newThread(Runnable r){
  final Thread t=createThread(r);
  ClassLoader cl=classLoader != null ? classLoader : Thread.currentThread().getContextClassLoader();
  t.setContextClassLoader(cl);
  if (t.isDaemon()) {
    t.setDaemon(false);
  }
  if (t.getPriority() != Thread.NORM_PRIORITY) {
    t.setPriority(Thread.NORM_PRIORITY);
  }
  return t;
}",0.8125
49067,"protected void onDestroy(){
  if (nearCacheListenerId != null) {
    removeEntryListener(nearCacheListenerId);
  }
  nearCache.clear();
  MapDestroyRequest request=new MapDestroyRequest(name);
  invoke(request);
}","protected void onDestroy(){
  if (nearCacheListenerId != null) {
    removeEntryListener(nearCacheListenerId);
  }
  if (nearCache != null) {
    nearCache.clear();
  }
  MapDestroyRequest request=new MapDestroyRequest(name);
  invoke(request);
}",0.9281045751633988
49068,"void clear(){
  for (  PartitionRecordStore store : maps.values()) {
    store.clear();
  }
  maps.clear();
}","void clear(){
  for (  PartitionRecordStore recordStore : maps.values()) {
    recordStore.clear();
  }
  maps.clear();
}",0.9304347826086956
49069,"public void removeAll(){
  final Collection<Data> locks=lockStore != null ? lockStore.getLockedKeys() : Collections.<Data>emptySet();
  final Map<Data,Record> lockRecords=new HashMap<Data,Record>(locks.size());
  for (  Data key : locks) {
    Record record=records.get(key);
    if (record != null) {
      lockRecords.put(key,record);
    }
  }
  Set<Data> keysToDelete=records.keySet();
  keysToDelete.removeAll(lockRecords.keySet());
  final MapStoreWrapper store=mapContainer.getStore();
  if (store != null) {
    Set<Object> keysObject=new HashSet<Object>();
    for (    Data key : keysToDelete) {
      removeIndex(key);
      keysObject.add(mapService.toObject(key));
    }
    store.deleteAll(keysObject);
    toBeRemovedKeys.clear();
  }
  records.clear();
  records.putAll(lockRecords);
}","public void removeAll(){
  final Collection<Data> locks=lockStore != null ? lockStore.getLockedKeys() : Collections.<Data>emptySet();
  final Map<Data,Record> lockRecords=new HashMap<Data,Record>(locks.size());
  for (  Data key : locks) {
    Record record=records.get(key);
    if (record != null) {
      lockRecords.put(key,record);
    }
  }
  Set<Data> keysToDelete=records.keySet();
  keysToDelete.removeAll(lockRecords.keySet());
  final MapStoreWrapper store=mapContainer.getStore();
  Set<Object> keysObject=new HashSet<Object>();
  for (  Data key : keysToDelete) {
    removeIndex(key);
    keysObject.add(mapService.toObject(key));
  }
  if (store != null) {
    store.deleteAll(keysObject);
    toBeRemovedKeys.clear();
  }
  records.clear();
  records.putAll(lockRecords);
}",0.9635220125786164
49070,"void clear(){
  final LockService lockService=mapService.getNodeEngine().getSharedService(LockService.SERVICE_NAME);
  if (lockService != null) {
    lockService.clearLockStore(partitionContainer.getPartitionId(),new DefaultObjectNamespace(MapService.SERVICE_NAME,name));
  }
  records.clear();
}","void clear(){
  final LockService lockService=mapService.getNodeEngine().getSharedService(LockService.SERVICE_NAME);
  if (lockService != null) {
    lockService.clearLockStore(partitionContainer.getPartitionId(),new DefaultObjectNamespace(MapService.SERVICE_NAME,name));
  }
  records.clear();
  final IndexService indexService=mapContainer.getIndexService();
  if (indexService.hasIndex()) {
    indexService.clear();
  }
}",0.8210818307905686
49071,"protected void onDestroy(){
  if (nearCacheListenerId != null) {
    removeEntryListener(nearCacheListenerId);
  }
  nearCache.clear();
  MapDestroyRequest request=new MapDestroyRequest(name);
  invoke(request);
}","protected void onDestroy(){
  if (nearCacheListenerId != null) {
    removeEntryListener(nearCacheListenerId);
  }
  if (nearCache != null) {
    nearCache.clear();
  }
  MapDestroyRequest request=new MapDestroyRequest(name);
  invoke(request);
}",0.9281045751633988
49072,"public ClassLoader getClassLoader(){
  return classLoader;
}","/** 
 * Returns the class-loader that will be used in serialization. <p> If null, then thread context class-loader will be used instead.
 * @return the class-loader
 */
public ClassLoader getClassLoader(){
  return classLoader;
}",0.4152249134948096
49073,"public Config setClassLoader(ClassLoader classLoader){
  this.classLoader=classLoader;
  return this;
}","/** 
 * Sets the class-loader to be used during de-serialization and as context class-loader of Hazelcast internal threads. <p> If not set (or set to null); thread context class-loader will be used in required places. <p> Default value is null.
 * @param classLoader class-loader to be used during de-serialization
 * @return Config instance
 */
public Config setClassLoader(ClassLoader classLoader){
  this.classLoader=classLoader;
  return this;
}",0.3731884057971014
49074,"public final Thread newThread(Runnable r){
  final Thread t=createThread(r);
  t.setContextClassLoader(classLoader);
  if (t.isDaemon()) {
    t.setDaemon(false);
  }
  if (t.getPriority() != Thread.NORM_PRIORITY) {
    t.setPriority(Thread.NORM_PRIORITY);
  }
  return t;
}","public final Thread newThread(Runnable r){
  final Thread t=createThread(r);
  ClassLoader cl=classLoader != null ? classLoader : Thread.currentThread().getContextClassLoader();
  t.setContextClassLoader(cl);
  if (t.isDaemon()) {
    t.setDaemon(false);
  }
  if (t.getPriority() != Thread.NORM_PRIORITY) {
    t.setPriority(Thread.NORM_PRIORITY);
  }
  return t;
}",0.8125
49075,"public boolean replace(K key,V oldValue,V newValue){
  TxnMapRequest request=new TxnMapRequest(getName(),TxnMapRequest.TxnMapRequestType.REPLACE,toData(key),toData(oldValue),toData(newValue));
  Boolean result=invoke(request);
  return result;
}","public boolean replace(K key,V oldValue,V newValue){
  TxnMapRequest request=new TxnMapRequest(getName(),TxnMapRequest.TxnMapRequestType.REPLACE_IF_SAME,toData(key),toData(oldValue),toData(newValue));
  Boolean result=invoke(request);
  return result;
}",0.9839357429718876
49076,"public Object call() throws Exception {
  final TransactionContext context=getEndpoint().getTransactionContext();
  final TransactionalMap map=context.getMap(name);
switch (requestType) {
case CONTAINS_KEY:
    return map.containsKey(key);
case GET:
  return map.get(key);
case SIZE:
return map.size();
case PUT:
return map.put(key,value);
case PUT_IF_ABSENT:
return map.putIfAbsent(key,value);
case REPLACE:
return map.replace(key,value);
case REPLACE_IS_SAME:
return map.replace(key,value,newValue);
case SET:
map.set(key,value);
break;
case REMOVE:
return map.remove(key);
case DELETE:
map.delete(key);
break;
case REMOVE_IF_SAME:
return map.remove(key,value);
}
return null;
}","public Object call() throws Exception {
  final TransactionContext context=getEndpoint().getTransactionContext();
  final TransactionalMap map=context.getMap(name);
switch (requestType) {
case CONTAINS_KEY:
    return map.containsKey(key);
case GET:
  return map.get(key);
case SIZE:
return map.size();
case PUT:
return map.put(key,value);
case PUT_IF_ABSENT:
return map.putIfAbsent(key,value);
case REPLACE:
return map.replace(key,value);
case REPLACE_IF_SAME:
return map.replace(key,value,newValue);
case SET:
map.set(key,value);
break;
case REMOVE:
return map.remove(key);
case DELETE:
map.delete(key);
break;
case REMOVE_IF_SAME:
return map.remove(key,value);
}
return null;
}",0.998529411764706
49077,"public void preDeregister() throws Exception {
  super.preDeregister();
  managedObject.removeItemListener(registrationId);
}","public void preDeregister() throws Exception {
  super.preDeregister();
  try {
    managedObject.removeItemListener(registrationId);
  }
 catch (  Exception ignored) {
  }
}",0.8361204013377926
49078,"public void preDeregister() throws Exception {
  super.preDeregister();
  managedObject.removeEntryListener(listenerId);
}","public void preDeregister() throws Exception {
  super.preDeregister();
  try {
    managedObject.removeEntryListener(listenerId);
  }
 catch (  Exception ignored) {
  }
}",0.8327645051194539
49079,"public void preDeregister() throws Exception {
  super.preDeregister();
  managedObject.removeItemListener(registrationId);
}","public void preDeregister() throws Exception {
  super.preDeregister();
  try {
    managedObject.removeItemListener(registrationId);
  }
 catch (  Exception ignored) {
  }
}",0.8361204013377926
49080,"public void preDeregister() throws Exception {
  super.preDeregister();
  managedObject.removeItemListener(registrationId);
}","public void preDeregister() throws Exception {
  super.preDeregister();
  try {
    managedObject.removeItemListener(registrationId);
  }
 catch (  Exception ignored) {
  }
}",0.8361204013377926
49081,"public void preDeregister() throws Exception {
  super.preDeregister();
  managedObject.removeMessageListener(registrationId);
}","public void preDeregister() throws Exception {
  super.preDeregister();
  try {
    managedObject.removeMessageListener(registrationId);
  }
 catch (  Exception ignored) {
  }
}",0.839344262295082
49082,"public void preDeregister() throws Exception {
  super.preDeregister();
  managedObject.removeItemListener(registrationId);
}","public void preDeregister() throws Exception {
  super.preDeregister();
  try {
    managedObject.removeItemListener(registrationId);
  }
 catch (  Exception ignored) {
  }
}",0.8361204013377926
49083,"public void preDeregister() throws Exception {
  super.preDeregister();
  managedObject.removeEntryListener(listenerId);
}","public void preDeregister() throws Exception {
  super.preDeregister();
  try {
    managedObject.removeEntryListener(listenerId);
  }
 catch (  Exception ignored) {
  }
}",0.8327645051194539
49084,"public void preDeregister() throws Exception {
  super.preDeregister();
  managedObject.removeItemListener(registrationId);
}","public void preDeregister() throws Exception {
  super.preDeregister();
  try {
    managedObject.removeItemListener(registrationId);
  }
 catch (  Exception ignored) {
  }
}",0.8361204013377926
49085,"public void preDeregister() throws Exception {
  super.preDeregister();
  managedObject.removeItemListener(registrationId);
}","public void preDeregister() throws Exception {
  super.preDeregister();
  try {
    managedObject.removeItemListener(registrationId);
  }
 catch (  Exception ignored) {
  }
}",0.8361204013377926
49086,"public void preDeregister() throws Exception {
  super.preDeregister();
  managedObject.removeMessageListener(registrationId);
}","public void preDeregister() throws Exception {
  super.preDeregister();
  try {
    managedObject.removeMessageListener(registrationId);
  }
 catch (  Exception ignored) {
  }
}",0.839344262295082
49087,"public AtomicLongMBean(IAtomicLong managedObject,ManagementService service){
  super(managedObject,service);
  objectName=createObjectName(""String_Node_Str"",managedObject.getName());
}","public AtomicLongMBean(IAtomicLong managedObject,ManagementService service){
  super(managedObject,service);
  objectName=service.createObjectName(""String_Node_Str"",managedObject.getName());
}",0.9787234042553192
49088,"protected CountDownLatchMBean(ICountDownLatch managedObject,ManagementService service){
  super(managedObject,service);
  objectName=createObjectName(""String_Node_Str"",managedObject.getName());
}","protected CountDownLatchMBean(ICountDownLatch managedObject,ManagementService service){
  super(managedObject,service);
  objectName=service.createObjectName(""String_Node_Str"",managedObject.getName());
}",0.9798994974874372
49089,"protected InstanceMBean(HazelcastInstance managedObject,ManagementService service){
  super(managedObject,service);
  objectName=createObjectName(null,null);
  config=managedObject.getConfig();
  cluster=managedObject.getCluster();
}","protected InstanceMBean(HazelcastInstance managedObject,ManagementService service){
  super(managedObject,service);
  objectName=service.createObjectName(null,null);
  config=managedObject.getConfig();
  cluster=managedObject.getCluster();
}",0.9831223628691984
49090,"protected ListMBean(IList<?> managedObject,ManagementService service){
  super(managedObject,service);
  objectName=createObjectName(""String_Node_Str"",managedObject.getName());
  ItemListener itemListener=new ItemListener(){
    public void itemAdded(    ItemEvent item){
      totalAddedItemCount.incrementAndGet();
    }
    public void itemRemoved(    ItemEvent item){
      totalRemovedItemCount.incrementAndGet();
    }
  }
;
  registrationId=managedObject.addItemListener(itemListener,false);
}","protected ListMBean(IList<?> managedObject,ManagementService service){
  super(managedObject,service);
  objectName=service.createObjectName(""String_Node_Str"",managedObject.getName());
  ItemListener itemListener=new ItemListener(){
    public void itemAdded(    ItemEvent item){
      totalAddedItemCount.incrementAndGet();
    }
    public void itemRemoved(    ItemEvent item){
      totalRemovedItemCount.incrementAndGet();
    }
  }
;
  registrationId=managedObject.addItemListener(itemListener,false);
}",0.992063492063492
49091,"protected LockMBean(ILock managedObject,ManagementService service){
  super(managedObject,service);
  objectName=createObjectName(""String_Node_Str"",managedObject.getName());
}","protected LockMBean(ILock managedObject,ManagementService service){
  super(managedObject,service);
  objectName=service.createObjectName(""String_Node_Str"",managedObject.getName());
}",0.9776536312849162
49092,"public static void shutdownAll(){
  MBeanServer mbs=ManagementFactory.getPlatformMBeanServer();
  try {
    Set<ObjectName> entries=mbs.queryNames(new ObjectName(HazelcastMBean.DOMAIN + ""String_Node_Str""),null);
    for (    ObjectName name : entries) {
      if (mbs.isRegistered(name)) {
        mbs.unregisterMBean(name);
      }
    }
  }
 catch (  Exception e) {
    Logger.getLogger(ManagementService.class.getName()).log(Level.WARNING,""String_Node_Str"",e);
  }
}","public static void shutdownAll(){
  MBeanServer mbs=ManagementFactory.getPlatformMBeanServer();
  try {
    Set<ObjectName> entries=mbs.queryNames(new ObjectName(DOMAIN + ""String_Node_Str""),null);
    for (    ObjectName name : entries) {
      if (mbs.isRegistered(name)) {
        mbs.unregisterMBean(name);
      }
    }
  }
 catch (  Exception e) {
    Logger.getLogger(ManagementService.class.getName()).log(Level.WARNING,""String_Node_Str"",e);
  }
}",0.9837486457204768
49093,"public void destroy(){
  if (!enabled) {
    return;
  }
  instance.removeDistributedObjectListener(registrationId);
  MBeanServer mbs=ManagementFactory.getPlatformMBeanServer();
  try {
    Set<ObjectName> entries=mbs.queryNames(new ObjectName(HazelcastMBean.DOMAIN + ""String_Node_Str"" + instance.getName()+ ""String_Node_Str""),null);
    for (    ObjectName name : entries) {
      if (mbs.isRegistered(name)) {
        mbs.unregisterMBean(name);
      }
    }
  }
 catch (  Exception e) {
    logger.warning(""String_Node_Str"",e);
  }
}","public void destroy(){
  if (!enabled) {
    return;
  }
  instance.removeDistributedObjectListener(registrationId);
  MBeanServer mbs=ManagementFactory.getPlatformMBeanServer();
  try {
    Set<ObjectName> entries=mbs.queryNames(new ObjectName(DOMAIN + ""String_Node_Str"" + quote(instance.getName())+ ""String_Node_Str""),null);
    for (    ObjectName name : entries) {
      if (mbs.isRegistered(name)) {
        mbs.unregisterMBean(name);
      }
    }
  }
 catch (  Exception e) {
    logger.warning(""String_Node_Str"",e);
  }
}",0.947467166979362
49094,"private void unregisterDistributedObject(DistributedObject distributedObject){
  HazelcastMBean bean=createHazelcastBean(distributedObject);
  if (bean != null) {
    MBeanServer mbs=ManagementFactory.getPlatformMBeanServer();
    if (mbs.isRegistered(bean.objectName)) {
      try {
        mbs.unregisterMBean(bean.objectName);
      }
 catch (      Exception e) {
        logger.warning(""String_Node_Str"" + bean.objectName,e);
      }
    }
  }
}","private void unregisterDistributedObject(DistributedObject distributedObject){
  final String objectType=getObjectType(distributedObject);
  if (objectType != null) {
    ObjectName objectName=createObjectName(objectType,distributedObject.getName());
    MBeanServer mbs=ManagementFactory.getPlatformMBeanServer();
    if (mbs.isRegistered(objectName)) {
      try {
        mbs.unregisterMBean(objectName);
      }
 catch (      Exception e) {
        logger.warning(""String_Node_Str"" + objectName,e);
      }
    }
  }
}",0.486096807415036
49095,"protected MapMBean(IMap managedObject,ManagementService service){
  super(managedObject,service);
  objectName=createObjectName(""String_Node_Str"",managedObject.getName());
  EntryListener entryListener=new EntryListener(){
    public void entryAdded(    EntryEvent event){
      totalAddedEntryCount.incrementAndGet();
    }
    public void entryRemoved(    EntryEvent event){
      totalRemovedEntryCount.incrementAndGet();
    }
    public void entryUpdated(    EntryEvent event){
      totalUpdatedEntryCount.incrementAndGet();
    }
    public void entryEvicted(    EntryEvent event){
      totalEvictedEntryCount.incrementAndGet();
    }
  }
;
  listenerId=managedObject.addEntryListener(entryListener,false);
}","protected MapMBean(IMap managedObject,ManagementService service){
  super(managedObject,service);
  objectName=service.createObjectName(""String_Node_Str"",managedObject.getName());
  EntryListener entryListener=new EntryListener(){
    public void entryAdded(    EntryEvent event){
      totalAddedEntryCount.incrementAndGet();
    }
    public void entryRemoved(    EntryEvent event){
      totalRemovedEntryCount.incrementAndGet();
    }
    public void entryUpdated(    EntryEvent event){
      totalUpdatedEntryCount.incrementAndGet();
    }
    public void entryEvicted(    EntryEvent event){
      totalEvictedEntryCount.incrementAndGet();
    }
  }
;
  listenerId=managedObject.addEntryListener(entryListener,false);
}",0.9944444444444444
49096,"protected MultiMapMBean(MultiMap managedObject,ManagementService service){
  super(managedObject,service);
  objectName=createObjectName(""String_Node_Str"",managedObject.getName());
}","protected MultiMapMBean(MultiMap managedObject,ManagementService service){
  super(managedObject,service);
  objectName=service.createObjectName(""String_Node_Str"",managedObject.getName());
}",0.978494623655914
49097,"protected QueueMBean(IQueue managedObject,ManagementService service){
  super(managedObject,service);
  objectName=createObjectName(""String_Node_Str"",managedObject.getName());
  ItemListener itemListener=new ItemListener(){
    public void itemAdded(    ItemEvent item){
      totalAddedItemCount.incrementAndGet();
    }
    public void itemRemoved(    ItemEvent item){
      totalRemovedItemCount.incrementAndGet();
    }
  }
;
  registrationId=managedObject.addItemListener(itemListener,false);
}","protected QueueMBean(IQueue managedObject,ManagementService service){
  super(managedObject,service);
  objectName=service.createObjectName(""String_Node_Str"",managedObject.getName());
  ItemListener itemListener=new ItemListener(){
    public void itemAdded(    ItemEvent item){
      totalAddedItemCount.incrementAndGet();
    }
    public void itemRemoved(    ItemEvent item){
      totalRemovedItemCount.incrementAndGet();
    }
  }
;
  registrationId=managedObject.addItemListener(itemListener,false);
}",0.9920477137176938
49098,"protected SemaphoreMBean(ISemaphore managedObject,ManagementService service){
  super(managedObject,service);
  objectName=createObjectName(""String_Node_Str"",managedObject.getName());
}","protected SemaphoreMBean(ISemaphore managedObject,ManagementService service){
  super(managedObject,service);
  objectName=service.createObjectName(""String_Node_Str"",managedObject.getName());
}",0.9788359788359788
49099,"public void preDeregister() throws Exception {
  super.preDeregister();
}","public void preDeregister() throws Exception {
  super.preDeregister();
  managedObject.removeItemListener(registrationId);
}",0.7373737373737373
49100,"protected SetMBean(ISet managedObject,ManagementService service){
  super(managedObject,service);
  objectName=createObjectName(""String_Node_Str"",managedObject.getName());
  ItemListener itemListener=new ItemListener(){
    public void itemAdded(    ItemEvent item){
      totalAddedItemCount.incrementAndGet();
    }
    public void itemRemoved(    ItemEvent item){
      totalRemovedItemCount.incrementAndGet();
    }
  }
;
}","protected SetMBean(ISet managedObject,ManagementService service){
  super(managedObject,service);
  objectName=service.createObjectName(""String_Node_Str"",managedObject.getName());
  ItemListener itemListener=new ItemListener(){
    public void itemAdded(    ItemEvent item){
      totalAddedItemCount.incrementAndGet();
    }
    public void itemRemoved(    ItemEvent item){
      totalRemovedItemCount.incrementAndGet();
    }
  }
;
  registrationId=managedObject.addItemListener(itemListener,false);
}",0.9182795698924732
49101,"protected TopicMBean(ITopic managedObject,ManagementService service){
  super(managedObject,service);
  objectName=createObjectName(""String_Node_Str"",managedObject.getName());
  MessageListener messageListener=new MessageListener(){
    public void onMessage(    Message message){
      totalMessageCount.incrementAndGet();
    }
  }
;
  registrationId=managedObject.addMessageListener(messageListener);
}","protected TopicMBean(ITopic managedObject,ManagementService service){
  super(managedObject,service);
  objectName=service.createObjectName(""String_Node_Str"",managedObject.getName());
  MessageListener messageListener=new MessageListener(){
    public void onMessage(    Message message){
      totalMessageCount.incrementAndGet();
    }
  }
;
  registrationId=managedObject.addMessageListener(messageListener);
}",0.9902200488997556
49102,"public boolean replace(K key,V oldValue,V newValue){
  TxnMapRequest request=new TxnMapRequest(getName(),TxnMapRequest.TxnMapRequestType.REPLACE,toData(key),toData(oldValue),toData(newValue));
  Boolean result=invoke(request);
  return result;
}","public boolean replace(K key,V oldValue,V newValue){
  TxnMapRequest request=new TxnMapRequest(getName(),TxnMapRequest.TxnMapRequestType.REPLACE_IF_SAME,toData(key),toData(oldValue),toData(newValue));
  Boolean result=invoke(request);
  return result;
}",0.9839357429718876
49103,"public Object call() throws Exception {
  final TransactionContext context=getEndpoint().getTransactionContext();
  final TransactionalMap map=context.getMap(name);
switch (requestType) {
case CONTAINS_KEY:
    return map.containsKey(key);
case GET:
  return map.get(key);
case SIZE:
return map.size();
case PUT:
return map.put(key,value);
case PUT_IF_ABSENT:
return map.putIfAbsent(key,value);
case REPLACE:
return map.replace(key,value);
case REPLACE_IS_SAME:
return map.replace(key,value,newValue);
case SET:
map.set(key,value);
break;
case REMOVE:
return map.remove(key);
case DELETE:
map.delete(key);
break;
case REMOVE_IF_SAME:
return map.remove(key,value);
}
return null;
}","public Object call() throws Exception {
  final TransactionContext context=getEndpoint().getTransactionContext();
  final TransactionalMap map=context.getMap(name);
switch (requestType) {
case CONTAINS_KEY:
    return map.containsKey(key);
case GET:
  return map.get(key);
case SIZE:
return map.size();
case PUT:
return map.put(key,value);
case PUT_IF_ABSENT:
return map.putIfAbsent(key,value);
case REPLACE:
return map.replace(key,value);
case REPLACE_IF_SAME:
return map.replace(key,value,newValue);
case SET:
map.set(key,value);
break;
case REMOVE:
return map.remove(key);
case DELETE:
map.delete(key);
break;
case REMOVE_IF_SAME:
return map.remove(key,value);
}
return null;
}",0.998529411764706
49104,"@Override public Collection<DistributedObject> getDistributedObjects(){
  Collection<DistributedObject> objects=new LinkedList<DistributedObject>();
  for (  ClientProxy clientProxy : proxyManager.getProxies()) {
    objects.add(clientProxy);
  }
  return objects;
}","@Override public Collection<DistributedObject> getDistributedObjects(){
  try {
    GetDistributedObjectsRequest request=new GetDistributedObjectsRequest();
    final SerializableCollection serializableCollection=(SerializableCollection)invocationService.invokeOnRandomTarget(request);
    final ArrayList<DistributedObject> coll=new ArrayList<DistributedObject>(serializableCollection.size());
    for (    Data data : serializableCollection) {
      final DistributedObjectInfo o=(DistributedObjectInfo)serializationService.toObject(data);
      coll.add(getDistributedObject(o.getServiceName(),o.getId()));
    }
    return coll;
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e);
  }
}",0.3508771929824561
49105,"void shutdown(){
  CLIENTS.remove(id);
  executionService.shutdown();
  partitionService.stop();
  clusterService.stop();
  connectionManager.shutdown();
}","void shutdown(){
  CLIENTS.remove(id);
  executionService.shutdown();
  partitionService.stop();
  clusterService.stop();
  connectionManager.shutdown();
  proxyManager.destroy();
}",0.9226190476190476
49106,"public void destroy(){
  for (  ClientProxy proxy : getProxies()) {
    try {
      proxy.destroy();
    }
 catch (    Exception ignored) {
    }
  }
  proxies.clear();
  listeners.clear();
}","public void destroy(){
  proxies.clear();
  listeners.clear();
}",0.5019607843137255
49107,"@Override public int getClassId(){
  return 2;
}","@Override public int getClassId(){
  return ClientPortableHook.AUTH;
}",0.7966101694915254
49108,"void doShutdown(){
  CLIENTS.remove(id);
  executionService.shutdown();
  partitionService.stop();
  clusterService.stop();
  connectionManager.shutdown();
}","void doShutdown(){
  CLIENTS.remove(id);
  executionService.shutdown();
  partitionService.stop();
  clusterService.stop();
  connectionManager.shutdown();
  proxyManager.destroy();
}",0.923529411764706
49109,"@Override public Collection<DistributedObject> getDistributedObjects(){
  Collection<DistributedObject> objects=new LinkedList<DistributedObject>();
  for (  ClientProxy clientProxy : proxyManager.getProxies()) {
    objects.add(clientProxy);
  }
  return objects;
}","@Override public Collection<DistributedObject> getDistributedObjects(){
  try {
    GetDistributedObjectsRequest request=new GetDistributedObjectsRequest();
    final SerializableCollection serializableCollection=(SerializableCollection)invocationService.invokeOnRandomTarget(request);
    final ArrayList<DistributedObject> coll=new ArrayList<DistributedObject>(serializableCollection.size());
    for (    Data data : serializableCollection) {
      final DistributedObjectInfo o=(DistributedObjectInfo)serializationService.toObject(data);
      coll.add(getDistributedObject(o.getServiceName(),o.getId()));
    }
    return coll;
  }
 catch (  Exception e) {
    throw ExceptionUtil.rethrow(e);
  }
}",0.3508771929824561
49110,"public void destroy(){
  for (  ClientProxy proxy : getProxies()) {
    try {
      proxy.destroy();
    }
 catch (    Exception ignored) {
    }
  }
  proxies.clear();
  listeners.clear();
}","public void destroy(){
  proxies.clear();
  listeners.clear();
}",0.5019607843137255
49111,"@Override public int getClassId(){
  return 2;
}","@Override public int getClassId(){
  return ClientPortableHook.AUTH;
}",0.7966101694915254
49112,"public AtomicLongMBean(IAtomicLong managedObject,ManagementService service){
  super(managedObject,service);
  objectName=createObjectName(""String_Node_Str"",managedObject.getName());
}","public AtomicLongMBean(IAtomicLong managedObject,ManagementService service){
  super(managedObject,service);
  objectName=service.createObjectName(""String_Node_Str"",managedObject.getName());
}",0.9787234042553192
49113,"protected CountDownLatchMBean(ICountDownLatch managedObject,ManagementService service){
  super(managedObject,service);
  objectName=createObjectName(""String_Node_Str"",managedObject.getName());
}","protected CountDownLatchMBean(ICountDownLatch managedObject,ManagementService service){
  super(managedObject,service);
  objectName=service.createObjectName(""String_Node_Str"",managedObject.getName());
}",0.9798994974874372
49114,"protected InstanceMBean(HazelcastInstance managedObject,ManagementService service){
  super(managedObject,service);
  objectName=createObjectName(null,null);
  config=managedObject.getConfig();
  cluster=managedObject.getCluster();
}","protected InstanceMBean(HazelcastInstance managedObject,ManagementService service){
  super(managedObject,service);
  objectName=service.createObjectName(null,null);
  config=managedObject.getConfig();
  cluster=managedObject.getCluster();
}",0.9831223628691984
49115,"protected ListMBean(IList<?> managedObject,ManagementService service){
  super(managedObject,service);
  objectName=createObjectName(""String_Node_Str"",managedObject.getName());
  ItemListener itemListener=new ItemListener(){
    public void itemAdded(    ItemEvent item){
      totalAddedItemCount.incrementAndGet();
    }
    public void itemRemoved(    ItemEvent item){
      totalRemovedItemCount.incrementAndGet();
    }
  }
;
  registrationId=managedObject.addItemListener(itemListener,false);
}","protected ListMBean(IList<?> managedObject,ManagementService service){
  super(managedObject,service);
  objectName=service.createObjectName(""String_Node_Str"",managedObject.getName());
  ItemListener itemListener=new ItemListener(){
    public void itemAdded(    ItemEvent item){
      totalAddedItemCount.incrementAndGet();
    }
    public void itemRemoved(    ItemEvent item){
      totalRemovedItemCount.incrementAndGet();
    }
  }
;
  registrationId=managedObject.addItemListener(itemListener,false);
}",0.992063492063492
49116,"protected LockMBean(ILock managedObject,ManagementService service){
  super(managedObject,service);
  objectName=createObjectName(""String_Node_Str"",managedObject.getName());
}","protected LockMBean(ILock managedObject,ManagementService service){
  super(managedObject,service);
  objectName=service.createObjectName(""String_Node_Str"",managedObject.getName());
}",0.9776536312849162
49117,"public static void shutdownAll(){
  MBeanServer mbs=ManagementFactory.getPlatformMBeanServer();
  try {
    Set<ObjectName> entries=mbs.queryNames(new ObjectName(HazelcastMBean.DOMAIN + ""String_Node_Str""),null);
    for (    ObjectName name : entries) {
      if (mbs.isRegistered(name)) {
        mbs.unregisterMBean(name);
      }
    }
  }
 catch (  Exception e) {
    Logger.getLogger(ManagementService.class.getName()).log(Level.WARNING,""String_Node_Str"",e);
  }
}","public static void shutdownAll(){
  MBeanServer mbs=ManagementFactory.getPlatformMBeanServer();
  try {
    Set<ObjectName> entries=mbs.queryNames(new ObjectName(DOMAIN + ""String_Node_Str""),null);
    for (    ObjectName name : entries) {
      if (mbs.isRegistered(name)) {
        mbs.unregisterMBean(name);
      }
    }
  }
 catch (  Exception e) {
    Logger.getLogger(ManagementService.class.getName()).log(Level.WARNING,""String_Node_Str"",e);
  }
}",0.9837486457204768
49118,"public void destroy(){
  if (!enabled) {
    return;
  }
  instance.removeDistributedObjectListener(registrationId);
  MBeanServer mbs=ManagementFactory.getPlatformMBeanServer();
  try {
    Set<ObjectName> entries=mbs.queryNames(new ObjectName(HazelcastMBean.DOMAIN + ""String_Node_Str"" + instance.getName()+ ""String_Node_Str""),null);
    for (    ObjectName name : entries) {
      if (mbs.isRegistered(name)) {
        mbs.unregisterMBean(name);
      }
    }
  }
 catch (  Exception e) {
    logger.warning(""String_Node_Str"",e);
  }
}","public void destroy(){
  if (!enabled) {
    return;
  }
  instance.removeDistributedObjectListener(registrationId);
  MBeanServer mbs=ManagementFactory.getPlatformMBeanServer();
  try {
    Set<ObjectName> entries=mbs.queryNames(new ObjectName(DOMAIN + ""String_Node_Str"" + quote(instance.getName())+ ""String_Node_Str""),null);
    for (    ObjectName name : entries) {
      if (mbs.isRegistered(name)) {
        mbs.unregisterMBean(name);
      }
    }
  }
 catch (  Exception e) {
    logger.warning(""String_Node_Str"",e);
  }
}",0.947467166979362
49119,"private void unregisterDistributedObject(DistributedObject distributedObject){
  HazelcastMBean bean=createHazelcastBean(distributedObject);
  if (bean != null) {
    MBeanServer mbs=ManagementFactory.getPlatformMBeanServer();
    if (mbs.isRegistered(bean.objectName)) {
      try {
        mbs.unregisterMBean(bean.objectName);
      }
 catch (      Exception e) {
        logger.warning(""String_Node_Str"" + bean.objectName,e);
      }
    }
  }
}","private void unregisterDistributedObject(DistributedObject distributedObject){
  final String objectType=getObjectType(distributedObject);
  if (objectType != null) {
    ObjectName objectName=createObjectName(objectType,distributedObject.getName());
    MBeanServer mbs=ManagementFactory.getPlatformMBeanServer();
    if (mbs.isRegistered(objectName)) {
      try {
        mbs.unregisterMBean(objectName);
      }
 catch (      Exception e) {
        logger.warning(""String_Node_Str"" + objectName,e);
      }
    }
  }
}",0.486096807415036
49120,"protected MapMBean(IMap managedObject,ManagementService service){
  super(managedObject,service);
  objectName=createObjectName(""String_Node_Str"",managedObject.getName());
  EntryListener entryListener=new EntryListener(){
    public void entryAdded(    EntryEvent event){
      totalAddedEntryCount.incrementAndGet();
    }
    public void entryRemoved(    EntryEvent event){
      totalRemovedEntryCount.incrementAndGet();
    }
    public void entryUpdated(    EntryEvent event){
      totalUpdatedEntryCount.incrementAndGet();
    }
    public void entryEvicted(    EntryEvent event){
      totalEvictedEntryCount.incrementAndGet();
    }
  }
;
  listenerId=managedObject.addEntryListener(entryListener,false);
}","protected MapMBean(IMap managedObject,ManagementService service){
  super(managedObject,service);
  objectName=service.createObjectName(""String_Node_Str"",managedObject.getName());
  EntryListener entryListener=new EntryListener(){
    public void entryAdded(    EntryEvent event){
      totalAddedEntryCount.incrementAndGet();
    }
    public void entryRemoved(    EntryEvent event){
      totalRemovedEntryCount.incrementAndGet();
    }
    public void entryUpdated(    EntryEvent event){
      totalUpdatedEntryCount.incrementAndGet();
    }
    public void entryEvicted(    EntryEvent event){
      totalEvictedEntryCount.incrementAndGet();
    }
  }
;
  listenerId=managedObject.addEntryListener(entryListener,false);
}",0.9944444444444444
49121,"protected MultiMapMBean(MultiMap managedObject,ManagementService service){
  super(managedObject,service);
  objectName=createObjectName(""String_Node_Str"",managedObject.getName());
}","protected MultiMapMBean(MultiMap managedObject,ManagementService service){
  super(managedObject,service);
  objectName=service.createObjectName(""String_Node_Str"",managedObject.getName());
}",0.978494623655914
49122,"protected QueueMBean(IQueue managedObject,ManagementService service){
  super(managedObject,service);
  objectName=createObjectName(""String_Node_Str"",managedObject.getName());
  ItemListener itemListener=new ItemListener(){
    public void itemAdded(    ItemEvent item){
      totalAddedItemCount.incrementAndGet();
    }
    public void itemRemoved(    ItemEvent item){
      totalRemovedItemCount.incrementAndGet();
    }
  }
;
  registrationId=managedObject.addItemListener(itemListener,false);
}","protected QueueMBean(IQueue managedObject,ManagementService service){
  super(managedObject,service);
  objectName=service.createObjectName(""String_Node_Str"",managedObject.getName());
  ItemListener itemListener=new ItemListener(){
    public void itemAdded(    ItemEvent item){
      totalAddedItemCount.incrementAndGet();
    }
    public void itemRemoved(    ItemEvent item){
      totalRemovedItemCount.incrementAndGet();
    }
  }
;
  registrationId=managedObject.addItemListener(itemListener,false);
}",0.9920477137176938
49123,"protected SemaphoreMBean(ISemaphore managedObject,ManagementService service){
  super(managedObject,service);
  objectName=createObjectName(""String_Node_Str"",managedObject.getName());
}","protected SemaphoreMBean(ISemaphore managedObject,ManagementService service){
  super(managedObject,service);
  objectName=service.createObjectName(""String_Node_Str"",managedObject.getName());
}",0.9788359788359788
49124,"public void preDeregister() throws Exception {
  super.preDeregister();
}","public void preDeregister() throws Exception {
  super.preDeregister();
  managedObject.removeItemListener(registrationId);
}",0.7373737373737373
49125,"protected SetMBean(ISet managedObject,ManagementService service){
  super(managedObject,service);
  objectName=createObjectName(""String_Node_Str"",managedObject.getName());
  ItemListener itemListener=new ItemListener(){
    public void itemAdded(    ItemEvent item){
      totalAddedItemCount.incrementAndGet();
    }
    public void itemRemoved(    ItemEvent item){
      totalRemovedItemCount.incrementAndGet();
    }
  }
;
}","protected SetMBean(ISet managedObject,ManagementService service){
  super(managedObject,service);
  objectName=service.createObjectName(""String_Node_Str"",managedObject.getName());
  ItemListener itemListener=new ItemListener(){
    public void itemAdded(    ItemEvent item){
      totalAddedItemCount.incrementAndGet();
    }
    public void itemRemoved(    ItemEvent item){
      totalRemovedItemCount.incrementAndGet();
    }
  }
;
  registrationId=managedObject.addItemListener(itemListener,false);
}",0.9182795698924732
49126,"protected TopicMBean(ITopic managedObject,ManagementService service){
  super(managedObject,service);
  objectName=createObjectName(""String_Node_Str"",managedObject.getName());
  MessageListener messageListener=new MessageListener(){
    public void onMessage(    Message message){
      totalMessageCount.incrementAndGet();
    }
  }
;
  registrationId=managedObject.addMessageListener(messageListener);
}","protected TopicMBean(ITopic managedObject,ManagementService service){
  super(managedObject,service);
  objectName=service.createObjectName(""String_Node_Str"",managedObject.getName());
  MessageListener messageListener=new MessageListener(){
    public void onMessage(    Message message){
      totalMessageCount.incrementAndGet();
    }
  }
;
  registrationId=managedObject.addMessageListener(messageListener);
}",0.9902200488997556
49127,"void clear(){
  for (  PartitionRecordStore store : maps.values()) {
    store.clear();
  }
  maps.clear();
}","void clear(){
  for (  PartitionRecordStore recordStore : maps.values()) {
    recordStore.clear();
  }
  maps.clear();
}",0.9304347826086956
49128,"public void removeAll(){
  final Collection<Data> locks=lockStore != null ? lockStore.getLockedKeys() : Collections.<Data>emptySet();
  final Map<Data,Record> lockRecords=new HashMap<Data,Record>(locks.size());
  for (  Data key : locks) {
    Record record=records.get(key);
    if (record != null) {
      lockRecords.put(key,record);
    }
  }
  Set<Data> keysToDelete=records.keySet();
  keysToDelete.removeAll(lockRecords.keySet());
  final MapStoreWrapper store=mapContainer.getStore();
  if (store != null) {
    Set<Object> keysObject=new HashSet<Object>();
    for (    Data key : keysToDelete) {
      removeIndex(key);
      keysObject.add(mapService.toObject(key));
    }
    store.deleteAll(keysObject);
    toBeRemovedKeys.clear();
  }
  records.clear();
  records.putAll(lockRecords);
}","public void removeAll(){
  final Collection<Data> locks=lockStore != null ? lockStore.getLockedKeys() : Collections.<Data>emptySet();
  final Map<Data,Record> lockRecords=new HashMap<Data,Record>(locks.size());
  for (  Data key : locks) {
    Record record=records.get(key);
    if (record != null) {
      lockRecords.put(key,record);
    }
  }
  Set<Data> keysToDelete=records.keySet();
  keysToDelete.removeAll(lockRecords.keySet());
  final MapStoreWrapper store=mapContainer.getStore();
  Set<Object> keysObject=new HashSet<Object>();
  for (  Data key : keysToDelete) {
    removeIndex(key);
    keysObject.add(mapService.toObject(key));
  }
  if (store != null) {
    store.deleteAll(keysObject);
    toBeRemovedKeys.clear();
  }
  records.clear();
  records.putAll(lockRecords);
}",0.9635220125786164
49129,"void clear(){
  final LockService lockService=mapService.getNodeEngine().getSharedService(LockService.SERVICE_NAME);
  if (lockService != null) {
    lockService.clearLockStore(partitionContainer.getPartitionId(),new DefaultObjectNamespace(MapService.SERVICE_NAME,name));
  }
  records.clear();
}","void clear(){
  final LockService lockService=mapService.getNodeEngine().getSharedService(LockService.SERVICE_NAME);
  if (lockService != null) {
    lockService.clearLockStore(partitionContainer.getPartitionId(),new DefaultObjectNamespace(MapService.SERVICE_NAME,name));
  }
  records.clear();
  final IndexService indexService=mapContainer.getIndexService();
  if (indexService.hasIndex()) {
    indexService.clear();
  }
}",0.8210818307905686
49130,"public Portable[] readPortableArray(String fieldName) throws IOException {
  FieldDefinition fd=cd.get(fieldName);
  if (fd == null) {
    throw throwUnknownFieldException(fieldName);
  }
  final int currentPos=in.position();
  try {
    int pos=getPosition(fd);
    in.position(pos);
    final int len=in.readInt();
    final Portable[] portables=new Portable[len];
    if (len > 0) {
      final int offset=in.position();
      final PortableContextAwareInputStream ctxIn=(PortableContextAwareInputStream)in;
      try {
        ctxIn.setFactoryId(fd.getFactoryId());
        ctxIn.setClassId(fd.getClassId());
        for (int i=0; i < len; i++) {
          final int start=in.readInt(offset + i * 4);
          in.position(start);
          portables[i]=serializer.read(in);
        }
      }
  finally {
        ctxIn.setFactoryId(cd.getFactoryId());
        ctxIn.setClassId(cd.getClassId());
      }
    }
    return portables;
  }
  finally {
    in.position(currentPos);
  }
}","public Portable[] readPortableArray(String fieldName) throws IOException {
  FieldDefinition fd=cd.get(fieldName);
  if (fd == null) {
    throw throwUnknownFieldException(fieldName);
  }
  final int currentPos=in.position();
  try {
    int pos=getPosition(fd);
    in.position(pos);
    final int len=in.readInt();
    final Portable[] portables=new Portable[len];
    if (len > 0) {
      final int offset=in.position();
      final PortableContextAwareInputStream ctxIn=(PortableContextAwareInputStream)in;
      try {
        ctxIn.setFactoryId(fd.getFactoryId());
        ctxIn.setClassId(fd.getClassId());
        for (int i=0; i < len; i++) {
          final int start=in.readInt(offset + i * 4);
          in.position(start);
          portables[i]=serializer.readAndInitialize(in);
        }
      }
  finally {
        ctxIn.setFactoryId(cd.getFactoryId());
        ctxIn.setClassId(cd.getClassId());
      }
    }
    return portables;
  }
  finally {
    in.position(currentPos);
  }
}",0.9934442763489664
49131,"public Portable readPortable(String fieldName) throws IOException {
  FieldDefinition fd=cd.get(fieldName);
  if (fd == null) {
    throw throwUnknownFieldException(fieldName);
  }
  final int currentPos=in.position();
  try {
    int pos=getPosition(fd);
    in.position(pos);
    final boolean NULL=in.readBoolean();
    if (!NULL) {
      final PortableContextAwareInputStream ctxIn=(PortableContextAwareInputStream)in;
      try {
        ctxIn.setFactoryId(fd.getFactoryId());
        ctxIn.setClassId(fd.getClassId());
        return serializer.read(in);
      }
  finally {
        ctxIn.setFactoryId(cd.getFactoryId());
        ctxIn.setClassId(cd.getClassId());
      }
    }
    return null;
  }
  finally {
    in.position(currentPos);
  }
}","public Portable readPortable(String fieldName) throws IOException {
  FieldDefinition fd=cd.get(fieldName);
  if (fd == null) {
    throw throwUnknownFieldException(fieldName);
  }
  final int currentPos=in.position();
  try {
    int pos=getPosition(fd);
    in.position(pos);
    final boolean NULL=in.readBoolean();
    if (!NULL) {
      final PortableContextAwareInputStream ctxIn=(PortableContextAwareInputStream)in;
      try {
        ctxIn.setFactoryId(fd.getFactoryId());
        ctxIn.setClassId(fd.getClassId());
        return serializer.readAndInitialize(in);
      }
  finally {
        ctxIn.setFactoryId(cd.getFactoryId());
        ctxIn.setClassId(cd.getClassId());
      }
    }
    return null;
  }
  finally {
    in.position(currentPos);
  }
}",0.991430454845089
49132,"public int getVersion(){
  return version;
}","public final int getVersion(){
  return version;
}",0.9361702127659576
49133,"public int getClassId(){
  return classId;
}","public final int getClassId(){
  return classId;
}",0.9361702127659576
49134,"public byte[] getBinary(){
  return binary;
}","public final byte[] getBinary(){
  return binary;
}",0.9375
49135,"public int getFactoryId(){
  return factoryId;
}","public final int getFactoryId(){
  return factoryId;
}",0.9411764705882352
49136,"public BinaryClassDefinitionProxy(int factoryId,int classId,int version,byte[] binary){
  this.classId=classId;
  this.version=version;
  this.binary=binary;
  this.factoryId=factoryId;
}","public BinaryClassDefinitionProxy(int factoryId,int classId,int version,byte[] binary){
  this.classId=classId;
  this.version=version;
  this.factoryId=factoryId;
  setBinary(binary);
}",0.8847184986595175
49137,"public ClassDefinition toReal(SerializationContext context) throws IOException {
  final ClassDefinition cd=context.lookup(factoryId,classId,version);
  return cd != null ? cd : context.createClassDefinition(factoryId,binary);
}","public ClassDefinition toReal(SerializationContext context) throws IOException {
  final ClassDefinition cd=context.lookup(factoryId,classId,version);
  return cd != null ? cd : context.createClassDefinition(factoryId,getBinary());
}",0.9848156182212582
49138,"@Override public String toString(){
  final StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(classId);
  sb.append(""String_Node_Str"").append(version);
  sb.append(""String_Node_Str"").append(fieldDefinitions);
  sb.append('}');
  return sb.toString();
}","@Override public String toString(){
  final StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(factoryId);
  sb.append(""String_Node_Str"").append(classId);
  sb.append(""String_Node_Str"").append(version);
  sb.append(""String_Node_Str"").append(fieldDefinitions);
  sb.append('}');
  return sb.toString();
}",0.9253731343283582
49139,"ClassDefinition registerClassDefinition(ClassDefinition cd){
  if (cd == null)   return null;
  final ClassDefinitionImpl cdImpl=(ClassDefinitionImpl)cd;
  if (cdImpl.getVersion() < 0) {
    cdImpl.version=getVersion();
  }
  final long versionedClassId=combineToLong(cdImpl.getClassId(),cdImpl.getVersion());
  final ClassDefinitionImpl currentClassDef=versionedDefinitions.putIfAbsent(versionedClassId,cdImpl);
  if (currentClassDef == null) {
    registerNestedDefinitions(cdImpl);
    if (cdImpl.getBinary() == null) {
      final BufferObjectDataOutput out=serializationService.pop();
      try {
        cdImpl.writeData(out);
        final byte[] binary=out.toByteArray();
        out.clear();
        compress(binary,out);
        cdImpl.setBinary(out.toByteArray());
      }
 catch (      IOException e) {
        throw new HazelcastSerializationException(e);
      }
 finally {
        serializationService.push(out);
      }
    }
    return cd;
  }
  return currentClassDef;
}","ClassDefinition registerClassDefinition(ClassDefinition cd){
  if (cd == null)   return null;
  final ClassDefinitionImpl cdImpl=(ClassDefinitionImpl)cd;
  if (cdImpl.getVersion() < 0) {
    cdImpl.version=getVersion();
  }
  if (cdImpl.getBinary() == null) {
    final BufferObjectDataOutput out=serializationService.pop();
    try {
      cdImpl.writeData(out);
      final byte[] binary=out.toByteArray();
      out.clear();
      compress(binary,out);
      cdImpl.setBinary(out.toByteArray());
    }
 catch (    IOException e) {
      throw new HazelcastSerializationException(e);
    }
 finally {
      serializationService.push(out);
    }
  }
  final long versionedClassId=combineToLong(cdImpl.getClassId(),cdImpl.getVersion());
  final ClassDefinitionImpl currentClassDef=versionedDefinitions.putIfAbsent(versionedClassId,cdImpl);
  if (currentClassDef == null) {
    registerNestedDefinitions(cdImpl);
    return cd;
  }
  return currentClassDef;
}",0.6813977389516958
49140,"static void compress(byte[] input,DataOutput out) throws IOException {
  Deflater deflater=new Deflater();
  deflater.setLevel(Deflater.BEST_COMPRESSION);
  deflater.setInput(input);
  deflater.finish();
  byte[] buf=new byte[input.length / 10];
  while (!deflater.finished()) {
    int count=deflater.deflate(buf);
    out.write(buf,0,count);
  }
  deflater.end();
}","static void compress(byte[] input,DataOutput out) throws IOException {
  Deflater deflater=new Deflater();
  deflater.setLevel(Deflater.DEFAULT_COMPRESSION);
  deflater.setStrategy(Deflater.FILTERED);
  deflater.setInput(input);
  deflater.finish();
  byte[] buf=new byte[1024];
  while (!deflater.finished()) {
    int count=deflater.deflate(buf);
    out.write(buf,0,count);
  }
  deflater.end();
}",0.9126466753585396
49141,"ClassDefinition createClassDefinition(byte[] compressedBinary) throws IOException {
  final BufferObjectDataOutput out=serializationService.pop();
  final byte[] binary;
  try {
    decompress(compressedBinary,out);
    binary=out.toByteArray();
  }
  finally {
    serializationService.push(out);
  }
  final ClassDefinitionImpl cd=new ClassDefinitionImpl();
  cd.readData(serializationService.createObjectDataInput(binary));
  cd.setBinary(compressedBinary);
  final ClassDefinitionImpl currentCD=versionedDefinitions.putIfAbsent(combineToLong(cd.classId,getVersion()),cd);
  if (currentCD == null) {
    registerNestedDefinitions(cd);
    return cd;
  }
 else {
    return currentCD;
  }
}","ClassDefinition createClassDefinition(byte[] compressedBinary) throws IOException {
  if (compressedBinary == null || compressedBinary.length == 0) {
    throw new IOException(""String_Node_Str"");
  }
  final BufferObjectDataOutput out=serializationService.pop();
  final byte[] binary;
  try {
    decompress(compressedBinary,out);
    binary=out.toByteArray();
  }
  finally {
    serializationService.push(out);
  }
  final ClassDefinitionImpl cd=new ClassDefinitionImpl();
  cd.readData(serializationService.createObjectDataInput(binary));
  cd.setBinary(compressedBinary);
  final ClassDefinitionImpl currentCD=versionedDefinitions.putIfAbsent(combineToLong(cd.classId,getVersion()),cd);
  if (currentCD == null) {
    registerNestedDefinitions(cd);
    return cd;
  }
 else {
    return currentCD;
  }
}",0.9226666666666666
49142,"public MultiMapTransactionLog(Data key,CollectionProxyId proxyId,long ttl,int threadId,long version,Operation op){
  this.key=key;
  this.proxyId=proxyId;
  this.ttl=ttl;
  this.threadId=threadId;
  this.txVersion=version;
  opList.add(op);
}","public MultiMapTransactionLog(Data key,CollectionProxyId proxyId,long ttl,int threadId,long version){
  this.key=key;
  this.proxyId=proxyId;
  this.ttl=ttl;
  this.threadId=threadId;
  this.txVersion=version;
}",0.9315673289183224
49143,"protected Collection<CollectionRecord> removeAllInternal(Data key){
  throwExceptionIfNull(key);
  long timeout=tx.getTimeoutMillis();
  long ttl=timeout * 3 / 2;
  Collection<CollectionRecord> coll=txMap.get(key);
  if (coll == null) {
    CollectionResponse response=lockAndGet(key,timeout,ttl);
    if (response == null) {
      throw new ConcurrentModificationException(""String_Node_Str"" + getThreadId());
    }
    version=response.getTxVersion();
    coll=createCollection(response.getRecordCollection(getNodeEngine()));
  }
  txMap.put(key,createCollection());
  TxnRemoveAllOperation operation=new TxnRemoveAllOperation(proxyId,key,coll);
  MultiMapTransactionLog log=(MultiMapTransactionLog)tx.getTransactionLog(getTxLogKey(key));
  if (log != null) {
    log.addOperation(operation);
  }
 else {
    log=new MultiMapTransactionLog(key,proxyId,ttl,getThreadId(),version,operation);
    tx.addTransactionLog(log);
  }
  return coll;
}","protected Collection<CollectionRecord> removeAllInternal(Data key){
  throwExceptionIfNull(key);
  long timeout=tx.getTimeoutMillis();
  long ttl=timeout * 3 / 2;
  Collection<CollectionRecord> coll=txMap.get(key);
  final MultiMapTransactionLog log;
  if (coll == null) {
    CollectionResponse response=lockAndGet(key,timeout,ttl);
    if (response == null) {
      throw new ConcurrentModificationException(""String_Node_Str"" + getThreadId());
    }
    log=new MultiMapTransactionLog(key,proxyId,ttl,getThreadId(),version);
    version=response.getTxVersion();
    coll=createCollection(response.getRecordCollection(getNodeEngine()));
  }
 else {
    log=(MultiMapTransactionLog)tx.getTransactionLog(getTxLogKey(key));
  }
  txMap.put(key,createCollection());
  TxnRemoveAllOperation operation=new TxnRemoveAllOperation(proxyId,key,coll);
  log.addOperation(operation);
  return coll;
}",0.7405789186237028
49144,"protected boolean putInternal(Data key,Data value){
  throwExceptionIfNull(key);
  throwExceptionIfNull(value);
  Collection<CollectionRecord> coll=txMap.get(key);
  long recordId=-1;
  long timeout=tx.getTimeoutMillis();
  long ttl=timeout * 3 / 2;
  if (coll == null) {
    CollectionResponse response=lockAndGet(key,timeout,ttl);
    if (response == null) {
      throw new ConcurrentModificationException(""String_Node_Str"" + getThreadId());
    }
    recordId=response.getNextRecordId();
    version=response.getTxVersion();
    coll=createCollection(response.getRecordCollection(getNodeEngine()));
    txMap.put(key,coll);
  }
  CollectionRecord record=new CollectionRecord(config.isBinary() ? value : getNodeEngine().toObject(value));
  if (coll.add(record)) {
    if (recordId == -1) {
      recordId=nextId(key);
    }
    record.setRecordId(recordId);
    TxnPutOperation operation=new TxnPutOperation(proxyId,key,value,recordId);
    MultiMapTransactionLog log=(MultiMapTransactionLog)tx.getTransactionLog(getTxLogKey(key));
    if (log != null) {
      log.addOperation(operation);
    }
 else {
      log=new MultiMapTransactionLog(key,proxyId,ttl,getThreadId(),version,operation);
      tx.addTransactionLog(log);
    }
    return true;
  }
  return false;
}","protected boolean putInternal(Data key,Data value){
  throwExceptionIfNull(key);
  throwExceptionIfNull(value);
  Collection<CollectionRecord> coll=txMap.get(key);
  long recordId=-1;
  long timeout=tx.getTimeoutMillis();
  long ttl=timeout * 3 / 2;
  final MultiMapTransactionLog log;
  if (coll == null) {
    CollectionResponse response=lockAndGet(key,timeout,ttl);
    if (response == null) {
      throw new ConcurrentModificationException(""String_Node_Str"" + getThreadId());
    }
    log=new MultiMapTransactionLog(key,proxyId,ttl,getThreadId(),version);
    tx.addTransactionLog(log);
    recordId=response.getNextRecordId();
    version=response.getTxVersion();
    coll=createCollection(response.getRecordCollection(getNodeEngine()));
    txMap.put(key,coll);
  }
 else {
    log=(MultiMapTransactionLog)tx.getTransactionLog(getTxLogKey(key));
  }
  CollectionRecord record=new CollectionRecord(config.isBinary() ? value : getNodeEngine().toObject(value));
  if (coll.add(record)) {
    if (recordId == -1) {
      recordId=nextId(key);
    }
    record.setRecordId(recordId);
    TxnPutOperation operation=new TxnPutOperation(proxyId,key,value,recordId);
    log.addOperation(operation);
    return true;
  }
  return false;
}",0.6244019138755981
49145,"protected boolean removeInternal(Data key,Data value){
  throwExceptionIfNull(key);
  throwExceptionIfNull(value);
  Collection<CollectionRecord> coll=txMap.get(key);
  long timeout=tx.getTimeoutMillis();
  long ttl=timeout * 3 / 2;
  if (coll == null) {
    CollectionResponse response=lockAndGet(key,timeout,ttl);
    if (response == null) {
      throw new ConcurrentModificationException(""String_Node_Str"" + getThreadId());
    }
    version=response.getTxVersion();
    coll=createCollection(response.getRecordCollection(getNodeEngine()));
    txMap.put(key,coll);
  }
  CollectionRecord record=new CollectionRecord(config.isBinary() ? value : getNodeEngine().toObject(value));
  Iterator<CollectionRecord> iterator=coll.iterator();
  long recordId=-1;
  while (iterator.hasNext()) {
    CollectionRecord r=iterator.next();
    if (r.equals(record)) {
      iterator.remove();
      recordId=r.getRecordId();
      break;
    }
  }
  if (version != -1 || recordId != -1) {
    TxnRemoveOperation operation=new TxnRemoveOperation(proxyId,key,recordId,value);
    MultiMapTransactionLog log=(MultiMapTransactionLog)tx.getTransactionLog(getTxLogKey(key));
    if (log != null) {
      log.addOperation(operation);
    }
 else {
      log=new MultiMapTransactionLog(key,proxyId,ttl,getThreadId(),version,operation);
      tx.addTransactionLog(log);
    }
    return recordId != -1;
  }
  return false;
}","protected boolean removeInternal(Data key,Data value){
  throwExceptionIfNull(key);
  throwExceptionIfNull(value);
  Collection<CollectionRecord> coll=txMap.get(key);
  long timeout=tx.getTimeoutMillis();
  long ttl=timeout * 3 / 2;
  final MultiMapTransactionLog log;
  if (coll == null) {
    CollectionResponse response=lockAndGet(key,timeout,ttl);
    if (response == null) {
      throw new ConcurrentModificationException(""String_Node_Str"" + getThreadId());
    }
    log=new MultiMapTransactionLog(key,proxyId,ttl,getThreadId(),version);
    tx.addTransactionLog(log);
    version=response.getTxVersion();
    coll=createCollection(response.getRecordCollection(getNodeEngine()));
    txMap.put(key,coll);
  }
 else {
    log=(MultiMapTransactionLog)tx.getTransactionLog(getTxLogKey(key));
  }
  CollectionRecord record=new CollectionRecord(config.isBinary() ? value : getNodeEngine().toObject(value));
  Iterator<CollectionRecord> iterator=coll.iterator();
  long recordId=-1;
  while (iterator.hasNext()) {
    CollectionRecord r=iterator.next();
    if (r.equals(record)) {
      iterator.remove();
      recordId=r.getRecordId();
      break;
    }
  }
  if (version != -1 || recordId != -1) {
    TxnRemoveOperation operation=new TxnRemoveOperation(proxyId,key,recordId,value);
    log.addOperation(operation);
    return recordId != -1;
  }
  return false;
}",0.7361211247296323
49146,"@Override public String toString(){
  return ""String_Node_Str"" + endpoint + ""String_Node_Str""+ socket.getInetAddress().getHostAddress()+ ""String_Node_Str""+ socket.getPort()+ ""String_Node_Str"";
}","@Override public String toString(){
  return ""String_Node_Str"" + endpoint + ""String_Node_Str""+ socket.getLocalSocketAddress()+ ""String_Node_Str"";
}",0.8093841642228738
49147,"public Connection getConnection(Address address) throws IOException {
  checkLive();
  if (address == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final ObjectPool<ConnectionWrapper> pool=getConnectionPool(address);
  if (pool == null) {
    return null;
  }
  Connection connection=null;
  try {
    connection=pool.take();
  }
 catch (  Exception e) {
    logger.log(Level.WARNING,""String_Node_Str"",e);
  }
  if (connection != null && !heartbeat.checkHeartBeat(connection)) {
    connection.close();
    connection=null;
  }
  return connection;
}","public Connection getConnection(Address address) throws IOException {
  checkLive();
  if (address == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final ObjectPool<ConnectionWrapper> pool=getConnectionPool(address);
  if (pool == null) {
    return null;
  }
  Connection connection=null;
  try {
    connection=pool.take();
  }
 catch (  Exception e) {
    logger.log(Level.WARNING,""String_Node_Str"" + address,e);
  }
  if (connection != null && !heartbeat.checkHeartBeat(connection)) {
    logger.log(Level.WARNING,connection + ""String_Node_Str"");
    connection.close();
    connection=null;
  }
  return connection;
}",0.9249592169657422
49148,"public void close(){
  IOUtil.closeResource(connection);
}","public void close(){
  logger.log(Level.INFO,""String_Node_Str"" + connection);
  IOUtil.closeResource(connection);
}",0.6705202312138728
49149,"private <T>T sendAndReceive(Connection conn,Object obj) throws IOException {
  try {
    final SerializationService serializationService=getSerializationService();
    final Data request=serializationService.toData(obj);
    conn.write(request);
    final Data response=conn.read();
    final Object result=serializationService.toObject(response);
    return ErrorHandler.returnResultOrThrowException(result);
  }
 catch (  Exception e) {
    return retryOrThrowException(obj,null,e);
  }
}","<T>T sendAndReceive(final Address address,Object obj) throws IOException {
  return _sendAndReceive(new TargetConnectionFactory(address),obj);
}",0.2744479495268139
49150,"private void beforeRetry(){
  try {
    Thread.sleep(RETRY_WAIT_TIME);
  }
 catch (  InterruptedException ignored) {
  }
}","private void beforeRetry(){
  try {
    Thread.sleep(RETRY_WAIT_TIME);
    ((ClientPartitionServiceImpl)client.getClientPartitionService()).refreshPartitions();
  }
 catch (  InterruptedException ignored) {
  }
}",0.7305389221556886
49151,"private void sendAndHandle(Connection conn,Object obj,ResponseHandler handler) throws IOException {
  ResponseStream stream=null;
  try {
    final SerializationService serializationService=getSerializationService();
    final Data request=serializationService.toData(obj);
    conn.write(request);
    stream=new ResponseStreamImpl(serializationService,conn);
  }
 catch (  Exception e) {
    retryOrThrowException(obj,handler,e);
  }
  if (stream != null) {
    try {
      handler.handle(stream);
    }
 catch (    Exception e) {
      throw ExceptionUtil.rethrow(e,IOException.class);
    }
 finally {
      stream.end();
    }
  }
}","void sendAndHandle(Object obj,ResponseHandler handler) throws IOException {
  _sendAndHandle(randomConnectionFactory,obj,handler);
}",0.2756827048114434
49152,"private void loadInitialMemberList() throws IOException {
  SerializableCollection coll=sendAndReceive(conn,new AddMembershipListenerRequest());
  final SerializationService serializationService=getSerializationService();
  Map<String,MemberImpl> prevMembers=Collections.emptyMap();
  if (!members.isEmpty()) {
    prevMembers=new HashMap<String,MemberImpl>(members.size());
    for (    MemberImpl member : members) {
      prevMembers.put(member.getUuid(),member);
    }
    members.clear();
  }
  for (  Data d : coll.getCollection()) {
    members.add((MemberImpl)serializationService.toObject(d));
  }
  updateMembersRef();
  logger.log(Level.INFO,membersString());
  final List<MembershipEvent> events=new LinkedList<MembershipEvent>();
  for (  MemberImpl member : members) {
    final MemberImpl former=prevMembers.remove(member.getUuid());
    if (former == null) {
      events.add(new MembershipEvent(member,MembershipEvent.MEMBER_ADDED));
    }
  }
  for (  MemberImpl member : prevMembers.values()) {
    events.add(new MembershipEvent(member,MembershipEvent.MEMBER_REMOVED));
  }
  for (  MembershipEvent event : events) {
    fireMembershipEvent(event);
  }
}","private void loadInitialMemberList() throws IOException {
  final SerializationService serializationService=getSerializationService();
  final Data request=serializationService.toData(new AddMembershipListenerRequest());
  conn.write(request);
  final Data response=conn.read();
  SerializableCollection coll=ErrorHandler.returnResultOrThrowException(serializationService.toObject(response));
  Map<String,MemberImpl> prevMembers=Collections.emptyMap();
  if (!members.isEmpty()) {
    prevMembers=new HashMap<String,MemberImpl>(members.size());
    for (    MemberImpl member : members) {
      prevMembers.put(member.getUuid(),member);
    }
    members.clear();
  }
  for (  Data d : coll.getCollection()) {
    members.add((MemberImpl)serializationService.toObject(d));
  }
  updateMembersRef();
  logger.log(Level.INFO,membersString());
  final List<MembershipEvent> events=new LinkedList<MembershipEvent>();
  for (  MemberImpl member : members) {
    final MemberImpl former=prevMembers.remove(member.getUuid());
    if (former == null) {
      events.add(new MembershipEvent(member,MembershipEvent.MEMBER_ADDED));
    }
  }
  for (  MemberImpl member : prevMembers.values()) {
    events.add(new MembershipEvent(member,MembershipEvent.MEMBER_REMOVED));
  }
  for (  MembershipEvent event : events) {
    fireMembershipEvent(event);
  }
}",0.8344581183009131
49153,"private void processPartitionResponse(PartitionsResponse response){
  final Address[] members=response.getMembers();
  final int[] ownerIndexes=response.getOwnerIndexes();
  if (partitionCount == 0) {
    partitions=new ConcurrentHashMap<Integer,Address>(271,0.75f,1);
    partitionCount=ownerIndexes.length;
  }
  for (int partitionId=0; partitionId < partitionCount; partitionId++) {
    final int ownerIndex=ownerIndexes[partitionId];
    if (ownerIndex > -1) {
      partitions.put(partitionId,members[ownerIndex]);
    }
  }
}","private void processPartitionResponse(PartitionsResponse response){
  final Address[] members=response.getMembers();
  final int[] ownerIndexes=response.getOwnerIndexes();
  if (partitionCount == 0) {
    partitionCount=ownerIndexes.length;
  }
  for (int partitionId=0; partitionId < partitionCount; partitionId++) {
    final int ownerIndex=ownerIndexes[partitionId];
    if (ownerIndex > -1) {
      partitions.put(partitionId,members[ownerIndex]);
    }
  }
}",0.93158953722334
49154,"public void start(){
  getInitialPartitions();
  client.getClientExecutionService().scheduleWithFixedDelay(new Runnable(){
    public void run(){
      final ClientClusterService clusterService=client.getClientClusterService();
      final Address master=clusterService.getMasterAddress();
      final PartitionsResponse response=getPartitionsFrom((ClientClusterServiceImpl)clusterService,master);
      if (response != null) {
        processPartitionResponse(response);
      }
    }
  }
,10,10,TimeUnit.SECONDS);
}","public void start(){
  getInitialPartitions();
  client.getClientExecutionService().scheduleWithFixedDelay(new RefreshTask(),10,10,TimeUnit.SECONDS);
}",0.4431137724550898
49155,"public void run(){
  final ClientClusterService clusterService=client.getClientClusterService();
  final Address master=clusterService.getMasterAddress();
  final PartitionsResponse response=getPartitionsFrom((ClientClusterServiceImpl)clusterService,master);
  if (response != null) {
    processPartitionResponse(response);
  }
}","public void run(){
  if (updating.compareAndSet(false,true)) {
    try {
      final ClientClusterService clusterService=client.getClientClusterService();
      final Address master=clusterService.getMasterAddress();
      final PartitionsResponse response=getPartitionsFrom((ClientClusterServiceImpl)clusterService,master);
      if (response != null) {
        processPartitionResponse(response);
      }
    }
  finally {
      updating.set(false);
    }
  }
}",0.832282471626734
49156,"@Test public void testOperationRedo() throws Exception {
  final HazelcastInstance hz1=Hazelcast.newHazelcastInstance();
  final HazelcastInstance hz2=Hazelcast.newHazelcastInstance();
  ClientConfig clientConfig=new ClientConfig();
  clientConfig.setRedoOperation(true);
  HazelcastInstance client=HazelcastClient.newHazelcastClient(clientConfig);
  final Thread thread=new Thread(){
    public void run(){
      try {
        Thread.sleep(100);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
      hz1.getLifecycleService().terminate();
    }
  }
;
  final IQueue<Object> q=client.getQueue(""String_Node_Str"");
  thread.start();
  for (int i=0; i < 1000; i++) {
    q.offer(""String_Node_Str"" + i);
  }
  thread.join();
  assertEquals(1000,q.size());
}","@Test public void testOperationRedo() throws Exception {
  final HazelcastInstance hz1=Hazelcast.newHazelcastInstance();
  final HazelcastInstance hz2=Hazelcast.newHazelcastInstance();
  ClientConfig clientConfig=new ClientConfig();
  clientConfig.setRedoOperation(true);
  HazelcastInstance client=HazelcastClient.newHazelcastClient(clientConfig);
  final Thread thread=new Thread(){
    public void run(){
      try {
        Thread.sleep(100);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
      hz1.getLifecycleService().terminate();
    }
  }
;
  final IMap map=client.getMap(""String_Node_Str"");
  thread.start();
  int expected=1000;
  for (int i=0; i < expected; i++) {
    map.put(i,""String_Node_Str"" + i);
  }
  thread.join();
  assertEquals(expected,map.size());
}",0.9232688708671242
49157,"@Test @ClientCompatibleTest public void testLatchMigration() throws InterruptedException {
  TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(5);
  HazelcastInstance hz1=factory.newHazelcastInstance(new Config());
  HazelcastInstance hz2=factory.newHazelcastInstance(new Config());
  final ICountDownLatch latch1=hz1.getCountDownLatch(""String_Node_Str"");
  latch1.trySetCount(10);
  Thread.sleep(100);
  final ICountDownLatch latch2=hz2.getCountDownLatch(""String_Node_Str"");
  Assert.assertEquals(10,latch2.getCount());
  latch2.countDown();
  Assert.assertEquals(9,latch1.getCount());
  hz1.getLifecycleService().shutdown();
  Assert.assertEquals(9,latch2.getCount());
  HazelcastInstance hz3=factory.newHazelcastInstance(new Config());
  final ICountDownLatch latch3=hz3.getCountDownLatch(""String_Node_Str"");
  latch3.countDown();
  Assert.assertEquals(8,latch3.getCount());
  hz2.getLifecycleService().shutdown();
  latch3.countDown();
  Assert.assertEquals(7,latch3.getCount());
  HazelcastInstance hz4=factory.newHazelcastInstance(new Config());
  HazelcastInstance hz5=factory.newHazelcastInstance(new Config());
  Thread.sleep(250);
  hz3.getLifecycleService().shutdown();
  final ICountDownLatch latch4=hz4.getCountDownLatch(""String_Node_Str"");
  Assert.assertEquals(7,latch4.getCount());
  final ICountDownLatch latch5=hz5.getCountDownLatch(""String_Node_Str"");
  latch5.countDown();
  Assert.assertEquals(6,latch5.getCount());
  latch5.countDown();
  Assert.assertEquals(5,latch4.getCount());
  Assert.assertEquals(5,latch5.getCount());
}","@Test @ClientCompatibleTest public void testLatchMigration() throws InterruptedException {
  TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(5);
  HazelcastInstance hz1=factory.newHazelcastInstance(new Config());
  HazelcastInstance hz2=factory.newHazelcastInstance(new Config());
  warmUpPartitions(hz2,hz1);
  final ICountDownLatch latch1=hz1.getCountDownLatch(""String_Node_Str"");
  latch1.trySetCount(10);
  Thread.sleep(500);
  final ICountDownLatch latch2=hz2.getCountDownLatch(""String_Node_Str"");
  Assert.assertEquals(10,latch2.getCount());
  latch2.countDown();
  Assert.assertEquals(9,latch1.getCount());
  hz1.getLifecycleService().shutdown();
  Assert.assertEquals(9,latch2.getCount());
  HazelcastInstance hz3=factory.newHazelcastInstance(new Config());
  warmUpPartitions(hz3);
  final ICountDownLatch latch3=hz3.getCountDownLatch(""String_Node_Str"");
  latch3.countDown();
  Assert.assertEquals(8,latch3.getCount());
  hz2.getLifecycleService().shutdown();
  latch3.countDown();
  Assert.assertEquals(7,latch3.getCount());
  HazelcastInstance hz4=factory.newHazelcastInstance(new Config());
  HazelcastInstance hz5=factory.newHazelcastInstance(new Config());
  warmUpPartitions(hz5,hz4);
  Thread.sleep(250);
  hz3.getLifecycleService().shutdown();
  final ICountDownLatch latch4=hz4.getCountDownLatch(""String_Node_Str"");
  Assert.assertEquals(7,latch4.getCount());
  final ICountDownLatch latch5=hz5.getCountDownLatch(""String_Node_Str"");
  latch5.countDown();
  Assert.assertEquals(6,latch5.getCount());
  latch5.countDown();
  Assert.assertEquals(5,latch4.getCount());
  Assert.assertEquals(5,latch5.getCount());
}",0.973561430793157
49158,"/** 
 * Testing if topic can properly listen messages and if topic has any issue after a shutdown.
 */
@Test public void testTopicCluster(){
  final Config cfg=new Config();
  TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(2);
  HazelcastInstance[] instances=factory.newInstances(cfg);
  HazelcastInstance h1=instances[0];
  HazelcastInstance h2=instances[1];
  String topicName=""String_Node_Str"";
  ITopic<String> topic1=h1.getTopic(topicName);
  final CountDownLatch latch1=new CountDownLatch(1);
  topic1.addMessageListener(new MessageListener<String>(){
    public void onMessage(    Message msg){
      assertEquals(""String_Node_Str"",msg.getMessageObject());
      latch1.countDown();
    }
  }
);
  ITopic<String> topic2=h2.getTopic(topicName);
  final CountDownLatch latch2=new CountDownLatch(2);
  topic2.addMessageListener(new MessageListener<String>(){
    public void onMessage(    Message msg){
      assertEquals(""String_Node_Str"",msg.getMessageObject());
      latch2.countDown();
    }
  }
);
  topic1.publish(""String_Node_Str"");
  h1.getLifecycleService().shutdown();
  topic2.publish(""String_Node_Str"");
  try {
    assertTrue(latch1.await(5,TimeUnit.SECONDS));
    assertTrue(latch2.await(5,TimeUnit.SECONDS));
  }
 catch (  InterruptedException ignored) {
  }
}","/** 
 * Testing if topic can properly listen messages and if topic has any issue after a shutdown.
 */
@Test public void testTopicCluster() throws InterruptedException {
  final Config cfg=new Config();
  TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(2);
  HazelcastInstance[] instances=factory.newInstances(cfg);
  HazelcastInstance h1=instances[0];
  HazelcastInstance h2=instances[1];
  String topicName=""String_Node_Str"";
  ITopic<String> topic1=h1.getTopic(topicName);
  final CountDownLatch latch1=new CountDownLatch(1);
  final String message=""String_Node_Str"";
  topic1.addMessageListener(new MessageListener<String>(){
    public void onMessage(    Message msg){
      assertEquals(message,msg.getMessageObject());
      latch1.countDown();
    }
  }
);
  ITopic<String> topic2=h2.getTopic(topicName);
  final CountDownLatch latch2=new CountDownLatch(2);
  topic2.addMessageListener(new MessageListener<String>(){
    public void onMessage(    Message msg){
      assertEquals(message,msg.getMessageObject());
      latch2.countDown();
    }
  }
);
  topic1.publish(message);
  assertTrue(latch1.await(5,TimeUnit.SECONDS));
  h1.getLifecycleService().shutdown();
  topic2.publish(message);
  assertTrue(latch2.await(5,TimeUnit.SECONDS));
}",0.8642551536367172
49159,"@Test public void testMapEvictAndListener() throws InterruptedException {
  IMap<String,String> map=getInstance().getMap(""String_Node_Str"");
  final String value1=""String_Node_Str"";
  final String value2=""String_Node_Str"";
  final List<String> newList=new CopyOnWriteArrayList<String>();
  final CountDownLatch latch1=new CountDownLatch(1);
  final CountDownLatch latch2=new CountDownLatch(1);
  map.addEntryListener(new EntryAdapter<String,String>(){
    public void entryEvicted(    EntryEvent<String,String> event){
      if (value1.equals(event.getValue())) {
        latch1.countDown();
      }
 else       if (value2.equals(event.getValue())) {
        latch2.countDown();
      }
      newList.add(event.getValue());
    }
  }
,true);
  map.put(""String_Node_Str"",value1,1,TimeUnit.SECONDS);
  assertTrue(latch1.await(10,TimeUnit.SECONDS));
  map.put(""String_Node_Str"",value2,1,TimeUnit.SECONDS);
  assertTrue(latch2.await(10,TimeUnit.SECONDS));
  assertEquals(value1,newList.get(0));
  assertEquals(value2,newList.get(1));
}","@Test public void testMapEvictAndListener() throws InterruptedException {
  IMap<String,String> map=getInstance().getMap(""String_Node_Str"");
  final String value1=""String_Node_Str"";
  final String value2=""String_Node_Str"";
  final List<String> newList=new CopyOnWriteArrayList<String>();
  final CountDownLatch latch1=new CountDownLatch(1);
  final CountDownLatch latch2=new CountDownLatch(1);
  map.addEntryListener(new EntryAdapter<String,String>(){
    public void entryEvicted(    EntryEvent<String,String> event){
      if (value1.equals(event.getValue())) {
        newList.add(event.getValue());
        latch1.countDown();
      }
 else       if (value2.equals(event.getValue())) {
        newList.add(event.getValue());
        latch2.countDown();
      }
    }
  }
,true);
  map.put(""String_Node_Str"",value1,1,TimeUnit.SECONDS);
  assertTrue(latch1.await(10,TimeUnit.SECONDS));
  map.put(""String_Node_Str"",value2,1,TimeUnit.SECONDS);
  assertTrue(latch2.await(10,TimeUnit.SECONDS));
  assertEquals(value1,newList.get(0));
  assertEquals(value2,newList.get(1));
}",0.9453162149310508
49160,"public void run(){
  int ttl=(int)(Math.random() * 5000 + 3000);
  for (int j=0; j < putCount; j++) {
    final long expectedEvictionTime=ttl + System.currentTimeMillis();
    map.put(j + putCount * threadId,expectedEvictionTime,ttl,TimeUnit.MILLISECONDS);
  }
}","public void run(){
  while (!Thread.currentThread().isInterrupted()) {
    try {
      for (int i=0; i < nsize; i++) {
        map.get(i);
      }
      Thread.sleep(1000);
    }
 catch (    HazelcastInstanceNotActiveException e) {
      return;
    }
catch (    InterruptedException e) {
      return;
    }
  }
}",0.1180555555555555
49161,"@Test public void testMapPutTtlWithListener() throws InterruptedException {
  Config cfg=new Config();
  TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(2);
  final HazelcastInstance[] instances=factory.newInstances(cfg);
  warmUpPartitions(instances);
  final int k=10;
  final int putCount=10000;
  final CountDownLatch latch=new CountDownLatch(k * putCount);
  final IMap map=instances[0].getMap(""String_Node_Str"");
  final ExecutorService ex=Executors.newFixedThreadPool(k * 2);
  final AtomicBoolean error=new AtomicBoolean(false);
  final Set<Long> times=Collections.newSetFromMap(new ConcurrentHashMap<Long,Boolean>());
  map.addEntryListener(new EntryAdapter(){
    public void entryEvicted(    final EntryEvent event){
      ex.execute(new Runnable(){
        public void run(){
          final Long expectedEvictionTime=(Long)(event.getOldValue());
          long timeDifference=System.currentTimeMillis() - expectedEvictionTime;
          if (timeDifference > 5000) {
            error.set(true);
            times.add(timeDifference);
          }
          latch.countDown();
        }
      }
);
    }
  }
,true);
  for (int i=0; i < k; i++) {
    final int threadId=i;
    ex.execute(new Runnable(){
      public void run(){
        int ttl=(int)(Math.random() * 5000 + 3000);
        for (int j=0; j < putCount; j++) {
          final long expectedEvictionTime=ttl + System.currentTimeMillis();
          map.put(j + putCount * threadId,expectedEvictionTime,ttl,TimeUnit.MILLISECONDS);
        }
      }
    }
);
  }
  try {
    assertTrue(latch.await(1,TimeUnit.MINUTES));
    assertFalse(""String_Node_Str"" + times,error.get());
  }
  finally {
    ex.shutdownNow();
  }
}","@Test public void testMapPutTtlWithListener() throws InterruptedException {
  Config cfg=new Config();
  TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(2);
  final HazelcastInstance[] instances=factory.newInstances(cfg);
  warmUpPartitions(instances);
  final int k=10;
  final int putCount=10000;
  final CountDownLatch latch=new CountDownLatch(k * putCount);
  final IMap map=instances[0].getMap(""String_Node_Str"");
  final AtomicBoolean error=new AtomicBoolean(false);
  final Set<Long> times=Collections.newSetFromMap(new ConcurrentHashMap<Long,Boolean>());
  map.addEntryListener(new EntryAdapter(){
    public void entryEvicted(    final EntryEvent event){
      final Long expectedEvictionTime=(Long)(event.getOldValue());
      long timeDifference=System.currentTimeMillis() - expectedEvictionTime;
      if (timeDifference > 5000) {
        error.set(true);
        times.add(timeDifference);
      }
      latch.countDown();
    }
  }
,true);
  for (int i=0; i < k; i++) {
    final int threadId=i;
    int ttl=(int)(Math.random() * 5000 + 3000);
    for (int j=0; j < putCount; j++) {
      final long expectedEvictionTime=ttl + System.currentTimeMillis();
      map.put(j + putCount * threadId,expectedEvictionTime,ttl,TimeUnit.MILLISECONDS);
    }
  }
  assertTrue(latch.await(1,TimeUnit.MINUTES));
  assertFalse(""String_Node_Str"" + times,error.get());
}",0.8856589147286822
49162,"protected void invalidateValueCache(){
  if (cmap.isCacheValue()) {
    valueObject=null;
  }
}","protected void invalidateValueCache(){
  if (cmap.isCacheValue()) {
synchronized (this) {
      valueObject=null;
    }
  }
}",0.8636363636363636
49163,"public final void init(final FilterConfig config) throws ServletException {
  filterConfig=config;
  servletContext=config.getServletContext();
  initInstance();
  String debugParam=getParam(""String_Node_Str"");
  if (debugParam != null) {
    debug=Boolean.valueOf(debugParam);
  }
  String mapName=getParam(""String_Node_Str"");
  if (mapName != null) {
    clusterMapName=mapName;
  }
 else {
    clusterMapName=""String_Node_Str"" + servletContext.getServletContextName();
  }
  Config hzConfig=hazelcastInstance.getConfig();
  String sessionTTL=getParam(""String_Node_Str"");
  if (sessionTTL != null) {
    MapConfig mapConfig=new MapConfig(clusterMapName);
    mapConfig.setTimeToLiveSeconds(Integer.valueOf(sessionTTL));
    hzConfig.addMapConfig(mapConfig);
  }
  String cookieName=getParam(""String_Node_Str"");
  if (cookieName != null) {
    sessionCookieName=cookieName;
  }
  String cookieDomain=getParam(""String_Node_Str"");
  if (cookieDomain != null) {
    sessionCookieDomain=cookieDomain;
  }
  String cookieSecure=getParam(""String_Node_Str"");
  if (cookieSecure != null) {
    sessionCookieSecure=Boolean.valueOf(cookieSecure);
  }
  String cookieHttpOnly=getParam(""String_Node_Str"");
  if (cookieHttpOnly != null) {
    sessionCookieHttpOnly=Boolean.valueOf(cookieHttpOnly);
  }
  String stickySessionParam=getParam(""String_Node_Str"");
  if (stickySessionParam != null) {
    stickySession=Boolean.valueOf(stickySessionParam);
  }
  String shutdownOnDestroyParam=getParam(""String_Node_Str"");
  if (shutdownOnDestroyParam != null) {
    shutdownOnDestroy=Boolean.valueOf(shutdownOnDestroyParam);
  }
  if (!stickySession) {
    getClusterMap().addEntryListener(new EntryListener(){
      public void entryAdded(      EntryEvent entryEvent){
      }
      public void entryRemoved(      EntryEvent entryEvent){
        if (entryEvent.getMember() == null || !entryEvent.getMember().localMember()) {
          removeSessionLocally((String)entryEvent.getKey());
        }
      }
      public void entryUpdated(      EntryEvent entryEvent){
        if (entryEvent.getMember() == null || !entryEvent.getMember().localMember()) {
          markSessionDirty((String)entryEvent.getKey());
        }
      }
      public void entryEvicted(      EntryEvent entryEvent){
        entryRemoved(entryEvent);
      }
    }
,false);
  }
  log(""String_Node_Str"" + stickySession + ""String_Node_Str""+ debug+ ""String_Node_Str""+ shutdownOnDestroy+ ""String_Node_Str""+ clusterMapName);
}","public final void init(final FilterConfig config) throws ServletException {
  filterConfig=config;
  servletContext=config.getServletContext();
  initInstance();
  String debugParam=getParam(""String_Node_Str"");
  if (debugParam != null) {
    debug=Boolean.valueOf(debugParam);
  }
  String mapName=getParam(""String_Node_Str"");
  if (mapName != null) {
    clusterMapName=mapName;
  }
 else {
    clusterMapName=""String_Node_Str"" + servletContext.getServletContextName();
  }
  try {
    Config hzConfig=hazelcastInstance.getConfig();
    String sessionTTL=getParam(""String_Node_Str"");
    if (sessionTTL != null) {
      MapConfig mapConfig=new MapConfig(clusterMapName);
      mapConfig.setTimeToLiveSeconds(Integer.valueOf(sessionTTL));
      hzConfig.addMapConfig(mapConfig);
    }
  }
 catch (  UnsupportedOperationException ignored) {
  }
  String cookieName=getParam(""String_Node_Str"");
  if (cookieName != null) {
    sessionCookieName=cookieName;
  }
  String cookieDomain=getParam(""String_Node_Str"");
  if (cookieDomain != null) {
    sessionCookieDomain=cookieDomain;
  }
  String cookieSecure=getParam(""String_Node_Str"");
  if (cookieSecure != null) {
    sessionCookieSecure=Boolean.valueOf(cookieSecure);
  }
  String cookieHttpOnly=getParam(""String_Node_Str"");
  if (cookieHttpOnly != null) {
    sessionCookieHttpOnly=Boolean.valueOf(cookieHttpOnly);
  }
  String stickySessionParam=getParam(""String_Node_Str"");
  if (stickySessionParam != null) {
    stickySession=Boolean.valueOf(stickySessionParam);
  }
  String shutdownOnDestroyParam=getParam(""String_Node_Str"");
  if (shutdownOnDestroyParam != null) {
    shutdownOnDestroy=Boolean.valueOf(shutdownOnDestroyParam);
  }
  if (!stickySession) {
    getClusterMap().addEntryListener(new EntryListener(){
      public void entryAdded(      EntryEvent entryEvent){
      }
      public void entryRemoved(      EntryEvent entryEvent){
        if (entryEvent.getMember() == null || !entryEvent.getMember().localMember()) {
          removeSessionLocally((String)entryEvent.getKey());
        }
      }
      public void entryUpdated(      EntryEvent entryEvent){
        if (entryEvent.getMember() == null || !entryEvent.getMember().localMember()) {
          markSessionDirty((String)entryEvent.getKey());
        }
      }
      public void entryEvicted(      EntryEvent entryEvent){
        entryRemoved(entryEvent);
      }
    }
,false);
  }
  log(""String_Node_Str"" + stickySession + ""String_Node_Str""+ debug+ ""String_Node_Str""+ shutdownOnDestroy+ ""String_Node_Str""+ clusterMapName);
}",0.9838934181745874
49164,"public Set<Data> localKeySet(CollectionProxyId proxyId){
  Set<Data> keySet=new HashSet<Data>();
  ClusterServiceImpl clusterService=(ClusterServiceImpl)nodeEngine.getClusterService();
  Address thisAddress=clusterService.getThisAddress();
  for (int i=0; i < nodeEngine.getPartitionService().getPartitionCount(); i++) {
    PartitionView partition=nodeEngine.getPartitionService().getPartitionView(i);
    CollectionPartitionContainer partitionContainer=getPartitionContainer(i);
    CollectionContainer collectionContainer=partitionContainer.getCollectionContainer(proxyId);
    if (collectionContainer == null) {
      continue;
    }
    if (partition.getOwner().equals(thisAddress)) {
      keySet.addAll(collectionContainer.keySet());
    }
  }
  getLocalMultiMapStatsImpl(proxyId).incrementOtherOperations();
  return keySet;
}","public Set<Data> localKeySet(CollectionProxyId proxyId){
  Set<Data> keySet=new HashSet<Data>();
  ClusterServiceImpl clusterService=(ClusterServiceImpl)nodeEngine.getClusterService();
  Address thisAddress=clusterService.getThisAddress();
  for (int i=0; i < nodeEngine.getPartitionService().getPartitionCount(); i++) {
    PartitionView partition=nodeEngine.getPartitionService().getPartition(i);
    CollectionPartitionContainer partitionContainer=getPartitionContainer(i);
    CollectionContainer collectionContainer=partitionContainer.getCollectionContainer(proxyId);
    if (collectionContainer == null) {
      continue;
    }
    if (partition.getOwner().equals(thisAddress)) {
      keySet.addAll(collectionContainer.keySet());
    }
  }
  getLocalMultiMapStatsImpl(proxyId).incrementOtherOperations();
  return keySet;
}",0.997596153846154
49165,"public LocalMapStats createStats(CollectionProxyId proxyId){
  LocalMultiMapStatsImpl stats=getLocalMultiMapStatsImpl(proxyId);
  long ownedEntryCount=0;
  long backupEntryCount=0;
  long dirtyCount=0;
  long ownedEntryMemoryCost=0;
  long backupEntryMemoryCost=0;
  long hits=0;
  long lockedEntryCount=0;
  ClusterServiceImpl clusterService=(ClusterServiceImpl)nodeEngine.getClusterService();
  Address thisAddress=clusterService.getThisAddress();
  for (int i=0; i < nodeEngine.getPartitionService().getPartitionCount(); i++) {
    PartitionView partition=nodeEngine.getPartitionService().getPartitionView(i);
    CollectionPartitionContainer partitionContainer=getPartitionContainer(i);
    CollectionContainer collectionContainer=partitionContainer.getCollectionContainer(proxyId);
    if (collectionContainer == null) {
      continue;
    }
    if (partition.getOwner().equals(thisAddress)) {
      lockedEntryCount+=collectionContainer.getLockedCount();
      for (      CollectionWrapper wrapper : collectionContainer.collections.values()) {
        hits+=wrapper.getHits();
        ownedEntryCount+=wrapper.getCollection().size();
      }
    }
 else {
      int backupCount=collectionContainer.config.getTotalBackupCount();
      for (int j=1; j <= backupCount; j++) {
        Address replicaAddress=partition.getReplicaAddress(j);
        int memberSize=nodeEngine.getClusterService().getMembers().size();
        int tryCount=3;
        while (memberSize > backupCount && replicaAddress == null && tryCount-- > 0) {
          try {
            Thread.sleep(1000);
          }
 catch (          InterruptedException e) {
            throw ExceptionUtil.rethrow(e);
          }
          replicaAddress=partition.getReplicaAddress(j);
        }
        if (replicaAddress != null && replicaAddress.equals(thisAddress)) {
          for (          CollectionWrapper wrapper : collectionContainer.collections.values()) {
            backupEntryCount+=wrapper.getCollection().size();
          }
        }
      }
    }
  }
  stats.setOwnedEntryCount(ownedEntryCount);
  stats.setBackupEntryCount(backupEntryCount);
  stats.setHits(hits);
  stats.setLockedEntryCount(lockedEntryCount);
  return stats;
}","public LocalMapStats createStats(CollectionProxyId proxyId){
  LocalMultiMapStatsImpl stats=getLocalMultiMapStatsImpl(proxyId);
  long ownedEntryCount=0;
  long backupEntryCount=0;
  long dirtyCount=0;
  long ownedEntryMemoryCost=0;
  long backupEntryMemoryCost=0;
  long hits=0;
  long lockedEntryCount=0;
  ClusterServiceImpl clusterService=(ClusterServiceImpl)nodeEngine.getClusterService();
  Address thisAddress=clusterService.getThisAddress();
  for (int i=0; i < nodeEngine.getPartitionService().getPartitionCount(); i++) {
    PartitionView partition=nodeEngine.getPartitionService().getPartition(i);
    CollectionPartitionContainer partitionContainer=getPartitionContainer(i);
    CollectionContainer collectionContainer=partitionContainer.getCollectionContainer(proxyId);
    if (collectionContainer == null) {
      continue;
    }
    if (partition.getOwner().equals(thisAddress)) {
      lockedEntryCount+=collectionContainer.getLockedCount();
      for (      CollectionWrapper wrapper : collectionContainer.collections.values()) {
        hits+=wrapper.getHits();
        ownedEntryCount+=wrapper.getCollection().size();
      }
    }
 else {
      int backupCount=collectionContainer.config.getTotalBackupCount();
      for (int j=1; j <= backupCount; j++) {
        Address replicaAddress=partition.getReplicaAddress(j);
        int memberSize=nodeEngine.getClusterService().getMembers().size();
        int tryCount=3;
        while (memberSize > backupCount && replicaAddress == null && tryCount-- > 0) {
          try {
            Thread.sleep(1000);
          }
 catch (          InterruptedException e) {
            throw ExceptionUtil.rethrow(e);
          }
          replicaAddress=partition.getReplicaAddress(j);
        }
        if (replicaAddress != null && replicaAddress.equals(thisAddress)) {
          for (          CollectionWrapper wrapper : collectionContainer.collections.values()) {
            backupEntryCount+=wrapper.getCollection().size();
          }
        }
      }
    }
  }
  stats.setOwnedEntryCount(ownedEntryCount);
  stats.setBackupEntryCount(backupEntryCount);
  stats.setHits(hits);
  stats.setLockedEntryCount(lockedEntryCount);
  return stats;
}",0.9990942028985508
49166,"private void onOwnerDisconnected(final String caller){
  for (  String name : permitMap.keySet()) {
    int partitionId=nodeEngine.getPartitionService().getPartitionId(name);
    PartitionView info=nodeEngine.getPartitionService().getPartitionView(partitionId);
    if (nodeEngine.getThisAddress().equals(info.getOwner())) {
      Operation op=new SemaphoreDeadMemberOperation(name,caller).setPartitionId(partitionId).setResponseHandler(ResponseHandlerFactory.createEmptyResponseHandler()).setService(this).setNodeEngine(nodeEngine).setServiceName(SERVICE_NAME);
      nodeEngine.getOperationService().executeOperation(op);
    }
  }
}","private void onOwnerDisconnected(final String caller){
  for (  String name : permitMap.keySet()) {
    int partitionId=nodeEngine.getPartitionService().getPartitionId(name);
    PartitionView info=nodeEngine.getPartitionService().getPartition(partitionId);
    if (nodeEngine.getThisAddress().equals(info.getOwner())) {
      Operation op=new SemaphoreDeadMemberOperation(name,caller).setPartitionId(partitionId).setResponseHandler(ResponseHandlerFactory.createEmptyResponseHandler()).setService(this).setNodeEngine(nodeEngine).setServiceName(SERVICE_NAME);
      nodeEngine.getOperationService().executeOperation(op);
    }
  }
}",0.9968404423380728
49167,"public void readData(ObjectDataInput in) throws IOException {
  partitionId=in.readInt();
  oldOwner=new MemberImpl();
  oldOwner.readData(in);
  newOwner=new MemberImpl();
  newOwner.readData(in);
  status=MigrationStatus.readFrom(in);
}","public void readData(ObjectDataInput in) throws IOException {
  partitionId=in.readInt();
  oldOwner=in.readObject();
  newOwner=in.readObject();
  status=MigrationStatus.readFrom(in);
}",0.8207547169811321
49168,"@Override public String toString(){
  return ""String_Node_Str"" + ""String_Node_Str"" + partitionId + ""String_Node_Str""+ oldOwner+ ""String_Node_Str""+ newOwner+ '}';
}","@Override public String toString(){
  final StringBuilder sb=new StringBuilder(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(partitionId);
  sb.append(""String_Node_Str"").append(status);
  sb.append(""String_Node_Str"").append(oldOwner);
  sb.append(""String_Node_Str"").append(newOwner);
  sb.append('}');
  return sb.toString();
}",0.2828685258964143
49169,"public void writeData(ObjectDataOutput out) throws IOException {
  out.writeInt(partitionId);
  oldOwner.writeData(out);
  newOwner.writeData(out);
  MigrationStatus.writeTo(status,out);
}","public void writeData(ObjectDataOutput out) throws IOException {
  out.writeInt(partitionId);
  out.writeObject(oldOwner);
  out.writeObject(newOwner);
  MigrationStatus.writeTo(status,out);
}",0.8578947368421053
49170,"public void rollbackMigration(PartitionMigrationEvent event){
  logger.log(Level.FINEST,""String_Node_Str"" + event);
  if (event.getMigrationEndpoint() == MigrationEndpoint.DESTINATION) {
    clearPartitionData(event.getPartitionId());
  }
  ownedPartitions.set(nodeEngine.getPartitionService().getMemberPartitions(nodeEngine.getThisAddress()));
}","public void rollbackMigration(PartitionMigrationEvent event){
  if (event.getMigrationEndpoint() == MigrationEndpoint.DESTINATION) {
    clearPartitionData(event.getPartitionId());
  }
  ownedPartitions.set(nodeEngine.getPartitionService().getMemberPartitions(nodeEngine.getThisAddress()));
}",0.915360501567398
49171,"private void migrateIndex(PartitionMigrationEvent event){
  final PartitionContainer container=partitionContainers[event.getPartitionId()];
  for (  PartitionRecordStore mapPartition : container.getMaps().values()) {
    final MapContainer mapContainer=getMapContainer(mapPartition.name);
    final IndexService indexService=mapContainer.getIndexService();
    if (indexService.hasIndex()) {
      for (      Record record : mapPartition.getRecords().values()) {
        if (event.getMigrationEndpoint() == MigrationEndpoint.SOURCE) {
          indexService.removeEntryIndex(record.getKey());
        }
 else {
          indexService.saveEntryIndex(new QueryEntry(getSerializationService(),record.getKey(),record.getKey(),record.getValue()));
        }
      }
    }
  }
}","private void migrateIndex(PartitionMigrationEvent event){
  final PartitionContainer container=partitionContainers[event.getPartitionId()];
  for (  PartitionRecordStore recordStore : container.getMaps().values()) {
    final MapContainer mapContainer=getMapContainer(recordStore.name);
    final IndexService indexService=mapContainer.getIndexService();
    if (indexService.hasIndex()) {
      for (      Record record : recordStore.getRecords().values()) {
        if (event.getMigrationEndpoint() == MigrationEndpoint.SOURCE) {
          indexService.removeEntryIndex(record.getKey());
        }
 else {
          indexService.saveEntryIndex(new QueryEntry(getSerializationService(),record.getKey(),record.getKey(),record.getValue()));
        }
      }
    }
  }
}",0.9552238805970148
49172,"public Operation prepareReplicationOperation(PartitionReplicationEvent event){
  logger.log(Level.FINEST,""String_Node_Str"" + event);
  final PartitionContainer container=partitionContainers[event.getPartitionId()];
  final MapReplicationOperation operation=new MapReplicationOperation(container,event.getPartitionId(),event.getReplicaIndex());
  return operation.isEmpty() ? null : operation;
}","public Operation prepareReplicationOperation(PartitionReplicationEvent event){
  final PartitionContainer container=partitionContainers[event.getPartitionId()];
  final MapReplicationOperation operation=new MapReplicationOperation(container,event.getPartitionId(),event.getReplicaIndex());
  return operation.isEmpty() ? null : operation;
}",0.9264305177111716
49173,"public LocalMapStatsImpl createLocalMapStats(String mapName){
  MapContainer mapContainer=getMapContainer(mapName);
  LocalMapStatsImpl localMapStats=getLocalMapStatsImpl(mapName);
  if (!mapContainer.getMapConfig().isStatisticsEnabled()) {
    return localMapStats;
  }
  long ownedEntryCount=0;
  long backupEntryCount=0;
  long dirtyCount=0;
  long ownedEntryMemoryCost=0;
  long backupEntryMemoryCost=0;
  long hits=0;
  long lockedEntryCount=0;
  int backupCount=mapContainer.getTotalBackupCount();
  ClusterService clusterService=nodeEngine.getClusterService();
  final com.hazelcast.partition.PartitionService partitionService=nodeEngine.getPartitionService();
  Address thisAddress=clusterService.getThisAddress();
  for (int partitionId=0; partitionId < partitionService.getPartitionCount(); partitionId++) {
    PartitionView partition=partitionService.getPartitionView(partitionId);
    if (partition.getOwner().equals(thisAddress)) {
      PartitionContainer partitionContainer=getPartitionContainer(partitionId);
      RecordStore recordStore=partitionContainer.getRecordStore(mapName);
      Map<Data,Record> records=recordStore.getRecords();
      for (      Record record : records.values()) {
        RecordStatistics stats=record.getStatistics();
        ownedEntryCount++;
        ownedEntryMemoryCost+=record.getCost();
        localMapStats.setLastAccessTime(stats.getLastAccessTime());
        hits+=stats.getHits();
        if (recordStore.isLocked(record.getKey())) {
          lockedEntryCount++;
        }
      }
    }
 else {
      for (int replica=1; replica <= backupCount; replica++) {
        Address replicaAddress=partition.getReplicaAddress(replica);
        int tryCount=30;
        while (replicaAddress == null && clusterService.getSize() > backupCount && tryCount-- > 0) {
          try {
            Thread.sleep(100);
          }
 catch (          InterruptedException e) {
            throw ExceptionUtil.rethrow(e);
          }
          replicaAddress=partition.getReplicaAddress(replica);
        }
        if (replicaAddress != null && replicaAddress.equals(thisAddress)) {
          PartitionContainer partitionContainer=getPartitionContainer(partitionId);
          RecordStore recordStore=partitionContainer.getRecordStore(mapName);
          Map<Data,Record> records=recordStore.getRecords();
          for (          Record record : records.values()) {
            backupEntryCount++;
            backupEntryMemoryCost+=record.getCost();
          }
        }
 else         if (replicaAddress == null && clusterService.getSize() > backupCount) {
          logger.log(Level.WARNING,""String_Node_Str"" + partition + ""String_Node_Str""+ replica+ ""String_Node_Str"");
        }
      }
    }
  }
  if (mapContainer.getMapStoreWriteScheduler() != null && mapContainer.getMapStoreDeleteScheduler() != null) {
    dirtyCount=mapContainer.getMapStoreWriteScheduler().size() + mapContainer.getMapStoreDeleteScheduler().size();
  }
  localMapStats.setBackupCount(backupCount);
  localMapStats.setDirtyEntryCount(zeroOrPositive(dirtyCount));
  localMapStats.setLockedEntryCount(zeroOrPositive(lockedEntryCount));
  localMapStats.setHits(zeroOrPositive(hits));
  localMapStats.setOwnedEntryCount(zeroOrPositive(ownedEntryCount));
  localMapStats.setBackupEntryCount(zeroOrPositive(backupEntryCount));
  localMapStats.setOwnedEntryMemoryCost(zeroOrPositive(ownedEntryMemoryCost));
  localMapStats.setBackupEntryMemoryCost(zeroOrPositive(backupEntryMemoryCost));
  return localMapStats;
}","public LocalMapStatsImpl createLocalMapStats(String mapName){
  MapContainer mapContainer=getMapContainer(mapName);
  LocalMapStatsImpl localMapStats=getLocalMapStatsImpl(mapName);
  if (!mapContainer.getMapConfig().isStatisticsEnabled()) {
    return localMapStats;
  }
  long ownedEntryCount=0;
  long backupEntryCount=0;
  long dirtyCount=0;
  long ownedEntryMemoryCost=0;
  long backupEntryMemoryCost=0;
  long hits=0;
  long lockedEntryCount=0;
  int backupCount=mapContainer.getTotalBackupCount();
  ClusterService clusterService=nodeEngine.getClusterService();
  final com.hazelcast.partition.PartitionService partitionService=nodeEngine.getPartitionService();
  Address thisAddress=clusterService.getThisAddress();
  for (int partitionId=0; partitionId < partitionService.getPartitionCount(); partitionId++) {
    PartitionView partition=partitionService.getPartition(partitionId);
    if (partition.getOwner().equals(thisAddress)) {
      PartitionContainer partitionContainer=getPartitionContainer(partitionId);
      RecordStore recordStore=partitionContainer.getRecordStore(mapName);
      Map<Data,Record> records=recordStore.getRecords();
      for (      Record record : records.values()) {
        RecordStatistics stats=record.getStatistics();
        ownedEntryCount++;
        ownedEntryMemoryCost+=record.getCost();
        localMapStats.setLastAccessTime(stats.getLastAccessTime());
        hits+=stats.getHits();
        if (recordStore.isLocked(record.getKey())) {
          lockedEntryCount++;
        }
      }
    }
 else {
      for (int replica=1; replica <= backupCount; replica++) {
        Address replicaAddress=partition.getReplicaAddress(replica);
        int tryCount=30;
        while (replicaAddress == null && clusterService.getSize() > backupCount && tryCount-- > 0) {
          try {
            Thread.sleep(100);
          }
 catch (          InterruptedException e) {
            throw ExceptionUtil.rethrow(e);
          }
          replicaAddress=partition.getReplicaAddress(replica);
        }
        if (replicaAddress != null && replicaAddress.equals(thisAddress)) {
          PartitionContainer partitionContainer=getPartitionContainer(partitionId);
          RecordStore recordStore=partitionContainer.getRecordStore(mapName);
          Map<Data,Record> records=recordStore.getRecords();
          for (          Record record : records.values()) {
            backupEntryCount++;
            backupEntryMemoryCost+=record.getCost();
          }
        }
 else         if (replicaAddress == null && clusterService.getSize() > backupCount) {
          logger.log(Level.WARNING,""String_Node_Str"" + partition + ""String_Node_Str""+ replica+ ""String_Node_Str"");
        }
      }
    }
  }
  if (mapContainer.getMapStoreWriteScheduler() != null && mapContainer.getMapStoreDeleteScheduler() != null) {
    dirtyCount=mapContainer.getMapStoreWriteScheduler().size() + mapContainer.getMapStoreDeleteScheduler().size();
  }
  localMapStats.setBackupCount(backupCount);
  localMapStats.setDirtyEntryCount(zeroOrPositive(dirtyCount));
  localMapStats.setLockedEntryCount(zeroOrPositive(lockedEntryCount));
  localMapStats.setHits(zeroOrPositive(hits));
  localMapStats.setOwnedEntryCount(zeroOrPositive(ownedEntryCount));
  localMapStats.setBackupEntryCount(zeroOrPositive(backupEntryCount));
  localMapStats.setOwnedEntryMemoryCost(zeroOrPositive(ownedEntryMemoryCost));
  localMapStats.setBackupEntryMemoryCost(zeroOrPositive(backupEntryMemoryCost));
  return localMapStats;
}",0.999431818181818
49174,"private void clearPartitionData(final int partitionId){
  logger.log(Level.FINEST,""String_Node_Str"" + partitionId);
  final PartitionContainer container=partitionContainers[partitionId];
  if (container != null) {
    for (    PartitionRecordStore mapPartition : container.getMaps().values()) {
      mapPartition.clear();
    }
    container.getMaps().clear();
  }
}","private void clearPartitionData(final int partitionId){
  final PartitionContainer container=partitionContainers[partitionId];
  if (container != null) {
    for (    PartitionRecordStore mapPartition : container.getMaps().values()) {
      mapPartition.clear();
    }
    container.getMaps().clear();
  }
}",0.9109792284866468
49175,"public void commitMigration(PartitionMigrationEvent event){
  logger.log(Level.FINEST,""String_Node_Str"" + event);
  if (event.getMigrationEndpoint() == MigrationEndpoint.SOURCE) {
    migrateIndex(event);
    clearPartitionData(event.getPartitionId());
  }
 else {
    migrateIndex(event);
  }
  ownedPartitions.set(nodeEngine.getPartitionService().getMemberPartitions(nodeEngine.getThisAddress()));
}","public void commitMigration(PartitionMigrationEvent event){
  if (event.getMigrationEndpoint() == MigrationEndpoint.SOURCE) {
    migrateIndex(event);
    clearPartitionData(event.getPartitionId());
  }
 else {
    migrateIndex(event);
  }
  ownedPartitions.set(nodeEngine.getPartitionService().getMemberPartitions(nodeEngine.getThisAddress()));
}",0.927807486631016
49176,"@Override protected final void invoke(){
  Collection<MemberImpl> members=getClientEngine().getClusterService().getMemberList();
  int partitionCount=getClientEngine().getPartitionService().getPartitionCount();
  Set<Integer> plist=new HashSet<Integer>(partitionCount);
  final ClientEndpoint endpoint=getEndpoint();
  QueryDataResultStream result=new QueryDataResultStream(iterationType,true);
  try {
    List<Future> flist=new ArrayList<Future>();
    final Predicate predicate=getPredicate();
    for (    MemberImpl member : members) {
      Invocation invocation=createInvocationBuilder(SERVICE_NAME,new QueryOperation(name,predicate),member.getAddress()).build();
      Future future=invocation.invoke();
      flist.add(future);
    }
    for (    Future future : flist) {
      QueryResult queryResult=(QueryResult)future.get();
      if (queryResult != null) {
        final List<Integer> partitionIds=queryResult.getPartitionIds();
        if (partitionIds != null) {
          plist.addAll(partitionIds);
          result.addAll(queryResult.getResult());
        }
      }
    }
    if (plist.size() != partitionCount) {
      List<Integer> missingList=new ArrayList<Integer>();
      for (int i=0; i < partitionCount; i++) {
        if (!plist.contains(i)) {
          missingList.add(i);
        }
      }
      List<Future> futures=new ArrayList<Future>(missingList.size());
      for (      Integer pid : missingList) {
        QueryPartitionOperation queryPartitionOperation=new QueryPartitionOperation(name,predicate);
        queryPartitionOperation.setPartitionId(pid);
        try {
          Future f=createInvocationBuilder(SERVICE_NAME,queryPartitionOperation,pid).build().invoke();
          futures.add(f);
        }
 catch (        Throwable t) {
          throw ExceptionUtil.rethrow(t);
        }
      }
      for (      Future future : futures) {
        QueryResult queryResult=(QueryResult)future.get();
        result.addAll(queryResult.getResult());
      }
    }
  }
 catch (  Throwable t) {
    t.printStackTrace();
    throw ExceptionUtil.rethrow(t);
  }
 finally {
    result.end();
  }
  getClientEngine().sendResponse(endpoint,result);
}","@Override protected final void invoke(){
  Collection<MemberImpl> members=getClientEngine().getClusterService().getMemberList();
  int partitionCount=getClientEngine().getPartitionService().getPartitionCount();
  Set<Integer> plist=new HashSet<Integer>(partitionCount);
  final ClientEndpoint endpoint=getEndpoint();
  QueryResultSet result=new QueryResultSet(null,iterationType,true);
  try {
    List<Future> flist=new ArrayList<Future>();
    final Predicate predicate=getPredicate();
    for (    MemberImpl member : members) {
      Invocation invocation=createInvocationBuilder(SERVICE_NAME,new QueryOperation(name,predicate),member.getAddress()).build();
      Future future=invocation.invoke();
      flist.add(future);
    }
    for (    Future future : flist) {
      QueryResult queryResult=(QueryResult)future.get();
      if (queryResult != null) {
        final List<Integer> partitionIds=queryResult.getPartitionIds();
        if (partitionIds != null) {
          plist.addAll(partitionIds);
          result.addAll(queryResult.getResult());
        }
      }
    }
    if (plist.size() != partitionCount) {
      List<Integer> missingList=new ArrayList<Integer>();
      for (int i=0; i < partitionCount; i++) {
        if (!plist.contains(i)) {
          missingList.add(i);
        }
      }
      List<Future> futures=new ArrayList<Future>(missingList.size());
      for (      Integer pid : missingList) {
        QueryPartitionOperation queryPartitionOperation=new QueryPartitionOperation(name,predicate);
        queryPartitionOperation.setPartitionId(pid);
        try {
          Future f=createInvocationBuilder(SERVICE_NAME,queryPartitionOperation,pid).build().invoke();
          futures.add(f);
        }
 catch (        Throwable t) {
          throw ExceptionUtil.rethrow(t);
        }
      }
      for (      Future future : futures) {
        QueryResult queryResult=(QueryResult)future.get();
        result.addAll(queryResult.getResult());
      }
    }
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
  getClientEngine().sendResponse(endpoint,result);
}",0.9564000932618326
49177,"private Collection<Operation> prepareMigrationTasks(){
  NodeEngineImpl nodeEngine=(NodeEngineImpl)getNodeEngine();
  final PartitionReplicationEvent replicationEvent=new PartitionReplicationEvent(migrationInfo.getPartitionId(),0);
  final PartitionMigrationEvent migrationEvent=new PartitionMigrationEvent(MigrationEndpoint.SOURCE,migrationInfo.getPartitionId());
  final Collection<Operation> tasks=new LinkedList<Operation>();
  for (  ServiceInfo serviceInfo : nodeEngine.getServiceInfos(MigrationAwareService.class)) {
    MigrationAwareService service=(MigrationAwareService)serviceInfo.getService();
    final Operation op=service.prepareReplicationOperation(replicationEvent);
    if (op != null) {
      op.setServiceName(serviceInfo.getName());
      service.beforeMigration(migrationEvent);
      tasks.add(op);
    }
  }
  return tasks;
}","private Collection<Operation> prepareMigrationTasks(){
  NodeEngineImpl nodeEngine=(NodeEngineImpl)getNodeEngine();
  final PartitionReplicationEvent replicationEvent=new PartitionReplicationEvent(migrationInfo.getPartitionId(),0);
  final PartitionMigrationEvent migrationEvent=new PartitionMigrationEvent(MigrationEndpoint.SOURCE,migrationInfo.getPartitionId());
  final Collection<Operation> tasks=new LinkedList<Operation>();
  for (  ServiceInfo serviceInfo : nodeEngine.getServiceInfos(MigrationAwareService.class)) {
    MigrationAwareService service=(MigrationAwareService)serviceInfo.getService();
    service.beforeMigration(migrationEvent);
    final Operation op=service.prepareReplicationOperation(replicationEvent);
    if (op != null) {
      op.setServiceName(serviceInfo.getName());
      tasks.add(op);
    }
  }
  return tasks;
}",0.945818610129564
49178,"public void run(){
  final BufferObjectDataOutput out=serializationService.createObjectDataOutput(1024 * 32);
  try {
    out.writeInt(tasks.size());
    for (    Operation task : tasks) {
      serializationService.writeObject(out,task);
    }
    final byte[] data=IOUtil.compress(out.toByteArray());
    final MigrationOperation migrationOperation=new MigrationOperation(migrationInfo,replicaVersions,data,tasks.size());
    Invocation inv=nodeEngine.getOperationService().createInvocationBuilder(PartitionServiceImpl.SERVICE_NAME,migrationOperation,to).setTryPauseMillis(1000).setReplicaIndex(getReplicaIndex()).build();
    Future future=inv.invoke();
    Boolean result=(Boolean)nodeEngine.toObject(future.get(timeout,TimeUnit.SECONDS));
    responseHandler.sendResponse(result);
  }
 catch (  Throwable e) {
    responseHandler.sendResponse(Boolean.FALSE);
    if (e instanceof ExecutionException) {
      e=e.getCause() != null ? e.getCause() : e;
    }
    Level level=(e instanceof MemberLeftException || e instanceof InterruptedException) || !getNodeEngine().isActive() ? Level.INFO : Level.WARNING;
    getLogger().log(level,e.getMessage(),e);
  }
 finally {
    IOUtil.closeResource(out);
  }
}","public void run(){
  final BufferObjectDataOutput out=serializationService.createObjectDataOutput(1024 * 32);
  try {
    out.writeInt(tasks.size());
    for (    Operation task : tasks) {
      serializationService.writeObject(out,task);
    }
    final byte[] data=IOUtil.compress(out.toByteArray());
    final MigrationOperation migrationOperation=new MigrationOperation(migrationInfo,replicaVersions,data,tasks.size());
    Invocation inv=nodeEngine.getOperationService().createInvocationBuilder(PartitionServiceImpl.SERVICE_NAME,migrationOperation,destination).setTryPauseMillis(1000).setReplicaIndex(getReplicaIndex()).build();
    Future future=inv.invoke();
    Boolean result=(Boolean)nodeEngine.toObject(future.get(timeout,TimeUnit.SECONDS));
    responseHandler.sendResponse(result);
  }
 catch (  Throwable e) {
    responseHandler.sendResponse(Boolean.FALSE);
    if (e instanceof ExecutionException) {
      e=e.getCause() != null ? e.getCause() : e;
    }
    Level level=(e instanceof MemberLeftException || e instanceof InterruptedException) || !getNodeEngine().isActive() ? Level.INFO : Level.WARNING;
    getLogger().log(level,e.getMessage(),e);
  }
 finally {
    IOUtil.closeResource(out);
  }
}",0.9946347503095336
49179,"public final void init(final FilterConfig config) throws ServletException {
  filterConfig=config;
  servletContext=config.getServletContext();
  initInstance();
  String debugParam=getParam(""String_Node_Str"");
  if (debugParam != null) {
    debug=Boolean.valueOf(debugParam);
  }
  String mapName=getParam(""String_Node_Str"");
  if (mapName != null) {
    clusterMapName=mapName;
  }
 else {
    clusterMapName=""String_Node_Str"" + servletContext.getServletContextName();
  }
  Config hzConfig=hazelcastInstance.getConfig();
  String sessionTTL=getParam(""String_Node_Str"");
  if (sessionTTL != null) {
    MapConfig mapConfig=new MapConfig(clusterMapName);
    mapConfig.setTimeToLiveSeconds(Integer.valueOf(sessionTTL));
    hzConfig.addMapConfig(mapConfig);
  }
  String cookieName=getParam(""String_Node_Str"");
  if (cookieName != null) {
    sessionCookieName=cookieName;
  }
  String cookieDomain=getParam(""String_Node_Str"");
  if (cookieDomain != null) {
    sessionCookieDomain=cookieDomain;
  }
  String cookieSecure=getParam(""String_Node_Str"");
  if (cookieSecure != null) {
    sessionCookieSecure=Boolean.valueOf(cookieSecure);
  }
  String cookieHttpOnly=getParam(""String_Node_Str"");
  if (cookieHttpOnly != null) {
    sessionCookieHttpOnly=Boolean.valueOf(cookieHttpOnly);
  }
  String stickySessionParam=getParam(""String_Node_Str"");
  if (stickySessionParam != null) {
    stickySession=Boolean.valueOf(stickySessionParam);
  }
  String shutdownOnDestroyParam=getParam(""String_Node_Str"");
  if (shutdownOnDestroyParam != null) {
    shutdownOnDestroy=Boolean.valueOf(shutdownOnDestroyParam);
  }
  if (!stickySession) {
    getClusterMap().addEntryListener(new EntryListener(){
      public void entryAdded(      EntryEvent entryEvent){
      }
      public void entryRemoved(      EntryEvent entryEvent){
        if (entryEvent.getMember() == null || !entryEvent.getMember().localMember()) {
          removeSessionLocally((String)entryEvent.getKey());
        }
      }
      public void entryUpdated(      EntryEvent entryEvent){
        if (entryEvent.getMember() == null || !entryEvent.getMember().localMember()) {
          markSessionDirty((String)entryEvent.getKey());
        }
      }
      public void entryEvicted(      EntryEvent entryEvent){
        entryRemoved(entryEvent);
      }
    }
,false);
  }
  log(""String_Node_Str"" + stickySession + ""String_Node_Str""+ debug+ ""String_Node_Str""+ shutdownOnDestroy+ ""String_Node_Str""+ clusterMapName);
}","public final void init(final FilterConfig config) throws ServletException {
  filterConfig=config;
  servletContext=config.getServletContext();
  initInstance();
  String debugParam=getParam(""String_Node_Str"");
  if (debugParam != null) {
    debug=Boolean.valueOf(debugParam);
  }
  String mapName=getParam(""String_Node_Str"");
  if (mapName != null) {
    clusterMapName=mapName;
  }
 else {
    clusterMapName=""String_Node_Str"" + servletContext.getServletContextName();
  }
  try {
    Config hzConfig=hazelcastInstance.getConfig();
    String sessionTTL=getParam(""String_Node_Str"");
    if (sessionTTL != null) {
      MapConfig mapConfig=new MapConfig(clusterMapName);
      mapConfig.setTimeToLiveSeconds(Integer.valueOf(sessionTTL));
      hzConfig.addMapConfig(mapConfig);
    }
  }
 catch (  UnsupportedOperationException ignored) {
  }
  String cookieName=getParam(""String_Node_Str"");
  if (cookieName != null) {
    sessionCookieName=cookieName;
  }
  String cookieDomain=getParam(""String_Node_Str"");
  if (cookieDomain != null) {
    sessionCookieDomain=cookieDomain;
  }
  String cookieSecure=getParam(""String_Node_Str"");
  if (cookieSecure != null) {
    sessionCookieSecure=Boolean.valueOf(cookieSecure);
  }
  String cookieHttpOnly=getParam(""String_Node_Str"");
  if (cookieHttpOnly != null) {
    sessionCookieHttpOnly=Boolean.valueOf(cookieHttpOnly);
  }
  String stickySessionParam=getParam(""String_Node_Str"");
  if (stickySessionParam != null) {
    stickySession=Boolean.valueOf(stickySessionParam);
  }
  String shutdownOnDestroyParam=getParam(""String_Node_Str"");
  if (shutdownOnDestroyParam != null) {
    shutdownOnDestroy=Boolean.valueOf(shutdownOnDestroyParam);
  }
  if (!stickySession) {
    getClusterMap().addEntryListener(new EntryListener(){
      public void entryAdded(      EntryEvent entryEvent){
      }
      public void entryRemoved(      EntryEvent entryEvent){
        if (entryEvent.getMember() == null || !entryEvent.getMember().localMember()) {
          removeSessionLocally((String)entryEvent.getKey());
        }
      }
      public void entryUpdated(      EntryEvent entryEvent){
        if (entryEvent.getMember() == null || !entryEvent.getMember().localMember()) {
          markSessionDirty((String)entryEvent.getKey());
        }
      }
      public void entryEvicted(      EntryEvent entryEvent){
        entryRemoved(entryEvent);
      }
    }
,false);
  }
  log(""String_Node_Str"" + stickySession + ""String_Node_Str""+ debug+ ""String_Node_Str""+ shutdownOnDestroy+ ""String_Node_Str""+ clusterMapName);
}",0.9838934181745874
49180,"public static void main(String[] args) throws Exception {
  final String baseDir=""String_Node_Str"";
  final String sourceDir=baseDir + ""String_Node_Str"";
  Server server=new Server();
  SelectChannelConnector connector=new SelectChannelConnector();
  connector.setPort(8080);
  server.addConnector(connector);
  WebAppContext context=new WebAppContext();
  context.setResourceBase(sourceDir);
  context.setDescriptor(sourceDir + ""String_Node_Str"");
  context.setLogUrlOnStart(true);
  context.setContextPath(""String_Node_Str"");
  context.setParentLoaderPriority(true);
  server.setHandler(context);
  server.start();
  server.join();
}","public static void main(String[] args) throws Exception {
  final String baseDir=args.length > 0 ? args[0] : ""String_Node_Str"";
  final String sourceDir=baseDir + ""String_Node_Str"";
  Server server=new Server();
  SelectChannelConnector connector=new SelectChannelConnector();
  connector.setPort(8080);
  server.addConnector(connector);
  WebAppContext context=new WebAppContext();
  context.setResourceBase(sourceDir);
  context.setDescriptor(sourceDir + ""String_Node_Str"");
  context.setLogUrlOnStart(true);
  context.setContextPath(""String_Node_Str"");
  context.setParentLoaderPriority(true);
  server.setHandler(context);
  server.start();
  server.join();
}",0.9784283513097072
49181,"private Object authenticate(Connection connection,Credentials credentials,ClientPrincipal principal,boolean reAuth,boolean firstConnection) throws IOException {
  AuthenticationRequest auth=new AuthenticationRequest(credentials,principal);
  auth.setReAuth(reAuth);
  auth.setFirstConnection(firstConnection);
  final SerializationService serializationService=getSerializationService();
  connection.write(serializationService.toData(auth));
  final Data addressData=connection.read();
  Address address=(Address)serializationService.toObject(addressData);
  connection.setEndpoint(address);
  final Data data=connection.read();
  return ErrorHandler.returnResultOrThrowException(serializationService.toObject(data));
}","private Object authenticate(Connection connection,Credentials credentials,ClientPrincipal principal,boolean reAuth,boolean firstConnection) throws IOException {
  AuthenticationRequest auth=new AuthenticationRequest(credentials,principal);
  auth.setReAuth(reAuth);
  auth.setFirstConnection(firstConnection);
  final SerializationService serializationService=getSerializationService();
  connection.write(serializationService.toData(auth));
  final Data addressData=connection.read();
  Address address=ErrorHandler.returnResultOrThrowException(serializationService.toObject(addressData));
  connection.setEndpoint(address);
  final Data data=connection.read();
  return ErrorHandler.returnResultOrThrowException(serializationService.toObject(data));
}",0.9646739130434784
49182,"private void start(){
  try {
    clusterService.start();
  }
 catch (  IllegalStateException e) {
    lifecycleService.shutdown();
    throw e;
  }
  partitionService.start();
  lifecycleService.setStarted();
}","private void start(){
  lifecycleService.setStarted();
  try {
    clusterService.start();
  }
 catch (  IllegalStateException e) {
    lifecycleService.shutdown();
    throw e;
  }
  partitionService.start();
}",0.8436018957345972
49183,"public static <T>Iterator<T> iterator(final Class<T> clazz,final String factoryId,final ClassLoader classLoader) throws Exception {
  final Set<ServiceDefinition> classDefinitions=parse(factoryId,classLoader);
  if (classLoader != null && ServiceLoader.class.getClassLoader() != classLoader) {
    classDefinitions.addAll(parse(factoryId,ServiceLoader.class.getClassLoader()));
  }
  return new Iterator<T>(){
    final Iterator<ServiceDefinition> classIter=classDefinitions.iterator();
    public boolean hasNext(){
      return classIter.hasNext();
    }
    public T next(){
      final ServiceDefinition classDefinition=classIter.next();
      try {
        String className=classDefinition.className;
        ClassLoader classLoader=classDefinition.classLoader;
        return clazz.cast(ClassLoaderUtil.newInstance(classLoader,className));
      }
 catch (      Exception e) {
        throw new HazelcastException(e);
      }
    }
    public void remove(){
      throw new UnsupportedOperationException();
    }
  }
;
}","public static <T>Iterator<T> iterator(final Class<T> clazz,final String factoryId,final ClassLoader classLoader) throws Exception {
  final Set<ServiceDefinition> classDefinitions=parse(factoryId,classLoader);
  final ClassLoader systemClassLoader=ServiceLoader.class.getClassLoader();
  if (classLoader != null && systemClassLoader != classLoader) {
    final Set<ServiceDefinition> systemDefinitions=parse(factoryId,systemClassLoader);
    classDefinitions.addAll(systemDefinitions);
  }
  return new Iterator<T>(){
    final Iterator<ServiceDefinition> classIter=classDefinitions.iterator();
    public boolean hasNext(){
      return classIter.hasNext();
    }
    public T next(){
      final ServiceDefinition classDefinition=classIter.next();
      try {
        String className=classDefinition.className;
        ClassLoader classLoader=classDefinition.classLoader;
        return clazz.cast(ClassLoaderUtil.newInstance(classLoader,className));
      }
 catch (      Exception e) {
        throw new HazelcastException(e);
      }
    }
    public void remove(){
      throw new UnsupportedOperationException();
    }
  }
;
}",0.8805555555555555
49184,"@Test public void testTimestamp(){
  final long now=System.currentTimeMillis();
  final Timestamp date1=new Timestamp(now);
  final Timestamp date2=DateHelper.parseTimeStamp(date1.toString());
  Calendar cal1=Calendar.getInstance(Locale.US);
  cal1.setTimeInMillis(date1.getTime());
  Calendar cal2=Calendar.getInstance(Locale.US);
  cal2.setTimeInMillis(date2.getTime());
  Assert.assertEquals(cal1.get(Calendar.YEAR),cal2.get(Calendar.YEAR));
  Assert.assertEquals(cal1.get(Calendar.MONTH),cal2.get(Calendar.MONTH));
  Assert.assertEquals(cal1.get(Calendar.DAY_OF_MONTH),cal2.get(Calendar.DAY_OF_MONTH));
  Assert.assertEquals(cal1.get(Calendar.HOUR_OF_DAY),cal2.get(Calendar.HOUR_OF_DAY));
  Assert.assertEquals(cal1.get(Calendar.MINUTE),cal2.get(Calendar.MINUTE));
  Assert.assertEquals(cal1.get(Calendar.SECOND),cal2.get(Calendar.SECOND));
  Assert.assertEquals(cal1.get(Calendar.MILLISECOND),cal2.get(Calendar.MILLISECOND));
}","@Test public void testTimestamp(){
  final long now=System.currentTimeMillis();
  final Timestamp date1=new Timestamp(now);
  final Timestamp date2=DateHelper.parseTimeStamp(date1.toString());
  Calendar cal1=Calendar.getInstance(Locale.US);
  cal1.setTimeInMillis(date1.getTime());
  Calendar cal2=Calendar.getInstance(Locale.US);
  cal2.setTimeInMillis(date2.getTime());
  Assert.assertEquals(cal1.get(Calendar.YEAR),cal2.get(Calendar.YEAR));
  Assert.assertEquals(cal1.get(Calendar.MONTH),cal2.get(Calendar.MONTH));
  Assert.assertEquals(cal1.get(Calendar.DAY_OF_MONTH),cal2.get(Calendar.DAY_OF_MONTH));
  Assert.assertEquals(cal1.get(Calendar.HOUR_OF_DAY),cal2.get(Calendar.HOUR_OF_DAY));
  Assert.assertEquals(cal1.get(Calendar.MINUTE),cal2.get(Calendar.MINUTE));
  Assert.assertEquals(cal1.get(Calendar.SECOND),cal2.get(Calendar.SECOND));
}",0.9516310461192352
49185,"MockConnectionManager(Node node){
  this.node=node;
  thisConnection=new MockConnection(node.getThisAddress(),node.nodeEngine);
  register(node.getThisAddress(),node.nodeEngine);
}","MockConnectionManager(Node node){
  this.node=node;
  thisConnection=new MockConnection(node.getThisAddress(),node.nodeEngine);
synchronized (joinerLock) {
    nodes.put(node.getThisAddress(),node.nodeEngine);
  }
}",0.8607594936708861
49186,"public void doJoin(AtomicBoolean joined){
  NodeEngineImpl nodeEngine=null;
  for (  Address address : addresses) {
    NodeEngineImpl ne=nodes.get(address);
    if (ne != null && ne.getNode().isActive() && ne.getNode().joined()) {
      nodeEngine=ne;
      break;
    }
  }
  Address master=null;
  if (nodeEngine != null) {
    if (nodeEngine.getNode().isMaster()) {
      master=nodeEngine.getThisAddress();
    }
 else {
      master=nodeEngine.getMasterAddress();
    }
  }
  if (master == null) {
    master=node.getThisAddress();
  }
  node.setMasterAddress(master);
  if (node.getMasterAddress().equals(node.getThisAddress())) {
    node.setJoined();
  }
 else {
    for (int i=0; !node.joined() && i < 1000; i++) {
      try {
        node.clusterService.sendJoinRequest(node.getMasterAddress(),true);
        Thread.sleep(50);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
    if (!node.joined()) {
      throw new AssertionError(""String_Node_Str"" + thisAddress + ""String_Node_Str""+ node.getMasterAddress());
    }
  }
}","public void doJoin(AtomicBoolean joined){
  NodeEngineImpl nodeEngine=null;
synchronized (joinerLock) {
    for (    Address address : addresses) {
      NodeEngineImpl ne=nodes.get(address);
      if (ne != null && ne.getNode().isActive() && ne.getNode().joined()) {
        nodeEngine=ne;
        break;
      }
    }
    Address master=null;
    if (nodeEngine != null) {
      if (nodeEngine.getNode().isMaster()) {
        master=nodeEngine.getThisAddress();
      }
 else {
        master=nodeEngine.getMasterAddress();
      }
    }
    if (master == null) {
      master=node.getThisAddress();
    }
    node.setMasterAddress(master);
    if (node.getMasterAddress().equals(node.getThisAddress())) {
      node.setJoined();
    }
 else {
      for (int i=0; !node.joined() && i < 1000; i++) {
        try {
          node.clusterService.sendJoinRequest(node.getMasterAddress(),true);
          Thread.sleep(50);
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
      }
      if (!node.joined()) {
        throw new AssertionError(""String_Node_Str"" + thisAddress + ""String_Node_Str""+ node.getMasterAddress());
      }
    }
  }
}",0.9104609929078016
49187,"public void run(){
  final NodeEngine nodeEngine=getNodeEngine();
  final Address masterAddress=nodeEngine.getMasterAddress();
  if (!masterAddress.equals(migrationInfo.getMaster())) {
    throw new RetryableHazelcastException(""String_Node_Str"" + toString());
  }
  if (!masterAddress.equals(getCallerAddress())) {
    throw new RetryableHazelcastException(""String_Node_Str"" + toString());
  }
  final Address from=migrationInfo.getSource();
  final Address to=migrationInfo.getDestination();
  if (to.equals(from)) {
    getLogger().log(Level.WARNING,""String_Node_Str"" + toString());
    success=false;
    return;
  }
  if (from == null) {
    getLogger().log(Level.FINEST,""String_Node_Str"" + toString());
  }
  if (migrationInfo.startProcessing()) {
    try {
      final Member target=nodeEngine.getClusterService().getMember(to);
      if (target == null) {
        throw new RetryableHazelcastException(""String_Node_Str"" + toString());
      }
      final PartitionServiceImpl partitionService=getService();
      partitionService.addActiveMigration(migrationInfo);
      final long[] replicaVersions=partitionService.getPartitionReplicaVersions(migrationInfo.getPartitionId());
      final long timeout=nodeEngine.getGroupProperties().PARTITION_MIGRATION_TIMEOUT.getLong();
      final Collection<Operation> tasks=prepareMigrationTasks();
      if (tasks.size() > 0) {
        final SerializationService serializationService=nodeEngine.getSerializationService();
        final BufferObjectDataOutput out=serializationService.createObjectDataOutput(1024 * 32);
        try {
          out.writeInt(tasks.size());
          for (          Operation task : tasks) {
            serializationService.writeObject(out,task);
          }
          final byte[] data=IOUtil.compress(out.toByteArray());
          final MigrationOperation migrationOperation=new MigrationOperation(migrationInfo,replicaVersions,data,tasks.size());
          Invocation inv=nodeEngine.getOperationService().createInvocationBuilder(PartitionServiceImpl.SERVICE_NAME,migrationOperation,to).setTryPauseMillis(1000).setReplicaIndex(getReplicaIndex()).build();
          Future future=inv.invoke();
          success=(Boolean)nodeEngine.toObject(future.get(timeout,TimeUnit.SECONDS));
        }
  finally {
          IOUtil.closeResource(out);
        }
      }
 else {
        success=true;
      }
    }
 catch (    Throwable e) {
      if (e instanceof ExecutionException) {
        e=e.getCause() != null ? e.getCause() : e;
      }
      Level level=(e instanceof MemberLeftException || e instanceof InterruptedException) || !getNodeEngine().isActive() ? Level.INFO : Level.WARNING;
      getLogger().log(level,e.getMessage(),e);
      success=false;
    }
 finally {
      migrationInfo.doneProcessing();
    }
  }
 else {
    getLogger().log(Level.WARNING,""String_Node_Str"" + migrationInfo);
    success=false;
  }
}","public void run(){
  final BufferObjectDataOutput out=serializationService.createObjectDataOutput(1024 * 32);
  try {
    out.writeInt(tasks.size());
    for (    Operation task : tasks) {
      serializationService.writeObject(out,task);
    }
    final byte[] data=IOUtil.compress(out.toByteArray());
    final MigrationOperation migrationOperation=new MigrationOperation(migrationInfo,replicaVersions,data,tasks.size());
    Invocation inv=nodeEngine.getOperationService().createInvocationBuilder(PartitionServiceImpl.SERVICE_NAME,migrationOperation,to).setTryPauseMillis(1000).setReplicaIndex(getReplicaIndex()).build();
    Future future=inv.invoke();
    Boolean result=(Boolean)nodeEngine.toObject(future.get(timeout,TimeUnit.SECONDS));
    responseHandler.sendResponse(result);
  }
 catch (  Throwable e) {
    responseHandler.sendResponse(Boolean.FALSE);
    if (e instanceof ExecutionException) {
      e=e.getCause() != null ? e.getCause() : e;
    }
    Level level=(e instanceof MemberLeftException || e instanceof InterruptedException) || !getNodeEngine().isActive() ? Level.INFO : Level.WARNING;
    getLogger().log(level,e.getMessage(),e);
  }
 finally {
    IOUtil.closeResource(out);
  }
}",0.5247259439707673
49188,"@Override public boolean returnsResponse(){
  return true;
}","@Override public boolean returnsResponse(){
  return returnResponse;
}",0.9076923076923076
49189,"private void migrationTaskFailed(){
  systemLogService.logPartition(""String_Node_Str"" + migrationRequestOp);
  finalizeMigration(false);
  sendMigrationEvent(migrationInfo,MigrationStatus.FAILED);
}","private void migrationTaskFailed(){
  systemLogService.logPartition(""String_Node_Str"" + migrationInfo);
  finalizeMigration(false);
  sendMigrationEvent(migrationInfo,MigrationStatus.FAILED);
}",0.9667519181585678
49190,"void processPartitionRuntimeState(PartitionRuntimeState partitionState){
  lock.lock();
  try {
    if (!node.isActive() || !node.joined()) {
      return;
    }
    final Address sender=partitionState.getEndpoint();
    final Address master=node.getMasterAddress();
    if (node.isMaster()) {
      logger.log(Level.WARNING,""String_Node_Str"" + sender + ""String_Node_Str"");
      return;
    }
 else {
      if (sender == null || !sender.equals(master)) {
        if (node.clusterService.getMember(sender) == null) {
          logger.log(Level.SEVERE,""String_Node_Str"" + ""String_Node_Str"" + sender + ""String_Node_Str""+ master+ ""String_Node_Str"");
          return;
        }
 else {
          logger.log(Level.WARNING,""String_Node_Str"" + ""String_Node_Str"" + sender + ""String_Node_Str""+ master+ ""String_Node_Str""+ ""String_Node_Str"");
        }
      }
    }
    final Set<Address> unknownAddresses=new HashSet<Address>();
    PartitionView[] newPartitions=partitionState.getPartitions();
    for (    PartitionView newPartition : newPartitions) {
      PartitionImpl currentPartition=partitions[newPartition.getPartitionId()];
      for (int index=0; index < PartitionImpl.MAX_REPLICA_COUNT; index++) {
        Address address=newPartition.getReplicaAddress(index);
        if (address != null && getMember(address) == null) {
          if (logger.isLoggable(Level.FINEST)) {
            logger.log(Level.FINEST,""String_Node_Str"" + address + ""String_Node_Str""+ sender+ ""String_Node_Str""+ newPartition);
          }
          unknownAddresses.add(address);
        }
      }
      currentPartition.setOwner(newPartition.getOwner());
    }
    if (!unknownAddresses.isEmpty()) {
      StringBuilder s=new StringBuilder(""String_Node_Str"").append(""String_Node_Str"").append(sender).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
      for (      Address address : unknownAddresses) {
        s.append(""String_Node_Str"").append(address);
      }
      s.append(""String_Node_Str"");
      logger.log(Level.WARNING,s.toString());
    }
    Collection<MigrationInfo> completedMigrations=partitionState.getCompletedMigrations();
    for (    MigrationInfo completedMigration : completedMigrations) {
      addCompletedMigration(completedMigration);
      finalizeActiveMigration(completedMigration);
    }
    if (!activeMigrations.isEmpty()) {
      final MemberImpl masterMember=getMasterMember();
      rollbackActiveMigrationsFromPreviousMaster(masterMember.getUuid());
    }
    for (    PartitionView newPartition : newPartitions) {
      PartitionImpl currentPartition=partitions[newPartition.getPartitionId()];
      currentPartition.setPartitionInfo(newPartition);
    }
    stateVersion.set(partitionState.getVersion());
    initialized=true;
  }
  finally {
    lock.unlock();
  }
}","void processPartitionRuntimeState(PartitionRuntimeState partitionState){
  lock.lock();
  try {
    if (!node.isActive() || !node.joined()) {
      return;
    }
    final Address sender=partitionState.getEndpoint();
    final Address master=node.getMasterAddress();
    if (node.isMaster()) {
      logger.log(Level.WARNING,""String_Node_Str"" + sender + ""String_Node_Str"");
      return;
    }
 else {
      if (sender == null || !sender.equals(master)) {
        if (node.clusterService.getMember(sender) == null) {
          logger.log(Level.SEVERE,""String_Node_Str"" + ""String_Node_Str"" + sender + ""String_Node_Str""+ master+ ""String_Node_Str"");
          return;
        }
 else {
          logger.log(Level.WARNING,""String_Node_Str"" + ""String_Node_Str"" + sender + ""String_Node_Str""+ master+ ""String_Node_Str""+ ""String_Node_Str"");
        }
      }
    }
    final Set<Address> unknownAddresses=new HashSet<Address>();
    PartitionView[] newPartitions=partitionState.getPartitions();
    for (    PartitionView newPartition : newPartitions) {
      PartitionImpl currentPartition=partitions[newPartition.getPartitionId()];
      for (int index=0; index < PartitionImpl.MAX_REPLICA_COUNT; index++) {
        Address address=newPartition.getReplicaAddress(index);
        if (address != null && getMember(address) == null) {
          if (logger.isLoggable(Level.FINEST)) {
            logger.log(Level.FINEST,""String_Node_Str"" + address + ""String_Node_Str""+ sender+ ""String_Node_Str""+ newPartition);
          }
          unknownAddresses.add(address);
        }
      }
      currentPartition.setOwner(newPartition.getOwner());
    }
    if (!unknownAddresses.isEmpty() && logger.isLoggable(Level.WARNING)) {
      StringBuilder s=new StringBuilder(""String_Node_Str"").append(""String_Node_Str"").append(sender).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
      for (      Address address : unknownAddresses) {
        s.append(""String_Node_Str"").append(address);
      }
      s.append(""String_Node_Str"");
      logger.log(Level.WARNING,s.toString());
    }
    Collection<MigrationInfo> completedMigrations=partitionState.getCompletedMigrations();
    for (    MigrationInfo completedMigration : completedMigrations) {
      addCompletedMigration(completedMigration);
      finalizeActiveMigration(completedMigration);
    }
    if (!activeMigrations.isEmpty()) {
      final MemberImpl masterMember=getMasterMember();
      rollbackActiveMigrationsFromPreviousMaster(masterMember.getUuid());
    }
    for (    PartitionView newPartition : newPartitions) {
      PartitionImpl currentPartition=partitions[newPartition.getPartitionId()];
      currentPartition.setPartitionInfo(newPartition);
    }
    stateVersion.set(partitionState.getVersion());
    initialized=true;
  }
  finally {
    lock.unlock();
  }
}",0.9936418226774992
49191,"private boolean shouldWaitMigrationOrBackups(Level level){
  if (initialized) {
    MemberGroupFactory mgf=memberGroupFactory;
    final Collection<MemberGroup> memberGroups=mgf.createMemberGroups(node.getClusterService().getMembers());
    if (memberGroups.size() < 2)     return false;
    int groups=0;
    for (    MemberGroup memberGroup : memberGroups) {
      if (memberGroup.size() > 0) {
        groups++;
      }
    }
    if (groups < 2)     return false;
    final int activeSize=activeMigrations.size();
    if (activeSize != 0) {
      logger.log(level,""String_Node_Str"" + activeSize);
      return true;
    }
    final int queueSize=migrationQueue.size();
    if (queueSize == 0) {
      for (      PartitionImpl partition : partitions) {
        if (partition.getReplicaAddress(1) == null) {
          logger.log(level,""String_Node_Str"" + partition.getPartitionId());
          return true;
        }
 else {
          final int replicaSyncProcesses=replicaSyncProcessCount.get();
          if (replicaSyncProcesses > 0) {
            logger.log(level,""String_Node_Str"" + replicaSyncProcesses);
            return true;
          }
        }
      }
    }
 else {
      logger.log(level,""String_Node_Str"" + queueSize);
      return true;
    }
  }
  return false;
}","private boolean shouldWaitMigrationOrBackups(Level level){
  if (initialized) {
    MemberGroupFactory mgf=memberGroupFactory;
    final Collection<MemberGroup> memberGroups=mgf.createMemberGroups(node.getClusterService().getMembers());
    if (memberGroups.size() < 2)     return false;
    int groups=0;
    for (    MemberGroup memberGroup : memberGroups) {
      if (memberGroup.size() > 0) {
        groups++;
      }
    }
    if (groups < 2)     return false;
    final int activeSize=activeMigrations.size();
    if (activeSize != 0) {
      if (logger.isLoggable(level)) {
        logger.log(level,""String_Node_Str"" + activeSize);
      }
      return true;
    }
    final int queueSize=migrationQueue.size();
    if (queueSize == 0) {
      for (      PartitionImpl partition : partitions) {
        if (partition.getReplicaAddress(1) == null) {
          if (logger.isLoggable(level)) {
            logger.log(level,""String_Node_Str"" + partition.getPartitionId());
          }
          return true;
        }
 else {
          final int replicaSyncProcesses=replicaSyncProcessCount.get();
          if (replicaSyncProcesses > 0) {
            if (logger.isLoggable(level)) {
              logger.log(level,""String_Node_Str"" + replicaSyncProcesses);
            }
            return true;
          }
        }
      }
    }
 else {
      if (logger.isLoggable(level)) {
        logger.log(level,""String_Node_Str"" + queueSize);
      }
      return true;
    }
  }
  return false;
}",0.8695965417867435
49192,"private void rollbackActiveMigrationsFromPreviousMaster(final String masterUuid){
  lock.lock();
  try {
    if (!activeMigrations.isEmpty()) {
      for (      MigrationInfo migrationInfo : activeMigrations.values()) {
        if (!masterUuid.equals(migrationInfo.getMasterUuid())) {
          logger.log(Level.INFO,""String_Node_Str"" + migrationInfo);
          finalizeActiveMigration(migrationInfo);
        }
      }
    }
  }
  finally {
    lock.unlock();
  }
}","private void rollbackActiveMigrationsFromPreviousMaster(final String currentMasterUuid){
  lock.lock();
  try {
    if (!activeMigrations.isEmpty()) {
      for (      MigrationInfo migrationInfo : activeMigrations.values()) {
        if (!currentMasterUuid.equals(migrationInfo.getMasterUuid())) {
          logger.log(Level.INFO,""String_Node_Str"" + migrationInfo);
          finalizeActiveMigration(migrationInfo);
        }
      }
    }
  }
  finally {
    lock.unlock();
  }
}",0.981012658227848
49193,"public boolean backup(){
  final PartitionService partitionService=nodeEngine.getPartitionService();
  final PartitionView partition=partitionService.getPartitionView(partitionId);
  final Address target=partition.getReplicaAddress(replicaIndex);
  if (target != null) {
    send(backup,target);
    return true;
  }
  return ++retries >= 5;
}","public boolean backup(){
  final PartitionService partitionService=nodeEngine.getPartitionService();
  final PartitionView partition=partitionService.getPartitionView(partitionId);
  final Address target=partition.getReplicaAddress(replicaIndex);
  if (target != null && !target.equals(node.getThisAddress())) {
    send(backup,target);
    return true;
  }
  return ++retries >= 10;
}",0.9395604395604396
49194,"private int sendBackups(BackupAwareOperation backupAwareOp) throws Exception {
  final Operation op=(Operation)backupAwareOp;
  final boolean returnsResponse=op.returnsResponse();
  final PartitionServiceImpl partitionService=(PartitionServiceImpl)nodeEngine.getPartitionService();
  final int maxBackups=Math.min(partitionService.getMemberGroupsSize() - 1,PartitionView.MAX_BACKUP_COUNT);
  int syncBackupCount=backupAwareOp.getSyncBackupCount() > 0 ? Math.min(maxBackups,backupAwareOp.getSyncBackupCount()) : 0;
  int asyncBackupCount=(backupAwareOp.getAsyncBackupCount() > 0 && maxBackups > syncBackupCount) ? Math.min(maxBackups - syncBackupCount,backupAwareOp.getAsyncBackupCount()) : 0;
  if (!returnsResponse) {
    asyncBackupCount+=syncBackupCount;
    syncBackupCount=0;
  }
  final int totalBackupCount=syncBackupCount + asyncBackupCount;
  if (totalBackupCount > 0) {
    final String serviceName=op.getServiceName();
    final int partitionId=op.getPartitionId();
    final long[] replicaVersions=partitionService.incrementPartitionReplicaVersions(partitionId,totalBackupCount);
    final PartitionView partition=partitionService.getPartitionView(partitionId);
    for (int replicaIndex=1; replicaIndex <= totalBackupCount; replicaIndex++) {
      final Operation backupOp=backupAwareOp.getBackupOperation();
      if (backupOp == null) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      backupOp.setPartitionId(partitionId).setReplicaIndex(replicaIndex).setServiceName(serviceName);
      final Backup backup=new Backup(backupOp,op.getCallerAddress(),replicaVersions,replicaIndex <= syncBackupCount);
      backup.setPartitionId(partitionId).setReplicaIndex(replicaIndex).setServiceName(serviceName).setCallerUuid(nodeEngine.getLocalMember().getUuid());
      OperationAccessor.setCallId(backup,op.getCallId());
      final Address target=partition.getReplicaAddress(replicaIndex);
      if (target != null) {
        if (target.equals(node.getThisAddress())) {
          throw new IllegalStateException(""String_Node_Str"");
        }
 else {
          send(backup,target);
        }
      }
 else {
        final RemoteCallKey key=new RemoteCallKey(op.getCallerAddress(),op.getCallId());
        if (logger.isLoggable(Level.INFO)) {
          logger.log(Level.INFO,""String_Node_Str"" + backup);
        }
        backupScheduler.schedule(500,key,new ScheduledBackup(backup,partitionId,replicaIndex));
      }
    }
  }
  return syncBackupCount;
}","private int sendBackups(BackupAwareOperation backupAwareOp) throws Exception {
  final Operation op=(Operation)backupAwareOp;
  final boolean returnsResponse=op.returnsResponse();
  final PartitionServiceImpl partitionService=(PartitionServiceImpl)nodeEngine.getPartitionService();
  final int maxBackups=Math.min(partitionService.getMemberGroupsSize() - 1,PartitionView.MAX_BACKUP_COUNT);
  int syncBackupCount=backupAwareOp.getSyncBackupCount() > 0 ? Math.min(maxBackups,backupAwareOp.getSyncBackupCount()) : 0;
  int asyncBackupCount=(backupAwareOp.getAsyncBackupCount() > 0 && maxBackups > syncBackupCount) ? Math.min(maxBackups - syncBackupCount,backupAwareOp.getAsyncBackupCount()) : 0;
  if (!returnsResponse) {
    asyncBackupCount+=syncBackupCount;
    syncBackupCount=0;
  }
  final int totalBackupCount=syncBackupCount + asyncBackupCount;
  if (totalBackupCount > 0) {
    final String serviceName=op.getServiceName();
    final int partitionId=op.getPartitionId();
    final long[] replicaVersions=partitionService.incrementPartitionReplicaVersions(partitionId,totalBackupCount);
    final PartitionView partition=partitionService.getPartitionView(partitionId);
    for (int replicaIndex=1; replicaIndex <= totalBackupCount; replicaIndex++) {
      final Operation backupOp=backupAwareOp.getBackupOperation();
      if (backupOp == null) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
      backupOp.setPartitionId(partitionId).setReplicaIndex(replicaIndex).setServiceName(serviceName);
      final Backup backup=new Backup(backupOp,op.getCallerAddress(),replicaVersions,replicaIndex <= syncBackupCount);
      backup.setPartitionId(partitionId).setReplicaIndex(replicaIndex).setServiceName(serviceName).setCallerUuid(nodeEngine.getLocalMember().getUuid());
      OperationAccessor.setCallId(backup,op.getCallId());
      final Address target=partition.getReplicaAddress(replicaIndex);
      if (target != null) {
        if (target.equals(node.getThisAddress())) {
          throw new IllegalStateException(""String_Node_Str"" + partition);
        }
 else {
          send(backup,target);
        }
      }
 else {
        scheduleBackup(op,backup,partitionId,replicaIndex);
      }
    }
  }
  return syncBackupCount;
}",0.9066385669125396
49195,"public void process(EntryTaskScheduler<Object,ScheduledBackup> scheduler,Collection<ScheduledEntry<Object,ScheduledBackup>> scheduledEntries){
  for (  ScheduledEntry<Object,ScheduledBackup> entry : scheduledEntries) {
    final ScheduledBackup backup=entry.getValue();
    if (!backup.backup()) {
      final int retries=backup.retries;
      if (logger.isLoggable(Level.INFO)) {
        logger.log(Level.INFO,""String_Node_Str"" + retries + ""String_Node_Str""+ backup);
      }
      scheduler.schedule(entry.getScheduledDelayMillis(),entry.getKey(),backup);
    }
  }
}","public void process(EntryTaskScheduler<Object,ScheduledBackup> scheduler,Collection<ScheduledEntry<Object,ScheduledBackup>> scheduledEntries){
  for (  ScheduledEntry<Object,ScheduledBackup> entry : scheduledEntries) {
    final ScheduledBackup backup=entry.getValue();
    if (!backup.backup()) {
      final int retries=backup.retries;
      if (logger.isLoggable(Level.INFO)) {
        logger.log(Level.INFO,""String_Node_Str"" + retries + ""String_Node_Str""+ backup);
      }
      scheduler.schedule(entry.getScheduledDelayMillis() * retries,entry.getKey(),backup);
    }
  }
}",0.9912891986062716
49196,"public static <T>Iterator<T> iterator(final Class<T> clazz,final String factoryId,final ClassLoader classLoader) throws Exception {
  final Set<ServiceDefinition> classDefinitions=parse(factoryId,classLoader);
  if (ServiceLoader.class.getClassLoader() != classLoader) {
    classDefinitions.addAll(parse(factoryId,ServiceLoader.class.getClassLoader()));
  }
  return new Iterator<T>(){
    final Iterator<ServiceDefinition> classIter=classDefinitions.iterator();
    public boolean hasNext(){
      return classIter.hasNext();
    }
    public T next(){
      final ServiceDefinition classDefinition=classIter.next();
      try {
        String className=classDefinition.className;
        ClassLoader classLoader=classDefinition.classLoader;
        return clazz.cast(ClassLoaderUtil.newInstance(classLoader,className));
      }
 catch (      Exception e) {
        throw new HazelcastException(e);
      }
    }
    public void remove(){
      throw new UnsupportedOperationException();
    }
  }
;
}","public static <T>Iterator<T> iterator(final Class<T> clazz,final String factoryId,final ClassLoader classLoader) throws Exception {
  final Set<ServiceDefinition> classDefinitions=parse(factoryId,classLoader);
  if (classLoader != null && ServiceLoader.class.getClassLoader() != classLoader) {
    classDefinitions.addAll(parse(factoryId,ServiceLoader.class.getClassLoader()));
  }
  return new Iterator<T>(){
    final Iterator<ServiceDefinition> classIter=classDefinitions.iterator();
    public boolean hasNext(){
      return classIter.hasNext();
    }
    public T next(){
      final ServiceDefinition classDefinition=classIter.next();
      try {
        String className=classDefinition.className;
        ClassLoader classLoader=classDefinition.classLoader;
        return clazz.cast(ClassLoaderUtil.newInstance(classLoader,className));
      }
 catch (      Exception e) {
        throw new HazelcastException(e);
      }
    }
    public void remove(){
      throw new UnsupportedOperationException();
    }
  }
;
}",0.9886643666830952
49197,"public T next(){
  final String className=classIter.next();
  try {
    return clazz.cast(ClassLoaderUtil.newInstance(classLoader,className));
  }
 catch (  Exception e) {
    throw new HazelcastException(e);
  }
}","public T next(){
  final ServiceDefinition classDefinition=classIter.next();
  try {
    String className=classDefinition.className;
    ClassLoader classLoader=classDefinition.classLoader;
    return clazz.cast(ClassLoaderUtil.newInstance(classLoader,className));
  }
 catch (  Exception e) {
    throw new HazelcastException(e);
  }
}",0.7054545454545454
49198,"public static <T>Iterator<T> iterator(final Class<T> clazz,final String factoryId,final ClassLoader classLoader) throws Exception {
  final Set<String> classNames=parse(factoryId,classLoader);
  return new Iterator<T>(){
    final Iterator<String> classIter=classNames.iterator();
    public boolean hasNext(){
      return classIter.hasNext();
    }
    public T next(){
      final String className=classIter.next();
      try {
        return clazz.cast(ClassLoaderUtil.newInstance(classLoader,className));
      }
 catch (      Exception e) {
        throw new HazelcastException(e);
      }
    }
    public void remove(){
      throw new UnsupportedOperationException();
    }
  }
;
}","public static <T>Iterator<T> iterator(final Class<T> clazz,final String factoryId,final ClassLoader classLoader) throws Exception {
  final Set<ServiceDefinition> classDefinitions=parse(factoryId,classLoader);
  if (ServiceLoader.class.getClassLoader() != classLoader) {
    classDefinitions.addAll(parse(factoryId,ServiceLoader.class.getClassLoader()));
  }
  return new Iterator<T>(){
    final Iterator<ServiceDefinition> classIter=classDefinitions.iterator();
    public boolean hasNext(){
      return classIter.hasNext();
    }
    public T next(){
      final ServiceDefinition classDefinition=classIter.next();
      try {
        String className=classDefinition.className;
        ClassLoader classLoader=classDefinition.classLoader;
        return clazz.cast(ClassLoaderUtil.newInstance(classLoader,className));
      }
 catch (      Exception e) {
        throw new HazelcastException(e);
      }
    }
    public void remove(){
      throw new UnsupportedOperationException();
    }
  }
;
}",0.7749556999409333
49199,"private static Set<String> parse(String factoryId,ClassLoader classLoader){
  final ClassLoader cl=(classLoader == null) ? Thread.currentThread().getContextClassLoader() : classLoader;
  final String resourceName=""String_Node_Str"" + factoryId;
  try {
    final Enumeration<URL> configs;
    if (cl != null) {
      configs=cl.getResources(resourceName);
    }
 else {
      configs=ClassLoader.getSystemResources(resourceName);
    }
    final Set<String> names=new HashSet<String>();
    while (configs.hasMoreElements()) {
      URL url=configs.nextElement();
      BufferedReader r=null;
      try {
        r=new BufferedReader(new InputStreamReader(url.openStream(),""String_Node_Str""));
        while (true) {
          String line=r.readLine();
          if (line == null) {
            break;
          }
          int comment=line.indexOf('#');
          if (comment >= 0) {
            line=line.substring(0,comment);
          }
          String name=line.trim();
          if (name.length() == 0) {
            continue;
          }
          names.add(name);
        }
      }
  finally {
        IOUtil.closeResource(r);
      }
    }
    return names;
  }
 catch (  Exception e) {
    logger.log(Level.SEVERE,e.getMessage(),e);
  }
  return Collections.emptySet();
}","private static Set<ServiceDefinition> parse(String factoryId,ClassLoader classLoader){
  final ClassLoader cl=(classLoader == null) ? Thread.currentThread().getContextClassLoader() : classLoader;
  final String resourceName=""String_Node_Str"" + factoryId;
  try {
    final Enumeration<URL> configs;
    if (cl != null) {
      configs=cl.getResources(resourceName);
    }
 else {
      configs=ClassLoader.getSystemResources(resourceName);
    }
    final Set<ServiceDefinition> names=new HashSet<ServiceDefinition>();
    while (configs.hasMoreElements()) {
      URL url=configs.nextElement();
      BufferedReader r=null;
      try {
        r=new BufferedReader(new InputStreamReader(url.openStream(),""String_Node_Str""));
        while (true) {
          String line=r.readLine();
          if (line == null) {
            break;
          }
          int comment=line.indexOf('#');
          if (comment >= 0) {
            line=line.substring(0,comment);
          }
          String name=line.trim();
          if (name.length() == 0) {
            continue;
          }
          names.add(new ServiceDefinition(name,classLoader));
        }
      }
  finally {
        IOUtil.closeResource(r);
      }
    }
    return names;
  }
 catch (  Exception e) {
    logger.log(Level.SEVERE,e.getMessage(),e);
  }
  return Collections.emptySet();
}",0.9604562737642586
49200,"public static void shutdownAll(){
  final List<HazelcastInstanceProxy> instances=new ArrayList<HazelcastInstanceProxy>(INSTANCE_MAP.values());
  INSTANCE_MAP.clear();
  Collections.sort(instances,new Comparator<HazelcastInstanceProxy>(){
    public int compare(    HazelcastInstanceProxy o1,    HazelcastInstanceProxy o2){
      return o1.getName().compareTo(o2.getName());
    }
  }
);
  for (  HazelcastInstanceProxy proxy : instances) {
    proxy.getLifecycleService().shutdown();
    proxy.original=null;
  }
  ManagementService.shutdownAll();
}","public static void shutdownAll(){
  final List<HazelcastInstanceProxy> instances=new ArrayList<HazelcastInstanceProxy>(INSTANCE_MAP.values());
  INSTANCE_MAP.clear();
  ManagementService.shutdownAll();
  Collections.sort(instances,new Comparator<HazelcastInstanceProxy>(){
    public int compare(    HazelcastInstanceProxy o1,    HazelcastInstanceProxy o2){
      return o1.getName().compareTo(o2.getName());
    }
  }
);
  for (  HazelcastInstanceProxy proxy : instances) {
    proxy.getLifecycleService().shutdown();
    proxy.original=null;
  }
}",0.936247723132969
49201,"private HazelcastMBean createHazelcastBean(DistributedObject distributedObject){
  if (distributedObject instanceof IList) {
    return new ListMBean((IList)distributedObject,this);
  }
  if (distributedObject instanceof IAtomicLong) {
    return new AtomicLongMBean((IAtomicLong)distributedObject,this);
  }
  if (distributedObject instanceof ICountDownLatch) {
    return new CountDownLatchMBean((ICountDownLatch)distributedObject,this);
  }
  if (distributedObject instanceof ILock) {
    return new LockMBean((ILock)distributedObject,this);
  }
  if (distributedObject instanceof IMap) {
    return new MapMBean((IMap)distributedObject,this);
  }
  if (distributedObject instanceof MultiMap) {
    return new MultiMapMBean((MultiMap)distributedObject,this);
  }
  if (distributedObject instanceof IQueue) {
    return new QueueMBean((IQueue)distributedObject,this);
  }
  if (distributedObject instanceof ISemaphore) {
    return new SemaphoreMBean((ISemaphore)distributedObject,this);
  }
  if (distributedObject instanceof ISet) {
    return new SetMBean((ISet)distributedObject,this);
  }
  if (distributedObject instanceof ITopic) {
    return new TopicMBean((ITopic)distributedObject,this);
  }
  return null;
}","private HazelcastMBean createHazelcastBean(DistributedObject distributedObject){
  try {
    if (distributedObject instanceof IList) {
      return new ListMBean((IList)distributedObject,this);
    }
    if (distributedObject instanceof IAtomicLong) {
      return new AtomicLongMBean((IAtomicLong)distributedObject,this);
    }
    if (distributedObject instanceof ICountDownLatch) {
      return new CountDownLatchMBean((ICountDownLatch)distributedObject,this);
    }
    if (distributedObject instanceof ILock) {
      return new LockMBean((ILock)distributedObject,this);
    }
    if (distributedObject instanceof IMap) {
      return new MapMBean((IMap)distributedObject,this);
    }
    if (distributedObject instanceof MultiMap) {
      return new MultiMapMBean((MultiMap)distributedObject,this);
    }
    if (distributedObject instanceof IQueue) {
      return new QueueMBean((IQueue)distributedObject,this);
    }
    if (distributedObject instanceof ISemaphore) {
      return new SemaphoreMBean((ISemaphore)distributedObject,this);
    }
    if (distributedObject instanceof ISet) {
      return new SetMBean((ISet)distributedObject,this);
    }
    if (distributedObject instanceof ITopic) {
      return new TopicMBean((ITopic)distributedObject,this);
    }
  }
 catch (  HazelcastInstanceNotActiveException ignored) {
  }
  return null;
}",0.948309366498251
49202,"void handleMaster(Address masterAddress){
  lock.lock();
  try {
    if (!node.joined() && !node.getThisAddress().equals(masterAddress)) {
      logger.log(Level.FINEST,""String_Node_Str"" + this);
      final Address currentMaster=node.getMasterAddress();
      if (currentMaster != null && !currentMaster.equals(masterAddress)) {
        final Connection conn=node.connectionManager.getConnection(currentMaster);
        if (conn != null && conn.live()) {
          logger.log(Level.WARNING,""String_Node_Str"" + this + ""String_Node_Str""+ currentMaster);
          return;
        }
      }
      node.setMasterAddress(masterAddress);
      node.connectionManager.getOrConnect(masterAddress);
      if (!sendJoinRequest(masterAddress,true)) {
        logger.log(Level.WARNING,""String_Node_Str"" + masterAddress);
      }
    }
  }
  finally {
    lock.unlock();
  }
}","void handleMaster(Address masterAddress){
  lock.lock();
  try {
    if (!node.joined() && !node.getThisAddress().equals(masterAddress)) {
      logger.log(Level.FINEST,""String_Node_Str"" + this);
      final Address currentMaster=node.getMasterAddress();
      if (currentMaster != null && !currentMaster.equals(masterAddress)) {
        final Connection conn=node.connectionManager.getConnection(currentMaster);
        if (conn != null && conn.live()) {
          logger.log(Level.WARNING,""String_Node_Str"" + masterAddress + ""String_Node_Str""+ currentMaster);
          return;
        }
      }
      node.setMasterAddress(masterAddress);
      node.connectionManager.getOrConnect(masterAddress);
      if (!sendJoinRequest(masterAddress,true)) {
        logger.log(Level.WARNING,""String_Node_Str"" + masterAddress);
      }
    }
  }
  finally {
    lock.unlock();
  }
}",0.9913644214162348
49203,"@Test @ClientCompatibleTest public void testAtomicLongSpawnNodeInParallel(){
  int total=6;
  int parallel=2;
  final TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(total + 1);
  final Config config=new Config();
  HazelcastInstance instance=nodeFactory.newHazelcastInstance(config);
  final String name=""String_Node_Str"";
  IAtomicLong atomicLong=instance.getAtomicLong(name);
  atomicLong.set(100);
  for (int i=0; i < total / parallel; i++) {
    final HazelcastInstance[] instances=new HazelcastInstance[parallel];
    final CountDownLatch countDownLatch=new CountDownLatch(parallel);
    for (int j=0; j < parallel; j++) {
      final int id=j;
      new Thread(){
        public void run(){
          instances[id]=nodeFactory.newHazelcastInstance(config);
          instances[id].getAtomicLong(name).incrementAndGet();
          countDownLatch.countDown();
        }
      }
.start();
    }
    try {
      countDownLatch.await(1,TimeUnit.MINUTES);
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
    IAtomicLong newAtomicLong=instance.getAtomicLong(name);
    Assert.assertEquals((long)100 + (i + 1) * parallel,newAtomicLong.get());
    instance.getLifecycleService().shutdown();
    instance=instances[0];
    for (int j=1; j < parallel; j++) {
      instances[j].getLifecycleService().shutdown();
    }
  }
}","@Test @ClientCompatibleTest public void testAtomicLongSpawnNodeInParallel() throws InterruptedException {
  int total=6;
  int parallel=2;
  final TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(total + 1);
  final Config config=new Config();
  HazelcastInstance instance=nodeFactory.newHazelcastInstance(config);
  final String name=""String_Node_Str"";
  IAtomicLong atomicLong=instance.getAtomicLong(name);
  atomicLong.set(100);
  final ExecutorService ex=Executors.newFixedThreadPool(parallel);
  try {
    for (int i=0; i < total / parallel; i++) {
      final HazelcastInstance[] instances=new HazelcastInstance[parallel];
      final CountDownLatch countDownLatch=new CountDownLatch(parallel);
      for (int j=0; j < parallel; j++) {
        final int id=j;
        ex.execute(new Runnable(){
          public void run(){
            instances[id]=nodeFactory.newHazelcastInstance(config);
            instances[id].getAtomicLong(name).incrementAndGet();
            countDownLatch.countDown();
          }
        }
);
      }
      assertTrue(countDownLatch.await(1,TimeUnit.MINUTES));
      IAtomicLong newAtomicLong=instance.getAtomicLong(name);
      Assert.assertEquals((long)100 + (i + 1) * parallel,newAtomicLong.get());
      instance.getLifecycleService().shutdown();
      instance=instances[0];
    }
  }
  finally {
    ex.shutdownNow();
  }
}",0.6944545125045306
49204,"public void run(){
  final HazelcastInstance h=instances[instanceIndex];
  h.getMap(""String_Node_Str"").size();
  counts.offer(getLocalPartitionsCount(h));
}","public void run(){
  final HazelcastInstance h=instances[instanceIndex];
  try {
    warmUpPartitions(h);
    counts.offer(getLocalPartitionsCount(h));
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
}",0.6349206349206349
49205,"private void testPartitionDistribution(final int partitionCount,final int nodeCount) throws InterruptedException {
  final Config config=new Config();
  config.setProperty(GroupProperties.PROP_PARTITION_COUNT,String.valueOf(partitionCount));
  TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(nodeCount);
  final BlockingQueue<Integer> counts=new ArrayBlockingQueue<Integer>(nodeCount);
  final HazelcastInstance[] instances=new HazelcastInstance[nodeCount];
  for (int i=0; i < nodeCount; i++) {
    instances[i]=factory.newHazelcastInstance(config);
  }
  for (int j=0; j < nodeCount; j++) {
    final int instanceIndex=j;
    new Thread(new Runnable(){
      public void run(){
        final HazelcastInstance h=instances[instanceIndex];
        h.getMap(""String_Node_Str"").size();
        counts.offer(getLocalPartitionsCount(h));
      }
    }
).start();
  }
  final int average=(partitionCount / nodeCount);
  int total=0;
  for (int i=0; i < nodeCount; i++) {
    final int c=counts.take();
    assertTrue(""String_Node_Str"" + i + ""String_Node_Str""+ c+ ""String_Node_Str""+ partitionCount+ ""String_Node_Str""+ nodeCount,c >= average);
    total+=c;
  }
  assertEquals(partitionCount,total);
}","private void testPartitionDistribution(final int partitionCount,final int nodeCount) throws InterruptedException {
  final Config config=new Config();
  config.setProperty(GroupProperties.PROP_PARTITION_COUNT,String.valueOf(partitionCount));
  TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(nodeCount);
  final BlockingQueue<Integer> counts=new ArrayBlockingQueue<Integer>(nodeCount);
  final HazelcastInstance[] instances=new HazelcastInstance[nodeCount];
  for (int i=0; i < nodeCount; i++) {
    instances[i]=factory.newHazelcastInstance(config);
  }
  final ExecutorService ex=Executors.newCachedThreadPool();
  try {
    for (int j=0; j < nodeCount; j++) {
      final int instanceIndex=j;
      new Thread(new Runnable(){
        public void run(){
          final HazelcastInstance h=instances[instanceIndex];
          try {
            warmUpPartitions(h);
            counts.offer(getLocalPartitionsCount(h));
          }
 catch (          InterruptedException e) {
            e.printStackTrace();
          }
        }
      }
).start();
    }
    final int average=(partitionCount / nodeCount);
    int total=0;
    for (int i=0; i < nodeCount; i++) {
      final int c=counts.poll(1,TimeUnit.MINUTES);
      assertTrue(""String_Node_Str"" + c + ""String_Node_Str""+ partitionCount+ ""String_Node_Str""+ nodeCount,c >= average);
      total+=c;
    }
    assertEquals(partitionCount,total);
  }
  finally {
    ex.shutdownNow();
  }
}",0.6539611360239163
49206,"public void doJoin(AtomicBoolean joined){
  Address master=null;
  for (  Address address : addresses) {
    final NodeEngineImpl nodeEngine=nodes.get(address);
    if (nodeEngine != null && nodeEngine.getNode().isActive()) {
      master=address;
      break;
    }
  }
  node.setMasterAddress(master);
  if (node.getMasterAddress().equals(node.getThisAddress())) {
    node.setJoined();
  }
 else {
    for (int i=0; !node.joined() && i < 1000; i++) {
      try {
        node.clusterService.sendJoinRequest(node.getMasterAddress(),true);
        Thread.sleep(50);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
    if (!node.joined()) {
      throw new AssertionError(""String_Node_Str"" + thisAddress + ""String_Node_Str""+ node.getMasterAddress());
    }
  }
}","public void doJoin(AtomicBoolean joined){
  NodeEngineImpl nodeEngine=null;
  for (  Address address : addresses) {
    NodeEngineImpl ne=nodes.get(address);
    if (ne != null && ne.getNode().isActive() && ne.getNode().joined()) {
      nodeEngine=ne;
      break;
    }
  }
  Address master=null;
  if (nodeEngine != null) {
    if (nodeEngine.getNode().isMaster()) {
      master=nodeEngine.getThisAddress();
    }
 else {
      master=nodeEngine.getMasterAddress();
    }
  }
  if (master == null) {
    master=node.getThisAddress();
  }
  node.setMasterAddress(master);
  if (node.getMasterAddress().equals(node.getThisAddress())) {
    node.setJoined();
  }
 else {
    for (int i=0; !node.joined() && i < 1000; i++) {
      try {
        node.clusterService.sendJoinRequest(node.getMasterAddress(),true);
        Thread.sleep(50);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
    if (!node.joined()) {
      throw new AssertionError(""String_Node_Str"" + thisAddress + ""String_Node_Str""+ node.getMasterAddress());
    }
  }
}",0.7166400850611377
49207,"@Override public Object getKey(){
  return key;
}","@Override public Object getKey(){
  return new MapKey(name,key);
}",0.8521739130434782
49208,"@Test public void testIteratorContract(){
  TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(1);
  HazelcastInstance instance=nodeFactory.newHazelcastInstance(new Config());
  final IMap<String,ValueType> map=instance.getMap(""String_Node_Str"");
  map.put(""String_Node_Str"",new ValueType(""String_Node_Str""));
  map.put(""String_Node_Str"",new ValueType(""String_Node_Str""));
  map.put(""String_Node_Str"",new ValueType(""String_Node_Str""));
  final Predicate predicate=new SqlPredicate(""String_Node_Str"");
  testIterator(map.keySet().iterator(),3);
  testIterator(map.keySet(predicate).iterator(),2);
  testIterator(map.entrySet().iterator(),3);
  testIterator(map.entrySet(predicate).iterator(),2);
  testIterator(map.values().iterator(),3);
  testIterator(map.values(predicate).iterator(),2);
}","@Test public void testIteratorContract(){
  TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(1);
  HazelcastInstance instance=nodeFactory.newHazelcastInstance(new Config());
  final IMap<String,ValueType> map=instance.getMap(""String_Node_Str"");
  map.put(""String_Node_Str"",new ValueType(""String_Node_Str""));
  map.put(""String_Node_Str"",new ValueType(""String_Node_Str""));
  map.put(""String_Node_Str"",new ValueType(""String_Node_Str""));
  final Predicate predicate=new SqlPredicate(""String_Node_Str"");
  Collection<ValueType> values=map.values(predicate);
  assertEquals(2,map.values(predicate).size());
  assertEquals(2,map.keySet(predicate).size());
  testIterator(map.keySet().iterator(),3);
  testIterator(map.keySet(predicate).iterator(),2);
  testIterator(map.entrySet().iterator(),3);
  testIterator(map.entrySet(predicate).iterator(),2);
  testIterator(map.values().iterator(),3);
  testIterator(map.values(predicate).iterator(),2);
}",0.9007891770011274
49209,"/** 
 * Test for issue 711
 */
@Test public void testPredicateWithEntryKeyObject(){
  Config cfg=new Config();
  TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(1);
  HazelcastInstance instance=nodeFactory.newHazelcastInstance(cfg);
  IMap map=instance.getMap(""String_Node_Str"");
  map.put(""String_Node_Str"",11);
  map.put(""String_Node_Str"",22);
  map.put(""String_Node_Str"",33);
  Predicate predicate=new PredicateBuilder().getEntryObject().key().equal(""String_Node_Str"");
  assertEquals(1,map.values(predicate).size());
  predicate=new PredicateBuilder().getEntryObject().key().in(""String_Node_Str"",""String_Node_Str"");
  assertEquals(2,map.keySet(predicate).size());
}","/** 
 * Test for issue 711
 */
@Test public void testPredicateWithEntryKeyObject(){
  Config cfg=new Config();
  TestHazelcastInstanceFactory nodeFactory=createHazelcastInstanceFactory(1);
  HazelcastInstance instance=nodeFactory.newHazelcastInstance(cfg);
  IMap map=instance.getMap(""String_Node_Str"");
  map.put(""String_Node_Str"",11);
  map.put(""String_Node_Str"",22);
  map.put(""String_Node_Str"",33);
  map.put(""String_Node_Str"",44);
  map.put(""String_Node_Str"",55);
  map.put(""String_Node_Str"",66);
  Predicate predicate=new PredicateBuilder().getEntryObject().key().equal(""String_Node_Str"");
  assertEquals(1,map.values(predicate).size());
  predicate=new PredicateBuilder().getEntryObject().key().in(""String_Node_Str"",""String_Node_Str"");
  assertEquals(2,map.keySet(predicate).size());
  predicate=new PredicateBuilder().getEntryObject().key().in(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertEquals(4,map.keySet(predicate).size());
}",0.8220640569395018
49210,"protected Comparable convert(Map.Entry mapEntry,Comparable entryValue,Comparable attributeValue){
  if (attributeValue == null) {
    return null;
  }
  if (attributeType == null) {
    QueryableEntry queryableEntry=(QueryableEntry)mapEntry;
    attributeType=queryableEntry.getAttributeType(attribute);
  }
  if (attributeType == AttributeType.ENUM) {
    return attributeType.getConverter().convert(attributeValue);
  }
 else {
    if (entryValue != null && entryValue.getClass().isAssignableFrom(attributeValue.getClass())) {
      return attributeValue;
    }
 else     if (attributeType != null) {
      return attributeType.getConverter().convert(attributeValue);
    }
 else {
      throw new QueryException(""String_Node_Str"" + attributeValue.getClass());
    }
  }
}","protected Comparable convert(Map.Entry mapEntry,Comparable entryValue,Comparable attributeValue){
  if (attributeValue == null) {
    return null;
  }
  AttributeType type=attributeType;
  if (type == null) {
    QueryableEntry queryableEntry=(QueryableEntry)mapEntry;
    type=queryableEntry.getAttributeType(attribute);
    attributeType=type;
  }
  if (type == AttributeType.ENUM) {
    return type.getConverter().convert(attributeValue);
  }
 else {
    if (entryValue != null && entryValue.getClass().isAssignableFrom(attributeValue.getClass())) {
      return attributeValue;
    }
 else     if (type != null) {
      return type.getConverter().convert(attributeValue);
    }
 else {
      throw new QueryException(""String_Node_Str"" + attributeValue.getClass());
    }
  }
}",0.7992277992277992
49211,"public void incrementRemoves(long latency){
  removeCount.incrementAndGet();
  maxRemoveLatency.set(Math.max(maxRemoveLatency.get(),latency));
}","public void incrementRemoves(long latency){
  removeCount.incrementAndGet();
  totalRemoveLatencies.addAndGet(latency);
  maxRemoveLatency.set(Math.max(maxRemoveLatency.get(),latency));
}",0.8700906344410876
49212,"public boolean checkHeartBeat(final Connection connection){
  if ((Clock.currentTimeMillis() - connection.getLastReadTime()) > connectionTimeout / 2) {
    final CountDownLatch latch=new CountDownLatch(1);
    executionService.execute(new Runnable(){
      public void run(){
        try {
          connection.write(ping);
          latch.countDown();
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
    }
);
    try {
      return latch.await(5,TimeUnit.SECONDS);
    }
 catch (    InterruptedException e) {
      return false;
    }
  }
 else {
    return true;
  }
}","public boolean checkHeartBeat(final Connection connection){
  if ((Clock.currentTimeMillis() - connection.getLastReadTime()) > connectionTimeout / 2) {
    final CountDownLatch latch=new CountDownLatch(1);
    executionService.execute(new Runnable(){
      public void run(){
        try {
          connection.write(ping);
          connection.read();
          latch.countDown();
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
    }
);
    try {
      return latch.await(5,TimeUnit.SECONDS);
    }
 catch (    InterruptedException e) {
      return false;
    }
  }
 else {
    return true;
  }
}",0.9769291964996022
49213,"public void run(){
  try {
    connection.write(ping);
    latch.countDown();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","public void run(){
  try {
    connection.write(ping);
    connection.read();
    latch.countDown();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}",0.9235880398671096
49214,"private void check(Callable task){
  if (task == null) {
    throw new NullPointerException();
  }
  if (isShutdown()) {
    throw new RejectedExecutionException(getRejectionMessage());
  }
}","private void check(Callable task){
  if (task == null) {
    throw new NullPointerException();
  }
}",0.6872852233676976
49215,"private void listenMembershipEvents() throws IOException {
  final SerializationService serializationService=getSerializationService();
  while (!Thread.currentThread().isInterrupted()) {
    final Data eventData=conn.read();
    final ClientMembershipEvent event=(ClientMembershipEvent)serializationService.toObject(eventData);
    final MemberImpl member=(MemberImpl)event.getMember();
    if (event.getEventType() == MembershipEvent.MEMBER_ADDED) {
      members.add(member);
    }
 else {
      members.remove(member);
    }
    updateMembersRef();
    getConnectionManager().removeConnectionPool(member.getAddress());
    fireMembershipEvent(event);
  }
}","private void listenMembershipEvents() throws IOException {
  final SerializationService serializationService=getSerializationService();
  while (!Thread.currentThread().isInterrupted()) {
    final Data eventData=conn.read();
    final ClientMembershipEvent event=(ClientMembershipEvent)serializationService.toObject(eventData);
    final MemberImpl member=(MemberImpl)event.getMember();
    if (event.getEventType() == MembershipEvent.MEMBER_ADDED) {
      members.add(member);
    }
 else {
      members.remove(member);
      getConnectionManager().removeConnectionPool(member.getAddress());
    }
    updateMembersRef();
    fireMembershipEvent(event);
  }
}",0.8925869894099848
49216,"@Override public int hashCode(){
  return indexKey.hashCode();
}","@Override public int hashCode(){
  return indexKey != null ? indexKey.hashCode() : 0;
}",0.847682119205298
49217,"@Override public boolean equals(Object o){
  if (this == o)   return true;
  if (o == null || getClass() != o.getClass())   return false;
  QueryResultEntryImpl that=(QueryResultEntryImpl)o;
  if (!indexKey.equals(that.indexKey))   return false;
  return true;
}","@Override public boolean equals(Object o){
  if (this == o)   return true;
  if (o == null || getClass() != o.getClass())   return false;
  QueryResultEntryImpl that=(QueryResultEntryImpl)o;
  if (indexKey != null ? !indexKey.equals(that.indexKey) : that.indexKey != null)   return false;
  return true;
}",0.8712522045855379
49218,"public synchronized boolean add(QueryResultEntry entry){
  if (!set || keys.add(entry.getIndexKey())) {
    q.offer(entry);
    size++;
    return true;
  }
  return false;
}","public synchronized boolean add(QueryResultEntry entry){
  if (!started) {
    started=true;
  }
  if (!set || keys.add(entry.getIndexKey())) {
    q.offer(entry);
    size++;
    return true;
  }
  return false;
}",0.8969072164948454
49219,"@Override public int size(){
synchronized (endLock) {
    while (!ended) {
      try {
        endLock.wait();
      }
 catch (      InterruptedException e) {
        return size;
      }
    }
    return size;
  }
}","@Override public int size(){
  if (!started) {
    return 0;
  }
synchronized (endLock) {
    while (!ended) {
      try {
        endLock.wait();
      }
 catch (      InterruptedException e) {
        return size;
      }
    }
    return size;
  }
}",0.9230769230769232
49220,"public static HazelcastInstance newHazelcastClient(ClientConfig config){
  if (config == null) {
    config=new ClientConfig();
  }
  final HazelcastClient client=new HazelcastClient(config);
  final HazelcastClientProxy proxy=new HazelcastClientProxy(client);
  CLIENTS.put(client.id,proxy);
  return proxy;
}","public static HazelcastInstance newHazelcastClient(ClientConfig config){
  if (config == null) {
    config=new XmlClientConfigBuilder().build();
  }
  final HazelcastClient client=new HazelcastClient(config);
  final HazelcastClientProxy proxy=new HazelcastClientProxy(client);
  CLIENTS.put(client.id,proxy);
  return proxy;
}",0.9341692789968652
49221,"public ClientClusterServiceImpl(HazelcastClient client){
  this.client=client;
  clusterThread=new ClusterListenerThread(client.getThreadGroup(),client.getName() + ""String_Node_Str"");
  final ClientConfig clientConfig=getClientConfig();
  redoOperation=clientConfig.isRedoOperation();
  credentials=clientConfig.getCredentials();
  final Collection<EventListener> listeners=client.getClientConfig().getListeners();
  if (listeners != null && !listeners.isEmpty()) {
    for (    EventListener listener : listeners) {
      if (listener instanceof MembershipListener) {
        addMembershipListener((MembershipListener)listener);
      }
    }
  }
}","public ClientClusterServiceImpl(HazelcastClient client){
  this.client=client;
  clusterThread=new ClusterListenerThread(client.getThreadGroup(),client.getName() + ""String_Node_Str"");
  final ClientConfig clientConfig=getClientConfig();
  redoOperation=clientConfig.isRedoOperation();
  credentials=clientConfig.getCredentials();
  final Collection<EventListener> listenersList=client.getClientConfig().getListeners();
  if (listenersList != null && !listenersList.isEmpty()) {
    for (    EventListener listener : listenersList) {
      if (listener instanceof MembershipListener) {
        addMembershipListener((MembershipListener)listener);
      }
    }
  }
}",0.9878234398782344
49222,"public void readData(ObjectDataInput in) throws IOException {
  Member member=new MemberImpl();
  member.readData(in);
}","public void readData(ObjectDataInput in) throws IOException {
  member=new MemberImpl();
  member.readData(in);
}",0.9699570815450644
49223,"protected final void invalidateNearCaches(){
  final MapService mapService=getService();
  final MapContainer mapContainer=mapService.getMapContainer(name);
  if (mapContainer.isNearCacheEnabled() && mapContainer.getMapConfig().getNearCacheConfig().isInvalidateOnChange()) {
    mapService.invalidateAllNearCaches(name,dataKey);
  }
}","protected final void invalidateNearCaches(){
  if (mapContainer.isNearCacheEnabled() && mapContainer.getMapConfig().getNearCacheConfig().isInvalidateOnChange()) {
    mapService.invalidateAllNearCaches(name,dataKey);
  }
}",0.7985611510791367
49224,"@Override protected Object reduce(Map<Integer,Object> map){
  MapEntrySet resultSet=new MapEntrySet();
  MapService mapService=getService();
  for (  Map.Entry<Integer,Object> entry : map.entrySet()) {
    MapEntrySet mapEntrySet=(MapEntrySet)mapService.toObject(entry.getValue());
    Set<Map.Entry<Data,Data>> entrySet=mapEntrySet.getEntrySet();
    for (    Map.Entry<Data,Data> dataEntry : entrySet) {
      resultSet.add(dataEntry);
    }
  }
  return resultSet;
}","@Override protected Object reduce(Map<Integer,Object> map){
  MapEntrySet resultSet=new MapEntrySet();
  MapService mapService=getService();
  for (  Map.Entry<Integer,Object> entry : map.entrySet()) {
    MapEntrySet mapEntrySet=(MapEntrySet)mapService.toObject(entry.getValue());
    Set<Map.Entry<Data,Data>> set=mapEntrySet.getEntrySet();
    for (    Map.Entry<Data,Data> dataEntry : set) {
      resultSet.add(dataEntry);
    }
  }
  return resultSet;
}",0.9849137931034484
49225,"public Map<Long,Data> addAll(Collection<Data> dataList){
  Map<Long,Data> dataMap=new HashMap<Long,Data>(dataList.size());
  for (  Data data : dataList) {
    QueueItem item=new QueueItem(this,nextId(),null);
    if (!store.isEnabled() || store.getMemoryLimit() > getItemQueue().size()) {
      item.setData(data);
    }
    getItemQueue().offer(item);
    dataMap.put(item.getItemId(),data);
  }
  if (store.isEnabled()) {
    try {
      store.storeAll(dataMap);
    }
 catch (    Exception e) {
      for (int i=0; i < dataList.size(); i++) {
        getItemQueue().poll();
      }
      throw new HazelcastException(e);
    }
  }
  return dataMap;
}","public Map<Long,Data> addAll(Collection<Data> dataList){
  Map<Long,Data> map=new HashMap<Long,Data>(dataList.size());
  for (  Data data : dataList) {
    QueueItem item=new QueueItem(this,nextId(),null);
    if (!store.isEnabled() || store.getMemoryLimit() > getItemQueue().size()) {
      item.setData(data);
    }
    getItemQueue().offer(item);
    map.put(item.getItemId(),data);
  }
  if (store.isEnabled()) {
    try {
      store.storeAll(map);
    }
 catch (    Exception e) {
      for (int i=0; i < dataList.size(); i++) {
        getItemQueue().poll();
      }
      throw new HazelcastException(e);
    }
  }
  return map;
}",0.9814241486068112
49226,"public Connection getConnection(Address address) throws IOException {
  checkLive();
  if (address == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final ObjectPool<ConnectionWrapper> pool=getConnectionPool(address);
  if (pool == null) {
    return null;
  }
  Connection connection=null;
  try {
    connection=pool.take();
  }
 catch (  Exception e) {
  }
  if (connection != null && !heartbeat.checkHeartBeat(connection)) {
    connection.close();
    connection=null;
  }
  return connection;
}","public Connection getConnection(Address address) throws IOException {
  checkLive();
  if (address == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final ObjectPool<ConnectionWrapper> pool=getConnectionPool(address);
  if (pool == null) {
    return null;
  }
  Connection connection=null;
  try {
    connection=pool.take();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  if (connection != null && !heartbeat.checkHeartBeat(connection)) {
    connection.close();
    connection=null;
  }
  return connection;
}",0.9767873723305478
49227,"public void handle(final ResponseStream stream) throws Exception {
  stream.read();
  lastStream=stream;
  while (active && !Thread.currentThread().isInterrupted()) {
    try {
      final Object event=stream.read();
      handler.handle(event);
    }
 catch (    Exception e) {
      try {
        stream.end();
      }
 catch (      IOException ignored) {
      }
      if (!(e instanceof IOException)) {
        active=false;
      }
 else {
        throw e;
      }
    }
  }
}","public void handle(final ResponseStream stream) throws Exception {
  stream.read();
  lastStream=stream;
  latch.countDown();
  while (active && !Thread.currentThread().isInterrupted()) {
    try {
      final Object event=stream.read();
      handler.handle(event);
    }
 catch (    Exception e) {
      try {
        stream.end();
      }
 catch (      IOException ignored) {
      }
      if (!(e instanceof IOException)) {
        active=false;
      }
 else {
        throw e;
      }
    }
  }
}",0.9786368260427264
49228,"public String listen(){
  future=context.getExecutionService().submit(new Runnable(){
    public void run(){
      while (active && !Thread.currentThread().isInterrupted()) {
        try {
          EventResponseHandler eventResponseHandler=new EventResponseHandler();
          if (key == null) {
            context.getInvocationService().invokeOnRandomTarget(registrationRequest,eventResponseHandler);
          }
 else {
            context.getInvocationService().invokeOnKeyOwner(registrationRequest,key,eventResponseHandler);
          }
        }
 catch (        Exception ignored) {
        }
      }
    }
  }
);
  return UUID.randomUUID().toString();
}","public String listen(){
  future=context.getExecutionService().submit(new Runnable(){
    public void run(){
      while (active && !Thread.currentThread().isInterrupted()) {
        try {
          EventResponseHandler eventResponseHandler=new EventResponseHandler();
          if (key == null) {
            context.getInvocationService().invokeOnRandomTarget(registrationRequest,eventResponseHandler);
          }
 else {
            context.getInvocationService().invokeOnKeyOwner(registrationRequest,key,eventResponseHandler);
          }
        }
 catch (        Exception ignored) {
        }
      }
    }
  }
);
  try {
    if (!latch.await(1,TimeUnit.MINUTES)) {
      throw new ClientException(""String_Node_Str"");
    }
  }
 catch (  InterruptedException e) {
  }
  return UUID.randomUUID().toString();
}",0.8958051420838972
49229,"private Object authenticate(Connection connection,Credentials credentials,ClientPrincipal principal,boolean reAuth) throws IOException {
  AuthenticationRequest auth=new AuthenticationRequest(credentials,principal);
  auth.setReAuth(reAuth);
  final SerializationService serializationService=getSerializationService();
  connection.write(serializationService.toData(auth));
  final Data addressData=connection.read();
  Address address=(Address)serializationService.toObject(addressData);
  connection.setEndpoint(address);
  final Data data=connection.read();
  Object response=serializationService.toObject(data);
  if (response instanceof GenericError) {
    throw new AuthenticationException(((GenericError)response).getMessage());
  }
  return response;
}","private Object authenticate(Connection connection,Credentials credentials,ClientPrincipal principal,boolean reAuth,boolean firstConnection) throws IOException {
  AuthenticationRequest auth=new AuthenticationRequest(credentials,principal);
  auth.setReAuth(reAuth);
  auth.setFirstConnection(firstConnection);
  final SerializationService serializationService=getSerializationService();
  connection.write(serializationService.toData(auth));
  final Data addressData=connection.read();
  Address address=(Address)serializationService.toObject(addressData);
  connection.setEndpoint(address);
  final Data data=connection.read();
  Object response=serializationService.toObject(data);
  if (response instanceof GenericError) {
    throw new AuthenticationException(((GenericError)response).getMessage());
  }
  return response;
}",0.9571788413098236
49230,"public void auth(Connection connection) throws AuthenticationException, IOException {
  authenticate(connection,credentials,principal,false);
}","public void auth(Connection connection) throws AuthenticationException, IOException {
  authenticate(connection,credentials,principal,false,false);
}",0.9794520547945206
49231,"private Connection getConnection(Address address) throws IOException {
  if (!client.getLifecycleService().isRunning()) {
    throw new HazelcastInstanceNotActiveException();
  }
  Connection connection=null;
  int retryCount=RETRY_COUNT;
  while (connection == null && retryCount > 0) {
    if (address != null) {
      connection=client.getConnectionManager().getConnection(address);
    }
 else {
      connection=client.getConnectionManager().getRandomConnection();
    }
    if (connection == null) {
      retryCount--;
      try {
        Thread.sleep(RETRY_WAIT_TIME);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
  }
  if (connection == null) {
    throw new HazelcastException(""String_Node_Str"");
  }
  return connection;
}","private Connection getConnection(Address address) throws IOException {
  if (!client.getLifecycleService().isRunning()) {
    throw new HazelcastInstanceNotActiveException();
  }
  Connection connection=null;
  int retryCount=RETRY_COUNT;
  while (connection == null && retryCount > 0) {
    if (address != null) {
      connection=client.getConnectionManager().getConnection(address);
    }
 else {
      connection=client.getConnectionManager().getRandomConnection();
    }
    if (connection == null) {
      retryCount--;
      try {
        Thread.sleep(RETRY_WAIT_TIME);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
    address=null;
  }
  if (connection == null) {
    throw new HazelcastException(""String_Node_Str"");
  }
  return connection;
}",0.9885786802030456
49232,"void rollback(){
  try {
    if (state == NO_TXN || state == ROLLED_BACK) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    checkThread();
    try {
      sendAndReceive(new RollbackTransactionRequest());
    }
 catch (    Exception e) {
    }
    state=ROLLED_BACK;
  }
  finally {
    closeConnection();
  }
}","void rollback(){
  try {
    if (state == NO_TXN || state == ROLLED_BACK) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    if (state == ROLLING_BACK) {
      state=ROLLED_BACK;
      return;
    }
    checkThread();
    try {
      sendAndReceive(new RollbackTransactionRequest());
    }
 catch (    Exception e) {
    }
    state=ROLLED_BACK;
  }
  finally {
    closeConnection();
  }
}",0.5378378378378378
49233,"void commit(){
  try {
    if (state != ACTIVE) {
      throw new TransactionNotActiveException(""String_Node_Str"");
    }
    checkThread();
    checkTimeout();
    sendAndReceive(new CommitTransactionRequest());
    state=COMMITTED;
  }
  finally {
    closeConnection();
  }
}","void commit(){
  try {
    if (state != ACTIVE) {
      throw new TransactionNotActiveException(""String_Node_Str"");
    }
    checkThread();
    checkTimeout();
    sendAndReceive(new CommitTransactionRequest());
    state=COMMITTED;
  }
 catch (  Exception e) {
    state=ROLLING_BACK;
    ExceptionUtil.rethrow(e);
  }
 finally {
    closeConnection();
  }
}",0.8714733542319749
49234,"private void closeConnection(){
  try {
    connection.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","private void closeConnection(){
  threadFlag.set(null);
  try {
    connection.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}",0.9124087591240876
49235,"@Test public void testPutIfAbsentTtl() throws Exception {
  assertNull(map.putIfAbsent(""String_Node_Str"",""String_Node_Str"",1,TimeUnit.SECONDS));
  assertEquals(""String_Node_Str"",map.putIfAbsent(""String_Node_Str"",""String_Node_Str"",1,TimeUnit.SECONDS));
  Thread.sleep(2000);
  assertNull(map.putIfAbsent(""String_Node_Str"",""String_Node_Str"",1,TimeUnit.SECONDS));
  assertEquals(""String_Node_Str"",map.putIfAbsent(""String_Node_Str"",""String_Node_Str"",1,TimeUnit.SECONDS));
}","@Test public void testPutIfAbsentTtl() throws Exception {
  assertNull(map.putIfAbsent(""String_Node_Str"",""String_Node_Str"",1,TimeUnit.SECONDS));
  assertEquals(""String_Node_Str"",map.putIfAbsent(""String_Node_Str"",""String_Node_Str"",1,TimeUnit.SECONDS));
  Thread.sleep(2000);
  assertNull(map.putIfAbsent(""String_Node_Str"",""String_Node_Str"",1,TimeUnit.SECONDS));
  assertEquals(""String_Node_Str"",map.putIfAbsent(""String_Node_Str"",""String_Node_Str"",1,TimeUnit.SECONDS));
  Thread.sleep(2000);
}",0.9770833333333332
49236,"@Test public void testOfferPoll() throws IOException, InterruptedException {
  for (int i=0; i < 10; i++) {
    boolean result=q.offer(""String_Node_Str"");
    if (i < 6) {
      assertTrue(result);
    }
 else {
      assertFalse(result);
    }
  }
  assertEquals(6,q.size());
  new Thread(){
    public void run(){
      try {
        Thread.sleep(2 * 1000);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
      q.poll();
    }
  }
.start();
  boolean result=q.offer(""String_Node_Str"",5,TimeUnit.SECONDS);
  assertTrue(result);
  for (int i=0; i < 10; i++) {
    Object o=q.poll();
    if (i < 6) {
      assertNotNull(o);
    }
 else {
      assertNull(o);
    }
  }
  assertEquals(0,q.size());
  new Thread(){
    public void run(){
      try {
        Thread.sleep(2 * 1000);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
      q.offer(""String_Node_Str"");
    }
  }
.start();
  Object o=q.poll(5,TimeUnit.SECONDS);
  assertEquals(""String_Node_Str"",o);
}","@Test public void testOfferPoll() throws IOException, InterruptedException {
  for (int i=0; i < 10; i++) {
    boolean result=q.offer(""String_Node_Str"");
    if (i < 6) {
      assertTrue(result);
    }
 else {
      assertFalse(result);
    }
  }
  assertEquals(6,q.size());
  final Thread t1=new Thread(){
    public void run(){
      try {
        Thread.sleep(2 * 1000);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
      q.poll();
    }
  }
;
  t1.start();
  boolean result=q.offer(""String_Node_Str"",5,TimeUnit.SECONDS);
  assertTrue(result);
  for (int i=0; i < 10; i++) {
    Object o=q.poll();
    if (i < 6) {
      assertNotNull(o);
    }
 else {
      assertNull(o);
    }
  }
  assertEquals(0,q.size());
  final Thread t2=new Thread(){
    public void run(){
      try {
        Thread.sleep(2 * 1000);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
      q.offer(""String_Node_Str"");
    }
  }
;
  t2.start();
  Object o=q.poll(5,TimeUnit.SECONDS);
  assertEquals(""String_Node_Str"",o);
  t1.join(10000);
  t2.join(10000);
}",0.9618249534450652
49237,"public Object call() throws Exception {
  ClientEngineImpl clientEngine=getService();
  Connection connection=endpoint.getConnection();
  ILogger logger=clientEngine.getILogger(getClass());
  clientEngine.sendResponse(endpoint,clientEngine.getThisAddress());
  boolean authenticated;
  if (credentials == null) {
    authenticated=false;
    logger.log(Level.SEVERE,""String_Node_Str"");
  }
 else   if (clientEngine.getSecurityContext() != null) {
    credentials.setEndpoint(connection.getInetAddress().getHostAddress());
    try {
      SecurityContext securityContext=clientEngine.getSecurityContext();
      LoginContext lc=securityContext.createClientLoginContext(credentials);
      lc.login();
      endpoint.setLoginContext(lc);
      authenticated=true;
    }
 catch (    LoginException e) {
      logger.log(Level.WARNING,e.getMessage(),e);
      authenticated=false;
    }
  }
 else {
    if (credentials instanceof UsernamePasswordCredentials) {
      final UsernamePasswordCredentials usernamePasswordCredentials=(UsernamePasswordCredentials)credentials;
      GroupConfig groupConfig=clientEngine.getConfig().getGroupConfig();
      final String nodeGroupName=groupConfig.getName();
      final String nodeGroupPassword=groupConfig.getPassword();
      authenticated=(nodeGroupName.equals(usernamePasswordCredentials.getUsername()) && nodeGroupPassword.equals(usernamePasswordCredentials.getPassword()));
    }
 else {
      authenticated=false;
      logger.log(Level.SEVERE,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ credentials.getClass().getName());
    }
  }
  logger.log((authenticated ? Level.INFO : Level.WARNING),""String_Node_Str"" + connection + ""String_Node_Str""+ (authenticated ? ""String_Node_Str"" : ""String_Node_Str""));
  if (authenticated) {
    if (principal != null) {
      final ClusterService clusterService=clientEngine.getClusterService();
      if (reAuth) {
        if (clusterService.getMember(principal.getOwnerUuid()) != null) {
          return new GenericError(""String_Node_Str"",0);
        }
 else {
          principal=new ClientPrincipal(principal.getUuid(),clientEngine.getLocalMember().getUuid());
          final Collection<MemberImpl> members=clientEngine.getClusterService().getMemberList();
          for (          MemberImpl member : members) {
            if (!member.localMember()) {
              clientEngine.sendOperation(new ClientReAuthOperation(principal.getUuid()),member.getAddress());
            }
          }
        }
      }
 else       if (clusterService.getMember(principal.getOwnerUuid()) == null) {
        clientEngine.removeEndpoint(connection);
        return new GenericError(""String_Node_Str"",0);
      }
    }
    if (principal == null) {
      principal=new ClientPrincipal(endpoint.getUuid(),clientEngine.getLocalMember().getUuid());
    }
    endpoint.authenticated(principal);
    clientEngine.bind(endpoint);
    return principal;
  }
 else {
    clientEngine.removeEndpoint(connection);
    return new GenericError(""String_Node_Str"",0);
  }
}","public Object call() throws Exception {
  ClientEngineImpl clientEngine=getService();
  Connection connection=endpoint.getConnection();
  ILogger logger=clientEngine.getILogger(getClass());
  clientEngine.sendResponse(endpoint,clientEngine.getThisAddress());
  boolean authenticated;
  if (credentials == null) {
    authenticated=false;
    logger.log(Level.SEVERE,""String_Node_Str"");
  }
 else   if (clientEngine.getSecurityContext() != null) {
    credentials.setEndpoint(connection.getInetAddress().getHostAddress());
    try {
      SecurityContext securityContext=clientEngine.getSecurityContext();
      LoginContext lc=securityContext.createClientLoginContext(credentials);
      lc.login();
      endpoint.setLoginContext(lc);
      authenticated=true;
    }
 catch (    LoginException e) {
      logger.log(Level.WARNING,e.getMessage(),e);
      authenticated=false;
    }
  }
 else {
    if (credentials instanceof UsernamePasswordCredentials) {
      final UsernamePasswordCredentials usernamePasswordCredentials=(UsernamePasswordCredentials)credentials;
      GroupConfig groupConfig=clientEngine.getConfig().getGroupConfig();
      final String nodeGroupName=groupConfig.getName();
      final String nodeGroupPassword=groupConfig.getPassword();
      authenticated=(nodeGroupName.equals(usernamePasswordCredentials.getUsername()) && nodeGroupPassword.equals(usernamePasswordCredentials.getPassword()));
    }
 else {
      authenticated=false;
      logger.log(Level.SEVERE,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ credentials.getClass().getName());
    }
  }
  logger.log((authenticated ? Level.INFO : Level.WARNING),""String_Node_Str"" + connection + ""String_Node_Str""+ (authenticated ? ""String_Node_Str"" : ""String_Node_Str""));
  if (authenticated) {
    if (principal != null) {
      final ClusterService clusterService=clientEngine.getClusterService();
      if (reAuth) {
        if (clusterService.getMember(principal.getOwnerUuid()) != null) {
          return new GenericError(""String_Node_Str"",0);
        }
 else {
          principal=new ClientPrincipal(principal.getUuid(),clientEngine.getLocalMember().getUuid());
          final Collection<MemberImpl> members=clientEngine.getClusterService().getMemberList();
          for (          MemberImpl member : members) {
            if (!member.localMember()) {
              clientEngine.sendOperation(new ClientReAuthOperation(principal.getUuid(),firstConnection),member.getAddress());
            }
          }
        }
      }
 else       if (clusterService.getMember(principal.getOwnerUuid()) == null) {
        clientEngine.removeEndpoint(connection);
        return new GenericError(""String_Node_Str"",0);
      }
    }
    if (principal == null) {
      principal=new ClientPrincipal(endpoint.getUuid(),clientEngine.getLocalMember().getUuid());
    }
    endpoint.authenticated(principal,firstConnection);
    clientEngine.bind(endpoint);
    return principal;
  }
 else {
    clientEngine.removeEndpoint(connection);
    return new GenericError(""String_Node_Str"",0);
  }
}",0.9947643979057592
49238,"@Override public void writePortable(PortableWriter writer) throws IOException {
  writer.writePortable(""String_Node_Str"",(Portable)credentials);
  if (principal != null) {
    writer.writePortable(""String_Node_Str"",principal);
  }
 else {
    writer.writeNullPortable(""String_Node_Str"",ClientPortableHook.ID,ClientPortableHook.PRINCIPAL);
  }
  writer.writeBoolean(""String_Node_Str"",reAuth);
}","@Override public void writePortable(PortableWriter writer) throws IOException {
  writer.writePortable(""String_Node_Str"",(Portable)credentials);
  if (principal != null) {
    writer.writePortable(""String_Node_Str"",principal);
  }
 else {
    writer.writeNullPortable(""String_Node_Str"",ClientPortableHook.ID,ClientPortableHook.PRINCIPAL);
  }
  writer.writeBoolean(""String_Node_Str"",reAuth);
  writer.writeBoolean(""String_Node_Str"",firstConnection);
}",0.9312796208530806
49239,"@Override public void readPortable(PortableReader reader) throws IOException {
  credentials=(Credentials)reader.readPortable(""String_Node_Str"");
  principal=reader.readPortable(""String_Node_Str"");
  reAuth=reader.readBoolean(""String_Node_Str"");
}","@Override public void readPortable(PortableReader reader) throws IOException {
  credentials=(Credentials)reader.readPortable(""String_Node_Str"");
  principal=reader.readPortable(""String_Node_Str"");
  reAuth=reader.readBoolean(""String_Node_Str"");
  firstConnection=reader.readBoolean(""String_Node_Str"");
}",0.896551724137931
49240,"void authenticated(ClientPrincipal principal){
  this.principal=principal;
  this.uuid=principal.getUuid();
  authenticated=true;
}","void authenticated(ClientPrincipal principal,boolean firstConnection){
  this.principal=principal;
  this.uuid=principal.getUuid();
  this.firstConnection=firstConnection;
  authenticated=true;
}",0.803680981595092
49241,"void destroy() throws LoginException {
  final LoginContext lc=loginContext;
  if (lc != null) {
    lc.logout();
  }
  final TransactionContext context=transactionContext;
  if (context != null) {
    transactionContext=null;
  }
  authenticated=false;
}","void destroy() throws LoginException {
  final LoginContext lc=loginContext;
  if (lc != null) {
    lc.logout();
  }
  final TransactionContext context=transactionContext;
  if (context != null) {
    try {
      context.rollbackTransaction();
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    transactionContext=null;
  }
  authenticated=false;
}",0.7158908507223114
49242,"@Override public String toString(){
  final StringBuilder sb=new StringBuilder(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(conn);
  sb.append(""String_Node_Str"").append(uuid).append('\'');
  sb.append(""String_Node_Str"").append(authenticated);
  sb.append('}');
  return sb.toString();
}","@Override public String toString(){
  final StringBuilder sb=new StringBuilder(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(conn);
  sb.append(""String_Node_Str"").append(uuid).append('\'');
  sb.append(""String_Node_Str"").append(firstConnection);
  sb.append(""String_Node_Str"").append(authenticated);
  sb.append('}');
  return sb.toString();
}",0.9143730886850152
49243,"public void connectionRemoved(Connection connection){
  if (connection.isClient() && connection instanceof TcpIpConnection) {
    final ClientEndpoint endpoint=endpoints.get(connection);
    if (endpoint != null && node.getLocalMember().getUuid().equals(endpoint.getPrincipal().getOwnerUuid())) {
      removeEndpoint(connection,true);
      NodeEngine nodeEngine=node.nodeEngine;
      final Collection<MemberImpl> memberList=nodeEngine.getClusterService().getMemberList();
      for (      MemberImpl member : memberList) {
        final ClientDisconnectionOperation op=new ClientDisconnectionOperation(endpoint.getUuid());
        op.setNodeEngine(nodeEngine).setServiceName(SERVICE_NAME).setService(this).setResponseHandler(ResponseHandlerFactory.createEmptyResponseHandler());
        if (member.localMember()) {
          nodeEngine.getOperationService().runOperation(op);
        }
 else {
          nodeEngine.getOperationService().send(op,member.getAddress());
        }
      }
    }
  }
}","public void connectionRemoved(Connection connection){
  if (connection.isClient() && connection instanceof TcpIpConnection) {
    final ClientEndpoint endpoint=endpoints.get(connection);
    if (endpoint != null && node.getLocalMember().getUuid().equals(endpoint.getPrincipal().getOwnerUuid())) {
      removeEndpoint(connection,true);
      if (!endpoint.isFirstConnection()) {
        return;
      }
      NodeEngine nodeEngine=node.nodeEngine;
      final Collection<MemberImpl> memberList=nodeEngine.getClusterService().getMemberList();
      for (      MemberImpl member : memberList) {
        final ClientDisconnectionOperation op=new ClientDisconnectionOperation(endpoint.getUuid());
        op.setNodeEngine(nodeEngine).setServiceName(SERVICE_NAME).setService(this).setResponseHandler(ResponseHandlerFactory.createEmptyResponseHandler());
        if (member.localMember()) {
          nodeEngine.getOperationService().runOperation(op);
        }
 else {
          nodeEngine.getOperationService().send(op,member.getAddress());
        }
      }
    }
  }
}",0.9675544794188862
49244,"public ClientReAuthOperation(String clientUuid){
  this.clientUuid=clientUuid;
}","public ClientReAuthOperation(String clientUuid,boolean firstConnection){
  this.clientUuid=clientUuid;
  this.firstConnection=firstConnection;
}",0.7142857142857143
49245,"public void run() throws Exception {
  ClientEngineImpl service=getService();
  final ClientEndpoint endpoint=service.getEndpoint(clientUuid);
  if (endpoint != null) {
    endpoint.authenticated(new ClientPrincipal(clientUuid,getCallerUuid()));
  }
}","public void run() throws Exception {
  ClientEngineImpl service=getService();
  final ClientEndpoint endpoint=service.getEndpoint(clientUuid);
  if (endpoint != null) {
    endpoint.authenticated(new ClientPrincipal(clientUuid,getCallerUuid()),firstConnection);
  }
}",0.9691119691119692
49246,"@Override protected void readInternal(ObjectDataInput in) throws IOException {
  super.readInternal(in);
  clientUuid=in.readUTF();
}","@Override protected void readInternal(ObjectDataInput in) throws IOException {
  super.readInternal(in);
  clientUuid=in.readUTF();
  firstConnection=in.readBoolean();
}",0.8807947019867549
49247,"@Override protected void writeInternal(ObjectDataOutput out) throws IOException {
  super.writeInternal(out);
  out.writeUTF(clientUuid);
}","@Override protected void writeInternal(ObjectDataOutput out) throws IOException {
  super.writeInternal(out);
  out.writeUTF(clientUuid);
  out.writeBoolean(firstConnection);
}",0.8825396825396825
49248,"public boolean cancel(String uuid,boolean interrupt){
  final CallableProcessor processor=submittedTasks.remove(uuid);
  if (processor != null && processor.cancel(interrupt)) {
    processor.responseHandler.sendResponse(new CancellationException());
    getLocalExecutorStats(processor.name).cancelExecution();
    return true;
  }
  return false;
}","public boolean cancel(String uuid,boolean interrupt){
  final CallableProcessor processor=submittedTasks.remove(uuid);
  if (processor != null && processor.cancel(interrupt)) {
    processor.sendResponse(new CancellationException());
    getLocalExecutorStats(processor.name).cancelExecution();
    return true;
  }
  return false;
}",0.9765395894428152
49249,"public void run(){
  final long start=Clock.currentTimeMillis();
  startExecution(name,start - creationTime);
  Object result=null;
  try {
    super.run();
    result=get();
  }
 catch (  Exception e) {
    final ILogger logger=getLogger();
    logger.log(Level.FINEST,""String_Node_Str"" + callableToString,e);
    result=e;
  }
 finally {
    if (uuid != null) {
      submittedTasks.remove(uuid);
    }
    final boolean cancelled=isCancelled();
    try {
      responseHandler.sendResponse(result);
    }
 catch (    ResponseAlreadySentException e) {
      if (!cancelled) {
        final ILogger logger=getLogger();
        logger.log(Level.SEVERE,e.getMessage(),e);
      }
    }
    if (!cancelled) {
      finishExecution(name,Clock.currentTimeMillis() - start);
    }
  }
}","public void run(){
  final long start=Clock.currentTimeMillis();
  startExecution(name,start - creationTime);
  Object result=null;
  try {
    super.run();
    result=get();
  }
 catch (  Exception e) {
    final ILogger logger=getLogger();
    logger.log(Level.FINEST,""String_Node_Str"" + callableToString,e);
    result=e;
  }
 finally {
    if (uuid != null) {
      submittedTasks.remove(uuid);
    }
    sendResponse(result);
    if (!isCancelled()) {
      finishExecution(name,Clock.currentTimeMillis() - start);
    }
  }
}",0.7637195121951219
49250,"public ClientConfig build(){
  logger.log(Level.INFO,""String_Node_Str"" + (resource != null ? ""String_Node_Str"" + resource : ""String_Node_Str"") + ""String_Node_Str"");
  if (props.containsKey(GROUP_NAME)) {
    config.getGroupConfig().setName(props.getProperty(GROUP_NAME));
  }
  if (props.containsKey(GROUP_PASS)) {
    config.getGroupConfig().setPassword(props.getProperty(GROUP_PASS));
  }
  if (props.containsKey(CONNECTION_TIMEOUT)) {
    config.setConnectionTimeout(Integer.parseInt(props.getProperty(CONNECTION_TIMEOUT)));
  }
  if (props.containsKey(CONNECTION_ATTEMPT_LIMIT)) {
    config.setConnectionAttemptLimit(Integer.parseInt(props.getProperty(CONNECTION_ATTEMPT_LIMIT)));
  }
  if (props.containsKey(RECONNECTION_TIMEOUT)) {
    config.setAttemptPeriod(Integer.parseInt(props.getProperty(RECONNECTION_TIMEOUT)));
  }
  if (props.containsKey(ADDRESSES)) {
    final String addressesProp=props.getProperty(ADDRESSES);
    if (addressesProp != null) {
      final String[] addresses=addressesProp.split(""String_Node_Str"");
      for (      String address : addresses) {
        address=address.trim();
        if (address.length() > 0) {
          config.addAddress(address);
        }
      }
    }
  }
  return config;
}","public ClientConfig build(){
  logger.log(Level.INFO,""String_Node_Str"" + (resource != null ? ""String_Node_Str"" + resource : ""String_Node_Str"") + ""String_Node_Str"");
  if (props.containsKey(GROUP_NAME)) {
    config.getGroupConfig().setName(props.getProperty(GROUP_NAME));
  }
  if (props.containsKey(GROUP_PASS)) {
    config.getGroupConfig().setPassword(props.getProperty(GROUP_PASS));
  }
  if (props.containsKey(CONNECTION_TIMEOUT)) {
    config.setConnectionTimeout(Integer.parseInt(props.getProperty(CONNECTION_TIMEOUT)));
  }
  if (props.containsKey(CONNECTION_ATTEMPT_LIMIT)) {
    config.setConnectionAttemptLimit(Integer.parseInt(props.getProperty(CONNECTION_ATTEMPT_LIMIT)));
  }
  if (props.containsKey(CONNECTION_ATTEMPT_PERIOD)) {
    config.setConnectionAttemptPeriod(Integer.parseInt(props.getProperty(CONNECTION_ATTEMPT_PERIOD)));
  }
  if (props.containsKey(ADDRESSES)) {
    final String addressesProp=props.getProperty(ADDRESSES);
    if (addressesProp != null) {
      final String[] addresses=addressesProp.split(""String_Node_Str"");
      for (      String address : addresses) {
        address=address.trim();
        if (address.length() > 0) {
          config.addAddress(address);
        }
      }
    }
  }
  return config;
}",0.9074818986323412
49251,"private Connection getConnection(Address address) throws IOException {
  if (!client.getLifecycleService().isRunning()) {
    throw new HazelcastInstanceNotActiveException();
  }
  Connection connection=null;
  int retryCount=RETRY_COUNT;
  while (connection == null && retryCount > 0) {
    if (address == null) {
      connection=client.getConnectionManager().getConnection(address);
    }
 else {
      connection=client.getConnectionManager().getRandomConnection();
    }
    if (connection == null) {
      retryCount--;
      try {
        Thread.sleep(RETRY_WAIT_TIME);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
  }
  if (connection == null) {
    throw new HazelcastException(""String_Node_Str"");
  }
  return connection;
}","private Connection getConnection(Address address) throws IOException {
  if (!client.getLifecycleService().isRunning()) {
    throw new HazelcastInstanceNotActiveException();
  }
  Connection connection=null;
  int retryCount=RETRY_COUNT;
  while (connection == null && retryCount > 0) {
    if (address != null) {
      connection=client.getConnectionManager().getConnection(address);
    }
 else {
      connection=client.getConnectionManager().getRandomConnection();
    }
    if (connection == null) {
      retryCount--;
      try {
        Thread.sleep(RETRY_WAIT_TIME);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
  }
  if (connection == null) {
    throw new HazelcastException(""String_Node_Str"");
  }
  return connection;
}",0.9987163029525032
49252,"private Connection connectToOne(final Collection<InetSocketAddress> socketAddresses) throws Exception {
  final int connectionAttemptLimit=getClientConfig().getConnectionAttemptLimit();
  final ManagerAuthenticator authenticator=new ManagerAuthenticator();
  int attempt=0;
  while (true) {
    final long nextTry=Clock.currentTimeMillis() + getClientConfig().getAttemptPeriod();
    for (    InetSocketAddress isa : socketAddresses) {
      try {
        Address address=new Address(isa);
        return getConnectionManager().firstConnection(address,authenticator);
      }
 catch (      IOException ignored) {
      }
    }
    if (attempt++ >= connectionAttemptLimit) {
      break;
    }
    final long remainingTime=nextTry - Clock.currentTimeMillis();
    System.err.println(String.format(""String_Node_Str"" + ""String_Node_Str"",Math.max(0,remainingTime),attempt,connectionAttemptLimit));
    if (remainingTime > 0) {
      try {
        Thread.sleep(remainingTime);
      }
 catch (      InterruptedException e) {
        break;
      }
    }
  }
  throw new IllegalStateException(""String_Node_Str"");
}","private Connection connectToOne(final Collection<InetSocketAddress> socketAddresses) throws Exception {
  final int connectionAttemptLimit=getClientConfig().getConnectionAttemptLimit();
  final ManagerAuthenticator authenticator=new ManagerAuthenticator();
  int attempt=0;
  while (true) {
    final long nextTry=Clock.currentTimeMillis() + getClientConfig().getConnectionAttemptPeriod();
    for (    InetSocketAddress isa : socketAddresses) {
      try {
        Address address=new Address(isa);
        return getConnectionManager().firstConnection(address,authenticator);
      }
 catch (      IOException ignored) {
      }
    }
    if (attempt++ >= connectionAttemptLimit) {
      break;
    }
    final long remainingTime=nextTry - Clock.currentTimeMillis();
    System.err.println(String.format(""String_Node_Str"" + ""String_Node_Str"",Math.max(0,remainingTime),attempt,connectionAttemptLimit));
    if (remainingTime > 0) {
      try {
        Thread.sleep(remainingTime);
      }
 catch (      InterruptedException e) {
        break;
      }
    }
  }
  throw new IllegalStateException(""String_Node_Str"");
}",0.995507637017071
49253,"@Test public void testClient(){
  assertNotNull(client);
  assertNotNull(client2);
  ClientConfig config=client.getClientConfig();
  assertEquals(3,config.getConnectionAttemptLimit());
  assertEquals(1000,config.getConnectionTimeout());
  assertEquals(3000,config.getAttemptPeriod());
  ClientConfig config2=client2.getClientConfig();
  assertEquals(credentials,config2.getCredentials());
  client.getMap(""String_Node_Str"").put(""String_Node_Str"",""String_Node_Str"");
  client2.getMap(""String_Node_Str"").put(""String_Node_Str"",""String_Node_Str"");
  final IMap<Object,Object> map=instance.getMap(""String_Node_Str"");
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
}","@Test public void testClient(){
  assertNotNull(client);
  assertNotNull(client2);
  ClientConfig config=client.getClientConfig();
  assertEquals(3,config.getConnectionAttemptLimit());
  assertEquals(1000,config.getConnectionTimeout());
  assertEquals(3000,config.getConnectionAttemptPeriod());
  ClientConfig config2=client2.getClientConfig();
  assertEquals(credentials,config2.getCredentials());
  client.getMap(""String_Node_Str"").put(""String_Node_Str"",""String_Node_Str"");
  client2.getMap(""String_Node_Str"").put(""String_Node_Str"",""String_Node_Str"");
  final IMap<Object,Object> map=instance.getMap(""String_Node_Str"");
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
}",0.9932614555256064
49254,"@Test public void testTxnOwnerDies() throws TransactionException {
  Config config=new Config();
  StaticNodeFactory factory=new StaticNodeFactory(3);
  final HazelcastInstance h1=factory.newHazelcastInstance(config);
  HazelcastInstance h2=factory.newHazelcastInstance(config);
  HazelcastInstance h3=factory.newHazelcastInstance(config);
  final IMap map1=h1.getMap(""String_Node_Str"");
  final int size=50;
  Runnable runnable=new Runnable(){
    public void run(){
      try {
        boolean b=h1.executeTransaction(new TransactionalTask<Boolean>(){
          public Boolean execute(          TransactionalTaskContext context) throws TransactionException {
            final TransactionalMap<Object,Object> txMap=context.getMap(""String_Node_Str"");
            for (int i=0; i < size; i++) {
              txMap.put(i,i);
              try {
                Thread.sleep(100);
                System.out.println(""String_Node_Str"" + i);
              }
 catch (              InterruptedException e) {
                e.printStackTrace();
              }
            }
            return true;
          }
        }
);
        fail();
      }
 catch (      TransactionException e) {
      }
    }
  }
;
  try {
    Thread thread=new Thread(runnable);
    thread.start();
    Thread.sleep(200);
    h1.getLifecycleService().shutdown();
    thread.join();
    final IMap map2=h2.getMap(""String_Node_Str"");
    for (int i=0; i < size; i++) {
      assertNull(map2.get(i));
    }
  }
 catch (  InterruptedException e) {
  }
}","@Test public void testTxnOwnerDies() throws TransactionException {
  Config config=new Config();
  final TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(3);
  final HazelcastInstance h1=factory.newHazelcastInstance(config);
  final HazelcastInstance h2=factory.newHazelcastInstance(config);
  final HazelcastInstance h3=factory.newHazelcastInstance(config);
  final IMap map1=h1.getMap(""String_Node_Str"");
  final int size=50;
  Runnable runnable=new Runnable(){
    public void run(){
      try {
        boolean b=h1.executeTransaction(new TransactionalTask<Boolean>(){
          public Boolean execute(          TransactionalTaskContext context) throws TransactionException {
            final TransactionalMap<Object,Object> txMap=context.getMap(""String_Node_Str"");
            for (int i=0; i < size; i++) {
              txMap.put(i,i);
              try {
                Thread.sleep(100);
                System.out.println(""String_Node_Str"" + i);
              }
 catch (              InterruptedException e) {
                e.printStackTrace();
              }
            }
            return true;
          }
        }
);
        fail();
      }
 catch (      TransactionException e) {
      }
    }
  }
;
  try {
    Thread thread=new Thread(runnable);
    thread.start();
    Thread.sleep(200);
    h1.getLifecycleService().shutdown();
    thread.join();
    final IMap map2=h2.getMap(""String_Node_Str"");
    for (int i=0; i < size; i++) {
      assertNull(map2.get(i));
    }
  }
 catch (  InterruptedException e) {
  }
}",0.9733939000648928
49255,"@Test public void testTxnCommit() throws TransactionException {
  Config config=new Config();
  StaticNodeFactory factory=new StaticNodeFactory(2);
  HazelcastInstance h1=factory.newHazelcastInstance(config);
  HazelcastInstance h2=factory.newHazelcastInstance(config);
  final IMap map2=h2.getMap(""String_Node_Str"");
  boolean b=h1.executeTransaction(new TransactionalTask<Boolean>(){
    public Boolean execute(    TransactionalTaskContext context) throws TransactionException {
      final TransactionalMap<Object,Object> txMap=context.getMap(""String_Node_Str"");
      txMap.put(""String_Node_Str"",""String_Node_Str"");
      assertEquals(""String_Node_Str"",txMap.put(""String_Node_Str"",""String_Node_Str""));
      assertEquals(""String_Node_Str"",txMap.get(""String_Node_Str""));
      assertEquals(true,txMap.containsKey(""String_Node_Str""));
      assertNull(map2.get(""String_Node_Str""));
      assertNull(map2.get(""String_Node_Str""));
      return true;
    }
  }
);
  assertTrue(b);
  IMap map1=h1.getMap(""String_Node_Str"");
  assertEquals(""String_Node_Str"",map1.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map2.get(""String_Node_Str""));
}","@Test public void testTxnCommit() throws TransactionException {
  Config config=new Config();
  final TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(2);
  final HazelcastInstance h1=factory.newHazelcastInstance(config);
  final HazelcastInstance h2=factory.newHazelcastInstance(config);
  final IMap map2=h2.getMap(""String_Node_Str"");
  boolean b=h1.executeTransaction(new TransactionalTask<Boolean>(){
    public Boolean execute(    TransactionalTaskContext context) throws TransactionException {
      final TransactionalMap<Object,Object> txMap=context.getMap(""String_Node_Str"");
      txMap.put(""String_Node_Str"",""String_Node_Str"");
      assertEquals(""String_Node_Str"",txMap.put(""String_Node_Str"",""String_Node_Str""));
      assertEquals(""String_Node_Str"",txMap.get(""String_Node_Str""));
      assertEquals(true,txMap.containsKey(""String_Node_Str""));
      assertNull(map2.get(""String_Node_Str""));
      assertNull(map2.get(""String_Node_Str""));
      return true;
    }
  }
);
  assertTrue(b);
  IMap map1=h1.getMap(""String_Node_Str"");
  assertEquals(""String_Node_Str"",map1.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map2.get(""String_Node_Str""));
}",0.9648972602739726
49256,"@Test public void testTxnReplaceIfSame() throws TransactionException {
  Config config=new Config();
  StaticNodeFactory factory=new StaticNodeFactory(2);
  HazelcastInstance h1=factory.newHazelcastInstance(config);
  HazelcastInstance h2=factory.newHazelcastInstance(config);
  final IMap map2=h2.getMap(""String_Node_Str"");
  map2.put(""String_Node_Str"",""String_Node_Str"");
  map2.put(""String_Node_Str"",""String_Node_Str"");
  boolean b=h1.executeTransaction(new TransactionalTask<Boolean>(){
    public Boolean execute(    TransactionalTaskContext context) throws TransactionException {
      final TransactionalMap<Object,Object> txMap=context.getMap(""String_Node_Str"");
      assertEquals(true,txMap.replace(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
      assertEquals(false,txMap.replace(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
      assertEquals(false,txMap.replace(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
      assertEquals(""String_Node_Str"",map2.get(""String_Node_Str""));
      assertEquals(""String_Node_Str"",txMap.get(""String_Node_Str""));
      assertEquals(""String_Node_Str"",map2.get(""String_Node_Str""));
      assertEquals(""String_Node_Str"",txMap.get(""String_Node_Str""));
      return true;
    }
  }
);
  assertTrue(b);
  IMap map1=h1.getMap(""String_Node_Str"");
  assertEquals(""String_Node_Str"",map1.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map2.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map1.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map2.get(""String_Node_Str""));
}","@Test public void testTxnReplaceIfSame() throws TransactionException {
  Config config=new Config();
  final TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(2);
  final HazelcastInstance h1=factory.newHazelcastInstance(config);
  final HazelcastInstance h2=factory.newHazelcastInstance(config);
  final IMap map2=h2.getMap(""String_Node_Str"");
  map2.put(""String_Node_Str"",""String_Node_Str"");
  map2.put(""String_Node_Str"",""String_Node_Str"");
  boolean b=h1.executeTransaction(new TransactionalTask<Boolean>(){
    public Boolean execute(    TransactionalTaskContext context) throws TransactionException {
      final TransactionalMap<Object,Object> txMap=context.getMap(""String_Node_Str"");
      assertEquals(true,txMap.replace(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
      assertEquals(false,txMap.replace(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
      assertEquals(false,txMap.replace(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
      assertEquals(""String_Node_Str"",map2.get(""String_Node_Str""));
      assertEquals(""String_Node_Str"",txMap.get(""String_Node_Str""));
      assertEquals(""String_Node_Str"",map2.get(""String_Node_Str""));
      assertEquals(""String_Node_Str"",txMap.get(""String_Node_Str""));
      return true;
    }
  }
);
  assertTrue(b);
  IMap map1=h1.getMap(""String_Node_Str"");
  assertEquals(""String_Node_Str"",map1.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map2.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map1.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map2.get(""String_Node_Str""));
}",0.9742300439974858
49257,"@Test public void testCommitOrder() throws TransactionException {
  Config config=new Config();
  StaticNodeFactory factory=new StaticNodeFactory(4);
  HazelcastInstance h1=factory.newHazelcastInstance(config);
  HazelcastInstance h2=factory.newHazelcastInstance(config);
  HazelcastInstance h3=factory.newHazelcastInstance(config);
  HazelcastInstance h4=factory.newHazelcastInstance(config);
  boolean b=h1.executeTransaction(new TransactionalTask<Boolean>(){
    public Boolean execute(    TransactionalTaskContext context) throws TransactionException {
      final TransactionalMap<Object,Object> txMap=context.getMap(""String_Node_Str"");
      txMap.put(""String_Node_Str"",""String_Node_Str"");
      assertEquals(""String_Node_Str"",txMap.put(""String_Node_Str"",""String_Node_Str""));
      assertEquals(""String_Node_Str"",txMap.put(""String_Node_Str"",""String_Node_Str""));
      assertEquals(""String_Node_Str"",txMap.put(""String_Node_Str"",""String_Node_Str""));
      assertEquals(""String_Node_Str"",txMap.put(""String_Node_Str"",""String_Node_Str""));
      assertEquals(""String_Node_Str"",txMap.put(""String_Node_Str"",""String_Node_Str""));
      return true;
    }
  }
);
  assertEquals(""String_Node_Str"",h4.getMap(""String_Node_Str"").get(""String_Node_Str""));
}","@Test public void testCommitOrder() throws TransactionException {
  Config config=new Config();
  final TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(4);
  final HazelcastInstance h1=factory.newHazelcastInstance(config);
  final HazelcastInstance h2=factory.newHazelcastInstance(config);
  final HazelcastInstance h3=factory.newHazelcastInstance(config);
  final HazelcastInstance h4=factory.newHazelcastInstance(config);
  boolean b=h1.executeTransaction(new TransactionalTask<Boolean>(){
    public Boolean execute(    TransactionalTaskContext context) throws TransactionException {
      final TransactionalMap<Object,Object> txMap=context.getMap(""String_Node_Str"");
      txMap.put(""String_Node_Str"",""String_Node_Str"");
      assertEquals(""String_Node_Str"",txMap.put(""String_Node_Str"",""String_Node_Str""));
      assertEquals(""String_Node_Str"",txMap.put(""String_Node_Str"",""String_Node_Str""));
      assertEquals(""String_Node_Str"",txMap.put(""String_Node_Str"",""String_Node_Str""));
      assertEquals(""String_Node_Str"",txMap.put(""String_Node_Str"",""String_Node_Str""));
      assertEquals(""String_Node_Str"",txMap.put(""String_Node_Str"",""String_Node_Str""));
      return true;
    }
  }
);
  assertEquals(""String_Node_Str"",h4.getMap(""String_Node_Str"").get(""String_Node_Str""));
}",0.963021243115657
49258,"@Test public void testTxnRemoveIfSame() throws TransactionException {
  Config config=new Config();
  StaticNodeFactory factory=new StaticNodeFactory(2);
  HazelcastInstance h1=factory.newHazelcastInstance(config);
  HazelcastInstance h2=factory.newHazelcastInstance(config);
  final IMap map2=h2.getMap(""String_Node_Str"");
  map2.put(""String_Node_Str"",""String_Node_Str"");
  map2.put(""String_Node_Str"",""String_Node_Str"");
  boolean b=h1.executeTransaction(new TransactionalTask<Boolean>(){
    public Boolean execute(    TransactionalTaskContext context) throws TransactionException {
      final TransactionalMap<Object,Object> txMap=context.getMap(""String_Node_Str"");
      txMap.put(""String_Node_Str"",""String_Node_Str"");
      map2.put(""String_Node_Str"",""String_Node_Str"");
      assertEquals(true,txMap.remove(""String_Node_Str"",""String_Node_Str""));
      assertEquals(false,txMap.remove(""String_Node_Str"",""String_Node_Str""));
      assertEquals(""String_Node_Str"",map2.get(""String_Node_Str""));
      assertEquals(null,txMap.get(""String_Node_Str""));
      assertEquals(true,txMap.remove(""String_Node_Str"",""String_Node_Str""));
      assertEquals(false,txMap.remove(""String_Node_Str"",null));
      assertEquals(false,txMap.remove(""String_Node_Str"",""String_Node_Str""));
      return true;
    }
  }
);
  assertTrue(b);
  IMap map1=h1.getMap(""String_Node_Str"");
  assertEquals(null,map1.get(""String_Node_Str""));
  assertEquals(null,map2.get(""String_Node_Str""));
  assertEquals(null,map1.get(""String_Node_Str""));
  assertEquals(null,map2.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map1.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map2.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map1.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map2.get(""String_Node_Str""));
}","@Test public void testTxnRemoveIfSame() throws TransactionException {
  Config config=new Config();
  final TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(2);
  final HazelcastInstance h1=factory.newHazelcastInstance(config);
  final HazelcastInstance h2=factory.newHazelcastInstance(config);
  final IMap map2=h2.getMap(""String_Node_Str"");
  map2.put(""String_Node_Str"",""String_Node_Str"");
  map2.put(""String_Node_Str"",""String_Node_Str"");
  boolean b=h1.executeTransaction(new TransactionalTask<Boolean>(){
    public Boolean execute(    TransactionalTaskContext context) throws TransactionException {
      final TransactionalMap<Object,Object> txMap=context.getMap(""String_Node_Str"");
      txMap.put(""String_Node_Str"",""String_Node_Str"");
      map2.put(""String_Node_Str"",""String_Node_Str"");
      assertEquals(true,txMap.remove(""String_Node_Str"",""String_Node_Str""));
      assertEquals(false,txMap.remove(""String_Node_Str"",""String_Node_Str""));
      assertEquals(""String_Node_Str"",map2.get(""String_Node_Str""));
      assertEquals(null,txMap.get(""String_Node_Str""));
      assertEquals(true,txMap.remove(""String_Node_Str"",""String_Node_Str""));
      assertEquals(false,txMap.remove(""String_Node_Str"",null));
      assertEquals(false,txMap.remove(""String_Node_Str"",""String_Node_Str""));
      return true;
    }
  }
);
  assertTrue(b);
  IMap map1=h1.getMap(""String_Node_Str"");
  assertEquals(null,map1.get(""String_Node_Str""));
  assertEquals(null,map2.get(""String_Node_Str""));
  assertEquals(null,map1.get(""String_Node_Str""));
  assertEquals(null,map2.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map1.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map2.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map1.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map2.get(""String_Node_Str""));
}",0.9776200873362444
49259,"@Test public void testTxnRemove() throws TransactionException {
  Config config=new Config();
  StaticNodeFactory factory=new StaticNodeFactory(2);
  HazelcastInstance h1=factory.newHazelcastInstance(config);
  HazelcastInstance h2=factory.newHazelcastInstance(config);
  final IMap map2=h2.getMap(""String_Node_Str"");
  map2.put(""String_Node_Str"",""String_Node_Str"");
  map2.put(""String_Node_Str"",""String_Node_Str"");
  boolean b=h1.executeTransaction(new TransactionalTask<Boolean>(){
    public Boolean execute(    TransactionalTaskContext context) throws TransactionException {
      final TransactionalMap<Object,Object> txMap=context.getMap(""String_Node_Str"");
      txMap.put(""String_Node_Str"",""String_Node_Str"");
      map2.put(""String_Node_Str"",""String_Node_Str"");
      assertEquals(""String_Node_Str"",txMap.remove(""String_Node_Str""));
      assertEquals(""String_Node_Str"",map2.remove(""String_Node_Str""));
      assertEquals(""String_Node_Str"",map2.get(""String_Node_Str""));
      assertEquals(null,txMap.get(""String_Node_Str""));
      assertEquals(null,txMap.remove(""String_Node_Str""));
      return true;
    }
  }
);
  assertTrue(b);
  IMap map1=h1.getMap(""String_Node_Str"");
  assertEquals(null,map1.get(""String_Node_Str""));
  assertEquals(null,map2.get(""String_Node_Str""));
  assertEquals(null,map1.get(""String_Node_Str""));
  assertEquals(null,map2.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map1.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map2.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map1.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map2.get(""String_Node_Str""));
}","@Test public void testTxnRemove() throws TransactionException {
  Config config=new Config();
  final TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(2);
  final HazelcastInstance h1=factory.newHazelcastInstance(config);
  final HazelcastInstance h2=factory.newHazelcastInstance(config);
  final IMap map2=h2.getMap(""String_Node_Str"");
  map2.put(""String_Node_Str"",""String_Node_Str"");
  map2.put(""String_Node_Str"",""String_Node_Str"");
  boolean b=h1.executeTransaction(new TransactionalTask<Boolean>(){
    public Boolean execute(    TransactionalTaskContext context) throws TransactionException {
      final TransactionalMap<Object,Object> txMap=context.getMap(""String_Node_Str"");
      txMap.put(""String_Node_Str"",""String_Node_Str"");
      map2.put(""String_Node_Str"",""String_Node_Str"");
      assertEquals(""String_Node_Str"",txMap.remove(""String_Node_Str""));
      assertEquals(""String_Node_Str"",map2.remove(""String_Node_Str""));
      assertEquals(""String_Node_Str"",map2.get(""String_Node_Str""));
      assertEquals(null,txMap.get(""String_Node_Str""));
      assertEquals(null,txMap.remove(""String_Node_Str""));
      return true;
    }
  }
);
  assertTrue(b);
  IMap map1=h1.getMap(""String_Node_Str"");
  assertEquals(null,map1.get(""String_Node_Str""));
  assertEquals(null,map2.get(""String_Node_Str""));
  assertEquals(null,map1.get(""String_Node_Str""));
  assertEquals(null,map2.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map1.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map2.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map1.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map2.get(""String_Node_Str""));
}",0.9752265861027192
49260,"@Test public void testTxnSet() throws TransactionException {
  Config config=new Config();
  StaticNodeFactory factory=new StaticNodeFactory(2);
  HazelcastInstance h1=factory.newHazelcastInstance(config);
  HazelcastInstance h2=factory.newHazelcastInstance(config);
  final IMap map2=h2.getMap(""String_Node_Str"");
  boolean b=h1.executeTransaction(new TransactionalTask<Boolean>(){
    public Boolean execute(    TransactionalTaskContext context) throws TransactionException {
      final TransactionalMap<Object,Object> txMap=context.getMap(""String_Node_Str"");
      txMap.set(""String_Node_Str"",""String_Node_Str"");
      txMap.set(""String_Node_Str"",""String_Node_Str"");
      assertEquals(""String_Node_Str"",txMap.get(""String_Node_Str""));
      assertNull(map2.get(""String_Node_Str""));
      assertNull(map2.get(""String_Node_Str""));
      return true;
    }
  }
);
  assertTrue(b);
  IMap map1=h1.getMap(""String_Node_Str"");
  assertEquals(""String_Node_Str"",map1.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map2.get(""String_Node_Str""));
}","@Test public void testTxnSet() throws TransactionException {
  Config config=new Config();
  final TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(2);
  final HazelcastInstance h1=factory.newHazelcastInstance(config);
  final HazelcastInstance h2=factory.newHazelcastInstance(config);
  final IMap map2=h2.getMap(""String_Node_Str"");
  boolean b=h1.executeTransaction(new TransactionalTask<Boolean>(){
    public Boolean execute(    TransactionalTaskContext context) throws TransactionException {
      final TransactionalMap<Object,Object> txMap=context.getMap(""String_Node_Str"");
      txMap.set(""String_Node_Str"",""String_Node_Str"");
      txMap.set(""String_Node_Str"",""String_Node_Str"");
      assertEquals(""String_Node_Str"",txMap.get(""String_Node_Str""));
      assertNull(map2.get(""String_Node_Str""));
      assertNull(map2.get(""String_Node_Str""));
      return true;
    }
  }
);
  assertTrue(b);
  IMap map1=h1.getMap(""String_Node_Str"");
  assertEquals(""String_Node_Str"",map1.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map2.get(""String_Node_Str""));
}",0.9616822429906542
49261,"@Test public void testTxnReplace2() throws TransactionException {
  Config config=new Config();
  StaticNodeFactory factory=new StaticNodeFactory(2);
  HazelcastInstance h1=factory.newHazelcastInstance(config);
  HazelcastInstance h2=factory.newHazelcastInstance(config);
  final IMap map2=h2.getMap(""String_Node_Str"");
  map2.put(""String_Node_Str"",""String_Node_Str"");
  boolean b=h1.executeTransaction(new TransactionalTask<Boolean>(){
    public Boolean execute(    TransactionalTaskContext context) throws TransactionException {
      final TransactionalMap<Object,Object> txMap=context.getMap(""String_Node_Str"");
      assertEquals(""String_Node_Str"",txMap.replace(""String_Node_Str"",""String_Node_Str""));
      assertEquals(""String_Node_Str"",txMap.get(""String_Node_Str""));
      assertNull(map2.get(""String_Node_Str""));
      return true;
    }
  }
);
  assertTrue(b);
  IMap map1=h1.getMap(""String_Node_Str"");
  assertEquals(""String_Node_Str"",map1.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map2.get(""String_Node_Str""));
}","@Test public void testTxnReplace2() throws TransactionException {
  Config config=new Config();
  final TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(2);
  final HazelcastInstance h1=factory.newHazelcastInstance(config);
  final HazelcastInstance h2=factory.newHazelcastInstance(config);
  final IMap map2=h2.getMap(""String_Node_Str"");
  map2.put(""String_Node_Str"",""String_Node_Str"");
  boolean b=h1.executeTransaction(new TransactionalTask<Boolean>(){
    public Boolean execute(    TransactionalTaskContext context) throws TransactionException {
      final TransactionalMap<Object,Object> txMap=context.getMap(""String_Node_Str"");
      assertEquals(""String_Node_Str"",txMap.replace(""String_Node_Str"",""String_Node_Str""));
      assertEquals(""String_Node_Str"",txMap.get(""String_Node_Str""));
      assertNull(map2.get(""String_Node_Str""));
      return true;
    }
  }
);
  assertTrue(b);
  IMap map1=h1.getMap(""String_Node_Str"");
  assertEquals(""String_Node_Str"",map1.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map2.get(""String_Node_Str""));
}",0.9612842304060434
49262,"@Test public void testTxnDelete() throws TransactionException {
  Config config=new Config();
  StaticNodeFactory factory=new StaticNodeFactory(2);
  HazelcastInstance h1=factory.newHazelcastInstance(config);
  HazelcastInstance h2=factory.newHazelcastInstance(config);
  final IMap map2=h2.getMap(""String_Node_Str"");
  map2.put(""String_Node_Str"",""String_Node_Str"");
  map2.put(""String_Node_Str"",""String_Node_Str"");
  boolean b=h1.executeTransaction(new TransactionalTask<Boolean>(){
    public Boolean execute(    TransactionalTaskContext context) throws TransactionException {
      final TransactionalMap<Object,Object> txMap=context.getMap(""String_Node_Str"");
      txMap.put(""String_Node_Str"",""String_Node_Str"");
      map2.put(""String_Node_Str"",""String_Node_Str"");
      txMap.delete(""String_Node_Str"");
      map2.delete(""String_Node_Str"");
      assertEquals(""String_Node_Str"",map2.get(""String_Node_Str""));
      assertEquals(null,txMap.get(""String_Node_Str""));
      txMap.delete(""String_Node_Str"");
      return true;
    }
  }
);
  assertTrue(b);
  IMap map1=h1.getMap(""String_Node_Str"");
  assertEquals(null,map1.get(""String_Node_Str""));
  assertEquals(null,map2.get(""String_Node_Str""));
  assertEquals(null,map1.get(""String_Node_Str""));
  assertEquals(null,map2.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map1.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map2.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map1.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map2.get(""String_Node_Str""));
}","@Test public void testTxnDelete() throws TransactionException {
  Config config=new Config();
  final TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(2);
  final HazelcastInstance h1=factory.newHazelcastInstance(config);
  final HazelcastInstance h2=factory.newHazelcastInstance(config);
  final IMap map2=h2.getMap(""String_Node_Str"");
  map2.put(""String_Node_Str"",""String_Node_Str"");
  map2.put(""String_Node_Str"",""String_Node_Str"");
  boolean b=h1.executeTransaction(new TransactionalTask<Boolean>(){
    public Boolean execute(    TransactionalTaskContext context) throws TransactionException {
      final TransactionalMap<Object,Object> txMap=context.getMap(""String_Node_Str"");
      txMap.put(""String_Node_Str"",""String_Node_Str"");
      map2.put(""String_Node_Str"",""String_Node_Str"");
      txMap.delete(""String_Node_Str"");
      map2.delete(""String_Node_Str"");
      assertEquals(""String_Node_Str"",map2.get(""String_Node_Str""));
      assertEquals(null,txMap.get(""String_Node_Str""));
      txMap.delete(""String_Node_Str"");
      return true;
    }
  }
);
  assertTrue(b);
  IMap map1=h1.getMap(""String_Node_Str"");
  assertEquals(null,map1.get(""String_Node_Str""));
  assertEquals(null,map2.get(""String_Node_Str""));
  assertEquals(null,map1.get(""String_Node_Str""));
  assertEquals(null,map2.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map1.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map2.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map1.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map2.get(""String_Node_Str""));
}",0.9739185750636132
49263,"@Test public void testTxnBackupDies() throws TransactionException {
  Config config=new Config();
  StaticNodeFactory factory=new StaticNodeFactory(2);
  final HazelcastInstance h1=factory.newHazelcastInstance(config);
  final HazelcastInstance h2=factory.newHazelcastInstance(config);
  final IMap map1=h1.getMap(""String_Node_Str"");
  final int size=50;
  final CountDownLatch latch=new CountDownLatch(size + 1);
  Runnable runnable=new Runnable(){
    public void run(){
      try {
        boolean b=h1.executeTransaction(new TransactionOptions().setDurability(1),new TransactionalTask<Boolean>(){
          public Boolean execute(          TransactionalTaskContext context) throws TransactionException {
            final TransactionalMap<Object,Object> txMap=context.getMap(""String_Node_Str"");
            for (int i=0; i < size; i++) {
              txMap.put(i,i);
              try {
                Thread.sleep(100);
              }
 catch (              InterruptedException e) {
              }
              latch.countDown();
            }
            return true;
          }
        }
);
        fail();
      }
 catch (      Exception e) {
      }
      latch.countDown();
    }
  }
;
  new Thread(runnable).start();
  try {
    Thread.sleep(1000);
    h2.getLifecycleService().shutdown();
    latch.await();
    for (int i=0; i < size; i++) {
      assertNull(map1.get(i));
    }
  }
 catch (  InterruptedException e) {
  }
}","@Test public void testTxnBackupDies() throws TransactionException {
  Config config=new Config();
  final TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(2);
  final HazelcastInstance h1=factory.newHazelcastInstance(config);
  final HazelcastInstance h2=factory.newHazelcastInstance(config);
  final IMap map1=h1.getMap(""String_Node_Str"");
  final int size=50;
  final CountDownLatch latch=new CountDownLatch(size + 1);
  Runnable runnable=new Runnable(){
    public void run(){
      try {
        boolean b=h1.executeTransaction(new TransactionOptions().setDurability(1),new TransactionalTask<Boolean>(){
          public Boolean execute(          TransactionalTaskContext context) throws TransactionException {
            final TransactionalMap<Object,Object> txMap=context.getMap(""String_Node_Str"");
            for (int i=0; i < size; i++) {
              txMap.put(i,i);
              try {
                Thread.sleep(100);
              }
 catch (              InterruptedException e) {
              }
              latch.countDown();
            }
            return true;
          }
        }
);
        fail();
      }
 catch (      Exception e) {
      }
      latch.countDown();
    }
  }
;
  new Thread(runnable).start();
  try {
    Thread.sleep(1000);
    h2.getLifecycleService().shutdown();
    latch.await();
    for (int i=0; i < size; i++) {
      assertNull(map1.get(i));
    }
  }
 catch (  InterruptedException e) {
  }
}",0.9759615384615384
49264,"@Test public void testTxnPutIfAbsent() throws TransactionException {
  Config config=new Config();
  StaticNodeFactory factory=new StaticNodeFactory(2);
  HazelcastInstance h1=factory.newHazelcastInstance(config);
  HazelcastInstance h2=factory.newHazelcastInstance(config);
  final IMap map2=h2.getMap(""String_Node_Str"");
  boolean b=h1.executeTransaction(new TransactionalTask<Boolean>(){
    public Boolean execute(    TransactionalTaskContext context) throws TransactionException {
      final TransactionalMap<Object,Object> txMap=context.getMap(""String_Node_Str"");
      txMap.putIfAbsent(""String_Node_Str"",""String_Node_Str"");
      assertEquals(""String_Node_Str"",txMap.putIfAbsent(""String_Node_Str"",""String_Node_Str""));
      assertEquals(""String_Node_Str"",txMap.get(""String_Node_Str""));
      assertNull(map2.get(""String_Node_Str""));
      assertNull(map2.get(""String_Node_Str""));
      return true;
    }
  }
);
  assertTrue(b);
  IMap map1=h1.getMap(""String_Node_Str"");
  assertEquals(""String_Node_Str"",map1.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map2.get(""String_Node_Str""));
}","@Test public void testTxnPutIfAbsent() throws TransactionException {
  Config config=new Config();
  final TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(2);
  final HazelcastInstance h1=factory.newHazelcastInstance(config);
  final HazelcastInstance h2=factory.newHazelcastInstance(config);
  final IMap map2=h2.getMap(""String_Node_Str"");
  boolean b=h1.executeTransaction(new TransactionalTask<Boolean>(){
    public Boolean execute(    TransactionalTaskContext context) throws TransactionException {
      final TransactionalMap<Object,Object> txMap=context.getMap(""String_Node_Str"");
      txMap.putIfAbsent(""String_Node_Str"",""String_Node_Str"");
      assertEquals(""String_Node_Str"",txMap.putIfAbsent(""String_Node_Str"",""String_Node_Str""));
      assertEquals(""String_Node_Str"",txMap.get(""String_Node_Str""));
      assertNull(map2.get(""String_Node_Str""));
      assertNull(map2.get(""String_Node_Str""));
      return true;
    }
  }
);
  assertTrue(b);
  IMap map1=h1.getMap(""String_Node_Str"");
  assertEquals(""String_Node_Str"",map1.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map2.get(""String_Node_Str""));
}",0.9635879218472468
49265,"@Test public void testTxnReplace() throws TransactionException {
  Config config=new Config();
  StaticNodeFactory factory=new StaticNodeFactory(2);
  HazelcastInstance h1=factory.newHazelcastInstance(config);
  HazelcastInstance h2=factory.newHazelcastInstance(config);
  final IMap map2=h2.getMap(""String_Node_Str"");
  boolean b=h1.executeTransaction(new TransactionOptions().setTimeout(1,TimeUnit.SECONDS),new TransactionalTask<Boolean>(){
    public Boolean execute(    TransactionalTaskContext context) throws TransactionException {
      final TransactionalMap<Object,Object> txMap=context.getMap(""String_Node_Str"");
      assertNull(txMap.replace(""String_Node_Str"",""String_Node_Str""));
      txMap.put(""String_Node_Str"",""String_Node_Str"");
      assertEquals(""String_Node_Str"",txMap.replace(""String_Node_Str"",""String_Node_Str""));
      assertEquals(""String_Node_Str"",txMap.get(""String_Node_Str""));
      assertNull(map2.get(""String_Node_Str""));
      assertNull(map2.get(""String_Node_Str""));
      return true;
    }
  }
);
  assertTrue(b);
  IMap map1=h1.getMap(""String_Node_Str"");
  assertEquals(""String_Node_Str"",map1.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map2.get(""String_Node_Str""));
}","@Test public void testTxnReplace() throws TransactionException {
  Config config=new Config();
  final TestHazelcastInstanceFactory factory=createHazelcastInstanceFactory(2);
  final HazelcastInstance h1=factory.newHazelcastInstance(config);
  final HazelcastInstance h2=factory.newHazelcastInstance(config);
  final IMap map2=h2.getMap(""String_Node_Str"");
  boolean b=h1.executeTransaction(new TransactionOptions().setTimeout(1,TimeUnit.SECONDS),new TransactionalTask<Boolean>(){
    public Boolean execute(    TransactionalTaskContext context) throws TransactionException {
      final TransactionalMap<Object,Object> txMap=context.getMap(""String_Node_Str"");
      assertNull(txMap.replace(""String_Node_Str"",""String_Node_Str""));
      txMap.put(""String_Node_Str"",""String_Node_Str"");
      assertEquals(""String_Node_Str"",txMap.replace(""String_Node_Str"",""String_Node_Str""));
      assertEquals(""String_Node_Str"",txMap.get(""String_Node_Str""));
      assertNull(map2.get(""String_Node_Str""));
      assertNull(map2.get(""String_Node_Str""));
      return true;
    }
  }
);
  assertTrue(b);
  IMap map1=h1.getMap(""String_Node_Str"");
  assertEquals(""String_Node_Str"",map1.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map2.get(""String_Node_Str""));
}",0.9668284789644012
49266,"public final int getAsyncBackupCount(){
  return getLockStore().getAsyncBackupCount();
}","public final int getAsyncBackupCount(){
  final LockStoreImpl lockStore=getLockStore();
  return !asyncBackup ? lockStore.getAsyncBackupCount() : lockStore.getBackupCount() + lockStore.getAsyncBackupCount();
}",0.5117845117845118
49267,"public final int getSyncBackupCount(){
  return getLockStore().getBackupCount();
}","public final int getSyncBackupCount(){
  return !asyncBackup ? getLockStore().getBackupCount() : 0;
}",0.8961748633879781
49268,"private void releaseLocksOf(final String uuid){
  for (  LockStoreContainer container : containers) {
    for (    LockStoreImpl lockStore : container.getLockStores()) {
      Map<Data,DistributedLock> locks=lockStore.getLocks();
      for (      Map.Entry<Data,DistributedLock> entry : locks.entrySet()) {
        final Data key=entry.getKey();
        final DistributedLock lock=entry.getValue();
        if (uuid.equals(lock.getOwner()) && !lock.isTransactional()) {
          UnlockOperation op=new UnlockOperation(lockStore.getNamespace(),key,-1,true);
          op.setNodeEngine(nodeEngine);
          op.setServiceName(SERVICE_NAME);
          op.setService(LockService.this);
          op.setResponseHandler(ResponseHandlerFactory.createEmptyResponseHandler());
          op.setPartitionId(container.getPartitionId());
          nodeEngine.getOperationService().executeOperation(op);
        }
      }
    }
  }
}","private void releaseLocksOf(final String uuid){
  for (  LockStoreContainer container : containers) {
    for (    LockStoreImpl lockStore : container.getLockStores()) {
      Map<Data,DistributedLock> locks=lockStore.getLocks();
      for (      Map.Entry<Data,DistributedLock> entry : locks.entrySet()) {
        final Data key=entry.getKey();
        final DistributedLock lock=entry.getValue();
        if (uuid.equals(lock.getOwner()) && !lock.isTransactional()) {
          UnlockOperation op=new UnlockOperation(lockStore.getNamespace(),key,-1,true);
          op.setAsyncBackup(true);
          op.setNodeEngine(nodeEngine);
          op.setServiceName(SERVICE_NAME);
          op.setService(LockService.this);
          op.setResponseHandler(ResponseHandlerFactory.createEmptyResponseHandler());
          op.setPartitionId(container.getPartitionId());
          nodeEngine.getOperationService().executeOperation(op);
        }
      }
    }
  }
}",0.9813532232285562
49269,"public boolean containsKey(Data dataKey){
  Record record=records.get(dataKey);
  if (record == null) {
    if (mapContainer.getStore() != null) {
      Object value=mapContainer.getStore().load(mapService.toObject(dataKey));
      if (value != null) {
        record=mapService.createRecord(name,dataKey,value,-1);
        records.put(dataKey,record);
      }
      if (value == null) {
        record=mapService.createRecord(name,dataKey,null,100);
        records.put(dataKey,record);
      }
    }
  }
  return record != null;
}","public boolean containsKey(Data dataKey){
  Record record=records.get(dataKey);
  if (record == null) {
    if (mapContainer.getStore() != null) {
      Object value=mapContainer.getStore().load(mapService.toObject(dataKey));
      if (value != null) {
        record=mapService.createRecord(name,dataKey,value,-1);
        records.put(dataKey,record);
      }
    }
  }
  return record != null && record.getValue() != null;
}",0.7682672233820459
49270,"public boolean replaceIfSameInternal(Data key,Object oldValue,Data newValue){
  VersionedValue versionedValue=lockAndGet(key,tx.getTimeoutMillis());
  if (versionedValue == null) {
    throw new ConcurrentModificationException(""String_Node_Str"" + ThreadUtil.getThreadId());
  }
  if (!getService().compare(name,oldValue,versionedValue.value))   return false;
  tx.addTransactionLog(new MapTransactionLog(name,key,new TxnSetOperation(name,key,newValue,-1,versionedValue.version),versionedValue.version));
  return true;
}","public boolean replaceIfSameInternal(Data key,Object oldValue,Data newValue){
  VersionedValue versionedValue=lockAndGet(key,tx.getTimeoutMillis());
  if (versionedValue == null) {
    throw new TransactionException(""String_Node_Str"" + ThreadUtil.getThreadId());
  }
  if (!getService().compare(name,oldValue,versionedValue.value))   return false;
  tx.addTransactionLog(new MapTransactionLog(name,key,new TxnSetOperation(name,key,newValue,-1,versionedValue.version),versionedValue.version));
  return true;
}",0.9757045675413022
49271,"public boolean removeIfSameInternal(Data key,Object value){
  VersionedValue versionedValue=lockAndGet(key,tx.getTimeoutMillis());
  if (versionedValue == null) {
    throw new ConcurrentModificationException(""String_Node_Str"" + ThreadUtil.getThreadId());
  }
  if (!getService().compare(name,versionedValue.value,value)) {
    return false;
  }
  tx.addTransactionLog(new MapTransactionLog(name,key,new TxnDeleteOperation(name,key,versionedValue.version),versionedValue.version));
  return true;
}","public boolean removeIfSameInternal(Data key,Object value){
  VersionedValue versionedValue=lockAndGet(key,tx.getTimeoutMillis());
  if (versionedValue == null) {
    throw new TransactionException(""String_Node_Str"" + ThreadUtil.getThreadId());
  }
  if (!getService().compare(name,versionedValue.value,value)) {
    return false;
  }
  tx.addTransactionLog(new MapTransactionLog(name,key,new TxnDeleteOperation(name,key,versionedValue.version),versionedValue.version));
  return true;
}",0.9746192893401016
49272,"public void setInternal(Data key,Data value){
  VersionedValue versionedValue=lockAndGet(key,tx.getTimeoutMillis());
  if (versionedValue == null) {
    throw new ConcurrentModificationException(""String_Node_Str"" + ThreadUtil.getThreadId());
  }
  tx.addTransactionLog(new MapTransactionLog(name,key,new TxnSetOperation(name,key,value,-1,versionedValue.version),versionedValue.version));
}","public void setInternal(Data key,Data value){
  VersionedValue versionedValue=lockAndGet(key,tx.getTimeoutMillis());
  if (versionedValue == null) {
    throw new TransactionException(""String_Node_Str"" + ThreadUtil.getThreadId());
  }
  tx.addTransactionLog(new MapTransactionLog(name,key,new TxnSetOperation(name,key,value,-1,versionedValue.version),versionedValue.version));
}",0.967405475880052
49273,"public Data replaceInternal(Data key,Data value){
  VersionedValue versionedValue=lockAndGet(key,tx.getTimeoutMillis());
  if (versionedValue == null) {
    throw new ConcurrentModificationException(""String_Node_Str"" + ThreadUtil.getThreadId());
  }
  if (versionedValue.value == null)   return null;
  tx.addTransactionLog(new MapTransactionLog(name,key,new TxnSetOperation(name,key,value,-1,versionedValue.version),versionedValue.version));
  return versionedValue.value;
}","public Data replaceInternal(Data key,Data value){
  VersionedValue versionedValue=lockAndGet(key,tx.getTimeoutMillis());
  if (versionedValue == null) {
    throw new TransactionException(""String_Node_Str"" + ThreadUtil.getThreadId());
  }
  if (versionedValue.value == null)   return null;
  tx.addTransactionLog(new MapTransactionLog(name,key,new TxnSetOperation(name,key,value,-1,versionedValue.version),versionedValue.version));
  return versionedValue.value;
}",0.9733759318423856
49274,"public Data putInternal(Data key,Data value){
  VersionedValue versionedValue=lockAndGet(key,tx.getTimeoutMillis());
  if (versionedValue == null) {
    throw new ConcurrentModificationException(""String_Node_Str"" + ThreadUtil.getThreadId());
  }
  tx.addTransactionLog(new MapTransactionLog(name,key,new TxnSetOperation(name,key,value,-1,versionedValue.version),versionedValue.version));
  return versionedValue.value;
}","public Data putInternal(Data key,Data value){
  VersionedValue versionedValue=lockAndGet(key,tx.getTimeoutMillis());
  if (versionedValue == null) {
    throw new TransactionException(""String_Node_Str"" + ThreadUtil.getThreadId());
  }
  tx.addTransactionLog(new MapTransactionLog(name,key,new TxnSetOperation(name,key,value,-1,versionedValue.version),versionedValue.version));
  return versionedValue.value;
}",0.9698431845597104
49275,"public Data removeInternal(Data key){
  VersionedValue versionedValue=lockAndGet(key,tx.getTimeoutMillis());
  if (versionedValue == null) {
    throw new ConcurrentModificationException(""String_Node_Str"" + ThreadUtil.getThreadId());
  }
  tx.addTransactionLog(new MapTransactionLog(name,key,new TxnDeleteOperation(name,key,versionedValue.version),versionedValue.version));
  return versionedValue.value;
}","public Data removeInternal(Data key){
  VersionedValue versionedValue=lockAndGet(key,tx.getTimeoutMillis());
  if (versionedValue == null) {
    throw new TransactionException(""String_Node_Str"" + ThreadUtil.getThreadId());
  }
  tx.addTransactionLog(new MapTransactionLog(name,key,new TxnDeleteOperation(name,key,versionedValue.version),versionedValue.version));
  return versionedValue.value;
}",0.968789013732834
49276,"public Data putIfAbsentInternal(Data key,Data value){
  VersionedValue versionedValue=lockAndGet(key,tx.getTimeoutMillis());
  if (versionedValue == null) {
    throw new ConcurrentModificationException(""String_Node_Str"" + ThreadUtil.getThreadId());
  }
  if (versionedValue.value != null)   return versionedValue.value;
  tx.addTransactionLog(new MapTransactionLog(name,key,new TxnSetOperation(name,key,value,-1,versionedValue.version),versionedValue.version));
  return versionedValue.value;
}","public Data putIfAbsentInternal(Data key,Data value){
  VersionedValue versionedValue=lockAndGet(key,tx.getTimeoutMillis());
  if (versionedValue == null) {
    throw new TransactionException(""String_Node_Str"" + ThreadUtil.getThreadId());
  }
  if (versionedValue.value != null)   return versionedValue.value;
  tx.addTransactionLog(new MapTransactionLog(name,key,new TxnSetOperation(name,key,value,-1,versionedValue.version),versionedValue.version));
  return versionedValue.value;
}",0.9744637385086824
49277,"Backup(Operation backupOp,Address originalCaller,long[] replicaVersions,boolean sync){
  this.backupOp=backupOp;
  this.originalCaller=originalCaller;
  this.sync=sync;
  this.replicaVersions=replicaVersions;
  if (sync && originalCaller == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}","Backup(Operation backupOp,Address originalCaller,long[] replicaVersions,boolean sync){
  this.backupOp=backupOp;
  this.originalCaller=originalCaller;
  this.sync=sync;
  this.replicaVersions=replicaVersions;
  if (sync && originalCaller == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + backupOp);
  }
}",0.9528158295281582
49278,"@Test public void testLock() throws Exception {
  Config config=new Config();
  final String name=""String_Node_Str"";
  config.getMultiMapConfig(name).setValueCollectionType(MultiMapConfig.ValueCollectionType.LIST);
  final int insCount=4;
  final HazelcastInstance[] instances=StaticNodeFactory.newInstances(config,insCount);
  final CountDownLatch latch=new CountDownLatch(1);
  new Thread(){
    public void run(){
      instances[0].getMultiMap(name).lock(""String_Node_Str"");
      latch.countDown();
      try {
        Thread.sleep(5 * 1000);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
      instances[0].getMultiMap(name).unlock(""String_Node_Str"");
    }
  }
.start();
  assertTrue(latch.await(10,TimeUnit.SECONDS));
  assertFalse(getMultiMap(instances,name).tryLock(""String_Node_Str""));
  assertTrue(instances[0].getMultiMap(name).tryLock(""String_Node_Str"",20,TimeUnit.SECONDS));
  new Thread(){
    public void run(){
      try {
        Thread.sleep(3000);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
      instances[0].getLifecycleService().shutdown();
    }
  }
.start();
  assertTrue(instances[1].getMultiMap(name).tryLock(""String_Node_Str"",20,TimeUnit.SECONDS));
}","@Test public void testLock() throws Exception {
  Config config=new Config();
  final String name=""String_Node_Str"";
  config.getMultiMapConfig(name).setValueCollectionType(MultiMapConfig.ValueCollectionType.LIST);
  final int insCount=4;
  final HazelcastInstance[] instances=StaticNodeFactory.newInstances(config,insCount);
  final CountDownLatch latch=new CountDownLatch(1);
  final CountDownLatch latch2=new CountDownLatch(1);
  new Thread(){
    public void run(){
      instances[0].getMultiMap(name).lock(""String_Node_Str"");
      latch.countDown();
      try {
        latch2.await(10,TimeUnit.SECONDS);
        instances[0].getMultiMap(name).unlock(""String_Node_Str"");
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
  }
.start();
  assertTrue(latch.await(10,TimeUnit.SECONDS));
  assertFalse(getMultiMap(instances,name).tryLock(""String_Node_Str""));
  latch2.countDown();
  assertTrue(instances[0].getMultiMap(name).tryLock(""String_Node_Str"",20,TimeUnit.SECONDS));
  new Thread(){
    public void run(){
      try {
        Thread.sleep(3000);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
      instances[0].getLifecycleService().shutdown();
    }
  }
.start();
  assertTrue(instances[1].getMultiMap(name).tryLock(""String_Node_Str"",20,TimeUnit.SECONDS));
}",0.8849693251533742
49279,"@Test public void testLockConditionSignalAllShutDownKeyOwner() throws InterruptedException {
  final StaticNodeFactory nodeFactory=new StaticNodeFactory(2);
  final Config config=new Config();
  final String name=""String_Node_Str"";
  final HazelcastInstance instance=nodeFactory.newHazelcastInstance(config);
  final AtomicInteger count=new AtomicInteger(0);
  final int size=50;
  int k=0;
  final HazelcastInstance keyOwner=nodeFactory.newHazelcastInstance(config);
  while (!keyOwner.getCluster().getLocalMember().equals(instance.getPartitionService().getPartition(++k).getOwner()))   ;
  final ILock lock=instance.getLock(k);
  final ICondition condition=lock.newCondition(name);
  final CountDownLatch awaitLatch=new CountDownLatch(size);
  final CountDownLatch finalLatch=new CountDownLatch(size);
  for (int i=0; i < size; i++) {
    new Thread(new Runnable(){
      public void run(){
        try {
          lock.lock();
          if (lock.isLocked() && lock.tryLock()) {
            count.incrementAndGet();
            lock.unlock();
          }
          awaitLatch.countDown();
          condition.await();
          Thread.sleep(5);
          if (lock.isLocked() && lock.tryLock()) {
            count.incrementAndGet();
            lock.unlock();
          }
        }
 catch (        InterruptedException e) {
          return;
        }
 finally {
          lock.unlock();
          finalLatch.countDown();
        }
      }
    }
).start();
  }
  final ILock lock1=keyOwner.getLock(k);
  final ICondition condition1=lock1.newCondition(name);
  awaitLatch.await(1,TimeUnit.MINUTES);
  lock1.lock();
  condition1.signalAll();
  lock1.unlock();
  keyOwner.getLifecycleService().shutdown();
  finalLatch.await(1,TimeUnit.MINUTES);
  Assert.assertEquals(size * 2,count.get());
}","@Test public void testLockConditionSignalAllShutDownKeyOwner() throws InterruptedException {
  final StaticNodeFactory nodeFactory=new StaticNodeFactory(2);
  final Config config=new Config();
  final String name=""String_Node_Str"";
  final HazelcastInstance instance=nodeFactory.newHazelcastInstance(config);
  final AtomicInteger count=new AtomicInteger(0);
  final int size=50;
  int k=0;
  final HazelcastInstance keyOwner=nodeFactory.newHazelcastInstance(config);
  while (!keyOwner.getCluster().getLocalMember().equals(instance.getPartitionService().getPartition(++k).getOwner())) {
    Thread.sleep(1);
  }
  final ILock lock=instance.getLock(k);
  final ICondition condition=lock.newCondition(name);
  final CountDownLatch awaitLatch=new CountDownLatch(size);
  final CountDownLatch finalLatch=new CountDownLatch(size);
  for (int i=0; i < size; i++) {
    new Thread(new Runnable(){
      public void run(){
        lock.lock();
        try {
          awaitLatch.countDown();
          condition.await();
          Thread.sleep(5);
          if (lock.isLocked() && lock.tryLock()) {
            count.incrementAndGet();
            lock.unlock();
          }
        }
 catch (        InterruptedException ignored) {
        }
 finally {
          lock.unlock();
          finalLatch.countDown();
        }
      }
    }
).start();
  }
  final ILock lock1=keyOwner.getLock(k);
  final ICondition condition1=lock1.newCondition(name);
  awaitLatch.await(1,TimeUnit.MINUTES);
  lock1.lock();
  condition1.signalAll();
  lock1.unlock();
  keyOwner.getLifecycleService().shutdown();
  finalLatch.await(2,TimeUnit.MINUTES);
  Assert.assertEquals(size,count.get());
}",0.8884393063583815
49280,"@Test(timeout=100000) public void testLockEviction() throws Exception {
  final StaticNodeFactory nodeFactory=new StaticNodeFactory(2);
  final Config config=new Config();
  final AtomicInteger integer=new AtomicInteger(0);
  final HazelcastInstance lockOwner=nodeFactory.newHazelcastInstance(config);
  final HazelcastInstance instance1=nodeFactory.newHazelcastInstance(config);
  final String name=""String_Node_Str"";
  final ILock lock=lockOwner.getLock(name);
  lock.lock(1,TimeUnit.SECONDS);
  Assert.assertEquals(true,lock.isLocked());
  Thread t=new Thread(new Runnable(){
    public void run(){
      final ILock lock=instance1.getLock(name);
      lock.lock();
      integer.incrementAndGet();
    }
  }
);
  t.start();
  Assert.assertEquals(0,integer.get());
  Thread.sleep(2000);
  Assert.assertEquals(1,integer.get());
}","@Test(timeout=100000) public void testLockEviction() throws Exception {
  final StaticNodeFactory nodeFactory=new StaticNodeFactory(2);
  final Config config=new Config();
  final AtomicInteger integer=new AtomicInteger(0);
  final HazelcastInstance lockOwner=nodeFactory.newHazelcastInstance(config);
  final HazelcastInstance instance1=nodeFactory.newHazelcastInstance(config);
  final String name=""String_Node_Str"";
  final ILock lock=lockOwner.getLock(name);
  lock.lock(1,TimeUnit.SECONDS);
  Assert.assertTrue(lock.isLocked());
  final CountDownLatch latch=new CountDownLatch(1);
  Thread t=new Thread(new Runnable(){
    public void run(){
      final ILock lock=instance1.getLock(name);
      lock.lock();
      latch.countDown();
    }
  }
);
  t.start();
  Assert.assertTrue(latch.await(3,TimeUnit.SECONDS));
}",0.8067837674136886
49281,"@Test(timeout=100000) public void testKeyOwnerDies() throws Exception {
  final StaticNodeFactory nodeFactory=new StaticNodeFactory(3);
  final Config config=new Config();
  final HazelcastInstance keyOwner=nodeFactory.newHazelcastInstance(config);
  final HazelcastInstance instance1=nodeFactory.newHazelcastInstance(config);
  final HazelcastInstance instance2=nodeFactory.newHazelcastInstance(config);
  int k=0;
  final AtomicInteger atomicInteger=new AtomicInteger(0);
  while (!keyOwner.getCluster().getLocalMember().equals(instance1.getPartitionService().getPartition(++k).getOwner()))   ;
  final int key=k;
  final ILock lock1=instance1.getLock(key);
  lock1.lock();
  Thread t=new Thread(new Runnable(){
    public void run(){
      final ILock lock=instance2.getLock(key);
      lock.lock();
      atomicInteger.incrementAndGet();
    }
  }
);
  t.start();
  keyOwner.getLifecycleService().shutdown();
  Assert.assertEquals(true,lock1.isLocked());
  Assert.assertEquals(true,lock1.tryLock());
  lock1.unlock();
  lock1.unlock();
  Thread.sleep(1000);
  Assert.assertEquals(1,atomicInteger.get());
  lock1.forceUnlock();
}","@Test(timeout=100000) public void testKeyOwnerDies() throws Exception {
  final StaticNodeFactory nodeFactory=new StaticNodeFactory(3);
  final Config config=new Config();
  final HazelcastInstance keyOwner=nodeFactory.newHazelcastInstance(config);
  final HazelcastInstance instance1=nodeFactory.newHazelcastInstance(config);
  final HazelcastInstance instance2=nodeFactory.newHazelcastInstance(config);
  int k=0;
  final Member localMember=keyOwner.getCluster().getLocalMember();
  while (!localMember.equals(instance1.getPartitionService().getPartition(++k).getOwner())) {
    Thread.sleep(1);
  }
  final int key=k;
  final ILock lock1=instance1.getLock(key);
  lock1.lock();
  final CountDownLatch latch=new CountDownLatch(1);
  new Thread(new Runnable(){
    public void run(){
      final ILock lock=instance2.getLock(key);
      lock.lock();
      latch.countDown();
    }
  }
).start();
  keyOwner.getLifecycleService().shutdown();
  Assert.assertTrue(lock1.isLocked());
  Assert.assertTrue(lock1.tryLock());
  lock1.unlock();
  lock1.unlock();
  Assert.assertTrue(latch.await(5,TimeUnit.SECONDS));
}",0.6271186440677966
49282,"@Test public void testSingleNode(){
  final int k=1;
  final Config config=new Config();
  final HazelcastInstance[] instances=StaticNodeFactory.newInstances(config,k);
  ISemaphore semaphore=instances[0].getSemaphore(""String_Node_Str"");
  int numberOfPermits=20;
  Assert.assertTrue(semaphore.init(numberOfPermits));
  try {
    for (int i=0; i < numberOfPermits; i++) {
      Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
      semaphore.acquire();
    }
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
  for (int i=0; i < numberOfPermits; i++) {
    Assert.assertEquals(i,semaphore.availablePermits());
    semaphore.release();
  }
  Assert.assertTrue(semaphore.init(numberOfPermits));
  try {
    for (int i=0; i < numberOfPermits; i+=5) {
      Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
      semaphore.acquire(5);
    }
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
  for (int i=0; i < numberOfPermits; i+=5) {
    Assert.assertEquals(i,semaphore.availablePermits());
    semaphore.release(5);
  }
  Assert.assertTrue(semaphore.init(numberOfPermits));
  try {
    semaphore.acquire(5);
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  int drainedPermits=semaphore.drainPermits();
  Assert.assertEquals(drainedPermits,numberOfPermits - 5);
  Assert.assertEquals(semaphore.availablePermits(),0);
  Assert.assertTrue(semaphore.init(numberOfPermits));
  for (int i=0; i < numberOfPermits; i+=5) {
    Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
    semaphore.reducePermits(5);
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
  Assert.assertTrue(semaphore.init(numberOfPermits));
  for (int i=0; i < numberOfPermits; i++) {
    Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
    Assert.assertEquals(semaphore.tryAcquire(),true);
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
  Assert.assertTrue(semaphore.init(numberOfPermits));
  for (int i=0; i < numberOfPermits; i+=5) {
    Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
    Assert.assertEquals(semaphore.tryAcquire(5),true);
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
}","@Test public void testSingleNode(){
  final int k=1;
  final Config config=new Config();
  final HazelcastInstance[] instances=StaticNodeFactory.newInstances(config,k);
  ISemaphore semaphore=instances[0].getSemaphore(""String_Node_Str"");
  int numberOfPermits=20;
  Assert.assertTrue(semaphore.init(numberOfPermits));
  try {
    for (int i=0; i < numberOfPermits; i++) {
      Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
      semaphore.acquire();
    }
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
  for (int i=0; i < numberOfPermits; i++) {
    Assert.assertEquals(i,semaphore.availablePermits());
    semaphore.release();
  }
  Assert.assertEquals(semaphore.availablePermits(),numberOfPermits);
  Assert.assertFalse(semaphore.init(numberOfPermits));
  try {
    for (int i=0; i < numberOfPermits; i+=5) {
      Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
      semaphore.acquire(5);
    }
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
  for (int i=0; i < numberOfPermits; i+=5) {
    Assert.assertEquals(i,semaphore.availablePermits());
    semaphore.release(5);
  }
  Assert.assertEquals(semaphore.availablePermits(),numberOfPermits);
  Assert.assertFalse(semaphore.init(numberOfPermits));
  try {
    semaphore.acquire(5);
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  int drainedPermits=semaphore.drainPermits();
  Assert.assertEquals(drainedPermits,numberOfPermits - 5);
  Assert.assertEquals(semaphore.availablePermits(),0);
  Assert.assertTrue(semaphore.init(numberOfPermits));
  for (int i=0; i < numberOfPermits; i+=5) {
    Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
    semaphore.reducePermits(5);
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
  Assert.assertTrue(semaphore.init(numberOfPermits));
  for (int i=0; i < numberOfPermits; i++) {
    Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
    Assert.assertEquals(semaphore.tryAcquire(),true);
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
  Assert.assertTrue(semaphore.init(numberOfPermits));
  for (int i=0; i < numberOfPermits; i+=5) {
    Assert.assertEquals(numberOfPermits - i,semaphore.availablePermits());
    Assert.assertEquals(semaphore.tryAcquire(5),true);
  }
  Assert.assertEquals(semaphore.availablePermits(),0);
}",0.9688524590163936
49283,IPartitionService getPartitionService();,PartitionService getPartitionService();,0.9873417721518988
49284,"public IPartitionService getPartitionService(){
  return nodeEngine.getPartitionService();
}","public PartitionService getPartitionService(){
  return nodeEngine.getPartitionService();
}",0.994535519125683
49285,"public LocalMapStatsImpl createLocalMapStats(String mapName){
  MapContainer mapContainer=getMapContainer(mapName);
  LocalMapStatsImpl localMapStats=getLocalMapStatsImpl(mapName);
  if (!mapContainer.getMapConfig().isStatisticsEnabled()) {
    return localMapStats;
  }
  long ownedEntryCount=0;
  long backupEntryCount=0;
  long dirtyCount=0;
  long ownedEntryMemoryCost=0;
  long backupEntryMemoryCost=0;
  long hits=0;
  long lockedEntryCount=0;
  int backupCount=mapContainer.getTotalBackupCount();
  ClusterService clusterService=nodeEngine.getClusterService();
  final IPartitionService partitionService=nodeEngine.getPartitionService();
  Address thisAddress=clusterService.getThisAddress();
  for (int partition=0; partition < partitionService.getPartitionCount(); partition++) {
    PartitionInfo partitionInfo=partitionService.getPartitionInfo(partition);
    if (partitionInfo.getOwner().equals(thisAddress)) {
      PartitionContainer partitionContainer=getPartitionContainer(partition);
      RecordStore recordStore=partitionContainer.getRecordStore(mapName);
      Map<Data,Record> records=recordStore.getRecords();
      for (      Record record : records.values()) {
        RecordStatistics stats=record.getStatistics();
        ownedEntryCount++;
        ownedEntryMemoryCost+=record.getCost();
        localMapStats.setLastAccessTime(stats.getLastAccessTime());
        hits+=stats.getHits();
        if (recordStore.isLocked(record.getKey())) {
          lockedEntryCount++;
        }
      }
    }
 else {
      for (int replica=1; replica <= backupCount; replica++) {
        Address replicaAddress=partitionInfo.getReplicaAddress(replica);
        int tryCount=30;
        while (replicaAddress == null && clusterService.getSize() > backupCount && tryCount-- > 0) {
          try {
            Thread.sleep(100);
          }
 catch (          InterruptedException e) {
            throw ExceptionUtil.rethrow(e);
          }
          replicaAddress=partitionInfo.getReplicaAddress(replica);
        }
        if (replicaAddress != null && replicaAddress.equals(thisAddress)) {
          PartitionContainer partitionContainer=getPartitionContainer(partition);
          RecordStore recordStore=partitionContainer.getRecordStore(mapName);
          Map<Data,Record> records=recordStore.getRecords();
          for (          Record record : records.values()) {
            backupEntryCount++;
            backupEntryMemoryCost+=record.getCost();
          }
        }
 else         if (replicaAddress == null && clusterService.getSize() > backupCount) {
          logger.log(Level.WARNING,""String_Node_Str"" + partition + ""String_Node_Str""+ replica+ ""String_Node_Str"");
        }
      }
    }
  }
  if (mapContainer.getMapStoreWriteScheduler() != null && mapContainer.getMapStoreDeleteScheduler() != null) {
    dirtyCount=mapContainer.getMapStoreWriteScheduler().size() + mapContainer.getMapStoreDeleteScheduler().size();
  }
  localMapStats.setDirtyEntryCount(zeroOrPositive(dirtyCount));
  localMapStats.setLockedEntryCount(zeroOrPositive(lockedEntryCount));
  localMapStats.setHits(zeroOrPositive(hits));
  localMapStats.setOwnedEntryCount(zeroOrPositive(ownedEntryCount));
  localMapStats.setBackupEntryCount(zeroOrPositive(backupEntryCount));
  localMapStats.setOwnedEntryMemoryCost(zeroOrPositive(ownedEntryMemoryCost));
  localMapStats.setBackupEntryMemoryCost(zeroOrPositive(backupEntryMemoryCost));
  return localMapStats;
}","public LocalMapStatsImpl createLocalMapStats(String mapName){
  MapContainer mapContainer=getMapContainer(mapName);
  LocalMapStatsImpl localMapStats=getLocalMapStatsImpl(mapName);
  if (!mapContainer.getMapConfig().isStatisticsEnabled()) {
    return localMapStats;
  }
  long ownedEntryCount=0;
  long backupEntryCount=0;
  long dirtyCount=0;
  long ownedEntryMemoryCost=0;
  long backupEntryMemoryCost=0;
  long hits=0;
  long lockedEntryCount=0;
  int backupCount=mapContainer.getTotalBackupCount();
  ClusterService clusterService=nodeEngine.getClusterService();
  final com.hazelcast.partition.PartitionService partitionService=nodeEngine.getPartitionService();
  Address thisAddress=clusterService.getThisAddress();
  for (int partition=0; partition < partitionService.getPartitionCount(); partition++) {
    PartitionInfo partitionInfo=partitionService.getPartitionInfo(partition);
    if (partitionInfo.getOwner().equals(thisAddress)) {
      PartitionContainer partitionContainer=getPartitionContainer(partition);
      RecordStore recordStore=partitionContainer.getRecordStore(mapName);
      Map<Data,Record> records=recordStore.getRecords();
      for (      Record record : records.values()) {
        RecordStatistics stats=record.getStatistics();
        ownedEntryCount++;
        ownedEntryMemoryCost+=record.getCost();
        localMapStats.setLastAccessTime(stats.getLastAccessTime());
        hits+=stats.getHits();
        if (recordStore.isLocked(record.getKey())) {
          lockedEntryCount++;
        }
      }
    }
 else {
      for (int replica=1; replica <= backupCount; replica++) {
        Address replicaAddress=partitionInfo.getReplicaAddress(replica);
        int tryCount=30;
        while (replicaAddress == null && clusterService.getSize() > backupCount && tryCount-- > 0) {
          try {
            Thread.sleep(100);
          }
 catch (          InterruptedException e) {
            throw ExceptionUtil.rethrow(e);
          }
          replicaAddress=partitionInfo.getReplicaAddress(replica);
        }
        if (replicaAddress != null && replicaAddress.equals(thisAddress)) {
          PartitionContainer partitionContainer=getPartitionContainer(partition);
          RecordStore recordStore=partitionContainer.getRecordStore(mapName);
          Map<Data,Record> records=recordStore.getRecords();
          for (          Record record : records.values()) {
            backupEntryCount++;
            backupEntryMemoryCost+=record.getCost();
          }
        }
 else         if (replicaAddress == null && clusterService.getSize() > backupCount) {
          logger.log(Level.WARNING,""String_Node_Str"" + partition + ""String_Node_Str""+ replica+ ""String_Node_Str"");
        }
      }
    }
  }
  if (mapContainer.getMapStoreWriteScheduler() != null && mapContainer.getMapStoreDeleteScheduler() != null) {
    dirtyCount=mapContainer.getMapStoreWriteScheduler().size() + mapContainer.getMapStoreDeleteScheduler().size();
  }
  localMapStats.setDirtyEntryCount(zeroOrPositive(dirtyCount));
  localMapStats.setLockedEntryCount(zeroOrPositive(lockedEntryCount));
  localMapStats.setHits(zeroOrPositive(hits));
  localMapStats.setOwnedEntryCount(zeroOrPositive(ownedEntryCount));
  localMapStats.setBackupEntryCount(zeroOrPositive(backupEntryCount));
  localMapStats.setOwnedEntryMemoryCost(zeroOrPositive(ownedEntryMemoryCost));
  localMapStats.setBackupEntryMemoryCost(zeroOrPositive(backupEntryMemoryCost));
  return localMapStats;
}",0.9963971753855022
49286,"public ClassDefinitionBuilder addByteArrayField(String fieldName){
  check();
  cd.add(new FieldDefinitionImpl(index++,fieldName,FieldType.BYTE_ARRAY));
  return this;
}","public ClassDefinitionBuilder addByteArrayField(String fieldName){
  check();
  fieldDefinitions.add(new FieldDefinitionImpl(index++,fieldName,FieldType.BYTE_ARRAY));
  return this;
}",0.9545454545454546
49287,"public ClassDefinitionBuilder addPortableField(String fieldName,int factoryId,int classId){
  check();
  if (classId == Data.NO_CLASS_ID) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  cd.add(new FieldDefinitionImpl(index++,fieldName,FieldType.PORTABLE,factoryId,classId));
  return this;
}","public ClassDefinitionBuilder addPortableField(String fieldName,ClassDefinition def){
  check();
  if (def.getClassId() == Data.NO_CLASS_ID) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  fieldDefinitions.add(new FieldDefinitionImpl(index++,fieldName,FieldType.PORTABLE,def.getFactoryId(),def.getClassId()));
  nestedClassDefinitions.add(def);
  return this;
}",0.7710144927536232
49288,"public ClassDefinitionBuilder addPortableArrayField(String fieldName,int factoryId,int classId){
  check();
  if (classId == Data.NO_CLASS_ID) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  cd.add(new FieldDefinitionImpl(index++,fieldName,FieldType.PORTABLE_ARRAY,factoryId,classId));
  return this;
}","public ClassDefinitionBuilder addPortableArrayField(String fieldName,ClassDefinition def){
  check();
  if (def.getClassId() == Data.NO_CLASS_ID) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  fieldDefinitions.add(new FieldDefinitionImpl(index++,fieldName,FieldType.PORTABLE_ARRAY,def.getFactoryId(),def.getClassId()));
  nestedClassDefinitions.add(def);
  return this;
}",0.7780898876404494
49289,"public ClassDefinitionBuilder addBooleanField(String fieldName){
  check();
  cd.add(new FieldDefinitionImpl(index++,fieldName,FieldType.BOOLEAN));
  return this;
}","public ClassDefinitionBuilder addBooleanField(String fieldName){
  check();
  fieldDefinitions.add(new FieldDefinitionImpl(index++,fieldName,FieldType.BOOLEAN));
  return this;
}",0.953216374269006
49290,"public ClassDefinitionBuilder addFloatArrayField(String fieldName){
  check();
  cd.add(new FieldDefinitionImpl(index++,fieldName,FieldType.FLOAT_ARRAY));
  return this;
}","public ClassDefinitionBuilder addFloatArrayField(String fieldName){
  check();
  fieldDefinitions.add(new FieldDefinitionImpl(index++,fieldName,FieldType.FLOAT_ARRAY));
  return this;
}",0.9550561797752808
49291,"public ClassDefinitionBuilder addCharField(String fieldName){
  check();
  cd.add(new FieldDefinitionImpl(index++,fieldName,FieldType.CHAR));
  return this;
}","public ClassDefinitionBuilder addCharField(String fieldName){
  check();
  fieldDefinitions.add(new FieldDefinitionImpl(index++,fieldName,FieldType.CHAR));
  return this;
}",0.9515151515151516
49292,"public ClassDefinitionBuilder addLongArrayField(String fieldName){
  check();
  cd.add(new FieldDefinitionImpl(index++,fieldName,FieldType.LONG_ARRAY));
  return this;
}","public ClassDefinitionBuilder addLongArrayField(String fieldName){
  check();
  fieldDefinitions.add(new FieldDefinitionImpl(index++,fieldName,FieldType.LONG_ARRAY));
  return this;
}",0.9545454545454546
49293,"private void check(){
  if (done) {
    throw new HazelcastSerializationException(""String_Node_Str"" + cd.getClassId());
  }
}","private void check(){
  if (done) {
    throw new HazelcastSerializationException(""String_Node_Str"" + classId);
  }
}",0.9669421487603306
49294,"public ClassDefinitionBuilder addFloatField(String fieldName){
  check();
  cd.add(new FieldDefinitionImpl(index++,fieldName,FieldType.FLOAT));
  return this;
}","public ClassDefinitionBuilder addFloatField(String fieldName){
  check();
  fieldDefinitions.add(new FieldDefinitionImpl(index++,fieldName,FieldType.FLOAT));
  return this;
}",0.9520958083832336
49295,"public ClassDefinitionBuilder addByteField(String fieldName){
  check();
  cd.add(new FieldDefinitionImpl(index++,fieldName,FieldType.BYTE));
  return this;
}","public ClassDefinitionBuilder addByteField(String fieldName){
  check();
  fieldDefinitions.add(new FieldDefinitionImpl(index++,fieldName,FieldType.BYTE));
  return this;
}",0.9515151515151516
49296,"public ClassDefinitionBuilder addShortArrayField(String fieldName){
  check();
  cd.add(new FieldDefinitionImpl(index++,fieldName,FieldType.SHORT_ARRAY));
  return this;
}","public ClassDefinitionBuilder addShortArrayField(String fieldName){
  check();
  fieldDefinitions.add(new FieldDefinitionImpl(index++,fieldName,FieldType.SHORT_ARRAY));
  return this;
}",0.9550561797752808
49297,"public ClassDefinitionBuilder addDoubleArrayField(String fieldName){
  check();
  cd.add(new FieldDefinitionImpl(index++,fieldName,FieldType.DOUBLE_ARRAY));
  return this;
}","public ClassDefinitionBuilder addDoubleArrayField(String fieldName){
  check();
  fieldDefinitions.add(new FieldDefinitionImpl(index++,fieldName,FieldType.DOUBLE_ARRAY));
  return this;
}",0.9555555555555556
49298,"public ClassDefinitionBuilder addUTFField(String fieldName){
  check();
  cd.add(new FieldDefinitionImpl(index++,fieldName,FieldType.UTF));
  return this;
}","public ClassDefinitionBuilder addUTFField(String fieldName){
  check();
  fieldDefinitions.add(new FieldDefinitionImpl(index++,fieldName,FieldType.UTF));
  return this;
}",0.950920245398773
49299,"public ClassDefinition build(){
  done=true;
  return cd;
}","public ClassDefinition build(){
  done=true;
  final ClassDefinitionImpl cd=new ClassDefinitionImpl(factoryId,classId);
  for (  FieldDefinition fd : fieldDefinitions) {
    cd.addFieldDef(fd);
  }
  for (  ClassDefinition nestedCd : nestedClassDefinitions) {
    cd.addClassDef(nestedCd);
  }
  return cd;
}",0.3215258855585831
49300,"public ClassDefinitionBuilder addIntField(String fieldName){
  check();
  cd.add(new FieldDefinitionImpl(index++,fieldName,FieldType.INT));
  return this;
}","public ClassDefinitionBuilder addIntField(String fieldName){
  check();
  fieldDefinitions.add(new FieldDefinitionImpl(index++,fieldName,FieldType.INT));
  return this;
}",0.950920245398773
49301,"public ClassDefinitionBuilder addLongField(String fieldName){
  check();
  cd.add(new FieldDefinitionImpl(index++,fieldName,FieldType.LONG));
  return this;
}","public ClassDefinitionBuilder addLongField(String fieldName){
  check();
  fieldDefinitions.add(new FieldDefinitionImpl(index++,fieldName,FieldType.LONG));
  return this;
}",0.9515151515151516
49302,"public ClassDefinitionBuilder addIntArrayField(String fieldName){
  check();
  cd.add(new FieldDefinitionImpl(index++,fieldName,FieldType.INT_ARRAY));
  return this;
}","public ClassDefinitionBuilder addIntArrayField(String fieldName){
  check();
  fieldDefinitions.add(new FieldDefinitionImpl(index++,fieldName,FieldType.INT_ARRAY));
  return this;
}",0.9540229885057472
49303,"public ClassDefinitionBuilder addCharArrayField(String fieldName){
  check();
  cd.add(new FieldDefinitionImpl(index++,fieldName,FieldType.CHAR_ARRAY));
  return this;
}","public ClassDefinitionBuilder addCharArrayField(String fieldName){
  check();
  fieldDefinitions.add(new FieldDefinitionImpl(index++,fieldName,FieldType.CHAR_ARRAY));
  return this;
}",0.9545454545454546
49304,"public ClassDefinitionBuilder addDoubleField(String fieldName){
  check();
  cd.add(new FieldDefinitionImpl(index++,fieldName,FieldType.DOUBLE));
  return this;
}","public ClassDefinitionBuilder addDoubleField(String fieldName){
  check();
  fieldDefinitions.add(new FieldDefinitionImpl(index++,fieldName,FieldType.DOUBLE));
  return this;
}",0.9526627218934912
49305,"public ClassDefinitionBuilder addShortField(String fieldName){
  check();
  cd.add(new FieldDefinitionImpl(index++,fieldName,FieldType.SHORT));
  return this;
}","public ClassDefinitionBuilder addShortField(String fieldName){
  check();
  fieldDefinitions.add(new FieldDefinitionImpl(index++,fieldName,FieldType.SHORT));
  return this;
}",0.9520958083832336
49306,"public ClassDefinitionBuilder(int factoryId,int classId){
  cd=new ClassDefinitionImpl(factoryId,classId);
}","public ClassDefinitionBuilder(int factoryId,int classId){
  this.factoryId=factoryId;
  this.classId=classId;
}",0.730593607305936
49307,"public void readData(ObjectDataInput in) throws IOException {
  factoryId=in.readInt();
  classId=in.readInt();
  version=in.readInt();
  int size=in.readInt();
  for (int i=0; i < size; i++) {
    FieldDefinitionImpl fieldDefinition=new FieldDefinitionImpl();
    fieldDefinition.readData(in);
    add(fieldDefinition);
  }
  size=in.readInt();
  for (int i=0; i < size; i++) {
    ClassDefinitionImpl classDefinition=new ClassDefinitionImpl();
    classDefinition.readData(in);
    add(classDefinition);
  }
}","public void readData(ObjectDataInput in) throws IOException {
  factoryId=in.readInt();
  classId=in.readInt();
  version=in.readInt();
  int size=in.readInt();
  for (int i=0; i < size; i++) {
    FieldDefinitionImpl fieldDefinition=new FieldDefinitionImpl();
    fieldDefinition.readData(in);
    addFieldDef(fieldDefinition);
  }
  size=in.readInt();
  for (int i=0; i < size; i++) {
    ClassDefinitionImpl classDefinition=new ClassDefinitionImpl();
    classDefinition.readData(in);
    addClassDef(classDefinition);
  }
}",0.9845857418111752
49308,"public void writePortableArray(String fieldName,Portable[] portables) throws IOException {
  if (portables == null || portables.length == 0) {
    throw new HazelcastSerializationException(""String_Node_Str"" + ""String_Node_Str"");
  }
  final Portable p=portables[0];
  final int classId=p.getClassId();
  for (int i=1; i < portables.length; i++) {
    if (portables[i].getClassId() != classId) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  builder.addPortableArrayField(fieldName,p.getFactoryId(),classId);
  addNestedField(p,new ClassDefinitionBuilder(p.getFactoryId(),classId));
}","public void writePortableArray(String fieldName,Portable[] portables) throws IOException {
  if (portables == null || portables.length == 0) {
    throw new HazelcastSerializationException(""String_Node_Str"" + ""String_Node_Str"");
  }
  final Portable p=portables[0];
  final int classId=p.getClassId();
  for (int i=1; i < portables.length; i++) {
    if (portables[i].getClassId() != classId) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  final ClassDefinition nestedClassDef=createNestedClassDef(p,new ClassDefinitionBuilder(p.getFactoryId(),classId));
  builder.addPortableArrayField(fieldName,nestedClassDef);
}",0.8300079808459697
49309,"private void writePortable(String fieldName,int factoryId,int classId,Portable portable) throws IOException {
  builder.addPortableField(fieldName,factoryId,classId);
  if (portable != null) {
    addNestedField(portable,new ClassDefinitionBuilder(portable.getFactoryId(),classId));
  }
 else   if (context.lookup(factoryId,classId) == null) {
    throw new HazelcastSerializationException(""String_Node_Str"" + ""String_Node_Str"");
  }
}","private void writePortable(String fieldName,int factoryId,int classId,Portable portable) throws IOException {
  final ClassDefinition nestedClassDef;
  if (portable != null) {
    nestedClassDef=createNestedClassDef(portable,new ClassDefinitionBuilder(factoryId,classId));
  }
 else {
    nestedClassDef=context.lookup(factoryId,classId);
    if (nestedClassDef == null) {
      throw new HazelcastSerializationException(""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  builder.addPortableField(fieldName,nestedClassDef);
}",0.7346514047866806
49310,"public IdentifiedDataSerializable create(int typeId){
switch (typeId) {
case GET_ALL_PARTITIONS:
    return new GetAllPartitionsRequest();
case GET_PARTITION:
  return new GetPartitionRequest();
case ADD_LISTENER:
return new AddMembershipListenerRequest();
}
return null;
}","public IdentifiedDataSerializable create(int typeId){
switch (typeId) {
case GET_PARTITIONS:
    return new GetPartitionsRequest();
case PARTITIONS:
  return new PartitionsResponse();
case ADD_LISTENER:
return new AddMigrationListenerRequest();
}
return null;
}",0.8764044943820225
49311,"public DataSerializableFactory createFactory(){
  return new DataSerializableFactory(){
    public IdentifiedDataSerializable create(    int typeId){
switch (typeId) {
case GET_ALL_PARTITIONS:
        return new GetAllPartitionsRequest();
case GET_PARTITION:
      return new GetPartitionRequest();
case ADD_LISTENER:
    return new AddMembershipListenerRequest();
}
return null;
}
}
;
}","public DataSerializableFactory createFactory(){
  return new DataSerializableFactory(){
    public IdentifiedDataSerializable create(    int typeId){
switch (typeId) {
case GET_PARTITIONS:
        return new GetPartitionsRequest();
case PARTITIONS:
      return new PartitionsResponse();
case ADD_LISTENER:
    return new AddMigrationListenerRequest();
}
return null;
}
}
;
}",0.937007874015748
49312,"public boolean containsKey(String name,Object key){
  this.keyObject=key;
  this.nearCache=mapCaches.get(name);
  Data dataKey=toData(key);
  if (nearCache != null) {
    if (nearCache.containsKey(key)) {
      return true;
    }
  }
  final CMap cMap=maps.get(name);
  if (cMap != null) {
    Record record=cMap.getOwnedRecord(dataKey);
    if (record != null && record.isActive() && record.isValid() && record.hasValueData()) {
      if (cMap.isReadBackupData()) {
        return true;
      }
 else {
        PartitionServiceImpl.PartitionProxy partition=partitionServiceImpl.getPartition(record.getBlockId());
        if (partition != null && !partitionManager.isOwnedPartitionMigrating(partition.getPartitionId()) && partition.getOwner() != null && partition.getOwner().localMember()) {
          return true;
        }
      }
    }
  }
  return booleanCall(CONCURRENT_MAP_CONTAINS_KEY,name,dataKey,null,0,-1);
}","public boolean containsKey(String name,Object key){
  this.keyObject=key;
  this.nearCache=mapCaches.get(name);
  Data dataKey=toData(key);
  if (nearCache != null) {
    if (nearCache.containsKey(key)) {
      return true;
    }
  }
  final CMap cMap=maps.get(name);
  if (cMap != null) {
    Record record=cMap.getOwnedRecord(dataKey);
    if (record != null && record.isActive() && record.isValid() && record.hasValueData()) {
      if (cMap.isReadBackupData()) {
        record.setLastAccessed();
        return true;
      }
 else {
        PartitionServiceImpl.PartitionProxy partition=partitionServiceImpl.getPartition(record.getBlockId());
        if (partition != null && !partitionManager.isOwnedPartitionMigrating(partition.getPartitionId()) && partition.getOwner() != null && partition.getOwner().localMember()) {
          record.setLastAccessed();
          return true;
        }
      }
    }
  }
  return booleanCall(CONCURRENT_MAP_CONTAINS_KEY,name,dataKey,null,0,-1);
}",0.9632738719832108
49313,"public void run(){
  final Connection conn=packet.getConn();
  try {
    final ClientEndpoint endpoint=getEndpoint(conn);
    currentEndpoint.set(endpoint);
    final Data data=packet.getData();
    final ClientRequest request=(ClientRequest)serializationService.toObject(data);
    if (endpoint.isAuthenticated() || request instanceof ClientAuthenticationRequest) {
      request.setConnection(conn);
      request.setService(nodeEngine.getService(request.getServiceName()));
      request.setClientEngine(ClientEngineImpl.this);
      final Object result=request.process();
      final Data resultData=result != null ? serializationService.toData(result) : new Data();
      sendResponse(conn,resultData);
    }
 else {
      String message=""String_Node_Str"" + conn + ""String_Node_Str"";
      logger.log(Level.SEVERE,message);
      sendResponse(conn,new GenericError(message,0));
      removeEndpoint(conn);
    }
  }
 catch (  Throwable e) {
    logger.log(Level.SEVERE,e.getMessage(),e);
  }
 finally {
    currentEndpoint.set(null);
  }
}","public void run(){
  final Connection conn=packet.getConn();
  try {
    final ClientEndpoint endpoint=getEndpoint(conn);
    currentEndpoint.set(endpoint);
    final Data data=packet.getData();
    final ClientRequest request=(ClientRequest)serializationService.toObject(data);
    if (endpoint.isAuthenticated() || request instanceof ClientAuthenticationRequest) {
      request.setConnection(conn);
      request.setService(nodeEngine.getService(request.getServiceName()));
      request.setClientEngine(ClientEngineImpl.this);
      final Object result=request.process();
      final Data resultData=result != null ? serializationService.toData(result) : new Data();
      sendResponse(conn,resultData);
    }
 else {
      String message=""String_Node_Str"" + conn + ""String_Node_Str"";
      logger.log(Level.SEVERE,message);
      sendResponse(conn,new GenericError(message,0));
      removeEndpoint(conn);
    }
  }
 catch (  Throwable e) {
    logger.log(Level.SEVERE,e.getMessage(),e);
    StringWriter w=new StringWriter();
    e.printStackTrace(new PrintWriter(w));
    sendResponse(conn,new GenericError(w.toString(),0));
  }
 finally {
    currentEndpoint.set(null);
  }
}",0.9375841939829368
49314,"public Object invoke() throws InterruptedException, ExecutionException, TimeoutException {
  op.setCallerUuid(uuid);
  final InvocationBuilder builder;
  if (target == null) {
    builder=nodeEngine.getOperationService().createInvocationBuilder(serviceName,op,partitionId).setReplicaIndex(replicaIndex);
  }
 else {
    builder=nodeEngine.getOperationService().createInvocationBuilder(serviceName,op,target);
  }
  builder.setTryCount(50).setCallTimeout(30 * 1000);
  Invocation inv=builder.build();
  Future f=inv.invoke();
  return f.get(60,TimeUnit.SECONDS);
}","public Object invoke() throws InterruptedException, ExecutionException, TimeoutException {
  op.setCallerUuid(uuid);
  final InvocationBuilder builder;
  if (target == null) {
    builder=nodeEngine.getOperationService().createInvocationBuilder(serviceName,op,partitionId).setReplicaIndex(replicaIndex);
  }
 else {
    builder=nodeEngine.getOperationService().createInvocationBuilder(serviceName,op,target);
  }
  builder.setTryCount(100).setCallTimeout(20 * 1000);
  Invocation inv=builder.build();
  Future f=inv.invoke();
  return f.get(30,TimeUnit.SECONDS);
}",0.9937888198757764
49315,"public int size(){
  return (data == null) ? 6 : data.totalSize() + 6;
}","public int size(){
  return (data != null ? data.totalSize() : 0) + 6;
}",0.9166666666666666
49316,"public boolean write(DataAdapter writer,ByteBuffer socketBuffer) throws Exception {
  System.err.println(""String_Node_Str"" + writer.getData());
  return writer.writeTo(socketBuffer);
}","public boolean write(DataAdapter writer,ByteBuffer socketBuffer) throws Exception {
  return writer.writeTo(socketBuffer);
}",0.8051948051948052
49317,"/** 
 * Calculates the size of the binary after the Data is serialized. WARNING: Should be in sync with   {@link #writeData(com.hazelcast.nio.ObjectDataOutput)}
 */
public int totalSize(){
  int total=0;
  total+=4;
  if (classDefinition != null) {
    total+=4;
    total+=4;
    total+=4;
    total+=4;
    total+=4;
    final byte[] binary=((BinaryClassDefinition)classDefinition).getBinary();
    total+=binary != null ? binary.length : 0;
  }
 else {
    total+=4;
  }
  total+=4;
  total+=bufferSize();
  total+=4;
  return total;
}","/** 
 * Calculates the size of the binary after the Data is serialized. WARNING: Should be in sync with   {@link #writeData(com.hazelcast.nio.ObjectDataOutput)}
 */
public int totalSize(){
  int total=0;
  total+=4;
  if (classDefinition != null) {
    total+=4;
    total+=4;
    total+=4;
    total+=4;
    final byte[] binary=((BinaryClassDefinition)classDefinition).getBinary();
    total+=binary != null ? binary.length : 0;
  }
 else {
    total+=4;
  }
  total+=4;
  total+=bufferSize();
  total+=4;
  return total;
}",0.9868173258003766
49318,"@Override public String toString(){
  return ""String_Node_Str"" + ""String_Node_Str"" + type + ""String_Node_Str""+ ""String_Node_Str""+ getPartitionHash()+ ""String_Node_Str""+ bufferSize();
}","@Override public String toString(){
  final StringBuilder sb=new StringBuilder(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(type);
  sb.append(""String_Node_Str"").append(getPartitionHash());
  sb.append(""String_Node_Str"").append(bufferSize());
  sb.append(""String_Node_Str"").append(totalSize());
  sb.append('}');
  return sb.toString();
}",0.2728971962616822
49319,"/** 
 * WARNING: Should be in sync with   {@link Data#readData(com.hazelcast.nio.ObjectDataInput)}
 */
public boolean readFrom(ByteBuffer source){
  if (data == null) {
    data=new Data();
  }
  if (!isStatusSet(stType)) {
    if (source.remaining() < 4) {
      return false;
    }
    data.type=source.getInt();
    setStatus(stType);
  }
  if (!isStatusSet(stClassId)) {
    if (source.remaining() < 4) {
      return false;
    }
    classId=source.getInt();
    setStatus(stClassId);
    if (classId == Data.NO_CLASS_ID) {
      setStatus(stFactoryId);
      setStatus(stVersion);
      setStatus(stClassDefSize);
      setStatus(stClassDef);
    }
  }
  if (!isStatusSet(stFactoryId)) {
    if (source.remaining() < 4) {
      return false;
    }
    factoryId=source.getInt();
    setStatus(stFactoryId);
  }
  if (!isStatusSet(stVersion)) {
    if (source.remaining() < 4) {
      return false;
    }
    version=source.getInt();
    setStatus(stVersion);
  }
  if (!isStatusSet(stClassDef)) {
    ClassDefinition cd;
    if ((cd=context.lookup(factoryId,classId,version)) != null) {
      data.classDefinition=cd;
      setStatus(stClassDefSize);
      setStatus(stClassDef);
    }
 else {
      if (!isStatusSet(stClassDefSize)) {
        if (source.remaining() < 4) {
          return false;
        }
        classDefSize=source.getInt();
        setStatus(stClassDefSize);
      }
      if (!isStatusSet(stClassDef)) {
        if (source.remaining() < classDefSize) {
          return false;
        }
        final byte[] binary=new byte[classDefSize];
        source.get(binary);
        data.classDefinition=new BinaryClassDefinitionProxy(factoryId,classId,version,binary);
        setStatus(stClassDef);
      }
    }
  }
  if (!isStatusSet(stSize)) {
    if (source.remaining() < 4) {
      return false;
    }
    final int size=source.getInt();
    buffer=ByteBuffer.allocate(size);
    setStatus(stSize);
  }
  if (!isStatusSet(stValue)) {
    IOUtil.copyToHeapBuffer(source,buffer);
    if (buffer.hasRemaining()) {
      return false;
    }
    buffer.flip();
    data.buffer=buffer.array();
    setStatus(stValue);
  }
  if (!isStatusSet(stHash)) {
    if (source.remaining() < 4) {
      return false;
    }
    data.setPartitionHash(source.getInt());
    setStatus(stHash);
  }
  setStatus(stAll);
  return true;
}","/** 
 * WARNING: Should be in sync with   {@link Data#readData(com.hazelcast.nio.ObjectDataInput)}
 */
public boolean readFrom(ByteBuffer source){
  if (data == null) {
    data=new Data();
  }
  if (!isStatusSet(stType)) {
    if (source.remaining() < 4) {
      return false;
    }
    data.type=source.getInt();
    setStatus(stType);
  }
  if (!isStatusSet(stClassId)) {
    if (source.remaining() < 4) {
      return false;
    }
    classId=source.getInt();
    setStatus(stClassId);
    if (classId == Data.NO_CLASS_ID) {
      setStatus(stFactoryId);
      setStatus(stVersion);
      setStatus(stClassDefSize);
      setStatus(stClassDef);
    }
  }
  if (!isStatusSet(stFactoryId)) {
    if (source.remaining() < 4) {
      return false;
    }
    factoryId=source.getInt();
    setStatus(stFactoryId);
  }
  if (!isStatusSet(stVersion)) {
    if (source.remaining() < 4) {
      return false;
    }
    version=source.getInt();
    setStatus(stVersion);
  }
  if (!isStatusSet(stClassDef)) {
    ClassDefinition cd;
    if (!skipClassDef && (cd=context.lookup(factoryId,classId,version)) != null) {
      data.classDefinition=cd;
      skipClassDef=true;
    }
    if (!isStatusSet(stClassDefSize)) {
      if (source.remaining() < 4) {
        return false;
      }
      classDefSize=source.getInt();
      setStatus(stClassDefSize);
    }
    if (!isStatusSet(stClassDef)) {
      if (source.remaining() < classDefSize) {
        return false;
      }
      if (skipClassDef) {
        source.position(classDefSize + source.position());
      }
 else {
        final byte[] binary=new byte[classDefSize];
        source.get(binary);
        data.classDefinition=new BinaryClassDefinitionProxy(factoryId,classId,version,binary);
      }
      setStatus(stClassDef);
    }
  }
  if (!isStatusSet(stSize)) {
    if (source.remaining() < 4) {
      return false;
    }
    final int size=source.getInt();
    buffer=ByteBuffer.allocate(size);
    setStatus(stSize);
  }
  if (!isStatusSet(stValue)) {
    IOUtil.copyToHeapBuffer(source,buffer);
    if (buffer.hasRemaining()) {
      return false;
    }
    buffer.flip();
    data.buffer=buffer.array();
    setStatus(stValue);
  }
  if (!isStatusSet(stHash)) {
    if (source.remaining() < 4) {
      return false;
    }
    data.setPartitionHash(source.getInt());
    setStatus(stHash);
  }
  setStatus(stAll);
  return true;
}",0.8611287254280279
49320,"ClassDefinition createClassDefinition(byte[] compressedBinary) throws IOException {
  final ContextAwareDataOutput out=pop();
  final byte[] binary;
  try {
    decompress(compressedBinary,out);
    binary=out.toByteArray();
  }
  finally {
    push(out);
  }
  final ClassDefinitionImpl cd=new ClassDefinitionImpl();
  cd.readData(new ContextAwareDataInput(binary,SerializationServiceImpl.this));
  cd.setBinary(binary);
  final ClassDefinitionImpl currentCD=versionedDefinitions.putIfAbsent(combineToLong(cd.classId,serializationContext.getVersion()),cd);
  if (currentCD == null) {
    serializationContext.registerNestedDefinitions(cd);
    return cd;
  }
 else {
    return currentCD;
  }
}","ClassDefinition createClassDefinition(byte[] compressedBinary) throws IOException {
  final ContextAwareDataOutput out=pop();
  final byte[] binary;
  try {
    decompress(compressedBinary,out);
    binary=out.toByteArray();
  }
  finally {
    push(out);
  }
  final ClassDefinitionImpl cd=new ClassDefinitionImpl();
  cd.readData(new ContextAwareDataInput(binary,SerializationServiceImpl.this));
  cd.setBinary(compressedBinary);
  final ClassDefinitionImpl currentCD=versionedDefinitions.putIfAbsent(combineToLong(cd.classId,serializationContext.getVersion()),cd);
  if (currentCD == null) {
    serializationContext.registerNestedDefinitions(cd);
    return cd;
  }
 else {
    return currentCD;
  }
}",0.9914285714285714
49321,"public void init(final NodeEngine nodeEngine,Properties properties){
  int partitionCount=nodeEngine.getPartitionService().getPartitionCount();
  for (int i=0; i < partitionCount; i++) {
    partitionContainers[i]=new CollectionPartitionContainer(this,i);
  }
  final SharedLockService lockService=nodeEngine.getSharedService(SharedLockService.SERVICE_NAME);
  if (lockService != null) {
    lockService.registerLockStoreConstructor(SERVICE_NAME,new ConcurrencyUtil.ConstructorFunction<ObjectNamespace,LockStoreInfo>(){
      public LockStoreInfo createNew(      final ObjectNamespace key){
        CollectionProxyId id=(CollectionProxyId)key.getObjectId();
        final MultiMapConfig multiMapConfig=nodeEngine.getConfig().getMultiMapConfig(id.getName());
        return new LockStoreInfo(){
          public ObjectNamespace getObjectNamespace(){
            return key;
          }
          public int getBackupCount(){
            return multiMapConfig.getSyncBackupCount();
          }
          public int getAsyncBackupCount(){
            return multiMapConfig.getAsyncBackupCount();
          }
        }
;
      }
    }
);
  }
}","public void init(final NodeEngine nodeEngine,Properties properties){
  int partitionCount=nodeEngine.getPartitionService().getPartitionCount();
  for (int i=0; i < partitionCount; i++) {
    partitionContainers[i]=new CollectionPartitionContainer(this,i);
  }
  final SharedLockService lockService=nodeEngine.getSharedService(SharedLockService.SERVICE_NAME);
  if (lockService != null) {
    lockService.registerLockStoreConstructor(SERVICE_NAME,new ConstructorFunction<ObjectNamespace,LockStoreInfo>(){
      public LockStoreInfo createNew(      final ObjectNamespace key){
        CollectionProxyId id=(CollectionProxyId)key.getObjectId();
        final MultiMapConfig multiMapConfig=nodeEngine.getConfig().getMultiMapConfig(id.getName());
        return new LockStoreInfo(){
          public ObjectNamespace getObjectNamespace(){
            return key;
          }
          public int getBackupCount(){
            return multiMapConfig.getSyncBackupCount();
          }
          public int getAsyncBackupCount(){
            return multiMapConfig.getAsyncBackupCount();
          }
        }
;
      }
    }
);
  }
}",0.9929266136162688
49322,"public void init(NodeEngine nodeEngine,Properties properties){
  registerLockStoreConstructor(SERVICE_NAME,new ConcurrencyUtil.ConstructorFunction<ObjectNamespace,LockStoreInfo>(){
    public LockStoreInfo createNew(    ObjectNamespace key){
      return new LockStoreInfo(){
        public ObjectNamespace getObjectNamespace(){
          return new InternalLockNamespace();
        }
        public int getBackupCount(){
          return 1;
        }
        public int getAsyncBackupCount(){
          return 0;
        }
      }
;
    }
  }
);
}","public void init(NodeEngine nodeEngine,Properties properties){
  registerLockStoreConstructor(SERVICE_NAME,new ConstructorFunction<ObjectNamespace,LockStoreInfo>(){
    public LockStoreInfo createNew(    ObjectNamespace key){
      return new LockStoreInfo(){
        public ObjectNamespace getObjectNamespace(){
          return new InternalLockNamespace();
        }
        public int getBackupCount(){
          return 1;
        }
        public int getAsyncBackupCount(){
          return 0;
        }
      }
;
    }
  }
);
}",0.9851851851851852
49323,"public void registerLockStoreConstructor(String serviceName,ConcurrencyUtil.ConstructorFunction<ObjectNamespace,LockStoreInfo> constructorFunction){
  if (constructors.putIfAbsent(serviceName,constructorFunction) != null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}","public void registerLockStoreConstructor(String serviceName,ConstructorFunction<ObjectNamespace,LockStoreInfo> constructorFunction){
  if (constructors.putIfAbsent(serviceName,constructorFunction) != null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}",0.9714285714285714
49324,"void registerLockStoreConstructor(String serviceName,ConcurrencyUtil.ConstructorFunction<ObjectNamespace,LockStoreInfo> constructorFunction);","void registerLockStoreConstructor(String serviceName,ConstructorFunction<ObjectNamespace,LockStoreInfo> constructorFunction);",0.9398496240601504
49325,"private int sendBackups(BackupAwareOperation backupAwareOp) throws Exception {
  final Operation op=(Operation)backupAwareOp;
  boolean returnsResponse=op.returnsResponse();
  final int maxBackups=node.getClusterService().getSize() - 1;
  int syncBackupCount=backupAwareOp.getSyncBackupCount() > 0 ? Math.min(maxBackups,backupAwareOp.getSyncBackupCount()) : 0;
  int asyncBackupCount=(backupAwareOp.getAsyncBackupCount() > 0 && maxBackups > syncBackupCount) ? Math.min(maxBackups - syncBackupCount,backupAwareOp.getAsyncBackupCount()) : 0;
  if (!returnsResponse) {
    asyncBackupCount+=syncBackupCount;
    syncBackupCount=0;
  }
  final int totalBackupCount=syncBackupCount + asyncBackupCount;
  if (totalBackupCount > 0) {
    final String serviceName=op.getServiceName();
    final int partitionId=op.getPartitionId();
    final PartitionServiceImpl partitionService=(PartitionServiceImpl)nodeEngine.getPartitionService();
    final long[] replicaVersions=partitionService.incrementPartitionReplicaVersions(partitionId,totalBackupCount);
    final PartitionInfo partitionInfo=partitionService.getPartitionInfo(partitionId);
    for (int replicaIndex=1; replicaIndex <= totalBackupCount; replicaIndex++) {
      final Address target=partitionInfo.getReplicaAddress(replicaIndex);
      if (target != null) {
        final Operation backupOp=backupAwareOp.getBackupOperation();
        if (backupOp == null) {
          throw new IllegalArgumentException(""String_Node_Str"");
        }
        if (target.equals(node.getThisAddress())) {
          throw new IllegalStateException(""String_Node_Str"");
        }
 else {
          backupOp.setPartitionId(partitionId).setReplicaIndex(replicaIndex).setServiceName(serviceName);
          Backup backup=new Backup(backupOp,op.getCallerAddress(),replicaVersions,replicaIndex <= syncBackupCount);
          backup.setPartitionId(partitionId).setReplicaIndex(replicaIndex).setServiceName(serviceName).setCallerUuid(nodeEngine.getLocalMember().getUuid());
          OperationAccessor.setCallId(backup,op.getCallId());
          send(backup,target);
        }
      }
    }
  }
  return syncBackupCount;
}","private int sendBackups(BackupAwareOperation backupAwareOp) throws Exception {
  final Operation op=(Operation)backupAwareOp;
  final boolean returnsResponse=op.returnsResponse();
  final int maxBackups=Math.min(node.getClusterService().getSize(),PartitionInfo.MAX_REPLICA_COUNT) - 1;
  int syncBackupCount=backupAwareOp.getSyncBackupCount() > 0 ? Math.min(maxBackups,backupAwareOp.getSyncBackupCount()) : 0;
  int asyncBackupCount=(backupAwareOp.getAsyncBackupCount() > 0 && maxBackups > syncBackupCount) ? Math.min(maxBackups - syncBackupCount,backupAwareOp.getAsyncBackupCount()) : 0;
  if (!returnsResponse) {
    asyncBackupCount+=syncBackupCount;
    syncBackupCount=0;
  }
  final int totalBackupCount=syncBackupCount + asyncBackupCount;
  if (totalBackupCount > 0) {
    final String serviceName=op.getServiceName();
    final int partitionId=op.getPartitionId();
    final PartitionServiceImpl partitionService=(PartitionServiceImpl)nodeEngine.getPartitionService();
    final long[] replicaVersions=partitionService.incrementPartitionReplicaVersions(partitionId,totalBackupCount);
    final PartitionInfo partitionInfo=partitionService.getPartitionInfo(partitionId);
    for (int replicaIndex=1; replicaIndex <= totalBackupCount; replicaIndex++) {
      final Address target=partitionInfo.getReplicaAddress(replicaIndex);
      if (target != null) {
        final Operation backupOp=backupAwareOp.getBackupOperation();
        if (backupOp == null) {
          throw new IllegalArgumentException(""String_Node_Str"");
        }
        if (target.equals(node.getThisAddress())) {
          throw new IllegalStateException(""String_Node_Str"");
        }
 else {
          backupOp.setPartitionId(partitionId).setReplicaIndex(replicaIndex).setServiceName(serviceName);
          Backup backup=new Backup(backupOp,op.getCallerAddress(),replicaVersions,replicaIndex <= syncBackupCount);
          backup.setPartitionId(partitionId).setReplicaIndex(replicaIndex).setServiceName(serviceName).setCallerUuid(nodeEngine.getLocalMember().getUuid());
          OperationAccessor.setCallId(backup,op.getCallId());
          send(backup,target);
        }
      }
    }
  }
  return syncBackupCount;
}",0.988945186549977
49326,"void startJoin(){
  logger.log(Level.FINEST,""String_Node_Str"");
  lock.lock();
  try {
    joinInProgress=true;
    final Collection<MemberImpl> members=getMemberList();
    final Collection<MemberInfo> memberInfos=createMemberInfos(members);
    for (    MemberImpl member : members) {
      memberInfos.add(new MemberInfo(member.getAddress(),member.getUuid()));
    }
    for (    MemberInfo memberJoining : setJoins) {
      memberInfos.add(memberJoining);
    }
    final long time=getClusterTime();
    final MemberInfoUpdateOperation memberInfoUpdateOp=new MemberInfoUpdateOperation(memberInfos,time,true);
    final Operation[] postJoinOps=nodeEngine.getPostJoinOperations();
    final PostJoinOperation postJoinOp=postJoinOps != null && postJoinOps.length > 0 ? new PostJoinOperation(postJoinOps) : null;
    final FinalizeJoinOperation finalizeJoinOp=new FinalizeJoinOperation(memberInfos,postJoinOp,time);
    final List<Future> calls=new ArrayList<Future>(members.size());
    for (    MemberInfo member : setJoins) {
      calls.add(invokeClusterOperation(finalizeJoinOp,member.getAddress()));
    }
    for (    MemberImpl member : members) {
      if (!member.getAddress().equals(thisAddress)) {
        calls.add(invokeClusterOperation(memberInfoUpdateOp,member.getAddress()));
      }
    }
    updateMembers(memberInfos);
    for (    Future future : calls) {
      try {
        future.get(3,TimeUnit.SECONDS);
      }
 catch (      TimeoutException ignored) {
        logger.log(Level.FINEST,""String_Node_Str"" + future);
      }
catch (      Exception e) {
        logger.log(Level.WARNING,""String_Node_Str"",e);
      }
    }
  }
  finally {
    lock.unlock();
  }
}","void startJoin(){
  logger.log(Level.FINEST,""String_Node_Str"");
  lock.lock();
  try {
    joinInProgress=true;
    final Collection<MemberImpl> members=getMemberList();
    final Collection<MemberInfo> memberInfos=createMemberInfos(members);
    for (    MemberImpl member : members) {
      memberInfos.add(new MemberInfo(member.getAddress(),member.getUuid()));
    }
    for (    MemberInfo memberJoining : setJoins) {
      memberInfos.add(memberJoining);
    }
    final long time=getClusterTime();
    final Operation[] postJoinOps=nodeEngine.getPostJoinOperations();
    final PostJoinOperation postJoinOp=postJoinOps != null && postJoinOps.length > 0 ? new PostJoinOperation(postJoinOps) : null;
    final List<Future> calls=new ArrayList<Future>(members.size());
    for (    MemberInfo member : setJoins) {
      calls.add(invokeClusterOperation(new FinalizeJoinOperation(memberInfos,postJoinOp,time),member.getAddress()));
    }
    for (    MemberImpl member : members) {
      if (!member.getAddress().equals(thisAddress)) {
        calls.add(invokeClusterOperation(new MemberInfoUpdateOperation(memberInfos,time,true),member.getAddress()));
      }
    }
    updateMembers(memberInfos);
    for (    Future future : calls) {
      try {
        future.get(3,TimeUnit.SECONDS);
      }
 catch (      TimeoutException ignored) {
        logger.log(Level.FINEST,""String_Node_Str"" + future);
      }
catch (      Exception e) {
        logger.log(Level.WARNING,""String_Node_Str"",e);
      }
    }
  }
  finally {
    lock.unlock();
  }
}",0.9102722772277227
49327,"@Override public void run() throws Exception {
  if (isValid()) {
    super.run();
    final ClusterServiceImpl clusterService=getService();
    final NodeEngineImpl nodeEngine=clusterService.getNodeEngine();
    final Operation[] postJoinOperations=nodeEngine.getPostJoinOperations();
    Collection<Future> calls=null;
    if (postJoinOperations != null && postJoinOperations.length > 0) {
      final PostJoinOperation localPJOp=new PostJoinOperation(postJoinOperations);
      final Collection<MemberImpl> members=clusterService.getMemberList();
      calls=new ArrayList<Future>(members.size());
      for (      MemberImpl member : members) {
        if (!member.localMember()) {
          Future f=nodeEngine.getOperationService().createInvocationBuilder(ClusterServiceImpl.SERVICE_NAME,localPJOp,member.getAddress()).setTryCount(10).setTryPauseMillis(100).build().invoke();
          calls.add(f);
        }
      }
    }
    if (postJoinOp != null) {
      postJoinOp.setNodeEngine(nodeEngine);
      OperationAccessor.setCallerAddress(postJoinOp,getCallerAddress());
      OperationAccessor.setConnection(postJoinOp,getConnection());
      postJoinOp.setResponseHandler(ResponseHandlerFactory.createEmptyResponseHandler());
      nodeEngine.getOperationService().runOperation(postJoinOp);
    }
    if (calls != null) {
      for (      Future f : calls) {
        try {
          f.get(1,TimeUnit.SECONDS);
        }
 catch (        InterruptedException ignored) {
        }
catch (        TimeoutException ignored) {
        }
catch (        ExecutionException e) {
          final ILogger logger=nodeEngine.getLogger(FinalizeJoinOperation.class);
          logger.log(Level.FINEST,""String_Node_Str"" + e.getClass().getSimpleName() + ""String_Node_Str""+ e.getMessage()+ ""String_Node_Str"");
        }
      }
    }
  }
}","@Override public void run() throws Exception {
  if (isValid()) {
    super.run();
    final ClusterServiceImpl clusterService=getService();
    final NodeEngineImpl nodeEngine=clusterService.getNodeEngine();
    final Operation[] postJoinOperations=nodeEngine.getPostJoinOperations();
    Collection<Future> calls=null;
    if (postJoinOperations != null && postJoinOperations.length > 0) {
      final Collection<MemberImpl> members=clusterService.getMemberList();
      calls=new ArrayList<Future>(members.size());
      for (      MemberImpl member : members) {
        if (!member.localMember()) {
          Future f=nodeEngine.getOperationService().createInvocationBuilder(ClusterServiceImpl.SERVICE_NAME,new PostJoinOperation(postJoinOperations),member.getAddress()).setTryCount(10).setTryPauseMillis(100).build().invoke();
          calls.add(f);
        }
      }
    }
    if (postJoinOp != null) {
      postJoinOp.setNodeEngine(nodeEngine);
      OperationAccessor.setCallerAddress(postJoinOp,getCallerAddress());
      OperationAccessor.setConnection(postJoinOp,getConnection());
      postJoinOp.setResponseHandler(ResponseHandlerFactory.createEmptyResponseHandler());
      nodeEngine.getOperationService().runOperation(postJoinOp);
    }
    if (calls != null) {
      for (      Future f : calls) {
        try {
          f.get(1,TimeUnit.SECONDS);
        }
 catch (        InterruptedException ignored) {
        }
catch (        TimeoutException ignored) {
        }
catch (        ExecutionException e) {
          final ILogger logger=nodeEngine.getLogger(FinalizeJoinOperation.class);
          logger.log(Level.FINEST,""String_Node_Str"" + e.getClass().getSimpleName() + ""String_Node_Str""+ e.getMessage()+ ""String_Node_Str"");
        }
      }
    }
  }
}",0.9642362073745496
49328,"public MapContainer(String name,MapConfig mapConfig,MapService mapService){
  MapStore storeTemp=null;
  this.name=name;
  this.mapConfig=mapConfig;
  this.mapService=mapService;
  MapStoreConfig mapStoreConfig=mapConfig.getMapStoreConfig();
  NodeEngine nodeEngine=mapService.getNodeEngine();
  if (mapStoreConfig != null) {
    try {
      MapStoreFactory factory=(MapStoreFactory)mapStoreConfig.getFactoryImplementation();
      if (factory == null) {
        String factoryClassName=mapStoreConfig.getFactoryClassName();
        if (factoryClassName != null && !""String_Node_Str"".equals(factoryClassName)) {
          factory=(MapStoreFactory)ClassLoaderUtil.newInstance(factoryClassName);
        }
      }
      storeTemp=(MapStore)(factory == null ? mapStoreConfig.getImplementation() : factory.newMapStore(name,mapStoreConfig.getProperties()));
      if (storeTemp == null) {
        String mapStoreClassName=mapStoreConfig.getClassName();
        storeTemp=ClassLoaderUtil.newInstance(mapStoreClassName);
      }
    }
 catch (    Exception e) {
      ExceptionUtil.rethrow(e);
      storeTemp=null;
    }
  }
  store=storeTemp;
  if (store != null) {
    if (store instanceof MapLoaderLifecycleSupport) {
      ((MapLoaderLifecycleSupport)store).init(nodeEngine.getHazelcastInstance(),mapConfig.getMapStoreConfig().getProperties(),name);
    }
    if (nodeEngine.getClusterService().isMaster() && initialLoaded.compareAndSet(false,true)) {
      loadMapFromStore(true);
      Collection<MemberImpl> members=nodeEngine.getClusterService().getMemberList();
      Operation operation=new MapInitialLoadOperation(name);
      for (      Member member : members) {
        try {
          if (member.localMember())           continue;
          MemberImpl memberImpl=(MemberImpl)member;
          Invocation invocation=nodeEngine.getOperationService().createInvocationBuilder(SERVICE_NAME,operation,memberImpl.getAddress()).build();
          invocation.invoke();
        }
 catch (        Throwable t) {
          throw ExceptionUtil.rethrow(t);
        }
      }
    }
 else {
      mapReady=true;
    }
    if (mapStoreConfig.getWriteDelaySeconds() > 0) {
      mapStoreWriteScheduler=EntryTaskSchedulerFactory.newScheduler(nodeEngine.getExecutionService().getScheduledExecutor(),new MapStoreWriteProcessor(this,mapService),false);
      mapStoreDeleteScheduler=EntryTaskSchedulerFactory.newScheduler(nodeEngine.getExecutionService().getScheduledExecutor(),new MapStoreDeleteProcessor(this,mapService),false);
    }
 else {
      mapStoreDeleteScheduler=null;
      mapStoreWriteScheduler=null;
    }
  }
 else {
    mapReady=true;
    mapStoreDeleteScheduler=null;
    mapStoreWriteScheduler=null;
  }
  ttlEvictionScheduler=EntryTaskSchedulerFactory.newScheduler(nodeEngine.getExecutionService().getScheduledExecutor(),new EvictionProcessor(nodeEngine,mapService,name),true);
  idleEvictionScheduler=EntryTaskSchedulerFactory.newScheduler(nodeEngine.getExecutionService().getScheduledExecutor(),new EvictionProcessor(nodeEngine,mapService,name),true);
  WanReplicationRef wanReplicationRef=mapConfig.getWanReplicationRef();
  if (wanReplicationRef != null) {
    this.wanReplicationPublisher=nodeEngine.getWanReplicationService().getWanReplicationListener(wanReplicationRef.getName());
    this.wanMergePolicy=mapService.getMergePolicy(wanReplicationRef.getMergePolicy());
  }
 else {
    wanMergePolicy=null;
    wanReplicationPublisher=null;
  }
  interceptors=new CopyOnWriteArrayList<MapInterceptor>();
  interceptorMap=new ConcurrentHashMap<String,MapInterceptor>();
  interceptorIdMap=new ConcurrentHashMap<MapInterceptor,String>();
  nearCacheEnabled=mapConfig.getNearCacheConfig() != null;
}","public MapContainer(String name,MapConfig mapConfig,MapService mapService){
  MapStore storeTemp=null;
  this.name=name;
  this.mapConfig=mapConfig;
  this.mapService=mapService;
  MapStoreConfig mapStoreConfig=mapConfig.getMapStoreConfig();
  NodeEngine nodeEngine=mapService.getNodeEngine();
  if (mapStoreConfig != null) {
    try {
      MapStoreFactory factory=(MapStoreFactory)mapStoreConfig.getFactoryImplementation();
      if (factory == null) {
        String factoryClassName=mapStoreConfig.getFactoryClassName();
        if (factoryClassName != null && !""String_Node_Str"".equals(factoryClassName)) {
          factory=(MapStoreFactory)ClassLoaderUtil.newInstance(factoryClassName);
        }
      }
      storeTemp=(MapStore)(factory == null ? mapStoreConfig.getImplementation() : factory.newMapStore(name,mapStoreConfig.getProperties()));
      if (storeTemp == null) {
        String mapStoreClassName=mapStoreConfig.getClassName();
        storeTemp=ClassLoaderUtil.newInstance(mapStoreClassName);
      }
    }
 catch (    Exception e) {
      ExceptionUtil.rethrow(e);
      storeTemp=null;
    }
  }
  store=storeTemp;
  if (store != null) {
    if (store instanceof MapLoaderLifecycleSupport) {
      ((MapLoaderLifecycleSupport)store).init(nodeEngine.getHazelcastInstance(),mapConfig.getMapStoreConfig().getProperties(),name);
    }
    if (nodeEngine.getClusterService().isMaster() && initialLoaded.compareAndSet(false,true)) {
      loadMapFromStore(true);
      Collection<MemberImpl> members=nodeEngine.getClusterService().getMemberList();
      for (      Member member : members) {
        try {
          if (member.localMember())           continue;
          MemberImpl memberImpl=(MemberImpl)member;
          Invocation invocation=nodeEngine.getOperationService().createInvocationBuilder(SERVICE_NAME,new MapInitialLoadOperation(name),memberImpl.getAddress()).build();
          invocation.invoke();
        }
 catch (        Throwable t) {
          throw ExceptionUtil.rethrow(t);
        }
      }
    }
 else {
      mapReady=true;
    }
    if (mapStoreConfig.getWriteDelaySeconds() > 0) {
      mapStoreWriteScheduler=EntryTaskSchedulerFactory.newScheduler(nodeEngine.getExecutionService().getScheduledExecutor(),new MapStoreWriteProcessor(this,mapService),false);
      mapStoreDeleteScheduler=EntryTaskSchedulerFactory.newScheduler(nodeEngine.getExecutionService().getScheduledExecutor(),new MapStoreDeleteProcessor(this,mapService),false);
    }
 else {
      mapStoreDeleteScheduler=null;
      mapStoreWriteScheduler=null;
    }
  }
 else {
    mapReady=true;
    mapStoreDeleteScheduler=null;
    mapStoreWriteScheduler=null;
  }
  ttlEvictionScheduler=EntryTaskSchedulerFactory.newScheduler(nodeEngine.getExecutionService().getScheduledExecutor(),new EvictionProcessor(nodeEngine,mapService,name),true);
  idleEvictionScheduler=EntryTaskSchedulerFactory.newScheduler(nodeEngine.getExecutionService().getScheduledExecutor(),new EvictionProcessor(nodeEngine,mapService,name),true);
  WanReplicationRef wanReplicationRef=mapConfig.getWanReplicationRef();
  if (wanReplicationRef != null) {
    this.wanReplicationPublisher=nodeEngine.getWanReplicationService().getWanReplicationListener(wanReplicationRef.getName());
    this.wanMergePolicy=mapService.getMergePolicy(wanReplicationRef.getMergePolicy());
  }
 else {
    wanMergePolicy=null;
    wanReplicationPublisher=null;
  }
  interceptors=new CopyOnWriteArrayList<MapInterceptor>();
  interceptorMap=new ConcurrentHashMap<String,MapInterceptor>();
  interceptorIdMap=new ConcurrentHashMap<MapInterceptor,String>();
  nearCacheEnabled=mapConfig.getNearCacheConfig() != null;
}",0.9860452513209592
49329,"protected Set query(final Predicate predicate,final QueryResultStream.IterationType iterationType,final boolean dataResult){
  final NodeEngine nodeEngine=getNodeEngine();
  OperationService operationService=nodeEngine.getOperationService();
  QueryOperation operation=new QueryOperation(name,predicate);
  Collection<MemberImpl> members=nodeEngine.getClusterService().getMemberList();
  int partitionCount=nodeEngine.getPartitionService().getPartitionCount();
  Set<Integer> plist=new HashSet<Integer>(partitionCount);
  QueryResultStream result=new QueryResultStream(nodeEngine.getSerializationService(),iterationType,dataResult,true);
  try {
    List<Future> flist=new ArrayList<Future>();
    for (    MemberImpl member : members) {
      Invocation invocation=operationService.createInvocationBuilder(SERVICE_NAME,operation,member.getAddress()).build();
      Future future=invocation.invoke();
      flist.add(future);
    }
    for (    Future future : flist) {
      QueryResult queryResult=(QueryResult)future.get();
      if (queryResult != null) {
        final List<Integer> partitionIds=queryResult.getPartitionIds();
        if (partitionIds != null) {
          plist.addAll(partitionIds);
          result.addAll(queryResult.getResult());
        }
      }
    }
    if (plist.size() == partitionCount) {
      return result;
    }
    List<Integer> missingList=new ArrayList<Integer>();
    for (int i=0; i < partitionCount; i++) {
      if (!plist.contains(i)) {
        missingList.add(i);
      }
    }
    List<Future> futures=new ArrayList<Future>(missingList.size());
    for (    Integer pid : missingList) {
      QueryPartitionOperation queryPartitionOperation=new QueryPartitionOperation(name,predicate);
      queryPartitionOperation.setPartitionId(pid);
      try {
        Future f=operationService.createInvocationBuilder(SERVICE_NAME,queryPartitionOperation,pid).build().invoke();
        futures.add(f);
      }
 catch (      Throwable t) {
        throw ExceptionUtil.rethrow(t);
      }
    }
    for (    Future future : futures) {
      QueryResult queryResult=(QueryResult)future.get();
      result.addAll(queryResult.getResult());
    }
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
 finally {
    result.end();
  }
  return result;
}","protected Set query(final Predicate predicate,final QueryResultStream.IterationType iterationType,final boolean dataResult){
  final NodeEngine nodeEngine=getNodeEngine();
  OperationService operationService=nodeEngine.getOperationService();
  Collection<MemberImpl> members=nodeEngine.getClusterService().getMemberList();
  int partitionCount=nodeEngine.getPartitionService().getPartitionCount();
  Set<Integer> plist=new HashSet<Integer>(partitionCount);
  QueryResultStream result=new QueryResultStream(nodeEngine.getSerializationService(),iterationType,dataResult,true);
  try {
    List<Future> flist=new ArrayList<Future>();
    for (    MemberImpl member : members) {
      Invocation invocation=operationService.createInvocationBuilder(SERVICE_NAME,new QueryOperation(name,predicate),member.getAddress()).build();
      Future future=invocation.invoke();
      flist.add(future);
    }
    for (    Future future : flist) {
      QueryResult queryResult=(QueryResult)future.get();
      if (queryResult != null) {
        final List<Integer> partitionIds=queryResult.getPartitionIds();
        if (partitionIds != null) {
          plist.addAll(partitionIds);
          result.addAll(queryResult.getResult());
        }
      }
    }
    if (plist.size() == partitionCount) {
      return result;
    }
    List<Integer> missingList=new ArrayList<Integer>();
    for (int i=0; i < partitionCount; i++) {
      if (!plist.contains(i)) {
        missingList.add(i);
      }
    }
    System.out.println(""String_Node_Str"" + missingList.size());
    List<Future> futures=new ArrayList<Future>(missingList.size());
    for (    Integer pid : missingList) {
      QueryPartitionOperation queryPartitionOperation=new QueryPartitionOperation(name,predicate);
      queryPartitionOperation.setPartitionId(pid);
      try {
        Future f=operationService.createInvocationBuilder(SERVICE_NAME,queryPartitionOperation,pid).build().invoke();
        futures.add(f);
      }
 catch (      Throwable t) {
        throw ExceptionUtil.rethrow(t);
      }
    }
    for (    Future future : futures) {
      QueryResult queryResult=(QueryResult)future.get();
      result.addAll(queryResult.getResult());
    }
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
 finally {
    result.end();
  }
  return result;
}",0.963219385547382
49330,"public final Future invoke(){
  if (invokeCount > 0) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (nodeEngine.operationService.isOperationThread() && (op instanceof PartitionAwareOperation) && !OperationAccessor.isMigrationOperation(op)) {
    throw new IllegalThreadStateException(Thread.currentThread() + ""String_Node_Str"" + op);
  }
  try {
    OperationAccessor.setCallTimeout(op,callTimeout);
    OperationAccessor.setCallerAddress(op,nodeEngine.getThisAddress());
    op.setNodeEngine(nodeEngine).setServiceName(serviceName).setPartitionId(partitionId).setReplicaIndex(replicaIndex);
    if (op.getCallerUuid() == null) {
      final ThreadContext threadContext=ThreadContext.get();
      if (threadContext != null) {
        op.setCallerUuid(threadContext.getCallerUuid());
      }
    }
    if (op.getCallerUuid() == null) {
      op.setCallerUuid(nodeEngine.getLocalMember().getUuid());
    }
    doInvoke();
  }
 catch (  Exception e) {
    if (e instanceof RetryableException) {
      notify(e);
    }
 else {
      throw ExceptionUtil.rethrow(e);
    }
  }
  return new InvocationFuture();
}","public final Future invoke(){
  if (invokeCount > 0) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (op.getCallId() != 0) {
    throw new IllegalStateException(""String_Node_Str"" + op + ""String_Node_Str"");
  }
  if (nodeEngine.operationService.isOperationThread() && (op instanceof PartitionAwareOperation) && !OperationAccessor.isMigrationOperation(op)) {
    throw new IllegalThreadStateException(Thread.currentThread() + ""String_Node_Str"" + op);
  }
  try {
    OperationAccessor.setCallTimeout(op,callTimeout);
    OperationAccessor.setCallerAddress(op,nodeEngine.getThisAddress());
    op.setNodeEngine(nodeEngine).setServiceName(serviceName).setPartitionId(partitionId).setReplicaIndex(replicaIndex);
    if (op.getCallerUuid() == null) {
      final ThreadContext threadContext=ThreadContext.get();
      if (threadContext != null) {
        op.setCallerUuid(threadContext.getCallerUuid());
      }
    }
    if (op.getCallerUuid() == null) {
      op.setCallerUuid(nodeEngine.getLocalMember().getUuid());
    }
    doInvoke();
  }
 catch (  Exception e) {
    if (e instanceof RetryableException) {
      notify(e);
    }
 else {
      throw ExceptionUtil.rethrow(e);
    }
  }
  return new InvocationFuture();
}",0.9517766497461928
49331,"@Test(timeout=20000) public void testLockEviction() throws Exception {
  final String mapName=""String_Node_Str"";
  final StaticNodeFactory nodeFactory=new StaticNodeFactory(2);
  final Config config=new Config();
  config.getMapConfig(mapName).setBackupCount(0);
  final HazelcastInstance instance1=nodeFactory.newHazelcastInstance(config);
  final HazelcastInstance instance2=nodeFactory.newHazelcastInstance(config);
  final AtomicInteger counter=new AtomicInteger(0);
  Thread.sleep(7000);
  final IMap map=instance1.getMap(mapName);
  long st=Clock.currentTimeMillis();
  map.lock(1,3,TimeUnit.SECONDS);
  if (!map.isLocked(1))   System.out.println(""String_Node_Str"");
  System.out.println(Clock.currentTimeMillis() - st);
}","public void testLockEviction() throws Exception {
  final String mapName=""String_Node_Str"";
  final StaticNodeFactory nodeFactory=new StaticNodeFactory(2);
  final Config config=new Config();
  config.getMapConfig(mapName).setBackupCount(1);
  final HazelcastInstance instance1=nodeFactory.newHazelcastInstance(config);
  final HazelcastInstance instance2=nodeFactory.newHazelcastInstance(config);
  final AtomicInteger counter=new AtomicInteger(0);
  final IMap map=instance1.getMap(mapName);
  map.put(1,1);
  long st=Clock.currentTimeMillis();
  map.lock(1,3,TimeUnit.SECONDS);
  Assert.assertEquals(true,map.isLocked(1));
  Thread t=new Thread(new Runnable(){
    public void run(){
      map.lock(1);
      counter.incrementAndGet();
    }
  }
);
  t.start();
  Thread.sleep(2000);
  Assert.assertEquals(0,counter.get());
  Thread.sleep(2000);
  Assert.assertEquals(1,counter.get());
}",0.73053152039555
49332,"/** 
 * test for issue #359
 */
@Test public void testIndexCleanupOnMigration() throws InterruptedException {
  Config cfg=new Config();
  final int n=6;
  final int runCount=500;
  final StaticNodeFactory nodeFactory=new StaticNodeFactory(n);
  HazelcastInstance instance=nodeFactory.newHazelcastInstance(cfg);
  final Config config=new Config();
  config.setProperty(GroupProperties.PROP_WAIT_SECONDS_BEFORE_JOIN,""String_Node_Str"");
  final String mapName=""String_Node_Str"";
  config.getMapConfig(mapName).addMapIndexConfig(new MapIndexConfig(""String_Node_Str"",false));
  ExecutorService ex=Executors.newFixedThreadPool(n);
  final CountDownLatch latch=new CountDownLatch(n);
  final AtomicInteger countdown=new AtomicInteger(n * runCount);
  final Random rand=new Random();
  for (int i=0; i < n; i++) {
    Thread.sleep(rand.nextInt((i + 1) * 100) + 10);
    ex.execute(new Runnable(){
      public void run(){
        final HazelcastInstance hz=nodeFactory.newHazelcastInstance(config);
        final String name=UUID.randomUUID().toString();
        final IMap<Object,Value> map=hz.getMap(mapName);
        map.put(name,new Value(name,0));
        try {
          for (int j=1; j <= runCount; j++) {
            Value v=map.get(name);
            v.setIndex(j);
            map.put(name,v);
            try {
              Thread.sleep(rand.nextInt(100) + 1);
            }
 catch (            InterruptedException e) {
              break;
            }
            EntryObject e=new PredicateBuilder().getEntryObject();
            Predicate<?,?> predicate=e.get(""String_Node_Str"").equal(name);
            final Collection<Value> values=map.values(predicate);
            assertEquals(1,values.size());
            Value v1=values.iterator().next();
            Value v2=map.get(name);
            assertEquals(v1,v2);
            countdown.decrementAndGet();
          }
        }
 catch (        AssertionError e) {
          e.printStackTrace();
        }
catch (        Throwable e) {
          System.err.println(e.getClass().getName() + ""String_Node_Str"" + e.getMessage());
        }
 finally {
          latch.countDown();
        }
      }
    }
);
  }
  try {
    assertTrue(latch.await(60,TimeUnit.SECONDS));
    assertEquals(0,countdown.get());
  }
  finally {
    ex.shutdownNow();
  }
}","/** 
 * test for issue #359
 */
@Test public void testIndexCleanupOnMigration() throws InterruptedException {
  Config cfg=new Config();
  final int n=6;
  final int runCount=500;
  final StaticNodeFactory nodeFactory=new StaticNodeFactory(n);
  final Config config=new Config();
  config.setProperty(GroupProperties.PROP_WAIT_SECONDS_BEFORE_JOIN,""String_Node_Str"");
  final String mapName=""String_Node_Str"";
  config.getMapConfig(mapName).addMapIndexConfig(new MapIndexConfig(""String_Node_Str"",false));
  ExecutorService ex=Executors.newFixedThreadPool(n);
  final CountDownLatch latch=new CountDownLatch(n);
  final AtomicInteger countdown=new AtomicInteger(n * runCount);
  final Random rand=new Random();
  for (int i=0; i < n; i++) {
    Thread.sleep(rand.nextInt((i + 1) * 100) + 10);
    ex.execute(new Runnable(){
      public void run(){
        final HazelcastInstance hz=nodeFactory.newHazelcastInstance(config);
        final String name=UUID.randomUUID().toString();
        final IMap<Object,Value> map=hz.getMap(mapName);
        map.put(name,new Value(name,0));
        try {
          for (int j=1; j <= runCount; j++) {
            Value v=map.get(name);
            v.setIndex(j);
            map.put(name,v);
            try {
              Thread.sleep(rand.nextInt(100) + 1);
            }
 catch (            InterruptedException e) {
              break;
            }
            EntryObject e=new PredicateBuilder().getEntryObject();
            Predicate<?,?> predicate=e.get(""String_Node_Str"").equal(name);
            final Collection<Value> values=map.values(predicate);
            assertEquals(1,values.size());
            Value v1=values.iterator().next();
            Value v2=map.get(name);
            assertEquals(v1,v2);
            countdown.decrementAndGet();
          }
        }
 catch (        AssertionError e) {
          e.printStackTrace();
        }
catch (        Throwable e) {
          System.err.println(e.getClass().getName() + ""String_Node_Str"" + e.getMessage());
        }
 finally {
          latch.countDown();
        }
      }
    }
);
  }
  try {
    assertTrue(latch.await(60,TimeUnit.SECONDS));
    assertEquals(0,countdown.get());
  }
  finally {
    ex.shutdownNow();
  }
}",0.9850483729111698
49333,"public void run() throws Exception {
  CollectionWrapper wrapper=getCollectionWrapper();
  if (wrapper == null || wrapper.getVersion() == version) {
    notify=false;
    return;
  }
  for (  Operation op : opList) {
    op.setNodeEngine(getNodeEngine()).setServiceName(getServiceName()).setPartitionId(getPartitionId());
    op.beforeRun();
    op.run();
    op.afterRun();
  }
  getOrCreateContainer().unlock(dataKey,getCallerUuid(),threadId);
}","public void run() throws Exception {
  CollectionWrapper wrapper=getCollectionWrapper();
  if (wrapper == null || wrapper.getVersion() != version) {
    notify=false;
    return;
  }
  wrapper.incrementAndGetVersion();
  for (  Operation op : opList) {
    op.setNodeEngine(getNodeEngine()).setServiceName(getServiceName()).setPartitionId(getPartitionId());
    op.beforeRun();
    op.run();
    op.afterRun();
  }
  getOrCreateContainer().unlock(dataKey,getCallerUuid(),threadId);
}",0.9591397849462364
49334,"public Operation prepareMigrationOperation(MigrationServiceEvent event){
  int replicaIndex=event.getReplicaIndex();
  CollectionPartitionContainer partitionContainer=partitionContainers[event.getPartitionId()];
  Map<CollectionProxyId,Map> map=new HashMap<CollectionProxyId,Map>(partitionContainer.containerMap.size());
  return new CollectionMigrationOperation(map);
}","public Operation prepareMigrationOperation(MigrationServiceEvent event){
  int replicaIndex=event.getReplicaIndex();
  CollectionPartitionContainer partitionContainer=partitionContainers[event.getPartitionId()];
  Map<CollectionProxyId,Map> map=new HashMap<CollectionProxyId,Map>(partitionContainer.containerMap.size());
  for (  Map.Entry<CollectionProxyId,CollectionContainer> entry : partitionContainer.containerMap.entrySet()) {
    CollectionProxyId proxyId=entry.getKey();
    CollectionContainer container=entry.getValue();
    if (container.config.getTotalBackupCount() < replicaIndex) {
      continue;
    }
    map.put(proxyId,container.collections);
  }
  if (map.isEmpty()) {
    return null;
  }
  return new CollectionMigrationOperation(map);
}",0.6554472984942427
49335,"@Override public void run(){
  try {
    if (isActive() && !completelyShutdown) {
      completelyShutdown=true;
      if (groupProperties.SHUTDOWNHOOK_ENABLED.getBoolean()) {
        shutdown(false,true);
      }
    }
 else {
      logger.log(Level.FINEST,""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    logger.log(Level.WARNING,e.getMessage(),e);
  }
}","@Override public void run(){
  try {
    if (isActive() && !completelyShutdown) {
      completelyShutdown=true;
      if (groupProperties.SHUTDOWNHOOK_ENABLED.getBoolean()) {
        shutdown(true,true);
      }
    }
 else {
      logger.log(Level.FINEST,""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    logger.log(Level.WARNING,e.getMessage(),e);
  }
}",0.9904240766073872
49336,"public MigrationInfo(int partitionId,int replicaIndex,MigrationType migrationType,Address from,Address to,int copyBackReplicaIndex){
  this.partitionId=partitionId;
  this.from=from;
  this.to=to;
  this.replicaIndex=replicaIndex;
  this.copyBackReplicaIndex=copyBackReplicaIndex;
  this.migrationType=migrationType;
}","public MigrationInfo(int partitionId,int replicaIndex,MigrationType migrationType,Address from,Address to){
  this.partitionId=partitionId;
  this.from=from;
  this.to=to;
  this.replicaIndex=replicaIndex;
  this.migrationType=migrationType;
}",0.8663101604278075
49337,"public void readData(ObjectDataInput in) throws IOException {
  partitionId=in.readInt();
  replicaIndex=in.readInt();
  copyBackReplicaIndex=in.readInt();
  migrationType=MigrationType.readFrom(in);
  boolean hasFrom=in.readBoolean();
  if (hasFrom) {
    from=new Address();
    from.readData(in);
  }
  to=new Address();
  to.readData(in);
}","public void readData(ObjectDataInput in) throws IOException {
  partitionId=in.readInt();
  replicaIndex=in.readInt();
  copyBackReplicaIndex=in.readInt();
  migrationType=MigrationType.readFrom(in);
  boolean hasFrom=in.readBoolean();
  if (hasFrom) {
    from=new Address();
    from.readData(in);
  }
  to=new Address();
  to.readData(in);
  master=new Address();
  master.readData(in);
}",0.9360544217687076
49338,"public void writeData(ObjectDataOutput out) throws IOException {
  out.writeInt(partitionId);
  out.writeInt(replicaIndex);
  out.writeInt(copyBackReplicaIndex);
  MigrationType.writeTo(migrationType,out);
  boolean hasFrom=from != null;
  out.writeBoolean(hasFrom);
  if (hasFrom) {
    from.writeData(out);
  }
  to.writeData(out);
}","public void writeData(ObjectDataOutput out) throws IOException {
  out.writeInt(partitionId);
  out.writeInt(replicaIndex);
  out.writeInt(copyBackReplicaIndex);
  MigrationType.writeTo(migrationType,out);
  boolean hasFrom=from != null;
  out.writeBoolean(hasFrom);
  if (hasFrom) {
    from.writeData(out);
  }
  to.writeData(out);
  master.writeData(out);
}",0.9640287769784172
49339,"@Override public String toString(){
  final StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(copyBackReplicaIndex);
  sb.append(""String_Node_Str"").append(partitionId);
  sb.append(""String_Node_Str"").append(from);
  sb.append(""String_Node_Str"").append(to);
  sb.append(""String_Node_Str"").append(replicaIndex);
  sb.append(""String_Node_Str"").append(migrationType);
  sb.append('}');
  return sb.toString();
}","@Override public String toString(){
  final StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(copyBackReplicaIndex);
  sb.append(""String_Node_Str"").append(partitionId);
  sb.append(""String_Node_Str"").append(from);
  sb.append(""String_Node_Str"").append(to);
  sb.append(""String_Node_Str"").append(replicaIndex);
  sb.append(""String_Node_Str"").append(migrationType);
  sb.append(""String_Node_Str"").append(master);
  sb.append('}');
  return sb.toString();
}",0.9518935516888434
49340,"public void run(){
  NodeEngine nodeEngine=getNodeEngine();
  SerializationService serializationService=nodeEngine.getSerializationService();
  ObjectDataInput in=null;
  try {
    final byte[] taskData=IOUtil.decompress(zippedTaskData);
    in=serializationService.createObjectDataInput(taskData);
    int size=in.readInt();
    tasks=new ArrayList<Operation>(size);
    for (int i=0; i < size; i++) {
      Operation task=(Operation)serializationService.readObject(in);
      tasks.add(task);
    }
    if (taskCount != tasks.size()) {
      getLogger().log(Level.SEVERE,""String_Node_Str"" + ""String_Node_Str"" + size + ""String_Node_Str""+ tasks.size()+ ""String_Node_Str""+ migrationInfo.getFromAddress()+ ""String_Node_Str""+ getPartitionId()+ ""String_Node_Str""+ getReplicaIndex());
    }
    success=runMigrationTasks();
  }
 catch (  Throwable e) {
    Level level=Level.WARNING;
    if (e instanceof IllegalStateException) {
      level=Level.FINEST;
    }
    getLogger().log(level,e.getMessage(),e);
    success=false;
  }
 finally {
    IOUtil.closeResource(in);
  }
}","public void run(){
  NodeEngine nodeEngine=getNodeEngine();
  SerializationService serializationService=nodeEngine.getSerializationService();
  ObjectDataInput in=null;
  if (migrationInfo.startProcessing()) {
    try {
      final byte[] taskData=IOUtil.decompress(zippedTaskData);
      in=serializationService.createObjectDataInput(taskData);
      int size=in.readInt();
      tasks=new ArrayList<Operation>(size);
      for (int i=0; i < size; i++) {
        Operation task=(Operation)serializationService.readObject(in);
        tasks.add(task);
      }
      if (taskCount != tasks.size()) {
        getLogger().log(Level.SEVERE,""String_Node_Str"" + ""String_Node_Str"" + size + ""String_Node_Str""+ tasks.size()+ ""String_Node_Str""+ migrationInfo.getFromAddress()+ ""String_Node_Str""+ getPartitionId()+ ""String_Node_Str""+ getReplicaIndex());
      }
      success=runMigrationTasks();
    }
 catch (    Throwable e) {
      Level level=Level.WARNING;
      if (e instanceof IllegalStateException) {
        level=Level.FINEST;
      }
      getLogger().log(level,e.getMessage(),e);
      success=false;
    }
 finally {
      migrationInfo.doneProcessing();
      IOUtil.closeResource(in);
    }
  }
 else {
    getLogger().log(Level.WARNING,""String_Node_Str"" + migrationInfo);
    success=false;
  }
}",0.9022746419545072
49341,"public SimpleMapTest(final int threadCount,final int entryCount,final int valueSize,final int getPercentage,final int putPercentage,final boolean load){
  this.threadCount=threadCount;
  this.entryCount=entryCount;
  this.valueSize=valueSize;
  this.getPercentage=getPercentage;
  this.putPercentage=putPercentage;
  this.load=load;
  Config cfg=new XmlConfigBuilder().build();
  cfg.getMapConfig(""String_Node_Str"").setRecordType(MapConfig.RecordType.DATA);
  cfg.getSerializationConfig().setPortableFactory(new PortableFactory(){
    public Portable create(    int classId){
      return new PortableByteArray();
    }
  }
);
  instance=Hazelcast.newHazelcastInstance(cfg);
  logger=instance.getLoggingService().getLogger(""String_Node_Str"");
}","public SimpleMapTest(final int threadCount,final int entryCount,final int valueSize,final int getPercentage,final int putPercentage,final boolean load){
  this.threadCount=threadCount;
  this.entryCount=entryCount;
  this.valueSize=valueSize;
  this.getPercentage=getPercentage;
  this.putPercentage=putPercentage;
  this.load=load;
  Config cfg=new XmlConfigBuilder().build();
  cfg.getNetworkConfig().getJoin().getMulticastConfig().setEnabled(false);
  cfg.getNetworkConfig().getJoin().getTcpIpConfig().setEnabled(true);
  cfg.getNetworkConfig().getJoin().getTcpIpConfig().addMember(""String_Node_Str"");
  cfg.getSerializationConfig().setPortableFactory(new PortableFactory(){
    public Portable create(    int classId){
      return new PortableByteArray();
    }
  }
);
  instance=Hazelcast.newHazelcastInstance(cfg);
  logger=instance.getLoggingService().getLogger(""String_Node_Str"");
}",0.8501529051987767
49342,"public void afterRun(){
  mapService.afterPut(name,dataValue);
  int eventType=dataOldValue == null ? EntryEvent.TYPE_ADDED : EntryEvent.TYPE_UPDATED;
  mapService.publishEvent(getCallerAddress(),name,eventType,dataKey,dataOldValue,dataValue);
  invalidateNearCaches();
  if (mapContainer.getMapConfig().isStatisticsEnabled()) {
    mapContainer.getMapOperationCounter().incrementPuts(Clock.currentTimeMillis() - getStartTime());
  }
}","public void afterRun(){
  mapService.interceptAfterPut(name,dataValue);
  int eventType=dataOldValue == null ? EntryEvent.TYPE_ADDED : EntryEvent.TYPE_UPDATED;
  mapService.publishEvent(getCallerAddress(),name,eventType,dataKey,dataOldValue,dataValue);
  invalidateNearCaches();
  if (mapContainer.getMapConfig().isStatisticsEnabled()) {
    mapContainer.getMapOperationCounter().incrementPuts(Clock.currentTimeMillis() - getStartTime());
  }
}",0.987485779294653
49343,"public void afterRun(){
  mapService.afterRemove(name,dataValue);
  int eventType=EntryEvent.TYPE_REMOVED;
  mapService.publishEvent(getCallerAddress(),name,eventType,dataKey,dataOldValue,null);
  invalidateNearCaches();
  if (mapContainer.getMapConfig().isStatisticsEnabled()) {
    mapContainer.getMapOperationCounter().incrementRemoves(Clock.currentTimeMillis() - getStartTime());
  }
}","public void afterRun(){
  mapService.interceptAfterRemove(name,dataValue);
  int eventType=EntryEvent.TYPE_REMOVED;
  mapService.publishEvent(getCallerAddress(),name,eventType,dataKey,dataOldValue,null);
  invalidateNearCaches();
  if (mapContainer.getMapConfig().isStatisticsEnabled()) {
    mapContainer.getMapOperationCounter().incrementRemoves(Clock.currentTimeMillis() - getStartTime());
  }
}",0.9860228716645488
49344,"public void run(){
  mapService=(MapService)getService();
  RecordStore recordStore=mapService.getRecordStore(getPartitionId(),name);
  Map.Entry<Data,Object> mapEntry=recordStore.getMapEntryObject(dataKey);
  NodeEngine nodeEngine=mapService.getNodeEngine();
  entry=new AbstractMap.SimpleEntry<Object,Object>(nodeEngine.toObject(dataKey),mapEntry.getValue());
  entryProcessor.processBackup(entry);
  recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,entry.getValue()));
}","public void run(){
  mapService=(MapService)getService();
  RecordStore recordStore=mapService.getRecordStore(getPartitionId(),name);
  Map.Entry<Data,Object> mapEntry=recordStore.getMapEntryObject(dataKey);
  NodeEngine nodeEngine=mapService.getNodeEngine();
  entry=new AbstractMap.SimpleEntry<Object,Object>(mapService.toObject(dataKey),mapEntry.getValue());
  entryProcessor.processBackup(entry);
  recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,entry.getValue()));
}",0.9819277108433736
49345,"public void run(){
  Map.Entry<Data,Object> mapEntry=recordStore.getMapEntryObject(dataKey);
  NodeEngine nodeEngine=mapService.getNodeEngine();
  entry=new AbstractMap.SimpleEntry(nodeEngine.toObject(dataKey),nodeEngine.toObject(mapEntry.getValue()));
  response=nodeEngine.toData(entryProcessor.process(entry));
  recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,entry.getValue()));
}","public void run(){
  Map.Entry<Data,Object> mapEntry=recordStore.getMapEntryObject(dataKey);
  NodeEngine nodeEngine=mapService.getNodeEngine();
  entry=new AbstractMap.SimpleEntry(mapService.toObject(dataKey),mapService.toObject(mapEntry.getValue()));
  response=mapService.toData(entryProcessor.process(entry));
  recordStore.put(new AbstractMap.SimpleImmutableEntry<Data,Object>(dataKey,entry.getValue()));
}",0.9343065693430656
49346,"public void afterRun(){
  mapService.afterRemove(name,dataValue);
  int eventType=EntryEvent.TYPE_EVICTED;
  mapService.publishEvent(getCallerAddress(),name,eventType,dataKey,dataValue,null);
  invalidateNearCaches();
}","public void afterRun(){
  mapService.interceptAfterRemove(name,dataValue);
  int eventType=EntryEvent.TYPE_EVICTED;
  mapService.publishEvent(getCallerAddress(),name,eventType,dataKey,dataValue,null);
  invalidateNearCaches();
}",0.9753914988814316
49347,"public void run(){
  MapService mapService=(MapService)getService();
  RecordStore recordStore=mapService.getRecordStore(getPartitionId(),name);
  Record record=recordStore.getRecords().get(dataKey);
  result=new SimpleEntryView(record.getKey(),getNodeEngine().toData(record.getValue()),record);
}","public void run(){
  MapService mapService=(MapService)getService();
  RecordStore recordStore=mapService.getRecordStore(getPartitionId(),name);
  Record record=recordStore.getRecords().get(dataKey);
  result=new SimpleEntryView(record.getKey(),mapService.toData(record.getValue()),record);
}",0.9575551782682512
49348,"public void afterRun(){
  mapService.afterGet(name,result);
  if (mapContainer.getMapConfig().isStatisticsEnabled()) {
    mapContainer.getMapOperationCounter().incrementGets(Clock.currentTimeMillis() - getStartTime());
  }
}","public void afterRun(){
  mapService.interceptAfterGet(name,result);
  if (mapContainer.getMapConfig().isStatisticsEnabled()) {
    mapContainer.getMapOperationCounter().incrementGets(Clock.currentTimeMillis() - getStartTime());
  }
}",0.9760348583877996
49349,"public Object toObject(Object data){
  if (data == null)   return null;
  if (data instanceof Data)   return nodeEngine.toObject(data);
 else   return data;
}","public Object toObject(Object data){
  if (data == null)   return null;
  if (data instanceof Data) {
    return nodeEngine.toObject(data);
  }
 else {
    return data;
  }
}",0.9518072289156626
49350,"public Data toData(Object object){
  if (object == null)   return null;
  if (object instanceof Data)   return (Data)object;
 else   return nodeEngine.toData(object);
}","public Data toData(Object object){
  if (object == null)   return null;
  if (object instanceof Data) {
    return (Data)object;
  }
 else {
    return nodeEngine.toData(object);
  }
}",0.9545454545454546
49351,"public void delete(Object k){
  final NodeEngine nodeEngine=getNodeEngine();
  final Data key=nodeEngine.toData(k);
  deleteInternal(key);
}","public void delete(Object k){
  final NodeEngine nodeEngine=getNodeEngine();
  final Data key=getService().toData(k);
  deleteInternal(key);
}",0.9432624113475178
49352,"public boolean remove(final Object k,final Object v){
  final NodeEngine nodeEngine=getNodeEngine();
  Data key=nodeEngine.toData(k);
  Data value=nodeEngine.toData(v);
  return removeInternal(key,value);
}","public boolean remove(final Object k,final Object v){
  Data key=getService().toData(k);
  Data value=getService().toData(v);
  return removeInternal(key,value);
}",0.7859078590785907
49353,"public boolean containsValue(final Object value){
  final NodeEngine nodeEngine=getNodeEngine();
  Data v=nodeEngine.toData(value);
  return containsValueInternal(v);
}","public boolean containsValue(final Object value){
  final NodeEngine nodeEngine=getNodeEngine();
  Data v=getService().toData(value);
  return containsValueInternal(v);
}",0.9526627218934912
49354,"public Data get(Object k){
  final NodeEngine nodeEngine=getNodeEngine();
  Data key=nodeEngine.toData(k);
  return getInternal(key);
}","public Data get(Object k){
  Data key=getService().toData(k);
  return getInternal(key);
}",0.72
49355,"@Override public EntryView<Data,Data> getEntryView(Data key){
  return getEntryViewInternal(getNodeEngine().toData(key));
}","@Override public EntryView<Data,Data> getEntryView(Data key){
  return getEntryViewInternal(getService().toData(key));
}",0.9547325102880658
49356,"public boolean containsKey(Object k){
  final NodeEngine nodeEngine=getNodeEngine();
  Data key=nodeEngine.toData(k);
  return containsKeyInternal(key);
}","public boolean containsKey(Object k){
  final NodeEngine nodeEngine=getNodeEngine();
  Data key=getService().toData(k);
  return containsKeyInternal(key);
}",0.9483870967741936
49357,"protected boolean containsKeyInternal(Data key){
  final NodeEngine nodeEngine=getNodeEngine();
  int partitionId=nodeEngine.getPartitionService().getPartitionId(key);
  ContainsKeyOperation containsKeyOperation=new ContainsKeyOperation(name,key);
  containsKeyOperation.setServiceName(SERVICE_NAME);
  try {
    Invocation invocation=nodeEngine.getOperationService().createInvocationBuilder(SERVICE_NAME,containsKeyOperation,partitionId).build();
    Future f=invocation.invoke();
    return (Boolean)nodeEngine.toObject(f.get());
  }
 catch (  Throwable t) {
    throw new RuntimeException(t);
  }
}","protected boolean containsKeyInternal(Data key){
  final NodeEngine nodeEngine=getNodeEngine();
  int partitionId=nodeEngine.getPartitionService().getPartitionId(key);
  ContainsKeyOperation containsKeyOperation=new ContainsKeyOperation(name,key);
  containsKeyOperation.setServiceName(SERVICE_NAME);
  try {
    Invocation invocation=nodeEngine.getOperationService().createInvocationBuilder(SERVICE_NAME,containsKeyOperation,partitionId).build();
    Future f=invocation.invoke();
    return (Boolean)getService().toObject(f.get());
  }
 catch (  Throwable t) {
    throw new RuntimeException(t);
  }
}",0.9817275747508306
49358,"protected Collection<Data> valuesInternal(){
  final NodeEngine nodeEngine=getNodeEngine();
  try {
    MapValuesOperation mapValuesOperation=new MapValuesOperation(name);
    Map<Integer,Object> results=nodeEngine.getOperationService().invokeOnAllPartitions(SERVICE_NAME,mapValuesOperation);
    List<Data> values=new ArrayList<Data>();
    for (    Object result : results.values()) {
      values.addAll(((MapValueCollection)nodeEngine.toObject(result)).getValues());
    }
    return values;
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}","protected Collection<Data> valuesInternal(){
  final NodeEngine nodeEngine=getNodeEngine();
  try {
    MapValuesOperation mapValuesOperation=new MapValuesOperation(name);
    Map<Integer,Object> results=nodeEngine.getOperationService().invokeOnAllPartitions(SERVICE_NAME,mapValuesOperation);
    List<Data> values=new ArrayList<Data>();
    for (    Object result : results.values()) {
      values.addAll(((MapValueCollection)getService().toObject(result)).getValues());
    }
    return values;
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}",0.980599647266314
49359,"public boolean containsValueInternal(Data dataValue){
  final NodeEngine nodeEngine=getNodeEngine();
  try {
    ContainsValueOperation containsValueOperation=new ContainsValueOperation(name,dataValue);
    Map<Integer,Object> results=nodeEngine.getOperationService().invokeOnAllPartitions(SERVICE_NAME,containsValueOperation);
    for (    Object result : results.values()) {
      Boolean contains=(Boolean)nodeEngine.toObject(result);
      if (contains)       return true;
    }
    return false;
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}","public boolean containsValueInternal(Data dataValue){
  final NodeEngine nodeEngine=getNodeEngine();
  try {
    ContainsValueOperation containsValueOperation=new ContainsValueOperation(name,dataValue);
    Map<Integer,Object> results=nodeEngine.getOperationService().invokeOnAllPartitions(SERVICE_NAME,containsValueOperation);
    for (    Object result : results.values()) {
      Boolean contains=(Boolean)getService().toObject(result);
      if (contains)       return true;
    }
    return false;
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}",0.9807692307692308
49360,"protected void putAllObjectInternal(final Map<? extends Object,? extends Object> m){
  final NodeEngine nodeEngine=getNodeEngine();
  for (  Entry<? extends Object,? extends Object> entry : m.entrySet()) {
    putInternal(nodeEngine.toData(entry.getKey()),nodeEngine.toData(entry.getValue()),-1,null);
  }
}","protected void putAllObjectInternal(final Map<? extends Object,? extends Object> m){
  final NodeEngine nodeEngine=getNodeEngine();
  for (  Entry<? extends Object,? extends Object> entry : m.entrySet()) {
    putInternal(getService().toData(entry.getKey()),getService().toData(entry.getValue()),-1,null);
  }
}",0.9288025889967636
49361,"public boolean isEmpty(){
  final NodeEngine nodeEngine=getNodeEngine();
  try {
    MapIsEmptyOperation mapIsEmptyOperation=new MapIsEmptyOperation(name);
    Map<Integer,Object> results=nodeEngine.getOperationService().invokeOnAllPartitions(SERVICE_NAME,mapIsEmptyOperation);
    for (    Object result : results.values()) {
      if (!(Boolean)nodeEngine.toObject(result))       return false;
    }
    return true;
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}","public boolean isEmpty(){
  final NodeEngine nodeEngine=getNodeEngine();
  try {
    MapIsEmptyOperation mapIsEmptyOperation=new MapIsEmptyOperation(name);
    Map<Integer,Object> results=nodeEngine.getOperationService().invokeOnAllPartitions(SERVICE_NAME,mapIsEmptyOperation);
    for (    Object result : results.values()) {
      if (!(Boolean)getService().toObject(result))       return false;
    }
    return true;
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}",0.9775510204081632
49362,"protected Data getInternal(Data key){
  final MapService mapService=getService();
  final boolean nearCacheEnabled=mapService.getMapContainer(name).isNearCacheEnabled();
  if (nearCacheEnabled) {
    Data cachedData=mapService.getFromNearCache(name,key);
    if (cachedData != null)     return cachedData;
  }
  GetOperation operation=new GetOperation(name,key);
  Data result=(Data)invokeOperation(key,operation);
  if (nearCacheEnabled) {
    final NodeEngine nodeEngine=getNodeEngine();
    int partitionId=nodeEngine.getPartitionService().getPartitionId(key);
    if (nodeEngine.getPartitionService().getPartitionOwner(partitionId).equals(nodeEngine.getClusterService().getThisAddress())) {
      mapService.putNearCache(name,key,result);
    }
  }
  return result;
}","protected Data getInternal(Data key){
  final MapService mapService=getService();
  final boolean nearCacheEnabled=mapService.getMapContainer(name).isNearCacheEnabled();
  if (nearCacheEnabled) {
    Data cachedData=mapService.getFromNearCache(name,key);
    if (cachedData != null) {
      return cachedData;
    }
  }
  GetOperation operation=new GetOperation(name,key);
  Data result=(Data)invokeOperation(key,operation);
  if (nearCacheEnabled) {
    final NodeEngine nodeEngine=getNodeEngine();
    int partitionId=nodeEngine.getPartitionService().getPartitionId(key);
    if (nodeEngine.getPartitionService().getPartitionOwner(partitionId).equals(nodeEngine.getClusterService().getThisAddress())) {
      mapService.putNearCache(name,key,result);
    }
  }
  return result;
}",0.993556701030928
49363,"protected Set<Entry<Data,Data>> entrySetInternal(){
  final NodeEngine nodeEngine=getNodeEngine();
  try {
    MapEntrySetOperation mapEntrySetOperation=new MapEntrySetOperation(name);
    Map<Integer,Object> results=nodeEngine.getOperationService().invokeOnAllPartitions(SERVICE_NAME,mapEntrySetOperation);
    Set<Entry<Data,Data>> entrySet=new HashSet<Entry<Data,Data>>();
    for (    Object result : results.values()) {
      Set entries=((MapEntrySet)nodeEngine.toObject(result)).getEntrySet();
      if (entries != null)       entrySet.addAll(entries);
    }
    return entrySet;
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}","protected Set<Entry<Data,Data>> entrySetInternal(){
  final NodeEngine nodeEngine=getNodeEngine();
  try {
    MapEntrySetOperation mapEntrySetOperation=new MapEntrySetOperation(name);
    Map<Integer,Object> results=nodeEngine.getOperationService().invokeOnAllPartitions(SERVICE_NAME,mapEntrySetOperation);
    Set<Entry<Data,Data>> entrySet=new HashSet<Entry<Data,Data>>();
    for (    Object result : results.values()) {
      Set entries=((MapEntrySet)getService().toObject(result)).getEntrySet();
      if (entries != null)       entrySet.addAll(entries);
    }
    return entrySet;
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}",0.9832826747720363
49364,"public int size(){
  final NodeEngine nodeEngine=getNodeEngine();
  try {
    MapSizeOperation mapSizeOperation=new MapSizeOperation(name);
    Map<Integer,Object> results=nodeEngine.getOperationService().invokeOnAllPartitions(SERVICE_NAME,mapSizeOperation);
    int total=0;
    for (    Object result : results.values()) {
      Integer size=(Integer)nodeEngine.toObject(result);
      total+=size;
    }
    return total;
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}","public int size(){
  final NodeEngine nodeEngine=getNodeEngine();
  try {
    MapSizeOperation mapSizeOperation=new MapSizeOperation(name);
    Map<Integer,Object> results=nodeEngine.getOperationService().invokeOnAllPartitions(SERVICE_NAME,mapSizeOperation);
    int total=0;
    for (    Object result : results.values()) {
      Integer size=(Integer)getService().toObject(result);
      total+=size;
    }
    return total;
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}",0.9778225806451613
49365,"protected Map<Object,Object> getAllObjectInternal(final Set<Data> keys){
  final NodeEngine nodeEngine=getNodeEngine();
  Map<Object,Object> res=new HashMap(keys.size());
  for (  Data key : keys) {
    res.put(nodeEngine.toObject(key),nodeEngine.toObject(getInternal(key)));
  }
  return res;
}","protected Map<Object,Object> getAllObjectInternal(final Set<Data> keys){
  final NodeEngine nodeEngine=getNodeEngine();
  Map<Object,Object> res=new HashMap(keys.size());
  for (  Data key : keys) {
    res.put(getService().toObject(key),getService().toObject(getInternal(key)));
  }
  return res;
}",0.925925925925926
49366,"protected Set<Data> keySetInternal(){
  final NodeEngine nodeEngine=getNodeEngine();
  try {
    MapKeySetOperation mapKeySetOperation=new MapKeySetOperation(name);
    Map<Integer,Object> results=nodeEngine.getOperationService().invokeOnAllPartitions(SERVICE_NAME,mapKeySetOperation);
    Set<Data> keySet=new HashSet<Data>();
    for (    Object result : results.values()) {
      Set keys=((MapKeySet)nodeEngine.toObject(result)).getKeySet();
      keySet.addAll(keys);
    }
    return keySet;
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}","protected Set<Data> keySetInternal(){
  final NodeEngine nodeEngine=getNodeEngine();
  try {
    MapKeySetOperation mapKeySetOperation=new MapKeySetOperation(name);
    Map<Integer,Object> results=nodeEngine.getOperationService().invokeOnAllPartitions(SERVICE_NAME,mapKeySetOperation);
    Set<Data> keySet=new HashSet<Data>();
    for (    Object result : results.values()) {
      Set keys=((MapKeySet)getService().toObject(result)).getKeySet();
      keySet.addAll(keys);
    }
    return keySet;
  }
 catch (  Throwable t) {
    throw ExceptionUtil.rethrow(t);
  }
}",0.9806678383128296
49367,"protected EntryView getEntryViewInternal(final Data key){
  final NodeEngine nodeEngine=getNodeEngine();
  int partitionId=nodeEngine.getPartitionService().getPartitionId(key);
  GetEntryViewOperation getEntryViewOperation=new GetEntryViewOperation(name,key);
  getEntryViewOperation.setServiceName(SERVICE_NAME);
  try {
    Invocation invocation=nodeEngine.getOperationService().createInvocationBuilder(SERVICE_NAME,getEntryViewOperation,partitionId).build();
    Future f=invocation.invoke();
    Object o=nodeEngine.toObject(f.get());
    return (EntryView)o;
  }
 catch (  Throwable t) {
    throw new RuntimeException(t);
  }
}","protected EntryView getEntryViewInternal(final Data key){
  final NodeEngine nodeEngine=getNodeEngine();
  int partitionId=nodeEngine.getPartitionService().getPartitionId(key);
  GetEntryViewOperation getEntryViewOperation=new GetEntryViewOperation(name,key);
  getEntryViewOperation.setServiceName(SERVICE_NAME);
  try {
    Invocation invocation=nodeEngine.getOperationService().createInvocationBuilder(SERVICE_NAME,getEntryViewOperation,partitionId).build();
    Future f=invocation.invoke();
    Object o=getService().toObject(f.get());
    return (EntryView)o;
  }
 catch (  Throwable t) {
    throw new RuntimeException(t);
  }
}",0.9826498422712934
49368,"protected void readInternal(final ObjectDataInput in) throws IOException {
  super.readInternal(in);
  int len=in.readInt();
  if (len > 0) {
    LockStoreImpl ls=new LockStoreImpl();
    ls.readData(in);
    locks.add(ls);
  }
}","protected void readInternal(final ObjectDataInput in) throws IOException {
  super.readInternal(in);
  int len=in.readInt();
  if (len > 0) {
    for (int i=0; i < len; i++) {
      LockStoreImpl ls=new LockStoreImpl();
      ls.readData(in);
      locks.add(ls);
    }
  }
}",0.9087301587301588
49369,"public Operation prepareMigrationOperation(MigrationServiceEvent event){
  Map<String,QueueContainer> migrationData=new HashMap<String,QueueContainer>();
  for (  Entry<String,QueueContainer> entry : containerMap.entrySet()) {
    String name=entry.getKey();
    QueueContainer container=entry.getValue();
    if (container.getPartitionId() == event.getPartitionId() && container.getConfig().getTotalBackupCount() >= event.getReplicaIndex()) {
      migrationData.put(name,container);
    }
  }
  return new QueueMigrationOperation(migrationData,event.getPartitionId(),event.getReplicaIndex());
}","public Operation prepareMigrationOperation(MigrationServiceEvent event){
  Map<String,QueueContainer> migrationData=new HashMap<String,QueueContainer>();
  for (  Entry<String,QueueContainer> entry : containerMap.entrySet()) {
    String name=entry.getKey();
    QueueContainer container=entry.getValue();
    if (container.getPartitionId() == event.getPartitionId() && container.getConfig().getTotalBackupCount() >= event.getReplicaIndex()) {
      migrationData.put(name,container);
    }
  }
  return migrationData.isEmpty() ? null : new QueueMigrationOperation(migrationData,event.getPartitionId(),event.getReplicaIndex());
}",0.973061224489796
49370,"public void run(){
  final ConcurrentMap<K,ScheduledEntry<K,V>> entries=scheduledEntries.remove(second);
  if (entries == null || entries.isEmpty())   return;
  for (  K key : entries.keySet()) {
    secondsOfKeys.remove(key);
  }
  entryProcessor.process(SecondsBasedEntryTaskScheduler.this,entries.values());
}","public void run(){
  final ConcurrentMap<K,ScheduledEntry<K,V>> entries=scheduledEntries.remove(second);
  if (entries == null || entries.isEmpty())   return;
  Set<ScheduledEntry<K,V>> values=new HashSet<ScheduledEntry<K,V>>(entries.size());
  for (  K key : entries.keySet()) {
    Integer removed=secondsOfKeys.remove(key);
    if (removed != null) {
      values.add(entries.get(key));
    }
  }
  entryProcessor.process(SecondsBasedEntryTaskScheduler.this,values);
}",0.756066411238825
49371,"public <T>T executeTransaction(TransactionalTask<T> task) throws TransactionException {
  return null;
}","public <T>T executeTransaction(TransactionalTask<T> task,TransactionOptions options) throws TransactionException {
  return null;
}",0.8851063829787233
49372,<T>T executeTransaction(TransactionalTask<T> task) throws TransactionException ;,"<T>T executeTransaction(TransactionalTask<T> task,TransactionOptions options) throws TransactionException ;",0.8556149732620321
49373,"public <T>T executeTransaction(TransactionalTask<T> task) throws TransactionException {
  return node.nodeEngine.getTransactionManagerService().executeTransaction(task);
}","public <T>T executeTransaction(TransactionalTask<T> task,TransactionOptions options) throws TransactionException {
  return node.nodeEngine.getTransactionManagerService().executeTransaction(task,options);
}",0.9071618037135278
49374,"public <T>T executeTransaction(TransactionalTask<T> task) throws TransactionException {
  return getOriginal().executeTransaction(task);
}","public <T>T executeTransaction(TransactionalTask<T> task,TransactionOptions options) throws TransactionException {
  return getOriginal().executeTransaction(task,options);
}",0.887459807073955
49375,"public TransactionContextImpl(NodeEngineImpl nodeEngine){
  this.nodeEngine=nodeEngine;
  this.transaction=new TransactionImpl(this.nodeEngine);
}","public TransactionContextImpl(NodeEngineImpl nodeEngine,TransactionOptions options){
  this.nodeEngine=nodeEngine;
  this.transaction=new TransactionImpl(this.nodeEngine,options.getTimeoutMillis());
}",0.8439306358381503
49376,"void rollback() throws IllegalStateException {
  if (state == NO_TXN || state == ROLLED_BACK) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  state=ROLLING_BACK;
  try {
    List<Future> futures=new ArrayList<Future>(partitions.size());
    for (    Integer partitionId : partitions) {
      RollbackOperation op=new RollbackOperation(txnId);
      futures.add(nodeEngine.getOperationService().createInvocationBuilder(SERVICE_NAME,op,partitionId).build().invoke());
    }
    for (    Future future : futures) {
      future.get(timeoutMillis,TimeUnit.MILLISECONDS);
    }
  }
 catch (  Throwable e) {
    throw ExceptionUtil.rethrow(e);
  }
 finally {
    state=ROLLED_BACK;
  }
}","void rollback() throws IllegalStateException {
  if (state == NO_TXN || state == ROLLED_BACK) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  state=ROLLING_BACK;
  try {
    List<Future> futures=new ArrayList<Future>(partitions.size());
    for (    Integer partitionId : partitions) {
      RollbackOperation op=new RollbackOperation(txnId);
      futures.add(nodeEngine.getOperationService().createInvocationBuilder(SERVICE_NAME,op,partitionId).build().invoke());
    }
    for (    Future future : futures) {
      future.get(5,TimeUnit.MINUTES);
    }
  }
 catch (  Throwable e) {
    throw ExceptionUtil.rethrow(e);
  }
 finally {
    state=ROLLED_BACK;
  }
}",0.9818445896877268
49377,"void commit() throws TransactionException, IllegalStateException {
  if (state != ACTIVE) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  checkTimeout();
  try {
    state=PREPARING;
    final List<Future> futures=new ArrayList<Future>(partitions.size());
    final OperationService operationService=nodeEngine.getOperationService();
    for (    Integer partitionId : partitions) {
      PrepareOperation op=new PrepareOperation(txnId);
      futures.add(operationService.createInvocationBuilder(SERVICE_NAME,op,partitionId).build().invoke());
    }
    for (    Future future : futures) {
      future.get(timeoutMillis,TimeUnit.MILLISECONDS);
    }
    state=PREPARED;
    futures.clear();
    state=COMMITTING;
    for (    Integer partitionId : partitions) {
      CommitOperation op=new CommitOperation(txnId);
      futures.add(operationService.createInvocationBuilder(SERVICE_NAME,op,partitionId).build().invoke());
    }
    for (    Future future : futures) {
      future.get(timeoutMillis,TimeUnit.MILLISECONDS);
    }
    state=COMMITTED;
  }
 catch (  Throwable e) {
    state=COMMIT_FAILED;
    if (e instanceof ExecutionException && e.getCause() instanceof TransactionException) {
      throw (TransactionException)e.getCause();
    }
    throw ExceptionUtil.rethrow(e);
  }
}","void commit() throws TransactionException, IllegalStateException {
  if (state != ACTIVE) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  checkTimeout();
  try {
    state=PREPARING;
    final List<Future> futures=new ArrayList<Future>(partitions.size());
    final OperationService operationService=nodeEngine.getOperationService();
    for (    Integer partitionId : partitions) {
      PrepareOperation op=new PrepareOperation(txnId);
      futures.add(operationService.createInvocationBuilder(SERVICE_NAME,op,partitionId).build().invoke());
    }
    for (    Future future : futures) {
      future.get(timeoutMillis,TimeUnit.MILLISECONDS);
    }
    state=PREPARED;
    futures.clear();
    state=COMMITTING;
    for (    Integer partitionId : partitions) {
      CommitOperation op=new CommitOperation(txnId);
      futures.add(operationService.createInvocationBuilder(SERVICE_NAME,op,partitionId).build().invoke());
    }
    for (    Future future : futures) {
      future.get(5,TimeUnit.MINUTES);
    }
    state=COMMITTED;
  }
 catch (  Throwable e) {
    state=COMMIT_FAILED;
    if (e instanceof ExecutionException && e.getCause() instanceof TransactionException) {
      throw (TransactionException)e.getCause();
    }
    throw ExceptionUtil.rethrow(e);
  }
}",0.9842247018083878
49378,"public TransactionImpl(NodeEngine nodeEngine){
  this.nodeEngine=nodeEngine;
}","public TransactionImpl(NodeEngine nodeEngine,long timeoutMillis){
  this.nodeEngine=nodeEngine;
  this.timeoutMillis=timeoutMillis;
}",0.7393364928909952
49379,<T>T executeTransaction(TransactionalTask<T> task) throws TransactionException ;,"<T>T executeTransaction(TransactionalTask<T> task,TransactionOptions options) throws TransactionException ;",0.8556149732620321
49380,"public void prepare(String caller,String txnId,int partitionId) throws TransactionException {
  final TransactionKey key=new TransactionKey(txnId,partitionId);
  final TransactionLog log=txLogs.get(key);
  if (log == null) {
    throw new TransactionException(""String_Node_Str"");
  }
  if (!log.beginProcess()) {
    throw new TransactionException(""String_Node_Str"");
  }
  try {
    log.setCallerUuid(caller);
    log.setState(Transaction.State.PREPARED);
    for (    TransactionalOperation op : log.getOperationRecords()) {
      op.doPrepare();
    }
    scheduler.schedule(ONE_MIN_MS * 2,key,DUMMY_OBJECT);
    log.setScheduled(true);
  }
  finally {
    log.endProcess();
  }
}","void prepare(String caller,String txnId,int partitionId) throws TransactionException {
  final TransactionKey key=new TransactionKey(txnId,partitionId);
  final TransactionLog log=txLogs.get(key);
  if (log == null) {
    throw new TransactionException(""String_Node_Str"");
  }
  if (!log.beginProcess()) {
    throw new TransactionException(""String_Node_Str"");
  }
  try {
    log.setCallerUuid(caller);
    log.setState(Transaction.State.PREPARED);
    for (    TransactionalOperation op : log.getOperationRecords()) {
      op.doPrepare();
    }
    scheduler.schedule(ONE_MIN_MS * 2,key,DUMMY_OBJECT);
    log.setScheduled(true);
  }
  finally {
    log.endProcess();
  }
}",0.9948491537895512
49381,"public void commit(String caller,String txnId,int partitionId) throws TransactionException {
  final TransactionKey key=new TransactionKey(txnId,partitionId);
  final TransactionLog log=txLogs.get(key);
  if (log == null) {
    throw new TransactionException(""String_Node_Str"");
  }
  if (!log.beginProcess()) {
    throw new TransactionException(""String_Node_Str"");
  }
  try {
    log.setCallerUuid(caller);
    log.setState(Transaction.State.COMMITTED);
    commitTransactionLog(log);
    scheduler.schedule(ONE_MIN_MS,key,DUMMY_OBJECT);
    log.setScheduled(true);
  }
  finally {
    log.endProcess();
  }
}","void commit(String caller,String txnId,int partitionId) throws TransactionException {
  final TransactionKey key=new TransactionKey(txnId,partitionId);
  final TransactionLog log=txLogs.get(key);
  if (log == null) {
    throw new TransactionException(""String_Node_Str"");
  }
  if (!log.beginProcess()) {
    throw new TransactionException(""String_Node_Str"");
  }
  try {
    log.setCallerUuid(caller);
    log.setState(Transaction.State.COMMITTED);
    commitTransactionLog(log);
    scheduler.schedule(ONE_MIN_MS,key,DUMMY_OBJECT);
    log.setScheduled(true);
  }
  finally {
    log.endProcess();
  }
}",0.9942481511914544
49382,"public <T>T executeTransaction(TransactionalTask<T> task) throws TransactionException {
  final TransactionContextImpl context=new TransactionContextImpl(nodeEngine);
  context.beginTransaction();
  try {
    final T value=task.execute(context);
    context.commitTransaction();
    return value;
  }
 catch (  Throwable e) {
    context.rollbackTransaction();
    if (e instanceof TransactionException) {
      throw (TransactionException)e;
    }
    if (e.getCause() instanceof TransactionException) {
      throw (TransactionException)e.getCause();
    }
    throw new TransactionException(e);
  }
}","public <T>T executeTransaction(TransactionalTask<T> task,TransactionOptions options) throws TransactionException {
  final TransactionContextImpl context=new TransactionContextImpl(nodeEngine,options);
  context.beginTransaction();
  try {
    final T value=task.execute(context);
    context.commitTransaction();
    return value;
  }
 catch (  Throwable e) {
    context.rollbackTransaction();
    if (e instanceof TransactionException) {
      throw (TransactionException)e;
    }
    if (e.getCause() instanceof TransactionException) {
      throw (TransactionException)e.getCause();
    }
    throw new TransactionException(e);
  }
}",0.9717969379532636
49383,"public void rollback(String caller,String txnId,int partitionId) throws TransactionException {
  final TransactionKey key=new TransactionKey(txnId,partitionId);
  final TransactionLog log=txLogs.get(key);
  if (log == null) {
    throw new TransactionException(""String_Node_Str"");
  }
  if (!log.beginProcess()) {
    throw new TransactionException(""String_Node_Str"");
  }
  try {
    log.setCallerUuid(caller);
    log.setState(Transaction.State.ROLLED_BACK);
    rollbackTransactionLog(log);
    scheduler.schedule(ONE_MIN_MS,key,DUMMY_OBJECT);
    log.setScheduled(true);
  }
  finally {
    log.endProcess();
  }
}","void rollback(String caller,String txnId,int partitionId) throws TransactionException {
  final TransactionKey key=new TransactionKey(txnId,partitionId);
  final TransactionLog log=txLogs.get(key);
  if (log == null) {
    logger.log(Level.WARNING,""String_Node_Str"");
    return;
  }
  if (!log.beginProcess()) {
    throw new TransactionException(""String_Node_Str"");
  }
  try {
    log.setCallerUuid(caller);
    log.setState(Transaction.State.ROLLED_BACK);
    rollbackTransactionLog(log);
    scheduler.schedule(ONE_MIN_MS,key,DUMMY_OBJECT);
    log.setScheduled(true);
  }
  finally {
    log.endProcess();
  }
}",0.9392712550607288
49384,"public final void beforeRun() throws Exception {
  if (state == Transaction.State.ACTIVE) {
    innerBeforeRun();
  }
}","public final void beforeRun() throws Exception {
  if (state == Transaction.State.ACTIVE) {
    final TransactionManagerServiceImpl txService=(TransactionManagerServiceImpl)getNodeEngine().getTransactionManagerService();
    txService.addTransactionalOperation(getPartitionId(),this);
    innerBeforeRun();
  }
}",0.5522041763341067
49385,"public final void run() throws Exception {
switch (state) {
case ACTIVE:
    process();
  addTransactionRecord();
break;
case PREPARED:
prepare();
break;
case COMMITTED:
commit();
break;
case ROLLED_BACK:
rollback();
break;
default :
throw new IllegalStateException();
}
}","public final void run() throws Exception {
switch (state) {
case ACTIVE:
    process();
  break;
case PREPARED:
prepare();
break;
case COMMITTED:
commit();
break;
case ROLLED_BACK:
rollback();
break;
default :
throw new IllegalStateException();
}
}",0.953846153846154
49386,"@Test public void testTxnCommit() throws TransactionException {
  Config config=new Config();
  StaticNodeFactory factory=new StaticNodeFactory(2);
  HazelcastInstance h1=factory.newHazelcastInstance(config);
  HazelcastInstance h2=factory.newHazelcastInstance(config);
  final IMap map2=h2.getMap(""String_Node_Str"");
  boolean b=h1.executeTransaction(new TransactionalTask<Boolean>(){
    public Boolean execute(    TransactionContext context) throws TransactionException {
      final TransactionalMap<Object,Object> txMap=context.getMap(""String_Node_Str"");
      txMap.put(""String_Node_Str"",""String_Node_Str"");
      txMap.put(""String_Node_Str"",""String_Node_Str"");
      txMap.put(""String_Node_Str"",""String_Node_Str"");
      txMap.put(""String_Node_Str"",""String_Node_Str"");
      txMap.set(""String_Node_Str"",""String_Node_Str"");
      assertEquals(""String_Node_Str"",txMap.get(""String_Node_Str""));
      assertEquals(""String_Node_Str"",txMap.get(""String_Node_Str""));
      assertEquals(""String_Node_Str"",txMap.get(""String_Node_Str""));
      assertNull(map2.get(""String_Node_Str""));
      assertNull(map2.get(""String_Node_Str""));
      assertNull(map2.get(""String_Node_Str""));
      return true;
    }
  }
);
  assertTrue(b);
  IMap map1=h1.getMap(""String_Node_Str"");
  assertEquals(""String_Node_Str"",map1.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map1.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map1.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map2.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map2.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map2.get(""String_Node_Str""));
}","@Test public void testTxnCommit() throws TransactionException {
  Config config=new Config();
  StaticNodeFactory factory=new StaticNodeFactory(2);
  HazelcastInstance h1=factory.newHazelcastInstance(config);
  HazelcastInstance h2=factory.newHazelcastInstance(config);
  final IMap map2=h2.getMap(""String_Node_Str"");
  boolean b=h1.executeTransaction(new TransactionalTask<Boolean>(){
    public Boolean execute(    TransactionContext context) throws TransactionException {
      final TransactionalMap<Object,Object> txMap=context.getMap(""String_Node_Str"");
      txMap.put(""String_Node_Str"",""String_Node_Str"");
      txMap.put(""String_Node_Str"",""String_Node_Str"");
      txMap.put(""String_Node_Str"",""String_Node_Str"");
      txMap.put(""String_Node_Str"",""String_Node_Str"");
      txMap.set(""String_Node_Str"",""String_Node_Str"");
      assertEquals(""String_Node_Str"",txMap.get(""String_Node_Str""));
      assertEquals(""String_Node_Str"",txMap.get(""String_Node_Str""));
      assertEquals(""String_Node_Str"",txMap.get(""String_Node_Str""));
      assertNull(map2.get(""String_Node_Str""));
      assertNull(map2.get(""String_Node_Str""));
      assertNull(map2.get(""String_Node_Str""));
      return true;
    }
  }
,new TransactionOptions().setTimeout(1,TimeUnit.SECONDS));
  assertTrue(b);
  IMap map1=h1.getMap(""String_Node_Str"");
  assertEquals(""String_Node_Str"",map1.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map1.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map1.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map2.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map2.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map2.get(""String_Node_Str""));
}",0.9832635983263598
49387,"private boolean checkLimits(MapContainer mapContainer){
  MaxSizeConfig maxSizeConfig=mapContainer.getMapConfig().getMaxSizeConfig();
  MaxSizeConfig.MaxSizePolicy maxSizePolicy=maxSizeConfig.getMaxSizePolicy();
  String mapName=mapContainer.getName();
  if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_NODE || maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_PARTITION) {
    int totalSize=0;
    for (int i=0; i < nodeEngine.getPartitionService().getPartitionCount(); i++) {
      Address owner=nodeEngine.getPartitionService().getPartitionOwner(i);
      if (nodeEngine.getThisAddress().equals(owner)) {
        int size=partitionContainers[i].getRecordStore(mapName).getRecords().size();
        if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_PARTITION) {
          if (size >= maxSizeConfig.getSize())           return true;
        }
 else {
          totalSize+=size;
        }
      }
    }
    if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_NODE)     return totalSize >= maxSizeConfig.getSize();
 else     return false;
  }
  if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.USED_HEAP_SIZE || maxSizePolicy == MaxSizeConfig.MaxSizePolicy.USED_HEAP_PERCENTAGE) {
    long total=Runtime.getRuntime().totalMemory();
    long used=(total - Runtime.getRuntime().freeMemory());
    if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.USED_HEAP_SIZE) {
      return maxSizeConfig.getSize() > (used / 1024 / 1024);
    }
 else {
      return maxSizeConfig.getSize() > (used / total);
    }
  }
  return false;
}","private boolean checkLimits(MapContainer mapContainer){
  MaxSizeConfig maxSizeConfig=mapContainer.getMapConfig().getMaxSizeConfig();
  MaxSizeConfig.MaxSizePolicy maxSizePolicy=maxSizeConfig.getMaxSizePolicy();
  String mapName=mapContainer.getName();
  int maxSize=maxSizeConfig.getSize() * 95 / 100;
  if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_NODE || maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_PARTITION) {
    int totalSize=0;
    for (int i=0; i < nodeEngine.getPartitionService().getPartitionCount(); i++) {
      Address owner=nodeEngine.getPartitionService().getPartitionOwner(i);
      if (nodeEngine.getThisAddress().equals(owner)) {
        int size=partitionContainers[i].getRecordStore(mapName).getRecords().size();
        if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_PARTITION) {
          if (size >= maxSize)           return true;
        }
 else {
          totalSize+=size;
        }
      }
    }
    if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_NODE)     return totalSize >= maxSize;
 else     return false;
  }
  if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.USED_HEAP_SIZE || maxSizePolicy == MaxSizeConfig.MaxSizePolicy.USED_HEAP_PERCENTAGE) {
    long total=Runtime.getRuntime().totalMemory();
    long used=(total - Runtime.getRuntime().freeMemory());
    if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.USED_HEAP_SIZE) {
      return maxSize > (used / 1024 / 1024);
    }
 else {
      return maxSize > (used / total);
    }
  }
  return false;
}",0.9624753127057276
49388,"public void run(){
  for (int i=0; i < nodeEngine.getPartitionService().getPartitionCount(); i++) {
    if ((i % ExecutorConfig.DEFAULT_POOL_SIZE) != mod) {
      continue;
    }
    Address owner=nodeEngine.getPartitionService().getPartitionOwner(i);
    if (nodeEngine.getThisAddress().equals(owner)) {
      PartitionContainer pc=partitionContainers[i];
      final RecordStore recordStore=pc.getRecordStore(mapName);
      SortedSet sortedRecords=new TreeSet(comparator);
      Set<Map.Entry<Data,Record>> recordEntries=recordStore.getRecords().entrySet();
      for (      Map.Entry<Data,Record> entry : recordEntries) {
        sortedRecords.add(entry.getValue());
      }
      int evictSize=0;
      if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_NODE || maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_PARTITION) {
        evictSize=sortedRecords.size() - targetSizePerPartition;
      }
 else {
        evictSize=sortedRecords.size() * evictionPercentage / 100;
      }
      if (evictSize == 0)       continue;
      Set<Data> keySet=new HashSet();
      Iterator iterator=sortedRecords.iterator();
      while (iterator.hasNext() && evictSize-- > 0) {
        Record rec=(Record)iterator.next();
        keySet.add(rec.getKey());
      }
      ClearOperation clearOperation=new ClearOperation(mapName,keySet);
      clearOperation.setNodeEngine(nodeEngine);
      clearOperation.setServiceName(SERVICE_NAME);
      clearOperation.setResponseHandler(ResponseHandlerFactory.createEmptyResponseHandler());
      clearOperation.setPartitionId(i);
      nodeEngine.getOperationService().runOperation(clearOperation);
    }
  }
}","public void run(){
  for (int i=0; i < nodeEngine.getPartitionService().getPartitionCount(); i++) {
    if ((i % ExecutorConfig.DEFAULT_POOL_SIZE) != mod) {
      continue;
    }
    Address owner=nodeEngine.getPartitionService().getPartitionOwner(i);
    if (nodeEngine.getThisAddress().equals(owner)) {
      PartitionContainer pc=partitionContainers[i];
      final RecordStore recordStore=pc.getRecordStore(mapName);
      List<Record> sortedRecords=new ArrayList<Record>(recordStore.getRecords().values());
      Collections.sort(sortedRecords,comparator);
      int evictSize=0;
      if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_NODE || maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_PARTITION) {
        evictSize=Math.max((sortedRecords.size() - targetSizePerPartition),(sortedRecords.size() * evictionPercentage / 100 + 1));
      }
 else {
        evictSize=sortedRecords.size() * evictionPercentage / 100;
      }
      if (evictSize == 0)       continue;
      Set<Data> keySet=new HashSet();
      Iterator iterator=sortedRecords.iterator();
      while (iterator.hasNext() && evictSize-- > 0) {
        Record rec=(Record)iterator.next();
        keySet.add(rec.getKey());
      }
      ClearOperation clearOperation=new ClearOperation(mapName,keySet);
      clearOperation.setNodeEngine(nodeEngine);
      clearOperation.setServiceName(SERVICE_NAME);
      clearOperation.setResponseHandler(ResponseHandlerFactory.createEmptyResponseHandler());
      clearOperation.setPartitionId(i);
      nodeEngine.getOperationService().runOperation(clearOperation);
    }
  }
}",0.8796783173523044
49389,"private void evictMap(MapContainer mapContainer){
  MapConfig mapConfig=mapContainer.getMapConfig();
  MapConfig.EvictionPolicy evictionPolicy=mapConfig.getEvictionPolicy();
  Comparator comparator=null;
  if (evictionPolicy == MapConfig.EvictionPolicy.LRU) {
    comparator=new Comparator<AbstractRecord>(){
      public int compare(      AbstractRecord o1,      AbstractRecord o2){
        return o1.getLastAccessTime().compareTo(o2.getLastAccessTime());
      }
    }
;
  }
 else   if (evictionPolicy == MapConfig.EvictionPolicy.LFU) {
    comparator=new Comparator<AbstractRecord>(){
      public int compare(      AbstractRecord o1,      AbstractRecord o2){
        return o1.getHits().compareTo(o2.getHits());
      }
    }
;
  }
  final int evictionPercentage=mapConfig.getEvictionPercentage();
  int memberCount=nodeEngine.getClusterService().getMembers().size();
  int targetSizePerPartition=-1;
  int maxPartitionSize=0;
  final MaxSizeConfig.MaxSizePolicy maxSizePolicy=mapConfig.getMaxSizeConfig().getMaxSizePolicy();
  if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_NODE) {
    maxPartitionSize=mapConfig.getMaxSizeConfig().getSize() * memberCount / nodeEngine.getPartitionService().getPartitionCount();
    targetSizePerPartition=Double.valueOf(maxPartitionSize * ((100 - evictionPercentage) / 100.0)).intValue();
  }
 else   if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_PARTITION) {
    maxPartitionSize=mapConfig.getMaxSizeConfig().getSize();
    targetSizePerPartition=Double.valueOf(maxPartitionSize * ((100 - evictionPercentage) / 100.0)).intValue();
  }
  for (int i=0; i < ExecutorConfig.DEFAULT_POOL_SIZE; i++) {
    nodeEngine.getExecutionService().execute(""String_Node_Str"",new EvictRunner(i,mapConfig,targetSizePerPartition,comparator));
  }
}","private void evictMap(MapContainer mapContainer){
  MapConfig mapConfig=mapContainer.getMapConfig();
  MapConfig.EvictionPolicy evictionPolicy=mapConfig.getEvictionPolicy();
  Comparator comparator=null;
  if (evictionPolicy == MapConfig.EvictionPolicy.LRU) {
    comparator=new Comparator<AbstractRecord>(){
      public int compare(      AbstractRecord o1,      AbstractRecord o2){
        return o1.getLastAccessTime().compareTo(o2.getLastAccessTime());
      }
      public boolean equals(      Object obj){
        return this.equals(obj);
      }
    }
;
  }
 else   if (evictionPolicy == MapConfig.EvictionPolicy.LFU) {
    comparator=new Comparator<AbstractRecord>(){
      public int compare(      AbstractRecord o1,      AbstractRecord o2){
        return o1.getHits().compareTo(o2.getHits());
      }
      public boolean equals(      Object obj){
        return this.equals(obj);
      }
    }
;
  }
  final int evictionPercentage=mapConfig.getEvictionPercentage();
  int memberCount=nodeEngine.getClusterService().getMembers().size();
  int targetSizePerPartition=-1;
  int maxPartitionSize=0;
  final MaxSizeConfig.MaxSizePolicy maxSizePolicy=mapConfig.getMaxSizeConfig().getMaxSizePolicy();
  if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_NODE) {
    maxPartitionSize=(mapConfig.getMaxSizeConfig().getSize() * memberCount / nodeEngine.getPartitionService().getPartitionCount());
    targetSizePerPartition=Double.valueOf(maxPartitionSize * ((100 - evictionPercentage) / 100.0)).intValue();
  }
 else   if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_PARTITION) {
    maxPartitionSize=mapConfig.getMaxSizeConfig().getSize();
    targetSizePerPartition=Double.valueOf(maxPartitionSize * ((100 - evictionPercentage) / 100.0)).intValue();
  }
  for (int i=0; i < ExecutorConfig.DEFAULT_POOL_SIZE; i++) {
    nodeEngine.getExecutionService().execute(""String_Node_Str"",new EvictRunner(i,mapConfig,targetSizePerPartition,comparator,evictionPercentage));
  }
}",0.947620313746344
49390,"public void init(final NodeEngine nodeEngine,Properties properties){
  int partitionCount=nodeEngine.getPartitionService().getPartitionCount();
  for (int i=0; i < partitionCount; i++) {
    partitionContainers[i]=new PartitionContainer(this,i);
  }
  nodeEngine.getExecutionService().scheduleAtFixedRate(new MapEvictTask(),3,1,TimeUnit.SECONDS);
}","public void init(final NodeEngine nodeEngine,Properties properties){
  int partitionCount=nodeEngine.getPartitionService().getPartitionCount();
  for (int i=0; i < partitionCount; i++) {
    partitionContainers[i]=new PartitionContainer(this,i);
  }
  nodeEngine.getExecutionService().scheduleAtFixedRate(new MapEvictTask(),1,1,TimeUnit.SECONDS);
}",0.9971264367816092
49391,"private EvictRunner(int mod,MapConfig mapConfig,int targetSizePerPartition,Comparator comparator){
  this.mod=mod;
  mapName=mapConfig.getName();
  this.targetSizePerPartition=targetSizePerPartition;
  this.comparator=comparator;
  maxSizePolicy=mapConfig.getMaxSizeConfig().getMaxSizePolicy();
}","private EvictRunner(int mod,MapConfig mapConfig,int targetSizePerPartition,Comparator comparator,int evictionPercentage){
  this.mod=mod;
  mapName=mapConfig.getName();
  this.targetSizePerPartition=targetSizePerPartition;
  this.evictionPercentage=evictionPercentage;
  this.comparator=comparator;
  maxSizePolicy=mapConfig.getMaxSizeConfig().getMaxSizePolicy();
}",0.8956127080181543
49392,"public void run(){
  for (int j=0; j < 100000; j++) {
    map.put(""String_Node_Str"" + j,j);
  }
  latch.countDown();
}","public void run(){
  for (int j=0; j < 100000; j++) {
    map.put(k + ""String_Node_Str"" + j,j);
  }
  latch.countDown();
}",0.9833333333333332
49393,"@Test public void testEvictionSpeedTest(){
  final int k=3;
  final int size=10000;
  final CountDownLatch latch=new CountDownLatch(k);
  final String mapName=""String_Node_Str"";
  Config cfg=new Config();
  MapConfig mc=cfg.getMapConfig(mapName);
  mc.setEvictionPolicy(MapConfig.EvictionPolicy.LRU);
  mc.setEvictionPercentage(25);
  MaxSizeConfig msc=new MaxSizeConfig();
  msc.setMaxSizePolicy(MaxSizeConfig.MaxSizePolicy.PER_NODE);
  msc.setSize(size);
  mc.setMaxSizeConfig(msc);
  Hazelcast.shutdownAll();
  final HazelcastInstance[] instances=StaticNodeFactory.newInstances(cfg,k);
  new Thread(){
    final IMap map=instances[0].getMap(mapName);
    public void run(){
      try {
        Thread.sleep(1000);
        while (latch.getCount() != 0) {
          try {
            System.out.println(""String_Node_Str"" + map.size() + ""String_Node_Str""+ (size * k));
            Thread.sleep(1000);
          }
 catch (          InterruptedException e) {
            e.printStackTrace();
          }
        }
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
  }
.start();
  for (int i=0; i < k; i++) {
    final IMap map=instances[i].getMap(mapName);
    new Thread(){
      public void run(){
        for (int j=0; j < 100000; j++) {
          map.put(""String_Node_Str"" + j,j);
        }
        latch.countDown();
      }
    }
.start();
  }
  try {
    Assert.assertEquals(latch.await(10,TimeUnit.MINUTES),true);
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
    Assert.fail(e.getMessage());
  }
}","@Test public void testEvictionSpeedTest(){
  final int k=3;
  final int size=10000;
  final CountDownLatch latch=new CountDownLatch(k);
  final String mapName=""String_Node_Str"";
  Config cfg=new Config();
  final MapConfig mc=cfg.getMapConfig(mapName);
  mc.setEvictionPolicy(MapConfig.EvictionPolicy.LRU);
  mc.setEvictionPercentage(25);
  final MaxSizeConfig msc=new MaxSizeConfig();
  msc.setMaxSizePolicy(MaxSizeConfig.MaxSizePolicy.PER_NODE);
  msc.setSize(size);
  mc.setMaxSizeConfig(msc);
  Hazelcast.shutdownAll();
  final HazelcastInstance[] instances=StaticNodeFactory.newInstances(cfg,k);
  new Thread(){
    final IMap map=instances[0].getMap(mapName);
    public void run(){
      try {
        Thread.sleep(1000);
        while (latch.getCount() != 0) {
          try {
            int msize=map.size();
            assertTrue(msize <= (size * k + size * k * 10 / 100));
            Thread.sleep(1000);
          }
 catch (          InterruptedException e) {
            e.printStackTrace();
          }
        }
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
  }
.start();
  for (int i=0; i < k; i++) {
    final IMap map=instances[i].getMap(mapName);
    new Thread(){
      public void run(){
        for (int j=0; j < 100000; j++) {
          map.put(k + ""String_Node_Str"" + j,j);
        }
        latch.countDown();
      }
    }
.start();
  }
  try {
    Assert.assertEquals(latch.await(10,TimeUnit.MINUTES),true);
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
    Assert.fail(e.getMessage());
  }
}",0.9495077802476976
49394,"public void run(){
  if (prepareTransaction()) {
    return;
  }
  evicted=recordStore.evict(dataKey);
}","public void run(){
  if (prepareTransaction()) {
    return;
  }
  dataValue=mapService.toData(recordStore.evict(dataKey));
  evicted=dataValue != null;
}",0.7829457364341085
49395,"public void afterRun(){
  mapService.interceptAfterProcess(name,MapOperationType.EVICT,dataKey,dataValue,dataValue);
  int eventType=EntryEvent.TYPE_EVICTED;
  mapService.publishEvent(getCallerAddress(),name,eventType,dataKey,null,dataValue);
  invalidateNearCaches();
}","public void afterRun(){
  mapService.interceptAfterProcess(name,MapOperationType.EVICT,dataKey,dataValue,dataValue);
  int eventType=EntryEvent.TYPE_EVICTED;
  mapService.publishEvent(getCallerAddress(),name,eventType,dataKey,dataValue,null);
  invalidateNearCaches();
}",0.9481481481481482
49396,"private boolean checkLimits(MapContainer mapContainer){
  MaxSizeConfig maxSizeConfig=mapContainer.getMapConfig().getMaxSizeConfig();
  MaxSizeConfig.MaxSizePolicy maxSizePolicy=maxSizeConfig.getMaxSizePolicy();
  String mapName=mapContainer.getName();
  int maxSize=maxSizeConfig.getSize() * 95 / 100;
  if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_NODE || maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_PARTITION) {
    int totalSize=0;
    for (int i=0; i < nodeEngine.getPartitionService().getPartitionCount(); i++) {
      Address owner=nodeEngine.getPartitionService().getPartitionOwner(i);
      if (nodeEngine.getThisAddress().equals(owner)) {
        int size=partitionContainers[i].getRecordStore(mapName).getRecords().size();
        if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_PARTITION) {
          if (size >= maxSize)           return true;
        }
 else {
          totalSize+=size;
        }
      }
    }
    if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_NODE)     return totalSize >= maxSize;
 else     return false;
  }
  if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.USED_HEAP_SIZE || maxSizePolicy == MaxSizeConfig.MaxSizePolicy.USED_HEAP_PERCENTAGE) {
    long total=Runtime.getRuntime().totalMemory();
    long used=(total - Runtime.getRuntime().freeMemory());
    if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.USED_HEAP_SIZE) {
      return maxSize > (used / 1024 / 1024);
    }
 else {
      return maxSize > (used / total);
    }
  }
  return false;
}","private boolean checkLimits(MapContainer mapContainer){
  MaxSizeConfig maxSizeConfig=mapContainer.getMapConfig().getMaxSizeConfig();
  MaxSizeConfig.MaxSizePolicy maxSizePolicy=maxSizeConfig.getMaxSizePolicy();
  String mapName=mapContainer.getName();
  int maxSize=maxSizeConfig.getSize() * 95 / 100;
  if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_NODE || maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_PARTITION) {
    int totalSize=0;
    for (int i=0; i < nodeEngine.getPartitionService().getPartitionCount(); i++) {
      Address owner=nodeEngine.getPartitionService().getPartitionOwner(i);
      if (nodeEngine.getThisAddress().equals(owner)) {
        int size=partitionContainers[i].getRecordStore(mapName).getRecords().size();
        if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_PARTITION) {
          if (size >= maxSize) {
            return true;
          }
        }
 else {
          totalSize+=size;
        }
      }
    }
    if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.PER_NODE)     return totalSize >= maxSize;
 else     return false;
  }
  if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.USED_HEAP_SIZE || maxSizePolicy == MaxSizeConfig.MaxSizePolicy.USED_HEAP_PERCENTAGE) {
    long total=Runtime.getRuntime().totalMemory();
    long used=(total - Runtime.getRuntime().freeMemory());
    if (maxSizePolicy == MaxSizeConfig.MaxSizePolicy.USED_HEAP_SIZE) {
      return maxSize > (used / 1024 / 1024);
    }
 else {
      return maxSize > (used / total);
    }
  }
  return false;
}",0.9947368421052633
49397,"public void publishEvent(Address caller,String mapName,int eventType,Data dataKey,Data dataOldValue,Data dataValue){
  Collection<EventRegistration> candidates=nodeEngine.getEventService().getRegistrations(SERVICE_NAME,mapName);
  Set<EventRegistration> registrationsWithValue=new HashSet<EventRegistration>();
  Set<EventRegistration> registrationsWithoutValue=new HashSet<EventRegistration>();
  if (candidates.isEmpty())   return;
  Object key=null;
  Object value=null;
  Object oldValue=null;
  for (  EventRegistration candidate : candidates) {
    EventFilter filter=candidate.getFilter();
    if (filter instanceof EventServiceImpl.EmptyFilter) {
      registrationsWithValue.add(candidate);
    }
 else     if (filter instanceof QueryEventFilter) {
      Object testValue;
      if (eventType == EntryEvent.TYPE_REMOVED) {
        oldValue=oldValue != null ? oldValue : toObject(dataOldValue);
        testValue=oldValue;
      }
 else {
        value=value != null ? value : toObject(dataValue);
        testValue=value;
      }
      key=key != null ? key : toObject(key);
      QueryEventFilter queryEventFilter=(QueryEventFilter)filter;
      if (queryEventFilter.eval(new SimpleMapEntry(key,testValue))) {
        if (queryEventFilter.isIncludeValue()) {
          registrationsWithValue.add(candidate);
        }
 else {
          registrationsWithoutValue.add(candidate);
        }
      }
    }
 else     if (filter.eval(dataKey)) {
      EntryEventFilter eventFilter=(EntryEventFilter)filter;
      if (eventFilter.isIncludeValue()) {
        registrationsWithValue.add(candidate);
      }
 else {
        registrationsWithoutValue.add(candidate);
      }
    }
  }
  if (registrationsWithValue.isEmpty() && registrationsWithoutValue.isEmpty())   return;
  String source=nodeEngine.getThisAddress().toString();
  EventData event=new EventData(source,mapName,caller,dataKey,dataValue,dataOldValue,eventType);
  nodeEngine.getEventService().publishEvent(SERVICE_NAME,registrationsWithValue,event);
  nodeEngine.getEventService().publishEvent(SERVICE_NAME,registrationsWithoutValue,event.cloneWithoutValues());
}","public void publishEvent(Address caller,String mapName,int eventType,Data dataKey,Data dataOldValue,Data dataValue){
  Collection<EventRegistration> candidates=nodeEngine.getEventService().getRegistrations(SERVICE_NAME,mapName);
  Set<EventRegistration> registrationsWithValue=new HashSet<EventRegistration>();
  Set<EventRegistration> registrationsWithoutValue=new HashSet<EventRegistration>();
  if (candidates.isEmpty())   return;
  Object key=null;
  Object value=null;
  Object oldValue=null;
  for (  EventRegistration candidate : candidates) {
    EventFilter filter=candidate.getFilter();
    if (filter instanceof EventServiceImpl.EmptyFilter) {
      registrationsWithValue.add(candidate);
    }
 else     if (filter instanceof QueryEventFilter) {
      Object testValue;
      if (eventType == EntryEvent.TYPE_REMOVED || eventType == EntryEvent.TYPE_EVICTED) {
        oldValue=oldValue != null ? oldValue : toObject(dataOldValue);
        testValue=oldValue;
      }
 else {
        value=value != null ? value : toObject(dataValue);
        testValue=value;
      }
      key=key != null ? key : toObject(key);
      QueryEventFilter queryEventFilter=(QueryEventFilter)filter;
      if (queryEventFilter.eval(new SimpleMapEntry(key,testValue))) {
        if (queryEventFilter.isIncludeValue()) {
          registrationsWithValue.add(candidate);
        }
 else {
          registrationsWithoutValue.add(candidate);
        }
      }
    }
 else     if (filter.eval(dataKey)) {
      EntryEventFilter eventFilter=(EntryEventFilter)filter;
      if (eventFilter.isIncludeValue()) {
        registrationsWithValue.add(candidate);
      }
 else {
        registrationsWithoutValue.add(candidate);
      }
    }
  }
  if (registrationsWithValue.isEmpty() && registrationsWithoutValue.isEmpty())   return;
  String source=nodeEngine.getThisAddress().toString();
  EventData event=new EventData(source,mapName,caller,dataKey,dataValue,dataOldValue,eventType);
  nodeEngine.getEventService().publishEvent(SERVICE_NAME,registrationsWithValue,event);
  nodeEngine.getEventService().publishEvent(SERVICE_NAME,registrationsWithoutValue,event.cloneWithoutValues());
}",0.9906846762925012
49398,"public boolean evict(Data dataKey){
  Record record=records.get(dataKey);
  if (record != null) {
    mapService.intercept(name,MapOperationType.EVICT,dataKey,record.getValue(),record.getValue());
    records.remove(dataKey);
    removeIndex(dataKey);
    return true;
  }
  return false;
}","public Object evict(Data dataKey){
  Record record=records.get(dataKey);
  Object oldValue=null;
  if (record != null) {
    mapService.intercept(name,MapOperationType.EVICT,dataKey,record.getValue(),record.getValue());
    oldValue=record.getValue();
    records.remove(dataKey);
    removeIndex(dataKey);
  }
  return oldValue;
}",0.8470209339774557
49399,boolean evict(Data key);,Object evict(Data key);,0.8085106382978723
49400,"@Override public void process(EntryTaskScheduler scheduler,Collection<ScheduledEntry<Data,Object>> entries){
  System.out.println(""String_Node_Str"" + entries.size());
  for (  ScheduledEntry<Data,Object> entry : entries) {
    Data key=entry.getKey();
    Operation operation=new EvictOperation(mapName,key,null);
    int partitionId=nodeEngine.getPartitionService().getPartitionId(key);
    try {
      Invocation invocation=nodeEngine.getOperationService().createInvocationBuilder(SERVICE_NAME,operation,partitionId).build();
      Future f=invocation.invoke();
      f.get();
    }
 catch (    Throwable t) {
      throw ExceptionUtil.rethrow(t);
    }
  }
}","@Override public void process(EntryTaskScheduler scheduler,Collection<ScheduledEntry<Data,Object>> entries){
  for (  ScheduledEntry<Data,Object> entry : entries) {
    Data key=entry.getKey();
    Operation operation=new EvictOperation(mapName,key,null);
    int partitionId=nodeEngine.getPartitionService().getPartitionId(key);
    try {
      Invocation invocation=nodeEngine.getOperationService().createInvocationBuilder(SERVICE_NAME,operation,partitionId).build();
      Future f=invocation.invoke();
      f.get();
    }
 catch (    Throwable t) {
      throw ExceptionUtil.rethrow(t);
    }
  }
}",0.9541139240506328
49401,"public Record createRecord(String name,Data dataKey,Object value,long ttl){
  Record record=null;
  MapContainer mapContainer=getMapContainer(name);
  final MapConfig.RecordType recordType=mapContainer.getMapConfig().getRecordType();
  if (recordType == MapConfig.RecordType.DATA) {
    record=new DataRecord(dataKey,toData(value));
  }
 else   if (recordType == MapConfig.RecordType.OBJECT) {
    record=new ObjectRecord(dataKey,toObject(value));
  }
 else   if (recordType == MapConfig.RecordType.CACHED) {
    record=new CachedDataRecord(dataKey,toData(value));
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (ttl <= 0 && mapContainer.getMapConfig().getTimeToLiveSeconds() > 0) {
    record.getState().updateTtlExpireTime(mapContainer.getMapConfig().getTimeToLiveSeconds() * 1000);
    scheduleTtlEviction(name,dataKey,mapContainer.getMapConfig().getTimeToLiveSeconds() * 1000);
  }
  if (ttl > 0) {
    record.getState().updateTtlExpireTime(ttl);
    scheduleTtlEviction(name,record.getKey(),ttl);
  }
  if (mapContainer.getMapConfig().getMaxIdleSeconds() > 0) {
    record.getState().updateIdleExpireTime(mapContainer.getMapConfig().getMaxIdleSeconds() * 1000);
    scheduleIdleEviction(name,dataKey,mapContainer.getMapConfig().getMaxIdleSeconds() * 1000);
  }
  return record;
}","public Record createRecord(String name,Data dataKey,Object value,long ttl,boolean backup){
  Record record=null;
  MapContainer mapContainer=getMapContainer(name);
  final MapConfig.RecordType recordType=mapContainer.getMapConfig().getRecordType();
  if (recordType == MapConfig.RecordType.DATA) {
    record=new DataRecord(dataKey,toData(value));
  }
 else   if (recordType == MapConfig.RecordType.OBJECT) {
    record=new ObjectRecord(dataKey,toObject(value));
  }
 else   if (recordType == MapConfig.RecordType.CACHED) {
    record=new CachedDataRecord(dataKey,toData(value));
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (!backup) {
    if (ttl <= 0 && mapContainer.getMapConfig().getTimeToLiveSeconds() > 0) {
      record.getState().updateTtlExpireTime(mapContainer.getMapConfig().getTimeToLiveSeconds() * 1000);
      scheduleTtlEviction(name,dataKey,mapContainer.getMapConfig().getTimeToLiveSeconds() * 1000);
    }
    if (ttl > 0) {
      record.getState().updateTtlExpireTime(ttl);
      scheduleTtlEviction(name,record.getKey(),ttl);
    }
    if (mapContainer.getMapConfig().getMaxIdleSeconds() > 0) {
      record.getState().updateIdleExpireTime(mapContainer.getMapConfig().getMaxIdleSeconds() * 1000);
      scheduleIdleEviction(name,dataKey,mapContainer.getMapConfig().getMaxIdleSeconds() * 1000);
    }
  }
  return record;
}",0.977728285077951
49402,"@Override public void process(EntryTaskScheduler scheduler,Collection<ScheduledEntry<Data,Object>> entries){
  System.out.println(""String_Node_Str"" + entries.size());
  for (  ScheduledEntry<Data,Object> entry : entries) {
    System.out.println(""String_Node_Str"" + mapService.toObject(entry.getKey()) + ""String_Node_Str""+ mapService.toObject(entry.getValue()));
    mapContainer.getStore().store(mapService.toObject(entry.getKey()),mapService.toObject(entry.getValue()));
  }
}","@Override public void process(EntryTaskScheduler scheduler,Collection<ScheduledEntry<Data,Object>> entries){
  for (  ScheduledEntry<Data,Object> entry : entries) {
    mapContainer.getStore().store(mapService.toObject(entry.getKey()),mapService.toObject(entry.getValue()));
  }
}",0.5936675461741425
49403,"public void run(){
  MapService mapService=(MapService)getService();
  int partitionId=getPartitionId();
  RecordStore recordStore=mapService.getRecordStore(partitionId,name);
  Record record=recordStore.getRecords().get(dataKey);
  if (record == null) {
    record=mapService.createRecord(name,dataKey,dataValue,ttl);
    recordStore.getRecords().put(dataKey,record);
  }
 else {
    recordStore.setRecordValue(record,dataValue);
  }
}","public void run(){
  MapService mapService=(MapService)getService();
  int partitionId=getPartitionId();
  RecordStore recordStore=mapService.getRecordStore(partitionId,name);
  Record record=recordStore.getRecords().get(dataKey);
  if (record == null) {
    record=mapService.createRecord(name,dataKey,dataValue,ttl,true);
    recordStore.getRecords().put(dataKey,record);
  }
 else {
    if (record instanceof DataRecord)     ((DataRecord)record).setValue(dataValue);
 else     if (record instanceof ObjectRecord)     ((ObjectRecord)record).setValue(mapService.toObject(dataValue));
  }
}",0.7953216374269005
49404,"private boolean scheduleEntry(long delayMillis,K key,V value){
  final int delaySeconds=ceilToSecond(delayMillis);
  final Integer newSecond=findRelativeSecond(delayMillis);
  final Integer existingSecond=secondsOfKeys.put(key,newSecond);
  if (existingSecond != null) {
    if (existingSecond.equals(newSecond)) {
      System.out.println(""String_Node_Str"" + existingSecond + ""String_Node_Str""+ newSecond);
      return false;
    }
    removeKeyFromSecond(key,existingSecond);
  }
  doSchedule(new ScheduledEntry<K,V>(key,value,delayMillis,delaySeconds),newSecond);
  return true;
}","private boolean scheduleEntry(long delayMillis,K key,V value){
  final int delaySeconds=ceilToSecond(delayMillis);
  final Integer newSecond=findRelativeSecond(delayMillis);
  final Integer existingSecond=secondsOfKeys.put(key,newSecond);
  if (existingSecond != null) {
    if (existingSecond.equals(newSecond)) {
      return false;
    }
    removeKeyFromSecond(key,existingSecond);
  }
  doSchedule(new ScheduledEntry<K,V>(key,value,delayMillis,delaySeconds),newSecond);
  return true;
}",0.9134883720930232
49405,"private void removeKeyFromSecond(K key,Integer existingSecond){
  ConcurrentMap<K,ScheduledEntry<K,V>> scheduledKeys=scheduledEntries.get(existingSecond);
  if (scheduledKeys != null) {
    scheduledKeys.remove(key);
    System.out.println(""String_Node_Str"" + key);
  }
}","private void removeKeyFromSecond(K key,Integer existingSecond){
  ConcurrentMap<K,ScheduledEntry<K,V>> scheduledKeys=scheduledEntries.get(existingSecond);
  if (scheduledKeys != null) {
    scheduledKeys.remove(key);
  }
}",0.9006085192697769
49406,"/** 
 * Creates a new SecondExecutorService that will execute each entry one by one. Imagine a map with entries with different max-idle-seconds. Note that each key can be rescheduled and its execution can be postponed. So two things to remember: 1. a key can be rescheduled any number of times so its execution can be postponed. 2. each entry is executed individually. Once a key is executed, it can be re-scheduled for another execution. <p/> SecondExecutorService implementation is thread-safe.
 * @param es  ScheduledExecutorService instance to execute the second
 * @param stf entry executor
 * @return SecondExecutorService
 */
public SecondExecutorService newSecondEntryExecutor(ScheduledExecutorService es,SecondEntryTaskFactory stf){
  return new SecondScheduler(es,stf);
}","/** 
 * Creates a new SecondExecutorService that will execute each entry one by one. Imagine a map with entries with different max-idle-seconds. Note that each key can be rescheduled and its execution can be postponed. So two things to remember: 1. a key can be rescheduled any number of times so its execution can be postponed. 2. each entry is executed individually. Once a key is executed, it can be re-scheduled for another execution. <p/> SecondExecutorService implementation is thread-safe.
 * @param es  ScheduledExecutorService instance to execute the second
 * @param stf entry executor
 * @return SecondExecutorService
 */
public static SecondExecutorService newSecondEntryExecutor(ScheduledExecutorService es,SecondEntryTaskFactory stf){
  return new SecondScheduler(es,stf);
}",0.9955385595920968
49407,"/** 
 * Creates a new SecondExecutorService that will run all second operations in bulk. Imagine a write-behind map where dirty entries will be stored in bulk. Note that each key can be only once; meaning you cannot delay the execution Once an entry is marked as dirty for example, it will run in write-delay-seconds, even if the entry is updated again within write-delay-seconds. So two things to remember: 1. a key cannot be re-scheduled (postponing its execution). 2. all entries scheduled for a given second will be executed in once by your SecondBulkExecutor implementation. Once a key is executed, it can be re-scheduled for another execution. <p/> SecondExecutorService implementation is thread-safe.
 * @param es  ScheduledExecutorService instance to execute the second
 * @param stf bulk executor
 * @return SecondExecutorService
 */
public SecondExecutorService newSecondBulkExecutor(ScheduledExecutorService es,SecondBulkTaskFactory stf){
  return new SecondScheduler(es,stf);
}","/** 
 * Creates a new SecondExecutorService that will run all second operations in bulk. Imagine a write-behind map where dirty entries will be stored in bulk. Note that each key can be only once; meaning you cannot delay the execution Once an entry is marked as dirty for example, it will run in write-delay-seconds, even if the entry is updated again within write-delay-seconds. So two things to remember: 1. a key cannot be re-scheduled (postponing its execution). 2. all entries scheduled for a given second will be executed in once by your SecondBulkExecutor implementation. Once a key is executed, it can be re-scheduled for another execution. <p/> SecondExecutorService implementation is thread-safe.
 * @param es  ScheduledExecutorService instance to execute the second
 * @param stf bulk executor
 * @return SecondExecutorService
 */
public static SecondExecutorService newSecondBulkExecutor(ScheduledExecutorService es,SecondBulkTaskFactory stf){
  return new SecondScheduler(es,stf);
}",0.9964735516372796
49408,"public void executeAll(SecondExecutorService ses,ConcurrentMap<Object,Object> entries,int delaySecond){
  for (  Object o : entries.values()) {
    System.out.println(o);
  }
}","public void executeAll(SecondExecutorService ses,ConcurrentMap<Object,Object> entries,int delaySecond){
  for (  Object o : entries.values()) {
    System.out.println(""String_Node_Str"" + o);
  }
}",0.946236559139785
49409,"@Override public synchronized void run(){
  while (true) {
    System.out.println(secondScheduler);
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
  }
}","@Override public synchronized void run(){
  while (true) {
    System.out.println(ses);
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
  }
}",0.9669811320754716
49410,"public static void main(String[] args) throws Exception {
  SecondTaskFactory secondTaskFactory=new SecondTaskFactory(){
    public SecondTask newSecondTask(){
      return new SecondBulkTask(){
        public void executeAll(        SecondExecutorService ses,        ConcurrentMap<Object,Object> entries,        int delaySecond){
          for (          Object o : entries.values()) {
            System.out.println(o);
          }
        }
        public void endSecond(){
        }
      }
;
    }
  }
;
  final ScheduledExecutorService ses=Executors.newScheduledThreadPool(10);
  final SecondScheduler secondScheduler=new SecondScheduler(ses,secondTaskFactory);
  new Thread(){
    @Override public synchronized void run(){
      while (true) {
        System.out.println(secondScheduler);
        try {
          Thread.sleep(1000);
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
      }
    }
  }
.start();
  while (true) {
    for (int i=0; i < 10; i++) {
      schedule(true,secondScheduler,i,100);
    }
  }
}","public static void main(String[] args) throws Exception {
  final ScheduledExecutorService se=Executors.newScheduledThreadPool(10);
  final SecondBulkTaskFactory sbtf=new SecondBulkTaskFactory(){
    @Override public SecondBulkTask newSecondTask(){
      return new SecondBulkTask(){
        public void executeAll(        SecondExecutorService ses,        ConcurrentMap<Object,Object> entries,        int delaySecond){
          for (          Object o : entries.values()) {
            System.out.println(""String_Node_Str"" + o);
          }
        }
        public void endSecond(){
        }
      }
;
    }
  }
;
  final SecondEntryTaskFactory setf=new SecondEntryTaskFactory(){
    @Override public SecondEntryTask newSecondTask(){
      return new SecondEntryTask(){
        @Override public void executeEntry(        SecondExecutorService ses,        Map.Entry entry,        int delaySeconds){
          System.out.println(""String_Node_Str"" + entry.getValue());
        }
        public void endSecond(){
        }
      }
;
    }
  }
;
  final SecondExecutorService ses=SecondExecutorServiceFactory.newSecondBulkExecutor(se,sbtf);
  new Thread(){
    @Override public synchronized void run(){
      while (true) {
        System.out.println(ses);
        try {
          Thread.sleep(1000);
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
      }
    }
  }
.start();
  for (int i=0; i < 10; i++) {
    ses.schedule(100,i,""String_Node_Str"" + i);
    ses.schedule(100,i,""String_Node_Str"" + i);
    ses.schedule(100,i,""String_Node_Str"" + i);
  }
  for (int i=10; i < 20; i++) {
    ses.schedule(3330,i,""String_Node_Str"" + i);
    ses.schedule(4330,i,""String_Node_Str"" + i);
    ses.schedule(5330,i,""String_Node_Str"" + i);
  }
}",0.5611814345991561
49411,"void execute(final Integer second,final int delaySecond){
  ses.schedule(new Runnable(){
    public void run(){
      final ConcurrentMap<Object,Object> scheduledKeys=secondObjects.remove(second);
      final SecondTask secondTask=secondTaskFactory.newSecondTask();
      try {
        if (bulk) {
          final SecondBulkTask sbe=(SecondBulkTask)secondTask;
          for (          Object o : scheduledKeys.keySet()) {
            keySeconds.remove(o);
          }
          sbe.executeAll(SecondScheduler.this,scheduledKeys,delaySecond);
        }
 else {
          final SecondEntryTask see=(SecondEntryTask)secondTask;
          for (          Map.Entry<Object,Object> object : scheduledKeys.entrySet()) {
            final Object scheduleKey=object.getKey();
            if (keySeconds.remove(scheduleKey,second)) {
              try {
                see.executeEntry(SecondScheduler.this,object,delaySecond);
              }
 catch (              Exception ignored) {
              }
            }
          }
        }
      }
 catch (      Throwable ignored) {
        ignored.printStackTrace();
      }
 finally {
        secondTask.endSecond();
      }
    }
  }
,delaySecond,TimeUnit.SECONDS);
  System.out.println(""String_Node_Str"" + second);
}","void execute(final Integer second,final int delaySecond){
  ses.schedule(new Runnable(){
    public void run(){
      final ConcurrentMap<Object,Object> scheduledKeys=secondObjects.remove(second);
      if (scheduledKeys == null || scheduledKeys.isEmpty())       return;
      final SecondTask secondTask=secondTaskFactory.newSecondTask();
      try {
        if (bulk) {
          final SecondBulkTask sbe=(SecondBulkTask)secondTask;
          for (          Object o : scheduledKeys.keySet()) {
            keySeconds.remove(o);
          }
          sbe.executeAll(SecondScheduler.this,scheduledKeys,delaySecond);
        }
 else {
          final SecondEntryTask see=(SecondEntryTask)secondTask;
          for (          Map.Entry<Object,Object> object : scheduledKeys.entrySet()) {
            final Object scheduleKey=object.getKey();
            if (keySeconds.remove(scheduleKey,second)) {
              try {
                see.executeEntry(SecondScheduler.this,object,delaySecond);
              }
 catch (              Exception ignored) {
              }
            }
          }
        }
      }
 catch (      Throwable ignored) {
        ignored.printStackTrace();
      }
 finally {
        secondTask.endSecond();
      }
    }
  }
,delaySecond,TimeUnit.SECONDS);
}",0.95125786163522
49412,"private static void schedule(boolean update,SecondScheduler secondScheduler,final Object key,final long millis){
  if (update) {
    secondScheduler.schedule(millis,key,""String_Node_Str"" + key);
  }
 else {
    secondScheduler.scheduleIfNew(millis,key,""String_Node_Str"" + key);
  }
}","public boolean schedule(long delayMillis,Object key,Object object){
  if (bulk) {
    return scheduleIfNew(delayMillis,key,object);
  }
 else {
    return scheduleEntry(delayMillis,key,object);
  }
}",0.5186721991701245
49413,"@Override public String toString(){
  return ""String_Node_Str"" + ""String_Node_Str"" + keySeconds.size() + ""String_Node_Str""+ secondObjects.keySet()+ '}';
}","@Override public String toString(){
  return ""String_Node_Str"" + ""String_Node_Str"" + keySeconds.size() + ""String_Node_Str""+ secondObjects.size()+ ""String_Node_Str""+ secondObjects.keySet()+ '}';
}",0.8825214899713467
49414,"public SecondTask newSecondTask(){
  return new SecondBulkTask(){
    public void executeAll(    SecondExecutorService ses,    ConcurrentMap<Object,Object> entries,    int delaySecond){
      for (      Object o : entries.values()) {
        System.out.println(o);
      }
    }
    public void endSecond(){
    }
  }
;
}","@Override public SecondEntryTask newSecondTask(){
  return new SecondEntryTask(){
    @Override public void executeEntry(    SecondExecutorService ses,    Map.Entry entry,    int delaySeconds){
      System.out.println(""String_Node_Str"" + entry.getValue());
    }
    public void endSecond(){
    }
  }
;
}",0.5390749601275917
49415,"public ExecutorService getExecutorService(String name){
  if (name == null)   throw new IllegalArgumentException(""String_Node_Str"");
  ExecutorServiceClientProxy executorServiceProxy=mapExecutors.get(name);
  if (executorServiceProxy == null) {
    executorServiceProxy=new ExecutorServiceClientProxy(this,name);
    ExecutorServiceClientProxy old=mapExecutors.putIfAbsent(name,executorServiceProxy);
    if (old != null) {
      executorServiceProxy=old;
    }
  }
  return executorServiceProxy;
}","public IExecutorService getExecutorService(String name){
  if (name == null)   throw new IllegalArgumentException(""String_Node_Str"");
  ExecutorServiceClientProxy executorServiceProxy=mapExecutors.get(name);
  if (executorServiceProxy == null) {
    executorServiceProxy=new ExecutorServiceClientProxy(this,name);
    ExecutorServiceClientProxy old=mapExecutors.putIfAbsent(name,executorServiceProxy);
    if (old != null) {
      executorServiceProxy=old;
    }
  }
  return null;
}",0.9745158002038736
49416,"public void addIndex(Expression<?> expression,boolean ordered){
  proxyHelper.doCommand(Command.MADDINDEX,new String[]{getName(),String.valueOf(ordered)},proxyHelper.toData(expression));
}","public void addIndex(String attribute,boolean ordered){
  proxyHelper.doCommand(Command.MADDINDEX,new String[]{getName(),attribute,String.valueOf(ordered)},null);
}",0.7784090909090909
49417,"public void flush(boolean flushAllEntries){
}","public void flush(){
  proxyHelper.doCommand(Command.MFLUSH,getName(),null);
}",0.3577235772357723
49418,"@Override public void beforeRun() throws Exception {
  if (operations == null && operationData != null) {
    final NodeEngine nodeEngine=getNodeEngine();
    final int len=operationData.length;
    operations=new Operation[len];
    for (int i=0; i < len; i++) {
      final Operation op=(Operation)nodeEngine.toObject(operationData[i]);
      op.setNodeEngine(nodeEngine).setCaller(getCaller()).setConnection(getConnection()).setResponseHandler(ResponseHandlerFactory.createEmptyResponseHandler());
      OperationAccessor.setCallId(op,getCallId());
      operations[i]=op;
    }
  }
}","@Override public void beforeRun() throws Exception {
  if (operations != null && operations.length > 0) {
    final NodeEngine nodeEngine=getNodeEngine();
    final int len=operations.length;
    for (int i=0; i < len; i++) {
      final Operation op=operations[i];
      op.setNodeEngine(nodeEngine).setCaller(getCaller()).setConnection(getConnection()).setResponseHandler(ResponseHandlerFactory.createEmptyResponseHandler());
      OperationAccessor.setCallId(op,getCallId());
      operations[i]=op;
    }
  }
}",0.7683923705722071
49419,"@Override protected void readInternal(final ObjectDataInput in) throws IOException {
  int len=in.readInt();
  operationData=new Data[len];
  for (int i=0; i < len; i++) {
    operationData[i]=new Data();
    operationData[i].readData(in);
  }
}","@Override protected void readInternal(final ObjectDataInput in) throws IOException {
  final int len=in.readInt();
  operations=new Operation[len];
  for (int i=0; i < len; i++) {
    operations[i]=in.readObject();
  }
}",0.8344086021505376
49420,"@Override protected void writeInternal(final ObjectDataOutput out) throws IOException {
  prepareToWrite();
  int len=operationData.length;
  out.writeInt(len);
  for (  Data op : operationData) {
    op.writeData(out);
  }
}","@Override protected void writeInternal(final ObjectDataOutput out) throws IOException {
  final int len=operations != null ? operations.length : 0;
  out.writeInt(len);
  if (len > 0) {
    for (    Operation op : operations) {
      out.writeObject(op);
    }
  }
}",0.4806517311608961
49421,"public void dispatchEvent(Data data,EntryListener listener){
  EventData eventData=(EventData)nodeEngine.toObject(data);
  Member member=nodeEngine.getClusterService().getMember(eventData.getCaller());
  EntryEvent event=null;
  if (eventData.getDataOldValue() == null) {
    event=new EntryEvent(eventData.getSource(),member,eventData.getEventType(),toObject(eventData.getDataKey()),toObject(eventData.getDataNewValue()));
  }
 else {
    event=new EntryEvent(eventData.getSource(),member,eventData.getEventType(),toObject(eventData.getDataKey()),toObject(eventData.getDataOldValue()),toObject(eventData.getDataNewValue()));
  }
switch (event.getEventType()) {
case ADDED:
    listener.entryAdded(event);
  break;
case EVICTED:
listener.entryEvicted(event);
break;
case UPDATED:
listener.entryUpdated(event);
break;
case REMOVED:
listener.entryRemoved(event);
break;
}
}","public void dispatchEvent(EventData eventData,EntryListener listener){
  Member member=nodeEngine.getClusterService().getMember(eventData.getCaller());
  EntryEvent event=null;
  if (eventData.getDataOldValue() == null) {
    event=new EntryEvent(eventData.getSource(),member,eventData.getEventType(),toObject(eventData.getDataKey()),toObject(eventData.getDataNewValue()));
  }
 else {
    event=new EntryEvent(eventData.getSource(),member,eventData.getEventType(),toObject(eventData.getDataKey()),toObject(eventData.getDataOldValue()),toObject(eventData.getDataNewValue()));
  }
switch (event.getEventType()) {
case ADDED:
    listener.entryAdded(event);
  break;
case EVICTED:
listener.entryEvicted(event);
break;
case UPDATED:
listener.entryUpdated(event);
break;
case REMOVED:
listener.entryRemoved(event);
break;
}
}",0.9515366430260048
49422,"public void publishEvent(Address caller,String mapName,int eventType,Data dataKey,Data dataOldValue,Data dataValue){
  Collection<EventRegistration> candidates=nodeEngine.getEventService().getRegistrations(MAP_SERVICE_NAME,mapName);
  Set<EventRegistration> registrationsWithValue=new HashSet<EventRegistration>();
  Set<EventRegistration> registrationsWithoutValue=new HashSet<EventRegistration>();
  for (  EventRegistration candidate : candidates) {
    EntryEventFilter filter=(EntryEventFilter)candidate.getFilter();
    if (filter.eval(dataKey)) {
      if (filter.isIncludeValue()) {
        registrationsWithValue.add(candidate);
      }
 else {
        registrationsWithoutValue.add(candidate);
      }
    }
  }
  if (registrationsWithValue.isEmpty() && registrationsWithoutValue.isEmpty())   return;
  String source=nodeEngine.getNode().address.toString();
  EventData event=new EventData(source,caller,dataKey,dataValue,dataOldValue,eventType);
  nodeEngine.getEventService().publishEvent(MAP_SERVICE_NAME,registrationsWithValue,toData(event));
  nodeEngine.getEventService().publishEvent(MAP_SERVICE_NAME,registrationsWithoutValue,toData(event.cloneWithoutValues()));
}","public void publishEvent(Address caller,String mapName,int eventType,Data dataKey,Data dataOldValue,Data dataValue){
  Collection<EventRegistration> candidates=nodeEngine.getEventService().getRegistrations(MAP_SERVICE_NAME,mapName);
  Set<EventRegistration> registrationsWithValue=new HashSet<EventRegistration>();
  Set<EventRegistration> registrationsWithoutValue=new HashSet<EventRegistration>();
  for (  EventRegistration candidate : candidates) {
    EntryEventFilter filter=(EntryEventFilter)candidate.getFilter();
    if (filter.eval(dataKey)) {
      if (filter.isIncludeValue()) {
        registrationsWithValue.add(candidate);
      }
 else {
        registrationsWithoutValue.add(candidate);
      }
    }
  }
  if (registrationsWithValue.isEmpty() && registrationsWithoutValue.isEmpty())   return;
  String source=nodeEngine.getNode().address.toString();
  EventData event=new EventData(source,caller,dataKey,dataValue,dataOldValue,eventType);
  nodeEngine.getEventService().publishEvent(MAP_SERVICE_NAME,registrationsWithValue,event);
  nodeEngine.getEventService().publishEvent(MAP_SERVICE_NAME,registrationsWithoutValue,event.cloneWithoutValues());
}",0.9889267461669506
49423,"public Map<Integer,DataSerializableFactory> getFactories(){
  final Map<Integer,DataSerializableFactory> factories=new HashMap<Integer,DataSerializableFactory>();
  factories.put(RESPONSE,new DataSerializableFactory(){
    public DataSerializable create(){
      return new Response();
    }
  }
);
  factories.put(MULTI_RESPONSE,new DataSerializableFactory(){
    public DataSerializable create(){
      return new MultiResponse();
    }
  }
);
  factories.put(EVENT_PACKET,new DataSerializableFactory(){
    public DataSerializable create(){
      return new EventPacket();
    }
  }
);
  factories.put(PARTITION_ITERATOR,new DataSerializableFactory(){
    public DataSerializable create(){
      return new PartitionIteratingOperation();
    }
  }
);
  factories.put(PARTITION_RESPONSE,new DataSerializableFactory(){
    public DataSerializable create(){
      return new PartitionResponse();
    }
  }
);
  factories.put(OPERATION_WRAPPER,new DataSerializableFactory(){
    public DataSerializable create(){
      return new OperationWrapper();
    }
  }
);
  return factories;
}","public Map<Integer,DataSerializableFactory> getFactories(){
  final Map<Integer,DataSerializableFactory> factories=new HashMap<Integer,DataSerializableFactory>();
  factories.put(DATA,new DataSerializableFactory(){
    public DataSerializable create(){
      return new Data();
    }
  }
);
  factories.put(RESPONSE,new DataSerializableFactory(){
    public DataSerializable create(){
      return new Response();
    }
  }
);
  factories.put(MULTI_RESPONSE,new DataSerializableFactory(){
    public DataSerializable create(){
      return new MultiResponse();
    }
  }
);
  factories.put(EVENT_PACKET,new DataSerializableFactory(){
    public DataSerializable create(){
      return new EventPacket();
    }
  }
);
  factories.put(PARTITION_ITERATOR,new DataSerializableFactory(){
    public DataSerializable create(){
      return new PartitionIteratingOperation();
    }
  }
);
  factories.put(PARTITION_RESPONSE,new DataSerializableFactory(){
    public DataSerializable create(){
      return new PartitionResponse();
    }
  }
);
  factories.put(OPERATION_WRAPPER,new DataSerializableFactory(){
    public DataSerializable create(){
      return new OperationWrapper();
    }
  }
);
  return factories;
}",0.944202266782912
49424,"TaskPoller(){
  super(factory.node.threadGroup,factory.node.getThreadNamePrefix(""String_Node_Str""));
  register(new RuntimeStateRequest());
  register(new ThreadDumpRequest());
  register(new ExecuteScriptRequest());
  register(new EvictLocalMapRequest());
  register(new ConsoleCommandRequest());
  register(new MapConfigRequest());
  register(new DetectDeadlockRequest());
  register(new MemberConfigRequest());
  register(new ClusterPropsRequest());
  register(new SetLogLevelRequest());
  register(new GetLogLevelRequest());
  register(new GetVersionRequest());
  register(new GetLogsRequest());
  register(new RunGcRequest());
  register(new GetMemberSystemPropertiesRequest());
  register(new GetMapEntryRequest());
  register(new LogVersionMismatchRequest());
  register(new ShutdownMemberRequest());
}","TaskPoller(){
  super(factory.node.threadGroup,factory.node.getThreadNamePrefix(""String_Node_Str""));
  register(new RuntimeStateRequest());
  register(new ThreadDumpRequest());
  register(new ExecuteScriptRequest());
  register(new EvictLocalMapRequest());
  register(new ConsoleCommandRequest());
  register(new MapConfigRequest());
  register(new DetectDeadlockRequest());
  register(new MemberConfigRequest());
  register(new ClusterPropsRequest());
  register(new SetLogLevelRequest());
  register(new GetLogLevelRequest());
  register(new GetVersionRequest());
  register(new GetLogsRequest());
  register(new RunGcRequest());
  register(new GetMemberSystemPropertiesRequest());
  register(new GetMapEntryRequest());
  register(new VersionMismatchLogRequest());
  register(new ShutdownMemberRequest());
}",0.9814585908529048
49425,"public static void removeTransaction(){
  ThreadContext.get().setAttachment(null);
}","public static void removeTransaction(){
}",0.656
49426,"public static Transaction getTransaction(HazelcastClient client){
  final ThreadContext ctx=ThreadContext.get();
  TransactionClientProxy transactionProxy=ctx.getAttachment();
  if (transactionProxy == null) {
    transactionProxy=new TransactionClientProxy(null,client);
    ctx.setAttachment(transactionProxy);
  }
  return transactionProxy;
}","public static Transaction getTransaction(HazelcastClient client){
  final ThreadContext ctx=ThreadContext.get();
  return null;
}",0.5316455696202531
49427,"@Test public void testMemberRemoved() throws Exception {
  HazelcastClient client=mock(HazelcastClient.class);
  InetSocketAddress inetSocketAddress=new InetSocketAddress(""String_Node_Str"",5701);
  final Connection connection=mock(Connection.class);
  final List<LifecycleState> lifecycleEvents=new ArrayList<LifecycleState>();
  final LifecycleServiceClientImpl lifecycleService=createLifecycleServiceClientImpl(client,lifecycleEvents);
  ClientConfig clientConfig=new ClientConfig();
  clientConfig.setCredentials(credentials).addInetSocketAddress(inetSocketAddress).setConnectionTimeout(60000);
  ConnectionManager connectionManager=new ConnectionManager(client,clientConfig,lifecycleService){
    protected Connection getNextConnection(){
      return connection;
    }
  }
;
  ClientBinder binder=mock(ClientBinder.class);
  connectionManager.setBinder(binder);
  Cluster cluster=mock(Cluster.class);
  Member member=mock(Member.class);
  when(member.getInetSocketAddress()).thenReturn(inetSocketAddress);
  MembershipEvent membershipEvent=new MembershipEvent(cluster,member,MembershipEvent.MEMBER_REMOVED);
  connectionManager.memberRemoved(membershipEvent);
  assertEquals(0,connectionManager.getClusterMembers().size());
  assertArrayEquals(new Object[0],lifecycleEvents.toArray());
}","@Test public void testMemberRemoved() throws Exception {
  HazelcastClient client=mock(HazelcastClient.class);
  InetSocketAddress inetSocketAddress=new InetSocketAddress(""String_Node_Str"",5701);
  final Connection connection=mock(Connection.class);
  final List<LifecycleState> lifecycleEvents=new ArrayList<LifecycleState>();
  final LifecycleServiceClientImpl lifecycleService=createLifecycleServiceClientImpl(client,lifecycleEvents);
  ClientConfig clientConfig=new ClientConfig();
  clientConfig.setCredentials(credentials).addInetSocketAddress(inetSocketAddress).setConnectionTimeout(60000);
  ConnectionManager connectionManager=new ConnectionManager(client,clientConfig,lifecycleService){
    protected Connection getNextConnection(){
      return connection;
    }
  }
;
  ClientBinder binder=mock(ClientBinder.class);
  connectionManager.setBinder(binder);
  Cluster cluster=mock(Cluster.class);
  Member member=mock(Member.class);
  when(member.getInetSocketAddress()).thenReturn(inetSocketAddress);
  MembershipEvent membershipEvent=new MembershipEvent(member,MembershipEvent.MEMBER_REMOVED);
  connectionManager.memberRemoved(membershipEvent);
  assertEquals(0,connectionManager.getClusterMembers().size());
  assertArrayEquals(new Object[0],lifecycleEvents.toArray());
}",0.9968944099378882
49428,"@Test @Ignore public void testDifferentMemberAdded() throws Exception {
  HazelcastClient client=mock(HazelcastClient.class);
  InetSocketAddress inetSocketAddress=new InetSocketAddress(""String_Node_Str"",5701);
  final Connection connection=mock(Connection.class);
  final List<LifecycleState> lifecycleEvents=new ArrayList<LifecycleState>();
  final LifecycleServiceClientImpl lifecycleService=createLifecycleServiceClientImpl(client,lifecycleEvents);
  ClientConfig clientConfig=new ClientConfig();
  clientConfig.setCredentials(credentials).addInetSocketAddress(inetSocketAddress).setConnectionTimeout(60000);
  ConnectionManager connectionManager=new ConnectionManager(client,clientConfig,lifecycleService){
    protected Connection getNextConnection(){
      return connection;
    }
  }
;
  ClientBinder binder=mock(ClientBinder.class);
  connectionManager.setBinder(binder);
  Cluster cluster=mock(Cluster.class);
  InetSocketAddress inetSocketAddress2=new InetSocketAddress(""String_Node_Str"",5702);
  Member member=mock(Member.class);
  when(member.getInetSocketAddress()).thenReturn(inetSocketAddress2);
  MembershipEvent membershipEvent=new MembershipEvent(cluster,member,MembershipEvent.MEMBER_ADDED);
  connectionManager.memberAdded(membershipEvent);
  connectionManager.getClusterMembers().contains(inetSocketAddress2);
  assertEquals(2,connectionManager.getClusterMembers().size());
  assertArrayEquals(new Object[0],lifecycleEvents.toArray());
}","@Test @Ignore public void testDifferentMemberAdded() throws Exception {
  HazelcastClient client=mock(HazelcastClient.class);
  InetSocketAddress inetSocketAddress=new InetSocketAddress(""String_Node_Str"",5701);
  final Connection connection=mock(Connection.class);
  final List<LifecycleState> lifecycleEvents=new ArrayList<LifecycleState>();
  final LifecycleServiceClientImpl lifecycleService=createLifecycleServiceClientImpl(client,lifecycleEvents);
  ClientConfig clientConfig=new ClientConfig();
  clientConfig.setCredentials(credentials).addInetSocketAddress(inetSocketAddress).setConnectionTimeout(60000);
  ConnectionManager connectionManager=new ConnectionManager(client,clientConfig,lifecycleService){
    protected Connection getNextConnection(){
      return connection;
    }
  }
;
  ClientBinder binder=mock(ClientBinder.class);
  connectionManager.setBinder(binder);
  Cluster cluster=mock(Cluster.class);
  InetSocketAddress inetSocketAddress2=new InetSocketAddress(""String_Node_Str"",5702);
  Member member=mock(Member.class);
  when(member.getInetSocketAddress()).thenReturn(inetSocketAddress2);
  MembershipEvent membershipEvent=new MembershipEvent(member,MembershipEvent.MEMBER_ADDED);
  connectionManager.memberAdded(membershipEvent);
  connectionManager.getClusterMembers().contains(inetSocketAddress2);
  assertEquals(2,connectionManager.getClusterMembers().size());
  assertArrayEquals(new Object[0],lifecycleEvents.toArray());
}",0.9972527472527472
49429,"@Test @Ignore public void testSameMemberAdded() throws Exception {
  HazelcastClient client=mock(HazelcastClient.class);
  InetSocketAddress inetSocketAddress=new InetSocketAddress(""String_Node_Str"",5701);
  final Connection connection=mock(Connection.class);
  final CountDownLatch latch=new CountDownLatch(2);
  final List<LifecycleState> lifecycleEvents=new ArrayList<LifecycleState>();
  final LifecycleServiceClientImpl lifecycleService=createLifecycleServiceClientImpl(client,lifecycleEvents);
  ClientConfig clientConfig=new ClientConfig();
  clientConfig.setCredentials(credentials).addInetSocketAddress(inetSocketAddress).setConnectionTimeout(60000);
  ConnectionManager connectionManager=new ConnectionManager(client,clientConfig,lifecycleService){
    protected Connection getNextConnection(){
      latch.countDown();
      return connection;
    }
  }
;
  ClientBinder binder=mock(ClientBinder.class);
  connectionManager.setBinder(binder);
  Cluster cluster=mock(Cluster.class);
  Member member=mock(Member.class);
  when(member.getInetSocketAddress()).thenReturn(inetSocketAddress);
  MembershipEvent membershipEvent=new MembershipEvent(cluster,member,MembershipEvent.MEMBER_ADDED);
  connectionManager.memberAdded(membershipEvent);
  connectionManager.getClusterMembers().contains(inetSocketAddress);
  assertEquals(1,connectionManager.getClusterMembers().size());
  assertArrayEquals(new Object[0],lifecycleEvents.toArray());
}","@Test @Ignore public void testSameMemberAdded() throws Exception {
  HazelcastClient client=mock(HazelcastClient.class);
  InetSocketAddress inetSocketAddress=new InetSocketAddress(""String_Node_Str"",5701);
  final Connection connection=mock(Connection.class);
  final CountDownLatch latch=new CountDownLatch(2);
  final List<LifecycleState> lifecycleEvents=new ArrayList<LifecycleState>();
  final LifecycleServiceClientImpl lifecycleService=createLifecycleServiceClientImpl(client,lifecycleEvents);
  ClientConfig clientConfig=new ClientConfig();
  clientConfig.setCredentials(credentials).addInetSocketAddress(inetSocketAddress).setConnectionTimeout(60000);
  ConnectionManager connectionManager=new ConnectionManager(client,clientConfig,lifecycleService){
    protected Connection getNextConnection(){
      latch.countDown();
      return connection;
    }
  }
;
  ClientBinder binder=mock(ClientBinder.class);
  connectionManager.setBinder(binder);
  Cluster cluster=mock(Cluster.class);
  Member member=mock(Member.class);
  when(member.getInetSocketAddress()).thenReturn(inetSocketAddress);
  MembershipEvent membershipEvent=new MembershipEvent(member,MembershipEvent.MEMBER_ADDED);
  connectionManager.memberAdded(membershipEvent);
  connectionManager.getClusterMembers().contains(inetSocketAddress);
  assertEquals(1,connectionManager.getClusterMembers().size());
  assertArrayEquals(new Object[0],lifecycleEvents.toArray());
}",0.9972222222222222
49430,"public void connectionRemoved(Connection connection){
  LifecycleServiceImpl lifecycleService=(LifecycleServiceImpl)node.factory.getLifecycleService();
  if (connection.equals(this.conn) && !lifecycleService.paused.get()) {
    destroyEndpointThreads();
    rollbackTransactions();
    removeEntryListeners();
    removeEntryListenersWithKey();
    removeMessageListeners();
    cancelRunningOperations();
    releaseAttachedSemaphorePermits();
    node.clusterManager.sendProcessableToAll(new ClientHandlerService.ClientDisconnect(node.address),true);
    node.clientService.remove(this);
  }
}","public void connectionRemoved(Connection connection){
  LifecycleServiceImpl lifecycleService=(LifecycleServiceImpl)node.factory.getLifecycleService();
  if (connection.equals(this.conn) && !lifecycleService.paused.get()) {
    destroyEndpointThreads();
    rollbackTransactions();
    removeEntryListeners();
    removeEntryListenersWithKey();
    removeMessageListeners();
    cancelRunningOperations();
    releaseAttachedSemaphorePermits();
    node.clusterManager.sendProcessableToAll(new ClientHandlerService.CountDownLatchLeave(conn.getEndPoint()),true);
    node.clientService.remove(this);
  }
}",0.950792326939116
49431,"public void writeData(DataOutput out) throws IOException {
  deadAddress.writeData(out);
}","public void writeData(DataOutput out) throws IOException {
  out.writeInt(partitionId);
  boolean hasOwner=(owner != null);
  out.writeBoolean(hasOwner);
  if (hasOwner) {
    owner.writeData(out);
  }
}",0.5460750853242321
49432,"public void readData(DataInput in) throws IOException {
  (deadAddress=new Address()).readData(in);
}","public void readData(DataInput in) throws IOException {
  partitionId=in.readInt();
  boolean hasOwner=in.readBoolean();
  if (hasOwner) {
    owner=new MemberImpl();
    owner.readData(in);
  }
}",0.5993265993265994
49433,"public void process(){
  node.blockingQueueManager.syncForDead(deadAddress);
  node.concurrentMapManager.syncForDeadCountDownLatches(deadAddress);
}","public void process(){
  node.concurrentMapManager.syncForDeadCountDownLatches(deadAddress);
}",0.7768595041322314
49434,"void processResult(Object result) throws InterruptedException, ExecutionException, TimeoutException {
  if (result == null) {
    throw new TimeoutException();
  }
 else   if (result instanceof Throwable) {
    if (result instanceof InterruptedException) {
      throw (InterruptedException)result;
    }
 else     if (result instanceof ExecutionException) {
      throw (ExecutionException)result;
    }
 else     if (result instanceof TimeoutException) {
      throw (TimeoutException)result;
    }
 else {
      throw new ExecutionException((Throwable)result);
    }
  }
 else   if (result instanceof Packet) {
    setResult(ProxyHelper.getValue((Packet)result));
  }
 else {
    setResult(result);
  }
}","void processResult(Object result) throws InterruptedException, ExecutionException, TimeoutException {
  if (result == null) {
    throw new TimeoutException();
  }
 else   if (result instanceof Throwable) {
    if (result instanceof InterruptedException) {
      throw (InterruptedException)result;
    }
 else     if (result instanceof ExecutionException) {
      throw (ExecutionException)result;
    }
 else     if (result instanceof TimeoutException) {
      throw (TimeoutException)result;
    }
 else {
      throw new ExecutionException((Throwable)result);
    }
  }
 else {
    setResult(result);
  }
}",0.9157175398633256
49435,"public AtomicNumberClientProxy(HazelcastClient hazelcastClient,String name){
  this.name=name;
  this.proxyHelper=new ProxyHelper(name,hazelcastClient);
}","public AtomicNumberClientProxy(HazelcastClient hazelcastClient,String name){
  this.name=name;
  this.proxyHelper=new PacketProxyHelper(name,hazelcastClient);
}",0.9808917197452228
49436,"public boolean compareAndSet(long expect,long update){
  return (Boolean)proxyHelper.doOp(ATOMIC_NUMBER_COMPARE_AND_SET,expect,update);
}","public boolean compareAndSet(long expect,long update){
  return false;
}",0.6602870813397129
49437,"public long getAndAdd(long delta){
  return (Long)proxyHelper.doOp(ATOMIC_NUMBER_GET_AND_ADD,0L,delta);
}","public long getAndAdd(long delta){
  return 0;
}",0.6274509803921569
49438,"public long addAndGet(long delta){
  return (Long)proxyHelper.doOp(ATOMIC_NUMBER_ADD_AND_GET,0L,delta);
}","public long addAndGet(long delta){
  return 0;
}",0.6274509803921569
49439,"public long getAndSet(long newValue){
  return (Long)proxyHelper.doOp(ATOMIC_NUMBER_GET_AND_SET,0L,newValue);
}","public long getAndSet(long newValue){
  return 0;
}",0.6296296296296297
49440,"public Call(Long id,Packet request){
  this.id=id;
  this.request=request;
  if (request != null) {
    this.request.setCallId(id);
  }
}","public Call(Long id,Object request){
  this.id=id;
  this.request=request;
}",0.676056338028169
49441,"public Packet getRequest(){
  return request;
}","public Object getRequest(){
  return request;
}",0.9148936170212766
49442,"@Override public String toString(){
  return ""String_Node_Str"" + ""String_Node_Str"" + id + ""String_Node_Str""+ (request != null ? request.getOperation() : null);
}","@Override public String toString(){
  return request == null ? ""String_Node_Str"" : request.toString();
}",0.6188679245283019
49443,"public Collection<Instance> getInstances(){
  Keys instances=(Keys)proxyHelper.doOp(ClusterOperation.GET_INSTANCES,null,null);
  List<Instance> list=new ArrayList<Instance>();
  if (instances != null) {
    for (    Data data : instances) {
    }
  }
  return list;
}","public Collection<Instance> getInstances(){
  List<Instance> list=new ArrayList<Instance>();
  return list;
}",0.5797872340425532
49444,"public void addInstanceListener(InstanceListener listener){
  check(listener);
  if (instanceListenerManager().noListenerRegistered()) {
    Call c=instanceListenerManager().createNewAddListenerCall(proxyHelper);
    proxyHelper.doCall(c);
  }
  instanceListenerManager().registerListener(listener);
}","public void addInstanceListener(InstanceListener listener){
}",0.3370165745856354
49445,"public ClusterClientProxy(HazelcastClient client){
  this.client=client;
  proxyHelper=new ProxyHelper(""String_Node_Str"",client);
}","public ClusterClientProxy(HazelcastClient client){
  this.client=client;
  protocolProxyHelper=new ProtocolProxyHelper(""String_Node_Str"",client);
}",0.9424460431654677
49446,"public long getClusterTime(){
  return (Long)proxyHelper.doOp(ClusterOperation.GET_CLUSTER_TIME,null,null);
}","public long getClusterTime(){
  return 0;
}",0.5526315789473685
49447,"public Set<Member> getMembers(){
  Keys cw=(Keys)proxyHelper.doOp(ClusterOperation.GET_MEMBERS,null,null);
  Collection<Data> datas=cw.getKeys();
  Set<Member> set=new LinkedHashSet<Member>();
  for (  Data d : datas) {
    set.add((Member)IOUtil.toObject(d.buffer));
  }
  return set;
}","public Set<Member> getMembers(){
  Protocol protocol=protocolProxyHelper.doCommand(Command.MEMBERS,(String[])null,null);
  Set<Member> members=new HashSet<Member>();
  for (  String arg : protocol.args) {
    String[] address=arg.split(""String_Node_Str"");
    System.out.println(arg + ""String_Node_Str"" + address[0]+ ""String_Node_Str""+ address[1]);
    try {
      Member member=new MemberImpl(new Address(address[0],Integer.valueOf(address[1])),false);
      members.add(member);
    }
 catch (    UnknownHostException e) {
      e.printStackTrace();
    }
  }
  return members;
}",0.2258064516129032
49448,"public void handleMaster(Master master){
  if (!node.joined() && !thisAddress.equals(master.address)) {
    logger.log(Level.FINEST,""String_Node_Str"" + master);
    final Address currentMaster=node.getMasterAddress();
    if (currentMaster != null && !currentMaster.equals(master.address)) {
      final Connection conn=node.connectionManager.getConnection(currentMaster);
      if (conn != null && conn.live()) {
        logger.log(Level.FINEST,""String_Node_Str"" + master + ""String_Node_Str""+ currentMaster);
        return;
      }
    }
    node.setMasterAddress(master.address);
    final Connection connMaster=node.connectionManager.getOrConnect(master.address);
    if (connMaster != null) {
      sendJoinRequest(master.address,true);
    }
  }
}","public void handleMaster(Master master){
  if (!node.joined() && !thisAddress.equals(master.address)) {
    logger.log(Level.FINEST,""String_Node_Str"" + master);
    final Address currentMaster=node.getMasterAddress();
    if (currentMaster != null && !currentMaster.equals(master.address)) {
      final Connection conn=node.connectionManager.getConnection(currentMaster);
      if (conn != null && conn.live()) {
        logger.log(Level.FINEST,""String_Node_Str"" + master + ""String_Node_Str""+ currentMaster);
        return;
      }
    }
    node.setMasterAddress(master.address);
    node.connectionManager.getOrConnect(master.address);
    if (!sendJoinRequest(master.address,true)) {
      logger.log(Level.WARNING,""String_Node_Str"" + master.address);
    }
  }
}",0.8099934253780408
49449,"public boolean sendJoinRequest(Address toAddress,boolean withCredentials){
  if (toAddress == null) {
    toAddress=node.getMasterAddress();
  }
  return sendProcessableTo(node.createJoinInfo(withCredentials),toAddress);
}","public boolean sendJoinRequest(Address toAddress,boolean withCredentials){
  if (toAddress == null) {
    toAddress=node.getMasterAddress();
  }
  logger.log(Level.INFO,""String_Node_Str"" + toAddress);
  final boolean send=sendProcessableTo(node.createJoinInfo(withCredentials),toAddress);
  if (!send) {
    logger.log(Level.WARNING,""String_Node_Str"" + toAddress);
  }
  return send;
}",0.7084019769357496
49450,"void scheduleHeartbeatTimerTask(){
  final int TIMEOUT=config.getConnectionTimeout();
  heartbeatTimer.schedule(new TimerTask(){
    @Override public void run(){
      long diff=Clock.currentTimeMillis() - client.getInRunnable().lastReceived;
      try {
        if (diff >= TIMEOUT / 5 && diff < TIMEOUT) {
          logger.log(Level.FINEST,""String_Node_Str"");
          final CountDownLatch latch=new CountDownLatch(1);
          new Thread(new Runnable(){
            public void run(){
              Set<Member> members=client.getCluster().getMembers();
              if (members != null && members.size() >= 1) {
                latch.countDown();
              }
            }
          }
).start();
          if (!latch.await(10000,TimeUnit.MILLISECONDS)) {
            logger.log(Level.WARNING,""String_Node_Str"");
          }
        }
 else         if (diff >= TIMEOUT) {
          logger.log(Level.WARNING,""String_Node_Str"" + TIMEOUT / 1000 + ""String_Node_Str"");
          currentConnection.close();
        }
      }
 catch (      InterruptedException e) {
        return;
      }
catch (      IOException ignored) {
      }
    }
  }
,TIMEOUT / 10,TIMEOUT / 10);
}","void scheduleHeartbeatTimerTask(){
  final int TIMEOUT=config.getConnectionTimeout();
  heartbeatTimer.schedule(new TimerTask(){
    @Override public void run(){
      long diff=Clock.currentTimeMillis() - client.getInRunnable().lastReceived;
      try {
        if (diff >= TIMEOUT / 5 && diff < TIMEOUT) {
          logger.log(Level.FINEST,""String_Node_Str"");
          final CountDownLatch latch=new CountDownLatch(1);
          new Thread(new Runnable(){
            public void run(){
              Set<Member> members=client.getCluster().getMembers();
              if (members != null && members.size() >= 1) {
                latch.countDown();
              }
            }
          }
).start();
          if (!latch.await(10000,TimeUnit.MILLISECONDS)) {
            logger.log(Level.WARNING,""String_Node_Str"");
          }
        }
 else         if (diff >= TIMEOUT) {
          logger.log(Level.WARNING,""String_Node_Str"" + TIMEOUT / 1000 + ""String_Node_Str"");
          currentConnection.close();
        }
      }
 catch (      InterruptedException e) {
        return;
      }
catch (      IOException ignored) {
      }
    }
  }
,TIMEOUT,TIMEOUT / 10);
}",0.9978696207925012
49451,"/** 
 * Returns the default Hazelcast instance, starts it with the default configuration, if not already started.
 * @return the default Hazelcast instance
 * @deprecated as of version 2.2
 * @see #newHazelcastInstance(com.hazelcast.config.Config)
 * @see #getHazelcastInstanceByName(String)
 * @see #getAllHazelcastInstances()
 */
@Deprecated public static HazelcastInstance getDefaultInstance(){
  HazelcastInstance defaultInstanceObject=defaultInstance.get();
  if (defaultInstanceObject == null || !defaultInstanceObject.getLifecycleService().isRunning()) {
synchronized (initLock) {
      defaultInstanceObject=defaultInstance.get();
      if (defaultInstanceObject == null || !defaultInstanceObject.getLifecycleService().isRunning()) {
        defaultInstanceObject=com.hazelcast.impl.FactoryImpl.newHazelcastInstanceProxy(defaultConfig,null);
        defaultInstance.set(defaultInstanceObject);
        return defaultInstanceObject;
      }
 else {
        return defaultInstanceObject;
      }
    }
  }
 else {
    return defaultInstanceObject;
  }
}","/** 
 * Returns the default Hazelcast instance, starts it with the default configuration, if not already started.
 * @return the default Hazelcast instance
 * @deprecated as of version 2.2
 * @see #newHazelcastInstance(com.hazelcast.config.Config)
 * @see #getHazelcastInstanceByName(String)
 * @see #getAllHazelcastInstances()
 */
@Deprecated public static HazelcastInstance getDefaultInstance(){
  HazelcastInstance defaultInstanceObject=defaultInstance.get();
  if (defaultInstanceObject == null || !defaultInstanceObject.getLifecycleService().isRunning()) {
synchronized (initLock) {
      defaultInstanceObject=defaultInstance.get();
      if (defaultInstanceObject == null || !defaultInstanceObject.getLifecycleService().isRunning()) {
        defaultInstanceObject=com.hazelcast.impl.FactoryImpl.newHazelcastInstanceProxy(defaultConfig);
        defaultInstance.set(defaultInstanceObject);
        return defaultInstanceObject;
      }
 else {
        return defaultInstanceObject;
      }
    }
  }
 else {
    return defaultInstanceObject;
  }
}",0.9976336961665878
49452,"/** 
 * Initializes the default Hazelcast instance with the specified configuration. This method should be called before calling any other methods.
 * @param config configuration for this Hazelcast instance.
 * @return the default instance
 * @throws IllegalStateException if this instance is already initialized
 * @deprecated as of version 2.2
 * @see #newHazelcastInstance(com.hazelcast.config.Config)
 * @see #getHazelcastInstanceByName(String)
 * @see #getAllHazelcastInstances()
 */
@Deprecated public static HazelcastInstance init(Config config){
  if (defaultInstance.get() != null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
synchronized (initLock) {
    if (defaultInstance.get() != null) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    defaultConfig=config;
    HazelcastInstance defaultInstanceObject=com.hazelcast.impl.FactoryImpl.newHazelcastInstanceProxy(config,null);
    defaultInstance.set(defaultInstanceObject);
    return defaultInstanceObject;
  }
}","/** 
 * Initializes the default Hazelcast instance with the specified configuration. This method should be called before calling any other methods.
 * @param config configuration for this Hazelcast instance.
 * @return the default instance
 * @throws IllegalStateException if this instance is already initialized
 * @deprecated as of version 2.2
 * @see #newHazelcastInstance(com.hazelcast.config.Config)
 * @see #getHazelcastInstanceByName(String)
 * @see #getAllHazelcastInstances()
 */
@Deprecated public static HazelcastInstance init(Config config){
  if (defaultInstance.get() != null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
synchronized (initLock) {
    if (defaultInstance.get() != null) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    defaultConfig=config;
    HazelcastInstance defaultInstanceObject=com.hazelcast.impl.FactoryImpl.newHazelcastInstanceProxy(config);
    defaultInstance.set(defaultInstanceObject);
    return defaultInstanceObject;
  }
}",0.9975235264982664
49453,"/** 
 * Creates a new HazelcastInstance (a new node in a cluster). This method allows you to create and run multiple instances of Hazelcast cluster members on the same JVM. <p/> To shutdown all running HazelcastInstances (all members on this JVM) call   {@link #shutdownAll()}. Hazelcast will look into two places for the configuration file: <ol> <li> System property: Hazelcast will first check if ""hazelcast.config"" system property is set to a file path. Example: -Dhazelcast.config=C:/myhazelcast.xml. </li> <li> Classpath: If config file is not set as a system property, Hazelcast will check classpath for hazelcast.xml file. </li> </ol> If Hazelcast doesn't find any config file, it will happily start with default configuration (hazelcast-default.xml) located in hazelcast.jar.
 * @return new HazelcastInstance
 * @see #shutdownAll()
 * @see #getHazelcastInstanceByName(String)
 */
public static HazelcastInstance newHazelcastInstance(){
  return com.hazelcast.impl.FactoryImpl.newHazelcastInstanceProxy(null,null);
}","/** 
 * Creates a new HazelcastInstance (a new node in a cluster). This method allows you to create and run multiple instances of Hazelcast cluster members on the same JVM. <p/> To shutdown all running HazelcastInstances (all members on this JVM) call   {@link #shutdownAll()}. Hazelcast will look into two places for the configuration file: <ol> <li> System property: Hazelcast will first check if ""hazelcast.config"" system property is set to a file path. Example: -Dhazelcast.config=C:/myhazelcast.xml. </li> <li> Classpath: If config file is not set as a system property, Hazelcast will check classpath for hazelcast.xml file. </li> </ol> If Hazelcast doesn't find any config file, it will happily start with default configuration (hazelcast-default.xml) located in hazelcast.jar.
 * @return new HazelcastInstance
 * @see #shutdownAll()
 * @see #getHazelcastInstanceByName(String)
 */
public static HazelcastInstance newHazelcastInstance(){
  return com.hazelcast.impl.FactoryImpl.newHazelcastInstanceProxy();
}",0.9955817378497792
49454,"protected void backup(ClusterOperation operation){
  final int localBackupCount=backupCount;
  final int localAsyncBackupCount=asyncBackupCount;
  final int totalBackupCount=localBackupCount + localAsyncBackupCount;
  if (localBackupCount <= 0 && localAsyncBackupCount <= 0) {
    return;
  }
  if (totalBackupCount > maxBackupCount) {
    String msg=""String_Node_Str"" + maxBackupCount + ""String_Node_Str""+ totalBackupCount;
    logger.log(Level.SEVERE,msg);
    throw new HazelcastException(msg);
  }
  if (request.key == null || request.key.size() == 0) {
    throw new HazelcastException(""String_Node_Str"" + request.key);
  }
  final MBackup[] backupOps=new MBackup[localBackupCount];
  for (int i=0; i < totalBackupCount; i++) {
    final int replicaIndex=i + 1;
    if (i < localBackupCount) {
      MBackup backupOp=new MBackup();
      backupOps[i]=backupOp;
      backupOp.sendBackup(operation,replicaIndex,request);
    }
 else {
      final Request reqBackup=Request.copyFromRequest(request);
      reqBackup.operation=operation;
      enqueueAndReturn(new AsyncBackupProcessable(reqBackup,replicaIndex));
    }
  }
  for (int i=0; i < localBackupCount; i++) {
    MBackup backupOp=backupOps[i];
    try {
      if (!backupOp.getResultAsBoolean()) {
        if (logger.isLoggable(Level.FINEST)) {
          logger.log(Level.FINEST,""String_Node_Str"" + request);
        }
      }
    }
 catch (    HazelcastException e) {
      final Level level=backupRedoEnabled ? Level.WARNING : Level.FINEST;
      logger.log(level,""String_Node_Str"" + operation + ""String_Node_Str""+ e.getClass().getName()+ ""String_Node_Str""+ e.getMessage());
      logger.log(Level.FINEST,e.getMessage(),e);
    }
  }
}","protected void backup(ClusterOperation operation){
  final int localBackupCount=backupCount;
  final int localAsyncBackupCount=asyncBackupCount;
  final int totalBackupCount=localBackupCount + localAsyncBackupCount;
  if (localBackupCount <= 0 && localAsyncBackupCount <= 0) {
    return;
  }
  if (totalBackupCount > maxBackupCount) {
    String msg=""String_Node_Str"" + maxBackupCount + ""String_Node_Str""+ totalBackupCount;
    logger.log(Level.SEVERE,msg);
    throw new HazelcastException(msg);
  }
  if (request.key == null || request.key.size() == 0) {
    throw new HazelcastException(""String_Node_Str"" + request.key);
  }
  final MBackup[] backupOps=new MBackup[localBackupCount];
  for (int i=0; i < totalBackupCount; i++) {
    final int replicaIndex=i + 1;
    if (i < localBackupCount) {
      MBackup backupOp=new MBackup();
      backupOps[i]=backupOp;
      backupOp.sendBackup(operation,replicaIndex,request);
    }
 else {
      final Request reqBackup=Request.copyFromRequest(request);
      reqBackup.operation=operation;
      enqueueAndReturn(new AsyncBackupProcessable(reqBackup,replicaIndex));
    }
  }
  for (int i=0; i < localBackupCount; i++) {
    MBackup backupOp=backupOps[i];
    try {
      if (!backupOp.getResultAsBoolean()) {
        if (logger.isLoggable(Level.FINEST)) {
          logger.log(Level.FINEST,""String_Node_Str"" + request);
        }
      }
    }
 catch (    HazelcastException e) {
      final Level level=backupRedoEnabled ? Level.WARNING : Level.FINEST;
      logger.log(level,""String_Node_Str"" + operation + ""String_Node_Str""+ e.getClass().getName()+ ""String_Node_Str""+ e.getMessage());
      logger.log(Level.FINEST,e.getMessage(),e);
    }
  }
  if (totalBackupCount > 0 && shouldRedoWhenOwnerDies() && target != null && node.getClusterImpl().getMember(target) == null) {
    logger.log(Level.WARNING,""String_Node_Str"" + target + ""String_Node_Str""+ ""String_Node_Str""+ request.operation);
    doOp();
    getRedoAwareResult();
  }
}",0.9223669923995657
49455,"public void run(){
  try {
    Thread.sleep(3000 * finalI);
    HazelcastInstance instance=Hazelcast.newHazelcastInstance(config);
    instances.set(finalI,instance);
    Thread.sleep(rand.nextInt(100));
    if (finalI != 0) {
      for (int j=0; j < 10000; j++) {
        instance.getMap(name).put(getName() + ""String_Node_Str"" + j,""String_Node_Str"");
      }
    }
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
}","public void run(){
  for (int j=(n * chunk); j < (n + 1) * chunk; j++) {
    map.remove(j);
    try {
      Thread.sleep(1);
    }
 catch (    InterruptedException ignored) {
    }
  }
  latch.countDown();
}",0.2142857142857142
49456,"public Object poll(final String name,long timeout) throws InterruptedException {
  if (timeout == -1) {
    timeout=Long.MAX_VALUE;
  }
  Object removedItem=null;
  long start=Clock.currentTimeMillis();
  while (removedItem == null && timeout >= 0) {
    Data key=takeKey(name,timeout);
    if (key == null) {
      return null;
    }
    IMap imap=getStorageMap(name);
    try {
      removedItem=imap.tryRemove(key,0,TimeUnit.MILLISECONDS);
      if (removedItem != null) {
        ThreadContext threadContext=ThreadContext.get();
        TransactionImpl txn=threadContext.getCallContext().getTransaction();
        final Data removedItemData=toData(removedItem);
        if (txn != null && txn.getStatus() == Transaction.TXN_STATUS_ACTIVE) {
          txn.attachRemoveOp(name,key,removedItemData,true);
        }
        fireQueueEvent(name,EntryEventType.REMOVED,removedItemData);
      }
    }
 catch (    TimeoutException e) {
      throw new OperationTimeoutException();
    }
    long now=Clock.currentTimeMillis();
    timeout-=(now - start);
    start=now;
  }
  return removedItem;
}","public Object poll(final String name,long timeout) throws InterruptedException {
  if (timeout == -1) {
    timeout=Long.MAX_VALUE;
  }
  Object removedItem=null;
  long start=Clock.currentTimeMillis();
  while (removedItem == null && timeout >= 0) {
    Data key=takeKey(name,timeout);
    if (key == null) {
      return null;
    }
    IMap imap=getStorageMap(name);
    try {
      removedItem=imap.tryRemove(key,0,TimeUnit.MILLISECONDS);
      if (removedItem != null) {
        ThreadContext threadContext=ThreadContext.get();
        TransactionImpl txn=threadContext.getCallContext().getTransaction();
        final Data removedItemData=toData(removedItem);
        if (txn != null && txn.getStatus() == Transaction.TXN_STATUS_ACTIVE) {
          txn.attachRemoveOp(name,key,removedItemData,true);
        }
        fireQueueEvent(name,EntryEventType.REMOVED,removedItemData);
      }
    }
 catch (    TimeoutException e) {
      throw new OperationTimeoutException(e);
    }
    long now=Clock.currentTimeMillis();
    timeout-=(now - start);
    start=now;
  }
  return removedItem;
}",0.9995431703974418
49457,"public void rollbackPoll(String name,Object key,Object obj){
  final Data dataKey=toData(key);
  if (addKeyAsync) {
    sendKeyToMaster(name,dataKey,0);
  }
 else {
    addKey(name,dataKey,0);
  }
}","public void rollbackPoll(String name,Object key){
  final Data dataKey=toData(key);
  if (addKeyAsync) {
    sendKeyToMaster(name,dataKey,0);
  }
 else {
    addKey(name,dataKey,0);
  }
}",0.9714285714285714
49458,"void doShutdown(boolean force){
  long start=Clock.currentTimeMillis();
  logger.log(Level.FINEST,""String_Node_Str"" + String.valueOf(active));
  if (!force && isActive()) {
    final int maxWaitSeconds=groupProperties.GRACEFUL_SHUTDOWN_MAX_WAIT.getInteger();
    int waitSeconds=0;
    do {
      try {
        Thread.sleep(500);
      }
 catch (      InterruptedException e) {
      }
    }
 while (concurrentMapManager.partitionManager.hasActiveBackupTask() && ++waitSeconds < maxWaitSeconds);
    if (waitSeconds >= maxWaitSeconds) {
      logger.log(Level.WARNING,""String_Node_Str"" + maxWaitSeconds + ""String_Node_Str"");
    }
  }
  if (isActive()) {
    joined.set(false);
    setActive(false);
    setMasterAddress(null);
    wanReplicationService.shutdown();
    try {
      Runtime.getRuntime().removeShutdownHook(shutdownHookThread);
    }
 catch (    Throwable ignored) {
    }
    if (managementCenterService != null) {
      managementCenterService.shutdown();
    }
    logger.log(Level.FINEST,""String_Node_Str"");
    clientHandlerService.shutdown();
    logger.log(Level.FINEST,""String_Node_Str"");
    concurrentMapManager.shutdown();
    logger.log(Level.FINEST,""String_Node_Str"");
    clusterService.stop();
    if (multicastService != null) {
      logger.log(Level.FINEST,""String_Node_Str"");
      multicastService.stop();
    }
    logger.log(Level.FINEST,""String_Node_Str"");
    connectionManager.shutdown();
    logger.log(Level.FINEST,""String_Node_Str"");
    executorManager.stop();
    textCommandService.stop();
    masterAddress=null;
    if (securityContext != null) {
      securityContext.destroy();
    }
    initializer.destroy();
    int numThreads=threadGroup.activeCount();
    Thread[] threads=new Thread[numThreads * 2];
    numThreads=threadGroup.enumerate(threads,false);
    for (int i=0; i < numThreads; i++) {
      Thread thread=threads[i];
      logger.log(Level.FINEST,""String_Node_Str"" + thread.getName());
      thread.interrupt();
    }
    failedConnections.clear();
    serviceThreadPacketQueue.clear();
    systemLogService.shutdown();
    ThreadContext.get().shutdown(this.factory);
    logger.log(Level.INFO,""String_Node_Str"" + (Clock.currentTimeMillis() - start) + ""String_Node_Str"");
  }
}","void doShutdown(boolean force){
  long start=Clock.currentTimeMillis();
  logger.log(Level.FINEST,""String_Node_Str"" + String.valueOf(active));
  if (!force && isActive()) {
    final int maxWaitSeconds=groupProperties.GRACEFUL_SHUTDOWN_MAX_WAIT.getInteger();
    int waitSeconds=0;
    do {
      try {
        Thread.sleep(500);
      }
 catch (      InterruptedException e) {
      }
    }
 while (concurrentMapManager.partitionManager.hasActiveBackupTask() && ++waitSeconds < maxWaitSeconds);
    if (waitSeconds >= maxWaitSeconds) {
      logger.log(Level.WARNING,""String_Node_Str"" + maxWaitSeconds + ""String_Node_Str"");
    }
  }
  if (isActive()) {
    joined.set(false);
    setActive(false);
    setMasterAddress(null);
    wanReplicationService.shutdown();
    try {
      Runtime.getRuntime().removeShutdownHook(shutdownHookThread);
    }
 catch (    Throwable ignored) {
    }
    if (managementCenterService != null) {
      managementCenterService.shutdown();
    }
    logger.log(Level.FINEST,""String_Node_Str"");
    clientHandlerService.shutdown();
    logger.log(Level.FINEST,""String_Node_Str"");
    connectionManager.shutdown();
    if (multicastService != null) {
      logger.log(Level.FINEST,""String_Node_Str"");
      multicastService.stop();
    }
    logger.log(Level.FINEST,""String_Node_Str"");
    concurrentMapManager.shutdown();
    logger.log(Level.FINEST,""String_Node_Str"");
    clusterService.stop();
    logger.log(Level.FINEST,""String_Node_Str"");
    executorManager.stop();
    textCommandService.stop();
    masterAddress=null;
    if (securityContext != null) {
      securityContext.destroy();
    }
    initializer.destroy();
    int numThreads=threadGroup.activeCount();
    Thread[] threads=new Thread[numThreads * 2];
    numThreads=threadGroup.enumerate(threads,false);
    for (int i=0; i < numThreads; i++) {
      Thread thread=threads[i];
      logger.log(Level.FINEST,""String_Node_Str"" + thread.getName());
      thread.interrupt();
    }
    failedConnections.clear();
    serviceThreadPacketQueue.clear();
    systemLogService.shutdown();
    ThreadContext.get().shutdown(this.factory);
    logger.log(Level.INFO,""String_Node_Str"" + (Clock.currentTimeMillis() - start) + ""String_Node_Str"");
  }
}",0.9085637823371988
49459,"public void rollbackMap(){
  MProxy mapProxy=null;
  Object proxy=factory.getOrCreateProxyByName(name);
  if (proxy instanceof MProxy) {
    mapProxy=(MProxy)proxy;
  }
  if (mapProxy != null)   mapProxy.unlock(key);
}","public void rollbackMap(){
  factory.node.concurrentMapManager.new MLock().unlock(name,key,-1);
}",0.3809523809523809
49460,"public void rollbackQueue(){
  if (removed) {
    factory.node.blockingQueueManager.rollbackPoll(name,key,value);
  }
}","public void rollbackQueue(){
  if (removed) {
    factory.node.blockingQueueManager.rollbackPoll(name,key);
  }
}",0.9741379310344828
49461,"public void close0() throws IOException {
  if (!live)   return;
  live=false;
  if (socketChannel != null && socketChannel.isOpen()) {
    socketChannel.close();
  }
  readHandler.shutdown();
  writeHandler.shutdown();
}","public void close0() throws IOException {
  if (!live) {
    return;
  }
  readHandler.shutdown();
  writeHandler.shutdown();
  live=false;
  if (socketChannel != null && socketChannel.isOpen()) {
    socketChannel.close();
  }
}",0.7111111111111111
49462,"private void stop(){
  live=false;
  log(Level.FINEST,""String_Node_Str"");
  shutdownSocketAcceptor();
  ioService.onShutdown();
  for (  Connection conn : mapConnections.values()) {
    try {
      destroyConnection(conn);
    }
 catch (    final Throwable ignore) {
      logger.log(Level.FINEST,ignore.getMessage(),ignore);
    }
  }
  for (  Connection conn : setActiveConnections) {
    try {
      destroyConnection(conn);
    }
 catch (    final Throwable ignore) {
      logger.log(Level.FINEST,ignore.getMessage(),ignore);
    }
  }
  shutdownIOSelectors();
  setConnectionInProgress.clear();
  mapConnections.clear();
  mapMonitors.clear();
  setActiveConnections.clear();
}","private void stop(){
  live=false;
  log(Level.FINEST,""String_Node_Str"");
  shutdownSocketAcceptor();
  ioService.onShutdown();
  closeConnections(mapConnections.values());
  closeConnections(setActiveConnections);
  shutdownIOSelectors();
  setConnectionInProgress.clear();
  mapConnections.clear();
  mapMonitors.clear();
  setActiveConnections.clear();
}",0.6115384615384616
49463,"@Override public void shutdown(){
  Object obj=poll();
  while (obj != null) {
    obj=poll();
  }
}","@Override public void shutdown(){
  writeQueue.clear();
}",0.5605095541401274
49464,"private Address createAddress(final AddressDefinition addressDef,final int port) throws UnknownHostException {
  return new Address(addressDef.host != null ? addressDef.host : addressDef.address,port);
}","private Address createAddress(final AddressDefinition addressDef,final int port) throws UnknownHostException {
  return addressDef.host != null ? new Address(addressDef.host,port) : new Address(addressDef.inetAddress,port);
}",0.8878504672897196
49465,public void searchForOtherClusters(SplitBrainHandler splitBrainHandler);,void searchForOtherClusters(SplitBrainHandler splitBrainHandler);,0.948905109489051
49466,public void join(AtomicBoolean joined);,void join(AtomicBoolean joined);,0.9014084507042254
49467,"private Collection<Address> getPossibleAddresses(){
  final Collection<String> possibleMembers=getMembers();
  final Set<Address> possibleAddresses=new HashSet<Address>();
  final NetworkConfig networkConfig=config.getNetworkConfig();
  for (  String possibleMember : possibleMembers) {
    try {
      final AddressHolder addressHolder=AddressUtil.getAddressHolder(possibleMember);
      final boolean portIsDefined=addressHolder.port != -1 || !networkConfig.isPortAutoIncrement();
      final int count=portIsDefined ? 1 : MAX_PORT_TRIES;
      final int port=addressHolder.port != -1 ? addressHolder.port : networkConfig.getPort();
      AddressMatcher addressMatcher=null;
      try {
        addressMatcher=AddressUtil.getAddressMatcher(addressHolder.address);
      }
 catch (      InvalidAddressException ignore) {
      }
      if (addressMatcher != null) {
        final Collection<String> matchedAddresses;
        if (addressMatcher.isIPv4()) {
          matchedAddresses=AddressUtil.getMatchingIpv4Addresses(addressMatcher);
        }
 else {
          matchedAddresses=Collections.singleton(addressHolder.address);
        }
        for (        String matchedAddress : matchedAddresses) {
          addPossibleAddresses(possibleAddresses,matchedAddress,null,port,count);
        }
      }
 else {
        final String host=addressHolder.address;
        final Interfaces interfaces=networkConfig.getInterfaces();
        if (interfaces.isEnabled()) {
          final InetAddress[] inetAddresses=InetAddress.getAllByName(host);
          if (inetAddresses.length > 1) {
            for (            InetAddress inetAddress : inetAddresses) {
              if (AddressUtil.matchAnyInterface(inetAddress.getHostAddress(),interfaces.getInterfaces())) {
                addPossibleAddresses(possibleAddresses,null,inetAddress,port,count);
              }
            }
          }
 else {
            final InetAddress inetAddress=inetAddresses[0];
            if (AddressUtil.matchAnyInterface(inetAddress.getHostAddress(),interfaces.getInterfaces())) {
              addPossibleAddresses(possibleAddresses,host,null,port,count);
            }
          }
        }
 else {
          addPossibleAddresses(possibleAddresses,host,null,port,count);
        }
      }
    }
 catch (    UnknownHostException e) {
      logger.log(Level.WARNING,e.getMessage(),e);
    }
  }
  possibleAddresses.addAll(networkConfig.getJoin().getTcpIpConfig().getAddresses());
  return possibleAddresses;
}","private Collection<Address> getPossibleAddresses(){
  final Collection<String> possibleMembers=getMembers();
  final Set<Address> possibleAddresses=new HashSet<Address>();
  final NetworkConfig networkConfig=config.getNetworkConfig();
  for (  String possibleMember : possibleMembers) {
    try {
      final AddressHolder addressHolder=AddressUtil.getAddressHolder(possibleMember);
      final boolean portIsDefined=addressHolder.port != -1 || !networkConfig.isPortAutoIncrement();
      final int count=portIsDefined ? 1 : MAX_PORT_TRIES;
      final int port=addressHolder.port != -1 ? addressHolder.port : networkConfig.getPort();
      AddressMatcher addressMatcher=null;
      try {
        addressMatcher=AddressUtil.getAddressMatcher(addressHolder.address);
      }
 catch (      InvalidAddressException ignore) {
      }
      if (addressMatcher != null) {
        final Collection<String> matchedAddresses;
        if (addressMatcher.isIPv4()) {
          matchedAddresses=AddressUtil.getMatchingIpv4Addresses(addressMatcher);
        }
 else {
          matchedAddresses=Collections.singleton(addressHolder.address);
        }
        for (        String matchedAddress : matchedAddresses) {
          addPossibleAddresses(possibleAddresses,null,InetAddress.getByName(matchedAddress),port,count);
        }
      }
 else {
        final String host=addressHolder.address;
        final Interfaces interfaces=networkConfig.getInterfaces();
        if (interfaces.isEnabled()) {
          final InetAddress[] inetAddresses=InetAddress.getAllByName(host);
          if (inetAddresses.length > 1) {
            for (            InetAddress inetAddress : inetAddresses) {
              if (AddressUtil.matchAnyInterface(inetAddress.getHostAddress(),interfaces.getInterfaces())) {
                addPossibleAddresses(possibleAddresses,null,inetAddress,port,count);
              }
            }
          }
 else {
            final InetAddress inetAddress=inetAddresses[0];
            if (AddressUtil.matchAnyInterface(inetAddress.getHostAddress(),interfaces.getInterfaces())) {
              addPossibleAddresses(possibleAddresses,host,null,port,count);
            }
          }
        }
 else {
          addPossibleAddresses(possibleAddresses,host,null,port,count);
        }
      }
    }
 catch (    UnknownHostException e) {
      logger.log(Level.WARNING,e.getMessage(),e);
    }
  }
  possibleAddresses.addAll(networkConfig.getJoin().getTcpIpConfig().getAddresses());
  return possibleAddresses;
}",0.9934092270820852
49468,"public void searchForOtherClusters(SplitBrainHandler splitBrainHandler){
  final Collection<Address> colPossibleAddresses;
  try {
    colPossibleAddresses=getPossibleAddresses();
  }
 catch (  Throwable e) {
    logger.log(Level.SEVERE,e.getMessage(),e);
    return;
  }
  colPossibleAddresses.remove(node.getThisAddress());
  for (  Member member : node.getClusterService().getMembers()) {
    colPossibleAddresses.remove(((MemberImpl)member).getAddress());
  }
  if (colPossibleAddresses.isEmpty()) {
    return;
  }
  for (  Address possibleAddress : colPossibleAddresses) {
    logger.log(Level.WARNING,node.getThisAddress() + ""String_Node_Str"" + possibleAddress);
    node.connectionManager.getOrConnect(possibleAddress,true);
    try {
      Thread.sleep(1500);
    }
 catch (    InterruptedException e) {
      return;
    }
    final Connection conn=node.connectionManager.getConnection(possibleAddress);
    if (conn != null) {
      final JoinInfo response=node.clusterService.checkJoin(possibleAddress);
      System.out.println(""String_Node_Str"" + response);
      if (response != null && shouldMerge(response)) {
        logger.log(Level.WARNING,node.address + ""String_Node_Str"" + possibleAddress);
        targetAddress=possibleAddress;
        sendClusterMergeToOthers(targetAddress);
        splitBrainHandler.restart();
        return;
      }
    }
  }
}","public void searchForOtherClusters(SplitBrainHandler splitBrainHandler){
  final Collection<Address> colPossibleAddresses;
  try {
    colPossibleAddresses=getPossibleAddresses();
  }
 catch (  Throwable e) {
    logger.log(Level.SEVERE,e.getMessage(),e);
    return;
  }
  colPossibleAddresses.remove(node.getThisAddress());
  for (  Member member : node.getClusterService().getMembers()) {
    colPossibleAddresses.remove(((MemberImpl)member).getAddress());
  }
  if (colPossibleAddresses.isEmpty()) {
    return;
  }
  for (  Address possibleAddress : colPossibleAddresses) {
    logger.log(Level.FINEST,node.getThisAddress() + ""String_Node_Str"" + possibleAddress);
    node.connectionManager.getOrConnect(possibleAddress,true);
    try {
      Thread.sleep(1500);
    }
 catch (    InterruptedException e) {
      return;
    }
    final Connection conn=node.connectionManager.getConnection(possibleAddress);
    if (conn != null) {
      final JoinInfo response=node.clusterService.checkJoinInfo(possibleAddress);
      System.out.println(""String_Node_Str"" + response);
      if (response != null && shouldMerge(response)) {
        logger.log(Level.WARNING,node.address + ""String_Node_Str"" + possibleAddress);
        targetAddress=possibleAddress;
        sendClusterMergeToOthers(targetAddress);
        splitBrainHandler.restart();
        return;
      }
    }
  }
}",0.4932702801018552
49469,"private void tryToConnect(final InetSocketAddress socketAddress,final int timeout) throws Exception {
  final SocketChannel socketChannel=SocketChannel.open();
  connectionManager.initSocket(socketChannel.socket());
  if (!connectionManager.ioService.isSocketBindAny()) {
    final Address thisAddress=connectionManager.ioService.getThisAddress();
    socketChannel.socket().bind(new InetSocketAddress(thisAddress.getInetAddress(),0));
  }
  final String message=""String_Node_Str"" + socketAddress + ""String_Node_Str""+ timeout+ ""String_Node_Str""+ connectionManager.ioService.isSocketBindAny();
  log(Level.FINEST,message);
  try {
    socketChannel.configureBlocking(true);
    if (timeout > 0) {
      socketChannel.socket().connect(socketAddress,timeout);
    }
 else {
      socketChannel.connect(socketAddress);
    }
    log(Level.FINEST,""String_Node_Str"" + address + ""String_Node_Str""+ socketChannel.socket());
    MemberSocketInterceptor memberSocketInterceptor=connectionManager.getMemberSocketInterceptor();
    if (memberSocketInterceptor != null) {
      log(Level.FINEST,""String_Node_Str"" + memberSocketInterceptor + ""String_Node_Str""+ socketChannel);
      memberSocketInterceptor.onConnect(socketChannel.socket());
    }
    socketChannel.configureBlocking(false);
    final SocketChannelWrapper socketChannelWrapper=connectionManager.wrapSocketChannel(socketChannel,true);
    Connection connection=connectionManager.assignSocketChannel(socketChannelWrapper);
    connectionManager.sendBindRequest(connection,address,true);
  }
 catch (  Exception e) {
    closeSocket(socketChannel);
    final Level level=silent ? Level.FINEST : Level.INFO;
    log(level,""String_Node_Str"" + socketAddress + ""String_Node_Str""+ e.getClass().getSimpleName()+ ""String_Node_Str""+ e.getMessage()+ ""String_Node_Str"");
    throw e;
  }
}","private void tryToConnect(final InetSocketAddress socketAddress,final int timeout) throws Exception {
  final SocketChannel socketChannel=SocketChannel.open();
  connectionManager.initSocket(socketChannel.socket());
  if (!connectionManager.ioService.isSocketBindAny()) {
    final Address thisAddress=connectionManager.ioService.getThisAddress();
    socketChannel.socket().bind(new InetSocketAddress(thisAddress.getInetAddress(),0));
  }
  final String message=""String_Node_Str"" + socketAddress + ""String_Node_Str""+ timeout+ ""String_Node_Str""+ connectionManager.ioService.isSocketBindAny();
  log(Level.INFO,message);
  try {
    socketChannel.configureBlocking(true);
    if (timeout > 0) {
      socketChannel.socket().connect(socketAddress,timeout);
    }
 else {
      socketChannel.connect(socketAddress);
    }
    log(Level.FINEST,""String_Node_Str"" + address + ""String_Node_Str""+ socketChannel.socket());
    MemberSocketInterceptor memberSocketInterceptor=connectionManager.getMemberSocketInterceptor();
    if (memberSocketInterceptor != null) {
      log(Level.FINEST,""String_Node_Str"" + memberSocketInterceptor + ""String_Node_Str""+ socketChannel);
      memberSocketInterceptor.onConnect(socketChannel.socket());
    }
    socketChannel.configureBlocking(false);
    final SocketChannelWrapper socketChannelWrapper=connectionManager.wrapSocketChannel(socketChannel,true);
    Connection connection=connectionManager.assignSocketChannel(socketChannelWrapper);
    connectionManager.sendBindRequest(connection,address,true);
  }
 catch (  Exception e) {
    closeSocket(socketChannel);
    final Level level=silent ? Level.FINEST : Level.INFO;
    log(level,""String_Node_Str"" + socketAddress + ""String_Node_Str""+ e.getClass().getSimpleName()+ ""String_Node_Str""+ e.getMessage()+ ""String_Node_Str"");
    throw e;
  }
}",0.5071115973741794
49470,"public void run(){
  if (!connectionManager.isLive()) {
    String message=""String_Node_Str"" + address + ""String_Node_Str"";
    log(Level.FINEST,message);
    return;
  }
  try {
    connectionManager.ioService.onIOThreadStart();
    log(Level.FINEST,""String_Node_Str"" + address);
    final Address thisAddress=connectionManager.ioService.getThisAddress();
    if (address.isIPv4()) {
      tryToConnect(address.getInetSocketAddress(),0);
    }
 else     if (thisAddress.isIPv6() && thisAddress.getScopeId() != null) {
      final Inet6Address inetAddress=AddressUtil.getInetAddressFor((Inet6Address)address.getInetAddress(),thisAddress.getScopeId());
      tryToConnect(new InetSocketAddress(inetAddress,address.getPort()),0);
    }
 else {
      final Collection<Inet6Address> possibleInetAddresses=AddressUtil.getPossibleInetAddressesFor((Inet6Address)address.getInetAddress());
      log(Level.INFO,""String_Node_Str"" + possibleInetAddresses);
      boolean connected=false;
      Exception error=null;
      for (      Inet6Address inetAddress : possibleInetAddresses) {
        try {
          tryToConnect(new InetSocketAddress(inetAddress,address.getPort()),3000);
          connected=true;
          break;
        }
 catch (        Exception e) {
          error=e;
        }
      }
      if (!connected) {
        throw error;
      }
    }
  }
 catch (  Throwable e) {
    logger.log(Level.FINEST,e.getMessage(),e);
    connectionManager.failedConnection(address,e,silent);
  }
}","public void run(){
  if (!connectionManager.isLive()) {
    String message=""String_Node_Str"" + address + ""String_Node_Str"";
    log(Level.FINEST,message);
    return;
  }
  try {
    connectionManager.ioService.onIOThreadStart();
    log(Level.FINEST,""String_Node_Str"" + address);
    final Address thisAddress=connectionManager.ioService.getThisAddress();
    if (address.isIPv4()) {
      tryToConnect(address.getInetSocketAddress(),0);
    }
 else     if (thisAddress.isIPv6() && thisAddress.getScopeId() != null) {
      final Inet6Address inetAddress=AddressUtil.getInetAddressFor((Inet6Address)address.getInetAddress(),thisAddress.getScopeId());
      tryToConnect(new InetSocketAddress(inetAddress,address.getPort()),0);
    }
 else {
      final Collection<Inet6Address> possibleInetAddresses=AddressUtil.getPossibleInetAddressesFor((Inet6Address)address.getInetAddress());
      final Level level=silent ? Level.FINEST : Level.INFO;
      log(level,""String_Node_Str"" + possibleInetAddresses);
      boolean connected=false;
      Exception error=null;
      for (      Inet6Address inetAddress : possibleInetAddresses) {
        try {
          tryToConnect(new InetSocketAddress(inetAddress,address.getPort()),3000);
          connected=true;
          break;
        }
 catch (        Exception e) {
          error=e;
        }
      }
      if (!connected) {
        throw error;
      }
    }
  }
 catch (  Throwable e) {
    logger.log(Level.FINEST,e.getMessage(),e);
    connectionManager.failedConnection(address,e,silent);
  }
}",0.9792558445834704
49471,"public static Collection<Inet6Address> getPossibleInetAddressesFor(final Inet6Address inet6Address){
  if (inet6Address.getScopeId() <= 0 && inet6Address.getScopedInterface() == null) {
    final LinkedList<Inet6Address> possibleAddresses=new LinkedList<Inet6Address>();
    try {
      final Enumeration<NetworkInterface> interfaces=NetworkInterface.getNetworkInterfaces();
      while (interfaces.hasMoreElements()) {
        NetworkInterface ni=interfaces.nextElement();
        Enumeration<InetAddress> addresses=ni.getInetAddresses();
        while (addresses.hasMoreElements()) {
          InetAddress address=addresses.nextElement();
          if (address instanceof Inet4Address) {
            continue;
          }
          if (inet6Address.isLinkLocalAddress() && address.isLinkLocalAddress() || inet6Address.isSiteLocalAddress() && address.isSiteLocalAddress()) {
            final Inet6Address newAddress=Inet6Address.getByAddress(null,inet6Address.getAddress(),((Inet6Address)address).getScopeId());
            possibleAddresses.addFirst(newAddress);
          }
        }
      }
    }
 catch (    IOException ignored) {
    }
    if (possibleAddresses.isEmpty()) {
      throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + inet6Address);
    }
    return possibleAddresses;
  }
  return Collections.singleton(inet6Address);
}","public static Collection<Inet6Address> getPossibleInetAddressesFor(final Inet6Address inet6Address){
  if ((inet6Address.isSiteLocalAddress() || inet6Address.isLinkLocalAddress()) && inet6Address.getScopeId() <= 0 && inet6Address.getScopedInterface() == null) {
    final LinkedList<Inet6Address> possibleAddresses=new LinkedList<Inet6Address>();
    try {
      final Enumeration<NetworkInterface> interfaces=NetworkInterface.getNetworkInterfaces();
      while (interfaces.hasMoreElements()) {
        NetworkInterface ni=interfaces.nextElement();
        Enumeration<InetAddress> addresses=ni.getInetAddresses();
        while (addresses.hasMoreElements()) {
          InetAddress address=addresses.nextElement();
          if (address instanceof Inet4Address) {
            continue;
          }
          if (inet6Address.isLinkLocalAddress() && address.isLinkLocalAddress() || inet6Address.isSiteLocalAddress() && address.isSiteLocalAddress()) {
            final Inet6Address newAddress=Inet6Address.getByAddress(null,inet6Address.getAddress(),((Inet6Address)address).getScopeId());
            possibleAddresses.addFirst(newAddress);
          }
        }
      }
    }
 catch (    IOException ignored) {
    }
    if (possibleAddresses.isEmpty()) {
      throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + inet6Address);
    }
    return possibleAddresses;
  }
  return Collections.singleton(inet6Address);
}",0.9729151817533856
49472,"private boolean returnResponse(Request request,Connection conn,RedoType redoType){
  if (systemLogService.shouldLog(INFO)) {
    systemLogService.logObject(request,INFO,""String_Node_Str"");
  }
  if (request.local) {
    final TargetAwareOp targetAwareOp=(TargetAwareOp)request.attachment;
    if (request.response == OBJECT_REDO) {
      targetAwareOp.setRedoResult(redoType);
    }
 else {
      targetAwareOp.setResult(request.response);
    }
  }
 else {
    Packet packet=obtainPacket();
    packet.setFromRequest(request);
    packet.operation=ClusterOperation.RESPONSE;
    packet.responseType=RESPONSE_SUCCESS;
    packet.longValue=request.longValue;
    if (request.value != null) {
      packet.setValue(request.value);
    }
    if (request.response == OBJECT_REDO) {
      packet.lockAddress=null;
      packet.responseType=RESPONSE_REDO;
      packet.redoData=redoType != null ? redoType.getCode() : REDO_UNKNOWN.getCode();
      if (systemLogService.shouldInfo()) {
        systemLogService.info(request,""String_Node_Str"");
      }
    }
 else     if (request.response != null) {
      if (request.response instanceof Boolean) {
        if (request.response == Boolean.FALSE) {
          packet.responseType=RESPONSE_FAILURE;
        }
      }
 else       if (request.response instanceof Long) {
        packet.longValue=(Long)request.response;
      }
 else {
        Data data;
        if (request.response instanceof Data) {
          data=(Data)request.response;
        }
 else {
          data=toData(request.response);
        }
        if (data != null && data.size() > 0) {
          packet.setValue(data);
        }
      }
    }
    if (conn != null) {
      conn.getWriteHandler().enqueueSocketWritable(packet);
    }
 else {
      return sendResponse(packet,request.caller);
    }
  }
  return true;
}","public boolean returnResponse(Request request,Connection conn){
  if (systemLogService.shouldLog(INFO)) {
    systemLogService.logObject(request,INFO,""String_Node_Str"");
  }
  if (request.local) {
    final TargetAwareOp targetAwareOp=(TargetAwareOp)request.attachment;
    if (request.response == OBJECT_REDO) {
      targetAwareOp.setRedoResult(RedoType.getRedoType(request.redoCode));
    }
 else {
      targetAwareOp.setResult(request.response);
    }
  }
 else {
    Packet packet=obtainPacket();
    packet.setFromRequest(request);
    packet.operation=ClusterOperation.RESPONSE;
    packet.responseType=RESPONSE_SUCCESS;
    packet.longValue=request.longValue;
    if (request.value != null) {
      packet.setValue(request.value);
    }
    if (request.response == OBJECT_REDO) {
      packet.lockAddress=null;
      packet.responseType=RESPONSE_REDO;
      packet.redoData=request.redoCode;
      if (systemLogService.shouldInfo()) {
        systemLogService.info(request,""String_Node_Str"");
      }
    }
 else     if (request.response != null) {
      if (request.response instanceof Boolean) {
        if (request.response == Boolean.FALSE) {
          packet.responseType=RESPONSE_FAILURE;
        }
      }
 else       if (request.response instanceof Long) {
        packet.longValue=(Long)request.response;
      }
 else {
        Data data;
        if (request.response instanceof Data) {
          data=(Data)request.response;
        }
 else {
          data=toData(request.response);
        }
        if (data != null && data.size() > 0) {
          packet.setValue(data);
        }
      }
    }
    if (conn != null) {
      conn.getWriteHandler().enqueueSocketWritable(packet);
    }
 else {
      return sendResponse(packet,request.caller);
    }
  }
  return true;
}",0.9649074329925392
49473,"public boolean returnRedoResponse(Request request,RedoType redoType){
  logRedo(request,redoType,false);
  request.clearForResponse();
  request.response=OBJECT_REDO;
  return returnResponse(request,null,redoType);
}","public boolean returnRedoResponse(Request request,RedoType redoType){
  setRedoResponse(request,redoType);
  return returnResponse(request,null);
}",0.7493112947658402
49474,"public Object putFromLoad(String name,Object key,Object value){
  return txnalPut(CONCURRENT_MAP_PUT_FROM_LOAD,name,key,value,-1,-1);
}","public Object putFromLoad(String name,Object key,Object value){
  return txnalPut(CONCURRENT_MAP_PUT_FROM_LOAD,name,key,value,0,-1);
}",0.9888475836431226
49475,"private Connection searchForAvailableConnection(){
  Connection connection=null;
  popAndPush(clusterMembers);
  int counter=clusterMembers.size();
  while (counter > 0) {
    try {
      connection=getNextConnection();
      break;
    }
 catch (    Exception e) {
      logger.log(Level.FINEST,e.getMessage(),e);
      popAndPush(clusterMembers);
      counter--;
    }
  }
  logger.log(Level.FINEST,format(""String_Node_Str"",connection));
  return connection;
}","private Connection searchForAvailableConnection(){
  Connection connection=null;
  popAndPush(clusterMembers);
  if (clusterMembers.isEmpty()) {
    clusterMembers.addAll(initialClusterMembers);
  }
  int counter=clusterMembers.size();
  while (counter > 0) {
    try {
      connection=getNextConnection();
      break;
    }
 catch (    Exception e) {
      logger.log(Level.FINEST,e.getMessage(),e);
      popAndPush(clusterMembers);
      counter--;
    }
  }
  logger.log(Level.FINEST,format(""String_Node_Str"",connection));
  return connection;
}",0.9132149901380672
49476,"public ConnectionManager(HazelcastClient client,ClientConfig config,LifecycleServiceClientImpl lifecycleService){
  this.config=config;
  this.client=client;
  this.lifecycleService=lifecycleService;
  this.clusterMembers.addAll(config.getAddressList());
  if (config.isShuffle()) {
    Collections.shuffle(this.clusterMembers);
  }
}","public ConnectionManager(HazelcastClient client,ClientConfig config,LifecycleServiceClientImpl lifecycleService){
  this.config=config;
  this.client=client;
  this.lifecycleService=lifecycleService;
  this.clusterMembers.addAll(config.getAddressList());
  this.initialClusterMembers.addAll(config.getAddressList());
  if (config.isShuffle()) {
    Collections.shuffle(this.clusterMembers);
    Collections.shuffle(this.initialClusterMembers);
  }
}",0.7100893997445722
49477,"public void memberAdded(MembershipEvent membershipEvent){
  InetSocketAddress address=membershipEvent.getMember().getInetSocketAddress();
  Collection<InetSocketAddress> addresses=AddressHelper.getPossibleSocketAddresses(address.getAddress(),address.getPort());
  clusterMembers.addAll(addresses);
}","public void memberAdded(MembershipEvent membershipEvent){
  InetSocketAddress address=membershipEvent.getMember().getInetSocketAddress();
  Collection<InetSocketAddress> addresses=AddressHelper.getPossibleSocketAddresses(address.getAddress(),address.getPort());
  clusterMembers.addAll(addresses);
  initialClusterMembers.addAll(addresses);
}",0.9329173166926678
49478,"public ClusterManager(final Node node){
  super(node);
  securityLogger=node.loggingService.getLogger(""String_Node_Str"");
  WAIT_MILLIS_BEFORE_JOIN=node.groupProperties.WAIT_SECONDS_BEFORE_JOIN.getInteger() * 1000L;
  MAX_WAIT_SECONDS_BEFORE_JOIN=node.groupProperties.MAX_WAIT_SECONDS_BEFORE_JOIN.getInteger();
  MAX_NO_HEARTBEAT_MILLIS=node.groupProperties.MAX_NO_HEARTBEAT_SECONDS.getInteger() * 1000L;
  HEARTBEAT_INTERVAL_MILLIS=node.groupProperties.HEARTBEAT_INTERVAL_SECONDS.getInteger() * 1000L;
  ICMP_ENABLED=node.groupProperties.ICMP_ENABLED.getBoolean();
  ICMP_TTL=node.groupProperties.ICMP_TTL.getInteger();
  ICMP_TIMEOUT=node.groupProperties.ICMP_TIMEOUT.getInteger();
  node.clusterService.registerPeriodicRunnable(new SplitBrainHandler(node));
  node.clusterService.registerPeriodicRunnable(new Runnable(){
    public void run(){
      long now=Clock.currentTimeMillis();
      if (now - lastHeartbeat >= HEARTBEAT_INTERVAL_MILLIS) {
        heartBeater();
        lastHeartbeat=now;
      }
    }
  }
);
  node.clusterService.registerPeriodicRunnable(new Runnable(){
    public void run(){
      checkScheduledActions();
    }
  }
);
  node.connectionManager.addConnectionListener(this);
  registerPacketProcessor(ClusterOperation.RESPONSE,new PacketProcessor(){
    public void process(    Packet packet){
      handleResponse(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.HEARTBEAT,new PacketProcessor(){
    public void process(    Packet packet){
      releasePacket(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.LOG,new PacketProcessor(){
    public void process(    Packet packet){
      logger.log(Level.parse(packet.name),toObject(packet.getValueData()).toString());
      releasePacket(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.JOIN_CHECK,new PacketProcessor(){
    public void process(    Packet packet){
      Connection conn=packet.conn;
      Request request=Request.copyFromPacket(packet);
      JoinInfo joinInfo=(JoinInfo)toObject(request.value);
      request.clearForResponse();
      if (joinInfo != null && node.joined() && node.isActive()) {
        try {
          node.validateJoinRequest(joinInfo);
          request.response=toData(node.createJoinInfo());
        }
 catch (        Exception e) {
          request.response=toData(e);
        }
      }
      returnResponse(request,conn);
      releasePacket(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.REMOTELY_PROCESS_AND_RESPOND,new PacketProcessor(){
    public void process(    Packet packet){
      Data data=packet.getValueData();
      RemotelyProcessable rp=(RemotelyProcessable)toObject(data);
      rp.setConnection(packet.conn);
      rp.setNode(node);
      rp.process();
      sendResponse(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.REMOTELY_PROCESS,new PacketProcessor(){
    public void process(    Packet packet){
      Data data=packet.getValueData();
      RemotelyProcessable rp=(RemotelyProcessable)toObject(data);
      rp.setConnection(packet.conn);
      rp.setNode(node);
      rp.process();
      releasePacket(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.REMOTELY_CALLABLE_BOOLEAN,new PacketProcessor(){
    public void process(    Packet packet){
      Boolean result;
      AbstractRemotelyCallable<Boolean> callable=null;
      try {
        Data data=packet.getValueData();
        callable=(AbstractRemotelyCallable<Boolean>)toObject(data);
        callable.setConnection(packet.conn);
        callable.setNode(node);
        result=callable.call();
      }
 catch (      Exception e) {
        logger.log(Level.SEVERE,""String_Node_Str"" + callable,e);
        result=Boolean.FALSE;
      }
      if (result == Boolean.TRUE) {
        sendResponse(packet);
      }
 else {
        sendResponseFailure(packet);
      }
    }
  }
);
  registerPacketProcessor(ClusterOperation.REMOTELY_CALLABLE_OBJECT,new PacketProcessor(){
    public void process(    Packet packet){
      Object result;
      AbstractRemotelyCallable<Boolean> callable=null;
      try {
        Data data=packet.getValueData();
        callable=(AbstractRemotelyCallable)toObject(data);
        callable.setConnection(packet.conn);
        callable.setNode(node);
        result=callable.call();
      }
 catch (      Exception e) {
        logger.log(Level.SEVERE,""String_Node_Str"" + callable,e);
        result=null;
      }
      if (result != null) {
        Data value;
        if (result instanceof Data) {
          value=(Data)result;
        }
 else {
          value=toData(result);
        }
        packet.setValue(value);
      }
      sendResponse(packet);
    }
  }
);
}","public ClusterManager(final Node node){
  super(node);
  securityLogger=node.loggingService.getLogger(""String_Node_Str"");
  WAIT_MILLIS_BEFORE_JOIN=node.groupProperties.WAIT_SECONDS_BEFORE_JOIN.getInteger() * 1000L;
  MAX_WAIT_SECONDS_BEFORE_JOIN=node.groupProperties.MAX_WAIT_SECONDS_BEFORE_JOIN.getInteger();
  MAX_NO_HEARTBEAT_MILLIS=node.groupProperties.MAX_NO_HEARTBEAT_SECONDS.getInteger() * 1000L;
  HEARTBEAT_INTERVAL_MILLIS=node.groupProperties.HEARTBEAT_INTERVAL_SECONDS.getInteger() * 1000L;
  ICMP_ENABLED=node.groupProperties.ICMP_ENABLED.getBoolean();
  ICMP_TTL=node.groupProperties.ICMP_TTL.getInteger();
  ICMP_TIMEOUT=node.groupProperties.ICMP_TIMEOUT.getInteger();
  node.clusterService.registerPeriodicRunnable(new SplitBrainHandler(node));
  node.clusterService.registerPeriodicRunnable(new Runnable(){
    public void run(){
      long now=Clock.currentTimeMillis();
      if (now - lastHeartbeat >= HEARTBEAT_INTERVAL_MILLIS) {
        heartBeater();
        lastHeartbeat=now;
      }
    }
  }
);
  node.clusterService.registerPeriodicRunnable(new Runnable(){
    public void run(){
      checkScheduledActions();
    }
  }
);
  node.connectionManager.addConnectionListener(this);
  registerPacketProcessor(ClusterOperation.RESPONSE,new PacketProcessor(){
    public void process(    Packet packet){
      handleResponse(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.HEARTBEAT,new PacketProcessor(){
    public void process(    Packet packet){
      releasePacket(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.LOG,new PacketProcessor(){
    public void process(    Packet packet){
      logger.log(Level.parse(packet.name),toObject(packet.getValueData()).toString());
      releasePacket(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.JOIN_CHECK,new PacketProcessor(){
    public void process(    Packet packet){
      Connection conn=packet.conn;
      Request request=Request.copyFromPacket(packet);
      Data value=request.value;
      request.clearForResponse();
      if (node.isMaster() && node.joined() && node.isActive()) {
        JoinInfo joinInfo=(JoinInfo)toObject(value);
        if (joinInfo != null) {
          try {
            node.validateJoinRequest(joinInfo);
            request.response=toData(node.createJoinInfo());
          }
 catch (          Exception e) {
            request.response=toData(e);
          }
        }
      }
      returnResponse(request,conn);
      releasePacket(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.REMOTELY_PROCESS_AND_RESPOND,new PacketProcessor(){
    public void process(    Packet packet){
      Data data=packet.getValueData();
      RemotelyProcessable rp=(RemotelyProcessable)toObject(data);
      rp.setConnection(packet.conn);
      rp.setNode(node);
      rp.process();
      sendResponse(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.REMOTELY_PROCESS,new PacketProcessor(){
    public void process(    Packet packet){
      Data data=packet.getValueData();
      RemotelyProcessable rp=(RemotelyProcessable)toObject(data);
      rp.setConnection(packet.conn);
      rp.setNode(node);
      rp.process();
      releasePacket(packet);
    }
  }
);
  registerPacketProcessor(ClusterOperation.REMOTELY_CALLABLE_BOOLEAN,new PacketProcessor(){
    public void process(    Packet packet){
      Boolean result;
      AbstractRemotelyCallable<Boolean> callable=null;
      try {
        Data data=packet.getValueData();
        callable=(AbstractRemotelyCallable<Boolean>)toObject(data);
        callable.setConnection(packet.conn);
        callable.setNode(node);
        result=callable.call();
      }
 catch (      Exception e) {
        logger.log(Level.SEVERE,""String_Node_Str"" + callable,e);
        result=Boolean.FALSE;
      }
      if (result == Boolean.TRUE) {
        sendResponse(packet);
      }
 else {
        sendResponseFailure(packet);
      }
    }
  }
);
  registerPacketProcessor(ClusterOperation.REMOTELY_CALLABLE_OBJECT,new PacketProcessor(){
    public void process(    Packet packet){
      Object result;
      AbstractRemotelyCallable<Boolean> callable=null;
      try {
        Data data=packet.getValueData();
        callable=(AbstractRemotelyCallable)toObject(data);
        callable.setConnection(packet.conn);
        callable.setNode(node);
        result=callable.call();
      }
 catch (      Exception e) {
        logger.log(Level.SEVERE,""String_Node_Str"" + callable,e);
        result=null;
      }
      if (result != null) {
        Data value;
        if (result instanceof Data) {
          value=(Data)result;
        }
 else {
          value=toData(result);
        }
        packet.setValue(value);
      }
      sendResponse(packet);
    }
  }
);
}",0.9433604050205676
49479,"private void postJoin(){
  systemLogService.logJoin(""String_Node_Str"" + node.getMasterAddress() + ""String_Node_Str""+ node.isMaster());
  if (!node.isActive()) {
    return;
  }
  if (tryCount.incrementAndGet() == 5) {
    logger.log(Level.WARNING,""String_Node_Str"");
    node.setAsMaster();
  }
  if (!node.isMaster()) {
    boolean allConnected=false;
    int checkCount=0;
    long maxJoinMillis=node.getGroupProperties().MAX_JOIN_SECONDS.getInteger() * 1000;
    if (node.joined()) {
      systemLogService.logJoin(""String_Node_Str"");
      while (checkCount++ < node.groupProperties.CONNECT_ALL_WAIT_SECONDS.getInteger() && !allConnected) {
        try {
          Thread.sleep(1000);
        }
 catch (        InterruptedException ignored) {
        }
        Set<Member> members=node.getClusterImpl().getMembers();
        allConnected=true;
        for (        Member member : members) {
          MemberImpl memberImpl=(MemberImpl)member;
          if (!memberImpl.localMember() && node.connectionManager.getConnection(memberImpl.getAddress()) == null) {
            allConnected=false;
            systemLogService.logJoin(""String_Node_Str"" + memberImpl.getAddress());
          }
        }
      }
    }
    if (!node.joined() || !allConnected) {
      if (Clock.currentTimeMillis() - joinStartTime < maxJoinMillis) {
        logger.log(Level.WARNING,""String_Node_Str"" + node.joined() + ""String_Node_Str""+ allConnected+ ""String_Node_Str""+ checkCount+ ""String_Node_Str"");
        logger.log(Level.WARNING,""String_Node_Str"");
        try {
          Thread.sleep(10000);
          node.rejoin();
        }
 catch (        InterruptedException e) {
          logger.log(Level.WARNING,e.getMessage(),e);
          node.shutdown(false,true);
        }
      }
 else {
        throw new RuntimeException(""String_Node_Str"" + (maxJoinMillis / 1000) + ""String_Node_Str"");
      }
      return;
    }
 else {
      node.clusterManager.finalizeJoin();
    }
  }
  tryCount.set(0);
  node.clusterManager.enqueueAndWait(new Processable(){
    public void process(){
      if (node.baseVariables.lsMembers.size() == 1) {
        final StringBuilder sb=new StringBuilder();
        sb.append(""String_Node_Str"");
        sb.append(node.clusterManager);
        logger.log(Level.INFO,sb.toString());
      }
    }
  }
,5);
}","private void postJoin(){
  systemLogService.logJoin(""String_Node_Str"" + node.getMasterAddress() + ""String_Node_Str""+ node.isMaster());
  if (!node.isActive()) {
    return;
  }
  if (tryCount.incrementAndGet() == 5) {
    logger.log(Level.WARNING,""String_Node_Str"");
    node.setAsMaster();
  }
  if (!node.isMaster()) {
    boolean allConnected=false;
    int checkCount=0;
    long maxJoinMillis=node.getGroupProperties().MAX_JOIN_SECONDS.getInteger() * 1000;
    if (node.joined()) {
      systemLogService.logJoin(""String_Node_Str"");
      while (checkCount++ < node.groupProperties.CONNECT_ALL_WAIT_SECONDS.getInteger() && !allConnected) {
        try {
          Thread.sleep(1000);
        }
 catch (        InterruptedException ignored) {
        }
        Set<Member> members=node.getClusterImpl().getMembers();
        allConnected=true;
        for (        Member member : members) {
          MemberImpl memberImpl=(MemberImpl)member;
          if (!memberImpl.localMember() && node.connectionManager.getConnection(memberImpl.getAddress()) == null) {
            allConnected=false;
            systemLogService.logJoin(""String_Node_Str"" + memberImpl.getAddress());
          }
        }
      }
    }
    if (!node.joined() || !allConnected) {
      if (Clock.currentTimeMillis() - getStartTime() < maxJoinMillis) {
        logger.log(Level.WARNING,""String_Node_Str"" + node.joined() + ""String_Node_Str""+ allConnected+ ""String_Node_Str""+ checkCount+ ""String_Node_Str"");
        logger.log(Level.WARNING,""String_Node_Str"");
        try {
          Thread.sleep(10000);
          node.rejoin();
        }
 catch (        InterruptedException e) {
          logger.log(Level.WARNING,e.getMessage(),e);
          node.shutdown(false,true);
        }
      }
 else {
        throw new RuntimeException(""String_Node_Str"" + (maxJoinMillis / 1000) + ""String_Node_Str"");
      }
      return;
    }
 else {
      node.clusterManager.finalizeJoin();
    }
  }
  node.clusterManager.enqueueAndWait(new Processable(){
    public void process(){
      if (node.baseVariables.lsMembers.size() == 1) {
        final StringBuilder sb=new StringBuilder();
        sb.append(""String_Node_Str"");
        sb.append(node.clusterManager);
        logger.log(Level.INFO,sb.toString());
      }
    }
  }
,5);
}",0.9939367691641404
49480,"public final long getStartTime(){
  return joinStartTime;
}","public final long getStartTime(){
  return joinStartTime.get();
}",0.9516129032258064
49481,"public AbstractJoiner(Node node){
  this.node=node;
  this.systemLogService=node.getSystemLogService();
  if (node.loggingService != null) {
    this.logger=node.loggingService.getLogger(this.getClass().getName());
  }
  this.config=node.config;
}","public AbstractJoiner(Node node){
  this.node=node;
  this.systemLogService=node.getSystemLogService();
  this.logger=node.loggingService.getLogger(this.getClass().getName());
  this.config=node.config;
}",0.7937915742793792
49482,"private Address findMasterWithMulticast(){
  try {
    final String ip=System.getProperty(""String_Node_Str"");
    if (ip == null) {
      JoinInfo joinInfo=node.createJoinInfo();
      for (; node.isActive() && currentTryCount.incrementAndGet() <= tryCount.get(); ) {
        joinInfo.setTryCount(currentTryCount.get());
        node.multicastService.send(joinInfo);
        if (node.getMasterAddress() == null) {
          Thread.sleep(10);
        }
 else {
          return node.getMasterAddress();
        }
      }
    }
 else {
      logger.log(Level.FINEST,""String_Node_Str"");
      return new Address(ip,config.getPort());
    }
  }
 catch (  final Exception e) {
    if (logger != null) {
      logger.log(Level.WARNING,e.getMessage(),e);
    }
  }
 finally {
    this.currentTryCount.set(0);
  }
  return null;
}","private Address findMasterWithMulticast(){
  try {
    final String ip=System.getProperty(""String_Node_Str"");
    if (ip == null) {
      JoinInfo joinInfo=node.createJoinInfo();
      for (; node.isActive() && currentTryCount.incrementAndGet() <= maxTryCount.get(); ) {
        joinInfo.setTryCount(currentTryCount.get());
        node.multicastService.send(joinInfo);
        if (node.getMasterAddress() == null) {
          Thread.sleep(10);
        }
 else {
          return node.getMasterAddress();
        }
      }
    }
 else {
      logger.log(Level.FINEST,""String_Node_Str"");
      return new Address(ip,config.getPort());
    }
  }
 catch (  final Exception e) {
    if (logger != null) {
      logger.log(Level.WARNING,e.getMessage(),e);
    }
  }
 finally {
    this.currentTryCount.set(0);
  }
  return null;
}",0.996964177292046
49483,"public void searchForOtherClusters(SplitBrainHandler splitBrainHandler){
  final BlockingQueue q=new LinkedBlockingQueue();
  MulticastListener listener=new MulticastListener(){
    public void onMessage(    Object msg){
      systemLogService.logJoin(""String_Node_Str"" + msg);
      if (msg != null && msg instanceof JoinInfo) {
        JoinInfo joinInfo=(JoinInfo)msg;
        if (node.address != null && !node.address.equals(joinInfo.address)) {
          q.offer(msg);
        }
      }
    }
  }
;
  node.multicastService.addMulticastListener(listener);
  node.multicastService.send(node.createJoinInfo());
  systemLogService.logJoin(""String_Node_Str"");
  try {
    JoinInfo joinInfo=(JoinInfo)q.poll(3,TimeUnit.SECONDS);
    if (joinInfo != null) {
      if (joinInfo.getMemberCount() == 1) {
        Thread.sleep(node.groupProperties.WAIT_SECONDS_BEFORE_JOIN.getInteger() * 1000L * 2);
      }
      if (shouldMerge(joinInfo)) {
        logger.log(Level.WARNING,node.address + ""String_Node_Str"" + joinInfo.address);
        targetAddress=joinInfo.address;
        node.clusterManager.sendClusterMergeToOthers(targetAddress);
        node.factory.restart();
        return;
      }
    }
  }
 catch (  InterruptedException ignored) {
  }
catch (  Exception e) {
    if (logger != null) {
      logger.log(Level.WARNING,e.getMessage(),e);
    }
  }
 finally {
    node.multicastService.removeMulticastListener(listener);
  }
}","public void searchForOtherClusters(SplitBrainHandler splitBrainHandler){
  final BlockingQueue q=new LinkedBlockingQueue();
  MulticastListener listener=new MulticastListener(){
    public void onMessage(    Object msg){
      systemLogService.logJoin(""String_Node_Str"" + msg);
      if (msg != null && msg instanceof JoinInfo) {
        JoinInfo joinInfo=(JoinInfo)msg;
        if (node.address != null && !node.address.equals(joinInfo.address)) {
          q.offer(msg);
        }
      }
    }
  }
;
  node.multicastService.addMulticastListener(listener);
  node.multicastService.send(node.createJoinInfo());
  systemLogService.logJoin(""String_Node_Str"");
  try {
    JoinInfo joinInfo=(JoinInfo)q.poll(3,TimeUnit.SECONDS);
    if (joinInfo != null) {
      if (joinInfo.getMemberCount() == 1) {
        Thread.sleep(node.groupProperties.WAIT_SECONDS_BEFORE_JOIN.getInteger() * 1000L * 2);
      }
      if (shouldMerge(joinInfo)) {
        logger.log(Level.WARNING,node.address + ""String_Node_Str"" + joinInfo.address);
        targetAddress=joinInfo.address;
        node.clusterManager.sendClusterMergeToOthers(targetAddress);
        splitBrainHandler.restart();
        return;
      }
    }
  }
 catch (  InterruptedException ignored) {
  }
catch (  Exception e) {
    if (logger != null) {
      logger.log(Level.WARNING,e.getMessage(),e);
    }
  }
 finally {
    node.multicastService.removeMulticastListener(listener);
  }
}",0.9898848971049878
49484,"public void onReceivedJoinInfo(JoinInfo joinInfo){
  if (joinInfo.getTryCount() > this.currentTryCount.get() + 20) {
    int timeoutSeconds=(config.getNetworkConfig().getJoin().getMulticastConfig().getMulticastTimeoutSeconds() + 4) * 100;
    this.tryCount.set(timeoutSeconds);
  }
}","public void onReceivedJoinInfo(JoinInfo joinInfo){
  if (joinInfo.getTryCount() > this.currentTryCount.get() + 20) {
    int timeoutSeconds=(config.getNetworkConfig().getJoin().getMulticastConfig().getMulticastTimeoutSeconds() + 4) * 100;
    this.maxTryCount.set(timeoutSeconds);
  }
}",0.9912126537785588
49485,"public MulticastJoiner(Node node){
  super(node);
  tryCount=new AtomicInteger(calculateTryCount());
}","public MulticastJoiner(Node node){
  super(node);
  maxTryCount=new AtomicInteger(calculateTryCount());
}",0.9758454106280192
49486,"void join(){
  final long joinStartTime=joiner != null ? joiner.getStartTime() : Clock.currentTimeMillis();
  final long maxJoinMillis=getGroupProperties().MAX_JOIN_SECONDS.getInteger() * 1000;
  try {
    if (joiner == null) {
      logger.log(Level.WARNING,""String_Node_Str"");
      setAsMaster();
    }
 else {
      joiner.join(joined);
    }
  }
 catch (  Exception e) {
    if (Clock.currentTimeMillis() - joinStartTime < maxJoinMillis) {
      logger.log(Level.WARNING,e.getMessage());
      rejoin();
    }
 else {
      logger.log(Level.SEVERE,e.getMessage(),e);
      shutdown(false,true);
    }
  }
}","void join(){
  final long joinStartTime=joiner != null ? joiner.getStartTime() : Clock.currentTimeMillis();
  final long maxJoinMillis=getGroupProperties().MAX_JOIN_SECONDS.getInteger() * 1000;
  try {
    if (joiner == null) {
      logger.log(Level.WARNING,""String_Node_Str"");
      setAsMaster();
    }
 else {
      joiner.join(joined);
    }
  }
 catch (  Exception e) {
    if (Clock.currentTimeMillis() - joinStartTime < maxJoinMillis) {
      logger.log(Level.WARNING,e.getMessage());
      rejoin();
    }
 else {
      logger.log(Level.SEVERE,""String_Node_Str"",e);
      shutdown(false,true);
    }
  }
}",0.9746938775510204
49487,"public void onRestart(){
  joined.set(false);
  final String uuid=UUID.randomUUID().toString();
  logger.log(Level.FINEST,""String_Node_Str"" + uuid);
  localMember.setUuid(uuid);
}","public void onRestart(){
  joined.set(false);
  joiner.reset();
  final String uuid=UUID.randomUUID().toString();
  logger.log(Level.FINEST,""String_Node_Str"" + uuid);
  localMember.setUuid(uuid);
}",0.952127659574468
49488,"private Address getAddressFor(String host){
  try {
    final AddressHolder addressHolder=AddressUtil.getAddressHolder(host,config.getPort());
    if (AddressUtil.isIpAddress(addressHolder.address)) {
      return new Address(addressHolder.address,addressHolder.port);
    }
 else {
      final InetAddress[] allAddresses=InetAddress.getAllByName(addressHolder.address);
      final Interfaces interfaces=config.getNetworkConfig().getInterfaces();
      for (      final InetAddress inetAddress : allAddresses) {
        boolean matchingAddress=true;
        if (interfaces.isEnabled()) {
          matchingAddress=AddressUtil.matchAnyInterface(inetAddress.getHostAddress(),interfaces.getInterfaces());
        }
        if (matchingAddress) {
          return new Address(inetAddress,addressHolder.port);
        }
      }
    }
  }
 catch (  final Exception e) {
    logger.log(Level.WARNING,e.getMessage(),e);
  }
  return null;
}","private Address getAddressFor(String host){
  try {
    final AddressHolder addressHolder=AddressUtil.getAddressHolder(host,config.getPort());
    if (AddressUtil.isIpAddress(addressHolder.address)) {
      return new Address(addressHolder.address,addressHolder.port);
    }
 else {
      final Interfaces interfaces=config.getNetworkConfig().getInterfaces();
      if (interfaces.isEnabled()) {
        final InetAddress[] inetAddresses=InetAddress.getAllByName(addressHolder.address);
        if (inetAddresses.length > 1) {
          for (          InetAddress inetAddress : inetAddresses) {
            if (AddressUtil.matchAnyInterface(inetAddress.getHostAddress(),interfaces.getInterfaces())) {
              return new Address(inetAddress,addressHolder.port);
            }
          }
        }
 else {
          final InetAddress inetAddress=inetAddresses[0];
          if (AddressUtil.matchAnyInterface(inetAddress.getHostAddress(),interfaces.getInterfaces())) {
            return new Address(addressHolder.address,addressHolder.port);
          }
        }
      }
 else {
        return new Address(addressHolder.address,addressHolder.port);
      }
    }
  }
 catch (  final Exception e) {
    logger.log(Level.WARNING,e.getMessage(),e);
  }
  return null;
}",0.653968253968254
49489,"private void joinViaTargetMember(AtomicBoolean joined,Address targetAddress,long maxJoinMillis){
  try {
    logger.log(Level.FINEST,""String_Node_Str"" + targetAddress);
    if (targetAddress == null) {
      throw new RuntimeException(""String_Node_Str"" + targetAddress);
    }
    if (targetAddress.equals(node.address)) {
      node.setAsMaster();
      return;
    }
    long joinStartTime=Clock.currentTimeMillis();
    Connection connection=null;
    node.getFailedConnections().clear();
    while (node.isActive() && !joined.get() && (Clock.currentTimeMillis() - joinStartTime < maxJoinMillis)) {
      connection=node.connectionManager.getOrConnect(targetAddress);
      if (connection == null) {
        if (node.getFailedConnections().contains(targetAddress)) {
          break;
        }
        Thread.sleep(2000L);
        continue;
      }
      logger.log(Level.FINEST,""String_Node_Str"" + targetAddress);
      node.clusterManager.sendJoinRequest(targetAddress,true);
      Thread.sleep(3000L);
    }
  }
 catch (  final Exception e) {
    logger.log(Level.WARNING,e.getMessage(),e);
  }
}","private void joinViaTargetMember(AtomicBoolean joined,Address targetAddress,long maxJoinMillis){
  try {
    logger.log(Level.FINEST,""String_Node_Str"" + targetAddress);
    if (targetAddress == null) {
      throw new RuntimeException(""String_Node_Str"" + targetAddress);
    }
    if (targetAddress.equals(node.address) || isLocalAddress(targetAddress)) {
      node.setAsMaster();
      return;
    }
    long joinStartTime=Clock.currentTimeMillis();
    Connection connection=null;
    node.getFailedConnections().clear();
    while (node.isActive() && !joined.get() && (Clock.currentTimeMillis() - joinStartTime < maxJoinMillis)) {
      connection=node.connectionManager.getOrConnect(targetAddress);
      if (connection == null) {
        if (node.getFailedConnections().contains(targetAddress)) {
          break;
        }
        Thread.sleep(2000L);
        continue;
      }
      logger.log(Level.FINEST,""String_Node_Str"" + targetAddress);
      node.clusterManager.sendJoinRequest(targetAddress,true);
      Thread.sleep(3000L);
    }
  }
 catch (  final Exception e) {
    logger.log(Level.WARNING,e.getMessage(),e);
  }
}",0.985248100134108
49490,"private Address getAddressFor(String host){
  try {
    final AddressHolder addressHolder=AddressUtil.getAddressHolder(host,config.getPort());
    if (AddressUtil.isIpAddress(addressHolder.address)) {
      return new Address(addressHolder.address,addressHolder.port);
    }
 else {
      final InetAddress[] allAddresses=InetAddress.getAllByName(addressHolder.address);
      final Interfaces interfaces=config.getNetworkConfig().getInterfaces();
      for (      final InetAddress inetAddress : allAddresses) {
        boolean matchingAddress=true;
        if (interfaces.isEnabled()) {
          matchingAddress=AddressUtil.matchAnyInterface(inetAddress.getHostAddress(),interfaces.getInterfaces());
        }
        if (matchingAddress) {
          return new Address(inetAddress,addressHolder.port);
        }
      }
    }
  }
 catch (  final Exception e) {
    logger.log(Level.WARNING,e.getMessage(),e);
  }
  return null;
}","private Address getAddressFor(String host){
  try {
    final AddressHolder addressHolder=AddressUtil.getAddressHolder(host,config.getPort());
    if (AddressUtil.isIpAddress(addressHolder.address)) {
      return new Address(addressHolder.address,addressHolder.port);
    }
 else {
      final Interfaces interfaces=config.getNetworkConfig().getInterfaces();
      if (interfaces.isEnabled()) {
        final InetAddress[] inetAddresses=InetAddress.getAllByName(addressHolder.address);
        if (inetAddresses.length > 1) {
          for (          InetAddress inetAddress : inetAddresses) {
            if (AddressUtil.matchAnyInterface(inetAddress.getHostAddress(),interfaces.getInterfaces())) {
              return new Address(inetAddress,addressHolder.port);
            }
          }
        }
 else {
          final InetAddress inetAddress=inetAddresses[0];
          if (AddressUtil.matchAnyInterface(inetAddress.getHostAddress(),interfaces.getInterfaces())) {
            return new Address(addressHolder.address,addressHolder.port);
          }
        }
      }
 else {
        return new Address(addressHolder.address,addressHolder.port);
      }
    }
  }
 catch (  final Exception e) {
    logger.log(Level.WARNING,e.getMessage(),e);
  }
  return null;
}",0.653968253968254
49491,"private void joinViaTargetMember(AtomicBoolean joined,Address targetAddress,long maxJoinMillis){
  try {
    logger.log(Level.FINEST,""String_Node_Str"" + targetAddress);
    if (targetAddress == null) {
      throw new RuntimeException(""String_Node_Str"" + targetAddress);
    }
    if (targetAddress.equals(node.address)) {
      node.setAsMaster();
      return;
    }
    long joinStartTime=Clock.currentTimeMillis();
    Connection connection=null;
    node.getFailedConnections().clear();
    while (node.isActive() && !joined.get() && (Clock.currentTimeMillis() - joinStartTime < maxJoinMillis)) {
      connection=node.connectionManager.getOrConnect(targetAddress);
      if (connection == null) {
        if (node.getFailedConnections().contains(targetAddress)) {
          break;
        }
        Thread.sleep(2000L);
        continue;
      }
      logger.log(Level.FINEST,""String_Node_Str"" + targetAddress);
      node.clusterImpl.sendJoinRequest(targetAddress,true);
      Thread.sleep(3000L);
    }
  }
 catch (  final Exception e) {
    logger.log(Level.WARNING,e.getMessage(),e);
  }
}","private void joinViaTargetMember(AtomicBoolean joined,Address targetAddress,long maxJoinMillis){
  try {
    logger.log(Level.FINEST,""String_Node_Str"" + targetAddress);
    if (targetAddress == null) {
      throw new RuntimeException(""String_Node_Str"" + targetAddress);
    }
    if (targetAddress.equals(node.address) || isLocalAddress(targetAddress)) {
      node.setAsMaster();
      return;
    }
    long joinStartTime=Clock.currentTimeMillis();
    Connection connection=null;
    node.getFailedConnections().clear();
    while (node.isActive() && !joined.get() && (Clock.currentTimeMillis() - joinStartTime < maxJoinMillis)) {
      connection=node.connectionManager.getOrConnect(targetAddress);
      if (connection == null) {
        if (node.getFailedConnections().contains(targetAddress)) {
          break;
        }
        Thread.sleep(2000L);
        continue;
      }
      logger.log(Level.FINEST,""String_Node_Str"" + targetAddress);
      node.clusterImpl.sendJoinRequest(targetAddress,true);
      Thread.sleep(3000L);
    }
  }
 catch (  final Exception e) {
    logger.log(Level.WARNING,e.getMessage(),e);
  }
}",0.9852084267144778
49492,"boolean shouldMerge(JoinInfo joinInfo){
  boolean shouldMerge=false;
  if (joinInfo != null) {
    boolean validJoinRequest;
    try {
      try {
        validJoinRequest=node.validateJoinRequest(joinInfo);
      }
 catch (      Exception e) {
        validJoinRequest=false;
      }
      if (validJoinRequest) {
        for (        Member member : node.getClusterImpl().getMembers()) {
          MemberImpl memberImpl=(MemberImpl)member;
          if (memberImpl.getAddress().equals(joinInfo.address)) {
            logger.log(Level.FINEST,""String_Node_Str"" + joinInfo.address + ""String_Node_Str"");
            return false;
          }
        }
        int currentMemberCount=node.getClusterImpl().getMembers().size();
        if (joinInfo.getMemberCount() > currentMemberCount) {
          logger.log(Level.INFO,node.address + ""String_Node_Str"" + joinInfo.address+ ""String_Node_Str""+ (joinInfo.getMemberCount() + ""String_Node_Str"" + currentMemberCount)+ ""String_Node_Str"");
          logger.log(Level.FINEST,joinInfo.toString());
          shouldMerge=true;
        }
 else         if (joinInfo.getMemberCount() == currentMemberCount) {
          if (node.getThisAddress().hashCode() > joinInfo.address.hashCode()) {
            logger.log(Level.INFO,node.address + ""String_Node_Str"" + joinInfo.address+ ""String_Node_Str""+ ""String_Node_Str""+ currentMemberCount);
            logger.log(Level.FINEST,joinInfo.toString());
            shouldMerge=true;
          }
        }
      }
    }
 catch (    Throwable e) {
      logger.log(Level.SEVERE,e.getMessage(),e);
      return false;
    }
  }
  return shouldMerge;
}","boolean shouldMerge(JoinInfo joinInfo){
  boolean shouldMerge=false;
  if (joinInfo != null) {
    boolean validJoinRequest;
    try {
      try {
        validJoinRequest=node.validateJoinRequest(joinInfo);
      }
 catch (      Exception e) {
        logger.log(Level.FINEST,e.getMessage());
        validJoinRequest=false;
      }
      if (validJoinRequest) {
        for (        Member member : node.getClusterImpl().getMembers()) {
          MemberImpl memberImpl=(MemberImpl)member;
          if (memberImpl.getAddress().equals(joinInfo.address)) {
            logger.log(Level.FINEST,""String_Node_Str"" + joinInfo.address + ""String_Node_Str"");
            return false;
          }
        }
        int currentMemberCount=node.getClusterImpl().getMembers().size();
        if (joinInfo.getMemberCount() > currentMemberCount) {
          logger.log(Level.INFO,node.address + ""String_Node_Str"" + joinInfo.address+ ""String_Node_Str""+ (joinInfo.getMemberCount() + ""String_Node_Str"" + currentMemberCount)+ ""String_Node_Str"");
          logger.log(Level.FINEST,joinInfo.toString());
          shouldMerge=true;
        }
 else         if (joinInfo.getMemberCount() == currentMemberCount) {
          if (node.getThisAddress().hashCode() > joinInfo.address.hashCode()) {
            logger.log(Level.INFO,node.address + ""String_Node_Str"" + joinInfo.address+ ""String_Node_Str""+ ""String_Node_Str""+ currentMemberCount);
            logger.log(Level.FINEST,joinInfo.toString());
            shouldMerge=true;
          }
 else {
            logger.log(Level.FINEST,joinInfo.address + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ currentMemberCount);
          }
        }
      }
    }
 catch (    Throwable e) {
      logger.log(Level.SEVERE,e.getMessage(),e);
      return false;
    }
  }
  return shouldMerge;
}",0.941142360104378
49493,"public void searchForOtherClusters(SplitBrainHandler splitBrainHandler){
  final Collection<Address> colPossibleAddresses;
  try {
    colPossibleAddresses=getPossibleAddresses();
  }
 catch (  Throwable e) {
    logger.log(Level.SEVERE,e.getMessage(),e);
    return;
  }
  colPossibleAddresses.remove(node.getThisAddress());
  for (  Member member : node.getClusterImpl().getMembers()) {
    colPossibleAddresses.remove(((MemberImpl)member).getAddress());
  }
  if (colPossibleAddresses.isEmpty()) {
    return;
  }
  for (  Address possibleAddress : colPossibleAddresses) {
    logger.log(Level.FINEST,node.getThisAddress() + ""String_Node_Str"" + possibleAddress);
    node.connectionManager.getOrConnect(possibleAddress,true);
    try {
      Thread.sleep(1500);
    }
 catch (    InterruptedException e) {
      return;
    }
    final Connection conn=node.connectionManager.getConnection(possibleAddress);
    if (conn != null) {
      final JoinInfo response=node.clusterManager.checkJoin(conn);
      if (response != null && shouldMerge(response)) {
        logger.log(Level.WARNING,node.address + ""String_Node_Str"" + possibleAddress);
        splitBrainHandler.restart();
        return;
      }
 else {
        conn.close();
      }
    }
  }
}","public void searchForOtherClusters(SplitBrainHandler splitBrainHandler){
  final Collection<Address> colPossibleAddresses;
  try {
    colPossibleAddresses=getPossibleAddresses();
  }
 catch (  Throwable e) {
    logger.log(Level.SEVERE,e.getMessage(),e);
    return;
  }
  colPossibleAddresses.remove(node.getThisAddress());
  for (  Member member : node.getClusterImpl().getMembers()) {
    colPossibleAddresses.remove(((MemberImpl)member).getAddress());
  }
  if (colPossibleAddresses.isEmpty()) {
    return;
  }
  for (  Address possibleAddress : colPossibleAddresses) {
    logger.log(Level.FINEST,node.getThisAddress() + ""String_Node_Str"" + possibleAddress);
    node.connectionManager.getOrConnect(possibleAddress,true);
    try {
      Thread.sleep(1500);
    }
 catch (    InterruptedException e) {
      return;
    }
    final Connection conn=node.connectionManager.getConnection(possibleAddress);
    if (conn != null) {
      final JoinInfo response=node.clusterManager.checkJoin(conn);
      if (response != null && shouldMerge(response)) {
        logger.log(Level.WARNING,node.address + ""String_Node_Str"" + possibleAddress);
        splitBrainHandler.restart();
        return;
      }
    }
  }
}",0.9845904298459044
49494,"boolean shouldMerge(JoinInfo joinInfo){
  boolean shouldMerge=false;
  if (joinInfo != null) {
    boolean validJoinRequest;
    try {
      try {
        validJoinRequest=node.validateJoinRequest(joinInfo);
      }
 catch (      Exception e) {
        validJoinRequest=false;
      }
      if (validJoinRequest) {
        for (        Member member : node.getClusterImpl().getMembers()) {
          MemberImpl memberImpl=(MemberImpl)member;
          if (memberImpl.getAddress().equals(joinInfo.address)) {
            logger.log(Level.FINEST,""String_Node_Str"" + joinInfo.address + ""String_Node_Str"");
            return false;
          }
        }
        int currentMemberCount=node.getClusterImpl().getMembers().size();
        if (joinInfo.getMemberCount() > currentMemberCount) {
          logger.log(Level.INFO,node.address + ""String_Node_Str"" + joinInfo.address+ ""String_Node_Str""+ (joinInfo.getMemberCount() + ""String_Node_Str"" + currentMemberCount)+ ""String_Node_Str"");
          logger.log(Level.FINEST,joinInfo.toString());
          shouldMerge=true;
        }
 else         if (joinInfo.getMemberCount() == currentMemberCount) {
          if (node.getThisAddress().hashCode() > joinInfo.address.hashCode()) {
            logger.log(Level.INFO,node.address + ""String_Node_Str"" + joinInfo.address+ ""String_Node_Str""+ ""String_Node_Str""+ currentMemberCount);
            logger.log(Level.FINEST,joinInfo.toString());
            shouldMerge=true;
          }
        }
      }
    }
 catch (    Throwable e) {
      logger.log(Level.SEVERE,e.getMessage(),e);
      return false;
    }
  }
  return shouldMerge;
}","boolean shouldMerge(JoinInfo joinInfo){
  boolean shouldMerge=false;
  if (joinInfo != null) {
    boolean validJoinRequest;
    try {
      try {
        validJoinRequest=node.validateJoinRequest(joinInfo);
      }
 catch (      Exception e) {
        logger.log(Level.FINEST,e.getMessage());
        validJoinRequest=false;
      }
      if (validJoinRequest) {
        for (        Member member : node.getClusterImpl().getMembers()) {
          MemberImpl memberImpl=(MemberImpl)member;
          if (memberImpl.getAddress().equals(joinInfo.address)) {
            logger.log(Level.FINEST,""String_Node_Str"" + joinInfo.address + ""String_Node_Str"");
            return false;
          }
        }
        int currentMemberCount=node.getClusterImpl().getMembers().size();
        if (joinInfo.getMemberCount() > currentMemberCount) {
          logger.log(Level.INFO,node.address + ""String_Node_Str"" + joinInfo.address+ ""String_Node_Str""+ (joinInfo.getMemberCount() + ""String_Node_Str"" + currentMemberCount)+ ""String_Node_Str"");
          logger.log(Level.FINEST,joinInfo.toString());
          shouldMerge=true;
        }
 else         if (joinInfo.getMemberCount() == currentMemberCount) {
          if (node.getThisAddress().hashCode() > joinInfo.address.hashCode()) {
            logger.log(Level.INFO,node.address + ""String_Node_Str"" + joinInfo.address+ ""String_Node_Str""+ ""String_Node_Str""+ currentMemberCount);
            logger.log(Level.FINEST,joinInfo.toString());
            shouldMerge=true;
          }
 else {
            logger.log(Level.FINEST,joinInfo.address + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ currentMemberCount);
          }
        }
      }
    }
 catch (    Throwable e) {
      logger.log(Level.SEVERE,e.getMessage(),e);
      return false;
    }
  }
  return shouldMerge;
}",0.941142360104378
49495,"public void searchForOtherClusters(SplitBrainHandler splitBrainHandler){
  final Collection<Address> colPossibleAddresses;
  try {
    colPossibleAddresses=getPossibleAddresses();
  }
 catch (  Throwable e) {
    logger.log(Level.SEVERE,e.getMessage(),e);
    return;
  }
  colPossibleAddresses.remove(node.getThisAddress());
  for (  Member member : node.getClusterImpl().getMembers()) {
    colPossibleAddresses.remove(((MemberImpl)member).getAddress());
  }
  if (colPossibleAddresses.isEmpty()) {
    return;
  }
  for (  Address possibleAddress : colPossibleAddresses) {
    logger.log(Level.FINEST,node.getThisAddress() + ""String_Node_Str"" + possibleAddress);
    node.connectionManager.getOrConnect(possibleAddress,true);
    try {
      Thread.sleep(1500);
    }
 catch (    InterruptedException e) {
      return;
    }
    final Connection conn=node.connectionManager.getConnection(possibleAddress);
    if (conn != null) {
      final JoinInfo response=node.clusterManager.checkJoin(conn);
      if (response != null && shouldMerge(response)) {
        logger.log(Level.WARNING,node.address + ""String_Node_Str"" + possibleAddress);
        splitBrainHandler.restart();
        return;
      }
 else {
        conn.close();
      }
    }
  }
}","public void searchForOtherClusters(SplitBrainHandler splitBrainHandler){
  final Collection<Address> colPossibleAddresses;
  try {
    colPossibleAddresses=getPossibleAddresses();
  }
 catch (  Throwable e) {
    logger.log(Level.SEVERE,e.getMessage(),e);
    return;
  }
  colPossibleAddresses.remove(node.getThisAddress());
  for (  Member member : node.getClusterImpl().getMembers()) {
    colPossibleAddresses.remove(((MemberImpl)member).getAddress());
  }
  if (colPossibleAddresses.isEmpty()) {
    return;
  }
  for (  Address possibleAddress : colPossibleAddresses) {
    logger.log(Level.FINEST,node.getThisAddress() + ""String_Node_Str"" + possibleAddress);
    node.connectionManager.getOrConnect(possibleAddress,true);
    try {
      Thread.sleep(1500);
    }
 catch (    InterruptedException e) {
      return;
    }
    final Connection conn=node.connectionManager.getConnection(possibleAddress);
    if (conn != null) {
      final JoinInfo response=node.clusterManager.checkJoin(conn);
      if (response != null && shouldMerge(response)) {
        logger.log(Level.WARNING,node.address + ""String_Node_Str"" + possibleAddress);
        splitBrainHandler.restart();
        return;
      }
    }
  }
}",0.9845904298459044
49496,"public void searchForOtherClusters(SplitBrainHandler splitBrainHandler){
  final Collection<Address> colPossibleAddresses;
  try {
    colPossibleAddresses=getPossibleAddresses();
  }
 catch (  Throwable e) {
    logger.log(Level.SEVERE,e.getMessage(),e);
    return;
  }
  colPossibleAddresses.remove(node.getThisAddress());
  for (  Member member : node.getClusterImpl().getMembers()) {
    colPossibleAddresses.remove(((MemberImpl)member).getAddress());
  }
  if (colPossibleAddresses.size() == 0) {
    return;
  }
  for (  final Address possibleAddress : colPossibleAddresses) {
    logger.log(Level.FINEST,node.getThisAddress() + ""String_Node_Str"" + possibleAddress);
    node.connectionManager.getOrConnect(possibleAddress,true);
  }
  for (  Address possibleAddress : colPossibleAddresses) {
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
      return;
    }
    final Connection conn=node.connectionManager.getConnection(possibleAddress);
    if (conn != null) {
      final JoinInfo response=node.clusterManager.checkJoin(conn);
      if (response != null && shouldMerge(response)) {
        logger.log(Level.WARNING,node.address + ""String_Node_Str"" + possibleAddress);
        splitBrainHandler.restart();
      }
      return;
    }
  }
}","public void searchForOtherClusters(SplitBrainHandler splitBrainHandler){
  final Collection<Address> colPossibleAddresses;
  try {
    colPossibleAddresses=getPossibleAddresses();
  }
 catch (  Throwable e) {
    logger.log(Level.SEVERE,e.getMessage(),e);
    return;
  }
  colPossibleAddresses.remove(node.getThisAddress());
  for (  Member member : node.getClusterImpl().getMembers()) {
    colPossibleAddresses.remove(((MemberImpl)member).getAddress());
  }
  if (colPossibleAddresses.isEmpty()) {
    return;
  }
  for (  Address possibleAddress : colPossibleAddresses) {
    logger.log(Level.FINEST,node.getThisAddress() + ""String_Node_Str"" + possibleAddress);
    node.connectionManager.getOrConnect(possibleAddress,true);
    try {
      Thread.sleep(1500);
    }
 catch (    InterruptedException e) {
      return;
    }
    final Connection conn=node.connectionManager.getConnection(possibleAddress);
    if (conn != null) {
      final JoinInfo response=node.clusterManager.checkJoin(conn);
      if (response != null && shouldMerge(response)) {
        logger.log(Level.WARNING,node.address + ""String_Node_Str"" + possibleAddress);
        splitBrainHandler.restart();
        return;
      }
 else {
        conn.close();
      }
    }
  }
}",0.9380670611439842
49497,"protected List<String> read(Socket socket) throws IOException {
  List<String> values=new ArrayList<String>();
  InputStreamReader reader=new InputStreamReader(socket.getInputStream(),""String_Node_Str"");
  BufferedReader buf=new BufferedReader(reader);
  String commandLine=buf.readLine();
  System.out.println(commandLine);
  String[] split=commandLine.split(""String_Node_Str"");
  if (split[split.length - 1].startsWith(""String_Node_Str"")) {
    String sizeLine=buf.readLine();
    System.out.println(sizeLine);
    String[] tokens=sizeLine.split(""String_Node_Str"");
    int count=Integer.valueOf(split[split.length - 1].substring(1));
    for (int i=0; i < count; i++) {
      int s=Integer.valueOf(tokens[i]);
      char[] value=new char[s];
      buf.read(value);
      System.out.println(String.valueOf(value));
      values.add(String.valueOf(value));
    }
  }
  if (values.size() == 0) {
    values.add(commandLine.split(""String_Node_Str"")[0]);
  }
  return values;
}","protected List<String> read(Socket socket) throws IOException {
  List<String> values=new ArrayList<String>();
  InputStreamReader reader=new InputStreamReader(socket.getInputStream(),""String_Node_Str"");
  BufferedReader buf=new BufferedReader(reader);
  String commandLine=buf.readLine();
  System.out.println(commandLine);
  if (commandLine == null) {
    return Collections.emptyList();
  }
  String[] split=commandLine.split(""String_Node_Str"");
  if (split[split.length - 1].startsWith(""String_Node_Str"")) {
    String sizeLine=buf.readLine();
    System.out.println(sizeLine);
    String[] tokens=sizeLine.split(""String_Node_Str"");
    int count=Integer.valueOf(split[split.length - 1].substring(1));
    for (int i=0; i < count; i++) {
      int s=Integer.valueOf(tokens[i]);
      char[] value=new char[s];
      buf.read(value);
      System.out.println(String.valueOf(value));
      values.add(String.valueOf(value));
    }
  }
  if (values.size() == 0) {
    values.addAll(Arrays.asList(commandLine.split(""String_Node_Str"")));
  }
  return values;
}",0.9557522123893806
49498,"public void doLocalOp(){
  if (isMigrationAware() && isMigrating(request)) {
    setRedoResult(REDO_PARTITION_MIGRATING);
  }
 else {
    request.attachment=TargetAwareOp.this;
    request.local=true;
    ((RequestHandler)getPacketProcessor(request.operation)).handle(request);
  }
}","public void doLocalOp(){
  if (isMigrationAware() && isPartitionMigrating()) {
    setRedoResult(REDO_PARTITION_MIGRATING);
  }
 else {
    request.attachment=TargetAwareOp.this;
    request.local=true;
    ((RequestHandler)getPacketProcessor(request.operation)).handle(request);
  }
}",0.971830985915493
49499,"protected boolean isMigrating(Request req){
  return false;
}","protected boolean isMigrating(Request req,int replica){
  return false;
}",0.9104477611940298
49500,"protected void backup(ClusterOperation operation){
  final int localBackupCount=backupCount;
  final int localAsyncBackupCount=asyncBackupCount;
  final int totalBackupCount=localBackupCount + localAsyncBackupCount;
  if (localBackupCount <= 0 && localAsyncBackupCount <= 0) {
    return;
  }
  if (totalBackupCount > MAX_BACKUP_COUNT) {
    String msg=""String_Node_Str"" + MAX_BACKUP_COUNT + ""String_Node_Str""+ totalBackupCount;
    logger.log(Level.SEVERE,msg);
    throw new RuntimeException(msg);
  }
  if (request.key == null || request.key.size() == 0) {
    throw new RuntimeException(""String_Node_Str"" + request.key);
  }
  final MBackup[] backupOps=new MBackup[localBackupCount];
  for (int i=0; i < totalBackupCount; i++) {
    int replicaIndex=i + 1;
    if (i < localBackupCount) {
      MBackup backupOp=new MBackup();
      backupOps[i]=backupOp;
      backupOp.sendBackup(operation,replicaIndex,request);
    }
 else {
      final Request reqBackup=Request.copyFromRequest(request);
      reqBackup.operation=operation;
      enqueueAndReturn(new AsyncBackupProcessable(reqBackup,replicaIndex));
    }
  }
  for (int i=0; i < localBackupCount; i++) {
    MBackup backupOp=backupOps[i];
    backupOp.getResultAsBoolean();
  }
}","protected void backup(ClusterOperation operation){
  final int localBackupCount=backupCount;
  final int localAsyncBackupCount=asyncBackupCount;
  final int totalBackupCount=localBackupCount + localAsyncBackupCount;
  if (localBackupCount <= 0 && localAsyncBackupCount <= 0) {
    return;
  }
  if (totalBackupCount > MAX_BACKUP_COUNT) {
    String msg=""String_Node_Str"" + MAX_BACKUP_COUNT + ""String_Node_Str""+ totalBackupCount;
    logger.log(Level.SEVERE,msg);
    throw new RuntimeException(msg);
  }
  if (request.key == null || request.key.size() == 0) {
    throw new RuntimeException(""String_Node_Str"" + request.key);
  }
  final MBackup[] backupOps=new MBackup[localBackupCount];
  for (int i=0; i < totalBackupCount; i++) {
    final int replicaIndex=i + 1;
    if (i < localBackupCount) {
      MBackup backupOp=new MBackup();
      backupOps[i]=backupOp;
      backupOp.sendBackup(operation,replicaIndex,request);
    }
 else {
      final Request reqBackup=Request.copyFromRequest(request);
      reqBackup.operation=operation;
      enqueueAndReturn(new AsyncBackupProcessable(reqBackup,replicaIndex));
    }
  }
  for (int i=0; i < localBackupCount; i++) {
    MBackup backupOp=backupOps[i];
    backupOp.getResultAsBoolean();
  }
}",0.997586484312148
49501,"ConcurrentMapManager(final Node node){
  super(node);
  recordFactory=node.initializer.getRecordFactory();
  storeExecutor=node.executorManager.newParallelExecutor(node.groupProperties.EXECUTOR_STORE_THREAD_COUNT.getInteger());
  evictionExecutor=node.executorManager.newParallelExecutor(node.groupProperties.EXECUTOR_STORE_THREAD_COUNT.getInteger());
  PARTITION_COUNT=node.groupProperties.CONCURRENT_MAP_PARTITION_COUNT.getInteger();
  MAX_BACKUP_COUNT=MapConfig.MAX_BACKUP_COUNT;
  int removeDelaySeconds=node.groupProperties.REMOVE_DELAY_SECONDS.getInteger();
  if (removeDelaySeconds <= 0) {
    logger.log(Level.WARNING,GroupProperties.PROP_REMOVE_DELAY_SECONDS + ""String_Node_Str"");
    removeDelaySeconds=1;
  }
  GLOBAL_REMOVE_DELAY_MILLIS=removeDelaySeconds * 1000L;
  LOG_STATE=node.groupProperties.LOG_STATE.getBoolean();
  maps=new ConcurrentHashMap<String,CMap>(10,0.75f,1);
  mapCaches=new ConcurrentHashMap<String,NearCache>(10,0.75f,1);
  partitionManager=new PartitionManager(this);
  partitionServiceImpl=new PartitionServiceImpl(this);
  node.executorManager.getScheduledExecutorService().scheduleAtFixedRate(new Runnable(){
    public void run(){
      startCleanup(true,false);
    }
  }
,1,1,TimeUnit.SECONDS);
  registerPacketProcessor(CONCURRENT_MAP_GET_MAP_ENTRY,new GetMapEntryOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_GET_DATA_RECORD_ENTRY,new GetDataRecordEntryOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_GET,new GetOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ASYNC_MERGE,new AsyncMergePacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_WAN_MERGE,new WanMergePacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_MERGE,new MergeOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_TRY_PUT,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_SET,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT_AND_UNLOCK,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT_IF_ABSENT,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REPLACE_IF_NOT_NULL,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT_TRANSIENT,new PutTransientOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REPLACE_IF_SAME,new ReplaceOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT_MULTI,new PutMultiOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE,new RemoveOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_EVICT,new EvictOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE_IF_SAME,new RemoveIfSameOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE_ITEM,new RemoveItemOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_PUT,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_PUT_AND_UNLOCK,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_ADD,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_REMOVE_MULTI,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_REMOVE,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_LOCK,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_LOCK,new LockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_IS_KEY_LOCKED,new IsKeyLockedOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_TRY_LOCK_AND_GET,new LockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_UNLOCK,new UnlockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_FORCE_UNLOCK,new ForceUnlockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_LOCK_MAP,new LockMapOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_UNLOCK_MAP,new LockMapOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE_MULTI,new RemoveMultiOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ADD_TO_LIST,new AddOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ADD_TO_SET,new AddOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_CONTAINS_KEY,new ContainsKeyOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_CONTAINS_ENTRY,new ContainsEntryOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_CONTAINS_VALUE,new ContainsValueOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_VALUE_COUNT,new ValueCountOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_INVALIDATE,new InvalidateOperationHandler());
  registerPacketProcessor(ATOMIC_NUMBER_ADD_AND_GET,new AtomicNumberAddAndGetOperationHandler());
  registerPacketProcessor(ATOMIC_NUMBER_COMPARE_AND_SET,new AtomicNumberCompareAndSetOperationHandler());
  registerPacketProcessor(ATOMIC_NUMBER_GET_AND_ADD,new AtomicNumberGetAndAddOperationHandler());
  registerPacketProcessor(ATOMIC_NUMBER_GET_AND_SET,new AtomicNumberGetAndSetOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_AWAIT,new CountDownLatchAwaitOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_COUNT_DOWN,new CountDownLatchCountDownOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_DESTROY,new CountDownLatchDestroyOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_GET_COUNT,new CountDownLatchGetCountOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_GET_OWNER,new CountDownLatchGetOwnerOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_SET_COUNT,new CountDownLatchSetCountOperationHandler());
  registerPacketProcessor(SEMAPHORE_ATTACH_DETACH_PERMITS,new SemaphoreAttachDetachOperationHandler());
  registerPacketProcessor(SEMAPHORE_CANCEL_ACQUIRE,new SemaphoreCancelAcquireOperationHandler());
  registerPacketProcessor(SEMAPHORE_DESTROY,new SemaphoreDestroyOperationHandler());
  registerPacketProcessor(SEMAPHORE_DRAIN_PERMITS,new SemaphoreDrainOperationHandler());
  registerPacketProcessor(SEMAPHORE_GET_ATTACHED_PERMITS,new SemaphoreGetAttachedOperationHandler());
  registerPacketProcessor(SEMAPHORE_GET_AVAILABLE_PERMITS,new SemaphoreGetAvailableOperationHandler());
  registerPacketProcessor(SEMAPHORE_REDUCE_PERMITS,new SemaphoreReduceOperationHandler());
  registerPacketProcessor(SEMAPHORE_RELEASE,new SemaphoreReleaseOperationHandler());
  registerPacketProcessor(SEMAPHORE_TRY_ACQUIRE,new SemaphoreTryAcquireOperationHandler());
}","ConcurrentMapManager(final Node node){
  super(node);
  recordFactory=node.initializer.getRecordFactory();
  storeExecutor=node.executorManager.newParallelExecutor(node.groupProperties.EXECUTOR_STORE_THREAD_COUNT.getInteger());
  evictionExecutor=node.executorManager.newParallelExecutor(node.groupProperties.EXECUTOR_STORE_THREAD_COUNT.getInteger());
  PARTITION_COUNT=node.groupProperties.CONCURRENT_MAP_PARTITION_COUNT.getInteger();
  MAX_BACKUP_COUNT=MapConfig.MAX_BACKUP_COUNT;
  int removeDelaySeconds=node.groupProperties.REMOVE_DELAY_SECONDS.getInteger();
  if (removeDelaySeconds <= 0) {
    logger.log(Level.WARNING,GroupProperties.PROP_REMOVE_DELAY_SECONDS + ""String_Node_Str"");
    removeDelaySeconds=1;
  }
  GLOBAL_REMOVE_DELAY_MILLIS=removeDelaySeconds * 1000L;
  LOG_STATE=node.groupProperties.LOG_STATE.getBoolean();
  maps=new ConcurrentHashMap<String,CMap>(10,0.75f,1);
  mapCaches=new ConcurrentHashMap<String,NearCache>(10,0.75f,1);
  partitionManager=new PartitionManager(this);
  partitionServiceImpl=new PartitionServiceImpl(this);
  node.executorManager.getScheduledExecutorService().scheduleAtFixedRate(new Runnable(){
    public void run(){
      startCleanup(true,false);
    }
  }
,1,1,TimeUnit.SECONDS);
  registerPacketProcessor(CONCURRENT_MAP_GET_MAP_ENTRY,new GetMapEntryOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_GET_DATA_RECORD_ENTRY,new GetDataRecordEntryOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_GET,new GetOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ASYNC_MERGE,new AsyncMergePacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_WAN_MERGE,new WanMergePacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_MERGE,new MergeOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_TRY_PUT,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_SET,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT_AND_UNLOCK,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT_IF_ABSENT,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REPLACE_IF_NOT_NULL,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT_TRANSIENT,new PutTransientOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REPLACE_IF_SAME,new ReplaceOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT_MULTI,new PutMultiOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE,new RemoveOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_EVICT,new EvictOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE_IF_SAME,new RemoveIfSameOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE_ITEM,new RemoveItemOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_PUT,new BackupOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_PUT_AND_UNLOCK,new BackupOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_ADD,new BackupOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_REMOVE_MULTI,new BackupOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_REMOVE,new BackupOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_LOCK,new BackupOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_LOCK,new LockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_IS_KEY_LOCKED,new IsKeyLockedOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_TRY_LOCK_AND_GET,new LockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_UNLOCK,new UnlockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_FORCE_UNLOCK,new ForceUnlockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_LOCK_MAP,new LockMapOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_UNLOCK_MAP,new LockMapOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE_MULTI,new RemoveMultiOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ADD_TO_LIST,new AddOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ADD_TO_SET,new AddOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_CONTAINS_KEY,new ContainsKeyOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_CONTAINS_ENTRY,new ContainsEntryOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_CONTAINS_VALUE,new ContainsValueOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_VALUE_COUNT,new ValueCountOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_INVALIDATE,new InvalidateOperationHandler());
  registerPacketProcessor(ATOMIC_NUMBER_ADD_AND_GET,new AtomicNumberAddAndGetOperationHandler());
  registerPacketProcessor(ATOMIC_NUMBER_COMPARE_AND_SET,new AtomicNumberCompareAndSetOperationHandler());
  registerPacketProcessor(ATOMIC_NUMBER_GET_AND_ADD,new AtomicNumberGetAndAddOperationHandler());
  registerPacketProcessor(ATOMIC_NUMBER_GET_AND_SET,new AtomicNumberGetAndSetOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_AWAIT,new CountDownLatchAwaitOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_COUNT_DOWN,new CountDownLatchCountDownOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_DESTROY,new CountDownLatchDestroyOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_GET_COUNT,new CountDownLatchGetCountOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_GET_OWNER,new CountDownLatchGetOwnerOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_SET_COUNT,new CountDownLatchSetCountOperationHandler());
  registerPacketProcessor(SEMAPHORE_ATTACH_DETACH_PERMITS,new SemaphoreAttachDetachOperationHandler());
  registerPacketProcessor(SEMAPHORE_CANCEL_ACQUIRE,new SemaphoreCancelAcquireOperationHandler());
  registerPacketProcessor(SEMAPHORE_DESTROY,new SemaphoreDestroyOperationHandler());
  registerPacketProcessor(SEMAPHORE_DRAIN_PERMITS,new SemaphoreDrainOperationHandler());
  registerPacketProcessor(SEMAPHORE_GET_ATTACHED_PERMITS,new SemaphoreGetAttachedOperationHandler());
  registerPacketProcessor(SEMAPHORE_GET_AVAILABLE_PERMITS,new SemaphoreGetAvailableOperationHandler());
  registerPacketProcessor(SEMAPHORE_REDUCE_PERMITS,new SemaphoreReduceOperationHandler());
  registerPacketProcessor(SEMAPHORE_RELEASE,new SemaphoreReleaseOperationHandler());
  registerPacketProcessor(SEMAPHORE_TRY_ACQUIRE,new SemaphoreTryAcquireOperationHandler());
}",0.986586493987049
49502,"public void sendBackup(ClusterOperation operation,int replicaIndex,Request reqBackup){
  reset();
  this.replicaIndex=replicaIndex;
  SystemLogService css=node.getSystemLogService();
  if (css.shouldLog(TRACE)) {
    css.trace(this,""String_Node_Str"",callId);
  }
  request.setFromRequest(reqBackup);
  request.operation=operation;
  request.caller=thisAddress;
  request.setBooleanRequest();
  doOp();
}","public void sendBackup(ClusterOperation operation,int replicaIndex,Request reqBackup){
  reset();
  this.replicaIndex=replicaIndex;
  SystemLogService css=node.getSystemLogService();
  if (css.shouldLog(TRACE)) {
    css.trace(this,""String_Node_Str"",callId);
  }
  request.setFromRequest(reqBackup);
  request.operation=operation;
  request.caller=thisAddress;
  request.longValue=replicaIndex;
  request.setBooleanRequest();
  doOp();
}",0.9595238095238096
49503,"@Override public boolean isMigrating(Request req){
  final Data key=req.key;
  if (key == null)   return false;
  return partitionManager.isOwnedPartitionMigrating(getPartitionId(req));
}","@Override public boolean isMigrating(Request req,int replica){
  final Data key=req.key;
  return key != null && partitionManager.isPartitionMigrating(getPartitionId(req),replica);
}",0.8130081300813008
49504,"public void doJoin(AtomicBoolean joined){
  int tryCount=0;
  long joinStartTime=Clock.currentTimeMillis();
  long maxJoinMillis=node.getGroupProperties().MAX_JOIN_SECONDS.getInteger() * 1000;
  while (node.isActive() && !joined.get() && (Clock.currentTimeMillis() - joinStartTime < maxJoinMillis)) {
    String msg=""String_Node_Str"" + node.getMasterAddress();
    logger.log(Level.FINEST,msg);
    systemLogService.logJoin(msg);
    Address masterAddressNow=findMasterWithMulticast();
    node.setMasterAddress(masterAddressNow);
    if (masterAddressNow != null) {
      systemLogService.logJoin(""String_Node_Str"" + masterAddressNow);
    }
    if (node.getMasterAddress() == null || node.address.equals(node.getMasterAddress())) {
      TcpIpConfig tcpIpConfig=config.getNetworkConfig().getJoin().getTcpIpConfig();
      if (tcpIpConfig != null && tcpIpConfig.isEnabled()) {
        doTCP(joined);
      }
 else {
        node.setAsMaster();
      }
      return;
    }
    if (++tryCount > 24) {
      failedJoiningToMaster(true,tryCount);
    }
    if (!node.getMasterAddress().equals(node.address)) {
      connectAndSendJoinRequest(node.getMasterAddress());
    }
 else {
      node.setMasterAddress(null);
      tryCount=0;
    }
    try {
      Thread.sleep(500L);
    }
 catch (    InterruptedException ignored) {
    }
  }
}","public void doJoin(AtomicBoolean joined){
  int tryCount=0;
  long joinStartTime=Clock.currentTimeMillis();
  long maxJoinMillis=node.getGroupProperties().MAX_JOIN_SECONDS.getInteger() * 1000;
  while (node.isActive() && !joined.get() && (Clock.currentTimeMillis() - joinStartTime < maxJoinMillis)) {
    String msg=""String_Node_Str"" + node.getMasterAddress();
    logger.log(Level.FINEST,msg);
    systemLogService.logJoin(msg);
    Address masterAddressNow=findMasterWithMulticast();
    node.setMasterAddress(masterAddressNow);
    if (masterAddressNow != null) {
      systemLogService.logJoin(""String_Node_Str"" + masterAddressNow);
    }
    if (node.getMasterAddress() == null || node.address.equals(node.getMasterAddress())) {
      TcpIpConfig tcpIpConfig=config.getNetworkConfig().getJoin().getTcpIpConfig();
      if (tcpIpConfig != null && tcpIpConfig.isEnabled()) {
        doTCP(joined);
      }
 else {
        node.setAsMaster();
      }
      return;
    }
    if (++tryCount > 49) {
      failedJoiningToMaster(true,tryCount);
    }
    if (!node.getMasterAddress().equals(node.address)) {
      connectAndSendJoinRequest(node.getMasterAddress());
    }
 else {
      node.setMasterAddress(null);
      tryCount=0;
    }
    try {
      Thread.sleep(500L);
    }
 catch (    InterruptedException ignored) {
    }
  }
}",0.999250936329588
49505,"/** 
 * @param partitionId
 * @return true if owned replica (0) of partition is migrating, false otherwise
 */
public boolean isOwnedPartitionMigrating(int partitionId){
  final MigratingPartition currentMigratingPartition=migratingPartition;
  return currentMigratingPartition != null && currentMigratingPartition.getPartitionId() == partitionId && currentMigratingPartition.getReplicaIndex() == 0;
}","/** 
 * @param partitionId
 * @return true if owned replica (0) of partition is migrating, false otherwise
 */
public boolean isOwnedPartitionMigrating(int partitionId){
  return isPartitionMigrating(partitionId,0);
}",0.5954692556634305
49506,"/** 
 * @param partitionId
 * @return true if any replica of partition is migrating, false otherwise
 */
public boolean isPartitionMigrating(int partitionId){
  final MigratingPartition currentMigratingPartition=migratingPartition;
  return currentMigratingPartition != null && currentMigratingPartition.getPartitionId() == partitionId;
}","/** 
 * @param partitionId
 * @param replicaIndex
 * @return true if replicaIndex of partition is migrating, false otherwise
 */
public boolean isPartitionMigrating(int partitionId,int replicaIndex){
  final MigratingPartition currentMigratingPartition=migratingPartition;
  return currentMigratingPartition != null && currentMigratingPartition.getPartitionId() == partitionId && currentMigratingPartition.getReplicaIndex() == replicaIndex;
}",0.8384615384615385
49507,"@Override public String toString(){
  return ""String_Node_Str"" + ""String_Node_Str"" + name + '\''+ ""String_Node_Str""+ operation+ ""String_Node_Str""+ callId+ '\''+ ""String_Node_Str""+ redoCount+ '\''+ ""String_Node_Str""+ timeout+ '\''+ ""String_Node_Str""+ lockThreadId+ '\''+ ""String_Node_Str""+ target+ '\''+ '}';
}","@Override public String toString(){
  return ""String_Node_Str"" + ""String_Node_Str"" + name + '\''+ ""String_Node_Str""+ operation+ ""String_Node_Str""+ callId+ '\''+ ""String_Node_Str""+ redoCount+ '\''+ ""String_Node_Str""+ timeout+ '\''+ ""String_Node_Str""+ lockThreadId+ '\''+ ""String_Node_Str""+ target+ '\''+ ""String_Node_Str""+ local+ '\''+ '}';
}",0.9507692307692308
49508,"/** 
 * Fix for the issue 275.
 * @throws Exception
 */
@Test(timeout=60000) public void testDataRecovery2() throws Exception {
  final int size=1000;
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(new Config());
  IMap map1=h1.getMap(""String_Node_Str"");
  for (int i=0; i < size; i++) {
    map1.put(i,""String_Node_Str"" + i);
  }
  assertEquals(size,map1.size());
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(new Config());
  sleep(3000);
  IMap map2=h2.getMap(""String_Node_Str"");
  assertEquals(size,map1.size());
  assertEquals(size,map2.size());
  assertEquals(size,getTotalOwnedEntryCount(map1,map2));
  assertEquals(size,getTotalBackupEntryCount(map1,map2));
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(new Config());
  IMap map3=h3.getMap(""String_Node_Str"");
  sleep(3000);
  assertEquals(size,map1.size());
  assertEquals(size,map2.size());
  assertEquals(size,map3.size());
  assertEquals(size,getTotalOwnedEntryCount(map1,map2,map3));
  assertEquals(size,getTotalBackupEntryCount(map1,map2,map3));
  MemberImpl member2=(MemberImpl)h2.getCluster().getLocalMember();
  h2.getLifecycleService().shutdown();
  sleep(3000);
  assertEquals(size,map1.size());
  assertEquals(size,map3.size());
  assertEquals(size,getTotalOwnedEntryCount(map1,map3));
  assertEquals(size,getTotalBackupEntryCount(map1,map3));
  MemberImpl member1=(MemberImpl)h1.getCluster().getLocalMember();
  h1.getLifecycleService().shutdown();
  assertEquals(size,map3.size());
  ConcurrentMapManager c3=getConcurrentMapManager(h3);
  MemberImpl member3=(MemberImpl)h3.getCluster().getLocalMember();
  for (int i=0; i < 271; i++) {
    PartitionInfo p=c3.getPartitionInfo(i);
    assertTrue(p.toString(),member3.getAddress().equals(p.getOwner()));
    assertFalse(p.toString(),p.isOwnerOrBackup(member1.getAddress(),PartitionInfo.MAX_REPLICA_COUNT));
    assertFalse(p.toString(),p.isOwnerOrBackup(member2.getAddress(),PartitionInfo.MAX_REPLICA_COUNT));
  }
}","/** 
 * Fix for the issue 275.
 * @throws Exception
 */
@Test(timeout=60000) public void testDataRecovery2() throws Exception {
  final int size=1000;
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(new Config());
  IMap map1=h1.getMap(""String_Node_Str"");
  for (int i=0; i < size; i++) {
    map1.put(i,""String_Node_Str"" + i);
  }
  assertEquals(size,map1.size());
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(new Config());
  sleep(3000);
  IMap map2=h2.getMap(""String_Node_Str"");
  assertEquals(size,map1.size());
  assertEquals(size,map2.size());
  assertEquals(size,getTotalOwnedEntryCount(map1,map2));
  assertEquals(size,getTotalBackupEntryCount(map1,map2));
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(new Config());
  IMap map3=h3.getMap(""String_Node_Str"");
  sleep(3000);
  assertEquals(size,map1.size());
  assertEquals(size,map2.size());
  assertEquals(size,map3.size());
  assertEquals(size,getTotalOwnedEntryCount(map1,map2,map3));
  assertEquals(size,getTotalBackupEntryCount(map1,map2,map3));
  MemberImpl member2=(MemberImpl)h2.getCluster().getLocalMember();
  h2.getLifecycleService().shutdown();
  sleep(5000);
  assertEquals(size,map1.size());
  assertEquals(size,map3.size());
  assertEquals(size,getTotalOwnedEntryCount(map1,map3));
  assertEquals(size,getTotalBackupEntryCount(map1,map3));
  MemberImpl member1=(MemberImpl)h1.getCluster().getLocalMember();
  h1.getLifecycleService().shutdown();
  assertEquals(size,map3.size());
  ConcurrentMapManager c3=getConcurrentMapManager(h3);
  MemberImpl member3=(MemberImpl)h3.getCluster().getLocalMember();
  for (int i=0; i < 271; i++) {
    PartitionInfo p=c3.getPartitionInfo(i);
    assertTrue(p.toString(),member3.getAddress().equals(p.getOwner()));
    assertFalse(p.toString(),p.isOwnerOrBackup(member1.getAddress(),PartitionInfo.MAX_REPLICA_COUNT));
    assertFalse(p.toString(),p.isOwnerOrBackup(member2.getAddress(),PartitionInfo.MAX_REPLICA_COUNT));
  }
}",0.9994895354772844
49509,"@Test public void issue395BackupProblemWithBCount2() throws InterruptedException {
  final int size=1000;
  Config config=new Config();
  config.getProperties().put(GroupProperties.PROP_PARTITION_MIGRATION_INTERVAL,""String_Node_Str"");
  config.getMapConfig(""String_Node_Str"").setBackupCount(2);
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(config);
  IMap map1=h1.getMap(""String_Node_Str"");
  IMap map2=h2.getMap(""String_Node_Str"");
  for (int i=0; i < size; i++) {
    map1.put(i,i);
  }
  assertEquals(size,getTotalOwnedEntryCount(map1,map2));
  assertEquals(size,getTotalBackupEntryCount(map1,map2));
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(config);
  IMap map3=h3.getMap(""String_Node_Str"");
  Thread.sleep(1000 * 2);
  assertEquals(size,getTotalOwnedEntryCount(map1,map2,map3));
  assertEquals(2 * size,getTotalBackupEntryCount(map1,map2,map3));
}","@Test public void issue395BackupProblemWithBCount2() throws InterruptedException {
  final int size=1000;
  Config config=new Config();
  config.setProperty(GroupProperties.PROP_PARTITION_MIGRATION_INTERVAL,""String_Node_Str"");
  config.getMapConfig(""String_Node_Str"").setBackupCount(2);
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(config);
  IMap map1=h1.getMap(""String_Node_Str"");
  IMap map2=h2.getMap(""String_Node_Str"");
  for (int i=0; i < size; i++) {
    map1.put(i,i);
  }
  assertEquals(size,getTotalOwnedEntryCount(map1,map2));
  assertEquals(size,getTotalBackupEntryCount(map1,map2));
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(config);
  IMap map3=h3.getMap(""String_Node_Str"");
  Thread.sleep(1000 * 3);
  assertEquals(size,getTotalOwnedEntryCount(map1,map2,map3));
  assertEquals(2 * size,getTotalBackupEntryCount(map1,map2,map3));
}",0.992497320471597
49510,"@Override public String toString(){
  StringBuffer sb=new StringBuffer(""String_Node_Str"");
  sb.append(lsMembers.size());
  sb.append(""String_Node_Str"");
  for (  MemberImpl member : lsMembers) {
    sb.append(""String_Node_Str"").append(member);
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}","@Override public String toString(){
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  sb.append(lsMembers.size());
  sb.append(""String_Node_Str"");
  for (  MemberImpl member : lsMembers) {
    sb.append(""String_Node_Str"").append(member);
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}",0.3908794788273615
49511,"private void postJoin(){
  systemLogService.logJoin(""String_Node_Str"" + node.getMasterAddress() + ""String_Node_Str""+ node.isMaster());
  if (!node.isActive()) {
    return;
  }
  if (tryCount.incrementAndGet() == 5) {
    node.setAsMaster();
  }
  if (!node.isMaster()) {
    boolean allConnected=false;
    int checkCount=0;
    long maxJoinMillis=node.getGroupProperties().MAX_JOIN_SECONDS.getInteger() * 1000;
    if (node.joined()) {
      systemLogService.logJoin(""String_Node_Str"");
      while (checkCount++ < node.groupProperties.CONNECT_ALL_WAIT_SECONDS.getInteger() && !allConnected) {
        try {
          Thread.sleep(1000);
        }
 catch (        InterruptedException ignored) {
        }
        Set<Member> members=node.getClusterImpl().getMembers();
        allConnected=true;
        for (        Member member : members) {
          MemberImpl memberImpl=(MemberImpl)member;
          if (!memberImpl.localMember() && node.connectionManager.getConnection(memberImpl.getAddress()) == null) {
            allConnected=false;
            systemLogService.logJoin(""String_Node_Str"" + memberImpl.getAddress());
          }
        }
      }
    }
    if (!node.joined() || !allConnected) {
      if (Clock.currentTimeMillis() - joinStartTime < maxJoinMillis) {
        logger.log(Level.WARNING,""String_Node_Str"" + node.joined() + ""String_Node_Str""+ allConnected+ ""String_Node_Str""+ checkCount+ ""String_Node_Str"");
        logger.log(Level.WARNING,""String_Node_Str"");
        try {
          Thread.sleep(10000);
        }
 catch (        InterruptedException e) {
          node.shutdown(false,true);
        }
        node.rejoin();
      }
 else {
        throw new RuntimeException(""String_Node_Str"" + (maxJoinMillis / 1000) + ""String_Node_Str"");
      }
      return;
    }
 else {
      node.clusterManager.finalizeJoin();
    }
  }
  node.clusterManager.enqueueAndWait(new Processable(){
    public void process(){
      if (node.baseVariables.lsMembers.size() == 1) {
        final StringBuilder sb=new StringBuilder();
        sb.append(""String_Node_Str"");
        sb.append(node.clusterManager);
        logger.log(Level.INFO,sb.toString());
      }
    }
  }
,5);
}","private void postJoin(){
  systemLogService.logJoin(""String_Node_Str"" + node.getMasterAddress() + ""String_Node_Str""+ node.isMaster());
  if (!node.isActive()) {
    return;
  }
  if (tryCount.incrementAndGet() == 5) {
    logger.log(Level.WARNING,""String_Node_Str"");
    node.setAsMaster();
  }
  if (!node.isMaster()) {
    boolean allConnected=false;
    int checkCount=0;
    long maxJoinMillis=node.getGroupProperties().MAX_JOIN_SECONDS.getInteger() * 1000;
    if (node.joined()) {
      systemLogService.logJoin(""String_Node_Str"");
      while (checkCount++ < node.groupProperties.CONNECT_ALL_WAIT_SECONDS.getInteger() && !allConnected) {
        try {
          Thread.sleep(1000);
        }
 catch (        InterruptedException ignored) {
        }
        Set<Member> members=node.getClusterImpl().getMembers();
        allConnected=true;
        for (        Member member : members) {
          MemberImpl memberImpl=(MemberImpl)member;
          if (!memberImpl.localMember() && node.connectionManager.getConnection(memberImpl.getAddress()) == null) {
            allConnected=false;
            systemLogService.logJoin(""String_Node_Str"" + memberImpl.getAddress());
          }
        }
      }
    }
    if (!node.joined() || !allConnected) {
      if (Clock.currentTimeMillis() - joinStartTime < maxJoinMillis) {
        logger.log(Level.WARNING,""String_Node_Str"" + node.joined() + ""String_Node_Str""+ allConnected+ ""String_Node_Str""+ checkCount+ ""String_Node_Str"");
        logger.log(Level.WARNING,""String_Node_Str"");
        try {
          Thread.sleep(10000);
          node.rejoin();
        }
 catch (        InterruptedException e) {
          logger.log(Level.WARNING,e.getMessage(),e);
          node.shutdown(false,true);
        }
      }
 else {
        throw new RuntimeException(""String_Node_Str"" + (maxJoinMillis / 1000) + ""String_Node_Str"");
      }
      return;
    }
 else {
      node.clusterManager.finalizeJoin();
    }
  }
  tryCount.set(0);
  node.clusterManager.enqueueAndWait(new Processable(){
    public void process(){
      if (node.baseVariables.lsMembers.size() == 1) {
        final StringBuilder sb=new StringBuilder();
        sb.append(""String_Node_Str"");
        sb.append(node.clusterManager);
        logger.log(Level.INFO,sb.toString());
      }
    }
  }
,5);
}",0.962322695035461
49512,"protected void failedJoiningToMaster(boolean multicast,int tryCount){
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(tryCount);
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(node.address);
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(node.getMasterAddress());
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(multicast);
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(node.connectionManager.getConnection(node.getMasterAddress()));
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  throw new IllegalStateException(sb.toString());
}","protected void failedJoiningToMaster(boolean multicast,int tryCount){
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(tryCount);
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(node.address);
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(node.getMasterAddress());
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(multicast);
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(node.connectionManager.getConnection(node.getMasterAddress()));
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  throw new IllegalStateException(sb.toString());
}",0.979565772669221
49513,"public void pickAddress() throws Exception {
  if (address != null) {
    return;
  }
  try {
    final Config config=node.getConfig();
    final InetAddress inetAddress=pickInetAddress(config);
    final boolean reuseAddress=config.isReuseAddress();
    serverSocketChannel=ServerSocketChannel.open();
    final ServerSocket serverSocket=serverSocketChannel.socket();
    log(Level.FINEST,""String_Node_Str"" + reuseAddress);
    serverSocket.setReuseAddress(reuseAddress);
    serverSocket.setSoTimeout(1000);
    InetSocketAddress isa;
    int port=config.getPort();
    for (int i=0; i < 100; i++) {
      try {
        boolean bindAny=node.getGroupProperties().SOCKET_BIND_ANY.getBoolean();
        if (bindAny) {
          isa=new InetSocketAddress(port);
        }
 else {
          isa=new InetSocketAddress(inetAddress,port);
        }
        log(Level.FINEST,""String_Node_Str"" + isa);
        serverSocket.bind(isa,100);
        log(Level.FINEST,""String_Node_Str"" + isa);
        break;
      }
 catch (      final Exception e) {
        if (config.isPortAutoIncrement()) {
          port++;
        }
 else {
          String msg=""String_Node_Str"" + port + ""String_Node_Str""+ ""String_Node_Str"";
          logger.log(Level.SEVERE,msg,e);
          throw e;
        }
      }
    }
    serverSocketChannel.configureBlocking(false);
    address=new Address(inetAddress,port);
  }
 catch (  Exception e) {
    logger.log(Level.SEVERE,e.getMessage(),e);
    throw e;
  }
}","private AddressDefinition pickAddress(final Config config) throws UnknownHostException, SocketException {
  AddressDefinition infAddress=getSystemConfiguredAddress();
  if (infAddress == null) {
    final NetworkConfig networkConfig=config.getNetworkConfig();
    final Collection<InterfaceDefinition> interfaces=getInterfaces(networkConfig);
    if (interfaces.contains(new InterfaceDefinition(""String_Node_Str"")) || interfaces.contains(new InterfaceDefinition(""String_Node_Str""))) {
      infAddress=pickLoopbackAddress();
    }
 else {
      if (preferIPv4Stack()) {
        logger.log(Level.INFO,""String_Node_Str"");
      }
      if (interfaces.size() > 0) {
        infAddress=pickMatchingAddress(interfaces);
      }
      if (infAddress == null) {
        if (networkConfig.getInterfaces().isEnabled()) {
          String msg=""String_Node_Str"";
          msg+=""String_Node_Str"";
          logger.log(Level.SEVERE,msg);
          throw new RuntimeException(msg);
        }
 else {
          if (networkConfig.getJoin().getTcpIpConfig().isEnabled()) {
            logger.log(Level.WARNING,""String_Node_Str"" + ""String_Node_Str"");
          }
          infAddress=pickMatchingAddress(null);
        }
      }
    }
  }
  if (infAddress != null) {
    infAddress.inetAddress=AddressUtil.fixScopeIdAndGetInetAddress(infAddress.inetAddress);
  }
  if (infAddress == null) {
    infAddress=pickLoopbackAddress();
  }
  return infAddress;
}",0.1598627787307032
49514,"private Collection<String> getInterfaces(final Config config){
  final Collection<String> interfaces=new HashSet<String>();
  if (config.getNetworkConfig().getInterfaces().isEnabled()) {
    interfaces.addAll(config.getNetworkConfig().getInterfaces().getInterfaces());
    logger.log(Level.INFO,""String_Node_Str"" + ""String_Node_Str"" + interfaces);
  }
 else   if (config.getNetworkConfig().getJoin().getTcpIpConfig().isEnabled()) {
    final Collection<String> possibleAddresses=TcpIpJoiner.getConfigurationMembers(node.config);
    for (    String possibleAddress : possibleAddresses) {
      interfaces.add(AddressUtil.getAddressHolder(possibleAddress).address);
    }
    logger.log(Level.FINEST,""String_Node_Str"" + ""String_Node_Str"" + interfaces);
  }
  return interfaces;
}","private Collection<InterfaceDefinition> getInterfaces(final NetworkConfig networkConfig) throws UnknownHostException {
  final Collection<InterfaceDefinition> interfaces=new HashSet<InterfaceDefinition>();
  if (networkConfig.getInterfaces().isEnabled()) {
    final Collection<String> configInterfaces=networkConfig.getInterfaces().getInterfaces();
    for (    String configInterface : configInterfaces) {
      if (AddressUtil.isIpAddress(configInterface)) {
        interfaces.add(new InterfaceDefinition(configInterface));
      }
 else {
        logger.log(Level.INFO,""String_Node_Str"" + configInterface + ""String_Node_Str"");
      }
    }
    logger.log(Level.INFO,""String_Node_Str"" + ""String_Node_Str"" + interfaces);
  }
 else   if (networkConfig.getJoin().getTcpIpConfig().isEnabled()) {
    final Collection<String> possibleAddresses=TcpIpJoiner.getConfigurationMembers(node.config);
    for (    String possibleAddress : possibleAddresses) {
      final String s=AddressUtil.getAddressHolder(possibleAddress).address;
      if (AddressUtil.isIpAddress(s)) {
        interfaces.add(new InterfaceDefinition(s));
      }
 else {
        String address=resolveDomainName(s);
        logger.log(Level.INFO,""String_Node_Str"" + address + ""String_Node_Str""+ s+ ""String_Node_Str"");
        interfaces.add(new InterfaceDefinition(s,address));
      }
    }
    logger.log(Level.INFO,""String_Node_Str"" + ""String_Node_Str"" + interfaces);
  }
  return interfaces;
}",0.4792503346720214
49515,"private InetAddress pickLoopbackAddress() throws UnknownHostException {
  if (System.getProperty(""String_Node_Str"") == null && System.getProperty(""String_Node_Str"") == null) {
    logger.log(Level.WARNING,""String_Node_Str"");
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
  }
  return InetAddress.getByName(""String_Node_Str"");
}","private AddressDefinition pickLoopbackAddress() throws UnknownHostException {
  if (System.getProperty(""String_Node_Str"") == null && System.getProperty(""String_Node_Str"") == null) {
    logger.log(Level.WARNING,""String_Node_Str"");
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
  }
  return new AddressDefinition(""String_Node_Str"",InetAddress.getByName(""String_Node_Str""));
}",0.905608755129959
49516,"private boolean preferIPv4Stack(){
  boolean preferIPv4Stack=node.groupProperties.PREFER_IPv4_STACK.getBoolean();
  Join join=node.getConfig().getNetworkConfig().getJoin();
  AwsConfig awsConfig=join.getAwsConfig();
  boolean awsEnabled=awsConfig != null && awsConfig.isEnabled();
  return preferIPv4Stack || awsEnabled;
}","private boolean preferIPv4Stack(){
  boolean preferIPv4Stack=Boolean.getBoolean(""String_Node_Str"") || node.groupProperties.PREFER_IPv4_STACK.getBoolean();
  Join join=node.getConfig().getNetworkConfig().getJoin();
  AwsConfig awsConfig=join.getAwsConfig();
  boolean awsEnabled=awsConfig != null && awsConfig.isEnabled();
  return preferIPv4Stack || awsEnabled;
}",0.94014598540146
49517,"private InetAddress getSystemConfiguredAddress() throws UnknownHostException {
  final String localAddress=System.getProperty(""String_Node_Str"");
  if (localAddress != null) {
    if (""String_Node_Str"".equals(localAddress.trim()) || ""String_Node_Str"".equals(localAddress.trim())) {
      return pickLoopbackAddress();
    }
 else {
      return InetAddress.getByName(localAddress.trim());
    }
  }
  return null;
}","private AddressDefinition getSystemConfiguredAddress() throws UnknownHostException {
  String localAddress=System.getProperty(""String_Node_Str"");
  if (localAddress != null) {
    localAddress=localAddress.trim();
    if (""String_Node_Str"".equals(localAddress) || ""String_Node_Str"".equals(localAddress)) {
      return pickLoopbackAddress();
    }
 else {
      logger.log(Level.INFO,""String_Node_Str"");
      return new AddressDefinition(localAddress,InetAddress.getByName(localAddress));
    }
  }
  return null;
}",0.7969924812030075
49518,"public void doRun(){
  clientEndpoint.connectionRemoved(connection);
  if (node.securityContext != null) {
    try {
      clientEndpoint.getLoginContext().logout();
    }
 catch (    LoginException e) {
      logger.log(Level.WARNING,e.getMessage(),e);
    }
  }
}","public void doRun(){
  logger.log(Level.INFO,""String_Node_Str"" + connection + ""String_Node_Str"");
  clientEndpoint.connectionRemoved(connection);
  if (node.securityContext != null) {
    try {
      clientEndpoint.getLoginContext().logout();
    }
 catch (    LoginException e) {
      logger.log(Level.WARNING,e.getMessage(),e);
    }
  }
}",0.8731466227347611
49519,"public void connectionRemoved(final Connection connection){
  final ClientEndpoint clientEndpoint=removeClientEndpoint(connection);
  if (clientEndpoint != null) {
    node.executorManager.executeNow(new FallThroughRunnable(){
      public void doRun(){
        clientEndpoint.connectionRemoved(connection);
        if (node.securityContext != null) {
          try {
            clientEndpoint.getLoginContext().logout();
          }
 catch (          LoginException e) {
            logger.log(Level.WARNING,e.getMessage(),e);
          }
        }
      }
    }
);
  }
}","public void connectionRemoved(final Connection connection){
  final ClientEndpoint clientEndpoint=removeClientEndpoint(connection);
  if (clientEndpoint != null) {
    node.executorManager.executeNow(new FallThroughRunnable(){
      public void doRun(){
        logger.log(Level.INFO,""String_Node_Str"" + connection + ""String_Node_Str"");
        clientEndpoint.connectionRemoved(connection);
        if (node.securityContext != null) {
          try {
            clientEndpoint.getLoginContext().logout();
          }
 catch (          LoginException e) {
            logger.log(Level.WARNING,e.getMessage(),e);
          }
        }
      }
    }
);
  }
}",0.9324654190398698
49520,"public void searchForOtherClusters(SplitBrainHandler splitBrainHandler){
  final Collection<Address> colPossibleAddresses;
  try {
    colPossibleAddresses=getPossibleAddresses();
  }
 catch (  Throwable e) {
    logger.log(Level.SEVERE,e.getMessage(),e);
    return;
  }
  colPossibleAddresses.remove(node.getThisAddress());
  for (  Member member : node.getClusterImpl().getMembers()) {
    colPossibleAddresses.remove(((MemberImpl)member).getAddress());
  }
  if (colPossibleAddresses.size() == 0) {
    return;
  }
  for (  final Address possibleAddress : colPossibleAddresses) {
    logger.log(Level.FINEST,node.getThisAddress() + ""String_Node_Str"" + possibleAddress);
    node.connectionManager.getOrConnect(possibleAddress,true);
  }
  for (  Address possibleAddress : colPossibleAddresses) {
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
      return;
    }
    final Connection conn=node.connectionManager.getConnection(possibleAddress);
    if (conn != null) {
      final JoinInfo response=node.clusterManager.checkJoin(conn);
      if (response != null && shouldMerge(response)) {
        logger.log(Level.WARNING,node.address + ""String_Node_Str"" + possibleAddress);
        splitBrainHandler.restart();
      }
      return;
    }
  }
}","public void searchForOtherClusters(SplitBrainHandler splitBrainHandler){
  final Collection<Address> colPossibleAddresses;
  try {
    colPossibleAddresses=getPossibleAddresses();
  }
 catch (  Throwable e) {
    logger.log(Level.SEVERE,e.getMessage(),e);
    return;
  }
  colPossibleAddresses.remove(node.getThisAddress());
  for (  Member member : node.getClusterImpl().getMembers()) {
    colPossibleAddresses.remove(((MemberImpl)member).getAddress());
  }
  if (colPossibleAddresses.isEmpty()) {
    return;
  }
  for (  Address possibleAddress : colPossibleAddresses) {
    logger.log(Level.FINEST,node.getThisAddress() + ""String_Node_Str"" + possibleAddress);
    node.connectionManager.getOrConnect(possibleAddress,true);
    try {
      Thread.sleep(1500);
    }
 catch (    InterruptedException e) {
      return;
    }
    final Connection conn=node.connectionManager.getConnection(possibleAddress);
    if (conn != null) {
      final JoinInfo response=node.clusterManager.checkJoin(conn);
      if (response != null && shouldMerge(response)) {
        logger.log(Level.WARNING,node.address + ""String_Node_Str"" + possibleAddress);
        splitBrainHandler.restart();
        return;
      }
 else {
        conn.close();
      }
    }
  }
}",0.9380670611439842
49521,"@Override public String toString(){
  StringBuffer sb=new StringBuffer(""String_Node_Str"");
  sb.append(lsMembers.size());
  sb.append(""String_Node_Str"");
  for (  MemberImpl member : lsMembers) {
    sb.append(""String_Node_Str"").append(member);
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}","@Override public String toString(){
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  sb.append(lsMembers.size());
  sb.append(""String_Node_Str"");
  for (  MemberImpl member : lsMembers) {
    sb.append(""String_Node_Str"").append(member);
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}",0.3908794788273615
49522,"private void postJoin(){
  systemLogService.logJoin(""String_Node_Str"" + node.getMasterAddress() + ""String_Node_Str""+ node.isMaster());
  if (!node.isActive()) {
    return;
  }
  if (tryCount.incrementAndGet() == 5) {
    node.setAsMaster();
  }
  if (!node.isMaster()) {
    boolean allConnected=false;
    int checkCount=0;
    long maxJoinMillis=node.getGroupProperties().MAX_JOIN_SECONDS.getInteger() * 1000;
    if (node.joined()) {
      systemLogService.logJoin(""String_Node_Str"");
      while (checkCount++ < node.groupProperties.CONNECT_ALL_WAIT_SECONDS.getInteger() && !allConnected) {
        try {
          Thread.sleep(1000);
        }
 catch (        InterruptedException ignored) {
        }
        Set<Member> members=node.getClusterImpl().getMembers();
        allConnected=true;
        for (        Member member : members) {
          MemberImpl memberImpl=(MemberImpl)member;
          if (!memberImpl.localMember() && node.connectionManager.getConnection(memberImpl.getAddress()) == null) {
            allConnected=false;
            systemLogService.logJoin(""String_Node_Str"" + memberImpl.getAddress());
          }
        }
      }
    }
    if (!node.joined() || !allConnected) {
      if (Clock.currentTimeMillis() - joinStartTime < maxJoinMillis) {
        logger.log(Level.WARNING,""String_Node_Str"" + node.joined() + ""String_Node_Str""+ allConnected+ ""String_Node_Str""+ checkCount+ ""String_Node_Str"");
        logger.log(Level.WARNING,""String_Node_Str"");
        try {
          Thread.sleep(10000);
        }
 catch (        InterruptedException e) {
          node.shutdown(false,true);
        }
        node.rejoin();
      }
 else {
        throw new RuntimeException(""String_Node_Str"" + (maxJoinMillis / 1000) + ""String_Node_Str"");
      }
      return;
    }
 else {
      node.clusterManager.finalizeJoin();
    }
  }
  node.clusterManager.enqueueAndWait(new Processable(){
    public void process(){
      if (node.baseVariables.lsMembers.size() == 1) {
        final StringBuilder sb=new StringBuilder();
        sb.append(""String_Node_Str"");
        sb.append(node.clusterManager);
        logger.log(Level.INFO,sb.toString());
      }
    }
  }
,5);
}","private void postJoin(){
  systemLogService.logJoin(""String_Node_Str"" + node.getMasterAddress() + ""String_Node_Str""+ node.isMaster());
  if (!node.isActive()) {
    return;
  }
  if (tryCount.incrementAndGet() == 5) {
    logger.log(Level.WARNING,""String_Node_Str"");
    node.setAsMaster();
  }
  if (!node.isMaster()) {
    boolean allConnected=false;
    int checkCount=0;
    long maxJoinMillis=node.getGroupProperties().MAX_JOIN_SECONDS.getInteger() * 1000;
    if (node.joined()) {
      systemLogService.logJoin(""String_Node_Str"");
      while (checkCount++ < node.groupProperties.CONNECT_ALL_WAIT_SECONDS.getInteger() && !allConnected) {
        try {
          Thread.sleep(1000);
        }
 catch (        InterruptedException ignored) {
        }
        Set<Member> members=node.getClusterImpl().getMembers();
        allConnected=true;
        for (        Member member : members) {
          MemberImpl memberImpl=(MemberImpl)member;
          if (!memberImpl.localMember() && node.connectionManager.getConnection(memberImpl.getAddress()) == null) {
            allConnected=false;
            systemLogService.logJoin(""String_Node_Str"" + memberImpl.getAddress());
          }
        }
      }
    }
    if (!node.joined() || !allConnected) {
      if (Clock.currentTimeMillis() - joinStartTime < maxJoinMillis) {
        logger.log(Level.WARNING,""String_Node_Str"" + node.joined() + ""String_Node_Str""+ allConnected+ ""String_Node_Str""+ checkCount+ ""String_Node_Str"");
        logger.log(Level.WARNING,""String_Node_Str"");
        try {
          Thread.sleep(10000);
          node.rejoin();
        }
 catch (        InterruptedException e) {
          logger.log(Level.WARNING,e.getMessage(),e);
          node.shutdown(false,true);
        }
      }
 else {
        throw new RuntimeException(""String_Node_Str"" + (maxJoinMillis / 1000) + ""String_Node_Str"");
      }
      return;
    }
 else {
      node.clusterManager.finalizeJoin();
    }
  }
  tryCount.set(0);
  node.clusterManager.enqueueAndWait(new Processable(){
    public void process(){
      if (node.baseVariables.lsMembers.size() == 1) {
        final StringBuilder sb=new StringBuilder();
        sb.append(""String_Node_Str"");
        sb.append(node.clusterManager);
        logger.log(Level.INFO,sb.toString());
      }
    }
  }
,5);
}",0.962322695035461
49523,"protected void failedJoiningToMaster(boolean multicast,int tryCount){
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(tryCount);
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(node.address);
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(node.getMasterAddress());
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(multicast);
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(node.connectionManager.getConnection(node.getMasterAddress()));
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  throw new IllegalStateException(sb.toString());
}","protected void failedJoiningToMaster(boolean multicast,int tryCount){
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(tryCount);
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(node.address);
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(node.getMasterAddress());
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(multicast);
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(node.connectionManager.getConnection(node.getMasterAddress()));
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  throw new IllegalStateException(sb.toString());
}",0.979565772669221
49524,"public void pickAddress() throws Exception {
  if (address != null) {
    return;
  }
  try {
    final Config config=node.getConfig();
    final InetAddress inetAddress=pickInetAddress(config);
    final boolean reuseAddress=config.isReuseAddress();
    serverSocketChannel=ServerSocketChannel.open();
    final ServerSocket serverSocket=serverSocketChannel.socket();
    logger.log(Level.FINEST,""String_Node_Str"" + reuseAddress);
    serverSocket.setReuseAddress(reuseAddress);
    serverSocket.setSoTimeout(1000);
    InetSocketAddress isa;
    int port=config.getPort();
    for (int i=0; i < 100; i++) {
      try {
        boolean bindAny=node.getGroupProperties().SOCKET_BIND_ANY.getBoolean();
        if (bindAny) {
          isa=new InetSocketAddress(port);
        }
 else {
          isa=new InetSocketAddress(inetAddress,port);
        }
        logger.log(Level.FINEST,""String_Node_Str"" + isa);
        serverSocket.bind(isa,100);
        break;
      }
 catch (      final Exception e) {
        if (config.isPortAutoIncrement()) {
          port++;
        }
 else {
          String msg=""String_Node_Str"" + port + ""String_Node_Str""+ ""String_Node_Str"";
          logger.log(Level.SEVERE,msg,e);
          throw e;
        }
      }
    }
    serverSocketChannel.configureBlocking(false);
    address=new Address(inetAddress,port);
  }
 catch (  Exception e) {
    logger.log(Level.SEVERE,e.getMessage(),e);
    throw e;
  }
}","public void pickAddress() throws Exception {
  if (address != null) {
    return;
  }
  try {
    final Config config=node.getConfig();
    final InetAddress inetAddress=pickInetAddress(config);
    final boolean reuseAddress=config.isReuseAddress();
    final boolean bindAny=node.getGroupProperties().SOCKET_BIND_ANY.getBoolean();
    serverSocketChannel=ServerSocketChannel.open();
    final ServerSocket serverSocket=serverSocketChannel.socket();
    logger.log(Level.FINEST,""String_Node_Str"" + reuseAddress);
    serverSocket.setReuseAddress(reuseAddress);
    serverSocket.setSoTimeout(1000);
    InetSocketAddress isa;
    int port=config.getPort();
    for (int i=0; i < 100; i++) {
      try {
        if (bindAny) {
          isa=new InetSocketAddress(port);
        }
 else {
          isa=new InetSocketAddress(inetAddress,port);
        }
        logger.log(Level.FINEST,""String_Node_Str"" + isa);
        serverSocket.bind(isa,100);
        break;
      }
 catch (      final Exception e) {
        if (config.isPortAutoIncrement()) {
          port++;
        }
 else {
          String msg=""String_Node_Str"" + port + ""String_Node_Str""+ ""String_Node_Str"";
          logger.log(Level.SEVERE,msg,e);
          throw e;
        }
      }
    }
    serverSocketChannel.configureBlocking(false);
    address=new Address(inetAddress,port);
    logger.log(Level.INFO,""String_Node_Str"" + address + ""String_Node_Str""+ serverSocket+ ""String_Node_Str""+ bindAny);
  }
 catch (  Exception e) {
    logger.log(Level.SEVERE,e.getMessage(),e);
    throw e;
  }
}",0.7113333333333334
49525,"private Collection<String> getInterfaces(final Config config){
  final Collection<String> interfaces=new HashSet<String>();
  if (config.getNetworkConfig().getInterfaces().isEnabled()) {
    interfaces.addAll(config.getNetworkConfig().getInterfaces().getInterfaces());
    logger.log(Level.INFO,""String_Node_Str"" + ""String_Node_Str"" + interfaces);
  }
 else   if (config.getNetworkConfig().getJoin().getTcpIpConfig().isEnabled()) {
    final Collection<String> possibleAddresses=TcpIpJoiner.getConfigurationMembers(node.config);
    for (    String possibleAddress : possibleAddresses) {
      interfaces.add(AddressUtil.getAddressHolder(possibleAddress).address);
    }
    logger.log(Level.FINEST,""String_Node_Str"" + ""String_Node_Str"" + interfaces);
  }
  return interfaces;
}","private Collection<String> getInterfaces(final NetworkConfig networkConfig) throws UnknownHostException {
  final Collection<String> interfaces=new HashSet<String>();
  if (networkConfig.getInterfaces().isEnabled()) {
    interfaces.addAll(networkConfig.getInterfaces().getInterfaces());
    logger.log(Level.INFO,""String_Node_Str"" + ""String_Node_Str"" + interfaces);
    removeDomainNames(interfaces);
  }
 else   if (networkConfig.getJoin().getTcpIpConfig().isEnabled()) {
    final Collection<String> possibleAddresses=TcpIpJoiner.getConfigurationMembers(node.config);
    for (    String possibleAddress : possibleAddresses) {
      final String s=AddressUtil.getAddressHolder(possibleAddress).address;
      if (AddressUtil.isIpAddress(s)) {
        interfaces.add(s);
      }
 else {
        String address=resolveDomainName(s);
        logger.log(Level.INFO,""String_Node_Str"" + address + ""String_Node_Str""+ s+ ""String_Node_Str"");
        interfaces.add(address);
      }
    }
    logger.log(Level.INFO,""String_Node_Str"" + ""String_Node_Str"" + interfaces);
  }
  return interfaces;
}",0.6237942122186495
49526,"public void doJoin(AtomicBoolean joined){
  int tryCount=0;
  long joinStartTime=Clock.currentTimeMillis();
  long maxJoinMillis=node.getGroupProperties().MAX_JOIN_SECONDS.getInteger() * 1000;
  while (node.isActive() && !joined.get() && (Clock.currentTimeMillis() - joinStartTime < maxJoinMillis)) {
    String msg=""String_Node_Str"" + node.getMasterAddress();
    logger.log(Level.FINEST,msg);
    systemLogService.logJoin(msg);
    Address masterAddressNow=findMasterWithMulticast();
    if (masterAddressNow != null && masterAddressNow.equals(node.getMasterAddress())) {
      tryCount--;
    }
    node.setMasterAddress(masterAddressNow);
    systemLogService.logJoin(""String_Node_Str"" + masterAddressNow);
    if (node.getMasterAddress() == null || node.address.equals(node.getMasterAddress())) {
      TcpIpConfig tcpIpConfig=config.getNetworkConfig().getJoin().getTcpIpConfig();
      if (tcpIpConfig != null && tcpIpConfig.isEnabled()) {
        doTCP(joined);
      }
 else {
        systemLogService.logJoin(""String_Node_Str"");
        node.setAsMaster();
      }
      return;
    }
    if (tryCount++ > 22) {
      failedJoiningToMaster(true,tryCount);
    }
    if (!node.getMasterAddress().equals(node.address)) {
      connectAndSendJoinRequest(node.getMasterAddress());
    }
 else {
      node.setMasterAddress(null);
      tryCount=0;
    }
    try {
      Thread.sleep(500L);
    }
 catch (    InterruptedException ignored) {
    }
  }
}","public void doJoin(AtomicBoolean joined){
  int tryCount=0;
  long joinStartTime=Clock.currentTimeMillis();
  long maxJoinMillis=node.getGroupProperties().MAX_JOIN_SECONDS.getInteger() * 1000;
  while (node.isActive() && !joined.get() && (Clock.currentTimeMillis() - joinStartTime < maxJoinMillis)) {
    String msg=""String_Node_Str"" + node.getMasterAddress();
    logger.log(Level.FINEST,msg);
    systemLogService.logJoin(msg);
    Address masterAddressNow=findMasterWithMulticast();
    node.setMasterAddress(masterAddressNow);
    systemLogService.logJoin(""String_Node_Str"" + masterAddressNow);
    if (node.getMasterAddress() == null || node.address.equals(node.getMasterAddress())) {
      TcpIpConfig tcpIpConfig=config.getNetworkConfig().getJoin().getTcpIpConfig();
      if (tcpIpConfig != null && tcpIpConfig.isEnabled()) {
        doTCP(joined);
      }
 else {
        systemLogService.logJoin(""String_Node_Str"");
        node.setAsMaster();
      }
      return;
    }
    if (++tryCount > 24) {
      failedJoiningToMaster(true,tryCount);
    }
    if (!node.getMasterAddress().equals(node.address)) {
      connectAndSendJoinRequest(node.getMasterAddress());
    }
 else {
      node.setMasterAddress(null);
      tryCount=0;
    }
    try {
      Thread.sleep(500L);
    }
 catch (    InterruptedException ignored) {
    }
  }
}",0.9578571428571429
49527,"private boolean connectAndSendJoinRequest(Address masterAddress){
  if (masterAddress == null || masterAddress.equals(node.address)) {
    throw new IllegalArgumentException();
  }
  Connection conn=node.connectionManager.getOrConnect(masterAddress);
  logger.log(Level.FINEST,""String_Node_Str"" + conn);
  systemLogService.logJoin(""String_Node_Str"" + conn);
  if (conn != null) {
    return node.clusterManager.sendJoinRequest(masterAddress,true);
  }
  return false;
}","private boolean connectAndSendJoinRequest(Address masterAddress){
  if (masterAddress == null || masterAddress.equals(node.address)) {
    throw new IllegalArgumentException();
  }
  Connection conn=node.connectionManager.getOrConnect(masterAddress);
  logger.log(Level.FINEST,""String_Node_Str"" + conn);
  systemLogService.logJoin(""String_Node_Str"" + conn);
  if (conn != null) {
    return node.clusterManager.sendJoinRequest(masterAddress,true);
  }
 else {
    logger.log(Level.INFO,""String_Node_Str"" + masterAddress);
    return false;
  }
}",0.9250493096646942
49528,"void join(){
  long joinStartTime=Clock.currentTimeMillis();
  long maxJoinMillis=getGroupProperties().MAX_JOIN_SECONDS.getInteger() * 1000;
  try {
    if (joiner == null) {
      logger.log(Level.WARNING,""String_Node_Str"");
      setAsMaster();
    }
 else {
      joiner.join(joined);
    }
  }
 catch (  Exception e) {
    logger.log(Level.WARNING,e.getMessage());
    if (Clock.currentTimeMillis() - joinStartTime < maxJoinMillis) {
      factory.lifecycleService.restart();
    }
 else {
      setActive(false);
      joined.set(false);
      Util.throwUncheckedException(e);
    }
  }
}","void join(){
  final long joinStartTime=joiner != null ? joiner.getStartTime() : Clock.currentTimeMillis();
  final long maxJoinMillis=getGroupProperties().MAX_JOIN_SECONDS.getInteger() * 1000;
  try {
    if (joiner == null) {
      logger.log(Level.WARNING,""String_Node_Str"");
      setAsMaster();
    }
 else {
      joiner.join(joined);
    }
  }
 catch (  Exception e) {
    if (Clock.currentTimeMillis() - joinStartTime < maxJoinMillis) {
      logger.log(Level.WARNING,e.getMessage());
      rejoin();
    }
 else {
      logger.log(Level.SEVERE,e.getMessage(),e);
      shutdown(false,true);
    }
  }
}",0.6461794019933554
49529,"@Override public String toString(){
  StringBuffer sb=new StringBuffer(""String_Node_Str"");
  sb.append(lsMembers.size());
  sb.append(""String_Node_Str"");
  for (  MemberImpl member : lsMembers) {
    sb.append(""String_Node_Str"").append(member);
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}","@Override public String toString(){
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  sb.append(lsMembers.size());
  sb.append(""String_Node_Str"");
  for (  MemberImpl member : lsMembers) {
    sb.append(""String_Node_Str"").append(member);
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}",0.3908794788273615
49530,"private void postJoin(){
  systemLogService.logJoin(""String_Node_Str"" + node.getMasterAddress() + ""String_Node_Str""+ node.isMaster());
  if (!node.isActive()) {
    return;
  }
  if (tryCount.incrementAndGet() == 5) {
    node.setAsMaster();
  }
  if (!node.isMaster()) {
    boolean allConnected=false;
    int checkCount=0;
    long maxJoinMillis=node.getGroupProperties().MAX_JOIN_SECONDS.getInteger() * 1000;
    if (node.joined()) {
      systemLogService.logJoin(""String_Node_Str"");
      while (checkCount++ < node.groupProperties.CONNECT_ALL_WAIT_SECONDS.getInteger() && !allConnected) {
        try {
          Thread.sleep(1000);
        }
 catch (        InterruptedException ignored) {
        }
        Set<Member> members=node.getClusterImpl().getMembers();
        allConnected=true;
        for (        Member member : members) {
          MemberImpl memberImpl=(MemberImpl)member;
          if (!memberImpl.localMember() && node.connectionManager.getConnection(memberImpl.getAddress()) == null) {
            allConnected=false;
            systemLogService.logJoin(""String_Node_Str"" + memberImpl.getAddress());
          }
        }
      }
    }
    if (!node.joined() || !allConnected) {
      if (Clock.currentTimeMillis() - joinStartTime < maxJoinMillis) {
        logger.log(Level.WARNING,""String_Node_Str"" + node.joined() + ""String_Node_Str""+ allConnected+ ""String_Node_Str""+ checkCount+ ""String_Node_Str"");
        logger.log(Level.WARNING,""String_Node_Str"");
        try {
          Thread.sleep(10000);
        }
 catch (        InterruptedException e) {
          node.shutdown(false,true);
        }
        node.rejoin();
      }
 else {
        throw new RuntimeException(""String_Node_Str"" + (maxJoinMillis / 1000) + ""String_Node_Str"");
      }
      return;
    }
 else {
      node.clusterManager.finalizeJoin();
    }
  }
  node.clusterManager.enqueueAndWait(new Processable(){
    public void process(){
      if (node.baseVariables.lsMembers.size() == 1) {
        final StringBuilder sb=new StringBuilder();
        sb.append(""String_Node_Str"");
        sb.append(node.clusterManager);
        logger.log(Level.INFO,sb.toString());
      }
    }
  }
,5);
}","private void postJoin(){
  systemLogService.logJoin(""String_Node_Str"" + node.getMasterAddress() + ""String_Node_Str""+ node.isMaster());
  if (!node.isActive()) {
    return;
  }
  if (tryCount.incrementAndGet() == 5) {
    logger.log(Level.WARNING,""String_Node_Str"");
    node.setAsMaster();
  }
  if (!node.isMaster()) {
    boolean allConnected=false;
    int checkCount=0;
    long maxJoinMillis=node.getGroupProperties().MAX_JOIN_SECONDS.getInteger() * 1000;
    if (node.joined()) {
      systemLogService.logJoin(""String_Node_Str"");
      while (checkCount++ < node.groupProperties.CONNECT_ALL_WAIT_SECONDS.getInteger() && !allConnected) {
        try {
          Thread.sleep(1000);
        }
 catch (        InterruptedException ignored) {
        }
        Set<Member> members=node.getClusterImpl().getMembers();
        allConnected=true;
        for (        Member member : members) {
          MemberImpl memberImpl=(MemberImpl)member;
          if (!memberImpl.localMember() && node.connectionManager.getConnection(memberImpl.getAddress()) == null) {
            allConnected=false;
            systemLogService.logJoin(""String_Node_Str"" + memberImpl.getAddress());
          }
        }
      }
    }
    if (!node.joined() || !allConnected) {
      if (Clock.currentTimeMillis() - joinStartTime < maxJoinMillis) {
        logger.log(Level.WARNING,""String_Node_Str"" + node.joined() + ""String_Node_Str""+ allConnected+ ""String_Node_Str""+ checkCount+ ""String_Node_Str"");
        logger.log(Level.WARNING,""String_Node_Str"");
        try {
          Thread.sleep(10000);
          node.rejoin();
        }
 catch (        InterruptedException e) {
          logger.log(Level.WARNING,e.getMessage(),e);
          node.shutdown(false,true);
        }
      }
 else {
        throw new RuntimeException(""String_Node_Str"" + (maxJoinMillis / 1000) + ""String_Node_Str"");
      }
      return;
    }
 else {
      node.clusterManager.finalizeJoin();
    }
  }
  tryCount.set(0);
  node.clusterManager.enqueueAndWait(new Processable(){
    public void process(){
      if (node.baseVariables.lsMembers.size() == 1) {
        final StringBuilder sb=new StringBuilder();
        sb.append(""String_Node_Str"");
        sb.append(node.clusterManager);
        logger.log(Level.INFO,sb.toString());
      }
    }
  }
,5);
}",0.962322695035461
49531,"protected void failedJoiningToMaster(boolean multicast,int tryCount){
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(tryCount);
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(node.address);
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(node.getMasterAddress());
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(multicast);
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(node.connectionManager.getConnection(node.getMasterAddress()));
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  throw new IllegalStateException(sb.toString());
}","protected void failedJoiningToMaster(boolean multicast,int tryCount){
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(tryCount);
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(node.address);
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(node.getMasterAddress());
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(multicast);
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"").append(node.connectionManager.getConnection(node.getMasterAddress()));
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  throw new IllegalStateException(sb.toString());
}",0.979565772669221
49532,"public void pickAddress() throws Exception {
  if (address != null) {
    return;
  }
  try {
    final Config config=node.getConfig();
    final InetAddress inetAddress=pickInetAddress(config);
    final boolean reuseAddress=config.isReuseAddress();
    serverSocketChannel=ServerSocketChannel.open();
    final ServerSocket serverSocket=serverSocketChannel.socket();
    logger.log(Level.FINEST,""String_Node_Str"" + reuseAddress);
    serverSocket.setReuseAddress(reuseAddress);
    serverSocket.setSoTimeout(1000);
    InetSocketAddress isa;
    int port=config.getPort();
    for (int i=0; i < 100; i++) {
      try {
        boolean bindAny=node.getGroupProperties().SOCKET_BIND_ANY.getBoolean();
        if (bindAny) {
          isa=new InetSocketAddress(port);
        }
 else {
          isa=new InetSocketAddress(inetAddress,port);
        }
        logger.log(Level.FINEST,""String_Node_Str"" + isa);
        serverSocket.bind(isa,100);
        break;
      }
 catch (      final Exception e) {
        if (config.isPortAutoIncrement()) {
          port++;
        }
 else {
          String msg=""String_Node_Str"" + port + ""String_Node_Str""+ ""String_Node_Str"";
          logger.log(Level.SEVERE,msg,e);
          throw e;
        }
      }
    }
    serverSocketChannel.configureBlocking(false);
    address=new Address(inetAddress,port);
  }
 catch (  Exception e) {
    logger.log(Level.SEVERE,e.getMessage(),e);
    throw e;
  }
}","private AddressDefinition pickAddress(final Config config) throws UnknownHostException, SocketException {
  AddressDefinition infAddress=getSystemConfiguredAddress();
  if (infAddress == null) {
    final NetworkConfig networkConfig=config.getNetworkConfig();
    final Collection<InterfaceDefinition> interfaces=getInterfaces(networkConfig);
    if (interfaces.contains(new InterfaceDefinition(""String_Node_Str"")) || interfaces.contains(new InterfaceDefinition(""String_Node_Str""))) {
      infAddress=pickLoopbackAddress();
    }
 else {
      if (preferIPv4Stack()) {
        logger.log(Level.INFO,""String_Node_Str"");
      }
      if (interfaces.size() > 0) {
        infAddress=pickMatchingAddress(interfaces);
      }
      if (infAddress == null) {
        if (networkConfig.getInterfaces().isEnabled()) {
          String msg=""String_Node_Str"";
          msg+=""String_Node_Str"";
          logger.log(Level.SEVERE,msg);
          throw new RuntimeException(msg);
        }
 else {
          if (networkConfig.getJoin().getTcpIpConfig().isEnabled()) {
            logger.log(Level.WARNING,""String_Node_Str"" + ""String_Node_Str"");
          }
          infAddress=pickMatchingAddress(null);
        }
      }
    }
  }
  if (infAddress != null) {
    infAddress.inetAddress=AddressUtil.fixScopeIdAndGetInetAddress(infAddress.inetAddress);
  }
  if (infAddress == null) {
    infAddress=pickLoopbackAddress();
  }
  return infAddress;
}",0.1619179986101459
49533,"private Collection<String> getInterfaces(final Config config){
  final Collection<String> interfaces=new HashSet<String>();
  if (config.getNetworkConfig().getInterfaces().isEnabled()) {
    interfaces.addAll(config.getNetworkConfig().getInterfaces().getInterfaces());
    logger.log(Level.INFO,""String_Node_Str"" + ""String_Node_Str"" + interfaces);
  }
 else   if (config.getNetworkConfig().getJoin().getTcpIpConfig().isEnabled()) {
    final Collection<String> possibleAddresses=TcpIpJoiner.getConfigurationMembers(node.config);
    for (    String possibleAddress : possibleAddresses) {
      interfaces.add(AddressUtil.getAddressHolder(possibleAddress).address);
    }
    logger.log(Level.FINEST,""String_Node_Str"" + ""String_Node_Str"" + interfaces);
  }
  return interfaces;
}","private Collection<InterfaceDefinition> getInterfaces(final NetworkConfig networkConfig) throws UnknownHostException {
  final Collection<InterfaceDefinition> interfaces=new HashSet<InterfaceDefinition>();
  if (networkConfig.getInterfaces().isEnabled()) {
    final Collection<String> configInterfaces=networkConfig.getInterfaces().getInterfaces();
    for (    String configInterface : configInterfaces) {
      if (AddressUtil.isIpAddress(configInterface)) {
        interfaces.add(new InterfaceDefinition(configInterface));
      }
 else {
        logger.log(Level.INFO,""String_Node_Str"" + configInterface + ""String_Node_Str"");
      }
    }
    logger.log(Level.INFO,""String_Node_Str"" + ""String_Node_Str"" + interfaces);
  }
 else   if (networkConfig.getJoin().getTcpIpConfig().isEnabled()) {
    final Collection<String> possibleAddresses=TcpIpJoiner.getConfigurationMembers(node.config);
    for (    String possibleAddress : possibleAddresses) {
      final String s=AddressUtil.getAddressHolder(possibleAddress).address;
      if (AddressUtil.isIpAddress(s)) {
        interfaces.add(new InterfaceDefinition(s));
      }
 else {
        String address=resolveDomainName(s);
        logger.log(Level.INFO,""String_Node_Str"" + address + ""String_Node_Str""+ s+ ""String_Node_Str"");
        interfaces.add(new InterfaceDefinition(s,address));
      }
    }
    logger.log(Level.INFO,""String_Node_Str"" + ""String_Node_Str"" + interfaces);
  }
  return interfaces;
}",0.4792503346720214
49534,"private InetAddress pickLoopbackAddress() throws UnknownHostException {
  if (System.getProperty(""String_Node_Str"") == null && System.getProperty(""String_Node_Str"") == null) {
    logger.log(Level.WARNING,""String_Node_Str"");
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
  }
  return InetAddress.getByName(""String_Node_Str"");
}","private AddressDefinition pickLoopbackAddress() throws UnknownHostException {
  if (System.getProperty(""String_Node_Str"") == null && System.getProperty(""String_Node_Str"") == null) {
    logger.log(Level.WARNING,""String_Node_Str"");
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
  }
  return new AddressDefinition(""String_Node_Str"",InetAddress.getByName(""String_Node_Str""));
}",0.905608755129959
49535,"private boolean preferIPv4Stack(){
  boolean preferIPv4Stack=node.groupProperties.PREFER_IPv4_STACK.getBoolean();
  Join join=node.getConfig().getNetworkConfig().getJoin();
  AwsConfig awsConfig=join.getAwsConfig();
  boolean awsEnabled=awsConfig != null && awsConfig.isEnabled();
  return preferIPv4Stack || awsEnabled;
}","private boolean preferIPv4Stack(){
  boolean preferIPv4Stack=Boolean.getBoolean(""String_Node_Str"") || node.groupProperties.PREFER_IPv4_STACK.getBoolean();
  Join join=node.getConfig().getNetworkConfig().getJoin();
  AwsConfig awsConfig=join.getAwsConfig();
  boolean awsEnabled=awsConfig != null && awsConfig.isEnabled();
  return preferIPv4Stack || awsEnabled;
}",0.94014598540146
49536,"private InetAddress getSystemConfiguredAddress() throws UnknownHostException {
  final String localAddress=System.getProperty(""String_Node_Str"");
  if (localAddress != null) {
    if (""String_Node_Str"".equals(localAddress.trim()) || ""String_Node_Str"".equals(localAddress.trim())) {
      return pickLoopbackAddress();
    }
 else {
      return InetAddress.getByName(localAddress.trim());
    }
  }
  return null;
}","private AddressDefinition getSystemConfiguredAddress() throws UnknownHostException {
  String localAddress=System.getProperty(""String_Node_Str"");
  if (localAddress != null) {
    localAddress=localAddress.trim();
    if (""String_Node_Str"".equals(localAddress) || ""String_Node_Str"".equals(localAddress)) {
      return pickLoopbackAddress();
    }
 else {
      logger.log(Level.INFO,""String_Node_Str"");
      return new AddressDefinition(localAddress,InetAddress.getByName(localAddress));
    }
  }
  return null;
}",0.7969924812030075
49537,"public void doRun(){
  clientEndpoint.connectionRemoved(connection);
  if (node.securityContext != null) {
    try {
      clientEndpoint.getLoginContext().logout();
    }
 catch (    LoginException e) {
      logger.log(Level.WARNING,e.getMessage(),e);
    }
  }
}","public void doRun(){
  logger.log(Level.INFO,""String_Node_Str"" + connection + ""String_Node_Str"");
  clientEndpoint.connectionRemoved(connection);
  if (node.securityContext != null) {
    try {
      clientEndpoint.getLoginContext().logout();
    }
 catch (    LoginException e) {
      logger.log(Level.WARNING,e.getMessage(),e);
    }
  }
}",0.8731466227347611
49538,"public void connectionRemoved(final Connection connection){
  final ClientEndpoint clientEndpoint=removeClientEndpoint(connection);
  if (clientEndpoint != null) {
    node.executorManager.executeNow(new FallThroughRunnable(){
      public void doRun(){
        clientEndpoint.connectionRemoved(connection);
        if (node.securityContext != null) {
          try {
            clientEndpoint.getLoginContext().logout();
          }
 catch (          LoginException e) {
            logger.log(Level.WARNING,e.getMessage(),e);
          }
        }
      }
    }
);
  }
}","public void connectionRemoved(final Connection connection){
  final ClientEndpoint clientEndpoint=removeClientEndpoint(connection);
  if (clientEndpoint != null) {
    node.executorManager.executeNow(new FallThroughRunnable(){
      public void doRun(){
        logger.log(Level.INFO,""String_Node_Str"" + connection + ""String_Node_Str"");
        clientEndpoint.connectionRemoved(connection);
        if (node.securityContext != null) {
          try {
            clientEndpoint.getLoginContext().logout();
          }
 catch (          LoginException e) {
            logger.log(Level.WARNING,e.getMessage(),e);
          }
        }
      }
    }
);
  }
}",0.9324654190398698
49539,"public void doLocalOp(){
  if (isMigrationAware() && isMigrating(request)) {
    setResult(OBJECT_REDO);
  }
 else {
    request.attachment=TargetAwareOp.this;
    request.local=true;
    ((RequestHandler)getPacketProcessor(request.operation)).handle(request);
  }
}","public void doLocalOp(){
  if (isMigrationAware() && isPartitionMigrating()) {
    setResult(OBJECT_REDO);
  }
 else {
    request.attachment=TargetAwareOp.this;
    request.local=true;
    ((RequestHandler)getPacketProcessor(request.operation)).handle(request);
  }
}",0.9700374531835206
49540,"protected boolean isMigrating(Request req){
  return false;
}","protected boolean isMigrating(Request req,int replica){
  return false;
}",0.9104477611940298
49541,"protected void backup(ClusterOperation operation){
  final int localBackupCount=backupCount;
  final int localAsyncBackupCount=asyncBackupCount;
  final int totalBackupCount=localBackupCount + localAsyncBackupCount;
  if (localBackupCount <= 0 && localAsyncBackupCount <= 0) {
    return;
  }
  if (totalBackupCount > MAX_BACKUP_COUNT) {
    String msg=""String_Node_Str"" + MAX_BACKUP_COUNT + ""String_Node_Str""+ totalBackupCount;
    logger.log(Level.SEVERE,msg);
    throw new RuntimeException(msg);
  }
  if (request.key == null || request.key.size() == 0) {
    throw new RuntimeException(""String_Node_Str"" + request.key);
  }
  final MBackup[] backupOps=new MBackup[localBackupCount];
  for (int i=0; i < totalBackupCount; i++) {
    int replicaIndex=i + 1;
    if (i < localBackupCount) {
      MBackup backupOp=new MBackup();
      backupOps[i]=backupOp;
      backupOp.sendBackup(operation,replicaIndex,request);
    }
 else {
      final Request reqBackup=Request.copyFromRequest(request);
      reqBackup.operation=operation;
      enqueueAndReturn(new AsyncBackupProcessable(reqBackup,replicaIndex));
    }
  }
  for (int i=0; i < localBackupCount; i++) {
    MBackup backupOp=backupOps[i];
    backupOp.getResultAsBoolean();
  }
}","protected void backup(ClusterOperation operation){
  final int localBackupCount=backupCount;
  final int localAsyncBackupCount=asyncBackupCount;
  final int totalBackupCount=localBackupCount + localAsyncBackupCount;
  if (localBackupCount <= 0 && localAsyncBackupCount <= 0) {
    return;
  }
  if (totalBackupCount > MAX_BACKUP_COUNT) {
    String msg=""String_Node_Str"" + MAX_BACKUP_COUNT + ""String_Node_Str""+ totalBackupCount;
    logger.log(Level.SEVERE,msg);
    throw new RuntimeException(msg);
  }
  if (request.key == null || request.key.size() == 0) {
    throw new RuntimeException(""String_Node_Str"" + request.key);
  }
  final MBackup[] backupOps=new MBackup[localBackupCount];
  for (int i=0; i < totalBackupCount; i++) {
    final int replicaIndex=i + 1;
    if (i < localBackupCount) {
      MBackup backupOp=new MBackup();
      backupOps[i]=backupOp;
      backupOp.sendBackup(operation,replicaIndex,request);
    }
 else {
      final Request reqBackup=Request.copyFromRequest(request);
      reqBackup.operation=operation;
      enqueueAndReturn(new AsyncBackupProcessable(reqBackup,replicaIndex));
    }
  }
  for (int i=0; i < localBackupCount; i++) {
    MBackup backupOp=backupOps[i];
    backupOp.getResultAsBoolean();
  }
}",0.997586484312148
49542,"ConcurrentMapManager(final Node node){
  super(node);
  recordFactory=node.initializer.getRecordFactory();
  storeExecutor=node.executorManager.newParallelExecutor(node.groupProperties.EXECUTOR_STORE_THREAD_COUNT.getInteger());
  evictionExecutor=node.executorManager.newParallelExecutor(node.groupProperties.EXECUTOR_STORE_THREAD_COUNT.getInteger());
  PARTITION_COUNT=node.groupProperties.CONCURRENT_MAP_PARTITION_COUNT.getInteger();
  MAX_BACKUP_COUNT=MapConfig.MAX_BACKUP_COUNT;
  int removeDelaySeconds=node.groupProperties.REMOVE_DELAY_SECONDS.getInteger();
  if (removeDelaySeconds <= 0) {
    logger.log(Level.WARNING,GroupProperties.PROP_REMOVE_DELAY_SECONDS + ""String_Node_Str"");
    removeDelaySeconds=1;
  }
  GLOBAL_REMOVE_DELAY_MILLIS=removeDelaySeconds * 1000L;
  LOG_STATE=node.groupProperties.LOG_STATE.getBoolean();
  maps=new ConcurrentHashMap<String,CMap>(10,0.75f,1);
  mapCaches=new ConcurrentHashMap<String,NearCache>(10,0.75f,1);
  partitionManager=new PartitionManager(this);
  partitionServiceImpl=new PartitionServiceImpl(this);
  node.executorManager.getScheduledExecutorService().scheduleAtFixedRate(new Runnable(){
    public void run(){
      startCleanup(true,false);
    }
  }
,1,1,TimeUnit.SECONDS);
  registerPacketProcessor(CONCURRENT_MAP_GET_MAP_ENTRY,new GetMapEntryOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_GET_DATA_RECORD_ENTRY,new GetDataRecordEntryOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_GET,new GetOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ASYNC_MERGE,new AsyncMergePacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_WAN_MERGE,new WanMergePacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_MERGE,new MergeOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_TRY_PUT,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_SET,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT_AND_UNLOCK,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT_IF_ABSENT,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REPLACE_IF_NOT_NULL,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT_TRANSIENT,new PutTransientOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REPLACE_IF_SAME,new ReplaceOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT_MULTI,new PutMultiOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE,new RemoveOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_EVICT,new EvictOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE_IF_SAME,new RemoveIfSameOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE_ITEM,new RemoveItemOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_PUT,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_PUT_AND_UNLOCK,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_ADD,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_REMOVE_MULTI,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_REMOVE,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_LOCK,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_LOCK,new LockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_TRY_LOCK_AND_GET,new LockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_UNLOCK,new UnlockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_FORCE_UNLOCK,new ForceUnlockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_LOCK_MAP,new LockMapOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_UNLOCK_MAP,new LockMapOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE_MULTI,new RemoveMultiOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ADD_TO_LIST,new AddOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ADD_TO_SET,new AddOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_CONTAINS_KEY,new ContainsKeyOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_CONTAINS_ENTRY,new ContainsEntryOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_CONTAINS_VALUE,new ContainsValueOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_VALUE_COUNT,new ValueCountOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_INVALIDATE,new InvalidateOperationHandler());
  registerPacketProcessor(ATOMIC_NUMBER_ADD_AND_GET,new AtomicNumberAddAndGetOperationHandler());
  registerPacketProcessor(ATOMIC_NUMBER_COMPARE_AND_SET,new AtomicNumberCompareAndSetOperationHandler());
  registerPacketProcessor(ATOMIC_NUMBER_GET_AND_ADD,new AtomicNumberGetAndAddOperationHandler());
  registerPacketProcessor(ATOMIC_NUMBER_GET_AND_SET,new AtomicNumberGetAndSetOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_AWAIT,new CountDownLatchAwaitOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_COUNT_DOWN,new CountDownLatchCountDownOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_DESTROY,new CountDownLatchDestroyOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_GET_COUNT,new CountDownLatchGetCountOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_GET_OWNER,new CountDownLatchGetOwnerOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_SET_COUNT,new CountDownLatchSetCountOperationHandler());
  registerPacketProcessor(SEMAPHORE_ATTACH_DETACH_PERMITS,new SemaphoreAttachDetachOperationHandler());
  registerPacketProcessor(SEMAPHORE_CANCEL_ACQUIRE,new SemaphoreCancelAcquireOperationHandler());
  registerPacketProcessor(SEMAPHORE_DESTROY,new SemaphoreDestroyOperationHandler());
  registerPacketProcessor(SEMAPHORE_DRAIN_PERMITS,new SemaphoreDrainOperationHandler());
  registerPacketProcessor(SEMAPHORE_GET_ATTACHED_PERMITS,new SemaphoreGetAttachedOperationHandler());
  registerPacketProcessor(SEMAPHORE_GET_AVAILABLE_PERMITS,new SemaphoreGetAvailableOperationHandler());
  registerPacketProcessor(SEMAPHORE_REDUCE_PERMITS,new SemaphoreReduceOperationHandler());
  registerPacketProcessor(SEMAPHORE_RELEASE,new SemaphoreReleaseOperationHandler());
  registerPacketProcessor(SEMAPHORE_TRY_ACQUIRE,new SemaphoreTryAcquireOperationHandler());
}","ConcurrentMapManager(final Node node){
  super(node);
  recordFactory=node.initializer.getRecordFactory();
  storeExecutor=node.executorManager.newParallelExecutor(node.groupProperties.EXECUTOR_STORE_THREAD_COUNT.getInteger());
  evictionExecutor=node.executorManager.newParallelExecutor(node.groupProperties.EXECUTOR_STORE_THREAD_COUNT.getInteger());
  PARTITION_COUNT=node.groupProperties.CONCURRENT_MAP_PARTITION_COUNT.getInteger();
  MAX_BACKUP_COUNT=MapConfig.MAX_BACKUP_COUNT;
  int removeDelaySeconds=node.groupProperties.REMOVE_DELAY_SECONDS.getInteger();
  if (removeDelaySeconds <= 0) {
    logger.log(Level.WARNING,GroupProperties.PROP_REMOVE_DELAY_SECONDS + ""String_Node_Str"");
    removeDelaySeconds=1;
  }
  GLOBAL_REMOVE_DELAY_MILLIS=removeDelaySeconds * 1000L;
  LOG_STATE=node.groupProperties.LOG_STATE.getBoolean();
  maps=new ConcurrentHashMap<String,CMap>(10,0.75f,1);
  mapCaches=new ConcurrentHashMap<String,NearCache>(10,0.75f,1);
  partitionManager=new PartitionManager(this);
  partitionServiceImpl=new PartitionServiceImpl(this);
  node.executorManager.getScheduledExecutorService().scheduleAtFixedRate(new Runnable(){
    public void run(){
      startCleanup(true,false);
    }
  }
,1,1,TimeUnit.SECONDS);
  registerPacketProcessor(CONCURRENT_MAP_GET_MAP_ENTRY,new GetMapEntryOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_GET_DATA_RECORD_ENTRY,new GetDataRecordEntryOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_GET,new GetOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ASYNC_MERGE,new AsyncMergePacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_WAN_MERGE,new WanMergePacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_MERGE,new MergeOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_TRY_PUT,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_SET,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT_AND_UNLOCK,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT_IF_ABSENT,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REPLACE_IF_NOT_NULL,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT_TRANSIENT,new PutTransientOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REPLACE_IF_SAME,new ReplaceOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT_MULTI,new PutMultiOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE,new RemoveOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_EVICT,new EvictOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE_IF_SAME,new RemoveIfSameOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE_ITEM,new RemoveItemOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_PUT,new BackupOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_PUT_AND_UNLOCK,new BackupOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_ADD,new BackupOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_REMOVE_MULTI,new BackupOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_REMOVE,new BackupOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_LOCK,new BackupOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_LOCK,new LockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_TRY_LOCK_AND_GET,new LockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_UNLOCK,new UnlockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_FORCE_UNLOCK,new ForceUnlockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_LOCK_MAP,new LockMapOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_UNLOCK_MAP,new LockMapOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE_MULTI,new RemoveMultiOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ADD_TO_LIST,new AddOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ADD_TO_SET,new AddOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_CONTAINS_KEY,new ContainsKeyOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_CONTAINS_ENTRY,new ContainsEntryOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_CONTAINS_VALUE,new ContainsValueOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_VALUE_COUNT,new ValueCountOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_INVALIDATE,new InvalidateOperationHandler());
  registerPacketProcessor(ATOMIC_NUMBER_ADD_AND_GET,new AtomicNumberAddAndGetOperationHandler());
  registerPacketProcessor(ATOMIC_NUMBER_COMPARE_AND_SET,new AtomicNumberCompareAndSetOperationHandler());
  registerPacketProcessor(ATOMIC_NUMBER_GET_AND_ADD,new AtomicNumberGetAndAddOperationHandler());
  registerPacketProcessor(ATOMIC_NUMBER_GET_AND_SET,new AtomicNumberGetAndSetOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_AWAIT,new CountDownLatchAwaitOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_COUNT_DOWN,new CountDownLatchCountDownOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_DESTROY,new CountDownLatchDestroyOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_GET_COUNT,new CountDownLatchGetCountOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_GET_OWNER,new CountDownLatchGetOwnerOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_SET_COUNT,new CountDownLatchSetCountOperationHandler());
  registerPacketProcessor(SEMAPHORE_ATTACH_DETACH_PERMITS,new SemaphoreAttachDetachOperationHandler());
  registerPacketProcessor(SEMAPHORE_CANCEL_ACQUIRE,new SemaphoreCancelAcquireOperationHandler());
  registerPacketProcessor(SEMAPHORE_DESTROY,new SemaphoreDestroyOperationHandler());
  registerPacketProcessor(SEMAPHORE_DRAIN_PERMITS,new SemaphoreDrainOperationHandler());
  registerPacketProcessor(SEMAPHORE_GET_ATTACHED_PERMITS,new SemaphoreGetAttachedOperationHandler());
  registerPacketProcessor(SEMAPHORE_GET_AVAILABLE_PERMITS,new SemaphoreGetAvailableOperationHandler());
  registerPacketProcessor(SEMAPHORE_REDUCE_PERMITS,new SemaphoreReduceOperationHandler());
  registerPacketProcessor(SEMAPHORE_RELEASE,new SemaphoreReleaseOperationHandler());
  registerPacketProcessor(SEMAPHORE_TRY_ACQUIRE,new SemaphoreTryAcquireOperationHandler());
}",0.9863956215793588
49543,"public void sendBackup(ClusterOperation operation,int replicaIndex,Request reqBackup){
  reset();
  this.replicaIndex=replicaIndex;
  SystemLogService css=node.getSystemLogService();
  if (css.shouldLog(CS_TRACE)) {
    css.trace(this,""String_Node_Str"",callId);
  }
  request.setFromRequest(reqBackup);
  request.operation=operation;
  request.caller=thisAddress;
  request.setBooleanRequest();
  doOp();
}","public void sendBackup(ClusterOperation operation,int replicaIndex,Request reqBackup){
  reset();
  this.replicaIndex=replicaIndex;
  SystemLogService css=node.getSystemLogService();
  if (css.shouldLog(CS_TRACE)) {
    css.trace(this,""String_Node_Str"",callId);
  }
  request.setFromRequest(reqBackup);
  request.operation=operation;
  request.caller=thisAddress;
  request.longValue=replicaIndex;
  request.setBooleanRequest();
  doOp();
}",0.9598108747044918
49544,"@Override public boolean isMigrating(Request req){
  final Data key=req.key;
  if (key == null)   return false;
  return partitionManager.isOwnedPartitionMigrating(getPartitionId(req));
}","@Override public boolean isMigrating(Request req,int replica){
  final Data key=req.key;
  return key != null && partitionManager.isPartitionMigrating(getPartitionId(req),replica);
}",0.8130081300813008
49545,"public void doJoin(AtomicBoolean joined){
  int tryCount=0;
  long joinStartTime=Clock.currentTimeMillis();
  long maxJoinMillis=node.getGroupProperties().MAX_JOIN_SECONDS.getInteger() * 1000;
  while (node.isActive() && !joined.get() && (Clock.currentTimeMillis() - joinStartTime < maxJoinMillis)) {
    String msg=""String_Node_Str"" + node.getMasterAddress();
    logger.log(Level.FINEST,msg);
    systemLogService.logJoin(msg);
    Address masterAddressNow=findMasterWithMulticast();
    node.setMasterAddress(masterAddressNow);
    systemLogService.logJoin(""String_Node_Str"" + masterAddressNow);
    if (node.getMasterAddress() == null || node.address.equals(node.getMasterAddress())) {
      TcpIpConfig tcpIpConfig=config.getNetworkConfig().getJoin().getTcpIpConfig();
      if (tcpIpConfig != null && tcpIpConfig.isEnabled()) {
        doTCP(joined);
      }
 else {
        systemLogService.logJoin(""String_Node_Str"");
        node.setAsMaster();
      }
      return;
    }
    if (++tryCount > 24) {
      failedJoiningToMaster(true,tryCount);
    }
    if (!node.getMasterAddress().equals(node.address)) {
      connectAndSendJoinRequest(node.getMasterAddress());
    }
 else {
      node.setMasterAddress(null);
      tryCount=0;
    }
    try {
      Thread.sleep(500L);
    }
 catch (    InterruptedException ignored) {
    }
  }
}","public void doJoin(AtomicBoolean joined){
  int tryCount=0;
  long joinStartTime=Clock.currentTimeMillis();
  long maxJoinMillis=node.getGroupProperties().MAX_JOIN_SECONDS.getInteger() * 1000;
  while (node.isActive() && !joined.get() && (Clock.currentTimeMillis() - joinStartTime < maxJoinMillis)) {
    String msg=""String_Node_Str"" + node.getMasterAddress();
    logger.log(Level.FINEST,msg);
    systemLogService.logJoin(msg);
    Address masterAddressNow=findMasterWithMulticast();
    node.setMasterAddress(masterAddressNow);
    systemLogService.logJoin(""String_Node_Str"" + masterAddressNow);
    if (node.getMasterAddress() == null || node.address.equals(node.getMasterAddress())) {
      TcpIpConfig tcpIpConfig=config.getNetworkConfig().getJoin().getTcpIpConfig();
      if (tcpIpConfig != null && tcpIpConfig.isEnabled()) {
        doTCP(joined);
      }
 else {
        systemLogService.logJoin(""String_Node_Str"");
        node.setAsMaster();
      }
      return;
    }
    if (++tryCount > 49) {
      failedJoiningToMaster(true,tryCount);
    }
    if (!node.getMasterAddress().equals(node.address)) {
      connectAndSendJoinRequest(node.getMasterAddress());
    }
 else {
      node.setMasterAddress(null);
      tryCount=0;
    }
    try {
      Thread.sleep(500L);
    }
 catch (    InterruptedException ignored) {
    }
  }
}",0.9992559523809524
49546,"/** 
 * @param partitionId
 * @return true if owned replica (0) of partition is migrating, false otherwise
 */
public boolean isOwnedPartitionMigrating(int partitionId){
  final MigratingPartition currentMigratingPartition=migratingPartition;
  return currentMigratingPartition != null && currentMigratingPartition.getPartitionId() == partitionId && currentMigratingPartition.getReplicaIndex() == 0;
}","/** 
 * @param partitionId
 * @return true if owned replica (0) of partition is migrating, false otherwise
 */
public boolean isOwnedPartitionMigrating(int partitionId){
  return isPartitionMigrating(partitionId,0);
}",0.5954692556634305
49547,"/** 
 * @param partitionId
 * @return true if any replica of partition is migrating, false otherwise
 */
public boolean isPartitionMigrating(int partitionId){
  final MigratingPartition currentMigratingPartition=migratingPartition;
  return currentMigratingPartition != null && currentMigratingPartition.getPartitionId() == partitionId;
}","/** 
 * @param partitionId
 * @param replicaIndex
 * @return true if replicaIndex of partition is migrating, false otherwise
 */
public boolean isPartitionMigrating(int partitionId,int replicaIndex){
  final MigratingPartition currentMigratingPartition=migratingPartition;
  return currentMigratingPartition != null && currentMigratingPartition.getPartitionId() == partitionId && currentMigratingPartition.getReplicaIndex() == replicaIndex;
}",0.8384615384615385
49548,"@Override public String toString(){
  return ""String_Node_Str"" + ""String_Node_Str"" + name + '\''+ ""String_Node_Str""+ operation+ ""String_Node_Str""+ redoCount+ '\''+ ""String_Node_Str""+ callId+ '\''+ ""String_Node_Str""+ lockThreadId+ '\''+ '}';
}","@Override public String toString(){
  return ""String_Node_Str"" + ""String_Node_Str"" + name + '\''+ ""String_Node_Str""+ operation+ ""String_Node_Str""+ redoCount+ '\''+ ""String_Node_Str""+ callId+ '\''+ ""String_Node_Str""+ lockThreadId+ '\''+ ""String_Node_Str""+ target+ '\''+ ""String_Node_Str""+ local+ '\''+ '}';
}",0.8816029143897997
49549,"/** 
 * Fix for the issue 275.
 * @throws Exception
 */
@Test(timeout=60000) public void testDataRecovery2() throws Exception {
  final int size=1000;
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(new Config());
  IMap map1=h1.getMap(""String_Node_Str"");
  for (int i=0; i < size; i++) {
    map1.put(i,""String_Node_Str"" + i);
  }
  assertEquals(size,map1.size());
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(new Config());
  sleep(3000);
  IMap map2=h2.getMap(""String_Node_Str"");
  assertEquals(size,map1.size());
  assertEquals(size,map2.size());
  assertEquals(size,getTotalOwnedEntryCount(map1,map2));
  assertEquals(size,getTotalBackupEntryCount(map1,map2));
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(new Config());
  IMap map3=h3.getMap(""String_Node_Str"");
  sleep(3000);
  assertEquals(size,map1.size());
  assertEquals(size,map2.size());
  assertEquals(size,map3.size());
  assertEquals(size,getTotalOwnedEntryCount(map1,map2,map3));
  assertEquals(size,getTotalBackupEntryCount(map1,map2,map3));
  MemberImpl member2=(MemberImpl)h2.getCluster().getLocalMember();
  h2.getLifecycleService().shutdown();
  sleep(3000);
  assertEquals(size,map1.size());
  assertEquals(size,map3.size());
  assertEquals(size,getTotalOwnedEntryCount(map1,map3));
  assertEquals(size,getTotalBackupEntryCount(map1,map3));
  MemberImpl member1=(MemberImpl)h1.getCluster().getLocalMember();
  h1.getLifecycleService().shutdown();
  assertEquals(size,map3.size());
  ConcurrentMapManager c3=getConcurrentMapManager(h3);
  MemberImpl member3=(MemberImpl)h3.getCluster().getLocalMember();
  for (int i=0; i < 271; i++) {
    PartitionInfo p=c3.getPartitionInfo(i);
    assertTrue(p.toString(),member3.getAddress().equals(p.getOwner()));
    assertFalse(p.toString(),p.isOwnerOrBackup(member1.getAddress(),PartitionInfo.MAX_REPLICA_COUNT));
    assertFalse(p.toString(),p.isOwnerOrBackup(member2.getAddress(),PartitionInfo.MAX_REPLICA_COUNT));
  }
}","/** 
 * Fix for the issue 275.
 * @throws Exception
 */
@Test(timeout=60000) public void testDataRecovery2() throws Exception {
  final int size=1000;
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(new Config());
  IMap map1=h1.getMap(""String_Node_Str"");
  for (int i=0; i < size; i++) {
    map1.put(i,""String_Node_Str"" + i);
  }
  assertEquals(size,map1.size());
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(new Config());
  sleep(3000);
  IMap map2=h2.getMap(""String_Node_Str"");
  assertEquals(size,map1.size());
  assertEquals(size,map2.size());
  assertEquals(size,getTotalOwnedEntryCount(map1,map2));
  assertEquals(size,getTotalBackupEntryCount(map1,map2));
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(new Config());
  IMap map3=h3.getMap(""String_Node_Str"");
  sleep(3000);
  assertEquals(size,map1.size());
  assertEquals(size,map2.size());
  assertEquals(size,map3.size());
  assertEquals(size,getTotalOwnedEntryCount(map1,map2,map3));
  assertEquals(size,getTotalBackupEntryCount(map1,map2,map3));
  MemberImpl member2=(MemberImpl)h2.getCluster().getLocalMember();
  h2.getLifecycleService().shutdown();
  sleep(5000);
  assertEquals(size,map1.size());
  assertEquals(size,map3.size());
  assertEquals(size,getTotalOwnedEntryCount(map1,map3));
  assertEquals(size,getTotalBackupEntryCount(map1,map3));
  MemberImpl member1=(MemberImpl)h1.getCluster().getLocalMember();
  h1.getLifecycleService().shutdown();
  assertEquals(size,map3.size());
  ConcurrentMapManager c3=getConcurrentMapManager(h3);
  MemberImpl member3=(MemberImpl)h3.getCluster().getLocalMember();
  for (int i=0; i < 271; i++) {
    PartitionInfo p=c3.getPartitionInfo(i);
    assertTrue(p.toString(),member3.getAddress().equals(p.getOwner()));
    assertFalse(p.toString(),p.isOwnerOrBackup(member1.getAddress(),PartitionInfo.MAX_REPLICA_COUNT));
    assertFalse(p.toString(),p.isOwnerOrBackup(member2.getAddress(),PartitionInfo.MAX_REPLICA_COUNT));
  }
}",0.9994895354772844
49550,"@Test public void issue395BackupProblemWithBCount2() throws InterruptedException {
  final int size=1000;
  Config config=new Config();
  config.getProperties().put(GroupProperties.PROP_PARTITION_MIGRATION_INTERVAL,""String_Node_Str"");
  config.getMapConfig(""String_Node_Str"").setBackupCount(2);
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(config);
  IMap map1=h1.getMap(""String_Node_Str"");
  IMap map2=h2.getMap(""String_Node_Str"");
  for (int i=0; i < size; i++) {
    map1.put(i,i);
  }
  assertEquals(size,getTotalOwnedEntryCount(map1,map2));
  assertEquals(size,getTotalBackupEntryCount(map1,map2));
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(config);
  IMap map3=h3.getMap(""String_Node_Str"");
  Thread.sleep(1000 * 2);
  assertEquals(size,getTotalOwnedEntryCount(map1,map2,map3));
  assertEquals(2 * size,getTotalBackupEntryCount(map1,map2,map3));
}","@Test public void issue395BackupProblemWithBCount2() throws InterruptedException {
  final int size=1000;
  Config config=new Config();
  config.setProperty(GroupProperties.PROP_PARTITION_MIGRATION_INTERVAL,""String_Node_Str"");
  config.getMapConfig(""String_Node_Str"").setBackupCount(2);
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(config);
  IMap map1=h1.getMap(""String_Node_Str"");
  IMap map2=h2.getMap(""String_Node_Str"");
  for (int i=0; i < size; i++) {
    map1.put(i,i);
  }
  assertEquals(size,getTotalOwnedEntryCount(map1,map2));
  assertEquals(size,getTotalBackupEntryCount(map1,map2));
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(config);
  IMap map3=h3.getMap(""String_Node_Str"");
  Thread.sleep(1000 * 3);
  assertEquals(size,getTotalOwnedEntryCount(map1,map2,map3));
  assertEquals(2 * size,getTotalBackupEntryCount(map1,map2,map3));
}",0.992497320471597
49551,"private void executeStoreUpdate(final Set<Record> dirtyRecords){
  if (dirtyRecords.size() > 0) {
    concurrentMapManager.storeExecutor.execute(new Runnable(){
      public void run(){
        try {
          Set<Object> keysToDelete=new HashSet<Object>();
          Set<Record> toStore=new HashSet<Record>();
          Map<Object,Object> updates=new HashMap<Object,Object>();
          for (          Record dirtyRecord : dirtyRecords) {
            if (!dirtyRecord.isActive()) {
              keysToDelete.add(dirtyRecord.getKey());
            }
 else {
              toStore.add(dirtyRecord);
              updates.put(dirtyRecord.getKey(),dirtyRecord.getValue());
            }
          }
          if (keysToDelete.size() == 1) {
            store.delete(keysToDelete.iterator().next());
          }
 else           if (keysToDelete.size() > 1) {
            store.deleteAll(keysToDelete);
          }
          if (updates.size() == 1) {
            Map.Entry entry=updates.entrySet().iterator().next();
            store.store(entry.getKey(),entry.getValue());
          }
 else           if (updates.size() > 1) {
            store.storeAll(updates);
          }
          for (          Record stored : toStore) {
            stored.setLastStoredTime(Clock.currentTimeMillis());
          }
        }
 catch (        Exception e) {
          for (          Record dirtyRecord : dirtyRecords) {
            dirtyRecord.setDirty(true);
          }
        }
      }
    }
);
  }
}","private void executeStoreUpdate(final Set<Record> dirtyRecords){
  if (dirtyRecords.size() > 0) {
    concurrentMapManager.storeExecutor.execute(new Runnable(){
      public void run(){
        runStoreUpdate(dirtyRecords);
      }
    }
);
  }
}",0.2406447898675878
49552,"public void run(){
  try {
    Set<Object> keysToDelete=new HashSet<Object>();
    Set<Record> toStore=new HashSet<Record>();
    Map<Object,Object> updates=new HashMap<Object,Object>();
    for (    Record dirtyRecord : dirtyRecords) {
      if (!dirtyRecord.isActive()) {
        keysToDelete.add(dirtyRecord.getKey());
      }
 else {
        toStore.add(dirtyRecord);
        updates.put(dirtyRecord.getKey(),dirtyRecord.getValue());
      }
    }
    if (keysToDelete.size() == 1) {
      store.delete(keysToDelete.iterator().next());
    }
 else     if (keysToDelete.size() > 1) {
      store.deleteAll(keysToDelete);
    }
    if (updates.size() == 1) {
      Map.Entry entry=updates.entrySet().iterator().next();
      store.store(entry.getKey(),entry.getValue());
    }
 else     if (updates.size() > 1) {
      store.storeAll(updates);
    }
    for (    Record stored : toStore) {
      stored.setLastStoredTime(Clock.currentTimeMillis());
    }
  }
 catch (  Exception e) {
    for (    Record dirtyRecord : dirtyRecords) {
      dirtyRecord.setDirty(true);
    }
  }
}","public void run(){
  runStoreUpdate(dirtyRecords);
}",0.088261253309797
49553,"public void flush(String name){
  CMap cmap=getMap(name);
  if (cmap != null && cmap.store != null && cmap.writeDelayMillis > 0) {
    Map mapDirtyEntries=new HashMap();
    for (    Record record : cmap.mapRecords.values()) {
      if (record.isDirty()) {
        Object key=record.getKey();
        Object value=record.getValue();
        if (key != null && value != null) {
          mapDirtyEntries.put(key,value);
        }
      }
    }
    if (mapDirtyEntries.size() > 0) {
      cmap.store.storeAll(mapDirtyEntries);
    }
  }
}","public void flush(String name){
  CMap cmap=getMap(name);
  if (cmap != null && cmap.store != null && cmap.writeDelayMillis > 0) {
    final Set<Record> dirtyRecords=new HashSet<Record>();
    for (    Record record : cmap.mapRecords.values()) {
      if (record.isDirty()) {
        PartitionInfo partition=partitionManager.getPartition(record.getBlockId());
        Address owner=partition.getOwner();
        if (owner != null && thisAddress.equals(owner)) {
          dirtyRecords.add(record);
          record.setDirty(false);
        }
      }
    }
    cmap.runStoreUpdate(dirtyRecords);
  }
}",0.329225352112676
49554,"@Test public void testOneMemberFlush() throws Exception {
  TestMapStore testMapStore=new TestMapStore(1,1,1);
  testMapStore.setLoadAllKeys(false);
  Config config=newConfig(testMapStore,200);
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  IMap map=h1.getMap(""String_Node_Str"");
  assertEquals(0,map.size());
  for (int i=0; i < 100; i++) {
    map.put(i,i);
  }
  assertEquals(100,map.size());
  assertEquals(0,testMapStore.getStore().size());
  getConcurrentMapManager(h1).flush(Prefix.MAP + ""String_Node_Str"");
  assertEquals(100,testMapStore.getStore().size());
  assertEquals(100,map.size());
}","@Test public void testOneMemberFlush() throws Exception {
  TestMapStore testMapStore=new TestMapStore(1,1,1);
  testMapStore.setLoadAllKeys(false);
  Config config=newConfig(testMapStore,200);
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  IMap map=h1.getMap(""String_Node_Str"");
  assertEquals(0,map.size());
  for (int i=0; i < 100; i++) {
    map.put(i,i);
  }
  assertEquals(100,map.size());
  assertEquals(0,testMapStore.getStore().size());
  assertEquals(100,map.getLocalMapStats().getDirtyEntryCount());
  getConcurrentMapManager(h1).flush(Prefix.MAP + ""String_Node_Str"");
  assertEquals(100,testMapStore.getStore().size());
  assertEquals(0,map.getLocalMapStats().getDirtyEntryCount());
  assertEquals(100,map.size());
  for (int i=0; i < 50; i++) {
    map.remove(i);
  }
  assertEquals(50,map.size());
  assertEquals(100,testMapStore.getStore().size());
  getConcurrentMapManager(h1).flush(Prefix.MAP + ""String_Node_Str"");
  assertEquals(50,testMapStore.getStore().size());
  assertEquals(50,map.size());
}",0.7276029055690073
49555,"private void executeStoreUpdate(final Set<Record> dirtyRecords){
  if (dirtyRecords.size() > 0) {
    concurrentMapManager.storeExecutor.execute(new Runnable(){
      public void run(){
        try {
          Set<Object> keysToDelete=new HashSet<Object>();
          Set<Record> toStore=new HashSet<Record>();
          Map<Object,Object> updates=new HashMap<Object,Object>();
          for (          Record dirtyRecord : dirtyRecords) {
            if (!dirtyRecord.isActive()) {
              keysToDelete.add(dirtyRecord.getKey());
            }
 else {
              toStore.add(dirtyRecord);
              updates.put(dirtyRecord.getKey(),dirtyRecord.getValue());
            }
          }
          if (keysToDelete.size() == 1) {
            store.delete(keysToDelete.iterator().next());
          }
 else           if (keysToDelete.size() > 1) {
            store.deleteAll(keysToDelete);
          }
          if (updates.size() == 1) {
            Map.Entry entry=updates.entrySet().iterator().next();
            store.store(entry.getKey(),entry.getValue());
          }
 else           if (updates.size() > 1) {
            store.storeAll(updates);
          }
          for (          Record stored : toStore) {
            stored.setLastStoredTime(Clock.currentTimeMillis());
          }
        }
 catch (        Exception e) {
          for (          Record dirtyRecord : dirtyRecords) {
            dirtyRecord.setDirty(true);
          }
        }
      }
    }
);
  }
}","private void executeStoreUpdate(final Set<Record> dirtyRecords){
  if (dirtyRecords.size() > 0) {
    concurrentMapManager.storeExecutor.execute(new Runnable(){
      public void run(){
        runStoreUpdate(dirtyRecords);
      }
    }
);
  }
}",0.2406447898675878
49556,"public void run(){
  try {
    Set<Object> keysToDelete=new HashSet<Object>();
    Set<Record> toStore=new HashSet<Record>();
    Map<Object,Object> updates=new HashMap<Object,Object>();
    for (    Record dirtyRecord : dirtyRecords) {
      if (!dirtyRecord.isActive()) {
        keysToDelete.add(dirtyRecord.getKey());
      }
 else {
        toStore.add(dirtyRecord);
        updates.put(dirtyRecord.getKey(),dirtyRecord.getValue());
      }
    }
    if (keysToDelete.size() == 1) {
      store.delete(keysToDelete.iterator().next());
    }
 else     if (keysToDelete.size() > 1) {
      store.deleteAll(keysToDelete);
    }
    if (updates.size() == 1) {
      Map.Entry entry=updates.entrySet().iterator().next();
      store.store(entry.getKey(),entry.getValue());
    }
 else     if (updates.size() > 1) {
      store.storeAll(updates);
    }
    for (    Record stored : toStore) {
      stored.setLastStoredTime(Clock.currentTimeMillis());
    }
  }
 catch (  Exception e) {
    for (    Record dirtyRecord : dirtyRecords) {
      dirtyRecord.setDirty(true);
    }
  }
}","public void run(){
  runStoreUpdate(dirtyRecords);
}",0.088261253309797
49557,"public void flush(String name){
  CMap cmap=getMap(name);
  if (cmap != null && cmap.store != null && cmap.writeDelayMillis > 0) {
    Map mapDirtyEntries=new HashMap();
    Set<Record> toStore=new HashSet<Record>();
    for (    Record record : cmap.mapRecords.values()) {
      if (record.isDirty()) {
        Object key=record.getKey();
        Object value=record.getValue();
        if (key != null && value != null) {
          mapDirtyEntries.put(key,value);
          toStore.add(record);
        }
      }
    }
    if (mapDirtyEntries.size() > 0) {
      cmap.store.storeAll(mapDirtyEntries);
      for (      Record stored : toStore) {
        stored.setDirty(false);
        stored.setLastStoredTime(Clock.currentTimeMillis());
      }
    }
  }
}","public void flush(String name){
  CMap cmap=getMap(name);
  if (cmap != null && cmap.store != null && cmap.writeDelayMillis > 0) {
    final Set<Record> dirtyRecords=new HashSet<Record>();
    for (    Record record : cmap.mapRecords.values()) {
      if (record.isDirty()) {
        PartitionInfo partition=partitionManager.getPartition(record.getBlockId());
        Address owner=partition.getOwner();
        if (owner != null && thisAddress.equals(owner)) {
          dirtyRecords.add(record);
          record.setDirty(false);
        }
      }
    }
    cmap.runStoreUpdate(dirtyRecords);
  }
}",0.47093451066961
49558,"@Test public void testOneMemberFlush() throws Exception {
  TestMapStore testMapStore=new TestMapStore(1,1,1);
  testMapStore.setLoadAllKeys(false);
  Config config=newConfig(testMapStore,200);
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  IMap map=h1.getMap(""String_Node_Str"");
  assertEquals(0,map.size());
  for (int i=0; i < 100; i++) {
    map.put(i,i);
  }
  assertEquals(100,map.size());
  assertEquals(0,testMapStore.getStore().size());
  assertEquals(100,map.getLocalMapStats().getDirtyEntryCount());
  getConcurrentMapManager(h1).flush(Prefix.MAP + ""String_Node_Str"");
  assertEquals(100,testMapStore.getStore().size());
  assertEquals(0,map.getLocalMapStats().getDirtyEntryCount());
  assertEquals(100,map.size());
}","@Test public void testOneMemberFlush() throws Exception {
  TestMapStore testMapStore=new TestMapStore(1,1,1);
  testMapStore.setLoadAllKeys(false);
  Config config=newConfig(testMapStore,200);
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  IMap map=h1.getMap(""String_Node_Str"");
  assertEquals(0,map.size());
  for (int i=0; i < 100; i++) {
    map.put(i,i);
  }
  assertEquals(100,map.size());
  assertEquals(0,testMapStore.getStore().size());
  assertEquals(100,map.getLocalMapStats().getDirtyEntryCount());
  getConcurrentMapManager(h1).flush(Prefix.MAP + ""String_Node_Str"");
  assertEquals(100,testMapStore.getStore().size());
  assertEquals(0,map.getLocalMapStats().getDirtyEntryCount());
  assertEquals(100,map.size());
  for (int i=0; i < 50; i++) {
    map.remove(i);
  }
  assertEquals(50,map.size());
  assertEquals(100,testMapStore.getStore().size());
  getConcurrentMapManager(h1).flush(Prefix.MAP + ""String_Node_Str"");
  assertEquals(50,testMapStore.getStore().size());
  assertEquals(50,map.size());
}",0.8382022471910112
49559,"public Member getTarget(HazelcastInstance hazelcastInstance){
  Object[] memberObjects=hazelcastInstance.getCluster().getMembers().toArray();
  return (MemberImpl)memberObjects[((int)(count++ % memberObjects.length))];
}","public Member getTarget(HazelcastInstance hazelcastInstance){
  Object[] memberObjects=hazelcastInstance.getCluster().getMembers().toArray();
  return (MemberImpl)memberObjects[((int)(Math.abs(count.incrementAndGet()) % memberObjects.length))];
}",0.9356223175965666
49560,"public Member getTarget(HazelcastInstance hazelcastInstance){
  Object[] memberObjects=hazelcastInstance.getCluster().getMembers().toArray();
  return (MemberImpl)memberObjects[((int)(count++ % memberObjects.length))];
}","public Member getTarget(HazelcastInstance hazelcastInstance){
  Object[] memberObjects=hazelcastInstance.getCluster().getMembers().toArray();
  return (MemberImpl)memberObjects[((int)(Math.abs(count.incrementAndGet()) % memberObjects.length))];
}",0.9356223175965666
49561,"public static void kill(HazelcastInstanceProxy hazelcastInstanceProxy){
  FactoryImpl factory=hazelcastInstanceProxy.getFactory();
  factory.managementService.unregister();
  factories.remove(factory.getName());
  if (factories.size() == 0) {
    shutdownManagementService();
  }
  factory.proxies.clear();
  for (  ExecutorService esp : factory.executorServiceProxies.values()) {
    esp.shutdown();
  }
  factory.node.shutdown(true,true);
}","public static void kill(FactoryImpl factory){
  factory.managementService.unregister();
  factories.remove(factory.getName());
  if (factories.size() == 0) {
    shutdownManagementService();
  }
  factory.proxies.clear();
  for (  ExecutorService esp : factory.executorServiceProxies.values()) {
    esp.shutdown();
  }
  factory.node.shutdown(true,true);
}",0.851063829787234
49562,"public void kill(){
synchronized (lifecycleLock) {
    fireLifecycleEvent(SHUTTING_DOWN);
    FactoryImpl.kill(factory.getHazelcastInstanceProxy());
    fireLifecycleEvent(SHUTDOWN);
  }
}","public void kill(){
synchronized (lifecycleLock) {
    fireLifecycleEvent(SHUTTING_DOWN);
    FactoryImpl.kill(factory);
    fireLifecycleEvent(SHUTDOWN);
  }
}",0.9195402298850576
49563,"public void shutdown(){
synchronized (lifecycleLock) {
    fireLifecycleEvent(SHUTTING_DOWN);
    FactoryImpl.shutdown(factory.getHazelcastInstanceProxy());
    fireLifecycleEvent(SHUTDOWN);
  }
}","public void shutdown(){
synchronized (lifecycleLock) {
    fireLifecycleEvent(SHUTTING_DOWN);
    FactoryImpl.shutdown(factory);
    fireLifecycleEvent(SHUTDOWN);
  }
}",0.9230769230769232
49564,"/** 
 * Unregister a cluster instance.
 */
public void unregister(){
synchronized (LOCK) {
    if (!started) {
      return;
    }
    MBeanServer mbs=mBeanServer();
    Set<ObjectName> entries;
    try {
      entries=mbs.queryNames(ObjectNameSpec.getClusterNameFilter(this.name),null);
      for (      ObjectName name : entries) {
        if (mbs.isRegistered(name)) {
          mbs.unregisterMBean(name);
        }
      }
    }
 catch (    Exception e) {
      logger.log(Level.FINEST,""String_Node_Str"",e);
    }
    counter.decrementAndGet();
  }
}","/** 
 * Unregister a cluster instance.
 */
public void unregister(){
  if (!enabled) {
    return;
  }
  if (started.compareAndSet(true,false)) {
    MBeanServer mbs=mBeanServer();
    try {
      Set<ObjectName> entries=mbs.queryNames(new ObjectName(ObjectNameSpec.NAME_DOMAIN + ""String_Node_Str"" + name+ ""String_Node_Str""),null);
      for (      ObjectName name : entries) {
        if (mbs.isRegistered(name)) {
          mbs.unregisterMBean(name);
        }
      }
    }
 catch (    Exception e) {
      logger.log(Level.FINEST,""String_Node_Str"",e);
    }
  }
}",0.7332738626226584
49565,"/** 
 * Create a new collector or return null if statistics are not enabled
 * @return statisticsCollector
 */
@SuppressWarnings(""String_Node_Str"") public static StatisticsCollector newStatisticsCollector(){
synchronized (LOCK) {
    if (statCollectors != null) {
      long interval=1L;
      ScheduledCollector collector=new ScheduledCollector(interval);
      ScheduledFuture future=statCollectors.scheduleWithFixedDelay(collector,interval,interval,TimeUnit.SECONDS);
      collector.setScheduledFuture(future);
      return collector;
    }
 else {
      return null;
    }
  }
}","/** 
 * Create a new collector or return null if statistics are not enabled
 * @return statisticsCollector
 */
@SuppressWarnings(""String_Node_Str"") public static StatisticsCollector newStatisticsCollector(){
  final ScheduledExecutorService scheduledExecutor=statCollectorExecutor;
  if (scheduledExecutor != null) {
    long interval=1L;
    ScheduledCollector collector=new ScheduledCollector(interval);
    ScheduledFuture future=scheduledExecutor.scheduleWithFixedDelay(collector,interval,interval,TimeUnit.SECONDS);
    collector.setScheduledFuture(future);
    return collector;
  }
 else {
    return null;
  }
}",0.8452579034941764
49566,"public ManagementService(FactoryImpl instance){
  this.instance=instance;
  this.logger=instance.node.getLogger(ManagementService.class.getName());
  this.showDetails=instance.node.groupProperties.ENABLE_JMX_DETAILED.getBoolean();
}","public ManagementService(FactoryImpl instance){
  this.instance=instance;
  this.name=instance.getName();
  this.logger=instance.node.getLogger(ManagementService.class.getName());
  this.enabled=instance.node.groupProperties.ENABLE_JMX.getBoolean();
  this.showDetails=instance.node.groupProperties.ENABLE_JMX_DETAILED.getBoolean();
}",0.8197879858657244
49567,"/** 
 * Stop the management service
 */
public static void shutdown(){
synchronized (LOCK) {
    if (counter.get() > 0) {
      return;
    }
    MBeanServer mbs=mBeanServer();
    Set<ObjectName> entries;
    try {
      entries=mbs.queryNames(new ObjectName(ObjectNameSpec.NAME_DOMAIN + ""String_Node_Str""),null);
      for (      ObjectName name : entries) {
        if (mbs.isRegistered(name)) {
          mbs.unregisterMBean(name);
        }
      }
    }
 catch (    Exception e) {
      Logger.getLogger(""String_Node_Str"").log(Level.FINEST,""String_Node_Str"",e);
    }
    if (statCollectors != null) {
      statCollectors.shutdownNow();
      statCollectors=null;
    }
  }
}","/** 
 * Stop the management service
 */
public synchronized static void shutdown(){
  MBeanServer mbs=mBeanServer();
  try {
    Set<ObjectName> entries=mbs.queryNames(new ObjectName(ObjectNameSpec.NAME_DOMAIN + ""String_Node_Str""),null);
    for (    ObjectName name : entries) {
      if (mbs.isRegistered(name)) {
        mbs.unregisterMBean(name);
      }
    }
  }
 catch (  Exception e) {
    Logger.getLogger(""String_Node_Str"").log(Level.FINEST,""String_Node_Str"",e);
  }
  stopStatsCollector();
}",0.7972972972972973
49568,"/** 
 * Register all the MBeans.
 */
public void register(){
synchronized (LOCK) {
    if (!started) {
      start();
    }
    if (!started) {
      return;
    }
    MBeanServer mbs=mBeanServer();
    try {
      nameLookup();
      ClusterMBean clusterMBean=new ClusterMBean(this,this.name);
      mbs.registerMBean(clusterMBean,clusterMBean.getObjectName());
      DataMBean dataMBean=new DataMBean(this);
      dataMBean.setParentName(clusterMBean.getRootName());
      mbs.registerMBean(dataMBean,dataMBean.getObjectName());
    }
 catch (    Exception e) {
      logger.log(Level.WARNING,""String_Node_Str"",e);
      return;
    }
    counter.incrementAndGet();
  }
}","/** 
 * Register all the MBeans.
 */
public void register(){
  if (!enabled) {
    return;
  }
  if (started.compareAndSet(false,true)) {
    logger.log(Level.INFO,""String_Node_Str"");
    if (showDetails()) {
      startStatsCollector();
    }
    MBeanServer mbs=mBeanServer();
    try {
      ClusterMBean clusterMBean=new ClusterMBean(this,this.name);
      mbs.registerMBean(clusterMBean,clusterMBean.getObjectName());
      DataMBean dataMBean=new DataMBean(this);
      dataMBean.setParentName(clusterMBean.getRootName());
      mbs.registerMBean(dataMBean,dataMBean.getObjectName());
    }
 catch (    Exception e) {
      logger.log(Level.WARNING,""String_Node_Str"",e);
    }
  }
}",0.6818515797207936
49569,"/** 
 * Builde the name, overwriting the defaults
 */
public ObjectName buildObjectName(String type,String name) throws Exception {
  StringBuffer sb=new StringBuffer(NAME_DOMAIN);
  if (type != null) {
    sb.append(""String_Node_Str"").append(clean(type));
  }
  if (name != null) {
    if (type != null || cluster != null) {
      sb.append(',');
    }
    sb.append(""String_Node_Str"").append(clean(name));
  }
  return new ObjectName(sb.toString());
}","/** 
 * Builde the name, overwriting the defaults
 */
public ObjectName buildObjectName(String type,String name) throws Exception {
  StringBuilder sb=new StringBuilder(NAME_DOMAIN);
  if (type != null) {
    sb.append(""String_Node_Str"").append(clean(type));
  }
  if (name != null) {
    if (type != null || cluster != null) {
      sb.append(',');
    }
    sb.append(""String_Node_Str"").append(clean(name));
  }
  return new ObjectName(sb.toString());
}",0.9889867841409692
49570,"public static void kill(HazelcastInstanceProxy hazelcastInstanceProxy){
  FactoryImpl factory=hazelcastInstanceProxy.getFactory();
  factory.managementService.unregister();
  factories.remove(factory.getName());
  if (factories.size() == 0) {
    shutdownManagementService();
  }
  factory.proxies.clear();
  for (  ExecutorService esp : factory.executorServiceProxies.values()) {
    esp.shutdown();
  }
  factory.node.shutdown(true,true);
}","public static void kill(FactoryImpl factory){
  factory.managementService.unregister();
  factories.remove(factory.getName());
  if (factories.size() == 0) {
    shutdownManagementService();
  }
  factory.proxies.clear();
  for (  ExecutorService esp : factory.executorServiceProxies.values()) {
    esp.shutdown();
  }
  factory.node.shutdown(true,true);
}",0.851063829787234
49571,"public void kill(){
synchronized (lifecycleLock) {
    fireLifecycleEvent(SHUTTING_DOWN);
    FactoryImpl.kill(factory.getHazelcastInstanceProxy());
    fireLifecycleEvent(SHUTDOWN);
  }
}","public void kill(){
synchronized (lifecycleLock) {
    fireLifecycleEvent(SHUTTING_DOWN);
    FactoryImpl.kill(factory);
    fireLifecycleEvent(SHUTDOWN);
  }
}",0.9195402298850576
49572,"public void shutdown(){
synchronized (lifecycleLock) {
    fireLifecycleEvent(SHUTTING_DOWN);
    FactoryImpl.shutdown(factory.getHazelcastInstanceProxy());
    fireLifecycleEvent(SHUTDOWN);
  }
}","public void shutdown(){
synchronized (lifecycleLock) {
    fireLifecycleEvent(SHUTTING_DOWN);
    FactoryImpl.shutdown(factory);
    fireLifecycleEvent(SHUTDOWN);
  }
}",0.9230769230769232
49573,"/** 
 * Unregister a cluster instance.
 */
public void unregister(){
synchronized (LOCK) {
    if (!started) {
      return;
    }
    MBeanServer mbs=mBeanServer();
    Set<ObjectName> entries;
    try {
      entries=mbs.queryNames(ObjectNameSpec.getClusterNameFilter(this.name),null);
      for (      ObjectName name : entries) {
        if (mbs.isRegistered(name)) {
          mbs.unregisterMBean(name);
        }
      }
    }
 catch (    Exception e) {
      logger.log(Level.FINEST,""String_Node_Str"",e);
    }
    counter.decrementAndGet();
  }
}","/** 
 * Unregister a cluster instance.
 */
public void unregister(){
  if (!enabled) {
    return;
  }
  if (started.compareAndSet(true,false)) {
    MBeanServer mbs=mBeanServer();
    try {
      Set<ObjectName> entries=mbs.queryNames(new ObjectName(ObjectNameSpec.NAME_DOMAIN + ""String_Node_Str"" + name+ ""String_Node_Str""),null);
      for (      ObjectName name : entries) {
        if (mbs.isRegistered(name)) {
          mbs.unregisterMBean(name);
        }
      }
    }
 catch (    Exception e) {
      logger.log(Level.FINEST,""String_Node_Str"",e);
    }
  }
}",0.7332738626226584
49574,"/** 
 * Create a new collector or return null if statistics are not enabled
 * @return statisticsCollector
 */
@SuppressWarnings(""String_Node_Str"") public static StatisticsCollector newStatisticsCollector(){
synchronized (LOCK) {
    if (statCollectors != null) {
      long interval=1L;
      ScheduledCollector collector=new ScheduledCollector(interval);
      ScheduledFuture future=statCollectors.scheduleWithFixedDelay(collector,interval,interval,TimeUnit.SECONDS);
      collector.setScheduledFuture(future);
      return collector;
    }
 else {
      return null;
    }
  }
}","/** 
 * Create a new collector or return null if statistics are not enabled
 * @return statisticsCollector
 */
@SuppressWarnings(""String_Node_Str"") public static StatisticsCollector newStatisticsCollector(){
  final ScheduledExecutorService scheduledExecutor=statCollectorExecutor;
  if (scheduledExecutor != null) {
    long interval=1L;
    ScheduledCollector collector=new ScheduledCollector(interval);
    ScheduledFuture future=scheduledExecutor.scheduleWithFixedDelay(collector,interval,interval,TimeUnit.SECONDS);
    collector.setScheduledFuture(future);
    return collector;
  }
 else {
    return null;
  }
}",0.8452579034941764
49575,"public ManagementService(FactoryImpl instance){
  this.instance=instance;
  this.logger=instance.node.getLogger(ManagementService.class.getName());
  this.showDetails=instance.node.groupProperties.ENABLE_JMX_DETAILED.getBoolean();
}","public ManagementService(FactoryImpl instance){
  this.instance=instance;
  this.name=instance.getName();
  this.logger=instance.node.getLogger(ManagementService.class.getName());
  this.enabled=instance.node.groupProperties.ENABLE_JMX.getBoolean();
  this.showDetails=instance.node.groupProperties.ENABLE_JMX_DETAILED.getBoolean();
}",0.8197879858657244
49576,"/** 
 * Stop the management service
 */
public static void shutdown(){
synchronized (LOCK) {
    if (counter.get() > 0) {
      return;
    }
    MBeanServer mbs=mBeanServer();
    Set<ObjectName> entries;
    try {
      entries=mbs.queryNames(new ObjectName(ObjectNameSpec.NAME_DOMAIN + ""String_Node_Str""),null);
      for (      ObjectName name : entries) {
        if (mbs.isRegistered(name)) {
          mbs.unregisterMBean(name);
        }
      }
    }
 catch (    Exception e) {
      Logger.getLogger(""String_Node_Str"").log(Level.FINEST,""String_Node_Str"",e);
    }
    if (statCollectors != null) {
      statCollectors.shutdownNow();
      statCollectors=null;
    }
  }
}","/** 
 * Stop the management service
 */
public synchronized static void shutdown(){
  MBeanServer mbs=mBeanServer();
  try {
    Set<ObjectName> entries=mbs.queryNames(new ObjectName(ObjectNameSpec.NAME_DOMAIN + ""String_Node_Str""),null);
    for (    ObjectName name : entries) {
      if (mbs.isRegistered(name)) {
        mbs.unregisterMBean(name);
      }
    }
  }
 catch (  Exception e) {
    Logger.getLogger(""String_Node_Str"").log(Level.FINEST,""String_Node_Str"",e);
  }
  stopStatsCollector();
}",0.7972972972972973
49577,"/** 
 * Register all the MBeans.
 */
public void register(){
synchronized (LOCK) {
    if (!started) {
      start();
    }
    if (!started) {
      return;
    }
    MBeanServer mbs=mBeanServer();
    try {
      nameLookup();
      ClusterMBean clusterMBean=new ClusterMBean(this,this.name);
      mbs.registerMBean(clusterMBean,clusterMBean.getObjectName());
      DataMBean dataMBean=new DataMBean(this);
      dataMBean.setParentName(clusterMBean.getRootName());
      mbs.registerMBean(dataMBean,dataMBean.getObjectName());
    }
 catch (    Exception e) {
      logger.log(Level.WARNING,""String_Node_Str"",e);
      return;
    }
    counter.incrementAndGet();
  }
}","/** 
 * Register all the MBeans.
 */
public void register(){
  if (!enabled) {
    return;
  }
  if (started.compareAndSet(false,true)) {
    logger.log(Level.INFO,""String_Node_Str"");
    if (showDetails()) {
      startStatsCollector();
    }
    MBeanServer mbs=mBeanServer();
    try {
      ClusterMBean clusterMBean=new ClusterMBean(this,this.name);
      mbs.registerMBean(clusterMBean,clusterMBean.getObjectName());
      DataMBean dataMBean=new DataMBean(this);
      dataMBean.setParentName(clusterMBean.getRootName());
      mbs.registerMBean(dataMBean,dataMBean.getObjectName());
    }
 catch (    Exception e) {
      logger.log(Level.WARNING,""String_Node_Str"",e);
    }
  }
}",0.6818515797207936
49578,"/** 
 * Builde the name, overwriting the defaults
 */
public ObjectName buildObjectName(String type,String name) throws Exception {
  StringBuffer sb=new StringBuffer(NAME_DOMAIN);
  if (type != null) {
    sb.append(""String_Node_Str"").append(clean(type));
  }
  if (name != null) {
    if (type != null || cluster != null) {
      sb.append(',');
    }
    sb.append(""String_Node_Str"").append(clean(name));
  }
  return new ObjectName(sb.toString());
}","/** 
 * Builde the name, overwriting the defaults
 */
public ObjectName buildObjectName(String type,String name) throws Exception {
  StringBuilder sb=new StringBuilder(NAME_DOMAIN);
  if (type != null) {
    sb.append(""String_Node_Str"").append(clean(type));
  }
  if (name != null) {
    if (type != null || cluster != null) {
      sb.append(',');
    }
    sb.append(""String_Node_Str"").append(clean(name));
  }
  return new ObjectName(sb.toString());
}",0.9889867841409692
49579,"private InetAddress pickInetAddress(final Collection<String> interfaces) throws SocketException {
  final Enumeration<NetworkInterface> networkInterfaces=NetworkInterface.getNetworkInterfaces();
  final boolean preferIPv4Stack=preferIPv4Stack();
  while (networkInterfaces.hasMoreElements()) {
    final NetworkInterface ni=networkInterfaces.nextElement();
    final Enumeration<InetAddress> e=ni.getInetAddresses();
    while (e.hasMoreElements()) {
      final InetAddress inetAddress=e.nextElement();
      if (preferIPv4Stack && inetAddress instanceof Inet6Address) {
        continue;
      }
      if (interfaces != null && !interfaces.isEmpty()) {
        final String address=inetAddress.getHostAddress();
        if (matchAddress(address,interfaces)) {
          return inetAddress;
        }
      }
 else       if (!inetAddress.isLoopbackAddress()) {
        return inetAddress;
      }
    }
  }
  return null;
}","private InetAddress pickInetAddress(final Collection<String> interfaces) throws SocketException {
  final Enumeration<NetworkInterface> networkInterfaces=NetworkInterface.getNetworkInterfaces();
  final boolean preferIPv4Stack=preferIPv4Stack();
  while (networkInterfaces.hasMoreElements()) {
    final NetworkInterface ni=networkInterfaces.nextElement();
    final Enumeration<InetAddress> e=ni.getInetAddresses();
    while (e.hasMoreElements()) {
      final InetAddress inetAddress=e.nextElement();
      if (preferIPv4Stack && inetAddress instanceof Inet6Address) {
        continue;
      }
      if (interfaces != null && !interfaces.isEmpty()) {
        final String address=inetAddress.getHostAddress();
        if (AddressUtil.matchAnyInterface(address,interfaces)) {
          return inetAddress;
        }
      }
 else       if (!inetAddress.isLoopbackAddress()) {
        return inetAddress;
      }
    }
  }
  return null;
}",0.984450402144772
49580,"public Address pickAddress() throws Exception {
  InetAddress currentInetAddress=null;
  try {
    final Config config=node.getConfig();
    final String localAddress=System.getProperty(""String_Node_Str"");
    if (localAddress != null) {
      currentInetAddress=InetAddress.getByName(localAddress.trim());
    }
    if (currentInetAddress == null) {
      final Collection<String> interfaces=new HashSet<String>();
      if (config.getNetworkConfig().getInterfaces().isEnabled()) {
        interfaces.addAll(config.getNetworkConfig().getInterfaces().getInterfaces());
        logger.log(Level.INFO,""String_Node_Str"" + ""String_Node_Str"" + interfaces);
      }
 else       if (config.getNetworkConfig().getJoin().getTcpIpConfig().isEnabled()) {
        final Collection<String> possibleAddresses=TcpIpJoiner.getConfigurationMembers(node.config);
        for (        String possibleAddress : possibleAddresses) {
          interfaces.add(AddressUtil.getAddressHolder(possibleAddress).address);
        }
        logger.log(Level.FINEST,""String_Node_Str"" + ""String_Node_Str"" + interfaces);
      }
      if (interfaces.contains(""String_Node_Str"") || interfaces.contains(""String_Node_Str"")) {
        currentInetAddress=InetAddress.getByName(""String_Node_Str"");
      }
 else {
        if (interfaces.size() > 0) {
          currentInetAddress=pickInetAddress(interfaces);
        }
        if (currentInetAddress == null) {
          if (config.getNetworkConfig().getInterfaces().isEnabled()) {
            String msg=""String_Node_Str"";
            msg+=""String_Node_Str"";
            logger.log(Level.SEVERE,msg);
            throw new RuntimeException(msg);
          }
 else {
            currentInetAddress=pickInetAddress(null);
          }
        }
      }
    }
    if (currentInetAddress != null) {
      currentInetAddress=AddressUtil.fixAndGetInetAddress(currentInetAddress);
    }
    if (currentInetAddress == null) {
      currentInetAddress=InetAddress.getByName(""String_Node_Str"");
    }
    final InetAddress inetAddress=currentInetAddress;
    final boolean reuseAddress=config.isReuseAddress();
    ServerSocket serverSocket=serverSocketChannel.socket();
    logger.log(Level.FINEST,""String_Node_Str"" + reuseAddress);
    serverSocket.setReuseAddress(reuseAddress);
    serverSocket.setSoTimeout(1000);
    InetSocketAddress isa;
    int port=config.getPort();
    for (int i=0; i < 100; i++) {
      try {
        boolean bindAny=node.getGroupProperties().SOCKET_BIND_ANY.getBoolean();
        if (bindAny) {
          isa=new InetSocketAddress(port);
        }
 else {
          isa=new InetSocketAddress(inetAddress,port);
        }
        logger.log(Level.FINEST,""String_Node_Str"" + isa);
        serverSocket.bind(isa,100);
        break;
      }
 catch (      final Exception e) {
        if (config.isPortAutoIncrement()) {
          serverSocket=serverSocketChannel.socket();
          serverSocket.setReuseAddress(reuseAddress);
          port++;
        }
 else {
          String msg=""String_Node_Str"" + port + ""String_Node_Str""+ ""String_Node_Str"";
          logger.log(Level.SEVERE,msg,e);
          throw e;
        }
      }
    }
    serverSocketChannel.configureBlocking(false);
    return new Address(inetAddress,port);
  }
 catch (  Exception e) {
    logger.log(Level.SEVERE,e.getMessage(),e);
    throw e;
  }
}","public void pickAddress() throws Exception {
  if (address != null) {
    return;
  }
  try {
    final Config config=node.getConfig();
    final InetAddress inetAddress=pickInetAddress(config);
    final boolean reuseAddress=config.isReuseAddress();
    serverSocketChannel=ServerSocketChannel.open();
    final ServerSocket serverSocket=serverSocketChannel.socket();
    logger.log(Level.FINEST,""String_Node_Str"" + reuseAddress);
    serverSocket.setReuseAddress(reuseAddress);
    serverSocket.setSoTimeout(1000);
    InetSocketAddress isa;
    int port=config.getPort();
    for (int i=0; i < 100; i++) {
      try {
        boolean bindAny=node.getGroupProperties().SOCKET_BIND_ANY.getBoolean();
        if (bindAny) {
          isa=new InetSocketAddress(port);
        }
 else {
          isa=new InetSocketAddress(inetAddress,port);
        }
        logger.log(Level.FINEST,""String_Node_Str"" + isa);
        serverSocket.bind(isa,100);
        break;
      }
 catch (      final Exception e) {
        if (config.isPortAutoIncrement()) {
          port++;
        }
 else {
          String msg=""String_Node_Str"" + port + ""String_Node_Str""+ ""String_Node_Str"";
          logger.log(Level.SEVERE,msg,e);
          throw e;
        }
      }
    }
    serverSocketChannel.configureBlocking(false);
    address=new Address(inetAddress,port);
  }
 catch (  Exception e) {
    logger.log(Level.SEVERE,e.getMessage(),e);
    throw e;
  }
}",0.5140948005846732
49581,"public AddressPicker(Node node,ServerSocketChannel serverSocketChannel){
  this.node=node;
  this.logger=Logger.getLogger(AddressPicker.class.getName());
  this.serverSocketChannel=serverSocketChannel;
}","public AddressPicker(Node node){
  this.node=node;
  this.logger=Logger.getLogger(AddressPicker.class.getName());
}",0.7232704402515723
49582,"public Node(FactoryImpl factory,Config config){
  this.id=counter.incrementAndGet();
  this.threadGroup=new ThreadGroup(factory.getName());
  this.factory=factory;
  this.config=config;
  this.groupProperties=new GroupProperties(config);
  this.liteMember=config.isLiteMember();
  this.localNodeType=(liteMember) ? NodeType.LITE_MEMBER : NodeType.MEMBER;
  ServerSocketChannel serverSocketChannel=null;
  Address localAddress=null;
  try {
    serverSocketChannel=ServerSocketChannel.open();
    AddressPicker addressPicker=new AddressPicker(this,serverSocketChannel);
    localAddress=addressPicker.pickAddress();
  }
 catch (  Throwable e) {
    Util.throwUncheckedException(e);
  }
  address=localAddress;
  localMember=new MemberImpl(address,true,localNodeType,UUID.randomUUID().toString());
  String loggingType=groupProperties.LOGGING_TYPE.getString();
  systemLogService=new SystemLogService(Node.this);
  this.loggingService=new LoggingServiceImpl(systemLogService,config.getGroupConfig().getName(),loggingType,localMember);
  this.logger=loggingService.getLogger(Node.class.getName());
  ThreadContext.get().setCurrentFactory(factory);
  initializer=NodeInitializerFactory.create();
  initializer.beforeInitialize(this);
  securityContext=config.getSecurityConfig().isEnabled() ? initializer.getSecurityContext() : null;
  clusterImpl=new ClusterImpl(this);
  baseVariables=new NodeBaseVariables(address,localMember);
  clusterService=new ClusterService(this);
  clusterService.start();
  connectionManager=new ConnectionManager(new NodeIOService(this),serverSocketChannel);
  clusterManager=new ClusterManager(this);
  executorManager=new ExecutorManager(this);
  clientHandlerService=new ClientHandlerService(this);
  concurrentMapManager=new ConcurrentMapManager(this);
  blockingQueueManager=new BlockingQueueManager(this);
  listenerManager=new ListenerManager(this);
  clientService=new ClientServiceImpl(concurrentMapManager);
  topicManager=new TopicManager(this);
  textCommandService=new TextCommandServiceImpl(this);
  clusterManager.addMember(false,localMember);
  initializer.printNodeInfo(this);
  buildNumber=initializer.getBuildNumber();
  VersionCheck.check(this,initializer.getBuild(),initializer.getVersion());
  Join join=config.getNetworkConfig().getJoin();
  MulticastService mcService=null;
  try {
    if (join.getMulticastConfig().isEnabled()) {
      MulticastConfig multicastConfig=join.getMulticastConfig();
      MulticastSocket multicastSocket=new MulticastSocket(null);
      multicastSocket.setReuseAddress(true);
      multicastSocket.bind(new InetSocketAddress(multicastConfig.getMulticastPort()));
      multicastSocket.setTimeToLive(multicastConfig.getMulticastTimeToLive());
      try {
        multicastSocket.setInterface(address.getInetAddress());
      }
 catch (      Exception e) {
        logger.log(Level.WARNING,e.getMessage(),e);
      }
      multicastSocket.setReceiveBufferSize(64 * 1024);
      multicastSocket.setSendBufferSize(64 * 1024);
      String multicastGroup=System.getProperty(""String_Node_Str"");
      if (multicastGroup == null) {
        multicastGroup=multicastConfig.getMulticastGroup();
      }
      multicastConfig.setMulticastGroup(multicastGroup);
      multicastSocket.joinGroup(InetAddress.getByName(multicastGroup));
      multicastSocket.setSoTimeout(1000);
      mcService=new MulticastService(this,multicastSocket);
      mcService.addMulticastListener(new NodeMulticastListener(this));
    }
  }
 catch (  Exception e) {
    logger.log(Level.SEVERE,e.getMessage(),e);
  }
  this.multicastService=mcService;
  wanReplicationService=new WanReplicationService(this);
  initializeListeners(config);
  joiner=createJoiner();
}","public Node(FactoryImpl factory,Config config){
  this.id=counter.incrementAndGet();
  this.threadGroup=new ThreadGroup(factory.getName());
  this.factory=factory;
  this.config=config;
  this.groupProperties=new GroupProperties(config);
  this.liteMember=config.isLiteMember();
  this.localNodeType=(liteMember) ? NodeType.LITE_MEMBER : NodeType.MEMBER;
  ServerSocketChannel serverSocketChannel=null;
  Address localAddress=null;
  try {
    AddressPicker addressPicker=new AddressPicker(this);
    addressPicker.pickAddress();
    localAddress=addressPicker.getAddress();
    serverSocketChannel=addressPicker.getServerSocketChannel();
  }
 catch (  Throwable e) {
    Util.throwUncheckedException(e);
  }
  address=localAddress;
  localMember=new MemberImpl(address,true,localNodeType,UUID.randomUUID().toString());
  String loggingType=groupProperties.LOGGING_TYPE.getString();
  systemLogService=new SystemLogService(Node.this);
  this.loggingService=new LoggingServiceImpl(systemLogService,config.getGroupConfig().getName(),loggingType,localMember);
  this.logger=loggingService.getLogger(Node.class.getName());
  ThreadContext.get().setCurrentFactory(factory);
  initializer=NodeInitializerFactory.create();
  initializer.beforeInitialize(this);
  securityContext=config.getSecurityConfig().isEnabled() ? initializer.getSecurityContext() : null;
  clusterImpl=new ClusterImpl(this);
  baseVariables=new NodeBaseVariables(address,localMember);
  clusterService=new ClusterService(this);
  clusterService.start();
  connectionManager=new ConnectionManager(new NodeIOService(this),serverSocketChannel);
  clusterManager=new ClusterManager(this);
  executorManager=new ExecutorManager(this);
  clientHandlerService=new ClientHandlerService(this);
  concurrentMapManager=new ConcurrentMapManager(this);
  blockingQueueManager=new BlockingQueueManager(this);
  listenerManager=new ListenerManager(this);
  clientService=new ClientServiceImpl(concurrentMapManager);
  topicManager=new TopicManager(this);
  textCommandService=new TextCommandServiceImpl(this);
  clusterManager.addMember(false,localMember);
  initializer.printNodeInfo(this);
  buildNumber=initializer.getBuildNumber();
  VersionCheck.check(this,initializer.getBuild(),initializer.getVersion());
  Join join=config.getNetworkConfig().getJoin();
  MulticastService mcService=null;
  try {
    if (join.getMulticastConfig().isEnabled()) {
      MulticastConfig multicastConfig=join.getMulticastConfig();
      MulticastSocket multicastSocket=new MulticastSocket(null);
      multicastSocket.setReuseAddress(true);
      multicastSocket.bind(new InetSocketAddress(multicastConfig.getMulticastPort()));
      multicastSocket.setTimeToLive(multicastConfig.getMulticastTimeToLive());
      try {
        multicastSocket.setInterface(address.getInetAddress());
      }
 catch (      Exception e) {
        logger.log(Level.WARNING,e.getMessage(),e);
      }
      multicastSocket.setReceiveBufferSize(64 * 1024);
      multicastSocket.setSendBufferSize(64 * 1024);
      String multicastGroup=System.getProperty(""String_Node_Str"");
      if (multicastGroup == null) {
        multicastGroup=multicastConfig.getMulticastGroup();
      }
      multicastConfig.setMulticastGroup(multicastGroup);
      multicastSocket.joinGroup(InetAddress.getByName(multicastGroup));
      multicastSocket.setSoTimeout(1000);
      mcService=new MulticastService(this,multicastSocket);
      mcService.addMulticastListener(new NodeMulticastListener(this));
    }
  }
 catch (  Exception e) {
    logger.log(Level.SEVERE,e.getMessage(),e);
  }
  this.multicastService=mcService;
  wanReplicationService=new WanReplicationService(this);
  initializeListeners(config);
  joiner=createJoiner();
}",0.9639881752217144
49583,"public void onMessage(Object msg){
  if (msg != null && msg instanceof JoinInfo) {
    JoinInfo joinInfo=(JoinInfo)msg;
    if (node.address != null && !node.address.equals(joinInfo.address)) {
      boolean validJoinRequest;
      try {
        validJoinRequest=node.validateJoinRequest(joinInfo);
      }
 catch (      Exception e) {
        validJoinRequest=false;
      }
      if (validJoinRequest) {
        if (node.isMaster() && node.isActive() && node.joined()) {
          if (joinInfo.isRequest()) {
            node.multicastService.send(joinInfo.copy(false,node.address,node.getClusterImpl().getMembers().size()));
          }
        }
 else {
          if (!node.joined() && !joinInfo.isRequest()) {
            if (node.masterAddress == null) {
              final String masterHost=joinInfo.address.getHost();
              if (trustedInterfaces.isEmpty() || AddressPicker.matchAddress(masterHost,trustedInterfaces)) {
                node.masterAddress=new Address(joinInfo.address);
              }
            }
          }
 else           if (joinInfo.isRequest()) {
            Joiner joiner=node.getJoiner();
            if (joiner instanceof MulticastJoiner) {
              MulticastJoiner mjoiner=(MulticastJoiner)joiner;
              mjoiner.onReceivedJoinInfo(joinInfo);
            }
          }
        }
      }
    }
  }
}","public void onMessage(Object msg){
  if (msg != null && msg instanceof JoinInfo) {
    JoinInfo joinInfo=(JoinInfo)msg;
    if (node.address != null && !node.address.equals(joinInfo.address)) {
      boolean validJoinRequest;
      try {
        validJoinRequest=node.validateJoinRequest(joinInfo);
      }
 catch (      Exception e) {
        validJoinRequest=false;
      }
      if (validJoinRequest) {
        if (node.isMaster() && node.isActive() && node.joined()) {
          if (joinInfo.isRequest()) {
            node.multicastService.send(joinInfo.copy(false,node.address,node.getClusterImpl().getMembers().size()));
          }
        }
 else {
          if (!node.joined() && !joinInfo.isRequest()) {
            if (node.masterAddress == null) {
              final String masterHost=joinInfo.address.getHost();
              if (trustedInterfaces.isEmpty() || AddressUtil.matchAnyInterface(masterHost,trustedInterfaces)) {
                node.masterAddress=new Address(joinInfo.address);
              }
            }
          }
 else           if (joinInfo.isRequest()) {
            Joiner joiner=node.getJoiner();
            if (joiner instanceof MulticastJoiner) {
              MulticastJoiner mjoiner=(MulticastJoiner)joiner;
              mjoiner.onReceivedJoinInfo(joinInfo);
            }
          }
        }
      }
    }
  }
}",0.9900479174345744
49584,"private Address getAddressFor(String host){
  try {
    final AddressHolder addressHolder=AddressUtil.getAddressHolder(host,config.getPort());
    if (AddressUtil.isIpAddress(addressHolder.address)) {
      return new Address(addressHolder.address,addressHolder.port);
    }
 else {
      final InetAddress[] allAddresses=InetAddress.getAllByName(addressHolder.address);
      final Interfaces interfaces=config.getNetworkConfig().getInterfaces();
      for (      final InetAddress inetAddress : allAddresses) {
        boolean matchingAddress=true;
        if (interfaces.isEnabled()) {
          matchingAddress=AddressPicker.matchAddress(inetAddress.getHostAddress(),interfaces.getInterfaces());
        }
        if (matchingAddress) {
          return new Address(inetAddress,addressHolder.port);
        }
      }
    }
  }
 catch (  final Exception e) {
    logger.log(Level.WARNING,e.getMessage(),e);
  }
  return null;
}","private Address getAddressFor(String host){
  try {
    final AddressHolder addressHolder=AddressUtil.getAddressHolder(host,config.getPort());
    if (AddressUtil.isIpAddress(addressHolder.address)) {
      return new Address(addressHolder.address,addressHolder.port);
    }
 else {
      final InetAddress[] allAddresses=InetAddress.getAllByName(addressHolder.address);
      final Interfaces interfaces=config.getNetworkConfig().getInterfaces();
      for (      final InetAddress inetAddress : allAddresses) {
        boolean matchingAddress=true;
        if (interfaces.isEnabled()) {
          matchingAddress=AddressUtil.matchAnyInterface(inetAddress.getHostAddress(),interfaces.getInterfaces());
        }
        if (matchingAddress) {
          return new Address(inetAddress,addressHolder.port);
        }
      }
    }
  }
 catch (  final Exception e) {
    logger.log(Level.WARNING,e.getMessage(),e);
  }
  return null;
}",0.9855072463768116
49585,"private Collection<Address> getPossibleAddresses(){
  final Collection<String> possibleMembers=getMembers();
  final Set<Address> setPossibleAddresses=new HashSet<Address>();
  final Address thisAddress=node.address;
  for (  String host : possibleMembers) {
    try {
      final AddressHolder addressHolder=AddressUtil.getAddressHolder(host);
      final boolean portIsDefined=addressHolder.port != -1 || !config.isPortAutoIncrement();
      final int maxAddressTries=portIsDefined ? 1 : MAX_ADDRESS_TRIES;
      final int port=addressHolder.port != -1 ? addressHolder.port : config.getPort();
      AddressMatcher addressMatcher=null;
      try {
        addressMatcher=AddressUtil.getAddressMatcher(addressHolder.address);
      }
 catch (      InvalidAddressException ignore) {
      }
      if (addressMatcher != null) {
        final Collection<String> matchedAddresses;
        if (addressMatcher.isIPv4()) {
          matchedAddresses=AddressUtil.getMatchingIpv4Addresses(addressMatcher);
        }
 else {
          matchedAddresses=Collections.singleton(addressHolder.address);
        }
        for (        String matchedAddress : matchedAddresses) {
          for (int i=0; i < maxAddressTries; i++) {
            final Address addressProper=new Address(matchedAddress,port + i);
            if (!addressProper.equals(thisAddress)) {
              setPossibleAddresses.add(addressProper);
            }
          }
        }
      }
 else {
        final InetAddress[] allAddresses=InetAddress.getAllByName(addressHolder.address);
        for (        final InetAddress inetAddress : allAddresses) {
          boolean matchingAddress=true;
          Interfaces interfaces=config.getNetworkConfig().getInterfaces();
          if (interfaces.isEnabled()) {
            matchingAddress=AddressPicker.matchAddress(inetAddress.getHostAddress(),interfaces.getInterfaces());
          }
          if (matchingAddress) {
            for (int i=0; i < maxAddressTries; i++) {
              final Address addressProper=new Address(inetAddress,port + i);
              if (!addressProper.equals(thisAddress)) {
                setPossibleAddresses.add(addressProper);
              }
            }
          }
        }
      }
    }
 catch (    UnknownHostException e) {
      logger.log(Level.WARNING,e.getMessage(),e);
    }
  }
  setPossibleAddresses.addAll(config.getNetworkConfig().getJoin().getTcpIpConfig().getAddresses());
  return setPossibleAddresses;
}","private Collection<Address> getPossibleAddresses(){
  final Collection<String> possibleMembers=getMembers();
  final Set<Address> setPossibleAddresses=new HashSet<Address>();
  final Address thisAddress=node.address;
  for (  String host : possibleMembers) {
    try {
      final AddressHolder addressHolder=AddressUtil.getAddressHolder(host);
      final boolean portIsDefined=addressHolder.port != -1 || !config.isPortAutoIncrement();
      final int maxAddressTries=portIsDefined ? 1 : MAX_ADDRESS_TRIES;
      final int port=addressHolder.port != -1 ? addressHolder.port : config.getPort();
      AddressMatcher addressMatcher=null;
      try {
        addressMatcher=AddressUtil.getAddressMatcher(addressHolder.address);
      }
 catch (      InvalidAddressException ignore) {
      }
      if (addressMatcher != null) {
        final Collection<String> matchedAddresses;
        if (addressMatcher.isIPv4()) {
          matchedAddresses=AddressUtil.getMatchingIpv4Addresses(addressMatcher);
        }
 else {
          matchedAddresses=Collections.singleton(addressHolder.address);
        }
        for (        String matchedAddress : matchedAddresses) {
          for (int i=0; i < maxAddressTries; i++) {
            final Address addressProper=new Address(matchedAddress,port + i);
            if (!addressProper.equals(thisAddress)) {
              setPossibleAddresses.add(addressProper);
            }
          }
        }
      }
 else {
        final InetAddress[] allAddresses=InetAddress.getAllByName(addressHolder.address);
        for (        final InetAddress inetAddress : allAddresses) {
          boolean matchingAddress=true;
          Interfaces interfaces=config.getNetworkConfig().getInterfaces();
          if (interfaces.isEnabled()) {
            matchingAddress=AddressUtil.matchAnyInterface(inetAddress.getHostAddress(),interfaces.getInterfaces());
          }
          if (matchingAddress) {
            for (int i=0; i < maxAddressTries; i++) {
              final Address addressProper=new Address(inetAddress,port + i);
              if (!addressProper.equals(thisAddress)) {
                setPossibleAddresses.add(addressProper);
              }
            }
          }
        }
      }
    }
 catch (    UnknownHostException e) {
      logger.log(Level.WARNING,e.getMessage(),e);
    }
  }
  setPossibleAddresses.addAll(config.getNetworkConfig().getJoin().getTcpIpConfig().getAddresses());
  return setPossibleAddresses;
}",0.9945310917561272
49586,"public Collection<MemberGroup> createMemberGroups(Collection<MemberImpl> members){
  final Map<Integer,MemberGroup> memberGroups=new HashMap<Integer,MemberGroup>();
  for (  MemberImpl member : members) {
    if (member.isLiteMember()) {
      continue;
    }
    for (    Entry<Integer,MemberGroupConfig> groupConfigEntry : memberGroupConfigMap.entrySet()) {
      if (AddressPicker.matchAddress(member.getAddress().getHost(),groupConfigEntry.getValue().getInterfaces())) {
        MemberGroup group=memberGroups.get(groupConfigEntry.getKey());
        if (group == null) {
          group=new DefaultMemberGroup();
          memberGroups.put(groupConfigEntry.getKey(),group);
        }
        group.addMember(member);
        break;
      }
    }
  }
  return memberGroups.values();
}","public Collection<MemberGroup> createMemberGroups(Collection<MemberImpl> members){
  final Map<Integer,MemberGroup> memberGroups=new HashMap<Integer,MemberGroup>();
  for (  MemberImpl member : members) {
    if (member.isLiteMember()) {
      continue;
    }
    for (    Entry<Integer,MemberGroupConfig> groupConfigEntry : memberGroupConfigMap.entrySet()) {
      if (AddressUtil.matchAnyInterface(member.getAddress().getHost(),groupConfigEntry.getValue().getInterfaces())) {
        MemberGroup group=memberGroups.get(groupConfigEntry.getKey());
        if (group == null) {
          group=new DefaultMemberGroup();
          memberGroups.put(groupConfigEntry.getKey(),group);
        }
        group.addMember(member);
        break;
      }
    }
  }
  return memberGroups.values();
}",0.9828788839568802
49587,"private InetAddress pickInetAddress(final Collection<String> interfaces) throws SocketException {
  final Enumeration<NetworkInterface> networkInterfaces=NetworkInterface.getNetworkInterfaces();
  final boolean preferIPv4Stack=preferIPv4Stack();
  while (networkInterfaces.hasMoreElements()) {
    final NetworkInterface ni=networkInterfaces.nextElement();
    final Enumeration<InetAddress> e=ni.getInetAddresses();
    while (e.hasMoreElements()) {
      final InetAddress inetAddress=e.nextElement();
      if (preferIPv4Stack && inetAddress instanceof Inet6Address) {
        continue;
      }
      if (interfaces != null && !interfaces.isEmpty()) {
        final String address=inetAddress.getHostAddress();
        if (matchAddress(address,interfaces)) {
          return inetAddress;
        }
      }
 else       if (!inetAddress.isLoopbackAddress()) {
        return inetAddress;
      }
    }
  }
  return null;
}","private InetAddress pickInetAddress(final Collection<String> interfaces) throws SocketException {
  final Enumeration<NetworkInterface> networkInterfaces=NetworkInterface.getNetworkInterfaces();
  final boolean preferIPv4Stack=preferIPv4Stack();
  while (networkInterfaces.hasMoreElements()) {
    final NetworkInterface ni=networkInterfaces.nextElement();
    final Enumeration<InetAddress> e=ni.getInetAddresses();
    while (e.hasMoreElements()) {
      final InetAddress inetAddress=e.nextElement();
      if (preferIPv4Stack && inetAddress instanceof Inet6Address) {
        continue;
      }
      if (interfaces != null && !interfaces.isEmpty()) {
        final String address=inetAddress.getHostAddress();
        if (AddressUtil.matchAnyInterface(address,interfaces)) {
          return inetAddress;
        }
      }
 else       if (!inetAddress.isLoopbackAddress()) {
        return inetAddress;
      }
    }
  }
  return null;
}",0.984450402144772
49588,"public Address pickAddress() throws Exception {
  InetAddress currentInetAddress=null;
  try {
    final Config config=node.getConfig();
    final String localAddress=System.getProperty(""String_Node_Str"");
    if (localAddress != null) {
      currentInetAddress=InetAddress.getByName(localAddress.trim());
    }
    if (currentInetAddress == null) {
      final Collection<String> interfaces=new HashSet<String>();
      if (config.getNetworkConfig().getInterfaces().isEnabled()) {
        interfaces.addAll(config.getNetworkConfig().getInterfaces().getInterfaces());
        logger.log(Level.INFO,""String_Node_Str"" + ""String_Node_Str"" + interfaces);
      }
 else       if (config.getNetworkConfig().getJoin().getTcpIpConfig().isEnabled()) {
        final Collection<String> possibleAddresses=TcpIpJoiner.getConfigurationMembers(node.config);
        for (        String possibleAddress : possibleAddresses) {
          interfaces.add(AddressUtil.getAddressHolder(possibleAddress).address);
        }
        logger.log(Level.FINEST,""String_Node_Str"" + ""String_Node_Str"" + interfaces);
      }
      if (interfaces.contains(""String_Node_Str"") || interfaces.contains(""String_Node_Str"")) {
        currentInetAddress=InetAddress.getByName(""String_Node_Str"");
      }
 else {
        if (interfaces.size() > 0) {
          currentInetAddress=pickInetAddress(interfaces);
        }
        if (currentInetAddress == null) {
          if (config.getNetworkConfig().getInterfaces().isEnabled()) {
            String msg=""String_Node_Str"";
            msg+=""String_Node_Str"";
            logger.log(Level.SEVERE,msg);
            throw new RuntimeException(msg);
          }
 else {
            currentInetAddress=pickInetAddress(null);
          }
        }
      }
    }
    if (currentInetAddress != null) {
      currentInetAddress=AddressUtil.fixAndGetInetAddress(currentInetAddress);
    }
    if (currentInetAddress == null) {
      currentInetAddress=InetAddress.getByName(""String_Node_Str"");
    }
    final InetAddress inetAddress=currentInetAddress;
    final boolean reuseAddress=config.isReuseAddress();
    ServerSocket serverSocket=serverSocketChannel.socket();
    logger.log(Level.FINEST,""String_Node_Str"" + reuseAddress);
    serverSocket.setReuseAddress(reuseAddress);
    serverSocket.setSoTimeout(1000);
    InetSocketAddress isa;
    int port=config.getPort();
    for (int i=0; i < 100; i++) {
      try {
        boolean bindAny=node.getGroupProperties().SOCKET_BIND_ANY.getBoolean();
        if (bindAny) {
          isa=new InetSocketAddress(port);
        }
 else {
          isa=new InetSocketAddress(inetAddress,port);
        }
        logger.log(Level.FINEST,""String_Node_Str"" + isa);
        serverSocket.bind(isa,100);
        break;
      }
 catch (      final Exception e) {
        if (config.isPortAutoIncrement()) {
          serverSocket=serverSocketChannel.socket();
          serverSocket.setReuseAddress(reuseAddress);
          port++;
        }
 else {
          String msg=""String_Node_Str"" + port + ""String_Node_Str""+ ""String_Node_Str"";
          logger.log(Level.SEVERE,msg,e);
          throw e;
        }
      }
    }
    serverSocketChannel.configureBlocking(false);
    return new Address(inetAddress,port);
  }
 catch (  Exception e) {
    logger.log(Level.SEVERE,e.getMessage(),e);
    throw e;
  }
}","public void pickAddress() throws Exception {
  if (address != null) {
    return;
  }
  try {
    final Config config=node.getConfig();
    final InetAddress inetAddress=pickInetAddress(config);
    final boolean reuseAddress=config.isReuseAddress();
    serverSocketChannel=ServerSocketChannel.open();
    final ServerSocket serverSocket=serverSocketChannel.socket();
    logger.log(Level.FINEST,""String_Node_Str"" + reuseAddress);
    serverSocket.setReuseAddress(reuseAddress);
    serverSocket.setSoTimeout(1000);
    InetSocketAddress isa;
    int port=config.getPort();
    for (int i=0; i < 100; i++) {
      try {
        boolean bindAny=node.getGroupProperties().SOCKET_BIND_ANY.getBoolean();
        if (bindAny) {
          isa=new InetSocketAddress(port);
        }
 else {
          isa=new InetSocketAddress(inetAddress,port);
        }
        logger.log(Level.FINEST,""String_Node_Str"" + isa);
        serverSocket.bind(isa,100);
        break;
      }
 catch (      final Exception e) {
        if (config.isPortAutoIncrement()) {
          port++;
        }
 else {
          String msg=""String_Node_Str"" + port + ""String_Node_Str""+ ""String_Node_Str"";
          logger.log(Level.SEVERE,msg,e);
          throw e;
        }
      }
    }
    serverSocketChannel.configureBlocking(false);
    address=new Address(inetAddress,port);
  }
 catch (  Exception e) {
    logger.log(Level.SEVERE,e.getMessage(),e);
    throw e;
  }
}",0.5140948005846732
49589,"public AddressPicker(Node node,ServerSocketChannel serverSocketChannel){
  this.node=node;
  this.logger=Logger.getLogger(AddressPicker.class.getName());
  this.serverSocketChannel=serverSocketChannel;
}","public AddressPicker(Node node){
  this.node=node;
  this.logger=Logger.getLogger(AddressPicker.class.getName());
}",0.7232704402515723
49590,"public Node(FactoryImpl factory,Config config){
  this.id=counter.incrementAndGet();
  this.threadGroup=new ThreadGroup(factory.getName());
  this.factory=factory;
  this.config=config;
  this.groupProperties=new GroupProperties(config);
  this.liteMember=config.isLiteMember();
  this.localNodeType=(liteMember) ? NodeType.LITE_MEMBER : NodeType.MEMBER;
  ServerSocketChannel serverSocketChannel=null;
  Address localAddress=null;
  try {
    serverSocketChannel=ServerSocketChannel.open();
    AddressPicker addressPicker=new AddressPicker(this,serverSocketChannel);
    localAddress=addressPicker.pickAddress();
  }
 catch (  Throwable e) {
    Util.throwUncheckedException(e);
  }
  address=localAddress;
  localMember=new MemberImpl(address,true,localNodeType,UUID.randomUUID().toString());
  String loggingType=groupProperties.LOGGING_TYPE.getString();
  systemLogService=new SystemLogService(Node.this);
  this.loggingService=new LoggingServiceImpl(systemLogService,config.getGroupConfig().getName(),loggingType,localMember);
  this.logger=loggingService.getLogger(Node.class.getName());
  ThreadContext.get().setCurrentFactory(factory);
  initializer=NodeInitializerFactory.create();
  initializer.beforeInitialize(this);
  securityContext=config.getSecurityConfig().isEnabled() ? initializer.getSecurityContext() : null;
  clusterImpl=new ClusterImpl(this);
  baseVariables=new NodeBaseVariables(address,localMember);
  clusterService=new ClusterService(this);
  clusterService.start();
  connectionManager=new ConnectionManager(new NodeIOService(this),serverSocketChannel);
  clusterManager=new ClusterManager(this);
  executorManager=new ExecutorManager(this);
  clientHandlerService=new ClientHandlerService(this);
  concurrentMapManager=new ConcurrentMapManager(this);
  blockingQueueManager=new BlockingQueueManager(this);
  listenerManager=new ListenerManager(this);
  clientService=new ClientServiceImpl(concurrentMapManager);
  topicManager=new TopicManager(this);
  textCommandService=new TextCommandServiceImpl(this);
  clusterManager.addMember(false,localMember);
  initializer.printNodeInfo(this);
  buildNumber=initializer.getBuildNumber();
  VersionCheck.check(this,initializer.getBuild(),initializer.getVersion());
  Join join=config.getNetworkConfig().getJoin();
  MulticastService mcService=null;
  try {
    if (join.getMulticastConfig().isEnabled()) {
      MulticastConfig multicastConfig=join.getMulticastConfig();
      MulticastSocket multicastSocket=new MulticastSocket(null);
      multicastSocket.setReuseAddress(true);
      multicastSocket.bind(new InetSocketAddress(multicastConfig.getMulticastPort()));
      multicastSocket.setTimeToLive(multicastConfig.getMulticastTimeToLive());
      try {
        multicastSocket.setInterface(address.getInetAddress());
      }
 catch (      Exception e) {
        logger.log(Level.WARNING,e.getMessage(),e);
      }
      multicastSocket.setReceiveBufferSize(64 * 1024);
      multicastSocket.setSendBufferSize(64 * 1024);
      String multicastGroup=System.getProperty(""String_Node_Str"");
      if (multicastGroup == null) {
        multicastGroup=multicastConfig.getMulticastGroup();
      }
      multicastConfig.setMulticastGroup(multicastGroup);
      multicastSocket.joinGroup(InetAddress.getByName(multicastGroup));
      multicastSocket.setSoTimeout(1000);
      mcService=new MulticastService(this,multicastSocket);
      mcService.addMulticastListener(new NodeMulticastListener(this));
    }
  }
 catch (  Exception e) {
    logger.log(Level.SEVERE,e.getMessage(),e);
  }
  this.multicastService=mcService;
  wanReplicationService=new WanReplicationService(this);
  initializeListeners(config);
  joiner=createJoiner();
}","public Node(FactoryImpl factory,Config config){
  this.id=counter.incrementAndGet();
  this.threadGroup=new ThreadGroup(factory.getName());
  this.factory=factory;
  this.config=config;
  this.groupProperties=new GroupProperties(config);
  this.liteMember=config.isLiteMember();
  this.localNodeType=(liteMember) ? NodeType.LITE_MEMBER : NodeType.MEMBER;
  ServerSocketChannel serverSocketChannel=null;
  Address localAddress=null;
  try {
    AddressPicker addressPicker=new AddressPicker(this);
    addressPicker.pickAddress();
    localAddress=addressPicker.getAddress();
    serverSocketChannel=addressPicker.getServerSocketChannel();
  }
 catch (  Throwable e) {
    Util.throwUncheckedException(e);
  }
  address=localAddress;
  localMember=new MemberImpl(address,true,localNodeType,UUID.randomUUID().toString());
  String loggingType=groupProperties.LOGGING_TYPE.getString();
  systemLogService=new SystemLogService(Node.this);
  this.loggingService=new LoggingServiceImpl(systemLogService,config.getGroupConfig().getName(),loggingType,localMember);
  this.logger=loggingService.getLogger(Node.class.getName());
  ThreadContext.get().setCurrentFactory(factory);
  initializer=NodeInitializerFactory.create();
  initializer.beforeInitialize(this);
  securityContext=config.getSecurityConfig().isEnabled() ? initializer.getSecurityContext() : null;
  clusterImpl=new ClusterImpl(this);
  baseVariables=new NodeBaseVariables(address,localMember);
  clusterService=new ClusterService(this);
  clusterService.start();
  connectionManager=new ConnectionManager(new NodeIOService(this),serverSocketChannel);
  clusterManager=new ClusterManager(this);
  executorManager=new ExecutorManager(this);
  clientHandlerService=new ClientHandlerService(this);
  concurrentMapManager=new ConcurrentMapManager(this);
  blockingQueueManager=new BlockingQueueManager(this);
  listenerManager=new ListenerManager(this);
  clientService=new ClientServiceImpl(concurrentMapManager);
  topicManager=new TopicManager(this);
  textCommandService=new TextCommandServiceImpl(this);
  clusterManager.addMember(false,localMember);
  initializer.printNodeInfo(this);
  buildNumber=initializer.getBuildNumber();
  VersionCheck.check(this,initializer.getBuild(),initializer.getVersion());
  Join join=config.getNetworkConfig().getJoin();
  MulticastService mcService=null;
  try {
    if (join.getMulticastConfig().isEnabled()) {
      MulticastConfig multicastConfig=join.getMulticastConfig();
      MulticastSocket multicastSocket=new MulticastSocket(null);
      multicastSocket.setReuseAddress(true);
      multicastSocket.bind(new InetSocketAddress(multicastConfig.getMulticastPort()));
      multicastSocket.setTimeToLive(multicastConfig.getMulticastTimeToLive());
      try {
        multicastSocket.setInterface(address.getInetAddress());
      }
 catch (      Exception e) {
        logger.log(Level.WARNING,e.getMessage(),e);
      }
      multicastSocket.setReceiveBufferSize(64 * 1024);
      multicastSocket.setSendBufferSize(64 * 1024);
      String multicastGroup=System.getProperty(""String_Node_Str"");
      if (multicastGroup == null) {
        multicastGroup=multicastConfig.getMulticastGroup();
      }
      multicastConfig.setMulticastGroup(multicastGroup);
      multicastSocket.joinGroup(InetAddress.getByName(multicastGroup));
      multicastSocket.setSoTimeout(1000);
      mcService=new MulticastService(this,multicastSocket);
      mcService.addMulticastListener(new NodeMulticastListener(this));
    }
  }
 catch (  Exception e) {
    logger.log(Level.SEVERE,e.getMessage(),e);
  }
  this.multicastService=mcService;
  wanReplicationService=new WanReplicationService(this);
  initializeListeners(config);
  joiner=createJoiner();
}",0.9639881752217144
49591,"public void onMessage(Object msg){
  if (msg != null && msg instanceof JoinInfo) {
    JoinInfo joinInfo=(JoinInfo)msg;
    if (node.address != null && !node.address.equals(joinInfo.address)) {
      boolean validJoinRequest;
      try {
        validJoinRequest=node.validateJoinRequest(joinInfo);
      }
 catch (      Exception e) {
        validJoinRequest=false;
      }
      if (validJoinRequest) {
        if (node.isMaster() && node.isActive() && node.joined()) {
          if (joinInfo.isRequest()) {
            node.multicastService.send(joinInfo.copy(false,node.address,node.getClusterImpl().getMembers().size()));
          }
        }
 else {
          if (!node.joined() && !joinInfo.isRequest()) {
            if (node.masterAddress == null) {
              final String masterHost=joinInfo.address.getHost();
              if (trustedInterfaces.isEmpty() || AddressPicker.matchAddress(masterHost,trustedInterfaces)) {
                node.masterAddress=new Address(joinInfo.address);
              }
            }
          }
 else           if (joinInfo.isRequest()) {
            Joiner joiner=node.getJoiner();
            if (joiner instanceof MulticastJoiner) {
              MulticastJoiner mjoiner=(MulticastJoiner)joiner;
              mjoiner.onReceivedJoinInfo(joinInfo);
            }
          }
        }
      }
    }
  }
}","public void onMessage(Object msg){
  if (msg != null && msg instanceof JoinInfo) {
    JoinInfo joinInfo=(JoinInfo)msg;
    if (node.address != null && !node.address.equals(joinInfo.address)) {
      boolean validJoinRequest;
      try {
        validJoinRequest=node.validateJoinRequest(joinInfo);
      }
 catch (      Exception e) {
        validJoinRequest=false;
      }
      if (validJoinRequest) {
        if (node.isMaster() && node.isActive() && node.joined()) {
          if (joinInfo.isRequest()) {
            node.multicastService.send(joinInfo.copy(false,node.address,node.getClusterImpl().getMembers().size()));
          }
        }
 else {
          if (!node.joined() && !joinInfo.isRequest()) {
            if (node.masterAddress == null) {
              final String masterHost=joinInfo.address.getHost();
              if (trustedInterfaces.isEmpty() || AddressUtil.matchAnyInterface(masterHost,trustedInterfaces)) {
                node.masterAddress=new Address(joinInfo.address);
              }
            }
          }
 else           if (joinInfo.isRequest()) {
            Joiner joiner=node.getJoiner();
            if (joiner instanceof MulticastJoiner) {
              MulticastJoiner mjoiner=(MulticastJoiner)joiner;
              mjoiner.onReceivedJoinInfo(joinInfo);
            }
          }
        }
      }
    }
  }
}",0.9900479174345744
49592,"private Address getAddressFor(String host){
  try {
    final AddressHolder addressHolder=AddressUtil.getAddressHolder(host,config.getPort());
    if (AddressUtil.isIpAddress(addressHolder.address)) {
      return new Address(addressHolder.address,addressHolder.port);
    }
 else {
      final InetAddress[] allAddresses=InetAddress.getAllByName(addressHolder.address);
      final Interfaces interfaces=config.getNetworkConfig().getInterfaces();
      for (      final InetAddress inetAddress : allAddresses) {
        boolean matchingAddress=true;
        if (interfaces.isEnabled()) {
          matchingAddress=AddressPicker.matchAddress(inetAddress.getHostAddress(),interfaces.getInterfaces());
        }
        if (matchingAddress) {
          return new Address(inetAddress,addressHolder.port);
        }
      }
    }
  }
 catch (  final Exception e) {
    logger.log(Level.WARNING,e.getMessage(),e);
  }
  return null;
}","private Address getAddressFor(String host){
  try {
    final AddressHolder addressHolder=AddressUtil.getAddressHolder(host,config.getPort());
    if (AddressUtil.isIpAddress(addressHolder.address)) {
      return new Address(addressHolder.address,addressHolder.port);
    }
 else {
      final InetAddress[] allAddresses=InetAddress.getAllByName(addressHolder.address);
      final Interfaces interfaces=config.getNetworkConfig().getInterfaces();
      for (      final InetAddress inetAddress : allAddresses) {
        boolean matchingAddress=true;
        if (interfaces.isEnabled()) {
          matchingAddress=AddressUtil.matchAnyInterface(inetAddress.getHostAddress(),interfaces.getInterfaces());
        }
        if (matchingAddress) {
          return new Address(inetAddress,addressHolder.port);
        }
      }
    }
  }
 catch (  final Exception e) {
    logger.log(Level.WARNING,e.getMessage(),e);
  }
  return null;
}",0.9855072463768116
49593,"private Collection<Address> getPossibleAddresses(){
  final Collection<String> possibleMembers=getMembers();
  final Set<Address> setPossibleAddresses=new HashSet<Address>();
  final Address thisAddress=node.address;
  for (  String host : possibleMembers) {
    try {
      final AddressHolder addressHolder=AddressUtil.getAddressHolder(host);
      final boolean portIsDefined=addressHolder.port != -1 || !config.isPortAutoIncrement();
      final int maxAddressTries=portIsDefined ? 1 : MAX_ADDRESS_TRIES;
      final int port=addressHolder.port != -1 ? addressHolder.port : config.getPort();
      AddressMatcher addressMatcher=null;
      try {
        addressMatcher=AddressUtil.getAddressMatcher(addressHolder.address);
      }
 catch (      InvalidAddressException ignore) {
      }
      if (addressMatcher != null) {
        final Collection<String> matchedAddresses;
        if (addressMatcher.isIPv4()) {
          matchedAddresses=AddressUtil.getMatchingIpv4Addresses(addressMatcher);
        }
 else {
          matchedAddresses=Collections.singleton(addressHolder.address);
        }
        for (        String matchedAddress : matchedAddresses) {
          for (int i=0; i < maxAddressTries; i++) {
            final Address addressProper=new Address(matchedAddress,port + i);
            if (!addressProper.equals(thisAddress)) {
              setPossibleAddresses.add(addressProper);
            }
          }
        }
      }
 else {
        final InetAddress[] allAddresses=InetAddress.getAllByName(addressHolder.address);
        for (        final InetAddress inetAddress : allAddresses) {
          boolean matchingAddress=true;
          Interfaces interfaces=config.getNetworkConfig().getInterfaces();
          if (interfaces.isEnabled()) {
            matchingAddress=AddressPicker.matchAddress(inetAddress.getHostAddress(),interfaces.getInterfaces());
          }
          if (matchingAddress) {
            for (int i=0; i < maxAddressTries; i++) {
              final Address addressProper=new Address(inetAddress,port + i);
              if (!addressProper.equals(thisAddress)) {
                setPossibleAddresses.add(addressProper);
              }
            }
          }
        }
      }
    }
 catch (    UnknownHostException e) {
      logger.log(Level.WARNING,e.getMessage(),e);
    }
  }
  setPossibleAddresses.addAll(config.getNetworkConfig().getJoin().getTcpIpConfig().getAddresses());
  return setPossibleAddresses;
}","private Collection<Address> getPossibleAddresses(){
  final Collection<String> possibleMembers=getMembers();
  final Set<Address> setPossibleAddresses=new HashSet<Address>();
  final Address thisAddress=node.address;
  for (  String host : possibleMembers) {
    try {
      final AddressHolder addressHolder=AddressUtil.getAddressHolder(host);
      final boolean portIsDefined=addressHolder.port != -1 || !config.isPortAutoIncrement();
      final int maxAddressTries=portIsDefined ? 1 : MAX_ADDRESS_TRIES;
      final int port=addressHolder.port != -1 ? addressHolder.port : config.getPort();
      AddressMatcher addressMatcher=null;
      try {
        addressMatcher=AddressUtil.getAddressMatcher(addressHolder.address);
      }
 catch (      InvalidAddressException ignore) {
      }
      if (addressMatcher != null) {
        final Collection<String> matchedAddresses;
        if (addressMatcher.isIPv4()) {
          matchedAddresses=AddressUtil.getMatchingIpv4Addresses(addressMatcher);
        }
 else {
          matchedAddresses=Collections.singleton(addressHolder.address);
        }
        for (        String matchedAddress : matchedAddresses) {
          for (int i=0; i < maxAddressTries; i++) {
            final Address addressProper=new Address(matchedAddress,port + i);
            if (!addressProper.equals(thisAddress)) {
              setPossibleAddresses.add(addressProper);
            }
          }
        }
      }
 else {
        final InetAddress[] allAddresses=InetAddress.getAllByName(addressHolder.address);
        for (        final InetAddress inetAddress : allAddresses) {
          boolean matchingAddress=true;
          Interfaces interfaces=config.getNetworkConfig().getInterfaces();
          if (interfaces.isEnabled()) {
            matchingAddress=AddressUtil.matchAnyInterface(inetAddress.getHostAddress(),interfaces.getInterfaces());
          }
          if (matchingAddress) {
            for (int i=0; i < maxAddressTries; i++) {
              final Address addressProper=new Address(inetAddress,port + i);
              if (!addressProper.equals(thisAddress)) {
                setPossibleAddresses.add(addressProper);
              }
            }
          }
        }
      }
    }
 catch (    UnknownHostException e) {
      logger.log(Level.WARNING,e.getMessage(),e);
    }
  }
  setPossibleAddresses.addAll(config.getNetworkConfig().getJoin().getTcpIpConfig().getAddresses());
  return setPossibleAddresses;
}",0.9945310917561272
49594,"public Collection<MemberGroup> createMemberGroups(Collection<MemberImpl> members){
  final Map<Integer,MemberGroup> memberGroups=new HashMap<Integer,MemberGroup>();
  for (  MemberImpl member : members) {
    if (member.isLiteMember()) {
      continue;
    }
    for (    Entry<Integer,MemberGroupConfig> groupConfigEntry : memberGroupConfigMap.entrySet()) {
      if (AddressPicker.matchAddress(member.getAddress().getHost(),groupConfigEntry.getValue().getInterfaces())) {
        MemberGroup group=memberGroups.get(groupConfigEntry.getKey());
        if (group == null) {
          group=new DefaultMemberGroup();
          memberGroups.put(groupConfigEntry.getKey(),group);
        }
        group.addMember(member);
        break;
      }
    }
  }
  return memberGroups.values();
}","public Collection<MemberGroup> createMemberGroups(Collection<MemberImpl> members){
  final Map<Integer,MemberGroup> memberGroups=new HashMap<Integer,MemberGroup>();
  for (  MemberImpl member : members) {
    if (member.isLiteMember()) {
      continue;
    }
    for (    Entry<Integer,MemberGroupConfig> groupConfigEntry : memberGroupConfigMap.entrySet()) {
      if (AddressUtil.matchAnyInterface(member.getAddress().getHost(),groupConfigEntry.getValue().getInterfaces())) {
        MemberGroup group=memberGroups.get(groupConfigEntry.getKey());
        if (group == null) {
          group=new DefaultMemberGroup();
          memberGroups.put(groupConfigEntry.getKey(),group);
        }
        group.addMember(member);
        break;
      }
    }
  }
  return memberGroups.values();
}",0.9828788839568802
49595,"public void put(Request req){
  long now=Clock.currentTimeMillis();
  boolean sendEvictEvent=false;
  Record evictedRecord=null;
  if (req.value == null) {
    req.value=new Data();
  }
  Record record=getRecord(req);
  if (record != null && !record.isValid(now)) {
    if (record.isActive() && record.isEvictable()) {
      sendEvictEvent=true;
      evictedRecord=createNewTransientRecord(record.getKeyData(),record.getValueData());
    }
    record.setValueData(null);
    record.setMultiValues(null);
  }
  if (req.operation == CONCURRENT_MAP_PUT_IF_ABSENT) {
    if (!isApplicable(CONCURRENT_MAP_PUT_IF_ABSENT,req,now)) {
      req.clearForResponse();
      req.response=record.getValueData();
      return;
    }
  }
 else   if (req.operation == CONCURRENT_MAP_REPLACE_IF_NOT_NULL) {
    if (!isApplicable(CONCURRENT_MAP_REPLACE_IF_NOT_NULL,req,now)) {
      req.value=null;
      return;
    }
  }
  Data oldValue=null;
  if (record == null) {
    record=createAndAddNewRecord(req.key,req.value);
  }
 else {
    markAsActive(record);
    oldValue=(record.isValid(now)) ? record.getValueData() : null;
    record.setValueData(req.value);
    record.incrementVersion();
    record.setLastUpdated();
  }
  if (req.ttl > 0 && req.ttl < Long.MAX_VALUE) {
    record.setTTL(req.ttl);
    ttlPerRecord=true;
  }
  if (sendEvictEvent) {
    concurrentMapManager.fireMapEvent(mapListeners,EntryEvent.TYPE_EVICTED,null,evictedRecord,req.caller);
  }
  if (oldValue == null) {
    concurrentMapManager.fireMapEvent(mapListeners,EntryEvent.TYPE_ADDED,null,record,req.caller);
  }
 else {
    fireInvalidation(record);
    concurrentMapManager.fireMapEvent(mapListeners,EntryEvent.TYPE_UPDATED,oldValue,record,req.caller);
  }
  if (req.txnId != -1 || req.operation == ClusterOperation.CONCURRENT_MAP_PUT_AND_UNLOCK) {
    unlock(record,req);
  }
  record.setIndexes(req.indexes,req.indexTypes);
  updateIndexes(record);
  markAsDirty(record,false);
  req.clearForResponse();
  req.version=record.getVersion();
  if (localUpdateListener != null && req.txnId != Long.MIN_VALUE) {
    localUpdateListener.recordUpdated(record);
  }
  if (req.operation == CONCURRENT_MAP_REPLACE_IF_SAME || req.operation == CONCURRENT_MAP_SET) {
    req.response=Boolean.TRUE;
  }
 else {
    req.response=oldValue;
  }
}","public void put(Request req){
  long now=Clock.currentTimeMillis();
  boolean sendEvictEvent=false;
  Record evictedRecord=null;
  if (req.value == null) {
    req.value=new Data();
  }
  Record record=getRecord(req);
  if (record != null && !record.isValid(now)) {
    if (record.isActive() && record.isEvictable()) {
      sendEvictEvent=true;
      evictedRecord=createNewTransientRecord(record.getKeyData(),record.getValueData());
    }
    record.setValueData(null);
    record.setMultiValues(null);
  }
  if (req.operation == CONCURRENT_MAP_PUT_IF_ABSENT) {
    if (!isApplicable(CONCURRENT_MAP_PUT_IF_ABSENT,req,now)) {
      req.clearForResponse();
      req.response=record.getValueData();
      return;
    }
  }
 else   if (req.operation == CONCURRENT_MAP_REPLACE_IF_NOT_NULL) {
    if (!isApplicable(CONCURRENT_MAP_REPLACE_IF_NOT_NULL,req,now)) {
      req.value=null;
      return;
    }
  }
  Data oldValue=null;
  if (record == null) {
    record=createAndAddNewRecord(req.key,req.value);
  }
 else {
    markAsActive(record);
    oldValue=(record.isValid(now)) ? record.getValueData() : null;
    record.setValueData(req.value);
    record.incrementVersion();
    record.setLastUpdated();
  }
  if (req.ttl > 0 && req.ttl < Long.MAX_VALUE) {
    record.setTTL(req.ttl);
    ttlPerRecord=true;
  }
  if (sendEvictEvent) {
    concurrentMapManager.fireMapEvent(mapListeners,EntryEvent.TYPE_EVICTED,null,evictedRecord,req.caller);
  }
  if (oldValue == null) {
    concurrentMapManager.fireMapEvent(mapListeners,EntryEvent.TYPE_ADDED,null,record,req.caller);
  }
 else {
    fireInvalidation(record);
    concurrentMapManager.fireMapEvent(mapListeners,EntryEvent.TYPE_UPDATED,oldValue,record,req.caller);
  }
  if (req.txnId != -1 || req.operation == ClusterOperation.CONCURRENT_MAP_PUT_AND_UNLOCK) {
    unlock(record,req);
  }
  record.setIndexes(req.indexes,req.indexTypes);
  updateIndexes(record);
  markAsDirty(record,false);
  req.clearForResponse();
  req.version=record.getVersion();
  if (localUpdateListener != null && req.txnId != Long.MIN_VALUE) {
    localUpdateListener.recordUpdated(record);
  }
  if (req.operation == CONCURRENT_MAP_SET || req.operation == CONCURRENT_MAP_TRY_PUT || req.operation == CONCURRENT_MAP_PUT_TRANSIENT || req.operation == CONCURRENT_MAP_REPLACE_IF_SAME || req.operation == CONCURRENT_MAP_PUT_AND_UNLOCK) {
    req.response=Boolean.TRUE;
  }
 else {
    req.response=oldValue;
  }
}",0.968736797634136
49596,"private ManagedList parseListeners(Node node,String listenerBeanName,Class listenerConfigClass){
  ManagedList listeners=new ManagedList();
  final String implementationAttr=""String_Node_Str"";
  for (  Node listenerNode : new IterableNodeList(node.getChildNodes(),Node.ELEMENT_NODE)) {
    final BeanDefinitionBuilder listenerConfBuilder=createBeanBuilder(listenerConfigClass);
    fillAttributeValues(listenerNode,listenerConfBuilder,implementationAttr);
    Node implementationNode=null;
    if ((implementationNode=listenerNode.getAttributes().getNamedItem(implementationAttr)) != null) {
      listenerConfBuilder.addPropertyReference(implementationAttr,getValue(implementationNode));
    }
    listeners.add(listenerConfBuilder.getBeanDefinition());
  }
  return listeners;
}","private ManagedList parseListeners(Node node,Class listenerConfigClass){
  ManagedList listeners=new ManagedList();
  final String implementationAttr=""String_Node_Str"";
  for (  Node listenerNode : new IterableNodeList(node.getChildNodes(),Node.ELEMENT_NODE)) {
    final BeanDefinitionBuilder listenerConfBuilder=createBeanBuilder(listenerConfigClass);
    fillAttributeValues(listenerNode,listenerConfBuilder,implementationAttr);
    Node implementationNode=null;
    if ((implementationNode=listenerNode.getAttributes().getNamedItem(implementationAttr)) != null) {
      listenerConfBuilder.addPropertyReference(implementationAttr,getValue(implementationNode));
    }
    listeners.add(listenerConfBuilder.getBeanDefinition());
  }
  return listeners;
}",0.984375
49597,"public void handleMap(Node node){
  BeanDefinitionBuilder mapConfigBuilder=createBeanBuilder(MapConfig.class);
  final AbstractBeanDefinition beanDefinition=mapConfigBuilder.getBeanDefinition();
  final Node attName=node.getAttributes().getNamedItem(""String_Node_Str"");
  final String name=getValue(attName);
  mapConfigBuilder.addPropertyValue(""String_Node_Str"",name);
  fillAttributeValues(node,mapConfigBuilder,""String_Node_Str"",""String_Node_Str"");
  final BeanDefinitionBuilder maxSizeConfigBuilder=createBeanBuilder(MaxSizeConfig.class);
  final AbstractBeanDefinition maxSizeConfigBeanDefinition=maxSizeConfigBuilder.getBeanDefinition();
  mapConfigBuilder.addPropertyValue(""String_Node_Str"",maxSizeConfigBeanDefinition);
  final Node maxSizeNode=node.getAttributes().getNamedItem(""String_Node_Str"");
  if (maxSizeNode != null) {
    maxSizeConfigBuilder.addPropertyValue(""String_Node_Str"",getValue(maxSizeNode));
  }
  final Node maxSizePolicyNode=node.getAttributes().getNamedItem(""String_Node_Str"");
  if (maxSizePolicyNode != null) {
    maxSizeConfigBuilder.addPropertyValue(xmlToJavaName(cleanNodeName(maxSizePolicyNode)),getValue(maxSizePolicyNode));
  }
  for (  org.w3c.dom.Node childNode : new IterableNodeList(node.getChildNodes(),Node.ELEMENT_NODE)) {
    final String nodeName=cleanNodeName(childNode.getNodeName());
    if (""String_Node_Str"".equals(nodeName)) {
      handleMapStoreConfig(childNode,mapConfigBuilder);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleNearCacheConfig(childNode,mapConfigBuilder);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      final BeanDefinitionBuilder wanReplicationRefBuilder=createBeanBuilder(WanReplicationRef.class);
      final AbstractBeanDefinition wanReplicationRefBeanDefinition=wanReplicationRefBuilder.getBeanDefinition();
      fillValues(childNode,wanReplicationRefBuilder);
      mapConfigBuilder.addPropertyValue(""String_Node_Str"",wanReplicationRefBeanDefinition);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      ManagedList indexes=new ManagedList();
      for (      Node indexNode : new IterableNodeList(childNode.getChildNodes(),Node.ELEMENT_NODE)) {
        final BeanDefinitionBuilder indexConfBuilder=createBeanBuilder(MapIndexConfig.class);
        fillAttributeValues(indexNode,indexConfBuilder);
        indexes.add(indexConfBuilder.getBeanDefinition());
      }
      mapConfigBuilder.addPropertyValue(""String_Node_Str"",indexes);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      ManagedList listeners=parseListeners(childNode,""String_Node_Str"",EntryListenerConfig.class);
      mapConfigBuilder.addPropertyValue(""String_Node_Str"",listeners);
    }
  }
  mapConfigManagedMap.put(name,beanDefinition);
}","public void handleMap(Node node){
  BeanDefinitionBuilder mapConfigBuilder=createBeanBuilder(MapConfig.class);
  final AbstractBeanDefinition beanDefinition=mapConfigBuilder.getBeanDefinition();
  final Node attName=node.getAttributes().getNamedItem(""String_Node_Str"");
  final String name=getValue(attName);
  mapConfigBuilder.addPropertyValue(""String_Node_Str"",name);
  fillAttributeValues(node,mapConfigBuilder,""String_Node_Str"",""String_Node_Str"");
  final BeanDefinitionBuilder maxSizeConfigBuilder=createBeanBuilder(MaxSizeConfig.class);
  final AbstractBeanDefinition maxSizeConfigBeanDefinition=maxSizeConfigBuilder.getBeanDefinition();
  mapConfigBuilder.addPropertyValue(""String_Node_Str"",maxSizeConfigBeanDefinition);
  final Node maxSizeNode=node.getAttributes().getNamedItem(""String_Node_Str"");
  if (maxSizeNode != null) {
    maxSizeConfigBuilder.addPropertyValue(""String_Node_Str"",getValue(maxSizeNode));
  }
  final Node maxSizePolicyNode=node.getAttributes().getNamedItem(""String_Node_Str"");
  if (maxSizePolicyNode != null) {
    maxSizeConfigBuilder.addPropertyValue(xmlToJavaName(cleanNodeName(maxSizePolicyNode)),getValue(maxSizePolicyNode));
  }
  for (  org.w3c.dom.Node childNode : new IterableNodeList(node.getChildNodes(),Node.ELEMENT_NODE)) {
    final String nodeName=cleanNodeName(childNode.getNodeName());
    if (""String_Node_Str"".equals(nodeName)) {
      handleMapStoreConfig(childNode,mapConfigBuilder);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleNearCacheConfig(childNode,mapConfigBuilder);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      final BeanDefinitionBuilder wanReplicationRefBuilder=createBeanBuilder(WanReplicationRef.class);
      final AbstractBeanDefinition wanReplicationRefBeanDefinition=wanReplicationRefBuilder.getBeanDefinition();
      fillValues(childNode,wanReplicationRefBuilder);
      mapConfigBuilder.addPropertyValue(""String_Node_Str"",wanReplicationRefBeanDefinition);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      ManagedList indexes=new ManagedList();
      for (      Node indexNode : new IterableNodeList(childNode.getChildNodes(),Node.ELEMENT_NODE)) {
        final BeanDefinitionBuilder indexConfBuilder=createBeanBuilder(MapIndexConfig.class);
        fillAttributeValues(indexNode,indexConfBuilder);
        indexes.add(indexConfBuilder.getBeanDefinition());
      }
      mapConfigBuilder.addPropertyValue(""String_Node_Str"",indexes);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      ManagedList listeners=parseListeners(childNode,EntryListenerConfig.class);
      mapConfigBuilder.addPropertyValue(""String_Node_Str"",listeners);
    }
  }
  mapConfigManagedMap.put(name,beanDefinition);
}",0.9967177242888404
49598,"public void handleQueue(Node node){
  BeanDefinitionBuilder queueConfigBuilder=createBeanBuilder(QueueConfig.class);
  final Node attName=node.getAttributes().getNamedItem(""String_Node_Str"");
  final String name=getValue(attName);
  fillAttributeValues(node,queueConfigBuilder);
  for (  org.w3c.dom.Node childNode : new IterableNodeList(node.getChildNodes(),Node.ELEMENT_NODE)) {
    if (""String_Node_Str"".equals(cleanNodeName(childNode))) {
      ManagedList listeners=parseListeners(childNode,""String_Node_Str"",ItemListenerConfig.class);
      queueConfigBuilder.addPropertyValue(""String_Node_Str"",listeners);
    }
  }
  queueManagedMap.put(name,queueConfigBuilder.getBeanDefinition());
}","public void handleQueue(Node node){
  BeanDefinitionBuilder queueConfigBuilder=createBeanBuilder(QueueConfig.class);
  final Node attName=node.getAttributes().getNamedItem(""String_Node_Str"");
  final String name=getValue(attName);
  fillAttributeValues(node,queueConfigBuilder);
  for (  org.w3c.dom.Node childNode : new IterableNodeList(node.getChildNodes(),Node.ELEMENT_NODE)) {
    if (""String_Node_Str"".equals(cleanNodeName(childNode))) {
      ManagedList listeners=parseListeners(childNode,ItemListenerConfig.class);
      queueConfigBuilder.addPropertyValue(""String_Node_Str"",listeners);
    }
  }
  queueManagedMap.put(name,queueConfigBuilder.getBeanDefinition());
}",0.8857979502196194
49599,"public void handleTopic(Node node){
  BeanDefinitionBuilder topicConfigBuilder=createBeanBuilder(TopicConfig.class);
  final Node attName=node.getAttributes().getNamedItem(""String_Node_Str"");
  final String name=getValue(attName);
  fillAttributeValues(node,topicConfigBuilder);
  for (  org.w3c.dom.Node childNode : new IterableNodeList(node.getChildNodes(),Node.ELEMENT_NODE)) {
    if (""String_Node_Str"".equals(cleanNodeName(childNode))) {
      ManagedList listeners=parseListeners(childNode,""String_Node_Str"",ListenerConfig.class);
      topicConfigBuilder.addPropertyValue(""String_Node_Str"",listeners);
    }
  }
  topicManagedMap.put(name,topicConfigBuilder.getBeanDefinition());
}","public void handleTopic(Node node){
  BeanDefinitionBuilder topicConfigBuilder=createBeanBuilder(TopicConfig.class);
  final Node attName=node.getAttributes().getNamedItem(""String_Node_Str"");
  final String name=getValue(attName);
  fillAttributeValues(node,topicConfigBuilder);
  for (  org.w3c.dom.Node childNode : new IterableNodeList(node.getChildNodes(),Node.ELEMENT_NODE)) {
    if (""String_Node_Str"".equals(cleanNodeName(childNode))) {
      ManagedList listeners=parseListeners(childNode,ListenerConfig.class);
      topicConfigBuilder.addPropertyValue(""String_Node_Str"",listeners);
    }
  }
  topicManagedMap.put(name,topicConfigBuilder.getBeanDefinition());
}",0.7717231222385862
49600,"public void handleMultiMap(Node node){
  BeanDefinitionBuilder multiMapConfigBuilder=createBeanBuilder(MultiMapConfig.class);
  final Node attName=node.getAttributes().getNamedItem(""String_Node_Str"");
  final String name=getValue(attName);
  fillAttributeValues(node,multiMapConfigBuilder);
  for (  org.w3c.dom.Node childNode : new IterableNodeList(node.getChildNodes(),Node.ELEMENT_NODE)) {
    if (""String_Node_Str"".equals(cleanNodeName(childNode))) {
      ManagedList listeners=parseListeners(childNode,""String_Node_Str"",EntryListenerConfig.class);
      multiMapConfigBuilder.addPropertyValue(""String_Node_Str"",listeners);
    }
  }
  multiMapManagedMap.put(name,multiMapConfigBuilder.getBeanDefinition());
}","public void handleMultiMap(Node node){
  BeanDefinitionBuilder multiMapConfigBuilder=createBeanBuilder(MultiMapConfig.class);
  final Node attName=node.getAttributes().getNamedItem(""String_Node_Str"");
  final String name=getValue(attName);
  fillAttributeValues(node,multiMapConfigBuilder);
  for (  org.w3c.dom.Node childNode : new IterableNodeList(node.getChildNodes(),Node.ELEMENT_NODE)) {
    if (""String_Node_Str"".equals(cleanNodeName(childNode))) {
      ManagedList listeners=parseListeners(childNode,EntryListenerConfig.class);
      multiMapConfigBuilder.addPropertyValue(""String_Node_Str"",listeners);
    }
  }
  multiMapManagedMap.put(name,multiMapConfigBuilder.getBeanDefinition());
}",0.7602836879432624
49601,"public void handleConfig(final Element element){
  handleCommonBeanAttributes(element,configBuilder,parserContext);
  for (  org.w3c.dom.Node node : new IterableNodeList(element,Node.ELEMENT_NODE)) {
    final String nodeName=cleanNodeName(node.getNodeName());
    if (""String_Node_Str"".equals(nodeName)) {
      handleNetwork(node);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleGroup(node);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleProperties(node);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleExecutor(node);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleQueue(node);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleMap(node);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleMultiMap(node);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleTopic(node);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleMergePolicies(node);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleWanReplication(node);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handlePartitionGroup(node);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleSecurity(node);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      configBuilder.addPropertyValue(xmlToJavaName(nodeName),getValue(node));
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      final List listeners=parseListeners(node,""String_Node_Str"",ListenerConfig.class);
      configBuilder.addPropertyValue(""String_Node_Str"",listeners);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      configBuilder.addPropertyValue(xmlToJavaName(nodeName),getValue(node));
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      configBuilder.addPropertyValue(xmlToJavaName(nodeName),getValue(node));
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleManagementCenter(node);
    }
  }
}","public void handleConfig(final Element element){
  handleCommonBeanAttributes(element,configBuilder,parserContext);
  for (  org.w3c.dom.Node node : new IterableNodeList(element,Node.ELEMENT_NODE)) {
    final String nodeName=cleanNodeName(node.getNodeName());
    if (""String_Node_Str"".equals(nodeName)) {
      handleNetwork(node);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleGroup(node);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleProperties(node);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleExecutor(node);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleQueue(node);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleMap(node);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleMultiMap(node);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleTopic(node);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleMergePolicies(node);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleWanReplication(node);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handlePartitionGroup(node);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleSecurity(node);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      configBuilder.addPropertyValue(xmlToJavaName(nodeName),getValue(node));
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      final List listeners=parseListeners(node,ListenerConfig.class);
      configBuilder.addPropertyValue(""String_Node_Str"",listeners);
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      configBuilder.addPropertyValue(xmlToJavaName(nodeName),getValue(node));
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      configBuilder.addPropertyValue(xmlToJavaName(nodeName),getValue(node));
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      handleManagementCenter(node);
    }
  }
}",0.9955044955044956
49602,"private void initializeListeners(){
  final TopicConfig topicConfig=node.config.findMatchingTopicConfig(name);
  for (  ListenerConfig lc : topicConfig.getMessageListenerConfigs()) {
    try {
      node.listenerManager.createAndAddListenerItem(name,lc,InstanceType.TOPIC);
      for (      MemberImpl member : node.clusterManager.getMembers()) {
        addListener(member.getAddress(),true);
      }
    }
 catch (    Exception e) {
      logger.log(Level.SEVERE,e.getMessage(),e);
    }
  }
}","private void initializeListeners(){
  for (  ListenerConfig lc : topicConfig.getMessageListenerConfigs()) {
    try {
      node.listenerManager.createAndAddListenerItem(name,lc,InstanceType.TOPIC);
      for (      MemberImpl member : node.clusterManager.getMembers()) {
        addListener(member.getAddress(),true);
      }
    }
 catch (    Exception e) {
      logger.log(Level.SEVERE,e.getMessage(),e);
    }
  }
}",0.918032786885246
49603,"public TopicInstance(final TopicManager topicManager,final String name){
  if (topicManager == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (name == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  this.topicManager=topicManager;
  this.name=name;
  initializeListeners();
}","public TopicInstance(final TopicManager topicManager,final String name){
  if (topicManager == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  if (name == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  this.topicManager=topicManager;
  this.name=name;
  String shortName=name.substring(Prefix.TOPIC.length());
  topicConfig=node.config.findMatchingTopicConfig(shortName);
  initializeListeners();
}",0.84251968503937
49604,"public void run(){
  assertFalse(lock.tryLock());
  unlockLatch.countDown();
  try {
    assertTrue(lock.tryLock(10,TimeUnit.SECONDS));
  }
 catch (  InterruptedException e) {
    throw new RuntimeException(e);
  }
  latch.countDown();
}","public void run(){
  assertTrue(lock.isLocked());
  try {
    while (lock.isLocked()) {
      Thread.sleep(100);
    }
  }
 catch (  InterruptedException e) {
    throw new RuntimeException(e);
  }
  latch.countDown();
}",0.612691466083151
49605,"public void run(){
  if (!map.tryLock(""String_Node_Str"",100,TimeUnit.MILLISECONDS)) {
    latch.countDown();
  }
  if (!map.tryLock(""String_Node_Str"")) {
    latch.countDown();
  }
  if (map.tryLock(""String_Node_Str"")) {
    latch.countDown();
  }
}","public void run(){
  assertTrue(map.isLocked(""String_Node_Str""));
  try {
    while (map.isLocked(""String_Node_Str"")) {
      Thread.sleep(100);
    }
  }
 catch (  InterruptedException e) {
    throw new RuntimeException(e);
  }
  latch.countDown();
}",0.2315369261477046
49606,"boolean startCleanup(boolean forced){
  final long now=Clock.currentTimeMillis();
  long dirtyAge=(now - lastCleanup);
  boolean shouldRun=forced || (store != null && dirty && dirtyAge >= writeDelayMillis) || (dirtyAge > cleanupDelayMillis);
  if (shouldRun && cleanupActive.compareAndSet(false,true)) {
    lastCleanup=now;
    try {
      if (nearCache != null) {
        nearCache.evict(now,false);
      }
      dirty=false;
      final Set<Record> recordsDirty=new HashSet<Record>();
      final Set<Record> recordsUnknown=new HashSet<Record>();
      final Set<Record> recordsToPurge=new HashSet<Record>();
      final Set<Record> recordsToEvict=new HashSet<Record>();
      final Set<Record> sortedRecords=new TreeSet<Record>(new ComparatorWrapper(evictionComparator));
      final Collection<Record> records=mapRecords.values();
      final boolean overCapacity=overCapacity();
      final boolean evictionAware=evictionComparator != null && overCapacity;
      int recordsStillOwned=0;
      int backupPurgeCount=0;
      long costOfRecords=0L;
      PartitionManager partitionManager=concurrentMapManager.partitionManager;
      for (      Record record : records) {
        PartitionInfo partition=partitionManager.getPartition(record.getBlockId());
        Address owner=partition.getOwner();
        boolean owned=(owner != null && thisAddress.equals(owner));
        boolean ownedOrBackup=partition.isOwnerOrBackup(thisAddress,getTotalBackupCount());
        if (owner != null && !partitionManager.isPartitionMigrating(partition.getPartitionId())) {
          if (owned) {
            if (store != null && mapStoreWrapper.isEnabled() && writeDelayMillis > 0 && record.isDirty()) {
              if (now > record.getWriteTime()) {
                recordsDirty.add(record);
                record.setDirty(false);
              }
 else {
                dirty=true;
              }
            }
 else             if (shouldPurgeRecord(record,now)) {
              recordsToPurge.add(record);
            }
 else             if (record.isActive() && !record.isValid(now)) {
              recordsToEvict.add(record);
            }
 else             if (evictionAware && record.isActive() && record.isEvictable()) {
              sortedRecords.add(record);
              recordsStillOwned++;
            }
            if (record.isActive() && record.isValid(now)) {
              costOfRecords+=record.getCost();
            }
          }
 else           if (ownedOrBackup) {
            if (shouldPurgeRecord(record,now)) {
              recordsToPurge.add(record);
              backupPurgeCount++;
            }
          }
 else {
            recordsUnknown.add(record);
          }
        }
      }
      totalCostOfRecords=costOfRecords;
      if (evictionAware && (forced || overCapacity)) {
        int numberOfRecordsToEvict=(int)(recordsStillOwned * evictionRate);
        int evictedCount=0;
        for (        Record record : sortedRecords) {
          if (record.isActive() && record.isEvictable()) {
            recordsToEvict.add(record);
            if (++evictedCount >= numberOfRecordsToEvict) {
              break;
            }
          }
        }
      }
      Level levelLog=(concurrentMapManager.LOG_STATE) ? Level.INFO : Level.FINEST;
      if (logger.isLoggable(levelLog)) {
        logger.log(levelLog,name + ""String_Node_Str"" + ""String_Node_Str""+ recordsDirty.size()+ ""String_Node_Str""+ recordsToPurge.size()+ ""String_Node_Str""+ recordsToEvict.size()+ ""String_Node_Str""+ recordsUnknown.size()+ ""String_Node_Str""+ recordsStillOwned+ ""String_Node_Str""+ backupPurgeCount);
        logger.log(levelLog,thisAddress + ""String_Node_Str"" + mapRecords.size()+ ""String_Node_Str""+ mapIndexService.getOwnedRecords().size()+ ""String_Node_Str""+ costOfRecords);
      }
      executeStoreUpdate(recordsDirty);
      executeEviction(recordsToEvict);
      executePurge(recordsToPurge);
      executePurgeUnknowns(recordsUnknown);
    }
  finally {
      cleanupActive.set(false);
    }
    return true;
  }
 else {
    return false;
  }
}","boolean startCleanup(boolean forced){
  final long now=Clock.currentTimeMillis();
  long dirtyAge=(now - lastCleanup);
  boolean shouldRun=forced || (store != null && mapStoreWrapper.isEnabled() && dirty && dirtyAge >= writeDelayMillis) || (dirtyAge > cleanupDelayMillis);
  if (shouldRun && cleanupActive.compareAndSet(false,true)) {
    lastCleanup=now;
    try {
      if (nearCache != null) {
        nearCache.evict(now,false);
      }
      dirty=false;
      final Set<Record> recordsDirty=new HashSet<Record>();
      final Set<Record> recordsUnknown=new HashSet<Record>();
      final Set<Record> recordsToPurge=new HashSet<Record>();
      final Set<Record> recordsToEvict=new HashSet<Record>();
      final Set<Record> sortedRecords=new TreeSet<Record>(new ComparatorWrapper(evictionComparator));
      final Collection<Record> records=mapRecords.values();
      final boolean overCapacity=overCapacity();
      final boolean evictionAware=evictionComparator != null && overCapacity;
      int recordsStillOwned=0;
      int backupPurgeCount=0;
      long costOfRecords=0L;
      PartitionManager partitionManager=concurrentMapManager.partitionManager;
      for (      Record record : records) {
        PartitionInfo partition=partitionManager.getPartition(record.getBlockId());
        Address owner=partition.getOwner();
        boolean owned=(owner != null && thisAddress.equals(owner));
        boolean ownedOrBackup=partition.isOwnerOrBackup(thisAddress,getTotalBackupCount());
        if (owner != null && !partitionManager.isPartitionMigrating(partition.getPartitionId())) {
          if (owned) {
            if (store != null && mapStoreWrapper.isEnabled() && writeDelayMillis > 0 && record.isDirty()) {
              if (now > record.getWriteTime()) {
                recordsDirty.add(record);
                record.setDirty(false);
              }
 else {
                dirty=true;
              }
            }
 else             if (shouldPurgeRecord(record,now)) {
              recordsToPurge.add(record);
            }
 else             if (record.isActive() && !record.isValid(now)) {
              recordsToEvict.add(record);
            }
 else             if (evictionAware && record.isActive() && record.isEvictable()) {
              sortedRecords.add(record);
              recordsStillOwned++;
            }
            if (record.isActive() && record.isValid(now)) {
              costOfRecords+=record.getCost();
            }
          }
 else           if (ownedOrBackup) {
            if (shouldPurgeRecord(record,now)) {
              recordsToPurge.add(record);
              backupPurgeCount++;
            }
          }
 else {
            recordsUnknown.add(record);
          }
        }
      }
      totalCostOfRecords=costOfRecords;
      if (evictionAware && (forced || overCapacity)) {
        int numberOfRecordsToEvict=(int)(recordsStillOwned * evictionRate);
        int evictedCount=0;
        for (        Record record : sortedRecords) {
          if (record.isActive() && record.isEvictable()) {
            recordsToEvict.add(record);
            if (++evictedCount >= numberOfRecordsToEvict) {
              break;
            }
          }
        }
      }
      Level levelLog=(concurrentMapManager.LOG_STATE) ? Level.INFO : Level.FINEST;
      if (logger.isLoggable(levelLog)) {
        logger.log(levelLog,name + ""String_Node_Str"" + ""String_Node_Str""+ recordsDirty.size()+ ""String_Node_Str""+ recordsToPurge.size()+ ""String_Node_Str""+ recordsToEvict.size()+ ""String_Node_Str""+ recordsUnknown.size()+ ""String_Node_Str""+ recordsStillOwned+ ""String_Node_Str""+ backupPurgeCount);
        logger.log(levelLog,thisAddress + ""String_Node_Str"" + mapRecords.size()+ ""String_Node_Str""+ mapIndexService.getOwnedRecords().size()+ ""String_Node_Str""+ costOfRecords);
      }
      executeStoreUpdate(recordsDirty);
      executeEviction(recordsToEvict);
      executePurge(recordsToPurge);
      executePurgeUnknowns(recordsUnknown);
    }
  finally {
      cleanupActive.set(false);
    }
    return true;
  }
 else {
    return false;
  }
}",0.9962014459012376
49607,"public ClientHandlerService(Node node){
  this.node=node;
  this.logger=node.getLogger(this.getClass().getName());
  node.getClusterImpl().addMembershipListener(new ClientServiceMembershipListener());
  registerHandler(CONCURRENT_MAP_PUT.getValue(),new MapPutHandler());
  registerHandler(CONCURRENT_MAP_PUT.getValue(),new MapPutHandler());
  registerHandler(CONCURRENT_MAP_PUT_AND_UNLOCK.getValue(),new MapPutAndUnlockHandler());
  registerHandler(CONCURRENT_MAP_PUT_ALL.getValue(),new MapPutAllHandler());
  registerHandler(CONCURRENT_MAP_PUT_MULTI.getValue(),new MapPutMultiHandler());
  registerHandler(CONCURRENT_MAP_PUT_IF_ABSENT.getValue(),new MapPutIfAbsentHandler());
  registerHandler(CONCURRENT_MAP_PUT_TRANSIENT.getValue(),new MapPutTransientHandler());
  registerHandler(CONCURRENT_MAP_SET.getValue(),new MapSetHandler());
  registerHandler(CONCURRENT_MAP_TRY_PUT.getValue(),new MapTryPutHandler());
  registerHandler(CONCURRENT_MAP_GET.getValue(),new MapGetHandler());
  registerHandler(CONCURRENT_MAP_GET_ALL.getValue(),new MapGetAllHandler());
  registerHandler(CONCURRENT_MAP_REMOVE.getValue(),new MapRemoveHandler());
  registerHandler(CONCURRENT_MAP_TRY_REMOVE.getValue(),new MapTryRemoveHandler());
  registerHandler(CONCURRENT_MAP_REMOVE_IF_SAME.getValue(),new MapRemoveIfSameHandler());
  registerHandler(CONCURRENT_MAP_REMOVE_MULTI.getValue(),new MapRemoveMultiHandler());
  registerHandler(CONCURRENT_MAP_EVICT.getValue(),new MapEvictHandler());
  registerHandler(CONCURRENT_MAP_FLUSH.getValue(),new MapFlushHandler());
  registerHandler(CONCURRENT_MAP_REPLACE_IF_NOT_NULL.getValue(),new MapReplaceIfNotNullHandler());
  registerHandler(CONCURRENT_MAP_REPLACE_IF_SAME.getValue(),new MapReplaceIfSameHandler());
  registerHandler(CONCURRENT_MAP_SIZE.getValue(),new MapSizeHandler());
  registerHandler(CONCURRENT_MAP_GET_MAP_ENTRY.getValue(),new GetMapEntryHandler());
  registerHandler(CONCURRENT_MAP_TRY_LOCK_AND_GET.getValue(),new MapTryLockAndGetHandler());
  registerHandler(CONCURRENT_MAP_LOCK.getValue(),new MapLockHandler());
  registerHandler(CONCURRENT_MAP_UNLOCK.getValue(),new MapUnlockHandler());
  registerHandler(CONCURRENT_MAP_FORCE_UNLOCK.getValue(),new MapForceUnlockHandler());
  registerHandler(CONCURRENT_MAP_LOCK_MAP.getValue(),new MapLockMapHandler());
  registerHandler(CONCURRENT_MAP_UNLOCK_MAP.getValue(),new MapUnlockMapHandler());
  registerHandler(CONCURRENT_MAP_CONTAINS_KEY.getValue(),new MapContainsHandler());
  registerHandler(CONCURRENT_MAP_CONTAINS_VALUE.getValue(),new MapContainsValueHandler());
  registerHandler(CONCURRENT_MAP_ADD_TO_LIST.getValue(),new ListAddHandler());
  registerHandler(CONCURRENT_MAP_ADD_TO_SET.getValue(),new SetAddHandler());
  registerHandler(CONCURRENT_MAP_REMOVE_ITEM.getValue(),new MapItemRemoveHandler());
  registerHandler(CONCURRENT_MAP_ITERATE_KEYS.getValue(),new MapIterateKeysHandler());
  registerHandler(CONCURRENT_MAP_ITERATE_ENTRIES.getValue(),new MapIterateEntriesHandler());
  registerHandler(CONCURRENT_MAP_VALUE_COUNT.getValue(),new MapValueCountHandler());
  registerHandler(TOPIC_PUBLISH.getValue(),new TopicPublishHandler());
  registerHandler(BLOCKING_QUEUE_OFFER.getValue(),new QueueOfferHandler());
  registerHandler(BLOCKING_QUEUE_POLL.getValue(),new QueuePollHandler());
  registerHandler(BLOCKING_QUEUE_REMOVE.getValue(),new QueueRemoveHandler());
  registerHandler(BLOCKING_QUEUE_PEEK.getValue(),new QueuePeekHandler());
  registerHandler(BLOCKING_QUEUE_SIZE.getValue(),new QueueSizeHandler());
  registerHandler(BLOCKING_QUEUE_REMAINING_CAPACITY.getValue(),new QueueRemainingCapacityHandler());
  registerHandler(BLOCKING_QUEUE_ENTRIES.getValue(),new QueueEntriesHandler());
  registerHandler(TRANSACTION_BEGIN.getValue(),new TransactionBeginHandler());
  registerHandler(TRANSACTION_COMMIT.getValue(),new TransactionCommitHandler());
  registerHandler(TRANSACTION_ROLLBACK.getValue(),new TransactionRollbackHandler());
  registerHandler(ADD_LISTENER.getValue(),new AddListenerHandler());
  registerHandler(REMOVE_LISTENER.getValue(),new RemoveListenerHandler());
  registerHandler(REMOTELY_PROCESS.getValue(),new RemotelyProcessHandler());
  registerHandler(DESTROY.getValue(),new DestroyHandler());
  registerHandler(GET_ID.getValue(),new GetIdHandler());
  registerHandler(ADD_INDEX.getValue(),new AddIndexHandler());
  registerHandler(NEW_ID.getValue(),new NewIdHandler());
  registerHandler(EXECUTE.getValue(),new ExecutorServiceHandler());
  registerHandler(CANCEL_EXECUTION.getValue(),new CancelExecutionHandler());
  registerHandler(GET_INSTANCES.getValue(),new GetInstancesHandler());
  registerHandler(GET_MEMBERS.getValue(),new GetMembersHandler());
  registerHandler(GET_CLUSTER_TIME.getValue(),new GetClusterTimeHandler());
  registerHandler(CLIENT_AUTHENTICATE.getValue(),new ClientAuthenticateHandler());
  registerHandler(CLIENT_ADD_INSTANCE_LISTENER.getValue(),new ClientAddInstanceListenerHandler());
  registerHandler(CLIENT_GET_PARTITIONS.getValue(),new GetPartitionsHandler());
  registerHandler(ATOMIC_NUMBER_ADD_AND_GET.getValue(),new AtomicLongAddAndGetHandler());
  registerHandler(ATOMIC_NUMBER_COMPARE_AND_SET.getValue(),new AtomicLongCompareAndSetHandler());
  registerHandler(ATOMIC_NUMBER_GET_AND_SET.getValue(),new AtomicLongGetAndSetHandler());
  registerHandler(ATOMIC_NUMBER_GET_AND_ADD.getValue(),new AtomicLongGetAndAddHandler());
  registerHandler(COUNT_DOWN_LATCH_AWAIT.getValue(),new CountDownLatchAwaitHandler());
  registerHandler(COUNT_DOWN_LATCH_COUNT_DOWN.getValue(),new CountDownLatchCountDownHandler());
  registerHandler(COUNT_DOWN_LATCH_GET_COUNT.getValue(),new CountDownLatchGetCountHandler());
  registerHandler(COUNT_DOWN_LATCH_GET_OWNER.getValue(),new CountDownLatchGetOwnerHandler());
  registerHandler(COUNT_DOWN_LATCH_SET_COUNT.getValue(),new CountDownLatchSetCountHandler());
  registerHandler(SEMAPHORE_ATTACH_DETACH_PERMITS.getValue(),new SemaphoreAttachDetachHandler());
  registerHandler(SEMAPHORE_CANCEL_ACQUIRE.getValue(),new SemaphoreCancelAcquireHandler());
  registerHandler(SEMAPHORE_DRAIN_PERMITS.getValue(),new SemaphoreDrainHandler());
  registerHandler(SEMAPHORE_GET_ATTACHED_PERMITS.getValue(),new SemaphoreGetAttachedHandler());
  registerHandler(SEMAPHORE_GET_AVAILABLE_PERMITS.getValue(),new SemaphoreGetAvailableHandler());
  registerHandler(SEMAPHORE_REDUCE_PERMITS.getValue(),new SemaphoreReduceHandler());
  registerHandler(SEMAPHORE_RELEASE.getValue(),new SemaphoreReleaseHandler());
  registerHandler(SEMAPHORE_TRY_ACQUIRE.getValue(),new SemaphoreTryAcquireHandler());
  registerHandler(LOCK_LOCK.getValue(),new LockOperationHandler());
  registerHandler(LOCK_UNLOCK.getValue(),new UnlockOperationHandler());
  registerHandler(LOCK_FORCE_UNLOCK.getValue(),new UnlockOperationHandler());
  node.connectionManager.addConnectionListener(this);
  this.THREAD_COUNT=node.getGroupProperties().EXECUTOR_CLIENT_THREAD_COUNT.getInteger();
  workers=new Worker[THREAD_COUNT];
  for (int i=0; i < THREAD_COUNT; i++) {
    workers[i]=new Worker();
  }
  this.factory=node.factory;
}","public ClientHandlerService(Node node){
  this.node=node;
  this.logger=node.getLogger(this.getClass().getName());
  node.getClusterImpl().addMembershipListener(new ClientServiceMembershipListener());
  registerHandler(CONCURRENT_MAP_PUT.getValue(),new MapPutHandler());
  registerHandler(CONCURRENT_MAP_PUT.getValue(),new MapPutHandler());
  registerHandler(CONCURRENT_MAP_PUT_AND_UNLOCK.getValue(),new MapPutAndUnlockHandler());
  registerHandler(CONCURRENT_MAP_PUT_ALL.getValue(),new MapPutAllHandler());
  registerHandler(CONCURRENT_MAP_PUT_MULTI.getValue(),new MapPutMultiHandler());
  registerHandler(CONCURRENT_MAP_PUT_IF_ABSENT.getValue(),new MapPutIfAbsentHandler());
  registerHandler(CONCURRENT_MAP_PUT_TRANSIENT.getValue(),new MapPutTransientHandler());
  registerHandler(CONCURRENT_MAP_SET.getValue(),new MapSetHandler());
  registerHandler(CONCURRENT_MAP_TRY_PUT.getValue(),new MapTryPutHandler());
  registerHandler(CONCURRENT_MAP_GET.getValue(),new MapGetHandler());
  registerHandler(CONCURRENT_MAP_GET_ALL.getValue(),new MapGetAllHandler());
  registerHandler(CONCURRENT_MAP_REMOVE.getValue(),new MapRemoveHandler());
  registerHandler(CONCURRENT_MAP_TRY_REMOVE.getValue(),new MapTryRemoveHandler());
  registerHandler(CONCURRENT_MAP_REMOVE_IF_SAME.getValue(),new MapRemoveIfSameHandler());
  registerHandler(CONCURRENT_MAP_REMOVE_MULTI.getValue(),new MapRemoveMultiHandler());
  registerHandler(CONCURRENT_MAP_EVICT.getValue(),new MapEvictHandler());
  registerHandler(CONCURRENT_MAP_FLUSH.getValue(),new MapFlushHandler());
  registerHandler(CONCURRENT_MAP_REPLACE_IF_NOT_NULL.getValue(),new MapReplaceIfNotNullHandler());
  registerHandler(CONCURRENT_MAP_REPLACE_IF_SAME.getValue(),new MapReplaceIfSameHandler());
  registerHandler(CONCURRENT_MAP_SIZE.getValue(),new MapSizeHandler());
  registerHandler(CONCURRENT_MAP_GET_MAP_ENTRY.getValue(),new GetMapEntryHandler());
  registerHandler(CONCURRENT_MAP_TRY_LOCK_AND_GET.getValue(),new MapTryLockAndGetHandler());
  registerHandler(CONCURRENT_MAP_LOCK.getValue(),new MapLockHandler());
  registerHandler(CONCURRENT_MAP_IS_KEY_LOCKED.getValue(),new MapIsKeyLockedHandler());
  registerHandler(CONCURRENT_MAP_UNLOCK.getValue(),new MapUnlockHandler());
  registerHandler(CONCURRENT_MAP_FORCE_UNLOCK.getValue(),new MapForceUnlockHandler());
  registerHandler(CONCURRENT_MAP_LOCK_MAP.getValue(),new MapLockMapHandler());
  registerHandler(CONCURRENT_MAP_UNLOCK_MAP.getValue(),new MapUnlockMapHandler());
  registerHandler(CONCURRENT_MAP_CONTAINS_KEY.getValue(),new MapContainsHandler());
  registerHandler(CONCURRENT_MAP_CONTAINS_VALUE.getValue(),new MapContainsValueHandler());
  registerHandler(CONCURRENT_MAP_ADD_TO_LIST.getValue(),new ListAddHandler());
  registerHandler(CONCURRENT_MAP_ADD_TO_SET.getValue(),new SetAddHandler());
  registerHandler(CONCURRENT_MAP_REMOVE_ITEM.getValue(),new MapItemRemoveHandler());
  registerHandler(CONCURRENT_MAP_ITERATE_KEYS.getValue(),new MapIterateKeysHandler());
  registerHandler(CONCURRENT_MAP_ITERATE_ENTRIES.getValue(),new MapIterateEntriesHandler());
  registerHandler(CONCURRENT_MAP_VALUE_COUNT.getValue(),new MapValueCountHandler());
  registerHandler(TOPIC_PUBLISH.getValue(),new TopicPublishHandler());
  registerHandler(BLOCKING_QUEUE_OFFER.getValue(),new QueueOfferHandler());
  registerHandler(BLOCKING_QUEUE_POLL.getValue(),new QueuePollHandler());
  registerHandler(BLOCKING_QUEUE_REMOVE.getValue(),new QueueRemoveHandler());
  registerHandler(BLOCKING_QUEUE_PEEK.getValue(),new QueuePeekHandler());
  registerHandler(BLOCKING_QUEUE_SIZE.getValue(),new QueueSizeHandler());
  registerHandler(BLOCKING_QUEUE_REMAINING_CAPACITY.getValue(),new QueueRemainingCapacityHandler());
  registerHandler(BLOCKING_QUEUE_ENTRIES.getValue(),new QueueEntriesHandler());
  registerHandler(TRANSACTION_BEGIN.getValue(),new TransactionBeginHandler());
  registerHandler(TRANSACTION_COMMIT.getValue(),new TransactionCommitHandler());
  registerHandler(TRANSACTION_ROLLBACK.getValue(),new TransactionRollbackHandler());
  registerHandler(ADD_LISTENER.getValue(),new AddListenerHandler());
  registerHandler(REMOVE_LISTENER.getValue(),new RemoveListenerHandler());
  registerHandler(REMOTELY_PROCESS.getValue(),new RemotelyProcessHandler());
  registerHandler(DESTROY.getValue(),new DestroyHandler());
  registerHandler(GET_ID.getValue(),new GetIdHandler());
  registerHandler(ADD_INDEX.getValue(),new AddIndexHandler());
  registerHandler(NEW_ID.getValue(),new NewIdHandler());
  registerHandler(EXECUTE.getValue(),new ExecutorServiceHandler());
  registerHandler(CANCEL_EXECUTION.getValue(),new CancelExecutionHandler());
  registerHandler(GET_INSTANCES.getValue(),new GetInstancesHandler());
  registerHandler(GET_MEMBERS.getValue(),new GetMembersHandler());
  registerHandler(GET_CLUSTER_TIME.getValue(),new GetClusterTimeHandler());
  registerHandler(CLIENT_AUTHENTICATE.getValue(),new ClientAuthenticateHandler());
  registerHandler(CLIENT_ADD_INSTANCE_LISTENER.getValue(),new ClientAddInstanceListenerHandler());
  registerHandler(CLIENT_GET_PARTITIONS.getValue(),new GetPartitionsHandler());
  registerHandler(ATOMIC_NUMBER_ADD_AND_GET.getValue(),new AtomicLongAddAndGetHandler());
  registerHandler(ATOMIC_NUMBER_COMPARE_AND_SET.getValue(),new AtomicLongCompareAndSetHandler());
  registerHandler(ATOMIC_NUMBER_GET_AND_SET.getValue(),new AtomicLongGetAndSetHandler());
  registerHandler(ATOMIC_NUMBER_GET_AND_ADD.getValue(),new AtomicLongGetAndAddHandler());
  registerHandler(COUNT_DOWN_LATCH_AWAIT.getValue(),new CountDownLatchAwaitHandler());
  registerHandler(COUNT_DOWN_LATCH_COUNT_DOWN.getValue(),new CountDownLatchCountDownHandler());
  registerHandler(COUNT_DOWN_LATCH_GET_COUNT.getValue(),new CountDownLatchGetCountHandler());
  registerHandler(COUNT_DOWN_LATCH_GET_OWNER.getValue(),new CountDownLatchGetOwnerHandler());
  registerHandler(COUNT_DOWN_LATCH_SET_COUNT.getValue(),new CountDownLatchSetCountHandler());
  registerHandler(SEMAPHORE_ATTACH_DETACH_PERMITS.getValue(),new SemaphoreAttachDetachHandler());
  registerHandler(SEMAPHORE_CANCEL_ACQUIRE.getValue(),new SemaphoreCancelAcquireHandler());
  registerHandler(SEMAPHORE_DRAIN_PERMITS.getValue(),new SemaphoreDrainHandler());
  registerHandler(SEMAPHORE_GET_ATTACHED_PERMITS.getValue(),new SemaphoreGetAttachedHandler());
  registerHandler(SEMAPHORE_GET_AVAILABLE_PERMITS.getValue(),new SemaphoreGetAvailableHandler());
  registerHandler(SEMAPHORE_REDUCE_PERMITS.getValue(),new SemaphoreReduceHandler());
  registerHandler(SEMAPHORE_RELEASE.getValue(),new SemaphoreReleaseHandler());
  registerHandler(SEMAPHORE_TRY_ACQUIRE.getValue(),new SemaphoreTryAcquireHandler());
  registerHandler(LOCK_LOCK.getValue(),new LockOperationHandler());
  registerHandler(LOCK_UNLOCK.getValue(),new UnlockOperationHandler());
  registerHandler(LOCK_FORCE_UNLOCK.getValue(),new UnlockOperationHandler());
  registerHandler(LOCK_IS_LOCKED.getValue(),new IsLockedOperationHandler());
  node.connectionManager.addConnectionListener(this);
  this.THREAD_COUNT=node.getGroupProperties().EXECUTOR_CLIENT_THREAD_COUNT.getInteger();
  workers=new Worker[THREAD_COUNT];
  for (int i=0; i < THREAD_COUNT; i++) {
    workers[i]=new Worker();
  }
  this.factory=node.factory;
}",0.9884591172973352
49608,"ConcurrentMapManager(final Node node){
  super(node);
  recordFactory=node.initializer.getRecordFactory();
  storeExecutor=node.executorManager.newParallelExecutor(node.groupProperties.EXECUTOR_STORE_THREAD_COUNT.getInteger());
  evictionExecutor=node.executorManager.newParallelExecutor(node.groupProperties.EXECUTOR_STORE_THREAD_COUNT.getInteger());
  PARTITION_COUNT=node.groupProperties.CONCURRENT_MAP_PARTITION_COUNT.getInteger();
  MAX_BACKUP_COUNT=MapConfig.MAX_BACKUP_COUNT;
  int removeDelaySeconds=node.groupProperties.REMOVE_DELAY_SECONDS.getInteger();
  if (removeDelaySeconds <= 0) {
    logger.log(Level.WARNING,GroupProperties.PROP_REMOVE_DELAY_SECONDS + ""String_Node_Str"");
    removeDelaySeconds=1;
  }
  GLOBAL_REMOVE_DELAY_MILLIS=removeDelaySeconds * 1000L;
  LOG_STATE=node.groupProperties.LOG_STATE.getBoolean();
  maps=new ConcurrentHashMap<String,CMap>(10,0.75f,1);
  mapCaches=new ConcurrentHashMap<String,NearCache>(10,0.75f,1);
  partitionManager=new PartitionManager(this);
  partitionServiceImpl=new PartitionServiceImpl(this);
  node.executorManager.getScheduledExecutorService().scheduleAtFixedRate(new Runnable(){
    public void run(){
      startCleanup(true,false);
    }
  }
,1,1,TimeUnit.SECONDS);
  registerPacketProcessor(CONCURRENT_MAP_GET_MAP_ENTRY,new GetMapEntryOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_GET_DATA_RECORD_ENTRY,new GetDataRecordEntryOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_GET,new GetOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ASYNC_MERGE,new AsyncMergePacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_WAN_MERGE,new WanMergePacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_MERGE,new MergeOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_TRY_PUT,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_SET,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT_AND_UNLOCK,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT_IF_ABSENT,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REPLACE_IF_NOT_NULL,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT_TRANSIENT,new PutTransientOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REPLACE_IF_SAME,new ReplaceOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT_MULTI,new PutMultiOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE,new RemoveOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_EVICT,new EvictOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE_IF_SAME,new RemoveIfSameOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE_ITEM,new RemoveItemOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_PUT,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_PUT_AND_UNLOCK,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_ADD,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_REMOVE_MULTI,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_REMOVE,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_LOCK,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_LOCK,new LockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_TRY_LOCK_AND_GET,new LockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_UNLOCK,new UnlockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_FORCE_UNLOCK,new ForceUnlockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_LOCK_MAP,new LockMapOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_UNLOCK_MAP,new LockMapOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE_MULTI,new RemoveMultiOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ADD_TO_LIST,new AddOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ADD_TO_SET,new AddOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_CONTAINS_KEY,new ContainsKeyOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_CONTAINS_ENTRY,new ContainsEntryOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_CONTAINS_VALUE,new ContainsValueOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_VALUE_COUNT,new ValueCountOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_INVALIDATE,new InvalidateOperationHandler());
  registerPacketProcessor(ATOMIC_NUMBER_ADD_AND_GET,new AtomicNumberAddAndGetOperationHandler());
  registerPacketProcessor(ATOMIC_NUMBER_COMPARE_AND_SET,new AtomicNumberCompareAndSetOperationHandler());
  registerPacketProcessor(ATOMIC_NUMBER_GET_AND_ADD,new AtomicNumberGetAndAddOperationHandler());
  registerPacketProcessor(ATOMIC_NUMBER_GET_AND_SET,new AtomicNumberGetAndSetOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_AWAIT,new CountDownLatchAwaitOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_COUNT_DOWN,new CountDownLatchCountDownOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_DESTROY,new CountDownLatchDestroyOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_GET_COUNT,new CountDownLatchGetCountOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_GET_OWNER,new CountDownLatchGetOwnerOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_SET_COUNT,new CountDownLatchSetCountOperationHandler());
  registerPacketProcessor(SEMAPHORE_ATTACH_DETACH_PERMITS,new SemaphoreAttachDetachOperationHandler());
  registerPacketProcessor(SEMAPHORE_CANCEL_ACQUIRE,new SemaphoreCancelAcquireOperationHandler());
  registerPacketProcessor(SEMAPHORE_DESTROY,new SemaphoreDestroyOperationHandler());
  registerPacketProcessor(SEMAPHORE_DRAIN_PERMITS,new SemaphoreDrainOperationHandler());
  registerPacketProcessor(SEMAPHORE_GET_ATTACHED_PERMITS,new SemaphoreGetAttachedOperationHandler());
  registerPacketProcessor(SEMAPHORE_GET_AVAILABLE_PERMITS,new SemaphoreGetAvailableOperationHandler());
  registerPacketProcessor(SEMAPHORE_REDUCE_PERMITS,new SemaphoreReduceOperationHandler());
  registerPacketProcessor(SEMAPHORE_RELEASE,new SemaphoreReleaseOperationHandler());
  registerPacketProcessor(SEMAPHORE_TRY_ACQUIRE,new SemaphoreTryAcquireOperationHandler());
}","ConcurrentMapManager(final Node node){
  super(node);
  recordFactory=node.initializer.getRecordFactory();
  storeExecutor=node.executorManager.newParallelExecutor(node.groupProperties.EXECUTOR_STORE_THREAD_COUNT.getInteger());
  evictionExecutor=node.executorManager.newParallelExecutor(node.groupProperties.EXECUTOR_STORE_THREAD_COUNT.getInteger());
  PARTITION_COUNT=node.groupProperties.CONCURRENT_MAP_PARTITION_COUNT.getInteger();
  MAX_BACKUP_COUNT=MapConfig.MAX_BACKUP_COUNT;
  int removeDelaySeconds=node.groupProperties.REMOVE_DELAY_SECONDS.getInteger();
  if (removeDelaySeconds <= 0) {
    logger.log(Level.WARNING,GroupProperties.PROP_REMOVE_DELAY_SECONDS + ""String_Node_Str"");
    removeDelaySeconds=1;
  }
  GLOBAL_REMOVE_DELAY_MILLIS=removeDelaySeconds * 1000L;
  LOG_STATE=node.groupProperties.LOG_STATE.getBoolean();
  maps=new ConcurrentHashMap<String,CMap>(10,0.75f,1);
  mapCaches=new ConcurrentHashMap<String,NearCache>(10,0.75f,1);
  partitionManager=new PartitionManager(this);
  partitionServiceImpl=new PartitionServiceImpl(this);
  node.executorManager.getScheduledExecutorService().scheduleAtFixedRate(new Runnable(){
    public void run(){
      startCleanup(true,false);
    }
  }
,1,1,TimeUnit.SECONDS);
  registerPacketProcessor(CONCURRENT_MAP_GET_MAP_ENTRY,new GetMapEntryOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_GET_DATA_RECORD_ENTRY,new GetDataRecordEntryOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_GET,new GetOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ASYNC_MERGE,new AsyncMergePacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_WAN_MERGE,new WanMergePacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_MERGE,new MergeOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_TRY_PUT,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_SET,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT_AND_UNLOCK,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT_IF_ABSENT,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REPLACE_IF_NOT_NULL,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT_TRANSIENT,new PutTransientOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REPLACE_IF_SAME,new ReplaceOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT_MULTI,new PutMultiOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE,new RemoveOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_EVICT,new EvictOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE_IF_SAME,new RemoveIfSameOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE_ITEM,new RemoveItemOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_PUT,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_PUT_AND_UNLOCK,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_ADD,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_REMOVE_MULTI,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_REMOVE,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_LOCK,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_LOCK,new LockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_IS_KEY_LOCKED,new IsKeyLockedOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_TRY_LOCK_AND_GET,new LockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_UNLOCK,new UnlockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_FORCE_UNLOCK,new ForceUnlockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_LOCK_MAP,new LockMapOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_UNLOCK_MAP,new LockMapOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE_MULTI,new RemoveMultiOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ADD_TO_LIST,new AddOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ADD_TO_SET,new AddOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_CONTAINS_KEY,new ContainsKeyOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_CONTAINS_ENTRY,new ContainsEntryOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_CONTAINS_VALUE,new ContainsValueOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_VALUE_COUNT,new ValueCountOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_INVALIDATE,new InvalidateOperationHandler());
  registerPacketProcessor(ATOMIC_NUMBER_ADD_AND_GET,new AtomicNumberAddAndGetOperationHandler());
  registerPacketProcessor(ATOMIC_NUMBER_COMPARE_AND_SET,new AtomicNumberCompareAndSetOperationHandler());
  registerPacketProcessor(ATOMIC_NUMBER_GET_AND_ADD,new AtomicNumberGetAndAddOperationHandler());
  registerPacketProcessor(ATOMIC_NUMBER_GET_AND_SET,new AtomicNumberGetAndSetOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_AWAIT,new CountDownLatchAwaitOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_COUNT_DOWN,new CountDownLatchCountDownOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_DESTROY,new CountDownLatchDestroyOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_GET_COUNT,new CountDownLatchGetCountOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_GET_OWNER,new CountDownLatchGetOwnerOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_SET_COUNT,new CountDownLatchSetCountOperationHandler());
  registerPacketProcessor(SEMAPHORE_ATTACH_DETACH_PERMITS,new SemaphoreAttachDetachOperationHandler());
  registerPacketProcessor(SEMAPHORE_CANCEL_ACQUIRE,new SemaphoreCancelAcquireOperationHandler());
  registerPacketProcessor(SEMAPHORE_DESTROY,new SemaphoreDestroyOperationHandler());
  registerPacketProcessor(SEMAPHORE_DRAIN_PERMITS,new SemaphoreDrainOperationHandler());
  registerPacketProcessor(SEMAPHORE_GET_ATTACHED_PERMITS,new SemaphoreGetAttachedOperationHandler());
  registerPacketProcessor(SEMAPHORE_GET_AVAILABLE_PERMITS,new SemaphoreGetAvailableOperationHandler());
  registerPacketProcessor(SEMAPHORE_REDUCE_PERMITS,new SemaphoreReduceOperationHandler());
  registerPacketProcessor(SEMAPHORE_RELEASE,new SemaphoreReleaseOperationHandler());
  registerPacketProcessor(SEMAPHORE_TRY_ACQUIRE,new SemaphoreTryAcquireOperationHandler());
}",0.9929320388349514
49609,"@Test public void issue587CallMapLoaderDuringRemoval(){
  final AtomicInteger loadCount=new AtomicInteger(0);
  final AtomicInteger storeCount=new AtomicInteger(0);
  final AtomicInteger deleteCount=new AtomicInteger(0);
class SimpleMapStore<K,V> implements MapStore<K,V> {
    SimpleMapStore(    ConcurrentMap<K,V> store){
      this.store=store;
    }
    public V load(    K key){
      V value=store.get(key);
      loadCount.incrementAndGet();
      return value;
    }
    public Map<K,V> loadAll(    Collection<K> keys){
      Map<K,V> result=new HashMap<K,V>();
      for (      K key : keys) {
        V value=load(key);
        if (value != null) {
          result.put(key,value);
        }
      }
      return result;
    }
    public Set<K> loadAllKeys(){
      Set<K> keys=store.keySet();
      return keys;
    }
    public void store(    K key,    V value){
      storeCount.incrementAndGet();
      store.put(key,value);
    }
    public void delete(    K key){
      deleteCount.incrementAndGet();
      store.remove(key);
    }
    public void storeAll(    Map<K,V> map){
      store.putAll(map);
    }
    public void deleteAll(    Collection<K> keys){
      for (      K key : keys) {
        store.remove(key);
      }
    }
    private final ConcurrentMap<K,V> store;
  }
  final ConcurrentMap<String,Long> store=new ConcurrentHashMap<String,Long>();
  final MapStore<String,Long> myMapStore=new SimpleMapStore<String,Long>(store);
  Config config=new Config();
  config.getMapConfig(""String_Node_Str"").setMapStoreConfig(new MapStoreConfig().setImplementation(myMapStore));
  HazelcastInstance hc=Hazelcast.newHazelcastInstance(config);
  try {
    store.put(""String_Node_Str"",1l);
    store.put(""String_Node_Str"",2l);
    assertEquals(0,loadCount.get());
    assertEquals(0,storeCount.get());
    assertEquals(0,deleteCount.get());
    IMap<String,Long> myMap=hc.getMap(""String_Node_Str"");
    assertEquals(1l,myMap.get(""String_Node_Str"").longValue());
    assertEquals(2l,myMap.get(""String_Node_Str"").longValue());
    assertEquals(2,loadCount.get());
    assertEquals(0,storeCount.get());
    assertEquals(0,deleteCount.get());
    assertNull(myMap.remove(""String_Node_Str""));
    assertEquals(3,loadCount.get());
    assertEquals(0,storeCount.get());
    assertEquals(0,deleteCount.get());
    myMap.put(""String_Node_Str"",3L);
    myMap.put(""String_Node_Str"",4L);
    assertEquals(5,loadCount.get());
    assertEquals(2,storeCount.get());
    assertEquals(0,deleteCount.get());
    myMap.remove(""String_Node_Str"");
    assertEquals(2,storeCount.get());
    assertEquals(1,deleteCount.get());
    assertEquals(5,loadCount.get());
  }
  finally {
    Hazelcast.shutdownAll();
  }
}","@Test public void issue587CallMapLoaderDuringRemoval(){
  final AtomicInteger loadCount=new AtomicInteger(0);
  final AtomicInteger storeCount=new AtomicInteger(0);
  final AtomicInteger deleteCount=new AtomicInteger(0);
class SimpleMapStore<K,V> implements MapStore<K,V> {
    SimpleMapStore(    ConcurrentMap<K,V> store){
      this.store=store;
    }
    public V load(    K key){
      V value=store.get(key);
      loadCount.incrementAndGet();
      return value;
    }
    public Map<K,V> loadAll(    Collection<K> keys){
      Map<K,V> result=new HashMap<K,V>();
      for (      K key : keys) {
        V value=load(key);
        if (value != null) {
          result.put(key,value);
        }
      }
      return result;
    }
    public Set<K> loadAllKeys(){
      Set<K> keys=store.keySet();
      return keys;
    }
    public void store(    K key,    V value){
      storeCount.incrementAndGet();
      store.put(key,value);
    }
    public void delete(    K key){
      deleteCount.incrementAndGet();
      store.remove(key);
    }
    public void storeAll(    Map<K,V> map){
      store.putAll(map);
    }
    public void deleteAll(    Collection<K> keys){
      for (      K key : keys) {
        store.remove(key);
      }
    }
    private final ConcurrentMap<K,V> store;
  }
  final ConcurrentMap<String,Long> store=new ConcurrentHashMap<String,Long>();
  final MapStore<String,Long> myMapStore=new SimpleMapStore<String,Long>(store);
  Config config=new Config();
  config.getMapConfig(""String_Node_Str"").setMapStoreConfig(new MapStoreConfig().setImplementation(myMapStore));
  HazelcastInstance hc=Hazelcast.newHazelcastInstance(config);
  store.put(""String_Node_Str"",1l);
  store.put(""String_Node_Str"",2l);
  assertEquals(0,loadCount.get());
  assertEquals(0,storeCount.get());
  assertEquals(0,deleteCount.get());
  IMap<String,Long> myMap=hc.getMap(""String_Node_Str"");
  assertEquals(1l,myMap.get(""String_Node_Str"").longValue());
  assertEquals(2l,myMap.get(""String_Node_Str"").longValue());
  assertEquals(2,loadCount.get());
  assertEquals(0,storeCount.get());
  assertEquals(0,deleteCount.get());
  assertNull(myMap.remove(""String_Node_Str""));
  assertEquals(3,loadCount.get());
  assertEquals(0,storeCount.get());
  assertEquals(0,deleteCount.get());
  myMap.put(""String_Node_Str"",3L);
  myMap.put(""String_Node_Str"",4L);
  assertEquals(5,loadCount.get());
  assertEquals(2,storeCount.get());
  assertEquals(0,deleteCount.get());
  myMap.remove(""String_Node_Str"");
  assertEquals(2,storeCount.get());
  assertEquals(1,deleteCount.get());
  assertEquals(5,loadCount.get());
}",0.9802222640798643
49610,"public void assertAwait(int seconds) throws Exception {
  assertTrue(latchStore.await(seconds,TimeUnit.SECONDS));
  assertTrue(latchStoreAll.await(seconds,TimeUnit.SECONDS));
  assertTrue(latchDelete.await(seconds,TimeUnit.SECONDS));
  assertTrue(latchDeleteAll.await(seconds,TimeUnit.SECONDS));
  assertTrue(latchLoad.await(seconds,TimeUnit.SECONDS));
  assertTrue(latchLoadAll.await(seconds,TimeUnit.SECONDS));
}","public void assertAwait(int seconds) throws InterruptedException {
  assertTrue(""String_Node_Str"" + latchStore.getCount(),latchStore.await(seconds,TimeUnit.SECONDS));
  assertTrue(""String_Node_Str"" + latchStoreAll.getCount(),latchStoreAll.await(seconds,TimeUnit.SECONDS));
  assertTrue(""String_Node_Str"" + latchDelete.getCount(),latchDelete.await(seconds,TimeUnit.SECONDS));
  assertTrue(""String_Node_Str"" + latchDeleteAll.getCount(),latchDeleteAll.await(seconds,TimeUnit.SECONDS));
  assertTrue(""String_Node_Str"" + latchLoad.getCount(),latchLoad.await(seconds,TimeUnit.SECONDS));
  assertTrue(""String_Node_Str"" + latchLoadAll.getCount(),latchLoadAll.await(seconds,TimeUnit.SECONDS));
}",0.7527272727272727
49611,"@Test public void issue587CallMapLoaderDuringRemoval(){
  final AtomicInteger loadCount=new AtomicInteger(0);
  final AtomicInteger storeCount=new AtomicInteger(0);
  final AtomicInteger deleteCount=new AtomicInteger(0);
class SimpleMapStore<K,V> implements MapStore<K,V> {
    SimpleMapStore(    ConcurrentMap<K,V> store){
      this.store=store;
    }
    public V load(    K key){
      V value=store.get(key);
      loadCount.incrementAndGet();
      return value;
    }
    public Map<K,V> loadAll(    Collection<K> keys){
      Map<K,V> result=new HashMap<K,V>();
      for (      K key : keys) {
        V value=load(key);
        if (value != null) {
          result.put(key,value);
        }
      }
      return result;
    }
    public Set<K> loadAllKeys(){
      Set<K> keys=store.keySet();
      return keys;
    }
    public void store(    K key,    V value){
      storeCount.incrementAndGet();
      store.put(key,value);
    }
    public void delete(    K key){
      deleteCount.incrementAndGet();
      store.remove(key);
    }
    public void storeAll(    Map<K,V> map){
      store.putAll(map);
    }
    public void deleteAll(    Collection<K> keys){
      for (      K key : keys) {
        store.remove(key);
      }
    }
    private final ConcurrentMap<K,V> store;
  }
  final ConcurrentMap<String,Long> store=new ConcurrentHashMap<String,Long>();
  final MapStore<String,Long> myMapStore=new SimpleMapStore<String,Long>(store);
  Config config=new Config();
  config.getMapConfig(""String_Node_Str"").setMapStoreConfig(new MapStoreConfig().setImplementation(myMapStore));
  HazelcastInstance hc=Hazelcast.newHazelcastInstance(config);
  try {
    store.put(""String_Node_Str"",1l);
    store.put(""String_Node_Str"",2l);
    assertEquals(0,loadCount.get());
    assertEquals(0,storeCount.get());
    assertEquals(0,deleteCount.get());
    IMap<String,Long> myMap=hc.getMap(""String_Node_Str"");
    assertEquals(1l,myMap.get(""String_Node_Str"").longValue());
    assertEquals(2l,myMap.get(""String_Node_Str"").longValue());
    assertEquals(2,loadCount.get());
    assertEquals(0,storeCount.get());
    assertEquals(0,deleteCount.get());
    assertNull(myMap.remove(""String_Node_Str""));
    assertEquals(3,loadCount.get());
    assertEquals(0,storeCount.get());
    assertEquals(0,deleteCount.get());
    myMap.put(""String_Node_Str"",3L);
    myMap.put(""String_Node_Str"",4L);
    assertEquals(5,loadCount.get());
    assertEquals(2,storeCount.get());
    assertEquals(0,deleteCount.get());
    myMap.remove(""String_Node_Str"");
    assertEquals(2,storeCount.get());
    assertEquals(1,deleteCount.get());
    assertEquals(5,loadCount.get());
  }
  finally {
    Hazelcast.shutdownAll();
  }
}","@Test public void issue587CallMapLoaderDuringRemoval(){
  final AtomicInteger loadCount=new AtomicInteger(0);
  final AtomicInteger storeCount=new AtomicInteger(0);
  final AtomicInteger deleteCount=new AtomicInteger(0);
class SimpleMapStore<K,V> implements MapStore<K,V> {
    SimpleMapStore(    ConcurrentMap<K,V> store){
      this.store=store;
    }
    public V load(    K key){
      V value=store.get(key);
      loadCount.incrementAndGet();
      return value;
    }
    public Map<K,V> loadAll(    Collection<K> keys){
      Map<K,V> result=new HashMap<K,V>();
      for (      K key : keys) {
        V value=load(key);
        if (value != null) {
          result.put(key,value);
        }
      }
      return result;
    }
    public Set<K> loadAllKeys(){
      Set<K> keys=store.keySet();
      return keys;
    }
    public void store(    K key,    V value){
      storeCount.incrementAndGet();
      store.put(key,value);
    }
    public void delete(    K key){
      deleteCount.incrementAndGet();
      store.remove(key);
    }
    public void storeAll(    Map<K,V> map){
      store.putAll(map);
    }
    public void deleteAll(    Collection<K> keys){
      for (      K key : keys) {
        store.remove(key);
      }
    }
    private final ConcurrentMap<K,V> store;
  }
  final ConcurrentMap<String,Long> store=new ConcurrentHashMap<String,Long>();
  final MapStore<String,Long> myMapStore=new SimpleMapStore<String,Long>(store);
  Config config=new Config();
  config.getMapConfig(""String_Node_Str"").setMapStoreConfig(new MapStoreConfig().setImplementation(myMapStore));
  HazelcastInstance hc=Hazelcast.newHazelcastInstance(config);
  store.put(""String_Node_Str"",1l);
  store.put(""String_Node_Str"",2l);
  assertEquals(0,loadCount.get());
  assertEquals(0,storeCount.get());
  assertEquals(0,deleteCount.get());
  IMap<String,Long> myMap=hc.getMap(""String_Node_Str"");
  assertEquals(1l,myMap.get(""String_Node_Str"").longValue());
  assertEquals(2l,myMap.get(""String_Node_Str"").longValue());
  assertEquals(2,loadCount.get());
  assertEquals(0,storeCount.get());
  assertEquals(0,deleteCount.get());
  assertNull(myMap.remove(""String_Node_Str""));
  assertEquals(3,loadCount.get());
  assertEquals(0,storeCount.get());
  assertEquals(0,deleteCount.get());
  myMap.put(""String_Node_Str"",3L);
  myMap.put(""String_Node_Str"",4L);
  assertEquals(5,loadCount.get());
  assertEquals(2,storeCount.get());
  assertEquals(0,deleteCount.get());
  myMap.remove(""String_Node_Str"");
  assertEquals(2,storeCount.get());
  assertEquals(1,deleteCount.get());
  assertEquals(5,loadCount.get());
}",0.9802222640798643
49612,"public void assertAwait(int seconds) throws Exception {
  assertTrue(latchStore.await(seconds,TimeUnit.SECONDS));
  assertTrue(latchStoreAll.await(seconds,TimeUnit.SECONDS));
  assertTrue(latchDelete.await(seconds,TimeUnit.SECONDS));
  assertTrue(latchDeleteAll.await(seconds,TimeUnit.SECONDS));
  assertTrue(latchLoad.await(seconds,TimeUnit.SECONDS));
  assertTrue(latchLoadAll.await(seconds,TimeUnit.SECONDS));
}","public void assertAwait(int seconds) throws InterruptedException {
  assertTrue(""String_Node_Str"" + latchStore.getCount(),latchStore.await(seconds,TimeUnit.SECONDS));
  assertTrue(""String_Node_Str"" + latchStoreAll.getCount(),latchStoreAll.await(seconds,TimeUnit.SECONDS));
  assertTrue(""String_Node_Str"" + latchDelete.getCount(),latchDelete.await(seconds,TimeUnit.SECONDS));
  assertTrue(""String_Node_Str"" + latchDeleteAll.getCount(),latchDeleteAll.await(seconds,TimeUnit.SECONDS));
  assertTrue(""String_Node_Str"" + latchLoad.getCount(),latchLoad.await(seconds,TimeUnit.SECONDS));
  assertTrue(""String_Node_Str"" + latchLoadAll.getCount(),latchLoadAll.await(seconds,TimeUnit.SECONDS));
}",0.7527272727272727
49613,"public void syncForDead(MemberImpl deadMember){
  Address deadAddress=deadMember.getAddress();
  Address thisAddress=concurrentMapManager.getThisAddress();
  if (deadAddress == null || deadAddress.equals(thisAddress)) {
    return;
  }
  if (!hasStorageMember()) {
    reset();
  }
  concurrentMapManager.partitionServiceImpl.reset();
  checkMigratingPartitionForDead(deadAddress);
  int[] indexesOfDead=new int[partitions.length];
  for (  PartitionInfo partition : partitions) {
    indexesOfDead[partition.getPartitionId()]=partition.getReplicaIndexOf(deadAddress);
  }
  if (!deadMember.isLiteMember()) {
    clearTaskQueues();
    for (    PartitionInfo partition : partitions) {
      while (partition.onDeadAddress(deadAddress))       ;
    }
  }
  fixCMapsForDead(deadAddress,indexesOfDead);
  fixReplicasAndPartitionsForDead(deadMember,indexesOfDead);
}","public void syncForDead(MemberImpl deadMember){
  Address deadAddress=deadMember.getAddress();
  Address thisAddress=concurrentMapManager.getThisAddress();
  if (deadAddress == null || deadAddress.equals(thisAddress)) {
    return;
  }
  if (!hasStorageMember()) {
    reset();
  }
  final boolean migrationStatus=migrationActive.getAndSet(false);
  concurrentMapManager.partitionServiceImpl.reset();
  checkMigratingPartitionForDead(deadAddress);
  int[] indexesOfDead=new int[partitions.length];
  for (  PartitionInfo partition : partitions) {
    indexesOfDead[partition.getPartitionId()]=partition.getReplicaIndexOf(deadAddress);
  }
  if (!deadMember.isLiteMember()) {
    clearTaskQueues();
    for (    PartitionInfo partition : partitions) {
      while (partition.onDeadAddress(deadAddress))       ;
    }
  }
  fixCMapsForDead(deadAddress,indexesOfDead);
  fixReplicasAndPartitionsForDead(deadMember,indexesOfDead);
  final Node node=concurrentMapManager.node;
  final long waitBeforeMigrationActivate=node.groupProperties.CONNECTION_MONITOR_INTERVAL.getLong() * node.groupProperties.CONNECTION_MONITOR_MAX_FAULTS.getInteger() * 10;
  node.executorManager.getScheduledExecutorService().schedule(new Runnable(){
    public void run(){
      migrationActive.compareAndSet(false,migrationStatus);
    }
  }
,waitBeforeMigrationActivate,TimeUnit.MILLISECONDS);
}",0.7727476467951592
49614,"private void sendClusterRuntimeState(){
  if (!concurrentMapManager.isMaster() || !concurrentMapManager.isActive() || !concurrentMapManager.node.joined()) {
    return;
  }
  if (!initialized)   return;
  long clusterTime=concurrentMapManager.node.getClusterImpl().getClusterTime();
  List<MemberImpl> lsMembers=concurrentMapManager.lsMembers;
  ArrayList<MemberInfo> memberInfos=new ArrayList<MemberInfo>(lsMembers.size());
  for (  MemberImpl member : lsMembers) {
    memberInfos.add(new MemberInfo(member.getAddress(),member.getNodeType(),member.getUuid()));
  }
  ClusterRuntimeState crs=new ClusterRuntimeState(memberInfos,partitions,clusterTime,version.get());
  concurrentMapManager.sendProcessableToAll(crs,false);
}","private void sendClusterRuntimeState(){
  if (!concurrentMapManager.isMaster() || !concurrentMapManager.isActive() || !concurrentMapManager.node.joined()) {
    return;
  }
  if (!migrationActive.get()) {
    return;
  }
  if (!initialized)   return;
  long clusterTime=concurrentMapManager.node.getClusterImpl().getClusterTime();
  List<MemberImpl> lsMembers=concurrentMapManager.lsMembers;
  ArrayList<MemberInfo> memberInfos=new ArrayList<MemberInfo>(lsMembers.size());
  for (  MemberImpl member : lsMembers) {
    memberInfos.add(new MemberInfo(member.getAddress(),member.getNodeType(),member.getUuid()));
  }
  ClusterRuntimeState crs=new ClusterRuntimeState(memberInfos,partitions,clusterTime,version.get());
  concurrentMapManager.sendProcessableToAll(crs,false);
}",0.9679572763684912
49615,"public boolean inactivateMigration(){
  migrationActive.getAndSet(false);
  while (migratingPartition != null) {
    try {
      Thread.sleep(250);
    }
 catch (    InterruptedException e) {
      return true;
    }
  }
  return true;
}","public boolean inactivateMigration(){
  migrationActive.compareAndSet(true,false);
  while (migratingPartition != null) {
    try {
      Thread.sleep(250);
    }
 catch (    InterruptedException e) {
      return true;
    }
  }
  return true;
}",0.968944099378882
49616,"public boolean activateMigration(){
  return migrationActive.getAndSet(true);
}","public boolean activateMigration(){
  return migrationActive.compareAndSet(false,true);
}",0.9166666666666666
49617,"@Test public void testPartitionAndCMapRecordCounts() throws InterruptedException {
  final int[] clusterSize=new int[]{3,5,7,6,4,2,1};
  final int entryCount=10000;
  final int totalPartitionCount=271;
  final int mapBackupCount=2;
  Config config=new Config();
  config.getProperties().put(GroupProperties.PROP_CLEANUP_DELAY_SECONDS,""String_Node_Str"");
  config.getProperties().put(GroupProperties.PROP_PARTITION_MIGRATION_INTERVAL,""String_Node_Str"");
  config.getProperties().put(GroupProperties.PROP_IMMEDIATE_BACKUP_INTERVAL,""String_Node_Str"");
  config.getProperties().put(GroupProperties.PROP_PARTITION_TABLE_SEND_INTERVAL,""String_Node_Str"");
  final String mapName=""String_Node_Str"";
  int testMapReplicaCount=mapBackupCount + 1;
  config.getMapConfig(mapName).setBackupCount(mapBackupCount);
  final IMap<Integer,Integer> testMap=Hazelcast.newHazelcastInstance(config).getMap(mapName);
  for (int i=0; i < entryCount; i++) {
    testMap.put(i,i);
  }
  int k=0;
  for (int i=0; i < clusterSize.length; i++) {
    int size=clusterSize[k++ % clusterSize.length];
    System.out.println(""String_Node_Str"" + size);
    while (Hazelcast.getAllHazelcastInstances().size() < size) {
      Hazelcast.newHazelcastInstance(config);
    }
    while (Hazelcast.getAllHazelcastInstances().size() > size) {
      Collection<HazelcastInstance> all=Hazelcast.getAllHazelcastInstances();
      for (      HazelcastInstance hz : all) {
        if (hz.getCluster().getMembers().iterator().next().localMember()) {
          hz.getLifecycleService().shutdown();
          break;
        }
      }
    }
    Collection<HazelcastInstance> set=Hazelcast.getAllHazelcastInstances();
    final int replicaMax=set.size();
    int wait=replicaMax * 3;
    System.out.println(""String_Node_Str"" + wait + ""String_Node_Str"");
    Thread.sleep(1000 * wait);
    int[] partitionCounts=new int[PartitionInfo.MAX_REPLICA_COUNT];
    for (    HazelcastInstance hazelcastInstance : set) {
      int[] pc=getPartitionCounts(getNode(hazelcastInstance));
      for (int j=0; j < pc.length; j++) {
        partitionCounts[j]+=pc[j];
      }
    }
    for (int j=0; j < partitionCounts.length; j++) {
      int partitionCount=partitionCounts[j];
      if (j < replicaMax) {
        assertTrue(""String_Node_Str"" + j + ""String_Node_Str""+ partitionCount+ ""String_Node_Str""+ replicaMax,partitionCount == totalPartitionCount);
      }
 else {
        assertTrue(""String_Node_Str"" + j + ""String_Node_Str""+ partitionCount+ ""String_Node_Str""+ replicaMax,partitionCount == 0);
      }
    }
    int[] recordCounts=new int[PartitionInfo.MAX_REPLICA_COUNT];
    for (    HazelcastInstance hazelcastInstance : set) {
      int[] rc=getCMapRecordCounts(getNode(hazelcastInstance),mapName);
      for (int j=0; j < rc.length; j++) {
        recordCounts[j]+=rc[j];
      }
    }
    for (int j=0; j < recordCounts.length; j++) {
      int recordCount=recordCounts[j];
      if (j < Math.min(testMapReplicaCount,replicaMax)) {
        assertTrue(""String_Node_Str"" + j + ""String_Node_Str""+ recordCount+ ""String_Node_Str""+ replicaMax,recordCount == entryCount);
      }
 else {
        assertTrue(""String_Node_Str"" + j + ""String_Node_Str""+ recordCount+ ""String_Node_Str""+ replicaMax,recordCount == 0);
      }
    }
  }
}","@Test public void testPartitionAndCMapRecordCounts() throws InterruptedException {
  final int[] clusterSize=new int[]{3,5,7,6,4,2,1};
  final int entryCount=10000;
  final int totalPartitionCount=271;
  final int mapBackupCount=2;
  Config config=new Config();
  config.getProperties().put(GroupProperties.PROP_CLEANUP_DELAY_SECONDS,""String_Node_Str"");
  config.getProperties().put(GroupProperties.PROP_PARTITION_MIGRATION_INTERVAL,""String_Node_Str"");
  config.getProperties().put(GroupProperties.PROP_IMMEDIATE_BACKUP_INTERVAL,""String_Node_Str"");
  config.getProperties().put(GroupProperties.PROP_PARTITION_TABLE_SEND_INTERVAL,""String_Node_Str"");
  final String mapName=""String_Node_Str"";
  int testMapReplicaCount=mapBackupCount + 1;
  config.getMapConfig(mapName).setBackupCount(mapBackupCount);
  final IMap<Integer,Integer> testMap=Hazelcast.newHazelcastInstance(config).getMap(mapName);
  for (int i=0; i < entryCount; i++) {
    testMap.put(i,i);
  }
  int k=0;
  for (int i=0; i < clusterSize.length; i++) {
    int size=clusterSize[k++ % clusterSize.length];
    System.out.println(""String_Node_Str"" + size);
    while (Hazelcast.getAllHazelcastInstances().size() < size) {
      Hazelcast.newHazelcastInstance(config);
    }
    while (Hazelcast.getAllHazelcastInstances().size() > size) {
      Collection<HazelcastInstance> all=Hazelcast.getAllHazelcastInstances();
      for (      HazelcastInstance hz : all) {
        if (hz.getCluster().getMembers().iterator().next().localMember()) {
          hz.getLifecycleService().shutdown();
          break;
        }
      }
    }
    Collection<HazelcastInstance> set=Hazelcast.getAllHazelcastInstances();
    final int replicaMax=set.size();
    int wait=replicaMax * 5;
    System.out.println(""String_Node_Str"" + wait + ""String_Node_Str"");
    Thread.sleep(1000 * wait);
    int[] partitionCounts=new int[PartitionInfo.MAX_REPLICA_COUNT];
    for (    HazelcastInstance hazelcastInstance : set) {
      int[] pc=getPartitionCounts(getNode(hazelcastInstance));
      for (int j=0; j < pc.length; j++) {
        partitionCounts[j]+=pc[j];
      }
    }
    for (int j=0; j < partitionCounts.length; j++) {
      int partitionCount=partitionCounts[j];
      if (j < replicaMax) {
        assertTrue(""String_Node_Str"" + j + ""String_Node_Str""+ partitionCount+ ""String_Node_Str""+ replicaMax,partitionCount == totalPartitionCount);
      }
 else {
        assertTrue(""String_Node_Str"" + j + ""String_Node_Str""+ partitionCount+ ""String_Node_Str""+ replicaMax,partitionCount == 0);
      }
    }
    int[] recordCounts=new int[PartitionInfo.MAX_REPLICA_COUNT];
    for (    HazelcastInstance hazelcastInstance : set) {
      int[] rc=getCMapRecordCounts(getNode(hazelcastInstance),mapName);
      for (int j=0; j < rc.length; j++) {
        recordCounts[j]+=rc[j];
      }
    }
    for (int j=0; j < recordCounts.length; j++) {
      int recordCount=recordCounts[j];
      if (j < Math.min(testMapReplicaCount,replicaMax)) {
        assertTrue(""String_Node_Str"" + j + ""String_Node_Str""+ recordCount+ ""String_Node_Str""+ replicaMax,recordCount == entryCount);
      }
 else {
        assertTrue(""String_Node_Str"" + j + ""String_Node_Str""+ recordCount+ ""String_Node_Str""+ replicaMax,recordCount == 0);
      }
    }
  }
}",0.9996940960538392
49618,"public void setAddresses(List<String> addresses){
  addressList.clear();
  for (  String address : addresses) {
    addressList.addAll(parse(address));
  }
}","public void setAddresses(List<String> addresses){
  addressList.clear();
  for (  String address : addresses) {
    addressList.addAll(AddressHelper.getSocketAddresses(address));
  }
}",0.9149560117302052
49619,"public ClientConfig addAddress(String... addresses){
  for (  String address : addresses) {
    this.addressList.addAll(parse(address));
  }
  return this;
}","public ClientConfig addAddress(String... addresses){
  for (  String address : addresses) {
    this.addressList.addAll(AddressHelper.getSocketAddresses(address));
  }
  return this;
}",0.9149560117302052
49620,"public synchronized void memberRemoved(MembershipEvent membershipEvent){
  this.clusterMembers.remove(membershipEvent.getMember().getInetSocketAddress());
}","public void memberRemoved(MembershipEvent membershipEvent){
  InetSocketAddress address=membershipEvent.getMember().getInetSocketAddress();
  Collection<InetSocketAddress> addresses=AddressHelper.getPossibleSocketAddresses(address.getAddress(),address.getPort());
  clusterMembers.removeAll(addresses);
}",0.3869565217391304
49621,"public synchronized void updateMembers(){
  Set<Member> members=client.getCluster().getMembers();
  clusterMembers.clear();
  for (  Member member : members) {
    clusterMembers.add(member.getInetSocketAddress());
  }
}","public void updateMembers(){
  Set<Member> members=client.getCluster().getMembers();
  clusterMembers.clear();
  for (  Member member : members) {
    InetSocketAddress address=member.getInetSocketAddress();
    Collection<InetSocketAddress> addresses=AddressHelper.getPossibleSocketAddresses(address.getAddress(),address.getPort());
    clusterMembers.addAll(addresses);
  }
}",0.5896147403685092
49622,"public synchronized void memberAdded(MembershipEvent membershipEvent){
  if (!this.clusterMembers.contains(membershipEvent.getMember().getInetSocketAddress())) {
    this.clusterMembers.add(membershipEvent.getMember().getInetSocketAddress());
  }
}","public void memberAdded(MembershipEvent membershipEvent){
  InetSocketAddress address=membershipEvent.getMember().getInetSocketAddress();
  Collection<InetSocketAddress> addresses=AddressHelper.getPossibleSocketAddresses(address.getAddress(),address.getPort());
  clusterMembers.addAll(addresses);
}",0.1206581352833638
49623,"public void destroyConnection(final Connection connection){
  boolean lost=false;
synchronized (this) {
    if (currentConnection != null && connection != null && currentConnection.getVersion() == connection.getVersion()) {
      logger.log(Level.WARNING,""String_Node_Str"" + currentConnection + ""String_Node_Str"");
      currentConnection=null;
      lost=true;
      try {
        connection.close();
      }
 catch (      IOException e) {
        logger.log(Level.FINEST,e.getMessage(),e);
      }
    }
  }
  if (lost) {
    lifecycleService.fireLifecycleEvent(CLIENT_CONNECTION_LOST);
  }
}","public void destroyConnection(final Connection connection){
  boolean lost=false;
synchronized (this) {
    if (currentConnection != null && connection != null && currentConnection.getVersion() == connection.getVersion()) {
      logger.log(Level.WARNING,""String_Node_Str"" + currentConnection + ""String_Node_Str"");
      while (clusterMembers.remove(currentConnection.getAddress()))       ;
      currentConnection=null;
      lost=true;
      try {
        connection.close();
      }
 catch (      IOException e) {
        logger.log(Level.FINEST,e.getMessage(),e);
      }
    }
  }
  if (lost) {
    lifecycleService.fireLifecycleEvent(CLIENT_CONNECTION_LOST);
  }
}",0.939873417721519
49624,"public void commit(){
  if (instanceType == Instance.InstanceType.QUEUE)   commitQueue();
 else   commitMap();
}","public void commit(){
  if (instanceType == Instance.InstanceType.QUEUE) {
    commitQueue();
  }
 else {
    commitMap();
  }
}",0.9333333333333332
49625,"public boolean containsValue(String name,Object value){
  for (  TransactionRecord transactionRecord : transactionRecords) {
    if (transactionRecord.name.equals(name)) {
      if (!transactionRecord.removed) {
        if (value.equals(toObject(transactionRecord.value)))         return true;
      }
    }
  }
  return false;
}","public boolean containsValue(String name,Object value){
  for (  TransactionRecord transactionRecord : transactionRecords) {
    if (transactionRecord.name.equals(name)) {
      if (!transactionRecord.removed) {
        if (value.equals(toObject(transactionRecord.value))) {
          return true;
        }
      }
    }
  }
  return false;
}",0.9791666666666666
49626,"public Data get(String name,Object key){
  TransactionRecord rec=findTransactionRecord(name,key);
  if (rec == null)   return null;
  if (rec.removed)   return null;
  rec.lastAccess=System.currentTimeMillis();
  return rec.value;
}","public Data get(String name,Object key){
  TransactionRecord rec=findTransactionRecord(name,key);
  if (rec == null) {
    return null;
  }
  if (rec.removed) {
    return null;
  }
  rec.lastAccess=System.currentTimeMillis();
  return rec.value;
}",0.85
49627,"public void rollback(){
  if (instanceType == Instance.InstanceType.QUEUE)   rollbackQueue();
 else   rollbackMap();
}","public void rollback(){
  if (instanceType == Instance.InstanceType.QUEUE) {
    rollbackQueue();
  }
 else {
    rollbackMap();
  }
}",0.9365079365079364
49628,"public void begin() throws IllegalStateException {
  if (status == TXN_STATUS_ACTIVE)   throw new IllegalStateException(""String_Node_Str"");
  status=TXN_STATUS_ACTIVE;
}","public void begin() throws IllegalStateException {
  if (status == TXN_STATUS_ACTIVE) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  status=TXN_STATUS_ACTIVE;
}",0.976878612716763
49629,"@Test public void issue770TestIMapTryPutUnderTransaction(){
  final HazelcastInstance hz=Hazelcast.getDefaultInstance();
  Transaction tx=hz.getTransaction();
  tx.begin();
  IMap<Object,Object> map=hz.getMap(""String_Node_Str"");
  Assert.assertTrue(map.tryPut(""String_Node_Str"",""String_Node_Str"",100,TimeUnit.MILLISECONDS));
  Assert.assertTrue(map.tryPut(""String_Node_Str"",""String_Node_Str"",100,TimeUnit.MILLISECONDS));
  tx.commit();
  Hazelcast.shutdownAll();
}","@Test public void issue770TestIMapTryPutUnderTransaction(){
  final HazelcastInstance hz=Hazelcast.getDefaultInstance();
  Transaction tx=hz.getTransaction();
  tx.begin();
  IMap<Object,Object> map=hz.getMap(""String_Node_Str"");
  Assert.assertTrue(map.tryPut(""String_Node_Str"",""String_Node_Str"",100,TimeUnit.MILLISECONDS));
  Assert.assertTrue(map.tryPut(""String_Node_Str"",""String_Node_Str"",100,TimeUnit.MILLISECONDS));
  tx.commit();
}",0.9700332963374028
49630,"@BeforeClass public static void init() throws Exception {
  Hazelcast.shutdownAll();
}","@AfterClass @BeforeClass public static void init() throws Exception {
  Hazelcast.shutdownAll();
}",0.9347826086956522
49631,"@Test public void issue581testRemoveInTwoTransactionOneShouldReturnNull() throws InterruptedException {
  final IMap m=Hazelcast.getMap(""String_Node_Str"");
  final AtomicReference<Object> t1Return=new AtomicReference<Object>();
  final AtomicReference<Object> t2Return=new AtomicReference<Object>();
  m.put(""String_Node_Str"",""String_Node_Str"");
  new Thread(""String_Node_Str""){
    @Override public void run(){
      try {
        Transaction tx=Hazelcast.getTransaction();
        tx.begin();
        t1Return.set(m.remove(""String_Node_Str""));
        Thread.sleep(1000);
        tx.commit();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
.start();
  Thread t2=new Thread(""String_Node_Str""){
    @Override public void run(){
      try {
        Transaction tx=Hazelcast.getTransaction();
        tx.begin();
        Thread.sleep(1000);
        t2Return.set(m.remove(""String_Node_Str""));
        tx.commit();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
;
  t2.start();
  t2.join();
  Assert.assertEquals(""String_Node_Str"",t1Return.get());
  Assert.assertNull(""String_Node_Str"",t2Return.get());
  Hazelcast.shutdownAll();
}","@Test public void issue581testRemoveInTwoTransactionOneShouldReturnNull() throws InterruptedException {
  final IMap m=Hazelcast.getMap(""String_Node_Str"");
  final AtomicReference<Object> t1Return=new AtomicReference<Object>();
  final AtomicReference<Object> t2Return=new AtomicReference<Object>();
  m.put(""String_Node_Str"",""String_Node_Str"");
  new Thread(""String_Node_Str""){
    @Override public void run(){
      try {
        Transaction tx=Hazelcast.getTransaction();
        tx.begin();
        t1Return.set(m.remove(""String_Node_Str""));
        Thread.sleep(1000);
        tx.commit();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
.start();
  Thread t2=new Thread(""String_Node_Str""){
    @Override public void run(){
      try {
        Transaction tx=Hazelcast.getTransaction();
        tx.begin();
        Thread.sleep(1000);
        t2Return.set(m.remove(""String_Node_Str""));
        tx.commit();
      }
 catch (      InterruptedException ex) {
      }
    }
  }
;
  t2.start();
  t2.join();
  Assert.assertEquals(""String_Node_Str"",t1Return.get());
  Assert.assertNull(""String_Node_Str"",t2Return.get());
}",0.988296488946684
49632,"public void setAddresses(List<String> addresses){
  addressList.clear();
  for (  String address : addresses) {
    addressList.addAll(parse(address));
  }
}","public void setAddresses(List<String> addresses){
  addressList.clear();
  for (  String address : addresses) {
    addressList.addAll(AddressHelper.getSocketAddresses(address));
  }
}",0.9149560117302052
49633,"public ClientConfig addAddress(String... addresses){
  for (  String address : addresses) {
    this.addressList.addAll(parse(address));
  }
  return this;
}","public ClientConfig addAddress(String... addresses){
  for (  String address : addresses) {
    this.addressList.addAll(AddressHelper.getSocketAddresses(address));
  }
  return this;
}",0.9149560117302052
49634,"public synchronized void memberRemoved(MembershipEvent membershipEvent){
  this.clusterMembers.remove(membershipEvent.getMember().getInetSocketAddress());
}","public void memberRemoved(MembershipEvent membershipEvent){
  InetSocketAddress address=membershipEvent.getMember().getInetSocketAddress();
  Collection<InetSocketAddress> addresses=AddressHelper.getPossibleSocketAddresses(address.getAddress(),address.getPort());
  clusterMembers.removeAll(addresses);
}",0.3869565217391304
49635,"public synchronized void updateMembers(){
  Set<Member> members=client.getCluster().getMembers();
  clusterMembers.clear();
  for (  Member member : members) {
    clusterMembers.add(member.getInetSocketAddress());
  }
}","public void updateMembers(){
  Set<Member> members=client.getCluster().getMembers();
  clusterMembers.clear();
  for (  Member member : members) {
    InetSocketAddress address=member.getInetSocketAddress();
    Collection<InetSocketAddress> addresses=AddressHelper.getPossibleSocketAddresses(address.getAddress(),address.getPort());
    clusterMembers.addAll(addresses);
  }
}",0.5896147403685092
49636,"public synchronized void memberAdded(MembershipEvent membershipEvent){
  if (!this.clusterMembers.contains(membershipEvent.getMember().getInetSocketAddress())) {
    this.clusterMembers.add(membershipEvent.getMember().getInetSocketAddress());
  }
}","public void memberAdded(MembershipEvent membershipEvent){
  InetSocketAddress address=membershipEvent.getMember().getInetSocketAddress();
  Collection<InetSocketAddress> addresses=AddressHelper.getPossibleSocketAddresses(address.getAddress(),address.getPort());
  clusterMembers.addAll(addresses);
}",0.1206581352833638
49637,"public void destroyConnection(final Connection connection){
  boolean lost=false;
synchronized (this) {
    if (currentConnection != null && connection != null && currentConnection.getVersion() == connection.getVersion()) {
      logger.log(Level.WARNING,""String_Node_Str"" + currentConnection + ""String_Node_Str"");
      currentConnection=null;
      lost=true;
      try {
        connection.close();
      }
 catch (      IOException e) {
        logger.log(Level.FINEST,e.getMessage(),e);
      }
    }
  }
  if (lost) {
    lifecycleService.fireLifecycleEvent(CLIENT_CONNECTION_LOST);
  }
}","public void destroyConnection(final Connection connection){
  boolean lost=false;
synchronized (this) {
    if (currentConnection != null && connection != null && currentConnection.getVersion() == connection.getVersion()) {
      logger.log(Level.WARNING,""String_Node_Str"" + currentConnection + ""String_Node_Str"");
      while (clusterMembers.remove(currentConnection.getAddress()))       ;
      currentConnection=null;
      lost=true;
      try {
        connection.close();
      }
 catch (      IOException e) {
        logger.log(Level.FINEST,e.getMessage(),e);
      }
    }
  }
  if (lost) {
    lifecycleService.fireLifecycleEvent(CLIENT_CONNECTION_LOST);
  }
}",0.939873417721519
49638,"private void callListener(final ListenerItem listenerItem,final DataAwareEntryEvent event){
  if (listenerItem.localListener && !event.firedLocally) {
    return;
  }
  final Object listener=listenerItem.listener;
  final EntryEventType entryEventType=event.getEventType();
  if (listenerItem.instanceType == Instance.InstanceType.MAP) {
    if (!listenerItem.name.startsWith(Prefix.MAP_HAZELCAST)) {
      Object proxy=node.factory.getOrCreateProxyByName(listenerItem.name);
      if (proxy instanceof MProxy) {
        MProxy mProxy=(MProxy)proxy;
        mProxy.getMapOperationCounter().incrementReceivedEvents();
      }
    }
  }
 else   if (listenerItem.instanceType == Instance.InstanceType.QUEUE) {
    if (!listenerItem.name.startsWith(Prefix.QUEUE_HAZELCAST)) {
      Object proxy=node.factory.getOrCreateProxyByName(listenerItem.name);
      if (proxy instanceof QProxy) {
        QProxy qProxy=(QProxy)proxy;
        qProxy.getQueueOperationCounter().incrementReceivedEvents();
      }
    }
  }
 else   if (listenerItem.instanceType == Instance.InstanceType.TOPIC) {
    if (!listenerItem.name.startsWith(Prefix.TOPIC_HAZELCAST)) {
      Object proxy=node.factory.getOrCreateProxyByName(listenerItem.name);
      if (proxy instanceof TopicProxy) {
        TopicProxy tProxy=(TopicProxy)proxy;
        tProxy.getTopicOperationCounter().incrementReceivedMessages();
      }
    }
  }
  final EntryEvent event2=listenerItem.includeValue ? event : (event.getValue() != null ? new DataAwareEntryEvent(event.getMember(),event.getEventType().getType(),event.getLongName(),event.getKeyData(),null,null,event.firedLocally) : event);
switch (listenerItem.instanceType) {
case MAP:
case MULTIMAP:
    EntryListener entryListener=(EntryListener)listener;
switch (entryEventType) {
case ADDED:
    entryListener.entryAdded(event2);
  break;
case REMOVED:
entryListener.entryRemoved(event2);
break;
case UPDATED:
entryListener.entryUpdated(event2);
break;
case EVICTED:
entryListener.entryEvicted(event2);
break;
}
break;
case SET:
case LIST:
ItemListener itemListener=(ItemListener)listener;
switch (entryEventType) {
case ADDED:
itemListener.itemAdded(new DataAwareItemEvent(listenerItem.name,ItemEventType.ADDED,event.getKeyData()));
break;
case REMOVED:
itemListener.itemRemoved(new DataAwareItemEvent(listenerItem.name,ItemEventType.REMOVED,event.getKeyData()));
break;
}
break;
case TOPIC:
MessageListener messageListener=(MessageListener)listener;
messageListener.onMessage(new DataMessage(listenerItem.name,event.getNewValueData()));
break;
case QUEUE:
ItemListener queueItemListener=(ItemListener)listener;
switch (entryEventType) {
case ADDED:
queueItemListener.itemAdded(new DataAwareItemEvent(listenerItem.name,ItemEventType.ADDED,event.getNewValueData()));
break;
case REMOVED:
queueItemListener.itemRemoved(new DataAwareItemEvent(listenerItem.name,ItemEventType.REMOVED,event.getNewValueData()));
break;
}
break;
}
}","private void callListener(final ListenerItem listenerItem,final DataAwareEntryEvent event){
  if (listenerItem.localListener && !event.firedLocally) {
    return;
  }
  final Object listener=listenerItem.listener;
  final EntryEventType entryEventType=event.getEventType();
  if (listenerItem.instanceType == Instance.InstanceType.MAP) {
    if (!listenerItem.name.startsWith(Prefix.MAP_HAZELCAST)) {
      Object proxy=node.factory.getOrCreateProxyByName(listenerItem.name);
      if (proxy instanceof MProxy) {
        MProxy mProxy=(MProxy)proxy;
        mProxy.getMapOperationCounter().incrementReceivedEvents();
      }
    }
  }
 else   if (listenerItem.instanceType == Instance.InstanceType.QUEUE) {
    if (!listenerItem.name.startsWith(Prefix.QUEUE_HAZELCAST)) {
      Object proxy=node.factory.getOrCreateProxyByName(listenerItem.name);
      if (proxy instanceof QProxy) {
        QProxy qProxy=(QProxy)proxy;
        qProxy.getQueueOperationCounter().incrementReceivedEvents();
      }
    }
  }
 else   if (listenerItem.instanceType == Instance.InstanceType.TOPIC) {
    if (!listenerItem.name.startsWith(Prefix.TOPIC_HAZELCAST)) {
      Object proxy=node.factory.getOrCreateProxyByName(listenerItem.name);
      if (proxy instanceof TopicProxy) {
        TopicProxy tProxy=(TopicProxy)proxy;
        tProxy.getTopicOperationCounter().incrementReceivedMessages();
      }
    }
  }
  final EntryEvent event2=listenerItem.includeValue ? event : (event.getNewValueData() != null ? new DataAwareEntryEvent(event.getMember(),event.getEventType().getType(),event.getLongName(),event.getKeyData(),null,null,event.firedLocally) : event);
switch (listenerItem.instanceType) {
case MAP:
case MULTIMAP:
    EntryListener entryListener=(EntryListener)listener;
switch (entryEventType) {
case ADDED:
    entryListener.entryAdded(event2);
  break;
case REMOVED:
entryListener.entryRemoved(event2);
break;
case UPDATED:
entryListener.entryUpdated(event2);
break;
case EVICTED:
entryListener.entryEvicted(event2);
break;
}
break;
case SET:
case LIST:
ItemListener itemListener=(ItemListener)listener;
switch (entryEventType) {
case ADDED:
itemListener.itemAdded(new DataAwareItemEvent(listenerItem.name,ItemEventType.ADDED,event.getKeyData()));
break;
case REMOVED:
itemListener.itemRemoved(new DataAwareItemEvent(listenerItem.name,ItemEventType.REMOVED,event.getKeyData()));
break;
}
break;
case TOPIC:
MessageListener messageListener=(MessageListener)listener;
messageListener.onMessage(new DataMessage(listenerItem.name,event.getNewValueData()));
break;
case QUEUE:
ItemListener queueItemListener=(ItemListener)listener;
switch (entryEventType) {
case ADDED:
queueItemListener.itemAdded(new DataAwareItemEvent(listenerItem.name,ItemEventType.ADDED,event.getNewValueData()));
break;
case REMOVED:
queueItemListener.itemRemoved(new DataAwareItemEvent(listenerItem.name,ItemEventType.REMOVED,event.getNewValueData()));
break;
}
break;
}
}",0.9988064791133844
49639,"private void callListener(final ListenerItem listenerItem,final DataAwareEntryEvent event){
  if (listenerItem.localListener && !event.firedLocally) {
    return;
  }
  final Object listener=listenerItem.listener;
  final EntryEventType entryEventType=event.getEventType();
  if (listenerItem.instanceType == Instance.InstanceType.MAP) {
    if (!listenerItem.name.startsWith(Prefix.MAP_HAZELCAST)) {
      Object proxy=node.factory.getOrCreateProxyByName(listenerItem.name);
      if (proxy instanceof MProxy) {
        MProxy mProxy=(MProxy)proxy;
        mProxy.getMapOperationCounter().incrementReceivedEvents();
      }
    }
  }
 else   if (listenerItem.instanceType == Instance.InstanceType.QUEUE) {
    if (!listenerItem.name.startsWith(Prefix.QUEUE_HAZELCAST)) {
      Object proxy=node.factory.getOrCreateProxyByName(listenerItem.name);
      if (proxy instanceof QProxy) {
        QProxy qProxy=(QProxy)proxy;
        qProxy.getQueueOperationCounter().incrementReceivedEvents();
      }
    }
  }
 else   if (listenerItem.instanceType == Instance.InstanceType.TOPIC) {
    if (!listenerItem.name.startsWith(Prefix.TOPIC_HAZELCAST)) {
      Object proxy=node.factory.getOrCreateProxyByName(listenerItem.name);
      if (proxy instanceof TopicProxy) {
        TopicProxy tProxy=(TopicProxy)proxy;
        tProxy.getTopicOperationCounter().incrementReceivedMessages();
      }
    }
  }
  final EntryEvent event2=listenerItem.includeValue ? event : (event.getValue() != null ? new DataAwareEntryEvent(event.getMember(),event.getEventType().getType(),event.getLongName(),event.getKeyData(),null,null,event.firedLocally) : event);
switch (listenerItem.instanceType) {
case MAP:
case MULTIMAP:
    EntryListener entryListener=(EntryListener)listener;
switch (entryEventType) {
case ADDED:
    entryListener.entryAdded(event2);
  break;
case REMOVED:
entryListener.entryRemoved(event2);
break;
case UPDATED:
entryListener.entryUpdated(event2);
break;
case EVICTED:
entryListener.entryEvicted(event2);
break;
}
break;
case SET:
case LIST:
ItemListener itemListener=(ItemListener)listener;
switch (entryEventType) {
case ADDED:
itemListener.itemAdded(new DataAwareItemEvent(listenerItem.name,ItemEventType.ADDED,event.getKeyData()));
break;
case REMOVED:
itemListener.itemRemoved(new DataAwareItemEvent(listenerItem.name,ItemEventType.REMOVED,event.getKeyData()));
break;
}
break;
case TOPIC:
MessageListener messageListener=(MessageListener)listener;
messageListener.onMessage(new DataMessage(listenerItem.name,event.getNewValueData()));
break;
case QUEUE:
ItemListener queueItemListener=(ItemListener)listener;
switch (entryEventType) {
case ADDED:
queueItemListener.itemAdded(new DataAwareItemEvent(listenerItem.name,ItemEventType.ADDED,event.getNewValueData()));
break;
case REMOVED:
queueItemListener.itemRemoved(new DataAwareItemEvent(listenerItem.name,ItemEventType.REMOVED,event.getNewValueData()));
break;
}
break;
}
}","private void callListener(final ListenerItem listenerItem,final DataAwareEntryEvent event){
  if (listenerItem.localListener && !event.firedLocally) {
    return;
  }
  final Object listener=listenerItem.listener;
  final EntryEventType entryEventType=event.getEventType();
  if (listenerItem.instanceType == Instance.InstanceType.MAP) {
    if (!listenerItem.name.startsWith(Prefix.MAP_HAZELCAST)) {
      Object proxy=node.factory.getOrCreateProxyByName(listenerItem.name);
      if (proxy instanceof MProxy) {
        MProxy mProxy=(MProxy)proxy;
        mProxy.getMapOperationCounter().incrementReceivedEvents();
      }
    }
  }
 else   if (listenerItem.instanceType == Instance.InstanceType.QUEUE) {
    if (!listenerItem.name.startsWith(Prefix.QUEUE_HAZELCAST)) {
      Object proxy=node.factory.getOrCreateProxyByName(listenerItem.name);
      if (proxy instanceof QProxy) {
        QProxy qProxy=(QProxy)proxy;
        qProxy.getQueueOperationCounter().incrementReceivedEvents();
      }
    }
  }
 else   if (listenerItem.instanceType == Instance.InstanceType.TOPIC) {
    if (!listenerItem.name.startsWith(Prefix.TOPIC_HAZELCAST)) {
      Object proxy=node.factory.getOrCreateProxyByName(listenerItem.name);
      if (proxy instanceof TopicProxy) {
        TopicProxy tProxy=(TopicProxy)proxy;
        tProxy.getTopicOperationCounter().incrementReceivedMessages();
      }
    }
  }
  final EntryEvent event2=listenerItem.includeValue ? event : (event.getNewValueData() != null ? new DataAwareEntryEvent(event.getMember(),event.getEventType().getType(),event.getLongName(),event.getKeyData(),null,null,event.firedLocally) : event);
switch (listenerItem.instanceType) {
case MAP:
case MULTIMAP:
    EntryListener entryListener=(EntryListener)listener;
switch (entryEventType) {
case ADDED:
    entryListener.entryAdded(event2);
  break;
case REMOVED:
entryListener.entryRemoved(event2);
break;
case UPDATED:
entryListener.entryUpdated(event2);
break;
case EVICTED:
entryListener.entryEvicted(event2);
break;
}
break;
case SET:
case LIST:
ItemListener itemListener=(ItemListener)listener;
switch (entryEventType) {
case ADDED:
itemListener.itemAdded(new DataAwareItemEvent(listenerItem.name,ItemEventType.ADDED,event.getKeyData()));
break;
case REMOVED:
itemListener.itemRemoved(new DataAwareItemEvent(listenerItem.name,ItemEventType.REMOVED,event.getKeyData()));
break;
}
break;
case TOPIC:
MessageListener messageListener=(MessageListener)listener;
messageListener.onMessage(new DataMessage(listenerItem.name,event.getNewValueData()));
break;
case QUEUE:
ItemListener queueItemListener=(ItemListener)listener;
switch (entryEventType) {
case ADDED:
queueItemListener.itemAdded(new DataAwareItemEvent(listenerItem.name,ItemEventType.ADDED,event.getNewValueData()));
break;
case REMOVED:
queueItemListener.itemRemoved(new DataAwareItemEvent(listenerItem.name,ItemEventType.REMOVED,event.getNewValueData()));
break;
}
break;
}
}",0.9988064791133844
49640,"void markAsRemoved(Record record){
  if (record.isActive()) {
    record.markRemoved();
  }
  record.setValueData(null);
  record.setMultiValues(null);
  updateIndexes(record);
  markAsDirty(record);
}","void markAsRemoved(Record record){
  markAsEvicted(record);
  markAsDirty(record);
}",0.5473684210526316
49641,"void markAsRemoved(Record record){
  if (record.isActive()) {
    record.markRemoved();
  }
  record.setValueData(null);
  record.setMultiValues(null);
  updateIndexes(record);
  markAsDirty(record);
}","void markAsRemoved(Record record){
  markAsEvicted(record);
  markAsDirty(record);
}",0.5473684210526316
49642,"ConcurrentMapManager(final Node node){
  super(node);
  recordFactory=node.initializer.getRecordFactory();
  storeExecutor=node.executorManager.newParallelExecutor(node.groupProperties.EXECUTOR_STORE_THREAD_COUNT.getInteger());
  evictionExecutor=node.executorManager.newParallelExecutor(node.groupProperties.EXECUTOR_STORE_THREAD_COUNT.getInteger());
  PARTITION_COUNT=node.groupProperties.CONCURRENT_MAP_PARTITION_COUNT.getInteger();
  MAX_BACKUP_COUNT=PartitionInfo.MAX_REPLICA_COUNT;
  GLOBAL_REMOVE_DELAY_MILLIS=node.groupProperties.REMOVE_DELAY_SECONDS.getLong() * 1000L;
  LOG_STATE=node.groupProperties.LOG_STATE.getBoolean();
  maps=new ConcurrentHashMap<String,CMap>(10,0.75f,1);
  mapCaches=new ConcurrentHashMap<String,NearCache>(10,0.75f,1);
  partitionManager=new PartitionManager(this);
  partitionServiceImpl=new PartitionServiceImpl(this);
  node.executorManager.getScheduledExecutorService().scheduleAtFixedRate(new Runnable(){
    public void run(){
      for (      CMap cMap : maps.values()) {
        cMap.startCleanup(false);
      }
    }
  }
,1,1,TimeUnit.SECONDS);
  registerPacketProcessor(CONCURRENT_MAP_GET_MAP_ENTRY,new GetMapEntryOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_GET_DATA_RECORD_ENTRY,new GetDataRecordEntryOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_GET,new GetOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ASYNC_MERGE,new AsyncMergePacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_WAN_MERGE,new WanMergePacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_MERGE,new MergeOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_TRY_PUT,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_SET,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT_AND_UNLOCK,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT_TRANSIENT,new PutTransientOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT_IF_ABSENT,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REPLACE_IF_NOT_NULL,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REPLACE_IF_SAME,new ReplaceOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT_MULTI,new PutMultiOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE,new RemoveOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_EVICT,new EvictOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE_IF_SAME,new RemoveIfSameOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE_ITEM,new RemoveItemOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_PUT,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_ADD,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_REMOVE_MULTI,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_REMOVE,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_LOCK,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_LOCK,new LockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_TRY_LOCK_AND_GET,new LockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_UNLOCK,new UnlockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_FORCE_UNLOCK,new ForceUnlockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_LOCK_MAP,new LockMapOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_UNLOCK_MAP,new LockMapOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE_MULTI,new RemoveMultiOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ADD_TO_LIST,new AddOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ADD_TO_SET,new AddOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_CONTAINS_KEY,new ContainsKeyOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_CONTAINS_ENTRY,new ContainsEntryOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_CONTAINS_VALUE,new ContainsValueOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_VALUE_COUNT,new ValueCountOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_INVALIDATE,new InvalidateOperationHandler());
  registerPacketProcessor(ATOMIC_NUMBER_ADD_AND_GET,new AtomicNumberAddAndGetOperationHandler());
  registerPacketProcessor(ATOMIC_NUMBER_COMPARE_AND_SET,new AtomicNumberCompareAndSetOperationHandler());
  registerPacketProcessor(ATOMIC_NUMBER_GET_AND_ADD,new AtomicNumberGetAndAddOperationHandler());
  registerPacketProcessor(ATOMIC_NUMBER_GET_AND_SET,new AtomicNumberGetAndSetOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_AWAIT,new CountDownLatchAwaitOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_COUNT_DOWN,new CountDownLatchCountDownOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_DESTROY,new CountDownLatchDestroyOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_GET_COUNT,new CountDownLatchGetCountOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_GET_OWNER,new CountDownLatchGetOwnerOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_SET_COUNT,new CountDownLatchSetCountOperationHandler());
  registerPacketProcessor(SEMAPHORE_ATTACH_DETACH_PERMITS,new SemaphoreAttachDetachOperationHandler());
  registerPacketProcessor(SEMAPHORE_CANCEL_ACQUIRE,new SemaphoreCancelAcquireOperationHandler());
  registerPacketProcessor(SEMAPHORE_DESTROY,new SemaphoreDestroyOperationHandler());
  registerPacketProcessor(SEMAPHORE_DRAIN_PERMITS,new SemaphoreDrainOperationHandler());
  registerPacketProcessor(SEMAPHORE_GET_ATTACHED_PERMITS,new SemaphoreGetAttachedOperationHandler());
  registerPacketProcessor(SEMAPHORE_GET_AVAILABLE_PERMITS,new SemaphoreGetAvailableOperationHandler());
  registerPacketProcessor(SEMAPHORE_REDUCE_PERMITS,new SemaphoreReduceOperationHandler());
  registerPacketProcessor(SEMAPHORE_RELEASE,new SemaphoreReleaseOperationHandler());
  registerPacketProcessor(SEMAPHORE_TRY_ACQUIRE,new SemaphoreTryAcquireOperationHandler());
}","ConcurrentMapManager(final Node node){
  super(node);
  recordFactory=node.initializer.getRecordFactory();
  storeExecutor=node.executorManager.newParallelExecutor(node.groupProperties.EXECUTOR_STORE_THREAD_COUNT.getInteger());
  evictionExecutor=node.executorManager.newParallelExecutor(node.groupProperties.EXECUTOR_STORE_THREAD_COUNT.getInteger());
  PARTITION_COUNT=node.groupProperties.CONCURRENT_MAP_PARTITION_COUNT.getInteger();
  MAX_BACKUP_COUNT=PartitionInfo.MAX_REPLICA_COUNT;
  GLOBAL_REMOVE_DELAY_MILLIS=node.groupProperties.REMOVE_DELAY_SECONDS.getLong() * 1000L;
  LOG_STATE=node.groupProperties.LOG_STATE.getBoolean();
  maps=new ConcurrentHashMap<String,CMap>(10,0.75f,1);
  mapCaches=new ConcurrentHashMap<String,NearCache>(10,0.75f,1);
  partitionManager=new PartitionManager(this);
  partitionServiceImpl=new PartitionServiceImpl(this);
  node.executorManager.getScheduledExecutorService().scheduleAtFixedRate(new Runnable(){
    public void run(){
      for (      CMap cMap : maps.values()) {
        cMap.startCleanup(false);
      }
    }
  }
,1,1,TimeUnit.SECONDS);
  registerPacketProcessor(CONCURRENT_MAP_GET_MAP_ENTRY,new GetMapEntryOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_GET_DATA_RECORD_ENTRY,new GetDataRecordEntryOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_GET,new GetOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ASYNC_MERGE,new AsyncMergePacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_WAN_MERGE,new WanMergePacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_MERGE,new MergeOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_TRY_PUT,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_SET,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT_AND_UNLOCK,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT_IF_ABSENT,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REPLACE_IF_NOT_NULL,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT_TRANSIENT,new PutTransientOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REPLACE_IF_SAME,new ReplaceOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT_MULTI,new PutMultiOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE,new RemoveOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_EVICT,new EvictOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE_IF_SAME,new RemoveIfSameOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE_ITEM,new RemoveItemOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_PUT,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_ADD,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_REMOVE_MULTI,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_REMOVE,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_LOCK,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_LOCK,new LockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_TRY_LOCK_AND_GET,new LockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_UNLOCK,new UnlockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_FORCE_UNLOCK,new ForceUnlockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_LOCK_MAP,new LockMapOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_UNLOCK_MAP,new LockMapOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE_MULTI,new RemoveMultiOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ADD_TO_LIST,new AddOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ADD_TO_SET,new AddOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_CONTAINS_KEY,new ContainsKeyOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_CONTAINS_ENTRY,new ContainsEntryOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_CONTAINS_VALUE,new ContainsValueOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_VALUE_COUNT,new ValueCountOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_INVALIDATE,new InvalidateOperationHandler());
  registerPacketProcessor(ATOMIC_NUMBER_ADD_AND_GET,new AtomicNumberAddAndGetOperationHandler());
  registerPacketProcessor(ATOMIC_NUMBER_COMPARE_AND_SET,new AtomicNumberCompareAndSetOperationHandler());
  registerPacketProcessor(ATOMIC_NUMBER_GET_AND_ADD,new AtomicNumberGetAndAddOperationHandler());
  registerPacketProcessor(ATOMIC_NUMBER_GET_AND_SET,new AtomicNumberGetAndSetOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_AWAIT,new CountDownLatchAwaitOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_COUNT_DOWN,new CountDownLatchCountDownOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_DESTROY,new CountDownLatchDestroyOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_GET_COUNT,new CountDownLatchGetCountOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_GET_OWNER,new CountDownLatchGetOwnerOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_SET_COUNT,new CountDownLatchSetCountOperationHandler());
  registerPacketProcessor(SEMAPHORE_ATTACH_DETACH_PERMITS,new SemaphoreAttachDetachOperationHandler());
  registerPacketProcessor(SEMAPHORE_CANCEL_ACQUIRE,new SemaphoreCancelAcquireOperationHandler());
  registerPacketProcessor(SEMAPHORE_DESTROY,new SemaphoreDestroyOperationHandler());
  registerPacketProcessor(SEMAPHORE_DRAIN_PERMITS,new SemaphoreDrainOperationHandler());
  registerPacketProcessor(SEMAPHORE_GET_ATTACHED_PERMITS,new SemaphoreGetAttachedOperationHandler());
  registerPacketProcessor(SEMAPHORE_GET_AVAILABLE_PERMITS,new SemaphoreGetAvailableOperationHandler());
  registerPacketProcessor(SEMAPHORE_REDUCE_PERMITS,new SemaphoreReduceOperationHandler());
  registerPacketProcessor(SEMAPHORE_RELEASE,new SemaphoreReleaseOperationHandler());
  registerPacketProcessor(SEMAPHORE_TRY_ACQUIRE,new SemaphoreTryAcquireOperationHandler());
}",0.9720597790773228
49643,"void putAndUnlock(String name,Object key,Object value){
  ThreadContext tc=ThreadContext.get();
  Data dataKey=toData(key);
  CMap cmap=getMap(name);
  LocalLock localLock=cmap.mapLocalLocks.get(dataKey);
  boolean shouldUnlock=localLock != null && localLock.getThreadId() == tc.getThreadId() && localLock.getCount() == 1;
  MPut mput=tc.getCallCache(node.factory).getMPut();
  if (shouldUnlock) {
    mput.txnalPut(CONCURRENT_MAP_PUT_AND_UNLOCK,name,key,value,-1,-1);
    cmap.mapLocalLocks.remove(dataKey);
  }
 else {
    mput.txnalPut(CONCURRENT_MAP_PUT,name,key,value,-1,-1);
    localLock.decrementAndGet();
  }
  mput.clearRequest();
}","void putAndUnlock(String name,Object key,Object value){
  ThreadContext tc=ThreadContext.get();
  Data dataKey=toData(key);
  CMap cmap=getMap(name);
  LocalLock localLock=cmap.mapLocalLocks.get(dataKey);
  boolean shouldUnlock=localLock != null && localLock.getThreadId() == tc.getThreadId() && localLock.getCount() == 1;
  MPut mput=tc.getCallCache(node.factory).getMPut();
  if (shouldUnlock) {
    mput.txnalPut(CONCURRENT_MAP_PUT_AND_UNLOCK,name,key,value,-1,-1);
    cmap.mapLocalLocks.remove(dataKey);
  }
 else {
    mput.txnalPut(CONCURRENT_MAP_PUT,name,key,value,-1,-1);
    if (localLock != null) {
      localLock.decrementAndGet();
    }
  }
  mput.clearRequest();
}",0.971990915972748
49644,"public void run(){
  try {
    q.take();
    fail();
  }
 catch (  InterruptedException e) {
    latch.countDown();
  }
}","public void run(){
  latch.countDown();
  map.putIfAbsent(""String_Node_Str"",""String_Node_Str"");
  latch.countDown();
}",0.3682008368200837
49645,"@Test public void testMapRemoveWithWriteBehindMapStore(){
  Config c=new Config();
  TestMapStore mapStore=new TestMapStore();
  mapStore.setLoadAllKeys(false);
  for (int i=1; i < 5; i++) {
    mapStore.store(i,""String_Node_Str"" + i);
  }
  c.getMapConfig(""String_Node_Str"").setMapStoreConfig(new MapStoreConfig().setEnabled(true).setWriteDelaySeconds(100).setImplementation(mapStore));
  HazelcastInstance hz=Hazelcast.newHazelcastInstance(c);
  Map map=hz.getMap(""String_Node_Str"");
  assertEquals(""String_Node_Str"",map.get(1));
  assertEquals(""String_Node_Str"",map.remove(1));
  assertNull(map.get(1));
  assertEquals(""String_Node_Str"",map.get(2));
  assertEquals(""String_Node_Str"",map.remove(2));
  assertFalse(map.containsKey(2));
  assertEquals(""String_Node_Str"",map.get(3));
  assertEquals(""String_Node_Str"",map.remove(3));
  assertNull(map.put(3,""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.get(4));
  assertEquals(""String_Node_Str"",map.remove(4));
  assertNull(map.remove(4));
}","@Test public void testMapRemoveWithWriteBehindMapStore(){
  Config c=new Config();
  TestMapStore mapStore=new TestMapStore();
  mapStore.setLoadAllKeys(false);
  for (int i=1; i < 6; i++) {
    mapStore.store(i,""String_Node_Str"" + i);
  }
  c.getMapConfig(""String_Node_Str"").setMapStoreConfig(new MapStoreConfig().setEnabled(true).setWriteDelaySeconds(100).setImplementation(mapStore));
  HazelcastInstance hz=Hazelcast.newHazelcastInstance(c);
  IMap map=hz.getMap(""String_Node_Str"");
  assertEquals(""String_Node_Str"",map.get(1));
  assertEquals(""String_Node_Str"",map.remove(1));
  assertNull(map.get(1));
  assertEquals(""String_Node_Str"",map.get(2));
  assertEquals(""String_Node_Str"",map.remove(2));
  assertFalse(map.containsKey(2));
  assertEquals(""String_Node_Str"",map.get(3));
  assertEquals(""String_Node_Str"",map.remove(3));
  assertNull(map.put(3,""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.get(4));
  assertEquals(""String_Node_Str"",map.remove(4));
  assertNull(map.remove(4));
  assertEquals(""String_Node_Str"",map.get(5));
  assertEquals(""String_Node_Str"",map.remove(5));
  assertNull(map.putIfAbsent(5,""String_Node_Str""));
}",0.9302325581395348
49646,"public Collection<MemberGroup> createMemberGroups(Collection<MemberImpl> members){
  Map<String,MemberGroup> groups=new HashMap<String,MemberGroup>();
  for (  MemberImpl member : members) {
    if (!member.isLiteMember()) {
      Address address=member.getAddress();
      MemberGroup group=groups.get(address.getHost());
      if (group == null) {
        group=new DefaultMemberGroup();
        groups.put(address.getHost(),group);
      }
      group.addMember(member);
    }
  }
  return groups.values();
}","public Collection<MemberGroup> createMemberGroups(Collection<MemberImpl> members){
  final Collection<MemberGroup> groups=createHostAwareMemberGroups(members);
  if (groups.size() == 1 && members.size() >= 2) {
    MemberGroup group1=groups.iterator().next();
    MemberGroup group2=new DefaultMemberGroup();
    final int sizePerGroup=group1.size() / 2;
    Iterator<MemberImpl> iter=group1.iterator();
    while (group2.size() < sizePerGroup && iter.hasNext()) {
      group2.addMember(iter.next());
      iter.remove();
    }
    groups.add(group2);
  }
  return groups;
}",0.2375690607734806
49647,"public PartitionStateGeneratorImpl(MemberGroupFactory nodeGroupFactory){
  super();
  this.memberGroupFactory=nodeGroupFactory;
}","public PartitionStateGeneratorImpl(MemberGroupFactory memberGroupFactory){
  super();
  this.memberGroupFactory=memberGroupFactory;
}",0.9389312977099236
49648,"public void remove(){
  throw new UnsupportedOperationException();
}","public void remove(){
  if (end) {
    member=null;
  }
}",0.528
49649,"public void finalizeJoin(){
  Set<Member> members=node.getClusterImpl().getMembers();
  List<AsyncRemotelyBooleanCallable> calls=new ArrayList<AsyncRemotelyBooleanCallable>();
  for (  Member m : members) {
    MemberImpl member=(MemberImpl)m;
    if (!member.localMember() && !member.isSuperClient()) {
      AsyncRemotelyBooleanCallable rrp=new AsyncRemotelyBooleanCallable();
      rrp.executeProcess(member.getAddress(),new FinalizeJoin());
      calls.add(rrp);
    }
  }
  for (  AsyncRemotelyBooleanCallable call : calls) {
    call.getResultAsBoolean();
  }
}","public void finalizeJoin(){
  Set<Member> members=node.getClusterImpl().getMembers();
  List<AsyncRemotelyBooleanCallable> calls=new ArrayList<AsyncRemotelyBooleanCallable>();
  for (  Member m : members) {
    MemberImpl member=(MemberImpl)m;
    if (!member.localMember() && !member.isLiteMember()) {
      AsyncRemotelyBooleanCallable rrp=new AsyncRemotelyBooleanCallable();
      rrp.executeProcess(member.getAddress(),new FinalizeJoin());
      calls.add(rrp);
    }
  }
  for (  AsyncRemotelyBooleanCallable call : calls) {
    call.getResultAsBoolean();
  }
}",0.9814651368049426
49650,"/** 
 * @see #isLiteMember()
 * @deprecated as of 2.0
 */
public boolean isSuperClient(){
  return liteMember;
}","/** 
 * @see #isLiteMember()
 * @deprecated as of 2.0
 */
@Deprecated public boolean isSuperClient(){
  return liteMember;
}",0.9491525423728814
49651,"/** 
 * @see #setLiteMember(boolean)
 * @deprecated as of 2.0
 */
public Config setSuperClient(boolean liteMember){
  this.liteMember=liteMember;
  return this;
}","/** 
 * @see #setLiteMember(boolean)
 * @deprecated as of 2.0
 */
@Deprecated public Config setSuperClient(boolean liteMember){
  this.liteMember=liteMember;
  return this;
}",0.9642857142857144
49652,"T call(){
  try {
    node.checkNodeState();
    onCall();
    Object result=null;
    boolean excludeThisMember=excludeSuperClient && thisMember.isSuperClient();
    if (!excludeThisMember) {
      SubCall localCall=createNewTargetAwareOp(getFirstAddressToMakeCall());
      localCall.doOp();
      result=localCall.getResultAsObject();
      if (result == OBJECT_REDO) {
        logRedo(localCall);
        onRedo();
        Thread.sleep(redoWaitMillis);
        return call();
      }
    }
    boolean runOnOtherMembers=excludeThisMember || onResponse(result);
    if (runOnOtherMembers) {
      Set<Member> members=node.getClusterImpl().getMembers();
      List<SubCall> lsCalls=new ArrayList<SubCall>();
      for (      Member member : members) {
        MemberImpl cMember=(MemberImpl)member;
        boolean excludeMember=excludeSuperClient && cMember.isSuperClient();
        if (!excludeMember && !cMember.getAddress().equals(getFirstAddressToMakeCall())) {
          SubCall subCall=createNewTargetAwareOp(cMember.getAddress());
          subCall.doOp();
          lsCalls.add(subCall);
        }
      }
      for (      SubCall call : lsCalls) {
        result=call.getResultAsObject();
        if (result == OBJECT_REDO) {
          logRedo(call);
          onRedo();
          Thread.sleep(redoWaitMillis);
          return call();
        }
 else {
          if (!onResponse(result)) {
            break;
          }
        }
      }
      onComplete();
    }
  }
 catch (  InterruptedException e) {
    throw new RuntimeException(e);
  }
  return (T)returnResult();
}","T call(){
  try {
    node.checkNodeState();
    onCall();
    Object result=null;
    final boolean excludeThisMember=excludeLiteMember() && thisMember.isLiteMember();
    if (!excludeThisMember) {
      SubCall localCall=createNewTargetAwareOp(getFirstAddressToMakeCall());
      localCall.doOp();
      result=localCall.getResultAsObject();
      if (result == OBJECT_REDO) {
        logRedo(localCall);
        onRedo();
        Thread.sleep(redoWaitMillis);
        return call();
      }
    }
    final boolean runOnOtherMembers=excludeThisMember || onResponse(result);
    if (runOnOtherMembers) {
      Set<Member> members=node.getClusterImpl().getMembers();
      List<SubCall> lsCalls=new ArrayList<SubCall>();
      for (      Member member : members) {
        MemberImpl cMember=(MemberImpl)member;
        final boolean excludeMember=excludeLiteMember() && cMember.isLiteMember();
        if (!excludeMember && !cMember.getAddress().equals(getFirstAddressToMakeCall())) {
          SubCall subCall=createNewTargetAwareOp(cMember.getAddress());
          subCall.doOp();
          lsCalls.add(subCall);
        }
      }
      for (      SubCall call : lsCalls) {
        result=call.getResultAsObject();
        if (result == OBJECT_REDO) {
          logRedo(call);
          onRedo();
          Thread.sleep(redoWaitMillis);
          return call();
        }
 else {
          if (!onResponse(result)) {
            break;
          }
        }
      }
      onComplete();
    }
  }
 catch (  InterruptedException e) {
    throw new RuntimeException(e);
  }
  return (T)returnResult();
}",0.9667711598746082
49653,"protected MemberImpl getNextMemberAfter(final List<MemberImpl> lsMembers,final Address address,final boolean skipSuperClient,final int distance){
  final int size=lsMembers.size();
  if (size <= 1)   return null;
  int indexOfMember=-1;
  for (int i=0; i < size; i++) {
    final MemberImpl member=lsMembers.get(i);
    if (member.getAddress().equals(address)) {
      indexOfMember=i;
    }
  }
  if (indexOfMember == -1)   return null;
  int foundDistance=0;
  for (int i=indexOfMember; i < size + indexOfMember; i++) {
    final MemberImpl member=lsMembers.get((1 + i) % size);
    if (!(skipSuperClient && member.isSuperClient())) {
      foundDistance++;
    }
    if (foundDistance == distance) {
      return member;
    }
  }
  return null;
}","protected MemberImpl getNextMemberAfter(final List<MemberImpl> lsMembers,final Address address,final boolean skipSuperClient,final int distance){
  final int size=lsMembers.size();
  if (size <= 1)   return null;
  int indexOfMember=-1;
  for (int i=0; i < size; i++) {
    final MemberImpl member=lsMembers.get(i);
    if (member.getAddress().equals(address)) {
      indexOfMember=i;
    }
  }
  if (indexOfMember == -1)   return null;
  int foundDistance=0;
  for (int i=indexOfMember; i < size + indexOfMember; i++) {
    final MemberImpl member=lsMembers.get((1 + i) % size);
    if (!(skipSuperClient && member.isLiteMember())) {
      foundDistance++;
    }
    if (foundDistance == distance) {
      return member;
    }
  }
  return null;
}",0.9859906604402936
49654,"public boolean isSuperClient(){
  return (nodeType == NodeType.LITE_MEMBER);
}","@Deprecated public boolean isSuperClient(){
  return isLiteMember();
}",0.6216216216216216
49655,"@JMXAttribute(""String_Node_Str"") @JMXDescription(""String_Node_Str"") public boolean isSuperClient(){
  return getManagedObject().isSuperClient();
}","@JMXAttribute(""String_Node_Str"") @JMXDescription(""String_Node_Str"") public boolean isSuperClient(){
  return getManagedObject().isLiteMember();
}",0.9415807560137456
49656,"public PredicateBuilder or(Predicate predicate){
  int index=lsPredicates.size() - 2;
  Predicate first=lsPredicates.remove(index);
  Predicate second=lsPredicates.remove(index);
  lsPredicates.add(Predicates.or(first,second));
  return this;
}","public PredicateBuilder or(Predicate predicate){
  if (predicate != PredicateBuilder.this) {
    throw new RuntimeException(""String_Node_Str"" + PredicateBuilder.class.getSimpleName() + ""String_Node_Str""+ ((predicate == null) ? ""String_Node_Str"" : predicate.getClass().getSimpleName()));
  }
  int index=lsPredicates.size() - 2;
  Predicate first=lsPredicates.remove(index);
  Predicate second=lsPredicates.remove(index);
  lsPredicates.add(Predicates.or(first,second));
  return this;
}",0.6493150684931507
49657,"public PredicateBuilder and(Predicate predicate){
  int index=lsPredicates.size() - 2;
  Predicate first=lsPredicates.remove(index);
  Predicate second=lsPredicates.remove(index);
  lsPredicates.add(Predicates.and(first,second));
  return this;
}","public PredicateBuilder and(Predicate predicate){
  if (predicate != PredicateBuilder.this) {
    throw new RuntimeException(""String_Node_Str"" + PredicateBuilder.class.getSimpleName() + ""String_Node_Str""+ ((predicate == null) ? ""String_Node_Str"" : predicate.getClass().getSimpleName()));
  }
  int index=lsPredicates.size() - 2;
  Predicate first=lsPredicates.remove(index);
  Predicate second=lsPredicates.remove(index);
  lsPredicates.add(Predicates.and(first,second));
  return this;
}",0.6512261580381471
49658,"@Override public String toString(){
  final StringBuffer sb=new StringBuffer();
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(lsPredicates.get(0));
  sb.append(""String_Node_Str"");
  return sb.toString();
}","@Override public String toString(){
  final StringBuffer sb=new StringBuffer();
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(lsPredicates.size() == 0 ? ""String_Node_Str"" : lsPredicates.get(0));
  sb.append(""String_Node_Str"");
  return sb.toString();
}",0.8936170212765957
49659,"protected void handleCommand(String command){
  if (command.contains(""String_Node_Str"")) {
    namespace=command.split(""String_Node_Str"")[0];
    command=command.substring(command.indexOf(""String_Node_Str"") + 1);
  }
  if (echo) {
    if (Thread.currentThread().getName().toLowerCase().indexOf(""String_Node_Str"") < 0)     println(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str""+ command);
 else     println(command);
  }
  if (command == null || command.startsWith(""String_Node_Str""))   return;
  command=command.trim();
  if (command == null || command.length() == 0) {
    return;
  }
  String first=command;
  int spaceIndex=command.indexOf(' ');
  String[] argsSplit=command.split(""String_Node_Str"");
  String[] args=new String[argsSplit.length];
  for (int i=0; i < argsSplit.length; i++) {
    args[i]=argsSplit[i].trim();
  }
  if (spaceIndex != -1) {
    first=args[0];
  }
  if (command.startsWith(""String_Node_Str"")) {
    handleHelp(command);
  }
 else   if (first.startsWith(""String_Node_Str"") && first.length() > 1) {
    int repeat=Integer.parseInt(first.substring(1));
    long t0=System.currentTimeMillis();
    for (int i=0; i < repeat; i++) {
      handleCommand(command.substring(first.length()).replaceAll(""String_Node_Str"",""String_Node_Str"" + i));
    }
    println(""String_Node_Str"" + repeat * 1000 / (System.currentTimeMillis() - t0));
    return;
  }
 else   if (first.startsWith(""String_Node_Str"") && first.length() > 1) {
    final int fork=Integer.parseInt(first.substring(1));
    ExecutorService pool=Executors.newFixedThreadPool(fork);
    final String threadCommand=command.substring(first.length());
    for (int i=0; i < fork; i++) {
      final int threadID=i;
      pool.submit(new Runnable(){
        public void run(){
          String command=threadCommand;
          String[] threadArgs=command.replaceAll(""String_Node_Str"",""String_Node_Str"" + threadID).trim().split(""String_Node_Str"");
          if (""String_Node_Str"".equals(threadArgs[0]) || ""String_Node_Str"".equals(threadArgs[0])) {
            if (threadArgs.length < 4) {
              command+=""String_Node_Str"" + Integer.parseInt(threadArgs[1]) * threadID;
            }
          }
          handleCommand(command);
        }
      }
);
    }
    pool.shutdown();
    try {
      pool.awaitTermination(60 * 60,TimeUnit.SECONDS);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
 else   if (first.startsWith(""String_Node_Str"")) {
    if (first.length() == 1) {
      println(""String_Node_Str"");
      return;
    }
    File f=new File(first.substring(1));
    println(""String_Node_Str"" + f.getAbsolutePath());
    if (f.exists()) {
      try {
        BufferedReader br=new BufferedReader(new FileReader(f));
        String l=br.readLine();
        while (l != null) {
          handleCommand(l);
          l=br.readLine();
        }
        br.close();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
 else {
      println(""String_Node_Str"" + f.getAbsolutePath());
    }
  }
 else   if (command.indexOf(';') != -1) {
    StringTokenizer st=new StringTokenizer(command,""String_Node_Str"");
    while (st.hasMoreTokens()) {
      handleCommand(st.nextToken());
    }
    return;
  }
 else   if (""String_Node_Str"".equals(first)) {
    silent=Boolean.parseBoolean(args[1]);
  }
 else   if (""String_Node_Str"".equals(first)) {
    hazelcast.restart();
  }
 else   if (""String_Node_Str"".equals(first)) {
    hazelcast.shutdown();
  }
 else   if (""String_Node_Str"".equals(first)) {
    echo=Boolean.parseBoolean(args[1]);
    println(""String_Node_Str"" + echo);
  }
 else   if (""String_Node_Str"".equals(first)) {
    if (args.length > 1) {
      namespace=args[1];
      println(""String_Node_Str"" + namespace);
    }
  }
 else   if (""String_Node_Str"".equals(first)) {
    println(hazelcast.getCluster().getLocalMember());
  }
 else   if (""String_Node_Str"".equals(first)) {
    println(hazelcast.getCluster());
  }
 else   if (""String_Node_Str"".equals(first)) {
    System.gc();
    println(""String_Node_Str"" + Runtime.getRuntime().maxMemory() / 1024 / 1024 + ""String_Node_Str"");
    println(""String_Node_Str"" + Runtime.getRuntime().freeMemory() / 1024 / 1024 + ""String_Node_Str"" + (int)(Runtime.getRuntime().freeMemory() * 100 / Runtime.getRuntime().maxMemory()) + ""String_Node_Str"");
    long total=Runtime.getRuntime().totalMemory();
    long free=Runtime.getRuntime().freeMemory();
    println(""String_Node_Str"" + ((total - free) / 1024 / 1024) + ""String_Node_Str"");
    println(""String_Node_Str"" + Runtime.getRuntime().availableProcessors());
    println(""String_Node_Str"" + ManagementFactory.getOperatingSystemMXBean().getArch() + ""String_Node_Str""+ ManagementFactory.getOperatingSystemMXBean().getName()+ ""String_Node_Str""+ ManagementFactory.getOperatingSystemMXBean().getVersion());
    println(""String_Node_Str"" + ManagementFactory.getRuntimeMXBean().getVmVendor() + ""String_Node_Str""+ ManagementFactory.getRuntimeMXBean().getVmName()+ ""String_Node_Str""+ ManagementFactory.getRuntimeMXBean().getVmVersion());
  }
 else   if (first.indexOf(""String_Node_Str"") != -1 && first.indexOf(""String_Node_Str"") == -1) {
    handleLock(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleSize(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleClear(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleDestroy(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleIterator(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleContains(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handStats(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleTopicPublish(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQOffer(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQTake(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQPoll(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQPeek(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQCapacity(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQOfferMany(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQPollMany(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleSetAdd(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleSetRemove(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleSetAddMany(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleSetRemoveMany(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapReplace(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    handleMapPutIfAbsent(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapPutAsync(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapGetAsync(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapPut(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapGet(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    handleMapGetMapEntry(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapRemove(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapEvict(args);
  }
 else   if (first.equals(""String_Node_Str"") || first.equalsIgnoreCase(""String_Node_Str"")) {
    handleMapPutMany(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapGetMany(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapRemoveMany(args);
  }
 else   if (command.equalsIgnoreCase(""String_Node_Str"")) {
    handleMapLocalKeys();
  }
 else   if (command.equals(""String_Node_Str"")) {
    handleMapKeys();
  }
 else   if (command.equals(""String_Node_Str"")) {
    handleMapValues();
  }
 else   if (command.equals(""String_Node_Str"")) {
    handleMapEntries();
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapLock(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    handleMapTryLock(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapUnlock(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleAddListener(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleRemoveListener(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapUnlock(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleListAdd(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleListSet(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleListAddMany(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleListRemove(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleListContains(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleAtomicNumberGet(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleAtomicNumberSet(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleAtomicNumberInc(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleAtomicNumberDec(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    execute(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handlePartitions(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    hazelcast.getTransaction().begin();
  }
 else   if (first.equals(""String_Node_Str"")) {
    hazelcast.getTransaction().commit();
  }
 else   if (first.equals(""String_Node_Str"")) {
    hazelcast.getTransaction().rollback();
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    executeOnKey(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    executeOnMember(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    executeOnMembers(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"") || first.equalsIgnoreCase(""String_Node_Str"")) {
    executeLongTaskOnOtherMember(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"") || first.equalsIgnoreCase(""String_Node_Str"")) {
    executeLong(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    handleInstances(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"") || first.equalsIgnoreCase(""String_Node_Str"")) {
    System.exit(0);
  }
 else {
    println(""String_Node_Str"");
  }
}","protected void handleCommand(String command){
  if (command.contains(""String_Node_Str"")) {
    namespace=command.split(""String_Node_Str"")[0];
    command=command.substring(command.indexOf(""String_Node_Str"") + 2);
  }
  if (echo) {
    if (Thread.currentThread().getName().toLowerCase().indexOf(""String_Node_Str"") < 0)     println(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str""+ command);
 else     println(command);
  }
  if (command == null || command.startsWith(""String_Node_Str""))   return;
  command=command.trim();
  if (command == null || command.length() == 0) {
    return;
  }
  String first=command;
  int spaceIndex=command.indexOf(' ');
  String[] argsSplit=command.split(""String_Node_Str"");
  String[] args=new String[argsSplit.length];
  for (int i=0; i < argsSplit.length; i++) {
    args[i]=argsSplit[i].trim();
  }
  if (spaceIndex != -1) {
    first=args[0];
  }
  if (command.startsWith(""String_Node_Str"")) {
    handleHelp(command);
  }
 else   if (first.startsWith(""String_Node_Str"") && first.length() > 1) {
    int repeat=Integer.parseInt(first.substring(1));
    long t0=System.currentTimeMillis();
    for (int i=0; i < repeat; i++) {
      handleCommand(command.substring(first.length()).replaceAll(""String_Node_Str"",""String_Node_Str"" + i));
    }
    println(""String_Node_Str"" + repeat * 1000 / (System.currentTimeMillis() - t0));
    return;
  }
 else   if (first.startsWith(""String_Node_Str"") && first.length() > 1) {
    final int fork=Integer.parseInt(first.substring(1));
    ExecutorService pool=Executors.newFixedThreadPool(fork);
    final String threadCommand=command.substring(first.length());
    for (int i=0; i < fork; i++) {
      final int threadID=i;
      pool.submit(new Runnable(){
        public void run(){
          String command=threadCommand;
          String[] threadArgs=command.replaceAll(""String_Node_Str"",""String_Node_Str"" + threadID).trim().split(""String_Node_Str"");
          if (""String_Node_Str"".equals(threadArgs[0]) || ""String_Node_Str"".equals(threadArgs[0])) {
            if (threadArgs.length < 4) {
              command+=""String_Node_Str"" + Integer.parseInt(threadArgs[1]) * threadID;
            }
          }
          handleCommand(command);
        }
      }
);
    }
    pool.shutdown();
    try {
      pool.awaitTermination(60 * 60,TimeUnit.SECONDS);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
 else   if (first.startsWith(""String_Node_Str"")) {
    if (first.length() == 1) {
      println(""String_Node_Str"");
      return;
    }
    File f=new File(first.substring(1));
    println(""String_Node_Str"" + f.getAbsolutePath());
    if (f.exists()) {
      try {
        BufferedReader br=new BufferedReader(new FileReader(f));
        String l=br.readLine();
        while (l != null) {
          handleCommand(l);
          l=br.readLine();
        }
        br.close();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
 else {
      println(""String_Node_Str"" + f.getAbsolutePath());
    }
  }
 else   if (command.indexOf(';') != -1) {
    StringTokenizer st=new StringTokenizer(command,""String_Node_Str"");
    while (st.hasMoreTokens()) {
      handleCommand(st.nextToken());
    }
    return;
  }
 else   if (""String_Node_Str"".equals(first)) {
    silent=Boolean.parseBoolean(args[1]);
  }
 else   if (""String_Node_Str"".equals(first)) {
    hazelcast.restart();
  }
 else   if (""String_Node_Str"".equals(first)) {
    hazelcast.shutdown();
  }
 else   if (""String_Node_Str"".equals(first)) {
    echo=Boolean.parseBoolean(args[1]);
    println(""String_Node_Str"" + echo);
  }
 else   if (""String_Node_Str"".equals(first)) {
    if (args.length > 1) {
      namespace=args[1];
      println(""String_Node_Str"" + namespace);
    }
  }
 else   if (""String_Node_Str"".equals(first)) {
    println(hazelcast.getCluster().getLocalMember());
  }
 else   if (""String_Node_Str"".equals(first)) {
    println(hazelcast.getCluster());
  }
 else   if (""String_Node_Str"".equals(first)) {
    System.gc();
    println(""String_Node_Str"" + Runtime.getRuntime().maxMemory() / 1024 / 1024 + ""String_Node_Str"");
    println(""String_Node_Str"" + Runtime.getRuntime().freeMemory() / 1024 / 1024 + ""String_Node_Str"" + (int)(Runtime.getRuntime().freeMemory() * 100 / Runtime.getRuntime().maxMemory()) + ""String_Node_Str"");
    long total=Runtime.getRuntime().totalMemory();
    long free=Runtime.getRuntime().freeMemory();
    println(""String_Node_Str"" + ((total - free) / 1024 / 1024) + ""String_Node_Str"");
    println(""String_Node_Str"" + Runtime.getRuntime().availableProcessors());
    println(""String_Node_Str"" + ManagementFactory.getOperatingSystemMXBean().getArch() + ""String_Node_Str""+ ManagementFactory.getOperatingSystemMXBean().getName()+ ""String_Node_Str""+ ManagementFactory.getOperatingSystemMXBean().getVersion());
    println(""String_Node_Str"" + ManagementFactory.getRuntimeMXBean().getVmVendor() + ""String_Node_Str""+ ManagementFactory.getRuntimeMXBean().getVmName()+ ""String_Node_Str""+ ManagementFactory.getRuntimeMXBean().getVmVersion());
  }
 else   if (first.indexOf(""String_Node_Str"") != -1 && first.indexOf(""String_Node_Str"") == -1) {
    handleLock(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleSize(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleClear(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleDestroy(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleIterator(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleContains(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handStats(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleTopicPublish(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQOffer(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQTake(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQPoll(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQPeek(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQCapacity(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQOfferMany(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQPollMany(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleSetAdd(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleSetRemove(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleSetAddMany(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleSetRemoveMany(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapReplace(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    handleMapPutIfAbsent(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapPutAsync(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapGetAsync(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapPut(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapGet(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    handleMapGetMapEntry(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapRemove(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapEvict(args);
  }
 else   if (first.equals(""String_Node_Str"") || first.equalsIgnoreCase(""String_Node_Str"")) {
    handleMapPutMany(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapGetMany(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapRemoveMany(args);
  }
 else   if (command.equalsIgnoreCase(""String_Node_Str"")) {
    handleMapLocalKeys();
  }
 else   if (command.equals(""String_Node_Str"")) {
    handleMapKeys();
  }
 else   if (command.equals(""String_Node_Str"")) {
    handleMapValues();
  }
 else   if (command.equals(""String_Node_Str"")) {
    handleMapEntries();
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapLock(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    handleMapTryLock(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapUnlock(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleAddListener(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleRemoveListener(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapUnlock(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleListAdd(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleListSet(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleListAddMany(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleListRemove(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleListContains(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleAtomicNumberGet(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleAtomicNumberSet(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleAtomicNumberInc(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleAtomicNumberDec(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    execute(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handlePartitions(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    hazelcast.getTransaction().begin();
  }
 else   if (first.equals(""String_Node_Str"")) {
    hazelcast.getTransaction().commit();
  }
 else   if (first.equals(""String_Node_Str"")) {
    hazelcast.getTransaction().rollback();
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    executeOnKey(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    executeOnMember(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    executeOnMembers(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"") || first.equalsIgnoreCase(""String_Node_Str"")) {
    executeLongTaskOnOtherMember(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"") || first.equalsIgnoreCase(""String_Node_Str"")) {
    executeLong(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    handleInstances(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"") || first.equalsIgnoreCase(""String_Node_Str"")) {
    System.exit(0);
  }
 else {
    println(""String_Node_Str"");
  }
}",0.9999038553985192
49660,"public void finalizeJoin(){
  Set<Member> members=node.getClusterImpl().getMembers();
  List<AsyncRemotelyBooleanCallable> calls=new ArrayList<AsyncRemotelyBooleanCallable>();
  for (  Member m : members) {
    MemberImpl member=(MemberImpl)m;
    if (!member.localMember() && !member.isSuperClient()) {
      AsyncRemotelyBooleanCallable rrp=new AsyncRemotelyBooleanCallable();
      rrp.executeProcess(member.getAddress(),new FinalizeJoin());
      calls.add(rrp);
    }
  }
  for (  AsyncRemotelyBooleanCallable call : calls) {
    call.getResultAsBoolean();
  }
}","public void finalizeJoin(){
  Set<Member> members=node.getClusterImpl().getMembers();
  List<AsyncRemotelyBooleanCallable> calls=new ArrayList<AsyncRemotelyBooleanCallable>();
  for (  Member m : members) {
    MemberImpl member=(MemberImpl)m;
    if (!member.localMember() && !member.isLiteMember()) {
      AsyncRemotelyBooleanCallable rrp=new AsyncRemotelyBooleanCallable();
      rrp.executeProcess(member.getAddress(),new FinalizeJoin());
      calls.add(rrp);
    }
  }
  for (  AsyncRemotelyBooleanCallable call : calls) {
    call.getResultAsBoolean();
  }
}",0.9814651368049426
49661,"/** 
 * @see #isLiteMember()
 * @deprecated as of 2.0
 */
public boolean isSuperClient(){
  return liteMember;
}","/** 
 * @see #isLiteMember()
 * @deprecated as of 2.0
 */
@Deprecated public boolean isSuperClient(){
  return liteMember;
}",0.9491525423728814
49662,"/** 
 * @see #setLiteMember(boolean)
 * @deprecated as of 2.0
 */
public Config setSuperClient(boolean liteMember){
  this.liteMember=liteMember;
  return this;
}","/** 
 * @see #setLiteMember(boolean)
 * @deprecated as of 2.0
 */
@Deprecated public Config setSuperClient(boolean liteMember){
  this.liteMember=liteMember;
  return this;
}",0.9642857142857144
49663,"T call(){
  try {
    node.checkNodeState();
    onCall();
    Object result=null;
    boolean excludeThisMember=excludeSuperClient && thisMember.isSuperClient();
    if (!excludeThisMember) {
      SubCall localCall=createNewTargetAwareOp(getFirstAddressToMakeCall());
      localCall.doOp();
      result=localCall.getResultAsObject();
      if (result == OBJECT_REDO) {
        logRedo(localCall);
        onRedo();
        Thread.sleep(redoWaitMillis);
        return call();
      }
    }
    boolean runOnOtherMembers=excludeThisMember || onResponse(result);
    if (runOnOtherMembers) {
      Set<Member> members=node.getClusterImpl().getMembers();
      List<SubCall> lsCalls=new ArrayList<SubCall>();
      for (      Member member : members) {
        MemberImpl cMember=(MemberImpl)member;
        boolean excludeMember=excludeSuperClient && cMember.isSuperClient();
        if (!excludeMember && !cMember.getAddress().equals(getFirstAddressToMakeCall())) {
          SubCall subCall=createNewTargetAwareOp(cMember.getAddress());
          subCall.doOp();
          lsCalls.add(subCall);
        }
      }
      for (      SubCall call : lsCalls) {
        result=call.getResultAsObject();
        if (result == OBJECT_REDO) {
          logRedo(call);
          onRedo();
          Thread.sleep(redoWaitMillis);
          return call();
        }
 else {
          if (!onResponse(result)) {
            break;
          }
        }
      }
      onComplete();
    }
  }
 catch (  InterruptedException e) {
    throw new RuntimeException(e);
  }
  return (T)returnResult();
}","T call(){
  try {
    node.checkNodeState();
    onCall();
    Object result=null;
    final boolean excludeThisMember=excludeLiteMember() && thisMember.isLiteMember();
    if (!excludeThisMember) {
      SubCall localCall=createNewTargetAwareOp(getFirstAddressToMakeCall());
      localCall.doOp();
      result=localCall.getResultAsObject();
      if (result == OBJECT_REDO) {
        logRedo(localCall);
        onRedo();
        Thread.sleep(redoWaitMillis);
        return call();
      }
    }
    final boolean runOnOtherMembers=excludeThisMember || onResponse(result);
    if (runOnOtherMembers) {
      Set<Member> members=node.getClusterImpl().getMembers();
      List<SubCall> lsCalls=new ArrayList<SubCall>();
      for (      Member member : members) {
        MemberImpl cMember=(MemberImpl)member;
        final boolean excludeMember=excludeLiteMember() && cMember.isLiteMember();
        if (!excludeMember && !cMember.getAddress().equals(getFirstAddressToMakeCall())) {
          SubCall subCall=createNewTargetAwareOp(cMember.getAddress());
          subCall.doOp();
          lsCalls.add(subCall);
        }
      }
      for (      SubCall call : lsCalls) {
        result=call.getResultAsObject();
        if (result == OBJECT_REDO) {
          logRedo(call);
          onRedo();
          Thread.sleep(redoWaitMillis);
          return call();
        }
 else {
          if (!onResponse(result)) {
            break;
          }
        }
      }
      onComplete();
    }
  }
 catch (  InterruptedException e) {
    throw new RuntimeException(e);
  }
  return (T)returnResult();
}",0.9667711598746082
49664,"protected MemberImpl getNextMemberAfter(final List<MemberImpl> lsMembers,final Address address,final boolean skipSuperClient,final int distance){
  final int size=lsMembers.size();
  if (size <= 1)   return null;
  int indexOfMember=-1;
  for (int i=0; i < size; i++) {
    final MemberImpl member=lsMembers.get(i);
    if (member.getAddress().equals(address)) {
      indexOfMember=i;
    }
  }
  if (indexOfMember == -1)   return null;
  int foundDistance=0;
  for (int i=indexOfMember; i < size + indexOfMember; i++) {
    final MemberImpl member=lsMembers.get((1 + i) % size);
    if (!(skipSuperClient && member.isSuperClient())) {
      foundDistance++;
    }
    if (foundDistance == distance) {
      return member;
    }
  }
  return null;
}","protected MemberImpl getNextMemberAfter(final List<MemberImpl> lsMembers,final Address address,final boolean skipSuperClient,final int distance){
  final int size=lsMembers.size();
  if (size <= 1)   return null;
  int indexOfMember=-1;
  for (int i=0; i < size; i++) {
    final MemberImpl member=lsMembers.get(i);
    if (member.getAddress().equals(address)) {
      indexOfMember=i;
    }
  }
  if (indexOfMember == -1)   return null;
  int foundDistance=0;
  for (int i=indexOfMember; i < size + indexOfMember; i++) {
    final MemberImpl member=lsMembers.get((1 + i) % size);
    if (!(skipSuperClient && member.isLiteMember())) {
      foundDistance++;
    }
    if (foundDistance == distance) {
      return member;
    }
  }
  return null;
}",0.9859906604402936
49665,"public boolean isSuperClient(){
  return (nodeType == NodeType.LITE_MEMBER);
}","@Deprecated public boolean isSuperClient(){
  return isLiteMember();
}",0.6216216216216216
49666,"@JMXAttribute(""String_Node_Str"") @JMXDescription(""String_Node_Str"") public boolean isSuperClient(){
  return getManagedObject().isSuperClient();
}","@JMXAttribute(""String_Node_Str"") @JMXDescription(""String_Node_Str"") public boolean isSuperClient(){
  return getManagedObject().isLiteMember();
}",0.9415807560137456
49667,"private synchronized void start(){
  final boolean jmxProperty=instance.node.groupProperties.ENABLE_JMX.getBoolean();
  if (!jmxProperty) {
    return;
  }
  logger.log(Level.INFO,""String_Node_Str"");
  if (showDetails()) {
    if (statCollectors == null) {
      statCollectors=new ScheduledThreadPoolExecutor(2,new ExecutorThreadFactory(null,""String_Node_Str"",null));
    }
  }
  started=true;
}","private void start(){
synchronized (LOCK) {
    final boolean jmxProperty=instance.node.groupProperties.ENABLE_JMX.getBoolean();
    if (!jmxProperty) {
      return;
    }
    logger.log(Level.INFO,""String_Node_Str"");
    if (showDetails()) {
      if (statCollectors == null) {
        statCollectors=new ScheduledThreadPoolExecutor(2,new ExecutorThreadFactory(null,""String_Node_Str"",null));
      }
    }
    started=true;
  }
}",0.928657799274486
49668,"/** 
 * Unregister a cluster instance.
 */
public synchronized void unregister(){
  if (!started) {
    return;
  }
  MBeanServer mbs=mBeanServer();
  Set<ObjectName> entries;
  try {
    entries=mbs.queryNames(ObjectNameSpec.getClusterNameFilter(this.name),null);
    for (    ObjectName name : entries) {
      if (mbs.isRegistered(name)) {
        mbs.unregisterMBean(name);
      }
    }
  }
 catch (  Exception e) {
    logger.log(Level.FINEST,""String_Node_Str"",e);
  }
  counter.decrementAndGet();
}","/** 
 * Unregister a cluster instance.
 */
public void unregister(){
synchronized (LOCK) {
    if (!started) {
      return;
    }
    MBeanServer mbs=mBeanServer();
    Set<ObjectName> entries;
    try {
      entries=mbs.queryNames(ObjectNameSpec.getClusterNameFilter(this.name),null);
      for (      ObjectName name : entries) {
        if (mbs.isRegistered(name)) {
          mbs.unregisterMBean(name);
        }
      }
    }
 catch (    Exception e) {
      logger.log(Level.FINEST,""String_Node_Str"",e);
    }
    counter.decrementAndGet();
  }
}",0.874409820585458
49669,"/** 
 * Create a new collector or return null if statistics are not enabled
 * @return statisticsCollector
 */
@SuppressWarnings(""String_Node_Str"") public static StatisticsCollector newStatisticsCollector(){
  if (statCollectors != null) {
    long interval=1L;
    ScheduledCollector collector=new ScheduledCollector(interval);
    ScheduledFuture future=statCollectors.scheduleWithFixedDelay(collector,interval,interval,TimeUnit.SECONDS);
    collector.setScheduledFuture(future);
    return collector;
  }
 else {
    return null;
  }
}","/** 
 * Create a new collector or return null if statistics are not enabled
 * @return statisticsCollector
 */
@SuppressWarnings(""String_Node_Str"") public static StatisticsCollector newStatisticsCollector(){
synchronized (LOCK) {
    if (statCollectors != null) {
      long interval=1L;
      ScheduledCollector collector=new ScheduledCollector(interval);
      ScheduledFuture future=statCollectors.scheduleWithFixedDelay(collector,interval,interval,TimeUnit.SECONDS);
      collector.setScheduledFuture(future);
      return collector;
    }
 else {
      return null;
    }
  }
}",0.9607843137254902
49670,"public ManagementService(FactoryImpl instance){
  this.instance=instance;
  this.logger=instance.node.getLogger(ManagementService.class.getName());
}","public ManagementService(FactoryImpl instance){
  this.instance=instance;
  this.logger=instance.node.getLogger(ManagementService.class.getName());
  this.showDetails=instance.node.groupProperties.ENABLE_JMX_DETAILED.getBoolean();
}",0.7821522309711286
49671,"/** 
 * Stop the management service
 */
public synchronized static void shutdown(){
  if (counter.get() > 0) {
    return;
  }
  MBeanServer mbs=mBeanServer();
  Set<ObjectName> entries;
  try {
    entries=mbs.queryNames(new ObjectName(ObjectNameSpec.NAME_DOMAIN + ""String_Node_Str""),null);
    for (    ObjectName name : entries) {
      if (mbs.isRegistered(name)) {
        mbs.unregisterMBean(name);
      }
    }
  }
 catch (  Exception e) {
    Logger.getLogger(""String_Node_Str"").log(Level.FINEST,""String_Node_Str"",e);
  }
  if (statCollectors != null) {
    statCollectors.shutdownNow();
    statCollectors=null;
  }
}","/** 
 * Stop the management service
 */
public static void shutdown(){
synchronized (LOCK) {
    if (counter.get() > 0) {
      return;
    }
    MBeanServer mbs=mBeanServer();
    Set<ObjectName> entries;
    try {
      entries=mbs.queryNames(new ObjectName(ObjectNameSpec.NAME_DOMAIN + ""String_Node_Str""),null);
      for (      ObjectName name : entries) {
        if (mbs.isRegistered(name)) {
          mbs.unregisterMBean(name);
        }
      }
    }
 catch (    Exception e) {
      Logger.getLogger(""String_Node_Str"").log(Level.FINEST,""String_Node_Str"",e);
    }
    if (statCollectors != null) {
      statCollectors.shutdownNow();
      statCollectors=null;
    }
  }
}",0.8831168831168831
49672,"/** 
 * Return if the instrumentation must manage objects and statistics at detailed level. For forward compatibility, return always true.
 */
final boolean showDetails(){
  return instance.node.groupProperties.ENABLE_JMX_DETAILED.getBoolean();
}","/** 
 * Return if the instrumentation must manage objects and statistics at detailed level. For forward compatibility, return always true.
 */
final boolean showDetails(){
  return showDetails;
}",0.8571428571428571
49673,"/** 
 * Register all the MBeans.
 */
public synchronized void register(){
  if (!started) {
    start();
  }
  if (!started) {
    return;
  }
  MBeanServer mbs=mBeanServer();
  try {
    nameLookup();
    ClusterMBean clusterMBean=new ClusterMBean(this,this.name);
    mbs.registerMBean(clusterMBean,clusterMBean.getObjectName());
    DataMBean dataMBean=new DataMBean(this);
    dataMBean.setParentName(clusterMBean.getRootName());
    mbs.registerMBean(dataMBean,dataMBean.getObjectName());
  }
 catch (  Exception e) {
    logger.log(Level.WARNING,""String_Node_Str"",e);
    return;
  }
  counter.incrementAndGet();
}","/** 
 * Register all the MBeans.
 */
public void register(){
synchronized (LOCK) {
    if (!started) {
      start();
    }
    if (!started) {
      return;
    }
    MBeanServer mbs=mBeanServer();
    try {
      nameLookup();
      ClusterMBean clusterMBean=new ClusterMBean(this,this.name);
      mbs.registerMBean(clusterMBean,clusterMBean.getObjectName());
      DataMBean dataMBean=new DataMBean(this);
      dataMBean.setParentName(clusterMBean.getRootName());
      mbs.registerMBean(dataMBean,dataMBean.getObjectName());
    }
 catch (    Exception e) {
      logger.log(Level.WARNING,""String_Node_Str"",e);
      return;
    }
    counter.incrementAndGet();
  }
}",0.6805877803557618
49674,"@Test public void testCleanupAfterMigration() throws Exception {
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  final int size=10000;
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(null);
  IMap map1=h1.getMap(""String_Node_Str"");
  for (int i=0; i < size; i++) {
    map1.put(i,""String_Node_Str"" + i);
  }
  assertEquals(size,map1.size());
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(new Config());
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(new Config());
  IMap map2=h2.getMap(""String_Node_Str"");
  IMap map3=h3.getMap(""String_Node_Str"");
  for (int i=0; i < 100; i++) {
    assertEquals(size,map1.size());
    assertEquals(size,map2.size());
    assertEquals(size,map3.size());
  }
  ConcurrentMapManager c1=getConcurrentMapManager(h1);
  ConcurrentMapManager c2=getConcurrentMapManager(h2);
  ConcurrentMapManager c3=getConcurrentMapManager(h3);
  c1.startCleanup(true,false);
  c2.startCleanup(true,false);
  c3.startCleanup(true,false);
  CMap cmap1=c1.getMap(""String_Node_Str"");
  CMap cmap2=c2.getMap(""String_Node_Str"");
  CMap cmap3=c3.getMap(""String_Node_Str"");
  assertTrue(cmap1.mapRecords.size() <= size);
  assertTrue(cmap2.mapRecords.size() <= size);
  assertTrue(cmap3.mapRecords.size() <= size);
  assertEquals(cmap1.mapRecords.size(),getOwnedAndBackupCount(map1));
  assertEquals(cmap2.mapRecords.size(),getOwnedAndBackupCount(map2));
  assertEquals(cmap3.mapRecords.size(),getOwnedAndBackupCount(map3));
  HazelcastInstance h4=Hazelcast.newHazelcastInstance(new Config());
  IMap map4=h4.getMap(""String_Node_Str"");
  ConcurrentMapManager c4=getConcurrentMapManager(h4);
  CMap cmap4=c4.getMap(""String_Node_Str"");
  Thread.sleep(5000);
  c1.startCleanup(true,false);
  c2.startCleanup(true,false);
  c3.startCleanup(true,false);
  c4.startCleanup(true,false);
  assertEquals(cmap1.mapRecords.size(),getOwnedAndBackupCount(map1));
  assertEquals(cmap2.mapRecords.size(),getOwnedAndBackupCount(map2));
  assertEquals(cmap3.mapRecords.size(),getOwnedAndBackupCount(map3));
  assertEquals(cmap4.mapRecords.size(),getOwnedAndBackupCount(map4));
  h4.getLifecycleService().shutdown();
  Thread.sleep(15000);
  c1.startCleanup(true,false);
  c2.startCleanup(true,false);
  c3.startCleanup(true,false);
  assertEquals(cmap1.mapRecords.size(),getOwnedAndBackupCount(map1));
  assertEquals(cmap2.mapRecords.size(),getOwnedAndBackupCount(map2));
  assertEquals(cmap3.mapRecords.size(),getOwnedAndBackupCount(map3));
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
}","@Test @Ignore public void testCleanupAfterMigration() throws Exception {
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  final int size=10000;
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(null);
  IMap map1=h1.getMap(""String_Node_Str"");
  for (int i=0; i < size; i++) {
    map1.put(i,""String_Node_Str"" + i);
  }
  assertEquals(size,map1.size());
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(new Config());
  HazelcastInstance h3=Hazelcast.newHazelcastInstance(new Config());
  IMap map2=h2.getMap(""String_Node_Str"");
  IMap map3=h3.getMap(""String_Node_Str"");
  for (int i=0; i < 100; i++) {
    assertEquals(size,map1.size());
    assertEquals(size,map2.size());
    assertEquals(size,map3.size());
  }
  ConcurrentMapManager c1=getConcurrentMapManager(h1);
  ConcurrentMapManager c2=getConcurrentMapManager(h2);
  ConcurrentMapManager c3=getConcurrentMapManager(h3);
  c1.startCleanup(true,true);
  c2.startCleanup(true,true);
  c3.startCleanup(true,true);
  Thread.sleep(1000);
  CMap cmap1=c1.getMap(""String_Node_Str"");
  CMap cmap2=c2.getMap(""String_Node_Str"");
  CMap cmap3=c3.getMap(""String_Node_Str"");
  assertTrue(cmap1.mapRecords.size() <= size);
  assertTrue(cmap2.mapRecords.size() <= size);
  assertTrue(cmap3.mapRecords.size() <= size);
  assertEquals(cmap1.mapRecords.size(),getOwnedAndBackupCount(map1));
  assertEquals(cmap2.mapRecords.size(),getOwnedAndBackupCount(map2));
  assertEquals(cmap3.mapRecords.size(),getOwnedAndBackupCount(map3));
  HazelcastInstance h4=Hazelcast.newHazelcastInstance(new Config());
  IMap map4=h4.getMap(""String_Node_Str"");
  ConcurrentMapManager c4=getConcurrentMapManager(h4);
  CMap cmap4=c4.getMap(""String_Node_Str"");
  Thread.sleep(1000);
  c1.startCleanup(true,true);
  c2.startCleanup(true,true);
  c3.startCleanup(true,true);
  c4.startCleanup(true,true);
  Thread.sleep(8000);
  assertEquals(cmap1.mapRecords.size(),getOwnedAndBackupCount(map1));
  assertEquals(cmap2.mapRecords.size(),getOwnedAndBackupCount(map2));
  assertEquals(cmap3.mapRecords.size(),getOwnedAndBackupCount(map3));
  assertEquals(cmap4.mapRecords.size(),getOwnedAndBackupCount(map4));
  h4.getLifecycleService().shutdown();
  Thread.sleep(1000);
  c1.startCleanup(true,true);
  c2.startCleanup(true,true);
  c3.startCleanup(true,true);
  Thread.sleep(8000);
  assertEquals(cmap1.mapRecords.size(),getOwnedAndBackupCount(map1));
  assertEquals(cmap2.mapRecords.size(),getOwnedAndBackupCount(map2));
  assertEquals(cmap3.mapRecords.size(),getOwnedAndBackupCount(map3));
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
}",0.8136123606493253
49675,"void clusterIsDown(Connection oldConnection){
  if (!running) {
    interruptWaitingCalls();
    return;
  }
  client.getConnectionManager().destroyConnection(oldConnection);
  if (reconnection.compareAndSet(false,true)) {
    client.runAsyncAndWait(new Runnable(){
      public void run(){
        try {
          final Connection lookForAliveConnection=client.getConnectionManager().lookForLiveConnection();
          if (lookForAliveConnection == null) {
            logger.log(Level.WARNING,""String_Node_Str"" + reconnection);
            if (reconnection.get()) {
              interruptWaitingCalls();
            }
          }
 else {
            if (running) {
              enQueue(RECONNECT_CALL);
            }
          }
        }
 catch (        IOException e) {
          logger.log(Level.WARNING,Thread.currentThread().getName() + ""String_Node_Str"" + e.getMessage(),e);
        }
 finally {
          reconnection.compareAndSet(true,false);
        }
      }
    }
);
  }
}","void clusterIsDown(Connection oldConnection){
  if (!running) {
    interruptWaitingCalls();
    return;
  }
  client.getConnectionManager().destroyConnection(oldConnection);
  if (reconnection.compareAndSet(false,true)) {
    client.runAsyncAndWait(new Runnable(){
      public void run(){
        try {
          final Connection lookForAliveConnection=client.getConnectionManager().lookForLiveConnection();
          if (lookForAliveConnection == null) {
            logger.log(Level.WARNING,""String_Node_Str"");
            if (reconnection.get()) {
              logger.log(Level.WARNING,""String_Node_Str"" + reconnection.get() + ""String_Node_Str"");
              interruptWaitingCalls();
              client.getLifecycleService().shutdown();
            }
          }
 else {
            if (running) {
              enQueue(RECONNECT_CALL);
            }
          }
        }
 catch (        IOException e) {
          logger.log(Level.WARNING,Thread.currentThread().getName() + ""String_Node_Str"" + e.getMessage(),e);
        }
 finally {
          reconnection.compareAndSet(true,false);
        }
      }
    }
);
  }
}",0.8790170132325141
49676,"public void run(){
  try {
    final Connection lookForAliveConnection=client.getConnectionManager().lookForLiveConnection();
    if (lookForAliveConnection == null) {
      logger.log(Level.WARNING,""String_Node_Str"" + reconnection);
      if (reconnection.get()) {
        interruptWaitingCalls();
      }
    }
 else {
      if (running) {
        enQueue(RECONNECT_CALL);
      }
    }
  }
 catch (  IOException e) {
    logger.log(Level.WARNING,Thread.currentThread().getName() + ""String_Node_Str"" + e.getMessage(),e);
  }
 finally {
    reconnection.compareAndSet(true,false);
  }
}","public void run(){
  try {
    final Connection lookForAliveConnection=client.getConnectionManager().lookForLiveConnection();
    if (lookForAliveConnection == null) {
      logger.log(Level.WARNING,""String_Node_Str"");
      if (reconnection.get()) {
        logger.log(Level.WARNING,""String_Node_Str"" + reconnection.get() + ""String_Node_Str"");
        interruptWaitingCalls();
        client.getLifecycleService().shutdown();
      }
    }
 else {
      if (running) {
        enQueue(RECONNECT_CALL);
      }
    }
  }
 catch (  IOException e) {
    logger.log(Level.WARNING,Thread.currentThread().getName() + ""String_Node_Str"" + e.getMessage(),e);
  }
 finally {
    reconnection.compareAndSet(true,false);
  }
}",0.8218125960061444
49677,"public String getPassword(){
  return new String(password);
}","public String getPassword(){
  return password == null ? ""String_Node_Str"" : new String(password);
}",0.7577639751552795
49678,"public void own(DataRecordEntry dataRecordEntry){
  Record record=storeDataRecordEntry(dataRecordEntry);
  if (record != null) {
    if (record.getValueData() != null) {
      updateIndexes(record);
    }
    Map<Address,Boolean> keyListeners=dataRecordEntry.getListeners();
    if (keyListeners != null) {
      record.setMapListeners(keyListeners);
    }
  }
}","public void own(DataRecordEntry dataRecordEntry){
  Record record=storeDataRecordEntry(dataRecordEntry);
  if (record != null) {
    if (record.valueCount() > 0) {
      updateIndexes(record);
    }
    Map<Address,Boolean> keyListeners=dataRecordEntry.getListeners();
    if (keyListeners != null) {
      record.setMapListeners(keyListeners);
    }
  }
}",0.947075208913649
49679,"boolean startCleanup(boolean forced){
  final long now=System.currentTimeMillis();
  long dirtyAge=(now - lastCleanup);
  boolean shouldRun=(store != null && dirty && dirtyAge >= writeDelayMillis) || (dirtyAge > cleanupDelayMillis);
  if (shouldRun && cleanupActive.compareAndSet(false,true)) {
    lastCleanup=now;
    try {
      if (nearCache != null) {
        nearCache.evict(now,false);
      }
      dirty=false;
      final Set<Record> recordsDirty=new HashSet<Record>();
      final Set<Record> recordsUnknown=new HashSet<Record>();
      final Set<Record> recordsToPurge=new HashSet<Record>();
      final Set<Record> recordsToEvict=new HashSet<Record>();
      final Set<Record> sortedRecords=new TreeSet<Record>(new ComparatorWrapper(evictionComparator));
      final Collection<Record> records=mapRecords.values();
      final boolean overCapacity=maxSizePolicy.overCapacity();
      final boolean evictionAware=evictionComparator != null && overCapacity;
      int recordsStillOwned=0;
      int backupPurgeCount=0;
      PartitionManager partitionManager=concurrentMapManager.partitionManager;
      for (      Record record : records) {
        PartitionInfo partition=partitionManager.getPartition(record.getBlockId());
        Address owner=partition.getOwner();
        boolean owned=(owner != null && thisAddress.equals(owner));
        boolean ownedOrBackup=partition.isOwnerOrBackup(thisAddress,backupCount);
        if (owner != null && !partitionManager.isPartitionMigrating(partition.getPartitionId())) {
          if (owned) {
            if (store != null && writeDelayMillis > 0 && record.isDirty()) {
              if (now > record.getWriteTime()) {
                recordsDirty.add(record);
                record.setDirty(false);
              }
 else {
                dirty=true;
              }
            }
 else             if (shouldPurgeRecord(record,now)) {
              recordsToPurge.add(record);
            }
 else             if (record.isActive() && !record.isValid(now)) {
              recordsToEvict.add(record);
            }
 else             if (evictionAware && record.isActive() && record.isEvictable()) {
              sortedRecords.add(record);
              recordsStillOwned++;
            }
          }
 else           if (ownedOrBackup) {
            if (shouldPurgeRecord(record,now)) {
              recordsToPurge.add(record);
              backupPurgeCount++;
            }
          }
 else {
            recordsUnknown.add(record);
          }
        }
      }
      if (evictionAware && (forced || overCapacity)) {
        int numberOfRecordsToEvict=(int)(recordsStillOwned * evictionRate);
        int evictedCount=0;
        for (        Record record : sortedRecords) {
          if (record.isActive() && record.isEvictable()) {
            recordsToEvict.add(record);
            if (++evictedCount >= numberOfRecordsToEvict) {
              break;
            }
          }
        }
      }
      Level levelLog=(concurrentMapManager.LOG_STATE) ? Level.INFO : Level.FINEST;
      logger.log(levelLog,name + ""String_Node_Str"" + ""String_Node_Str""+ recordsDirty.size()+ ""String_Node_Str""+ recordsToPurge.size()+ ""String_Node_Str""+ recordsToEvict.size()+ ""String_Node_Str""+ recordsUnknown.size()+ ""String_Node_Str""+ recordsStillOwned+ ""String_Node_Str""+ backupPurgeCount);
      executeStoreUpdate(recordsDirty);
      executeEviction(recordsToEvict);
      executePurge(recordsToPurge);
      executePurgeUnknowns(recordsUnknown);
      return true;
    }
  finally {
      cleanupActive.set(false);
    }
  }
 else {
    return false;
  }
}","boolean startCleanup(boolean forced){
  final long now=System.currentTimeMillis();
  long dirtyAge=(now - lastCleanup);
  boolean shouldRun=forced || (store != null && dirty && dirtyAge >= writeDelayMillis) || (dirtyAge > cleanupDelayMillis);
  if (shouldRun && cleanupActive.compareAndSet(false,true)) {
    lastCleanup=now;
    try {
      if (nearCache != null) {
        nearCache.evict(now,false);
      }
      dirty=false;
      final Set<Record> recordsDirty=new HashSet<Record>();
      final Set<Record> recordsUnknown=new HashSet<Record>();
      final Set<Record> recordsToPurge=new HashSet<Record>();
      final Set<Record> recordsToEvict=new HashSet<Record>();
      final Set<Record> sortedRecords=new TreeSet<Record>(new ComparatorWrapper(evictionComparator));
      final Collection<Record> records=mapRecords.values();
      final boolean overCapacity=maxSizePolicy.overCapacity();
      final boolean evictionAware=evictionComparator != null && overCapacity;
      int recordsStillOwned=0;
      int backupPurgeCount=0;
      PartitionManager partitionManager=concurrentMapManager.partitionManager;
      for (      Record record : records) {
        PartitionInfo partition=partitionManager.getPartition(record.getBlockId());
        Address owner=partition.getOwner();
        boolean owned=(owner != null && thisAddress.equals(owner));
        boolean ownedOrBackup=partition.isOwnerOrBackup(thisAddress,backupCount);
        if (owner != null && !partitionManager.isPartitionMigrating(partition.getPartitionId())) {
          if (owned) {
            if (store != null && writeDelayMillis > 0 && record.isDirty()) {
              if (now > record.getWriteTime()) {
                recordsDirty.add(record);
                record.setDirty(false);
              }
 else {
                dirty=true;
              }
            }
 else             if (shouldPurgeRecord(record,now)) {
              recordsToPurge.add(record);
            }
 else             if (record.isActive() && !record.isValid(now)) {
              recordsToEvict.add(record);
            }
 else             if (evictionAware && record.isActive() && record.isEvictable()) {
              sortedRecords.add(record);
              recordsStillOwned++;
            }
          }
 else           if (ownedOrBackup) {
            if (shouldPurgeRecord(record,now)) {
              recordsToPurge.add(record);
              backupPurgeCount++;
            }
          }
 else {
            recordsUnknown.add(record);
          }
        }
      }
      if (evictionAware && (forced || overCapacity)) {
        int numberOfRecordsToEvict=(int)(recordsStillOwned * evictionRate);
        int evictedCount=0;
        for (        Record record : sortedRecords) {
          if (record.isActive() && record.isEvictable()) {
            recordsToEvict.add(record);
            if (++evictedCount >= numberOfRecordsToEvict) {
              break;
            }
          }
        }
      }
      Level levelLog=(concurrentMapManager.LOG_STATE) ? Level.INFO : Level.FINEST;
      logger.log(levelLog,name + ""String_Node_Str"" + ""String_Node_Str""+ recordsDirty.size()+ ""String_Node_Str""+ recordsToPurge.size()+ ""String_Node_Str""+ recordsToEvict.size()+ ""String_Node_Str""+ recordsUnknown.size()+ ""String_Node_Str""+ recordsStillOwned+ ""String_Node_Str""+ backupPurgeCount);
      executeStoreUpdate(recordsDirty);
      executeEviction(recordsToEvict);
      executePurge(recordsToPurge);
      executePurgeUnknowns(recordsUnknown);
    }
  finally {
      cleanupActive.set(false);
    }
    return true;
  }
 else {
    return false;
  }
}",0.993641139065524
49680,"public Boolean call() throws Exception {
  if (to.equals(from)) {
    getLogger().log(Level.FINEST,""String_Node_Str"" + toString());
    return Boolean.TRUE;
  }
  if (from == null) {
    getLogger().log(Level.FINEST,""String_Node_Str"" + toString());
  }
  Node node=((FactoryImpl)hazelcast).node;
  PartitionManager pm=node.concurrentMapManager.getPartitionManager();
  try {
    Member target=pm.getMember(to);
    if (target == null) {
      getLogger().log(Level.WARNING,""String_Node_Str"" + toString());
      return Boolean.FALSE;
    }
    CostAwareRecordList costAwareRecordList=pm.getActivePartitionRecords(partitionId,replicaIndex,to,diffOnly);
    DistributedTask task=new DistributedTask(new MigrationTask(partitionId,costAwareRecordList,replicaIndex,from),target);
    Future future=node.factory.getExecutorService().submit(task);
    return (Boolean)future.get(400,TimeUnit.SECONDS);
  }
 catch (  Throwable e) {
    Level level=Level.WARNING;
    if (e instanceof ExecutionException) {
      e=e.getCause();
    }
    if (e instanceof MemberLeftException || e instanceof IllegalStateException) {
      level=Level.FINEST;
    }
    getLogger().log(level,e.getMessage(),e);
  }
  return Boolean.FALSE;
}","public Boolean call() throws Exception {
  if (to.equals(from)) {
    getLogger().log(Level.FINEST,""String_Node_Str"" + toString());
    return Boolean.TRUE;
  }
  if (from == null) {
    getLogger().log(Level.FINEST,""String_Node_Str"" + toString());
  }
  final Node node=((FactoryImpl)hazelcast).node;
  PartitionManager pm=node.concurrentMapManager.getPartitionManager();
  try {
    Member target=pm.getMember(to);
    if (target == null) {
      getLogger().log(Level.WARNING,""String_Node_Str"" + toString());
      return Boolean.FALSE;
    }
    final CostAwareRecordList costAwareRecordList=pm.getActivePartitionRecords(partitionId,replicaIndex,to,diffOnly);
    DistributedTask task=new DistributedTask(new MigrationTask(partitionId,costAwareRecordList,replicaIndex,from),target);
    Future future=node.factory.getExecutorService().submit(task);
    Boolean result=(Boolean)future.get(400,TimeUnit.SECONDS);
    if (result) {
      if (replicaIndex == 0) {
        node.concurrentMapManager.enqueueAndWait(new Processable(){
          public void process(){
            for (            Record record : costAwareRecordList.getRecords()) {
              CMap cmap=node.concurrentMapManager.getMap(record.getName());
              if (cmap != null) {
                cmap.getMapIndexService().remove(record);
              }
            }
          }
        }
,100);
      }
    }
    return result;
  }
 catch (  Throwable e) {
    Level level=Level.WARNING;
    if (e instanceof ExecutionException) {
      e=e.getCause();
    }
    if (e instanceof MemberLeftException || e instanceof IllegalStateException) {
      level=Level.FINEST;
    }
    getLogger().log(level,e.getMessage(),e);
  }
  return Boolean.FALSE;
}",0.821367812181014
49681,"@Test public void testMigrationOfTTLAndLock() throws Exception {
  Config config=new Config();
  final HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  final HazelcastInstance h2=Hazelcast.newHazelcastInstance(config);
  ConcurrentMapManager cmm1=getConcurrentMapManager(h1);
  ConcurrentMapManager cmm2=getConcurrentMapManager(h2);
  final IMap imap1=h1.getMap(""String_Node_Str"");
  final IMap imap2=h2.getMap(""String_Node_Str"");
  final Data dKey=toData(""String_Node_Str"");
  assertTrue(migrateKey(""String_Node_Str"",h1,h1,0));
  assertTrue(migrateKey(""String_Node_Str"",h1,h2,1));
  imap1.put(""String_Node_Str"",""String_Node_Str"",60,TimeUnit.SECONDS);
  imap1.lock(""String_Node_Str"");
  Future put2=imap2.putAsync(""String_Node_Str"",""String_Node_Str"");
  imap2.addEntryListener(new EntryAdapter(){
    @Override public void entryUpdated(    EntryEvent entryEvent){
      System.out.println(entryEvent);
    }
  }
,""String_Node_Str"",true);
  if (put2 == null)   fail();
  Thread.sleep(1000);
  CMap cmap1=getCMap(h1,""String_Node_Str"");
  CMap cmap2=getCMap(h2,""String_Node_Str"");
  Record record1=cmap1.getRecord(dKey);
  assertEquals(1,record1.getScheduledActionCount());
  for (  ScheduledAction scheduledAction : record1.getScheduledActions()) {
    assertTrue(scheduledAction.isValid());
  }
  assertNotNull(record1.getListeners());
  assertEquals(1,record1.getListeners().size());
  DistributedLock lock=cmap1.getRecord(dKey).getLock();
  assertTrue(cmm1.thisAddress.equals(lock.getLockAddress()));
  assertTrue(lock.getLockThreadId() != -1);
  assertEquals(1,lock.getLockCount());
  assertTrue(migrateKey(""String_Node_Str"",h1,h2,0));
  assertTrue(migrateKey(""String_Node_Str"",h1,h1,1));
  Thread.sleep(1000);
  cmap1.startCleanup(true);
  cmap2.startCleanup(true);
  assertEquals(1,cmap1.mapRecords.size());
  assertEquals(1,cmap2.mapRecords.size());
  assertEquals(1,cmap2.getMapIndexService().getOwnedRecords().size());
  assertEquals(0,cmap1.getMapIndexService().getOwnedRecords().size());
  assertTrue(cmap1.getRecord(dKey).getRemainingTTL() < 60000);
  assertTrue(cmap2.getRecord(dKey).getRemainingTTL() < 60000);
  Record record2=cmap2.getRecord(dKey);
  lock=record2.getLock();
  assertTrue(cmm1.thisAddress.equals(lock.getLockAddress()));
  assertTrue(lock.getLockThreadId() != -1);
  assertEquals(1,lock.getLockCount());
  lock=cmap1.getRecord(dKey).getLock();
  assertTrue(cmm1.thisAddress.equals(lock.getLockAddress()));
  assertTrue(lock.getLockThreadId() != -1);
  assertEquals(1,lock.getLockCount());
  imap1.unlock(""String_Node_Str"");
  put2.get(10,TimeUnit.SECONDS);
  assertEquals(""String_Node_Str"",imap1.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",imap2.get(""String_Node_Str""));
  assertNotNull(record2.getListeners());
  assertEquals(1,record2.getListeners().size());
}","@Test public void testMigrationOfTTLAndLock() throws Exception {
  Config config=new Config();
  final HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  final HazelcastInstance h2=Hazelcast.newHazelcastInstance(config);
  ConcurrentMapManager cmm1=getConcurrentMapManager(h1);
  ConcurrentMapManager cmm2=getConcurrentMapManager(h2);
  final IMap imap1=h1.getMap(""String_Node_Str"");
  final IMap imap2=h2.getMap(""String_Node_Str"");
  final Data dKey=toData(""String_Node_Str"");
  assertTrue(migrateKey(""String_Node_Str"",h1,h1,0));
  assertTrue(migrateKey(""String_Node_Str"",h1,h2,1));
  imap1.put(""String_Node_Str"",""String_Node_Str"",60,TimeUnit.SECONDS);
  imap1.lock(""String_Node_Str"");
  Future put2=imap2.putAsync(""String_Node_Str"",""String_Node_Str"");
  imap2.addEntryListener(new EntryAdapter(){
    @Override public void entryUpdated(    EntryEvent entryEvent){
      System.out.println(entryEvent);
    }
  }
,""String_Node_Str"",true);
  if (put2 == null)   fail();
  Thread.sleep(1000);
  CMap cmap1=getCMap(h1,""String_Node_Str"");
  CMap cmap2=getCMap(h2,""String_Node_Str"");
  Record record1=cmap1.getRecord(dKey);
  assertEquals(1,record1.getScheduledActionCount());
  for (  ScheduledAction scheduledAction : record1.getScheduledActions()) {
    assertTrue(scheduledAction.isValid());
  }
  assertNotNull(record1.getListeners());
  assertEquals(1,record1.getListeners().size());
  DistributedLock lock=cmap1.getRecord(dKey).getLock();
  assertTrue(cmm1.thisAddress.equals(lock.getLockAddress()));
  assertTrue(lock.getLockThreadId() != -1);
  assertEquals(1,lock.getLockCount());
  assertEquals(1,cmap1.mapRecords.size());
  assertEquals(1,cmap2.mapRecords.size());
  assertEquals(0,cmap2.getMapIndexService().getOwnedRecords().size());
  assertEquals(1,cmap1.getMapIndexService().getOwnedRecords().size());
  assertTrue(migrateKey(""String_Node_Str"",h1,h2,0));
  assertTrue(migrateKey(""String_Node_Str"",h1,h1,1));
  assertEquals(1,cmap1.mapRecords.size());
  assertEquals(1,cmap2.mapRecords.size());
  assertEquals(0,cmap1.getMapIndexService().getOwnedRecords().size());
  assertEquals(1,cmap2.getMapIndexService().getOwnedRecords().size());
  assertTrue(cmap1.getRecord(dKey).getRemainingTTL() < 60000);
  assertTrue(cmap2.getRecord(dKey).getRemainingTTL() < 60000);
  Record record2=cmap2.getRecord(dKey);
  lock=record2.getLock();
  assertTrue(cmm1.thisAddress.equals(lock.getLockAddress()));
  assertTrue(lock.getLockThreadId() != -1);
  assertEquals(1,lock.getLockCount());
  lock=cmap1.getRecord(dKey).getLock();
  assertTrue(cmm1.thisAddress.equals(lock.getLockAddress()));
  assertTrue(lock.getLockThreadId() != -1);
  assertEquals(1,lock.getLockCount());
  imap1.unlock(""String_Node_Str"");
  put2.get(10,TimeUnit.SECONDS);
  assertEquals(""String_Node_Str"",imap1.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",imap2.get(""String_Node_Str""));
  assertNotNull(record2.getListeners());
  assertEquals(1,record2.getListeners().size());
}",0.942314335060449
49682,"@Test(timeout=100000) public void testKeyOwnerDies() throws Exception {
  final HazelcastInstance h1=Hazelcast.newHazelcastInstance(new Config());
  final IMap map1=h1.getMap(""String_Node_Str"");
  final HazelcastInstance h2=Hazelcast.newHazelcastInstance(new Config());
  final IMap map2=h2.getMap(""String_Node_Str"");
  final HazelcastInstance h3=Hazelcast.newHazelcastInstance(new Config());
  final IMap map3=h3.getMap(""String_Node_Str"");
  CMap cmap1=getCMap(h1,""String_Node_Str"");
  CMap cmap2=getCMap(h2,""String_Node_Str"");
  CMap cmap3=getCMap(h3,""String_Node_Str"");
  Data dKey=toData(1);
  map1.put(1,1);
  migrateKey(1,h1,h2,0);
  migrateKey(1,h1,h3,1);
  cmap1.startCleanup(true);
  assertTrue(h1.getPartitionService().getPartition(1).getOwner().equals(h2.getCluster().getLocalMember()));
  assertTrue(h3.getPartitionService().getPartition(1).getOwner().equals(h2.getCluster().getLocalMember()));
  assertTrue(h2.getPartitionService().getPartition(1).getOwner().localMember());
  assertTrue(map1.tryLock(1));
  final CountDownLatch latchLock=new CountDownLatch(1);
  new Thread(new Runnable(){
    public void run(){
      try {
        map3.lock(1);
        assertTrue(latchLock.await(10,TimeUnit.SECONDS));
      }
 catch (      Throwable e) {
        fail();
      }
    }
  }
).start();
  Thread.sleep(2000);
  Record rec1=cmap1.getRecord(dKey);
  Record rec2=cmap2.getRecord(dKey);
  Record rec3=cmap3.getRecord(dKey);
  assertNull(rec1);
  assertNotNull(rec2);
  assertNotNull(rec3);
  DistributedLock lock2=rec2.getLock();
  DistributedLock lock3=rec3.getLock();
  assertEquals(1,rec2.getScheduledActionCount());
  assertTrue(rec2.getScheduledActions().iterator().next().isValid());
  Assert.assertNotNull(lock2);
  Assert.assertNotNull(lock3);
  System.out.println(lock2);
  System.out.println(lock3);
  h2.getLifecycleService().shutdown();
  Thread.sleep(3000);
  assertEquals(h3.getCluster().getLocalMember(),h1.getPartitionService().getPartition(1).getOwner());
  assertEquals(h3.getCluster().getLocalMember(),h3.getPartitionService().getPartition(1).getOwner());
  assertEquals(1,map1.put(1,2));
  rec3=cmap3.getRecord(dKey);
  assertEquals(1,rec3.getScheduledActionCount());
  assertTrue(rec3.getScheduledActions().iterator().next().isValid());
  map1.unlock(1);
  lock3=rec3.getLock();
  assertNotNull(lock3);
  assertEquals(lock3.getLockAddress(),((MemberImpl)h3.getCluster().getLocalMember()).getAddress());
  assertEquals(1,lock3.getLockCount());
  latchLock.countDown();
  assertFalse(map1.tryLock(1));
}","@Test(timeout=100000) public void testKeyOwnerDies() throws Exception {
  final HazelcastInstance h1=Hazelcast.newHazelcastInstance(new Config());
  final IMap map1=h1.getMap(""String_Node_Str"");
  final HazelcastInstance h2=Hazelcast.newHazelcastInstance(new Config());
  final IMap map2=h2.getMap(""String_Node_Str"");
  final HazelcastInstance h3=Hazelcast.newHazelcastInstance(new Config());
  final IMap map3=h3.getMap(""String_Node_Str"");
  CMap cmap1=getCMap(h1,""String_Node_Str"");
  CMap cmap2=getCMap(h2,""String_Node_Str"");
  CMap cmap3=getCMap(h3,""String_Node_Str"");
  Data dKey=toData(1);
  map1.put(1,1);
  migrateKey(1,h1,h2,0);
  migrateKey(1,h1,h3,1);
  cmap1.startCleanup(true);
  assertTrue(h1.getPartitionService().getPartition(1).getOwner().equals(h2.getCluster().getLocalMember()));
  assertTrue(h3.getPartitionService().getPartition(1).getOwner().equals(h2.getCluster().getLocalMember()));
  assertTrue(h2.getPartitionService().getPartition(1).getOwner().localMember());
  assertTrue(map1.tryLock(1));
  final CountDownLatch latchLock=new CountDownLatch(1);
  new Thread(new Runnable(){
    public void run(){
      try {
        map3.lock(1);
        assertTrue(latchLock.await(10,TimeUnit.SECONDS));
      }
 catch (      Throwable e) {
        fail();
      }
    }
  }
).start();
  Thread.sleep(2000);
  Record rec1=cmap1.getRecord(dKey);
  Record rec2=cmap2.getRecord(dKey);
  Record rec3=cmap3.getRecord(dKey);
  assertNull(rec1);
  assertNotNull(rec2);
  assertNotNull(rec3);
  DistributedLock lock2=rec2.getLock();
  DistributedLock lock3=rec3.getLock();
  assertEquals(1,rec2.getScheduledActionCount());
  assertTrue(rec2.getScheduledActions().iterator().next().isValid());
  Assert.assertNotNull(lock2);
  Assert.assertNotNull(lock3);
  h2.getLifecycleService().shutdown();
  Thread.sleep(3000);
  assertEquals(h3.getCluster().getLocalMember(),h1.getPartitionService().getPartition(1).getOwner());
  assertEquals(h3.getCluster().getLocalMember(),h3.getPartitionService().getPartition(1).getOwner());
  assertEquals(1,map1.put(1,2));
  rec3=cmap3.getRecord(dKey);
  assertEquals(1,rec3.getScheduledActionCount());
  assertTrue(rec3.getScheduledActions().iterator().next().isValid());
  map1.unlock(1);
  lock3=rec3.getLock();
  assertNotNull(lock3);
  assertEquals(lock3.getLockAddress(),((MemberImpl)h3.getCluster().getLocalMember()).getAddress());
  assertEquals(1,lock3.getLockCount());
  latchLock.countDown();
  assertFalse(map1.tryLock(1));
}",0.9884139033160207
49683,"@Test(timeout=60000) public void testMultiMapRecovery() throws Exception {
  HazelcastInstance h=Hazelcast.newHazelcastInstance(new Config());
  MultiMap mm=h.getMultiMap(""String_Node_Str"");
  Collection<String> expectedValues=new HashSet<String>();
  expectedValues.add(""String_Node_Str"");
  expectedValues.add(""String_Node_Str"");
  mm.put(""String_Node_Str"",""String_Node_Str"");
  mm.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(2,mm.size());
  assertEquals(1,mm.keySet().size());
  Collection values=mm.get(""String_Node_Str"");
  for (  Object value : values) {
    assertTrue(expectedValues.contains(value));
  }
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(new Config());
  assertEquals(2,mm.size());
  assertEquals(1,mm.keySet().size());
  values=mm.get(""String_Node_Str"");
  for (  Object value : values) {
    assertTrue(expectedValues.contains(value));
  }
  MultiMap mm2=h2.getMultiMap(""String_Node_Str"");
  assertEquals(2,mm2.size());
  assertEquals(1,mm2.keySet().size());
  values=mm2.get(""String_Node_Str"");
  for (  Object value : values) {
    assertTrue(expectedValues.contains(value));
  }
  h.getLifecycleService().shutdown();
  assertEquals(2,mm2.size());
  assertEquals(1,mm2.keySet().size());
  values=mm2.get(""String_Node_Str"");
  for (  Object value : values) {
    assertTrue(expectedValues.contains(value));
  }
}","@Test(timeout=60000) public void testMultiMapRecovery() throws Exception {
  HazelcastInstance h=Hazelcast.newHazelcastInstance(new Config());
  MultiMap mm=h.getMultiMap(""String_Node_Str"");
  Collection<String> expectedValues=new HashSet<String>();
  expectedValues.add(""String_Node_Str"");
  expectedValues.add(""String_Node_Str"");
  mm.put(""String_Node_Str"",""String_Node_Str"");
  mm.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(2,mm.size());
  assertEquals(1,mm.keySet().size());
  Collection values=mm.get(""String_Node_Str"");
  for (  Object value : values) {
    assertTrue(expectedValues.contains(value));
  }
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(new Config());
  MultiMap mm2=h2.getMultiMap(""String_Node_Str"");
  Thread.sleep(1000);
  getCMapForMultiMap(h,""String_Node_Str"").startCleanup(true);
  getCMapForMultiMap(h2,""String_Node_Str"").startCleanup(true);
  assertEquals(2,mm.size());
  assertEquals(1,mm.keySet().size());
  values=mm.get(""String_Node_Str"");
  for (  Object value : values) {
    assertTrue(expectedValues.contains(value));
  }
  assertEquals(2,mm2.size());
  assertEquals(1,mm2.keySet().size());
  values=mm2.get(""String_Node_Str"");
  for (  Object value : values) {
    assertTrue(expectedValues.contains(value));
  }
  h.getLifecycleService().shutdown();
  values=mm2.get(""String_Node_Str"");
  for (  Object value : values) {
    assertTrue(expectedValues.contains(value));
  }
  assertEquals(2,mm2.size());
  assertEquals(1,mm2.keySet().size());
}",0.787836420831877
49684,"@Test(timeout=60000) public void testMapRecovery() throws Exception {
  HazelcastInstance h=Hazelcast.newHazelcastInstance(new Config());
  IMap mm=h.getMap(""String_Node_Str"");
  mm.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(1,mm.size());
  assertEquals(1,mm.keySet().size());
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(new Config());
  assertEquals(1,mm.size());
  assertEquals(1,mm.keySet().size());
  IMap mm2=h2.getMap(""String_Node_Str"");
  assertEquals(1,mm2.size());
  assertEquals(1,mm2.keySet().size());
  h.getLifecycleService().shutdown();
  assertEquals(1,mm2.size());
  assertEquals(1,mm2.keySet().size());
}","@Test(timeout=60000) public void testMapRecovery() throws Exception {
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(new Config());
  IMap map1=h1.getMap(""String_Node_Str"");
  map1.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(1,map1.size());
  assertEquals(1,map1.keySet().size());
  CMap cmap1=getCMap(h1,""String_Node_Str"");
  assertEquals(1,cmap1.mapRecords.size());
  assertEquals(1,cmap1.getMapIndexService().getOwnedRecords().size());
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(new Config());
  IMap map2=h2.getMap(""String_Node_Str"");
  CMap cmap2=getCMap(h2,""String_Node_Str"");
  assertEquals(1,cmap1.mapRecords.size());
  assertEquals(1,cmap2.mapRecords.size());
  assertEquals(1,cmap1.getMapIndexService().getOwnedRecords().size() + cmap2.getMapIndexService().getOwnedRecords().size());
  assertEquals(1,map1.size());
  assertEquals(1,map1.keySet().size());
  assertEquals(1,map2.size());
  assertEquals(1,map2.keySet().size());
  h1.getLifecycleService().shutdown();
  assertEquals(1,map2.size());
  assertEquals(1,map2.keySet().size());
  assertEquals(1,cmap2.mapRecords.size());
  assertEquals(1,cmap2.getMapIndexService().getOwnedRecords().size());
}",0.5073489384866631
49685,"public DeleteCommandProcessor(TextCommandService textCommandService){
  super(textCommandService);
  logger=textCommandService.getNode().getLogger(this.getClass().getName());
}","public DeleteCommandProcessor(TextCommandService textCommandService){
  super(textCommandService);
}",0.7246376811594203
49686,"public void handle(DeleteCommand command){
  String key=null;
  try {
    key=URLDecoder.decode(command.getKey(),""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException e) {
    logger.log(Level.WARNING,e.getMessage(),e);
  }
  String mapName=""String_Node_Str"";
  int index=key.indexOf(':');
  if (index != -1) {
    mapName=key.substring(0,index);
    key=key.substring(index + 1);
  }
  command.setResponse(DELETED);
  if (command.shouldReply()) {
    textCommandService.sendResponse(command);
  }
  textCommandService.incrementDeleteCount();
  textCommandService.delete(mapName,key);
}","public void handle(DeleteCommand command){
  String key;
  try {
    key=URLDecoder.decode(command.getKey(),""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException e) {
    throw new RuntimeException(format(""String_Node_Str"",command.getKey()));
  }
  String mapName=""String_Node_Str"";
  int index=key.indexOf(':');
  if (index != -1) {
    mapName=key.substring(0,index);
    key=key.substring(index + 1);
  }
  command.setResponse(DELETED);
  if (command.shouldReply()) {
    textCommandService.sendResponse(command);
  }
  textCommandService.incrementDeleteCount();
  textCommandService.delete(mapName,key);
}",0.9101401483924156
49687,"public Long extractLongValue(Object value){
  Object extractedValue=expression.getValue(value);
  if (extractedValue == null) {
    return Long.MIN_VALUE;
  }
 else {
    if (!checkedStrength) {
      if (extractedValue instanceof Boolean || extractedValue instanceof Number) {
        strong=true;
      }
      checkedStrength=true;
    }
    return getLongValueByType(extractedValue);
  }
}","public Long extractLongValue(Object value){
  Object extractedValue=expression.getValue(value);
  setIndexType(extractedValue);
  if (extractedValue == null) {
    return Long.MIN_VALUE;
  }
 else {
    returnType=getIndexType(extractedValue.getClass());
    if (!checkedStrength) {
      if (extractedValue instanceof Boolean || extractedValue instanceof Number) {
        strong=true;
      }
      checkedStrength=true;
    }
    return getLongValueByType(extractedValue);
  }
}",0.8993135011441648
49688,"public byte getIndexType(Class klass){
  if (klass == String.class) {
    return TYPE_STRING;
  }
 else   if (klass == int.class || klass == Integer.class) {
    return TYPE_INT;
  }
 else   if (klass == long.class || klass == Long.class) {
    return TYPE_LONG;
  }
 else   if (klass == boolean.class || klass == Boolean.class) {
    return TYPE_BOOLEAN;
  }
 else   if (klass == double.class || klass == Double.class) {
    return TYPE_DOUBLE;
  }
 else   if (klass == float.class || klass == Float.class) {
    return TYPE_FLOAT;
  }
 else   if (klass == byte.class || klass == Byte.class) {
    return TYPE_BYTE;
  }
 else   if (klass == char.class || klass == Character.class) {
    return TYPE_CLASS;
  }
 else {
    return TYPE_UNKNOWN;
  }
}","public static byte getIndexType(Class klass){
  if (klass == String.class) {
    return TYPE_STRING;
  }
 else   if (klass == int.class || klass == Integer.class) {
    return TYPE_INT;
  }
 else   if (klass == long.class || klass == Long.class) {
    return TYPE_LONG;
  }
 else   if (klass == boolean.class || klass == Boolean.class) {
    return TYPE_BOOLEAN;
  }
 else   if (klass == double.class || klass == Double.class) {
    return TYPE_DOUBLE;
  }
 else   if (klass == float.class || klass == Float.class) {
    return TYPE_FLOAT;
  }
 else   if (klass == byte.class || klass == Byte.class) {
    return TYPE_BYTE;
  }
 else   if (klass == char.class || klass == Character.class) {
    return TYPE_CLASS;
  }
 else {
    return TYPE_UNKNOWN;
  }
}",0.9953488372093025
49689,"CMap(ConcurrentMapManager concurrentMapManager,String name){
  this.concurrentMapManager=concurrentMapManager;
  this.logger=concurrentMapManager.node.getLogger(CMap.class.getName());
  this.PARTITION_COUNT=concurrentMapManager.PARTITION_COUNT;
  this.node=concurrentMapManager.node;
  this.thisAddress=concurrentMapManager.thisAddress;
  this.name=name;
  mapForQueue=name.startsWith(MAP_FOR_QUEUE);
  instanceType=ConcurrentMapManager.getInstanceType(name);
  String mapConfigName=name.substring(2);
  if (isMultiMap() || mapConfigName.startsWith(HAZELCAST) || mapConfigName.startsWith(AS_LIST)|| mapConfigName.startsWith(AS_SET)) {
    mapConfig=new MapConfig();
  }
 else   if (mapForQueue) {
    String queueShortName=name.substring(4);
    QueueConfig qConfig=node.getConfig().findMatchingQueueConfig(queueShortName);
    mapConfig=node.getConfig().findMatchingMapConfig(qConfig.getBackingMapRef());
  }
 else {
    mapConfig=node.getConfig().findMatchingMapConfig(mapConfigName);
  }
  this.mapIndexService=new MapIndexService(mapConfig.isValueIndexed());
  setRuntimeConfig(mapConfig);
  if (mapForQueue || node.groupProperties.ELASTIC_MEMORY_ENABLED.getBoolean()) {
    cacheValue=false;
  }
  MapStoreConfig mapStoreConfig=mapConfig.getMapStoreConfig();
  int writeDelaySeconds=-1;
  if (!node.isLiteMember() && mapStoreConfig != null) {
    try {
      MapStoreFactory factory=(MapStoreFactory)mapStoreConfig.getFactoryImplementation();
      if (factory == null) {
        String factoryClassName=mapStoreConfig.getFactoryClassName();
        if (factoryClassName != null && !""String_Node_Str"".equals(factoryClassName)) {
          factory=(MapStoreFactory)Serializer.loadClass(node.getConfig().getClassLoader(),factoryClassName).newInstance();
        }
      }
      Object storeInstance=factory == null ? mapStoreConfig.getImplementation() : factory.newMapStore(name,mapStoreConfig.getProperties());
      if (storeInstance == null) {
        String mapStoreClassName=mapStoreConfig.getClassName();
        storeInstance=Serializer.loadClass(node.getConfig().getClassLoader(),mapStoreClassName).newInstance();
      }
      mapStoreWrapper=new MapStoreWrapper(storeInstance,node.factory.getHazelcastInstanceProxy(),mapStoreConfig.getProperties(),mapConfigName,mapStoreConfig.isEnabled());
      if (!mapStoreWrapper.isMapLoader() && !mapStoreWrapper.isMapStore()) {
        throw new Exception(""String_Node_Str"" + storeInstance.getClass().getName() + ""String_Node_Str"");
      }
    }
 catch (    Exception e) {
      logger.log(Level.SEVERE,e.getMessage(),e);
    }
    writeDelaySeconds=mapStoreConfig.getWriteDelaySeconds();
  }
  writeDelayMillis=(writeDelaySeconds == -1) ? -1L : writeDelaySeconds * 1000L;
  if (writeDelaySeconds > 0) {
    removeDelayMillis=concurrentMapManager.GLOBAL_REMOVE_DELAY_MILLIS + writeDelayMillis;
  }
 else {
    removeDelayMillis=concurrentMapManager.GLOBAL_REMOVE_DELAY_MILLIS;
  }
  loader=(mapStoreWrapper == null || !mapStoreWrapper.isMapLoader()) ? null : mapStoreWrapper;
  store=(mapStoreWrapper == null || !mapStoreWrapper.isMapStore()) ? null : mapStoreWrapper;
  NearCacheConfig nearCacheConfig=mapConfig.getNearCacheConfig();
  if (nearCacheConfig == null) {
    nearCache=null;
  }
 else {
    NearCache nearCache=new NearCache(this,SortedHashMap.getOrderingTypeByName(nearCacheConfig.getEvictionPolicy()),nearCacheConfig.getMaxSize(),nearCacheConfig.getTimeToLiveSeconds() * 1000L,nearCacheConfig.getMaxIdleSeconds() * 1000L,nearCacheConfig.isInvalidateOnChange());
    final NearCache anotherNearCache=concurrentMapManager.mapCaches.putIfAbsent(name,nearCache);
    if (anotherNearCache != null) {
      nearCache=anotherNearCache;
    }
    this.nearCache=nearCache;
  }
  this.mergePolicy=getMergePolicy(mapConfig.getMergePolicy());
  this.creationTime=System.currentTimeMillis();
  WanReplicationRef wanReplicationRef=mapConfig.getWanReplicationRef();
  if (wanReplicationRef != null) {
    this.localUpdateListener=node.wanReplicationService.getWanReplication(wanReplicationRef.getName());
    this.wanMergePolicy=getMergePolicy(wanReplicationRef.getMergePolicy());
  }
 else {
    this.localUpdateListener=null;
    this.wanMergePolicy=null;
  }
  if (instanceType.isMultiMap()) {
    String shortMultiMapName=name.substring(4);
    multiMapConfig=node.getConfig().getMultiMapConfig(shortMultiMapName);
    if (multiMapConfig.getValueCollectionType() == MultiMapConfig.ValueCollectionType.SET) {
      multiMapSet=true;
    }
 else {
      multiMapSet=false;
    }
  }
 else {
    multiMapConfig=null;
    multiMapSet=false;
  }
  if (!mapForQueue) {
    initializeIndexes();
    initializeListeners();
  }
}","CMap(ConcurrentMapManager concurrentMapManager,String name){
  this.concurrentMapManager=concurrentMapManager;
  this.logger=concurrentMapManager.node.getLogger(CMap.class.getName());
  this.PARTITION_COUNT=concurrentMapManager.PARTITION_COUNT;
  this.node=concurrentMapManager.node;
  this.thisAddress=concurrentMapManager.thisAddress;
  this.name=name;
  mapForQueue=name.startsWith(MAP_FOR_QUEUE);
  instanceType=ConcurrentMapManager.getInstanceType(name);
  String mapConfigName=name.substring(2);
  if (isMultiMap() || mapConfigName.startsWith(HAZELCAST) || mapConfigName.startsWith(AS_LIST)|| mapConfigName.startsWith(AS_SET)) {
    mapConfig=new MapConfig();
  }
 else   if (mapForQueue) {
    String queueShortName=name.substring(4);
    QueueConfig qConfig=node.getConfig().findMatchingQueueConfig(queueShortName);
    mapConfig=node.getConfig().findMatchingMapConfig(qConfig.getBackingMapRef());
  }
 else {
    mapConfig=node.getConfig().findMatchingMapConfig(mapConfigName);
  }
  this.mapIndexService=new MapIndexService(mapConfig.isValueIndexed());
  setRuntimeConfig(mapConfig);
  if (mapForQueue || node.groupProperties.ELASTIC_MEMORY_ENABLED.getBoolean()) {
    cacheValue=false;
  }
  MapStoreConfig mapStoreConfig=mapConfig.getMapStoreConfig();
  int writeDelaySeconds=-1;
  if (!node.isLiteMember() && mapStoreConfig != null) {
    try {
      MapStoreFactory factory=(MapStoreFactory)mapStoreConfig.getFactoryImplementation();
      if (factory == null) {
        String factoryClassName=mapStoreConfig.getFactoryClassName();
        if (factoryClassName != null && !""String_Node_Str"".equals(factoryClassName)) {
          factory=(MapStoreFactory)Serializer.loadClass(node.getConfig().getClassLoader(),factoryClassName).newInstance();
        }
      }
      Object storeInstance=factory == null ? mapStoreConfig.getImplementation() : factory.newMapStore(name,mapStoreConfig.getProperties());
      if (storeInstance == null) {
        String mapStoreClassName=mapStoreConfig.getClassName();
        storeInstance=Serializer.loadClass(node.getConfig().getClassLoader(),mapStoreClassName).newInstance();
      }
      mapStoreWrapper=new MapStoreWrapper(storeInstance,node.factory.getHazelcastInstanceProxy(),mapStoreConfig.getProperties(),mapConfigName,mapStoreConfig.isEnabled());
      if (!mapStoreWrapper.isMapLoader() && !mapStoreWrapper.isMapStore()) {
        throw new Exception(""String_Node_Str"" + storeInstance.getClass().getName() + ""String_Node_Str"");
      }
    }
 catch (    Exception e) {
      logger.log(Level.SEVERE,e.getMessage(),e);
    }
    writeDelaySeconds=mapStoreConfig.getWriteDelaySeconds();
  }
  writeDelayMillis=(writeDelaySeconds == -1) ? -1L : writeDelaySeconds * 1000L;
  if (writeDelaySeconds > 0) {
    removeDelayMillis=concurrentMapManager.GLOBAL_REMOVE_DELAY_MILLIS + writeDelayMillis;
  }
 else {
    removeDelayMillis=concurrentMapManager.GLOBAL_REMOVE_DELAY_MILLIS;
  }
  loader=(mapStoreWrapper == null || !mapStoreWrapper.isMapLoader()) ? null : mapStoreWrapper;
  store=(mapStoreWrapper == null || !mapStoreWrapper.isMapStore()) ? null : mapStoreWrapper;
  NearCacheConfig nearCacheConfig=mapConfig.getNearCacheConfig();
  if (nearCacheConfig == null) {
    nearCache=null;
  }
 else {
    NearCache nearCache=new NearCache(this,SortedHashMap.getOrderingTypeByName(nearCacheConfig.getEvictionPolicy()),nearCacheConfig.getMaxSize(),nearCacheConfig.getTimeToLiveSeconds() * 1000L,nearCacheConfig.getMaxIdleSeconds() * 1000L,nearCacheConfig.isInvalidateOnChange());
    final NearCache anotherNearCache=concurrentMapManager.mapCaches.putIfAbsent(name,nearCache);
    if (anotherNearCache != null) {
      nearCache=anotherNearCache;
    }
    this.nearCache=nearCache;
  }
  int CLEANUP_DELAY_SECONDS=node.groupProperties.CLEANUP_DELAY_SECONDS.getInteger();
  if (CLEANUP_DELAY_SECONDS <= 0) {
    logger.log(Level.WARNING,GroupProperties.PROP_CLEANUP_DELAY_SECONDS + ""String_Node_Str"");
    CLEANUP_DELAY_SECONDS=1;
  }
  cleanupDelayMillis=CLEANUP_DELAY_SECONDS * 1000;
  this.mergePolicy=getMergePolicy(mapConfig.getMergePolicy());
  this.creationTime=System.currentTimeMillis();
  WanReplicationRef wanReplicationRef=mapConfig.getWanReplicationRef();
  if (wanReplicationRef != null) {
    this.localUpdateListener=node.wanReplicationService.getWanReplication(wanReplicationRef.getName());
    this.wanMergePolicy=getMergePolicy(wanReplicationRef.getMergePolicy());
  }
 else {
    this.localUpdateListener=null;
    this.wanMergePolicy=null;
  }
  if (instanceType.isMultiMap()) {
    String shortMultiMapName=name.substring(4);
    multiMapConfig=node.getConfig().getMultiMapConfig(shortMultiMapName);
    if (multiMapConfig.getValueCollectionType() == MultiMapConfig.ValueCollectionType.SET) {
      multiMapSet=true;
    }
 else {
      multiMapSet=false;
    }
  }
 else {
    multiMapConfig=null;
    multiMapSet=false;
  }
  if (!mapForQueue) {
    initializeIndexes();
    initializeListeners();
  }
}",0.9690380035207622
49690,"void markAsDirty(Record record){
  if (!record.isDirty()) {
    record.setDirty(true);
    if (writeDelayMillis > 0) {
      record.setWriteTime(System.currentTimeMillis() + writeDelayMillis);
    }
  }
}","void markAsDirty(Record record){
  if (!record.isDirty()) {
    dirty=true;
    record.setDirty(true);
    if (writeDelayMillis > 0) {
      record.setWriteTime(System.currentTimeMillis() + writeDelayMillis);
    }
  }
}",0.8820754716981132
49691,"boolean startCleanup(boolean forced){
  if (cleanupActive.compareAndSet(false,true)) {
    try {
      final long now=System.currentTimeMillis();
      if (nearCache != null) {
        nearCache.evict(now,false);
      }
      final Set<Record> recordsDirty=new HashSet<Record>();
      final Set<Record> recordsUnknown=new HashSet<Record>();
      final Set<Record> recordsToPurge=new HashSet<Record>();
      final Set<Record> recordsToEvict=new HashSet<Record>();
      final Set<Record> sortedRecords=new TreeSet<Record>(new ComparatorWrapper(evictionComparator));
      final Collection<Record> records=mapRecords.values();
      final boolean overCapacity=maxSizePolicy.overCapacity();
      final boolean evictionAware=evictionComparator != null && overCapacity;
      int recordsStillOwned=0;
      int backupPurgeCount=0;
      PartitionManager partitionManager=concurrentMapManager.partitionManager;
      for (      Record record : records) {
        PartitionInfo partition=partitionManager.getPartition(record.getBlockId());
        Address owner=partition.getOwner();
        boolean owned=(owner != null && thisAddress.equals(owner));
        boolean ownedOrBackup=partition.isOwnerOrBackup(thisAddress,backupCount);
        if (owner != null && !partitionManager.isPartitionMigrating(partition.getPartitionId())) {
          if (owned) {
            if (store != null && writeDelayMillis > 0 && record.isDirty()) {
              if (now > record.getWriteTime()) {
                recordsDirty.add(record);
                record.setDirty(false);
              }
            }
 else             if (shouldPurgeRecord(record,now)) {
              recordsToPurge.add(record);
            }
 else             if (record.isActive() && !record.isValid(now)) {
              recordsToEvict.add(record);
            }
 else             if (evictionAware && record.isActive() && record.isEvictable()) {
              sortedRecords.add(record);
              recordsStillOwned++;
            }
          }
 else           if (ownedOrBackup) {
            if (shouldPurgeRecord(record,now)) {
              recordsToPurge.add(record);
              backupPurgeCount++;
            }
          }
 else {
            recordsUnknown.add(record);
          }
        }
      }
      if (evictionAware && (forced || overCapacity)) {
        int numberOfRecordsToEvict=(int)(recordsStillOwned * evictionRate);
        int evictedCount=0;
        for (        Record record : sortedRecords) {
          if (record.isActive() && record.isEvictable()) {
            recordsToEvict.add(record);
            if (++evictedCount >= numberOfRecordsToEvict) {
              break;
            }
          }
        }
      }
      Level levelLog=(concurrentMapManager.LOG_STATE) ? Level.INFO : Level.FINEST;
      logger.log(levelLog,name + ""String_Node_Str"" + ""String_Node_Str""+ recordsDirty.size()+ ""String_Node_Str""+ recordsToPurge.size()+ ""String_Node_Str""+ recordsToEvict.size()+ ""String_Node_Str""+ recordsUnknown.size()+ ""String_Node_Str""+ recordsStillOwned+ ""String_Node_Str""+ backupPurgeCount);
      executeStoreUpdate(recordsDirty);
      executeEviction(recordsToEvict);
      executePurge(recordsToPurge);
      executePurgeUnknowns(recordsUnknown);
    }
  finally {
      cleanupActive.set(false);
      return true;
    }
  }
 else {
    return false;
  }
}","boolean startCleanup(boolean forced){
  final long now=System.currentTimeMillis();
  long dirtyAge=(now - lastCleanup);
  boolean shouldRun=(store != null && dirty && dirtyAge >= writeDelayMillis) || (dirtyAge > cleanupDelayMillis);
  if (shouldRun && cleanupActive.compareAndSet(false,true)) {
    lastCleanup=now;
    try {
      if (nearCache != null) {
        nearCache.evict(now,false);
      }
      dirty=false;
      final Set<Record> recordsDirty=new HashSet<Record>();
      final Set<Record> recordsUnknown=new HashSet<Record>();
      final Set<Record> recordsToPurge=new HashSet<Record>();
      final Set<Record> recordsToEvict=new HashSet<Record>();
      final Set<Record> sortedRecords=new TreeSet<Record>(new ComparatorWrapper(evictionComparator));
      final Collection<Record> records=mapRecords.values();
      final boolean overCapacity=maxSizePolicy.overCapacity();
      final boolean evictionAware=evictionComparator != null && overCapacity;
      int recordsStillOwned=0;
      int backupPurgeCount=0;
      PartitionManager partitionManager=concurrentMapManager.partitionManager;
      for (      Record record : records) {
        PartitionInfo partition=partitionManager.getPartition(record.getBlockId());
        Address owner=partition.getOwner();
        boolean owned=(owner != null && thisAddress.equals(owner));
        boolean ownedOrBackup=partition.isOwnerOrBackup(thisAddress,backupCount);
        if (owner != null && !partitionManager.isPartitionMigrating(partition.getPartitionId())) {
          if (owned) {
            if (store != null && writeDelayMillis > 0 && record.isDirty()) {
              if (now > record.getWriteTime()) {
                recordsDirty.add(record);
                record.setDirty(false);
              }
 else {
                dirty=true;
              }
            }
 else             if (shouldPurgeRecord(record,now)) {
              recordsToPurge.add(record);
            }
 else             if (record.isActive() && !record.isValid(now)) {
              recordsToEvict.add(record);
            }
 else             if (evictionAware && record.isActive() && record.isEvictable()) {
              sortedRecords.add(record);
              recordsStillOwned++;
            }
          }
 else           if (ownedOrBackup) {
            if (shouldPurgeRecord(record,now)) {
              recordsToPurge.add(record);
              backupPurgeCount++;
            }
          }
 else {
            recordsUnknown.add(record);
          }
        }
      }
      if (evictionAware && (forced || overCapacity)) {
        int numberOfRecordsToEvict=(int)(recordsStillOwned * evictionRate);
        int evictedCount=0;
        for (        Record record : sortedRecords) {
          if (record.isActive() && record.isEvictable()) {
            recordsToEvict.add(record);
            if (++evictedCount >= numberOfRecordsToEvict) {
              break;
            }
          }
        }
      }
      Level levelLog=(concurrentMapManager.LOG_STATE) ? Level.INFO : Level.FINEST;
      logger.log(levelLog,name + ""String_Node_Str"" + ""String_Node_Str""+ recordsDirty.size()+ ""String_Node_Str""+ recordsToPurge.size()+ ""String_Node_Str""+ recordsToEvict.size()+ ""String_Node_Str""+ recordsUnknown.size()+ ""String_Node_Str""+ recordsStillOwned+ ""String_Node_Str""+ backupPurgeCount);
      executeStoreUpdate(recordsDirty);
      executeEviction(recordsToEvict);
      executePurge(recordsToPurge);
      executePurgeUnknowns(recordsUnknown);
      return true;
    }
  finally {
      cleanupActive.set(false);
    }
  }
 else {
    return false;
  }
}",0.9364874551971326
49692,"ConcurrentMapManager(final Node node){
  super(node);
  recordFactory=node.initializer.getRecordFactory();
  storeExecutor=node.executorManager.newParallelExecutor(node.groupProperties.EXECUTOR_STORE_THREAD_COUNT.getInteger());
  evictionExecutor=node.executorManager.newParallelExecutor(node.groupProperties.EXECUTOR_STORE_THREAD_COUNT.getInteger());
  PARTITION_COUNT=node.groupProperties.CONCURRENT_MAP_PARTITION_COUNT.getInteger();
  MAX_BACKUP_COUNT=PartitionInfo.MAX_REPLICA_COUNT;
  GLOBAL_REMOVE_DELAY_MILLIS=node.groupProperties.REMOVE_DELAY_SECONDS.getLong() * 1000L;
  int CLEANUP_DELAY_SECONDS=node.groupProperties.CLEANUP_DELAY_SECONDS.getInteger();
  if (CLEANUP_DELAY_SECONDS <= 0) {
    logger.log(Level.WARNING,GroupProperties.PROP_CLEANUP_DELAY_SECONDS + ""String_Node_Str"");
    CLEANUP_DELAY_SECONDS=1;
  }
  LOG_STATE=node.groupProperties.LOG_STATE.getBoolean();
  maps=new ConcurrentHashMap<String,CMap>(10,0.75f,1);
  mapCaches=new ConcurrentHashMap<String,NearCache>(10,0.75f,1);
  partitionManager=new PartitionManager(this);
  partitionServiceImpl=new PartitionServiceImpl(this);
  node.executorManager.getScheduledExecutorService().scheduleAtFixedRate(new Runnable(){
    public void run(){
      startCleanup(true,false);
    }
  }
,10,CLEANUP_DELAY_SECONDS,TimeUnit.SECONDS);
  registerPacketProcessor(CONCURRENT_MAP_GET_MAP_ENTRY,new GetMapEntryOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_GET_DATA_RECORD_ENTRY,new GetDataRecordEntryOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_GET,new GetOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ASYNC_MERGE,new AsyncMergePacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_WAN_MERGE,new WanMergePacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_MERGE,new MergeOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_TRY_PUT,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_SET,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT_AND_UNLOCK,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT_TRANSIENT,new PutTransientOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT_IF_ABSENT,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REPLACE_IF_NOT_NULL,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REPLACE_IF_SAME,new ReplaceOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT_MULTI,new PutMultiOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE,new RemoveOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_EVICT,new EvictOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE_IF_SAME,new RemoveIfSameOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE_ITEM,new RemoveItemOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_PUT,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_ADD,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_REMOVE_MULTI,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_REMOVE,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_LOCK,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_LOCK,new LockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_TRY_LOCK_AND_GET,new LockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_UNLOCK,new UnlockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_FORCE_UNLOCK,new ForceUnlockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_LOCK_MAP,new LockMapOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_UNLOCK_MAP,new LockMapOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE_MULTI,new RemoveMultiOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ADD_TO_LIST,new AddOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ADD_TO_SET,new AddOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_CONTAINS_KEY,new ContainsKeyOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_CONTAINS_ENTRY,new ContainsEntryOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_CONTAINS_VALUE,new ContainsValueOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_VALUE_COUNT,new ValueCountOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_INVALIDATE,new InvalidateOperationHandler());
  registerPacketProcessor(ATOMIC_NUMBER_ADD_AND_GET,new AtomicNumberAddAndGetOperationHandler());
  registerPacketProcessor(ATOMIC_NUMBER_COMPARE_AND_SET,new AtomicNumberCompareAndSetOperationHandler());
  registerPacketProcessor(ATOMIC_NUMBER_GET_AND_ADD,new AtomicNumberGetAndAddOperationHandler());
  registerPacketProcessor(ATOMIC_NUMBER_GET_AND_SET,new AtomicNumberGetAndSetOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_AWAIT,new CountDownLatchAwaitOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_COUNT_DOWN,new CountDownLatchCountDownOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_DESTROY,new CountDownLatchDestroyOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_GET_COUNT,new CountDownLatchGetCountOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_GET_OWNER,new CountDownLatchGetOwnerOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_SET_COUNT,new CountDownLatchSetCountOperationHandler());
  registerPacketProcessor(SEMAPHORE_ATTACH_DETACH_PERMITS,new SemaphoreAttachDetachOperationHandler());
  registerPacketProcessor(SEMAPHORE_CANCEL_ACQUIRE,new SemaphoreCancelAcquireOperationHandler());
  registerPacketProcessor(SEMAPHORE_DESTROY,new SemaphoreDestroyOperationHandler());
  registerPacketProcessor(SEMAPHORE_DRAIN_PERMITS,new SemaphoreDrainOperationHandler());
  registerPacketProcessor(SEMAPHORE_GET_ATTACHED_PERMITS,new SemaphoreGetAttachedOperationHandler());
  registerPacketProcessor(SEMAPHORE_GET_AVAILABLE_PERMITS,new SemaphoreGetAvailableOperationHandler());
  registerPacketProcessor(SEMAPHORE_REDUCE_PERMITS,new SemaphoreReduceOperationHandler());
  registerPacketProcessor(SEMAPHORE_RELEASE,new SemaphoreReleaseOperationHandler());
  registerPacketProcessor(SEMAPHORE_TRY_ACQUIRE,new SemaphoreTryAcquireOperationHandler());
}","ConcurrentMapManager(final Node node){
  super(node);
  recordFactory=node.initializer.getRecordFactory();
  storeExecutor=node.executorManager.newParallelExecutor(node.groupProperties.EXECUTOR_STORE_THREAD_COUNT.getInteger());
  evictionExecutor=node.executorManager.newParallelExecutor(node.groupProperties.EXECUTOR_STORE_THREAD_COUNT.getInteger());
  PARTITION_COUNT=node.groupProperties.CONCURRENT_MAP_PARTITION_COUNT.getInteger();
  MAX_BACKUP_COUNT=PartitionInfo.MAX_REPLICA_COUNT;
  GLOBAL_REMOVE_DELAY_MILLIS=node.groupProperties.REMOVE_DELAY_SECONDS.getLong() * 1000L;
  LOG_STATE=node.groupProperties.LOG_STATE.getBoolean();
  maps=new ConcurrentHashMap<String,CMap>(10,0.75f,1);
  mapCaches=new ConcurrentHashMap<String,NearCache>(10,0.75f,1);
  partitionManager=new PartitionManager(this);
  partitionServiceImpl=new PartitionServiceImpl(this);
  node.executorManager.getScheduledExecutorService().scheduleAtFixedRate(new Runnable(){
    public void run(){
      for (      CMap cMap : maps.values()) {
        cMap.startCleanup(false);
      }
    }
  }
,1,1,TimeUnit.SECONDS);
  registerPacketProcessor(CONCURRENT_MAP_GET_MAP_ENTRY,new GetMapEntryOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_GET_DATA_RECORD_ENTRY,new GetDataRecordEntryOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_GET,new GetOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ASYNC_MERGE,new AsyncMergePacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_WAN_MERGE,new WanMergePacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_MERGE,new MergeOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_TRY_PUT,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_SET,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT_AND_UNLOCK,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT_TRANSIENT,new PutTransientOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT_IF_ABSENT,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REPLACE_IF_NOT_NULL,new PutOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REPLACE_IF_SAME,new ReplaceOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_PUT_MULTI,new PutMultiOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE,new RemoveOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_EVICT,new EvictOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE_IF_SAME,new RemoveIfSameOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE_ITEM,new RemoveItemOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_PUT,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_ADD,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_REMOVE_MULTI,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_REMOVE,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_BACKUP_LOCK,new BackupPacketProcessor());
  registerPacketProcessor(CONCURRENT_MAP_LOCK,new LockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_TRY_LOCK_AND_GET,new LockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_UNLOCK,new UnlockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_FORCE_UNLOCK,new ForceUnlockOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_LOCK_MAP,new LockMapOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_UNLOCK_MAP,new LockMapOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_REMOVE_MULTI,new RemoveMultiOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ADD_TO_LIST,new AddOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_ADD_TO_SET,new AddOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_CONTAINS_KEY,new ContainsKeyOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_CONTAINS_ENTRY,new ContainsEntryOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_CONTAINS_VALUE,new ContainsValueOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_VALUE_COUNT,new ValueCountOperationHandler());
  registerPacketProcessor(CONCURRENT_MAP_INVALIDATE,new InvalidateOperationHandler());
  registerPacketProcessor(ATOMIC_NUMBER_ADD_AND_GET,new AtomicNumberAddAndGetOperationHandler());
  registerPacketProcessor(ATOMIC_NUMBER_COMPARE_AND_SET,new AtomicNumberCompareAndSetOperationHandler());
  registerPacketProcessor(ATOMIC_NUMBER_GET_AND_ADD,new AtomicNumberGetAndAddOperationHandler());
  registerPacketProcessor(ATOMIC_NUMBER_GET_AND_SET,new AtomicNumberGetAndSetOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_AWAIT,new CountDownLatchAwaitOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_COUNT_DOWN,new CountDownLatchCountDownOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_DESTROY,new CountDownLatchDestroyOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_GET_COUNT,new CountDownLatchGetCountOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_GET_OWNER,new CountDownLatchGetOwnerOperationHandler());
  registerPacketProcessor(COUNT_DOWN_LATCH_SET_COUNT,new CountDownLatchSetCountOperationHandler());
  registerPacketProcessor(SEMAPHORE_ATTACH_DETACH_PERMITS,new SemaphoreAttachDetachOperationHandler());
  registerPacketProcessor(SEMAPHORE_CANCEL_ACQUIRE,new SemaphoreCancelAcquireOperationHandler());
  registerPacketProcessor(SEMAPHORE_DESTROY,new SemaphoreDestroyOperationHandler());
  registerPacketProcessor(SEMAPHORE_DRAIN_PERMITS,new SemaphoreDrainOperationHandler());
  registerPacketProcessor(SEMAPHORE_GET_ATTACHED_PERMITS,new SemaphoreGetAttachedOperationHandler());
  registerPacketProcessor(SEMAPHORE_GET_AVAILABLE_PERMITS,new SemaphoreGetAvailableOperationHandler());
  registerPacketProcessor(SEMAPHORE_REDUCE_PERMITS,new SemaphoreReduceOperationHandler());
  registerPacketProcessor(SEMAPHORE_RELEASE,new SemaphoreReleaseOperationHandler());
  registerPacketProcessor(SEMAPHORE_TRY_ACQUIRE,new SemaphoreTryAcquireOperationHandler());
}",0.9711776447105788
49693,"protected void handleCommand(String command){
  if (echo) {
    if (Thread.currentThread().getName().toLowerCase().indexOf(""String_Node_Str"") < 0)     println(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str""+ command);
 else     println(command);
  }
  if (command == null || command.startsWith(""String_Node_Str""))   return;
  command=command.trim();
  if (command == null || command.length() == 0) {
    return;
  }
  String first=command;
  int spaceIndex=command.indexOf(' ');
  String[] argsSplit=command.split(""String_Node_Str"");
  String[] args=new String[argsSplit.length];
  for (int i=0; i < argsSplit.length; i++) {
    args[i]=argsSplit[i].trim();
  }
  if (spaceIndex != -1) {
    first=args[0];
  }
  if (command.startsWith(""String_Node_Str"")) {
    handleHelp(command);
  }
 else   if (first.startsWith(""String_Node_Str"") && first.length() > 1) {
    int repeat=Integer.parseInt(first.substring(1));
    long t0=System.currentTimeMillis();
    for (int i=0; i < repeat; i++) {
      handleCommand(command.substring(first.length()).replaceAll(""String_Node_Str"",""String_Node_Str"" + i));
    }
    println(""String_Node_Str"" + repeat * 1000 / (System.currentTimeMillis() - t0));
    return;
  }
 else   if (first.startsWith(""String_Node_Str"") && first.length() > 1) {
    final int fork=Integer.parseInt(first.substring(1));
    ExecutorService pool=Executors.newFixedThreadPool(fork);
    final String threadCommand=command.substring(first.length());
    for (int i=0; i < fork; i++) {
      final int threadID=i;
      pool.submit(new Runnable(){
        public void run(){
          String command=threadCommand;
          String[] threadArgs=command.replaceAll(""String_Node_Str"",""String_Node_Str"" + threadID).trim().split(""String_Node_Str"");
          if (""String_Node_Str"".equals(threadArgs[0]) || ""String_Node_Str"".equals(threadArgs[0])) {
            if (threadArgs.length < 4) {
              command+=""String_Node_Str"" + Integer.parseInt(threadArgs[1]) * threadID;
            }
          }
          handleCommand(command);
        }
      }
);
    }
    pool.shutdown();
    try {
      pool.awaitTermination(60 * 60,TimeUnit.SECONDS);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
 else   if (first.startsWith(""String_Node_Str"")) {
    if (first.length() == 1) {
      println(""String_Node_Str"");
      return;
    }
    File f=new File(first.substring(1));
    println(""String_Node_Str"" + f.getAbsolutePath());
    if (f.exists()) {
      try {
        BufferedReader br=new BufferedReader(new FileReader(f));
        String l=br.readLine();
        while (l != null) {
          handleCommand(l);
          l=br.readLine();
        }
        br.close();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
 else {
      println(""String_Node_Str"" + f.getAbsolutePath());
    }
  }
 else   if (command.indexOf(';') != -1) {
    StringTokenizer st=new StringTokenizer(command,""String_Node_Str"");
    while (st.hasMoreTokens()) {
      handleCommand(st.nextToken());
    }
    return;
  }
 else   if (""String_Node_Str"".equals(first)) {
    silent=Boolean.parseBoolean(args[1]);
  }
 else   if (""String_Node_Str"".equals(first)) {
    hazelcast.restart();
  }
 else   if (""String_Node_Str"".equals(first)) {
    hazelcast.shutdown();
  }
 else   if (""String_Node_Str"".equals(first)) {
    echo=Boolean.parseBoolean(args[1]);
    println(""String_Node_Str"" + echo);
  }
 else   if (""String_Node_Str"".equals(first)) {
    if (args.length > 1) {
      namespace=args[1];
      println(""String_Node_Str"" + namespace);
    }
  }
 else   if (""String_Node_Str"".equals(first)) {
    println(hazelcast.getCluster().getLocalMember());
  }
 else   if (""String_Node_Str"".equals(first)) {
    println(hazelcast.getCluster());
  }
 else   if (""String_Node_Str"".equals(first)) {
    System.gc();
    println(""String_Node_Str"" + Runtime.getRuntime().maxMemory() / 1024 / 1024 + ""String_Node_Str"");
    println(""String_Node_Str"" + Runtime.getRuntime().freeMemory() / 1024 / 1024 + ""String_Node_Str"" + (int)(Runtime.getRuntime().freeMemory() * 100 / Runtime.getRuntime().maxMemory()) + ""String_Node_Str"");
    long total=Runtime.getRuntime().totalMemory();
    long free=Runtime.getRuntime().freeMemory();
    println(""String_Node_Str"" + ((total - free) / 1024 / 1024) + ""String_Node_Str"");
    println(""String_Node_Str"" + Runtime.getRuntime().availableProcessors());
    println(""String_Node_Str"" + ManagementFactory.getOperatingSystemMXBean().getArch() + ""String_Node_Str""+ ManagementFactory.getOperatingSystemMXBean().getName()+ ""String_Node_Str""+ ManagementFactory.getOperatingSystemMXBean().getVersion());
    println(""String_Node_Str"" + ManagementFactory.getRuntimeMXBean().getVmVendor() + ""String_Node_Str""+ ManagementFactory.getRuntimeMXBean().getVmName()+ ""String_Node_Str""+ ManagementFactory.getRuntimeMXBean().getVmVersion());
  }
 else   if (first.indexOf(""String_Node_Str"") != -1 && first.indexOf(""String_Node_Str"") == -1) {
    handleLock(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleSize(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleClear(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleDestroy(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleIterator(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleContains(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handStats(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleTopicPublish(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQOffer(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQTake(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQPoll(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQPeek(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQCapacity(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQOfferMany(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQPollMany(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleSetAdd(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleSetRemove(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleSetAddMany(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleSetRemoveMany(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapReplace(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    handleMapPutIfAbsent(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapPutAsync(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapGetAsync(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapPut(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapGet(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    handleMapGetMapEntry(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapRemove(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapEvict(args);
  }
 else   if (first.equals(""String_Node_Str"") || first.equalsIgnoreCase(""String_Node_Str"")) {
    handleMapPutMany(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapGetMany(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapRemoveMany(args);
  }
 else   if (command.equalsIgnoreCase(""String_Node_Str"")) {
    handleMapLocalKeys();
  }
 else   if (command.equals(""String_Node_Str"")) {
    handleMapKeys();
  }
 else   if (command.equals(""String_Node_Str"")) {
    handleMapValues();
  }
 else   if (command.equals(""String_Node_Str"")) {
    handleMapEntries();
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapLock(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    handleMapTryLock(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapUnlock(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleAddListener(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleRemoveListener(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapUnlock(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleListAdd(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleListSet(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleListAddMany(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleListRemove(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleListContains(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    execute(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handlePartitions(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    hazelcast.getTransaction().begin();
  }
 else   if (first.equals(""String_Node_Str"")) {
    hazelcast.getTransaction().commit();
  }
 else   if (first.equals(""String_Node_Str"")) {
    hazelcast.getTransaction().rollback();
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    executeOnKey(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    executeOnMember(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    executeOnMembers(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"") || first.equalsIgnoreCase(""String_Node_Str"")) {
    executeLongTaskOnOtherMember(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"") || first.equalsIgnoreCase(""String_Node_Str"")) {
    executeLong(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    handleInstances(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"") || first.equalsIgnoreCase(""String_Node_Str"")) {
    System.exit(0);
  }
 else {
    println(""String_Node_Str"");
  }
}","protected void handleCommand(String command){
  if (echo) {
    if (Thread.currentThread().getName().toLowerCase().indexOf(""String_Node_Str"") < 0)     println(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str""+ command);
 else     println(command);
  }
  if (command == null || command.startsWith(""String_Node_Str""))   return;
  command=command.trim();
  if (command == null || command.length() == 0) {
    return;
  }
  String first=command;
  int spaceIndex=command.indexOf(' ');
  String[] argsSplit=command.split(""String_Node_Str"");
  String[] args=new String[argsSplit.length];
  for (int i=0; i < argsSplit.length; i++) {
    args[i]=argsSplit[i].trim();
  }
  if (spaceIndex != -1) {
    first=args[0];
  }
  if (command.startsWith(""String_Node_Str"")) {
    handleHelp(command);
  }
 else   if (first.startsWith(""String_Node_Str"") && first.length() > 1) {
    int repeat=Integer.parseInt(first.substring(1));
    long t0=System.currentTimeMillis();
    for (int i=0; i < repeat; i++) {
      handleCommand(command.substring(first.length()).replaceAll(""String_Node_Str"",""String_Node_Str"" + i));
    }
    println(""String_Node_Str"" + repeat * 1000 / (System.currentTimeMillis() - t0));
    return;
  }
 else   if (first.startsWith(""String_Node_Str"") && first.length() > 1) {
    final int fork=Integer.parseInt(first.substring(1));
    ExecutorService pool=Executors.newFixedThreadPool(fork);
    final String threadCommand=command.substring(first.length());
    for (int i=0; i < fork; i++) {
      final int threadID=i;
      pool.submit(new Runnable(){
        public void run(){
          String command=threadCommand;
          String[] threadArgs=command.replaceAll(""String_Node_Str"",""String_Node_Str"" + threadID).trim().split(""String_Node_Str"");
          if (""String_Node_Str"".equals(threadArgs[0]) || ""String_Node_Str"".equals(threadArgs[0])) {
            if (threadArgs.length < 4) {
              command+=""String_Node_Str"" + Integer.parseInt(threadArgs[1]) * threadID;
            }
          }
          handleCommand(command);
        }
      }
);
    }
    pool.shutdown();
    try {
      pool.awaitTermination(60 * 60,TimeUnit.SECONDS);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
 else   if (first.startsWith(""String_Node_Str"")) {
    if (first.length() == 1) {
      println(""String_Node_Str"");
      return;
    }
    File f=new File(first.substring(1));
    println(""String_Node_Str"" + f.getAbsolutePath());
    if (f.exists()) {
      try {
        BufferedReader br=new BufferedReader(new FileReader(f));
        String l=br.readLine();
        while (l != null) {
          handleCommand(l);
          l=br.readLine();
        }
        br.close();
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
 else {
      println(""String_Node_Str"" + f.getAbsolutePath());
    }
  }
 else   if (command.indexOf(';') != -1) {
    StringTokenizer st=new StringTokenizer(command,""String_Node_Str"");
    while (st.hasMoreTokens()) {
      handleCommand(st.nextToken());
    }
    return;
  }
 else   if (""String_Node_Str"".equals(first)) {
    silent=Boolean.parseBoolean(args[1]);
  }
 else   if (""String_Node_Str"".equals(first)) {
    hazelcast.restart();
  }
 else   if (""String_Node_Str"".equals(first)) {
    hazelcast.shutdown();
  }
 else   if (""String_Node_Str"".equals(first)) {
    echo=Boolean.parseBoolean(args[1]);
    println(""String_Node_Str"" + echo);
  }
 else   if (""String_Node_Str"".equals(first)) {
    if (args.length > 1) {
      namespace=args[1];
      println(""String_Node_Str"" + namespace);
    }
  }
 else   if (""String_Node_Str"".equals(first)) {
    println(hazelcast.getCluster().getLocalMember());
  }
 else   if (""String_Node_Str"".equals(first)) {
    println(hazelcast.getCluster());
  }
 else   if (""String_Node_Str"".equals(first)) {
    System.gc();
    println(""String_Node_Str"" + Runtime.getRuntime().maxMemory() / 1024 / 1024 + ""String_Node_Str"");
    println(""String_Node_Str"" + Runtime.getRuntime().freeMemory() / 1024 / 1024 + ""String_Node_Str"" + (int)(Runtime.getRuntime().freeMemory() * 100 / Runtime.getRuntime().maxMemory()) + ""String_Node_Str"");
    long total=Runtime.getRuntime().totalMemory();
    long free=Runtime.getRuntime().freeMemory();
    println(""String_Node_Str"" + ((total - free) / 1024 / 1024) + ""String_Node_Str"");
    println(""String_Node_Str"" + Runtime.getRuntime().availableProcessors());
    println(""String_Node_Str"" + ManagementFactory.getOperatingSystemMXBean().getArch() + ""String_Node_Str""+ ManagementFactory.getOperatingSystemMXBean().getName()+ ""String_Node_Str""+ ManagementFactory.getOperatingSystemMXBean().getVersion());
    println(""String_Node_Str"" + ManagementFactory.getRuntimeMXBean().getVmVendor() + ""String_Node_Str""+ ManagementFactory.getRuntimeMXBean().getVmName()+ ""String_Node_Str""+ ManagementFactory.getRuntimeMXBean().getVmVersion());
  }
 else   if (first.indexOf(""String_Node_Str"") != -1 && first.indexOf(""String_Node_Str"") == -1) {
    handleLock(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleSize(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleClear(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleDestroy(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleIterator(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleContains(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handStats(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleTopicPublish(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQOffer(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQTake(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQPoll(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQPeek(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQCapacity(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQOfferMany(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleQPollMany(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleSetAdd(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleSetRemove(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleSetAddMany(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleSetRemoveMany(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapReplace(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    handleMapPutIfAbsent(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapPutAsync(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapGetAsync(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapPut(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapGet(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    handleMapGetMapEntry(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapRemove(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapEvict(args);
  }
 else   if (first.equals(""String_Node_Str"") || first.equalsIgnoreCase(""String_Node_Str"")) {
    handleMapPutMany(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapGetMany(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapRemoveMany(args);
  }
 else   if (command.equalsIgnoreCase(""String_Node_Str"")) {
    handleMapLocalKeys();
  }
 else   if (command.equals(""String_Node_Str"")) {
    handleMapKeys();
  }
 else   if (command.equals(""String_Node_Str"")) {
    handleMapValues();
  }
 else   if (command.equals(""String_Node_Str"")) {
    handleMapEntries();
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapLock(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    handleMapTryLock(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapUnlock(args);
  }
 else   if (first.indexOf(""String_Node_Str"") != -1) {
    handleAddListener(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleRemoveListener(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleMapUnlock(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleListAdd(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleListSet(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleListAddMany(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleListRemove(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handleListContains(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleAtomicNumberGet(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleAtomicNumberSet(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleAtomicNumberInc(args);
  }
 else   if (""String_Node_Str"".equals(first)) {
    handleAtomicNumberDec(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    execute(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    handlePartitions(args);
  }
 else   if (first.equals(""String_Node_Str"")) {
    hazelcast.getTransaction().begin();
  }
 else   if (first.equals(""String_Node_Str"")) {
    hazelcast.getTransaction().commit();
  }
 else   if (first.equals(""String_Node_Str"")) {
    hazelcast.getTransaction().rollback();
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    executeOnKey(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    executeOnMember(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    executeOnMembers(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"") || first.equalsIgnoreCase(""String_Node_Str"")) {
    executeLongTaskOnOtherMember(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"") || first.equalsIgnoreCase(""String_Node_Str"")) {
    executeLong(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"")) {
    handleInstances(args);
  }
 else   if (first.equalsIgnoreCase(""String_Node_Str"") || first.equalsIgnoreCase(""String_Node_Str"")) {
    System.exit(0);
  }
 else {
    println(""String_Node_Str"");
  }
}",0.9833035181872392
49694,"protected void handleHelp(String command){
  boolean silentBefore=silent;
  silent=false;
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  silent=silentBefore;
}","protected void handleHelp(String command){
  boolean silentBefore=silent;
  silent=false;
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  print(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  print(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  silent=silentBefore;
}",0.9506688963210702
49695,"private HazelcastClient(ClientConfig config){
  if (config.getCredentials() == null) {
    config.setCredentials(new UsernamePasswordCredentials(config.getGroupConfig().getName(),config.getGroupConfig().getPassword()));
  }
  this.config=config;
  this.id=clientIdCounter.incrementAndGet();
  lifecycleService=new LifecycleServiceClientImpl(this);
  lifecycleService.fireLifecycleEvent(STARTING);
  connectionManager=new ConnectionManager(this,config,lifecycleService);
  connectionManager.setBinder(new DefaultClientBinder(this));
  out=new OutRunnable(this,calls,new PacketWriter());
  in=new InRunnable(this,out,calls,new PacketReader());
  listenerManager=new ListenerManager(this);
  try {
    final Connection c=connectionManager.getInitConnection();
    if (c == null) {
      connectionManager.shutdown();
      throw new IllegalStateException(""String_Node_Str"");
    }
  }
 catch (  IOException e) {
    connectionManager.shutdown();
    throw new ClusterClientException(e.getMessage(),e);
  }
  final String prefix=""String_Node_Str"" + this.id + ""String_Node_Str"";
  new Thread(out,prefix + ""String_Node_Str"").start();
  new Thread(in,prefix + ""String_Node_Str"").start();
  new Thread(listenerManager,prefix + ""String_Node_Str"").start();
  clusterClientProxy=new ClusterClientProxy(this);
  partitionClientProxy=new PartitionClientProxy(this);
  if (config.isUpdateAutomatic()) {
    this.getCluster().addMembershipListener(connectionManager);
    connectionManager.updateMembers();
  }
  lifecycleService.fireLifecycleEvent(STARTED);
  connectionManager.scheduleHeartbeatTimerTask();
  lsClients.add(HazelcastClient.this);
}","private HazelcastClient(ClientConfig config){
  if (config.getAddressList().size() == 0) {
    config.addAddress(""String_Node_Str"");
  }
  if (config.getCredentials() == null) {
    config.setCredentials(new UsernamePasswordCredentials(config.getGroupConfig().getName(),config.getGroupConfig().getPassword()));
  }
  this.config=config;
  this.id=clientIdCounter.incrementAndGet();
  lifecycleService=new LifecycleServiceClientImpl(this);
  lifecycleService.fireLifecycleEvent(STARTING);
  connectionManager=new ConnectionManager(this,config,lifecycleService);
  connectionManager.setBinder(new DefaultClientBinder(this));
  out=new OutRunnable(this,calls,new PacketWriter());
  in=new InRunnable(this,out,calls,new PacketReader());
  listenerManager=new ListenerManager(this);
  try {
    final Connection c=connectionManager.getInitConnection();
    if (c == null) {
      connectionManager.shutdown();
      throw new IllegalStateException(""String_Node_Str"");
    }
  }
 catch (  IOException e) {
    connectionManager.shutdown();
    throw new ClusterClientException(e.getMessage(),e);
  }
  final String prefix=""String_Node_Str"" + this.id + ""String_Node_Str"";
  new Thread(out,prefix + ""String_Node_Str"").start();
  new Thread(in,prefix + ""String_Node_Str"").start();
  new Thread(listenerManager,prefix + ""String_Node_Str"").start();
  clusterClientProxy=new ClusterClientProxy(this);
  partitionClientProxy=new PartitionClientProxy(this);
  if (config.isUpdateAutomatic()) {
    this.getCluster().addMembershipListener(connectionManager);
    connectionManager.updateMembers();
  }
  lifecycleService.fireLifecycleEvent(STARTED);
  connectionManager.scheduleHeartbeatTimerTask();
  lsClients.add(HazelcastClient.this);
}",0.9729086037511164
49696,"/** 
 * @param config
 * @return
 */
public static HazelcastClient newHazelcastClient(ClientConfig config){
  return new HazelcastClient(config);
}","/** 
 * @param config
 * @return
 */
public static HazelcastClient newHazelcastClient(ClientConfig config){
  if (config == null)   config=new ClientConfig();
  return new HazelcastClient(config);
}",0.8521739130434782
49697,"public void connectionRemoved(Connection connection){
  LifecycleServiceImpl lifecycleService=(LifecycleServiceImpl)node.factory.getLifecycleService();
  if (connection.equals(this.conn) && !lifecycleService.paused.get()) {
    destroyEndpointThreads();
    rollbackTransactions();
    removeEntryListeners();
    removeEntryListenersWithKey();
    removeMessageListeners();
    cancelRunningOperations();
    releaseAttachedSemaphorePermits();
    node.clusterManager.sendProcessableToAll(new ClientService.CountDownLatchLeave(conn.getEndPoint()),true);
  }
}","public void connectionRemoved(Connection connection){
  LifecycleServiceImpl lifecycleService=(LifecycleServiceImpl)node.factory.getLifecycleService();
  if (connection.equals(this.conn) && !lifecycleService.paused.get()) {
    destroyEndpointThreads();
    rollbackTransactions();
    removeEntryListeners();
    removeEntryListenersWithKey();
    removeMessageListeners();
    cancelRunningOperations();
    releaseAttachedSemaphorePermits();
    node.clusterManager.sendProcessableToAll(new ClientHandlerService.CountDownLatchLeave(conn.getEndPoint()),true);
    node.clientService.remove(this);
  }
}",0.9621993127147768
49698,"public void authenticated(){
  this.authenticated=true;
}","public void authenticated(){
  this.authenticated=true;
  node.clientService.add(this);
}",0.7808219178082192
49699,"public boolean pause(){
  Callable<Boolean> callable=new Callable<Boolean>(){
    public Boolean call(){
synchronized (lifecycleLock) {
        if (paused.get()) {
          fireLifecycleEvent(PAUSING);
        }
 else {
          return false;
        }
        paused.set(false);
        fireLifecycleEvent(PAUSED);
        return true;
      }
    }
  }
;
  return hazelcastClient.callAsyncAndWait(callable);
}","public boolean pause(){
  Callable<Boolean> callable=new Callable<Boolean>(){
    public Boolean call(){
synchronized (lifecycleLock) {
        if (!paused.get()) {
          fireLifecycleEvent(PAUSING);
        }
 else {
          return false;
        }
        paused.set(true);
        fireLifecycleEvent(PAUSED);
        return true;
      }
    }
  }
;
  return hazelcastClient.callAsyncAndWait(callable);
}",0.9903147699757868
49700,"Record getOwnedRecord(Data key){
  PartitionServiceImpl partitionService=concurrentMapManager.partitionServiceImpl;
  PartitionServiceImpl.PartitionProxy partition=partitionService.getPartition(concurrentMapManager.getPartitionId(key));
  Member ownerNow=partition.getOwner();
  if (ownerNow != null && !concurrentMapManager.isMigrating(partition.getPartitionId()) && ownerNow.localMember()) {
    return getRecord(key);
  }
  return null;
}","Record getOwnedRecord(Data key){
  PartitionServiceImpl partitionService=concurrentMapManager.partitionServiceImpl;
  PartitionServiceImpl.PartitionProxy partition=partitionService.getPartition(concurrentMapManager.getPartitionId(key));
  Member ownerNow=partition.getOwner();
  if (ownerNow != null && !concurrentMapManager.partitionManager.isOwnedPartitionMigrating(partition.getPartitionId()) && ownerNow.localMember()) {
    return getRecord(key);
  }
  return null;
}",0.9660460021905805
49701,"boolean startCleanup(boolean forced){
  if (cleanupActive.compareAndSet(false,true)) {
    try {
      final long now=System.currentTimeMillis();
      if (nearCache != null) {
        nearCache.evict(now,false);
      }
      final Set<Record> recordsDirty=new HashSet<Record>();
      final Set<Record> recordsUnknown=new HashSet<Record>();
      final Set<Record> recordsToPurge=new HashSet<Record>();
      final Set<Record> recordsToEvict=new HashSet<Record>();
      final Set<Record> sortedRecords=new TreeSet<Record>(new ComparatorWrapper(evictionComparator));
      final Collection<Record> records=mapRecords.values();
      final boolean overCapacity=maxSizePolicy.overCapacity();
      final boolean evictionAware=evictionComparator != null && overCapacity;
      int recordsStillOwned=0;
      int backupPurgeCount=0;
      PartitionManager partitionManager=concurrentMapManager.partitionManager;
      for (      Record record : records) {
        PartitionInfo partition=partitionManager.getPartition(record.getBlockId());
        Address owner=partition.getOwner();
        boolean owned=(owner != null && thisAddress.equals(owner));
        boolean ownedOrBackup=partition.isOwnerOrBackup(thisAddress,backupCount);
        if (owner != null && !partitionManager.isMigrating(partition.getPartitionId())) {
          if (owned) {
            if (store != null && writeDelayMillis > 0 && record.isDirty()) {
              if (now > record.getWriteTime()) {
                recordsDirty.add(record);
                record.setDirty(false);
              }
            }
 else             if (shouldPurgeRecord(record,now)) {
              recordsToPurge.add(record);
            }
 else             if (record.isActive() && !record.isValid(now)) {
              recordsToEvict.add(record);
            }
 else             if (evictionAware && record.isActive() && record.isEvictable()) {
              sortedRecords.add(record);
              recordsStillOwned++;
            }
          }
 else           if (ownedOrBackup) {
            if (shouldPurgeRecord(record,now)) {
              recordsToPurge.add(record);
              backupPurgeCount++;
            }
          }
 else {
            recordsUnknown.add(record);
          }
        }
      }
      if (evictionAware && (forced || overCapacity)) {
        int numberOfRecordsToEvict=(int)(recordsStillOwned * evictionRate);
        int evictedCount=0;
        for (        Record record : sortedRecords) {
          if (record.isActive() && record.isEvictable()) {
            recordsToEvict.add(record);
            if (++evictedCount >= numberOfRecordsToEvict) {
              break;
            }
          }
        }
      }
      Level levelLog=(concurrentMapManager.LOG_STATE) ? Level.INFO : Level.FINEST;
      logger.log(levelLog,name + ""String_Node_Str"" + ""String_Node_Str""+ recordsDirty.size()+ ""String_Node_Str""+ recordsToPurge.size()+ ""String_Node_Str""+ recordsToEvict.size()+ ""String_Node_Str""+ recordsUnknown.size()+ ""String_Node_Str""+ recordsStillOwned+ ""String_Node_Str""+ backupPurgeCount);
      executeStoreUpdate(recordsDirty);
      executeEviction(recordsToEvict);
      executePurge(recordsToPurge);
      executePurgeUnknowns(recordsUnknown);
    }
  finally {
      cleanupActive.set(false);
      return true;
    }
  }
 else {
    return false;
  }
}","boolean startCleanup(boolean forced){
  if (cleanupActive.compareAndSet(false,true)) {
    try {
      final long now=System.currentTimeMillis();
      if (nearCache != null) {
        nearCache.evict(now,false);
      }
      final Set<Record> recordsDirty=new HashSet<Record>();
      final Set<Record> recordsUnknown=new HashSet<Record>();
      final Set<Record> recordsToPurge=new HashSet<Record>();
      final Set<Record> recordsToEvict=new HashSet<Record>();
      final Set<Record> sortedRecords=new TreeSet<Record>(new ComparatorWrapper(evictionComparator));
      final Collection<Record> records=mapRecords.values();
      final boolean overCapacity=maxSizePolicy.overCapacity();
      final boolean evictionAware=evictionComparator != null && overCapacity;
      int recordsStillOwned=0;
      int backupPurgeCount=0;
      PartitionManager partitionManager=concurrentMapManager.partitionManager;
      for (      Record record : records) {
        PartitionInfo partition=partitionManager.getPartition(record.getBlockId());
        Address owner=partition.getOwner();
        boolean owned=(owner != null && thisAddress.equals(owner));
        boolean ownedOrBackup=partition.isOwnerOrBackup(thisAddress,backupCount);
        if (owner != null && !partitionManager.isPartitionMigrating(partition.getPartitionId())) {
          if (owned) {
            if (store != null && writeDelayMillis > 0 && record.isDirty()) {
              if (now > record.getWriteTime()) {
                recordsDirty.add(record);
                record.setDirty(false);
              }
            }
 else             if (shouldPurgeRecord(record,now)) {
              recordsToPurge.add(record);
            }
 else             if (record.isActive() && !record.isValid(now)) {
              recordsToEvict.add(record);
            }
 else             if (evictionAware && record.isActive() && record.isEvictable()) {
              sortedRecords.add(record);
              recordsStillOwned++;
            }
          }
 else           if (ownedOrBackup) {
            if (shouldPurgeRecord(record,now)) {
              recordsToPurge.add(record);
              backupPurgeCount++;
            }
          }
 else {
            recordsUnknown.add(record);
          }
        }
      }
      if (evictionAware && (forced || overCapacity)) {
        int numberOfRecordsToEvict=(int)(recordsStillOwned * evictionRate);
        int evictedCount=0;
        for (        Record record : sortedRecords) {
          if (record.isActive() && record.isEvictable()) {
            recordsToEvict.add(record);
            if (++evictedCount >= numberOfRecordsToEvict) {
              break;
            }
          }
        }
      }
      Level levelLog=(concurrentMapManager.LOG_STATE) ? Level.INFO : Level.FINEST;
      logger.log(levelLog,name + ""String_Node_Str"" + ""String_Node_Str""+ recordsDirty.size()+ ""String_Node_Str""+ recordsToPurge.size()+ ""String_Node_Str""+ recordsToEvict.size()+ ""String_Node_Str""+ recordsUnknown.size()+ ""String_Node_Str""+ recordsStillOwned+ ""String_Node_Str""+ backupPurgeCount);
      executeStoreUpdate(recordsDirty);
      executeEviction(recordsToEvict);
      executePurge(recordsToPurge);
      executePurgeUnknowns(recordsUnknown);
    }
  finally {
      cleanupActive.set(false);
      return true;
    }
  }
 else {
    return false;
  }
}",0.9986597170513776
49702,"public boolean containsKey(String name,Object key){
  this.keyObject=key;
  this.nearCache=mapCaches.get(name);
  Data dataKey=toData(key);
  if (nearCache != null) {
    if (nearCache.containsKey(key)) {
      return true;
    }
 else     if (nearCache.getMaxSize() == Integer.MAX_VALUE) {
      return false;
    }
  }
  final CMap cMap=maps.get(name);
  if (cMap != null) {
    Record record=cMap.getOwnedRecord(dataKey);
    if (record != null && record.isActive() && record.isValid() && record.hasValueData()) {
      if (cMap.readBackupData) {
        return true;
      }
 else {
        PartitionServiceImpl.PartitionProxy partition=partitionServiceImpl.getPartition(record.getBlockId());
        if (partition != null && !isMigrating(partition.getPartitionId()) && partition.getOwner() != null && partition.getOwner().localMember()) {
          return true;
        }
      }
    }
  }
  return booleanCall(CONCURRENT_MAP_CONTAINS_KEY,name,dataKey,null,0,-1);
}","public boolean containsKey(String name,Object key){
  this.keyObject=key;
  this.nearCache=mapCaches.get(name);
  Data dataKey=toData(key);
  if (nearCache != null) {
    if (nearCache.containsKey(key)) {
      return true;
    }
 else     if (nearCache.getMaxSize() == Integer.MAX_VALUE) {
      return false;
    }
  }
  final CMap cMap=maps.get(name);
  if (cMap != null) {
    Record record=cMap.getOwnedRecord(dataKey);
    if (record != null && record.isActive() && record.isValid() && record.hasValueData()) {
      if (cMap.readBackupData) {
        return true;
      }
 else {
        PartitionServiceImpl.PartitionProxy partition=partitionServiceImpl.getPartition(record.getBlockId());
        if (partition != null && !partitionManager.isOwnedPartitionMigrating(partition.getPartitionId()) && partition.getOwner() != null && partition.getOwner().localMember()) {
          return true;
        }
      }
    }
  }
  return booleanCall(CONCURRENT_MAP_CONTAINS_KEY,name,dataKey,null,0,-1);
}",0.9822425164890918
49703,"public boolean isMigrating(int partitionId){
  return partitionManager.isMigrating(partitionId);
}","@Override public boolean isMigrating(Request req){
  final Data key=req.key;
  if (key == null)   return false;
  return partitionManager.isOwnedPartitionMigrating(getPartitionId(key));
}",0.5964912280701754
49704,"ExecutorManager(final Node node){
  super(node);
  logger.log(Level.FINEST,""String_Node_Str"");
  GroupProperties gp=node.groupProperties;
  ClassLoader classLoader=node.getConfig().getClassLoader();
  threadPoolExecutor=new ThreadPoolExecutor(0,Integer.MAX_VALUE,60L,TimeUnit.SECONDS,new SynchronousQueue(),new ExecutorThreadFactory(node.threadGroup,node.getThreadPoolNamePrefix(""String_Node_Str""),classLoader),new RejectionHandler()){
    protected void beforeExecute(    Thread t,    Runnable r){
      ThreadContext threadContext=ThreadContext.get();
      threadContext.setCurrentFactory(node.factory);
      CallContext callContext=mapThreadCallContexts.get(t);
      if (callContext == null) {
        callContext=new CallContext(threadContext.createNewThreadId(),false);
        mapThreadCallContexts.put(t,callContext);
      }
      threadContext.setCallContext(callContext);
    }
  }
;
  esScheduled=new ScheduledThreadPoolExecutor(10,new ExecutorThreadFactory(node.threadGroup,node.getThreadPoolNamePrefix(""String_Node_Str""),classLoader),new RejectionHandler());
  parallelExecutorService=new ParallelExecutorService(node.getLogger(ParallelExecutorService.class.getName()),threadPoolExecutor);
  defaultExecutorService=getOrCreateNamedExecutorService(DEFAULT_EXECUTOR_SERVICE);
  queryExecutorService=getOrCreateNamedExecutorService(QUERY_EXECUTOR_SERVICE,gp.EXECUTOR_QUERY_THREAD_COUNT);
  eventExecutorService=getOrCreateNamedExecutorService(EVENT_EXECUTOR_SERVICE,gp.EXECUTOR_EVENT_THREAD_COUNT);
  mapLoaderExecutorService=parallelExecutorService.newParallelExecutor(gp.MAP_LOAD_THREAD_COUNT.getInteger());
  asyncExecutorService=parallelExecutorService.newBlockingParallelExecutor(24,1000);
  registerPacketProcessor(EXECUTE,new ExecutionOperationHandler());
  registerPacketProcessor(CANCEL_EXECUTION,new ExecutionCancelOperationHandler());
  started=true;
}","ExecutorManager(final Node node){
  super(node);
  logger.log(Level.FINEST,""String_Node_Str"");
  GroupProperties gp=node.groupProperties;
  ClassLoader classLoader=node.getConfig().getClassLoader();
  threadPoolExecutor=new ThreadPoolExecutor(0,Integer.MAX_VALUE,60L,TimeUnit.SECONDS,new SynchronousQueue(),new ExecutorThreadFactory(node.threadGroup,node.getThreadPoolNamePrefix(""String_Node_Str""),classLoader),new RejectionHandler()){
    protected void beforeExecute(    Thread t,    Runnable r){
      threadPoolBeforeExecute(t,r);
    }
  }
;
  esScheduled=new ScheduledThreadPoolExecutor(5,new ExecutorThreadFactory(node.threadGroup,node.getThreadPoolNamePrefix(""String_Node_Str""),classLoader),new RejectionHandler()){
    protected void beforeExecute(    Thread t,    Runnable r){
      threadPoolBeforeExecute(t,r);
    }
  }
;
  parallelExecutorService=new ParallelExecutorService(node.getLogger(ParallelExecutorService.class.getName()),threadPoolExecutor);
  defaultExecutorService=getOrCreateNamedExecutorService(DEFAULT_EXECUTOR_SERVICE);
  queryExecutorService=getOrCreateNamedExecutorService(QUERY_EXECUTOR_SERVICE,gp.EXECUTOR_QUERY_THREAD_COUNT);
  eventExecutorService=getOrCreateNamedExecutorService(EVENT_EXECUTOR_SERVICE,gp.EXECUTOR_EVENT_THREAD_COUNT);
  mapLoaderExecutorService=parallelExecutorService.newParallelExecutor(gp.MAP_LOAD_THREAD_COUNT.getInteger());
  asyncExecutorService=parallelExecutorService.newBlockingParallelExecutor(24,1000);
  registerPacketProcessor(EXECUTE,new ExecutionOperationHandler());
  registerPacketProcessor(CANCEL_EXECUTION,new ExecutionCancelOperationHandler());
  started=true;
}",0.7568337129840547
49705,"protected void beforeExecute(Thread t,Runnable r){
  ThreadContext threadContext=ThreadContext.get();
  threadContext.setCurrentFactory(node.factory);
  CallContext callContext=mapThreadCallContexts.get(t);
  if (callContext == null) {
    callContext=new CallContext(threadContext.createNewThreadId(),false);
    mapThreadCallContexts.put(t,callContext);
  }
  threadContext.setCallContext(callContext);
}","protected void beforeExecute(Thread t,Runnable r){
  threadPoolBeforeExecute(t,r);
}",0.2857142857142857
49706,"private boolean connectAndSendJoinRequest(Address masterAddress){
  if (masterAddress == null || masterAddress.equals(node.address)) {
    throw new IllegalArgumentException();
  }
  Connection conn=node.connectionManager.getOrConnect(masterAddress);
  logger.log(Level.FINEST,""String_Node_Str"" + conn);
  if (conn != null) {
    return node.clusterManager.sendJoinRequest(masterAddress);
  }
  return false;
}","private boolean connectAndSendJoinRequest(Address masterAddress){
  if (masterAddress == null || masterAddress.equals(node.address)) {
    throw new IllegalArgumentException();
  }
  Connection conn=node.connectionManager.getOrConnect(masterAddress);
  logger.log(Level.FINEST,""String_Node_Str"" + conn);
  if (conn != null) {
    return node.clusterManager.sendJoinRequest(masterAddress,true);
  }
  return false;
}",0.993939393939394
49707,"private void doShutdown(boolean force){
  long start=System.currentTimeMillis();
  logger.log(Level.FINE,""String_Node_Str"" + String.valueOf(active));
  if (!force && isActive()) {
    final int maxWaitSeconds=groupProperties.GRACEFUL_SHUTDOWN_MAX_WAIT.getInteger();
    int waitSeconds=0;
    do {
      try {
        Thread.sleep(500);
      }
 catch (      InterruptedException e) {
      }
    }
 while (concurrentMapManager.partitionManager.hasActiveBackupTask() && ++waitSeconds < maxWaitSeconds);
    if (waitSeconds >= maxWaitSeconds) {
      logger.log(Level.WARNING,""String_Node_Str"" + maxWaitSeconds + ""String_Node_Str"");
    }
  }
  if (isActive()) {
    joined.set(false);
    setActive(false);
    wanReplicationService.shutdown();
    try {
      Runtime.getRuntime().removeShutdownHook(shutdownHookThread);
    }
 catch (    Throwable ignored) {
    }
    if (managementCenterService != null) {
      managementCenterService.shutdown();
    }
    logger.log(Level.FINEST,""String_Node_Str"");
    clientService.shutdown();
    logger.log(Level.FINEST,""String_Node_Str"");
    concurrentMapManager.shutdown();
    logger.log(Level.FINEST,""String_Node_Str"");
    clusterService.stop();
    if (multicastService != null) {
      logger.log(Level.FINEST,""String_Node_Str"");
      multicastService.stop();
    }
    logger.log(Level.FINEST,""String_Node_Str"");
    connectionManager.shutdown();
    logger.log(Level.FINEST,""String_Node_Str"");
    executorManager.stop();
    textCommandService.stop();
    masterAddress=null;
    if (securityContext != null) {
      securityContext.destroy();
    }
    initializer.destroy();
    int numThreads=threadGroup.activeCount();
    Thread[] threads=new Thread[numThreads * 2];
    numThreads=threadGroup.enumerate(threads,false);
    for (int i=0; i < numThreads; i++) {
      Thread thread=threads[i];
      logger.log(Level.FINEST,""String_Node_Str"" + thread.getName());
      thread.interrupt();
    }
    failedConnections.clear();
    serviceThreadPacketQueue.clear();
    ThreadContext.get().shutdown(this.factory);
    logger.log(Level.INFO,""String_Node_Str"" + (System.currentTimeMillis() - start) + ""String_Node_Str"");
  }
}","private void doShutdown(boolean force){
  long start=System.currentTimeMillis();
  logger.log(Level.FINE,""String_Node_Str"" + String.valueOf(active));
  if (!force && isActive()) {
    final int maxWaitSeconds=groupProperties.GRACEFUL_SHUTDOWN_MAX_WAIT.getInteger();
    int waitSeconds=0;
    do {
      try {
        Thread.sleep(500);
      }
 catch (      InterruptedException e) {
      }
    }
 while (concurrentMapManager.partitionManager.hasActiveBackupTask() && ++waitSeconds < maxWaitSeconds);
    if (waitSeconds >= maxWaitSeconds) {
      logger.log(Level.WARNING,""String_Node_Str"" + maxWaitSeconds + ""String_Node_Str"");
    }
  }
  if (isActive()) {
    joined.set(false);
    setActive(false);
    wanReplicationService.shutdown();
    try {
      Runtime.getRuntime().removeShutdownHook(shutdownHookThread);
    }
 catch (    Throwable ignored) {
    }
    if (managementCenterService != null) {
      managementCenterService.shutdown();
    }
    logger.log(Level.FINEST,""String_Node_Str"");
    clientService.shutdown();
    logger.log(Level.FINEST,""String_Node_Str"");
    concurrentMapManager.shutdown();
    logger.log(Level.FINEST,""String_Node_Str"");
    clusterService.stop();
    if (multicastService != null) {
      logger.log(Level.FINEST,""String_Node_Str"");
      multicastService.stop();
    }
    logger.log(Level.FINEST,""String_Node_Str"");
    connectionManager.shutdown();
    logger.log(Level.FINEST,""String_Node_Str"");
    executorManager.stop();
    textCommandService.stop();
    masterAddress=null;
    if (securityContext != null) {
      securityContext.destroy();
    }
    initializer.destroy();
    int numThreads=threadGroup.activeCount();
    Thread[] threads=new Thread[numThreads * 2];
    numThreads=threadGroup.enumerate(threads,false);
    for (int i=0; i < numThreads; i++) {
      Thread thread=threads[i];
      logger.log(Level.FINEST,""String_Node_Str"" + thread.getName());
      thread.interrupt();
    }
    failedConnections.clear();
    serviceThreadPacketQueue.clear();
    mapCallStates.clear();
    ThreadContext.get().shutdown(this.factory);
    logger.log(Level.INFO,""String_Node_Str"" + (System.currentTimeMillis() - start) + ""String_Node_Str"");
  }
}",0.993851058984286
49708,"public ClientSerializer(){
  super(new DataSerializer(){
    @Override protected Class loadClass(    final String className) throws ClassNotFoundException {
      String name=className;
      if (className.equals(""String_Node_Str"")) {
        name=""String_Node_Str"";
      }
      return super.loadClass(name);
    }
    protected String toClassName(    final Class clazz) throws ClassNotFoundException {
      final String className=super.toClassName(clazz);
      if (!className.startsWith(""String_Node_Str"")) {
        return className;
      }
      return ""String_Node_Str"" + className.substring(""String_Node_Str"".length());
    }
  }
,new DefaultSerializer());
}","public ClientSerializer(){
  super(new DataSerializer(){
    @Override protected Class loadClass(    final String className) throws ClassNotFoundException {
      String name=className;
      if (className.equals(""String_Node_Str"")) {
        name=""String_Node_Str"";
      }
 else       if (className.equals(""String_Node_Str"")) {
        name=""String_Node_Str"";
      }
      return super.loadClass(name);
    }
    protected String toClassName(    final Class clazz) throws ClassNotFoundException {
      final String className=super.toClassName(clazz);
      if (!className.startsWith(""String_Node_Str"")) {
        return className;
      }
      return ""String_Node_Str"" + className.substring(""String_Node_Str"".length());
    }
  }
,new DefaultSerializer());
}",0.93361285814116
49709,"@Override protected Class loadClass(final String className) throws ClassNotFoundException {
  String name=className;
  if (className.equals(""String_Node_Str"")) {
    name=""String_Node_Str"";
  }
  return super.loadClass(name);
}","@Override protected Class loadClass(final String className) throws ClassNotFoundException {
  String name=className;
  if (className.equals(""String_Node_Str"")) {
    name=""String_Node_Str"";
  }
 else   if (className.equals(""String_Node_Str"")) {
    name=""String_Node_Str"";
  }
  return super.loadClass(name);
}",0.845437616387337
49710,"public void run(){
  try {
    while (running) {
      Runnable r=null;
      while (migrationActive.get() && (r=immediateTasksQueue.poll()) != null) {
        safeRunImmediate(r);
      }
      if (!running) {
        break;
      }
      if (!migrationActive.get() || scheduledTasksQueue.isEmpty()) {
        Thread.sleep(250);
        continue;
      }
      long totalWait=0L;
      while (migrationActive.get() && running && r == null && totalWait < partitionMigrationInterval) {
        long start=System.currentTimeMillis();
        r=immediateTasksQueue.poll(1,TimeUnit.SECONDS);
        safeRunImmediate(r);
        totalWait+=(System.currentTimeMillis() - start);
      }
      if (migrationActive.get() && running) {
        r=scheduledTasksQueue.poll();
        safeRun(r);
      }
    }
  }
 catch (  InterruptedException e) {
    logger.log(Level.FINEST,""String_Node_Str"" + e.getMessage(),e);
    running=false;
  }
 finally {
    clearTaskQueues();
  }
}","public void run(){
  ThreadContext.get().setCurrentFactory(concurrentMapManager.node.factory);
  try {
    while (running) {
      Runnable r=null;
      while (migrationActive.get() && (r=immediateTasksQueue.poll()) != null) {
        safeRunImmediate(r);
      }
      if (!running) {
        break;
      }
      if (!migrationActive.get() || scheduledTasksQueue.isEmpty()) {
        Thread.sleep(250);
        continue;
      }
      long totalWait=0L;
      while (migrationActive.get() && running && r == null && totalWait < partitionMigrationInterval) {
        long start=System.currentTimeMillis();
        r=immediateTasksQueue.poll(1,TimeUnit.SECONDS);
        safeRunImmediate(r);
        totalWait+=(System.currentTimeMillis() - start);
      }
      if (migrationActive.get() && running) {
        r=scheduledTasksQueue.poll();
        safeRun(r);
      }
    }
  }
 catch (  InterruptedException e) {
    logger.log(Level.FINEST,""String_Node_Str"" + e.getMessage(),e);
    running=false;
  }
 finally {
    clearTaskQueues();
  }
}",0.9622641509433962
49711,"void prepareMigrationTasks(){
  PartitionStateGenerator psg=getPartitionStateGenerator();
  psg.reArrange(partitions,members,PARTITION_COUNT,scheduledQ,immediateQ);
}","void prepareMigrationTasks(){
  PartitionStateGenerator psg=getPartitionStateGenerator();
  psg.reArrange(partitions,members,PARTITION_COUNT,lostQ,immediateQ,scheduledQ);
}",0.9349112426035504
49712,"void fillMigrationQueues(){
  clearTaskQueues();
  for (  MigrationRequestTask migrationRequestTask : immediateQ) {
    immediateTasksQueue.offer(new Migrator(migrationRequestTask));
  }
  immediateQ.clear();
  for (  MigrationRequestTask migrationRequestTask : scheduledQ) {
    scheduledTasksQueue.offer(new Migrator(migrationRequestTask));
  }
  scheduledQ.clear();
}","void fillMigrationQueues(){
  clearTaskQueues();
  if (!lostQ.isEmpty()) {
    concurrentMapManager.enqueueAndReturn(new LostPartitionsAssignmentProcess(lostQ));
    logger.log(Level.INFO,""String_Node_Str"" + lostQ.size() + ""String_Node_Str"");
  }
  for (  MigrationRequestTask migrationRequestTask : immediateQ) {
    immediateTasksQueue.offer(new Migrator(migrationRequestTask));
  }
  immediateQ.clear();
  for (  MigrationRequestTask migrationRequestTask : scheduledQ) {
    scheduledTasksQueue.offer(new Migrator(migrationRequestTask));
  }
  scheduledQ.clear();
}",0.7889125799573561
49713,"PartitionInfo[] reArrange(final PartitionInfo[] currentState,final Collection<MemberImpl> members,final int partitionCount,final List<MigrationRequestTask> scheduledTasksList,final List<MigrationRequestTask> immediateTasksList);","PartitionInfo[] reArrange(final PartitionInfo[] currentState,final Collection<MemberImpl> members,final int partitionCount,final List<MigrationRequestTask> lostPartitionTasksList,final List<MigrationRequestTask> immediateTasksList,final List<MigrationRequestTask> scheduledTasksList);",0.6875
49714,"private void finalizeArrangement(PartitionInfo[] currentState,PartitionInfo[] newState,int replicaCount,List<MigrationRequestTask> scheduledTasksList,List<MigrationRequestTask> immediateTasksList){
  final int partitionCount=currentState.length;
  final List<MigrationRequestTask> partitionMigrationTasks=new LinkedList<MigrationRequestTask>();
  for (int partitionId=0; partitionId < partitionCount; partitionId++) {
    PartitionInfo currentPartition=currentState[partitionId];
    PartitionInfo newPartition=newState[partitionId];
    boolean lost=false;
    for (int replicaIndex=0; replicaIndex < PartitionInfo.MAX_REPLICA_COUNT; replicaIndex++) {
      Address currentOwner=currentPartition.getReplicaAddress(replicaIndex);
      Address newOwner=newPartition.getReplicaAddress(replicaIndex);
      MigrationRequestTask migrationRequestTask=null;
      if (currentOwner != null && newOwner != null && !currentOwner.equals(newOwner)) {
        migrationRequestTask=new MigrationRequestTask(partitionId,currentOwner,newOwner,replicaIndex,true);
      }
 else       if (currentOwner == null && newOwner != null) {
        if ((currentOwner=currentPartition.getOwner()) == null) {
          lost=true;
        }
        boolean selfCopy=false;
        ListIterator<MigrationRequestTask> iter=partitionMigrationTasks.listIterator(partitionMigrationTasks.size());
        while (iter.hasPrevious()) {
          MigrationRequestTask task=iter.previous();
          if (newOwner.equals(task.getFromAddress())) {
            selfCopy=true;
            task.setSelfCopyReplicaIndex(replicaIndex);
            break;
          }
        }
        if (!selfCopy) {
          migrationRequestTask=new MigrationRequestTask(partitionId,currentOwner,newOwner,replicaIndex,false);
        }
      }
 else       if (currentOwner != null && newOwner == null) {
        logger.log(Level.WARNING,""String_Node_Str"" + ""String_Node_Str"" + partitionId + ""String_Node_Str""+ replicaIndex+ ""String_Node_Str""+ currentOwner);
        immediateTasksList.add(new MigrationRequestTask(partitionId,currentOwner,null,replicaIndex,false));
      }
      if (migrationRequestTask != null) {
        partitionMigrationTasks.add(migrationRequestTask);
        boolean immediate=false;
        if (replicaIndex == 0 && currentPartition.getOwner() != null && currentPartition.getOwner().equals(newPartition.getReplicaAddress(1))) {
          immediate=true;
        }
 else         if (replicaIndex == 1 && currentPartition.getReplicaAddress(1) == null) {
          immediate=true;
        }
        if (immediate) {
          immediateTasksList.add(migrationRequestTask);
        }
 else {
          scheduledTasksList.add(migrationRequestTask);
        }
      }
    }
    partitionMigrationTasks.clear();
    if (lost) {
      logger.log(Level.FINEST,""String_Node_Str"" + currentPartition + ""String_Node_Str"");
    }
  }
  arrangeScheduledTasks(scheduledTasksList);
}","private void finalizeArrangement(PartitionInfo[] currentState,PartitionInfo[] newState,List<MigrationRequestTask> lostPartitionTasksList,List<MigrationRequestTask> immediateTasksList,List<MigrationRequestTask> scheduledTasksList){
  final int partitionCount=currentState.length;
  final List<MigrationRequestTask> partitionMigrationTasks=new LinkedList<MigrationRequestTask>();
  for (int partitionId=0; partitionId < partitionCount; partitionId++) {
    PartitionInfo currentPartition=currentState[partitionId];
    PartitionInfo newPartition=newState[partitionId];
    boolean lost=false;
    for (int replicaIndex=0; replicaIndex < PartitionInfo.MAX_REPLICA_COUNT; replicaIndex++) {
      Address currentOwner=currentPartition.getReplicaAddress(replicaIndex);
      Address newOwner=newPartition.getReplicaAddress(replicaIndex);
      MigrationRequestTask migrationRequestTask=null;
      if (currentOwner != null && newOwner != null && !currentOwner.equals(newOwner)) {
        migrationRequestTask=new MigrationRequestTask(partitionId,currentOwner,newOwner,replicaIndex,true);
      }
 else       if (currentOwner == null && newOwner != null) {
        currentOwner=currentPartition.getOwner();
        boolean selfCopy=false;
        ListIterator<MigrationRequestTask> iter=partitionMigrationTasks.listIterator(partitionMigrationTasks.size());
        while (iter.hasPrevious()) {
          MigrationRequestTask task=iter.previous();
          if (newOwner.equals(task.getFromAddress())) {
            selfCopy=true;
            task.setSelfCopyReplicaIndex(replicaIndex);
            break;
          }
        }
        if (!selfCopy) {
          migrationRequestTask=new MigrationRequestTask(partitionId,currentOwner,newOwner,replicaIndex,false);
        }
      }
 else       if (currentOwner != null && newOwner == null) {
        logger.log(Level.WARNING,""String_Node_Str"" + ""String_Node_Str"" + partitionId + ""String_Node_Str""+ replicaIndex+ ""String_Node_Str""+ currentOwner);
        immediateTasksList.add(new MigrationRequestTask(partitionId,currentOwner,null,replicaIndex,false));
      }
      if (migrationRequestTask != null) {
        partitionMigrationTasks.add(migrationRequestTask);
        if (replicaIndex == 0 && currentOwner == null) {
          lostPartitionTasksList.add(migrationRequestTask);
        }
 else         if (replicaIndex == 0 && currentOwner != null && currentOwner.equals(newPartition.getReplicaAddress(1))) {
          immediateTasksList.add(migrationRequestTask);
        }
 else         if (replicaIndex == 1 && currentPartition.getReplicaAddress(1) == null) {
          immediateTasksList.add(migrationRequestTask);
        }
 else {
          scheduledTasksList.add(migrationRequestTask);
        }
      }
    }
    partitionMigrationTasks.clear();
  }
  arrangeScheduledTasks(scheduledTasksList);
}",0.7914216534071256
49715,"public PartitionInfo[] reArrange(PartitionInfo[] currentState,Collection<MemberImpl> members,int partitionCount,List<MigrationRequestTask> scheduledTasksList,List<MigrationRequestTask> immediateTasksList){
  final LinkedList<NodeGroup> groups=createNodeGroups(memberGroupFactory.createMemberGroups(members));
  if (groups.size() == 0)   return currentState;
  PartitionInfo[] newState=arrange(groups,partitionCount,new CopyStateInitializer(currentState));
  finalizeArrangement(currentState,newState,Math.min(groups.size(),PartitionInfo.MAX_REPLICA_COUNT),scheduledTasksList,immediateTasksList);
  return newState;
}","public PartitionInfo[] reArrange(PartitionInfo[] currentState,Collection<MemberImpl> members,int partitionCount,List<MigrationRequestTask> lostPartitionTasksList,List<MigrationRequestTask> immediateTasksList,List<MigrationRequestTask> scheduledTasksList){
  final LinkedList<NodeGroup> groups=createNodeGroups(memberGroupFactory.createMemberGroups(members));
  if (groups.size() == 0)   return currentState;
  PartitionInfo[] newState=arrange(groups,partitionCount,new CopyStateInitializer(currentState));
  finalizeArrangement(currentState,newState,lostPartitionTasksList,immediateTasksList,scheduledTasksList);
  return newState;
}",0.8390712570056045
49716,"/** 
 * Shuts down all running Hazelcast Instances on this JVM, including the default one if it is running. It doesn't shutdown all members of the cluster but just the ones running on this JVM.
 * @see #newHazelcastInstance(Config)
 */
public static void shutdownAll(){
  com.hazelcast.impl.FactoryImpl.shutdownAll();
  defaultInstance.set(null);
}","/** 
 * Shuts down all running Hazelcast Instances on this JVM, including the default one if it is running. It doesn't shutdown all members of the cluster but just the ones running on this JVM.
 * @see #newHazelcastInstance(Config)
 */
public static void shutdownAll(){
  com.hazelcast.impl.FactoryImpl.shutdownAll();
synchronized (initLock) {
    defaultInstance.set(null);
  }
}",0.956043956043956
49717,"public void processRequest(TextCommand command){
  if (responseThreadRunnable == null) {
    responseThreadRunnable=new ResponseThreadRunnable();
    Thread thread=new Thread(responseThreadRunnable,""String_Node_Str"");
    thread.start();
  }
  parallelExecutor.execute(new CommandExecutor(command));
}","public void processRequest(TextCommand command){
  if (responseThreadRunnable == null) {
synchronized (this) {
      if (responseThreadRunnable == null) {
        responseThreadRunnable=new ResponseThreadRunnable();
        Thread thread=new Thread(responseThreadRunnable,""String_Node_Str"");
        thread.start();
      }
    }
  }
  parallelExecutor.execute(new CommandExecutor(command));
}",0.8674351585014409
49718,"public void sendEvents(int eventType,String name,Data key,Data value,Map<Address,Boolean> mapListeners,Address callerAddress){
  if (mapListeners != null) {
    final Set<Map.Entry<Address,Boolean>> listeners=mapListeners.entrySet();
    for (    final Map.Entry<Address,Boolean> listener : listeners) {
      final Address toAddress=listener.getKey();
      final boolean includeValue=listener.getValue();
      if (toAddress.isThisAddress()) {
        enqueueEvent(eventType,name,key,(includeValue) ? value : null,callerAddress,true);
      }
 else {
        final Packet packet=obtainPacket();
        packet.set(name,ClusterOperation.EVENT,key,(includeValue) ? value : null);
        packet.lockAddress=callerAddress;
        packet.longValue=eventType;
        final boolean sent=send(packet,toAddress);
        if (!sent)         releasePacket(packet);
      }
    }
  }
}","public void sendEvents(int eventType,String name,Data key,Data value,Map<Address,Boolean> mapListeners,Address callerAddress){
  if (mapListeners != null) {
    final Set<Map.Entry<Address,Boolean>> listeners=mapListeners.entrySet();
    for (    final Map.Entry<Address,Boolean> listener : listeners) {
      final Address toAddress=listener.getKey();
      final boolean includeValue=listener.getValue();
      if (toAddress.isThisAddress()) {
        enqueueEvent(eventType,name,key,value,callerAddress,true);
      }
 else {
        final Packet packet=obtainPacket();
        packet.set(name,ClusterOperation.EVENT,key,(includeValue) ? value : null);
        packet.lockAddress=callerAddress;
        packet.longValue=eventType;
        final boolean sent=send(packet,toAddress);
        if (!sent)         releasePacket(packet);
      }
    }
  }
}",0.9861431870669746
49719,"/** 
 * Unregister a cluster instance.
 */
public synchronized void unregister(){
  if (!started) {
    return;
  }
  MBeanServer mbs=mBeanServer();
  Set<ObjectName> entries;
  try {
    entries=mbs.queryNames(ObjectNameSpec.getClusterNameFilter(this.name),null);
    for (    ObjectName name : entries) {
      if (mbs.isRegistered(name)) {
        mbs.unregisterMBean(name);
      }
    }
  }
 catch (  Exception e) {
    logger.log(Level.FINE,""String_Node_Str"",e);
  }
  counter.decrementAndGet();
}","/** 
 * Unregister a cluster instance.
 */
public synchronized void unregister(){
  if (!started) {
    return;
  }
  MBeanServer mbs=mBeanServer();
  Set<ObjectName> entries;
  try {
    entries=mbs.queryNames(ObjectNameSpec.getClusterNameFilter(this.name),null);
    for (    ObjectName name : entries) {
      if (mbs.isRegistered(name)) {
        mbs.unregisterMBean(name);
      }
    }
  }
 catch (  Exception e) {
    logger.log(Level.FINEST,""String_Node_Str"",e);
  }
  counter.decrementAndGet();
}",0.998015873015873
49720,"/** 
 * Stop the management service
 */
public synchronized static void shutdown(){
  if (counter.get() > 0) {
    return;
  }
  MBeanServer mbs=mBeanServer();
  Set<ObjectName> entries;
  try {
    entries=mbs.queryNames(new ObjectName(ObjectNameSpec.NAME_DOMAIN + ""String_Node_Str""),null);
    for (    ObjectName name : entries) {
      if (mbs.isRegistered(name)) {
        mbs.unregisterMBean(name);
      }
    }
  }
 catch (  Exception e) {
    Logger.getLogger(""String_Node_Str"").log(Level.FINE,""String_Node_Str"",e);
  }
  if (statCollectors != null) {
    statCollectors.shutdownNow();
    statCollectors=null;
  }
}","/** 
 * Stop the management service
 */
public synchronized static void shutdown(){
  if (counter.get() > 0) {
    return;
  }
  MBeanServer mbs=mBeanServer();
  Set<ObjectName> entries;
  try {
    entries=mbs.queryNames(new ObjectName(ObjectNameSpec.NAME_DOMAIN + ""String_Node_Str""),null);
    for (    ObjectName name : entries) {
      if (mbs.isRegistered(name)) {
        mbs.unregisterMBean(name);
      }
    }
  }
 catch (  Exception e) {
    Logger.getLogger(""String_Node_Str"").log(Level.FINEST,""String_Node_Str"",e);
  }
  if (statCollectors != null) {
    statCollectors.shutdownNow();
    statCollectors=null;
  }
}",0.9984025559105432
49721,"public void entryAdded(EntryEvent<String,String> event){
  if (local) {
    localCount.incrementAndGet();
  }
 else {
    globalCount.incrementAndGet();
  }
}","public void entryAdded(EntryEvent<String,String> event){
  if (local) {
    localCount.incrementAndGet();
  }
 else {
    globalCount.incrementAndGet();
  }
  if (event.getValue() != null) {
    valueCount.incrementAndGet();
  }
}",0.8092783505154639
49722,"private void createMaps(){
  globalCount.set(0);
  localCount.set(0);
  map1=h1.getMap(n);
  map2=h2.getMap(n);
}","private void createMaps(){
  globalCount.set(0);
  localCount.set(0);
  valueCount.set(0);
  map1=h1.getMap(n);
  map2=h2.getMap(n);
}",0.9149797570850202
49723,"private EntryListener<String,String> createEntryListener(final boolean isLocal){
  return new EntryListener<String,String>(){
    private final boolean local=isLocal;
    public void entryUpdated(    EntryEvent<String,String> event){
    }
    public void entryRemoved(    EntryEvent<String,String> event){
    }
    public void entryEvicted(    EntryEvent<String,String> event){
    }
    public void entryAdded(    EntryEvent<String,String> event){
      if (local) {
        localCount.incrementAndGet();
      }
 else {
        globalCount.incrementAndGet();
      }
    }
  }
;
}","private EntryListener<String,String> createEntryListener(final boolean isLocal){
  return new EntryListener<String,String>(){
    private final boolean local=isLocal;
    public void entryUpdated(    EntryEvent<String,String> event){
    }
    public void entryRemoved(    EntryEvent<String,String> event){
    }
    public void entryEvicted(    EntryEvent<String,String> event){
    }
    public void entryAdded(    EntryEvent<String,String> event){
      if (local) {
        localCount.incrementAndGet();
      }
 else {
        globalCount.incrementAndGet();
      }
      if (event.getValue() != null) {
        valueCount.incrementAndGet();
      }
    }
  }
;
}",0.9217252396166136
49724,"@Test public void globalListenerTest() throws InterruptedException {
  map1.addEntryListener(createEntryListener(false),true);
  map2.addEntryListener(createEntryListener(false),true);
  int k=3;
  putDummyData(k);
  checkCountWithExpected(k * 2,0);
}","@Test public void globalListenerTest() throws InterruptedException {
  map1.addEntryListener(createEntryListener(false),false);
  map1.addEntryListener(createEntryListener(false),true);
  map2.addEntryListener(createEntryListener(false),true);
  int k=3;
  putDummyData(k);
  checkCountWithExpected(k * 3,0,k * 2);
}",0.8783068783068783
49725,"@Test public void globalAndLocalListenerTest2() throws InterruptedException {
  map1.addEntryListener(createEntryListener(false),true);
  map1.addLocalEntryListener(createEntryListener(true));
  map2.addEntryListener(createEntryListener(false),true);
  map2.addLocalEntryListener(createEntryListener(true));
  int k=3;
  putDummyData(k);
  checkCountWithExpected(k * 2,k);
}","@Test public void globalAndLocalListenerTest2() throws InterruptedException {
  map1.addEntryListener(createEntryListener(false),false);
  map1.addLocalEntryListener(createEntryListener(true));
  map2.addEntryListener(createEntryListener(false),true);
  map2.addLocalEntryListener(createEntryListener(true));
  map2.addEntryListener(createEntryListener(false),false);
  int k=3;
  putDummyData(k);
  checkCountWithExpected(k * 3,k,k * 2);
}",0.9066339066339066
49726,"private void checkCountWithExpected(int expectedGlobal,int expectedLocal) throws InterruptedException {
  Thread.sleep(1000 * 3);
  Assert.assertEquals(expectedLocal,localCount.get());
  Assert.assertEquals(expectedGlobal,globalCount.get());
}","private void checkCountWithExpected(int expectedGlobal,int expectedLocal,int expectedValue) throws InterruptedException {
  Thread.sleep(1000 * 3);
  Assert.assertEquals(expectedLocal,localCount.get());
  Assert.assertEquals(expectedGlobal,globalCount.get());
  Assert.assertEquals(expectedValue,valueCount.get());
}",0.8694096601073346
49727,"@Test public void localListenerTest() throws InterruptedException {
  map1.addLocalEntryListener(createEntryListener(true));
  map2.addLocalEntryListener(createEntryListener(true));
  int k=4;
  putDummyData(k);
  checkCountWithExpected(0,k);
}","@Test public void localListenerTest() throws InterruptedException {
  map1.addLocalEntryListener(createEntryListener(true));
  map2.addLocalEntryListener(createEntryListener(true));
  int k=4;
  putDummyData(k);
  checkCountWithExpected(0,k,k);
}",0.9959183673469388
49728,"@Test public void globalAndLocalListenerTest() throws InterruptedException {
  map1.addLocalEntryListener(createEntryListener(true));
  map2.addLocalEntryListener(createEntryListener(true));
  map1.addEntryListener(createEntryListener(false),true);
  map2.addEntryListener(createEntryListener(false),true);
  int k=1;
  putDummyData(k);
  checkCountWithExpected(k * 2,k);
}","@Test public void globalAndLocalListenerTest() throws InterruptedException {
  map1.addLocalEntryListener(createEntryListener(true));
  map2.addLocalEntryListener(createEntryListener(true));
  map1.addEntryListener(createEntryListener(false),false);
  map2.addEntryListener(createEntryListener(false),false);
  map2.addEntryListener(createEntryListener(false),true);
  int k=1;
  putDummyData(k);
  checkCountWithExpected(k * 3,k,k * 2);
}",0.9064039408866996
49729,"public void set(String name,ClusterOperation operation,Object objKey,Object objValue){
  this.threadId=ThreadContext.get().getThreadId();
  this.name=name;
  this.operation=operation;
  if (objKey != null) {
    key=new DataHolder(ThreadContext.get().toData(objKey));
  }
  if (objValue != null) {
    value=new DataHolder(ThreadContext.get().toData(objValue));
  }
}","public void set(String name,ClusterOperation operation,Object objKey,Object objValue){
  this.threadId=ThreadContext.get().getThreadId();
  this.name=name;
  this.operation=operation;
  if (objKey != null) {
    if (objKey instanceof Data) {
      setKey((Data)objKey);
    }
 else {
      key=new DataHolder(ThreadContext.get().toData(objKey));
    }
  }
  if (objValue != null) {
    if (objValue instanceof Data) {
      setValue((Data)objValue);
    }
 else {
      value=new DataHolder(ThreadContext.get().toData(objValue));
    }
  }
}",0.801762114537445
49730,"public void itemRemoved(ItemEvent<String> itemEvent){
  assertEquals(""String_Node_Str"",itemEvent.getItem());
  latch.countDown();
}","public void itemRemoved(ItemEvent item){
}",0.4855491329479768
49731,"public void itemAdded(ItemEvent<String> itemEvent){
  assertEquals(""String_Node_Str"",itemEvent.getItem());
  latch.countDown();
}","public void itemAdded(ItemEvent item){
  latch.countDown();
  System.out.println(item);
}",0.5596330275229358
49732,"public void onMessage(Object message){
}","public void onMessage(Message message){
}",0.8641975308641975
49733,"@Test public void splitBrain() throws Exception {
  boolean multicast=true;
  Config c1=new Config();
  c1.getNetworkConfig().getJoin().getMulticastConfig().setEnabled(multicast);
  c1.getNetworkConfig().getJoin().getTcpIpConfig().setEnabled(!multicast);
  c1.getNetworkConfig().getJoin().getTcpIpConfig().addMember(""String_Node_Str"");
  c1.getNetworkConfig().getInterfaces().clear();
  c1.getNetworkConfig().getInterfaces().addInterface(""String_Node_Str"");
  c1.getNetworkConfig().getInterfaces().setEnabled(true);
  Config c2=new Config();
  c2.getNetworkConfig().getJoin().getMulticastConfig().setEnabled(multicast);
  c2.getNetworkConfig().getJoin().getTcpIpConfig().setEnabled(!multicast);
  c2.getNetworkConfig().getJoin().getTcpIpConfig().addMember(""String_Node_Str"");
  c2.getNetworkConfig().getInterfaces().clear();
  c2.getNetworkConfig().getInterfaces().addInterface(""String_Node_Str"");
  c2.getNetworkConfig().getInterfaces().setEnabled(true);
  c1.getGroupConfig().setName(""String_Node_Str"");
  c2.getGroupConfig().setName(""String_Node_Str"");
  c1.setProperty(GroupProperties.PROP_MERGE_FIRST_RUN_DELAY_SECONDS,""String_Node_Str"");
  c1.setProperty(GroupProperties.PROP_MERGE_NEXT_RUN_DELAY_SECONDS,""String_Node_Str"");
  c2.setProperty(GroupProperties.PROP_MERGE_FIRST_RUN_DELAY_SECONDS,""String_Node_Str"");
  c2.setProperty(GroupProperties.PROP_MERGE_NEXT_RUN_DELAY_SECONDS,""String_Node_Str"");
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(c1);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(c2);
  HazelcastClient client2=HazelcastClient.newHazelcastClient(c2.getGroupConfig().getName(),c2.getGroupConfig().getPassword(),""String_Node_Str"");
  client2.getTopic(""String_Node_Str"").addMessageListener(new MessageListener<Object>(){
    public void onMessage(    Object message){
    }
  }
);
  LifecycleCountingListener l=new LifecycleCountingListener();
  h2.getLifecycleService().addLifecycleListener(l);
  for (int i=0; i < 500; i++) {
    h2.getMap(""String_Node_Str"").put(i,""String_Node_Str"" + i);
    h2.getMultiMap(""String_Node_Str"").put(i,""String_Node_Str"" + i);
    h2.getMultiMap(""String_Node_Str"").put(i,""String_Node_Str"" + i);
  }
  assertEquals(500,h2.getMap(""String_Node_Str"").size());
  assertEquals(1000,h2.getMultiMap(""String_Node_Str"").size());
  assertEquals(1,h1.getCluster().getMembers().size());
  assertEquals(1,h2.getCluster().getMembers().size());
  Thread.sleep(2000);
  c1.getGroupConfig().setName(""String_Node_Str"");
  assertTrue(l.waitFor(LifecycleEvent.LifecycleState.RESTARTED,40));
  assertEquals(1,l.getCount(LifecycleEvent.LifecycleState.RESTARTING));
  assertEquals(1,l.getCount(LifecycleEvent.LifecycleState.RESTARTED));
  assertEquals(2,h1.getCluster().getMembers().size());
  assertEquals(2,h2.getCluster().getMembers().size());
  assertEquals(500,h1.getMap(""String_Node_Str"").size());
  assertEquals(500,h2.getMap(""String_Node_Str"").size());
  assertEquals(1000,h2.getMultiMap(""String_Node_Str"").size());
  assertEquals(1000,h1.getMultiMap(""String_Node_Str"").size());
  Thread.sleep(10000);
}","@Test public void splitBrain() throws Exception {
  boolean multicast=true;
  Config c1=new Config();
  c1.getNetworkConfig().getJoin().getMulticastConfig().setEnabled(multicast);
  c1.getNetworkConfig().getJoin().getTcpIpConfig().setEnabled(!multicast);
  c1.getNetworkConfig().getJoin().getTcpIpConfig().addMember(""String_Node_Str"");
  c1.getNetworkConfig().getInterfaces().clear();
  c1.getNetworkConfig().getInterfaces().addInterface(""String_Node_Str"");
  c1.getNetworkConfig().getInterfaces().setEnabled(true);
  Config c2=new Config();
  c2.getNetworkConfig().getJoin().getMulticastConfig().setEnabled(multicast);
  c2.getNetworkConfig().getJoin().getTcpIpConfig().setEnabled(!multicast);
  c2.getNetworkConfig().getJoin().getTcpIpConfig().addMember(""String_Node_Str"");
  c2.getNetworkConfig().getInterfaces().clear();
  c2.getNetworkConfig().getInterfaces().addInterface(""String_Node_Str"");
  c2.getNetworkConfig().getInterfaces().setEnabled(true);
  c1.getGroupConfig().setName(""String_Node_Str"");
  c2.getGroupConfig().setName(""String_Node_Str"");
  c1.setProperty(GroupProperties.PROP_MERGE_FIRST_RUN_DELAY_SECONDS,""String_Node_Str"");
  c1.setProperty(GroupProperties.PROP_MERGE_NEXT_RUN_DELAY_SECONDS,""String_Node_Str"");
  c2.setProperty(GroupProperties.PROP_MERGE_FIRST_RUN_DELAY_SECONDS,""String_Node_Str"");
  c2.setProperty(GroupProperties.PROP_MERGE_NEXT_RUN_DELAY_SECONDS,""String_Node_Str"");
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(c1);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(c2);
  HazelcastClient client2=HazelcastClient.newHazelcastClient(c2.getGroupConfig().getName(),c2.getGroupConfig().getPassword(),""String_Node_Str"");
  client2.getTopic(""String_Node_Str"").addMessageListener(new MessageListener<Object>(){
    public void onMessage(    Message message){
    }
  }
);
  LifecycleCountingListener l=new LifecycleCountingListener();
  h2.getLifecycleService().addLifecycleListener(l);
  for (int i=0; i < 500; i++) {
    h2.getMap(""String_Node_Str"").put(i,""String_Node_Str"" + i);
    h2.getMultiMap(""String_Node_Str"").put(i,""String_Node_Str"" + i);
    h2.getMultiMap(""String_Node_Str"").put(i,""String_Node_Str"" + i);
  }
  assertEquals(500,h2.getMap(""String_Node_Str"").size());
  assertEquals(1000,h2.getMultiMap(""String_Node_Str"").size());
  assertEquals(1,h1.getCluster().getMembers().size());
  assertEquals(1,h2.getCluster().getMembers().size());
  Thread.sleep(2000);
  c1.getGroupConfig().setName(""String_Node_Str"");
  assertTrue(l.waitFor(LifecycleEvent.LifecycleState.RESTARTED,40));
  assertEquals(1,l.getCount(LifecycleEvent.LifecycleState.RESTARTING));
  assertEquals(1,l.getCount(LifecycleEvent.LifecycleState.RESTARTED));
  assertEquals(2,h1.getCluster().getMembers().size());
  assertEquals(2,h2.getCluster().getMembers().size());
  assertEquals(500,h1.getMap(""String_Node_Str"").size());
  assertEquals(500,h2.getMap(""String_Node_Str"").size());
  assertEquals(1000,h2.getMultiMap(""String_Node_Str"").size());
  assertEquals(1000,h1.getMultiMap(""String_Node_Str"").size());
  Thread.sleep(10000);
}",0.997872688594338
49734,"@Test public void addMessageListenerWithClusterFailOver() throws InterruptedException, IOException {
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(config);
  client=newHazelcastClient(h1,h2);
  final ITopic<String> topic=client.getTopic(""String_Node_Str"");
  final CountDownLatch latch=new CountDownLatch(3);
  final String message=""String_Node_Str"";
  topic.addMessageListener(new MessageListener<String>(){
    public void onMessage(    String msg){
      if (msg.equals(message)) {
        latch.countDown();
      }
    }
  }
);
  topic.publish(message);
  Map<Integer,HazelcastInstance> memberMap=getMapOfClusterMembers(h1,h2);
  HazelcastInstance h=memberMap.remove(client.getConnectionManager().getConnection().getAddress().getPort());
  h.shutdown();
  Thread.sleep(1000);
  for (int i=0; i < 2; i++) {
    new Thread(new Runnable(){
      public void run(){
        topic.publish(message);
      }
    }
).start();
  }
  assertTrue(latch.await(5,SECONDS));
}","@Test public void addMessageListenerWithClusterFailOver() throws InterruptedException, IOException {
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(config);
  client=newHazelcastClient(h1,h2);
  final ITopic<String> topic=client.getTopic(""String_Node_Str"");
  final CountDownLatch latch=new CountDownLatch(3);
  final String message=""String_Node_Str"";
  topic.addMessageListener(new MessageListener<String>(){
    public void onMessage(    Message<String> msg){
      if (msg.equals(message)) {
        latch.countDown();
      }
    }
  }
);
  topic.publish(message);
  Map<Integer,HazelcastInstance> memberMap=getMapOfClusterMembers(h1,h2);
  HazelcastInstance h=memberMap.remove(client.getConnectionManager().getConnection().getAddress().getPort());
  h.shutdown();
  Thread.sleep(1000);
  for (int i=0; i < 2; i++) {
    new Thread(new Runnable(){
      public void run(){
        topic.publish(message);
      }
    }
).start();
  }
  assertTrue(latch.await(5,SECONDS));
}",0.99568345323741
49735,"public int incrementAndGet(){
  return ++count;
}","public int incrementAndGet(){
  return count.incrementAndGet();
}",0.8245614035087719
49736,"public int decrementAndGet(){
  return --count;
}","public int decrementAndGet(){
  return count.decrementAndGet();
}",0.8245614035087719
49737,"@Override public String toString(){
  return ""String_Node_Str"" + ""String_Node_Str"" + threadId + ""String_Node_Str""+ count+ '}';
}","@Override public String toString(){
  return ""String_Node_Str"" + ""String_Node_Str"" + threadId + ""String_Node_Str""+ count.get()+ '}';
}",0.9770992366412212
49738,"public int getCount(){
  return count;
}","public int getCount(){
  return count.get();
}",0.9302325581395348
49739,"public void clear(){
  mapIndexes.clear();
  records.clear();
  size=0;
}","public void clear(){
  mapIndexes.clear();
  records.clear();
  size.set(0);
}",0.9536423841059604
49740,"public void index(Record record){
  final Long recordId=record.getId();
  if (record.isActive()) {
    final Record anotherRecord=records.putIfAbsent(recordId,record);
    if (anotherRecord != null) {
      record=anotherRecord;
    }
 else {
      size++;
    }
  }
 else {
    remove(record);
  }
  if (indexValue != null) {
    Long newValueIndex=-1L;
    if (record.isActive() && record.hasValueData()) {
      newValueIndex=(long)record.getValueData().hashCode();
    }
    indexValue.index(newValueIndex,record);
  }
  Long[] indexValues=record.getIndexes();
  if (indexValues != null && hasIndexedAttributes) {
    byte[] indexTypes=record.getIndexTypes();
    if (indexTypes == null || indexValues.length != indexTypes.length) {
      throw new IllegalArgumentException(""String_Node_Str"" + Arrays.toString(indexTypes));
    }
    Collection<Index> indexes=mapIndexes.values();
    for (    Index index : indexes) {
      if (indexValues.length > index.getAttributeIndex()) {
        Long newValue=indexValues[index.getAttributeIndex()];
        index.index(newValue,record);
      }
    }
  }
}","public void index(Record record){
  final Long recordId=record.getId();
  if (record.isActive()) {
    final Record anotherRecord=records.putIfAbsent(recordId,record);
    if (anotherRecord != null) {
      record=anotherRecord;
    }
 else {
      size.incrementAndGet();
    }
  }
 else {
    remove(record);
  }
  if (indexValue != null) {
    Long newValueIndex=-1L;
    if (record.isActive() && record.hasValueData()) {
      newValueIndex=(long)record.getValueData().hashCode();
    }
    indexValue.index(newValueIndex,record);
  }
  Long[] indexValues=record.getIndexes();
  if (indexValues != null && hasIndexedAttributes) {
    byte[] indexTypes=record.getIndexTypes();
    if (indexTypes == null || indexValues.length != indexTypes.length) {
      throw new IllegalArgumentException(""String_Node_Str"" + Arrays.toString(indexTypes));
    }
    Collection<Index> indexes=mapIndexes.values();
    for (    Index index : indexes) {
      if (indexValues.length > index.getAttributeIndex()) {
        Long newValue=indexValues[index.getAttributeIndex()];
        index.index(newValue,record);
      }
    }
  }
}",0.990990990990991
49741,"public void remove(Record record){
  Record existingRecord=records.remove(record.getId());
  if (existingRecord != null) {
    size--;
  }
}","public void remove(Record record){
  Record existingRecord=records.remove(record.getId());
  if (existingRecord != null) {
    size.decrementAndGet();
  }
}",0.9324324324324323
49742,"public int size(){
  return size;
}","public int size(){
  return size.get();
}",0.9210526315789472
49743,"public Set<MapEntry> doQuery(QueryContext queryContext){
  boolean strong=false;
  Set<MapEntry> results=null;
  Predicate predicate=queryContext.getPredicate();
  try {
    if (predicate != null && mapIndexes != null && predicate instanceof IndexAwarePredicate) {
      List<IndexAwarePredicate> lsIndexAwarePredicates=new ArrayList<IndexAwarePredicate>();
      IndexAwarePredicate iap=(IndexAwarePredicate)predicate;
      strong=iap.collectIndexAwarePredicates(lsIndexAwarePredicates,mapIndexes);
      if (strong) {
        Set<Index> setAppliedIndexes=new HashSet<Index>(1);
        iap.collectAppliedIndexes(setAppliedIndexes,mapIndexes);
        if (setAppliedIndexes.size() > 0) {
          for (          Index index : setAppliedIndexes) {
            if (strong) {
              strong=index.isStrong();
            }
          }
        }
      }
      int indexAwarePredicateCount=lsIndexAwarePredicates.size();
      if (indexAwarePredicateCount == 1) {
        IndexAwarePredicate indexAwarePredicate=lsIndexAwarePredicates.get(0);
        Set<MapEntry> sub=indexAwarePredicate.filter(queryContext);
        if (sub == null || sub.size() == 0) {
          return null;
        }
 else {
          return sub;
        }
      }
 else       if (indexAwarePredicateCount > 0) {
        IndexAwarePredicate indexAwarePredicateFirst=lsIndexAwarePredicates.get(0);
        Set<MapEntry> subFirst=indexAwarePredicateFirst.filter(queryContext);
        if (subFirst != null && subFirst.size() < 11) {
          strong=true;
          Set<MapEntry> resultSet=new HashSet<MapEntry>(subFirst);
          for (int i=1; i < lsIndexAwarePredicates.size(); i++) {
            IndexAwarePredicate p=lsIndexAwarePredicates.get(i);
            Iterator<MapEntry> it=resultSet.iterator();
            while (it.hasNext()) {
              Record record=(Record)it.next();
              if (!p.apply(record)) {
                it.remove();
              }
            }
          }
          return resultSet;
        }
 else         if (subFirst != null) {
          List<Set<MapEntry>> lsSubResults=new ArrayList<Set<MapEntry>>(indexAwarePredicateCount);
          lsSubResults.add(subFirst);
          Set<MapEntry> smallestSet=subFirst;
          for (int i=1; i < indexAwarePredicateCount; i++) {
            IndexAwarePredicate p=lsIndexAwarePredicates.get(i);
            Set<MapEntry> sub=p.filter(queryContext);
            if (sub == null) {
              strong=false;
            }
 else             if (sub.size() == 0) {
              strong=true;
              return null;
            }
 else {
              if (sub.size() < smallestSet.size()) {
                smallestSet=sub;
              }
              lsSubResults.add(sub);
            }
          }
          if (smallestSet == null) {
            return null;
          }
          results=new HashSet<MapEntry>(smallestSet.size());
          Iterator<MapEntry> it=smallestSet.iterator();
          smallestLoop:           while (it.hasNext()) {
            MapEntry entry=it.next();
            for (            Set<MapEntry> sub : lsSubResults) {
              if (!sub.contains(entry)) {
                continue smallestLoop;
              }
            }
            results.add(entry);
          }
          return results;
        }
      }
    }
    return new SingleResultSet(records);
  }
  finally {
    queryContext.setStrong(strong);
  }
}","public Set<MapEntry> doQuery(QueryContext queryContext){
  boolean strong=false;
  Set<MapEntry> results;
  Predicate predicate=queryContext.getPredicate();
  try {
    if (predicate != null && mapIndexes != null && predicate instanceof IndexAwarePredicate) {
      List<IndexAwarePredicate> lsIndexAwarePredicates=new ArrayList<IndexAwarePredicate>();
      IndexAwarePredicate iap=(IndexAwarePredicate)predicate;
      strong=iap.collectIndexAwarePredicates(lsIndexAwarePredicates,mapIndexes);
      if (strong) {
        Set<Index> setAppliedIndexes=new HashSet<Index>(1);
        iap.collectAppliedIndexes(setAppliedIndexes,mapIndexes);
        if (setAppliedIndexes.size() > 0) {
          for (          Index index : setAppliedIndexes) {
            if (strong) {
              strong=index.isStrong();
            }
          }
        }
      }
      int indexAwarePredicateCount=lsIndexAwarePredicates.size();
      if (indexAwarePredicateCount == 1) {
        IndexAwarePredicate indexAwarePredicate=lsIndexAwarePredicates.get(0);
        Set<MapEntry> sub=indexAwarePredicate.filter(queryContext);
        if (sub == null || sub.size() == 0) {
          return null;
        }
 else {
          return sub;
        }
      }
 else       if (indexAwarePredicateCount > 0) {
        IndexAwarePredicate indexAwarePredicateFirst=lsIndexAwarePredicates.get(0);
        Set<MapEntry> subFirst=indexAwarePredicateFirst.filter(queryContext);
        if (subFirst != null && subFirst.size() < 11) {
          strong=true;
          Set<MapEntry> resultSet=new HashSet<MapEntry>(subFirst);
          for (int i=1; i < lsIndexAwarePredicates.size(); i++) {
            IndexAwarePredicate p=lsIndexAwarePredicates.get(i);
            Iterator<MapEntry> it=resultSet.iterator();
            while (it.hasNext()) {
              Record record=(Record)it.next();
              if (!p.apply(record)) {
                it.remove();
              }
            }
          }
          return resultSet;
        }
 else         if (subFirst != null) {
          List<Set<MapEntry>> lsSubResults=new ArrayList<Set<MapEntry>>(indexAwarePredicateCount);
          lsSubResults.add(subFirst);
          Set<MapEntry> smallestSet=subFirst;
          for (int i=1; i < indexAwarePredicateCount; i++) {
            IndexAwarePredicate p=lsIndexAwarePredicates.get(i);
            Set<MapEntry> sub=p.filter(queryContext);
            if (sub == null) {
              strong=false;
            }
 else             if (sub.size() == 0) {
              strong=true;
              return null;
            }
 else {
              if (sub.size() < smallestSet.size()) {
                smallestSet=sub;
              }
              lsSubResults.add(sub);
            }
          }
          if (smallestSet == null) {
            return null;
          }
          results=new HashSet<MapEntry>(smallestSet.size());
          Iterator<MapEntry> it=smallestSet.iterator();
          smallestLoop:           while (it.hasNext()) {
            MapEntry entry=it.next();
            for (            Set<MapEntry> sub : lsSubResults) {
              if (!sub.contains(entry)) {
                continue smallestLoop;
              }
            }
            results.add(entry);
          }
          return results;
        }
      }
    }
    return new SingleResultSet(records);
  }
  finally {
    queryContext.setStrong(strong);
  }
}",0.999269326318866
49744,"void doRemoveAddress(Address deadAddress){
  mapStorageMemberIndexes.clear();
  logger.log(Level.INFO,""String_Node_Str"" + deadAddress);
  if (!node.joined()) {
    node.failedConnection(deadAddress);
    return;
  }
  if (deadAddress.equals(thisAddress))   return;
  if (deadAddress.equals(getMasterAddress())) {
    if (node.joined()) {
      MemberImpl newMaster=getNextMemberAfter(deadAddress,false,1);
      if (newMaster != null)       node.setMasterAddress(newMaster.getAddress());
 else       node.setMasterAddress(null);
    }
 else {
      node.setMasterAddress(null);
    }
    logger.log(Level.FINEST,""String_Node_Str"" + node.getMasterAddress());
  }
  if (isMaster()) {
    setJoins.remove(new MemberInfo(deadAddress));
  }
  Connection conn=node.connectionManager.getConnection(deadAddress);
  if (conn != null) {
    node.connectionManager.destroyConnection(conn);
  }
  MemberImpl deadMember=getMember(deadAddress);
  if (deadMember != null) {
    lsMembersBefore.clear();
    for (    MemberImpl memberBefore : lsMembers) {
      lsMembersBefore.add(memberBefore);
    }
    removeMember(deadMember);
    node.concurrentMapManager.syncForDead(deadMember);
    node.listenerManager.syncForDead(deadAddress);
    node.topicManager.syncForDead(deadAddress);
    node.getClusterImpl().setMembers(lsMembers);
    disconnectExistingCalls(deadAddress);
    if (isMaster()) {
      logger.log(Level.FINEST,deadAddress + ""String_Node_Str"");
      sendRemoveMemberToOthers(deadAddress);
    }
    logger.log(Level.INFO,this.toString());
  }
}","void doRemoveAddress(Address deadAddress){
  mapStorageMemberIndexes.clear();
  logger.log(Level.INFO,""String_Node_Str"" + deadAddress);
  if (!node.joined()) {
    node.failedConnection(deadAddress);
    return;
  }
  if (deadAddress.equals(thisAddress))   return;
  if (deadAddress.equals(getMasterAddress())) {
    if (node.joined()) {
      MemberImpl newMaster=getNextMemberAfter(deadAddress,false,1);
      if (newMaster != null)       node.setMasterAddress(newMaster.getAddress());
 else       node.setMasterAddress(null);
    }
 else {
      node.setMasterAddress(null);
    }
    logger.log(Level.FINEST,""String_Node_Str"" + node.getMasterAddress());
  }
  if (isMaster()) {
    setJoins.remove(new MemberInfo(deadAddress));
  }
  Connection conn=node.connectionManager.getConnection(deadAddress);
  if (conn != null) {
    node.connectionManager.destroyConnection(conn);
  }
  MemberImpl deadMember=getMember(deadAddress);
  if (deadMember != null) {
    lsMembersBefore.clear();
    for (    MemberImpl memberBefore : lsMembers) {
      lsMembersBefore.add(memberBefore);
    }
    removeMember(deadMember);
    node.concurrentMapManager.syncForDead(deadMember);
    node.blockingQueueManager.syncForDead(deadMember);
    node.listenerManager.syncForDead(deadAddress);
    node.topicManager.syncForDead(deadAddress);
    node.getClusterImpl().setMembers(lsMembers);
    disconnectExistingCalls(deadAddress);
    if (isMaster()) {
      logger.log(Level.FINEST,deadAddress + ""String_Node_Str"");
      sendRemoveMemberToOthers(deadAddress);
    }
    logger.log(Level.INFO,this.toString());
  }
}",0.9825452237384956
49745,"IQueue newQueueProxy(String name){
  IQueue queue=Hazelcast.getQueue(name);
  ClassLoader classLoader=Thread.currentThread().getContextClassLoader();
  Class[] interfaces=new Class[]{IQueue.class};
  IQueue proxy=(IQueue)Proxy.newProxyInstance(classLoader,interfaces,new ThreadBoundInvocationHandler(queue));
  mapsUsed.add(proxy);
  return proxy;
}","public static IQueue newQueueProxy(HazelcastInstance hz,String name,List listToAdd){
  IQueue queue=hz.getQueue(name);
  ClassLoader classLoader=Thread.currentThread().getContextClassLoader();
  Class[] interfaces=new Class[]{IQueue.class};
  IQueue proxy=(IQueue)Proxy.newProxyInstance(classLoader,interfaces,new ThreadBoundInvocationHandler(queue));
  if (listToAdd != null) {
    listToAdd.add(proxy);
  }
  return proxy;
}",0.8051612903225807
49746,"@Test @Ignore public void testMapEntryLastAccessTime(){
  TransactionalMap txnMap=newTransactionalMapProxy(""String_Node_Str"");
  TransactionalMap txnMap2=newTransactionalMapProxy(""String_Node_Str"");
  txnMap.put(""String_Node_Str"",""String_Node_Str"");
  MapEntry mapEntry=txnMap.getMapEntry(""String_Node_Str"");
  txnMap.begin();
  txnMap.get(""String_Node_Str"");
  mapEntry=txnMap.getMapEntry(""String_Node_Str"");
  txnMap.commit();
}","@Test @Ignore public void testMapEntryLastAccessTime(){
  TransactionalMap txnMap=newTransactionalMapProxy(""String_Node_Str"");
  TransactionalMap txnMap2=newTransactionalMapProxy(""String_Node_Str"");
  txnMap.put(""String_Node_Str"",""String_Node_Str"");
  MapEntry mapEntry=txnMap.getMapEntry(""String_Node_Str"");
  txnMap.begin();
  txnMap.get(""String_Node_Str"");
  mapEntry=txnMap.getMapEntry(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + mapEntry.getLastAccessTime());
  txnMap.commit();
}",0.9227467811158798
49747,"IMap newMapProxy(String name){
  IMap imap=Hazelcast.getMap(name);
  ClassLoader classLoader=Thread.currentThread().getContextClassLoader();
  Class[] interfaces=new Class[]{IMap.class};
  IMap proxy=(IMap)Proxy.newProxyInstance(classLoader,interfaces,new ThreadBoundInvocationHandler(imap));
  mapsUsed.add(proxy);
  return proxy;
}","public static IMap newMapProxy(HazelcastInstance hz,String name,List listToAdd){
  IMap imap=hz.getMap(name);
  ClassLoader classLoader=Thread.currentThread().getContextClassLoader();
  Class[] interfaces=new Class[]{IMap.class};
  IMap proxy=(IMap)Proxy.newProxyInstance(classLoader,interfaces,new ThreadBoundInvocationHandler(imap));
  if (listToAdd != null) {
    listToAdd.add(proxy);
  }
  return proxy;
}",0.7779273216689099
49748,"public void processSelectionQueue(){
  while (live) {
    final Runnable runnable=selectorQueue.poll();
    if (runnable == null) {
      return;
    }
    runnable.run();
  }
}","private void processSelectionQueue(){
  while (live) {
    final Runnable runnable=selectorQueue.poll();
    if (runnable == null) {
      return;
    }
    runnable.run();
  }
}",0.9746478873239436
49749,"@Test public void addTwoMessageListener() throws InterruptedException {
  HazelcastClient hClient=getHazelcastClient();
  ITopic<String> topic=hClient.getTopic(""String_Node_Str"");
  final CountDownLatch latch=new CountDownLatch(2);
  final String message=""String_Node_Str"";
  topic.addMessageListener(new MessageListener<String>(){
    public void onMessage(    String msg){
      if (msg.equals(message)) {
        latch.countDown();
      }
    }
  }
);
  topic.addMessageListener(new MessageListener<String>(){
    public void onMessage(    String msg){
      if (msg.equals(message)) {
        latch.countDown();
      }
    }
  }
);
  topic.publish(message);
  assertTrue(latch.await(10000,TimeUnit.MILLISECONDS));
}","@Test public void addTwoMessageListener() throws InterruptedException {
  HazelcastClient hClient=getHazelcastClient();
  ITopic<String> topic=hClient.getTopic(""String_Node_Str"");
  final CountDownLatch latch=new CountDownLatch(2);
  final String message=""String_Node_Str"";
  topic.addMessageListener(new MessageListener<String>(){
    public void onMessage(    Message<String> msg){
      if (msg.getMessageObject().equals(message)) {
        latch.countDown();
      }
    }
  }
);
  topic.addMessageListener(new MessageListener<String>(){
    public void onMessage(    Message<String> msg){
      if (msg.getMessageObject().equals(message)) {
        latch.countDown();
      }
    }
  }
);
  topic.publish(message);
  assertTrue(latch.await(10000,TimeUnit.MILLISECONDS));
}",0.9465954606141522
49750,"@Test public void addMessageListener() throws InterruptedException {
  HazelcastClient hClient=getHazelcastClient();
  ITopic<String> topic=hClient.getTopic(""String_Node_Str"");
  final CountDownLatch latch=new CountDownLatch(1);
  final String message=""String_Node_Str"";
  topic.addMessageListener(new MessageListener<String>(){
    public void onMessage(    String msg){
      if (msg.equals(message)) {
        latch.countDown();
      }
    }
  }
);
  topic.publish(message);
  assertTrue(latch.await(10000,TimeUnit.MILLISECONDS));
}","@Test public void addMessageListener() throws InterruptedException {
  HazelcastClient hClient=getHazelcastClient();
  ITopic<String> topic=hClient.getTopic(""String_Node_Str"");
  final CountDownLatch latch=new CountDownLatch(1);
  final String message=""String_Node_Str"";
  topic.addMessageListener(new MessageListener<String>(){
    public void onMessage(    Message<String> msg){
      if (msg.getMessageObject().equals(message)) {
        latch.countDown();
      }
    }
  }
);
  topic.publish(message);
  assertTrue(latch.await(10000,TimeUnit.MILLISECONDS));
}",0.9636363636363636
49751,"@Test public void removeMessageListener() throws InterruptedException {
  HazelcastClient hClient=getHazelcastClient();
  ITopic<String> topic=hClient.getTopic(""String_Node_Str"");
  final CountDownLatch latch=new CountDownLatch(2);
  final CountDownLatch cp=new CountDownLatch(1);
  MessageListener<String> messageListener=new MessageListener<String>(){
    public void onMessage(    String msg){
      System.out.println(""String_Node_Str"" + msg + ""String_Node_Str""+ this);
      latch.countDown();
      cp.countDown();
    }
  }
;
  final String message=""String_Node_Str"" + messageListener.hashCode() + ""String_Node_Str"";
  topic.addMessageListener(messageListener);
  topic.publish(message + ""String_Node_Str"");
  cp.await();
  topic.removeMessageListener(messageListener);
  topic.publish(message + ""String_Node_Str"");
  Thread.sleep(50);
  assertEquals(1,latch.getCount());
}","@Test public void removeMessageListener() throws InterruptedException {
  HazelcastClient hClient=getHazelcastClient();
  ITopic<String> topic=hClient.getTopic(""String_Node_Str"");
  final CountDownLatch latch=new CountDownLatch(2);
  final CountDownLatch cp=new CountDownLatch(1);
  MessageListener<String> messageListener=new MessageListener<String>(){
    public void onMessage(    Message<String> msg){
      System.out.println(""String_Node_Str"" + msg + ""String_Node_Str""+ this);
      latch.countDown();
      cp.countDown();
    }
  }
;
  final String message=""String_Node_Str"" + messageListener.hashCode() + ""String_Node_Str"";
  topic.addMessageListener(messageListener);
  topic.publish(message + ""String_Node_Str"");
  cp.await();
  topic.removeMessageListener(messageListener);
  topic.publish(message + ""String_Node_Str"");
  Thread.sleep(50);
  assertEquals(1,latch.getCount());
}",0.988128886376484
49752,"public void onMessage(String msg){
  if (msg.startsWith(message)) {
    latch.countDown();
    cp.countDown();
  }
}","public void onMessage(Message<String> msg){
  if (msg.getMessageObject().startsWith(message)) {
    latch.countDown();
    cp.countDown();
  }
}",0.8923076923076924
49753,"@Test public void add2listenerAndRemoveOne() throws InterruptedException {
  HazelcastClient hClient=getHazelcastClient();
  ITopic<String> topic=hClient.getTopic(""String_Node_Str"");
  final CountDownLatch latch=new CountDownLatch(4);
  final CountDownLatch cp=new CountDownLatch(2);
  final String message=""String_Node_Str"";
  MessageListener<String> messageListener1=new MessageListener<String>(){
    public void onMessage(    String msg){
      if (msg.startsWith(message)) {
        latch.countDown();
        cp.countDown();
      }
    }
  }
;
  MessageListener<String> messageListener2=new MessageListener<String>(){
    public void onMessage(    String msg){
      if (msg.startsWith(message)) {
        latch.countDown();
        cp.countDown();
      }
    }
  }
;
  topic.addMessageListener(messageListener1);
  topic.addMessageListener(messageListener2);
  topic.publish(message + ""String_Node_Str"");
  Thread.sleep(50);
  topic.removeMessageListener(messageListener1);
  cp.await();
  topic.publish(message + ""String_Node_Str"");
  Thread.sleep(100);
  assertEquals(1,latch.getCount());
}","@Test public void add2listenerAndRemoveOne() throws InterruptedException {
  HazelcastClient hClient=getHazelcastClient();
  ITopic<String> topic=hClient.getTopic(""String_Node_Str"");
  final CountDownLatch latch=new CountDownLatch(4);
  final CountDownLatch cp=new CountDownLatch(2);
  final String message=""String_Node_Str"";
  MessageListener<String> messageListener1=new MessageListener<String>(){
    public void onMessage(    Message<String> msg){
      if (msg.getMessageObject().startsWith(message)) {
        latch.countDown();
        cp.countDown();
      }
    }
  }
;
  MessageListener<String> messageListener2=new MessageListener<String>(){
    public void onMessage(    Message<String> msg){
      if (msg.getMessageObject().startsWith(message)) {
        latch.countDown();
        cp.countDown();
      }
    }
  }
;
  topic.addMessageListener(messageListener1);
  topic.addMessageListener(messageListener2);
  topic.publish(message + ""String_Node_Str"");
  Thread.sleep(50);
  topic.removeMessageListener(messageListener1);
  cp.await();
  topic.publish(message + ""String_Node_Str"");
  Thread.sleep(100);
  assertEquals(1,latch.getCount());
}",0.9645704162976084
49754,"@Test public void testTopicPublish(){
  ITopic<String> topic=getHazelcastClient().getTopic(""String_Node_Str"");
  final CountDownLatch latch=new CountDownLatch(1);
  topic.addMessageListener(new MessageListener<String>(){
    public void onMessage(    String msg){
      assertEquals(""String_Node_Str"",msg);
      latch.countDown();
    }
  }
);
  topic.publish(""String_Node_Str"");
  try {
    assertTrue(latch.await(5,TimeUnit.SECONDS));
  }
 catch (  InterruptedException ignored) {
  }
}","@Test public void testTopicPublish(){
  ITopic<String> topic=getHazelcastClient().getTopic(""String_Node_Str"");
  final CountDownLatch latch=new CountDownLatch(1);
  topic.addMessageListener(new MessageListener<String>(){
    public void onMessage(    Message<String> msg){
      assertEquals(""String_Node_Str"",msg.getMessageObject());
      latch.countDown();
    }
  }
);
  topic.publish(""String_Node_Str"");
  try {
    assertTrue(latch.await(5,TimeUnit.SECONDS));
  }
 catch (  InterruptedException ignored) {
  }
}",0.9602385685884692
49755,"public void onMessage(String msg){
  assertEquals(""String_Node_Str"",msg);
  latch.countDown();
}","public void onMessage(Message<String> msg){
  assertEquals(""String_Node_Str"",msg.getMessageObject());
  latch.countDown();
}",0.8727272727272727
49756,"@Test public void testNotifyMessageListeners() throws Exception {
  final MessageListenerManager manager=new MessageListenerManager();
  final String name=""String_Node_Str"";
  assertTrue(manager.noListenerRegistered(name));
  final String myMessage=""String_Node_Str"";
  final CountDownLatch latch=new CountDownLatch(1);
  MessageListener listener=new MessageListener(){
    public void onMessage(    Object message){
      if (message.equals(myMessage)) {
        latch.countDown();
      }
    }
  }
;
  manager.registerListener(name,listener);
  assertFalse(manager.noListenerRegistered(name));
  new Thread(new Runnable(){
    public void run(){
      Packet packet=new Packet();
      packet.setName(name);
      packet.setKey(toByte(myMessage));
      manager.notifyMessageListeners(packet);
    }
  }
).start();
  assertTrue(latch.await(10,TimeUnit.SECONDS));
}","@Test public void testNotifyMessageListeners() throws Exception {
  final MessageListenerManager manager=new MessageListenerManager();
  final String name=""String_Node_Str"";
  assertTrue(manager.noListenerRegistered(name));
  final String myMessage=""String_Node_Str"";
  final CountDownLatch latch=new CountDownLatch(1);
  MessageListener listener=new MessageListener<Object>(){
    public void onMessage(    Message<Object> message){
      if (message.getMessageObject().equals(myMessage)) {
        latch.countDown();
      }
    }
  }
;
  manager.registerListener(name,listener);
  assertFalse(manager.noListenerRegistered(name));
  new Thread(new Runnable(){
    public void run(){
      Packet packet=new Packet();
      packet.setName(name);
      packet.setKey(toByte(myMessage));
      manager.notifyMessageListeners(packet);
    }
  }
).start();
  assertTrue(latch.await(10,TimeUnit.SECONDS));
}",0.9322033898305084
49757,"@Test public void testRegisterMessageListener() throws Exception {
  MessageListenerManager manager=new MessageListenerManager();
  String name=""String_Node_Str"";
  assertTrue(manager.noListenerRegistered(name));
  MessageListener listener=new MessageListener(){
    public void onMessage(    Object message){
    }
  }
;
  manager.registerListener(name,listener);
  assertFalse(manager.noListenerRegistered(name));
}","@Test public void testRegisterMessageListener() throws Exception {
  MessageListenerManager manager=new MessageListenerManager();
  String name=""String_Node_Str"";
  assertTrue(manager.noListenerRegistered(name));
  MessageListener listener=new MessageListener<Object>(){
    public void onMessage(    Message<Object> message){
    }
  }
;
  manager.registerListener(name,listener);
  assertFalse(manager.noListenerRegistered(name));
}",0.9800235017626322
49758,"@Test public void testRemoveMessageListener() throws Exception {
  MessageListenerManager manager=new MessageListenerManager();
  String name=""String_Node_Str"";
  assertTrue(manager.noListenerRegistered(name));
  MessageListener listener=new MessageListener(){
    public void onMessage(    Object message){
    }
  }
;
  manager.registerListener(name,listener);
  assertFalse(manager.noListenerRegistered(name));
  manager.removeListener(name,listener);
  assertTrue(manager.noListenerRegistered(name));
  manager.removeListener(name,listener);
  assertTrue(manager.noListenerRegistered(name));
}","@Test public void testRemoveMessageListener() throws Exception {
  MessageListenerManager manager=new MessageListenerManager();
  String name=""String_Node_Str"";
  assertTrue(manager.noListenerRegistered(name));
  MessageListener listener=new MessageListener<Object>(){
    public void onMessage(    Message<Object> message){
    }
  }
;
  manager.registerListener(name,listener);
  assertFalse(manager.noListenerRegistered(name));
  manager.removeListener(name,listener);
  assertTrue(manager.noListenerRegistered(name));
  manager.removeListener(name,listener);
  assertTrue(manager.noListenerRegistered(name));
}",0.985962014863749
49759,"public void onMessage(Object message){
  if (message.equals(myMessage)) {
    latch.countDown();
  }
}","public void onMessage(Message<Object> message){
  if (message.getMessageObject().equals(myMessage)) {
    latch.countDown();
  }
}",0.8793103448275862
49760,"protected static Object getConvertedRealValue(Object firstValue,Object value){
  if (firstValue == null)   return value;
  if (firstValue.getClass() == value.getClass()) {
    return value;
  }
 else {
    return getRealObject(firstValue,String.valueOf(value));
  }
}","protected static Object getConvertedRealValue(Object firstValue,Object value){
  if (firstValue == null)   return value;
  if (firstValue.getClass() == value.getClass()) {
    return value;
  }
 else {
    return getRealObject(firstValue,value);
  }
}",0.9498069498069498
49761,"public static Object getRealObject(Object type,String value){
  Object result=null;
  if (type instanceof Boolean) {
    result=""String_Node_Str"".equalsIgnoreCase(value) ? true : false;
  }
 else   if (type instanceof Integer) {
    result=Integer.valueOf(value);
  }
 else   if (type instanceof Long) {
    result=Long.valueOf(value);
  }
 else   if (type instanceof Double) {
    result=Double.valueOf(value);
  }
 else   if (type instanceof Float) {
    result=Float.valueOf(value);
  }
 else   if (type instanceof Byte) {
    result=Byte.valueOf(value);
  }
 else   if (type instanceof Timestamp) {
    try {
      result=new Timestamp(timestampFormat.parse(value).getTime());
    }
 catch (    ParseException e) {
      e.printStackTrace();
    }
  }
 else   if (type instanceof java.sql.Date) {
    try {
      result=sqlDateFormat.parse(value);
    }
 catch (    ParseException e) {
      e.printStackTrace();
    }
  }
 else   if (type instanceof Date) {
    try {
      result=dateFormat.parse(value);
    }
 catch (    ParseException e) {
      e.printStackTrace();
    }
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + type + ""String_Node_Str""+ value);
  }
  return result;
}","public static Object getRealObject(Object type,Object value){
  String valueString=String.valueOf(value);
  Object result=null;
  if (type instanceof Boolean) {
    result=""String_Node_Str"".equalsIgnoreCase(valueString) ? true : false;
  }
 else   if (type instanceof Integer) {
    if (value instanceof Number) {
      result=((Number)value).intValue();
    }
 else {
      result=Integer.valueOf(valueString);
    }
  }
 else   if (type instanceof Long) {
    if (value instanceof Number) {
      result=((Number)value).longValue();
    }
 else {
      result=Long.valueOf(valueString);
    }
  }
 else   if (type instanceof Double) {
    if (value instanceof Number) {
      result=((Number)value).doubleValue();
    }
 else {
      result=Double.valueOf(valueString);
    }
  }
 else   if (type instanceof Float) {
    if (value instanceof Number) {
      result=((Number)value).floatValue();
    }
 else {
      result=Float.valueOf(valueString);
    }
  }
 else   if (type instanceof Byte) {
    if (value instanceof Number) {
      result=((Number)value).byteValue();
    }
 else {
      result=Byte.valueOf(valueString);
    }
  }
 else   if (type instanceof Timestamp) {
    if (value instanceof Date) {
      result=(Date)value;
    }
 else {
      try {
        result=new Timestamp(getTimestampFormat().parse(valueString).getTime());
      }
 catch (      ParseException e) {
        Util.throwUncheckedException(e);
      }
    }
  }
 else   if (type instanceof java.sql.Date) {
    if (value instanceof Date) {
      result=(Date)value;
    }
 else {
      try {
        result=getSqlDateFormat().parse(valueString);
      }
 catch (      ParseException e) {
        Util.throwUncheckedException(e);
      }
    }
  }
 else   if (type instanceof Date) {
    if (value instanceof Date) {
      result=(Date)value;
    }
 else {
      try {
        result=getUtilDateFormat().parse(valueString);
      }
 catch (      ParseException e) {
        Util.throwUncheckedException(e);
      }
    }
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + type + ""String_Node_Str""+ valueString);
  }
  return result;
}",0.5565896127289103
49762,"public int deflate(){
  deflater.setInput(uncompressedBuffer.array(),0,uncompressedBuffer.position());
  deflater.finish();
  final int count=deflater.deflate(compressedBuffer.array());
  deflater.reset();
  return count;
}","public int deflate(){
  try {
    deflater.setInput(uncompressedBuffer.array(),0,uncompressedBuffer.position());
    deflater.finish();
    final int count=deflater.deflate(compressedBuffer.array());
    return count;
  }
  finally {
    deflater.reset();
  }
}",0.78099173553719
49763,"public int inflate(int length) throws DataFormatException {
  inflater.setInput(compressedBuffer.array(),0,length);
  final int count=inflater.inflate(uncompressedBuffer.array());
  uncompressedBuffer.limit(count);
  uncompressedBuffer.position(0);
  inflater.reset();
  return count;
}","public int inflate(int length) throws DataFormatException {
  try {
    inflater.setInput(compressedBuffer.array(),0,length);
    final int count=inflater.inflate(uncompressedBuffer.array());
    uncompressedBuffer.limit(count);
    uncompressedBuffer.position(0);
    return count;
  }
  finally {
    inflater.reset();
  }
}",0.8235294117647058
49764,"public void run(){
  while (running) {
    try {
      customRun();
    }
 catch (    InterruptedException e) {
      return;
    }
  }
  notifyMonitor();
}","public void run(){
  try {
    while (running) {
      try {
        customRun();
      }
 catch (      InterruptedException e) {
        return;
      }
    }
  }
  finally {
    terminate();
  }
}",0.8361581920903954
49765,"public void shutdown(){
synchronized (monitor) {
    if (running) {
      this.running=false;
      try {
        monitor.wait();
      }
 catch (      InterruptedException ignored) {
      }
    }
  }
}","public void shutdown(){
  if (terminated) {
    return;
  }
synchronized (monitor) {
    running=false;
    while (!terminated) {
      try {
        monitor.wait();
      }
 catch (      InterruptedException ignored) {
      }
    }
  }
}",0.8009049773755657
49766,"@Test public void testShutdown() throws Exception {
  final ClientRunnable clientRunnable=new ClientRunnable(){
    @Override protected void customRun() throws InterruptedException {
    }
  }
;
  final CountDownLatch latch1=new CountDownLatch(1);
  final CountDownLatch latch2=new CountDownLatch(1);
  final CountDownLatch latchShutDown=new CountDownLatch(1);
  new Thread(new Runnable(){
    public void run(){
      try {
        latch1.await();
        latch2.countDown();
        clientRunnable.shutdown();
        latchShutDown.countDown();
      }
 catch (      InterruptedException e) {
      }
    }
  }
).start();
  latch1.countDown();
  latch2.await();
  Thread.sleep(10);
  clientRunnable.notifyMonitor();
  assertTrue(latchShutDown.await(5,TimeUnit.SECONDS));
  assertFalse(clientRunnable.running);
}","@Test public void testShutdown() throws Exception {
  final ClientRunnable clientRunnable=new ClientRunnable(){
    @Override protected void customRun() throws InterruptedException {
    }
  }
;
  final CountDownLatch latch1=new CountDownLatch(1);
  final CountDownLatch latch2=new CountDownLatch(1);
  final CountDownLatch latchShutDown=new CountDownLatch(1);
  new Thread(new Runnable(){
    public void run(){
      try {
        latch1.await();
        latch2.countDown();
        clientRunnable.shutdown();
        latchShutDown.countDown();
      }
 catch (      InterruptedException e) {
      }
    }
  }
).start();
  latch1.countDown();
  latch2.await();
  Thread.sleep(10);
  clientRunnable.terminate();
  assertTrue(latchShutDown.await(5,TimeUnit.SECONDS));
  assertFalse(clientRunnable.running);
}",0.9864364981504316
49767,"protected String getValue(org.w3c.dom.Node node){
  return getTextContent(node).trim();
}","protected String getValue(org.w3c.dom.Node node){
  return node != null ? getTextContent(node).trim() : ""String_Node_Str"";
}",0.8356807511737089
49768,"public TopicConfig getTopicConfig(final String name){
  TopicConfig config;
  if ((config=lookupByPattern(mapTopicConfigs,name)) != null) {
    return config;
  }
  TopicConfig defConfig=mapTopicConfigs.get(""String_Node_Str"");
  if (defConfig == null) {
    defConfig=new TopicConfig();
    defConfig.setName(""String_Node_Str"");
    addTopicConfig(defConfig);
  }
  config=new TopicConfig(defConfig);
  config.setName(name);
  addTopicConfig(defConfig);
  return config;
}","public TopicConfig getTopicConfig(final String name){
  TopicConfig config;
  if ((config=lookupByPattern(mapTopicConfigs,name)) != null) {
    return config;
  }
  TopicConfig defConfig=mapTopicConfigs.get(""String_Node_Str"");
  if (defConfig == null) {
    defConfig=new TopicConfig();
    defConfig.setName(""String_Node_Str"");
    addTopicConfig(defConfig);
  }
  config=new TopicConfig(defConfig);
  config.setName(name);
  addTopicConfig(config);
  return config;
}",0.9946865037194474
49769,"public String generate(Config config){
  final StringBuilder xml=new StringBuilder();
  xml.append(""String_Node_Str"");
  xml.append(""String_Node_Str"");
  xml.append(""String_Node_Str"").append(config.getGroupConfig().getName()).append(""String_Node_Str"");
  xml.append(""String_Node_Str"").append(config.getGroupConfig().getPassword()).append(""String_Node_Str"");
  xml.append(""String_Node_Str"");
  appendProperties(xml,config.getProperties());
  final Collection<WanReplicationConfig> wanRepConfigs=config.getWanReplicationConfigs().values();
  for (  WanReplicationConfig wan : wanRepConfigs) {
    xml.append(""String_Node_Str"").append(wan.getName()).append(""String_Node_Str"");
    final List<WanTargetClusterConfig> targets=wan.getTargetClusterConfigs();
    for (    WanTargetClusterConfig t : targets) {
      xml.append(""String_Node_Str"").append(t.getGroupName()).append(""String_Node_Str"").append(t.getGroupPassword()).append(""String_Node_Str"");
      xml.append(""String_Node_Str"").append(t.getReplicationImpl()).append(""String_Node_Str"");
      xml.append(""String_Node_Str"");
      final List<String> eps=t.getEndpoints();
      for (      String ep : eps) {
        xml.append(""String_Node_Str"").append(ep).append(""String_Node_Str"");
      }
      xml.append(""String_Node_Str"").append(""String_Node_Str"");
    }
    xml.append(""String_Node_Str"");
  }
  final NetworkConfig netCfg=config.getNetworkConfig();
  xml.append(""String_Node_Str"");
  xml.append(""String_Node_Str"").append(config.isPortAutoIncrement()).append(""String_Node_Str"").append(config.getPort()).append(""String_Node_Str"");
  final Join join=netCfg.getJoin();
  xml.append(""String_Node_Str"");
  final MulticastConfig mcast=join.getMulticastConfig();
  xml.append(""String_Node_Str"").append(mcast.isEnabled()).append(""String_Node_Str"");
  xml.append(""String_Node_Str"").append(mcast.getMulticastGroup()).append(""String_Node_Str"");
  xml.append(""String_Node_Str"").append(mcast.getMulticastPort()).append(""String_Node_Str"");
  xml.append(""String_Node_Str"").append(mcast.getMulticastTimeoutSeconds()).append(""String_Node_Str"");
  xml.append(""String_Node_Str"");
  final TcpIpConfig tcpCfg=join.getTcpIpConfig();
  xml.append(""String_Node_Str"").append(tcpCfg.isEnabled()).append(""String_Node_Str"");
  final List<String> members=tcpCfg.getMembers();
  for (  String m : members) {
    xml.append(""String_Node_Str"").append(m).append(""String_Node_Str"");
  }
  final List<Address> addresses=tcpCfg.getAddresses();
  for (  Address a : addresses) {
    xml.append(""String_Node_Str"").append(a.getHost()).append(""String_Node_Str"").append(a.getPort()).append(""String_Node_Str"");
  }
  if (tcpCfg.getRequiredMember() != null) {
    xml.append(""String_Node_Str"").append(tcpCfg.getRequiredMember()).append(""String_Node_Str"");
  }
  xml.append(""String_Node_Str"");
  xml.append(""String_Node_Str"");
  final Interfaces interfaces=netCfg.getInterfaces();
  xml.append(""String_Node_Str"").append(interfaces.isEnabled()).append(""String_Node_Str"");
  final Collection<String> interfaceList=interfaces.getInterfaces();
  for (  String i : interfaceList) {
    xml.append(""String_Node_Str"").append(i).append(""String_Node_Str"");
  }
  xml.append(""String_Node_Str"");
  final SymmetricEncryptionConfig sec=netCfg.getSymmetricEncryptionConfig();
  xml.append(""String_Node_Str"").append(sec != null && sec.isEnabled()).append(""String_Node_Str"");
  if (sec != null) {
    xml.append(""String_Node_Str"").append(sec.getAlgorithm()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(sec.getSalt()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(sec.getPassword()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(sec.getIterationCount()).append(""String_Node_Str"");
  }
  xml.append(""String_Node_Str"");
  final AsymmetricEncryptionConfig asec=netCfg.getAsymmetricEncryptionConfig();
  xml.append(""String_Node_Str"").append(asec != null && asec.isEnabled()).append(""String_Node_Str"");
  if (asec != null) {
    xml.append(""String_Node_Str"").append(asec.getAlgorithm()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(asec.getKeyPassword()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(asec.getKeyAlias()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(asec.getStoreType()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(asec.getStorePassword()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(asec.getStorePath()).append(""String_Node_Str"");
  }
  xml.append(""String_Node_Str"");
  xml.append(""String_Node_Str"");
  final Collection<ExecutorConfig> exCfgs=config.getExecutorConfigs();
  for (  ExecutorConfig ex : exCfgs) {
    xml.append(""String_Node_Str"").append(ex.getName()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(ex.getCorePoolSize()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(ex.getMaxPoolSize()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(ex.getKeepAliveSeconds()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"");
  }
  final Collection<QueueConfig> qCfgs=config.getQConfigs().values();
  for (  QueueConfig q : qCfgs) {
    xml.append(""String_Node_Str"").append(q.getName()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(q.getMaxSizePerJVM()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(q.getBackingMapRef()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"");
  }
  final Collection<TopicConfig> tCfgs=config.getTopicConfigs().values();
  for (  TopicConfig t : tCfgs) {
    xml.append(""String_Node_Str"").append(t.getName()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(t.isGlobalOrderingEnabled()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"");
  }
  final Collection<MapConfig> mCfgs=config.getMapConfigs().values();
  for (  MapConfig m : mCfgs) {
    xml.append(""String_Node_Str"").append(m.getName()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(m.getBackupCount()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(m.getEvictionPolicy()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(m.getEvictionPercentage()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(m.getMaxSizeConfig().getMaxSizePolicy()).append(""String_Node_Str"").append(m.getMaxSizeConfig().getSize()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(m.getTimeToLiveSeconds()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(m.getMaxIdleSeconds()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(m.isCacheValue()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(m.isReadBackupData()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(m.getMergePolicy()).append(""String_Node_Str"");
    if (m.getMapStoreConfig() != null) {
      final MapStoreConfig s=m.getMapStoreConfig();
      xml.append(""String_Node_Str"").append(s.isEnabled()).append(""String_Node_Str"");
      xml.append(""String_Node_Str"").append(s.getClassName()).append(""String_Node_Str"");
      xml.append(""String_Node_Str"").append(s.getWriteDelaySeconds()).append(""String_Node_Str"");
      appendProperties(xml,s.getProperties());
      xml.append(""String_Node_Str"");
    }
    if (m.getNearCacheConfig() != null) {
      final NearCacheConfig n=m.getNearCacheConfig();
      xml.append(""String_Node_Str"");
      xml.append(""String_Node_Str"").append(n.getTimeToLiveSeconds()).append(""String_Node_Str"");
      xml.append(""String_Node_Str"").append(n.getMaxIdleSeconds()).append(""String_Node_Str"");
      xml.append(""String_Node_Str"").append(n.getMaxSize()).append(""String_Node_Str"");
      xml.append(""String_Node_Str"").append(n.getEvictionPolicy()).append(""String_Node_Str"");
      xml.append(""String_Node_Str"").append(n.isInvalidateOnChange()).append(""String_Node_Str"");
      xml.append(""String_Node_Str"");
    }
    if (m.getWanReplicationRef() != null) {
      final WanReplicationRef wan=m.getWanReplicationRef();
      xml.append(""String_Node_Str"").append(wan.getName()).append(""String_Node_Str"");
      xml.append(""String_Node_Str"").append(wan.getMergePolicy()).append(""String_Node_Str"");
      xml.append(""String_Node_Str"");
    }
    xml.append(""String_Node_Str"");
  }
  final Collection<SemaphoreConfig> semaphoreCfgs=config.getSemaphoreConfigs();
  for (  SemaphoreConfig sc : semaphoreCfgs) {
    xml.append(""String_Node_Str"").append(sc.getName()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(sc.getInitialPermits()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(sc.isFactoryEnabled()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(sc.getFactoryClassName()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"");
    xml.append(""String_Node_Str"");
  }
  final Collection<MergePolicyConfig> merges=config.getMergePolicyConfigs().values();
  xml.append(""String_Node_Str"");
  for (  MergePolicyConfig mp : merges) {
    xml.append(""String_Node_Str"").append(mp.getName()).append(""String_Node_Str"");
    final String clazz=mp.getImplementation() != null ? mp.getImplementation().getClass().getName() : mp.getClassName();
    xml.append(""String_Node_Str"").append(clazz).append(""String_Node_Str"");
    xml.append(""String_Node_Str"");
  }
  xml.append(""String_Node_Str"");
  xml.append(""String_Node_Str"");
  return format(xml.toString(),5);
}","public String generate(Config config){
  final StringBuilder xml=new StringBuilder();
  xml.append(""String_Node_Str"");
  xml.append(""String_Node_Str"");
  xml.append(""String_Node_Str"").append(config.getGroupConfig().getName()).append(""String_Node_Str"");
  xml.append(""String_Node_Str"").append(config.getGroupConfig().getPassword()).append(""String_Node_Str"");
  xml.append(""String_Node_Str"");
  appendProperties(xml,config.getProperties());
  final Collection<WanReplicationConfig> wanRepConfigs=config.getWanReplicationConfigs().values();
  for (  WanReplicationConfig wan : wanRepConfigs) {
    xml.append(""String_Node_Str"").append(wan.getName()).append(""String_Node_Str"");
    final List<WanTargetClusterConfig> targets=wan.getTargetClusterConfigs();
    for (    WanTargetClusterConfig t : targets) {
      xml.append(""String_Node_Str"").append(t.getGroupName()).append(""String_Node_Str"").append(t.getGroupPassword()).append(""String_Node_Str"");
      xml.append(""String_Node_Str"").append(t.getReplicationImpl()).append(""String_Node_Str"");
      xml.append(""String_Node_Str"");
      final List<String> eps=t.getEndpoints();
      for (      String ep : eps) {
        xml.append(""String_Node_Str"").append(ep).append(""String_Node_Str"");
      }
      xml.append(""String_Node_Str"").append(""String_Node_Str"");
    }
    xml.append(""String_Node_Str"");
  }
  final NetworkConfig netCfg=config.getNetworkConfig();
  xml.append(""String_Node_Str"");
  xml.append(""String_Node_Str"").append(config.isPortAutoIncrement()).append(""String_Node_Str"").append(config.getPort()).append(""String_Node_Str"");
  final Join join=netCfg.getJoin();
  xml.append(""String_Node_Str"");
  final MulticastConfig mcast=join.getMulticastConfig();
  xml.append(""String_Node_Str"").append(mcast.isEnabled()).append(""String_Node_Str"");
  xml.append(""String_Node_Str"").append(mcast.getMulticastGroup()).append(""String_Node_Str"");
  xml.append(""String_Node_Str"").append(mcast.getMulticastPort()).append(""String_Node_Str"");
  xml.append(""String_Node_Str"").append(mcast.getMulticastTimeoutSeconds()).append(""String_Node_Str"");
  if (!mcast.getTrustedInterfaces().isEmpty()) {
    xml.append(""String_Node_Str"");
    for (    String trustedInterface : mcast.getTrustedInterfaces()) {
      xml.append(""String_Node_Str"").append(trustedInterface).append(""String_Node_Str"");
    }
    xml.append(""String_Node_Str"");
  }
  xml.append(""String_Node_Str"");
  final TcpIpConfig tcpCfg=join.getTcpIpConfig();
  xml.append(""String_Node_Str"").append(tcpCfg.isEnabled()).append(""String_Node_Str"");
  final List<String> members=tcpCfg.getMembers();
  for (  String m : members) {
    xml.append(""String_Node_Str"").append(m).append(""String_Node_Str"");
  }
  final List<Address> addresses=tcpCfg.getAddresses();
  for (  Address a : addresses) {
    xml.append(""String_Node_Str"").append(a.getHost()).append(""String_Node_Str"").append(a.getPort()).append(""String_Node_Str"");
  }
  if (tcpCfg.getRequiredMember() != null) {
    xml.append(""String_Node_Str"").append(tcpCfg.getRequiredMember()).append(""String_Node_Str"");
  }
  xml.append(""String_Node_Str"");
  final AwsConfig awsConfig=join.getAwsConfig();
  xml.append(""String_Node_Str"").append(awsConfig.isEnabled()).append(""String_Node_Str"");
  xml.append(""String_Node_Str"").append(awsConfig.getAccessKey()).append(""String_Node_Str"");
  xml.append(""String_Node_Str"").append(awsConfig.getSecretKey()).append(""String_Node_Str"");
  xml.append(""String_Node_Str"").append(awsConfig.getRegion()).append(""String_Node_Str"");
  xml.append(""String_Node_Str"").append(awsConfig.getSecurityGroupName()).append(""String_Node_Str"");
  xml.append(""String_Node_Str"").append(awsConfig.getTagKey()).append(""String_Node_Str"");
  xml.append(""String_Node_Str"").append(awsConfig.getTagValue()).append(""String_Node_Str"");
  xml.append(""String_Node_Str"");
  xml.append(""String_Node_Str"");
  final Interfaces interfaces=netCfg.getInterfaces();
  xml.append(""String_Node_Str"").append(interfaces.isEnabled()).append(""String_Node_Str"");
  final Collection<String> interfaceList=interfaces.getInterfaces();
  for (  String i : interfaceList) {
    xml.append(""String_Node_Str"").append(i).append(""String_Node_Str"");
  }
  xml.append(""String_Node_Str"");
  final SymmetricEncryptionConfig sec=netCfg.getSymmetricEncryptionConfig();
  xml.append(""String_Node_Str"").append(sec != null && sec.isEnabled()).append(""String_Node_Str"");
  if (sec != null) {
    xml.append(""String_Node_Str"").append(sec.getAlgorithm()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(sec.getSalt()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(sec.getPassword()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(sec.getIterationCount()).append(""String_Node_Str"");
  }
  xml.append(""String_Node_Str"");
  final AsymmetricEncryptionConfig asec=netCfg.getAsymmetricEncryptionConfig();
  xml.append(""String_Node_Str"").append(asec != null && asec.isEnabled()).append(""String_Node_Str"");
  if (asec != null) {
    xml.append(""String_Node_Str"").append(asec.getAlgorithm()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(asec.getKeyPassword()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(asec.getKeyAlias()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(asec.getStoreType()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(asec.getStorePassword()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(asec.getStorePath()).append(""String_Node_Str"");
  }
  xml.append(""String_Node_Str"");
  xml.append(""String_Node_Str"");
  final Collection<ExecutorConfig> exCfgs=config.getExecutorConfigs();
  for (  ExecutorConfig ex : exCfgs) {
    xml.append(""String_Node_Str"").append(ex.getName()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(ex.getCorePoolSize()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(ex.getMaxPoolSize()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(ex.getKeepAliveSeconds()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"");
  }
  final Collection<QueueConfig> qCfgs=config.getQConfigs().values();
  for (  QueueConfig q : qCfgs) {
    xml.append(""String_Node_Str"").append(q.getName()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(q.getMaxSizePerJVM()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(q.getBackingMapRef()).append(""String_Node_Str"");
    if (!q.getItemListenerConfigs().isEmpty()) {
      xml.append(""String_Node_Str"");
      for (      ItemListenerConfig lc : q.getItemListenerConfigs()) {
        xml.append(""String_Node_Str"").append(lc.isIncludeValue()).append(""String_Node_Str"");
        xml.append(lc.getClassName());
        xml.append(""String_Node_Str"");
      }
      xml.append(""String_Node_Str"");
    }
    xml.append(""String_Node_Str"");
  }
  final Collection<MapConfig> mCfgs=config.getMapConfigs().values();
  for (  MapConfig m : mCfgs) {
    xml.append(""String_Node_Str"").append(m.getName()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(m.getBackupCount()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(m.getEvictionPolicy()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(m.getEvictionPercentage()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(m.getMaxSizeConfig().getMaxSizePolicy()).append(""String_Node_Str"").append(m.getMaxSizeConfig().getSize()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(m.getTimeToLiveSeconds()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(m.getMaxIdleSeconds()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(m.isCacheValue()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(m.isReadBackupData()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(m.getMergePolicy()).append(""String_Node_Str"");
    if (m.getMapStoreConfig() != null) {
      final MapStoreConfig s=m.getMapStoreConfig();
      xml.append(""String_Node_Str"").append(s.isEnabled()).append(""String_Node_Str"");
      xml.append(""String_Node_Str"").append(s.getClassName()).append(""String_Node_Str"");
      xml.append(""String_Node_Str"").append(s.getWriteDelaySeconds()).append(""String_Node_Str"");
      appendProperties(xml,s.getProperties());
      xml.append(""String_Node_Str"");
    }
    if (m.getNearCacheConfig() != null) {
      final NearCacheConfig n=m.getNearCacheConfig();
      xml.append(""String_Node_Str"");
      xml.append(""String_Node_Str"").append(n.getTimeToLiveSeconds()).append(""String_Node_Str"");
      xml.append(""String_Node_Str"").append(n.getMaxIdleSeconds()).append(""String_Node_Str"");
      xml.append(""String_Node_Str"").append(n.getMaxSize()).append(""String_Node_Str"");
      xml.append(""String_Node_Str"").append(n.getEvictionPolicy()).append(""String_Node_Str"");
      xml.append(""String_Node_Str"").append(n.isInvalidateOnChange()).append(""String_Node_Str"");
      xml.append(""String_Node_Str"");
    }
    if (m.getWanReplicationRef() != null) {
      final WanReplicationRef wan=m.getWanReplicationRef();
      xml.append(""String_Node_Str"").append(wan.getName()).append(""String_Node_Str"");
      xml.append(""String_Node_Str"").append(wan.getMergePolicy()).append(""String_Node_Str"");
      xml.append(""String_Node_Str"");
    }
    if (!m.getMapIndexConfigs().isEmpty()) {
      xml.append(""String_Node_Str"");
      for (      MapIndexConfig indexCfg : m.getMapIndexConfigs()) {
        xml.append(""String_Node_Str"").append(indexCfg.isOrdered()).append(""String_Node_Str"");
        xml.append(indexCfg.getAttribute());
        xml.append(""String_Node_Str"");
      }
      xml.append(""String_Node_Str"");
    }
    if (!m.getEntryListenerConfigs().isEmpty()) {
      xml.append(""String_Node_Str"");
      for (      EntryListenerConfig lc : m.getEntryListenerConfigs()) {
        xml.append(""String_Node_Str"").append(lc.isIncludeValue()).append(""String_Node_Str"").append(lc.isLocal()).append(""String_Node_Str"");
        xml.append(lc.getClassName());
        xml.append(""String_Node_Str"");
      }
      xml.append(""String_Node_Str"");
    }
    if (m.getStorageType() != null) {
      xml.append(""String_Node_Str"").append(m.getStorageType().toString()).append(""String_Node_Str"");
    }
    xml.append(""String_Node_Str"");
  }
  final Collection<MultiMapConfig> mmCfgs=config.getMultiMapConfigs().values();
  for (  MultiMapConfig mm : mmCfgs) {
    xml.append(""String_Node_Str"").append(mm.getName()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(mm.getValueCollectionType()).append(""String_Node_Str"");
    if (!mm.getEntryListenerConfigs().isEmpty()) {
      xml.append(""String_Node_Str"");
      for (      EntryListenerConfig lc : mm.getEntryListenerConfigs()) {
        xml.append(""String_Node_Str"").append(lc.isIncludeValue()).append(""String_Node_Str"").append(lc.isLocal()).append(""String_Node_Str"");
        xml.append(lc.getClassName());
        xml.append(""String_Node_Str"");
      }
      xml.append(""String_Node_Str"");
    }
    xml.append(""String_Node_Str"");
  }
  final Collection<TopicConfig> tCfgs=config.getTopicConfigs().values();
  for (  TopicConfig t : tCfgs) {
    xml.append(""String_Node_Str"").append(t.getName()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(t.isGlobalOrderingEnabled()).append(""String_Node_Str"");
    if (!t.getMessageListenerConfigs().isEmpty()) {
      xml.append(""String_Node_Str"");
      for (      ListenerConfig lc : t.getMessageListenerConfigs()) {
        xml.append(""String_Node_Str"");
        xml.append(lc.getClassName());
        xml.append(""String_Node_Str"");
      }
      xml.append(""String_Node_Str"");
    }
    xml.append(""String_Node_Str"");
  }
  final Collection<SemaphoreConfig> semaphoreCfgs=config.getSemaphoreConfigs();
  for (  SemaphoreConfig sc : semaphoreCfgs) {
    xml.append(""String_Node_Str"").append(sc.getName()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(sc.getInitialPermits()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(sc.isFactoryEnabled()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"").append(sc.getFactoryClassName()).append(""String_Node_Str"");
    xml.append(""String_Node_Str"");
    xml.append(""String_Node_Str"");
  }
  final Collection<MergePolicyConfig> merges=config.getMergePolicyConfigs().values();
  xml.append(""String_Node_Str"");
  for (  MergePolicyConfig mp : merges) {
    xml.append(""String_Node_Str"").append(mp.getName()).append(""String_Node_Str"");
    final String clazz=mp.getImplementation() != null ? mp.getImplementation().getClass().getName() : mp.getClassName();
    xml.append(""String_Node_Str"").append(clazz).append(""String_Node_Str"");
    xml.append(""String_Node_Str"");
  }
  xml.append(""String_Node_Str"");
  if (!config.getListenerConfigs().isEmpty()) {
    xml.append(""String_Node_Str"");
    for (    ListenerConfig lc : config.getListenerConfigs()) {
      xml.append(""String_Node_Str"");
      xml.append(lc.getClassName());
      xml.append(""String_Node_Str"");
    }
    xml.append(""String_Node_Str"");
  }
  xml.append(""String_Node_Str"");
  return format(xml.toString(),5);
}",0.6170353106723538
49770,"public Long[] getIndexValues(Object value){
  if (hasIndexedAttributes) {
    int indexCount=mapIndexes.size();
    Long[] newIndexes=new Long[indexCount];
    if (value instanceof Data) {
      value=toObject((Data)value);
    }
    Collection<Index> indexes=mapIndexes.values();
    for (    Index index : indexes) {
      int attributedIndex=index.getAttributeIndex();
      newIndexes[attributedIndex]=index.extractLongValue(value);
    }
    if (indexTypes == null || indexTypes.length != indexCount) {
synchronized (indexTypesLock) {
        if (indexTypes == null || indexTypes.length != indexCount) {
          indexTypes=new byte[indexCount];
          for (          Index index : indexes) {
            int attributedIndex=index.getAttributeIndex();
            indexTypes[attributedIndex]=index.getIndexType();
          }
        }
      }
    }
    return newIndexes;
  }
  return null;
}","public Long[] getIndexValues(Object value){
  if (hasIndexedAttributes) {
    int indexCount=mapIndexes.size();
    Long[] newIndexes=new Long[indexCount];
    if (value instanceof Data) {
      value=toObject((Data)value);
    }
    Collection<Index> indexes=mapIndexes.values();
    for (    Index index : indexes) {
      int attributedIndex=index.getAttributeIndex();
      newIndexes[attributedIndex]=index.extractLongValue(value);
    }
    byte[] _indexTypes=indexTypes;
    if (_indexTypes == null || _indexTypes.length != indexCount) {
synchronized (indexTypesLock) {
        _indexTypes=indexTypes;
        if (_indexTypes == null || _indexTypes.length != indexCount) {
          _indexTypes=new byte[indexCount];
          for (          Index index : indexes) {
            int attributedIndex=index.getAttributeIndex();
            _indexTypes[attributedIndex]=index.getIndexType();
          }
          indexTypes=_indexTypes;
        }
      }
    }
    return newIndexes;
  }
  return null;
}",0.9440083725798012
49771,"public void appendState(StringBuffer sbState){
  sbState.append(""String_Node_Str"" + records.size() + ""String_Node_Str""+ mapIndexes.size()+ ""String_Node_Str""+ ((indexTypes == null) ? 0 : indexTypes.length));
  for (  Index index : mapIndexes.values()) {
    index.appendState(sbState);
  }
}","public void appendState(StringBuffer sbState){
  byte[] _indexTypes=indexTypes;
  sbState.append(""String_Node_Str"" + records.size() + ""String_Node_Str""+ mapIndexes.size()+ ""String_Node_Str""+ ((_indexTypes == null) ? 0 : _indexTypes.length));
  for (  Index index : mapIndexes.values()) {
    index.appendState(sbState);
  }
}",0.943089430894309
49772,"public void addValue(Data value){
  if (value != null) {
    if (getMultiValues() == null) {
      setMultiValues(new ConcurrentHashSet<Data>(){
        @Override public boolean add(        Data e){
          return e != null && super.add(e);
        }
      }
);
    }
    getMultiValues().add(value);
  }
}","public void addValue(Data value){
  if (value != null) {
    if (getMultiValues() == null) {
      setMultiValues(new ConcurrentHashSet<ValueHolder>(){
        @Override public boolean add(        ValueHolder e){
          return e != null && super.add(e);
        }
      }
);
    }
    getMultiValues().add(new ValueHolder(value));
  }
}",0.9119010819165378
49773,"@Override public boolean add(Data e){
  return e != null && super.add(e);
}","@Override public boolean add(ValueHolder e){
  return e != null && super.add(e);
}",0.9171974522292994
49774,"public void clearLock(){
  if (lock != null) {
    lock.clear();
  }
}","public void clearLock(){
  lock=null;
}",0.7155963302752294
49775,"public void setMultiValues(Set<Data> lsValues){
  if (lsValues != null || optionalInfo != null) {
    this.getOptionalInfo().lsMultiValues=lsValues;
  }
}","public void setMultiValues(Set<ValueHolder> lsValues){
  if (lsValues != null || optionalInfo != null) {
    this.getOptionalInfo().lsMultiValues=lsValues;
  }
}",0.9587301587301588
49776,"public Set<Data> getMultiValues(){
  if (optionalInfo == null)   return null;
  return getOptionalInfo().lsMultiValues;
}","public Set<ValueHolder> getMultiValues(){
  if (optionalInfo == null)   return null;
  return getOptionalInfo().lsMultiValues;
}",0.9477911646586346
49777,"public void setMultiValues(Set<Data> lsValues){
}","public void setMultiValues(Set<ValueHolder> lsValues){
}",0.8761904761904762
49778,"public Set<Data> getMultiValues(){
  return null;
}","public Set<ValueHolder> getMultiValues(){
  return null;
}",0.8807339449541285
49779,"public Object poll(String name,long timeout) throws InterruptedException {
  if (timeout == -1) {
    timeout=Long.MAX_VALUE;
  }
  Object removedItem=null;
  long start=System.currentTimeMillis();
  while (removedItem == null && timeout >= 0) {
    Data key=takeKey(name,timeout);
    if (key == null) {
      return null;
    }
    IMap imap=getStorageMap(name);
    try {
      removedItem=imap.tryRemove(key,0,TimeUnit.MILLISECONDS);
      if (removedItem != null) {
        ThreadContext threadContext=ThreadContext.get();
        TransactionImpl txn=threadContext.getCallContext().getTransaction();
        if (txn != null && txn.getStatus() == Transaction.TXN_STATUS_ACTIVE) {
          txn.attachRemoveOp(name,key,removedItem,true);
        }
      }
    }
 catch (    TimeoutException e) {
    }
    long now=System.currentTimeMillis();
    timeout-=(now - start);
    start=now;
  }
  return removedItem;
}","public Object poll(final String name,long timeout) throws InterruptedException {
  if (timeout == -1) {
    timeout=Long.MAX_VALUE;
  }
  Object removedItem=null;
  long start=System.currentTimeMillis();
  while (removedItem == null && timeout >= 0) {
    Data key=takeKey(name,timeout);
    if (key == null) {
      return null;
    }
    IMap imap=getStorageMap(name);
    try {
      removedItem=imap.tryRemove(key,0,TimeUnit.MILLISECONDS);
      if (removedItem != null) {
        ThreadContext threadContext=ThreadContext.get();
        TransactionImpl txn=threadContext.getCallContext().getTransaction();
        if (txn != null && txn.getStatus() == Transaction.TXN_STATUS_ACTIVE) {
          txn.attachRemoveOp(name,key,removedItem,true);
        }
        final Data removedItemData=toData(removedItem);
        final BQ bq=getBQ(name);
        if (bq != null && bq.mapListeners.size() > 0) {
          enqueueAndReturn(new Processable(){
            public void process(){
              fireMapEvent(bq.mapListeners,name,EntryEvent.TYPE_REMOVED,removedItemData,thisAddress);
            }
          }
);
        }
      }
    }
 catch (    TimeoutException e) {
    }
    long now=System.currentTimeMillis();
    timeout-=(now - start);
    start=now;
  }
  return removedItem;
}",0.8308390022675737
49780,"public boolean offer(String name,Object obj,int index,long timeout) throws InterruptedException {
  Long key=generateKey(name,timeout);
  ThreadContext threadContext=ThreadContext.get();
  TransactionImpl txn=threadContext.getCallContext().getTransaction();
  if (key != -1) {
    if (txn != null && txn.getStatus() == Transaction.TXN_STATUS_ACTIVE) {
      txn.attachPutOp(name,key,obj,timeout,true);
    }
 else {
      storeQueueItem(name,key,obj,index);
    }
    return true;
  }
  return false;
}","public boolean offer(final String name,Object obj,int index,long timeout) throws InterruptedException {
  Long key=generateKey(name,timeout);
  ThreadContext threadContext=ThreadContext.get();
  TransactionImpl txn=threadContext.getCallContext().getTransaction();
  if (key != -1) {
    if (txn != null && txn.getStatus() == Transaction.TXN_STATUS_ACTIVE) {
      txn.attachPutOp(name,key,obj,timeout,true);
    }
 else {
      final Data dataItem=toData(obj);
      storeQueueItem(name,key,dataItem,index);
      final BQ bq=getBQ(name);
      if (bq != null && bq.mapListeners.size() > 0) {
        enqueueAndReturn(new Processable(){
          public void process(){
            fireMapEvent(bq.mapListeners,name,EntryEvent.TYPE_ADDED,dataItem,thisAddress);
          }
        }
);
      }
    }
    return true;
  }
  return false;
}",0.6880597014925374
49781,"public void addItemListener(final String name,final ItemListener listener,final boolean includeValue){
  IMap map=getStorageMap(name);
  map.addEntryListener(new QueueItemListener(listener,includeValue),includeValue);
}","public void addItemListener(final String name,final ItemListener listener,final boolean includeValue){
  node.listenerManager.addListener(name,listener,null,includeValue,Instance.InstanceType.QUEUE);
}",0.5380952380952381
49782,"protected void customRun() throws InterruptedException {
  if (reconnection.get()) {
    Thread.sleep(50L);
    return;
  }
  try {
    boolean written=false;
    if (queue.size() > 0 || q.size() > 0) {
      queue.drainTo(q);
      Call call=q.poll();
      while (call != null) {
        writeCall(call);
        written=true;
        call=q.poll();
      }
    }
    try {
      if (written) {
        writer.flush(connection);
      }
    }
 catch (    IOException e) {
      clusterIsDown(connection);
    }
    Call call=queue.poll(12,TimeUnit.MILLISECONDS);
    if (call != null) {
      writeCall(call);
      try {
        writer.flush(connection);
      }
 catch (      IOException e) {
        clusterIsDown(connection);
      }
    }
    if (reconnectionCalls.size() > 0) {
      checkOnReconnect(call);
    }
  }
 catch (  Throwable e) {
    logger.log(Level.FINE,""String_Node_Str"" + connection + ""String_Node_Str""+ e.toString(),e);
  }
}","protected void customRun() throws InterruptedException {
  if (reconnection.get()) {
    Thread.sleep(50L);
    return;
  }
  try {
    boolean written=false;
    if (queue.size() > 0 || q.size() > 0) {
      queue.drainTo(q,q.available());
      Call call=q.poll();
      while (call != null) {
        writeCall(call);
        written=true;
        call=q.poll();
      }
    }
    try {
      if (written) {
        writer.flush(connection);
      }
    }
 catch (    IOException e) {
      clusterIsDown(connection);
    }
    Call call=queue.poll(12,TimeUnit.MILLISECONDS);
    if (call != null) {
      writeCall(call);
      try {
        writer.flush(connection);
      }
 catch (      IOException e) {
        clusterIsDown(connection);
      }
    }
    if (reconnectionCalls.size() > 0) {
      checkOnReconnect(call);
    }
  }
 catch (  Throwable e) {
    logger.log(Level.FINE,""String_Node_Str"" + connection + ""String_Node_Str""+ e.toString(),e);
  }
}",0.9926931106471816
49783,"@Override public boolean add(E obj){
  if (size == maxSize)   return false;
  objects[add]=obj;
  add++;
  size++;
  if (add == maxSize) {
    add=0;
  }
  return true;
}","@Override public boolean add(E obj){
  if (size == maxSize) {
    return false;
  }
  objects[add]=obj;
  add++;
  size++;
  if (add == maxSize) {
    add=0;
  }
  return true;
}",0.9770114942528736
49784,"public void entryAdded(EntryEvent<String,String> event){
  assertEquals(""String_Node_Str"",event.getValue());
  assertEquals(""String_Node_Str"",event.getKey());
  latchAdded.countDown();
}","public void entryAdded(EntryEvent event){
  System.out.println(event);
  latch.countDown();
}",0.5806451612903226
49785,"public void entryUpdated(EntryEvent<String,String> event){
  assertEquals(""String_Node_Str"",event.getOldValue());
  assertEquals(""String_Node_Str"",event.getValue());
  assertEquals(""String_Node_Str"",event.getKey());
  latchUpdated.countDown();
}","public void entryUpdated(EntryEvent event){
}",0.3103448275862069
49786,"public void entryEvicted(EntryEvent<String,String> event){
  entryRemoved(event);
}","public void entryEvicted(EntryEvent event){
}",0.703125
49787,"public void entryRemoved(EntryEvent<String,String> event){
  assertEquals(""String_Node_Str"",event.getKey());
  assertEquals(""String_Node_Str"",event.getValue());
  latchRemoved.countDown();
}","public void entryRemoved(EntryEvent event){
}",0.3829787234042553
49788,"@Override public void readData(DataInput in) throws IOException {
  packetVersion=in.readByte();
  buildNumber=in.readInt();
  boolean hasTo=in.readBoolean();
  if (hasTo) {
    to=new Address();
    to.readData(in);
  }
  address=new Address();
  address.readData(in);
  nodeType=NodeType.create(in.readInt());
  config=new Config();
  config.readData(in);
  boolean hasCredentials=in.readBoolean();
  if (hasCredentials) {
    credentials=(Credentials)SerializationHelper.readObject(in);
    credentials.setEndpoint(address.getHost());
  }
}","@Override public void readData(DataInput in) throws IOException {
  packetVersion=in.readByte();
  buildNumber=in.readInt();
  boolean hasTo=in.readBoolean();
  if (hasTo) {
    to=new Address();
    to.readData(in);
  }
  address=new Address();
  address.readData(in);
  nodeType=NodeType.create(in.readInt());
  config=new Config();
  config.readData(in);
  boolean hasCredentials=in.readBoolean();
  if (hasCredentials) {
    credentials=(Credentials)SerializationHelper.readObject(in);
    if (credentials != null) {
      credentials.setEndpoint(address.getHost());
    }
  }
}",0.9653333333333334
49789,"void callListeners(DataAwareEntryEvent dataAwareEntryEvent){
  List<ListenerItem> listeners=getOrCreateListenerList(dataAwareEntryEvent.getLongName());
  for (  ListenerItem listenerItem : listeners) {
    if (listenerItem.listens(dataAwareEntryEvent)) {
      callListener(listenerItem,dataAwareEntryEvent);
    }
  }
}","void callListeners(DataAwareEntryEvent dataAwareEntryEvent){
  List<ListenerItem> listeners=getOrCreateListenerList(dataAwareEntryEvent.getLongName());
  for (  ListenerItem listenerItem : listeners) {
    if (listenerItem.listens(dataAwareEntryEvent)) {
      try {
        callListener(listenerItem,dataAwareEntryEvent);
      }
 catch (      Throwable e) {
        logger.log(Level.SEVERE,""String_Node_Str"" + e.getMessage(),e);
      }
    }
  }
}",0.8311688311688312
49790,"public void handleMap(Node node){
  BeanDefinitionBuilder mapConfigBuilder=createBeanBuilder(MapConfig.class,""String_Node_Str"");
  final AbstractBeanDefinition beanDefinition=mapConfigBuilder.getBeanDefinition();
  final Node attName=node.getAttributes().getNamedItem(""String_Node_Str"");
  final String name=getValue(attName);
  mapConfigBuilder.addPropertyValue(""String_Node_Str"",name);
  fillValues(node,mapConfigBuilder,""String_Node_Str"",""String_Node_Str"");
  for (  org.w3c.dom.Node n : new IterableNodeList(node.getChildNodes(),Node.ELEMENT_NODE)) {
    final String nname=cleanNodeName(n.getNodeName());
    if (""String_Node_Str"".equals(nname)) {
      handleMapStoreConfig(n,mapConfigBuilder);
    }
 else     if (""String_Node_Str"".equals(nname)) {
      handleNearCacheConfig(n,mapConfigBuilder);
    }
 else     if (""String_Node_Str"".equals(nname)) {
      final BeanDefinitionBuilder wanReplicationRefBuilder=createBeanBuilder(WanReplicationRef.class,""String_Node_Str"");
      final AbstractBeanDefinition wanReplicationRefBeanDefinition=wanReplicationRefBuilder.getBeanDefinition();
      fillValues(n,wanReplicationRefBuilder);
      mapConfigBuilder.addPropertyValue(""String_Node_Str"",wanReplicationRefBeanDefinition);
    }
  }
  mapConfigManagedMap.put(name,beanDefinition);
  mapConfigBuilder=null;
}","public void handleMap(Node node){
  BeanDefinitionBuilder mapConfigBuilder=createBeanBuilder(MapConfig.class,""String_Node_Str"");
  final AbstractBeanDefinition beanDefinition=mapConfigBuilder.getBeanDefinition();
  final Node attName=node.getAttributes().getNamedItem(""String_Node_Str"");
  final String name=getValue(attName);
  mapConfigBuilder.addPropertyValue(""String_Node_Str"",name);
  fillAttributeValues(node,mapConfigBuilder,""String_Node_Str"",""String_Node_Str"");
  final BeanDefinitionBuilder maxSizeConfigBuilder=createBeanBuilder(MaxSizeConfig.class,""String_Node_Str"");
  final AbstractBeanDefinition maxSizeConfigBeanDefinition=maxSizeConfigBuilder.getBeanDefinition();
  mapConfigBuilder.addPropertyValue(""String_Node_Str"",maxSizeConfigBeanDefinition);
  final Node maxSizeNode=node.getAttributes().getNamedItem(""String_Node_Str"");
  if (maxSizeNode != null) {
    maxSizeConfigBuilder.addPropertyValue(""String_Node_Str"",getValue(maxSizeNode));
  }
  final Node maxSizePolicyNode=node.getAttributes().getNamedItem(""String_Node_Str"");
  if (maxSizePolicyNode != null) {
    maxSizeConfigBuilder.addPropertyValue(xmlToJavaName(cleanNodeName(maxSizePolicyNode)),getValue(maxSizePolicyNode));
  }
  for (  org.w3c.dom.Node n : new IterableNodeList(node.getChildNodes(),Node.ELEMENT_NODE)) {
    final String nname=cleanNodeName(n.getNodeName());
    if (""String_Node_Str"".equals(nname)) {
      handleMapStoreConfig(n,mapConfigBuilder);
    }
 else     if (""String_Node_Str"".equals(nname)) {
      handleNearCacheConfig(n,mapConfigBuilder);
    }
 else     if (""String_Node_Str"".equals(nname)) {
      final BeanDefinitionBuilder wanReplicationRefBuilder=createBeanBuilder(WanReplicationRef.class,""String_Node_Str"");
      final AbstractBeanDefinition wanReplicationRefBeanDefinition=wanReplicationRefBuilder.getBeanDefinition();
      fillValues(n,wanReplicationRefBuilder);
      mapConfigBuilder.addPropertyValue(""String_Node_Str"",wanReplicationRefBeanDefinition);
    }
  }
  mapConfigManagedMap.put(name,beanDefinition);
  mapConfigBuilder=null;
}",0.7798518518518519
49791,"protected void parseSystemProps(){
  version=System.getProperty(""String_Node_Str"",""String_Node_Str"");
  build=System.getProperty(""String_Node_Str"",""String_Node_Str"");
  if (""String_Node_Str"".equals(version) || ""String_Node_Str"".equals(build)) {
    try {
      InputStream inRuntimeProperties=NodeInitializer.class.getClassLoader().getResourceAsStream(""String_Node_Str"");
      if (inRuntimeProperties != null) {
        Properties runtimeProperties=new Properties();
        runtimeProperties.load(inRuntimeProperties);
        version=runtimeProperties.getProperty(""String_Node_Str"");
        build=runtimeProperties.getProperty(""String_Node_Str"");
      }
    }
 catch (    Exception ignored) {
    }
  }
  try {
    buildNumber=Integer.getInteger(""String_Node_Str"",-1);
    if (buildNumber == -1) {
      buildNumber=Integer.parseInt(build);
    }
  }
 catch (  Exception ignored) {
  }
}","protected void parseSystemProps(){
  version=System.getProperty(""String_Node_Str"",""String_Node_Str"");
  build=System.getProperty(""String_Node_Str"",""String_Node_Str"");
  if (""String_Node_Str"".equals(version) || ""String_Node_Str"".equals(build)) {
    try {
      final InputStream inRuntimeProperties=NodeInitializer.class.getClassLoader().getResourceAsStream(""String_Node_Str"");
      if (inRuntimeProperties != null) {
        Properties runtimeProperties=new Properties();
        runtimeProperties.load(inRuntimeProperties);
        inRuntimeProperties.close();
        version=runtimeProperties.getProperty(""String_Node_Str"");
        build=runtimeProperties.getProperty(""String_Node_Str"");
      }
    }
 catch (    Exception ignored) {
    }
  }
  try {
    buildNumber=Integer.getInteger(""String_Node_Str"",-1);
    if (buildNumber == -1) {
      buildNumber=Integer.parseInt(build);
    }
  }
 catch (  Exception ignored) {
  }
}",0.976464148877942
49792,"public void destroy(){
}","public void destroy(){
  logger.log(Level.INFO,""String_Node_Str"");
}",0.5217391304347826
49793,"public JoinInfo receive(){
synchronized (receiveLock) {
    try {
      inflatingBuffer.reset();
      try {
        multicastSocket.receive(datagramPacketReceive);
      }
 catch (      SocketTimeoutException ignore) {
        return null;
      }
      try {
        inflatingBuffer.inflate(datagramPacketReceive.getLength());
        JoinInfo joinInfo=new JoinInfo();
        joinInfo.readData(inflatingBuffer.getDataInput());
        return joinInfo;
      }
 catch (      DataFormatException e) {
        logger.log(Level.FINEST,""String_Node_Str"" + ""String_Node_Str"",e);
      }
    }
 catch (    Exception e) {
      logger.log(Level.WARNING,e.getMessage(),e);
    }
    return null;
  }
}","public JoinInfo receive(){
synchronized (receiveLock) {
    try {
      inflatingBuffer.reset();
      try {
        multicastSocket.receive(datagramPacketReceive);
      }
 catch (      SocketTimeoutException ignore) {
        return null;
      }
      try {
        inflatingBuffer.inflate(datagramPacketReceive.getLength());
        JoinInfo joinInfo=new JoinInfo();
        joinInfo.readData(inflatingBuffer.getDataInput());
        return joinInfo;
      }
 catch (      Exception e) {
        if (e instanceof EOFException || e instanceof DataFormatException) {
          logger.log(Level.FINEST,""String_Node_Str"" + ""String_Node_Str"",e);
        }
 else {
          throw e;
        }
      }
    }
 catch (    Exception e) {
      logger.log(Level.WARNING,e.getMessage(),e);
    }
    return null;
  }
}",0.9096945551128818
49794,"void putAndUnlock(String name,Object key,Object value){
  MPut mput=ThreadContext.get().getCallCache(node.factory).getMPut();
  mput.txnalPut(CONCURRENT_MAP_PUT_AND_UNLOCK,name,key,value,-1,-1);
}","void putAndUnlock(String name,Object key,Object value){
  MPut mput=ThreadContext.get().getCallCache(node.factory).getMPut();
  mput.txnalPut(CONCURRENT_MAP_PUT_AND_UNLOCK,name,key,value,-1,-1);
  mput.clearRequest();
}",0.944578313253012
49795,"public Object put(Object key,Object value,long timeout,long ttl){
  long begin=System.currentTimeMillis();
  check(key);
  check(value);
  MPut mput=ThreadContext.get().getCallCache(factory).getMPut();
  Object result=mput.put(name,key,value,timeout,ttl);
  mapOperationCounter.incrementPuts(System.currentTimeMillis() - begin);
  return result;
}","public Object put(Object key,Object value,long timeout,long ttl){
  long begin=System.currentTimeMillis();
  check(key);
  check(value);
  MPut mput=ThreadContext.get().getCallCache(factory).getMPut();
  Object result=mput.put(name,key,value,timeout,ttl);
  mput.clearRequest();
  mapOperationCounter.incrementPuts(System.currentTimeMillis() - begin);
  return result;
}",0.9679218967921897
49796,"public boolean tryPut(Object key,Object value,long timeout,TimeUnit timeunit){
  long begin=System.currentTimeMillis();
  if (timeout < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + timeout);
  }
  if (timeout == 0) {
    timeout=-1;
  }
 else {
    timeout=toMillis(timeout,timeunit);
  }
  check(key);
  check(value);
  MPut mput=ThreadContext.get().getCallCache(factory).getMPut();
  Boolean result=mput.tryPut(name,key,value,timeout,-1);
  mapOperationCounter.incrementPuts(System.currentTimeMillis() - begin);
  return result;
}","public boolean tryPut(Object key,Object value,long timeout,TimeUnit timeunit){
  long begin=System.currentTimeMillis();
  if (timeout < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + timeout);
  }
  if (timeout == 0) {
    timeout=-1;
  }
 else {
    timeout=toMillis(timeout,timeunit);
  }
  check(key);
  check(value);
  MPut mput=ThreadContext.get().getCallCache(factory).getMPut();
  Boolean result=mput.tryPut(name,key,value,timeout,-1);
  mput.clearRequest();
  mapOperationCounter.incrementPuts(System.currentTimeMillis() - begin);
  return result;
}",0.9795555555555556
49797,"public void removeForSync(Object key){
  long begin=System.currentTimeMillis();
  check(key);
  MRemove mremove=ThreadContext.get().getCallCache(factory).getMRemove();
  mremove.removeForSync(name,key);
  mapOperationCounter.incrementRemoves(System.currentTimeMillis() - begin);
}","public void removeForSync(Object key){
  long begin=System.currentTimeMillis();
  check(key);
  MRemove mremove=ThreadContext.get().getCallCache(factory).getMRemove();
  mremove.removeForSync(name,key);
  mremove.clearRequest();
  mapOperationCounter.incrementRemoves(System.currentTimeMillis() - begin);
}",0.955631399317406
49798,"public void putForSync(Object key,Object value){
  long begin=System.currentTimeMillis();
  check(key);
  check(value);
  MPut mput=ThreadContext.get().getCallCache(factory).getMPut();
  mput.putForSync(name,key,value);
  mapOperationCounter.incrementPuts(System.currentTimeMillis() - begin);
}","public void putForSync(Object key,Object value){
  long begin=System.currentTimeMillis();
  check(key);
  check(value);
  MPut mput=ThreadContext.get().getCallCache(factory).getMPut();
  mput.putForSync(name,key,value);
  mput.clearRequest();
  mapOperationCounter.incrementPuts(System.currentTimeMillis() - begin);
}",0.962356792144026
49799,"public Object tryRemove(Object key,long timeout,TimeUnit timeunit) throws TimeoutException {
  long begin=System.currentTimeMillis();
  check(key);
  MRemove mremove=ThreadContext.get().getCallCache(factory).getMRemove();
  Object result=mremove.tryRemove(name,key,toMillis(timeout,timeunit));
  mapOperationCounter.incrementRemoves(System.currentTimeMillis() - begin);
  return result;
}","public Object tryRemove(Object key,long timeout,TimeUnit timeunit) throws TimeoutException {
  long begin=System.currentTimeMillis();
  check(key);
  MRemove mremove=ThreadContext.get().getCallCache(factory).getMRemove();
  Object result=mremove.tryRemove(name,key,toMillis(timeout,timeunit));
  mremove.clearRequest();
  mapOperationCounter.incrementRemoves(System.currentTimeMillis() - begin);
  return result;
}",0.9675810473815462
49800,"public Object get(Object key){
  check(key);
  long begin=System.currentTimeMillis();
  MGet mget=ThreadContext.get().getCallCache(factory).getMGet();
  Object result=mget.get(name,key,-1);
  if (result == null && name.contains(""String_Node_Str"")) {
    boolean isClient=ThreadContext.get().isClient();
    Object txn=ThreadContext.get().getTransaction();
    throw new RuntimeException(result + ""String_Node_Str"" + isClient+ ""String_Node_Str""+ txn);
  }
  mapOperationCounter.incrementGets(System.currentTimeMillis() - begin);
  return result;
}","public Object get(Object key){
  check(key);
  long begin=System.currentTimeMillis();
  MGet mget=ThreadContext.get().getCallCache(factory).getMGet();
  Object result=mget.get(name,key,-1);
  mget.clearRequest();
  if (result == null && name.contains(""String_Node_Str"")) {
    boolean isClient=ThreadContext.get().isClient();
    Object txn=ThreadContext.get().getTransaction();
    throw new RuntimeException(result + ""String_Node_Str"" + isClient+ ""String_Node_Str""+ txn);
  }
  mapOperationCounter.incrementGets(System.currentTimeMillis() - begin);
  return result;
}",0.979372197309417
49801,"public Object putIfAbsent(Object key,Object value,long timeout,long ttl){
  long begin=System.currentTimeMillis();
  check(key);
  check(value);
  MPut mput=concurrentMapManager.new MPut();
  Object result=mput.putIfAbsent(name,key,value,timeout,ttl);
  mapOperationCounter.incrementPuts(System.currentTimeMillis() - begin);
  return result;
}","public Object putIfAbsent(Object key,Object value,long timeout,long ttl){
  long begin=System.currentTimeMillis();
  check(key);
  check(value);
  MPut mput=concurrentMapManager.new MPut();
  Object result=mput.putIfAbsent(name,key,value,timeout,ttl);
  mput.clearRequest();
  mapOperationCounter.incrementPuts(System.currentTimeMillis() - begin);
  return result;
}",0.9675599435825106
49802,"public Object toObject(byte[] byteArray){
  if (byteArray == null || byteArray.length == 0) {
    return null;
  }
  this.bbis.set(byteArray,byteArray.length);
  return toObject(this.bbis);
}","public Object toObject(byte[] byteArray){
  if (byteArray == null || byteArray.length == 0) {
    return null;
  }
  this.bbis.set(byteArray,byteArray.length);
  final Object obj=toObject(this.bbis);
  this.bbis.set(null,0);
  return obj;
}",0.765661252900232
49803,"@Override public int hashCode(){
  if (buffer == null)   return Integer.MIN_VALUE;
  final int prime=0x01000193;
  int hash=0x811c9dc5;
  final byte[] data=buffer;
  for (int i=data.length - 1; i > 1; i--) {
    hash=(hash ^ data[i]) * prime;
  }
  return hash;
}","@Override public int hashCode(){
  if (buffer == null)   return Integer.MIN_VALUE;
  final int prime=0x01000193;
  int hash=0x811c9dc5;
  final byte[] data=buffer;
  for (int i=data.length - 1; i >= 0; i--) {
    hash=(hash ^ data[i]) * prime;
  }
  return hash;
}",0.9905123339658444
49804,"/** 
 * Test case for issue 323
 */
@Test public void testSuperClientWithQueues(){
  Config configSuperClient=new Config();
  configSuperClient.setSuperClient(true);
  HazelcastInstance hNormal=Hazelcast.newHazelcastInstance(new Config());
  final HazelcastInstance hSuper=Hazelcast.newHazelcastInstance(configSuperClient);
  final Queue qSuper=hSuper.getQueue(""String_Node_Str"");
  final Queue qNormal=hNormal.getQueue(""String_Node_Str"");
  for (int i=0; i < 12000; i++) {
    String item=""String_Node_Str"" + i;
    qSuper.offer(item);
    assertEquals(item,qNormal.poll());
  }
  for (int i=0; i < 5000; i++) {
    String item=""String_Node_Str"" + i;
    qNormal.offer(item);
    assertEquals(item,qSuper.poll());
  }
}","/** 
 * Test case for issue 323
 */
@Test public void testSuperClientWithQueues(){
  Config configSuperClient=new Config();
  configSuperClient.setLiteMember(true);
  HazelcastInstance hNormal=Hazelcast.newHazelcastInstance(new Config());
  final HazelcastInstance hSuper=Hazelcast.newHazelcastInstance(configSuperClient);
  final Queue qSuper=hSuper.getQueue(""String_Node_Str"");
  final Queue qNormal=hNormal.getQueue(""String_Node_Str"");
  for (int i=0; i < 12000; i++) {
    String item=""String_Node_Str"" + i;
    qSuper.offer(item);
    assertEquals(item,qNormal.poll());
  }
  for (int i=0; i < 5000; i++) {
    String item=""String_Node_Str"" + i;
    qNormal.offer(item);
    assertEquals(item,qSuper.poll());
  }
}",0.985406532314107
49805,"@Test(timeout=100000) public void testSuperClientPartitionOwnership() throws Exception {
  Config configSuperClient=new Config();
  configSuperClient.setSuperClient(true);
  HazelcastInstance hNormal=Hazelcast.newHazelcastInstance(new Config());
  final HazelcastInstance hSuper=Hazelcast.newHazelcastInstance(configSuperClient);
  IMap mapSuper=hSuper.getMap(""String_Node_Str"");
  IMap mapNormal=hNormal.getMap(""String_Node_Str"");
  for (int i=0; i < 1000; i++) {
    mapNormal.put(""String_Node_Str"" + i,""String_Node_Str"" + i);
  }
  for (int i=1000; i < 2000; i++) {
    mapSuper.put(""String_Node_Str"" + i,""String_Node_Str"" + i);
  }
  Set<Partition> partitions2=hSuper.getPartitionService().getPartitions();
  for (  Partition partition : partitions2) {
    assertEquals(partition.getOwner(),hNormal.getCluster().getLocalMember());
  }
  assertEquals(2000,mapNormal.size());
  assertEquals(2000,mapSuper.size());
  assertEquals(0,mapSuper.getLocalMapStats().getOwnedEntryCount());
  assertEquals(0,mapSuper.getLocalMapStats().getBackupEntryCount());
  assertEquals(2000,mapNormal.getLocalMapStats().getOwnedEntryCount());
  assertEquals(0,mapNormal.getLocalMapStats().getBackupEntryCount());
  hNormal.shutdown();
  Thread.sleep(3000);
  Set<Partition> partitions=hSuper.getPartitionService().getPartitions();
  for (  Partition partition : partitions) {
    assertNull(partition.getOwner());
  }
  hNormal=Hazelcast.newHazelcastInstance(new Config());
  partitions=hSuper.getPartitionService().getPartitions();
  for (  Partition partition : partitions) {
    assertEquals(hNormal.getCluster().getLocalMember(),partition.getOwner());
  }
  assertNull(mapSuper.put(""String_Node_Str"",""String_Node_Str""));
  hSuper.shutdown();
  partitions=hNormal.getPartitionService().getPartitions();
  for (  Partition partition : partitions) {
    assertEquals(hNormal.getCluster().getLocalMember(),partition.getOwner());
  }
  assertEquals(""String_Node_Str"",hNormal.getMap(""String_Node_Str"").get(""String_Node_Str""));
}","@Test(timeout=100000) public void testSuperClientPartitionOwnership() throws Exception {
  Config configSuperClient=new Config();
  configSuperClient.setLiteMember(true);
  HazelcastInstance hNormal=Hazelcast.newHazelcastInstance(new Config());
  final HazelcastInstance hSuper=Hazelcast.newHazelcastInstance(configSuperClient);
  IMap mapSuper=hSuper.getMap(""String_Node_Str"");
  IMap mapNormal=hNormal.getMap(""String_Node_Str"");
  for (int i=0; i < 1000; i++) {
    mapNormal.put(""String_Node_Str"" + i,""String_Node_Str"" + i);
  }
  for (int i=1000; i < 2000; i++) {
    mapSuper.put(""String_Node_Str"" + i,""String_Node_Str"" + i);
  }
  Set<Partition> partitions2=hSuper.getPartitionService().getPartitions();
  for (  Partition partition : partitions2) {
    assertEquals(partition.getOwner(),hNormal.getCluster().getLocalMember());
  }
  assertEquals(2000,mapNormal.size());
  assertEquals(2000,mapSuper.size());
  assertEquals(0,mapSuper.getLocalMapStats().getOwnedEntryCount());
  assertEquals(0,mapSuper.getLocalMapStats().getBackupEntryCount());
  assertEquals(2000,mapNormal.getLocalMapStats().getOwnedEntryCount());
  assertEquals(0,mapNormal.getLocalMapStats().getBackupEntryCount());
  hNormal.shutdown();
  Thread.sleep(3000);
  Set<Partition> partitions=hSuper.getPartitionService().getPartitions();
  for (  Partition partition : partitions) {
    assertNull(partition.getOwner());
  }
  hNormal=Hazelcast.newHazelcastInstance(new Config());
  partitions=hSuper.getPartitionService().getPartitions();
  for (  Partition partition : partitions) {
    assertEquals(hNormal.getCluster().getLocalMember(),partition.getOwner());
  }
  assertNull(mapSuper.put(""String_Node_Str"",""String_Node_Str""));
  hSuper.shutdown();
  partitions=hNormal.getPartitionService().getPartitions();
  for (  Partition partition : partitions) {
    assertEquals(hNormal.getCluster().getLocalMember(),partition.getOwner());
  }
  assertEquals(""String_Node_Str"",hNormal.getMap(""String_Node_Str"").get(""String_Node_Str""));
}",0.994769613947696
49806,"@Test public void issue388NoBackupWhenSuperClient() throws InterruptedException {
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(null);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(null);
  Config scconfig=new Config();
  scconfig.setSuperClient(true);
  HazelcastInstance sc=Hazelcast.newHazelcastInstance(scconfig);
  IMap map1=h1.getMap(""String_Node_Str"");
  IMap map2=h2.getMap(""String_Node_Str"");
  IMap map3=sc.getMap(""String_Node_Str"");
  for (int i=0; i < 300; ) {
    map1.put(i++,new byte[1000]);
    map2.put(i++,new byte[1000]);
    map3.put(i++,new byte[1000]);
  }
  assertEquals(map1.getLocalMapStats().getOwnedEntryCount(),map2.getLocalMapStats().getBackupEntryCount());
  assertEquals(map2.getLocalMapStats().getOwnedEntryCount(),map1.getLocalMapStats().getBackupEntryCount());
}","@Test public void issue388NoBackupWhenSuperClient() throws InterruptedException {
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(null);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(null);
  Config scconfig=new Config();
  scconfig.setLiteMember(true);
  HazelcastInstance sc=Hazelcast.newHazelcastInstance(scconfig);
  IMap map1=h1.getMap(""String_Node_Str"");
  IMap map2=h2.getMap(""String_Node_Str"");
  IMap map3=sc.getMap(""String_Node_Str"");
  for (int i=0; i < 300; ) {
    map1.put(i++,new byte[1000]);
    map2.put(i++,new byte[1000]);
    map3.put(i++,new byte[1000]);
  }
  assertEquals(map1.getLocalMapStats().getOwnedEntryCount(),map2.getLocalMapStats().getBackupEntryCount());
  assertEquals(map2.getLocalMapStats().getOwnedEntryCount(),map1.getLocalMapStats().getBackupEntryCount());
}",0.9870609981515712
49807,"@Test(timeout=60000) public void testSuperClientRestart() throws Exception {
  Config configNormal=new Config();
  Config configSuper=new Config();
  configSuper.setSuperClient(true);
  HazelcastInstance h=Hazelcast.newHazelcastInstance(configNormal);
  HazelcastInstance s=Hazelcast.newHazelcastInstance(configSuper);
  assertEquals(2,h.getCluster().getMembers().size());
  assertEquals(2,s.getCluster().getMembers().size());
  assertFalse(h.getCluster().getLocalMember().isSuperClient());
  assertTrue(s.getCluster().getLocalMember().isSuperClient());
  IMap map=h.getMap(""String_Node_Str"");
  final IMap maps=s.getMap(""String_Node_Str"");
  assertNull(map.put(""String_Node_Str"",""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",maps.get(""String_Node_Str""));
  assertEquals(1,map.size());
  assertEquals(1,maps.size());
  h.shutdown();
  sleep(500);
  assertEquals(1,s.getCluster().getMembers().size());
  final CountDownLatch latch=new CountDownLatch(1);
  new Thread(new Runnable(){
    public void run(){
      maps.size();
      assertNull(maps.get(""String_Node_Str""));
      maps.put(""String_Node_Str"",""String_Node_Str"");
      latch.countDown();
    }
  }
).start();
  h=Hazelcast.newHazelcastInstance(configNormal);
  latch.await();
  assertEquals(2,h.getCluster().getMembers().size());
  assertEquals(2,s.getCluster().getMembers().size());
  assertFalse(h.getCluster().getLocalMember().isSuperClient());
  assertTrue(s.getCluster().getLocalMember().isSuperClient());
  map=h.getMap(""String_Node_Str"");
  assertEquals(""String_Node_Str"",map.put(""String_Node_Str"",""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertEquals(1,map.size());
  assertEquals(1,maps.size());
}","@Test(timeout=60000) public void testSuperClientRestart() throws Exception {
  Config configNormal=new Config();
  Config configSuper=new Config();
  configSuper.setLiteMember(true);
  HazelcastInstance h=Hazelcast.newHazelcastInstance(configNormal);
  HazelcastInstance s=Hazelcast.newHazelcastInstance(configSuper);
  assertEquals(2,h.getCluster().getMembers().size());
  assertEquals(2,s.getCluster().getMembers().size());
  assertFalse(h.getCluster().getLocalMember().isSuperClient());
  assertTrue(s.getCluster().getLocalMember().isSuperClient());
  IMap map=h.getMap(""String_Node_Str"");
  final IMap maps=s.getMap(""String_Node_Str"");
  assertNull(map.put(""String_Node_Str"",""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",maps.get(""String_Node_Str""));
  assertEquals(1,map.size());
  assertEquals(1,maps.size());
  h.shutdown();
  sleep(500);
  assertEquals(1,s.getCluster().getMembers().size());
  final CountDownLatch latch=new CountDownLatch(1);
  new Thread(new Runnable(){
    public void run(){
      maps.size();
      assertNull(maps.get(""String_Node_Str""));
      maps.put(""String_Node_Str"",""String_Node_Str"");
      latch.countDown();
    }
  }
).start();
  h=Hazelcast.newHazelcastInstance(configNormal);
  latch.await();
  assertEquals(2,h.getCluster().getMembers().size());
  assertEquals(2,s.getCluster().getMembers().size());
  assertFalse(h.getCluster().getLocalMember().isSuperClient());
  assertTrue(s.getCluster().getLocalMember().isSuperClient());
  map=h.getMap(""String_Node_Str"");
  assertEquals(""String_Node_Str"",map.put(""String_Node_Str"",""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertEquals(1,map.size());
  assertEquals(1,maps.size());
}",0.9941027801179444
49808,"/** 
 * 3 node cluster: normal member(h1), super client (hSuper) and another normal member (h2) if h1 goes down, hSuper becomes the oldest member If hSuper fails to update the partition ownerships, h2.getMap(""default"").get(key) gets into infinite Re-Do.
 * @throws Exception
 */
@Test public void testSuperClientBeingOldestMember() throws Exception {
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(new Config());
  Config superConfig=new Config();
  superConfig.setSuperClient(true);
  HazelcastInstance hSuper=Hazelcast.newHazelcastInstance(superConfig);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(new Config());
  final IMap map=h2.getMap(""String_Node_Str"");
  h1.getLifecycleService().shutdown();
  final CountDownLatch latch=new CountDownLatch(1);
  new Thread(new Runnable(){
    public void run(){
      assertTrue(map.get(""String_Node_Str"") == null);
      latch.countDown();
    }
  }
).start();
  assertTrue(latch.await(10,TimeUnit.SECONDS));
}","/** 
 * 3 node cluster: normal member(h1), super client (hSuper) and another normal member (h2) if h1 goes down, hSuper becomes the oldest member If hSuper fails to update the partition ownerships, h2.getMap(""default"").get(key) gets into infinite Re-Do.
 * @throws Exception
 */
@Test public void testSuperClientBeingOldestMember() throws Exception {
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(new Config());
  Config superConfig=new Config();
  superConfig.setLiteMember(true);
  HazelcastInstance hSuper=Hazelcast.newHazelcastInstance(superConfig);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(new Config());
  final IMap map=h2.getMap(""String_Node_Str"");
  h1.getLifecycleService().shutdown();
  final CountDownLatch latch=new CountDownLatch(1);
  new Thread(new Runnable(){
    public void run(){
      assertTrue(map.get(""String_Node_Str"") == null);
      latch.countDown();
    }
  }
).start();
  assertTrue(latch.await(10,TimeUnit.SECONDS));
}",0.9891808346213292
49809,"@Test(timeout=30000) public void testSuperClientPutAfterBeforeNormalMember() throws Exception {
  final CountDownLatch latch=new CountDownLatch(1);
  final CountDownLatch latchSuperPut=new CountDownLatch(1);
  new Thread(new Runnable(){
    public void run(){
      Config config=new XmlConfigBuilder().build();
      config.setSuperClient(true);
      final HazelcastInstance hSuper=Hazelcast.newHazelcastInstance(config);
      latch.countDown();
      Map map=hSuper.getMap(""String_Node_Str"");
      map.put(""String_Node_Str"",""String_Node_Str"");
      latchSuperPut.countDown();
    }
  }
).start();
  latch.await(10,TimeUnit.SECONDS);
  HazelcastInstance hNormal=Hazelcast.newHazelcastInstance(null);
  assertTrue(latchSuperPut.await(10,TimeUnit.SECONDS));
  assertEquals(""String_Node_Str"",hNormal.getMap(""String_Node_Str"").get(""String_Node_Str""));
}","@Test(timeout=30000) public void testSuperClientPutAfterBeforeNormalMember() throws Exception {
  final CountDownLatch latch=new CountDownLatch(1);
  final CountDownLatch latchSuperPut=new CountDownLatch(1);
  new Thread(new Runnable(){
    public void run(){
      Config config=new XmlConfigBuilder().build();
      config.setLiteMember(true);
      final HazelcastInstance hSuper=Hazelcast.newHazelcastInstance(config);
      latch.countDown();
      Map map=hSuper.getMap(""String_Node_Str"");
      map.put(""String_Node_Str"",""String_Node_Str"");
      latchSuperPut.countDown();
    }
  }
).start();
  latch.await(10,TimeUnit.SECONDS);
  HazelcastInstance hNormal=Hazelcast.newHazelcastInstance(null);
  assertTrue(latchSuperPut.await(10,TimeUnit.SECONDS));
  assertEquals(""String_Node_Str"",hNormal.getMap(""String_Node_Str"").get(""String_Node_Str""));
}",0.9876977152899824
49810,"@Test public void testSuperBeingMaster() throws Exception {
  Config config=new Config();
  config.setSuperClient(true);
  final HazelcastInstance hSuper=Hazelcast.newHazelcastInstance(config);
  final HazelcastInstance hSuper2=Hazelcast.newHazelcastInstance(config);
  sleep(11000);
  HazelcastInstance hNormal=Hazelcast.newHazelcastInstance(new Config());
  Map map=hSuper.getMap(""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",hNormal.getMap(""String_Node_Str"").get(""String_Node_Str""));
  sleep(10000);
  assertEquals(""String_Node_Str"",hNormal.getMap(""String_Node_Str"").get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
}","@Test public void testSuperBeingMaster() throws Exception {
  Config config=new Config();
  config.setLiteMember(true);
  final HazelcastInstance hSuper=Hazelcast.newHazelcastInstance(config);
  final HazelcastInstance hSuper2=Hazelcast.newHazelcastInstance(config);
  sleep(11000);
  HazelcastInstance hNormal=Hazelcast.newHazelcastInstance(new Config());
  Map map=hSuper.getMap(""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",hNormal.getMap(""String_Node_Str"").get(""String_Node_Str""));
  sleep(10000);
  assertEquals(""String_Node_Str"",hNormal.getMap(""String_Node_Str"").get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
}",0.9852631578947368
49811,"@Test public void issue390NoBackupWhenSuperClient() throws InterruptedException {
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(null);
  IMap map1=h1.getMap(""String_Node_Str"");
  for (int i=0; i < 200; i++) {
    map1.put(i,new byte[1000]);
  }
  Config scconfig=new Config();
  scconfig.setSuperClient(true);
  HazelcastInstance sc=Hazelcast.newHazelcastInstance(scconfig);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(null);
  IMap map2=h2.getMap(""String_Node_Str"");
  final CountDownLatch latch=new CountDownLatch(2);
  h2.getPartitionService().addMigrationListener(new MigrationListener(){
    public void migrationStarted(    MigrationEvent migrationEvent){
    }
    public void migrationCompleted(    MigrationEvent migrationEvent){
      latch.countDown();
    }
  }
);
  assertTrue(latch.await(60,TimeUnit.SECONDS));
  System.out.println(map1.getLocalMapStats());
  System.out.println(map2.getLocalMapStats());
  assertEquals(map2.getLocalMapStats().getOwnedEntryCount(),map1.getLocalMapStats().getBackupEntryCount());
  assertEquals(map1.getLocalMapStats().getOwnedEntryCount(),map2.getLocalMapStats().getBackupEntryCount());
}","@Test public void issue390NoBackupWhenSuperClient() throws InterruptedException {
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(null);
  IMap map1=h1.getMap(""String_Node_Str"");
  for (int i=0; i < 200; i++) {
    map1.put(i,new byte[1000]);
  }
  Config scconfig=new Config();
  scconfig.setLiteMember(true);
  HazelcastInstance sc=Hazelcast.newHazelcastInstance(scconfig);
  HazelcastInstance h2=Hazelcast.newHazelcastInstance(null);
  IMap map2=h2.getMap(""String_Node_Str"");
  final CountDownLatch latch=new CountDownLatch(2);
  h2.getPartitionService().addMigrationListener(new MigrationListener(){
    public void migrationStarted(    MigrationEvent migrationEvent){
    }
    public void migrationCompleted(    MigrationEvent migrationEvent){
      latch.countDown();
    }
  }
);
  assertTrue(latch.await(60,TimeUnit.SECONDS));
  System.out.println(map1.getLocalMapStats());
  System.out.println(map2.getLocalMapStats());
  assertEquals(map2.getLocalMapStats().getOwnedEntryCount(),map1.getLocalMapStats().getBackupEntryCount());
  assertEquals(map1.getLocalMapStats().getOwnedEntryCount(),map2.getLocalMapStats().getBackupEntryCount());
}",0.9908972691807544
49812,"@Test public void testInitialization(){
  Config config=new Config();
  MapConfig mapConfig=config.getMapConfig(""String_Node_Str"");
  MapStoreConfig msConfig=new MapStoreConfig();
  mapConfig.setMapStoreConfig(msConfig);
  msConfig.setEnabled(true);
  Config configSuper=new Config();
  configSuper.setSuperClient(true);
  configSuper.addMapConfig(mapConfig);
  final int initialKeys=5;
  msConfig.setImplementation(new MapLoader(){
    public Object load(    Object key){
      return ""String_Node_Str"" + key;
    }
    public Map loadAll(    Collection keys){
      Map map=new HashMap(keys.size());
      for (      Object key : keys) {
        map.put(key,load(key));
      }
      return map;
    }
    public Set loadAllKeys(){
      Set keys=new HashSet(3);
      for (int i=0; i < initialKeys; i++) {
        keys.add(i);
      }
      return keys;
    }
  }
);
  final HazelcastInstance member=Hazelcast.newHazelcastInstance(config);
  final HazelcastInstance superClient=Hazelcast.newHazelcastInstance(configSuper);
  Hazelcast.newHazelcastInstance(config);
  assertEquals(initialKeys,member.getMap(""String_Node_Str"").size());
  assertEquals(initialKeys,superClient.getMap(""String_Node_Str"").size());
  assertEquals(initialKeys,superClient.getMap(""String_Node_Str"").size());
  assertEquals(initialKeys,member.getMap(""String_Node_Str"").size());
  Hazelcast.shutdownAll();
}","@Test public void testInitialization(){
  Config config=new Config();
  MapConfig mapConfig=config.getMapConfig(""String_Node_Str"");
  MapStoreConfig msConfig=new MapStoreConfig();
  mapConfig.setMapStoreConfig(msConfig);
  msConfig.setEnabled(true);
  Config configSuper=new Config();
  configSuper.setLiteMember(true);
  configSuper.addMapConfig(mapConfig);
  final int initialKeys=5;
  msConfig.setImplementation(new MapLoader(){
    public Object load(    Object key){
      return ""String_Node_Str"" + key;
    }
    public Map loadAll(    Collection keys){
      Map map=new HashMap(keys.size());
      for (      Object key : keys) {
        map.put(key,load(key));
      }
      return map;
    }
    public Set loadAllKeys(){
      Set keys=new HashSet(3);
      for (int i=0; i < initialKeys; i++) {
        keys.add(i);
      }
      return keys;
    }
  }
);
  final HazelcastInstance member=Hazelcast.newHazelcastInstance(config);
  final HazelcastInstance superClient=Hazelcast.newHazelcastInstance(configSuper);
  Hazelcast.newHazelcastInstance(config);
  assertEquals(initialKeys,member.getMap(""String_Node_Str"").size());
  assertEquals(initialKeys,superClient.getMap(""String_Node_Str"").size());
  assertEquals(initialKeys,superClient.getMap(""String_Node_Str"").size());
  assertEquals(initialKeys,member.getMap(""String_Node_Str"").size());
  Hazelcast.shutdownAll();
}",0.992399565689468
49813,"@Test public void testThreeMemberInit() throws Exception {
  TestEventBasedMapStore testMapStore=new TestEventBasedMapStore();
  testMapStore.setLoadAllKeys(true);
  Map store=testMapStore.getStore();
  Set keys=new HashSet();
  int size=10000;
  for (int i=0; i < size; i++) {
    store.put(i,""String_Node_Str"" + i);
    keys.add(i);
  }
  Config config=newConfig(testMapStore,2);
  final HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  final HazelcastInstance h2=Hazelcast.newHazelcastInstance(config);
  final HazelcastInstance h3=Hazelcast.newHazelcastInstance(config);
  final HazelcastInstance[] instances=new HazelcastInstance[]{h1,h2,h3};
  final Random random=new Random();
  final CountDownLatch latch=new CountDownLatch(50);
  for (int i=0; i < 50; i++) {
    new Thread(new Runnable(){
      public void run(){
        instances[random.nextInt(100) % 3].getMap(""String_Node_Str"");
        latch.countDown();
      }
    }
).start();
  }
  Assert.assertTrue(latch.await(100,TimeUnit.SECONDS));
  assertEquals(15,testMapStore.callCount.get());
  IMap map1=h1.getMap(""String_Node_Str"");
  IMap map2=h2.getMap(""String_Node_Str"");
  IMap map3=h3.getMap(""String_Node_Str"");
  for (int i=0; i < size; i++) {
    assertEquals(""String_Node_Str"" + i,map3.get(i));
  }
  assertEquals(15,testMapStore.callCount.get());
}","@Test public void testThreeMemberInit() throws Exception {
  TestEventBasedMapStore testMapStore=new TestEventBasedMapStore();
  testMapStore.setLoadAllKeys(true);
  Map store=testMapStore.getStore();
  Set keys=new HashSet();
  int size=10000;
  for (int i=0; i < size; i++) {
    store.put(i,""String_Node_Str"" + i);
    keys.add(i);
  }
  Config config=newConfig(testMapStore,2);
  final HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  final HazelcastInstance h2=Hazelcast.newHazelcastInstance(config);
  final HazelcastInstance h3=Hazelcast.newHazelcastInstance(config);
  final HazelcastInstance[] instances=new HazelcastInstance[]{h1,h2,h3};
  final Random random=new Random();
  final CountDownLatch latch=new CountDownLatch(50);
  for (int i=0; i < 50; i++) {
    new Thread(new Runnable(){
      public void run(){
        instances[random.nextInt(100) % 3].getMap(""String_Node_Str"");
        latch.countDown();
      }
    }
).start();
  }
  assertTrue(latch.await(100,TimeUnit.SECONDS));
  assertTrue(testMapStore.callCount.get() >= 13);
  assertTrue(testMapStore.callCount.get() <= 15);
  IMap map1=h1.getMap(""String_Node_Str"");
  IMap map2=h2.getMap(""String_Node_Str"");
  IMap map3=h3.getMap(""String_Node_Str"");
  for (int i=0; i < size; i++) {
    assertEquals(""String_Node_Str"" + i,map3.get(i));
  }
  assertTrue(testMapStore.callCount.get() >= 13);
  assertTrue(testMapStore.callCount.get() <= 15);
}",0.745750452079566
49814,"public ClientProperties setProperties(final Map<String,String> properties){
  for (  final Entry<String,String> entry : properties.entrySet()) {
    setPropertyValue(entry.getKey(),entry.getValue());
  }
  return this;
}","public ClientProperties setProperties(final Map<ClientPropertyName,String> properties){
  for (  final Entry<ClientPropertyName,String> entry : properties.entrySet()) {
    setPropertyValue(entry.getKey(),entry.getValue());
  }
  return this;
}",0.896551724137931
49815,"public void handle(Element element){
  ManagedMap properties=new ManagedMap();
  final NamedNodeMap atts=element.getAttributes();
  if (atts != null) {
    for (int a=0; a < atts.getLength(); a++) {
      final org.w3c.dom.Node att=atts.item(a);
      String name=att.getNodeName();
      final String value=att.getNodeValue();
      if (""String_Node_Str"".equals(name)) {
        name=ClientProperties.ClientPropertyName.GROUP_NAME.getName();
      }
 else       if (""String_Node_Str"".equals(name)) {
        name=ClientProperties.ClientPropertyName.GROUP_PASSWORD.getName();
      }
 else {
        continue;
      }
      properties.put(name,value);
    }
  }
  for (  org.w3c.dom.Node node : new IterableNodeList(element,Node.ELEMENT_NODE)) {
    final String nodeName=cleanNodeName(node.getNodeName());
    if (""String_Node_Str"".equals(nodeName)) {
      members.add(getValue(node));
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      for (      org.w3c.dom.Node n : new IterableNodeList(node.getChildNodes(),Node.ELEMENT_NODE)) {
        final String name=cleanNodeName(n.getNodeName());
        final String propertyName;
        if (""String_Node_Str"".equals(name)) {
          propertyName=getTextContent(n.getAttributes().getNamedItem(""String_Node_Str"")).trim();
          final String value=getValue(n);
          properties.put(propertyName,value);
        }
      }
    }
  }
  propertiesBuilder.addPropertyValue(""String_Node_Str"",properties);
  this.builder.addConstructorArgValue(propertiesBuilder.getBeanDefinition());
  this.builder.addConstructorArgValue(members);
}","public void handle(Element element){
  ManagedMap properties=new ManagedMap();
  final NamedNodeMap atts=element.getAttributes();
  if (atts != null) {
    for (int a=0; a < atts.getLength(); a++) {
      final org.w3c.dom.Node att=atts.item(a);
      String name=att.getNodeName();
      ClientProperties.ClientPropertyName key;
      final String value=att.getNodeValue();
      if (""String_Node_Str"".equals(name)) {
        key=ClientProperties.ClientPropertyName.GROUP_NAME;
      }
 else       if (""String_Node_Str"".equals(name)) {
        key=ClientProperties.ClientPropertyName.GROUP_PASSWORD;
      }
 else {
        continue;
      }
      properties.put(key,value);
    }
  }
  for (  org.w3c.dom.Node node : new IterableNodeList(element,Node.ELEMENT_NODE)) {
    final String nodeName=cleanNodeName(node.getNodeName());
    if (""String_Node_Str"".equals(nodeName)) {
      members.add(getValue(node));
    }
 else     if (""String_Node_Str"".equals(nodeName)) {
      for (      org.w3c.dom.Node n : new IterableNodeList(node.getChildNodes(),Node.ELEMENT_NODE)) {
        final String name=cleanNodeName(n.getNodeName());
        final String propertyName;
        if (""String_Node_Str"".equals(name)) {
          propertyName=getTextContent(n.getAttributes().getNamedItem(""String_Node_Str"")).trim();
          final String value=getValue(n);
          properties.put(propertyName,value);
        }
      }
    }
  }
  propertiesBuilder.addPropertyValue(""String_Node_Str"",properties);
  this.builder.addConstructorArgValue(propertiesBuilder.getBeanDefinition());
  this.builder.addConstructorArgValue(members);
}",0.9726197884256378
49816,"@Test public void testInstance(){
  assertNotNull(instance);
  final Set<Member> members=instance.getCluster().getMembers();
  assertEquals(1,members.size());
  final Member member=members.iterator().next();
  final InetSocketAddress inetSocketAddress=member.getInetSocketAddress();
  assertEquals(5800,inetSocketAddress.getPort());
  assertEquals(""String_Node_Str"",config.getInstanceName());
}","@Test public void testInstance(){
  assertNotNull(instance);
  final Set<Member> members=instance.getCluster().getMembers();
  assertEquals(1,members.size());
  final Member member=members.iterator().next();
  final InetSocketAddress inetSocketAddress=member.getInetSocketAddress();
  assertEquals(5700,inetSocketAddress.getPort());
  assertEquals(""String_Node_Str"",config.getInstanceName());
}",0.9974619289340102
49817,"@Test public void testNetworkConfig(){
  NetworkConfig networkConfig=config.getNetworkConfig();
  assertNotNull(networkConfig);
  assertEquals(5800,config.getPort());
  assertFalse(config.isPortAutoIncrement());
  assertFalse(networkConfig.getJoin().getMulticastConfig().isEnabled());
  assertFalse(networkConfig.getInterfaces().isEnabled());
  assertEquals(1,networkConfig.getInterfaces().getInterfaces().size());
  assertEquals(""String_Node_Str"",networkConfig.getInterfaces().getInterfaces().iterator().next());
  TcpIpConfig tcp=networkConfig.getJoin().getTcpIpConfig();
  assertNotNull(tcp);
  assertTrue(tcp.isEnabled());
  assertTrue(networkConfig.getSymmetricEncryptionConfig().isEnabled());
  final List<String> members=tcp.getMembers();
  assertEquals(members.toString(),2,members.size());
  assertEquals(""String_Node_Str"",members.get(0));
  assertEquals(""String_Node_Str"",members.get(1));
  assertEquals(""String_Node_Str"",tcp.getRequiredMember());
  AwsConfig aws=networkConfig.getJoin().getAwsConfig();
  assertFalse(aws.isEnabled());
  assertEquals(""String_Node_Str"",aws.getAccessKey());
  assertEquals(""String_Node_Str"",aws.getSecretKey());
  assertEquals(""String_Node_Str"",aws.getRegion());
  assertEquals(""String_Node_Str"",aws.getSecurityGroupName());
  assertEquals(""String_Node_Str"",aws.getTagKey());
  assertEquals(""String_Node_Str"",aws.getTagValue());
}","@Test public void testNetworkConfig(){
  NetworkConfig networkConfig=config.getNetworkConfig();
  assertNotNull(networkConfig);
  assertEquals(5700,config.getPort());
  assertFalse(config.isPortAutoIncrement());
  assertFalse(networkConfig.getJoin().getMulticastConfig().isEnabled());
  assertFalse(networkConfig.getInterfaces().isEnabled());
  assertEquals(1,networkConfig.getInterfaces().getInterfaces().size());
  assertEquals(""String_Node_Str"",networkConfig.getInterfaces().getInterfaces().iterator().next());
  TcpIpConfig tcp=networkConfig.getJoin().getTcpIpConfig();
  assertNotNull(tcp);
  assertTrue(tcp.isEnabled());
  assertTrue(networkConfig.getSymmetricEncryptionConfig().isEnabled());
  final List<String> members=tcp.getMembers();
  assertEquals(members.toString(),2,members.size());
  assertEquals(""String_Node_Str"",members.get(0));
  assertEquals(""String_Node_Str"",members.get(1));
  assertEquals(""String_Node_Str"",tcp.getRequiredMember());
  AwsConfig aws=networkConfig.getJoin().getAwsConfig();
  assertFalse(aws.isEnabled());
  assertEquals(""String_Node_Str"",aws.getAccessKey());
  assertEquals(""String_Node_Str"",aws.getSecretKey());
  assertEquals(""String_Node_Str"",aws.getRegion());
  assertEquals(""String_Node_Str"",aws.getSecurityGroupName());
  assertEquals(""String_Node_Str"",aws.getTagKey());
  assertEquals(""String_Node_Str"",aws.getTagValue());
}",0.999271137026239
49818,"@Test public void testInstance(){
  assertNotNull(instance);
  final Set<Member> members=instance.getCluster().getMembers();
  assertEquals(1,members.size());
  final Member member=members.iterator().next();
  final InetSocketAddress inetSocketAddress=member.getInetSocketAddress();
  assertEquals(5800,inetSocketAddress.getPort());
}","@Test public void testInstance(){
  assertNotNull(instance);
  final Set<Member> members=instance.getCluster().getMembers();
  assertEquals(1,members.size());
  final Member member=members.iterator().next();
  final InetSocketAddress inetSocketAddress=member.getInetSocketAddress();
  assertEquals(5700,inetSocketAddress.getPort());
}",0.997005988023952
49819,"public void run(){
  final ILogger logger=node.loggingService.getLogger(""String_Node_Str"");
  logger.log(Level.SEVERE,""String_Node_Str"");
  node.shutdown(true,false);
}","public void run(){
  final ILogger logger=node.loggingService.getLogger(""String_Node_Str"");
  logger.log(Level.SEVERE,""String_Node_Str"");
  node.shutdown(true,true);
}",0.9791044776119404
49820,"void reset(){
  for (  Record record : mapRecords.values()) {
    if (record.hasScheduledAction()) {
      List<ScheduledAction> lsScheduledActions=record.getScheduledActions();
      if (lsScheduledActions != null) {
        for (        ScheduledAction scheduledAction : lsScheduledActions) {
          scheduledAction.setValid(false);
        }
      }
    }
  }
  if (nearCache != null) {
    nearCache.reset();
  }
  mapRecords.clear();
  mapIndexService.clear();
  node.listenerManager.removeAllRegisteredListeners(getName());
  if (mapStoreWrapper != null) {
    try {
      mapStoreWrapper.destroy();
    }
 catch (    Exception e) {
      logger.log(Level.WARNING,e.getMessage(),e);
    }
  }
}","void reset(boolean invalidate){
  for (  Record record : mapRecords.values()) {
    if (record.hasScheduledAction()) {
      List<ScheduledAction> lsScheduledActions=record.getScheduledActions();
      if (lsScheduledActions != null) {
        for (        ScheduledAction scheduledAction : lsScheduledActions) {
          scheduledAction.setValid(false);
        }
      }
    }
    if (invalidate) {
      record.invalidate();
    }
  }
  if (nearCache != null) {
    nearCache.reset();
  }
  mapRecords.clear();
  mapIndexService.clear();
}",0.7528089887640449
49821,"public void onRestart(){
  enqueueAndWait(new Processable(){
    public void process(){
      partitionManager.reset();
      for (      CMap cmap : maps.values()) {
        cmap.reset();
      }
    }
  }
,5);
}","public void onRestart(){
  enqueueAndWait(new Processable(){
    public void process(){
      partitionManager.reset();
      for (      CMap cmap : maps.values()) {
        cmap.reset(false);
      }
    }
  }
,5);
}",0.9883449883449884
49822,"public Set iterate(){
  Entries entries=new Entries(ConcurrentMapManager.this,name,CONCURRENT_MAP_ITERATE_KEYS,predicate);
  Pairs pairs=(Pairs)getResultAsObject();
  entries.addEntries(pairs);
  return entries;
}","public Set iterate(){
  Entries entries=new Entries(ConcurrentMapManager.this,name,CONCURRENT_MAP_ITERATE_KEYS,predicate);
  final Object response=getResultAsObject();
  if (response instanceof Throwable) {
    Util.throwUncheckedException((Throwable)response);
  }
  Pairs pairs=(Pairs)response;
  entries.addEntries(pairs);
  return entries;
}",0.6953405017921147
49823,"public void run(){
  try {
    Predicate predicate=null;
    if (request.value != null) {
      predicate=(Predicate)toObject(request.value);
    }
    QueryContext queryContext=new QueryContext(cmap.getName(),predicate,cmap.getMapIndexService());
    Set<MapEntry> results=cmap.getMapIndexService().doQuery(queryContext);
    boolean evaluateValues=(predicate != null && !queryContext.isStrong());
    createResultPairs(request,results,evaluateValues,predicate);
    enqueueAndReturn(new Processable(){
      public void process(){
        int callerPartitionHash=request.blockId;
        if (partitionManager.containsMigratingBlock() || callerPartitionHash != partitionManager.hashBlocks()) {
          request.response=OBJECT_REDO;
        }
        boolean sent=returnResponse(request);
        if (!sent) {
          Connection conn=node.connectionManager.getConnection(request.caller);
          logger.log(Level.WARNING,request + ""String_Node_Str"" + request.caller+ ""String_Node_Str""+ conn);
        }
      }
    }
);
  }
 catch (  Throwable e) {
    logger.log(Level.SEVERE,request.toString(),e);
  }
}","public void run(){
  try {
    Predicate predicate=null;
    if (request.value != null) {
      predicate=(Predicate)toObject(request.value);
    }
    final QueryContext queryContext=new QueryContext(cmap.getName(),predicate,cmap.getMapIndexService());
    Set<MapEntry> results=cmap.getMapIndexService().doQuery(queryContext);
    boolean evaluateValues=(predicate != null && !queryContext.isStrong());
    createResultPairs(request,results,evaluateValues,predicate);
  }
 catch (  Throwable e) {
    logger.log(Level.SEVERE,request.toString(),e);
    request.response=e;
  }
  enqueueAndReturn(new Processable(){
    public void process(){
      int callerPartitionHash=request.blockId;
      if (partitionManager.containsMigratingBlock() || callerPartitionHash != partitionManager.hashBlocks()) {
        request.response=OBJECT_REDO;
      }
      boolean sent=returnResponse(request);
      if (!sent) {
        Connection conn=node.connectionManager.getConnection(request.caller);
        logger.log(Level.WARNING,request + ""String_Node_Str"" + request.caller+ ""String_Node_Str""+ conn);
      }
    }
  }
);
}",0.9011680143755616
49824,"boolean onResponse(Object response){
  Pairs pairs=null;
  if (response instanceof Data) {
    pairs=(Pairs)toObject((Data)response);
  }
 else   if (response instanceof Pairs) {
    pairs=(Pairs)response;
  }
 else {
    return true;
  }
  entries.addEntries(pairs);
  return true;
}","boolean onResponse(Object response){
  Pairs pairs=null;
  if (response instanceof Data) {
    pairs=(Pairs)toObject((Data)response);
  }
 else   if (response instanceof Pairs) {
    pairs=(Pairs)response;
  }
 else   if (response instanceof Throwable) {
    Util.throwUncheckedException((Throwable)response);
  }
 else {
    return true;
  }
  entries.addEntries(pairs);
  return true;
}",0.8452380952380952
49825,"public void shutdown(){
  for (  CMap cmap : maps.values()) {
    try {
      flush(cmap.name);
      cmap.reset();
    }
 catch (    Throwable e) {
      if (node.isActive()) {
        logger.log(Level.SEVERE,e.getMessage(),e);
      }
    }
  }
}","public void shutdown(){
  for (  CMap cmap : maps.values()) {
    try {
      flush(cmap.name);
      cmap.destroy();
    }
 catch (    Throwable e) {
      if (node.isActive()) {
        logger.log(Level.SEVERE,e.getMessage(),e);
      }
    }
  }
}",0.9759036144578314
49826,"public GroupProperties(Config config){
  VERSION_CHECK_ENABLED=new GroupProperty(config,PROP_VERSION_CHECK_ENABLED,""String_Node_Str"");
  IO_THREAD_COUNT=new GroupProperty(config,PROP_IO_THREAD_COUNT,""String_Node_Str"");
  TOPIC_FLOW_CONTROL_ENABLED=new GroupProperty(config,PROP_TOPIC_FLOW_CONTROL_ENABLED,""String_Node_Str"");
  CONNECT_ALL_WAIT_SECONDS=new GroupProperty(config,PROP_CONNECT_ALL_WAIT_SECONDS,""String_Node_Str"");
  MANCENTER_ENABLED=new GroupProperty(config,PROP_MANCENTER_ENABLED,""String_Node_Str"");
  MEMCACHE_ENABLED=new GroupProperty(config,PROP_MEMCACHE_ENABLED,""String_Node_Str"");
  REST_ENABLED=new GroupProperty(config,PROP_REST_ENABLED,""String_Node_Str"");
  MAP_LOAD_CHUNK_SIZE=new GroupProperty(config,PROP_MAP_LOAD_CHUNK_SIZE,""String_Node_Str"");
  IN_THREAD_PRIORITY=new GroupProperty(config,PROP_IN_THREAD_PRIORITY,""String_Node_Str"");
  OUT_THREAD_PRIORITY=new GroupProperty(config,PROP_OUT_THREAD_PRIORITY,""String_Node_Str"");
  SERVICE_THREAD_PRIORITY=new GroupProperty(config,PROP_SERVICE_THREAD_PRIORITY,""String_Node_Str"");
  MERGE_FIRST_RUN_DELAY_SECONDS=new GroupProperty(config,PROP_MERGE_FIRST_RUN_DELAY_SECONDS,""String_Node_Str"");
  MERGE_NEXT_RUN_DELAY_SECONDS=new GroupProperty(config,PROP_MERGE_NEXT_RUN_DELAY_SECONDS,""String_Node_Str"");
  REDO_WAIT_MILLIS=new GroupProperty(config,PROP_REDO_WAIT_MILLIS,""String_Node_Str"");
  SOCKET_BIND_ANY=new GroupProperty(config,PROP_SOCKET_BIND_ANY,""String_Node_Str"");
  SOCKET_RECEIVE_BUFFER_SIZE=new GroupProperty(config,PROP_SOCKET_RECEIVE_BUFFER_SIZE,""String_Node_Str"");
  SOCKET_SEND_BUFFER_SIZE=new GroupProperty(config,PROP_SOCKET_SEND_BUFFER_SIZE,""String_Node_Str"");
  SOCKET_LINGER_SECONDS=new GroupProperty(config,PROP_SOCKET_LINGER_SECONDS,""String_Node_Str"");
  SOCKET_KEEP_ALIVE=new GroupProperty(config,PROP_SOCKET_KEEP_ALIVE,""String_Node_Str"");
  SOCKET_NO_DELAY=new GroupProperty(config,PROP_SOCKET_NO_DELAY,""String_Node_Str"");
  SHUTDOWNHOOK_ENABLED=new GroupProperty(config,PROP_SHUTDOWNHOOK_ENABLED,""String_Node_Str"");
  WAIT_SECONDS_BEFORE_JOIN=new GroupProperty(config,PROP_WAIT_SECONDS_BEFORE_JOIN,""String_Node_Str"");
  MAX_WAIT_SECONDS_BEFORE_JOIN=new GroupProperty(config,PROP_MAX_WAIT_SECONDS_BEFORE_JOIN,""String_Node_Str"");
  HEARTBEAT_INTERVAL_SECONDS=new GroupProperty(config,PROP_HEARTBEAT_INTERVAL_SECONDS,""String_Node_Str"");
  MAX_NO_HEARTBEAT_SECONDS=new GroupProperty(config,PROP_MAX_NO_HEARTBEAT_SECONDS,""String_Node_Str"");
  ICMP_ENABLED=new GroupProperty(config,PROP_ICMP_ENABLED,""String_Node_Str"");
  INITIAL_MIN_CLUSTER_SIZE=new GroupProperty(config,PROP_INITIAL_MIN_CLUSTER_SIZE,""String_Node_Str"");
  INITIAL_WAIT_SECONDS=new GroupProperty(config,PROP_INITIAL_WAIT_SECONDS,""String_Node_Str"");
  RESTART_ON_MAX_IDLE=new GroupProperty(config,PROP_RESTART_ON_MAX_IDLE,""String_Node_Str"");
  CONCURRENT_MAP_PARTITION_COUNT=new GroupProperty(config,PROP_CONCURRENT_MAP_PARTITION_COUNT,""String_Node_Str"");
  CONCURRENT_MAP_MAX_BACKUP_COUNT=new GroupProperty(config,PROP_CONCURRENT_MAP_MAX_BACKUP_COUNT,""String_Node_Str"");
  REMOVE_DELAY_SECONDS=new GroupProperty(config,PROP_REMOVE_DELAY_SECONDS,""String_Node_Str"");
  CLEANUP_DELAY_SECONDS=new GroupProperty(config,PROP_CLEANUP_DELAY_SECONDS,""String_Node_Str"");
  EXECUTOR_QUERY_THREAD_COUNT=new GroupProperty(config,PROP_EXECUTOR_QUERY_THREAD_COUNT,""String_Node_Str"");
  EXECUTOR_EVENT_THREAD_COUNT=new GroupProperty(config,PROP_EXECUTOR_EVENT_THREAD_COUNT,""String_Node_Str"");
  EXECUTOR_MIGRATION_THREAD_COUNT=new GroupProperty(config,PROP_EXECUTOR_MIGRATION_THREAD_COUNT,""String_Node_Str"");
  EXECUTOR_CLIENT_THREAD_COUNT=new GroupProperty(config,PROP_EXECUTOR_CLIENT_THREAD_COUNT,""String_Node_Str"");
  EXECUTOR_STORE_THREAD_COUNT=new GroupProperty(config,PROP_EXECUTOR_STORE_THREAD_COUNT,""String_Node_Str"");
  LOG_STATE=new GroupProperty(config,PROP_LOG_STATE,""String_Node_Str"");
  LOGGING_TYPE=new GroupProperty(config,PROP_LOGGING_TYPE,""String_Node_Str"");
  ENABLE_JMX=new GroupProperty(config,PROP_ENABLE_JMX,""String_Node_Str"");
  ENABLE_JMX_DETAILED=new GroupProperty(config,PROP_ENABLE_JMX_DETAILED,""String_Node_Str"");
  MC_ATOMIC_NUMBER_EXCLUDES=new GroupProperty(config,PROP_MC_ATOMIC_NUMBER_EXCLUDES,null);
  MC_COUNT_DOWN_LATCH_EXCLUDES=new GroupProperty(config,PROP_MC_COUNT_DOWN_LATCH_EXCLUDES,null);
  MC_MAP_EXCLUDES=new GroupProperty(config,PROP_MC_MAP_EXCLUDES,null);
  MC_QUEUE_EXCLUDES=new GroupProperty(config,PROP_MC_QUEUE_EXCLUDES,null);
  MC_SEMAPHORE_EXCLUDES=new GroupProperty(config,PROP_MC_SEMAPHORE_EXCLUDES,null);
  MC_TOPIC_EXCLUDES=new GroupProperty(config,PROP_MC_TOPIC_EXCLUDES,null);
  MC_MAX_INSTANCE_COUNT=new GroupProperty(config,PROP_MC_MAX_VISIBLE_INSTANCE_COUNT,""String_Node_Str"");
  CONCURRENT_MAP_SIMPLE_RECORD=new GroupProperty(config,PROP_CONCURRENT_MAP_SIMPLE_RECORD,""String_Node_Str"");
  ELASTIC_MEMORY_ENABLED=new GroupProperty(config,PROP_ELASTIC_MEMORY_ENABLED,""String_Node_Str"");
  ELASTIC_MEMORY_TOTAL_SIZE=new GroupProperty(config,PROP_ELASTIC_MEMORY_TOTAL_SIZE,""String_Node_Str"");
  ELASTIC_MEMORY_CHUNK_SIZE=new GroupProperty(config,PROP_ELASTIC_MEMORY_CHUNK_SIZE,""String_Node_Str"");
  LICENSE_PATH=new GroupProperty(config,PROP_ENTERPRISE_LICENSE_PATH,null);
}","public GroupProperties(Config config){
  VERSION_CHECK_ENABLED=new GroupProperty(config,PROP_VERSION_CHECK_ENABLED,""String_Node_Str"");
  IO_THREAD_COUNT=new GroupProperty(config,PROP_IO_THREAD_COUNT,""String_Node_Str"");
  TOPIC_FLOW_CONTROL_ENABLED=new GroupProperty(config,PROP_TOPIC_FLOW_CONTROL_ENABLED,""String_Node_Str"");
  CONNECT_ALL_WAIT_SECONDS=new GroupProperty(config,PROP_CONNECT_ALL_WAIT_SECONDS,""String_Node_Str"");
  MANCENTER_ENABLED=new GroupProperty(config,PROP_MANCENTER_ENABLED,""String_Node_Str"");
  MEMCACHE_ENABLED=new GroupProperty(config,PROP_MEMCACHE_ENABLED,""String_Node_Str"");
  REST_ENABLED=new GroupProperty(config,PROP_REST_ENABLED,""String_Node_Str"");
  MAP_LOAD_CHUNK_SIZE=new GroupProperty(config,PROP_MAP_LOAD_CHUNK_SIZE,""String_Node_Str"");
  IN_THREAD_PRIORITY=new GroupProperty(config,PROP_IN_THREAD_PRIORITY,""String_Node_Str"");
  OUT_THREAD_PRIORITY=new GroupProperty(config,PROP_OUT_THREAD_PRIORITY,""String_Node_Str"");
  SERVICE_THREAD_PRIORITY=new GroupProperty(config,PROP_SERVICE_THREAD_PRIORITY,""String_Node_Str"");
  MERGE_FIRST_RUN_DELAY_SECONDS=new GroupProperty(config,PROP_MERGE_FIRST_RUN_DELAY_SECONDS,""String_Node_Str"");
  MERGE_NEXT_RUN_DELAY_SECONDS=new GroupProperty(config,PROP_MERGE_NEXT_RUN_DELAY_SECONDS,""String_Node_Str"");
  REDO_WAIT_MILLIS=new GroupProperty(config,PROP_REDO_WAIT_MILLIS,""String_Node_Str"");
  SOCKET_BIND_ANY=new GroupProperty(config,PROP_SOCKET_BIND_ANY,""String_Node_Str"");
  SOCKET_RECEIVE_BUFFER_SIZE=new GroupProperty(config,PROP_SOCKET_RECEIVE_BUFFER_SIZE,""String_Node_Str"");
  SOCKET_SEND_BUFFER_SIZE=new GroupProperty(config,PROP_SOCKET_SEND_BUFFER_SIZE,""String_Node_Str"");
  SOCKET_LINGER_SECONDS=new GroupProperty(config,PROP_SOCKET_LINGER_SECONDS,""String_Node_Str"");
  SOCKET_KEEP_ALIVE=new GroupProperty(config,PROP_SOCKET_KEEP_ALIVE,""String_Node_Str"");
  SOCKET_NO_DELAY=new GroupProperty(config,PROP_SOCKET_NO_DELAY,""String_Node_Str"");
  SHUTDOWNHOOK_ENABLED=new GroupProperty(config,PROP_SHUTDOWNHOOK_ENABLED,""String_Node_Str"");
  WAIT_SECONDS_BEFORE_JOIN=new GroupProperty(config,PROP_WAIT_SECONDS_BEFORE_JOIN,""String_Node_Str"");
  MAX_WAIT_SECONDS_BEFORE_JOIN=new GroupProperty(config,PROP_MAX_WAIT_SECONDS_BEFORE_JOIN,""String_Node_Str"");
  HEARTBEAT_INTERVAL_SECONDS=new GroupProperty(config,PROP_HEARTBEAT_INTERVAL_SECONDS,""String_Node_Str"");
  MAX_NO_HEARTBEAT_SECONDS=new GroupProperty(config,PROP_MAX_NO_HEARTBEAT_SECONDS,""String_Node_Str"");
  ICMP_ENABLED=new GroupProperty(config,PROP_ICMP_ENABLED,""String_Node_Str"");
  INITIAL_MIN_CLUSTER_SIZE=new GroupProperty(config,PROP_INITIAL_MIN_CLUSTER_SIZE,""String_Node_Str"");
  INITIAL_WAIT_SECONDS=new GroupProperty(config,PROP_INITIAL_WAIT_SECONDS,""String_Node_Str"");
  RESTART_ON_MAX_IDLE=new GroupProperty(config,PROP_RESTART_ON_MAX_IDLE,""String_Node_Str"");
  CONCURRENT_MAP_PARTITION_COUNT=new GroupProperty(config,PROP_CONCURRENT_MAP_PARTITION_COUNT,""String_Node_Str"");
  CONCURRENT_MAP_MAX_BACKUP_COUNT=new GroupProperty(config,PROP_CONCURRENT_MAP_MAX_BACKUP_COUNT,""String_Node_Str"");
  REMOVE_DELAY_SECONDS=new GroupProperty(config,PROP_REMOVE_DELAY_SECONDS,""String_Node_Str"");
  CLEANUP_DELAY_SECONDS=new GroupProperty(config,PROP_CLEANUP_DELAY_SECONDS,""String_Node_Str"");
  EXECUTOR_QUERY_THREAD_COUNT=new GroupProperty(config,PROP_EXECUTOR_QUERY_THREAD_COUNT,""String_Node_Str"");
  EXECUTOR_EVENT_THREAD_COUNT=new GroupProperty(config,PROP_EXECUTOR_EVENT_THREAD_COUNT,""String_Node_Str"");
  EXECUTOR_MIGRATION_THREAD_COUNT=new GroupProperty(config,PROP_EXECUTOR_MIGRATION_THREAD_COUNT,""String_Node_Str"");
  EXECUTOR_CLIENT_THREAD_COUNT=new GroupProperty(config,PROP_EXECUTOR_CLIENT_THREAD_COUNT,""String_Node_Str"");
  EXECUTOR_STORE_THREAD_COUNT=new GroupProperty(config,PROP_EXECUTOR_STORE_THREAD_COUNT,""String_Node_Str"");
  LOG_STATE=new GroupProperty(config,PROP_LOG_STATE,""String_Node_Str"");
  LOGGING_TYPE=new GroupProperty(config,PROP_LOGGING_TYPE,""String_Node_Str"");
  ENABLE_JMX=new GroupProperty(config,PROP_ENABLE_JMX,""String_Node_Str"");
  ENABLE_JMX_DETAILED=new GroupProperty(config,PROP_ENABLE_JMX_DETAILED,""String_Node_Str"");
  MC_PORT=new GroupProperty(config,PROP_MC_PORT,""String_Node_Str"");
  MC_ATOMIC_NUMBER_EXCLUDES=new GroupProperty(config,PROP_MC_ATOMIC_NUMBER_EXCLUDES,null);
  MC_COUNT_DOWN_LATCH_EXCLUDES=new GroupProperty(config,PROP_MC_COUNT_DOWN_LATCH_EXCLUDES,null);
  MC_MAP_EXCLUDES=new GroupProperty(config,PROP_MC_MAP_EXCLUDES,null);
  MC_QUEUE_EXCLUDES=new GroupProperty(config,PROP_MC_QUEUE_EXCLUDES,null);
  MC_SEMAPHORE_EXCLUDES=new GroupProperty(config,PROP_MC_SEMAPHORE_EXCLUDES,null);
  MC_TOPIC_EXCLUDES=new GroupProperty(config,PROP_MC_TOPIC_EXCLUDES,null);
  MC_MAX_INSTANCE_COUNT=new GroupProperty(config,PROP_MC_MAX_VISIBLE_INSTANCE_COUNT,""String_Node_Str"");
  CONCURRENT_MAP_SIMPLE_RECORD=new GroupProperty(config,PROP_CONCURRENT_MAP_SIMPLE_RECORD,""String_Node_Str"");
  ELASTIC_MEMORY_ENABLED=new GroupProperty(config,PROP_ELASTIC_MEMORY_ENABLED,""String_Node_Str"");
  ELASTIC_MEMORY_TOTAL_SIZE=new GroupProperty(config,PROP_ELASTIC_MEMORY_TOTAL_SIZE,""String_Node_Str"");
  ELASTIC_MEMORY_CHUNK_SIZE=new GroupProperty(config,PROP_ELASTIC_MEMORY_CHUNK_SIZE,""String_Node_Str"");
  LICENSE_PATH=new GroupProperty(config,PROP_ENTERPRISE_LICENSE_PATH,null);
}",0.9934715821812596
49827,"public UDPListener(DatagramSocket socket) throws SocketException {
  super(""String_Node_Str"");
  this.socket=socket;
  this.socket.setSoTimeout(1000);
}","public UDPListener(DatagramSocket socket,int timeout,boolean reuseAddress) throws SocketException {
  super(""String_Node_Str"");
  this.socket=socket;
  this.socket.setSoTimeout(timeout);
  this.socket.setReuseAddress(reuseAddress);
}",0.7688311688311689
49828,"public ManagementCenterService(FactoryImpl factoryImpl) throws Exception {
  this.factory=factoryImpl;
  this.instanceFilterMap=new StatsInstanceFilter(factoryImpl.node.getGroupProperties().MC_MAP_EXCLUDES.getString());
  this.instanceFilterQueue=new StatsInstanceFilter(factoryImpl.node.getGroupProperties().MC_QUEUE_EXCLUDES.getString());
  this.instanceFilterTopic=new StatsInstanceFilter(factoryImpl.node.getGroupProperties().MC_TOPIC_EXCLUDES.getString());
  this.instanceFilterAtomicNumber=new StatsInstanceFilter(factoryImpl.node.getGroupProperties().MC_ATOMIC_NUMBER_EXCLUDES.getString());
  this.instanceFilterCountDownLatch=new StatsInstanceFilter(factoryImpl.node.getGroupProperties().MC_COUNT_DOWN_LATCH_EXCLUDES.getString());
  this.instanceFilterSemaphore=new StatsInstanceFilter(factoryImpl.node.getGroupProperties().MC_SEMAPHORE_EXCLUDES.getString());
  thisAddress=((MemberImpl)factory.getCluster().getLocalMember()).getAddress();
  updateMemberOrder();
  logger=factory.node.getLogger(ManagementCenterService.class.getName());
  for (int i=0; i < 100; i++) {
    qClientHandlers.offer(new ClientHandler());
  }
  maxVisibleInstanceCount=factory.node.groupProperties.MC_MAX_INSTANCE_COUNT.getInteger();
  factory.getCluster().addMembershipListener(this);
  MemberImpl memberLocal=(MemberImpl)factory.getCluster().getLocalMember();
  int port=memberLocal.getInetSocketAddress().getPort() + 100;
  datagramSocket=new DatagramSocket(port);
  serverSocket=new SocketReadyServerSocket(port);
  udpListener=new UDPListener(datagramSocket);
  udpListener.start();
  udpSender=new UDPSender(datagramSocket);
  udpSender.start();
  tcpListener=new TCPListener(serverSocket);
  tcpListener.start();
  commandHandler=new ConsoleCommandHandler(factory);
  logger.log(Level.INFO,""String_Node_Str"" + port + ""String_Node_Str"");
}","public ManagementCenterService(FactoryImpl factoryImpl) throws Exception {
  this.factory=factoryImpl;
  this.instanceFilterMap=new StatsInstanceFilter(factoryImpl.node.getGroupProperties().MC_MAP_EXCLUDES.getString());
  this.instanceFilterQueue=new StatsInstanceFilter(factoryImpl.node.getGroupProperties().MC_QUEUE_EXCLUDES.getString());
  this.instanceFilterTopic=new StatsInstanceFilter(factoryImpl.node.getGroupProperties().MC_TOPIC_EXCLUDES.getString());
  this.instanceFilterAtomicNumber=new StatsInstanceFilter(factoryImpl.node.getGroupProperties().MC_ATOMIC_NUMBER_EXCLUDES.getString());
  this.instanceFilterCountDownLatch=new StatsInstanceFilter(factoryImpl.node.getGroupProperties().MC_COUNT_DOWN_LATCH_EXCLUDES.getString());
  this.instanceFilterSemaphore=new StatsInstanceFilter(factoryImpl.node.getGroupProperties().MC_SEMAPHORE_EXCLUDES.getString());
  Config config=factory.node.config;
  thisAddress=((MemberImpl)factory.getCluster().getLocalMember()).getAddress();
  updateMemberOrder();
  logger=factory.node.getLogger(ManagementCenterService.class.getName());
  for (int i=0; i < 100; i++) {
    qClientHandlers.offer(new ClientHandler());
  }
  maxVisibleInstanceCount=factory.node.groupProperties.MC_MAX_INSTANCE_COUNT.getInteger();
  factory.getCluster().addMembershipListener(this);
  MemberImpl memberLocal=(MemberImpl)factory.getCluster().getLocalMember();
  int port=(memberLocal.getInetSocketAddress().getPort() - config.getPort()) + factoryImpl.node.getGroupProperties().MC_PORT.getInteger();
  datagramSocket=new DatagramSocket(port);
  serverSocket=new SocketReadyServerSocket(port,1000,factory.node.config.isReuseAddress());
  udpListener=new UDPListener(datagramSocket,1000,factory.node.config.isReuseAddress());
  udpListener.start();
  udpSender=new UDPSender(datagramSocket);
  udpSender.start();
  tcpListener=new TCPListener(serverSocket);
  tcpListener.start();
  commandHandler=new ConsoleCommandHandler(factory);
  logger.log(Level.INFO,""String_Node_Str"" + port + ""String_Node_Str"");
}",0.9023062969681264
49829,"public SocketReadyServerSocket(int port) throws IOException {
  super(port);
}","public SocketReadyServerSocket(int port,int timeout,boolean reuseAddress) throws IOException {
  super(port);
  setSoTimeout(timeout);
  setReuseAddress(reuseAddress);
}",0.631578947368421
49830,"protected void customRun() throws InterruptedException {
  if (outRunnable.reconnection.get()) {
    Thread.sleep(10L);
    return;
  }
  Packet packet;
  try {
    Connection oldConnection=connection;
    connection=client.connectionManager.getConnection();
    if (oldConnection == null || restoredConnection(oldConnection,connection)) {
      if (outRunnable.sendReconnectCall(connection)) {
        logger.log(Level.FINEST,""String_Node_Str"");
        if (oldConnection != null) {
          redoUnfinishedCalls(oldConnection);
        }
      }
      return;
    }
    if (connection == null) {
      outRunnable.clusterIsDown(oldConnection);
      Thread.sleep(10);
    }
 else {
      packet=reader.readPacket(connection);
      this.lastReceived=System.currentTimeMillis();
      Call call=callMap.remove(packet.getCallId());
      if (call != null) {
        call.received=System.nanoTime();
        call.setResponse(packet);
      }
 else {
        if (packet.getOperation().equals(ClusterOperation.EVENT)) {
          client.getListenerManager().enqueue(packet);
        }
        if (packet.getCallId() != -1) {
          logger.log(Level.SEVERE,""String_Node_Str"" + packet.getOperation() + ""String_Node_Str""+ packet.getCallId());
        }
      }
    }
  }
 catch (  Throwable e) {
    logger.log(Level.FINE,""String_Node_Str"" + connection + ""String_Node_Str""+ e.toString(),e);
    outRunnable.clusterIsDown(connection);
  }
}","protected void customRun() throws InterruptedException {
  if (outRunnable.reconnection.get()) {
    Thread.sleep(10L);
    return;
  }
  Packet packet;
  try {
    Connection oldConnection=connection;
    connection=client.connectionManager.getConnection();
    if (restoredConnection(oldConnection,connection)) {
      if (outRunnable.sendReconnectCall(connection)) {
        logger.log(Level.FINEST,""String_Node_Str"");
        if (oldConnection != null) {
          redoUnfinishedCalls(oldConnection);
        }
      }
      return;
    }
    if (connection == null) {
      outRunnable.clusterIsDown(oldConnection);
      Thread.sleep(10);
    }
 else {
      packet=reader.readPacket(connection);
      this.lastReceived=System.currentTimeMillis();
      Call call=callMap.remove(packet.getCallId());
      if (call != null) {
        call.received=System.nanoTime();
        call.setResponse(packet);
      }
 else {
        if (packet.getOperation().equals(ClusterOperation.EVENT)) {
          client.getListenerManager().enqueue(packet);
        }
        if (packet.getCallId() != -1) {
          logger.log(Level.SEVERE,""String_Node_Str"" + packet.getOperation() + ""String_Node_Str""+ packet.getCallId());
        }
      }
    }
  }
 catch (  Throwable e) {
    logger.log(Level.FINEST,""String_Node_Str"" + connection + ""String_Node_Str""+ e.toString(),e);
    outRunnable.clusterIsDown(connection);
  }
}",0.9905229905229904
49831,"private void connect(String[] args){
  String groupName=""String_Node_Str"";
  String pass=""String_Node_Str"";
  if (args.length > 2) {
    groupName=args[2];
    pass=args[3];
  }
  String ip=args[1];
  System.out.println(""String_Node_Str"" + ip);
  String[] ips=null;
  if (ip.indexOf(':') == -1) {
    ips=new String[]{ip + ""String_Node_Str"",ip + ""String_Node_Str"",ip + ""String_Node_Str""};
  }
 else {
    ips=new String[]{ip};
  }
  this.hz=HazelcastClient.newHazelcastClient(groupName,pass,ips);
  System.out.println(hz.getCluster().getMembers());
}","private void connect(String[] args){
  String ip=""String_Node_Str"";
  String groupName=""String_Node_Str"";
  String pass=""String_Node_Str"";
  if (args.length > 1) {
    ip=args[1];
  }
  if (args.length > 3) {
    groupName=args[2];
    pass=args[3];
  }
  System.out.println(""String_Node_Str"" + ip);
  String[] ips=null;
  if (ip.indexOf(':') == -1) {
    ips=new String[]{ip + ""String_Node_Str"",ip + ""String_Node_Str"",ip + ""String_Node_Str""};
  }
 else {
    ips=new String[]{ip};
  }
  this.hz=HazelcastClient.newHazelcastClient(groupName,pass,ips);
  System.out.println(hz.getCluster().getMembers());
}",0.9142857142857144
49832,"@Test public void testProxySerialization(){
  IMap<Object,Object> mapProxy=getHazelcastClient().getMap(""String_Node_Str"");
  ILock mapLock=getHazelcastClient().getLock(mapProxy);
  assertNotNull(mapLock);
}","@Ignore public void testProxySerialization(){
  IMap<Object,Object> mapProxy=getHazelcastClient().getMap(""String_Node_Str"");
  ILock mapLock=getHazelcastClient().getLock(mapProxy);
  assertNotNull(mapLock);
}",0.9758454106280192
49833,"void markSessionDirty(String sessionId){
  System.out.println(""String_Node_Str"" + sessionId + ""String_Node_Str"");
  HazelcastHttpSession hazelSession=mapSessions.get(sessionId);
  if (hazelSession != null) {
    hazelSession.setDirty(true);
  }
}","void markSessionDirty(String sessionId){
  HazelcastHttpSession hazelSession=mapSessions.get(sessionId);
  if (hazelSession != null) {
    hazelSession.setDirty(true);
  }
}",0.8257756563245824
49834,"@Override public int hashCode(){
  if (buffer == null)   return Integer.MIN_VALUE;
  final int prime=0x01000193;
  int hash=0x811c9dc5;
  final byte[] data=buffer;
  for (int i=data.length - 1; i >= 0; i--) {
    hash=(hash ^ data[i]) * prime;
  }
  return hash;
}","@Override public int hashCode(){
  return Util.hashCode(buffer);
}",0.2848484848484848
49835,"public void enqueueFullPacket(final Packet p){
  p.flipBuffers();
  p.read();
  p.setFromConnection(connection);
  System.out.println(""String_Node_Str"" + p.client);
  if (p.client) {
    connection.setType(Connection.Type.JAVA_CLIENT);
    ioService.handleClientPacket(p);
  }
 else {
    connection.setType(Connection.Type.MEMBER);
    ioService.handleMemberPacket(p);
  }
}","public void enqueueFullPacket(final Packet p){
  p.flipBuffers();
  p.read();
  p.setFromConnection(connection);
  if (p.client) {
    connection.setType(Connection.Type.JAVA_CLIENT);
    ioService.handleClientPacket(p);
  }
 else {
    connection.setType(Connection.Type.MEMBER);
    ioService.handleMemberPacket(p);
  }
}",0.9255014326647564
49836,"private void overrideSession(HazelcastHttpSession session,Map mapSession){
  if (session == null || mapSession == null)   return;
  final Set<Map.Entry> entries=mapSession.entrySet();
  for (  final Map.Entry entry : entries) {
    session.setAttribute((String)entry.getKey(),entry.getValue());
  }
  session.setDirty(false);
}","private void overrideSession(HazelcastHttpSession session,Map mapSession){
  if (session == null || mapSession == null)   return;
  final Enumeration<String> atts=session.getAttributeNames();
  while (atts.hasMoreElements()) {
    session.removeAttribute(atts.nextElement());
  }
  Map mapData=null;
  final Set<Map.Entry> entries=mapSession.entrySet();
  for (  final Map.Entry entry : entries) {
    session.setAttribute((String)entry.getKey(),entry.getValue());
    if (mapData == null) {
      mapData=new HashMap<String,Object>();
    }
    mapData.put(entry.getKey(),entry.getValue());
  }
  session.sessionChanged(session.writeObject(mapData));
  session.setDirty(false);
}",0.6276067527308838
49837,"public void entryUpdated(EntryEvent entryEvent){
  markSessionDirty((String)entryEvent.getKey());
}","public void entryUpdated(EntryEvent entryEvent){
  if (!entryEvent.getMember().localMember()) {
    markSessionDirty((String)entryEvent.getKey());
  }
}",0.7888446215139442
49838,"public void init(final FilterConfig config) throws ServletException {
  String debugParam=config.getInitParameter(""String_Node_Str"");
  if (debugParam != null) {
    DEBUG=Boolean.valueOf(debugParam);
  }
  servletContext=config.getServletContext();
  String mapName=config.getInitParameter(""String_Node_Str"");
  if (mapName != null) {
    clusterMapName=mapName;
  }
 else {
    clusterMapName=""String_Node_Str"" + servletContext.getServletContextName();
  }
  String stickySessionParam=config.getInitParameter(""String_Node_Str"");
  if (stickySessionParam != null) {
    stickySession=Boolean.valueOf(stickySessionParam);
  }
  if (!stickySession) {
    getClusterMap().addEntryListener(new EntryListener(){
      public void entryAdded(      EntryEvent entryEvent){
      }
      public void entryRemoved(      EntryEvent entryEvent){
        removeSessionLocally((String)entryEvent.getKey());
      }
      public void entryUpdated(      EntryEvent entryEvent){
        markSessionDirty((String)entryEvent.getKey());
      }
      public void entryEvicted(      EntryEvent entryEvent){
      }
    }
,false);
  }
  log(""String_Node_Str"" + stickySession + ""String_Node_Str""+ DEBUG+ ""String_Node_Str""+ clusterMapName);
}","public void init(final FilterConfig config) throws ServletException {
  String debugParam=config.getInitParameter(""String_Node_Str"");
  if (debugParam != null) {
    debug=Boolean.valueOf(debugParam);
  }
  servletContext=config.getServletContext();
  String mapName=config.getInitParameter(""String_Node_Str"");
  if (mapName != null) {
    clusterMapName=mapName;
  }
 else {
    clusterMapName=""String_Node_Str"" + servletContext.getServletContextName();
  }
  String stickySessionParam=config.getInitParameter(""String_Node_Str"");
  if (stickySessionParam != null) {
    stickySession=Boolean.valueOf(stickySessionParam);
  }
  if (!stickySession) {
    getClusterMap().addEntryListener(new EntryListener(){
      public void entryAdded(      EntryEvent entryEvent){
      }
      public void entryRemoved(      EntryEvent entryEvent){
        if (!entryEvent.getMember().localMember()) {
          removeSessionLocally((String)entryEvent.getKey());
        }
      }
      public void entryUpdated(      EntryEvent entryEvent){
        if (!entryEvent.getMember().localMember()) {
          markSessionDirty((String)entryEvent.getKey());
        }
      }
      public void entryEvicted(      EntryEvent entryEvent){
      }
    }
,false);
  }
  log(""String_Node_Str"" + stickySession + ""String_Node_Str""+ debug+ ""String_Node_Str""+ clusterMapName);
}",0.9416342412451362
49839,"void destroySession(final HazelcastHttpSession session){
  log(""String_Node_Str"" + session.getId());
  mapSessions.remove(session.getId());
  mapOriginalSessions.remove(session.originalSession.getId());
  session.destroy();
  getClusterMap().remove(session.getId());
}","void destroySession(final HazelcastHttpSession session){
  log(""String_Node_Str"" + session.getId());
  mapSessions.remove(session.getId());
  mapOriginalSessions.remove(session.originalSession.getId());
  session.destroy();
  final long maxInactive=session.originalSession.getMaxInactiveInterval() * 1000;
  final long clusterLastAccess=session.timestamp.get();
  final long now=System.currentTimeMillis();
  if ((now - clusterLastAccess) >= maxInactive) {
    log(""String_Node_Str"" + session.getId() + ""String_Node_Str""+ maxInactive+ ""String_Node_Str""+ session.originalSession.getLastAccessedTime()+ ""String_Node_Str""+ clusterLastAccess+ ""String_Node_Str""+ now);
    getClusterMap().remove(session.getId());
    session.timestamp.destroy();
  }
}",0.5280788177339901
49840,"@Override public RequestDispatcher getRequestDispatcher(final String path){
  final ServletRequest original=getRequest();
  return new RequestDispatcher(){
    public void forward(    ServletRequest servletRequest,    ServletResponse servletResponse) throws ServletException, IOException {
      original.getRequestDispatcher(path).forward(original,servletResponse);
    }
    public void include(    ServletRequest servletRequest,    ServletResponse servletResponse) throws ServletException, IOException {
      original.getRequestDispatcher(path).include(original,servletResponse);
    }
  }
;
}","@Override public RequestDispatcher getRequestDispatcher(final String path){
  final ServletRequest original=getRequest();
  return new RequestDispatcher(){
    public void forward(    ServletRequest servletRequest,    ServletResponse servletResponse) throws ServletException, IOException {
      original.getRequestDispatcher(path).forward(RequestWrapper.this,servletResponse);
    }
    public void include(    ServletRequest servletRequest,    ServletResponse servletResponse) throws ServletException, IOException {
      original.getRequestDispatcher(path).include(RequestWrapper.this,servletResponse);
    }
  }
;
}",0.955592105263158
49841,"public void putValue(final String name,final Object value){
  originalSession.setAttribute(name,value);
}","public void putValue(final String name,final Object value){
  setAttribute(name,value);
}",0.9175257731958762
49842,"void log(final Object obj){
  if (DEBUG) {
    logger.log(Level.FINEST,obj.toString());
    System.out.println(obj.toString());
  }
}","void log(final Object obj){
  Level level=Level.FINEST;
  if (debug) {
    level=Level.INFO;
  }
  logger.log(level,obj.toString());
}",0.5692883895131086
49843,"public HazelcastHttpSession(WebFilter webFilter,final String sessionId,HttpSession originalSession){
  this.webFilter=webFilter;
  this.id=sessionId;
  this.originalSession=originalSession;
}","public HazelcastHttpSession(WebFilter webFilter,final String sessionId,HttpSession originalSession){
  this.webFilter=webFilter;
  this.id=sessionId;
  this.originalSession=originalSession;
  timestamp=Hazelcast.getAtomicNumber(clusterMapName + ""String_Node_Str"" + id);
}",0.8268398268398268
49844,"public void setAttribute(final String name,final Object value){
  originalSession.setAttribute(name,value);
}","public void setAttribute(final String name,final Object value){
  if (value != null && !(value instanceof Serializable)) {
    throw new IllegalArgumentException(new NotSerializableException(value.getClass().getName()));
  }
  originalSession.setAttribute(name,value);
}",0.496042216358839
49845,"public void doFilter(ServletRequest req,ServletResponse res,final FilterChain chain) throws IOException, ServletException {
  log(""String_Node_Str"" + req.getClass().getName());
  log(mapSessions.size() + ""String_Node_Str"" + mapOriginalSessions.size());
  if (!(req instanceof HttpServletRequest)) {
    chain.doFilter(req,res);
  }
 else {
    if (req instanceof RequestWrapper) {
      log(""String_Node_Str"");
      chain.doFilter(req,res);
      return;
    }
    HttpServletRequest httpReq=(HttpServletRequest)req;
    RequestWrapper existingReq=(RequestWrapper)req.getAttribute(HAZELCAST_REQUEST);
    final ResponseWrapper resWrapper=new ResponseWrapper((HttpServletResponse)res);
    final RequestWrapper reqWrapper=new RequestWrapper(httpReq,resWrapper);
    resWrapper.setRequest(reqWrapper);
    if (existingReq != null) {
      reqWrapper.setHazelcastSession(existingReq.hazelcastSession,existingReq.requestedSessionId);
    }
    req=null;
    res=null;
    httpReq=null;
    chain.doFilter(reqWrapper,resWrapper);
    if (existingReq != null)     return;
    req=null;
    HazelcastHttpSession session=reqWrapper.getSession(false);
    if (session != null && session.isValid()) {
      final Enumeration<String> attNames=session.getAttributeNames();
      Map mapData=null;
      while (attNames.hasMoreElements()) {
        final String attName=attNames.nextElement();
        final Object value=session.getAttribute(attName);
        if (value instanceof Serializable) {
          if (mapData == null) {
            mapData=new HashMap<String,Object>();
          }
          mapData.put(attName,value);
        }
      }
      Data data=session.writeObject(mapData);
      boolean sessionChanged=session.sessionChanged(data);
      if (sessionChanged) {
        if (data == null) {
          mapData=new HashMap<String,Object>();
          data=session.writeObject(mapData);
        }
        log(""String_Node_Str"" + session.getId());
        getClusterMap().put(session.getId(),data);
      }
    }
  }
}","public void doFilter(ServletRequest req,ServletResponse res,final FilterChain chain) throws IOException, ServletException {
  if (!(req instanceof HttpServletRequest)) {
    chain.doFilter(req,res);
  }
 else {
    if (req instanceof RequestWrapper) {
      log(""String_Node_Str"");
      chain.doFilter(req,res);
      return;
    }
    HttpServletRequest httpReq=(HttpServletRequest)req;
    RequestWrapper existingReq=(RequestWrapper)req.getAttribute(HAZELCAST_REQUEST);
    final ResponseWrapper resWrapper=new ResponseWrapper((HttpServletResponse)res);
    final RequestWrapper reqWrapper=new RequestWrapper(httpReq,resWrapper);
    resWrapper.setRequest(reqWrapper);
    if (existingReq != null) {
      reqWrapper.setHazelcastSession(existingReq.hazelcastSession,existingReq.requestedSessionId);
    }
    req=null;
    res=null;
    httpReq=null;
    chain.doFilter(reqWrapper,resWrapper);
    if (existingReq != null)     return;
    req=null;
    HazelcastHttpSession session=reqWrapper.getSession(false);
    if (session != null && session.isValid()) {
      session.setAccessed();
      final Enumeration<String> attNames=session.getAttributeNames();
      Map mapData=null;
      while (attNames.hasMoreElements()) {
        final String attName=attNames.nextElement();
        final Object value=session.getAttribute(attName);
        if (mapData == null) {
          mapData=new HashMap<String,Object>();
        }
        mapData.put(attName,value);
      }
      Data data=session.writeObject(mapData);
      boolean sessionChanged=session.sessionChanged(data);
      if (sessionChanged) {
        if (data == null) {
          mapData=new HashMap<String,Object>();
          data=session.writeObject(mapData);
        }
        log(""String_Node_Str"" + session.getId());
        getClusterMap().put(session.getId(),data);
      }
    }
  }
}",0.9352592210472016
49846,"private void addSessionCookie(final RequestWrapper req,final String sessionId){
  final Cookie sessionCookie=new Cookie(HAZELCAST_SESSION_COOKIE_NAME,sessionId);
  String path=req.getContextPath();
  if (""String_Node_Str"".equals(path)) {
    path=""String_Node_Str"";
  }
  sessionCookie.setPath(path);
  sessionCookie.setMaxAge(-1);
  req.res.addCookie(sessionCookie);
}","private static void addSessionCookie(final RequestWrapper req,final String sessionId){
  final Cookie sessionCookie=new Cookie(HAZELCAST_SESSION_COOKIE_NAME,sessionId);
  String path=req.getContextPath();
  if (""String_Node_Str"".equals(path)) {
    path=""String_Node_Str"";
  }
  sessionCookie.setPath(path);
  sessionCookie.setMaxAge(-1);
  req.res.addCookie(sessionCookie);
}",0.9906040268456376
49847,"public void entryRemoved(EntryEvent entryEvent){
  removeSessionLocally((String)entryEvent.getKey());
}","public void entryRemoved(EntryEvent entryEvent){
  if (!entryEvent.getMember().localMember()) {
    removeSessionLocally((String)entryEvent.getKey());
  }
}",0.7953667953667953
49848,"void markSessionDirty(String sessionId){
  HazelcastHttpSession hazelSession=mapSessions.get(sessionId);
  if (hazelSession != null) {
    hazelSession.setDirty(true);
  }
}","void markSessionDirty(String sessionId){
  System.out.println(""String_Node_Str"" + sessionId + ""String_Node_Str"");
  HazelcastHttpSession hazelSession=mapSessions.get(sessionId);
  if (hazelSession != null) {
    hazelSession.setDirty(true);
  }
}",0.8257756563245824
49849,"public void include(ServletRequest servletRequest,ServletResponse servletResponse) throws ServletException, IOException {
  original.getRequestDispatcher(path).include(original,servletResponse);
}","public void include(ServletRequest servletRequest,ServletResponse servletResponse) throws ServletException, IOException {
  original.getRequestDispatcher(path).include(RequestWrapper.this,servletResponse);
}",0.9330024813895782
49850,"public void forward(ServletRequest servletRequest,ServletResponse servletResponse) throws ServletException, IOException {
  original.getRequestDispatcher(path).forward(original,servletResponse);
}","public void forward(ServletRequest servletRequest,ServletResponse servletResponse) throws ServletException, IOException {
  original.getRequestDispatcher(path).forward(RequestWrapper.this,servletResponse);
}",0.9330024813895782
49851,"public Object getValue(final String name){
  return originalSession.getValue(name);
}","public Object getValue(final String name){
  return getAttribute(name);
}",0.8354430379746836
49852,"@Override public HazelcastHttpSession getSession(final boolean create){
  if (hazelcastSession != null && !hazelcastSession.isValid()) {
    log(""String_Node_Str"");
    destroySession(hazelcastSession);
    hazelcastSession=null;
  }
  if (hazelcastSession == null) {
    HttpSession originalSession=getOriginalSession(false);
    if (originalSession != null) {
      String hazelcastSessionId=mapOriginalSessions.get(originalSession.getId());
      if (hazelcastSessionId != null) {
        hazelcastSession=mapSessions.get(hazelcastSessionId);
      }
      if (hazelcastSession == null) {
        mapOriginalSessions.remove(originalSession.getId());
        originalSession.invalidate();
      }
    }
  }
  if (hazelcastSession != null)   return hazelcastSession;
  final String requestedSessionId=fetchHazelcastSessionId();
  if (requestedSessionId != null) {
    hazelcastSession=getSessionWithId(requestedSessionId);
    if (hazelcastSession == null) {
      final Map mapSession=(Map)getClusterMap().get(requestedSessionId);
      if (mapSession != null) {
        hazelcastSession=createNewSession(RequestWrapper.this,requestedSessionId);
        overrideSession(hazelcastSession,mapSession);
      }
    }
  }
  if (hazelcastSession == null && create) {
    hazelcastSession=createNewSession(RequestWrapper.this,null);
  }
 else   if (hazelcastSession != null && !stickySession && requestedSessionId != null && hazelcastSession.isDirty()) {
    log(requestedSessionId + ""String_Node_Str"");
    final Map mapSession=(Map)getClusterMap().get(requestedSessionId);
    overrideSession(hazelcastSession,mapSession);
  }
  return hazelcastSession;
}","@Override public HazelcastHttpSession getSession(final boolean create){
  if (hazelcastSession != null && !hazelcastSession.isValid()) {
    log(""String_Node_Str"");
    destroySession(hazelcastSession);
    hazelcastSession=null;
  }
  if (hazelcastSession == null) {
    HttpSession originalSession=getOriginalSession(false);
    if (originalSession != null) {
      String hazelcastSessionId=mapOriginalSessions.get(originalSession.getId());
      if (hazelcastSessionId != null) {
        hazelcastSession=mapSessions.get(hazelcastSessionId);
      }
      if (hazelcastSession == null) {
        mapOriginalSessions.remove(originalSession.getId());
        originalSession.invalidate();
      }
 else       if (hazelcastSession.isDirty()) {
        hazelcastSession=null;
      }
    }
  }
  if (hazelcastSession != null)   return hazelcastSession;
  final String requestedSessionId=fetchHazelcastSessionId();
  if (requestedSessionId != null) {
    hazelcastSession=getSessionWithId(requestedSessionId);
    if (hazelcastSession == null) {
      final Map mapSession=(Map)getClusterMap().get(requestedSessionId);
      if (mapSession != null) {
        hazelcastSession=createNewSession(RequestWrapper.this,requestedSessionId);
        overrideSession(hazelcastSession,mapSession);
      }
    }
  }
  if (hazelcastSession == null && create) {
    hazelcastSession=createNewSession(RequestWrapper.this,null);
  }
 else   if (hazelcastSession != null && !stickySession && requestedSessionId != null && hazelcastSession.isDirty()) {
    log(requestedSessionId + ""String_Node_Str"");
    final Map mapSession=(Map)getClusterMap().get(requestedSessionId);
    overrideSession(hazelcastSession,mapSession);
  }
  return hazelcastSession;
}",0.9749336478914774
49853,"Record ensureRecord(Request req,Data defaultValue){
  checkServiceThread();
  CMap cmap=getOrCreateMap(req.name);
  Record record=cmap.getRecord(req);
  if (record == null) {
    record=cmap.createNewRecord(req.key,defaultValue);
    cmap.mapRecords.put(req.key,record);
  }
  return record;
}","Record ensureRecord(Request req,Data defaultValue){
  checkServiceThread();
  CMap cmap=getOrCreateMap(req.name);
  Record record=cmap.getRecord(req);
  if (record == null || !record.isActive() || !record.isValid()) {
    record=cmap.createNewRecord(req.key,defaultValue);
    cmap.mapRecords.put(req.key,record);
  }
  return record;
}",0.931637519872814
49854,"/** 
 * Test for Issue 710
 */
@Test public void testEvictedEntryNotNullAfterLockAndGet() throws Exception {
  String mapName=""String_Node_Str"";
  Config config=new XmlConfigBuilder().build();
  MapConfig mapConfig=new MapConfig();
  mapConfig.setName(mapName);
  mapConfig.setTimeToLiveSeconds(3);
  config.addMapConfig(mapConfig);
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  IMap<Object,Object> m1=h1.getMap(mapName);
  m1.put(1,1);
  assertEquals(1,m1.get(1));
  Thread.sleep(3000);
  assertEquals(null,m1.get(1));
  m1.lock(1);
  assertEquals(null,m1.get(1));
  m1.put(1,1);
  assertEquals(1,m1.get(1));
}","/** 
 * Test for Issue 710
 */
@Test public void testEvictedEntryNotNullAfterLockAndGet() throws Exception {
  String mapName=""String_Node_Str"";
  Config config=new XmlConfigBuilder().build();
  MapConfig mapConfig=new MapConfig();
  mapConfig.setName(mapName);
  mapConfig.setTimeToLiveSeconds(3);
  config.addMapConfig(mapConfig);
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  IMap<Object,Object> m1=h1.getMap(mapName);
  m1.put(1,1);
  assertEquals(1,m1.get(1));
  Thread.sleep(5000);
  assertEquals(null,m1.get(1));
  m1.lock(1);
  assertEquals(null,m1.get(1));
  m1.put(1,1);
  assertEquals(1,m1.get(1));
}",0.9984126984126984
49855,"private void addSessionCookie(final RequestWrapper req,final String sessionId){
  final Cookie sessionCookie=new Cookie(HAZELCAST_SESSION_COOKIE_NAME,sessionId);
  sessionCookie.setPath(req.getContextPath());
  sessionCookie.setMaxAge(-1);
  req.res.addCookie(sessionCookie);
}","private void addSessionCookie(final RequestWrapper req,final String sessionId){
  final Cookie sessionCookie=new Cookie(HAZELCAST_SESSION_COOKIE_NAME,sessionId);
  String path=req.getContextPath();
  if (""String_Node_Str"".equals(path)) {
    path=""String_Node_Str"";
  }
  sessionCookie.setPath(path);
  sessionCookie.setMaxAge(-1);
  req.res.addCookie(sessionCookie);
}",0.7647058823529411
49856,"public CollectionRegion buildCollectionRegion(final String regionName,final Properties properties,final CacheDataDescription metadata) throws CacheException {
  return new HazelcastCollectionRegion(instance,regionName,metadata);
}","public CollectionRegion buildCollectionRegion(final String regionName,final Properties properties,final CacheDataDescription metadata) throws CacheException {
  return new HazelcastCollectionRegion(instance,regionName,properties,metadata);
}",0.9766454352441614
49857,"public EntityRegion buildEntityRegion(final String regionName,final Properties properties,final CacheDataDescription metadata) throws CacheException {
  return new HazelcastEntityRegion(instance,regionName,metadata);
}","public EntityRegion buildEntityRegion(final String regionName,final Properties properties,final CacheDataDescription metadata) throws CacheException {
  return new HazelcastEntityRegion(instance,regionName,properties,metadata);
}",0.9753914988814316
49858,"public TimestampsRegion buildTimestampsRegion(final String regionName,final Properties properties) throws CacheException {
  return new HazelcastTimestampsRegion(instance,regionName);
}","public TimestampsRegion buildTimestampsRegion(final String regionName,final Properties properties) throws CacheException {
  return new HazelcastTimestampsRegion(instance,regionName,properties);
}",0.9711286089238844
49859,"public void stop(){
  LOG.log(Level.INFO,""String_Node_Str"");
  instance.getLifecycleService().shutdown();
}","public void stop(){
  if (instanceLoader != null) {
    LOG.log(Level.INFO,""String_Node_Str"");
    instanceLoader.unloadInstance();
    instance=null;
    instanceLoader=null;
  }
}",0.5625
49860,"public void start(final Settings settings,final Properties properties) throws CacheException {
  LOG.log(Level.INFO,""String_Node_Str"");
  if (instance == null || !instance.getLifecycleService().isRunning()) {
    instance=HazelcastInstanceFactory.createInstance(properties);
  }
}","public void start(final Settings settings,final Properties properties) throws CacheException {
  LOG.log(Level.INFO,""String_Node_Str"");
  if (instance == null || !instance.getLifecycleService().isRunning()) {
    instanceLoader=HazelcastInstanceFactory.createInstanceLoader(properties);
    instance=instanceLoader.loadInstance();
  }
}",0.9090909090909092
49861,"public QueryResultsRegion buildQueryResultsRegion(final String regionName,final Properties properties) throws CacheException {
  return new HazelcastQueryResultsRegion(instance,regionName);
}","public QueryResultsRegion buildQueryResultsRegion(final String regionName,final Properties properties) throws CacheException {
  return new HazelcastQueryResultsRegion(instance,regionName,properties);
}",0.9720101781170484
49862,"public static int getTimeout(HazelcastInstance instance,String regionName){
  int ttl=DEFAULT_TIMEOUT;
  try {
    final MapConfig cfg=instance.getConfig().findMatchingMapConfig(regionName);
    if (cfg.getTimeToLiveSeconds() > 0) {
      ttl=cfg.getTimeToLiveSeconds() * 1000;
    }
  }
 catch (  UnsupportedOperationException ignore) {
  }
  return ttl;
}","public static int getTimeout(HazelcastInstance instance,String regionName){
  try {
    final MapConfig cfg=instance.getConfig().findMatchingMapConfig(regionName);
    if (cfg.getTimeToLiveSeconds() > 0) {
      return cfg.getTimeToLiveSeconds() * 1000;
    }
  }
 catch (  UnsupportedOperationException ignored) {
  }
  return CacheEnvironment.getDefaultCacheTimeoutInMillis();
}",0.5373134328358209
49863,"protected AbstractAccessDelegate(final T hazelcastRegion){
  this.hazelcastRegion=hazelcastRegion;
}","protected AbstractAccessDelegate(final T hazelcastRegion,final Properties props){
  this.hazelcastRegion=hazelcastRegion;
}",0.8968609865470852
49864,"public NonStrictReadWriteAccessDelegate(T hazelcastRegion){
  super(hazelcastRegion);
}","public NonStrictReadWriteAccessDelegate(T hazelcastRegion,final Properties props){
  super(hazelcastRegion,props);
}",0.8571428571428571
49865,"public ReadOnlyAccessDelegate(T hazelcastRegion){
  super(hazelcastRegion);
}","public ReadOnlyAccessDelegate(T hazelcastRegion,final Properties props){
  super(hazelcastRegion,props);
}",0.8415300546448088
49866,"public SoftLock lockItem(final Object key,final Object version) throws CacheException {
  getCache().lock(key);
  return new SoftLock(){
  }
;
}","public SoftLock lockItem(final Object key,final Object version) throws CacheException {
  if (lockTimeout > 0) {
    if (!getCache().tryLock(key,lockTimeout,TimeUnit.SECONDS)) {
      throw new CacheException(""String_Node_Str"" + lockTimeout + ""String_Node_Str"");
    }
  }
 else {
    getCache().lock(key);
  }
  return new SoftLock(){
  }
;
}",0.5626283367556468
49867,"public ReadWriteAccessDelegate(T hazelcastRegion){
  super(hazelcastRegion);
}","public ReadWriteAccessDelegate(T hazelcastRegion,final Properties props){
  super(hazelcastRegion,props);
  lockTimeout=CacheEnvironment.getLockTimeoutInSeconds(props);
}",0.6290322580645161
49868,"public CollectionRegionAccessStrategy buildAccessStrategy(final AccessType accessType) throws CacheException {
  if (null == accessType) {
    throw new CacheException(""String_Node_Str"");
  }
  if (AccessType.READ_ONLY.equals(accessType)) {
    return new ReadOnlyAccessStrategy(this);
  }
  if (AccessType.NONSTRICT_READ_WRITE.equals(accessType)) {
    return new NonStrictReadWriteAccessStrategy(this);
  }
  if (AccessType.READ_WRITE.equals(accessType)) {
    return new ReadWriteAccessStrategy(this);
  }
  if (AccessType.TRANSACTIONAL.equals(accessType)) {
    throw new CacheException(""String_Node_Str"");
  }
  throw new CacheException(""String_Node_Str"" + accessType + ""String_Node_Str"");
}","public CollectionRegionAccessStrategy buildAccessStrategy(final AccessType accessType) throws CacheException {
  if (null == accessType) {
    throw new CacheException(""String_Node_Str"");
  }
  if (AccessType.READ_ONLY.equals(accessType)) {
    return new ReadOnlyAccessStrategy(this,props);
  }
  if (AccessType.NONSTRICT_READ_WRITE.equals(accessType)) {
    return new NonStrictReadWriteAccessStrategy(this,props);
  }
  if (AccessType.READ_WRITE.equals(accessType)) {
    return new ReadWriteAccessStrategy(this,props);
  }
  if (AccessType.TRANSACTIONAL.equals(accessType)) {
    throw new CacheException(""String_Node_Str"");
  }
  throw new CacheException(""String_Node_Str"" + accessType + ""String_Node_Str"");
}",0.9872340425531916
49869,"public HazelcastCollectionRegion(final HazelcastInstance instance,final String regionName,final CacheDataDescription metadata){
  super(instance,regionName,metadata);
}","public HazelcastCollectionRegion(final HazelcastInstance instance,final String regionName,final Properties props,final CacheDataDescription metadata){
  super(instance,regionName,props,metadata);
}",0.9205479452054794
49870,"@Override public void onExpire(){
  request.response=null;
  returnResponse(request);
  setValid(false);
}","@Override public void onExpire(){
  request.response=null;
  pollWaitList.remove(this);
  returnResponse(request);
  setValid(false);
}",0.8796680497925311
49871,"final void handleSocketException(Throwable e){
  if (e instanceof OutOfMemoryError) {
    node.onOutOfMemory((OutOfMemoryError)e);
  }
  if (sk != null) {
    sk.cancel();
  }
  connection.close();
  StringBuilder sb=new StringBuilder();
  sb.append(Thread.currentThread().getName());
  sb.append(""String_Node_Str"");
  sb.append(connection.getEndPoint());
  sb.append(""String_Node_Str"").append(e);
  if (e instanceof IOException) {
    logger.log(Level.WARNING,sb.toString());
  }
 else {
    logger.log(Level.WARNING,sb.toString(),e);
  }
}","final void handleSocketException(Throwable e){
  if (e instanceof OutOfMemoryError) {
    node.onOutOfMemory((OutOfMemoryError)e);
  }
  if (sk != null) {
    sk.cancel();
  }
  connection.close();
  if (connection.getType().isClient() && !connection.getType().isBinary()) {
    return;
  }
  StringBuilder sb=new StringBuilder();
  sb.append(Thread.currentThread().getName());
  sb.append(""String_Node_Str"");
  sb.append(connection.getEndPoint());
  sb.append(""String_Node_Str"").append(e);
  if (e instanceof IOException) {
    logger.log(Level.WARNING,sb.toString());
  }
 else {
    logger.log(Level.WARNING,sb.toString(),e);
  }
}",0.9208510638297872
49872,"/** 
 * See the general contract of the <code>readLine</code> method of <code>DataInput</code>. <p/> Bytes for this operation are read from the contained input stream.
 * @return the next line of text from this input stream.
 * @throws IOException if an I/O error occurs.
 * @see java.io.BufferedReader#readLine()
 * @see java.io.FilterInputStream#in
 * @deprecated This method does not properly convert bytes to characters. Asof JDK&nbsp;1.1, the preferred way to read lines of text is via the <code>BufferedReader.readLine()</code> method. Programs that use the <code>DataInputStream</code> class to read lines can be converted to use the <code>BufferedReader</code> class by replacing code of the form: <blockquote> <p/> <pre> DataInputStream d = new DataInputStream(in); </pre> <p/> </blockquote> with: <blockquote> <p/> <pre> BufferedReader d = new BufferedReader(new InputStreamReader(in)); </pre> <p/> </blockquote>
 */
@Deprecated public final String readLine() throws IOException {
  char buf[]=lineBuffer;
  if (buf == null) {
    buf=lineBuffer=new char[128];
  }
  int room=buf.length;
  int offset=0;
  int c;
  loop:   while (true) {
switch (c=read()) {
case -1:
case '\n':
      break loop;
case '\r':
    final int c2=read();
  if ((c2 != '\n') && (c2 != -1)) {
    new PushbackInputStream(this).unread(c2);
  }
break loop;
default :
if (--room < 0) {
buf=new char[offset + 128];
room=buf.length - offset - 1;
System.arraycopy(lineBuffer,0,buf,0,offset);
lineBuffer=buf;
}
buf[offset++]=(char)c;
break;
}
}
if ((c == -1) && (offset == 0)) {
return null;
}
return String.copyValueOf(buf,0,offset);
}","/** 
 * See the general contract of the <code>readLine</code> method of <code>DataInput</code>. <p/> Bytes for this operation are read from the contained input stream.
 * @return the next line of text from this input stream.
 * @throws IOException if an I/O error occurs.
 * @see java.io.BufferedReader#readLine()
 * @see java.io.FilterInputStream#in
 * @deprecated This method does not properly convert bytes to characters. Asof JDK&nbsp;1.1, the preferred way to read lines of text is via the <code>BufferedReader.readLine()</code> method. Programs that use the <code>DataInputStream</code> class to read lines can be converted to use the <code>BufferedReader</code> class by replacing code of the form: <blockquote> <p/> <pre> DataInputStream d = new DataInputStream(in); </pre> </blockquote> with: <blockquote> <pre> BufferedReader d = new BufferedReader(new InputStreamReader(in)); </pre> </blockquote>
 */
@Deprecated public final String readLine() throws IOException {
  char buf[]=lineBuffer;
  if (buf == null) {
    buf=lineBuffer=new char[128];
  }
  int room=buf.length;
  int offset=0;
  int c;
  loop:   while (true) {
switch (c=read()) {
case -1:
case '\n':
      break loop;
case '\r':
    final int c2=read();
  if ((c2 != '\n') && (c2 != -1)) {
    new PushbackInputStream(this).unread(c2);
  }
break loop;
default :
if (--room < 0) {
buf=new char[offset + 128];
room=buf.length - offset - 1;
System.arraycopy(lineBuffer,0,buf,0,offset);
lineBuffer=buf;
}
buf[offset++]=(char)c;
break;
}
}
if ((c == -1) && (offset == 0)) {
return null;
}
return String.copyValueOf(buf,0,offset);
}",0.94926859632742
49873,"/** 
 * See the general contract of the <code>readUTF</code> method of <code>DataInput</code>. <p/> Bytes for this operation are read from the contained input stream.
 * @return a Unicode string.
 * @throws EOFException           if this input stream reaches the end before reading allthe bytes.
 * @throws IOException            if an I/O error occurs.
 * @throws UTFDataFormatException if the bytes do not represent a valid modified UTF-8encoding of a string.
 * @see java.io.DataInputStream#readUTF(java.io.DataInput)
 */
public final String readUTF() throws IOException {
  StringBuilder result=new StringBuilder();
  int chunkSize=readInt();
  while (chunkSize > 0) {
    result.append(readShortUTF());
    chunkSize--;
  }
  return result.toString();
}","/** 
 * See the general contract of the <code>readUTF</code> method of <code>DataInput</code>. <p/> Bytes for this operation are read from the contained input stream.
 * @return a Unicode string.
 * @throws EOFException           if this input stream reaches the end before reading allthe bytes.
 * @throws IOException            if an I/O error occurs.
 * @throws UTFDataFormatException if the bytes do not represent a valid modified UTF-8encoding of a string.
 * @see java.io.DataInputStream#readUTF(java.io.DataInput)
 */
public final String readUTF() throws IOException {
  boolean isNull=readBoolean();
  if (isNull)   return null;
  int length=readInt();
  StringBuilder result=new StringBuilder(length);
  int chunkSize=length / FastByteArrayOutputStream.STRING_CHUNK_SIZE + 1;
  while (chunkSize > 0) {
    result.append(readShortUTF());
    chunkSize--;
  }
  return result.toString();
}",0.8839177750906893
49874,"public final void writeUTF(final String str) throws IOException {
  int length=str.length();
  int chunkSize=length / STRING_CHUNK_SIZE + 1;
  writeInt(chunkSize);
  for (int i=0; i < chunkSize; i++) {
    int beginIndex=Math.max(0,i * STRING_CHUNK_SIZE - 1);
    int endIndex=Math.min((i + 1) * STRING_CHUNK_SIZE - 1,length);
    writeShortUTF(str.substring(beginIndex,endIndex));
  }
}","public final void writeUTF(final String str) throws IOException {
  boolean isNull=(str == null);
  writeBoolean(isNull);
  if (isNull)   return;
  int length=str.length();
  writeInt(length);
  int chunkSize=length / STRING_CHUNK_SIZE + 1;
  for (int i=0; i < chunkSize; i++) {
    int beginIndex=Math.max(0,i * STRING_CHUNK_SIZE - 1);
    int endIndex=Math.min((i + 1) * STRING_CHUNK_SIZE - 1,length);
    writeShortUTF(str.substring(beginIndex,endIndex));
  }
}",0.8554641598119859
49875,"public static Class<?> loadClass(final ClassLoader classLoader,final String className) throws ClassNotFoundException {
  if (className == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (className.startsWith(""String_Node_Str"")) {
    return AbstractSerializer.class.getClassLoader().loadClass(className);
  }
  ClassLoader theClassLoader=classLoader;
  if (theClassLoader == null) {
    theClassLoader=Thread.currentThread().getContextClassLoader();
  }
  if (theClassLoader != null) {
    return theClassLoader.loadClass(className);
  }
  return ClassLoader.getSystemClassLoader().loadClass(className);
}","public static Class<?> loadClass(final ClassLoader classLoader,final String className) throws ClassNotFoundException {
  if (className == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (className.startsWith(""String_Node_Str"")) {
    return AbstractSerializer.class.getClassLoader().loadClass(className);
  }
  ClassLoader theClassLoader=classLoader;
  if (theClassLoader == null) {
    theClassLoader=Thread.currentThread().getContextClassLoader();
  }
  if (className.startsWith(""String_Node_Str"")) {
    return Class.forName(className,true,theClassLoader);
  }
  if (theClassLoader != null) {
    return theClassLoader.loadClass(className);
  }
  return ClassLoader.getSystemClassLoader().loadClass(className);
}",0.9200581395348836
49876,"void markAsActive(Record record){
  long now=System.currentTimeMillis();
  if (!record.isActive() || !record.isValid(now)) {
    record.setActive();
    record.setCreationTime(now);
    record.setExpirationTime(ttl);
  }
}","void markAsActive(Record record){
  long now=System.currentTimeMillis();
  if (!record.isActive() || !record.isValid(now)) {
    record.setActive();
    record.setCreationTime(now);
    record.setLastUpdateTime(0L);
    record.setExpirationTime(ttl);
  }
}",0.9288702928870292
49877,"public void setLastUpdated(){
  if (expirationTime != Long.MAX_VALUE && expirationTime > 0) {
    long ttl=expirationTime - (lastUpdateTime > 0L ? lastUpdateTime : creationTime);
    setExpirationTime(ttl);
  }
  setLastUpdateTime(System.currentTimeMillis());
}","public void setLastUpdated(){
  if (expirationTime != Long.MAX_VALUE && expirationTime > 0) {
    long ttl=expirationTime - Math.max(lastUpdateTime,creationTime);
    setExpirationTime(ttl);
  }
  setLastUpdateTime(System.currentTimeMillis());
}",0.8735177865612648
49878,"public boolean isCancelled(){
  return false;
}","public boolean isCancelled(){
  return cancelled;
}",0.9183673469387756
49879,"public void setResult(Object obj){
  if (obj == null) {
    obj=NULL;
  }
  result=obj;
}","public void setResult(Object obj){
  result=(obj == null) ? NULL : obj;
}",0.7901234567901234
49880,"public V get(long timeout,TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
  if (result != null) {
    return getResult();
  }
  processResult(remoteCall.getResponse(timeout,unit));
  return getResult();
}","public V get(long timeout,TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
  if (isDone()) {
    return getResult();
  }
  Object response;
  try {
    response=remoteCall.getResponse(timeout,unit);
  }
 catch (  RuntimeException e) {
    response=e.getCause();
  }
  processResult(response);
  return getResult();
}",0.5195246179966044
49881,"public boolean isDone(){
  return false;
}","public boolean isDone(){
  return cancelled || result != null;
}",0.7547169811320755
49882,"public String getName(){
  return name.substring(Prefix.ATOMIC_NUMBER.length());
}","public String getName(){
  return name.substring(Prefix.ATOMIC_LONG.length());
}",0.9506172839506172
49883,"public InstanceType getInstanceType(){
  return InstanceType.ATOMIC_NUMBER;
}","public InstanceType getInstanceType(){
  return InstanceType.ATOMIC_LONG;
}",0.9473684210526316
49884,"public <K,V,E>Object getClientProxy(Object o){
  Object proxy=mapProxies.get(o);
  if (proxy == null) {
synchronized (mapProxies) {
      proxy=mapProxies.get(o);
      if (proxy == null) {
        if (o instanceof String) {
          String name=(String)o;
          if (name.startsWith(Prefix.MAP)) {
            proxy=new MapClientProxy<K,V>(this,name);
          }
 else           if (name.startsWith(Prefix.AS_LIST)) {
            proxy=new ListClientProxy<E>(this,name);
          }
 else           if (name.startsWith(Prefix.SET)) {
            proxy=new SetClientProxy<E>(this,name);
          }
 else           if (name.startsWith(Prefix.QUEUE)) {
            proxy=new QueueClientProxy<E>(this,name);
          }
 else           if (name.startsWith(Prefix.TOPIC)) {
            proxy=new TopicClientProxy<E>(this,name);
          }
 else           if (name.startsWith(Prefix.ATOMIC_NUMBER)) {
            proxy=new AtomicNumberClientProxy(this,name);
          }
 else           if (name.startsWith(Prefix.IDGEN)) {
            proxy=new IdGeneratorClientProxy(this,name);
          }
 else           if (name.startsWith(Prefix.MULTIMAP)) {
            proxy=new MultiMapClientProxy(this,name);
          }
 else           if (name.startsWith(Prefix.SEMAPHORE)) {
            proxy=new SemaphoreClientProxy(this,name);
          }
 else {
            proxy=new LockClientProxy(o,this);
          }
          mapProxies.put(o,proxy);
        }
 else {
          proxy=new LockClientProxy(o,this);
        }
      }
    }
  }
  return mapProxies.get(o);
}","public <K,V,E>Object getClientProxy(Object o){
  Object proxy=mapProxies.get(o);
  if (proxy == null) {
synchronized (mapProxies) {
      proxy=mapProxies.get(o);
      if (proxy == null) {
        if (o instanceof String) {
          String name=(String)o;
          if (name.startsWith(Prefix.MAP)) {
            proxy=new MapClientProxy<K,V>(this,name);
          }
 else           if (name.startsWith(Prefix.AS_LIST)) {
            proxy=new ListClientProxy<E>(this,name);
          }
 else           if (name.startsWith(Prefix.SET)) {
            proxy=new SetClientProxy<E>(this,name);
          }
 else           if (name.startsWith(Prefix.QUEUE)) {
            proxy=new QueueClientProxy<E>(this,name);
          }
 else           if (name.startsWith(Prefix.TOPIC)) {
            proxy=new TopicClientProxy<E>(this,name);
          }
 else           if (name.startsWith(Prefix.ATOMIC_LONG)) {
            proxy=new AtomicNumberClientProxy(this,name);
          }
 else           if (name.startsWith(Prefix.COUNT_DOWN_LATCH)) {
          }
 else           if (name.startsWith(Prefix.IDGEN)) {
            proxy=new IdGeneratorClientProxy(this,name);
          }
 else           if (name.startsWith(Prefix.MULTIMAP)) {
            proxy=new MultiMapClientProxy(this,name);
          }
 else           if (name.startsWith(Prefix.SEMAPHORE)) {
            proxy=new SemaphoreClientProxy(this,name);
          }
 else {
            proxy=new LockClientProxy(o,this);
          }
          mapProxies.put(o,proxy);
        }
 else {
          proxy=new LockClientProxy(o,this);
        }
      }
    }
  }
  return mapProxies.get(o);
}",0.97375
49885,"public AtomicNumber getAtomicNumber(String name){
  return (AtomicNumber)getClientProxy(Prefix.ATOMIC_NUMBER + name);
}","public AtomicNumber getAtomicNumber(String name){
  return (AtomicNumber)getClientProxy(Prefix.ATOMIC_LONG + name);
}",0.9661016949152542
49886,"@Override public boolean equals(Object o){
  if (o instanceof ILock && o != null) {
    return getId().equals(((ILock)o).getId());
  }
 else {
    return false;
  }
}","@Override public boolean equals(Object o){
  if (o != null && o instanceof ILock) {
    return getId().equals(((ILock)o).getId());
  }
 else {
    return false;
  }
}",0.9216867469879518
49887,"public Object getId(){
  return lockObject;
}","public Object getId(){
  return new FactoryImpl.ProxyKey(""String_Node_Str"",lockObject);
}",0.6716417910447762
49888,"void clusterIsDown(Connection oldConnection){
  if (!running) {
    return;
  }
  client.getConnectionManager().destroyConnection(oldConnection);
  if (reconnection.compareAndSet(false,true)) {
    client.runAsyncAndWait(new Runnable(){
      public void run(){
        try {
          final Connection lookForAliveConnection=client.getConnectionManager().lookForAliveConnection();
          if (lookForAliveConnection == null) {
            logger.log(Level.WARNING,""String_Node_Str"" + reconnection);
            if (reconnection.get()) {
              interruptWaitingCalls();
            }
          }
 else {
            if (running) {
              enQueue(RECONNECT_CALL);
            }
          }
        }
 catch (        IOException e) {
          logger.log(Level.WARNING,Thread.currentThread().getName() + ""String_Node_Str"" + e.getMessage(),e);
        }
 finally {
          reconnection.compareAndSet(true,false);
        }
      }
    }
);
  }
}","void clusterIsDown(Connection oldConnection){
  if (!running) {
    interruptWaitingCalls();
    return;
  }
  client.getConnectionManager().destroyConnection(oldConnection);
  if (reconnection.compareAndSet(false,true)) {
    client.runAsyncAndWait(new Runnable(){
      public void run(){
        try {
          final Connection lookForAliveConnection=client.getConnectionManager().lookForAliveConnection();
          if (lookForAliveConnection == null) {
            logger.log(Level.WARNING,""String_Node_Str"" + reconnection);
            if (reconnection.get()) {
              interruptWaitingCalls();
            }
          }
 else {
            if (running) {
              enQueue(RECONNECT_CALL);
            }
          }
        }
 catch (        IOException e) {
          logger.log(Level.WARNING,Thread.currentThread().getName() + ""String_Node_Str"" + e.getMessage(),e);
        }
 finally {
          reconnection.compareAndSet(true,false);
        }
      }
    }
);
  }
}",0.9851205746536684
49889,"protected Packet prepareRequest(ClusterOperation operation,Object key,Object value){
  return prepareRequest(operation,key,value,0,null);
}","Packet prepareRequest(ClusterOperation operation,Object key,Object value){
  return prepareRequest(operation,key,value,0,null);
}",0.9626865671641792
49890,"@Test(expected=IllegalStateException.class,timeout=50000L) public void testNoClusterOnStart() throws Exception {
  final ClientProperties clientProperties=ClientProperties.crateBaseClientProperties(GroupConfig.DEFAULT_GROUP_NAME,GroupConfig.DEFAULT_GROUP_PASSWORD);
  clientProperties.setPropertyValue(ClientPropertyName.INIT_CONNECTION_ATTEMPTS_LIMIT,""String_Node_Str"");
  clientProperties.setPropertyValue(ClientPropertyName.RECONNECTION_TIMEOUT,""String_Node_Str"");
  HazelcastClient.newHazelcastClient(clientProperties,""String_Node_Str"");
}","@Test(expected=IllegalStateException.class,timeout=50000L) public void testNoClusterOnStart() throws Exception {
  final ClientProperties clientProperties=ClientProperties.createBaseClientProperties(GroupConfig.DEFAULT_GROUP_NAME,GroupConfig.DEFAULT_GROUP_PASSWORD);
  clientProperties.setPropertyValue(ClientPropertyName.INIT_CONNECTION_ATTEMPTS_LIMIT,""String_Node_Str"");
  clientProperties.setPropertyValue(ClientPropertyName.RECONNECTION_TIMEOUT,""String_Node_Str"");
  HazelcastClient.newHazelcastClient(clientProperties,""String_Node_Str"");
}",0.999080036798528
49891,"@Test(expected=NoMemberAvailableException.class,timeout=50000L) public void testNoClusterAfterStart() throws Exception {
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(new Config());
  final ClientProperties clientProperties=ClientProperties.crateBaseClientProperties(GroupConfig.DEFAULT_GROUP_NAME,GroupConfig.DEFAULT_GROUP_PASSWORD);
  clientProperties.setPropertyValue(ClientPropertyName.INIT_CONNECTION_ATTEMPTS_LIMIT,""String_Node_Str"");
  clientProperties.setPropertyValue(ClientPropertyName.RECONNECTION_TIMEOUT,""String_Node_Str"");
  HazelcastClient client=newHazelcastClient(clientProperties,h1);
  final IMap<Object,Object> map=client.getMap(""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  h1.getLifecycleService().shutdown();
  map.put(""String_Node_Str"",""String_Node_Str"");
}","@Test(expected=NoMemberAvailableException.class,timeout=50000L) public void testNoClusterAfterStart() throws Exception {
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(new Config());
  final ClientProperties clientProperties=ClientProperties.createBaseClientProperties(GroupConfig.DEFAULT_GROUP_NAME,GroupConfig.DEFAULT_GROUP_PASSWORD);
  clientProperties.setPropertyValue(ClientPropertyName.INIT_CONNECTION_ATTEMPTS_LIMIT,""String_Node_Str"");
  clientProperties.setPropertyValue(ClientPropertyName.RECONNECTION_TIMEOUT,""String_Node_Str"");
  HazelcastClient client=newHazelcastClient(clientProperties,h1);
  final IMap<Object,Object> map=client.getMap(""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  h1.getLifecycleService().shutdown();
  map.put(""String_Node_Str"",""String_Node_Str"");
}",0.9993853718500308
49892,"@Test(timeout=120000L) public void testRestartClusterTwice() throws Exception {
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(new Config());
  final ClientProperties clientProperties=ClientProperties.crateBaseClientProperties(GroupConfig.DEFAULT_GROUP_NAME,GroupConfig.DEFAULT_GROUP_PASSWORD);
  clientProperties.setPropertyValue(ClientPropertyName.INIT_CONNECTION_ATTEMPTS_LIMIT,""String_Node_Str"");
  clientProperties.setPropertyValue(ClientPropertyName.RECONNECTION_ATTEMPTS_LIMIT,""String_Node_Str"");
  clientProperties.setPropertyValue(ClientPropertyName.RECONNECTION_TIMEOUT,""String_Node_Str"");
  HazelcastClient client=newHazelcastClient(clientProperties,h1);
  final IMap<String,String> map=client.getMap(""String_Node_Str"");
  final List<String> values=new ArrayList<String>();
  map.addEntryListener(new EntryAdapter<String,String>(){
    @Override public void entryAdded(    EntryEvent<String,String> event){
      values.add(event.getValue());
    }
    @Override public void entryUpdated(    EntryEvent<String,String> event){
      values.add(event.getValue());
    }
  }
,true);
  final BlockingQueue<LifecycleState> states=new LinkedBlockingQueue<LifecycleState>();
  client.getLifecycleService().addLifecycleListener(new LifecycleListener(){
    public void stateChanged(    LifecycleEvent event){
      states.add(event.getState());
    }
  }
);
  map.put(""String_Node_Str"",""String_Node_Str"");
  for (int i=0; i < 2; i++) {
    h1.getLifecycleService().shutdown();
    assertEquals(LifecycleState.CLIENT_CONNECTION_LOST,states.poll(500L,TimeUnit.MILLISECONDS));
    try {
      map.put(""String_Node_Str"",""String_Node_Str"" + i);
      fail();
    }
 catch (    NoMemberAvailableException e) {
    }
    Thread.sleep(50L);
    try {
      map.put(""String_Node_Str"",""String_Node_Str"" + i);
      fail();
    }
 catch (    NoMemberAvailableException e) {
    }
    Thread.sleep(50L);
    h1=Hazelcast.newHazelcastInstance(new Config());
    assertEquals(LifecycleState.CLIENT_CONNECTION_OPENING,states.poll(500L,TimeUnit.MILLISECONDS));
    assertEquals(LifecycleState.CLIENT_CONNECTION_OPENED,states.poll(1000L,TimeUnit.MILLISECONDS));
    map.put(""String_Node_Str"",""String_Node_Str"" + i);
    Thread.sleep(50L);
  }
  assertArrayEquals(values.toString(),new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},values.toArray(new String[0]));
}","@Test(timeout=120000L) public void testRestartClusterTwice() throws Exception {
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(new Config());
  final ClientProperties clientProperties=ClientProperties.createBaseClientProperties(GroupConfig.DEFAULT_GROUP_NAME,GroupConfig.DEFAULT_GROUP_PASSWORD);
  clientProperties.setPropertyValue(ClientPropertyName.INIT_CONNECTION_ATTEMPTS_LIMIT,""String_Node_Str"");
  clientProperties.setPropertyValue(ClientPropertyName.RECONNECTION_ATTEMPTS_LIMIT,""String_Node_Str"");
  clientProperties.setPropertyValue(ClientPropertyName.RECONNECTION_TIMEOUT,""String_Node_Str"");
  HazelcastClient client=newHazelcastClient(clientProperties,h1);
  final IMap<String,String> map=client.getMap(""String_Node_Str"");
  final List<String> values=new ArrayList<String>();
  map.addEntryListener(new EntryAdapter<String,String>(){
    @Override public void entryAdded(    EntryEvent<String,String> event){
      values.add(event.getValue());
    }
    @Override public void entryUpdated(    EntryEvent<String,String> event){
      values.add(event.getValue());
    }
  }
,true);
  final BlockingQueue<LifecycleState> states=new LinkedBlockingQueue<LifecycleState>();
  client.getLifecycleService().addLifecycleListener(new LifecycleListener(){
    public void stateChanged(    LifecycleEvent event){
      states.add(event.getState());
    }
  }
);
  map.put(""String_Node_Str"",""String_Node_Str"");
  for (int i=0; i < 2; i++) {
    h1.getLifecycleService().shutdown();
    assertEquals(LifecycleState.CLIENT_CONNECTION_LOST,states.poll(500L,TimeUnit.MILLISECONDS));
    try {
      map.put(""String_Node_Str"",""String_Node_Str"" + i);
      fail();
    }
 catch (    NoMemberAvailableException e) {
    }
    Thread.sleep(50L);
    try {
      map.put(""String_Node_Str"",""String_Node_Str"" + i);
      fail();
    }
 catch (    NoMemberAvailableException e) {
    }
    Thread.sleep(50L);
    h1=Hazelcast.newHazelcastInstance(new Config());
    assertEquals(LifecycleState.CLIENT_CONNECTION_OPENING,states.poll(500L,TimeUnit.MILLISECONDS));
    assertEquals(LifecycleState.CLIENT_CONNECTION_OPENED,states.poll(1000L,TimeUnit.MILLISECONDS));
    map.put(""String_Node_Str"",""String_Node_Str"" + i);
    Thread.sleep(50L);
  }
  assertArrayEquals(values.toString(),new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},values.toArray(new String[0]));
}",0.9997895179962112
49893,"@Test(timeout=120000L) public void testRestartCluster() throws Exception {
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(new Config());
  final ClientProperties clientProperties=ClientProperties.crateBaseClientProperties(GroupConfig.DEFAULT_GROUP_NAME,GroupConfig.DEFAULT_GROUP_PASSWORD);
  clientProperties.setPropertyValue(ClientPropertyName.INIT_CONNECTION_ATTEMPTS_LIMIT,""String_Node_Str"");
  clientProperties.setPropertyValue(ClientPropertyName.RECONNECTION_ATTEMPTS_LIMIT,""String_Node_Str"");
  clientProperties.setPropertyValue(ClientPropertyName.RECONNECTION_TIMEOUT,""String_Node_Str"");
  HazelcastClient client=newHazelcastClient(clientProperties,h1);
  final IMap<String,String> map=client.getMap(""String_Node_Str"");
  final List<String> values=new CopyOnWriteArrayList<String>();
  map.addEntryListener(new EntryAdapter<String,String>(){
    @Override public void entryAdded(    EntryEvent<String,String> event){
      values.add(event.getValue());
    }
    @Override public void entryUpdated(    EntryEvent<String,String> event){
      values.add(event.getValue());
    }
  }
,true);
  final BlockingQueue<LifecycleState> states=new LinkedBlockingQueue<LifecycleState>();
  client.getLifecycleService().addLifecycleListener(new LifecycleListener(){
    public void stateChanged(    LifecycleEvent event){
      states.add(event.getState());
    }
  }
);
  map.put(""String_Node_Str"",""String_Node_Str"");
  Thread.sleep(50L);
  assertArrayEquals(values.toString(),new String[]{""String_Node_Str""},values.toArray(new String[0]));
  h1.getLifecycleService().shutdown();
  assertEquals(LifecycleState.CLIENT_CONNECTION_LOST,states.poll(500L,TimeUnit.MILLISECONDS));
  Thread.sleep(50L);
  try {
    map.put(""String_Node_Str"",""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NoMemberAvailableException e) {
  }
  try {
    map.put(""String_Node_Str"",""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NoMemberAvailableException e) {
  }
  h1=Hazelcast.newHazelcastInstance(new Config());
  assertEquals(LifecycleState.CLIENT_CONNECTION_OPENING,states.poll(500L,TimeUnit.MILLISECONDS));
  assertEquals(LifecycleState.CLIENT_CONNECTION_OPENED,states.poll(30000L,TimeUnit.MILLISECONDS));
  map.put(""String_Node_Str"",""String_Node_Str"");
  Thread.sleep(50L);
  assertArrayEquals(values.toString(),new String[]{""String_Node_Str"",""String_Node_Str""},values.toArray(new String[0]));
}","@Test(timeout=120000L) public void testRestartCluster() throws Exception {
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(new Config());
  final ClientProperties clientProperties=ClientProperties.createBaseClientProperties(GroupConfig.DEFAULT_GROUP_NAME,GroupConfig.DEFAULT_GROUP_PASSWORD);
  clientProperties.setPropertyValue(ClientPropertyName.INIT_CONNECTION_ATTEMPTS_LIMIT,""String_Node_Str"");
  clientProperties.setPropertyValue(ClientPropertyName.RECONNECTION_ATTEMPTS_LIMIT,""String_Node_Str"");
  clientProperties.setPropertyValue(ClientPropertyName.RECONNECTION_TIMEOUT,""String_Node_Str"");
  HazelcastClient client=newHazelcastClient(clientProperties,h1);
  final IMap<String,String> map=client.getMap(""String_Node_Str"");
  final List<String> values=new CopyOnWriteArrayList<String>();
  map.addEntryListener(new EntryAdapter<String,String>(){
    @Override public void entryAdded(    EntryEvent<String,String> event){
      values.add(event.getValue());
    }
    @Override public void entryUpdated(    EntryEvent<String,String> event){
      values.add(event.getValue());
    }
  }
,true);
  final BlockingQueue<LifecycleState> states=new LinkedBlockingQueue<LifecycleState>();
  client.getLifecycleService().addLifecycleListener(new LifecycleListener(){
    public void stateChanged(    LifecycleEvent event){
      states.add(event.getState());
    }
  }
);
  map.put(""String_Node_Str"",""String_Node_Str"");
  Thread.sleep(50L);
  assertArrayEquals(values.toString(),new String[]{""String_Node_Str""},values.toArray(new String[0]));
  h1.getLifecycleService().shutdown();
  assertEquals(LifecycleState.CLIENT_CONNECTION_LOST,states.poll(500L,TimeUnit.MILLISECONDS));
  Thread.sleep(50L);
  try {
    map.put(""String_Node_Str"",""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NoMemberAvailableException e) {
  }
  try {
    map.put(""String_Node_Str"",""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  NoMemberAvailableException e) {
  }
  h1=Hazelcast.newHazelcastInstance(new Config());
  assertEquals(LifecycleState.CLIENT_CONNECTION_OPENING,states.poll(500L,TimeUnit.MILLISECONDS));
  assertEquals(LifecycleState.CLIENT_CONNECTION_OPENED,states.poll(30000L,TimeUnit.MILLISECONDS));
  map.put(""String_Node_Str"",""String_Node_Str"");
  Thread.sleep(50L);
  assertArrayEquals(values.toString(),new String[]{""String_Node_Str"",""String_Node_Str""},values.toArray(new String[0]));
}",0.9997927461139896
49894,"@Test(expected=NoMemberAvailableException.class) public void testNoClusterAfterStartIssue328() throws Exception {
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(new Config());
  final ClientProperties clientProperties=ClientProperties.crateBaseClientProperties(GroupConfig.DEFAULT_GROUP_NAME,GroupConfig.DEFAULT_GROUP_PASSWORD);
  clientProperties.setPropertyValue(ClientPropertyName.INIT_CONNECTION_ATTEMPTS_LIMIT,""String_Node_Str"");
  clientProperties.setPropertyValue(ClientPropertyName.RECONNECTION_TIMEOUT,""String_Node_Str"");
  HazelcastClient client=newHazelcastClient(clientProperties,h1);
  final IMap<Object,Object> map=client.getMap(""String_Node_Str"");
  h1.getLifecycleService().shutdown();
  map.put(""String_Node_Str"",""String_Node_Str"");
}","@Test(expected=NoMemberAvailableException.class) public void testNoClusterAfterStartIssue328() throws Exception {
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(new Config());
  final ClientProperties clientProperties=ClientProperties.createBaseClientProperties(GroupConfig.DEFAULT_GROUP_NAME,GroupConfig.DEFAULT_GROUP_PASSWORD);
  clientProperties.setPropertyValue(ClientPropertyName.INIT_CONNECTION_ATTEMPTS_LIMIT,""String_Node_Str"");
  clientProperties.setPropertyValue(ClientPropertyName.RECONNECTION_TIMEOUT,""String_Node_Str"");
  HazelcastClient client=newHazelcastClient(clientProperties,h1);
  final IMap<Object,Object> map=client.getMap(""String_Node_Str"");
  h1.getLifecycleService().shutdown();
  map.put(""String_Node_Str"",""String_Node_Str"");
}",0.999340804218853
49895,"@Test public void testMultiMapGetNameAndType(){
  HazelcastClient hClient=getHazelcastClient();
  MultiMap<String,String> map=hClient.getMultiMap(""String_Node_Str"");
  assertEquals(""String_Node_Str"",map.getName());
  Instance.InstanceType type=map.getInstanceType();
  assertEquals(Instance.InstanceType.MULTIMAP,type);
}","@Test public void testMultiMapGetNameAndType(){
  HazelcastClient hClient=getHazelcastClient();
  MultiMap<String,String> map=hClient.getMultiMap(""String_Node_Str"");
  assertEquals(""String_Node_Str"",map.getName());
  assertTrue(map.getInstanceType().isMultiMap());
}",0.7938671209540034
49896,"@Test @Ignore public void testMapInstanceDestroy() throws Exception {
  IMap<String,String> map=getHazelcastClient().getMap(""String_Node_Str"");
  Thread.sleep(1000);
  Collection<Instance> instances=getHazelcastClient().getInstances();
  boolean found=false;
  for (  Instance instance : instances) {
    if (instance.getInstanceType() == Instance.InstanceType.MAP) {
      IMap imap=(IMap)instance;
      if (imap.getName().equals(""String_Node_Str"")) {
        found=true;
      }
    }
  }
  assertTrue(found);
  map.destroy();
  Thread.sleep(1000);
  found=false;
  instances=getHazelcastClient().getInstances();
  for (  Instance instance : instances) {
    if (instance.getInstanceType() == Instance.InstanceType.MAP) {
      IMap imap=(IMap)instance;
      if (imap.getName().equals(""String_Node_Str"")) {
        found=true;
      }
    }
  }
  assertFalse(found);
}","@Test @Ignore public void testMapInstanceDestroy() throws Exception {
  IMap<String,String> map=getHazelcastClient().getMap(""String_Node_Str"");
  Thread.sleep(1000);
  Collection<Instance> instances=getHazelcastClient().getInstances();
  boolean found=false;
  for (  Instance instance : instances) {
    if (instance.getInstanceType().isMap()) {
      IMap imap=(IMap)instance;
      if (imap.getName().equals(""String_Node_Str"")) {
        found=true;
      }
    }
  }
  assertTrue(found);
  map.destroy();
  Thread.sleep(1000);
  found=false;
  instances=getHazelcastClient().getInstances();
  for (  Instance instance : instances) {
    if (instance.getInstanceType().isMap()) {
      IMap imap=(IMap)instance;
      if (imap.getName().equals(""String_Node_Str"")) {
        found=true;
      }
    }
  }
  assertFalse(found);
}",0.9588719153936546
49897,"@Override public void doRun(){
  runningThread=Thread.currentThread();
  ThreadContext.get().setCallContext(callContext);
  if (clientOperationHandler != null) {
    try {
      clientOperationHandler.handle(node,packet);
      node.clientService.getClientEndpoint(packet.conn).removeRequest(this);
    }
 catch (    Throwable e) {
      logger.log(Level.WARNING,e.getMessage(),e);
      if (node.isActive()) {
        throw (RuntimeException)e;
      }
    }
  }
 else {
    final String error=""String_Node_Str"" + packet.operation;
    logger.log(Level.WARNING,error);
    if (node.isActive()) {
      throw new RuntimeException(error);
    }
  }
}","@Override public void doRun(){
  runningThread=Thread.currentThread();
  ThreadContext.get().setCallContext(callContext);
  try {
    clientOperationHandler.handle(node,packet);
    node.clientService.getClientEndpoint(packet.conn).removeRequest(this);
    clientOperationHandler.postHandle(packet);
  }
 catch (  Throwable e) {
    logger.log(Level.WARNING,e.getMessage(),e);
    if (node.isActive()) {
      throw (RuntimeException)e;
    }
  }
}",0.4904284412032816
49898,"public void connectionRemoved(final Connection connection){
  final ClientEndpoint clientEndpoint=mapClientEndpoints.remove(connection);
  if (clientEndpoint != null) {
    node.executorManager.executeNow(new FallThroughRunnable(){
      public void doRun(){
        clientEndpoint.connectionRemoved(connection);
      }
    }
);
  }
}","public void connectionRemoved(final Connection connection){
  final ClientEndpoint clientEndpoint=removeClientEndpoint(connection);
  if (clientEndpoint != null) {
    node.executorManager.executeNow(new FallThroughRunnable(){
      public void doRun(){
        clientEndpoint.connectionRemoved(connection);
      }
    }
);
  }
}",0.9774436090225564
49899,"private void postJoin(){
  if (!node.isMaster()) {
    boolean allConnected=false;
    int checkCount=0;
    if (node.joined()) {
      while (checkCount++ < 100 && !allConnected) {
        try {
          Thread.sleep(1000);
        }
 catch (        InterruptedException ignored) {
        }
        Set<Member> members=node.getClusterImpl().getMembers();
        allConnected=true;
        for (        Member member : members) {
          MemberImpl memberImpl=(MemberImpl)member;
          if (!memberImpl.localMember() && node.connectionManager.getConnection(memberImpl.getAddress()) == null) {
            allConnected=false;
          }
        }
      }
    }
    if (!node.joined() || !allConnected) {
      logger.log(Level.WARNING,""String_Node_Str"" + node.joined() + ""String_Node_Str""+ allConnected+ ""String_Node_Str""+ checkCount+ ""String_Node_Str"");
      logger.log(Level.WARNING,""String_Node_Str"");
      try {
        Thread.sleep(10000);
      }
 catch (      InterruptedException e) {
        node.shutdown();
      }
      node.rejoin();
      return;
    }
 else {
      node.clusterManager.finalizeJoin();
    }
  }
  node.clusterManager.enqueueAndWait(new Processable(){
    public void process(){
      if (node.baseVariables.lsMembers.size() == 1) {
        final StringBuilder sb=new StringBuilder();
        sb.append(""String_Node_Str"");
        sb.append(node.clusterManager);
        logger.log(Level.INFO,sb.toString());
      }
    }
  }
,5);
}","private void postJoin(){
  if (tryCount.incrementAndGet() == 5) {
    node.setAsMaster();
  }
  if (!node.isMaster()) {
    boolean allConnected=false;
    int checkCount=0;
    if (node.joined()) {
      while (checkCount++ < 100 && !allConnected) {
        try {
          Thread.sleep(1000);
        }
 catch (        InterruptedException ignored) {
        }
        Set<Member> members=node.getClusterImpl().getMembers();
        allConnected=true;
        for (        Member member : members) {
          MemberImpl memberImpl=(MemberImpl)member;
          if (!memberImpl.localMember() && node.connectionManager.getConnection(memberImpl.getAddress()) == null) {
            allConnected=false;
          }
        }
      }
    }
    if (!node.joined() || !allConnected) {
      logger.log(Level.WARNING,""String_Node_Str"" + node.joined() + ""String_Node_Str""+ allConnected+ ""String_Node_Str""+ checkCount+ ""String_Node_Str"");
      logger.log(Level.WARNING,""String_Node_Str"");
      try {
        Thread.sleep(10000);
      }
 catch (      InterruptedException e) {
        node.shutdown();
      }
      node.rejoin();
      return;
    }
 else {
      node.clusterManager.finalizeJoin();
    }
  }
  node.clusterManager.enqueueAndWait(new Processable(){
    public void process(){
      if (node.baseVariables.lsMembers.size() == 1) {
        final StringBuilder sb=new StringBuilder();
        sb.append(""String_Node_Str"");
        sb.append(node.clusterManager);
        logger.log(Level.INFO,sb.toString());
      }
    }
  }
,5);
}",0.9771295989393436
49900,"public void put(Request req){
  long now=System.currentTimeMillis();
  boolean sendEvictEvent=false;
  Record evictedRecord=null;
  if (req.value == null) {
    req.value=new Data();
  }
  Record record=getRecord(req);
  if (record != null && !record.isValid(now)) {
    if (record.isActive() && record.isEvictable()) {
      sendEvictEvent=true;
      evictedRecord=createNewRecord(record.getKeyData(),record.getValueData());
    }
    record.setValue(null);
    record.setMultiValues(null);
  }
  if (req.operation == CONCURRENT_MAP_PUT_IF_ABSENT) {
    if (record != null && record.isActive() && record.isValid(now) && record.getValueData() != null) {
      req.clearForResponse();
      req.response=record.getValueData();
      return;
    }
  }
 else   if (req.operation == CONCURRENT_MAP_REPLACE_IF_NOT_NULL) {
    if (record == null || !record.isActive() || !record.isValid(now) || record.getValueData() == null) {
      req.value=null;
      return;
    }
  }
 else   if (req.operation == CONCURRENT_MAP_REPLACE_IF_SAME) {
    if (record == null || !record.isActive() || !record.isValid(now)) {
      req.response=Boolean.FALSE;
      return;
    }
    MultiData multiData=(MultiData)toObject(req.value);
    if (multiData == null || multiData.size() != 2) {
      throw new RuntimeException(""String_Node_Str"" + multiData);
    }
    Data expectedOldValue=multiData.getData(0);
    req.value=multiData.getData(1);
    if (!expectedOldValue.equals(record.getValueData())) {
      req.response=Boolean.FALSE;
      return;
    }
  }
  Data oldValue=null;
  if (record == null) {
    record=createNewRecord(req.key,req.value);
    mapRecords.put(req.key,record);
  }
 else {
    markAsActive(record);
    oldValue=(record.isValid(now)) ? record.getValueData() : null;
    record.setValue(req.value);
    record.incrementVersion();
    record.setLastUpdated();
  }
  if (req.ttl > 0 && req.ttl < Long.MAX_VALUE) {
    record.setExpirationTime(req.ttl);
    ttlPerRecord=true;
  }
  if (sendEvictEvent) {
    concurrentMapManager.fireMapEvent(mapListeners,EntryEvent.TYPE_EVICTED,null,evictedRecord,req.caller);
  }
  if (oldValue == null) {
    concurrentMapManager.fireMapEvent(mapListeners,EntryEvent.TYPE_ADDED,null,record,req.caller);
  }
 else {
    fireInvalidation(record);
    concurrentMapManager.fireMapEvent(mapListeners,EntryEvent.TYPE_UPDATED,oldValue,record,req.caller);
  }
  if (req.txnId != -1 || req.operation == ClusterOperation.CONCURRENT_MAP_PUT_AND_UNLOCK) {
    unlock(record,req);
  }
  record.setIndexes(req.indexes,req.indexTypes);
  updateIndexes(record);
  markAsDirty(record);
  req.clearForResponse();
  req.version=record.getVersion();
  req.longValue=record.getCopyCount();
  if (localUpdateListener != null && req.txnId != Long.MIN_VALUE) {
    localUpdateListener.recordUpdated(record);
  }
  if (req.operation == CONCURRENT_MAP_REPLACE_IF_SAME || req.operation == CONCURRENT_MAP_SET) {
    req.response=Boolean.TRUE;
  }
 else {
    req.response=oldValue;
  }
}","public void put(Request req){
  long now=System.currentTimeMillis();
  boolean sendEvictEvent=false;
  Record evictedRecord=null;
  if (req.value == null) {
    req.value=new Data();
  }
  Record record=getRecord(req);
  if (record != null && !record.isValid(now)) {
    if (record.isActive() && record.isEvictable()) {
      sendEvictEvent=true;
      evictedRecord=createNewRecord(record.getKeyData(),record.getValueData());
    }
    record.setValue(null);
    record.setMultiValues(null);
  }
  if (req.operation == CONCURRENT_MAP_PUT_IF_ABSENT) {
    if (!isApplicable(CONCURRENT_MAP_PUT_IF_ABSENT,req,now)) {
      req.clearForResponse();
      req.response=record.getValueData();
      return;
    }
  }
 else   if (req.operation == CONCURRENT_MAP_REPLACE_IF_NOT_NULL) {
    if (!isApplicable(CONCURRENT_MAP_REPLACE_IF_NOT_NULL,req,now)) {
      req.value=null;
      return;
    }
  }
 else   if (req.operation == CONCURRENT_MAP_REPLACE_IF_SAME) {
    if (!isApplicable(CONCURRENT_MAP_REPLACE_IF_SAME,req,now)) {
      req.response=Boolean.FALSE;
      return;
    }
    MultiData multiData=(MultiData)toObject(req.value);
    req.value=multiData.getData(1);
  }
  Data oldValue=null;
  if (record == null) {
    record=createNewRecord(req.key,req.value);
    mapRecords.put(req.key,record);
  }
 else {
    markAsActive(record);
    oldValue=(record.isValid(now)) ? record.getValueData() : null;
    record.setValue(req.value);
    record.incrementVersion();
    record.setLastUpdated();
  }
  if (req.ttl > 0 && req.ttl < Long.MAX_VALUE) {
    record.setExpirationTime(req.ttl);
    ttlPerRecord=true;
  }
  if (sendEvictEvent) {
    concurrentMapManager.fireMapEvent(mapListeners,EntryEvent.TYPE_EVICTED,null,evictedRecord,req.caller);
  }
  if (oldValue == null) {
    concurrentMapManager.fireMapEvent(mapListeners,EntryEvent.TYPE_ADDED,null,record,req.caller);
  }
 else {
    fireInvalidation(record);
    concurrentMapManager.fireMapEvent(mapListeners,EntryEvent.TYPE_UPDATED,oldValue,record,req.caller);
  }
  if (req.txnId != -1 || req.operation == ClusterOperation.CONCURRENT_MAP_PUT_AND_UNLOCK) {
    unlock(record,req);
  }
  record.setIndexes(req.indexes,req.indexTypes);
  updateIndexes(record);
  markAsDirty(record);
  req.clearForResponse();
  req.version=record.getVersion();
  req.longValue=record.getCopyCount();
  if (localUpdateListener != null && req.txnId != Long.MIN_VALUE) {
    localUpdateListener.recordUpdated(record);
  }
  if (req.operation == CONCURRENT_MAP_REPLACE_IF_SAME || req.operation == CONCURRENT_MAP_SET) {
    req.response=Boolean.TRUE;
  }
 else {
    req.response=oldValue;
  }
}",0.8482158707615836
49901,"void storeProceed(CMap cmap,Request request){
  if (cmap.store != null && cmap.writeDelayMillis == 0) {
    storeExecutor.execute(new PutStorer(cmap,request),request.key.hashCode());
  }
 else {
    doOperation(request);
    returnResponse(request);
  }
}","void storeProceed(CMap cmap,Request request){
  if (cmap.store != null && cmap.writeDelayMillis == 0 && cmap.isApplicable(request.operation,request,System.currentTimeMillis())) {
    storeExecutor.execute(new PutStorer(cmap,request),request.key.hashCode());
  }
 else {
    doOperation(request);
    returnResponse(request);
  }
}",0.8717948717948718
49902,"protected void backup(ClusterOperation operation){
  if (thisAddress.equals(target) && (operation == CONCURRENT_MAP_LOCK || operation == CONCURRENT_MAP_UNLOCK || operation == ClusterOperation.SEMAPHORE_ACQUIRE || operation == ClusterOperation.SEMAPHORE_RELEASE || operation == SEMAPHORE_DRAIN_PERMITS || operation == ClusterOperation.SEMAPHORE_REDUCE_PERMITS)) {
    return;
  }
  if (backupCount > 0) {
    for (int i=0; i < backupCount; i++) {
      int distance=i + 1;
      MBackup backupOp=backupOps[i];
      if (backupOp == null) {
        backupOp=new MBackup();
        backupOps[i]=backupOp;
      }
      if (request.key == null || request.key.size() == 0) {
        throw new RuntimeException(""String_Node_Str"" + request.key);
      }
      backupOp.sendBackup(operation,target,distance,request);
    }
    for (int i=0; i < backupCount; i++) {
      MBackup backupOp=backupOps[i];
      backupOp.getResultAsBoolean();
    }
  }
}","protected void backup(ClusterOperation operation){
  if (thisAddress.equals(target) && (operation == CONCURRENT_MAP_LOCK || operation == CONCURRENT_MAP_UNLOCK || operation == SEMAPHORE_ACQUIRE || operation == SEMAPHORE_RELEASE || operation == SEMAPHORE_DRAIN_PERMITS || operation == SEMAPHORE_REDUCE_PERMITS)) {
    return;
  }
  if (backupCount > 0) {
    for (int i=0; i < backupCount; i++) {
      int distance=i + 1;
      MBackup backupOp=backupOps[i];
      if (backupOp == null) {
        backupOp=new MBackup();
        backupOps[i]=backupOp;
      }
      if (request.key == null || request.key.size() == 0) {
        throw new RuntimeException(""String_Node_Str"" + request.key);
      }
      backupOp.sendBackup(operation,target,distance,request);
    }
    for (int i=0; i < backupCount; i++) {
      MBackup backupOp=backupOps[i];
      backupOp.getResultAsBoolean();
    }
  }
}",0.972176759410802
49903,"public void shutdown(){
  for (  CMap cmap : maps.values()) {
    try {
      flush(cmap.name);
    }
 catch (    Throwable e) {
      if (node.isActive()) {
        logger.log(Level.SEVERE,e.getMessage(),e);
      }
    }
  }
}","public void shutdown(){
  for (  CMap cmap : maps.values()) {
    try {
      flush(cmap.name);
      cmap.reset();
    }
 catch (    Throwable e) {
      if (node.isActive()) {
        logger.log(Level.SEVERE,e.getMessage(),e);
      }
    }
  }
}",0.957983193277311
49904,"public void destroy(){
  if (impl instanceof MapLoaderLifecycleSupport) {
    ((MapLoaderLifecycleSupport)impl).destroy();
  }
}","public void destroy(){
  if (shouldInitialize && initialized) {
synchronized (initLock) {
      if (initialized) {
        ((MapLoaderLifecycleSupport)impl).destroy();
        initialized=false;
      }
    }
  }
}",0.4327485380116959
49905,"@Test public void testOneMemberFlushOnShutdown() throws Exception {
  TestMapStore testMapStore=new TestMapStore(1,1,1);
  testMapStore.setLoadAllKeys(false);
  Config config=newConfig(testMapStore,200);
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  IMap map1=h1.getMap(""String_Node_Str"");
  assertEquals(0,map1.size());
  for (int i=0; i < 100; i++) {
    map1.put(i,i);
  }
  assertEquals(100,map1.size());
  assertEquals(0,testMapStore.getStore().size());
  h1.getLifecycleService().shutdown();
  assertEquals(100,testMapStore.getStore().size());
}","@Test public void testOneMemberFlushOnShutdown() throws Exception {
  TestMapStore testMapStore=new TestMapStore(1,1,1);
  testMapStore.setLoadAllKeys(false);
  Config config=newConfig(testMapStore,200);
  HazelcastInstance h1=Hazelcast.newHazelcastInstance(config);
  IMap map1=h1.getMap(""String_Node_Str"");
  assertEquals(0,map1.size());
  for (int i=0; i < 100; i++) {
    map1.put(i,i);
  }
  assertEquals(100,map1.size());
  assertEquals(0,testMapStore.getStore().size());
  h1.getLifecycleService().shutdown();
  assertEquals(100,testMapStore.getStore().size());
  assertEquals(1,testMapStore.getDestroyCount());
}",0.957983193277311
49906,"protected void handleHelp(String command){
  boolean silentBefore=silent;
  silent=false;
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  silent=silentBefore;
}","protected void handleHelp(String command){
  boolean silentBefore=silent;
  silent=false;
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  println(""String_Node_Str"");
  silent=silentBefore;
}",0.9930843706777316
49907,"public boolean writeTo(ByteBuffer bb){
  if (value != null) {
    IOUtil.copyToHeapBuffer(value,bb);
  }
  if (lastOne != null) {
    IOUtil.copyToHeapBuffer(lastOne,bb);
  }
  return !(value != null && value.hasRemaining()) || (lastOne != null && lastOne.hasRemaining());
}","public boolean writeTo(ByteBuffer bb){
  if (value != null) {
    IOUtil.copyToHeapBuffer(value,bb);
  }
  if (lastOne != null) {
    IOUtil.copyToHeapBuffer(lastOne,bb);
  }
  return !((value != null && value.hasRemaining()) || (lastOne != null && lastOne.hasRemaining()));
}",0.9963636363636365
49908,"@Override public String toString(){
  return ""String_Node_Str"" + ""String_Node_Str"" + key + '\''+ '}'+ super.toString();
}","@Override public String toString(){
  return ""String_Node_Str"" + ""String_Node_Str"" + key + ""String_Node_Str""+ value+ '\''+ ""String_Node_Str""+ super.toString();
}",0.8368794326241135
49909,"private Object doGetValue(Object obj){
  if (obj instanceof MapEntry) {
    obj=((MapEntry)obj).getValue();
  }
  if (obj == null)   return null;
  try {
    if (getter == null) {
      Getter parent=null;
      Class clazz=obj.getClass();
      List<String> possibleMethodNames=new ArrayList<String>(3);
      for (      final String name : input.split(""String_Node_Str"")) {
        Getter localGetter=null;
        possibleMethodNames.clear();
        possibleMethodNames.add(name);
        final String camelName=Character.toUpperCase(name.charAt(0)) + name.substring(1);
        possibleMethodNames.add(""String_Node_Str"" + camelName);
        possibleMethodNames.add(""String_Node_Str"" + camelName);
        for (        String methodName : possibleMethodNames) {
          try {
            final Method method=clazz.getMethod(methodName,null);
            method.setAccessible(true);
            localGetter=new MethodGetter(parent,method);
            clazz=method.getReturnType();
            break;
          }
 catch (          NoSuchMethodException ignored) {
          }
        }
        if (localGetter == null) {
          try {
            final Field field=clazz.getField(name);
            localGetter=new FieldGetter(parent,field);
            clazz=field.getType();
          }
 catch (          NoSuchFieldException ignored) {
          }
        }
        if (localGetter == null) {
          Class c=clazz;
          while (!Object.class.equals(c)) {
            try {
              final Field field=c.getDeclaredField(name);
              field.setAccessible(true);
              localGetter=new FieldGetter(parent,field);
              clazz=field.getType();
              break;
            }
 catch (            NoSuchFieldException ignored) {
              c=c.getSuperclass();
            }
          }
        }
        if (localGetter == null) {
          throw new RuntimeException(""String_Node_Str"" + name + ""String_Node_Str"");
        }
        parent=localGetter;
      }
      getter=parent;
    }
    return getter.getValue(obj);
  }
 catch (  Throwable e) {
    throw new RuntimeException(e);
  }
}","private Object doGetValue(Object obj){
  if (obj instanceof MapEntry) {
    obj=((MapEntry)obj).getValue();
  }
  if (obj == null)   return null;
  try {
    if (getter == null) {
      Getter parent=null;
      Class clazz=obj.getClass();
      List<String> possibleMethodNames=new ArrayList<String>(3);
      for (      final String name : input.split(""String_Node_Str"")) {
        Getter localGetter=null;
        possibleMethodNames.clear();
        possibleMethodNames.add(name);
        final String camelName=Character.toUpperCase(name.charAt(0)) + name.substring(1);
        possibleMethodNames.add(""String_Node_Str"" + camelName);
        possibleMethodNames.add(""String_Node_Str"" + camelName);
        if (name.equals(""String_Node_Str"")) {
          localGetter=new ThisGetter(parent,obj);
        }
 else {
          for (          String methodName : possibleMethodNames) {
            try {
              final Method method=clazz.getMethod(methodName,null);
              method.setAccessible(true);
              localGetter=new MethodGetter(parent,method);
              clazz=method.getReturnType();
              break;
            }
 catch (            NoSuchMethodException ignored) {
            }
          }
          if (localGetter == null) {
            try {
              final Field field=clazz.getField(name);
              localGetter=new FieldGetter(parent,field);
              clazz=field.getType();
            }
 catch (            NoSuchFieldException ignored) {
            }
          }
          if (localGetter == null) {
            Class c=clazz;
            while (!Object.class.equals(c)) {
              try {
                final Field field=c.getDeclaredField(name);
                field.setAccessible(true);
                localGetter=new FieldGetter(parent,field);
                clazz=field.getType();
                break;
              }
 catch (              NoSuchFieldException ignored) {
                c=c.getSuperclass();
              }
            }
          }
        }
        if (localGetter == null) {
          throw new RuntimeException(""String_Node_Str"" + name + ""String_Node_Str"");
        }
        parent=localGetter;
      }
      getter=parent;
    }
    return getter.getValue(obj);
  }
 catch (  Throwable e) {
    throw new RuntimeException(e);
  }
}",0.9476275738585496
49910,"Object getValue(Object obj) throws Exception {
  obj=parent != null ? parent.getValue(obj) : obj;
  return obj != null ? field.get(obj) : null;
}","@Override Object getValue(Object obj) throws Exception {
  return obj;
}",0.5714285714285714
49911,"Class getReturnType(){
  return this.field.getType();
}","@Override Class getReturnType(){
  return this.object.getClass();
}",0.7704918032786885
49912,"public ConnectionManager(final HazelcastClient client,LifecycleServiceClientImpl lifecycleService,InetSocketAddress address){
  this.client=client;
  this.lifecycleService=lifecycleService;
  this.clusterMembers.add(address);
}","public ConnectionManager(final HazelcastClient client,LifecycleServiceClientImpl lifecycleService,InetSocketAddress address,long timeout){
  this.TIMEOUT=timeout;
  this.client=client;
  this.lifecycleService=lifecycleService;
  this.clusterMembers.add(address);
  scheduleAHeartBeatThread();
}",0.7293666026871402
49913,"protected void customRun() throws InterruptedException {
  if (reconnection.get()) {
    Thread.sleep(50L);
    return;
  }
  try {
    boolean written=false;
    if (queue.size() > 0 || q.size() > 0) {
      queue.drainTo(q);
      Call call=q.poll();
      while (call != null) {
        writeCall(call);
        written=true;
        call=q.poll();
      }
    }
    try {
      if (written) {
        writer.flush(connection);
      }
    }
 catch (    IOException e) {
      clusterIsDown(connection);
    }
    Call call=queue.poll(12,TimeUnit.MILLISECONDS);
    if (call != null) {
      writeCall(call);
      try {
        writer.flush(connection);
      }
 catch (      IOException e) {
        clusterIsDown(connection);
      }
    }
    if (reconnectionCalls.size() > 0) {
      checkOnReconnect(call);
    }
  }
 catch (  Throwable e) {
    logger.log(Level.FINE,""String_Node_Str"" + connection + ""String_Node_Str""+ e.toString(),e);
  }
}","protected void customRun() throws InterruptedException {
  if (reconnection.get()) {
    Thread.sleep(50L);
    return;
  }
  try {
    boolean written=false;
    if (queue.size() > 0 || q.size() > 0) {
      queue.drainTo(q);
      Call call=q.poll();
      while (call != null) {
        writeCall(call);
        written=true;
        call=q.poll();
      }
    }
    try {
      if (written) {
        writer.flush(connection);
      }
    }
 catch (    IOException e) {
      clusterIsDown(connection);
    }
    Call call=queue.poll(12,TimeUnit.MILLISECONDS);
    if (call != null) {
      writeCall(call);
      System.out.println(""String_Node_Str"" + call);
      lastSend=System.currentTimeMillis();
      try {
        writer.flush(connection);
      }
 catch (      IOException e) {
        clusterIsDown(connection);
      }
    }
    if (reconnectionCalls.size() > 0) {
      checkOnReconnect(call);
    }
  }
 catch (  Throwable e) {
    logger.log(Level.FINE,""String_Node_Str"" + connection + ""String_Node_Str""+ e.toString(),e);
  }
}",0.9524286429644466
49914,"/** 
 * executorThread
 */
public void execute(Request request){
  CMap cmap=maps.get(request.name);
  if (request.operation == CONCURRENT_MAP_GET) {
    Object value=cmap.loader.load(toObject(request.key));
    if (value != null) {
      setIndexValues(request,value);
      request.value=toData(value);
    }
    putTransient(request);
  }
 else   if (request.operation == CONCURRENT_MAP_PUT || request.operation == CONCURRENT_MAP_PUT_IF_ABSENT) {
    Object key=toObject(request.key);
    Object value=toObject(request.value);
    cmap.store.store(key,value);
    Record storedRecord=cmap.getRecord(request);
    if (storedRecord != null) {
      storedRecord.setLastStoredTime(System.currentTimeMillis());
    }
  }
 else   if (request.operation == CONCURRENT_MAP_REMOVE) {
    Object key=toObject(request.key);
    if (cmap.loader != null && request.value == null) {
      Object removedObject=cmap.loader.load(key);
      if (removedObject == null) {
        return;
      }
 else {
        request.response=toData(removedObject);
      }
    }
    cmap.store.delete(key);
  }
 else   if (request.operation == CONCURRENT_MAP_EVICT) {
    cmap.store.store(toObject(request.key),toObject(request.value));
    Record storedRecord=cmap.getRecord(request);
    storedRecord.setLastStoredTime(System.currentTimeMillis());
    request.response=Boolean.TRUE;
  }
 else   if (request.operation == CONCURRENT_MAP_MERGE) {
    boolean success=false;
    Object winner=null;
    if (cmap.mergePolicy != null) {
      Record existingRecord=cmap.getRecord(request);
      DataRecordEntry existing=(existingRecord == null) ? null : new DataRecordEntry(existingRecord);
      DataRecordEntry newEntry=(DataRecordEntry)toObject(request.value);
      Object key=newEntry.getKey();
      if (key != null && newEntry.hasValue()) {
        winner=cmap.mergePolicy.merge(cmap.getName(),newEntry,existing);
        if (winner != null) {
          success=true;
          if (cmap.writeDelayMillis == 0 && cmap.store != null) {
            Object winnerObject=(winner instanceof Data) ? toObject((Data)winner) : winner;
            cmap.store.store(key,winnerObject);
            existingRecord.setLastStoredTime(System.currentTimeMillis());
            success=(request.response == null);
          }
        }
      }
    }
    if (success) {
      request.value=toData(winner);
      request.response=Boolean.TRUE;
    }
 else {
      request.value=null;
      request.response=Boolean.FALSE;
    }
  }
}","/** 
 * executorThread
 */
public void execute(Request request){
  CMap cmap=maps.get(request.name);
  if (request.operation == CONCURRENT_MAP_GET) {
    Object value=cmap.loader.load(toObject(request.key));
    if (value != null) {
      setIndexValues(request,value);
      request.value=toData(value);
    }
    putTransient(request);
  }
 else   if (request.operation == CONCURRENT_MAP_PUT || request.operation == CONCURRENT_MAP_PUT_IF_ABSENT) {
    Object key=toObject(request.key);
    Object value=toObject(request.value);
    cmap.store.store(key,value);
    Record storedRecord=cmap.getRecord(request);
    if (storedRecord != null) {
      storedRecord.setLastStoredTime(System.currentTimeMillis());
    }
  }
 else   if (request.operation == CONCURRENT_MAP_REMOVE) {
    Object key=toObject(request.key);
    Record record=cmap.getRecord(request);
    if (cmap.loader != null && request.value == null && (record == null || record.getValueData() == null)) {
      Object removedObject=cmap.loader.load(key);
      if (removedObject == null) {
        return;
      }
 else {
        request.response=toData(removedObject);
      }
    }
    cmap.store.delete(key);
  }
 else   if (request.operation == CONCURRENT_MAP_EVICT) {
    cmap.store.store(toObject(request.key),toObject(request.value));
    Record storedRecord=cmap.getRecord(request);
    storedRecord.setLastStoredTime(System.currentTimeMillis());
    request.response=Boolean.TRUE;
  }
 else   if (request.operation == CONCURRENT_MAP_MERGE) {
    boolean success=false;
    Object winner=null;
    if (cmap.mergePolicy != null) {
      Record existingRecord=cmap.getRecord(request);
      DataRecordEntry existing=(existingRecord == null) ? null : new DataRecordEntry(existingRecord);
      DataRecordEntry newEntry=(DataRecordEntry)toObject(request.value);
      Object key=newEntry.getKey();
      if (key != null && newEntry.hasValue()) {
        winner=cmap.mergePolicy.merge(cmap.getName(),newEntry,existing);
        if (winner != null) {
          success=true;
          if (cmap.writeDelayMillis == 0 && cmap.store != null) {
            Object winnerObject=(winner instanceof Data) ? toObject((Data)winner) : winner;
            cmap.store.store(key,winnerObject);
            existingRecord.setLastStoredTime(System.currentTimeMillis());
            success=(request.response == null);
          }
        }
      }
    }
    if (success) {
      request.value=toData(winner);
      request.response=Boolean.TRUE;
    }
 else {
      request.value=null;
      request.response=Boolean.FALSE;
    }
  }
}",0.9810800157666536
49915,"public void put(Request req){
  long now=System.currentTimeMillis();
  boolean sendEvictEvent=false;
  Record evictedRecord=null;
  if (req.value == null) {
    req.value=new Data();
  }
  Record record=getRecord(req);
  if (record != null && !record.isValid(now)) {
    if (record.isActive() && record.isEvictable()) {
      sendEvictEvent=true;
      evictedRecord=createNewRecord(record.getKeyData(),record.getValueData());
    }
    record.setValue(null);
    record.setMultiValues(null);
  }
  if (req.operation == CONCURRENT_MAP_PUT_IF_ABSENT) {
    if (record != null && record.isActive() && record.isValid(now) && record.getValueData() != null) {
      req.clearForResponse();
      req.response=record.getValueData();
      return;
    }
  }
 else   if (req.operation == CONCURRENT_MAP_REPLACE_IF_NOT_NULL) {
    if (record == null || !record.isActive() || !record.isValid(now) || record.getValueData() == null) {
      req.value=null;
      return;
    }
  }
 else   if (req.operation == CONCURRENT_MAP_REPLACE_IF_SAME) {
    if (record == null || !record.isActive() || !record.isValid(now)) {
      req.response=Boolean.FALSE;
      return;
    }
    MultiData multiData=(MultiData)toObject(req.value);
    if (multiData == null || multiData.size() != 2) {
      throw new RuntimeException(""String_Node_Str"" + multiData);
    }
    Data expectedOldValue=multiData.getData(0);
    req.value=multiData.getData(1);
    if (!expectedOldValue.equals(record.getValueData())) {
      req.response=Boolean.FALSE;
      return;
    }
  }
  Data oldValue=null;
  if (record == null) {
    record=createNewRecord(req.key,req.value);
    mapRecords.put(req.key,record);
  }
 else {
    markAsActive(record);
    oldValue=(record.isValid(now)) ? record.getValueData() : null;
    record.setValue(req.value);
    record.incrementVersion();
    record.setLastUpdated();
  }
  if (req.ttl > 0 && req.ttl < Long.MAX_VALUE) {
    record.setExpirationTime(req.ttl);
    ttlPerRecord=true;
  }
  if (sendEvictEvent) {
    concurrentMapManager.fireMapEvent(mapListeners,EntryEvent.TYPE_EVICTED,null,evictedRecord,req.caller);
  }
  if (oldValue == null) {
    concurrentMapManager.fireMapEvent(mapListeners,EntryEvent.TYPE_ADDED,null,record,req.caller);
  }
 else {
    fireInvalidation(record);
    concurrentMapManager.fireMapEvent(mapListeners,EntryEvent.TYPE_UPDATED,oldValue,record,req.caller);
  }
  if (req.txnId != -1 || req.operation == ClusterOperation.CONCURRENT_MAP_PUT_AND_UNLOCK) {
    unlock(record);
  }
  record.setIndexes(req.indexes,req.indexTypes);
  updateIndexes(record);
  markAsDirty(record);
  req.clearForResponse();
  req.version=record.getVersion();
  req.longValue=record.getCopyCount();
  if (localUpdateListener != null && req.txnId != Long.MIN_VALUE) {
    localUpdateListener.recordUpdated(record);
  }
  if (req.operation == CONCURRENT_MAP_REPLACE_IF_SAME || req.operation == CONCURRENT_MAP_SET) {
    req.response=Boolean.TRUE;
  }
 else {
    req.response=oldValue;
  }
}","public void put(Request req){
  long now=System.currentTimeMillis();
  boolean sendEvictEvent=false;
  Record evictedRecord=null;
  if (req.value == null) {
    req.value=new Data();
  }
  Record record=getRecord(req);
  if (record != null && !record.isValid(now)) {
    if (record.isActive() && record.isEvictable()) {
      sendEvictEvent=true;
      evictedRecord=createNewRecord(record.getKeyData(),record.getValueData());
    }
    record.setValue(null);
    record.setMultiValues(null);
  }
  if (req.operation == CONCURRENT_MAP_PUT_IF_ABSENT) {
    if (record != null && record.isActive() && record.isValid(now) && record.getValueData() != null) {
      req.clearForResponse();
      req.response=record.getValueData();
      return;
    }
  }
 else   if (req.operation == CONCURRENT_MAP_REPLACE_IF_NOT_NULL) {
    if (record == null || !record.isActive() || !record.isValid(now) || record.getValueData() == null) {
      req.value=null;
      return;
    }
  }
 else   if (req.operation == CONCURRENT_MAP_REPLACE_IF_SAME) {
    if (record == null || !record.isActive() || !record.isValid(now)) {
      req.response=Boolean.FALSE;
      return;
    }
    MultiData multiData=(MultiData)toObject(req.value);
    if (multiData == null || multiData.size() != 2) {
      throw new RuntimeException(""String_Node_Str"" + multiData);
    }
    Data expectedOldValue=multiData.getData(0);
    req.value=multiData.getData(1);
    if (!expectedOldValue.equals(record.getValueData())) {
      req.response=Boolean.FALSE;
      return;
    }
  }
  Data oldValue=null;
  if (record == null) {
    record=createNewRecord(req.key,req.value);
    mapRecords.put(req.key,record);
  }
 else {
    markAsActive(record);
    oldValue=(record.isValid(now)) ? record.getValueData() : null;
    record.setValue(req.value);
    record.incrementVersion();
    record.setLastUpdated();
  }
  if (req.ttl > 0 && req.ttl < Long.MAX_VALUE) {
    record.setExpirationTime(req.ttl);
    ttlPerRecord=true;
  }
  if (sendEvictEvent) {
    concurrentMapManager.fireMapEvent(mapListeners,EntryEvent.TYPE_EVICTED,null,evictedRecord,req.caller);
  }
  if (oldValue == null) {
    concurrentMapManager.fireMapEvent(mapListeners,EntryEvent.TYPE_ADDED,null,record,req.caller);
  }
 else {
    fireInvalidation(record);
    concurrentMapManager.fireMapEvent(mapListeners,EntryEvent.TYPE_UPDATED,oldValue,record,req.caller);
  }
  if (req.txnId != -1 || req.operation == ClusterOperation.CONCURRENT_MAP_PUT_AND_UNLOCK) {
    unlock(record,req);
  }
  record.setIndexes(req.indexes,req.indexTypes);
  updateIndexes(record);
  markAsDirty(record);
  req.clearForResponse();
  req.version=record.getVersion();
  req.longValue=record.getCopyCount();
  if (localUpdateListener != null && req.txnId != Long.MIN_VALUE) {
    localUpdateListener.recordUpdated(record);
  }
  if (req.operation == CONCURRENT_MAP_REPLACE_IF_SAME || req.operation == CONCURRENT_MAP_SET) {
    req.response=Boolean.TRUE;
  }
 else {
    req.response=oldValue;
  }
}",0.9993331110370124
49916,"public boolean putMulti(Request req){
  Record record=getRecord(req);
  boolean added=true;
  if (record == null) {
    record=toRecord(req);
  }
 else {
    if (!record.isActive()) {
      markAsActive(record);
    }
    if (record.containsValue(req.value)) {
      added=false;
    }
  }
  if (added) {
    Data value=req.value;
    updateIndexes(record);
    record.addValue(value);
    record.incrementVersion();
    concurrentMapManager.fireMapEvent(mapListeners,getName(),EntryEvent.TYPE_ADDED,record.getKeyData(),null,value,record.getListeners(),req.caller);
  }
  if (req.txnId != -1) {
    unlock(record);
  }
  req.clearForResponse();
  req.version=record.getVersion();
  return added;
}","public boolean putMulti(Request req){
  Record record=getRecord(req);
  boolean added=true;
  if (record == null) {
    record=toRecord(req);
  }
 else {
    if (!record.isActive()) {
      markAsActive(record);
    }
    if (record.containsValue(req.value)) {
      added=false;
    }
  }
  if (added) {
    Data value=req.value;
    updateIndexes(record);
    record.addValue(value);
    record.incrementVersion();
    concurrentMapManager.fireMapEvent(mapListeners,getName(),EntryEvent.TYPE_ADDED,record.getKeyData(),null,value,record.getListeners(),req.caller);
  }
  if (req.txnId != -1) {
    unlock(record,req);
  }
  req.clearForResponse();
  req.version=record.getVersion();
  return added;
}",0.9971387696709584
49917,"public void onDisconnect(Record record,Address deadAddress){
  if (record == null || deadAddress == null)   return;
  List<ScheduledAction> lsScheduledActions=record.getScheduledActions();
  if (lsScheduledActions != null) {
    if (lsScheduledActions.size() > 0) {
      Iterator<ScheduledAction> it=lsScheduledActions.iterator();
      while (it.hasNext()) {
        ScheduledAction sa=it.next();
        if (deadAddress.equals(sa.getRequest().caller)) {
          node.clusterManager.deregisterScheduledAction(sa);
          sa.setValid(false);
          it.remove();
        }
      }
    }
  }
  if (record.getLockCount() > 0) {
    if (deadAddress.equals(record.getLockAddress())) {
      unlock(record);
    }
  }
  if (record.getValue() instanceof DistributedSemaphore) {
    DistributedSemaphore semaphore=(DistributedSemaphore)record.getValue();
    if (semaphore.hasPermits(deadAddress)) {
      semaphore.releaseAll(deadAddress);
    }
  }
}","public void onDisconnect(Record record,Address deadAddress){
  if (record == null || deadAddress == null)   return;
  List<ScheduledAction> lsScheduledActions=record.getScheduledActions();
  if (lsScheduledActions != null) {
    if (lsScheduledActions.size() > 0) {
      Iterator<ScheduledAction> it=lsScheduledActions.iterator();
      while (it.hasNext()) {
        ScheduledAction sa=it.next();
        if (deadAddress.equals(sa.getRequest().caller)) {
          node.clusterManager.deregisterScheduledAction(sa);
          sa.setValid(false);
          it.remove();
        }
      }
    }
  }
  if (record.getLockCount() > 0) {
    if (deadAddress.equals(record.getLockAddress())) {
      clearLock(record);
    }
  }
  if (record.getValue() instanceof DistributedSemaphore) {
    DistributedSemaphore semaphore=(DistributedSemaphore)record.getValue();
    if (semaphore.hasPermits(deadAddress)) {
      semaphore.releaseAll(deadAddress);
    }
  }
}",0.995285489785228
49918,"public boolean removeMulti(Request req){
  Record record=getRecord(req);
  if (record == null)   return false;
  boolean removed=false;
  if (req.value == null) {
    removed=true;
    markAsRemoved(record);
  }
 else {
    if (record.containsValue(req.value)) {
      if (record.getMultiValues() != null) {
        removed=record.getMultiValues().remove(req.value);
      }
    }
  }
  if (req.txnId != -1) {
    unlock(record);
  }
  if (removed) {
    record.incrementVersion();
    concurrentMapManager.fireMapEvent(mapListeners,getName(),EntryEvent.TYPE_REMOVED,record.getKeyData(),null,req.value,record.getListeners(),req.caller);
  }
  req.version=record.getVersion();
  if (record.valueCount() == 0) {
    markAsRemoved(record);
  }
  return removed;
}","public boolean removeMulti(Request req){
  Record record=getRecord(req);
  if (record == null)   return false;
  boolean removed=false;
  if (req.value == null) {
    removed=true;
    markAsRemoved(record);
  }
 else {
    if (record.containsValue(req.value)) {
      if (record.getMultiValues() != null) {
        removed=record.getMultiValues().remove(req.value);
      }
    }
  }
  if (req.txnId != -1) {
    unlock(record,req);
  }
  if (removed) {
    record.incrementVersion();
    concurrentMapManager.fireMapEvent(mapListeners,getName(),EntryEvent.TYPE_REMOVED,record.getKeyData(),null,req.value,record.getListeners(),req.caller);
  }
  req.version=record.getVersion();
  if (record.valueCount() == 0) {
    markAsRemoved(record);
  }
  return removed;
}",0.9973753280839897
49919,"void unlock(Record record){
  record.clearLock();
  fireScheduledActions(record);
}","void unlock(Record record,Request request){
  record.unlock(request.lockThreadId,request.lockAddress);
  fireScheduledActions(record);
}",0.7123287671232876
49920,"public boolean removeItem(Request req){
  Record record=getRecord(req);
  if (record == null) {
    return false;
  }
  if (req.txnId != -1) {
    unlock(record);
  }
  boolean removed=false;
  if (record.getCopyCount() > 0) {
    record.decrementCopyCount();
    removed=true;
  }
 else   if (record.getValueData() != null) {
    removed=true;
  }
 else   if (record.getMultiValues() != null) {
    removed=true;
  }
  if (removed) {
    concurrentMapManager.fireMapEvent(mapListeners,EntryEvent.TYPE_REMOVED,null,record,req.caller);
    record.incrementVersion();
  }
  req.version=record.getVersion();
  req.longValue=record.getCopyCount();
  markAsRemoved(record);
  return true;
}","public boolean removeItem(Request req){
  Record record=getRecord(req);
  if (record == null) {
    return false;
  }
  if (req.txnId != -1) {
    unlock(record,req);
  }
  boolean removed=false;
  if (record.getCopyCount() > 0) {
    record.decrementCopyCount();
    removed=true;
  }
 else   if (record.getValueData() != null) {
    removed=true;
  }
 else   if (record.getMultiValues() != null) {
    removed=true;
  }
  if (removed) {
    concurrentMapManager.fireMapEvent(mapListeners,EntryEvent.TYPE_REMOVED,null,record,req.caller);
    record.incrementVersion();
  }
  req.version=record.getVersion();
  req.longValue=record.getCopyCount();
  markAsRemoved(record);
  return true;
}",0.9970887918486172
49921,"public void run(){
  try {
    map3.lock(1);
    assertTrue(latchLock.await(10,TimeUnit.SECONDS));
  }
 catch (  Throwable e) {
    fail();
  }
}","public void run(){
  try {
    map1.lock(1);
    locked.set(true);
  }
 catch (  Throwable e) {
  }
}",0.7398373983739838
49922,"@Test public void testMemberRemoved() throws Exception {
  HazelcastClient client=mock(HazelcastClient.class);
  InetSocketAddress inetSocketAddress=new InetSocketAddress(""String_Node_Str"",5701);
  final Connection connection=mock(Connection.class);
  final List<LifecycleState> lifecycleEvents=new ArrayList<LifecycleState>();
  final LifecycleServiceClientImpl lifecycleService=createLifecycleServiceClientImpl(client,lifecycleEvents);
  ConnectionManager connectionManager=new ConnectionManager(client,lifecycleService,inetSocketAddress){
    protected Connection getNextConnection(){
      return connection;
    }
  }
;
  ClientBinder binder=mock(ClientBinder.class);
  connectionManager.setBinder(binder);
  Cluster cluster=mock(Cluster.class);
  Member member=mock(Member.class);
  when(member.getInetSocketAddress()).thenReturn(inetSocketAddress);
  MembershipEvent membershipEvent=new MembershipEvent(cluster,member,MembershipEvent.MEMBER_REMOVED);
  connectionManager.memberRemoved(membershipEvent);
  assertEquals(0,connectionManager.getClusterMembers().size());
  assertArrayEquals(new Object[0],lifecycleEvents.toArray());
}","@Test public void testMemberRemoved() throws Exception {
  HazelcastClient client=mock(HazelcastClient.class);
  InetSocketAddress inetSocketAddress=new InetSocketAddress(""String_Node_Str"",5701);
  final Connection connection=mock(Connection.class);
  final List<LifecycleState> lifecycleEvents=new ArrayList<LifecycleState>();
  final LifecycleServiceClientImpl lifecycleService=createLifecycleServiceClientImpl(client,lifecycleEvents);
  ConnectionManager connectionManager=new ConnectionManager(client,lifecycleService,inetSocketAddress,60000){
    protected Connection getNextConnection(){
      return connection;
    }
  }
;
  ClientBinder binder=mock(ClientBinder.class);
  connectionManager.setBinder(binder);
  Cluster cluster=mock(Cluster.class);
  Member member=mock(Member.class);
  when(member.getInetSocketAddress()).thenReturn(inetSocketAddress);
  MembershipEvent membershipEvent=new MembershipEvent(cluster,member,MembershipEvent.MEMBER_REMOVED);
  connectionManager.memberRemoved(membershipEvent);
  assertEquals(0,connectionManager.getClusterMembers().size());
  assertArrayEquals(new Object[0],lifecycleEvents.toArray());
}",0.9973684210526316
49923,"@Test public void testDestroyConnection() throws Exception {
  HazelcastClient client=mock(HazelcastClient.class);
  InetSocketAddress inetSocketAddress=new InetSocketAddress(""String_Node_Str"",5701);
  final Connection connection=mock(Connection.class);
  final CountDownLatch latch=new CountDownLatch(2);
  final List<LifecycleState> lifecycleEvents=new ArrayList<LifecycleState>();
  final LifecycleServiceClientImpl lifecycleService=createLifecycleServiceClientImpl(client,lifecycleEvents);
  ConnectionManager connectionManager=new ConnectionManager(client,lifecycleService,inetSocketAddress){
    protected Connection getNextConnection(){
      latch.countDown();
      return connection;
    }
  }
;
  ClientBinder binder=mock(ClientBinder.class);
  connectionManager.setBinder(binder);
  assertEquals(connection,connectionManager.getConnection());
  connectionManager.destroyConnection(connection);
  connectionManager.getConnection();
  assertTrue(latch.await(1,TimeUnit.SECONDS));
  assertArrayEquals(new Object[]{LifecycleState.CLIENT_CONNECTION_OPENING,LifecycleState.CLIENT_CONNECTION_LOST,LifecycleState.CLIENT_CONNECTION_OPENING},lifecycleEvents.toArray());
}","@Test public void testDestroyConnection() throws Exception {
  HazelcastClient client=mock(HazelcastClient.class);
  InetSocketAddress inetSocketAddress=new InetSocketAddress(""String_Node_Str"",5701);
  final Connection connection=mock(Connection.class);
  final CountDownLatch latch=new CountDownLatch(2);
  final List<LifecycleState> lifecycleEvents=new ArrayList<LifecycleState>();
  final LifecycleServiceClientImpl lifecycleService=createLifecycleServiceClientImpl(client,lifecycleEvents);
  ConnectionManager connectionManager=new ConnectionManager(client,lifecycleService,inetSocketAddress,60000){
    protected Connection getNextConnection(){
      latch.countDown();
      return connection;
    }
  }
;
  ClientBinder binder=mock(ClientBinder.class);
  connectionManager.setBinder(binder);
  assertEquals(connection,connectionManager.getConnection());
  connectionManager.destroyConnection(connection);
  connectionManager.getConnection();
  assertTrue(latch.await(1,TimeUnit.SECONDS));
  assertArrayEquals(new Object[]{LifecycleState.CLIENT_CONNECTION_OPENING,LifecycleState.CLIENT_CONNECTION_LOST,LifecycleState.CLIENT_CONNECTION_OPENING},lifecycleEvents.toArray());
}",0.9974489795918368
49924,"@Test public void testDifferentMemberAdded() throws Exception {
  HazelcastClient client=mock(HazelcastClient.class);
  InetSocketAddress inetSocketAddress=new InetSocketAddress(""String_Node_Str"",5701);
  final Connection connection=mock(Connection.class);
  final List<LifecycleState> lifecycleEvents=new ArrayList<LifecycleState>();
  final LifecycleServiceClientImpl lifecycleService=createLifecycleServiceClientImpl(client,lifecycleEvents);
  ConnectionManager connectionManager=new ConnectionManager(client,lifecycleService,inetSocketAddress){
    protected Connection getNextConnection(){
      return connection;
    }
  }
;
  ClientBinder binder=mock(ClientBinder.class);
  connectionManager.setBinder(binder);
  Cluster cluster=mock(Cluster.class);
  InetSocketAddress inetSocketAddress2=new InetSocketAddress(""String_Node_Str"",5702);
  Member member=mock(Member.class);
  when(member.getInetSocketAddress()).thenReturn(inetSocketAddress2);
  MembershipEvent membershipEvent=new MembershipEvent(cluster,member,MembershipEvent.MEMBER_ADDED);
  connectionManager.memberAdded(membershipEvent);
  connectionManager.getClusterMembers().contains(inetSocketAddress2);
  assertEquals(2,connectionManager.getClusterMembers().size());
  assertArrayEquals(new Object[0],lifecycleEvents.toArray());
}","@Test public void testDifferentMemberAdded() throws Exception {
  HazelcastClient client=mock(HazelcastClient.class);
  InetSocketAddress inetSocketAddress=new InetSocketAddress(""String_Node_Str"",5701);
  final Connection connection=mock(Connection.class);
  final List<LifecycleState> lifecycleEvents=new ArrayList<LifecycleState>();
  final LifecycleServiceClientImpl lifecycleService=createLifecycleServiceClientImpl(client,lifecycleEvents);
  ConnectionManager connectionManager=new ConnectionManager(client,lifecycleService,inetSocketAddress,60000){
    protected Connection getNextConnection(){
      return connection;
    }
  }
;
  ClientBinder binder=mock(ClientBinder.class);
  connectionManager.setBinder(binder);
  Cluster cluster=mock(Cluster.class);
  InetSocketAddress inetSocketAddress2=new InetSocketAddress(""String_Node_Str"",5702);
  Member member=mock(Member.class);
  when(member.getInetSocketAddress()).thenReturn(inetSocketAddress2);
  MembershipEvent membershipEvent=new MembershipEvent(cluster,member,MembershipEvent.MEMBER_ADDED);
  connectionManager.memberAdded(membershipEvent);
  connectionManager.getClusterMembers().contains(inetSocketAddress2);
  assertEquals(2,connectionManager.getClusterMembers().size());
  assertArrayEquals(new Object[0],lifecycleEvents.toArray());
}",0.9976923076923075
49925,"@Test public void testUpdateMembers() throws Exception {
  HazelcastClient client=mock(HazelcastClient.class);
  Cluster cluster=mock(Cluster.class);
  when(client.getCluster()).thenReturn(cluster);
  Set<Member> members=new HashSet<Member>();
  Member member1=mock(Member.class);
  Member member2=mock(Member.class);
  Member member3=mock(Member.class);
  InetSocketAddress inetSocketAddress1=new InetSocketAddress(""String_Node_Str"",9701);
  InetSocketAddress inetSocketAddress2=new InetSocketAddress(""String_Node_Str"",9702);
  InetSocketAddress inetSocketAddress3=new InetSocketAddress(""String_Node_Str"",9703);
  when(member1.getInetSocketAddress()).thenReturn(inetSocketAddress1);
  when(member2.getInetSocketAddress()).thenReturn(inetSocketAddress2);
  when(member3.getInetSocketAddress()).thenReturn(inetSocketAddress3);
  members.add(member1);
  members.add(member2);
  members.add(member3);
  when(cluster.getMembers()).thenReturn(members);
  InetSocketAddress inetSocketAddress=new InetSocketAddress(""String_Node_Str"",5701);
  final Connection connection=mock(Connection.class);
  final List<LifecycleState> lifecycleEvents=new ArrayList<LifecycleState>();
  final LifecycleServiceClientImpl lifecycleService=createLifecycleServiceClientImpl(client,lifecycleEvents);
  ConnectionManager connectionManager=new ConnectionManager(client,lifecycleService,inetSocketAddress){
    protected Connection getNextConnection(){
      return connection;
    }
  }
;
  ClientBinder binder=mock(ClientBinder.class);
  connectionManager.setBinder(binder);
  connectionManager.updateMembers();
  assertTrue(connectionManager.getClusterMembers().contains(inetSocketAddress1));
  assertTrue(connectionManager.getClusterMembers().contains(inetSocketAddress2));
  assertTrue(connectionManager.getClusterMembers().contains(inetSocketAddress3));
  assertFalse(connectionManager.getClusterMembers().contains(inetSocketAddress));
  assertEquals(3,connectionManager.getClusterMembers().size());
  assertArrayEquals(new Object[0],lifecycleEvents.toArray());
}","@Test public void testUpdateMembers() throws Exception {
  HazelcastClient client=mock(HazelcastClient.class);
  Cluster cluster=mock(Cluster.class);
  when(client.getCluster()).thenReturn(cluster);
  Set<Member> members=new HashSet<Member>();
  Member member1=mock(Member.class);
  Member member2=mock(Member.class);
  Member member3=mock(Member.class);
  InetSocketAddress inetSocketAddress1=new InetSocketAddress(""String_Node_Str"",9701);
  InetSocketAddress inetSocketAddress2=new InetSocketAddress(""String_Node_Str"",9702);
  InetSocketAddress inetSocketAddress3=new InetSocketAddress(""String_Node_Str"",9703);
  when(member1.getInetSocketAddress()).thenReturn(inetSocketAddress1);
  when(member2.getInetSocketAddress()).thenReturn(inetSocketAddress2);
  when(member3.getInetSocketAddress()).thenReturn(inetSocketAddress3);
  members.add(member1);
  members.add(member2);
  members.add(member3);
  when(cluster.getMembers()).thenReturn(members);
  InetSocketAddress inetSocketAddress=new InetSocketAddress(""String_Node_Str"",5701);
  final Connection connection=mock(Connection.class);
  final List<LifecycleState> lifecycleEvents=new ArrayList<LifecycleState>();
  final LifecycleServiceClientImpl lifecycleService=createLifecycleServiceClientImpl(client,lifecycleEvents);
  ConnectionManager connectionManager=new ConnectionManager(client,lifecycleService,inetSocketAddress,60000){
    protected Connection getNextConnection(){
      return connection;
    }
  }
;
  ClientBinder binder=mock(ClientBinder.class);
  connectionManager.setBinder(binder);
  connectionManager.updateMembers();
  assertTrue(connectionManager.getClusterMembers().contains(inetSocketAddress1));
  assertTrue(connectionManager.getClusterMembers().contains(inetSocketAddress2));
  assertTrue(connectionManager.getClusterMembers().contains(inetSocketAddress3));
  assertFalse(connectionManager.getClusterMembers().contains(inetSocketAddress));
  assertEquals(3,connectionManager.getClusterMembers().size());
  assertArrayEquals(new Object[0],lifecycleEvents.toArray());
}",0.99853228962818
49926,"@Test public void testShouldExecuteOnDisconnect() throws Exception {
  HazelcastClient client=mock(HazelcastClient.class);
  InetSocketAddress inetSocketAddress=new InetSocketAddress(""String_Node_Str"",5701);
  final Connection connection=mock(Connection.class);
  final List<LifecycleState> lifecycleEvents=new ArrayList<LifecycleState>();
  final LifecycleServiceClientImpl lifecycleService=createLifecycleServiceClientImpl(client,lifecycleEvents);
  ConnectionManager connectionManager=new ConnectionManager(client,lifecycleService,inetSocketAddress){
    protected Connection getNextConnection(){
      return connection;
    }
  }
;
  assertTrue(connectionManager.shouldExecuteOnDisconnect(connection));
  assertFalse(connectionManager.shouldExecuteOnDisconnect(connection));
  assertArrayEquals(new Object[0],lifecycleEvents.toArray());
}","@Test public void testShouldExecuteOnDisconnect() throws Exception {
  HazelcastClient client=mock(HazelcastClient.class);
  InetSocketAddress inetSocketAddress=new InetSocketAddress(""String_Node_Str"",5701);
  final Connection connection=mock(Connection.class);
  final List<LifecycleState> lifecycleEvents=new ArrayList<LifecycleState>();
  final LifecycleServiceClientImpl lifecycleService=createLifecycleServiceClientImpl(client,lifecycleEvents);
  ConnectionManager connectionManager=new ConnectionManager(client,lifecycleService,inetSocketAddress,60000){
    protected Connection getNextConnection(){
      return connection;
    }
  }
;
  assertTrue(connectionManager.shouldExecuteOnDisconnect(connection));
  assertFalse(connectionManager.shouldExecuteOnDisconnect(connection));
  assertArrayEquals(new Object[0],lifecycleEvents.toArray());
}",0.99645390070922
49927,"@Test public void testGetConnection() throws Exception {
  HazelcastClient client=mock(HazelcastClient.class);
  InetSocketAddress inetSocketAddress=new InetSocketAddress(""String_Node_Str"",5701);
  final Connection connection=mock(Connection.class);
  final CountDownLatch latch=new CountDownLatch(2);
  final List<LifecycleState> lifecycleEvents=new ArrayList<LifecycleState>();
  final LifecycleServiceClientImpl lifecycleService=createLifecycleServiceClientImpl(client,lifecycleEvents);
  ConnectionManager connectionManager=new ConnectionManager(client,lifecycleService,inetSocketAddress){
    protected Connection getNextConnection(){
      latch.countDown();
      return connection;
    }
  }
;
  ClientBinder binder=mock(ClientBinder.class);
  connectionManager.setBinder(binder);
  connectionManager.getConnection();
  assertEquals(connection,connectionManager.getConnection());
  verify(binder).bind(connection);
  assertEquals(connection,connectionManager.getConnection());
  assertEquals(1,latch.getCount());
  assertArrayEquals(new Object[]{LifecycleState.CLIENT_CONNECTION_OPENING},lifecycleEvents.toArray());
}","@Test public void testGetConnection() throws Exception {
  HazelcastClient client=mock(HazelcastClient.class);
  InetSocketAddress inetSocketAddress=new InetSocketAddress(""String_Node_Str"",5701);
  final Connection connection=mock(Connection.class);
  final CountDownLatch latch=new CountDownLatch(2);
  final List<LifecycleState> lifecycleEvents=new ArrayList<LifecycleState>();
  final LifecycleServiceClientImpl lifecycleService=createLifecycleServiceClientImpl(client,lifecycleEvents);
  ConnectionManager connectionManager=new ConnectionManager(client,lifecycleService,inetSocketAddress,60000){
    protected Connection getNextConnection(){
      latch.countDown();
      return connection;
    }
  }
;
  ClientBinder binder=mock(ClientBinder.class);
  connectionManager.setBinder(binder);
  connectionManager.getConnection();
  assertEquals(connection,connectionManager.getConnection());
  verify(binder).bind(connection);
  assertEquals(connection,connectionManager.getConnection());
  assertEquals(1,latch.getCount());
  assertArrayEquals(new Object[]{LifecycleState.CLIENT_CONNECTION_OPENING},lifecycleEvents.toArray());
}",0.9973404255319148
49928,"@Test public void testGetConnectionWhenThereIsNoConnection() throws Exception {
  HazelcastClient client=mock(HazelcastClient.class);
  InetSocketAddress inetSocketAddress=new InetSocketAddress(""String_Node_Str"",5701);
  final List<LifecycleState> lifecycleEvents=new ArrayList<LifecycleState>();
  final LifecycleServiceClientImpl lifecycleService=createLifecycleServiceClientImpl(client,lifecycleEvents);
  ConnectionManager connectionManager=new ConnectionManager(client,lifecycleService,inetSocketAddress){
    protected Connection getNextConnection(){
      return null;
    }
  }
;
  ClientBinder binder=mock(ClientBinder.class);
  connectionManager.setBinder(binder);
  connectionManager.getConnection();
  assertEquals(null,connectionManager.getConnection());
  assertEquals(null,connectionManager.getConnection());
  assertArrayEquals(new Object[0],lifecycleEvents.toArray());
}","@Test public void testGetConnectionWhenThereIsNoConnection() throws Exception {
  HazelcastClient client=mock(HazelcastClient.class);
  InetSocketAddress inetSocketAddress=new InetSocketAddress(""String_Node_Str"",5701);
  final List<LifecycleState> lifecycleEvents=new ArrayList<LifecycleState>();
  final LifecycleServiceClientImpl lifecycleService=createLifecycleServiceClientImpl(client,lifecycleEvents);
  ConnectionManager connectionManager=new ConnectionManager(client,lifecycleService,inetSocketAddress,60000){
    protected Connection getNextConnection(){
      return null;
    }
  }
;
  ClientBinder binder=mock(ClientBinder.class);
  connectionManager.setBinder(binder);
  connectionManager.getConnection();
  assertEquals(null,connectionManager.getConnection());
  assertEquals(null,connectionManager.getConnection());
  assertArrayEquals(new Object[0],lifecycleEvents.toArray());
}",0.996629213483146
49929,"@Test public void testSameMemberAdded() throws Exception {
  HazelcastClient client=mock(HazelcastClient.class);
  InetSocketAddress inetSocketAddress=new InetSocketAddress(""String_Node_Str"",5701);
  final Connection connection=mock(Connection.class);
  final CountDownLatch latch=new CountDownLatch(2);
  final List<LifecycleState> lifecycleEvents=new ArrayList<LifecycleState>();
  final LifecycleServiceClientImpl lifecycleService=createLifecycleServiceClientImpl(client,lifecycleEvents);
  ConnectionManager connectionManager=new ConnectionManager(client,lifecycleService,inetSocketAddress){
    protected Connection getNextConnection(){
      latch.countDown();
      return connection;
    }
  }
;
  ClientBinder binder=mock(ClientBinder.class);
  connectionManager.setBinder(binder);
  Cluster cluster=mock(Cluster.class);
  Member member=mock(Member.class);
  when(member.getInetSocketAddress()).thenReturn(inetSocketAddress);
  MembershipEvent membershipEvent=new MembershipEvent(cluster,member,MembershipEvent.MEMBER_ADDED);
  connectionManager.memberAdded(membershipEvent);
  connectionManager.getClusterMembers().contains(inetSocketAddress);
  assertEquals(1,connectionManager.getClusterMembers().size());
  assertArrayEquals(new Object[0],lifecycleEvents.toArray());
}","@Test public void testSameMemberAdded() throws Exception {
  HazelcastClient client=mock(HazelcastClient.class);
  InetSocketAddress inetSocketAddress=new InetSocketAddress(""String_Node_Str"",5701);
  final Connection connection=mock(Connection.class);
  final CountDownLatch latch=new CountDownLatch(2);
  final List<LifecycleState> lifecycleEvents=new ArrayList<LifecycleState>();
  final LifecycleServiceClientImpl lifecycleService=createLifecycleServiceClientImpl(client,lifecycleEvents);
  ConnectionManager connectionManager=new ConnectionManager(client,lifecycleService,inetSocketAddress,60000){
    protected Connection getNextConnection(){
      latch.countDown();
      return connection;
    }
  }
;
  ClientBinder binder=mock(ClientBinder.class);
  connectionManager.setBinder(binder);
  Cluster cluster=mock(Cluster.class);
  Member member=mock(Member.class);
  when(member.getInetSocketAddress()).thenReturn(inetSocketAddress);
  MembershipEvent membershipEvent=new MembershipEvent(cluster,member,MembershipEvent.MEMBER_ADDED);
  connectionManager.memberAdded(membershipEvent);
  connectionManager.getClusterMembers().contains(inetSocketAddress);
  assertEquals(1,connectionManager.getClusterMembers().size());
  assertArrayEquals(new Object[0],lifecycleEvents.toArray());
}",0.9976635514018692
49930,"public int drainTo(Collection<? super E> objects,int i){
  if (objects == null)   throw new NullPointerException(""String_Node_Str"");
  if (i < 0)   throw new IllegalArgumentException(""String_Node_Str"" + i);
  if (i == 0)   return 0;
  if (objects instanceof IQueue) {
    if (((IQueue)objects).getName().equals(getName())) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  E e;
  int counter=0;
  while ((e=poll()) != null && counter < i) {
    objects.add(e);
    counter++;
  }
  return counter;
}","public int drainTo(Collection<? super E> objects,int i){
  if (objects == null)   throw new NullPointerException(""String_Node_Str"");
  if (i < 0)   throw new IllegalArgumentException(""String_Node_Str"" + i);
  if (i == 0)   return 0;
  if (objects instanceof IQueue) {
    if (((IQueue)objects).getName().equals(getName())) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  E e;
  int counter=0;
  while (counter < i && (e=poll()) != null) {
    objects.add(e);
    counter++;
  }
  return counter;
}",0.9446564885496184
49931,"public void removeLogListener(LogListener logListener){
  Iterator<LogListenerRegistration> it=lsListeners.iterator();
  while (it.hasNext()) {
    LogListenerRegistration logListenerRegistration=it.next();
    if (logListenerRegistration.getLogListener() == logListener) {
      it.remove();
    }
  }
}","public void removeLogListener(LogListener logListener){
  lsListeners.remove(new LogListenerRegistration(Level.ALL,logListener));
}",0.5379310344827586
49932,"public boolean isEmpty(){
  return (size() == 0);
}","public boolean isEmpty(String name){
  NearCache nearCache=mapCaches.get(name);
  if (nearCache != null && !nearCache.isEmpty()) {
    return false;
  }
  final CMap cMap=maps.get(name);
  if (cMap != null) {
    long now=System.currentTimeMillis();
    for (    Record record : cMap.mapRecords.values()) {
      if (record.isActive() && record.isValid(now) && record.getValueData() != null) {
        if (cMap.readBackupData) {
          return false;
        }
 else {
          Partition partition=partitionManager.partitionServiceImpl.getPartition(record.getBlockId());
          if (partition != null && partition.getOwner() != null && partition.getOwner().localMember()) {
            return false;
          }
        }
      }
    }
  }
  return new MSize(name).getSize() == 0;
}",0.0978520286396181
49933,"Object txnalPut(ClusterOperation operation,String name,Object key,Object value,long timeout,long ttl,long txnId){
  ThreadContext threadContext=ThreadContext.get();
  TransactionImpl txn=threadContext.getTransaction();
  if (txn != null && txn.getStatus() == Transaction.TXN_STATUS_ACTIVE) {
    if (!txn.has(name,key)) {
      MLock mlock=new MLock();
      boolean locked=mlock.lockAndGetValue(name,key,DEFAULT_TXN_TIMEOUT);
      if (!locked)       throwCME(key);
      Object oldObject=null;
      Data oldValue=mlock.oldValue;
      if (oldValue != null) {
        oldObject=threadContext.isClient() ? oldValue : threadContext.toObject(oldValue);
      }
      if (operation == ClusterOperation.CONCURRENT_MAP_PUT_IF_ABSENT && oldObject != null) {
        txn.attachPutOp(name,key,oldObject,0,ttl,false);
      }
 else {
        txn.attachPutOp(name,key,value,0,ttl,(oldObject == null));
      }
      return oldObject;
    }
 else {
      if (operation == CONCURRENT_MAP_PUT_IF_ABSENT) {
        Object existingValue=txn.get(name,key);
        if (existingValue != null) {
          return existingValue;
        }
      }
      return txn.attachPutOp(name,key,value,false);
    }
  }
 else {
    setLocal(operation,name,key,value,timeout,ttl);
    request.txnId=txnId;
    request.longValue=(request.value == null) ? Integer.MIN_VALUE : request.value.hashCode();
    setIndexValues(request,value);
    if (operation == CONCURRENT_MAP_TRY_PUT || operation == CONCURRENT_MAP_SET || operation == CONCURRENT_MAP_PUT_AND_UNLOCK || operation == CONCURRENT_MAP_PUT_TRANSIENT) {
      request.setBooleanRequest();
      doOp();
      Boolean returnObject=getResultAsBoolean();
      if (returnObject) {
        backup(CONCURRENT_MAP_BACKUP_PUT);
      }
      return returnObject;
    }
 else {
      request.setObjectRequest();
      doOp();
      Object returnObject=getResultAsObject();
      if (operation == CONCURRENT_MAP_REPLACE_IF_NOT_NULL && returnObject == null) {
        return null;
      }
      if (returnObject instanceof AddressAwareException) {
        rethrowException(operation,(AddressAwareException)returnObject);
      }
      request.longValue=Long.MIN_VALUE;
      backup(CONCURRENT_MAP_BACKUP_PUT);
      return returnObject;
    }
  }
}","Object txnalPut(ClusterOperation operation,String name,Object key,Object value,long timeout,long ttl,long txnId){
  ThreadContext threadContext=ThreadContext.get();
  TransactionImpl txn=threadContext.getTransaction();
  if (txn != null && txn.getStatus() == Transaction.TXN_STATUS_ACTIVE) {
    if (!txn.has(name,key)) {
      MLock mlock=new MLock();
      boolean locked=mlock.lockAndGetValue(name,key,DEFAULT_TXN_TIMEOUT);
      if (!locked)       throwCME(key);
      Object oldObject=null;
      Data oldValue=mlock.oldValue;
      if (oldValue != null) {
        oldObject=threadContext.isClient() ? oldValue : threadContext.toObject(oldValue);
      }
      if (operation == ClusterOperation.CONCURRENT_MAP_PUT_IF_ABSENT && oldObject != null) {
        txn.attachPutOp(name,key,oldObject,0,ttl,false);
      }
 else {
        txn.attachPutOp(name,key,value,0,ttl,(oldObject == null));
      }
      return oldObject;
    }
 else {
      if (operation == CONCURRENT_MAP_PUT_IF_ABSENT) {
        Object existingValue=txn.get(name,key);
        if (existingValue != null) {
          return existingValue;
        }
      }
      return txn.attachPutOp(name,key,value,false);
    }
  }
 else {
    setLocal(operation,name,key,value,timeout,ttl);
    request.txnId=txnId;
    request.longValue=(request.value == null) ? Integer.MIN_VALUE : request.value.hashCode();
    setIndexValues(request,value);
    if (operation == CONCURRENT_MAP_TRY_PUT || operation == CONCURRENT_MAP_SET || operation == CONCURRENT_MAP_PUT_AND_UNLOCK || operation == CONCURRENT_MAP_PUT_TRANSIENT) {
      request.setBooleanRequest();
      Data valueData=request.value;
      doOp();
      Boolean successful=getResultAsBoolean();
      if (successful) {
        request.value=valueData;
        backup(CONCURRENT_MAP_BACKUP_PUT);
      }
      return successful;
    }
 else {
      request.setObjectRequest();
      doOp();
      Object returnObject=getResultAsObject();
      if (operation == CONCURRENT_MAP_REPLACE_IF_NOT_NULL && returnObject == null) {
        return null;
      }
      if (returnObject instanceof AddressAwareException) {
        rethrowException(operation,(AddressAwareException)returnObject);
      }
      request.longValue=Long.MIN_VALUE;
      backup(CONCURRENT_MAP_BACKUP_PUT);
      return returnObject;
    }
  }
}",0.9278395465445826
49934,"CMap(ConcurrentMapManager concurrentMapManager,String name){
  this.concurrentMapManager=concurrentMapManager;
  this.logger=concurrentMapManager.node.getLogger(CMap.class.getName());
  this.PARTITION_COUNT=concurrentMapManager.PARTITION_COUNT;
  this.blocks=concurrentMapManager.blocks;
  this.node=concurrentMapManager.node;
  this.thisAddress=concurrentMapManager.thisAddress;
  this.name=name;
  mapForQueue=name.startsWith(""String_Node_Str"");
  instanceType=ConcurrentMapManager.getInstanceType(name);
  MapConfig mapConfig=null;
  String mapConfigName=name.substring(2);
  if (isMultiMap() || mapConfigName.startsWith(""String_Node_Str"") || mapConfigName.startsWith(AS_LIST)|| mapConfigName.startsWith(AS_SET)) {
    mapConfig=new MapConfig();
  }
 else   if (mapForQueue) {
    String queueShortName=name.substring(4);
    QueueConfig qConfig=node.getConfig().findMatchingQueueConfig(queueShortName);
    mapConfig=node.getConfig().findMatchingMapConfig(qConfig.getBackingMapRef());
  }
 else {
    mapConfig=node.getConfig().findMatchingMapConfig(mapConfigName);
  }
  this.mapIndexService=new MapIndexService(mapConfig.isValueIndexed());
  this.backupCount=mapConfig.getBackupCount();
  ttl=mapConfig.getTimeToLiveSeconds() * 1000L;
  evictionDelayMillis=mapConfig.getEvictionDelaySeconds() * 1000L;
  maxIdle=mapConfig.getMaxIdleSeconds() * 1000L;
  evictionPolicy=EvictionPolicy.valueOf(mapConfig.getEvictionPolicy());
  readBackupData=mapConfig.isReadBackupData();
  cacheValue=mapConfig.isCacheValue();
  MaxSizeConfig maxSizeConfig=mapConfig.getMaxSizeConfig();
  if (MaxSizeConfig.POLICY_MAP_SIZE_PER_JVM.equals(maxSizeConfig.getMaxSizePolicy())) {
    maxSizePolicy=new MaxSizePerJVMPolicy(maxSizeConfig);
  }
 else   if (MaxSizeConfig.POLICY_CLUSTER_WIDE_MAP_SIZE.equals(maxSizeConfig.getMaxSizePolicy())) {
    maxSizePolicy=new MaxSizeClusterWidePolicy(maxSizeConfig);
  }
 else   if (MaxSizeConfig.POLICY_PARTITIONS_WIDE_MAP_SIZE.equals(maxSizeConfig.getMaxSizePolicy())) {
    maxSizePolicy=new MaxSizePartitionsWidePolicy(maxSizeConfig);
  }
 else   if (MaxSizeConfig.POLICY_USED_HEAP_SIZE.equals(maxSizeConfig.getMaxSizePolicy())) {
    maxSizePolicy=new MaxSizeHeapPolicy(maxSizeConfig);
  }
 else   if (MaxSizeConfig.POLICY_USED_HEAP_PERCENTAGE.equals(maxSizeConfig.getMaxSizePolicy())) {
    maxSizePolicy=new MaxSizeHeapPercentagePolicy(maxSizeConfig);
  }
 else {
    maxSizePolicy=null;
  }
  if (evictionPolicy == EvictionPolicy.NONE) {
    evictionComparator=null;
  }
 else {
    if (evictionPolicy == EvictionPolicy.LRU) {
      evictionComparator=new ComparatorWrapper(LRU_COMPARATOR);
    }
 else {
      evictionComparator=new ComparatorWrapper(LFU_COMPARATOR);
    }
  }
  evictionRate=mapConfig.getEvictionPercentage() / 100f;
  MapStoreConfig mapStoreConfig=mapConfig.getMapStoreConfig();
  MapStoreWrapper mapStoreWrapper=null;
  int writeDelaySeconds=-1;
  if (!node.isSuperClient() && mapStoreConfig != null && mapStoreConfig.isEnabled()) {
    try {
      Object storeInstance=mapStoreConfig.getImplementation();
      if (storeInstance == null) {
        String mapStoreClassName=mapStoreConfig.getClassName();
        storeInstance=Serializer.classForName(node.getConfig().getClassLoader(),mapStoreClassName).newInstance();
      }
      mapStoreWrapper=new MapStoreWrapper(storeInstance,node.factory.getHazelcastInstanceProxy(),mapStoreConfig.getProperties(),mapConfigName);
      if (!mapStoreWrapper.isMapLoader() && !mapStoreWrapper.isMapStore()) {
        throw new Exception(""String_Node_Str"" + storeInstance.getClass().getName() + ""String_Node_Str"");
      }
    }
 catch (    Exception e) {
      logger.log(Level.SEVERE,e.getMessage(),e);
    }
    writeDelaySeconds=mapStoreConfig.getWriteDelaySeconds();
  }
  writeDelayMillis=(writeDelaySeconds == -1) ? -1L : writeDelaySeconds * 1000L;
  if (writeDelaySeconds > 0) {
    removeDelayMillis=concurrentMapManager.GLOBAL_REMOVE_DELAY_MILLIS + writeDelaySeconds;
  }
 else {
    removeDelayMillis=concurrentMapManager.GLOBAL_REMOVE_DELAY_MILLIS;
  }
  loader=(mapStoreWrapper == null || !mapStoreWrapper.isMapLoader()) ? null : mapStoreWrapper;
  store=(mapStoreWrapper == null || !mapStoreWrapper.isMapStore()) ? null : mapStoreWrapper;
  NearCacheConfig nearCacheConfig=mapConfig.getNearCacheConfig();
  if (nearCacheConfig == null) {
    nearCache=null;
  }
 else {
    NearCache nearCache=new NearCache(this,SortedHashMap.getOrderingTypeByName(nearCacheConfig.getEvictionPolicy()),nearCacheConfig.getMaxSize(),nearCacheConfig.getTimeToLiveSeconds() * 1000L,nearCacheConfig.getMaxIdleSeconds() * 1000L,nearCacheConfig.isInvalidateOnChange());
    final NearCache anotherNearCache=concurrentMapManager.mapCaches.putIfAbsent(name,nearCache);
    if (anotherNearCache != null) {
      nearCache=anotherNearCache;
    }
    this.nearCache=nearCache;
  }
  MergePolicy mergePolicyTemp=null;
  String mergePolicyName=mapConfig.getMergePolicy();
  if (mergePolicyName != null && !""String_Node_Str"".equalsIgnoreCase(mergePolicyName)) {
    MergePolicyConfig mergePolicyConfig=node.getConfig().getMergePolicyConfig(mapConfig.getMergePolicy());
    if (mergePolicyConfig != null) {
      mergePolicyTemp=mergePolicyConfig.getImplementation();
      if (mergePolicyTemp == null) {
        String mergeClassName=mergePolicyConfig.getClassName();
        try {
          mergePolicyTemp=(MergePolicy)Serializer.classForName(node.getConfig().getClassLoader(),mergeClassName).newInstance();
        }
 catch (        Exception e) {
          logger.log(Level.SEVERE,e.getMessage(),e);
        }
      }
    }
  }
  this.mergePolicy=mergePolicyTemp;
  this.creationTime=System.currentTimeMillis();
}","CMap(ConcurrentMapManager concurrentMapManager,String name){
  this.concurrentMapManager=concurrentMapManager;
  this.logger=concurrentMapManager.node.getLogger(CMap.class.getName());
  this.PARTITION_COUNT=concurrentMapManager.PARTITION_COUNT;
  this.blocks=concurrentMapManager.blocks;
  this.node=concurrentMapManager.node;
  this.thisAddress=concurrentMapManager.thisAddress;
  this.name=name;
  mapForQueue=name.startsWith(""String_Node_Str"");
  instanceType=ConcurrentMapManager.getInstanceType(name);
  MapConfig mapConfig=null;
  String mapConfigName=name.substring(2);
  if (isMultiMap() || mapConfigName.startsWith(""String_Node_Str"") || mapConfigName.startsWith(AS_LIST)|| mapConfigName.startsWith(AS_SET)) {
    mapConfig=new MapConfig();
  }
 else   if (mapForQueue) {
    String queueShortName=name.substring(4);
    QueueConfig qConfig=node.getConfig().findMatchingQueueConfig(queueShortName);
    mapConfig=node.getConfig().findMatchingMapConfig(qConfig.getBackingMapRef());
  }
 else {
    mapConfig=node.getConfig().findMatchingMapConfig(mapConfigName);
  }
  this.mapIndexService=new MapIndexService(mapConfig.isValueIndexed());
  this.backupCount=mapConfig.getBackupCount();
  ttl=mapConfig.getTimeToLiveSeconds() * 1000L;
  evictionDelayMillis=mapConfig.getEvictionDelaySeconds() * 1000L;
  maxIdle=mapConfig.getMaxIdleSeconds() * 1000L;
  evictionPolicy=EvictionPolicy.valueOf(mapConfig.getEvictionPolicy());
  readBackupData=mapConfig.isReadBackupData();
  cacheValue=mapConfig.isCacheValue();
  MaxSizeConfig maxSizeConfig=mapConfig.getMaxSizeConfig();
  if (MaxSizeConfig.POLICY_MAP_SIZE_PER_JVM.equals(maxSizeConfig.getMaxSizePolicy())) {
    maxSizePolicy=new MaxSizePerJVMPolicy(maxSizeConfig);
  }
 else   if (MaxSizeConfig.POLICY_CLUSTER_WIDE_MAP_SIZE.equals(maxSizeConfig.getMaxSizePolicy())) {
    maxSizePolicy=new MaxSizeClusterWidePolicy(maxSizeConfig);
  }
 else   if (MaxSizeConfig.POLICY_PARTITIONS_WIDE_MAP_SIZE.equals(maxSizeConfig.getMaxSizePolicy())) {
    maxSizePolicy=new MaxSizePartitionsWidePolicy(maxSizeConfig);
  }
 else   if (MaxSizeConfig.POLICY_USED_HEAP_SIZE.equals(maxSizeConfig.getMaxSizePolicy())) {
    maxSizePolicy=new MaxSizeHeapPolicy(maxSizeConfig);
  }
 else   if (MaxSizeConfig.POLICY_USED_HEAP_PERCENTAGE.equals(maxSizeConfig.getMaxSizePolicy())) {
    maxSizePolicy=new MaxSizeHeapPercentagePolicy(maxSizeConfig);
  }
 else {
    maxSizePolicy=null;
  }
  if (evictionPolicy == EvictionPolicy.NONE) {
    evictionComparator=null;
  }
 else {
    if (evictionPolicy == EvictionPolicy.LRU) {
      evictionComparator=new ComparatorWrapper(LRU_COMPARATOR);
    }
 else {
      evictionComparator=new ComparatorWrapper(LFU_COMPARATOR);
    }
  }
  evictionRate=mapConfig.getEvictionPercentage() / 100f;
  MapStoreConfig mapStoreConfig=mapConfig.getMapStoreConfig();
  MapStoreWrapper mapStoreWrapper=null;
  int writeDelaySeconds=-1;
  if (!node.isSuperClient() && mapStoreConfig != null && mapStoreConfig.isEnabled()) {
    try {
      MapStoreFactory factory=(MapStoreFactory)mapStoreConfig.getFactoryImplementation();
      if (factory == null) {
        String factoryClassName=mapStoreConfig.getFactoryClassName();
        if (factoryClassName != null && !""String_Node_Str"".equals(factoryClassName)) {
          factory=(MapStoreFactory)Serializer.classForName(node.getConfig().getClassLoader(),factoryClassName).newInstance();
        }
      }
      Object storeInstance=factory == null ? mapStoreConfig.getImplementation() : factory.newMapStore(name,mapStoreConfig.getProperties());
      if (storeInstance == null) {
        String mapStoreClassName=mapStoreConfig.getClassName();
        storeInstance=Serializer.classForName(node.getConfig().getClassLoader(),mapStoreClassName).newInstance();
      }
      mapStoreWrapper=new MapStoreWrapper(storeInstance,node.factory.getHazelcastInstanceProxy(),mapStoreConfig.getProperties(),mapConfigName);
      if (!mapStoreWrapper.isMapLoader() && !mapStoreWrapper.isMapStore()) {
        throw new Exception(""String_Node_Str"" + storeInstance.getClass().getName() + ""String_Node_Str"");
      }
    }
 catch (    Exception e) {
      logger.log(Level.SEVERE,e.getMessage(),e);
    }
    writeDelaySeconds=mapStoreConfig.getWriteDelaySeconds();
  }
  writeDelayMillis=(writeDelaySeconds == -1) ? -1L : writeDelaySeconds * 1000L;
  if (writeDelaySeconds > 0) {
    removeDelayMillis=concurrentMapManager.GLOBAL_REMOVE_DELAY_MILLIS + writeDelaySeconds;
  }
 else {
    removeDelayMillis=concurrentMapManager.GLOBAL_REMOVE_DELAY_MILLIS;
  }
  loader=(mapStoreWrapper == null || !mapStoreWrapper.isMapLoader()) ? null : mapStoreWrapper;
  store=(mapStoreWrapper == null || !mapStoreWrapper.isMapStore()) ? null : mapStoreWrapper;
  NearCacheConfig nearCacheConfig=mapConfig.getNearCacheConfig();
  if (nearCacheConfig == null) {
    nearCache=null;
  }
 else {
    NearCache nearCache=new NearCache(this,SortedHashMap.getOrderingTypeByName(nearCacheConfig.getEvictionPolicy()),nearCacheConfig.getMaxSize(),nearCacheConfig.getTimeToLiveSeconds() * 1000L,nearCacheConfig.getMaxIdleSeconds() * 1000L,nearCacheConfig.isInvalidateOnChange());
    final NearCache anotherNearCache=concurrentMapManager.mapCaches.putIfAbsent(name,nearCache);
    if (anotherNearCache != null) {
      nearCache=anotherNearCache;
    }
    this.nearCache=nearCache;
  }
  MergePolicy mergePolicyTemp=null;
  String mergePolicyName=mapConfig.getMergePolicy();
  if (mergePolicyName != null && !""String_Node_Str"".equalsIgnoreCase(mergePolicyName)) {
    MergePolicyConfig mergePolicyConfig=node.getConfig().getMergePolicyConfig(mapConfig.getMergePolicy());
    if (mergePolicyConfig != null) {
      mergePolicyTemp=mergePolicyConfig.getImplementation();
      if (mergePolicyTemp == null) {
        String mergeClassName=mergePolicyConfig.getClassName();
        try {
          mergePolicyTemp=(MergePolicy)Serializer.classForName(node.getConfig().getClassLoader(),mergeClassName).newInstance();
        }
 catch (        Exception e) {
          logger.log(Level.SEVERE,e.getMessage(),e);
        }
      }
    }
  }
  this.mergePolicy=mergePolicyTemp;
  this.creationTime=System.currentTimeMillis();
}",0.9581403183694096
49935,"public HazelcastClient getHazelcastClient(){
  if (client == null) {
    Config config=new Config();
    config.setProperty(GroupProperties.PROP_WAIT_SECONDS_BEFORE_JOIN,""String_Node_Str"");
    hz=Hazelcast.newHazelcastInstance(config);
    client=TestUtility.newHazelcastClient(hz);
  }
  return client;
}","public HazelcastClient getHazelcastClient(){
  if (client == null) {
    Config config=new Config();
    config.setProperty(GroupProperties.PROP_WAIT_SECONDS_BEFORE_JOIN,""String_Node_Str"");
    config.setProperty(GroupProperties.PROP_EXECUTOR_CLIENT_THREAD_COUNT,""String_Node_Str"");
    hz=Hazelcast.newHazelcastInstance(config);
    client=TestUtility.newHazelcastClient(hz);
  }
  return client;
}",0.8680851063829788
49936,"public void searchForOtherClusters(SplitBrainHandler splitBrainHandler){
  final BlockingQueue q=new LinkedBlockingQueue();
  MulticastListener listener=new MulticastListener(){
    public void onMessage(    Object msg){
      if (msg != null && msg instanceof JoinInfo) {
        JoinInfo joinInfo=(JoinInfo)msg;
        if (node.address != null && !node.address.equals(joinInfo.address)) {
          q.offer(msg);
        }
      }
    }
  }
;
  node.multicastService.addMulticastListener(listener);
  node.multicastService.send(node.createJoinInfo());
  try {
    JoinInfo joinInfo=(JoinInfo)q.poll(3,TimeUnit.SECONDS);
    if (joinInfo != null) {
      node.multicastService.removeMulticastListener(listener);
      if (shouldMerge(joinInfo)) {
        logger.log(Level.WARNING,node.address + ""String_Node_Str"" + joinInfo.address);
        node.factory.restart();
        return;
      }
    }
  }
 catch (  InterruptedException ignored) {
  }
catch (  Exception e) {
    if (logger != null) {
      logger.log(Level.WARNING,e.getMessage(),e);
    }
  }
}","public void searchForOtherClusters(SplitBrainHandler splitBrainHandler){
  final BlockingQueue q=new LinkedBlockingQueue();
  MulticastListener listener=new MulticastListener(){
    public void onMessage(    Object msg){
      if (msg != null && msg instanceof JoinInfo) {
        JoinInfo joinInfo=(JoinInfo)msg;
        if (node.address != null && !node.address.equals(joinInfo.address)) {
          q.offer(msg);
        }
      }
    }
  }
;
  node.multicastService.addMulticastListener(listener);
  node.multicastService.send(node.createJoinInfo());
  try {
    JoinInfo joinInfo=(JoinInfo)q.poll(3,TimeUnit.SECONDS);
    if (joinInfo != null) {
      if (shouldMerge(joinInfo)) {
        logger.log(Level.WARNING,node.address + ""String_Node_Str"" + joinInfo.address);
        node.factory.restart();
        return;
      }
    }
  }
 catch (  InterruptedException ignored) {
  }
catch (  Exception e) {
    if (logger != null) {
      logger.log(Level.WARNING,e.getMessage(),e);
    }
  }
 finally {
    node.multicastService.removeMulticastListener(listener);
  }
}",0.9338338808071328
49937,"@Override public Iterator<E> iterator(){
  final Collection<E> collection=proxyHelper.keys(null);
  final AbstractCollection<E> proxy=this;
  return new Iterator<E>(){
    Iterator<E> iterator=collection.iterator();
    volatile E lastRecord;
    public boolean hasNext(){
      return iterator.hasNext();
    }
    public E next(){
      lastRecord=iterator.next();
      return lastRecord;
    }
    public void remove(){
      iterator.remove();
      proxy.remove(lastRecord);
    }
  }
;
}","@Override public Iterator<E> iterator(){
  final Collection<E> collection=getTheCollection();
  final AbstractCollection<E> proxy=this;
  return new Iterator<E>(){
    Iterator<E> iterator=collection.iterator();
    volatile E lastRecord;
    public boolean hasNext(){
      return iterator.hasNext();
    }
    public E next(){
      lastRecord=iterator.next();
      return lastRecord;
    }
    public void remove(){
      iterator.remove();
      proxy.remove(lastRecord);
    }
  }
;
}",0.9613821138211384
49938,"public <K,V,E>Object getClientProxy(Object o){
  Object proxy=mapProxies.get(o);
  if (proxy == null) {
synchronized (mapProxies) {
      proxy=mapProxies.get(o);
      if (proxy == null) {
        if (o instanceof String) {
          String name=(String)o;
          if (name.startsWith(Prefix.MAP)) {
            proxy=new MapClientProxy<K,V>(this,name);
          }
 else           if (name.startsWith(Prefix.LIST)) {
            proxy=new ListClientProxy<E>(this,name);
          }
 else           if (name.startsWith(Prefix.SET)) {
            proxy=new SetClientProxy<E>(this,name);
          }
 else           if (name.startsWith(Prefix.QUEUE)) {
            proxy=new QueueClientProxy<E>(this,name);
          }
 else           if (name.startsWith(Prefix.TOPIC)) {
            proxy=new TopicClientProxy<E>(this,name);
          }
 else           if (name.startsWith(Prefix.ATOMIC_NUMBER)) {
            proxy=new AtomicNumberClientProxy(this,name);
          }
 else           if (name.startsWith(Prefix.IDGEN)) {
            proxy=new IdGeneratorClientProxy(this,name);
          }
 else           if (name.startsWith(Prefix.MULTIMAP)) {
            proxy=new MultiMapClientProxy(this,name);
          }
 else {
            proxy=new LockClientProxy(o,this);
          }
          mapProxies.put(o,proxy);
        }
 else {
          proxy=new LockClientProxy(o,this);
        }
      }
    }
  }
  return mapProxies.get(o);
}","public <K,V,E>Object getClientProxy(Object o){
  Object proxy=mapProxies.get(o);
  if (proxy == null) {
synchronized (mapProxies) {
      proxy=mapProxies.get(o);
      if (proxy == null) {
        if (o instanceof String) {
          String name=(String)o;
          if (name.startsWith(Prefix.MAP)) {
            proxy=new MapClientProxy<K,V>(this,name);
          }
 else           if (name.startsWith(Prefix.AS_LIST)) {
            proxy=new ListClientProxy<E>(this,name);
          }
 else           if (name.startsWith(Prefix.SET)) {
            proxy=new SetClientProxy<E>(this,name);
          }
 else           if (name.startsWith(Prefix.QUEUE)) {
            proxy=new QueueClientProxy<E>(this,name);
          }
 else           if (name.startsWith(Prefix.TOPIC)) {
            proxy=new TopicClientProxy<E>(this,name);
          }
 else           if (name.startsWith(Prefix.ATOMIC_NUMBER)) {
            proxy=new AtomicNumberClientProxy(this,name);
          }
 else           if (name.startsWith(Prefix.IDGEN)) {
            proxy=new IdGeneratorClientProxy(this,name);
          }
 else           if (name.startsWith(Prefix.MULTIMAP)) {
            proxy=new MultiMapClientProxy(this,name);
          }
 else {
            proxy=new LockClientProxy(o,this);
          }
          mapProxies.put(o,proxy);
        }
 else {
          proxy=new LockClientProxy(o,this);
        }
      }
    }
  }
  return mapProxies.get(o);
}",0.9989565217391304
49939,"public <E>IList<E> getList(String name){
  return (IList<E>)getClientProxy(Prefix.LIST + name);
}","public <E>IList<E> getList(String name){
  return (IList<E>)getClientProxy(Prefix.AS_LIST + name);
}",0.9847715736040608
49940,"public String getName(){
  return name.substring(Prefix.LIST.length());
}","public String getName(){
  return name.substring(Prefix.AS_LIST.length());
}",0.9798657718120806
49941,"public void entryAdded(EntryEvent<E,V> event){
  itemListener.itemAdded(event.getKey());
}","public void entryAdded(EntryEvent<E,V> event){
  itemListener.itemAdded(event.getValue());
}",0.967032967032967
49942,"public void entryRemoved(EntryEvent<E,V> event){
  itemListener.itemRemoved(event.getKey());
}","public void entryRemoved(EntryEvent<E,V> event){
  itemListener.itemRemoved(event.getValue());
}",0.968421052631579
49943,"public synchronized <E,V>void registerListener(String name,final ItemListener<E> itemListener){
  EntryListener<E,V> e=new EntryAdapter<E,V>(){
    public void entryAdded(    EntryEvent<E,V> event){
      itemListener.itemAdded(event.getKey());
    }
    public void entryRemoved(    EntryEvent<E,V> event){
      itemListener.itemRemoved(event.getKey());
    }
  }
;
  entryListenerManager.registerListener(name,null,false,e);
  itemListener2EntryListener.put(itemListener,e);
}","public synchronized <E,V>void registerListener(String name,final ItemListener<V> itemListener){
  EntryListener<E,V> e=new EntryAdapter<E,V>(){
    public void entryAdded(    EntryEvent<E,V> event){
      itemListener.itemAdded(event.getValue());
    }
    public void entryRemoved(    EntryEvent<E,V> event){
      itemListener.itemRemoved(event.getValue());
    }
  }
;
  entryListenerManager.registerListener(name,null,true,e);
  itemListener2EntryListener.put(itemListener,e);
}",0.9739854318418314
49944,"@Test public void clear(){
  HazelcastClient hClient=getHazelcastClient();
  IList<Integer> list=hClient.getList(""String_Node_Str"");
  int count=100;
  assertTrue(list.isEmpty());
  for (int i=0; i < count; i++) {
    assertTrue(list.add(i));
  }
  assertEquals(count,list.size());
  list.clear();
  assertTrue(list.isEmpty());
}","@Test public void clear(){
  HazelcastClient hClient=getHazelcastClient();
  IList<Integer> list=hClient.getList(""String_Node_Str"");
  int count=100;
  assertTrue(list.isEmpty());
  for (int i=0; i < count; i++) {
    assertTrue(list.add(i));
  }
  assertEquals(count,list.size());
  list.clear();
  assertTrue(""String_Node_Str"" + list.size(),list.isEmpty());
}",0.9536231884057972
49945,"@Test public void iterate(){
  HazelcastClient hClient=getHazelcastClient();
  IList<Integer> list=hClient.getList(""String_Node_Str"");
  list.add(1);
  list.add(2);
  list.add(2);
  list.add(3);
  assertEquals(4,list.size());
  Map<Integer,Integer> counter=new HashMap<Integer,Integer>();
  counter.put(1,1);
  counter.put(2,2);
  counter.put(3,1);
  for (Iterator<Integer> iterator=list.iterator(); iterator.hasNext(); ) {
    Integer integer=(Integer)iterator.next();
    counter.put(integer,(Integer)counter.get(integer) - 1);
    iterator.remove();
  }
  assertEquals(Integer.valueOf(0),counter.get(1));
  assertEquals(Integer.valueOf(0),counter.get(2));
  assertEquals(Integer.valueOf(0),counter.get(3));
  assertTrue(list.isEmpty());
}","@Test public void iterate(){
  HazelcastClient hClient=getHazelcastClient();
  IList<Integer> list=hClient.getList(""String_Node_Str"");
  list.add(1);
  list.add(2);
  list.add(2);
  list.add(3);
  assertEquals(4,list.size());
  Map<Integer,Integer> counter=new HashMap<Integer,Integer>();
  counter.put(1,1);
  counter.put(2,2);
  counter.put(3,1);
  for (Iterator<Integer> iterator=list.iterator(); iterator.hasNext(); ) {
    Integer integer=iterator.next();
    counter.put(integer,counter.get(integer) - 1);
    iterator.remove();
  }
  assertEquals(Integer.valueOf(0),counter.get(1));
  assertEquals(Integer.valueOf(0),counter.get(2));
  assertEquals(Integer.valueOf(0),counter.get(3));
  assertTrue(list.isEmpty());
}",0.9877049180327868
49946,"public static InstanceType getInstanceType(final String name){
  if (name.startsWith(Prefix.QUEUE)) {
    return InstanceType.QUEUE;
  }
 else   if (name.startsWith(Prefix.TOPIC)) {
    return InstanceType.TOPIC;
  }
 else   if (name.startsWith(Prefix.MAP)) {
    return InstanceType.MAP;
  }
 else   if (name.startsWith(Prefix.MAP_BASED)) {
    if (name.length() > 3) {
      final String typeStr=name.substring(2,4);
      if (Prefix.AS_SET.equals(typeStr)) {
        return InstanceType.SET;
      }
 else       if (Prefix.AS_LIST.equals(typeStr)) {
        return InstanceType.LIST;
      }
 else       if (Prefix.AS_MULTIMAP.equals(typeStr)) {
        return InstanceType.MULTIMAP;
      }
    }
    return InstanceType.MAP;
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + name);
  }
}","public static InstanceType getInstanceType(final String name){
  if (name.startsWith(Prefix.QUEUE)) {
    return InstanceType.QUEUE;
  }
 else   if (name.startsWith(Prefix.TOPIC)) {
    return InstanceType.TOPIC;
  }
 else   if (name.startsWith(Prefix.MAP)) {
    return InstanceType.MAP;
  }
 else   if (name.startsWith(Prefix.AS_LIST)) {
    return InstanceType.LIST;
  }
 else   if (name.startsWith(Prefix.MAP_BASED)) {
    if (name.length() > 3) {
      final String typeStr=name.substring(2,4);
      if (Prefix.AS_SET.equals(typeStr)) {
        return InstanceType.SET;
      }
 else       if (Prefix.AS_MULTIMAP.equals(typeStr)) {
        return InstanceType.MULTIMAP;
      }
    }
    return InstanceType.MAP;
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + name);
  }
}",0.8918073796122576
49947,"Packet createEntryEventPacket(EntryEvent event){
  Packet packet=new Packet();
  DataAwareEntryEvent dataAwareEntryEvent=(DataAwareEntryEvent)event;
  Data valueEvent=null;
  if (dataAwareEntryEvent.getNewValueData() != null) {
    Keys keys=new Keys();
    keys.add(dataAwareEntryEvent.getNewValueData());
    keys.add(dataAwareEntryEvent.getOldValueData());
    valueEvent=toData(keys);
  }
  packet.set(event.getName(),ClusterOperation.EVENT,dataAwareEntryEvent.getKeyData(),valueEvent);
  packet.longValue=event.getEventType().getType();
  return packet;
}","Packet createEntryEventPacket(EntryEvent event){
  Packet packet=new Packet();
  DataAwareEntryEvent dataAwareEntryEvent=(DataAwareEntryEvent)event;
  Data valueEvent=null;
  if (dataAwareEntryEvent.getNewValueData() != null) {
    Keys keys=new Keys();
    keys.add(dataAwareEntryEvent.getNewValueData());
    keys.add(dataAwareEntryEvent.getOldValueData());
    valueEvent=toData(keys);
  }
  String name=event.getName();
  if (name.startsWith(Prefix.MAP_OF_LIST)) {
    name=name.substring(Prefix.MAP.length() + Prefix.QUEUE.length());
    valueEvent=((DataAwareEntryEvent)event).getNewValueData();
  }
  packet.set(name,ClusterOperation.EVENT,dataAwareEntryEvent.getKeyData(),valueEvent);
  packet.longValue=event.getEventType().getType();
  return packet;
}",0.8290468986384266
49948,"public Map<K,V> getAll(Set<K> setKeys){
  check(setKeys);
  Keys keys=new Keys();
  for (  K key : setKeys) {
    keys.add(toData(key));
  }
  Pairs pairs=(Pairs)proxyHelper.doOp(ClusterOperation.CONCURRENT_MAP_GET_ALL,keys,null);
  List<KeyValue> lsKeyValues=pairs.getKeyValues();
  Map map=new HashMap();
  for (  KeyValue keyValue : lsKeyValues) {
    map.put(toObject(keyValue.getKeyData()),toObject(keyValue.getValueData()));
  }
  return map;
}","public Map<K,V> getAll(Set<K> setKeys){
  check(setKeys);
  Keys keys=new Keys();
  for (  K key : setKeys) {
    keys.add(toData(key));
  }
  Pairs pairs=(Pairs)proxyHelper.doOp(ClusterOperation.CONCURRENT_MAP_GET_ALL,keys,null);
  List<KeyValue> lsKeyValues=pairs.getKeyValues();
  Map map=new HashMap();
  if (lsKeyValues != null) {
    for (    KeyValue keyValue : lsKeyValues) {
      map.put(toObject(keyValue.getKeyData()),toObject(keyValue.getValueData()));
    }
  }
  return map;
}",0.9479277364505844
49949,"public <K,V,E>Object getClientProxy(Object o){
  Object proxy=mapProxies.get(o);
  if (proxy == null) {
synchronized (mapProxies) {
      proxy=mapProxies.get(o);
      if (proxy == null) {
        if (o instanceof String) {
          String name=(String)o;
          if (name.startsWith(Prefix.MAP)) {
            proxy=new MapClientProxy<K,V>(this,name);
          }
 else           if (name.startsWith(Prefix.AS_LIST)) {
            proxy=new ListClientProxy<E>(this,name);
          }
 else           if (name.startsWith(Prefix.SET)) {
            proxy=new SetClientProxy<E>(this,name);
          }
 else           if (name.startsWith(Prefix.QUEUE)) {
            proxy=new QueueClientProxy<E>(this,name);
          }
 else           if (name.startsWith(Prefix.TOPIC)) {
            proxy=new TopicClientProxy<E>(this,name);
          }
 else           if (name.startsWith(Prefix.ATOMIC_NUMBER)) {
            proxy=new AtomicNumberClientProxy(this,name);
          }
 else           if (name.startsWith(Prefix.IDGEN)) {
            proxy=new IdGeneratorClientProxy(this,name);
          }
 else           if (name.startsWith(Prefix.MULTIMAP)) {
            proxy=new MultiMapClientProxy(this,name);
          }
 else {
            proxy=new LockClientProxy(o,this);
          }
          mapProxies.put(o,proxy);
        }
 else {
          proxy=new LockClientProxy(o,this);
        }
      }
    }
  }
  return mapProxies.get(o);
}","public <K,V,E>Object getClientProxy(Object o){
  Object proxy=mapProxies.get(o);
  if (proxy == null) {
synchronized (mapProxies) {
      proxy=mapProxies.get(o);
      if (proxy == null) {
        if (o instanceof String) {
          String name=(String)o;
          if (name.startsWith(Prefix.MAP)) {
            proxy=new MapClientProxy<K,V>(this,name);
          }
 else           if (name.startsWith(Prefix.AS_LIST)) {
            proxy=new ListClientProxy<E>(this,name);
          }
 else           if (name.startsWith(Prefix.SET)) {
            proxy=new SetClientProxy<E>(this,name);
          }
 else           if (name.startsWith(Prefix.QUEUE)) {
            proxy=new QueueClientProxy<E>(this,name);
          }
 else           if (name.startsWith(Prefix.TOPIC)) {
            proxy=new TopicClientProxy<E>(this,name);
          }
 else           if (name.startsWith(Prefix.ATOMIC_NUMBER)) {
            proxy=new AtomicNumberClientProxy(this,name);
          }
 else           if (name.startsWith(Prefix.IDGEN)) {
            proxy=new IdGeneratorClientProxy(this,name);
          }
 else           if (name.startsWith(Prefix.MULTIMAP)) {
            proxy=new MultiMapClientProxy(this,name);
          }
 else           if (name.startsWith(Prefix.SEMAPHORE)) {
            proxy=new SemaphoreClientProxy(this,name);
          }
 else {
            proxy=new LockClientProxy(o,this);
          }
          mapProxies.put(o,proxy);
        }
 else {
          proxy=new LockClientProxy(o,this);
        }
      }
    }
  }
  return mapProxies.get(o);
}",0.9586942038640908
49950,"public Semaphore getSemaphore(String name){
  return (Semaphore)getClientProxy(Prefix.SEMAPHORE + name);
}","public ISemaphore getSemaphore(String name){
  ISemaphore semaphore=(ISemaphore)getClientProxy(Prefix.SEMAPHORE + name);
  return semaphore;
}",0.8225806451612904
49951,"@Override public Session findSession(String id) throws IOException {
  Session session=super.findSession(id);
  if (session != null) {
    return session;
  }
  HazelcastAttribute mark=(HazelcastAttribute)hazelAttributes.get(id + ""String_Node_Str"" + HAZEL_SESSION_MARK);
  if (mark != null && mark.getValue() != null) {
    session=createSession(id);
  }
  return session;
}","@Override public Session findSession(String id) throws IOException {
  Session session=super.findSession(id);
  if (session != null) {
    return session;
  }
  final IMap<String,HazelcastAttribute> sessionAttrMap=HazelcastClusterSupport.get().getAttributesMap();
  HazelcastAttribute mark=sessionAttrMap.get(id + ""String_Node_Str"" + HazelcastSession.SESSION_MARK);
  if (mark != null && mark.getValue() != null) {
    session=createSession(id);
  }
  return session;
}",0.7924080664294187
49952,"public void addListener(String name,Object listener,Object key,boolean includeValue,Instance.InstanceType instanceType){
  boolean remotelyRegister=true;
  for (  ListenerItem listenerItem : listeners) {
    if (!remotelyRegister) {
      break;
    }
    if (listenerItem.name.equals(name)) {
      if (key == null) {
        if (listenerItem.key == null && (!includeValue || listenerItem.includeValue == includeValue)) {
          remotelyRegister=false;
        }
      }
 else       if (listenerItem.key != null) {
        if (listenerItem.key.equals(key) && (!includeValue || listenerItem.includeValue == includeValue)) {
          remotelyRegister=false;
        }
      }
    }
  }
  if (remotelyRegister) {
    registerListener(name,key,true,includeValue);
  }
  ListenerItem listenerItem=new ListenerItem(name,key,listener,includeValue,instanceType);
  listeners.add(listenerItem);
}","public void addListener(String name,Object listener,Object key,boolean includeValue,Instance.InstanceType instanceType){
  boolean remotelyRegister=true;
  for (  ListenerItem listenerItem : listeners) {
    if (!remotelyRegister) {
      break;
    }
    if (!listenerItem.localListener && listenerItem.name.equals(name)) {
      if (key == null) {
        if (listenerItem.key == null && (!includeValue || listenerItem.includeValue == includeValue)) {
          remotelyRegister=false;
        }
      }
 else       if (listenerItem.key != null) {
        if (listenerItem.key.equals(key) && (!includeValue || listenerItem.includeValue == includeValue)) {
          remotelyRegister=false;
        }
      }
    }
  }
  if (remotelyRegister) {
    registerListener(name,key,true,includeValue);
  }
  ListenerItem listenerItem=new ListenerItem(name,key,listener,includeValue,instanceType);
  listeners.add(listenerItem);
}",0.878236914600551
49953,"private void callListener(final ListenerItem listenerItem,final EntryEvent event){
  final Object listener=listenerItem.listener;
  final EntryEventType entryEventType=event.getEventType();
  if (listenerItem.instanceType == Instance.InstanceType.MAP) {
    if (!listenerItem.name.startsWith(""String_Node_Str"")) {
      Object proxy=node.factory.getOrCreateProxyByName(listenerItem.name);
      if (proxy instanceof MProxy) {
        MProxy mProxy=(MProxy)proxy;
        mProxy.getMapOperationCounter().incrementReceivedEvents();
      }
    }
  }
 else   if (listenerItem.instanceType == Instance.InstanceType.QUEUE) {
    if (!listenerItem.name.startsWith(""String_Node_Str"")) {
      Object proxy=node.factory.getOrCreateProxyByName(listenerItem.name);
      if (proxy instanceof QProxy) {
        QProxy qProxy=(QProxy)proxy;
        qProxy.getQueueOperationCounter().incrementReceivedEvents();
      }
    }
  }
 else   if (listenerItem.instanceType == Instance.InstanceType.TOPIC) {
    if (!listenerItem.name.startsWith(""String_Node_Str"")) {
      Object proxy=node.factory.getOrCreateProxyByName(listenerItem.name);
      if (proxy instanceof TopicProxy) {
        TopicProxy tProxy=(TopicProxy)proxy;
        tProxy.getTopicOperationCounter().incrementReceivedMessages();
      }
    }
  }
  final EntryEvent event2=listenerItem.includeValue ? event : (event.getValue() != null ? new EntryEvent(event.getSource(),event.getMember(),event.getEventType().getType(),event.getKey(),null,null) : event);
switch (listenerItem.instanceType) {
case MAP:
case MULTIMAP:
    EntryListener entryListener=(EntryListener)listener;
switch (entryEventType) {
case ADDED:
    entryListener.entryAdded(event2);
  break;
case REMOVED:
entryListener.entryRemoved(event2);
break;
case UPDATED:
entryListener.entryUpdated(event2);
break;
case EVICTED:
entryListener.entryEvicted(event2);
break;
}
break;
case SET:
case LIST:
ItemListener itemListener=(ItemListener)listener;
switch (entryEventType) {
case ADDED:
itemListener.itemAdded(event2.getKey());
break;
case REMOVED:
itemListener.itemRemoved(event2.getKey());
break;
}
break;
case TOPIC:
MessageListener messageListener=(MessageListener)listener;
messageListener.onMessage(event2.getValue());
break;
case QUEUE:
ItemListener queueItemListener=(ItemListener)listener;
switch (entryEventType) {
case ADDED:
queueItemListener.itemAdded(event2.getValue());
break;
case REMOVED:
queueItemListener.itemRemoved(event2.getValue());
break;
}
break;
}
}","private void callListener(final ListenerItem listenerItem,final EntryEvent event){
  if (listenerItem.localListener) {
    Partition p=node.factory.getPartitionService().getPartition(event.getKey());
    if (!node.localMember.equals(p.getOwner())) {
      return;
    }
  }
  final Object listener=listenerItem.listener;
  final EntryEventType entryEventType=event.getEventType();
  if (listenerItem.instanceType == Instance.InstanceType.MAP) {
    if (!listenerItem.name.startsWith(""String_Node_Str"")) {
      Object proxy=node.factory.getOrCreateProxyByName(listenerItem.name);
      if (proxy instanceof MProxy) {
        MProxy mProxy=(MProxy)proxy;
        mProxy.getMapOperationCounter().incrementReceivedEvents();
      }
    }
  }
 else   if (listenerItem.instanceType == Instance.InstanceType.QUEUE) {
    if (!listenerItem.name.startsWith(""String_Node_Str"")) {
      Object proxy=node.factory.getOrCreateProxyByName(listenerItem.name);
      if (proxy instanceof QProxy) {
        QProxy qProxy=(QProxy)proxy;
        qProxy.getQueueOperationCounter().incrementReceivedEvents();
      }
    }
  }
 else   if (listenerItem.instanceType == Instance.InstanceType.TOPIC) {
    if (!listenerItem.name.startsWith(""String_Node_Str"")) {
      Object proxy=node.factory.getOrCreateProxyByName(listenerItem.name);
      if (proxy instanceof TopicProxy) {
        TopicProxy tProxy=(TopicProxy)proxy;
        tProxy.getTopicOperationCounter().incrementReceivedMessages();
      }
    }
  }
  final EntryEvent event2=listenerItem.includeValue ? event : (event.getValue() != null ? new EntryEvent(event.getSource(),event.getMember(),event.getEventType().getType(),event.getKey(),null,null) : event);
switch (listenerItem.instanceType) {
case MAP:
case MULTIMAP:
    EntryListener entryListener=(EntryListener)listener;
switch (entryEventType) {
case ADDED:
    entryListener.entryAdded(event2);
  break;
case REMOVED:
entryListener.entryRemoved(event2);
break;
case UPDATED:
entryListener.entryUpdated(event2);
break;
case EVICTED:
entryListener.entryEvicted(event2);
break;
}
break;
case SET:
case LIST:
ItemListener itemListener=(ItemListener)listener;
switch (entryEventType) {
case ADDED:
itemListener.itemAdded(event2.getKey());
break;
case REMOVED:
itemListener.itemRemoved(event2.getKey());
break;
}
break;
case TOPIC:
MessageListener messageListener=(MessageListener)listener;
messageListener.onMessage(event2.getValue());
break;
case QUEUE:
ItemListener queueItemListener=(ItemListener)listener;
switch (entryEventType) {
case ADDED:
queueItemListener.itemAdded(event2.getValue());
break;
case REMOVED:
queueItemListener.itemRemoved(event2.getValue());
break;
}
break;
}
}",0.9630203291384316
49954,"public void entryAdded(EntryEvent<Integer,DataSerializableUser> entryEvent){
  DataSerializableUser u=entryEvent.getValue();
  assertEquals(user.getName(),u.getName());
  assertEquals(user.getFamilyName(),u.getFamilyName());
  assertEquals(user.getAge(),u.getAge());
  assertEquals(user.getAddress().getAddress(),u.getAddress().getAddress());
  cdl.countDown();
}","public void entryAdded(EntryEvent<Object,Object> event){
  this.entryUpdated(event);
}",0.289532293986637
49955,"public void run(){
  int count=0;
  try {
    System.out.println(Thread.currentThread() + ""String_Node_Str"");
    HazelcastClient client;
synchronized (finished) {
      client=HazelcastClient.newHazelcastClient(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    }
    System.out.println(Thread.currentThread() + ""String_Node_Str"");
    startUpLatch.countDown();
    startUpLatch.await();
    while (!finished.get()) {
      queue.take();
      client.getMap(""String_Node_Str"").put(latch.getCount(),latch.getCount());
      count++;
      latch.countDown();
    }
  }
 catch (  InterruptedException e) {
    return;
  }
  System.out.println(Thread.currentThread() + ""String_Node_Str"" + count);
}","public void run(){
synchronized (latch) {
    h.getMap(""String_Node_Str"").put(""String_Node_Str"",counter1.incrementAndGet());
    latch.countDown();
  }
}",0.2707117852975496
49956,"BlockingQueueManager(Node node){
  super(node);
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_ITERATE,new InitializationAwareOperationHandler(){
    @Override void doOperation(    BQ queue,    Request request){
      queue.iterate(request);
    }
  }
);
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_SIZE,new InitializationAwareOperationHandler(){
    void doOperation(    BQ queue,    Request request){
      queue.size(request);
    }
  }
);
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_GET_KEY_BY_INDEX,new InitializationAwareOperationHandler(){
    public void doOperation(    BQ queue,    Request request){
      queue.doGetKeyByIndex(request);
    }
  }
);
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_GET_INDEX_BY_KEY,new InitializationAwareOperationHandler(){
    public void doOperation(    BQ queue,    Request request){
      queue.doGetIndexByKey(request);
    }
  }
);
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_TAKE_KEY,new InitializationAwareOperationHandler(){
    public void doOperation(    BQ queue,    Request request){
      queue.doTakeKey(request);
    }
  }
);
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_SET,new InitializationAwareOperationHandler(){
    public void doOperation(    BQ queue,    Request request){
      queue.doSet(request);
    }
  }
);
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_PEEK_KEY,new ResponsiveOperationHandler(){
    public void handle(    Request request){
      handlePeekKey(request);
    }
  }
);
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_ADD_KEY,new ResponsiveOperationHandler(){
    public void handle(    Request request){
      handleAddKey(request);
    }
  }
);
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_REMOVE_KEY,new InitializationAwareOperationHandler(){
    void doOperation(    BQ queue,    Request request){
      queue.removeKey(request);
    }
  }
);
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_GENERATE_KEY,new ResponsiveOperationHandler(){
    public void handle(    Request request){
      handleGenerateKey(request);
    }
  }
);
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_OFFER_KEY,new PacketProcessor(){
    public void process(    Packet packet){
      handleOfferKey(packet);
    }
  }
);
}","BlockingQueueManager(Node node){
  super(node);
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_ITERATE,new InitializationAwareOperationHandler(){
    @Override void doOperation(    BQ queue,    Request request){
      queue.iterate(request);
    }
  }
);
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_SIZE,new InitializationAwareOperationHandler(){
    void doOperation(    BQ queue,    Request request){
      queue.size(request);
    }
  }
);
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_GET_KEY_BY_INDEX,new InitializationAwareOperationHandler(){
    public void doOperation(    BQ queue,    Request request){
      queue.doGetKeyByIndex(request);
    }
  }
);
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_GET_INDEX_BY_KEY,new InitializationAwareOperationHandler(){
    public void doOperation(    BQ queue,    Request request){
      queue.doGetIndexByKey(request);
    }
  }
);
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_TAKE_KEY,new InitializationAwareOperationHandler(){
    public void doOperation(    BQ queue,    Request request){
      queue.doTakeKey(request);
    }
  }
);
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_CANCEL_TAKE_KEY,new InitializationAwareOperationHandler(){
    public void doOperation(    BQ queue,    Request request){
      queue.cancelTakeKey(request);
    }
  }
);
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_SET,new InitializationAwareOperationHandler(){
    public void doOperation(    BQ queue,    Request request){
      queue.doSet(request);
    }
  }
);
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_PEEK_KEY,new ResponsiveOperationHandler(){
    public void handle(    Request request){
      handlePeekKey(request);
    }
  }
);
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_ADD_KEY,new ResponsiveOperationHandler(){
    public void handle(    Request request){
      handleAddKey(request);
    }
  }
);
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_REMOVE_KEY,new InitializationAwareOperationHandler(){
    void doOperation(    BQ queue,    Request request){
      queue.removeKey(request);
    }
  }
);
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_GENERATE_KEY,new ResponsiveOperationHandler(){
    public void handle(    Request request){
      handleGenerateKey(request);
    }
  }
);
  node.clusterService.registerPacketProcessor(ClusterOperation.BLOCKING_OFFER_KEY,new PacketProcessor(){
    public void process(    Packet packet){
      handleOfferKey(packet);
    }
  }
);
}",0.953260242354299
49957,"private Data takeKey(String name,int index,long timeout) throws InterruptedException {
  try {
    MasterOp op=new MasterOp(ClusterOperation.BLOCKING_TAKE_KEY,name,timeout);
    op.request.longValue=index;
    op.initOp();
    return (Data)op.getResultAsIs();
  }
 catch (  Exception e) {
    if (e instanceof RuntimeInterruptedException) {
      throw new InterruptedException();
    }
  }
  return null;
}","private Data takeKey(String name,int index,long timeout) throws InterruptedException {
  try {
    MasterOp op=new MasterOp(ClusterOperation.BLOCKING_TAKE_KEY,name,timeout);
    op.request.longValue=index;
    op.request.txnId=ThreadContext.get().getThreadId();
    op.initOp();
    return (Data)op.getResultAsIs();
  }
 catch (  Exception e) {
    if (e instanceof RuntimeInterruptedException) {
      MasterOp op=new MasterOp(ClusterOperation.BLOCKING_CANCEL_TAKE_KEY,name,timeout);
      op.request.longValue=index;
      op.request.txnId=ThreadContext.get().getThreadId();
      op.initOp();
      throw new InterruptedException();
    }
  }
  return null;
}",0.7595884003741815
49958,"void doTakeKey(Request req){
  QData qdata=null;
  if (req.longValue > 0) {
    qdata=removeItemByIndex((int)req.longValue);
  }
 else {
    qdata=pollValidItem();
  }
  if (qdata != null) {
    keys.remove(qdata.data);
    req.response=qdata.data;
    returnResponse(req);
    offerOne();
  }
 else {
    if (req.hasEnoughTimeToSchedule()) {
      addPollAction(new PollAction(req));
    }
 else {
      req.response=null;
      returnResponse(req);
    }
  }
}","void doTakeKey(Request req){
  QData qdata;
  if (req.longValue > 0) {
    qdata=removeItemByIndex((int)req.longValue);
  }
 else {
    qdata=pollValidItem();
  }
  if (qdata != null) {
    keys.remove(qdata.data);
    req.response=qdata.data;
    returnResponse(req);
    offerOne();
  }
 else {
    if (req.hasEnoughTimeToSchedule()) {
      addPollAction(new PollAction(req));
    }
 else {
      req.response=null;
      returnResponse(req);
    }
  }
}",0.9945593035908596
49959,"public long generateKey(String name,long timeout) throws InterruptedException {
  try {
    MasterOp op=new MasterOp(ClusterOperation.BLOCKING_GENERATE_KEY,name,timeout);
    op.request.setLongRequest();
    op.initOp();
    return (Long)op.getResultAsObject();
  }
 catch (  Exception e) {
    if (e instanceof RuntimeInterruptedException) {
      throw new InterruptedException();
    }
  }
  return -1;
}","public long generateKey(String name,long timeout) throws InterruptedException {
  try {
    MasterOp op=new MasterOp(ClusterOperation.BLOCKING_GENERATE_KEY,name,timeout);
    op.request.setLongRequest();
    op.request.txnId=ThreadContext.get().getThreadId();
    op.initOp();
    return (Long)op.getResultAsObject();
  }
 catch (  Exception e) {
    if (e instanceof RuntimeInterruptedException) {
      throw new InterruptedException();
    }
  }
  return -1;
}",0.935632183908046
49960,"public void connectionRemoved(Connection connection){
  LifecycleServiceImpl lifecycleService=(LifecycleServiceImpl)node.factory.getLifecycleService();
  if (connection.equals(this.conn) && !lifecycleService.paused.get()) {
    removeLocks();
    rollbackTransactions();
    removeEntryListeners();
    removeEntryListenersWithKey();
    removeMessageListeners();
  }
}","public void connectionRemoved(Connection connection){
  LifecycleServiceImpl lifecycleService=(LifecycleServiceImpl)node.factory.getLifecycleService();
  if (connection.equals(this.conn) && !lifecycleService.paused.get()) {
    removeLocks();
    rollbackTransactions();
    removeEntryListeners();
    removeEntryListenersWithKey();
    removeMessageListeners();
    interruptRunningOperations();
  }
}",0.955958549222798
49961,"@Override public void doRun(){
  ThreadContext.get().setCallContext(callContext);
  if (clientOperationHandler != null) {
    try {
      clientOperationHandler.handle(node,packet);
    }
 catch (    Throwable e) {
      if (node.isActive()) {
        throw (RuntimeException)e;
      }
    }
  }
 else {
    if (node.isActive()) {
      throw new RuntimeException(""String_Node_Str"" + packet.operation);
    }
  }
}","@Override public void doRun(){
  runningThread=Thread.currentThread();
  ThreadContext.get().setCallContext(callContext);
  if (clientOperationHandler != null) {
    try {
      clientOperationHandler.handle(node,packet);
      node.clientService.getClientEndpoint(packet.conn).removeRequest(this);
    }
 catch (    Throwable e) {
      e.printStackTrace();
      if (node.isActive()) {
        throw (RuntimeException)e;
      }
    }
  }
 else {
    if (node.isActive()) {
      throw new RuntimeException(""String_Node_Str"" + packet.operation);
    }
  }
}",0.8521560574948666
49962,"public void run(){
  try {
    Thread.sleep(3000);
    takeThread.interrupt();
  }
 catch (  InterruptedException e) {
    fail();
  }
}","public void run(){
  try {
    q.take();
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
}",0.7611336032388664
49963,"public byte[] get(String key){
  String mapName=""String_Node_Str"";
  int index=key.indexOf(':');
  if (index != -1) {
    mapName=key.substring(0,index);
    key=key.substring(index + 1);
  }
  Object value=hazelcast.getMap(mapName).get(key);
  if (value != null && value instanceof RestValue) {
    RestValue restValue=(RestValue)value;
    return restValue.getValue();
  }
 else {
    return (byte[])value;
  }
}","public Object get(String mapName,String key){
  return hazelcast.getMap(mapName).get(key);
}",0.2766798418972332
49964,"public void handle(DeleteCommand command){
  String key=command.getKey();
  String mapName=""String_Node_Str"";
  int index=key.indexOf(':');
  if (index != -1) {
    mapName=key.substring(0,index);
    key=key.substring(index + 1);
  }
  command.setResponse(DELETED);
  if (command.shouldReply()) {
    textCommandService.sendResponse(command);
  }
  textCommandService.incrementDeleteCount();
  textCommandService.delete(mapName,key);
}","public void handle(DeleteCommand command){
  String key=null;
  try {
    key=URLDecoder.decode(command.getKey(),""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException e) {
    e.printStackTrace();
  }
  String mapName=""String_Node_Str"";
  int index=key.indexOf(':');
  if (index != -1) {
    mapName=key.substring(0,index);
    key=key.substring(index + 1);
  }
  command.setResponse(DELETED);
  if (command.shouldReply()) {
    textCommandService.sendResponse(command);
  }
  textCommandService.incrementDeleteCount();
  textCommandService.delete(mapName,key);
}",0.8630952380952381
49965,"public void handle(GetCommand getCommand){
  String key=getCommand.getKey();
  String mapName=""String_Node_Str"";
  int index=key.indexOf(':');
  if (index != -1) {
    mapName=key.substring(0,index);
    key=key.substring(index + 1);
  }
  Object value=textCommandService.get(mapName,key);
  MemcacheEntry entry=null;
  if (value != null) {
    if (value instanceof MemcacheEntry) {
      entry=(MemcacheEntry)value;
    }
 else {
      try {
        entry=new MemcacheEntry(key,IOUtil.serializeToBytes(value),0);
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
  textCommandService.incrementGetCount();
  if (entry != null) {
    textCommandService.incrementHitCount();
  }
  getCommand.setValue(entry,single);
  textCommandService.sendResponse(getCommand);
}","public void handle(GetCommand getCommand){
  String key=null;
  try {
    key=URLDecoder.decode(getCommand.getKey(),""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException e) {
    e.printStackTrace();
  }
  String mapName=""String_Node_Str"";
  int index=key.indexOf(':');
  if (index != -1) {
    mapName=key.substring(0,index);
    key=key.substring(index + 1);
  }
  Object value=textCommandService.get(mapName,key);
  MemcacheEntry entry=null;
  if (value != null) {
    if (value instanceof MemcacheEntry) {
      entry=(MemcacheEntry)value;
    }
 else {
      try {
        entry=new MemcacheEntry(getCommand.getKey(),IOUtil.serializeToBytes(value),0);
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
  textCommandService.incrementGetCount();
  if (entry != null) {
    textCommandService.incrementHitCount();
  }
  getCommand.setValue(entry,single);
  textCommandService.sendResponse(getCommand);
}",0.908256880733945
49966,"/** 
 * ""set"" means ""store this data"". <p/> ""add"" means ""store this data, but only if the server *doesn't* already hold data for this key"". <p/> ""replace"" means ""store this data, but only if the server *does already hold data for this key"". <p/> <p/> After sending the command line and the data block the client awaits the reply, which may be: <p/> - ""STORED\r\n"", to indicate success. <p/> - ""NOT_STORED\r\n"" to indicate the data was not stored, but not because of an error. This normally means that either that the condition for an ""add"" or a ""replace"" command wasn't met, or that the item is in a delete queue (see the ""delete"" command below).
 */
public void handle(SetCommand request){
  String key=request.getKey();
  String mapName=""String_Node_Str"";
  int index=key.indexOf(':');
  if (index != -1) {
    mapName=key.substring(0,index);
    key=key.substring(index + 1);
  }
  Object value=new MemcacheEntry(key,request.getValue(),request.getFlag());
  int ttl=textCommandService.getAdjustedTTLSeconds(request.getExpiration());
  textCommandService.incrementSetCount();
  if (SET == request.getType()) {
    request.setResponse(STORED);
    if (request.shouldReply()) {
      textCommandService.sendResponse(request);
    }
    textCommandService.put(mapName,key,value,ttl);
  }
 else   if (ADD == request.getType()) {
    boolean added=(textCommandService.putIfAbsent(mapName,key,value,ttl) == null);
    if (added) {
      request.setResponse(STORED);
    }
 else {
      request.setResponse(NOT_STORED);
    }
    if (request.shouldReply()) {
      textCommandService.sendResponse(request);
    }
  }
 else   if (REPLACE == request.getType()) {
    boolean replaced=(textCommandService.replace(mapName,key,value) != null);
    if (replaced) {
      request.setResponse(STORED);
    }
 else {
      request.setResponse(NOT_STORED);
    }
    if (request.shouldReply()) {
      textCommandService.sendResponse(request);
    }
  }
}","/** 
 * ""set"" means ""store this data"". <p/> ""add"" means ""store this data, but only if the server *doesn't* already hold data for this key"". <p/> ""replace"" means ""store this data, but only if the server *does already hold data for this key"". <p/> <p/> After sending the command line and the data block the client awaits the reply, which may be: <p/> - ""STORED\r\n"", to indicate success. <p/> - ""NOT_STORED\r\n"" to indicate the data was not stored, but not because of an error. This normally means that either that the condition for an ""add"" or a ""replace"" command wasn't met, or that the item is in a delete queue (see the ""delete"" command below).
 */
public void handle(SetCommand request){
  String key=null;
  try {
    key=URLDecoder.decode(request.getKey(),""String_Node_Str"");
  }
 catch (  UnsupportedEncodingException e) {
    e.printStackTrace();
  }
  String mapName=""String_Node_Str"";
  int index=key.indexOf(':');
  if (index != -1) {
    mapName=key.substring(0,index);
    key=key.substring(index + 1);
  }
  Object value=new MemcacheEntry(request.getKey(),request.getValue(),request.getFlag());
  int ttl=textCommandService.getAdjustedTTLSeconds(request.getExpiration());
  textCommandService.incrementSetCount();
  if (SET == request.getType()) {
    request.setResponse(STORED);
    if (request.shouldReply()) {
      textCommandService.sendResponse(request);
    }
    textCommandService.put(mapName,key,value,ttl);
  }
 else   if (ADD == request.getType()) {
    boolean added=(textCommandService.putIfAbsent(mapName,key,value,ttl) == null);
    if (added) {
      request.setResponse(STORED);
    }
 else {
      request.setResponse(NOT_STORED);
    }
    if (request.shouldReply()) {
      textCommandService.sendResponse(request);
    }
  }
 else   if (REPLACE == request.getType()) {
    boolean replaced=(textCommandService.replace(mapName,key,value) != null);
    if (replaced) {
      request.setResponse(STORED);
    }
 else {
      request.setResponse(NOT_STORED);
    }
    if (request.shouldReply()) {
      textCommandService.sendResponse(request);
    }
  }
}",0.952097294614048
49967,"public boolean writeTo(ByteBuffer bb){
  while (bb.hasRemaining() && response.hasRemaining()) {
    bb.put(response.get());
  }
  return !response.hasRemaining();
}","public boolean writeTo(ByteBuffer bb){
  IOUtil.copyToHeapBuffer(response,bb);
  return !response.hasRemaining();
}",0.6810035842293907
49968,"public void setResponse(byte[] value){
  this.response=ByteBuffer.wrap(value);
}","/** 
 * HTTP/1.0 200 OK Date: Fri, 31 Dec 1999 23:59:59 GMT Content-TextCommandType: text/html Content-Length: 1354
 * @param contentType
 * @param value
 */
public void setResponse(byte[] contentType,byte[] value){
  int valueSize=(value == null) ? 0 : value.length;
  byte[] len=String.valueOf(valueSize).getBytes();
  int size=RES_200.length;
  if (contentType != null) {
    size+=CONTENT_TYPE.length;
    size+=contentType.length;
    size+=RETURN.length;
  }
  size+=CONTENT_LENGTH.length;
  size+=len.length;
  size+=RETURN.length;
  size+=RETURN.length;
  size+=valueSize;
  size+=RETURN.length;
  this.response=ByteBuffer.allocate(size);
  response.put(RES_200);
  if (contentType != null) {
    response.put(CONTENT_TYPE);
    response.put(contentType);
    response.put(RETURN);
  }
  response.put(CONTENT_LENGTH);
  response.put(len);
  response.put(RETURN);
  response.put(RETURN);
  if (value != null) {
    response.put(value);
  }
  response.put(RETURN);
  response.flip();
}",0.1251167133520074
49969,"public void handle(HttpDeleteCommand command){
  String uri=command.getURI();
  if (uri.startsWith(URI_MAPS)) {
    int indexEnd=uri.indexOf('/',URI_MAPS.length());
    String mapName=uri.substring(URI_MAPS.length(),indexEnd);
    String key=uri.substring(indexEnd + 1);
    Object value=textCommandService.delete(mapName,key);
    command.send204();
  }
 else {
    command.send400();
  }
  textCommandService.sendResponse(command);
}","public void handle(HttpDeleteCommand command){
  String uri=command.getURI();
  if (uri.startsWith(URI_MAPS)) {
    int indexEnd=uri.indexOf('/',URI_MAPS.length());
    String mapName=uri.substring(URI_MAPS.length(),indexEnd);
    String key=uri.substring(indexEnd + 1);
    Object value=textCommandService.delete(mapName,key);
    command.send204();
  }
 else   if (uri.startsWith(URI_QUEUES)) {
    int indexEnd=uri.indexOf('/',URI_QUEUES.length());
    String queueName=uri.substring(URI_QUEUES.length(),indexEnd);
    String secondStr=(uri.length() > (indexEnd + 1)) ? uri.substring(indexEnd + 1) : null;
    int seconds=(secondStr == null) ? 0 : Integer.parseInt(secondStr);
    Object value=textCommandService.poll(queueName,seconds);
    if (value == null) {
      command.send204();
    }
 else {
      if (value instanceof byte[]) {
        command.setResponse(null,(byte[])value);
      }
 else       if (value instanceof RestValue) {
        RestValue restValue=(RestValue)value;
        command.setResponse(restValue.getContentType(),restValue.getValue());
      }
 else       if (value instanceof String) {
        command.setResponse(HttpCommand.CONTENT_TYPE_PLAIN_TEXT,((String)value).getBytes());
      }
 else {
        command.setResponse(null,ThreadContext.get().toByteArray(value));
      }
    }
  }
 else {
    command.send400();
  }
  textCommandService.sendResponse(command);
}",0.4738562091503268
49970,"public void handle(HttpGetCommand command){
  String uri=command.getURI();
  if (uri.startsWith(URI_MAPS)) {
    int indexEnd=uri.indexOf('/',URI_MAPS.length());
    String mapName=uri.substring(URI_MAPS.length(),indexEnd);
    String key=uri.substring(indexEnd + 1);
    Object value=textCommandService.get(mapName,key);
    if (value == null) {
      command.send204();
    }
 else {
      if (value instanceof byte[]) {
        command.setResponse(null,(byte[])value);
      }
 else       if (value instanceof RestValue) {
        RestValue restValue=(RestValue)value;
        command.setResponse(restValue.getContentType(),restValue.getValue());
      }
 else {
        command.setResponse(ThreadContext.get().toByteArray(value));
      }
    }
  }
 else   if (uri.startsWith(URI_CLUSTER)) {
    Node node=textCommandService.getNode();
    StringBuilder res=new StringBuilder(node.getClusterImpl().toString());
    res.append(""String_Node_Str"");
    ConnectionManager connectionManager=node.getConnectionManager();
    res.append(""String_Node_Str"" + connectionManager.getCurrentClientConnections());
    res.append(""String_Node_Str"");
    res.append(""String_Node_Str"" + connectionManager.getAllTextConnections());
    res.append(""String_Node_Str"");
    command.setResponse(null,res.toString().getBytes());
  }
 else {
    command.send400();
  }
  textCommandService.sendResponse(command);
}","public void handle(HttpGetCommand command){
  String uri=command.getURI();
  if (uri.startsWith(URI_MAPS)) {
    int indexEnd=uri.indexOf('/',URI_MAPS.length());
    String mapName=uri.substring(URI_MAPS.length(),indexEnd);
    String key=uri.substring(indexEnd + 1);
    Object value=textCommandService.get(mapName,key);
    if (value == null) {
      command.send204();
    }
 else {
      if (value instanceof byte[]) {
        command.setResponse(null,(byte[])value);
      }
 else       if (value instanceof RestValue) {
        RestValue restValue=(RestValue)value;
        command.setResponse(restValue.getContentType(),restValue.getValue());
      }
 else       if (value instanceof String) {
        command.setResponse(HttpCommand.CONTENT_TYPE_PLAIN_TEXT,((String)value).getBytes());
      }
 else {
        command.setResponse(ThreadContext.get().toByteArray(value));
      }
    }
  }
 else   if (uri.startsWith(URI_CLUSTER)) {
    Node node=textCommandService.getNode();
    StringBuilder res=new StringBuilder(node.getClusterImpl().toString());
    res.append(""String_Node_Str"");
    ConnectionManager connectionManager=node.getConnectionManager();
    res.append(""String_Node_Str"" + connectionManager.getCurrentClientConnections());
    res.append(""String_Node_Str"");
    res.append(""String_Node_Str"" + connectionManager.getAllTextConnections());
    res.append(""String_Node_Str"");
    command.setResponse(null,res.toString().getBytes());
  }
 else {
    command.send400();
  }
  textCommandService.sendResponse(command);
}",0.950886766712142
49971,"public MulticastService(Node node,MulticastSocket multicastSocket) throws Exception {
  this.node=node;
  logger=node.getLogger(MulticastService.class.getName());
  Config config=node.getConfig();
  this.multicastSocket=multicastSocket;
  int bufferSize=1024 * 1024;
  this.datagramPacketReceive=new DatagramPacket(new byte[bufferSize],bufferSize);
  this.datagramPacketSend=new DatagramPacket(new byte[bufferSize],bufferSize,InetAddress.getByName(config.getNetworkConfig().getJoin().getMulticastConfig().getMulticastGroup()),config.getNetworkConfig().getJoin().getMulticastConfig().getMulticastPort());
  running=true;
}","public MulticastService(Node node,MulticastSocket multicastSocket) throws Exception {
  this.node=node;
  logger=node.getLogger(MulticastService.class.getName());
  Config config=node.getConfig();
  this.multicastSocket=multicastSocket;
  int bufferSize=64 * 1024;
  this.datagramPacketReceive=new DatagramPacket(new byte[bufferSize],bufferSize);
  this.datagramPacketSend=new DatagramPacket(new byte[bufferSize],bufferSize,InetAddress.getByName(config.getNetworkConfig().getJoin().getMulticastConfig().getMulticastGroup()),config.getNetworkConfig().getJoin().getMulticastConfig().getMulticastPort());
  running=true;
}",0.9903225806451612
49972,"public void send(JoinInfo joinInfo){
synchronized (sendLock) {
    try {
      joinInfo.writeToPacket(datagramPacketSend);
      multicastSocket.send(datagramPacketSend);
    }
 catch (    IOException e) {
      logger.log(Level.WARNING,e.getMessage(),e);
    }
  }
}","public void send(JoinInfo joinInfo){
synchronized (sendLock) {
    try {
      joinInfo.writeToPacket(datagramPacketSend);
      multicastSocket.send(datagramPacketSend);
    }
 catch (    IOException e) {
      logger.log(Level.WARNING,""String_Node_Str"",e);
    }
  }
}",0.9422718808193667
49973,"public boolean cancel(boolean mayInterruptIfRunning){
  return false;
}","public boolean cancel(boolean mayInterruptIfRunning){
  cancelled=(Boolean)proxyHelper.doOp(ClusterOperation.CANCEL_EXECUTION,call.getId(),mayInterruptIfRunning);
  return cancelled;
}",0.5411764705882353
49974,"public void get(long timeout,TimeUnit unit) throws InterruptedException, ExecutionException {
  try {
    Object response=call.getResponse(timeout,unit);
    handle(response);
  }
 catch (  Throwable e) {
    handle(e);
  }
}","public void get(long timeout,TimeUnit unit) throws InterruptedException, ExecutionException {
  if (cancelled)   throw new CancellationException();
  try {
    Object response=call.getResponse(timeout,unit);
    handle(response);
  }
 catch (  Throwable e) {
    handle(e);
  }
}",0.8928571428571429
49975,"public void run(){
}","public void run(){
  try {
    System.out.println(""String_Node_Str"");
    Thread.sleep(1000);
    System.out.println(""String_Node_Str"");
    getHazelcastInstance().getMap(""String_Node_Str"").put(1,false);
  }
 catch (  InterruptedException e) {
    System.out.println(""String_Node_Str"");
    getHazelcastInstance().getMap(""String_Node_Str"").put(1,true);
  }
}",0.1058201058201058
49976,"public ClientService(Node node){
  this.node=node;
  this.logger=node.getLogger(this.getClass().getName());
  node.getClusterImpl().addMembershipListener(new ClientServiceMembershipListener());
  clientOperationHandlers[CONCURRENT_MAP_PUT.getValue()]=new MapPutHandler();
  clientOperationHandlers[CONCURRENT_MAP_PUT_AND_UNLOCK.getValue()]=new MapPutAndUnlockHandler();
  clientOperationHandlers[CONCURRENT_MAP_PUT_ALL.getValue()]=new MapPutAllHandler();
  clientOperationHandlers[CONCURRENT_MAP_PUT_MULTI.getValue()]=new MapPutMultiHandler();
  clientOperationHandlers[CONCURRENT_MAP_PUT_IF_ABSENT.getValue()]=new MapPutIfAbsentHandler();
  clientOperationHandlers[CONCURRENT_MAP_TRY_PUT.getValue()]=new MapTryPutHandler();
  clientOperationHandlers[CONCURRENT_MAP_GET.getValue()]=new MapGetHandler();
  clientOperationHandlers[CONCURRENT_MAP_GET_ALL.getValue()]=new MapGetAllHandler();
  clientOperationHandlers[CONCURRENT_MAP_REMOVE.getValue()]=new MapRemoveHandler();
  clientOperationHandlers[CONCURRENT_MAP_TRY_REMOVE.getValue()]=new MapTryRemoveHandler();
  clientOperationHandlers[CONCURRENT_MAP_REMOVE_IF_SAME.getValue()]=new MapRemoveIfSameHandler();
  clientOperationHandlers[CONCURRENT_MAP_REMOVE_MULTI.getValue()]=new MapRemoveMultiHandler();
  clientOperationHandlers[CONCURRENT_MAP_EVICT.getValue()]=new MapEvictHandler();
  clientOperationHandlers[CONCURRENT_MAP_FLUSH.getValue()]=new MapFlushHandler();
  clientOperationHandlers[CONCURRENT_MAP_REPLACE_IF_NOT_NULL.getValue()]=new MapReplaceIfNotNullHandler();
  clientOperationHandlers[CONCURRENT_MAP_REPLACE_IF_SAME.getValue()]=new MapReplaceIfSameHandler();
  clientOperationHandlers[CONCURRENT_MAP_SIZE.getValue()]=new MapSizeHandler();
  clientOperationHandlers[CONCURRENT_MAP_GET_MAP_ENTRY.getValue()]=new GetMapEntryHandler();
  clientOperationHandlers[CONCURRENT_MAP_TRY_LOCK_AND_GET.getValue()]=new MapTryLockAndGetHandler();
  clientOperationHandlers[CONCURRENT_MAP_LOCK.getValue()]=new MapLockHandler();
  clientOperationHandlers[CONCURRENT_MAP_UNLOCK.getValue()]=new MapUnlockHandler();
  clientOperationHandlers[CONCURRENT_MAP_LOCK_MAP.getValue()]=new MapLockMapHandler();
  clientOperationHandlers[CONCURRENT_MAP_UNLOCK_MAP.getValue()]=new MapUnlockMapHandler();
  clientOperationHandlers[CONCURRENT_MAP_CONTAINS.getValue()]=new MapContainsHandler();
  clientOperationHandlers[CONCURRENT_MAP_CONTAINS_VALUE.getValue()]=new MapContainsValueHandler();
  clientOperationHandlers[CONCURRENT_MAP_ADD_TO_LIST.getValue()]=new ListAddHandler();
  clientOperationHandlers[CONCURRENT_MAP_ADD_TO_SET.getValue()]=new SetAddHandler();
  clientOperationHandlers[CONCURRENT_MAP_REMOVE_ITEM.getValue()]=new MapItemRemoveHandler();
  clientOperationHandlers[CONCURRENT_MAP_ITERATE_KEYS.getValue()]=new MapIterateKeysHandler();
  clientOperationHandlers[CONCURRENT_MAP_ITERATE_ENTRIES.getValue()]=new MapIterateEntriesHandler();
  clientOperationHandlers[CONCURRENT_MAP_VALUE_COUNT.getValue()]=new MapValueCountHandler();
  clientOperationHandlers[TOPIC_PUBLISH.getValue()]=new TopicPublishHandler();
  clientOperationHandlers[BLOCKING_QUEUE_OFFER.getValue()]=new QueueOfferHandler();
  clientOperationHandlers[BLOCKING_QUEUE_POLL.getValue()]=new QueuePollHandler();
  clientOperationHandlers[BLOCKING_QUEUE_REMOVE.getValue()]=new QueueRemoveHandler();
  clientOperationHandlers[BLOCKING_QUEUE_PEEK.getValue()]=new QueuePeekHandler();
  clientOperationHandlers[BLOCKING_QUEUE_SIZE.getValue()]=new QueueSizeHandler();
  clientOperationHandlers[BLOCKING_QUEUE_REMAINING_CAPACITY.getValue()]=new QueueRemainingCapacityHandler();
  clientOperationHandlers[BLOCKING_QUEUE_ENTRIES.getValue()]=new QueueEntriesHandler();
  clientOperationHandlers[TRANSACTION_BEGIN.getValue()]=new TransactionBeginHandler();
  clientOperationHandlers[TRANSACTION_COMMIT.getValue()]=new TransactionCommitHandler();
  clientOperationHandlers[TRANSACTION_ROLLBACK.getValue()]=new TransactionRollbackHandler();
  clientOperationHandlers[ADD_LISTENER.getValue()]=new AddListenerHandler();
  clientOperationHandlers[REMOVE_LISTENER.getValue()]=new RemoveListenerHandler();
  clientOperationHandlers[REMOTELY_PROCESS.getValue()]=new RemotelyProcessHandler();
  clientOperationHandlers[DESTROY.getValue()]=new DestroyHandler();
  clientOperationHandlers[GET_ID.getValue()]=new GetIdHandler();
  clientOperationHandlers[ADD_INDEX.getValue()]=new AddIndexHandler();
  clientOperationHandlers[NEW_ID.getValue()]=new NewIdHandler();
  clientOperationHandlers[EXECUTE.getValue()]=new ExecutorServiceHandler();
  clientOperationHandlers[GET_INSTANCES.getValue()]=new GetInstancesHandler();
  clientOperationHandlers[GET_MEMBERS.getValue()]=new GetMembersHandler();
  clientOperationHandlers[GET_CLUSTER_TIME.getValue()]=new GetClusterTimeHandler();
  clientOperationHandlers[CLIENT_AUTHENTICATE.getValue()]=new ClientAuthenticateHandler();
  clientOperationHandlers[CLIENT_ADD_INSTANCE_LISTENER.getValue()]=new ClientAddInstanceListenerHandler();
  clientOperationHandlers[CLIENT_GET_PARTITIONS.getValue()]=new GetPartitionsHandler();
  clientOperationHandlers[ATOMIC_NUMBER_GET_AND_SET.getValue()]=new AtomicOperationHandler();
  clientOperationHandlers[ATOMIC_NUMBER_GET_AND_ADD.getValue()]=new AtomicOperationHandler();
  clientOperationHandlers[ATOMIC_NUMBER_COMPARE_AND_SET.getValue()]=new AtomicOperationHandler();
  clientOperationHandlers[ATOMIC_NUMBER_ADD_AND_GET.getValue()]=new AtomicOperationHandler();
  node.connectionManager.addConnectionListener(this);
  this.THREAD_COUNT=node.getGroupProperties().EXECUTOR_CLIENT_THREAD_COUNT.getInteger();
  workers=new Worker[THREAD_COUNT];
  for (int i=0; i < THREAD_COUNT; i++) {
    workers[i]=new Worker();
  }
}","public ClientService(Node node){
  this.node=node;
  this.logger=node.getLogger(this.getClass().getName());
  node.getClusterImpl().addMembershipListener(new ClientServiceMembershipListener());
  clientOperationHandlers[CONCURRENT_MAP_PUT.getValue()]=new MapPutHandler();
  clientOperationHandlers[CONCURRENT_MAP_PUT_AND_UNLOCK.getValue()]=new MapPutAndUnlockHandler();
  clientOperationHandlers[CONCURRENT_MAP_PUT_ALL.getValue()]=new MapPutAllHandler();
  clientOperationHandlers[CONCURRENT_MAP_PUT_MULTI.getValue()]=new MapPutMultiHandler();
  clientOperationHandlers[CONCURRENT_MAP_PUT_IF_ABSENT.getValue()]=new MapPutIfAbsentHandler();
  clientOperationHandlers[CONCURRENT_MAP_TRY_PUT.getValue()]=new MapTryPutHandler();
  clientOperationHandlers[CONCURRENT_MAP_GET.getValue()]=new MapGetHandler();
  clientOperationHandlers[CONCURRENT_MAP_GET_ALL.getValue()]=new MapGetAllHandler();
  clientOperationHandlers[CONCURRENT_MAP_REMOVE.getValue()]=new MapRemoveHandler();
  clientOperationHandlers[CONCURRENT_MAP_TRY_REMOVE.getValue()]=new MapTryRemoveHandler();
  clientOperationHandlers[CONCURRENT_MAP_REMOVE_IF_SAME.getValue()]=new MapRemoveIfSameHandler();
  clientOperationHandlers[CONCURRENT_MAP_REMOVE_MULTI.getValue()]=new MapRemoveMultiHandler();
  clientOperationHandlers[CONCURRENT_MAP_EVICT.getValue()]=new MapEvictHandler();
  clientOperationHandlers[CONCURRENT_MAP_FLUSH.getValue()]=new MapFlushHandler();
  clientOperationHandlers[CONCURRENT_MAP_REPLACE_IF_NOT_NULL.getValue()]=new MapReplaceIfNotNullHandler();
  clientOperationHandlers[CONCURRENT_MAP_REPLACE_IF_SAME.getValue()]=new MapReplaceIfSameHandler();
  clientOperationHandlers[CONCURRENT_MAP_SIZE.getValue()]=new MapSizeHandler();
  clientOperationHandlers[CONCURRENT_MAP_GET_MAP_ENTRY.getValue()]=new GetMapEntryHandler();
  clientOperationHandlers[CONCURRENT_MAP_TRY_LOCK_AND_GET.getValue()]=new MapTryLockAndGetHandler();
  clientOperationHandlers[CONCURRENT_MAP_LOCK.getValue()]=new MapLockHandler();
  clientOperationHandlers[CONCURRENT_MAP_UNLOCK.getValue()]=new MapUnlockHandler();
  clientOperationHandlers[CONCURRENT_MAP_LOCK_MAP.getValue()]=new MapLockMapHandler();
  clientOperationHandlers[CONCURRENT_MAP_UNLOCK_MAP.getValue()]=new MapUnlockMapHandler();
  clientOperationHandlers[CONCURRENT_MAP_CONTAINS.getValue()]=new MapContainsHandler();
  clientOperationHandlers[CONCURRENT_MAP_CONTAINS_VALUE.getValue()]=new MapContainsValueHandler();
  clientOperationHandlers[CONCURRENT_MAP_ADD_TO_LIST.getValue()]=new ListAddHandler();
  clientOperationHandlers[CONCURRENT_MAP_ADD_TO_SET.getValue()]=new SetAddHandler();
  clientOperationHandlers[CONCURRENT_MAP_REMOVE_ITEM.getValue()]=new MapItemRemoveHandler();
  clientOperationHandlers[CONCURRENT_MAP_ITERATE_KEYS.getValue()]=new MapIterateKeysHandler();
  clientOperationHandlers[CONCURRENT_MAP_ITERATE_ENTRIES.getValue()]=new MapIterateEntriesHandler();
  clientOperationHandlers[CONCURRENT_MAP_VALUE_COUNT.getValue()]=new MapValueCountHandler();
  clientOperationHandlers[TOPIC_PUBLISH.getValue()]=new TopicPublishHandler();
  clientOperationHandlers[BLOCKING_QUEUE_OFFER.getValue()]=new QueueOfferHandler();
  clientOperationHandlers[BLOCKING_QUEUE_POLL.getValue()]=new QueuePollHandler();
  clientOperationHandlers[BLOCKING_QUEUE_REMOVE.getValue()]=new QueueRemoveHandler();
  clientOperationHandlers[BLOCKING_QUEUE_PEEK.getValue()]=new QueuePeekHandler();
  clientOperationHandlers[BLOCKING_QUEUE_SIZE.getValue()]=new QueueSizeHandler();
  clientOperationHandlers[BLOCKING_QUEUE_REMAINING_CAPACITY.getValue()]=new QueueRemainingCapacityHandler();
  clientOperationHandlers[BLOCKING_QUEUE_ENTRIES.getValue()]=new QueueEntriesHandler();
  clientOperationHandlers[TRANSACTION_BEGIN.getValue()]=new TransactionBeginHandler();
  clientOperationHandlers[TRANSACTION_COMMIT.getValue()]=new TransactionCommitHandler();
  clientOperationHandlers[TRANSACTION_ROLLBACK.getValue()]=new TransactionRollbackHandler();
  clientOperationHandlers[ADD_LISTENER.getValue()]=new AddListenerHandler();
  clientOperationHandlers[REMOVE_LISTENER.getValue()]=new RemoveListenerHandler();
  clientOperationHandlers[REMOTELY_PROCESS.getValue()]=new RemotelyProcessHandler();
  clientOperationHandlers[DESTROY.getValue()]=new DestroyHandler();
  clientOperationHandlers[GET_ID.getValue()]=new GetIdHandler();
  clientOperationHandlers[ADD_INDEX.getValue()]=new AddIndexHandler();
  clientOperationHandlers[NEW_ID.getValue()]=new NewIdHandler();
  clientOperationHandlers[EXECUTE.getValue()]=new ExecutorServiceHandler();
  clientOperationHandlers[CANCEL_EXECUTION.getValue()]=new CancelExecutionHandler();
  clientOperationHandlers[GET_INSTANCES.getValue()]=new GetInstancesHandler();
  clientOperationHandlers[GET_MEMBERS.getValue()]=new GetMembersHandler();
  clientOperationHandlers[GET_CLUSTER_TIME.getValue()]=new GetClusterTimeHandler();
  clientOperationHandlers[CLIENT_AUTHENTICATE.getValue()]=new ClientAuthenticateHandler();
  clientOperationHandlers[CLIENT_ADD_INSTANCE_LISTENER.getValue()]=new ClientAddInstanceListenerHandler();
  clientOperationHandlers[CLIENT_GET_PARTITIONS.getValue()]=new GetPartitionsHandler();
  clientOperationHandlers[ATOMIC_NUMBER_GET_AND_SET.getValue()]=new AtomicOperationHandler();
  clientOperationHandlers[ATOMIC_NUMBER_GET_AND_ADD.getValue()]=new AtomicOperationHandler();
  clientOperationHandlers[ATOMIC_NUMBER_COMPARE_AND_SET.getValue()]=new AtomicOperationHandler();
  clientOperationHandlers[ATOMIC_NUMBER_ADD_AND_GET.getValue()]=new AtomicOperationHandler();
  node.connectionManager.addConnectionListener(this);
  this.THREAD_COUNT=node.getGroupProperties().EXECUTOR_CLIENT_THREAD_COUNT.getInteger();
  workers=new Worker[THREAD_COUNT];
  for (int i=0; i < THREAD_COUNT; i++) {
    workers[i]=new Worker();
  }
}",0.9925900095893994
49977,"public void done(Future future){
  Object result;
  try {
    result=future.get();
    packet.setValue(toData(result));
  }
 catch (  InterruptedException e) {
    return;
  }
catch (  ExecutionException e) {
    packet.setValue(toData(e));
  }
  sendResponse(packet);
}","public void done(Future future){
  Object result;
  try {
    clientEndpoint.removeTask(packet.callId);
    result=future.get();
    packet.setValue(toData(result));
  }
 catch (  InterruptedException e) {
    return;
  }
catch (  CancellationException e) {
    packet.setValue(toData(e));
  }
catch (  ExecutionException e) {
    packet.setValue(toData(e));
  }
  sendResponse(packet);
}",0.7993920972644377
49978,"public void lockMap(Request request){
  if (request.operation == CONCURRENT_MAP_LOCK_MAP) {
    if (lockEntireMap == null) {
      lockEntireMap=new DistributedLock();
    }
    lockEntireMap.lock(request.lockAddress,request.lockThreadId);
    request.clearForResponse();
    request.response=Boolean.TRUE;
  }
 else   if (request.operation == CONCURRENT_MAP_UNLOCK_MAP) {
    if (lockEntireMap != null) {
      request.response=lockEntireMap.unlock(request.lockAddress,request.lockThreadId);
    }
 else {
      request.response=Boolean.TRUE;
    }
  }
}","public void lockMap(Request request){
  if (request.operation == CONCURRENT_MAP_LOCK_MAP) {
    if (lockEntireMap == null) {
      lockEntireMap=new DistributedLock();
    }
    if (!lockEntireMap.isLockedBy(request.lockAddress,request.lockThreadId)) {
      lockEntireMap.lock(request.lockAddress,request.lockThreadId);
    }
    request.clearForResponse();
    request.response=Boolean.TRUE;
  }
 else   if (request.operation == CONCURRENT_MAP_UNLOCK_MAP) {
    if (lockEntireMap != null) {
      request.response=lockEntireMap.unlock(request.lockAddress,request.lockThreadId);
    }
 else {
      request.response=Boolean.TRUE;
    }
  }
}",0.8972431077694235
49979,"final boolean isNotLocked(Request request){
  return (lockEntireMap == null || !lockEntireMap.isLocked() || lockEntireMap.isLockedBy(request.lockAddress,request.lockThreadId));
}","final boolean isNotLocked(Request request){
  boolean result=(lockEntireMap == null || !lockEntireMap.isLocked() || lockEntireMap.isLockedBy(request.lockAddress,request.lockThreadId));
  if (!result) {
    System.out.println(thisAddress + ""String_Node_Str"" + request.caller);
    System.out.println(lockEntireMap + ""String_Node_Str"" + request.operation);
  }
  return result;
}",0.6162162162162163
49980,"/** 
 * MultiMap and List have to use versioned backup because each key can have multiple values and we don't want to miss backing up each one.
 * @param req
 * @return
 */
private boolean backupMultiValue(Request req){
  Record record=getRecord(req);
  if (record != null) {
    record.setActive();
    if (req.version > record.getVersion() + 1) {
      Request reqCopy=req.hardCopy();
      record.addBackupOp(new VersionedBackupOp(this,reqCopy));
      return true;
    }
 else     if (req.version <= record.getVersion()) {
      return false;
    }
  }
  doBackup(req);
  if (record != null) {
    record.setVersion(req.version);
    record.runBackupOps();
  }
  return true;
}","/** 
 * MultiMap and List have to use versioned backup because each key can have multiple values and we don't want to miss backing up each one.
 * @param req
 * @return
 */
private boolean backupMultiValue(Request req){
  Record record=getRecord(req);
  if (record != null) {
    record.setActive();
    if (req.version > record.getVersion() + 1) {
      Request reqCopy=req.hardCopy();
      record.addBackupOp(new VersionedBackupOp(this,reqCopy));
      return true;
    }
  }
  doBackup(req);
  if (record != null) {
    record.setVersion(req.version);
    record.runBackupOps();
  }
  return true;
}",0.9392523364485982
49981,"public void run(){
  long now=System.currentTimeMillis();
  if (now > nextMigrationMillis) {
    if (migrationStartTime != 0) {
      logger.log(Level.WARNING,""String_Node_Str"" + ((now - migrationStartTime) / 1000) + ""String_Node_Str"");
      for (      Block block : blocks) {
        logger.log(Level.WARNING,block == null ? ""String_Node_Str"" : block.toString());
      }
    }
    nextMigrationMillis=now + MIGRATION_INTERVAL_MILLIS;
    if (!concurrentMapManager.isMaster())     return;
    if (concurrentMapManager.getMembers().size() < 2)     return;
    if (now > timeToInitiateMigration) {
      initiateMigration();
    }
  }
}","public void run(){
  long now=System.currentTimeMillis();
  if (now > nextMigrationMillis) {
    if (migrationStartTime != 0) {
      for (      Block block : blocks) {
        if (block != null && block.isMigrating()) {
          long seconds=((now - migrationStartTime) / 1000);
          String msg=block.toString() + ""String_Node_Str"" + seconds+ ""String_Node_Str"";
          logger.log(Level.WARNING,msg);
        }
      }
    }
    nextMigrationMillis=now + MIGRATION_INTERVAL_MILLIS;
    if (!concurrentMapManager.isMaster())     return;
    if (concurrentMapManager.getMembers().size() < 2)     return;
    if (now > timeToInitiateMigration) {
      initiateMigration();
    }
  }
}",0.6485671191553545
49982,"void migrateBlock(final Block blockInfo){
  Block blockReal=blocks[blockInfo.getBlockId()];
  if (!thisAddress.equals(blockInfo.getOwner())) {
    throw new RuntimeException(thisAddress + ""String_Node_Str"" + blockInfo);
  }
  if (!blockInfo.isMigrating()) {
    throw new RuntimeException(thisAddress + ""String_Node_Str"" + blockInfo);
  }
  if (blockInfo.getOwner().equals(blockInfo.getMigrationAddress())) {
    throw new RuntimeException(thisAddress + ""String_Node_Str"" + blockInfo);
  }
  if (!node.isActive() || node.factory.restarted) {
    return;
  }
  if (concurrentMapManager.isSuperClient()) {
    return;
  }
  if (blockReal.isMigrationStarted())   return;
  blockReal.setMigrationStarted(true);
  blockReal.setOwner(blockInfo.getOwner());
  blockReal.setMigrationAddress(blockInfo.getMigrationAddress());
  logger.log(Level.FINEST,""String_Node_Str"" + blockInfo);
  List<Record> lsRecordsToMigrate=new ArrayList<Record>(1000);
  Collection<CMap> cmaps=concurrentMapManager.maps.values();
  for (  final CMap cmap : cmaps) {
    for (    Record rec : cmap.mapRecords.values()) {
      if (rec.isActive() && concurrentMapManager.isOwned(rec)) {
        if (rec.getKeyData() == null || rec.getKeyData().size() == 0) {
          throw new RuntimeException(""String_Node_Str"" + rec.getKeyData());
        }
        if (rec.getBlockId() == blockInfo.getBlockId()) {
          cmap.onMigrate(rec);
          Record recordCopy=rec.copy();
          lsRecordsToMigrate.add(recordCopy);
          cmap.markAsEvicted(rec);
        }
      }
    }
  }
  logger.log(Level.FINEST,""String_Node_Str"" + lsRecordsToMigrate.size() + ""String_Node_Str""+ blockInfo);
  final CountDownLatch latch=new CountDownLatch(lsRecordsToMigrate.size());
  for (  final Record rec : lsRecordsToMigrate) {
    final CMap cmap=concurrentMapManager.getMap(rec.getName());
    parallelExecutorMigration.execute(new FallThroughRunnable(){
      public void doRun(){
        try {
          concurrentMapManager.migrateRecord(cmap,rec);
        }
  finally {
          latch.countDown();
        }
      }
    }
);
  }
  parallelExecutorMigration.execute(new FallThroughRunnable(){
    public void doRun(){
      try {
        logger.log(Level.FINEST,""String_Node_Str"" + blockInfo + ""String_Node_Str"");
        latch.await(10,TimeUnit.SECONDS);
        if (MIGRATION_COMPLETE_WAIT_SECONDS > 0) {
          Thread.sleep(MIGRATION_COMPLETE_WAIT_SECONDS * 1000);
        }
      }
 catch (      InterruptedException ignored) {
      }
 finally {
        concurrentMapManager.enqueueAndReturn(new Processable(){
          public void process(){
            blockInfo.setOwner(blockInfo.getMigrationAddress());
            blockInfo.setMigrationAddress(null);
            completeMigration(blockInfo.getBlockId());
            sendCompletionInfo(blockInfo);
          }
        }
);
      }
    }
  }
);
}","void migrateBlock(final Block blockInfo){
  List<Record> lsRecordsToMigrate=prepareMigratingRecords(blockInfo);
  if (lsRecordsToMigrate == null)   return;
  migrateRecords(blockInfo,lsRecordsToMigrate);
}",0.049430894308943
49983,"void handleBlocks(Blocks blockOwners){
  for (  Block block : blockOwners.lsBlocks) {
    Block blockReal=getOrCreateBlock(block.getBlockId());
    boolean same=sameBlocks(block,blockReal);
    blockReal.setOwner(block.getOwner());
    blockReal.setMigrationAddress(block.getMigrationAddress());
    if (thisAddress.equals(blockReal.getOwner()) && blockReal.isMigrating()) {
      startMigration(new Block(block));
    }
 else     if (!same && block.getOwner() != null) {
      boolean started=blockReal.isMigrating();
      if (started) {
        fireMigrationEvent(started,new Block(block));
      }
 else {
        fireMigrationEvent(started,new Block(block.getBlockId(),null,block.getOwner()));
      }
    }
    if (!same) {
      invalidateBlocksHash();
    }
  }
}","void handleBlocks(Blocks blockOwners){
  for (  Block block : blockOwners.lsBlocks) {
    Block blockReal=getOrCreateBlock(block.getBlockId());
    boolean same=sameBlocks(block,blockReal);
    blockReal.setOwner(block.getOwner());
    blockReal.setMigrationAddress(block.getMigrationAddress());
    if (thisAddress.equals(blockReal.getOwner()) && blockReal.isMigrating()) {
      fireMigrationEventAndMigrate(new Block(block));
    }
 else     if (!same && block.getOwner() != null) {
      boolean started=blockReal.isMigrating();
      if (started) {
        fireMigrationEvent(started,new Block(block));
      }
 else {
        fireMigrationEvent(started,new Block(block.getBlockId(),null,block.getOwner()));
      }
    }
    if (!same) {
      invalidateBlocksHash();
    }
  }
}",0.9845758354755784
49984,"final void handleSocketException(Throwable e){
  if (e instanceof OutOfMemoryError) {
    node.onOutOfMemory((OutOfMemoryError)e);
  }
  if (sk != null) {
    sk.cancel();
  }
  connection.close();
  StringBuilder sb=new StringBuilder();
  sb.append(Thread.currentThread().getName());
  sb.append(""String_Node_Str"");
  sb.append(connection.getEndPoint());
  sb.append(""String_Node_Str"").append(e);
  if (e instanceof EOFException) {
    logger.log(Level.WARNING,sb.toString());
  }
 else {
    logger.log(Level.WARNING,sb.toString(),e);
  }
}","final void handleSocketException(Throwable e){
  if (e instanceof OutOfMemoryError) {
    node.onOutOfMemory((OutOfMemoryError)e);
  }
  if (sk != null) {
    sk.cancel();
  }
  connection.close();
  StringBuilder sb=new StringBuilder();
  sb.append(Thread.currentThread().getName());
  sb.append(""String_Node_Str"");
  sb.append(connection.getEndPoint());
  sb.append(""String_Node_Str"").append(e);
  if (e instanceof IOException) {
    logger.log(Level.WARNING,sb.toString());
  }
 else {
    logger.log(Level.WARNING,sb.toString(),e);
  }
}",0.9953831948291784
49985,"/** 
 * executorThread
 */
public void execute(Request request){
  CMap cmap=maps.get(request.name);
  if (request.operation == CONCURRENT_MAP_GET) {
    Object value=cmap.loader.load(toObject(request.key));
    if (value != null) {
      setIndexValues(request,value);
      request.value=toData(value);
    }
  }
 else   if (request.operation == CONCURRENT_MAP_PUT || request.operation == CONCURRENT_MAP_PUT_IF_ABSENT) {
    Object value=toObject(request.value);
    cmap.store.store(toObject(request.key),value);
    Record storedRecord=cmap.getRecord(request);
    if (storedRecord != null) {
      storedRecord.setLastStoredTime(System.currentTimeMillis());
    }
  }
 else   if (request.operation == CONCURRENT_MAP_REMOVE) {
    Object key=toObject(request.key);
    if (cmap.loader != null && request.value == null) {
      Object removedObject=cmap.loader.load(key);
      if (removedObject == null) {
        return;
      }
 else {
        request.response=toData(removedObject);
      }
    }
    cmap.store.delete(key);
  }
 else   if (request.operation == CONCURRENT_MAP_EVICT) {
    cmap.store.store(toObject(request.key),toObject(request.value));
    Record storedRecord=cmap.getRecord(request);
    storedRecord.setLastStoredTime(System.currentTimeMillis());
    request.response=Boolean.TRUE;
  }
 else   if (request.operation == CONCURRENT_MAP_MERGE) {
    boolean success=false;
    Object winner=null;
    if (cmap.mergePolicy != null) {
      Record existingRecord=cmap.getRecord(request);
      DataRecordEntry existing=(existingRecord == null) ? null : new DataRecordEntry(existingRecord);
      DataRecordEntry newEntry=(DataRecordEntry)toObject(request.value);
      Object key=newEntry.getKey();
      if (key != null && newEntry.hasValue()) {
        winner=cmap.mergePolicy.merge(cmap.getName(),newEntry,existing);
        if (winner != null) {
          success=true;
          if (cmap.writeDelayMillis == 0 && cmap.store != null) {
            Object winnerObject=(winner instanceof Data) ? toObject((Data)winner) : winner;
            cmap.store.store(key,winnerObject);
            existingRecord.setLastStoredTime(System.currentTimeMillis());
            success=(request.response == null);
          }
        }
      }
    }
    if (success) {
      request.value=toData(winner);
      request.response=Boolean.TRUE;
    }
 else {
      request.value=null;
      request.response=Boolean.FALSE;
    }
  }
}","/** 
 * executorThread
 */
public void execute(Request request){
  CMap cmap=maps.get(request.name);
  if (request.operation == CONCURRENT_MAP_GET) {
    Object value=cmap.loader.load(toObject(request.key));
    if (value != null) {
      setIndexValues(request,value);
      request.value=toData(value);
    }
    putTransient(request);
  }
 else   if (request.operation == CONCURRENT_MAP_PUT || request.operation == CONCURRENT_MAP_PUT_IF_ABSENT) {
    Object value=toObject(request.value);
    cmap.store.store(toObject(request.key),value);
    Record storedRecord=cmap.getRecord(request);
    if (storedRecord != null) {
      storedRecord.setLastStoredTime(System.currentTimeMillis());
    }
  }
 else   if (request.operation == CONCURRENT_MAP_REMOVE) {
    Object key=toObject(request.key);
    if (cmap.loader != null && request.value == null) {
      Object removedObject=cmap.loader.load(key);
      if (removedObject == null) {
        return;
      }
 else {
        request.response=toData(removedObject);
      }
    }
    cmap.store.delete(key);
  }
 else   if (request.operation == CONCURRENT_MAP_EVICT) {
    cmap.store.store(toObject(request.key),toObject(request.value));
    Record storedRecord=cmap.getRecord(request);
    storedRecord.setLastStoredTime(System.currentTimeMillis());
    request.response=Boolean.TRUE;
  }
 else   if (request.operation == CONCURRENT_MAP_MERGE) {
    boolean success=false;
    Object winner=null;
    if (cmap.mergePolicy != null) {
      Record existingRecord=cmap.getRecord(request);
      DataRecordEntry existing=(existingRecord == null) ? null : new DataRecordEntry(existingRecord);
      DataRecordEntry newEntry=(DataRecordEntry)toObject(request.value);
      Object key=newEntry.getKey();
      if (key != null && newEntry.hasValue()) {
        winner=cmap.mergePolicy.merge(cmap.getName(),newEntry,existing);
        if (winner != null) {
          success=true;
          if (cmap.writeDelayMillis == 0 && cmap.store != null) {
            Object winnerObject=(winner instanceof Data) ? toObject((Data)winner) : winner;
            cmap.store.store(key,winnerObject);
            existingRecord.setLastStoredTime(System.currentTimeMillis());
            success=(request.response == null);
          }
        }
      }
    }
    if (success) {
      request.value=toData(winner);
      request.response=Boolean.TRUE;
    }
 else {
      request.value=null;
      request.response=Boolean.FALSE;
    }
  }
}",0.9945021380574222
49986,"private void postJoin(){
  if (!isMaster()) {
    Set<Member> members=null;
    boolean allConnected=false;
    int checkCount=0;
    while (checkCount++ < 100 && !allConnected) {
      try {
        Thread.sleep(1000);
      }
 catch (      InterruptedException ignored) {
      }
      members=clusterImpl.getMembers();
      allConnected=true;
      for (      Member member : members) {
        MemberImpl memberImpl=(MemberImpl)member;
        if (!memberImpl.localMember() && connectionManager.getConnection(memberImpl.getAddress()) == null) {
          allConnected=false;
        }
      }
    }
    if (!allConnected) {
      logger.log(Level.WARNING,""String_Node_Str"" + checkCount + ""String_Node_Str"");
      logger.log(Level.WARNING,""String_Node_Str"");
      try {
        Thread.sleep(10000);
      }
 catch (      InterruptedException e) {
        shutdown();
      }
      rejoin();
      return;
    }
 else {
      clusterManager.finalizeJoin();
    }
  }
  clusterManager.enqueueAndWait(new Processable(){
    public void process(){
      if (baseVariables.lsMembers.size() == 1) {
        final StringBuilder sb=new StringBuilder();
        sb.append(""String_Node_Str"");
        sb.append(clusterManager);
        logger.log(Level.INFO,sb.toString());
      }
    }
  }
,5);
}","private void postJoin(){
  if (!isMaster()) {
    boolean allConnected=false;
    int checkCount=0;
    while (checkCount++ < 100 && !allConnected) {
      try {
        Thread.sleep(1000);
      }
 catch (      InterruptedException ignored) {
      }
      Set<Member> members=clusterImpl.getMembers();
      allConnected=true;
      for (      Member member : members) {
        MemberImpl memberImpl=(MemberImpl)member;
        if (!memberImpl.localMember() && connectionManager.getConnection(memberImpl.getAddress()) == null) {
          allConnected=false;
        }
      }
    }
    if (!allConnected) {
      logger.log(Level.WARNING,""String_Node_Str"" + checkCount + ""String_Node_Str"");
      logger.log(Level.WARNING,""String_Node_Str"");
      try {
        Thread.sleep(10000);
      }
 catch (      InterruptedException e) {
        shutdown();
      }
      rejoin();
      return;
    }
 else {
      clusterManager.finalizeJoin();
    }
  }
  clusterManager.enqueueAndWait(new Processable(){
    public void process(){
      if (baseVariables.lsMembers.size() == 1) {
        final StringBuilder sb=new StringBuilder();
        sb.append(""String_Node_Str"");
        sb.append(clusterManager);
        logger.log(Level.INFO,sb.toString());
      }
    }
  }
,5);
}",0.983657587548638
49987,"public void putAll(final Map<? extends K,? extends V> map){
  List<Future> lsFutures=new ArrayList<Future>(map.size());
  for (  final K key : map.keySet()) {
    final V value=map.get(key);
    lsFutures.add(putAsync(key,value));
  }
  for (  Future future : lsFutures) {
    try {
      future.get();
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
}","public void putAll(final Map<? extends K,? extends V> map){
  Pairs pairs=new Pairs(map.size());
  for (  final K key : map.keySet()) {
    final V value=map.get(key);
    pairs.addKeyValue(new KeyValue(toData(key),toData(value)));
  }
  proxyHelper.doOp(ClusterOperation.CONCURRENT_MAP_PUT_ALL,null,pairs);
}",0.4773060029282577
49988,"@Test public void putAllMany(){
  HazelcastClient hClient=getHazelcastClient();
  IMap map=hClient.getMap(""String_Node_Str"");
  int counter=100;
  for (int j=0; j < 4; j++, counter*=10) {
    Map tempMap=new HashMap();
    for (int i=0; i < counter; i++) {
      tempMap.put(i,i);
    }
    System.out.println(""String_Node_Str"" + tempMap.size() + ""String_Node_Str"");
    map.putAll(tempMap);
    System.out.println(""String_Node_Str"" + tempMap.size());
  }
  map.destroy();
}","@Test public void putAllMany(){
  HazelcastClient hClient=getHazelcastClient();
  IMap map=hClient.getMap(""String_Node_Str"");
  int counter=100;
  for (int j=0; j < 4; j++, counter*=10) {
    Map tempMap=new HashMap();
    for (int i=0; i < counter; i++) {
      tempMap.put(i,i);
    }
    map.putAll(tempMap);
    assertEquals(1,map.get(1));
  }
  map.destroy();
}",0.6976190476190476
49989,"public void run(){
  topic.publish(""String_Node_Str"");
}","public void run(){
  topic.publish(""String_Node_Str"");
  l.countDown();
}",0.8682170542635659
49990,"@Test public void testPerformance(){
  HazelcastClient hClient=getHazelcastClient();
  long begin=System.currentTimeMillis();
  int count=10000;
  final ITopic topic=hClient.getTopic(""String_Node_Str"");
  ExecutorService ex=Executors.newFixedThreadPool(10);
  for (int i=0; i < count; i++) {
    ex.submit(new Runnable(){
      public void run(){
        topic.publish(""String_Node_Str"");
      }
    }
);
  }
  long time=System.currentTimeMillis() - begin;
  System.out.println(""String_Node_Str"" + count * 1000 / time);
}","@Test public void testPerformance() throws InterruptedException {
  HazelcastClient hClient=getHazelcastClient();
  long begin=System.currentTimeMillis();
  int count=10000;
  final ITopic topic=hClient.getTopic(""String_Node_Str"");
  ExecutorService ex=Executors.newFixedThreadPool(10);
  final CountDownLatch l=new CountDownLatch(count);
  for (int i=0; i < count; i++) {
    ex.submit(new Runnable(){
      public void run(){
        topic.publish(""String_Node_Str"");
        l.countDown();
      }
    }
);
  }
  assertTrue(l.await(20,TimeUnit.SECONDS));
  long time=System.currentTimeMillis() - begin;
  System.out.println(""String_Node_Str"" + count * 1000 / time);
}",0.8758389261744967
49991,"public Object get(Object key){
  long now=System.currentTimeMillis();
  if (counter.incrementAndGet() == LOCAL_INVALIDATION_COUNTER) {
    counter.addAndGet(-(LOCAL_INVALIDATION_COUNTER));
    evict(now,false);
  }
  CacheEntry entry=cache.get(key);
  if (entry == null) {
    return null;
  }
 else {
    if (entry.isValid(now)) {
      Object value=entry.getValue();
      cmap.concurrentMapManager.enqueueAndReturn(entry);
      entry.touch(now);
      return value;
    }
 else {
      return null;
    }
  }
}","public Object get(Object key){
  long now=System.currentTimeMillis();
  if (counter.incrementAndGet() == LOCAL_INVALIDATION_COUNTER) {
    counter.addAndGet(-(LOCAL_INVALIDATION_COUNTER));
    evict(now,false);
  }
  CacheEntry entry=cache.get(key);
  if (entry == null) {
    return null;
  }
 else {
    if (entry.isValid(now)) {
      Object value=null;
      if (ThreadContext.get().isClient()) {
        value=entry.getValueData();
      }
 else {
        value=entry.getValue();
      }
      cmap.concurrentMapManager.enqueueAndReturn(entry);
      entry.touch(now);
      return value;
    }
 else {
      return null;
    }
  }
}",0.8784722222222222
49992,"CMap getOrCreateStorageCMap(String queueName){
  QueueConfig config=node.factory.getConfig().getQueueConfig(queueName);
  return node.concurrentMapManager.getOrCreateMap(Prefix.MAP + config.getBackingMapName());
}","CMap getOrCreateStorageCMap(String queueName){
  return node.concurrentMapManager.getOrCreateMap(Prefix.MAP + queueName);
}",0.7083333333333334
49993,"public IMap getStorageMap(String queueName){
  QueueConfig config=node.factory.getConfig().getQueueConfig(queueName);
  return node.factory.getMap(config.getBackingMapName());
}","public IMap getStorageMap(String queueName){
  return node.factory.getMap(queueName);
}",0.6287878787878788
49994,"CMap getStorageCMap(String queueName){
  QueueConfig config=node.factory.getConfig().getQueueConfig(queueName);
  return node.concurrentMapManager.getMap(Prefix.MAP + config.getBackingMapName());
}","CMap getStorageCMap(String queueName){
  return node.concurrentMapManager.getMap(Prefix.MAP + queueName);
}",0.6776315789473685
49995,"BQ(String name){
  this.name=name;
  QueueConfig qConfig=node.getConfig().findMatchingQueueConfig(name.substring(Prefix.QUEUE.length()));
  MapConfig backingMapConfig=node.getConfig().findMatchingMapConfig(qConfig.getBackingMapName());
  int backingMapTTL=backingMapConfig.getTimeToLiveSeconds();
  this.maxSizePerJVM=(qConfig.getMaxSizePerJVM() == 0) ? Integer.MAX_VALUE : qConfig.getMaxSizePerJVM();
  this.ttl=(backingMapTTL == 0) ? Integer.MAX_VALUE : TimeUnit.SECONDS.toMillis(backingMapTTL);
}","BQ(String name){
  this.name=name;
  String shortName=name.substring(Prefix.QUEUE.length());
  QueueConfig qConfig=node.getConfig().findMatchingQueueConfig(shortName);
  MapConfig backingMapConfig=node.getConfig().findMatchingMapConfig(qConfig.getBackingMapName());
  int backingMapTTL=backingMapConfig.getTimeToLiveSeconds();
  this.maxSizePerJVM=(qConfig.getMaxSizePerJVM() == 0) ? Integer.MAX_VALUE : qConfig.getMaxSizePerJVM();
  this.ttl=(backingMapTTL == 0) ? Integer.MAX_VALUE : TimeUnit.SECONDS.toMillis(backingMapTTL);
}",0.8521400778210116
49996,"CMap(ConcurrentMapManager concurrentMapManager,String name){
  this.concurrentMapManager=concurrentMapManager;
  this.logger=concurrentMapManager.node.getLogger(CMap.class.getName());
  this.PARTITION_COUNT=concurrentMapManager.PARTITION_COUNT;
  this.blocks=concurrentMapManager.blocks;
  this.node=concurrentMapManager.node;
  this.thisAddress=concurrentMapManager.thisAddress;
  this.name=name;
  mapForQueue=name.startsWith(""String_Node_Str"");
  instanceType=ConcurrentMapManager.getInstanceType(name);
  MapConfig mapConfig=null;
  String mapConfigName=name.substring(2);
  if (isMultiMap() || mapConfigName.startsWith(""String_Node_Str"") || mapConfigName.startsWith(AS_LIST)|| mapConfigName.startsWith(AS_SET)) {
    mapConfig=new MapConfig();
  }
 else {
    mapConfig=node.getConfig().findMatchingMapConfig(mapConfigName);
  }
  this.mapIndexService=new MapIndexService(mapConfig.isValueIndexed());
  this.backupCount=mapConfig.getBackupCount();
  ttl=mapConfig.getTimeToLiveSeconds() * 1000L;
  evictionDelayMillis=mapConfig.getEvictionDelaySeconds() * 1000L;
  maxIdle=mapConfig.getMaxIdleSeconds() * 1000L;
  evictionPolicy=EvictionPolicy.valueOf(mapConfig.getEvictionPolicy());
  readBackupData=mapConfig.isReadBackupData();
  cacheValue=mapConfig.isCacheValue();
  MaxSizeConfig maxSizeConfig=mapConfig.getMaxSizeConfig();
  if (MaxSizeConfig.POLICY_MAP_SIZE_PER_JVM.equals(maxSizeConfig.getMaxSizePolicy())) {
    maxSizePolicy=new MaxSizePerJVMPolicy(maxSizeConfig);
  }
 else   if (MaxSizeConfig.POLICY_CLUSTER_WIDE_MAP_SIZE.equals(maxSizeConfig.getMaxSizePolicy())) {
    maxSizePolicy=new MaxSizeClusterWidePolicy(maxSizeConfig);
  }
 else   if (MaxSizeConfig.POLICY_PARTITIONS_WIDE_MAP_SIZE.equals(maxSizeConfig.getMaxSizePolicy())) {
    maxSizePolicy=new MaxSizePartitionsWidePolicy(maxSizeConfig);
  }
 else   if (MaxSizeConfig.POLICY_USED_HEAP_SIZE.equals(maxSizeConfig.getMaxSizePolicy())) {
    maxSizePolicy=new MaxSizeHeapPolicy(maxSizeConfig);
  }
 else   if (MaxSizeConfig.POLICY_USED_HEAP_PERCENTAGE.equals(maxSizeConfig.getMaxSizePolicy())) {
    maxSizePolicy=new MaxSizeHeapPercentagePolicy(maxSizeConfig);
  }
 else {
    maxSizePolicy=null;
  }
  if (evictionPolicy == EvictionPolicy.NONE) {
    evictionComparator=null;
  }
 else {
    if (evictionPolicy == EvictionPolicy.LRU) {
      evictionComparator=new ComparatorWrapper(LRU_COMPARATOR);
    }
 else {
      evictionComparator=new ComparatorWrapper(LFU_COMPARATOR);
    }
  }
  evictionRate=mapConfig.getEvictionPercentage() / 100f;
  MapStoreConfig mapStoreConfig=mapConfig.getMapStoreConfig();
  MapStoreWrapper mapStoreWrapper=null;
  int writeDelaySeconds=-1;
  if (!node.isSuperClient() && mapStoreConfig != null && mapStoreConfig.isEnabled()) {
    try {
      Object storeInstance=mapStoreConfig.getImplementation();
      if (storeInstance == null) {
        String mapStoreClassName=mapStoreConfig.getClassName();
        storeInstance=Serializer.classForName(node.getConfig().getClassLoader(),mapStoreClassName).newInstance();
      }
      mapStoreWrapper=new MapStoreWrapper(storeInstance,node.factory.getHazelcastInstanceProxy(),mapStoreConfig.getProperties(),mapConfigName);
    }
 catch (    Exception e) {
      logger.log(Level.SEVERE,e.getMessage(),e);
    }
    writeDelaySeconds=mapStoreConfig.getWriteDelaySeconds();
  }
  writeDelayMillis=(writeDelaySeconds == -1) ? -1L : writeDelaySeconds * 1000L;
  if (writeDelaySeconds > 0) {
    removeDelayMillis=concurrentMapManager.GLOBAL_REMOVE_DELAY_MILLIS + writeDelaySeconds;
  }
 else {
    removeDelayMillis=concurrentMapManager.GLOBAL_REMOVE_DELAY_MILLIS;
  }
  loader=(mapStoreWrapper == null || !mapStoreWrapper.isMapLoader()) ? null : mapStoreWrapper;
  store=(mapStoreWrapper == null || !mapStoreWrapper.isMapStore()) ? null : mapStoreWrapper;
  NearCacheConfig nearCacheConfig=mapConfig.getNearCacheConfig();
  if (nearCacheConfig == null) {
    mapNearCache=null;
  }
 else {
    MapNearCache mapNearCache=new MapNearCache(this,SortedHashMap.getOrderingTypeByName(nearCacheConfig.getEvictionPolicy()),nearCacheConfig.getMaxSize(),nearCacheConfig.getTimeToLiveSeconds() * 1000L,nearCacheConfig.getMaxIdleSeconds() * 1000L,nearCacheConfig.isInvalidateOnChange());
    final MapNearCache anotherMapNearCache=concurrentMapManager.mapCaches.putIfAbsent(name,mapNearCache);
    if (anotherMapNearCache != null) {
      mapNearCache=anotherMapNearCache;
    }
    this.mapNearCache=mapNearCache;
  }
  MergePolicy mergePolicyTemp=null;
  String mergePolicyName=mapConfig.getMergePolicy();
  if (mergePolicyName != null && !""String_Node_Str"".equalsIgnoreCase(mergePolicyName)) {
    MergePolicyConfig mergePolicyConfig=node.getConfig().getMergePolicyConfig(mapConfig.getMergePolicy());
    if (mergePolicyConfig != null) {
      mergePolicyTemp=mergePolicyConfig.getImplementation();
      if (mergePolicyTemp == null) {
        String mergeClassName=mergePolicyConfig.getClassName();
        try {
          mergePolicyTemp=(MergePolicy)Serializer.classForName(node.getConfig().getClassLoader(),mergeClassName).newInstance();
        }
 catch (        Exception e) {
          logger.log(Level.SEVERE,e.getMessage(),e);
        }
      }
    }
  }
  this.mergePolicy=mergePolicyTemp;
  this.creationTime=System.currentTimeMillis();
}","CMap(ConcurrentMapManager concurrentMapManager,String name){
  this.concurrentMapManager=concurrentMapManager;
  this.logger=concurrentMapManager.node.getLogger(CMap.class.getName());
  this.PARTITION_COUNT=concurrentMapManager.PARTITION_COUNT;
  this.blocks=concurrentMapManager.blocks;
  this.node=concurrentMapManager.node;
  this.thisAddress=concurrentMapManager.thisAddress;
  this.name=name;
  mapForQueue=name.startsWith(""String_Node_Str"");
  instanceType=ConcurrentMapManager.getInstanceType(name);
  MapConfig mapConfig=null;
  String mapConfigName=name.substring(2);
  if (isMultiMap() || mapConfigName.startsWith(""String_Node_Str"") || mapConfigName.startsWith(AS_LIST)|| mapConfigName.startsWith(AS_SET)) {
    mapConfig=new MapConfig();
  }
 else   if (mapForQueue) {
    String queueShortName=name.substring(4);
    QueueConfig qConfig=node.getConfig().findMatchingQueueConfig(queueShortName);
    mapConfig=node.getConfig().findMatchingMapConfig(qConfig.getBackingMapName());
  }
 else {
    mapConfig=node.getConfig().findMatchingMapConfig(mapConfigName);
  }
  this.mapIndexService=new MapIndexService(mapConfig.isValueIndexed());
  this.backupCount=mapConfig.getBackupCount();
  ttl=mapConfig.getTimeToLiveSeconds() * 1000L;
  evictionDelayMillis=mapConfig.getEvictionDelaySeconds() * 1000L;
  maxIdle=mapConfig.getMaxIdleSeconds() * 1000L;
  evictionPolicy=EvictionPolicy.valueOf(mapConfig.getEvictionPolicy());
  readBackupData=mapConfig.isReadBackupData();
  cacheValue=mapConfig.isCacheValue();
  MaxSizeConfig maxSizeConfig=mapConfig.getMaxSizeConfig();
  if (MaxSizeConfig.POLICY_MAP_SIZE_PER_JVM.equals(maxSizeConfig.getMaxSizePolicy())) {
    maxSizePolicy=new MaxSizePerJVMPolicy(maxSizeConfig);
  }
 else   if (MaxSizeConfig.POLICY_CLUSTER_WIDE_MAP_SIZE.equals(maxSizeConfig.getMaxSizePolicy())) {
    maxSizePolicy=new MaxSizeClusterWidePolicy(maxSizeConfig);
  }
 else   if (MaxSizeConfig.POLICY_PARTITIONS_WIDE_MAP_SIZE.equals(maxSizeConfig.getMaxSizePolicy())) {
    maxSizePolicy=new MaxSizePartitionsWidePolicy(maxSizeConfig);
  }
 else   if (MaxSizeConfig.POLICY_USED_HEAP_SIZE.equals(maxSizeConfig.getMaxSizePolicy())) {
    maxSizePolicy=new MaxSizeHeapPolicy(maxSizeConfig);
  }
 else   if (MaxSizeConfig.POLICY_USED_HEAP_PERCENTAGE.equals(maxSizeConfig.getMaxSizePolicy())) {
    maxSizePolicy=new MaxSizeHeapPercentagePolicy(maxSizeConfig);
  }
 else {
    maxSizePolicy=null;
  }
  if (evictionPolicy == EvictionPolicy.NONE) {
    evictionComparator=null;
  }
 else {
    if (evictionPolicy == EvictionPolicy.LRU) {
      evictionComparator=new ComparatorWrapper(LRU_COMPARATOR);
    }
 else {
      evictionComparator=new ComparatorWrapper(LFU_COMPARATOR);
    }
  }
  evictionRate=mapConfig.getEvictionPercentage() / 100f;
  MapStoreConfig mapStoreConfig=mapConfig.getMapStoreConfig();
  MapStoreWrapper mapStoreWrapper=null;
  int writeDelaySeconds=-1;
  if (!node.isSuperClient() && mapStoreConfig != null && mapStoreConfig.isEnabled()) {
    try {
      Object storeInstance=mapStoreConfig.getImplementation();
      if (storeInstance == null) {
        String mapStoreClassName=mapStoreConfig.getClassName();
        storeInstance=Serializer.classForName(node.getConfig().getClassLoader(),mapStoreClassName).newInstance();
      }
      mapStoreWrapper=new MapStoreWrapper(storeInstance,node.factory.getHazelcastInstanceProxy(),mapStoreConfig.getProperties(),mapConfigName);
      if (!mapStoreWrapper.isMapLoader() && !mapStoreWrapper.isMapStore()) {
        throw new Exception(""String_Node_Str"" + storeInstance.getClass().getName() + ""String_Node_Str"");
      }
    }
 catch (    Exception e) {
      logger.log(Level.SEVERE,e.getMessage(),e);
    }
    writeDelaySeconds=mapStoreConfig.getWriteDelaySeconds();
  }
  writeDelayMillis=(writeDelaySeconds == -1) ? -1L : writeDelaySeconds * 1000L;
  if (writeDelaySeconds > 0) {
    removeDelayMillis=concurrentMapManager.GLOBAL_REMOVE_DELAY_MILLIS + writeDelaySeconds;
  }
 else {
    removeDelayMillis=concurrentMapManager.GLOBAL_REMOVE_DELAY_MILLIS;
  }
  loader=(mapStoreWrapper == null || !mapStoreWrapper.isMapLoader()) ? null : mapStoreWrapper;
  store=(mapStoreWrapper == null || !mapStoreWrapper.isMapStore()) ? null : mapStoreWrapper;
  NearCacheConfig nearCacheConfig=mapConfig.getNearCacheConfig();
  if (nearCacheConfig == null) {
    mapNearCache=null;
  }
 else {
    MapNearCache mapNearCache=new MapNearCache(this,SortedHashMap.getOrderingTypeByName(nearCacheConfig.getEvictionPolicy()),nearCacheConfig.getMaxSize(),nearCacheConfig.getTimeToLiveSeconds() * 1000L,nearCacheConfig.getMaxIdleSeconds() * 1000L,nearCacheConfig.isInvalidateOnChange());
    final MapNearCache anotherMapNearCache=concurrentMapManager.mapCaches.putIfAbsent(name,mapNearCache);
    if (anotherMapNearCache != null) {
      mapNearCache=anotherMapNearCache;
    }
    this.mapNearCache=mapNearCache;
  }
  MergePolicy mergePolicyTemp=null;
  String mergePolicyName=mapConfig.getMergePolicy();
  if (mergePolicyName != null && !""String_Node_Str"".equalsIgnoreCase(mergePolicyName)) {
    MergePolicyConfig mergePolicyConfig=node.getConfig().getMergePolicyConfig(mapConfig.getMergePolicy());
    if (mergePolicyConfig != null) {
      mergePolicyTemp=mergePolicyConfig.getImplementation();
      if (mergePolicyTemp == null) {
        String mergeClassName=mergePolicyConfig.getClassName();
        try {
          mergePolicyTemp=(MergePolicy)Serializer.classForName(node.getConfig().getClassLoader(),mergeClassName).newInstance();
        }
 catch (        Exception e) {
          logger.log(Level.SEVERE,e.getMessage(),e);
        }
      }
    }
  }
  this.mergePolicy=mergePolicyTemp;
  this.creationTime=System.currentTimeMillis();
}",0.9608857428078772
49997,"/** 
 * executorThread
 */
public void execute(Request request){
  CMap cmap=maps.get(request.name);
  if (request.operation == CONCURRENT_MAP_GET) {
    Object value=cmap.loader.load(toObject(request.key));
    if (value != null) {
      setIndexValues(request,value);
      request.value=toData(value);
    }
  }
 else   if (request.operation == CONCURRENT_MAP_PUT || request.operation == CONCURRENT_MAP_PUT_IF_ABSENT) {
    Object value=toObject(request.value);
    cmap.store.store(toObject(request.key),value);
    Record storedRecord=cmap.getRecord(request);
    storedRecord.setLastStoredTime(System.currentTimeMillis());
  }
 else   if (request.operation == CONCURRENT_MAP_REMOVE) {
    Object key=toObject(request.key);
    if (cmap.loader != null && request.value == null) {
      Object removedObject=cmap.loader.load(key);
      if (removedObject == null) {
        return;
      }
 else {
        request.response=toData(removedObject);
      }
    }
    cmap.store.delete(key);
  }
 else   if (request.operation == CONCURRENT_MAP_EVICT) {
    cmap.store.store(toObject(request.key),toObject(request.value));
    Record storedRecord=cmap.getRecord(request);
    storedRecord.setLastStoredTime(System.currentTimeMillis());
    request.response=Boolean.TRUE;
  }
 else   if (request.operation == CONCURRENT_MAP_MERGE) {
    boolean success=false;
    Object winner=null;
    if (cmap.mergePolicy != null) {
      Record existingRecord=cmap.getRecord(request);
      DataRecordEntry existing=(existingRecord == null) ? null : new DataRecordEntry(existingRecord);
      DataRecordEntry newEntry=(DataRecordEntry)toObject(request.value);
      Object key=newEntry.getKey();
      if (key != null && newEntry.hasValue()) {
        winner=cmap.mergePolicy.merge(cmap.getName(),newEntry,existing);
        if (winner != null) {
          success=true;
          if (cmap.writeDelayMillis == 0 && cmap.store != null) {
            Object winnerObject=(winner instanceof Data) ? toObject((Data)winner) : winner;
            cmap.store.store(key,winnerObject);
            existingRecord.setLastStoredTime(System.currentTimeMillis());
            success=(request.response == null);
          }
        }
      }
    }
    if (success) {
      request.value=toData(winner);
      request.response=Boolean.TRUE;
    }
 else {
      request.value=null;
      request.response=Boolean.FALSE;
    }
  }
}","/** 
 * executorThread
 */
public void execute(Request request){
  CMap cmap=maps.get(request.name);
  if (request.operation == CONCURRENT_MAP_GET) {
    Object value=cmap.loader.load(toObject(request.key));
    if (value != null) {
      setIndexValues(request,value);
      request.value=toData(value);
    }
  }
 else   if (request.operation == CONCURRENT_MAP_PUT || request.operation == CONCURRENT_MAP_PUT_IF_ABSENT) {
    Object value=toObject(request.value);
    cmap.store.store(toObject(request.key),value);
    Record storedRecord=cmap.getRecord(request);
    if (storedRecord != null) {
      storedRecord.setLastStoredTime(System.currentTimeMillis());
    }
  }
 else   if (request.operation == CONCURRENT_MAP_REMOVE) {
    Object key=toObject(request.key);
    if (cmap.loader != null && request.value == null) {
      Object removedObject=cmap.loader.load(key);
      if (removedObject == null) {
        return;
      }
 else {
        request.response=toData(removedObject);
      }
    }
    cmap.store.delete(key);
  }
 else   if (request.operation == CONCURRENT_MAP_EVICT) {
    cmap.store.store(toObject(request.key),toObject(request.value));
    Record storedRecord=cmap.getRecord(request);
    storedRecord.setLastStoredTime(System.currentTimeMillis());
    request.response=Boolean.TRUE;
  }
 else   if (request.operation == CONCURRENT_MAP_MERGE) {
    boolean success=false;
    Object winner=null;
    if (cmap.mergePolicy != null) {
      Record existingRecord=cmap.getRecord(request);
      DataRecordEntry existing=(existingRecord == null) ? null : new DataRecordEntry(existingRecord);
      DataRecordEntry newEntry=(DataRecordEntry)toObject(request.value);
      Object key=newEntry.getKey();
      if (key != null && newEntry.hasValue()) {
        winner=cmap.mergePolicy.merge(cmap.getName(),newEntry,existing);
        if (winner != null) {
          success=true;
          if (cmap.writeDelayMillis == 0 && cmap.store != null) {
            Object winnerObject=(winner instanceof Data) ? toObject((Data)winner) : winner;
            cmap.store.store(key,winnerObject);
            existingRecord.setLastStoredTime(System.currentTimeMillis());
            success=(request.response == null);
          }
        }
      }
    }
    if (success) {
      request.value=toData(winner);
      request.response=Boolean.TRUE;
    }
 else {
      request.value=null;
      request.response=Boolean.FALSE;
    }
  }
}",0.9917423616845582
49998,"private void loadKeys(MProxy mProxy,CMap cmap,Set keys){
  if (keys.size() > 0) {
    Map map=cmap.loader.loadAll(keys);
    Set<Map.Entry> entries=map.entrySet();
    for (    Map.Entry entry : entries) {
      mProxy.putTransient(entry.getKey(),entry.getValue(),0,null);
    }
  }
}","private void loadKeys(MProxy mProxy,CMap cmap,Set keys){
  if (keys.size() > 0) {
    Map map=cmap.loader.loadAll(keys);
    if (map != null && map.size() > 0) {
      Set<Map.Entry> entries=map.entrySet();
      for (      Map.Entry entry : entries) {
        mProxy.putTransient(entry.getKey(),entry.getValue(),0,null);
      }
    }
  }
}",0.9088
49999,"private void checkInitialization(Object proxy){
  if (proxy instanceof MProxy) {
    MProxy mProxy=(MProxy)proxy;
    CMap cmap=node.concurrentMapManager.getMap(mProxy.getLongName());
    if (!cmap.isMapForQueue() && !cmap.initialized) {
synchronized (cmap.getInitLock()) {
        if (!cmap.initialized) {
          if (cmap.loader != null) {
            if (getAtomicNumber(name).compareAndSet(0,1)) {
              ExecutorService es=getExecutorService();
              MultiTask task=new MultiTask(new InitializeMap(mProxy.getName()),getCluster().getMembers());
              es.execute(task);
            }
            Set keys=cmap.loader.loadAllKeys();
            if (keys != null) {
              int count=0;
              PartitionService partitionService=getPartitionService();
              Set ownedKeys=new HashSet();
              for (              Object key : keys) {
                if (partitionService.getPartition(key).getOwner().localMember()) {
                  ownedKeys.add(key);
                  count++;
                  if (ownedKeys.size() >= node.groupProperties.MAP_LOAD_CHUNK_SIZE.getInteger()) {
                    loadKeys(mProxy,cmap,ownedKeys);
                    ownedKeys.clear();
                  }
                }
              }
              loadKeys(mProxy,cmap,ownedKeys);
              logger.log(Level.INFO,node.address + ""String_Node_Str"" + mProxy.getName()+ ""String_Node_Str""+ count);
            }
          }
        }
        cmap.initialized=true;
      }
    }
  }
}","private void checkInitialization(Object proxy){
  if (proxy instanceof MProxy) {
    MProxy mProxy=(MProxy)proxy;
    CMap cmap=node.concurrentMapManager.getMap(mProxy.getLongName());
    if (!cmap.isMapForQueue() && !cmap.initialized) {
synchronized (cmap.getInitLock()) {
        if (!cmap.initialized) {
          if (cmap.loader != null) {
            try {
              if (getAtomicNumber(name).compareAndSet(0,1)) {
                ExecutorService es=getExecutorService();
                MultiTask task=new MultiTask(new InitializeMap(mProxy.getName()),getCluster().getMembers());
                es.execute(task);
              }
              Set keys=cmap.loader.loadAllKeys();
              if (keys != null) {
                int count=0;
                PartitionService partitionService=getPartitionService();
                Set ownedKeys=new HashSet();
                for (                Object key : keys) {
                  if (partitionService.getPartition(key).getOwner().localMember()) {
                    ownedKeys.add(key);
                    count++;
                    if (ownedKeys.size() >= node.groupProperties.MAP_LOAD_CHUNK_SIZE.getInteger()) {
                      loadKeys(mProxy,cmap,ownedKeys);
                      ownedKeys.clear();
                    }
                  }
                }
                loadKeys(mProxy,cmap,ownedKeys);
                logger.log(Level.INFO,node.address + ""String_Node_Str"" + mProxy.getName()+ ""String_Node_Str""+ count);
              }
            }
 catch (            Throwable e) {
              logger.log(Level.SEVERE,e.getMessage(),e);
            }
          }
        }
        cmap.initialized=true;
      }
    }
  }
}",0.942663378545006
50000,"void checkInit(){
  if (!initialized && shouldInitialize) {
synchronized (initLock) {
      if (!initialized) {
        ((MapLoaderLifecycleSupport)impl).init(hazelcastInstance,properties,mapName);
        initialized=true;
      }
    }
  }
}","void checkInit(){
  if (shouldInitialize && !initialized) {
synchronized (initLock) {
      if (!initialized) {
        ((MapLoaderLifecycleSupport)impl).init(hazelcastInstance,properties,mapName);
        initialized=true;
      }
    }
  }
}",0.8847736625514403
