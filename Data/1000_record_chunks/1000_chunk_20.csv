record_number,buggy_code,fixed_code,code_similarity
19001,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setDrawYValues(false);
  mChart.setLineWidth(4f);
  mChart.setCircleSize(4f);
  mChart.setYLegendCount(6);
  mChart.setTouchEnabled(true);
  mChart.setHighlightEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setTouchEnabled(true);
  TextView textView=new TextView(this);
  textView.setVisibility(View.VISIBLE);
  textView.setBackgroundColor(Color.WHITE);
  textView.setPadding(15,15,15,15);
  textView.setText(""String_Node_Str"");
  mChart.setDrawMarkerView(true);
  mChart.setMarkerView(textView);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setColorTemplate(new ColorTemplate(ColorTemplate.getColors(this,ColorTemplate.JOYFUL_COLORS)));
  mChart.setDrawTopYLegendEntry(false);
  mChart.setDrawYValues(false);
  mChart.setLineWidth(5f);
  mChart.setCircleSize(5f);
  mChart.setYLegendCount(6);
  mChart.setTouchEnabled(true);
  mChart.setHighlightEnabled(true);
  mChart.setDragEnabled(true);
  mChart.setTouchEnabled(true);
  TextView textView=new TextView(this);
  textView.setVisibility(View.VISIBLE);
  textView.setBackgroundColor(Color.WHITE);
  textView.setPadding(15,15,15,15);
  textView.setText(""String_Node_Str"");
  mChart.setDrawMarkerView(true);
  mChart.setMarkerView(textView);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
}",0.9345262301748678
19002,"/** 
 * draws the circle value indicators
 */
@Override protected void drawAdditional(){
  if (mDrawCircles) {
    ArrayList<DataSet> dataSets=mData.getDataSets();
    for (int i=0; i < mData.getDataSetCount(); i++) {
      DataSet dataSet=dataSets.get(i);
      ArrayList<Series> series=dataSet.getYVals();
      float[] positions=new float[dataSet.getYValCount() * 2];
      for (int j=0; j < positions.length; j+=2) {
        positions[j]=series.get(j / 2).getXIndex();
        positions[j + 1]=series.get(j / 2).getVal();
      }
      transformPointArray(positions);
      for (int j=0; j < positions.length; j+=2) {
        if (positions[j] < mContentRect.left || positions[j] > mContentRect.right)         continue;
        mDrawCanvas.drawCircle(positions[j],positions[j + 1],mCircleSize,mCirclePaintOuter);
        mDrawCanvas.drawCircle(positions[j],positions[j + 1],mCircleSize / 2,mCirclePaintInner);
      }
    }
  }
}","/** 
 * draws the circle value indicators
 */
@Override protected void drawAdditional(){
  if (mDrawCircles) {
    ArrayList<DataSet> dataSets=mData.getDataSets();
    for (int i=0; i < mData.getDataSetCount(); i++) {
      DataSet dataSet=dataSets.get(i);
      ArrayList<Series> series=dataSet.getYVals();
      float[] positions=new float[dataSet.getYValCount() * 2];
      for (int j=0; j < positions.length; j+=2) {
        positions[j]=series.get(j / 2).getXIndex();
        positions[j + 1]=series.get(j / 2).getVal();
      }
      transformPointArray(positions);
      for (int j=0; j < positions.length; j+=2) {
        if (positions[j] < mContentRect.left || positions[j] > mContentRect.right)         continue;
        mDrawCanvas.drawCircle(positions[j],positions[j + 1],mCircleSize,mDrawPaints[i % mDrawPaints.length]);
        mDrawCanvas.drawCircle(positions[j],positions[j + 1],mCircleSize / 2,mCirclePaintInner);
      }
    }
  }
}",0.9787460148777896
19003,"@Override protected void prepareDataPaints(ColorTemplate ct){
  if (ct == null)   return;
  mDrawPaints=new Paint[ct.getColors().size()];
  for (int i=0; i < ct.getColors().size(); i++) {
    mDrawPaints[i]=new Paint(Paint.ANTI_ALIAS_FLAG);
    mDrawPaints[i].setStrokeWidth(mLineWidth);
    mDrawPaints[i].setStyle(Style.STROKE);
    mDrawPaints[i].setColor(ct.getColors().get(i));
  }
}","@Override protected void prepareDataPaints(ColorTemplate ct){
  if (ct == null)   return;
  mDrawPaints=new Paint[ct.getColors().size()];
  for (int i=0; i < ct.getColors().size(); i++) {
    mDrawPaints[i]=new Paint(Paint.ANTI_ALIAS_FLAG);
    mDrawPaints[i].setStrokeWidth(mLineWidth);
    mDrawPaints[i].setStyle(Style.FILL);
    mDrawPaints[i].setColor(ct.getColors().get(i));
  }
}",0.9870801033591732
19004,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setColorTemplate(new ColorTemplate(ColorTemplate.getColors(this,ColorTemplate.FRESH_COLORS)));
  mChart.setDrawValues(false);
  mChart.set3DEnabled(false);
  mChart.setDrawAdditional(true);
  mChart.setYLegendCount(5);
  mChart.setTouchEnabled(true);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_barchart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(BarChart)findViewById(R.id.chart1);
  mChart.setColorTemplate(new ColorTemplate(ColorTemplate.getColors(this,ColorTemplate.FRESH_COLORS)));
  mChart.setDrawValues(false);
  mChart.set3DEnabled(false);
  mChart.setYLegendCount(5);
  mChart.setTouchEnabled(true);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
}",0.9807692307692308
19005,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setDrawValues(false);
  mChart.setLineWidth(5f);
  mChart.setCircleSize(5f);
  mChart.setDrawAdditional(true);
  mChart.setYLegendCount(6);
  mChart.setTouchEnabled(true);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  setContentView(R.layout.activity_linechart);
  tvX=(TextView)findViewById(R.id.tvXMax);
  tvY=(TextView)findViewById(R.id.tvYMax);
  mSeekBarX=(SeekBar)findViewById(R.id.seekBar1);
  mSeekBarX.setOnSeekBarChangeListener(this);
  mSeekBarY=(SeekBar)findViewById(R.id.seekBar2);
  mSeekBarY.setOnSeekBarChangeListener(this);
  mChart=(LineChart)findViewById(R.id.chart1);
  mChart.setDrawValues(false);
  mChart.setLineWidth(5f);
  mChart.setCircleSize(5f);
  mChart.setYLegendCount(6);
  mChart.setTouchEnabled(true);
  mSeekBarX.setProgress(45);
  mSeekBarY.setProgress(100);
}",0.9789343246592316
19006,"@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.actionToggleRound:
{
      if (mChart.isYLegendRounded())       mChart.setRoundedYLegend(false);
 else       mChart.setRoundedYLegend(true);
      mChart.invalidate();
      break;
    }
case R.id.actionToggleValues:
{
    if (mChart.isDrawValuesEnabled())     mChart.setDrawValues(false);
 else     mChart.setDrawValues(true);
    mChart.invalidate();
    break;
  }
case R.id.actionToggleFilled:
{
  if (mChart.isDrawFilledEnabled())   mChart.setDrawFilled(false);
 else   mChart.setDrawFilled(true);
  mChart.invalidate();
  break;
}
case R.id.actionToggleCircles:
{
if (mChart.isDrawAdditionalEnabled()) mChart.setDrawAdditional(false);
 else mChart.setDrawAdditional(true);
mChart.invalidate();
break;
}
case R.id.actionToggleStartzero:
{
if (mChart.isStartAtZeroEnabled()) mChart.setStartAtZero(false);
 else mChart.setStartAtZero(true);
mChart.invalidate();
break;
}
case R.id.actionToggleAdjustXLegend:
{
if (mChart.isAdjustXLegendEnabled()) mChart.setAdjustXLegend(false);
 else mChart.setAdjustXLegend(true);
mChart.invalidate();
break;
}
case R.id.actionSave:
{
mChart.saveToPath(""String_Node_Str"" + System.currentTimeMillis(),""String_Node_Str"");
break;
}
}
return true;
}","@Override public boolean onOptionsItemSelected(MenuItem item){
switch (item.getItemId()) {
case R.id.actionToggleRound:
{
      if (mChart.isYLegendRounded())       mChart.setRoundedYLegend(false);
 else       mChart.setRoundedYLegend(true);
      mChart.invalidate();
      break;
    }
case R.id.actionToggleValues:
{
    if (mChart.isDrawValuesEnabled())     mChart.setDrawValues(false);
 else     mChart.setDrawValues(true);
    mChart.invalidate();
    break;
  }
case R.id.actionToggleFilled:
{
  if (mChart.isDrawFilledEnabled())   mChart.setDrawFilled(false);
 else   mChart.setDrawFilled(true);
  mChart.invalidate();
  break;
}
case R.id.actionToggleCircles:
{
if (mChart.isDrawCirclesEnabled()) mChart.setDrawCircles(false);
 else mChart.setDrawCircles(true);
mChart.invalidate();
break;
}
case R.id.actionToggleStartzero:
{
if (mChart.isStartAtZeroEnabled()) mChart.setStartAtZero(false);
 else mChart.setStartAtZero(true);
mChart.invalidate();
break;
}
case R.id.actionToggleAdjustXLegend:
{
if (mChart.isAdjustXLegendEnabled()) mChart.setAdjustXLegend(false);
 else mChart.setAdjustXLegend(true);
mChart.invalidate();
break;
}
case R.id.actionSave:
{
mChart.saveToPath(""String_Node_Str"" + System.currentTimeMillis(),""String_Node_Str"");
break;
}
}
return true;
}",0.9800703399765534
19007,"/** 
 * draws the circle value indicators
 */
@Override protected void drawAdditional(){
  if (!mDrawAdditional)   return;
  if (mDrawCircles) {
    float[] positions=new float[mYVals.size() * 2];
    for (int i=0; i < positions.length; i+=2) {
      positions[i]=i / 2;
      positions[i + 1]=mYVals.get(i / 2);
    }
    transformPointArray(positions);
    for (int i=0; i < positions.length; i+=2) {
      mDrawCanvas.drawCircle(positions[i],positions[i + 1],mCircleSize,mCirclePaintOuter);
      mDrawCanvas.drawCircle(positions[i],positions[i + 1],mCircleSize / 2,mCirclePaintInner);
    }
  }
}","/** 
 * draws the circle value indicators
 */
@Override protected void drawAdditional(){
  if (mDrawCircles) {
    float[] positions=new float[mYVals.size() * 2];
    for (int i=0; i < positions.length; i+=2) {
      positions[i]=i / 2;
      positions[i + 1]=mYVals.get(i / 2);
    }
    transformPointArray(positions);
    for (int i=0; i < positions.length; i+=2) {
      mDrawCanvas.drawCircle(positions[i],positions[i + 1],mCircleSize,mCirclePaintOuter);
      mDrawCanvas.drawCircle(positions[i],positions[i + 1],mCircleSize / 2,mCirclePaintInner);
    }
  }
}",0.9708404802744426
19008,"@Override public void onFiltersChanged(TagFilterHolder filters){
  CharSequence filtersDesc=filters.describeFilters(getResources(),getContext().getTheme());
  mFiltersDescription.setText(filtersDesc);
  if (filters.hasAnyFilters()) {
    mFiltersBar.setVisibility(VISIBLE);
    mContent.setTranslationY(mFiltersBar.getHeight());
  }
 else {
    mFiltersBar.setVisibility(INVISIBLE);
    mContent.setTranslationY(0f);
  }
}","@Override public void onFiltersChanged(TagFilterHolder filters){
  CharSequence filtersDesc=filters.describeFilters(getResources(),getContext().getTheme());
  mFiltersDescription.setText(filtersDesc);
  if (filters.hasAnyFilters()) {
    mFiltersBar.setVisibility(VISIBLE);
    mContent.setTranslationY(mFiltersBar.getHeight());
    offsetFilters(mFiltersBar.getHeight(),0);
  }
 else {
    mFiltersBar.setVisibility(INVISIBLE);
    offsetFilters(mFiltersBar.getHeight(),0);
    mContent.setTranslationY(0f);
  }
}",0.9017094017094016
19009,"@Override public void onViewCreated(final View view,@Nullable final Bundle savedInstanceState){
  super.onViewCreated(view,savedInstanceState);
  String[] singleDayFragmentsTags=null;
  int currentSingleDayFragment=0;
  if (savedInstanceState != null) {
    if (savedInstanceState.containsKey(SINGLE_DAY_FRAGMENTS_TAGS)) {
      singleDayFragmentsTags=savedInstanceState.getStringArray(SINGLE_DAY_FRAGMENTS_TAGS);
    }
    if (savedInstanceState.containsKey(CURRENT_SINGLE_DAY_FRAGMENT_POSITION)) {
      currentSingleDayFragment=savedInstanceState.getInt(CURRENT_SINGLE_DAY_FRAGMENT_POSITION);
    }
  }
  mContent=view.findViewById(R.id.swipe_refresh_layout);
  mViewPager=(ViewPager)view.findViewById(R.id.view_pager);
  mViewPagerAdapter=new ScheduleDayViewPagerAdapter(getContext(),getChildFragmentManager(),ScheduleModel.showPreConferenceData(getContext()));
  mViewPagerAdapter.setRetainedFragmentsTags(singleDayFragmentsTags);
  mViewPager.setAdapter(mViewPagerAdapter);
  mViewPager.setCurrentItem(currentSingleDayFragment);
  mTabLayout=(TabLayout)view.findViewById(R.id.sliding_tabs);
  mTabLayout.setupWithViewPager(mViewPager);
  mTabLayout.addOnTabSelectedListener(new TabLayout.OnTabSelectedListener(){
    @Override public void onTabSelected(    final TabLayout.Tab tab){
    }
    @Override public void onTabUnselected(    final TabLayout.Tab tab){
    }
    @Override public void onTabReselected(    final TabLayout.Tab tab){
      mViewPagerAdapter.getFragments()[tab.getPosition()].resetListPosition();
    }
  }
);
  mViewPager.setPageMargin(getResources().getDimensionPixelSize(R.dimen.my_schedule_page_margin));
  mViewPager.setPageMarginDrawable(R.drawable.page_margin);
  mViewPager.setOffscreenPageLimit(3);
  mAppBar=(AppBarLayout)view.findViewById(R.id.appbar);
  mFiltersBar=view.findViewById(R.id.filters_bar);
  mFiltersDescription=(TextView)mFiltersBar.findViewById(R.id.filters_description);
  mFiltersDescription.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      Activity activity=getActivity();
      if (activity instanceof ScheduleViewParent) {
        ((ScheduleViewParent)activity).openFilterDrawer();
      }
    }
  }
);
  mClearFilters=mFiltersBar.findViewById(R.id.clear_filters);
  mClearFilters.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      Activity activity=getActivity();
      if (activity instanceof ScheduleViewParent) {
        ((ScheduleViewParent)activity).onRequestClearFilters();
      }
    }
  }
);
  calculateCurrentDay();
  if (mViewPager != null) {
    scrollToConferenceDay(mToday);
  }
  View header=view.findViewById(R.id.header_anim);
  if (header instanceof ImageView) {
    AnimatedVectorDrawable avd=(AnimatedVectorDrawable)ContextCompat.getDrawable(getContext(),R.drawable.avd_header_schedule);
    ((ImageView)header).setImageDrawable(avd);
    avd.start();
  }
  final AppBarCollapsedListener appBarCollapsedListener=new AppBarCollapsedListener();
  mAppBar.addOnOffsetChangedListener(appBarCollapsedListener);
  ((CoordinatorLayout.LayoutParams)mContent.getLayoutParams()).setBehavior(new AppBarLayout.ScrollingViewBehavior(){
    @Override public boolean onStartNestedScroll(    CoordinatorLayout coordinatorLayout,    View child,    View directTargetChild,    View target,    int nestedScrollAxes){
      return (nestedScrollAxes & View.SCROLL_AXIS_VERTICAL) != 0 && mFiltersBar.getVisibility() == VISIBLE;
    }
    @Override public void onNestedScroll(    CoordinatorLayout coordinatorLayout,    View child,    View target,    int dxConsumed,    int dyConsumed,    int dxUnconsumed,    int dyUnconsumed){
      float filtersOffset=mFiltersBar.getTranslationY();
      int filtersHeight=mFiltersBar.getHeight();
      if (dyConsumed > 0 && appBarCollapsedListener.isCollapsed() && filtersOffset > -filtersHeight) {
        int offset=(int)Math.max(filtersOffset - dyConsumed,-filtersHeight);
        offsetFilters(filtersHeight,offset);
      }
 else       if (dyConsumed < 0 && filtersOffset < 0f) {
        int offset=(int)Math.min(filtersOffset - dyConsumed,0f);
        offsetFilters(filtersHeight,offset);
      }
    }
    private void offsetFilters(    int filtersHeight,    int offset){
      mFiltersBar.setTranslationY(offset);
      mFiltersBarClip.set(0,-offset,mFiltersBar.getWidth(),filtersHeight);
      mFiltersBar.setClipBounds(mFiltersBarClip);
      mContent.setTranslationY(filtersHeight + offset);
    }
  }
);
  AnalyticsHelper.sendScreenView(""String_Node_Str"" + mToday,getActivity());
}","@Override public void onViewCreated(final View view,@Nullable final Bundle savedInstanceState){
  super.onViewCreated(view,savedInstanceState);
  String[] singleDayFragmentsTags=null;
  int currentSingleDayFragment=0;
  if (savedInstanceState != null) {
    if (savedInstanceState.containsKey(SINGLE_DAY_FRAGMENTS_TAGS)) {
      singleDayFragmentsTags=savedInstanceState.getStringArray(SINGLE_DAY_FRAGMENTS_TAGS);
    }
    if (savedInstanceState.containsKey(CURRENT_SINGLE_DAY_FRAGMENT_POSITION)) {
      currentSingleDayFragment=savedInstanceState.getInt(CURRENT_SINGLE_DAY_FRAGMENT_POSITION);
    }
  }
  mContent=view.findViewById(R.id.swipe_refresh_layout);
  mViewPager=(ViewPager)view.findViewById(R.id.view_pager);
  mViewPagerAdapter=new ScheduleDayViewPagerAdapter(getContext(),getChildFragmentManager(),ScheduleModel.showPreConferenceData(getContext()));
  mViewPagerAdapter.setRetainedFragmentsTags(singleDayFragmentsTags);
  mViewPager.setAdapter(mViewPagerAdapter);
  mViewPager.setCurrentItem(currentSingleDayFragment);
  mTabLayout=(TabLayout)view.findViewById(R.id.sliding_tabs);
  mTabLayout.setupWithViewPager(mViewPager);
  mTabLayout.addOnTabSelectedListener(new TabLayout.OnTabSelectedListener(){
    @Override public void onTabSelected(    final TabLayout.Tab tab){
    }
    @Override public void onTabUnselected(    final TabLayout.Tab tab){
    }
    @Override public void onTabReselected(    final TabLayout.Tab tab){
      mViewPagerAdapter.getFragments()[tab.getPosition()].resetListPosition();
    }
  }
);
  mViewPager.setPageMargin(getResources().getDimensionPixelSize(R.dimen.my_schedule_page_margin));
  mViewPager.setPageMarginDrawable(R.drawable.page_margin);
  mViewPager.setOffscreenPageLimit(3);
  mAppBar=(AppBarLayout)view.findViewById(R.id.appbar);
  mFiltersBar=view.findViewById(R.id.filters_bar);
  mFiltersDescription=(TextView)mFiltersBar.findViewById(R.id.filters_description);
  mFiltersDescription.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      Activity activity=getActivity();
      if (activity instanceof ScheduleViewParent) {
        ((ScheduleViewParent)activity).openFilterDrawer();
      }
    }
  }
);
  mClearFilters=mFiltersBar.findViewById(R.id.clear_filters);
  mClearFilters.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      Activity activity=getActivity();
      if (activity instanceof ScheduleViewParent) {
        ((ScheduleViewParent)activity).onRequestClearFilters();
      }
    }
  }
);
  calculateCurrentDay();
  if (mViewPager != null) {
    scrollToConferenceDay(mToday);
  }
  View header=view.findViewById(R.id.header_anim);
  if (header instanceof ImageView) {
    AnimatedVectorDrawable avd=(AnimatedVectorDrawable)ContextCompat.getDrawable(getContext(),R.drawable.avd_header_schedule);
    ((ImageView)header).setImageDrawable(avd);
    avd.start();
  }
  final AppBarCollapsedListener appBarCollapsedListener=new AppBarCollapsedListener();
  mAppBar.addOnOffsetChangedListener(appBarCollapsedListener);
  ((CoordinatorLayout.LayoutParams)mContent.getLayoutParams()).setBehavior(new AppBarLayout.ScrollingViewBehavior(){
    @Override public boolean onStartNestedScroll(    CoordinatorLayout coordinatorLayout,    View child,    View directTargetChild,    View target,    int nestedScrollAxes){
      return (nestedScrollAxes & View.SCROLL_AXIS_VERTICAL) != 0 && mFiltersBar.getVisibility() == VISIBLE;
    }
    @Override public void onNestedScroll(    CoordinatorLayout coordinatorLayout,    View child,    View target,    int dxConsumed,    int dyConsumed,    int dxUnconsumed,    int dyUnconsumed){
      float filtersOffset=mFiltersBar.getTranslationY();
      int filtersHeight=mFiltersBar.getHeight();
      if (dyConsumed > 0 && appBarCollapsedListener.isCollapsed() && filtersOffset > -filtersHeight) {
        int offset=(int)Math.max(filtersOffset - dyConsumed,-filtersHeight);
        offsetFilters(filtersHeight,offset);
      }
 else       if (dyConsumed < 0 && filtersOffset < 0f) {
        int offset=(int)Math.min(filtersOffset - dyConsumed,0f);
        offsetFilters(filtersHeight,offset);
      }
    }
  }
);
  AnalyticsHelper.sendScreenView(""String_Node_Str"" + mToday,getActivity());
}",0.9661246612466124
19010,"public void updateMenuView(){
  final int menuSize=mMenu.size();
  if (menuSize != mButtons.length) {
    buildMenuView();
    return;
  }
  int previousSelectedId=mSelectedItemId;
  for (int i=0; i < menuSize; i++) {
    MenuItem item=mMenu.getItem(i);
    if (item.isChecked()) {
      mSelectedItemId=item.getItemId();
      mSelectedItemPosition=i;
    }
  }
  if (previousSelectedId != mSelectedItemId) {
    TransitionManager.beginDelayedTransition(this,mSet);
  }
  for (int i=0; i < menuSize; i++) {
    mPresenter.setUpdateSuspended(true);
    if (mButtons[i] != null) {
      mButtons[i].initialize((MenuItemImpl)mMenu.getItem(i),0);
    }
    mPresenter.setUpdateSuspended(false);
  }
}","public void updateMenuView(){
  if (mMenu == null || mButtons == null)   return;
  final int menuSize=mMenu.size();
  if (menuSize != mButtons.length) {
    buildMenuView();
    return;
  }
  int previousSelectedId=mSelectedItemId;
  for (int i=0; i < menuSize; i++) {
    MenuItem item=mMenu.getItem(i);
    if (item.isChecked()) {
      mSelectedItemId=item.getItemId();
      mSelectedItemPosition=i;
    }
  }
  if (previousSelectedId != mSelectedItemId) {
    TransitionManager.beginDelayedTransition(this,mSet);
  }
  for (int i=0; i < menuSize; i++) {
    mPresenter.setUpdateSuspended(true);
    if (mButtons[i] != null) {
      mButtons[i].initialize((MenuItemImpl)mMenu.getItem(i),0);
    }
    mPresenter.setUpdateSuspended(false);
  }
}",0.9647058823529412
19011,"@Override public void onFiltersChanged(TagFilterHolder filters){
  CharSequence filtersDesc=filters.describeFilters(getResources(),getContext().getTheme());
  mFiltersDescription.setText(filtersDesc);
  if (filters.hasAnyFilters()) {
    mFiltersBar.setVisibility(VISIBLE);
    mContent.setTranslationY(mFiltersBar.getHeight());
  }
 else {
    mFiltersBar.setVisibility(INVISIBLE);
    mContent.setTranslationY(0f);
  }
}","@Override public void onFiltersChanged(TagFilterHolder filters){
  CharSequence filtersDesc=filters.describeFilters(getResources(),getContext().getTheme());
  mFiltersDescription.setText(filtersDesc);
  if (filters.hasAnyFilters()) {
    mFiltersBar.setVisibility(VISIBLE);
    mContent.setTranslationY(mFiltersBar.getHeight());
    offsetFilters(mFiltersBar.getHeight(),0);
  }
 else {
    mFiltersBar.setVisibility(INVISIBLE);
    offsetFilters(mFiltersBar.getHeight(),0);
    mContent.setTranslationY(0f);
  }
}",0.9017094017094016
19012,"@Override public void onViewCreated(final View view,@Nullable final Bundle savedInstanceState){
  super.onViewCreated(view,savedInstanceState);
  String[] singleDayFragmentsTags=null;
  int currentSingleDayFragment=0;
  if (savedInstanceState != null) {
    if (savedInstanceState.containsKey(SINGLE_DAY_FRAGMENTS_TAGS)) {
      singleDayFragmentsTags=savedInstanceState.getStringArray(SINGLE_DAY_FRAGMENTS_TAGS);
    }
    if (savedInstanceState.containsKey(CURRENT_SINGLE_DAY_FRAGMENT_POSITION)) {
      currentSingleDayFragment=savedInstanceState.getInt(CURRENT_SINGLE_DAY_FRAGMENT_POSITION);
    }
  }
  mContent=view.findViewById(R.id.swipe_refresh_layout);
  mViewPager=(ViewPager)view.findViewById(R.id.view_pager);
  mViewPagerAdapter=new ScheduleDayViewPagerAdapter(getContext(),getChildFragmentManager(),ScheduleModel.showPreConferenceData(getContext()));
  mViewPagerAdapter.setRetainedFragmentsTags(singleDayFragmentsTags);
  mViewPager.setAdapter(mViewPagerAdapter);
  mViewPager.setCurrentItem(currentSingleDayFragment);
  mTabLayout=(TabLayout)view.findViewById(R.id.sliding_tabs);
  mTabLayout.setupWithViewPager(mViewPager);
  mTabLayout.addOnTabSelectedListener(new TabLayout.OnTabSelectedListener(){
    @Override public void onTabSelected(    final TabLayout.Tab tab){
    }
    @Override public void onTabUnselected(    final TabLayout.Tab tab){
    }
    @Override public void onTabReselected(    final TabLayout.Tab tab){
      mViewPagerAdapter.getFragments()[tab.getPosition()].resetListPosition();
    }
  }
);
  mViewPager.setPageMargin(getResources().getDimensionPixelSize(R.dimen.my_schedule_page_margin));
  mViewPager.setPageMarginDrawable(R.drawable.page_margin);
  mViewPager.setOffscreenPageLimit(3);
  mAppBar=(AppBarLayout)view.findViewById(R.id.appbar);
  mFiltersBar=view.findViewById(R.id.filters_bar);
  mFiltersDescription=(TextView)mFiltersBar.findViewById(R.id.filters_description);
  mFiltersDescription.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      Activity activity=getActivity();
      if (activity instanceof ScheduleViewParent) {
        ((ScheduleViewParent)activity).openFilterDrawer();
      }
    }
  }
);
  mClearFilters=mFiltersBar.findViewById(R.id.clear_filters);
  mClearFilters.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      Activity activity=getActivity();
      if (activity instanceof ScheduleViewParent) {
        ((ScheduleViewParent)activity).onRequestClearFilters();
      }
    }
  }
);
  calculateCurrentDay();
  if (mViewPager != null) {
    scrollToConferenceDay(mToday);
  }
  View header=view.findViewById(R.id.header_anim);
  if (header instanceof ImageView) {
    AnimatedVectorDrawable avd=(AnimatedVectorDrawable)ContextCompat.getDrawable(getContext(),R.drawable.avd_header_schedule);
    ((ImageView)header).setImageDrawable(avd);
    avd.start();
  }
  final AppBarCollapsedListener appBarCollapsedListener=new AppBarCollapsedListener();
  mAppBar.addOnOffsetChangedListener(appBarCollapsedListener);
  ((CoordinatorLayout.LayoutParams)mContent.getLayoutParams()).setBehavior(new AppBarLayout.ScrollingViewBehavior(){
    @Override public boolean onStartNestedScroll(    CoordinatorLayout coordinatorLayout,    View child,    View directTargetChild,    View target,    int nestedScrollAxes){
      return (nestedScrollAxes & View.SCROLL_AXIS_VERTICAL) != 0 && mFiltersBar.getVisibility() == VISIBLE;
    }
    @Override public void onNestedScroll(    CoordinatorLayout coordinatorLayout,    View child,    View target,    int dxConsumed,    int dyConsumed,    int dxUnconsumed,    int dyUnconsumed){
      float filtersOffset=mFiltersBar.getTranslationY();
      int filtersHeight=mFiltersBar.getHeight();
      if (dyConsumed > 0 && appBarCollapsedListener.isCollapsed() && filtersOffset > -filtersHeight) {
        int offset=(int)Math.max(filtersOffset - dyConsumed,-filtersHeight);
        offsetFilters(filtersHeight,offset);
      }
 else       if (dyConsumed < 0 && filtersOffset < 0f) {
        int offset=(int)Math.min(filtersOffset - dyConsumed,0f);
        offsetFilters(filtersHeight,offset);
      }
    }
    private void offsetFilters(    int filtersHeight,    int offset){
      mFiltersBar.setTranslationY(offset);
      mFiltersBarClip.set(0,-offset,mFiltersBar.getWidth(),filtersHeight);
      mFiltersBar.setClipBounds(mFiltersBarClip);
      mContent.setTranslationY(filtersHeight + offset);
    }
  }
);
  AnalyticsHelper.sendScreenView(""String_Node_Str"" + mToday,getActivity());
}","@Override public void onViewCreated(final View view,@Nullable final Bundle savedInstanceState){
  super.onViewCreated(view,savedInstanceState);
  String[] singleDayFragmentsTags=null;
  int currentSingleDayFragment=0;
  if (savedInstanceState != null) {
    if (savedInstanceState.containsKey(SINGLE_DAY_FRAGMENTS_TAGS)) {
      singleDayFragmentsTags=savedInstanceState.getStringArray(SINGLE_DAY_FRAGMENTS_TAGS);
    }
    if (savedInstanceState.containsKey(CURRENT_SINGLE_DAY_FRAGMENT_POSITION)) {
      currentSingleDayFragment=savedInstanceState.getInt(CURRENT_SINGLE_DAY_FRAGMENT_POSITION);
    }
  }
  mContent=view.findViewById(R.id.swipe_refresh_layout);
  mViewPager=(ViewPager)view.findViewById(R.id.view_pager);
  mViewPagerAdapter=new ScheduleDayViewPagerAdapter(getContext(),getChildFragmentManager(),ScheduleModel.showPreConferenceData(getContext()));
  mViewPagerAdapter.setRetainedFragmentsTags(singleDayFragmentsTags);
  mViewPager.setAdapter(mViewPagerAdapter);
  mViewPager.setCurrentItem(currentSingleDayFragment);
  mTabLayout=(TabLayout)view.findViewById(R.id.sliding_tabs);
  mTabLayout.setupWithViewPager(mViewPager);
  mTabLayout.addOnTabSelectedListener(new TabLayout.OnTabSelectedListener(){
    @Override public void onTabSelected(    final TabLayout.Tab tab){
    }
    @Override public void onTabUnselected(    final TabLayout.Tab tab){
    }
    @Override public void onTabReselected(    final TabLayout.Tab tab){
      mViewPagerAdapter.getFragments()[tab.getPosition()].resetListPosition();
    }
  }
);
  mViewPager.setPageMargin(getResources().getDimensionPixelSize(R.dimen.my_schedule_page_margin));
  mViewPager.setPageMarginDrawable(R.drawable.page_margin);
  mViewPager.setOffscreenPageLimit(3);
  mAppBar=(AppBarLayout)view.findViewById(R.id.appbar);
  mFiltersBar=view.findViewById(R.id.filters_bar);
  mFiltersDescription=(TextView)mFiltersBar.findViewById(R.id.filters_description);
  mFiltersDescription.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      Activity activity=getActivity();
      if (activity instanceof ScheduleViewParent) {
        ((ScheduleViewParent)activity).openFilterDrawer();
      }
    }
  }
);
  mClearFilters=mFiltersBar.findViewById(R.id.clear_filters);
  mClearFilters.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      Activity activity=getActivity();
      if (activity instanceof ScheduleViewParent) {
        ((ScheduleViewParent)activity).onRequestClearFilters();
      }
    }
  }
);
  calculateCurrentDay();
  if (mViewPager != null) {
    scrollToConferenceDay(mToday);
  }
  View header=view.findViewById(R.id.header_anim);
  if (header instanceof ImageView) {
    AnimatedVectorDrawable avd=(AnimatedVectorDrawable)ContextCompat.getDrawable(getContext(),R.drawable.avd_header_schedule);
    ((ImageView)header).setImageDrawable(avd);
    avd.start();
  }
  final AppBarCollapsedListener appBarCollapsedListener=new AppBarCollapsedListener();
  mAppBar.addOnOffsetChangedListener(appBarCollapsedListener);
  ((CoordinatorLayout.LayoutParams)mContent.getLayoutParams()).setBehavior(new AppBarLayout.ScrollingViewBehavior(){
    @Override public boolean onStartNestedScroll(    CoordinatorLayout coordinatorLayout,    View child,    View directTargetChild,    View target,    int nestedScrollAxes){
      return (nestedScrollAxes & View.SCROLL_AXIS_VERTICAL) != 0 && mFiltersBar.getVisibility() == VISIBLE;
    }
    @Override public void onNestedScroll(    CoordinatorLayout coordinatorLayout,    View child,    View target,    int dxConsumed,    int dyConsumed,    int dxUnconsumed,    int dyUnconsumed){
      float filtersOffset=mFiltersBar.getTranslationY();
      int filtersHeight=mFiltersBar.getHeight();
      if (dyConsumed > 0 && appBarCollapsedListener.isCollapsed() && filtersOffset > -filtersHeight) {
        int offset=(int)Math.max(filtersOffset - dyConsumed,-filtersHeight);
        offsetFilters(filtersHeight,offset);
      }
 else       if (dyConsumed < 0 && filtersOffset < 0f) {
        int offset=(int)Math.min(filtersOffset - dyConsumed,0f);
        offsetFilters(filtersHeight,offset);
      }
    }
  }
);
  AnalyticsHelper.sendScreenView(""String_Node_Str"" + mToday,getActivity());
}",0.9661246612466124
19013,"@Override public void onAddEventsClicked(int conferenceDay){
  AnalyticsHelper.sendEvent(""String_Node_Str"",""String_Node_Str"",String.valueOf(conferenceDay));
  ScheduleActivity.launchScheduleForConferenceDay(getContext(),conferenceDay);
}","@Override public void onAddEventsClicked(int conferenceDay){
  AnalyticsHelper.sendEvent(""String_Node_Str"",""String_Node_Str"",String.valueOf(conferenceDay));
  ScheduleActivity.launchScheduleForConferenceDay(getContext(),conferenceDay);
  getActivity().finish();
}",0.948
19014,"@Override public void onViewCreated(View view,@Nullable Bundle savedInstanceState){
  super.onViewCreated(view,savedInstanceState);
  mRecyclerView=(RecyclerView)view.findViewById(R.id.filters);
  mClearFilters=(Button)view.findViewById(R.id.clear_filters);
  mClearFilters.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      mAdapter.clearAllFilters();
    }
  }
);
  final Context context=view.getContext();
  TextViewCompat.setCompoundDrawablesRelativeWithIntrinsicBounds(mClearFilters,null,null,AppCompatResources.getDrawable(context,R.drawable.ic_clear_all),null);
  mRecyclerView.setHasFixedSize(true);
  mRecyclerView.addItemDecoration(new DividerDecoration(context));
  final View filtersHeader=view.findViewById(R.id.filters_header);
  mRecyclerView.addOnScrollListener(new RecyclerView.OnScrollListener(){
    @Override public void onScrolled(    RecyclerView recyclerView,    int dx,    int dy){
      filtersHeader.setActivated(recyclerView.canScrollVertically(-1));
    }
  }
);
  mAdapter=new SessionsFilterAdapter(context,null,savedInstanceState);
  mAdapter.setSessionFilterAdapterListener(new OnFiltersChangedListener(){
    @Override public void onFiltersChanged(    TagFilterHolder filterHolder){
      mClearFilters.setVisibility(filterHolder.hasAnyFilters() ? View.VISIBLE : View.GONE);
      if (mListener != null) {
        mListener.onFiltersChanged(filterHolder);
        CharSequence filtersDesc=filterHolder.describeFilters(getResources(),getContext().getTheme());
        AnalyticsHelper.sendEvent(""String_Node_Str"",""String_Node_Str"",String.valueOf(filtersDesc));
      }
    }
  }
);
  mRecyclerView.setAdapter(mAdapter);
}","@Override public void onViewCreated(View view,@Nullable Bundle savedInstanceState){
  super.onViewCreated(view,savedInstanceState);
  mRecyclerView=(RecyclerView)view.findViewById(R.id.filters);
  mClearFilters=(Button)view.findViewById(R.id.clear_filters);
  mClearFilters.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      mAdapter.clearAllFilters();
    }
  }
);
  final Context context=view.getContext();
  TextViewCompat.setCompoundDrawablesRelativeWithIntrinsicBounds(mClearFilters,null,null,AppCompatResources.getDrawable(context,R.drawable.ic_clear_all),null);
  mRecyclerView.setHasFixedSize(true);
  mRecyclerView.addItemDecoration(new DividerDecoration(context));
  final View filtersHeader=view.findViewById(R.id.filters_header);
  mRecyclerView.addOnScrollListener(new RecyclerView.OnScrollListener(){
    @Override public void onScrolled(    RecyclerView recyclerView,    int dx,    int dy){
      filtersHeader.setActivated(recyclerView.canScrollVertically(-1));
    }
  }
);
  mAdapter=new SessionsFilterAdapter(context,null,savedInstanceState);
  mAdapter.setSessionFilterAdapterListener(new OnFiltersChangedListener(){
    @Override public void onFiltersChanged(    TagFilterHolder filterHolder){
      mClearFilters.setVisibility(filterHolder.hasAnyFilters() ? View.VISIBLE : View.GONE);
      if (mListener != null) {
        mListener.onFiltersChanged(filterHolder);
        CharSequence filtersDesc=filterHolder.describeFilters(getResources(),getContext().getTheme());
        AnalyticsHelper.sendEvent(""String_Node_Str"",""String_Node_Str"",String.valueOf(filtersDesc));
      }
    }
  }
);
  TagFilterHolder filters=mAdapter.getFilters();
  if (filters != null) {
    mClearFilters.setVisibility(filters.hasAnyFilters() ? View.VISIBLE : View.GONE);
  }
  mRecyclerView.setAdapter(mAdapter);
}",0.9541232761047004
19015,"SessionsFilterAdapter(Context context,TagMetadata filters,Bundle savedState){
  mInflater=LayoutInflater.from(context);
  mItems=new ArrayList<>();
  buildFiltersList(filters);
  restoreFromState(savedState);
}","SessionsFilterAdapter(Context context,TagMetadata filters,Bundle savedState){
  restoreFromState(savedState);
  mInflater=LayoutInflater.from(context);
  mItems=new ArrayList<>();
  buildFiltersList(filters);
}",0.8476190476190476
19016,"private void restoreFromState(Bundle savedState){
  if (savedState != null) {
    TagFilterHolder filterHolder=savedState.getParcelable(STATE_FILTERS);
    if (filterHolder != null) {
      mTagFilterHolder=filterHolder;
    }
  }
}","private void restoreFromState(Bundle savedState){
  if (savedState != null) {
    TagFilterHolder filterHolder=savedState.getParcelable(STATE_FILTERS);
    if (filterHolder != null) {
      mTagFilterHolder=filterHolder;
    }
  }
  if (mTagFilterHolder == null) {
    mTagFilterHolder=new TagFilterHolder();
  }
}",0.8498168498168498
19017,"/** 
 * @param tag The tag to check in the filter
 * @return boolean Return a boolean indicating that the tagId is present.
 */
public boolean contains(Tag tag){
  return mSelectedTopics.contains(tag) || mSelectedTopics.contains(tag);
}","/** 
 * @param tag The tag to check in the filter
 * @return boolean Return a boolean indicating that the tagId is present.
 */
public boolean contains(Tag tag){
  return mSelectedTypes.contains(tag) || mSelectedTopics.contains(tag);
}",0.9851380042462844
19018,"@Override public void onViewCreated(View view,@Nullable Bundle savedInstanceState){
  super.onViewCreated(view,savedInstanceState);
  mRecyclerView=(RecyclerView)view.findViewById(R.id.filters);
  mClearFilters=(Button)view.findViewById(R.id.clear_filters);
  mClearFilters.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      mAdapter.clearAllFilters();
    }
  }
);
  final Context context=view.getContext();
  TextViewCompat.setCompoundDrawablesRelativeWithIntrinsicBounds(mClearFilters,null,null,AppCompatResources.getDrawable(context,R.drawable.ic_clear_all),null);
  mRecyclerView.setHasFixedSize(true);
  mRecyclerView.addItemDecoration(new DividerDecoration(context));
  final View filtersHeader=view.findViewById(R.id.filters_header);
  mRecyclerView.addOnScrollListener(new RecyclerView.OnScrollListener(){
    @Override public void onScrolled(    RecyclerView recyclerView,    int dx,    int dy){
      filtersHeader.setActivated(recyclerView.canScrollVertically(-1));
    }
  }
);
  mAdapter=new SessionsFilterAdapter(context,null,savedInstanceState);
  mAdapter.setSessionFilterAdapterListener(new OnFiltersChangedListener(){
    @Override public void onFiltersChanged(    TagFilterHolder filterHolder){
      mClearFilters.setVisibility(filterHolder.hasAnyFilters() ? View.VISIBLE : View.GONE);
      if (mListener != null) {
        mListener.onFiltersChanged(filterHolder);
        CharSequence filtersDesc=filterHolder.describeFilters(getResources(),getContext().getTheme());
        AnalyticsHelper.sendEvent(""String_Node_Str"",""String_Node_Str"",String.valueOf(filtersDesc));
      }
    }
  }
);
  mRecyclerView.setAdapter(mAdapter);
}","@Override public void onViewCreated(View view,@Nullable Bundle savedInstanceState){
  super.onViewCreated(view,savedInstanceState);
  mRecyclerView=(RecyclerView)view.findViewById(R.id.filters);
  mClearFilters=(Button)view.findViewById(R.id.clear_filters);
  mClearFilters.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      mAdapter.clearAllFilters();
    }
  }
);
  final Context context=view.getContext();
  TextViewCompat.setCompoundDrawablesRelativeWithIntrinsicBounds(mClearFilters,null,null,AppCompatResources.getDrawable(context,R.drawable.ic_clear_all),null);
  mRecyclerView.setHasFixedSize(true);
  mRecyclerView.addItemDecoration(new DividerDecoration(context));
  final View filtersHeader=view.findViewById(R.id.filters_header);
  mRecyclerView.addOnScrollListener(new RecyclerView.OnScrollListener(){
    @Override public void onScrolled(    RecyclerView recyclerView,    int dx,    int dy){
      filtersHeader.setActivated(recyclerView.canScrollVertically(-1));
    }
  }
);
  mAdapter=new SessionsFilterAdapter(context,null,savedInstanceState);
  mAdapter.setSessionFilterAdapterListener(new OnFiltersChangedListener(){
    @Override public void onFiltersChanged(    TagFilterHolder filterHolder){
      mClearFilters.setVisibility(filterHolder.hasAnyFilters() ? View.VISIBLE : View.GONE);
      if (mListener != null) {
        mListener.onFiltersChanged(filterHolder);
        CharSequence filtersDesc=filterHolder.describeFilters(getResources(),getContext().getTheme());
        AnalyticsHelper.sendEvent(""String_Node_Str"",""String_Node_Str"",String.valueOf(filtersDesc));
      }
    }
  }
);
  TagFilterHolder filters=mAdapter.getFilters();
  if (filters != null) {
    mClearFilters.setVisibility(filters.hasAnyFilters() ? View.VISIBLE : View.GONE);
  }
  mRecyclerView.setAdapter(mAdapter);
}",0.9541232761047004
19019,"SessionsFilterAdapter(Context context,TagMetadata filters,Bundle savedState){
  mInflater=LayoutInflater.from(context);
  mItems=new ArrayList<>();
  buildFiltersList(filters);
  restoreFromState(savedState);
}","SessionsFilterAdapter(Context context,TagMetadata filters,Bundle savedState){
  restoreFromState(savedState);
  mInflater=LayoutInflater.from(context);
  mItems=new ArrayList<>();
  buildFiltersList(filters);
}",0.8476190476190476
19020,"private void restoreFromState(Bundle savedState){
  if (savedState != null) {
    TagFilterHolder filterHolder=savedState.getParcelable(STATE_FILTERS);
    if (filterHolder != null) {
      mTagFilterHolder=filterHolder;
    }
  }
}","private void restoreFromState(Bundle savedState){
  if (savedState != null) {
    TagFilterHolder filterHolder=savedState.getParcelable(STATE_FILTERS);
    if (filterHolder != null) {
      mTagFilterHolder=filterHolder;
    }
  }
  if (mTagFilterHolder == null) {
    mTagFilterHolder=new TagFilterHolder();
  }
}",0.8498168498168498
19021,"/** 
 * @param tag The tag to check in the filter
 * @return boolean Return a boolean indicating that the tagId is present.
 */
public boolean contains(Tag tag){
  return mSelectedTopics.contains(tag) || mSelectedTopics.contains(tag);
}","/** 
 * @param tag The tag to check in the filter
 * @return boolean Return a boolean indicating that the tagId is present.
 */
public boolean contains(Tag tag){
  return mSelectedTypes.contains(tag) || mSelectedTopics.contains(tag);
}",0.9851380042462844
19022,"@Override public void onAddEventsClicked(int conferenceDay){
  AnalyticsHelper.sendEvent(""String_Node_Str"",""String_Node_Str"",String.valueOf(conferenceDay));
  ScheduleActivity.launchScheduleForConferenceDay(getContext(),conferenceDay);
}","@Override public void onAddEventsClicked(int conferenceDay){
  AnalyticsHelper.sendEvent(""String_Node_Str"",""String_Node_Str"",String.valueOf(conferenceDay));
  ScheduleActivity.launchScheduleForConferenceDay(getContext(),conferenceDay);
  getActivity().finish();
}",0.948
19023,"private void updateReservationStatus(ScheduleItem item){
  if (FirebaseAuth.getInstance().getCurrentUser() == null || RegistrationUtils.isRegisteredAttendee(mReservationStatus.getContext()) != RegistrationUtils.REGSTATUS_REGISTERED || item.isKeynote() || item.reservationStatus == RESERVATION_STATUS_UNRESERVED) {
    mReservationStatus.setVisibility(GONE);
    return;
  }
  if (item.reservationStatus == RESERVATION_STATUS_RESERVED || item.reservationStatus == RESERVATION_STATUS_WAITLISTED) {
    mReservationStatus.setVisibility(VISIBLE);
    mReservationStatus.setCompoundDrawablesWithIntrinsicBounds(item.reservationStatus == RESERVATION_STATUS_RESERVED ? R.drawable.ic_reserved : R.drawable.ic_waitlisted,0,0,0);
    mReservationStatus.setText(item.reservationStatus == RESERVATION_STATUS_RESERVED ? R.string.schedule_item_reserved : R.string.schedule_item_waitlisted);
  }
}","private void updateReservationStatus(ScheduleItem item){
  if (item.reservationStatus == RESERVATION_STATUS_RESERVED || item.reservationStatus == RESERVATION_STATUS_WAITLISTED) {
    mReservationStatus.setVisibility(VISIBLE);
    mReservationStatus.setCompoundDrawablesWithIntrinsicBounds(item.reservationStatus == RESERVATION_STATUS_RESERVED ? R.drawable.ic_reserved : R.drawable.ic_waitlisted,0,0,0);
    mReservationStatus.setText(item.reservationStatus == RESERVATION_STATUS_RESERVED ? R.string.schedule_item_reserved : R.string.schedule_item_waitlisted);
  }
 else {
    mReservationStatus.setVisibility(GONE);
  }
}",0.7518296739853626
19024,"private void updateReservationStatus(ScheduleItem item){
  if (FirebaseAuth.getInstance().getCurrentUser() == null || RegistrationUtils.isRegisteredAttendee(mReservationStatus.getContext()) != RegistrationUtils.REGSTATUS_REGISTERED || item.isKeynote() || item.reservationStatus == RESERVATION_STATUS_UNRESERVED) {
    mReservationStatus.setVisibility(GONE);
    return;
  }
  if (item.reservationStatus == RESERVATION_STATUS_RESERVED || item.reservationStatus == RESERVATION_STATUS_WAITLISTED) {
    mReservationStatus.setVisibility(VISIBLE);
    mReservationStatus.setCompoundDrawablesWithIntrinsicBounds(item.reservationStatus == RESERVATION_STATUS_RESERVED ? R.drawable.ic_reserved : R.drawable.ic_waitlisted,0,0,0);
    mReservationStatus.setText(item.reservationStatus == RESERVATION_STATUS_RESERVED ? R.string.schedule_item_reserved : R.string.schedule_item_waitlisted);
  }
}","private void updateReservationStatus(ScheduleItem item){
  if (item.reservationStatus == RESERVATION_STATUS_RESERVED || item.reservationStatus == RESERVATION_STATUS_WAITLISTED) {
    mReservationStatus.setVisibility(VISIBLE);
    mReservationStatus.setCompoundDrawablesWithIntrinsicBounds(item.reservationStatus == RESERVATION_STATUS_RESERVED ? R.drawable.ic_reserved : R.drawable.ic_waitlisted,0,0,0);
    mReservationStatus.setText(item.reservationStatus == RESERVATION_STATUS_RESERVED ? R.string.schedule_item_reserved : R.string.schedule_item_waitlisted);
  }
 else {
    mReservationStatus.setVisibility(GONE);
  }
}",0.7518296739853626
19025,"public ReserveButton(Context context,AttributeSet attrs){
  super(context,attrs,R.attr.reserveButtonStyle);
  LayoutInflater.from(context).inflate(R.layout.reserve_button,this,true);
  text=(TextView)findViewById(R.id.reserve_text);
  text.setText(status.text);
}","public ReserveButton(Context context,AttributeSet attrs){
  super(context,attrs,R.attr.reserveButtonStyle);
  LayoutInflater.from(context).inflate(R.layout.reserve_button,this,true);
  text=(TextView)findViewById(R.id.reserve_text);
  setStatus(ReservationStatus.RESERVABLE);
}",0.8851851851851852
19026,"public void setStatus(ReservationStatus status){
  this.status=status;
  refreshDrawableState();
  text.setText(status.text);
}","public void setStatus(ReservationStatus status){
  if (this.status == status)   return;
  this.status=status;
  refreshDrawableState();
  text.setText(status.text);
}",0.8668941979522184
19027,"public ReserveButton(Context context,AttributeSet attrs){
  super(context,attrs,R.attr.reserveButtonStyle);
  LayoutInflater.from(context).inflate(R.layout.reserve_button,this,true);
  text=(TextView)findViewById(R.id.reserve_text);
  text.setText(status.text);
}","public ReserveButton(Context context,AttributeSet attrs){
  super(context,attrs,R.attr.reserveButtonStyle);
  LayoutInflater.from(context).inflate(R.layout.reserve_button,this,true);
  text=(TextView)findViewById(R.id.reserve_text);
  setStatus(ReservationStatus.RESERVABLE);
}",0.8851851851851852
19028,"public void setStatus(ReservationStatus status){
  this.status=status;
  refreshDrawableState();
  text.setText(status.text);
}","public void setStatus(ReservationStatus status){
  if (this.status == status)   return;
  this.status=status;
  refreshDrawableState();
  text.setText(status.text);
}",0.8668941979522184
19029,"/** 
 * Update UI to reflect reservation status known to ContentProvider.
 */
public void updateReservationStatusFromServer(SessionDetailModel sessionDetailModel){
  int reservationStatus=sessionDetailModel.getServerReservationStatus();
switch (reservationStatus) {
case ScheduleContract.MyReservations.RESERVATION_STATUS_RESERVED:
    showAlreadyReserved();
  break;
case ScheduleContract.MyReservations.RESERVATION_STATUS_UNRESERVED:
updateSeatsAvailability(sessionDetailModel);
break;
case ScheduleContract.MyReservations.RESERVATION_STATUS_WAITLISTED:
showWaitlisted();
break;
}
}","/** 
 * Update UI to reflect reservation status known to ContentProvider.
 */
public void updateReservationStatusFromServer(SessionDetailModel sessionDetailModel){
  int reservationStatus=sessionDetailModel.getServerReservationStatus();
switch (reservationStatus) {
case ScheduleContract.MyReservations.RESERVATION_STATUS_RESERVED:
    showAlreadyReserved();
  break;
case ScheduleContract.MyReservations.RESERVATION_STATUS_UNRESERVED:
updateReservationStatusAndSeatAvailability(sessionDetailModel);
break;
case ScheduleContract.MyReservations.RESERVATION_STATUS_WAITLISTED:
showWaitlisted();
break;
}
}",0.9755686604886268
19030,"@Override public void displayData(SessionDetailModel data,SessionDetailQueryEnum query){
switch (query) {
case SESSIONS:
    displaySessionData(data);
  displayTrackColor(data);
break;
case FEEDBACK:
updateFeedbackButton(data);
break;
case SPEAKERS:
displaySpeakersData(data);
break;
case TAG_METADATA:
displayTags(data);
displayTrackColor(data);
break;
case RELATED:
displayRelatedSessions(data);
break;
case RESERVATION_STATUS:
updateReservationStatus(data);
break;
case RESERVATION_RESULT:
updateReservationResult(data);
break;
case RESERVATION_PENDING:
updateReservationPending(data);
break;
case RESERVATION_FAILED:
showRequestFailed();
updateReservationStatus(data);
break;
case RESERVATION_SEAT_AVAILABILITY:
updateSeatsAvailability(data);
break;
case AUTH_REGISTRATION:
updateAuthRegistration(data);
break;
default :
break;
}
}","@Override public void displayData(SessionDetailModel data,SessionDetailQueryEnum query){
switch (query) {
case SESSIONS:
    displaySessionData(data);
  displayTrackColor(data);
break;
case FEEDBACK:
updateFeedbackButton(data);
break;
case SPEAKERS:
displaySpeakersData(data);
break;
case TAG_METADATA:
displayTags(data);
displayTrackColor(data);
break;
case RELATED:
displayRelatedSessions(data);
break;
case RESERVATION_STATUS:
updateReservationStatusAndSeatAvailability(data);
break;
case RESERVATION_RESULT:
updateReservationResult(data);
break;
case RESERVATION_PENDING:
updateReservationPending(data);
break;
case RESERVATION_FAILED:
showRequestFailed();
updateReservationStatusAndSeatAvailability(data);
break;
case RESERVATION_SEAT_AVAILABILITY:
updateReservationStatusAndSeatAvailability(data);
break;
case AUTH_REGISTRATION:
updateAuthRegistration(data);
break;
default :
break;
}
}",0.9612044006948466
19031,"/** 
 * Update UI based on reservation request result. Usually this means presenting a dialog and/or updating the reservation button UI.
 */
public void updateReservationResult(SessionDetailModel sessionDetailModel){
  String reservationResult=sessionDetailModel.getReservationResult();
  if (reservationResult != null && isAdded()) {
    LOGD(TAG,""String_Node_Str"" + reservationResult);
switch (reservationResult) {
case SessionDetailConstants.RESERVE_DENIED_CUTOFF:
      showReservationDeniedCutoff();
    break;
case SessionDetailConstants.RESERVE_DENIED_CLASH:
  showReservationDeniedClash();
break;
case SessionDetailConstants.RESERVE_DENIED_FAILED:
showRequestFailed();
break;
case SessionDetailConstants.RESERVE_DENIED_SPACE:
showReservationDeniedSpace();
break;
case SessionDetailConstants.RESERVED:
showReservationSuccessful();
break;
case SessionDetailConstants.RETURN_DENIED_CUTOFF:
showReturnDeniedCutoff();
break;
case SessionDetailConstants.RETURN_DENIED_FAILED:
showRequestFailed();
break;
case SessionDetailConstants.RETURNED:
break;
}
updateReservationStatus(sessionDetailModel);
}
}","/** 
 * Update UI based on reservation request result. Usually this means presenting a dialog and/or updating the reservation button UI.
 */
public void updateReservationResult(SessionDetailModel sessionDetailModel){
  String reservationResult=sessionDetailModel.getReservationResult();
  if (reservationResult != null && isAdded()) {
    LOGD(TAG,""String_Node_Str"" + reservationResult);
switch (reservationResult) {
case SessionDetailConstants.RESERVE_DENIED_CUTOFF:
      showReservationDeniedCutoff();
    break;
case SessionDetailConstants.RESERVE_DENIED_CLASH:
  showReservationDeniedClash();
break;
case SessionDetailConstants.RESERVE_DENIED_FAILED:
showRequestFailed();
break;
case SessionDetailConstants.RESERVE_DENIED_SPACE:
showReservationDeniedSpace();
break;
case SessionDetailConstants.RESERVED:
showReservationSuccessful();
break;
case SessionDetailConstants.RETURN_DENIED_CUTOFF:
showReturnDeniedCutoff();
break;
case SessionDetailConstants.RETURN_DENIED_FAILED:
showRequestFailed();
break;
case SessionDetailConstants.RETURNED:
break;
}
updateReservationStatusAndSeatAvailability(sessionDetailModel);
}
}",0.9914452949122016
19032,"@Override public void requestData(@NonNull SessionDetailQueryEnum query,@NonNull DataQueryCallback<SessionDetailQueryEnum> callback){
switch (query) {
case RESERVATION_PENDING:
case RESERVATION_STATUS:
case RESERVATION_RESULT:
    mDataQueryCallbacks.put(query,callback);
  break;
default :
super.requestData(query,callback);
break;
}
}","@Override public void requestData(@NonNull SessionDetailQueryEnum query,@NonNull DataQueryCallback<SessionDetailQueryEnum> callback){
switch (query) {
case RESERVATION_PENDING:
case RESERVATION_STATUS:
case RESERVATION_RESULT:
case RESERVATION_FAILED:
case RESERVATION_SEAT_AVAILABILITY:
    mDataQueryCallbacks.put(query,callback);
  break;
default :
super.requestData(query,callback);
break;
}
}",0.9167803547066848
19033,"/** 
 * Update UI to reflect reservation status known to ContentProvider.
 */
public void updateReservationStatusFromServer(SessionDetailModel sessionDetailModel){
  int reservationStatus=sessionDetailModel.getServerReservationStatus();
switch (reservationStatus) {
case ScheduleContract.MyReservations.RESERVATION_STATUS_RESERVED:
    showAlreadyReserved();
  break;
case ScheduleContract.MyReservations.RESERVATION_STATUS_UNRESERVED:
updateSeatsAvailability(sessionDetailModel);
break;
case ScheduleContract.MyReservations.RESERVATION_STATUS_WAITLISTED:
showWaitlisted();
break;
}
}","/** 
 * Update UI to reflect reservation status known to ContentProvider.
 */
public void updateReservationStatusFromServer(SessionDetailModel sessionDetailModel){
  int reservationStatus=sessionDetailModel.getServerReservationStatus();
switch (reservationStatus) {
case ScheduleContract.MyReservations.RESERVATION_STATUS_RESERVED:
    showAlreadyReserved();
  break;
case ScheduleContract.MyReservations.RESERVATION_STATUS_UNRESERVED:
updateReservationStatusAndSeatAvailability(sessionDetailModel);
break;
case ScheduleContract.MyReservations.RESERVATION_STATUS_WAITLISTED:
showWaitlisted();
break;
}
}",0.9755686604886268
19034,"@Override public void displayData(SessionDetailModel data,SessionDetailQueryEnum query){
switch (query) {
case SESSIONS:
    displaySessionData(data);
  displayTrackColor(data);
break;
case FEEDBACK:
updateFeedbackButton(data);
break;
case SPEAKERS:
displaySpeakersData(data);
break;
case TAG_METADATA:
displayTags(data);
displayTrackColor(data);
break;
case RELATED:
displayRelatedSessions(data);
break;
case RESERVATION_STATUS:
updateReservationStatus(data);
break;
case RESERVATION_RESULT:
updateReservationResult(data);
break;
case RESERVATION_PENDING:
updateReservationPending(data);
break;
case RESERVATION_FAILED:
showRequestFailed();
updateReservationStatus(data);
break;
case RESERVATION_SEAT_AVAILABILITY:
updateSeatsAvailability(data);
break;
case AUTH_REGISTRATION:
updateAuthRegistration(data);
break;
default :
break;
}
}","@Override public void displayData(SessionDetailModel data,SessionDetailQueryEnum query){
switch (query) {
case SESSIONS:
    displaySessionData(data);
  displayTrackColor(data);
break;
case FEEDBACK:
updateFeedbackButton(data);
break;
case SPEAKERS:
displaySpeakersData(data);
break;
case TAG_METADATA:
displayTags(data);
displayTrackColor(data);
break;
case RELATED:
displayRelatedSessions(data);
break;
case RESERVATION_STATUS:
updateReservationStatusAndSeatAvailability(data);
break;
case RESERVATION_RESULT:
updateReservationResult(data);
break;
case RESERVATION_PENDING:
updateReservationPending(data);
break;
case RESERVATION_FAILED:
showRequestFailed();
updateReservationStatusAndSeatAvailability(data);
break;
case RESERVATION_SEAT_AVAILABILITY:
updateReservationStatusAndSeatAvailability(data);
break;
case AUTH_REGISTRATION:
updateAuthRegistration(data);
break;
default :
break;
}
}",0.9612044006948466
19035,"/** 
 * Update UI based on reservation request result. Usually this means presenting a dialog and/or updating the reservation button UI.
 */
public void updateReservationResult(SessionDetailModel sessionDetailModel){
  String reservationResult=sessionDetailModel.getReservationResult();
  if (reservationResult != null && isAdded()) {
    LOGD(TAG,""String_Node_Str"" + reservationResult);
switch (reservationResult) {
case SessionDetailConstants.RESERVE_DENIED_CUTOFF:
      showReservationDeniedCutoff();
    break;
case SessionDetailConstants.RESERVE_DENIED_CLASH:
  showReservationDeniedClash();
break;
case SessionDetailConstants.RESERVE_DENIED_FAILED:
showRequestFailed();
break;
case SessionDetailConstants.RESERVE_DENIED_SPACE:
showReservationDeniedSpace();
break;
case SessionDetailConstants.RESERVED:
showReservationSuccessful();
break;
case SessionDetailConstants.RETURN_DENIED_CUTOFF:
showReturnDeniedCutoff();
break;
case SessionDetailConstants.RETURN_DENIED_FAILED:
showRequestFailed();
break;
case SessionDetailConstants.RETURNED:
break;
}
updateReservationStatus(sessionDetailModel);
}
}","/** 
 * Update UI based on reservation request result. Usually this means presenting a dialog and/or updating the reservation button UI.
 */
public void updateReservationResult(SessionDetailModel sessionDetailModel){
  String reservationResult=sessionDetailModel.getReservationResult();
  if (reservationResult != null && isAdded()) {
    LOGD(TAG,""String_Node_Str"" + reservationResult);
switch (reservationResult) {
case SessionDetailConstants.RESERVE_DENIED_CUTOFF:
      showReservationDeniedCutoff();
    break;
case SessionDetailConstants.RESERVE_DENIED_CLASH:
  showReservationDeniedClash();
break;
case SessionDetailConstants.RESERVE_DENIED_FAILED:
showRequestFailed();
break;
case SessionDetailConstants.RESERVE_DENIED_SPACE:
showReservationDeniedSpace();
break;
case SessionDetailConstants.RESERVED:
showReservationSuccessful();
break;
case SessionDetailConstants.RETURN_DENIED_CUTOFF:
showReturnDeniedCutoff();
break;
case SessionDetailConstants.RETURN_DENIED_FAILED:
showRequestFailed();
break;
case SessionDetailConstants.RETURNED:
break;
}
updateReservationStatusAndSeatAvailability(sessionDetailModel);
}
}",0.9914452949122016
19036,"@Override public void requestData(@NonNull SessionDetailQueryEnum query,@NonNull DataQueryCallback<SessionDetailQueryEnum> callback){
switch (query) {
case RESERVATION_PENDING:
case RESERVATION_STATUS:
case RESERVATION_RESULT:
    mDataQueryCallbacks.put(query,callback);
  break;
default :
super.requestData(query,callback);
break;
}
}","@Override public void requestData(@NonNull SessionDetailQueryEnum query,@NonNull DataQueryCallback<SessionDetailQueryEnum> callback){
switch (query) {
case RESERVATION_PENDING:
case RESERVATION_STATUS:
case RESERVATION_RESULT:
case RESERVATION_FAILED:
case RESERVATION_SEAT_AVAILABILITY:
    mDataQueryCallbacks.put(query,callback);
  break;
default :
super.requestData(query,callback);
break;
}
}",0.9167803547066848
19037,"@Override public void onClick(final View view){
  WelcomeUtils.markUserRefusedSignInDuringOnboarding(mActivity,true);
  doNext();
}","@Override public void onClick(final View view){
  WelcomeUtils.markUserRefusedOnboardingSignIn(mActivity);
  doNext();
}",0.9083665338645418
19038,"@Override protected View.OnClickListener getPrimaryButtonListener(){
  return new View.OnClickListener(){
    @Override public void onClick(    final View view){
      Intent signInIntent=Auth.GoogleSignInApi.getSignInIntent(mGoogleApiClient);
      startActivityForResult(signInIntent,AccountUtils.RC_SIGN_IN);
    }
  }
;
}","@Override protected View.OnClickListener getPrimaryButtonListener(){
  return new View.OnClickListener(){
    @Override public void onClick(    final View view){
      WelcomeUtils.markUserAttemptedOnboardingSignIn(mActivity);
      Intent signInIntent=Auth.GoogleSignInApi.getSignInIntent(mGoogleApiClient);
      startActivityForResult(signInIntent,AccountUtils.RC_SIGN_IN);
    }
  }
;
}",0.9090909090909092
19039,"@Override protected View.OnClickListener getSecondaryButtonListener(){
  return new View.OnClickListener(){
    @Override public void onClick(    final View view){
      WelcomeUtils.markUserRefusedSignInDuringOnboarding(mActivity,true);
      doNext();
    }
  }
;
}","@Override protected View.OnClickListener getSecondaryButtonListener(){
  return new View.OnClickListener(){
    @Override public void onClick(    final View view){
      WelcomeUtils.markUserRefusedOnboardingSignIn(mActivity);
      doNext();
    }
  }
;
}",0.9407265774378584
19040,"@Override public boolean shouldDisplay(final Context context){
  return AccountUtils.getActiveAccount(context) == null && !WelcomeUtils.hasUserRefusedSignInDuringOnboarding(context);
}","@Override public boolean shouldDisplay(final Context context){
  return !(WelcomeUtils.hasUserAttemptedOnboardingSignIn(context) || WelcomeUtils.hasUserRefusedOnboardingSignIn(context));
}",0.7688172043010753
19041,"@Override public void onClick(final View view){
  WelcomeUtils.markUserRefusedSignInDuringOnboarding(mActivity,true);
  doNext();
}","@Override public void onClick(final View view){
  WelcomeUtils.markUserRefusedOnboardingSignIn(mActivity);
  doNext();
}",0.9083665338645418
19042,"@Override protected View.OnClickListener getPrimaryButtonListener(){
  return new View.OnClickListener(){
    @Override public void onClick(    final View view){
      Intent signInIntent=Auth.GoogleSignInApi.getSignInIntent(mGoogleApiClient);
      startActivityForResult(signInIntent,AccountUtils.RC_SIGN_IN);
    }
  }
;
}","@Override protected View.OnClickListener getPrimaryButtonListener(){
  return new View.OnClickListener(){
    @Override public void onClick(    final View view){
      WelcomeUtils.markUserAttemptedOnboardingSignIn(mActivity);
      Intent signInIntent=Auth.GoogleSignInApi.getSignInIntent(mGoogleApiClient);
      startActivityForResult(signInIntent,AccountUtils.RC_SIGN_IN);
    }
  }
;
}",0.9090909090909092
19043,"@Override protected View.OnClickListener getSecondaryButtonListener(){
  return new View.OnClickListener(){
    @Override public void onClick(    final View view){
      WelcomeUtils.markUserRefusedSignInDuringOnboarding(mActivity,true);
      doNext();
    }
  }
;
}","@Override protected View.OnClickListener getSecondaryButtonListener(){
  return new View.OnClickListener(){
    @Override public void onClick(    final View view){
      WelcomeUtils.markUserRefusedOnboardingSignIn(mActivity);
      doNext();
    }
  }
;
}",0.9407265774378584
19044,"@Override public boolean shouldDisplay(final Context context){
  return AccountUtils.getActiveAccount(context) == null && !WelcomeUtils.hasUserRefusedSignInDuringOnboarding(context);
}","@Override public boolean shouldDisplay(final Context context){
  return !(WelcomeUtils.hasUserAttemptedOnboardingSignIn(context) || WelcomeUtils.hasUserRefusedOnboardingSignIn(context));
}",0.7688172043010753
19045,"@Override protected View.OnClickListener getPrimaryButtonListener(){
  return new View.OnClickListener(){
    @Override public void onClick(    final View view){
      WelcomeUtils.markUserAttemptedOnboardingSignIn(mActivity);
      ((WelcomeActivity)mActivity).signIn();
      mActivity.finish();
    }
  }
;
}","@Override protected View.OnClickListener getPrimaryButtonListener(){
  return new View.OnClickListener(){
    @Override public void onClick(    final View view){
      WelcomeUtils.markUserAttemptedOnboardingSignIn(mActivity);
      ((WelcomeActivity)mActivity).signIn();
    }
  }
;
}",0.9362416107382552
19046,"/** 
 * Proceed to the next activity.
 */
public void doNext(){
  LOGD(TAG,""String_Node_Str"");
  Intent intent=new Intent(this,MyIOActivity.class);
  startActivity(intent);
}","/** 
 * Proceed to the next activity.
 */
public void doNext(){
  LOGD(TAG,""String_Node_Str"");
  Intent intent=new Intent(this,MyIOActivity.class);
  intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
  startActivity(intent);
  finish();
}",0.7493917274939172
19047,"@Override public void displayUserActionResult(final ExploreIOModel model,final ExploreIOUserActionEnum userAction,final boolean success){
}","@Override public void displayUserActionResult(final ExploreIOModel model,final ExploreIOUserActionEnum userAction,final boolean success){
switch (userAction) {
case RELOAD:
    displayData(model,ExploreIOQueryEnum.SESSIONS);
  break;
}
}",0.7393617021276596
19048,"@Override public void onSharedPreferenceChanged(SharedPreferences sharedPreferences,String key){
  if (SettingsUtils.PREF_DECLINED_WIFI_SETUP.equals(key)) {
    fireReloadEvent();
  }
}","@Override public void onSharedPreferenceChanged(SharedPreferences sharedPreferences,String key){
  if (SettingsUtils.PREF_DECLINED_WIFI_SETUP.equals(key)) {
    fireReloadEvent();
  }
 else   if (AccountUtils.PREF_ACTIVE_ACCOUNT.equals(key)) {
    fireReloadEvent();
  }
}",0.8096280087527352
19049,"@Override public void displayUserActionResult(final VideoLibraryModel model,final VideoLibraryUserActionEnum userAction,final boolean success){
}","@Override public void displayUserActionResult(final VideoLibraryModel model,final VideoLibraryUserActionEnum userAction,final boolean success){
switch (userAction) {
case VIDEO_PLAYED:
case RELOAD_USER_VIDEOS:
    displayData(model,VideoLibraryQueryEnum.MY_VIEWED_VIDEOS);
  break;
}
}",0.6744186046511628
19050,"private void initPresenter(){
  VideoLibraryModel model=ModelProvider.provideVideoLibraryModel(getDataUri(VideoLibraryQueryEnum.VIDEOS),getDataUri(VideoLibraryQueryEnum.MY_VIEWED_VIDEOS),getDataUri(VideoLibraryQueryEnum.FILTERS),getActivity(),getLoaderManager());
  PresenterImpl presenter=new PresenterImpl(model,this,VideoLibraryUserActionEnum.values(),VideoLibraryQueryEnum.values());
  presenter.loadInitialQueries();
  addListener(presenter);
}","private void initPresenter(){
  VideoLibraryModel model=ModelProvider.provideVideoLibraryModel(getDataUri(VideoLibraryQueryEnum.VIDEOS),getDataUri(VideoLibraryQueryEnum.MY_VIEWED_VIDEOS),getDataUri(VideoLibraryQueryEnum.FILTERS),getActivity(),getLoaderManager());
  PresenterImpl presenter=new PresenterImpl(model,this,VideoLibraryUserActionEnum.values(),VideoLibraryQueryEnum.values());
  presenter.loadInitialQueries();
}",0.970183486238532
19051,"@Override public boolean readDataFromCursor(final Cursor cursor,final VideoLibraryQueryEnum query){
  LOGD(TAG,""String_Node_Str"");
switch (query) {
case VIDEOS:
    LOGD(TAG,""String_Node_Str"");
  if (cursor.moveToFirst()) {
    processVideos(cursor);
    markVideosAsViewed();
  }
return true;
case MY_VIEWED_VIDEOS:
LOGD(TAG,""String_Node_Str"");
if (cursor.moveToFirst()) {
Set<String> viewedVideoIds=new HashSet<>();
do {
viewedVideoIds.add(cursor.getString(cursor.getColumnIndex(ScheduleContract.MyViewedVideos.VIDEO_ID)));
}
 while (cursor.moveToNext());
if (!mViewedVideosIds.containsAll(viewedVideoIds)) {
mViewedVideosIds=viewedVideoIds;
markVideosAsViewed();
return true;
}
}
return false;
case FILTERS:
LOGD(TAG,""String_Node_Str"");
mYears=new ArrayList<>();
mTopics=new ArrayList<>();
if (cursor != null && cursor.moveToFirst()) {
do {
int year=cursor.getInt(cursor.getColumnIndex(ScheduleContract.Videos.VIDEO_YEAR));
String topic=cursor.getString(cursor.getColumnIndex(ScheduleContract.Videos.VIDEO_TOPIC));
if (!mYears.contains(year)) {
mYears.add(year);
}
if (!TextUtils.isEmpty(topic) && !mTopics.contains(topic)) {
mTopics.add(topic);
}
}
 while (cursor.moveToNext());
}
Collections.sort(mYears,new Comparator<Integer>(){
@Override public int compare(Integer a,Integer b){
return b.compareTo(a);
}
}
);
Collections.sort(mTopics);
return true;
case TAGS:
mTagMetadata=new TagMetadata(cursor);
addImageUrlToVideoTracksIfAvailable();
return true;
default :
return false;
}
}","@Override public boolean readDataFromCursor(final Cursor cursor,final VideoLibraryQueryEnum query){
  LOGD(TAG,""String_Node_Str"");
switch (query) {
case VIDEOS:
    LOGD(TAG,""String_Node_Str"");
  if (cursor.moveToFirst()) {
    processVideos(cursor);
    markVideosAsViewed();
  }
return true;
case MY_VIEWED_VIDEOS:
LOGD(TAG,""String_Node_Str"");
mViewedVideosIds.clear();
if (cursor.moveToFirst()) {
do {
mViewedVideosIds.add(cursor.getString(cursor.getColumnIndex(ScheduleContract.MyViewedVideos.VIDEO_ID)));
}
 while (cursor.moveToNext());
markVideosAsViewed();
return true;
}
return true;
case FILTERS:
LOGD(TAG,""String_Node_Str"");
mYears=new ArrayList<>();
mTopics=new ArrayList<>();
if (cursor != null && cursor.moveToFirst()) {
do {
int year=cursor.getInt(cursor.getColumnIndex(ScheduleContract.Videos.VIDEO_YEAR));
String topic=cursor.getString(cursor.getColumnIndex(ScheduleContract.Videos.VIDEO_TOPIC));
if (!mYears.contains(year)) {
mYears.add(year);
}
if (!TextUtils.isEmpty(topic) && !mTopics.contains(topic)) {
mTopics.add(topic);
}
}
 while (cursor.moveToNext());
}
Collections.sort(mYears,new Comparator<Integer>(){
@Override public int compare(Integer a,Integer b){
return b.compareTo(a);
}
}
);
Collections.sort(mTopics);
return true;
case TAGS:
mTagMetadata=new TagMetadata(cursor);
addImageUrlToVideoTracksIfAvailable();
return true;
default :
return false;
}
}",0.924258289703316
19052,"@Override public void onClick(final View v){
  final ViewGroup.LayoutParams lp=v.getLayoutParams();
  if (!(lp instanceof RecyclerView.LayoutParams))   return;
  final int position=((RecyclerView.LayoutParams)lp).getViewAdapterPosition();
  if (position == RecyclerView.NO_POSITION)   return;
  final Video video=(Video)mItems.get(position);
  final String videoId=video.getId();
  final String youtubeLink=TextUtils.isEmpty(videoId) ? ""String_Node_Str"" : videoId.contains(""String_Node_Str"") ? videoId : String.format(Locale.US,Config.VIDEO_LIBRARY_URL_FMT,videoId);
  if (!TextUtils.isEmpty(youtubeLink)) {
    AnalyticsHelper.sendEvent(VIDEO_LIBRARY_ANALYTICS_CATEGORY,""String_Node_Str"",youtubeLink);
    Intent i=new Intent(Intent.ACTION_VIEW,Uri.parse(youtubeLink));
    UIUtils.preferPackageForIntent(mHost,i,UIUtils.YOUTUBE_PACKAGE_NAME);
    i.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
    mHost.startActivity(i);
    fireVideoPlayedEvent(video);
  }
}","@Override public void onClick(final View v){
  final ViewGroup.LayoutParams lp=v.getLayoutParams();
  if (!(lp instanceof RecyclerView.LayoutParams)) {
    return;
  }
  final int position=((RecyclerView.LayoutParams)lp).getViewAdapterPosition();
  if (position == RecyclerView.NO_POSITION) {
    return;
  }
  final Video video=(Video)mItems.get(position);
  final String videoId=video.getId();
  final String youtubeLink=TextUtils.isEmpty(videoId) ? ""String_Node_Str"" : videoId.contains(""String_Node_Str"") ? videoId : String.format(Locale.US,Config.VIDEO_LIBRARY_URL_FMT,videoId);
  if (!TextUtils.isEmpty(youtubeLink)) {
    AnalyticsHelper.sendEvent(VIDEO_LIBRARY_ANALYTICS_CATEGORY,""String_Node_Str"",youtubeLink);
    Intent i=new Intent(Intent.ACTION_VIEW,Uri.parse(youtubeLink));
    UIUtils.preferPackageForIntent(mHost,i,UIUtils.YOUTUBE_PACKAGE_NAME);
    i.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
    mHost.startActivity(i);
    fireVideoPlayedEvent(video);
  }
}",0.9734422880490295
19053,"@Override public void update(@NonNull final List<Video> updatedData){
  final List newItems=processData(updatedData);
  if (newItems.size() != mItems.size()) {
    mItems=newItems;
    notifyDataSetChanged();
    return;
  }
  for (int i=0; i < newItems.size(); i++) {
    final Object oldItem=mItems.get(i);
    final Object newItem=newItems.get(i);
    if (!oldItem.equals(newItem)) {
      mItems.set(i,newItem);
      notifyItemChanged(i);
    }
  }
}","@Override public void update(@NonNull final List<Video> updatedData){
  final List newItems=processData(updatedData);
  if (newItems.size() != mItems.size()) {
    mItems=newItems;
    notifyDataSetChanged();
    return;
  }
  for (int i=0; i < newItems.size(); i++) {
    final Object oldItem=mItems.get(i);
    final Object newItem=newItems.get(i);
    if (!oldItem.equals(newItem) || (newItem instanceof Video && ((Video)newItem).dataUpdated())) {
      mItems.set(i,newItem);
      notifyItemChanged(i);
    }
  }
}",0.9342915811088296
19054,"/** 
 * Process the given   {@code vidoe} to create the list of items to be displayed bythe  {@link RecyclerView}. In detail mode, this means inserting date header objects to separate videos by year.
 */
private List processData(final List<Video> videos){
  List data=new ArrayList(videos.size());
  if (mCompactMode) {
    data.addAll(videos);
  }
 else {
    int currentYear=Integer.MAX_VALUE;
    for (    final Video video : videos) {
      if (video.getYear() < currentYear) {
        currentYear=video.getYear();
        data.add(new YearHeader(String.valueOf(currentYear)));
      }
      data.add(video);
    }
  }
  return data;
}","/** 
 * Process the given   {@code vidoe} to create the list of items to be displayed by the {@link RecyclerView}. In detail mode, this means inserting date header objects to separate videos by year.
 */
private List processData(final List<Video> videos){
  List data=new ArrayList(videos.size());
  if (mCompactMode) {
    data.addAll(videos);
  }
 else {
    int currentYear=Integer.MAX_VALUE;
    for (    final Video video : videos) {
      if (video.getYear() < currentYear) {
        currentYear=video.getYear();
        data.add(new YearHeader(String.valueOf(currentYear)));
      }
      data.add(video);
    }
  }
  return data;
}",0.9984350547730828
19055,"public void setAlreadyPlayed(boolean alreadyPlayed){
  mAlreadyPlayed=alreadyPlayed;
}","public void setAlreadyPlayed(boolean alreadyPlayed){
  if (mAlreadyPlayed != alreadyPlayed) {
    mDataUpdated=true;
  }
  mAlreadyPlayed=alreadyPlayed;
}",0.7166666666666667
19056,"@Override public void displayUserActionResult(final ExploreIOModel model,final ExploreIOUserActionEnum userAction,final boolean success){
}","@Override public void displayUserActionResult(final ExploreIOModel model,final ExploreIOUserActionEnum userAction,final boolean success){
switch (userAction) {
case RELOAD:
    displayData(model,ExploreIOQueryEnum.SESSIONS);
  break;
}
}",0.7393617021276596
19057,"@Override public void onSharedPreferenceChanged(SharedPreferences sharedPreferences,String key){
  if (SettingsUtils.PREF_DECLINED_WIFI_SETUP.equals(key)) {
    fireReloadEvent();
  }
}","@Override public void onSharedPreferenceChanged(SharedPreferences sharedPreferences,String key){
  if (SettingsUtils.PREF_DECLINED_WIFI_SETUP.equals(key)) {
    fireReloadEvent();
  }
 else   if (AccountUtils.PREF_ACTIVE_ACCOUNT.equals(key)) {
    fireReloadEvent();
  }
}",0.8096280087527352
19058,"private void updateTimeBasedUi(SessionDetailModel data){
  mLiveStreamedIndicator.setVisibility((data.hasLiveStream() && !data.hasSessionEnded()) ? View.VISIBLE : View.GONE);
  if (data.showLiveStream()) {
    mWatchVideo.setVisibility(View.VISIBLE);
    if (data.hasSessionEnded()) {
      mWatchVideo.setText(getString(R.string.session_watch));
    }
 else {
      mWatchVideo.setText(getString(R.string.session_watch_live));
    }
    mWatchVideo.setVisibility(View.GONE);
  }
  if (data.isSessionReadyForFeedback()) {
    mShowFab=false;
    mAddScheduleFab.setVisibility(View.GONE);
    if (!data.hasFeedback() && data.isInScheduleWhenSessionFirstLoaded() && !sDismissedFeedbackCard.contains(data.getSessionId())) {
      showGiveFeedbackCard(data);
    }
  }
  String timeHint=""String_Node_Str"";
  if (TimeUtils.hasConferenceEnded(getContext())) {
    timeHint=""String_Node_Str"";
  }
 else   if (data.hasSessionEnded()) {
    timeHint=getString(R.string.time_hint_session_ended);
  }
 else   if (data.isSessionOngoing()) {
    long minutesAgo=data.minutesSinceSessionStarted();
    if (minutesAgo > 1) {
      timeHint=getString(R.string.time_hint_started_min,minutesAgo);
    }
 else {
      timeHint=getString(R.string.time_hint_started_just);
    }
  }
 else {
    long minutesUntilStart=data.minutesUntilSessionStarts();
    if (minutesUntilStart > 0 && minutesUntilStart <= SessionDetailConstants.HINT_TIME_BEFORE_SESSION_MIN) {
      if (minutesUntilStart > 1) {
        timeHint=getString(R.string.time_hint_about_to_start_min,minutesUntilStart);
      }
 else {
        timeHint=getString(R.string.time_hint_about_to_start_shortly,minutesUntilStart);
      }
    }
  }
  final TextView timeHintView=(TextView)getActivity().findViewById(R.id.time_hint);
  if (!TextUtils.isEmpty(timeHint)) {
    timeHintView.setVisibility(View.VISIBLE);
    timeHintView.setText(timeHint);
  }
 else {
    timeHintView.setVisibility(View.GONE);
  }
}","private void updateTimeBasedUi(SessionDetailModel data){
  mLiveStreamedIndicator.setVisibility((data.hasLiveStream() && !data.hasSessionEnded()) ? View.VISIBLE : View.GONE);
  if (data.showLiveStream()) {
    mWatchVideo.setVisibility(View.VISIBLE);
    if (data.hasSessionEnded()) {
      mWatchVideo.setText(getString(R.string.session_watch));
    }
 else {
      mWatchVideo.setText(getString(R.string.session_watch_live));
    }
  }
 else {
    mWatchVideo.setVisibility(View.GONE);
  }
  if (data.isSessionReadyForFeedback()) {
    mShowFab=false;
    mAddScheduleFab.setVisibility(View.GONE);
    if (!data.hasFeedback() && data.isInScheduleWhenSessionFirstLoaded() && !sDismissedFeedbackCard.contains(data.getSessionId())) {
      showGiveFeedbackCard(data);
    }
  }
  String timeHint=""String_Node_Str"";
  if (TimeUtils.hasConferenceEnded(getContext())) {
    timeHint=""String_Node_Str"";
  }
 else   if (data.hasSessionEnded()) {
    timeHint=getString(R.string.time_hint_session_ended);
  }
 else   if (data.isSessionOngoing()) {
    long minutesAgo=data.minutesSinceSessionStarted();
    if (minutesAgo > 1) {
      timeHint=getString(R.string.time_hint_started_min,minutesAgo);
    }
 else {
      timeHint=getString(R.string.time_hint_started_just);
    }
  }
 else {
    long minutesUntilStart=data.minutesUntilSessionStarts();
    if (minutesUntilStart > 0 && minutesUntilStart <= SessionDetailConstants.HINT_TIME_BEFORE_SESSION_MIN) {
      if (minutesUntilStart > 1) {
        timeHint=getString(R.string.time_hint_about_to_start_min,minutesUntilStart);
      }
 else {
        timeHint=getString(R.string.time_hint_about_to_start_shortly,minutesUntilStart);
      }
    }
  }
  final TextView timeHintView=(TextView)getActivity().findViewById(R.id.time_hint);
  if (!TextUtils.isEmpty(timeHint)) {
    timeHintView.setVisibility(View.VISIBLE);
    timeHintView.setText(timeHint);
  }
 else {
    timeHintView.setVisibility(View.GONE);
  }
}",0.9969278033794164
19059,"private void updateTimeBasedUi(SessionDetailModel data){
  mLiveStreamedIndicator.setVisibility((data.hasLiveStream() && !data.hasSessionEnded()) ? View.VISIBLE : View.GONE);
  if (data.showLiveStream()) {
    mWatchVideo.setVisibility(View.VISIBLE);
    if (data.hasSessionEnded()) {
      mWatchVideo.setText(getString(R.string.session_watch));
    }
 else {
      mWatchVideo.setText(getString(R.string.session_watch_live));
    }
    mWatchVideo.setVisibility(View.GONE);
  }
  if (data.isSessionReadyForFeedback()) {
    mShowFab=false;
    mAddScheduleFab.setVisibility(View.GONE);
    if (!data.hasFeedback() && data.isInScheduleWhenSessionFirstLoaded() && !sDismissedFeedbackCard.contains(data.getSessionId())) {
      showGiveFeedbackCard(data);
    }
  }
  String timeHint=""String_Node_Str"";
  if (TimeUtils.hasConferenceEnded(getContext())) {
    timeHint=""String_Node_Str"";
  }
 else   if (data.hasSessionEnded()) {
    timeHint=getString(R.string.time_hint_session_ended);
  }
 else   if (data.isSessionOngoing()) {
    long minutesAgo=data.minutesSinceSessionStarted();
    if (minutesAgo > 1) {
      timeHint=getString(R.string.time_hint_started_min,minutesAgo);
    }
 else {
      timeHint=getString(R.string.time_hint_started_just);
    }
  }
 else {
    long minutesUntilStart=data.minutesUntilSessionStarts();
    if (minutesUntilStart > 0 && minutesUntilStart <= SessionDetailConstants.HINT_TIME_BEFORE_SESSION_MIN) {
      if (minutesUntilStart > 1) {
        timeHint=getString(R.string.time_hint_about_to_start_min,minutesUntilStart);
      }
 else {
        timeHint=getString(R.string.time_hint_about_to_start_shortly,minutesUntilStart);
      }
    }
  }
  final TextView timeHintView=(TextView)getActivity().findViewById(R.id.time_hint);
  if (!TextUtils.isEmpty(timeHint)) {
    timeHintView.setVisibility(View.VISIBLE);
    timeHintView.setText(timeHint);
  }
 else {
    timeHintView.setVisibility(View.GONE);
  }
}","private void updateTimeBasedUi(SessionDetailModel data){
  mLiveStreamedIndicator.setVisibility((data.hasLiveStream() && !data.hasSessionEnded()) ? View.VISIBLE : View.GONE);
  if (data.showLiveStream()) {
    mWatchVideo.setVisibility(View.VISIBLE);
    if (data.hasSessionEnded()) {
      mWatchVideo.setText(getString(R.string.session_watch));
    }
 else {
      mWatchVideo.setText(getString(R.string.session_watch_live));
    }
  }
 else {
    mWatchVideo.setVisibility(View.GONE);
  }
  if (data.isSessionReadyForFeedback()) {
    mShowFab=false;
    mAddScheduleFab.setVisibility(View.GONE);
    if (!data.hasFeedback() && data.isInScheduleWhenSessionFirstLoaded() && !sDismissedFeedbackCard.contains(data.getSessionId())) {
      showGiveFeedbackCard(data);
    }
  }
  String timeHint=""String_Node_Str"";
  if (TimeUtils.hasConferenceEnded(getContext())) {
    timeHint=""String_Node_Str"";
  }
 else   if (data.hasSessionEnded()) {
    timeHint=getString(R.string.time_hint_session_ended);
  }
 else   if (data.isSessionOngoing()) {
    long minutesAgo=data.minutesSinceSessionStarted();
    if (minutesAgo > 1) {
      timeHint=getString(R.string.time_hint_started_min,minutesAgo);
    }
 else {
      timeHint=getString(R.string.time_hint_started_just);
    }
  }
 else {
    long minutesUntilStart=data.minutesUntilSessionStarts();
    if (minutesUntilStart > 0 && minutesUntilStart <= SessionDetailConstants.HINT_TIME_BEFORE_SESSION_MIN) {
      if (minutesUntilStart > 1) {
        timeHint=getString(R.string.time_hint_about_to_start_min,minutesUntilStart);
      }
 else {
        timeHint=getString(R.string.time_hint_about_to_start_shortly,minutesUntilStart);
      }
    }
  }
  final TextView timeHintView=(TextView)getActivity().findViewById(R.id.time_hint);
  if (!TextUtils.isEmpty(timeHint)) {
    timeHintView.setVisibility(View.VISIBLE);
    timeHintView.setText(timeHint);
  }
 else {
    timeHintView.setVisibility(View.GONE);
  }
}",0.9969278033794164
19060,"@Override public void onRequestPermissionsResult(final int requestCode,@NonNull final String[] permissions,@NonNull final int[] grantResults){
  LOGW(TAG,""String_Node_Str"" + grantResults.length + ""String_Node_Str""+ permissions.length);
  if (grantResults.length == APP_REQUIRED_PERMISSIONS.length && grantResults[0] == PackageManager.PERMISSION_GRANTED && grantResults[1] == PackageManager.PERMISSION_GRANTED) {
    Snackbar snackbar;
    if ((snackbar=mSnackbar.get()) != null && snackbar.isShown()) {
      snackbar.dismiss();
    }
    reloadAccounts();
    refreshAccountListUI();
  }
 else {
    LOGI(TAG,""String_Node_Str"");
    mSnackbar=new WeakReference<>(PermissionsUtils.displayConditionalPermissionDenialSnackbar(getActivity(),R.string.welcome_permissions_rationale,APP_REQUIRED_PERMISSIONS,REQUEST_PERMISSION_REQUEST_CODE));
  }
}","@Override public void onRequestPermissionsResult(final int requestCode,@NonNull final String[] permissions,@NonNull final int[] grantResults){
  LOGW(TAG,""String_Node_Str"" + grantResults.length + ""String_Node_Str""+ permissions.length);
  if (grantResults.length == APP_REQUIRED_PERMISSIONS.length && grantResults[0] == PackageManager.PERMISSION_GRANTED && grantResults[1] == PackageManager.PERMISSION_GRANTED) {
    clearSnackbar();
    reloadAccounts();
    refreshAccountListUI();
  }
 else {
    LOGI(TAG,""String_Node_Str"");
    mSnackbar=new WeakReference<>(PermissionsUtils.displayConditionalPermissionDenialSnackbar(getActivity(),R.string.welcome_permissions_rationale,APP_REQUIRED_PERMISSIONS,REQUEST_PERMISSION_REQUEST_CODE));
  }
}",0.9266750948166876
19061,"@Override public void onResume(){
  super.onResume();
  if (!displayPermissionRequest(getActivity(),false)) {
    reloadAccounts();
    refreshAccountListUI();
  }
}","@Override public void onResume(){
  super.onResume();
  clearSnackbar();
  if (!displayPermissionRequest(getActivity(),false)) {
    reloadAccounts();
    refreshAccountListUI();
  }
}",0.9455587392550144
19062,"@Override public View onCreateView(LayoutInflater inflater,final ViewGroup container,Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  ViewGroup rootView=(ViewGroup)inflater.inflate(R.layout.debug_frag,null);
  mLogArea=(TextView)rootView.findViewById(R.id.logArea);
  ViewGroup tests=(ViewGroup)rootView.findViewById(R.id.debug_action_list);
  tests.addView(createTestAction(new ForceSyncNowAction()));
  tests.addView(createTestAction(new DisplayUserDataDebugAction()));
  tests.addView(createTestAction(new ShowAllDriveFilesDebugAction()));
  tests.addView(createTestAction(new ForceAppDataSyncNowAction()));
  tests.addView(createTestAction(new TestScheduleHelperAction()));
  tests.addView(createTestAction(new ScheduleStarredSessionAlarmsAction()));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    final Context context,    final Callback callback){
      final String sessionId=SessionAlarmService.DEBUG_SESSION_ID;
      final String sessionTitle=""String_Node_Str"";
      Intent intent=new Intent(SessionAlarmService.ACTION_NOTIFY_SESSION_FEEDBACK,null,context,SessionAlarmService.class);
      intent.putExtra(SessionAlarmService.EXTRA_SESSION_ID,sessionId);
      intent.putExtra(SessionAlarmService.EXTRA_SESSION_START,System.currentTimeMillis() - 30 * 60 * 1000);
      intent.putExtra(SessionAlarmService.EXTRA_SESSION_END,System.currentTimeMillis());
      intent.putExtra(SessionAlarmService.EXTRA_SESSION_TITLE,sessionTitle);
      context.startService(intent);
      Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_LONG).show();
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  tests.addView(createTestAction(new ShowSessionNotificationDebugAction()));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    Context context,    Callback callback){
      context.startActivity(new Intent(context,WelcomeActivity.class));
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    Context context,    Callback callback){
      SettingsUtils.markTosAccepted(context,false);
      SettingsUtils.markConductAccepted(context,false);
      SettingsUtils.setAttendeeAtVenue(context,false);
      SettingsUtils.markAnsweredLocalOrRemote(context,false);
      AccountUtils.setActiveAccount(context,null);
      ConfMessageCardUtils.unsetStateForAllCards(context);
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    Context context,    Callback callback){
      Intent intent=new Intent(context,ExploreSessionsActivity.class);
      intent.putExtra(ExploreSessionsActivity.EXTRA_FILTER_TAG,""String_Node_Str"");
      context.startActivity(intent);
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    Context context,    Callback callback){
      LOGW(TAG,""String_Node_Str"");
      ConfMessageCardUtils.markAnsweredConfMessageCardsPrompt(context,null);
      ConfMessageCardUtils.setConfMessageCardsEnabled(context,null);
      ConfMessageCardUtils.unsetStateForAllCards(context);
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    Context context,    Callback callback){
      TimeUtils.setCurrentTimeRelativeToStartOfConference(context,-TimeUtils.HOUR * 3);
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    Context context,    Callback callback){
      TimeUtils.setCurrentTimeRelativeToStartOfConference(context,-TimeUtils.DAY);
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    Context context,    Callback callback){
      TimeUtils.setCurrentTimeRelativeToStartOfConference(context,TimeUtils.HOUR * 3);
      LOGW(TAG,""String_Node_Str"");
      ConfMessageCardUtils.markAnsweredConfMessageCardsPrompt(context,null);
      ConfMessageCardUtils.setConfMessageCardsEnabled(context,null);
      SettingsUtils.markDeclinedWifiSetup(context,false);
      WiFiUtils.uninstallConferenceWiFi(context);
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    Context context,    Callback callback){
      TimeUtils.setCurrentTimeRelativeToStartOfSecondDayOfConference(context,TimeUtils.HOUR * 3);
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    Context context,    Callback callback){
      TimeUtils.setCurrentTimeRelativeToEndOfConference(context,TimeUtils.HOUR * 3);
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    Context context,    Callback callback){
      ConfMessageCardUtils.markShouldShowConfMessageCard(context,ConfMessageCardUtils.ConfMessageCard.CONFERENCE_CREDENTIALS,true);
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    Context context,    Callback callback){
      ConfMessageCardUtils.markShouldShowConfMessageCard(context,ConfMessageCardUtils.ConfMessageCard.KEYNOTE_ACCESS,true);
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    Context context,    Callback callback){
      ConfMessageCardUtils.markShouldShowConfMessageCard(context,ConfMessageCardUtils.ConfMessageCard.AFTER_HOURS,true);
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  return rootView;
}","@Override public View onCreateView(LayoutInflater inflater,final ViewGroup container,Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  ViewGroup rootView=(ViewGroup)inflater.inflate(R.layout.debug_frag,null);
  mLogArea=(TextView)rootView.findViewById(R.id.logArea);
  ViewGroup tests=(ViewGroup)rootView.findViewById(R.id.debug_action_list);
  tests.addView(createTestAction(new ForceSyncNowAction()));
  tests.addView(createTestAction(new DisplayUserDataDebugAction()));
  tests.addView(createTestAction(new ShowAllDriveFilesDebugAction()));
  tests.addView(createTestAction(new ForceAppDataSyncNowAction()));
  tests.addView(createTestAction(new TestScheduleHelperAction()));
  tests.addView(createTestAction(new ScheduleStarredSessionAlarmsAction()));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    final Context context,    final Callback callback){
      final String sessionId=SessionAlarmService.DEBUG_SESSION_ID;
      final String sessionTitle=""String_Node_Str"";
      Intent intent=new Intent(SessionAlarmService.ACTION_NOTIFY_SESSION_FEEDBACK,null,context,SessionAlarmService.class);
      intent.putExtra(SessionAlarmService.EXTRA_SESSION_ID,sessionId);
      intent.putExtra(SessionAlarmService.EXTRA_SESSION_START,System.currentTimeMillis() - 30 * 60 * 1000);
      intent.putExtra(SessionAlarmService.EXTRA_SESSION_END,System.currentTimeMillis());
      intent.putExtra(SessionAlarmService.EXTRA_SESSION_TITLE,sessionTitle);
      context.startService(intent);
      Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_LONG).show();
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  tests.addView(createTestAction(new ShowSessionNotificationDebugAction()));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    Context context,    Callback callback){
      SettingsUtils.markTosAccepted(context,false);
      SettingsUtils.markConductAccepted(context,false);
      SettingsUtils.setAttendeeAtVenue(context,false);
      SettingsUtils.markAnsweredLocalOrRemote(context,false);
      AccountUtils.setActiveAccount(context,null);
      context.startActivity(new Intent(context,WelcomeActivity.class));
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    Context context,    Callback callback){
      SettingsUtils.markTosAccepted(context,false);
      SettingsUtils.markConductAccepted(context,false);
      SettingsUtils.setAttendeeAtVenue(context,false);
      SettingsUtils.markAnsweredLocalOrRemote(context,false);
      AccountUtils.setActiveAccount(context,null);
      ConfMessageCardUtils.unsetStateForAllCards(context);
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    Context context,    Callback callback){
      Intent intent=new Intent(context,ExploreSessionsActivity.class);
      intent.putExtra(ExploreSessionsActivity.EXTRA_FILTER_TAG,""String_Node_Str"");
      context.startActivity(intent);
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    Context context,    Callback callback){
      LOGW(TAG,""String_Node_Str"");
      ConfMessageCardUtils.markAnsweredConfMessageCardsPrompt(context,null);
      ConfMessageCardUtils.setConfMessageCardsEnabled(context,null);
      ConfMessageCardUtils.unsetStateForAllCards(context);
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    Context context,    Callback callback){
      TimeUtils.setCurrentTimeRelativeToStartOfConference(context,-TimeUtils.HOUR * 3);
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    Context context,    Callback callback){
      TimeUtils.setCurrentTimeRelativeToStartOfConference(context,-TimeUtils.DAY);
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    Context context,    Callback callback){
      TimeUtils.setCurrentTimeRelativeToStartOfConference(context,TimeUtils.HOUR * 3);
      LOGW(TAG,""String_Node_Str"");
      ConfMessageCardUtils.markAnsweredConfMessageCardsPrompt(context,null);
      ConfMessageCardUtils.setConfMessageCardsEnabled(context,null);
      SettingsUtils.markDeclinedWifiSetup(context,false);
      WiFiUtils.uninstallConferenceWiFi(context);
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    Context context,    Callback callback){
      TimeUtils.setCurrentTimeRelativeToStartOfSecondDayOfConference(context,TimeUtils.HOUR * 3);
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    Context context,    Callback callback){
      TimeUtils.setCurrentTimeRelativeToEndOfConference(context,TimeUtils.HOUR * 3);
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    Context context,    Callback callback){
      ConfMessageCardUtils.markShouldShowConfMessageCard(context,ConfMessageCardUtils.ConfMessageCard.CONFERENCE_CREDENTIALS,true);
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    Context context,    Callback callback){
      ConfMessageCardUtils.markShouldShowConfMessageCard(context,ConfMessageCardUtils.ConfMessageCard.KEYNOTE_ACCESS,true);
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    Context context,    Callback callback){
      ConfMessageCardUtils.markShouldShowConfMessageCard(context,ConfMessageCardUtils.ConfMessageCard.AFTER_HOURS,true);
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  return rootView;
}",0.978756157635468
19063,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_welcome);
  mContentFragment=getCurrentFragment(this);
  if (mContentFragment == null) {
    finish();
  }
  FragmentTransaction fragmentTransaction=getFragmentManager().beginTransaction();
  fragmentTransaction.add(R.id.welcome_content,(Fragment)mContentFragment);
  fragmentTransaction.commit();
  final ImageView iv=(ImageView)findViewById(R.id.logo);
  final AnimatedVectorDrawableCompat logo=AnimatedVectorDrawableCompat.create(this,R.drawable.avd_hash_io_16);
  if (iv != null && logo != null) {
    iv.setImageDrawable(logo);
    if (UIUtils.animationEnabled(getContentResolver())) {
      logo.start();
    }
  }
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_welcome);
  mContentFragment=getCurrentFragment(this);
  if (mContentFragment == null) {
    finish();
  }
 else {
    FragmentTransaction fragmentTransaction=getFragmentManager().beginTransaction();
    fragmentTransaction.add(R.id.welcome_content,(Fragment)mContentFragment);
    fragmentTransaction.commit();
    final ImageView iv=(ImageView)findViewById(R.id.logo);
    final AnimatedVectorDrawableCompat logo=AnimatedVectorDrawableCompat.create(this,R.drawable.avd_hash_io_16);
    if (iv != null && logo != null) {
      iv.setImageDrawable(logo);
      if (UIUtils.animationEnabled(getContentResolver())) {
        logo.start();
      }
    }
  }
}",0.959792477302205
19064,"@Override public View onCreateView(LayoutInflater inflater,final ViewGroup container,Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  ViewGroup rootView=(ViewGroup)inflater.inflate(R.layout.debug_frag,null);
  mLogArea=(TextView)rootView.findViewById(R.id.logArea);
  ViewGroup tests=(ViewGroup)rootView.findViewById(R.id.debug_action_list);
  tests.addView(createTestAction(new ForceSyncNowAction()));
  tests.addView(createTestAction(new DisplayUserDataDebugAction()));
  tests.addView(createTestAction(new ShowAllDriveFilesDebugAction()));
  tests.addView(createTestAction(new ForceAppDataSyncNowAction()));
  tests.addView(createTestAction(new TestScheduleHelperAction()));
  tests.addView(createTestAction(new ScheduleStarredSessionAlarmsAction()));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    final Context context,    final Callback callback){
      final String sessionId=SessionAlarmService.DEBUG_SESSION_ID;
      final String sessionTitle=""String_Node_Str"";
      Intent intent=new Intent(SessionAlarmService.ACTION_NOTIFY_SESSION_FEEDBACK,null,context,SessionAlarmService.class);
      intent.putExtra(SessionAlarmService.EXTRA_SESSION_ID,sessionId);
      intent.putExtra(SessionAlarmService.EXTRA_SESSION_START,System.currentTimeMillis() - 30 * 60 * 1000);
      intent.putExtra(SessionAlarmService.EXTRA_SESSION_END,System.currentTimeMillis());
      intent.putExtra(SessionAlarmService.EXTRA_SESSION_TITLE,sessionTitle);
      context.startService(intent);
      Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_LONG).show();
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  tests.addView(createTestAction(new ShowSessionNotificationDebugAction()));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    Context context,    Callback callback){
      context.startActivity(new Intent(context,WelcomeActivity.class));
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    Context context,    Callback callback){
      SettingsUtils.markTosAccepted(context,false);
      SettingsUtils.markConductAccepted(context,false);
      SettingsUtils.setAttendeeAtVenue(context,false);
      SettingsUtils.markAnsweredLocalOrRemote(context,false);
      AccountUtils.setActiveAccount(context,null);
      ConfMessageCardUtils.unsetStateForAllCards(context);
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    Context context,    Callback callback){
      Intent intent=new Intent(context,ExploreSessionsActivity.class);
      intent.putExtra(ExploreSessionsActivity.EXTRA_FILTER_TAG,""String_Node_Str"");
      context.startActivity(intent);
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    Context context,    Callback callback){
      LOGW(TAG,""String_Node_Str"");
      ConfMessageCardUtils.markAnsweredConfMessageCardsPrompt(context,null);
      ConfMessageCardUtils.setConfMessageCardsEnabled(context,null);
      ConfMessageCardUtils.unsetStateForAllCards(context);
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    Context context,    Callback callback){
      TimeUtils.setCurrentTimeRelativeToStartOfConference(context,-TimeUtils.HOUR * 3);
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    Context context,    Callback callback){
      TimeUtils.setCurrentTimeRelativeToStartOfConference(context,-TimeUtils.DAY);
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    Context context,    Callback callback){
      TimeUtils.setCurrentTimeRelativeToStartOfConference(context,TimeUtils.HOUR * 3);
      LOGW(TAG,""String_Node_Str"");
      ConfMessageCardUtils.markAnsweredConfMessageCardsPrompt(context,null);
      ConfMessageCardUtils.setConfMessageCardsEnabled(context,null);
      SettingsUtils.markDeclinedWifiSetup(context,false);
      WiFiUtils.uninstallConferenceWiFi(context);
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    Context context,    Callback callback){
      TimeUtils.setCurrentTimeRelativeToStartOfSecondDayOfConference(context,TimeUtils.HOUR * 3);
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    Context context,    Callback callback){
      TimeUtils.setCurrentTimeRelativeToEndOfConference(context,TimeUtils.HOUR * 3);
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    Context context,    Callback callback){
      ConfMessageCardUtils.markShouldShowConfMessageCard(context,ConfMessageCardUtils.ConfMessageCard.CONFERENCE_CREDENTIALS,true);
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    Context context,    Callback callback){
      ConfMessageCardUtils.markShouldShowConfMessageCard(context,ConfMessageCardUtils.ConfMessageCard.KEYNOTE_ACCESS,true);
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    Context context,    Callback callback){
      ConfMessageCardUtils.markShouldShowConfMessageCard(context,ConfMessageCardUtils.ConfMessageCard.AFTER_HOURS,true);
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  return rootView;
}","@Override public View onCreateView(LayoutInflater inflater,final ViewGroup container,Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  ViewGroup rootView=(ViewGroup)inflater.inflate(R.layout.debug_frag,null);
  mLogArea=(TextView)rootView.findViewById(R.id.logArea);
  ViewGroup tests=(ViewGroup)rootView.findViewById(R.id.debug_action_list);
  tests.addView(createTestAction(new ForceSyncNowAction()));
  tests.addView(createTestAction(new DisplayUserDataDebugAction()));
  tests.addView(createTestAction(new ShowAllDriveFilesDebugAction()));
  tests.addView(createTestAction(new ForceAppDataSyncNowAction()));
  tests.addView(createTestAction(new TestScheduleHelperAction()));
  tests.addView(createTestAction(new ScheduleStarredSessionAlarmsAction()));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    final Context context,    final Callback callback){
      final String sessionId=SessionAlarmService.DEBUG_SESSION_ID;
      final String sessionTitle=""String_Node_Str"";
      Intent intent=new Intent(SessionAlarmService.ACTION_NOTIFY_SESSION_FEEDBACK,null,context,SessionAlarmService.class);
      intent.putExtra(SessionAlarmService.EXTRA_SESSION_ID,sessionId);
      intent.putExtra(SessionAlarmService.EXTRA_SESSION_START,System.currentTimeMillis() - 30 * 60 * 1000);
      intent.putExtra(SessionAlarmService.EXTRA_SESSION_END,System.currentTimeMillis());
      intent.putExtra(SessionAlarmService.EXTRA_SESSION_TITLE,sessionTitle);
      context.startService(intent);
      Toast.makeText(context,""String_Node_Str"",Toast.LENGTH_LONG).show();
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  tests.addView(createTestAction(new ShowSessionNotificationDebugAction()));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    Context context,    Callback callback){
      SettingsUtils.markTosAccepted(context,false);
      SettingsUtils.markConductAccepted(context,false);
      SettingsUtils.setAttendeeAtVenue(context,false);
      SettingsUtils.markAnsweredLocalOrRemote(context,false);
      AccountUtils.setActiveAccount(context,null);
      context.startActivity(new Intent(context,WelcomeActivity.class));
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    Context context,    Callback callback){
      SettingsUtils.markTosAccepted(context,false);
      SettingsUtils.markConductAccepted(context,false);
      SettingsUtils.setAttendeeAtVenue(context,false);
      SettingsUtils.markAnsweredLocalOrRemote(context,false);
      AccountUtils.setActiveAccount(context,null);
      ConfMessageCardUtils.unsetStateForAllCards(context);
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    Context context,    Callback callback){
      Intent intent=new Intent(context,ExploreSessionsActivity.class);
      intent.putExtra(ExploreSessionsActivity.EXTRA_FILTER_TAG,""String_Node_Str"");
      context.startActivity(intent);
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    Context context,    Callback callback){
      LOGW(TAG,""String_Node_Str"");
      ConfMessageCardUtils.markAnsweredConfMessageCardsPrompt(context,null);
      ConfMessageCardUtils.setConfMessageCardsEnabled(context,null);
      ConfMessageCardUtils.unsetStateForAllCards(context);
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    Context context,    Callback callback){
      TimeUtils.setCurrentTimeRelativeToStartOfConference(context,-TimeUtils.HOUR * 3);
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    Context context,    Callback callback){
      TimeUtils.setCurrentTimeRelativeToStartOfConference(context,-TimeUtils.DAY);
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    Context context,    Callback callback){
      TimeUtils.setCurrentTimeRelativeToStartOfConference(context,TimeUtils.HOUR * 3);
      LOGW(TAG,""String_Node_Str"");
      ConfMessageCardUtils.markAnsweredConfMessageCardsPrompt(context,null);
      ConfMessageCardUtils.setConfMessageCardsEnabled(context,null);
      SettingsUtils.markDeclinedWifiSetup(context,false);
      WiFiUtils.uninstallConferenceWiFi(context);
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    Context context,    Callback callback){
      TimeUtils.setCurrentTimeRelativeToStartOfSecondDayOfConference(context,TimeUtils.HOUR * 3);
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    Context context,    Callback callback){
      TimeUtils.setCurrentTimeRelativeToEndOfConference(context,TimeUtils.HOUR * 3);
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    Context context,    Callback callback){
      ConfMessageCardUtils.markShouldShowConfMessageCard(context,ConfMessageCardUtils.ConfMessageCard.CONFERENCE_CREDENTIALS,true);
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    Context context,    Callback callback){
      ConfMessageCardUtils.markShouldShowConfMessageCard(context,ConfMessageCardUtils.ConfMessageCard.KEYNOTE_ACCESS,true);
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  tests.addView(createTestAction(new DebugAction(){
    @Override public void run(    Context context,    Callback callback){
      ConfMessageCardUtils.markShouldShowConfMessageCard(context,ConfMessageCardUtils.ConfMessageCard.AFTER_HOURS,true);
    }
    @Override public String getLabel(){
      return ""String_Node_Str"";
    }
  }
));
  return rootView;
}",0.978756157635468
19065,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_welcome);
  mContentFragment=getCurrentFragment(this);
  if (mContentFragment == null) {
    finish();
  }
  FragmentTransaction fragmentTransaction=getFragmentManager().beginTransaction();
  fragmentTransaction.add(R.id.welcome_content,(Fragment)mContentFragment);
  fragmentTransaction.commit();
  final ImageView iv=(ImageView)findViewById(R.id.logo);
  final AnimatedVectorDrawableCompat logo=AnimatedVectorDrawableCompat.create(this,R.drawable.avd_hash_io_16);
  if (iv != null && logo != null) {
    iv.setImageDrawable(logo);
    if (UIUtils.animationEnabled(getContentResolver())) {
      logo.start();
    }
  }
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_welcome);
  mContentFragment=getCurrentFragment(this);
  if (mContentFragment == null) {
    finish();
  }
 else {
    FragmentTransaction fragmentTransaction=getFragmentManager().beginTransaction();
    fragmentTransaction.add(R.id.welcome_content,(Fragment)mContentFragment);
    fragmentTransaction.commit();
    final ImageView iv=(ImageView)findViewById(R.id.logo);
    final AnimatedVectorDrawableCompat logo=AnimatedVectorDrawableCompat.create(this,R.drawable.avd_hash_io_16);
    if (iv != null && logo != null) {
      iv.setImageDrawable(logo);
      if (UIUtils.animationEnabled(getContentResolver())) {
        logo.start();
      }
    }
  }
}",0.959792477302205
19066,"@Override public void onRequestPermissionsResult(final int requestCode,@NonNull final String[] permissions,@NonNull final int[] grantResults){
  LOGW(TAG,""String_Node_Str"" + grantResults.length + ""String_Node_Str""+ permissions.length);
  if (grantResults.length == APP_REQUIRED_PERMISSIONS.length && grantResults[0] == PackageManager.PERMISSION_GRANTED && grantResults[1] == PackageManager.PERMISSION_GRANTED) {
    Snackbar snackbar;
    if ((snackbar=mSnackbar.get()) != null && snackbar.isShown()) {
      snackbar.dismiss();
    }
    reloadAccounts();
    refreshAccountListUI();
  }
 else {
    LOGI(TAG,""String_Node_Str"");
    mSnackbar=new WeakReference<>(PermissionsUtils.displayConditionalPermissionDenialSnackbar(getActivity(),R.string.welcome_permissions_rationale,APP_REQUIRED_PERMISSIONS,REQUEST_PERMISSION_REQUEST_CODE));
  }
}","@Override public void onRequestPermissionsResult(final int requestCode,@NonNull final String[] permissions,@NonNull final int[] grantResults){
  LOGW(TAG,""String_Node_Str"" + grantResults.length + ""String_Node_Str""+ permissions.length);
  if (grantResults.length == APP_REQUIRED_PERMISSIONS.length && grantResults[0] == PackageManager.PERMISSION_GRANTED && grantResults[1] == PackageManager.PERMISSION_GRANTED) {
    clearSnackbar();
    reloadAccounts();
    refreshAccountListUI();
  }
 else {
    LOGI(TAG,""String_Node_Str"");
    mSnackbar=new WeakReference<>(PermissionsUtils.displayConditionalPermissionDenialSnackbar(getActivity(),R.string.welcome_permissions_rationale,APP_REQUIRED_PERMISSIONS,REQUEST_PERMISSION_REQUEST_CODE));
  }
}",0.9266750948166876
19067,"@Override public void onResume(){
  super.onResume();
  if (!displayPermissionRequest(getActivity(),false)) {
    reloadAccounts();
    refreshAccountListUI();
  }
}","@Override public void onResume(){
  super.onResume();
  clearSnackbar();
  if (!displayPermissionRequest(getActivity(),false)) {
    reloadAccounts();
    refreshAccountListUI();
  }
}",0.9455587392550144
19068,"/** 
 * Set the activity title & header image. <p> If the user is browsing a single track then it's name is shown as the title and a relevant header image; otherwise a generic title and image is shown.
 */
private void setHeader(){
  if (mMode == MODE_EXPLORE && mTagMetadata != null) {
    String tag=getIntent().getStringExtra(EXTRA_FILTER_TAG);
    TagMetadata.Tag titleTag=tag == null ? null : mTagMetadata.getTag(tag);
    String title=null;
    String headerImage=null;
    int trackColor=0;
    if (titleTag != null && mTagFilterHolder.getCountByCategory(titleTag.getCategory()) == 1) {
      for (      String tagId : mTagFilterHolder.getSelectedFilters()) {
        TagMetadata.Tag theTag=mTagMetadata.getTag(tagId);
        if (TextUtils.equals(titleTag.getCategory(),theTag.getCategory())) {
          title=theTag.getName();
          headerImage=theTag.getPhotoUrl();
          trackColor=theTag.getColor();
          break;
        }
      }
    }
    if (title == null) {
      title=getString(R.string.title_explore);
    }
    mTitle.setText(title);
    if (headerImage != null) {
      mHeaderImage.setScaleType(ImageView.ScaleType.CENTER_CROP);
      mImageLoader.loadImage(headerImage,mHeaderImage);
    }
 else {
      mHeaderImage.setScaleType(ImageView.ScaleType.FIT_CENTER);
      mHeaderImage.setImageResource(R.drawable.ic_hash_io_16_monochrome);
    }
    final int statusBarColor=trackColor != 0 ? UIUtils.adjustColorForStatusBar(trackColor) : UIUtils.getThemeColor(this,R.attr.colorPrimaryDark,R.color.theme_primary_dark);
    mDrawerLayout.setStatusBarBackgroundColor(statusBarColor);
  }
}","/** 
 * Set the activity title & header image. <p/> If the user is browsing a single track then it's name is shown as the title and a relevant header image; otherwise a generic title and image is shown.
 */
private void setHeader(){
  if (mMode == MODE_EXPLORE && mTagMetadata != null) {
    String title=null;
    String headerImage=null;
    int trackColor=0;
    int selectedTracks=mTagFilterHolder.getCountByCategory(Config.Tags.CATEGORY_TRACK);
    int selectedThemes=mTagFilterHolder.getCountByCategory(Config.Tags.CATEGORY_THEME);
    if (selectedThemes + selectedTracks == 1) {
      for (      String tagId : mTagFilterHolder.getSelectedFilters()) {
        if (tagId.contains(Config.Tags.CATEGORY_TRACK) || tagId.contains(Config.Tags.CATEGORY_THEME)) {
          TagMetadata.Tag selectedTag=mTagMetadata.getTag(tagId);
          title=selectedTag.getName();
          headerImage=selectedTag.getPhotoUrl();
          trackColor=selectedTag.getColor();
          break;
        }
      }
    }
    if (title == null) {
      title=getString(R.string.title_explore);
    }
    mTitle.setText(title);
    if (headerImage != null) {
      mHeaderImage.setScaleType(ImageView.ScaleType.CENTER_CROP);
      mImageLoader.loadImage(headerImage,mHeaderImage);
    }
 else {
      mHeaderImage.setScaleType(ImageView.ScaleType.FIT_CENTER);
      mHeaderImage.setImageResource(R.drawable.ic_hash_io_16_monochrome);
    }
    final int statusBarColor=trackColor != 0 ? UIUtils.adjustColorForStatusBar(trackColor) : UIUtils.getThemeColor(this,R.attr.colorPrimaryDark,R.color.theme_primary_dark);
    mDrawerLayout.setStatusBarBackgroundColor(statusBarColor);
  }
}",0.725998171289241
19069,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.explore_sessions_act);
  mImageLoader=new ImageLoader(this);
  mDrawerLayout=(DrawerLayout)findViewById(R.id.drawer_layout);
  mHeaderImage=(ImageView)findViewById(R.id.header_image);
  mTitle=(TextView)findViewById(R.id.title);
  mFiltersList=(RecyclerView)findViewById(R.id.filters);
  mTimeSlotLayout=findViewById(R.id.timeslot_view);
  mTimeSlotDivider=findViewById(R.id.timeslot_divider);
  TextView timeSlotTextView=(TextView)findViewById(R.id.timeslot);
  ImageButton dismissTimeSlotButton=(ImageButton)findViewById(R.id.close_timeslot);
  mDrawerLayout.setDrawerShadow(R.drawable.drawer_shadow_flipped,GravityCompat.END);
  mFragment=(ExploreSessionsFragment)getFragmentManager().findFragmentById(R.id.explore_sessions_frag);
  if (savedInstanceState != null) {
    mTagFilterHolder=savedInstanceState.getParcelable(STATE_FILTER_TAGS);
    mCurrentUri=savedInstanceState.getParcelable(STATE_CURRENT_URI);
  }
 else   if (getIntent() != null) {
    mCurrentUri=getIntent().getData();
  }
  long[] interval=ScheduleContract.Sessions.getInterval(mCurrentUri);
  if (interval != null) {
    mMode=MODE_TIME_FIT;
    String title=getString(R.string.explore_sessions_time_slot_title,getString(R.string.explore_sessions_show_day_n,UIUtils.startTimeToDayIndex(interval[0])),UIUtils.formatTime(interval[0],this));
    setTitle(title);
    mTimeSlotLayout.setVisibility(View.VISIBLE);
    mTimeSlotDivider.setVisibility(View.VISIBLE);
    timeSlotTextView.setText(title);
    dismissTimeSlotButton.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        mTimeSlotLayout.setVisibility(View.GONE);
        mTimeSlotDivider.setVisibility(View.GONE);
        mMode=MODE_EXPLORE;
        mCurrentUri=null;
        reloadFragment();
      }
    }
);
  }
 else {
    mMode=MODE_EXPLORE;
  }
  Toolbar toolbar=getToolbar();
  toolbar.setNavigationIcon(R.drawable.ic_up);
  toolbar.setNavigationContentDescription(R.string.close_and_go_back);
  toolbar.setNavigationOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      navigateUpOrBack(ExploreSessionsActivity.this,null);
    }
  }
);
  getSupportActionBar().setDisplayShowTitleEnabled(false);
  getLoaderManager().initLoader(TAG_METADATA_TOKEN,null,this);
  AnalyticsHelper.sendScreenView(SCREEN_LABEL);
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.explore_sessions_act);
  mImageLoader=new ImageLoader(this);
  mDrawerLayout=(DrawerLayout)findViewById(R.id.drawer_layout);
  mHeaderImage=(ImageView)findViewById(R.id.header_image);
  mTitle=(TextView)findViewById(R.id.title);
  mFiltersList=(RecyclerView)findViewById(R.id.filters);
  mTimeSlotLayout=findViewById(R.id.timeslot_view);
  mTimeSlotDivider=findViewById(R.id.timeslot_divider);
  TextView timeSlotTextView=(TextView)findViewById(R.id.timeslot);
  ImageButton dismissTimeSlotButton=(ImageButton)findViewById(R.id.close_timeslot);
  mDrawerLayout.setDrawerShadow(R.drawable.drawer_shadow_flipped,GravityCompat.END);
  mFragment=(ExploreSessionsFragment)getFragmentManager().findFragmentById(R.id.explore_sessions_frag);
  if (savedInstanceState != null) {
    mTagFilterHolder=savedInstanceState.getParcelable(STATE_FILTER_TAGS);
    mCurrentUri=savedInstanceState.getParcelable(STATE_CURRENT_URI);
  }
 else   if (getIntent() != null) {
    mCurrentUri=getIntent().getData();
  }
  long[] interval=ScheduleContract.Sessions.getInterval(mCurrentUri);
  if (interval != null) {
    mMode=MODE_TIME_FIT;
    String title=getString(R.string.explore_sessions_time_slot_title,TimeUtils.getDayName(this,UIUtils.startTimeToDayIndex(interval[0])),UIUtils.formatTime(interval[0],this));
    mTitle.setText(title);
    mHeaderImage.setScaleType(ImageView.ScaleType.FIT_CENTER);
    mHeaderImage.setImageResource(R.drawable.ic_hash_io_16_monochrome);
    mTimeSlotLayout.setVisibility(View.VISIBLE);
    mTimeSlotDivider.setVisibility(View.VISIBLE);
    timeSlotTextView.setText(title);
    dismissTimeSlotButton.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        mTimeSlotLayout.setVisibility(View.GONE);
        mTimeSlotDivider.setVisibility(View.GONE);
        mMode=MODE_EXPLORE;
        mCurrentUri=null;
        reloadFragment();
      }
    }
);
  }
 else {
    mMode=MODE_EXPLORE;
  }
  Toolbar toolbar=getToolbar();
  toolbar.setNavigationIcon(R.drawable.ic_up);
  toolbar.setNavigationContentDescription(R.string.close_and_go_back);
  toolbar.setNavigationOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      navigateUpOrBack(ExploreSessionsActivity.this,null);
    }
  }
);
  getSupportActionBar().setDisplayShowTitleEnabled(false);
  getLoaderManager().initLoader(TAG_METADATA_TOKEN,null,this);
  AnalyticsHelper.sendScreenView(SCREEN_LABEL);
}",0.9532673267326732
19070,"@Override public String toString(){
  return ""String_Node_Str"" + mTagsById.size() + ""String_Node_Str""+ mTagsInCategory.size()+ ""String_Node_Str"";
}","@Override public String toString(){
  return ""String_Node_Str"" + mId + ""String_Node_Str""+ mName;
}",0.7836734693877551
19071,"/** 
 * Return whether this is a LiveStreamed session and whether it is happening right now.
 */
public boolean isLiveStreamNow(Context context){
  if (!isLiveStreamAvailable()) {
    return false;
  }
  if (mStartDate == null || mEndDate == null) {
    return false;
  }
  Calendar now=java.util.Calendar.getInstance();
  now.setTimeInMillis(TimeUtils.getCurrentTime(context));
  return mStartDate.before(now.getTime()) && mEndDate.after(now.getTime());
}","/** 
 * Return whether this is a LiveStreamed session and whether it is happening right now.
 */
public boolean isLiveStreamNow(Context context){
  if (!isLiveStreamAvailable()) {
    return false;
  }
  if (mStartDate == null || mEndDate == null) {
    return false;
  }
  Calendar now=java.util.Calendar.getInstance();
  now.setTimeInMillis(TimeUtils.getCurrentTime(context));
  return mStartDate.before(now) && mEndDate.after(now);
}",0.9775784753363228
19072,"@Test public void readDataFromCursor_SessionsQuery_SessionsLoaded(){
  initMockCursorWithSessionsData(mMockCursor);
  boolean success=mExploreIOModel.readDataFromCursor(mMockCursor,ExploreIOModel.ExploreIOQueryEnum.SESSIONS);
  assertThat(success,is(true));
  assertThat(mExploreIOModel.getKeynoteData().getSessionName(),is(FAKE_SESSION_TITLE_2_KEYNOTE));
  assertThat(mExploreIOModel.getLiveStreamData().getSessions().get(0).getSessionName(),is(FAKE_SESSION_TITLE_1));
  assertThat(mExploreIOModel.getThemes().size(),is(2));
  assertThat(mExploreIOModel.getTracks().size(),is(1));
  Iterator<ItemGroup> themeGroupIterator=mExploreIOModel.getThemes().iterator();
  ItemGroup themeGroup1=themeGroupIterator.next();
  ItemGroup themeGroup2=themeGroupIterator.next();
  if (themeGroup1.getTitle().equals(FAKE_SESSION_TAGS_1)) {
    assertThat(themeGroup1.getSessions().size(),is(2));
    assertThat(themeGroup1.getSessions().get(0).getSessionName(),is(FAKE_SESSION_TITLE_1));
    assertThat(themeGroup1.getSessions().get(1).getSessionName(),is(FAKE_SESSION_TITLE_2_KEYNOTE));
    assertThat(themeGroup2.getSessions().size(),is(1));
    assertThat(themeGroup2.getSessions().get(0).getSessionName(),is(FAKE_SESSION_TITLE_3));
  }
 else {
    assertThat(themeGroup1.getSessions().size(),is(1));
    assertThat(themeGroup1.getSessions().get(0).getSessionName(),is(FAKE_SESSION_TITLE_3));
    assertThat(themeGroup2.getSessions().size(),is(2));
    assertThat(themeGroup2.getSessions().get(0).getSessionName(),is(FAKE_SESSION_TITLE_1));
    assertThat(themeGroup2.getSessions().get(1).getSessionName(),is(FAKE_SESSION_TITLE_2_KEYNOTE));
  }
  ItemGroup topicGroup=mExploreIOModel.getTracks().iterator().next();
  assertThat(topicGroup.getSessions().size(),is(1));
  assertThat(topicGroup.getSessions().get(0).getSessionName(),is(FAKE_SESSION_TITLE_4));
}","@Test public void readDataFromCursor_SessionsQuery_SessionsLoaded(){
  initMockCursorWithSessionsData(mMockCursor);
  boolean success=mExploreIOModel.readDataFromCursor(mMockCursor,ExploreIOModel.ExploreIOQueryEnum.SESSIONS);
  assertThat(success,is(true));
  assertThat(mExploreIOModel.getKeynoteData().getSessionName(),is(FAKE_SESSION_TITLE_2_KEYNOTE));
  assertThat(mExploreIOModel.getLiveStreamData().getSessions().get(0).getSessionName(),is(FAKE_SESSION_TITLE_1_LIVESTREAM));
  assertThat(mExploreIOModel.getThemes().size(),is(2));
  assertThat(mExploreIOModel.getTracks().size(),is(1));
  Iterator<ItemGroup> themeGroupIterator=mExploreIOModel.getThemes().iterator();
  ItemGroup themeGroup1=themeGroupIterator.next();
  ItemGroup themeGroup2=themeGroupIterator.next();
  if (themeGroup1.getTitle().equals(FAKE_SESSION_TAGS_1)) {
    assertThat(themeGroup1.getSessions().size(),is(2));
    assertThat(themeGroup1.getSessions().get(0).getSessionName(),is(FAKE_SESSION_TITLE_1_LIVESTREAM));
    assertThat(themeGroup1.getSessions().get(1).getSessionName(),is(FAKE_SESSION_TITLE_2_KEYNOTE));
    assertThat(themeGroup2.getSessions().size(),is(1));
    assertThat(themeGroup2.getSessions().get(0).getSessionName(),is(FAKE_SESSION_TITLE_3));
  }
 else {
    assertThat(themeGroup1.getSessions().size(),is(1));
    assertThat(themeGroup1.getSessions().get(0).getSessionName(),is(FAKE_SESSION_TITLE_3));
    assertThat(themeGroup2.getSessions().size(),is(2));
    assertThat(themeGroup2.getSessions().get(0).getSessionName(),is(FAKE_SESSION_TITLE_1_LIVESTREAM));
    assertThat(themeGroup2.getSessions().get(1).getSessionName(),is(FAKE_SESSION_TITLE_2_KEYNOTE));
  }
  ItemGroup topicGroup=mExploreIOModel.getTracks().iterator().next();
  assertThat(topicGroup.getSessions().size(),is(1));
  assertThat(topicGroup.getSessions().get(0).getSessionName(),is(FAKE_SESSION_TITLE_4));
}",0.9911409395973154
19073,"/** 
 * Set the activity title & header image. <p> If the user is browsing a single track then it's name is shown as the title and a relevant header image; otherwise a generic title and image is shown.
 */
private void setHeader(){
  if (mMode == MODE_EXPLORE && mTagMetadata != null) {
    String tag=getIntent().getStringExtra(EXTRA_FILTER_TAG);
    TagMetadata.Tag titleTag=tag == null ? null : mTagMetadata.getTag(tag);
    String title=null;
    String headerImage=null;
    int trackColor=0;
    if (titleTag != null && mTagFilterHolder.getCountByCategory(titleTag.getCategory()) == 1) {
      for (      String tagId : mTagFilterHolder.getSelectedFilters()) {
        TagMetadata.Tag theTag=mTagMetadata.getTag(tagId);
        if (TextUtils.equals(titleTag.getCategory(),theTag.getCategory())) {
          title=theTag.getName();
          headerImage=theTag.getPhotoUrl();
          trackColor=theTag.getColor();
          break;
        }
      }
    }
    if (title == null) {
      title=getString(R.string.title_explore);
    }
    mTitle.setText(title);
    if (headerImage != null) {
      mHeaderImage.setScaleType(ImageView.ScaleType.CENTER_CROP);
      mImageLoader.loadImage(headerImage,mHeaderImage);
    }
 else {
      mHeaderImage.setScaleType(ImageView.ScaleType.FIT_CENTER);
      mHeaderImage.setImageResource(R.drawable.ic_hash_io_16_monochrome);
    }
    final int statusBarColor=trackColor != 0 ? UIUtils.adjustColorForStatusBar(trackColor) : UIUtils.getThemeColor(this,R.attr.colorPrimaryDark,R.color.theme_primary_dark);
    mDrawerLayout.setStatusBarBackgroundColor(statusBarColor);
  }
}","/** 
 * Set the activity title & header image. <p/> If the user is browsing a single track then it's name is shown as the title and a relevant header image; otherwise a generic title and image is shown.
 */
private void setHeader(){
  if (mMode == MODE_EXPLORE && mTagMetadata != null) {
    String title=null;
    String headerImage=null;
    int trackColor=0;
    int selectedTracks=mTagFilterHolder.getCountByCategory(Config.Tags.CATEGORY_TRACK);
    int selectedThemes=mTagFilterHolder.getCountByCategory(Config.Tags.CATEGORY_THEME);
    if (selectedThemes + selectedTracks == 1) {
      for (      String tagId : mTagFilterHolder.getSelectedFilters()) {
        if (tagId.contains(Config.Tags.CATEGORY_TRACK) || tagId.contains(Config.Tags.CATEGORY_THEME)) {
          TagMetadata.Tag selectedTag=mTagMetadata.getTag(tagId);
          title=selectedTag.getName();
          headerImage=selectedTag.getPhotoUrl();
          trackColor=selectedTag.getColor();
          break;
        }
      }
    }
    if (title == null) {
      title=getString(R.string.title_explore);
    }
    mTitle.setText(title);
    if (headerImage != null) {
      mHeaderImage.setScaleType(ImageView.ScaleType.CENTER_CROP);
      mImageLoader.loadImage(headerImage,mHeaderImage);
    }
 else {
      mHeaderImage.setScaleType(ImageView.ScaleType.FIT_CENTER);
      mHeaderImage.setImageResource(R.drawable.ic_hash_io_16_monochrome);
    }
    final int statusBarColor=trackColor != 0 ? UIUtils.adjustColorForStatusBar(trackColor) : UIUtils.getThemeColor(this,R.attr.colorPrimaryDark,R.color.theme_primary_dark);
    mDrawerLayout.setStatusBarBackgroundColor(statusBarColor);
  }
}",0.725998171289241
19074,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.explore_sessions_act);
  mImageLoader=new ImageLoader(this);
  mDrawerLayout=(DrawerLayout)findViewById(R.id.drawer_layout);
  mHeaderImage=(ImageView)findViewById(R.id.header_image);
  mTitle=(TextView)findViewById(R.id.title);
  mFiltersList=(RecyclerView)findViewById(R.id.filters);
  mTimeSlotLayout=findViewById(R.id.timeslot_view);
  mTimeSlotDivider=findViewById(R.id.timeslot_divider);
  TextView timeSlotTextView=(TextView)findViewById(R.id.timeslot);
  ImageButton dismissTimeSlotButton=(ImageButton)findViewById(R.id.close_timeslot);
  mDrawerLayout.setDrawerShadow(R.drawable.drawer_shadow_flipped,GravityCompat.END);
  mFragment=(ExploreSessionsFragment)getFragmentManager().findFragmentById(R.id.explore_sessions_frag);
  if (savedInstanceState != null) {
    mTagFilterHolder=savedInstanceState.getParcelable(STATE_FILTER_TAGS);
    mCurrentUri=savedInstanceState.getParcelable(STATE_CURRENT_URI);
  }
 else   if (getIntent() != null) {
    mCurrentUri=getIntent().getData();
  }
  long[] interval=ScheduleContract.Sessions.getInterval(mCurrentUri);
  if (interval != null) {
    mMode=MODE_TIME_FIT;
    String title=getString(R.string.explore_sessions_time_slot_title,getString(R.string.explore_sessions_show_day_n,UIUtils.startTimeToDayIndex(interval[0])),UIUtils.formatTime(interval[0],this));
    setTitle(title);
    mTimeSlotLayout.setVisibility(View.VISIBLE);
    mTimeSlotDivider.setVisibility(View.VISIBLE);
    timeSlotTextView.setText(title);
    dismissTimeSlotButton.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        mTimeSlotLayout.setVisibility(View.GONE);
        mTimeSlotDivider.setVisibility(View.GONE);
        mMode=MODE_EXPLORE;
        mCurrentUri=null;
        reloadFragment();
      }
    }
);
  }
 else {
    mMode=MODE_EXPLORE;
  }
  Toolbar toolbar=getToolbar();
  toolbar.setNavigationIcon(R.drawable.ic_up);
  toolbar.setNavigationContentDescription(R.string.close_and_go_back);
  toolbar.setNavigationOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      navigateUpOrBack(ExploreSessionsActivity.this,null);
    }
  }
);
  getSupportActionBar().setDisplayShowTitleEnabled(false);
  getLoaderManager().initLoader(TAG_METADATA_TOKEN,null,this);
  AnalyticsHelper.sendScreenView(SCREEN_LABEL);
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.explore_sessions_act);
  mImageLoader=new ImageLoader(this);
  mDrawerLayout=(DrawerLayout)findViewById(R.id.drawer_layout);
  mHeaderImage=(ImageView)findViewById(R.id.header_image);
  mTitle=(TextView)findViewById(R.id.title);
  mFiltersList=(RecyclerView)findViewById(R.id.filters);
  mTimeSlotLayout=findViewById(R.id.timeslot_view);
  mTimeSlotDivider=findViewById(R.id.timeslot_divider);
  TextView timeSlotTextView=(TextView)findViewById(R.id.timeslot);
  ImageButton dismissTimeSlotButton=(ImageButton)findViewById(R.id.close_timeslot);
  mDrawerLayout.setDrawerShadow(R.drawable.drawer_shadow_flipped,GravityCompat.END);
  mFragment=(ExploreSessionsFragment)getFragmentManager().findFragmentById(R.id.explore_sessions_frag);
  if (savedInstanceState != null) {
    mTagFilterHolder=savedInstanceState.getParcelable(STATE_FILTER_TAGS);
    mCurrentUri=savedInstanceState.getParcelable(STATE_CURRENT_URI);
  }
 else   if (getIntent() != null) {
    mCurrentUri=getIntent().getData();
  }
  long[] interval=ScheduleContract.Sessions.getInterval(mCurrentUri);
  if (interval != null) {
    mMode=MODE_TIME_FIT;
    String title=getString(R.string.explore_sessions_time_slot_title,TimeUtils.getDayName(this,UIUtils.startTimeToDayIndex(interval[0])),UIUtils.formatTime(interval[0],this));
    mTitle.setText(title);
    mHeaderImage.setScaleType(ImageView.ScaleType.FIT_CENTER);
    mHeaderImage.setImageResource(R.drawable.ic_hash_io_16_monochrome);
    mTimeSlotLayout.setVisibility(View.VISIBLE);
    mTimeSlotDivider.setVisibility(View.VISIBLE);
    timeSlotTextView.setText(title);
    dismissTimeSlotButton.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        mTimeSlotLayout.setVisibility(View.GONE);
        mTimeSlotDivider.setVisibility(View.GONE);
        mMode=MODE_EXPLORE;
        mCurrentUri=null;
        reloadFragment();
      }
    }
);
  }
 else {
    mMode=MODE_EXPLORE;
  }
  Toolbar toolbar=getToolbar();
  toolbar.setNavigationIcon(R.drawable.ic_up);
  toolbar.setNavigationContentDescription(R.string.close_and_go_back);
  toolbar.setNavigationOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      navigateUpOrBack(ExploreSessionsActivity.this,null);
    }
  }
);
  getSupportActionBar().setDisplayShowTitleEnabled(false);
  getLoaderManager().initLoader(TAG_METADATA_TOKEN,null,this);
  AnalyticsHelper.sendScreenView(SCREEN_LABEL);
}",0.9532673267326732
19075,"@Override public String toString(){
  return ""String_Node_Str"" + mTagsById.size() + ""String_Node_Str""+ mTagsInCategory.size()+ ""String_Node_Str"";
}","@Override public String toString(){
  return ""String_Node_Str"" + mId + ""String_Node_Str""+ mName;
}",0.7836734693877551
19076,"private void displaySessionData(final SessionDetailModel data){
  mTitle.setText(data.getSessionTitle());
  mSubtitle.setText(data.getSessionSubtitle());
  mPhotoViewContainer.setBackgroundColor(UIUtils.scaleSessionColorToDefaultBG(data.getSessionColor()));
  if (data.hasPhotoUrl()) {
    mHasPhoto=true;
    mNoPlaceholderImageLoader.loadImage(data.getPhotoUrl(),mPhotoView,new RequestListener<String,Bitmap>(){
      @Override public boolean onException(      Exception e,      String model,      Target<Bitmap> target,      boolean isFirstResource){
        mHasPhoto=false;
        recomputePhotoAndScrollingMetrics();
        return false;
      }
      @Override public boolean onResourceReady(      Bitmap resource,      String model,      Target<Bitmap> target,      boolean isFromMemoryCache,      boolean isFirstResource){
        recomputePhotoAndScrollingMetrics();
        return false;
      }
    }
);
    recomputePhotoAndScrollingMetrics();
  }
 else {
    mHasPhoto=false;
    recomputePhotoAndScrollingMetrics();
  }
  tryExecuteDeferredUiOperations();
  mAddScheduleButton.setVisibility((AccountUtils.hasActiveAccount(getContext()) && !data.isKeynote()) ? View.VISIBLE : View.INVISIBLE);
  displayTags(data);
  if (!data.isKeynote()) {
    showStarredDeferred(data.isInSchedule(),false);
  }
  if (!TextUtils.isEmpty(data.getSessionAbstract())) {
    UIUtils.setTextMaybeHtml(mAbstract,data.getSessionAbstract());
    mAbstract.setVisibility(View.VISIBLE);
  }
 else {
    mAbstract.setVisibility(View.GONE);
  }
  final View requirementsBlock=getActivity().findViewById(R.id.session_requirements_block);
  final String sessionRequirements=data.getRequirements();
  if (!TextUtils.isEmpty(sessionRequirements)) {
    UIUtils.setTextMaybeHtml(mRequirements,sessionRequirements);
    requirementsBlock.setVisibility(View.VISIBLE);
  }
 else {
    requirementsBlock.setVisibility(View.GONE);
  }
  final ViewGroup relatedVideosBlock=(ViewGroup)getActivity().findViewById(R.id.related_videos_block);
  relatedVideosBlock.setVisibility(View.GONE);
  updateEmptyView(data);
  updateTimeBasedUi(data);
  if (data.getLiveStreamVideoWatched()) {
    mPhotoView.setColorFilter(getContext().getResources().getColor(R.color.video_scrim_watched));
    mLiveStreamPlayIconAndText.setText(getString(R.string.session_replay));
  }
  if (data.hasLiveStream()) {
    mLiveStreamPlayIconAndText.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        String videoId=YouTubeUtils.getVideoIdFromSessionData(data.getYouTubeUrl(),data.getLiveStreamId());
        YouTubeUtils.showYouTubeVideo(videoId,getActivity());
      }
    }
);
  }
  fireAnalyticsScreenView(data.getSessionTitle());
  mHandler.post(new Runnable(){
    @Override public void run(){
      onScrollChanged(0,0);
      mScrollViewChild.setVisibility(View.VISIBLE);
    }
  }
);
  mTimeHintUpdaterRunnable=new Runnable(){
    @Override public void run(){
      if (getActivity() == null) {
        return;
      }
      updateTimeBasedUi(data);
      mHandler.postDelayed(mTimeHintUpdaterRunnable,SessionDetailConstants.TIME_HINT_UPDATE_INTERVAL);
    }
  }
;
  mHandler.postDelayed(mTimeHintUpdaterRunnable,SessionDetailConstants.TIME_HINT_UPDATE_INTERVAL);
}","private void displaySessionData(final SessionDetailModel data){
  mTitle.setText(data.getSessionTitle());
  mSubtitle.setText(data.getSessionSubtitle());
  mPhotoViewContainer.setBackgroundColor(UIUtils.scaleSessionColorToDefaultBG(data.getSessionColor()));
  if (data.hasPhotoUrl()) {
    mHasPhoto=true;
    mNoPlaceholderImageLoader.loadImage(data.getPhotoUrl(),mPhotoView,new RequestListener<String,Bitmap>(){
      @Override public boolean onException(      Exception e,      String model,      Target<Bitmap> target,      boolean isFirstResource){
        mHasPhoto=false;
        recomputePhotoAndScrollingMetrics();
        return false;
      }
      @Override public boolean onResourceReady(      Bitmap resource,      String model,      Target<Bitmap> target,      boolean isFromMemoryCache,      boolean isFirstResource){
        recomputePhotoAndScrollingMetrics();
        return false;
      }
    }
);
    recomputePhotoAndScrollingMetrics();
  }
 else {
    mHasPhoto=false;
    recomputePhotoAndScrollingMetrics();
  }
  tryExecuteDeferredUiOperations();
  mAddScheduleButton.setVisibility((AccountUtils.hasActiveAccount(getContext()) && !data.isKeynote()) ? View.VISIBLE : View.INVISIBLE);
  displayTags(data);
  if (!data.isKeynote()) {
    showStarredDeferred(data.isInSchedule(),false);
  }
  if (!TextUtils.isEmpty(data.getSessionAbstract())) {
    UIUtils.setTextMaybeHtml(mAbstract,data.getSessionAbstract());
    mAbstract.setVisibility(View.VISIBLE);
  }
 else {
    mAbstract.setVisibility(View.GONE);
  }
  final View requirementsBlock=getActivity().findViewById(R.id.session_requirements_block);
  final String sessionRequirements=data.getRequirements();
  if (!TextUtils.isEmpty(sessionRequirements)) {
    UIUtils.setTextMaybeHtml(mRequirements,sessionRequirements);
    requirementsBlock.setVisibility(View.VISIBLE);
  }
 else {
    requirementsBlock.setVisibility(View.GONE);
  }
  final ViewGroup relatedVideosBlock=(ViewGroup)getActivity().findViewById(R.id.related_videos_block);
  relatedVideosBlock.setVisibility(View.GONE);
  updateEmptyView(data);
  updateTimeBasedUi(data);
  if (data.getLiveStreamVideoWatched()) {
    mPhotoView.setColorFilter(getContext().getResources().getColor(R.color.played_video_tint));
    mLiveStreamPlayIconAndText.setText(getString(R.string.session_replay));
  }
  if (data.hasLiveStream()) {
    mLiveStreamPlayIconAndText.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        String videoId=YouTubeUtils.getVideoIdFromSessionData(data.getYouTubeUrl(),data.getLiveStreamId());
        YouTubeUtils.showYouTubeVideo(videoId,getActivity());
      }
    }
);
  }
  fireAnalyticsScreenView(data.getSessionTitle());
  mHandler.post(new Runnable(){
    @Override public void run(){
      onScrollChanged(0,0);
      mScrollViewChild.setVisibility(View.VISIBLE);
    }
  }
);
  mTimeHintUpdaterRunnable=new Runnable(){
    @Override public void run(){
      if (getActivity() == null) {
        return;
      }
      updateTimeBasedUi(data);
      mHandler.postDelayed(mTimeHintUpdaterRunnable,SessionDetailConstants.TIME_HINT_UPDATE_INTERVAL);
    }
  }
;
  mHandler.postDelayed(mTimeHintUpdaterRunnable,SessionDetailConstants.TIME_HINT_UPDATE_INTERVAL);
}",0.9963358778625954
19077,"public VideoThumbnail(final Context context,final AttributeSet attrs,final int defStyleAttr){
  super(context,attrs,defStyleAttr);
  final TypedArray a=getContext().obtainStyledAttributes(attrs,R.styleable.VideoThumbnail,defStyleAttr,0);
  mPlayIcon=a.getDrawable(R.styleable.VideoThumbnail_playIcon);
  a.recycle();
  setScaleType(ScaleType.CENTER_CROP);
}","public VideoThumbnail(final Context context,final AttributeSet attrs,final int defStyleAttr){
  super(context,attrs,defStyleAttr);
  final TypedArray a=getContext().obtainStyledAttributes(attrs,R.styleable.VideoThumbnail,defStyleAttr,0);
  mPlayIcon=a.getDrawable(R.styleable.VideoThumbnail_playIcon);
  mPlayedTint=a.getColor(R.styleable.VideoThumbnail_playedTint,Color.TRANSPARENT);
  a.recycle();
  setScaleType(ScaleType.CENTER_CROP);
}",0.7979924717691342
19078,"public void setPlayed(final boolean played){
  if (mIsPlayed != played) {
    mIsPlayed=played;
    refreshDrawableState();
    invalidate();
  }
}","public void setPlayed(final boolean played){
  if (mIsPlayed != played) {
    mIsPlayed=played;
    if (played) {
      setColorFilter(mPlayedTint);
    }
 else {
      clearColorFilter();
    }
    invalidate();
  }
}",0.684931506849315
19079,"@Override public void displayData(final VideoLibraryModel model,final VideoLibraryQueryEnum query){
  if ((VideoLibraryModel.VideoLibraryQueryEnum.VIDEOS == query || VideoLibraryModel.VideoLibraryQueryEnum.MY_VIEWED_VIDEOS == query) && model.hasVideos()) {
    if (mAdapter == null) {
      mAdapter=new VideosAdapter(getActivity(),model,mImageLoader,mListeners);
      mCardList.setAdapter(mAdapter);
    }
 else {
      mAdapter.update(model);
    }
    mEmptyView.setVisibility(View.GONE);
  }
 else {
    mEmptyView.setVisibility(View.VISIBLE);
  }
}","@Override public void displayData(final VideoLibraryModel model,final VideoLibraryQueryEnum query){
  if ((VideoLibraryModel.VideoLibraryQueryEnum.VIDEOS == query || VideoLibraryModel.VideoLibraryQueryEnum.MY_VIEWED_VIDEOS == query) && model.hasVideos()) {
    if (mAdapter == null) {
      mAdapter=new VideosAdapter(getActivity(),model,mImageLoader,mListeners);
      mCardList.setAdapter(mAdapter);
    }
 else {
      mAdapter.update(model);
    }
  }
  mEmptyView.setVisibility((mAdapter != null && mAdapter.getItemCount() > 0) ? View.GONE : View.VISIBLE);
}",0.8845120859444942
19080,"/** 
 * Get the list of   {@link MessageData} to be displayed to the user,based upon time, location etc.
 * @return messages to be displayed.
 */
public List<MessageData> getMessages(){
  final List<MessageData> messages=new ArrayList<>();
  if (SettingsUtils.isAttendeeAtVenue(mContext)) {
    if (!ConfMessageCardUtils.hasAnsweredConfMessageCardsPrompt(mContext)) {
      messages.add(MessageCardHelper.getConferenceOptInMessageData(mContext));
    }
 else     if (ConfMessageCardUtils.isConfMessageCardsEnabled(mContext)) {
      ConfMessageCardUtils.enableActiveCards(mContext);
      if (shouldShowCard(ConfMessageCardUtils.ConfMessageCard.CONFERENCE_CREDENTIALS)) {
        messages.add(MessageCardHelper.getConferenceCredentialsMessageData(mContext));
      }
 else       if (shouldShowCard(ConfMessageCardUtils.ConfMessageCard.KEYNOTE_ACCESS)) {
        messages.add(MessageCardHelper.getKeynoteAccessMessageData(mContext));
      }
 else       if (shouldShowCard(ConfMessageCardUtils.ConfMessageCard.AFTER_HOURS)) {
        messages.add(MessageCardHelper.getAfterHoursMessageData(mContext));
      }
 else       if (shouldShowCard(ConfMessageCardUtils.ConfMessageCard.WIFI_FEEDBACK)) {
        if (WiFiUtils.isWiFiEnabled(mContext) && WiFiUtils.isWiFiApConfigured(mContext)) {
          messages.add(MessageCardHelper.getWifiFeedbackMessageData(mContext));
        }
      }
    }
    if (WiFiUtils.shouldOfferToSetupWifi(mContext,true)) {
      messages.add(MessageCardHelper.getWifiSetupMessageData(mContext));
    }
  }
  return messages;
}","/** 
 * Get the list of   {@link MessageData} to be displayed to the user, based upon time, locationetc.
 * @return messages to be displayed.
 */
public List<MessageData> getMessages(){
  final List<MessageData> messages=new ArrayList<>();
  if (SettingsUtils.isAttendeeAtVenue(mContext)) {
    if (!ConfMessageCardUtils.hasAnsweredConfMessageCardsPrompt(mContext)) {
      messages.add(MessageCardHelper.getConferenceOptInMessageData(mContext));
    }
 else     if (ConfMessageCardUtils.isConfMessageCardsEnabled(mContext)) {
      ConfMessageCardUtils.enableActiveCards(mContext);
      if (shouldShowCard(ConfMessageCardUtils.ConfMessageCard.CONFERENCE_CREDENTIALS)) {
        messages.add(MessageCardHelper.getConferenceCredentialsMessageData(mContext));
      }
 else       if (shouldShowCard(ConfMessageCardUtils.ConfMessageCard.KEYNOTE_ACCESS)) {
        messages.add(MessageCardHelper.getKeynoteAccessMessageData(mContext));
      }
 else       if (shouldShowCard(ConfMessageCardUtils.ConfMessageCard.AFTER_HOURS)) {
        messages.add(MessageCardHelper.getAfterHoursMessageData(mContext));
      }
 else       if (shouldShowCard(ConfMessageCardUtils.ConfMessageCard.WIFI_FEEDBACK)) {
        if (WiFiUtils.isWiFiEnabled(mContext) && WiFiUtils.isWiFiApConfigured(mContext)) {
          messages.add(MessageCardHelper.getWifiFeedbackMessageData(mContext));
        }
      }
    }
    if (WiFiUtils.shouldOfferToSetupWifi(mContext,true)) {
      messages.add(MessageCardHelper.getWifiSetupMessageData(mContext));
    }
  }
  return messages;
}",0.9993556701030928
19081,"private void populateSessionFromCursorRow(SessionData session,Cursor cursor){
  session.updateData(cursor.getString(cursor.getColumnIndex(ScheduleContract.Sessions.SESSION_TITLE)),cursor.getString(cursor.getColumnIndex(ScheduleContract.Sessions.SESSION_ABSTRACT)),cursor.getString(cursor.getColumnIndex(ScheduleContract.Sessions.SESSION_ID)),cursor.getString(cursor.getColumnIndex(ScheduleContract.Sessions.SESSION_PHOTO_URL)),cursor.getString(cursor.getColumnIndex(ScheduleContract.Sessions.SESSION_MAIN_TAG)),cursor.getLong(cursor.getColumnIndex(ScheduleContract.Sessions.SESSION_START)),cursor.getLong(cursor.getColumnIndex(ScheduleContract.Sessions.SESSION_END)),cursor.getString(cursor.getColumnIndex(ScheduleContract.Sessions.SESSION_LIVESTREAM_ID)),cursor.getString(cursor.getColumnIndex(ScheduleContract.Sessions.SESSION_YOUTUBE_URL)),cursor.getString(cursor.getColumnIndex(ScheduleContract.Sessions.SESSION_TAGS)),cursor.getLong(cursor.getColumnIndex(ScheduleContract.Sessions.SESSION_IN_MY_SCHEDULE)) == 1L);
}","private void populateSessionFromCursorRow(SessionData session,Cursor cursor){
  session.updateData(mContext,cursor.getString(cursor.getColumnIndex(ScheduleContract.Sessions.SESSION_TITLE)),cursor.getString(cursor.getColumnIndex(ScheduleContract.Sessions.SESSION_ABSTRACT)),cursor.getString(cursor.getColumnIndex(ScheduleContract.Sessions.SESSION_ID)),cursor.getString(cursor.getColumnIndex(ScheduleContract.Sessions.SESSION_PHOTO_URL)),cursor.getString(cursor.getColumnIndex(ScheduleContract.Sessions.SESSION_MAIN_TAG)),cursor.getLong(cursor.getColumnIndex(ScheduleContract.Sessions.SESSION_START)),cursor.getLong(cursor.getColumnIndex(ScheduleContract.Sessions.SESSION_END)),cursor.getString(cursor.getColumnIndex(ScheduleContract.Sessions.SESSION_LIVESTREAM_ID)),cursor.getString(cursor.getColumnIndex(ScheduleContract.Sessions.SESSION_YOUTUBE_URL)),cursor.getString(cursor.getColumnIndex(ScheduleContract.Sessions.SESSION_TAGS)),cursor.getLong(cursor.getColumnIndex(ScheduleContract.Sessions.SESSION_IN_MY_SCHEDULE)) == 1L);
}",0.9956076134699854
19082,"private void rewriteKeynoteDetails(SessionData keynoteData){
  long startTime, endTime, currentTime;
  currentTime=TimeUtils.getCurrentTime(mContext);
  if (keynoteData.getStartDate() != null) {
    startTime=keynoteData.getStartDate().getTime();
  }
 else {
    LOGD(TAG,""String_Node_Str"");
    startTime=0;
  }
  if (keynoteData.getEndDate() != null) {
    endTime=keynoteData.getEndDate().getTime();
  }
 else {
    LOGD(TAG,""String_Node_Str"");
    endTime=Long.MAX_VALUE;
  }
  StringBuilder stringBuilder=new StringBuilder();
  if (currentTime >= startTime && currentTime < endTime) {
    stringBuilder.append(mContext.getString(R.string.live_now));
  }
 else {
    stringBuilder.append(TimeUtils.formatShortDateTime(mContext,keynoteData.getStartDate()));
  }
  keynoteData.setDetails(stringBuilder.toString());
}","private void rewriteKeynoteDetails(SessionData keynoteData){
  long startTime, endTime, currentTime;
  currentTime=TimeUtils.getCurrentTime(mContext);
  if (keynoteData.getStartDate() != null) {
    startTime=keynoteData.getStartDate().getTimeInMillis();
  }
 else {
    LOGD(TAG,""String_Node_Str"");
    startTime=0;
  }
  if (keynoteData.getEndDate() != null) {
    endTime=keynoteData.getEndDate().getTimeInMillis();
  }
 else {
    LOGD(TAG,""String_Node_Str"");
    endTime=Long.MAX_VALUE;
  }
  StringBuilder stringBuilder=new StringBuilder();
  if (currentTime >= startTime && currentTime < endTime) {
    stringBuilder.append(mContext.getString(R.string.live_now));
  }
 else {
    stringBuilder.append(TimeUtils.formatShortDateTime(mContext,keynoteData.getStartDate().getTime()));
  }
  keynoteData.setDetails(stringBuilder.toString());
}",0.9843561973525872
19083,"private void reloadSessionData(Cursor cursor){
  mSessionList.setAdapter(null);
  mSessionsAdapter=null;
  final ExploreSessionsModel model=new ExploreSessionsModel(cursor);
  if (model.getSessionData() == null || model.getSessionData().isEmpty()) {
    mEmptyView.setVisibility(View.VISIBLE);
    return;
  }
  final GridLayoutManager glm=(GridLayoutManager)mSessionList.getLayoutManager();
  mSessionsAdapter=SessionsAdapter.createVerticalGrid(getActivity(),model.getSessionData(),glm.getSpanCount());
  glm.setSpanSizeLookup(new GridLayoutManager.SpanSizeLookup(){
    @Override public int getSpanSize(    final int position){
      return mSessionsAdapter.getSpanSize(position);
    }
  }
);
  mSessionList.setAdapter(mSessionsAdapter);
  mEmptyView.setVisibility(View.GONE);
}","private void reloadSessionData(Cursor cursor){
  mSessionList.setAdapter(null);
  mSessionsAdapter=null;
  final ExploreSessionsModel model=new ExploreSessionsModel(cursor,getActivity());
  if (model.getSessionData() == null || model.getSessionData().isEmpty()) {
    mEmptyView.setVisibility(View.VISIBLE);
    return;
  }
  final GridLayoutManager glm=(GridLayoutManager)mSessionList.getLayoutManager();
  mSessionsAdapter=SessionsAdapter.createVerticalGrid(getActivity(),model.getSessionData(),glm.getSpanCount());
  glm.setSpanSizeLookup(new GridLayoutManager.SpanSizeLookup(){
    @Override public int getSpanSize(    final int position){
      return mSessionsAdapter.getSpanSize(position);
    }
  }
);
  mSessionList.setAdapter(mSessionsAdapter);
  mEmptyView.setVisibility(View.GONE);
}",0.9911167512690356
19084,"public ExploreSessionsModel(Cursor cursor){
  if (cursor != null && cursor.moveToFirst()) {
    mSessionData=new ArrayList<>(cursor.getCount());
    do {
      mSessionData.add(createSessionData(cursor));
    }
 while (cursor.moveToNext());
  }
 else {
    mSessionData=null;
  }
}","public ExploreSessionsModel(Cursor cursor,Context context){
  mContext=context;
  if (cursor != null && cursor.moveToFirst()) {
    mSessionData=new ArrayList<>(cursor.getCount());
    do {
      mSessionData.add(createSessionData(cursor));
    }
 while (cursor.moveToNext());
  }
 else {
    mSessionData=null;
  }
}",0.939799331103679
19085,"private SessionData createSessionData(Cursor cursor){
  return new SessionData(cursor.getString(ExploreSessionsQuery.TITLE),cursor.getString(ExploreSessionsQuery.ABSTRACT),cursor.getString(ExploreSessionsQuery.SESSION_ID),cursor.getString(ExploreSessionsQuery.PHOTO_URL),cursor.getString(ExploreSessionsQuery.MAIN_TAG),cursor.getLong(ExploreSessionsQuery.SESSION_START),cursor.getLong(ExploreSessionsQuery.SESSION_END),cursor.getString(ExploreSessionsQuery.LIVESTREAM_ID),cursor.getString(ExploreSessionsQuery.YOUTUBE_URL),cursor.getString(ExploreSessionsQuery.TAGS),cursor.getLong(ExploreSessionsQuery.IN_MY_SCHEDULE) == 1L);
}","private SessionData createSessionData(Cursor cursor){
  return new SessionData(mContext,cursor.getString(ExploreSessionsQuery.TITLE),cursor.getString(ExploreSessionsQuery.ABSTRACT),cursor.getString(ExploreSessionsQuery.SESSION_ID),cursor.getString(ExploreSessionsQuery.PHOTO_URL),cursor.getString(ExploreSessionsQuery.MAIN_TAG),cursor.getLong(ExploreSessionsQuery.SESSION_START),cursor.getLong(ExploreSessionsQuery.SESSION_END),cursor.getString(ExploreSessionsQuery.LIVESTREAM_ID),cursor.getString(ExploreSessionsQuery.YOUTUBE_URL),cursor.getString(ExploreSessionsQuery.TAGS),cursor.getLong(ExploreSessionsQuery.IN_MY_SCHEDULE) == 1L);
}",0.9928853754940712
19086,"private void bindCompactSession(CompactSessionViewHolder holder,final SessionData session){
  holder.footer.setText(TimeUtils.formatShortDateTime(mHost,session.getStartDate()));
}","private void bindCompactSession(CompactSessionViewHolder holder,final SessionData session){
  holder.footer.setText(TimeUtils.formatShortDateTime(mHost,session.getStartDate().getTime()));
}",0.9728260869565216
19087,"@Override public void onClick(final View v){
  final ViewGroup.LayoutParams lp=v.getLayoutParams();
  if (!(lp instanceof RecyclerView.LayoutParams))   return;
  final int position=((RecyclerView.LayoutParams)lp).getViewAdapterPosition();
  if (position == RecyclerView.NO_POSITION)   return;
  final SessionData sessionData=(SessionData)mItems.get(position);
  final Intent intent=new Intent(mHost,SessionDetailActivity.class);
  intent.setData(ScheduleContract.Sessions.buildSessionUri(sessionData.getSessionId()));
  ActivityCompat.startActivity(mHost,intent,null);
}","@Override public void onClick(final View v){
  final ViewGroup.LayoutParams lp=v.getLayoutParams();
  if (!(lp instanceof RecyclerView.LayoutParams)) {
    return;
  }
  final int position=((RecyclerView.LayoutParams)lp).getViewAdapterPosition();
  if (position == RecyclerView.NO_POSITION) {
    return;
  }
  final SessionData sessionData=(SessionData)mItems.get(position);
  final Intent intent=new Intent(mHost,SessionDetailActivity.class);
  intent.setData(ScheduleContract.Sessions.buildSessionUri(sessionData.getSessionId()));
  ActivityCompat.startActivity(mHost,intent,null);
}",0.9550173010380624
19088,"/** 
 * Process the given list of sessions. If we are in detail mode then insert day/time headers.
 */
private List processData(final List<SessionData> sessions){
  final List data=new ArrayList(sessions.size());
  Collections.sort(sessions,new Comparator<SessionData>(){
    @Override public int compare(    final SessionData lhs,    final SessionData rhs){
      return lhs.getStartDate().compareTo(rhs.getStartDate());
    }
  }
);
  if (mCompactMode) {
    data.addAll(sessions);
  }
 else {
    int day=-1, time=-1;
    for (    SessionData session : sessions) {
      if (session.getStartDate().getDate() > day) {
        day=session.getStartDate().getDate();
        data.add(new DayHeader(TimeUtils.formatShortDate(mHost,session.getStartDate())));
        time=-1;
      }
      if (session.getStartDate().getHours() > time) {
        time=session.getStartDate().getHours();
        data.add(new TimeHeader(TimeUtils.formatShortTime(mHost,session.getStartDate())));
      }
      data.add(session);
    }
  }
  return data;
}","/** 
 * Process the given list of sessions. If we are in detail mode then insert day/time headers.
 */
private List processData(final List<SessionData> sessions){
  final List data=new ArrayList(sessions.size());
  Collections.sort(sessions,new Comparator<SessionData>(){
    @Override public int compare(    final SessionData lhs,    final SessionData rhs){
      return lhs.getStartDate().compareTo(rhs.getStartDate());
    }
  }
);
  if (mCompactMode) {
    data.addAll(sessions);
  }
 else {
    int day=-1, time=-1;
    for (    SessionData session : sessions) {
      if (session.getStartDate().get(Calendar.DAY_OF_YEAR) > day) {
        day=session.getStartDate().get(Calendar.DAY_OF_YEAR);
        data.add(new DayHeader(TimeUtils.formatShortDate(mHost,session.getStartDate().getTime())));
        time=-1;
      }
      if (session.getStartDate().get(Calendar.HOUR_OF_DAY) > time) {
        time=session.getStartDate().get(Calendar.HOUR_OF_DAY);
        data.add(new TimeHeader(TimeUtils.formatShortTime(mHost,session.getStartDate().getTime())));
      }
      data.add(session);
    }
  }
  return data;
}",0.7569832402234636
19089,"private void initPresenter(){
  MyScheduleModel model=ModelProvider.provideMyScheduleModel(new ScheduleHelper(this),this);
  if (mWideMode) {
    mPresenter=new PresenterImpl(model,(UpdatableView)getFragmentManager().findFragmentById(R.id.myScheduleWideFrag),MyScheduleModel.MyScheduleUserActionEnum.values(),MyScheduleModel.MyScheduleQueryEnum.values());
  }
 else {
    MyScheduleSingleDayFragment[] fragments=mViewPagerAdapter.getFragments();
    UpdatableView[] views=new UpdatableView[fragments.length];
    for (int i=0; i < fragments.length; i++) {
      views[i]=fragments[i];
    }
    mPresenter=new PresenterImpl(model,views,MyScheduleModel.MyScheduleUserActionEnum.values(),MyScheduleModel.MyScheduleQueryEnum.values());
  }
}","private void initPresenter(){
  MyScheduleModel model=ModelProvider.provideMyScheduleModel(new ScheduleHelper(this),this);
  if (mWideMode) {
    mPresenter=new PresenterImpl(model,(UpdatableView)getFragmentManager().findFragmentById(R.id.myScheduleWideFrag),MyScheduleModel.MyScheduleUserActionEnum.values(),MyScheduleModel.MyScheduleQueryEnum.values());
    mPresenter.loadInitialQueries();
  }
 else {
    MyScheduleSingleDayFragment[] fragments=mViewPagerAdapter.getFragments();
    UpdatableView[] views=new UpdatableView[fragments.length];
    for (int i=0; i < fragments.length; i++) {
      views[i]=fragments[i];
    }
    mPresenter=new PresenterImpl(model,views,MyScheduleModel.MyScheduleUserActionEnum.values(),MyScheduleModel.MyScheduleQueryEnum.values());
  }
}",0.9755452742894912
19090,"@Override protected void onDestroy(){
  super.onDestroy();
  mDestroyed=true;
  mPresenter.cleanUp();
}","@Override protected void onDestroy(){
  super.onDestroy();
  mDestroyed=true;
}",0.8681318681318682
19091,"private void detectNarrowOrWideMode(){
  mWideMode=getFragmentManager().findFragmentById(R.id.myScheduleWideFrag) != null;
}","private void detectNarrowOrWideMode(){
  mWideMode=getFragmentManager().findFragmentById(R.id.myScheduleWideFrag) != null && findViewById(R.id.view_pager).getVisibility() == View.GONE;
}",0.8
19092,"private void updateSchedule(MyScheduleModel model){
  if (MyScheduleModel.showPreConferenceData(getContext())) {
    if (mPreConferenceDayView.getAdapter() == null) {
      mPreConferenceDayView.setAdapter(new MyScheduleDayAdapter(getActivity(),((MyScheduleActivity)getActivity()).getLUtils(),mListener));
    }
    mPreConferenceDayView.getAdapter().updateItems(model.getConferenceDataForDay(MyScheduleModel.PRE_CONFERENCE_DAY_ID));
  }
  for (int i=0; i < mMyScheduleSingleDayViews.length; i++) {
    if (mMyScheduleSingleDayViews[i].getAdapter() == null) {
      mMyScheduleSingleDayViews[i].setAdapter(new MyScheduleDayAdapter(getActivity(),((MyScheduleActivity)getActivity()).getLUtils(),mListener));
    }
    mMyScheduleSingleDayViews[i].getAdapter().updateItems(model.getConferenceDataForDay(i + 1));
  }
}","private void updateSchedule(MyScheduleModel model){
  if (isVisible()) {
    if (MyScheduleModel.showPreConferenceData(getContext())) {
      if (mPreConferenceDayView.getAdapter() == null) {
        mPreConferenceDayView.setAdapter(new MyScheduleDayAdapter(getActivity(),((MyScheduleActivity)getActivity()).getLUtils(),mListener));
      }
      mPreConferenceDayView.getAdapter().updateItems(model.getConferenceDataForDay(MyScheduleModel.PRE_CONFERENCE_DAY_ID));
    }
    for (int i=0; i < mMyScheduleSingleDayViews.length; i++) {
      if (mMyScheduleSingleDayViews[i].getAdapter() == null) {
        mMyScheduleSingleDayViews[i].setAdapter(new MyScheduleDayAdapter(getActivity(),((MyScheduleActivity)getActivity()).getLUtils(),mListener));
      }
      mMyScheduleSingleDayViews[i].getAdapter().updateItems(model.getConferenceDataForDay(i + 1));
    }
  }
}",0.9707811568276684
19093,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View root=inflater.inflate(R.layout.my_schedule_alldays_frag,container,false);
  mMyScheduleSingleDayViews[0]=(MyScheduleSingleDayNoScrollView)root.findViewById(R.id.my_schedule_first_day);
  mMyScheduleSingleDayViews[1]=(MyScheduleSingleDayNoScrollView)root.findViewById(R.id.my_schedule_second_day);
  return root;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View root=inflater.inflate(R.layout.my_schedule_alldays_frag,container,false);
  mMyScheduleSingleDayViews[0]=(MyScheduleSingleDayNoScrollView)root.findViewById(R.id.my_schedule_first_day);
  mMyScheduleSingleDayViews[1]=(MyScheduleSingleDayNoScrollView)root.findViewById(R.id.my_schedule_second_day);
  mMyScheduleSingleDayViews[2]=(MyScheduleSingleDayNoScrollView)root.findViewById(R.id.my_schedule_third_day);
  setRetainInstance(false);
  return root;
}",0.837865055387714
19094,"private void initViews(){
  TextView firstDayHeaderView=(TextView)getActivity().findViewById(R.id.day_label_first_day);
  TextView secondDayHeaderView=(TextView)getActivity().findViewById(R.id.day_label_second_day);
  if (firstDayHeaderView != null) {
    firstDayHeaderView.setText(TimeUtils.getDayName(getContext(),0));
  }
  if (secondDayHeaderView != null) {
    secondDayHeaderView.setText(TimeUtils.getDayName(getContext(),1));
  }
  mPreConferenceDayView=(MyScheduleSingleDayNoScrollView)getActivity().findViewById(R.id.my_schedule_zeroth_day);
  TextView zerothDayHeaderView=(TextView)getActivity().findViewById(R.id.day_label_zeroth_day);
  if (MyScheduleModel.showPreConferenceData(getContext())) {
    mPreConferenceDayView.setVisibility(View.VISIBLE);
    zerothDayHeaderView.setText(TimeUtils.getDayName(getContext(),-1));
    zerothDayHeaderView.setVisibility(View.VISIBLE);
  }
 else {
    mPreConferenceDayView.setVisibility(View.GONE);
    zerothDayHeaderView.setVisibility(View.GONE);
  }
}","private void initViews(){
  TextView firstDayHeaderView=(TextView)getActivity().findViewById(R.id.day_label_first_day);
  TextView secondDayHeaderView=(TextView)getActivity().findViewById(R.id.day_label_second_day);
  TextView thirdDayHeaderView=(TextView)getActivity().findViewById(R.id.day_label_third_day);
  if (firstDayHeaderView != null) {
    firstDayHeaderView.setText(TimeUtils.getDayName(getContext(),0));
  }
  if (secondDayHeaderView != null) {
    secondDayHeaderView.setText(TimeUtils.getDayName(getContext(),1));
  }
  if (thirdDayHeaderView != null) {
    thirdDayHeaderView.setText(TimeUtils.getDayName(getContext(),2));
  }
  mPreConferenceDayView=(MyScheduleSingleDayNoScrollView)getActivity().findViewById(R.id.my_schedule_zeroth_day);
  TextView zerothDayHeaderView=(TextView)getActivity().findViewById(R.id.day_label_zeroth_day);
  if (MyScheduleModel.showPreConferenceData(getContext())) {
    mPreConferenceDayView.setVisibility(View.VISIBLE);
    zerothDayHeaderView.setText(TimeUtils.getDayName(getContext(),-1));
    zerothDayHeaderView.setVisibility(View.VISIBLE);
  }
 else {
    mPreConferenceDayView.setVisibility(View.GONE);
    zerothDayHeaderView.setVisibility(View.GONE);
  }
}",0.9081081081081082
19095,"private void initPresenter(){
  MyScheduleModel model=ModelProvider.provideMyScheduleModel(new ScheduleHelper(this),this);
  if (mWideMode) {
    mPresenter=new PresenterImpl(model,(UpdatableView)getFragmentManager().findFragmentById(R.id.myScheduleWideFrag),MyScheduleModel.MyScheduleUserActionEnum.values(),MyScheduleModel.MyScheduleQueryEnum.values());
  }
 else {
    MyScheduleSingleDayFragment[] fragments=mViewPagerAdapter.getFragments();
    UpdatableView[] views=new UpdatableView[fragments.length];
    for (int i=0; i < fragments.length; i++) {
      views[i]=fragments[i];
    }
    mPresenter=new PresenterImpl(model,views,MyScheduleModel.MyScheduleUserActionEnum.values(),MyScheduleModel.MyScheduleQueryEnum.values());
  }
}","private void initPresenter(){
  MyScheduleModel model=ModelProvider.provideMyScheduleModel(new ScheduleHelper(this),this);
  if (mWideMode) {
    mPresenter=new PresenterImpl(model,(UpdatableView)getFragmentManager().findFragmentById(R.id.myScheduleWideFrag),MyScheduleModel.MyScheduleUserActionEnum.values(),MyScheduleModel.MyScheduleQueryEnum.values());
    mPresenter.loadInitialQueries();
  }
 else {
    MyScheduleSingleDayFragment[] fragments=mViewPagerAdapter.getFragments();
    UpdatableView[] views=new UpdatableView[fragments.length];
    for (int i=0; i < fragments.length; i++) {
      views[i]=fragments[i];
    }
    mPresenter=new PresenterImpl(model,views,MyScheduleModel.MyScheduleUserActionEnum.values(),MyScheduleModel.MyScheduleQueryEnum.values());
  }
}",0.9755452742894912
19096,"@Override protected void onDestroy(){
  super.onDestroy();
  mDestroyed=true;
  mPresenter.cleanUp();
}","@Override protected void onDestroy(){
  super.onDestroy();
  mDestroyed=true;
}",0.8681318681318682
19097,"private void detectNarrowOrWideMode(){
  mWideMode=getFragmentManager().findFragmentById(R.id.myScheduleWideFrag) != null;
}","private void detectNarrowOrWideMode(){
  mWideMode=getFragmentManager().findFragmentById(R.id.myScheduleWideFrag) != null && findViewById(R.id.view_pager).getVisibility() == View.GONE;
}",0.8
19098,"private void updateSchedule(MyScheduleModel model){
  if (MyScheduleModel.showPreConferenceData(getContext())) {
    if (mPreConferenceDayView.getAdapter() == null) {
      mPreConferenceDayView.setAdapter(new MyScheduleDayAdapter(getActivity(),((MyScheduleActivity)getActivity()).getLUtils(),mListener));
    }
    mPreConferenceDayView.getAdapter().updateItems(model.getConferenceDataForDay(MyScheduleModel.PRE_CONFERENCE_DAY_ID));
  }
  for (int i=0; i < mMyScheduleSingleDayViews.length; i++) {
    if (mMyScheduleSingleDayViews[i].getAdapter() == null) {
      mMyScheduleSingleDayViews[i].setAdapter(new MyScheduleDayAdapter(getActivity(),((MyScheduleActivity)getActivity()).getLUtils(),mListener));
    }
    mMyScheduleSingleDayViews[i].getAdapter().updateItems(model.getConferenceDataForDay(i + 1));
  }
}","private void updateSchedule(MyScheduleModel model){
  if (isVisible()) {
    if (MyScheduleModel.showPreConferenceData(getContext())) {
      if (mPreConferenceDayView.getAdapter() == null) {
        mPreConferenceDayView.setAdapter(new MyScheduleDayAdapter(getActivity(),((MyScheduleActivity)getActivity()).getLUtils(),mListener));
      }
      mPreConferenceDayView.getAdapter().updateItems(model.getConferenceDataForDay(MyScheduleModel.PRE_CONFERENCE_DAY_ID));
    }
    for (int i=0; i < mMyScheduleSingleDayViews.length; i++) {
      if (mMyScheduleSingleDayViews[i].getAdapter() == null) {
        mMyScheduleSingleDayViews[i].setAdapter(new MyScheduleDayAdapter(getActivity(),((MyScheduleActivity)getActivity()).getLUtils(),mListener));
      }
      mMyScheduleSingleDayViews[i].getAdapter().updateItems(model.getConferenceDataForDay(i + 1));
    }
  }
}",0.9707811568276684
19099,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View root=inflater.inflate(R.layout.my_schedule_alldays_frag,container,false);
  mMyScheduleSingleDayViews[0]=(MyScheduleSingleDayNoScrollView)root.findViewById(R.id.my_schedule_first_day);
  mMyScheduleSingleDayViews[1]=(MyScheduleSingleDayNoScrollView)root.findViewById(R.id.my_schedule_second_day);
  return root;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View root=inflater.inflate(R.layout.my_schedule_alldays_frag,container,false);
  mMyScheduleSingleDayViews[0]=(MyScheduleSingleDayNoScrollView)root.findViewById(R.id.my_schedule_first_day);
  mMyScheduleSingleDayViews[1]=(MyScheduleSingleDayNoScrollView)root.findViewById(R.id.my_schedule_second_day);
  mMyScheduleSingleDayViews[2]=(MyScheduleSingleDayNoScrollView)root.findViewById(R.id.my_schedule_third_day);
  setRetainInstance(false);
  return root;
}",0.837865055387714
19100,"private void initViews(){
  TextView firstDayHeaderView=(TextView)getActivity().findViewById(R.id.day_label_first_day);
  TextView secondDayHeaderView=(TextView)getActivity().findViewById(R.id.day_label_second_day);
  if (firstDayHeaderView != null) {
    firstDayHeaderView.setText(TimeUtils.getDayName(getContext(),0));
  }
  if (secondDayHeaderView != null) {
    secondDayHeaderView.setText(TimeUtils.getDayName(getContext(),1));
  }
  mPreConferenceDayView=(MyScheduleSingleDayNoScrollView)getActivity().findViewById(R.id.my_schedule_zeroth_day);
  TextView zerothDayHeaderView=(TextView)getActivity().findViewById(R.id.day_label_zeroth_day);
  if (MyScheduleModel.showPreConferenceData(getContext())) {
    mPreConferenceDayView.setVisibility(View.VISIBLE);
    zerothDayHeaderView.setText(TimeUtils.getDayName(getContext(),-1));
    zerothDayHeaderView.setVisibility(View.VISIBLE);
  }
 else {
    mPreConferenceDayView.setVisibility(View.GONE);
    zerothDayHeaderView.setVisibility(View.GONE);
  }
}","private void initViews(){
  TextView firstDayHeaderView=(TextView)getActivity().findViewById(R.id.day_label_first_day);
  TextView secondDayHeaderView=(TextView)getActivity().findViewById(R.id.day_label_second_day);
  TextView thirdDayHeaderView=(TextView)getActivity().findViewById(R.id.day_label_third_day);
  if (firstDayHeaderView != null) {
    firstDayHeaderView.setText(TimeUtils.getDayName(getContext(),0));
  }
  if (secondDayHeaderView != null) {
    secondDayHeaderView.setText(TimeUtils.getDayName(getContext(),1));
  }
  if (thirdDayHeaderView != null) {
    thirdDayHeaderView.setText(TimeUtils.getDayName(getContext(),2));
  }
  mPreConferenceDayView=(MyScheduleSingleDayNoScrollView)getActivity().findViewById(R.id.my_schedule_zeroth_day);
  TextView zerothDayHeaderView=(TextView)getActivity().findViewById(R.id.day_label_zeroth_day);
  if (MyScheduleModel.showPreConferenceData(getContext())) {
    mPreConferenceDayView.setVisibility(View.VISIBLE);
    zerothDayHeaderView.setText(TimeUtils.getDayName(getContext(),-1));
    zerothDayHeaderView.setVisibility(View.VISIBLE);
  }
 else {
    mPreConferenceDayView.setVisibility(View.GONE);
    zerothDayHeaderView.setVisibility(View.GONE);
  }
}",0.9081081081081082
19101,"@Override public void onStatusChanged(int which){
  runOnUiThread(new Runnable(){
    @Override public void run(){
      String accountName=AccountUtils.getActiveAccountName(BaseActivity.this);
      if (TextUtils.isEmpty(accountName)) {
        onRefreshingStateChanged(false);
        mManualSyncRequest=false;
        return;
      }
      Account account=new Account(accountName,GoogleAuthUtil.GOOGLE_ACCOUNT_TYPE);
      boolean syncActive=ContentResolver.isSyncActive(account,ScheduleContract.CONTENT_AUTHORITY);
      boolean syncPending=ContentResolver.isSyncPending(account,ScheduleContract.CONTENT_AUTHORITY);
      if (!syncActive && !syncPending) {
        mManualSyncRequest=false;
      }
      onRefreshingStateChanged(syncActive || mManualSyncRequest);
    }
  }
);
}","@Override public void onStatusChanged(int which){
  runOnUiThread(new Runnable(){
    @Override public void run(){
      String accountName=AccountUtils.getActiveAccountName(BaseActivity.this);
      if (TextUtils.isEmpty(accountName)) {
        onRefreshingStateChanged(false);
        return;
      }
      Account account=new Account(accountName,GoogleAuthUtil.GOOGLE_ACCOUNT_TYPE);
      boolean syncActive=ContentResolver.isSyncActive(account,ScheduleContract.CONTENT_AUTHORITY);
      onRefreshingStateChanged(syncActive);
    }
  }
);
}",0.7631975867269984
19102,"@Override public void run(){
  String accountName=AccountUtils.getActiveAccountName(BaseActivity.this);
  if (TextUtils.isEmpty(accountName)) {
    onRefreshingStateChanged(false);
    mManualSyncRequest=false;
    return;
  }
  Account account=new Account(accountName,GoogleAuthUtil.GOOGLE_ACCOUNT_TYPE);
  boolean syncActive=ContentResolver.isSyncActive(account,ScheduleContract.CONTENT_AUTHORITY);
  boolean syncPending=ContentResolver.isSyncPending(account,ScheduleContract.CONTENT_AUTHORITY);
  if (!syncActive && !syncPending) {
    mManualSyncRequest=false;
  }
  onRefreshingStateChanged(syncActive || mManualSyncRequest);
}","@Override public void run(){
  String accountName=AccountUtils.getActiveAccountName(BaseActivity.this);
  if (TextUtils.isEmpty(accountName)) {
    onRefreshingStateChanged(false);
    return;
  }
  Account account=new Account(accountName,GoogleAuthUtil.GOOGLE_ACCOUNT_TYPE);
  boolean syncActive=ContentResolver.isSyncActive(account,ScheduleContract.CONTENT_AUTHORITY);
  onRefreshingStateChanged(syncActive);
}",0.7241379310344828
19103,"protected void requestDataRefresh(){
  Account activeAccount=AccountUtils.getActiveAccount(this);
  ContentResolver contentResolver=getContentResolver();
  if (contentResolver.isSyncActive(activeAccount,ScheduleContract.CONTENT_AUTHORITY)) {
    LOGD(TAG,""String_Node_Str"");
    return;
  }
  mManualSyncRequest=true;
  LOGD(TAG,""String_Node_Str"");
  SyncHelper.requestManualSync(activeAccount);
}","protected void requestDataRefresh(){
  Account activeAccount=AccountUtils.getActiveAccount(this);
  ContentResolver contentResolver=getContentResolver();
  if (contentResolver.isSyncActive(activeAccount,ScheduleContract.CONTENT_AUTHORITY)) {
    LOGD(TAG,""String_Node_Str"");
    return;
  }
  LOGD(TAG,""String_Node_Str"");
  SyncHelper.requestManualSync(activeAccount);
}",0.9647979139504564
19104,"private void displaySessionData(final SessionDetailModel data){
  mTitle.setText(data.getSessionTitle());
  mSubtitle.setText(data.getSessionSubtitle());
  mPhotoViewContainer.setBackgroundColor(UIUtils.scaleSessionColorToDefaultBG(data.getSessionColor()));
  if (data.hasPhotoUrl()) {
    mHasPhoto=true;
    mNoPlaceholderImageLoader.loadImage(data.getPhotoUrl(),mPhotoView,new RequestListener<String,Bitmap>(){
      @Override public boolean onException(      Exception e,      String model,      Target<Bitmap> target,      boolean isFirstResource){
        mHasPhoto=false;
        recomputePhotoAndScrollingMetrics();
        return false;
      }
      @Override public boolean onResourceReady(      Bitmap resource,      String model,      Target<Bitmap> target,      boolean isFromMemoryCache,      boolean isFirstResource){
        recomputePhotoAndScrollingMetrics();
        return false;
      }
    }
);
    recomputePhotoAndScrollingMetrics();
  }
 else {
    mHasPhoto=false;
    recomputePhotoAndScrollingMetrics();
  }
  tryExecuteDeferredUiOperations();
  mAddScheduleButton.setVisibility((AccountUtils.hasActiveAccount(getContext()) && !data.isKeynote()) ? View.VISIBLE : View.INVISIBLE);
  displayTags(data);
  if (!data.isKeynote()) {
    showStarredDeferred(data.isInSchedule(),false);
  }
  if (!TextUtils.isEmpty(data.getSessionAbstract())) {
    UIUtils.setTextMaybeHtml(mAbstract,data.getSessionAbstract());
    mAbstract.setVisibility(View.VISIBLE);
  }
 else {
    mAbstract.setVisibility(View.GONE);
  }
  final View requirementsBlock=getActivity().findViewById(R.id.session_requirements_block);
  final String sessionRequirements=data.getRequirements();
  if (!TextUtils.isEmpty(sessionRequirements)) {
    UIUtils.setTextMaybeHtml(mRequirements,sessionRequirements);
    requirementsBlock.setVisibility(View.VISIBLE);
  }
 else {
    requirementsBlock.setVisibility(View.GONE);
  }
  final ViewGroup relatedVideosBlock=(ViewGroup)getActivity().findViewById(R.id.related_videos_block);
  relatedVideosBlock.setVisibility(View.GONE);
  updateEmptyView(data);
  updateTimeBasedUi(data);
  if (data.getLiveStreamVideoWatched()) {
    mPhotoView.setColorFilter(getContext().getResources().getColor(R.color.video_scrim_watched));
    mLiveStreamPlayIconAndText.setText(getString(R.string.session_replay));
  }
  if (data.hasLiveStream()) {
    mLiveStreamPlayIconAndText.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        String videoId=YouTubeUtils.getVideoIdFromSessionData(data.getYouTubeUrl(),data.getLiveStreamId());
        YouTubeUtils.showYouTubeVideo(videoId,getActivity());
      }
    }
);
  }
  fireAnalyticsScreenView(data.getSessionTitle());
  mHandler.post(new Runnable(){
    @Override public void run(){
      onScrollChanged(0,0);
      mScrollViewChild.setVisibility(View.VISIBLE);
    }
  }
);
  mTimeHintUpdaterRunnable=new Runnable(){
    @Override public void run(){
      if (getActivity() == null) {
        return;
      }
      updateTimeBasedUi(data);
      mHandler.postDelayed(mTimeHintUpdaterRunnable,SessionDetailConstants.TIME_HINT_UPDATE_INTERVAL);
    }
  }
;
  mHandler.postDelayed(mTimeHintUpdaterRunnable,SessionDetailConstants.TIME_HINT_UPDATE_INTERVAL);
}","private void displaySessionData(final SessionDetailModel data){
  mTitle.setText(data.getSessionTitle());
  mSubtitle.setText(data.getSessionSubtitle());
  mPhotoViewContainer.setBackgroundColor(UIUtils.scaleSessionColorToDefaultBG(data.getSessionColor()));
  if (data.hasPhotoUrl()) {
    mHasPhoto=true;
    mNoPlaceholderImageLoader.loadImage(data.getPhotoUrl(),mPhotoView,new RequestListener<String,Bitmap>(){
      @Override public boolean onException(      Exception e,      String model,      Target<Bitmap> target,      boolean isFirstResource){
        mHasPhoto=false;
        recomputePhotoAndScrollingMetrics();
        return false;
      }
      @Override public boolean onResourceReady(      Bitmap resource,      String model,      Target<Bitmap> target,      boolean isFromMemoryCache,      boolean isFirstResource){
        recomputePhotoAndScrollingMetrics();
        return false;
      }
    }
);
    recomputePhotoAndScrollingMetrics();
  }
 else {
    mHasPhoto=false;
    recomputePhotoAndScrollingMetrics();
  }
  tryExecuteDeferredUiOperations();
  mAddScheduleButton.setVisibility((AccountUtils.hasActiveAccount(getContext()) && !data.isKeynote()) ? View.VISIBLE : View.INVISIBLE);
  displayTags(data);
  if (!data.isKeynote()) {
    showStarredDeferred(data.isInSchedule(),false);
  }
  if (!TextUtils.isEmpty(data.getSessionAbstract())) {
    UIUtils.setTextMaybeHtml(mAbstract,data.getSessionAbstract());
    mAbstract.setVisibility(View.VISIBLE);
  }
 else {
    mAbstract.setVisibility(View.GONE);
  }
  final View requirementsBlock=getActivity().findViewById(R.id.session_requirements_block);
  final String sessionRequirements=data.getRequirements();
  if (!TextUtils.isEmpty(sessionRequirements)) {
    UIUtils.setTextMaybeHtml(mRequirements,sessionRequirements);
    requirementsBlock.setVisibility(View.VISIBLE);
  }
 else {
    requirementsBlock.setVisibility(View.GONE);
  }
  final ViewGroup relatedVideosBlock=(ViewGroup)getActivity().findViewById(R.id.related_videos_block);
  relatedVideosBlock.setVisibility(View.GONE);
  updateEmptyView(data);
  updateTimeBasedUi(data);
  if (data.getLiveStreamVideoWatched()) {
    mPhotoView.setColorFilter(getContext().getResources().getColor(R.color.played_video_tint));
    mLiveStreamPlayIconAndText.setText(getString(R.string.session_replay));
  }
  if (data.hasLiveStream()) {
    mLiveStreamPlayIconAndText.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        String videoId=YouTubeUtils.getVideoIdFromSessionData(data.getYouTubeUrl(),data.getLiveStreamId());
        YouTubeUtils.showYouTubeVideo(videoId,getActivity());
      }
    }
);
  }
  fireAnalyticsScreenView(data.getSessionTitle());
  mHandler.post(new Runnable(){
    @Override public void run(){
      onScrollChanged(0,0);
      mScrollViewChild.setVisibility(View.VISIBLE);
    }
  }
);
  mTimeHintUpdaterRunnable=new Runnable(){
    @Override public void run(){
      if (getActivity() == null) {
        return;
      }
      updateTimeBasedUi(data);
      mHandler.postDelayed(mTimeHintUpdaterRunnable,SessionDetailConstants.TIME_HINT_UPDATE_INTERVAL);
    }
  }
;
  mHandler.postDelayed(mTimeHintUpdaterRunnable,SessionDetailConstants.TIME_HINT_UPDATE_INTERVAL);
}",0.9963358778625954
19105,"public VideoThumbnail(final Context context,final AttributeSet attrs,final int defStyleAttr){
  super(context,attrs,defStyleAttr);
  final TypedArray a=getContext().obtainStyledAttributes(attrs,R.styleable.VideoThumbnail,defStyleAttr,0);
  mPlayIcon=a.getDrawable(R.styleable.VideoThumbnail_playIcon);
  a.recycle();
  setScaleType(ScaleType.CENTER_CROP);
}","public VideoThumbnail(final Context context,final AttributeSet attrs,final int defStyleAttr){
  super(context,attrs,defStyleAttr);
  final TypedArray a=getContext().obtainStyledAttributes(attrs,R.styleable.VideoThumbnail,defStyleAttr,0);
  mPlayIcon=a.getDrawable(R.styleable.VideoThumbnail_playIcon);
  mPlayedTint=a.getColor(R.styleable.VideoThumbnail_playedTint,Color.TRANSPARENT);
  a.recycle();
  setScaleType(ScaleType.CENTER_CROP);
}",0.7979924717691342
19106,"public void setPlayed(final boolean played){
  if (mIsPlayed != played) {
    mIsPlayed=played;
    refreshDrawableState();
    invalidate();
  }
}","public void setPlayed(final boolean played){
  if (mIsPlayed != played) {
    mIsPlayed=played;
    if (played) {
      setColorFilter(mPlayedTint);
    }
 else {
      clearColorFilter();
    }
    invalidate();
  }
}",0.684931506849315
19107,"@Override public void displayData(final VideoLibraryModel model,final VideoLibraryQueryEnum query){
  if ((VideoLibraryModel.VideoLibraryQueryEnum.VIDEOS == query || VideoLibraryModel.VideoLibraryQueryEnum.MY_VIEWED_VIDEOS == query) && model.hasVideos()) {
    if (mAdapter == null) {
      mAdapter=new VideosAdapter(getActivity(),model,mImageLoader,mListeners);
      mCardList.setAdapter(mAdapter);
    }
 else {
      mAdapter.update(model);
    }
    mEmptyView.setVisibility(View.GONE);
  }
 else {
    mEmptyView.setVisibility(View.VISIBLE);
  }
}","@Override public void displayData(final VideoLibraryModel model,final VideoLibraryQueryEnum query){
  if ((VideoLibraryModel.VideoLibraryQueryEnum.VIDEOS == query || VideoLibraryModel.VideoLibraryQueryEnum.MY_VIEWED_VIDEOS == query) && model.hasVideos()) {
    if (mAdapter == null) {
      mAdapter=new VideosAdapter(getActivity(),model,mImageLoader,mListeners);
      mCardList.setAdapter(mAdapter);
    }
 else {
      mAdapter.update(model);
    }
  }
  mEmptyView.setVisibility((mAdapter != null && mAdapter.getItemCount() > 0) ? View.GONE : View.VISIBLE);
}",0.8845120859444942
19108,"/** 
 * Get the list of   {@link MessageData} to be displayed to the user,based upon time, location etc.
 * @return messages to be displayed.
 */
public List<MessageData> getMessages(){
  final List<MessageData> messages=new ArrayList<>();
  if (SettingsUtils.isAttendeeAtVenue(mContext)) {
    if (!ConfMessageCardUtils.hasAnsweredConfMessageCardsPrompt(mContext)) {
      messages.add(MessageCardHelper.getConferenceOptInMessageData(mContext));
    }
 else     if (ConfMessageCardUtils.isConfMessageCardsEnabled(mContext)) {
      ConfMessageCardUtils.enableActiveCards(mContext);
      if (shouldShowCard(ConfMessageCardUtils.ConfMessageCard.CONFERENCE_CREDENTIALS)) {
        messages.add(MessageCardHelper.getConferenceCredentialsMessageData(mContext));
      }
 else       if (shouldShowCard(ConfMessageCardUtils.ConfMessageCard.KEYNOTE_ACCESS)) {
        messages.add(MessageCardHelper.getKeynoteAccessMessageData(mContext));
      }
 else       if (shouldShowCard(ConfMessageCardUtils.ConfMessageCard.AFTER_HOURS)) {
        messages.add(MessageCardHelper.getAfterHoursMessageData(mContext));
      }
 else       if (shouldShowCard(ConfMessageCardUtils.ConfMessageCard.WIFI_FEEDBACK)) {
        if (WiFiUtils.isWiFiEnabled(mContext) && WiFiUtils.isWiFiApConfigured(mContext)) {
          messages.add(MessageCardHelper.getWifiFeedbackMessageData(mContext));
        }
      }
    }
    if (WiFiUtils.shouldOfferToSetupWifi(mContext,true)) {
      messages.add(MessageCardHelper.getWifiSetupMessageData(mContext));
    }
  }
  return messages;
}","/** 
 * Get the list of   {@link MessageData} to be displayed to the user, based upon time, locationetc.
 * @return messages to be displayed.
 */
public List<MessageData> getMessages(){
  final List<MessageData> messages=new ArrayList<>();
  if (SettingsUtils.isAttendeeAtVenue(mContext)) {
    if (!ConfMessageCardUtils.hasAnsweredConfMessageCardsPrompt(mContext)) {
      messages.add(MessageCardHelper.getConferenceOptInMessageData(mContext));
    }
 else     if (ConfMessageCardUtils.isConfMessageCardsEnabled(mContext)) {
      ConfMessageCardUtils.enableActiveCards(mContext);
      if (shouldShowCard(ConfMessageCardUtils.ConfMessageCard.CONFERENCE_CREDENTIALS)) {
        messages.add(MessageCardHelper.getConferenceCredentialsMessageData(mContext));
      }
 else       if (shouldShowCard(ConfMessageCardUtils.ConfMessageCard.KEYNOTE_ACCESS)) {
        messages.add(MessageCardHelper.getKeynoteAccessMessageData(mContext));
      }
 else       if (shouldShowCard(ConfMessageCardUtils.ConfMessageCard.AFTER_HOURS)) {
        messages.add(MessageCardHelper.getAfterHoursMessageData(mContext));
      }
 else       if (shouldShowCard(ConfMessageCardUtils.ConfMessageCard.WIFI_FEEDBACK)) {
        if (WiFiUtils.isWiFiEnabled(mContext) && WiFiUtils.isWiFiApConfigured(mContext)) {
          messages.add(MessageCardHelper.getWifiFeedbackMessageData(mContext));
        }
      }
    }
    if (WiFiUtils.shouldOfferToSetupWifi(mContext,true)) {
      messages.add(MessageCardHelper.getWifiSetupMessageData(mContext));
    }
  }
  return messages;
}",0.9993556701030928
19109,"private void populateSessionFromCursorRow(SessionData session,Cursor cursor){
  session.updateData(cursor.getString(cursor.getColumnIndex(ScheduleContract.Sessions.SESSION_TITLE)),cursor.getString(cursor.getColumnIndex(ScheduleContract.Sessions.SESSION_ABSTRACT)),cursor.getString(cursor.getColumnIndex(ScheduleContract.Sessions.SESSION_ID)),cursor.getString(cursor.getColumnIndex(ScheduleContract.Sessions.SESSION_PHOTO_URL)),cursor.getString(cursor.getColumnIndex(ScheduleContract.Sessions.SESSION_MAIN_TAG)),cursor.getLong(cursor.getColumnIndex(ScheduleContract.Sessions.SESSION_START)),cursor.getLong(cursor.getColumnIndex(ScheduleContract.Sessions.SESSION_END)),cursor.getString(cursor.getColumnIndex(ScheduleContract.Sessions.SESSION_LIVESTREAM_ID)),cursor.getString(cursor.getColumnIndex(ScheduleContract.Sessions.SESSION_YOUTUBE_URL)),cursor.getString(cursor.getColumnIndex(ScheduleContract.Sessions.SESSION_TAGS)),cursor.getLong(cursor.getColumnIndex(ScheduleContract.Sessions.SESSION_IN_MY_SCHEDULE)) == 1L);
}","private void populateSessionFromCursorRow(SessionData session,Cursor cursor){
  session.updateData(mContext,cursor.getString(cursor.getColumnIndex(ScheduleContract.Sessions.SESSION_TITLE)),cursor.getString(cursor.getColumnIndex(ScheduleContract.Sessions.SESSION_ABSTRACT)),cursor.getString(cursor.getColumnIndex(ScheduleContract.Sessions.SESSION_ID)),cursor.getString(cursor.getColumnIndex(ScheduleContract.Sessions.SESSION_PHOTO_URL)),cursor.getString(cursor.getColumnIndex(ScheduleContract.Sessions.SESSION_MAIN_TAG)),cursor.getLong(cursor.getColumnIndex(ScheduleContract.Sessions.SESSION_START)),cursor.getLong(cursor.getColumnIndex(ScheduleContract.Sessions.SESSION_END)),cursor.getString(cursor.getColumnIndex(ScheduleContract.Sessions.SESSION_LIVESTREAM_ID)),cursor.getString(cursor.getColumnIndex(ScheduleContract.Sessions.SESSION_YOUTUBE_URL)),cursor.getString(cursor.getColumnIndex(ScheduleContract.Sessions.SESSION_TAGS)),cursor.getLong(cursor.getColumnIndex(ScheduleContract.Sessions.SESSION_IN_MY_SCHEDULE)) == 1L);
}",0.9956076134699854
19110,"private void rewriteKeynoteDetails(SessionData keynoteData){
  long startTime, endTime, currentTime;
  currentTime=TimeUtils.getCurrentTime(mContext);
  if (keynoteData.getStartDate() != null) {
    startTime=keynoteData.getStartDate().getTime();
  }
 else {
    LOGD(TAG,""String_Node_Str"");
    startTime=0;
  }
  if (keynoteData.getEndDate() != null) {
    endTime=keynoteData.getEndDate().getTime();
  }
 else {
    LOGD(TAG,""String_Node_Str"");
    endTime=Long.MAX_VALUE;
  }
  StringBuilder stringBuilder=new StringBuilder();
  if (currentTime >= startTime && currentTime < endTime) {
    stringBuilder.append(mContext.getString(R.string.live_now));
  }
 else {
    stringBuilder.append(TimeUtils.formatShortDateTime(mContext,keynoteData.getStartDate()));
  }
  keynoteData.setDetails(stringBuilder.toString());
}","private void rewriteKeynoteDetails(SessionData keynoteData){
  long startTime, endTime, currentTime;
  currentTime=TimeUtils.getCurrentTime(mContext);
  if (keynoteData.getStartDate() != null) {
    startTime=keynoteData.getStartDate().getTimeInMillis();
  }
 else {
    LOGD(TAG,""String_Node_Str"");
    startTime=0;
  }
  if (keynoteData.getEndDate() != null) {
    endTime=keynoteData.getEndDate().getTimeInMillis();
  }
 else {
    LOGD(TAG,""String_Node_Str"");
    endTime=Long.MAX_VALUE;
  }
  StringBuilder stringBuilder=new StringBuilder();
  if (currentTime >= startTime && currentTime < endTime) {
    stringBuilder.append(mContext.getString(R.string.live_now));
  }
 else {
    stringBuilder.append(TimeUtils.formatShortDateTime(mContext,keynoteData.getStartDate().getTime()));
  }
  keynoteData.setDetails(stringBuilder.toString());
}",0.9843561973525872
19111,"private void reloadSessionData(Cursor cursor){
  mSessionList.setAdapter(null);
  mSessionsAdapter=null;
  final ExploreSessionsModel model=new ExploreSessionsModel(cursor);
  if (model.getSessionData() == null || model.getSessionData().isEmpty()) {
    mEmptyView.setVisibility(View.VISIBLE);
    return;
  }
  final GridLayoutManager glm=(GridLayoutManager)mSessionList.getLayoutManager();
  mSessionsAdapter=SessionsAdapter.createVerticalGrid(getActivity(),model.getSessionData(),glm.getSpanCount());
  glm.setSpanSizeLookup(new GridLayoutManager.SpanSizeLookup(){
    @Override public int getSpanSize(    final int position){
      return mSessionsAdapter.getSpanSize(position);
    }
  }
);
  mSessionList.setAdapter(mSessionsAdapter);
  mEmptyView.setVisibility(View.GONE);
}","private void reloadSessionData(Cursor cursor){
  mSessionList.setAdapter(null);
  mSessionsAdapter=null;
  final ExploreSessionsModel model=new ExploreSessionsModel(cursor,getActivity());
  if (model.getSessionData() == null || model.getSessionData().isEmpty()) {
    mEmptyView.setVisibility(View.VISIBLE);
    return;
  }
  final GridLayoutManager glm=(GridLayoutManager)mSessionList.getLayoutManager();
  mSessionsAdapter=SessionsAdapter.createVerticalGrid(getActivity(),model.getSessionData(),glm.getSpanCount());
  glm.setSpanSizeLookup(new GridLayoutManager.SpanSizeLookup(){
    @Override public int getSpanSize(    final int position){
      return mSessionsAdapter.getSpanSize(position);
    }
  }
);
  mSessionList.setAdapter(mSessionsAdapter);
  mEmptyView.setVisibility(View.GONE);
}",0.9911167512690356
19112,"public ExploreSessionsModel(Cursor cursor){
  if (cursor != null && cursor.moveToFirst()) {
    mSessionData=new ArrayList<>(cursor.getCount());
    do {
      mSessionData.add(createSessionData(cursor));
    }
 while (cursor.moveToNext());
  }
 else {
    mSessionData=null;
  }
}","public ExploreSessionsModel(Cursor cursor,Context context){
  mContext=context;
  if (cursor != null && cursor.moveToFirst()) {
    mSessionData=new ArrayList<>(cursor.getCount());
    do {
      mSessionData.add(createSessionData(cursor));
    }
 while (cursor.moveToNext());
  }
 else {
    mSessionData=null;
  }
}",0.939799331103679
19113,"private SessionData createSessionData(Cursor cursor){
  return new SessionData(cursor.getString(ExploreSessionsQuery.TITLE),cursor.getString(ExploreSessionsQuery.ABSTRACT),cursor.getString(ExploreSessionsQuery.SESSION_ID),cursor.getString(ExploreSessionsQuery.PHOTO_URL),cursor.getString(ExploreSessionsQuery.MAIN_TAG),cursor.getLong(ExploreSessionsQuery.SESSION_START),cursor.getLong(ExploreSessionsQuery.SESSION_END),cursor.getString(ExploreSessionsQuery.LIVESTREAM_ID),cursor.getString(ExploreSessionsQuery.YOUTUBE_URL),cursor.getString(ExploreSessionsQuery.TAGS),cursor.getLong(ExploreSessionsQuery.IN_MY_SCHEDULE) == 1L);
}","private SessionData createSessionData(Cursor cursor){
  return new SessionData(mContext,cursor.getString(ExploreSessionsQuery.TITLE),cursor.getString(ExploreSessionsQuery.ABSTRACT),cursor.getString(ExploreSessionsQuery.SESSION_ID),cursor.getString(ExploreSessionsQuery.PHOTO_URL),cursor.getString(ExploreSessionsQuery.MAIN_TAG),cursor.getLong(ExploreSessionsQuery.SESSION_START),cursor.getLong(ExploreSessionsQuery.SESSION_END),cursor.getString(ExploreSessionsQuery.LIVESTREAM_ID),cursor.getString(ExploreSessionsQuery.YOUTUBE_URL),cursor.getString(ExploreSessionsQuery.TAGS),cursor.getLong(ExploreSessionsQuery.IN_MY_SCHEDULE) == 1L);
}",0.9928853754940712
19114,"private void bindCompactSession(CompactSessionViewHolder holder,final SessionData session){
  holder.footer.setText(TimeUtils.formatShortDateTime(mHost,session.getStartDate()));
}","private void bindCompactSession(CompactSessionViewHolder holder,final SessionData session){
  holder.footer.setText(TimeUtils.formatShortDateTime(mHost,session.getStartDate().getTime()));
}",0.9728260869565216
19115,"@Override public void onClick(final View v){
  final ViewGroup.LayoutParams lp=v.getLayoutParams();
  if (!(lp instanceof RecyclerView.LayoutParams))   return;
  final int position=((RecyclerView.LayoutParams)lp).getViewAdapterPosition();
  if (position == RecyclerView.NO_POSITION)   return;
  final SessionData sessionData=(SessionData)mItems.get(position);
  final Intent intent=new Intent(mHost,SessionDetailActivity.class);
  intent.setData(ScheduleContract.Sessions.buildSessionUri(sessionData.getSessionId()));
  ActivityCompat.startActivity(mHost,intent,null);
}","@Override public void onClick(final View v){
  final ViewGroup.LayoutParams lp=v.getLayoutParams();
  if (!(lp instanceof RecyclerView.LayoutParams)) {
    return;
  }
  final int position=((RecyclerView.LayoutParams)lp).getViewAdapterPosition();
  if (position == RecyclerView.NO_POSITION) {
    return;
  }
  final SessionData sessionData=(SessionData)mItems.get(position);
  final Intent intent=new Intent(mHost,SessionDetailActivity.class);
  intent.setData(ScheduleContract.Sessions.buildSessionUri(sessionData.getSessionId()));
  ActivityCompat.startActivity(mHost,intent,null);
}",0.9550173010380624
19116,"/** 
 * Process the given list of sessions. If we are in detail mode then insert day/time headers.
 */
private List processData(final List<SessionData> sessions){
  final List data=new ArrayList(sessions.size());
  Collections.sort(sessions,new Comparator<SessionData>(){
    @Override public int compare(    final SessionData lhs,    final SessionData rhs){
      return lhs.getStartDate().compareTo(rhs.getStartDate());
    }
  }
);
  if (mCompactMode) {
    data.addAll(sessions);
  }
 else {
    int day=-1, time=-1;
    for (    SessionData session : sessions) {
      if (session.getStartDate().getDate() > day) {
        day=session.getStartDate().getDate();
        data.add(new DayHeader(TimeUtils.formatShortDate(mHost,session.getStartDate())));
        time=-1;
      }
      if (session.getStartDate().getHours() > time) {
        time=session.getStartDate().getHours();
        data.add(new TimeHeader(TimeUtils.formatShortTime(mHost,session.getStartDate())));
      }
      data.add(session);
    }
  }
  return data;
}","/** 
 * Process the given list of sessions. If we are in detail mode then insert day/time headers.
 */
private List processData(final List<SessionData> sessions){
  final List data=new ArrayList(sessions.size());
  Collections.sort(sessions,new Comparator<SessionData>(){
    @Override public int compare(    final SessionData lhs,    final SessionData rhs){
      return lhs.getStartDate().compareTo(rhs.getStartDate());
    }
  }
);
  if (mCompactMode) {
    data.addAll(sessions);
  }
 else {
    int day=-1, time=-1;
    for (    SessionData session : sessions) {
      if (session.getStartDate().get(Calendar.DAY_OF_YEAR) > day) {
        day=session.getStartDate().get(Calendar.DAY_OF_YEAR);
        data.add(new DayHeader(TimeUtils.formatShortDate(mHost,session.getStartDate().getTime())));
        time=-1;
      }
      if (session.getStartDate().get(Calendar.HOUR_OF_DAY) > time) {
        time=session.getStartDate().get(Calendar.HOUR_OF_DAY);
        data.add(new TimeHeader(TimeUtils.formatShortTime(mHost,session.getStartDate().getTime())));
      }
      data.add(session);
    }
  }
  return data;
}",0.7569832402234636
19117,"@Override public void onStatusChanged(int which){
  runOnUiThread(new Runnable(){
    @Override public void run(){
      String accountName=AccountUtils.getActiveAccountName(BaseActivity.this);
      if (TextUtils.isEmpty(accountName)) {
        onRefreshingStateChanged(false);
        mManualSyncRequest=false;
        return;
      }
      Account account=new Account(accountName,GoogleAuthUtil.GOOGLE_ACCOUNT_TYPE);
      boolean syncActive=ContentResolver.isSyncActive(account,ScheduleContract.CONTENT_AUTHORITY);
      boolean syncPending=ContentResolver.isSyncPending(account,ScheduleContract.CONTENT_AUTHORITY);
      if (!syncActive && !syncPending) {
        mManualSyncRequest=false;
      }
      onRefreshingStateChanged(syncActive || mManualSyncRequest);
    }
  }
);
}","@Override public void onStatusChanged(int which){
  runOnUiThread(new Runnable(){
    @Override public void run(){
      String accountName=AccountUtils.getActiveAccountName(BaseActivity.this);
      if (TextUtils.isEmpty(accountName)) {
        onRefreshingStateChanged(false);
        return;
      }
      Account account=new Account(accountName,GoogleAuthUtil.GOOGLE_ACCOUNT_TYPE);
      boolean syncActive=ContentResolver.isSyncActive(account,ScheduleContract.CONTENT_AUTHORITY);
      onRefreshingStateChanged(syncActive);
    }
  }
);
}",0.7631975867269984
19118,"@Override public void run(){
  String accountName=AccountUtils.getActiveAccountName(BaseActivity.this);
  if (TextUtils.isEmpty(accountName)) {
    onRefreshingStateChanged(false);
    mManualSyncRequest=false;
    return;
  }
  Account account=new Account(accountName,GoogleAuthUtil.GOOGLE_ACCOUNT_TYPE);
  boolean syncActive=ContentResolver.isSyncActive(account,ScheduleContract.CONTENT_AUTHORITY);
  boolean syncPending=ContentResolver.isSyncPending(account,ScheduleContract.CONTENT_AUTHORITY);
  if (!syncActive && !syncPending) {
    mManualSyncRequest=false;
  }
  onRefreshingStateChanged(syncActive || mManualSyncRequest);
}","@Override public void run(){
  String accountName=AccountUtils.getActiveAccountName(BaseActivity.this);
  if (TextUtils.isEmpty(accountName)) {
    onRefreshingStateChanged(false);
    return;
  }
  Account account=new Account(accountName,GoogleAuthUtil.GOOGLE_ACCOUNT_TYPE);
  boolean syncActive=ContentResolver.isSyncActive(account,ScheduleContract.CONTENT_AUTHORITY);
  onRefreshingStateChanged(syncActive);
}",0.7241379310344828
19119,"protected void requestDataRefresh(){
  Account activeAccount=AccountUtils.getActiveAccount(this);
  ContentResolver contentResolver=getContentResolver();
  if (contentResolver.isSyncActive(activeAccount,ScheduleContract.CONTENT_AUTHORITY)) {
    LOGD(TAG,""String_Node_Str"");
    return;
  }
  mManualSyncRequest=true;
  LOGD(TAG,""String_Node_Str"");
  SyncHelper.requestManualSync(activeAccount);
}","protected void requestDataRefresh(){
  Account activeAccount=AccountUtils.getActiveAccount(this);
  ContentResolver contentResolver=getContentResolver();
  if (contentResolver.isSyncActive(activeAccount,ScheduleContract.CONTENT_AUTHORITY)) {
    LOGD(TAG,""String_Node_Str"");
    return;
  }
  LOGD(TAG,""String_Node_Str"");
  SyncHelper.requestManualSync(activeAccount);
}",0.9647979139504564
19120,"/** 
 * On Lollipop+ perform a circular reveal animation (an expanding circular mask) when showing the search panel.
 */
@TargetApi(Build.VERSION_CODES.LOLLIPOP) private void doEnterAnim(){
  View scrim=findViewById(R.id.scrim);
  scrim.animate().alpha(1f).setDuration(500L).setInterpolator(AnimationUtils.loadInterpolator(this,android.R.interpolator.fast_out_slow_in)).start();
  final View searchPanel=findViewById(R.id.search_panel);
  if (searchPanel != null) {
    searchPanel.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener(){
      @Override public boolean onPreDraw(){
        searchPanel.getViewTreeObserver().removeOnPreDrawListener(this);
        int revealRadius=((ViewGroup)searchPanel.getParent()).getHeight();
        Animator show=ViewAnimationUtils.createCircularReveal(searchPanel,searchPanel.getRight(),searchPanel.getTop(),0f,revealRadius);
        show.setDuration(250L);
        show.setInterpolator(AnimationUtils.loadInterpolator(SearchActivity.this,android.R.interpolator.fast_out_slow_in));
        show.start();
        return false;
      }
    }
);
  }
}","/** 
 * On Lollipop+ perform a circular reveal animation (an expanding circular mask) when showing the search panel.
 */
@TargetApi(Build.VERSION_CODES.LOLLIPOP) private void doEnterAnim(){
  View scrim=findViewById(R.id.scrim);
  scrim.animate().alpha(1f).setDuration(500L).setInterpolator(AnimationUtils.loadInterpolator(this,android.R.interpolator.fast_out_slow_in)).start();
  final View searchPanel=findViewById(R.id.search_panel);
  if (searchPanel != null) {
    searchPanel.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener(){
      @Override public boolean onPreDraw(){
        searchPanel.getViewTreeObserver().removeOnPreDrawListener(this);
        final ViewGroup searchPanelParent=(ViewGroup)searchPanel.getParent();
        final int revealRadius=(int)Math.hypot(searchPanelParent.getWidth(),searchPanelParent.getHeight());
        Animator show=ViewAnimationUtils.createCircularReveal(searchPanel,searchPanel.getRight(),searchPanel.getTop(),0f,revealRadius);
        show.setDuration(250L);
        show.setInterpolator(AnimationUtils.loadInterpolator(SearchActivity.this,android.R.interpolator.fast_out_slow_in));
        show.start();
        return false;
      }
    }
);
  }
}",0.926226012793177
19121,"@Override public boolean onPreDraw(){
  searchPanel.getViewTreeObserver().removeOnPreDrawListener(this);
  int revealRadius=((ViewGroup)searchPanel.getParent()).getHeight();
  Animator show=ViewAnimationUtils.createCircularReveal(searchPanel,searchPanel.getRight(),searchPanel.getTop(),0f,revealRadius);
  show.setDuration(250L);
  show.setInterpolator(AnimationUtils.loadInterpolator(SearchActivity.this,android.R.interpolator.fast_out_slow_in));
  show.start();
  return false;
}","@Override public boolean onPreDraw(){
  searchPanel.getViewTreeObserver().removeOnPreDrawListener(this);
  final ViewGroup searchPanelParent=(ViewGroup)searchPanel.getParent();
  final int revealRadius=(int)Math.hypot(searchPanelParent.getWidth(),searchPanelParent.getHeight());
  Animator show=ViewAnimationUtils.createCircularReveal(searchPanel,searchPanel.getRight(),searchPanel.getTop(),0f,revealRadius);
  show.setDuration(250L);
  show.setInterpolator(AnimationUtils.loadInterpolator(SearchActivity.this,android.R.interpolator.fast_out_slow_in));
  show.start();
  return false;
}",0.8359887535145267
19122,"/** 
 * On Lollipop+ perform a circular animation (a contracting circular mask) when hiding the search panel.
 */
@TargetApi(Build.VERSION_CODES.LOLLIPOP) private void doExitAnim(){
  final View searchPanel=findViewById(R.id.search_panel);
  int revealRadius=(int)Math.sqrt(Math.pow(searchPanel.getWidth(),2) + Math.pow(searchPanel.getHeight(),2));
  Animator shrink=ViewAnimationUtils.createCircularReveal(searchPanel,searchPanel.getRight(),searchPanel.getTop(),revealRadius,0f);
  shrink.setDuration(200L);
  shrink.setInterpolator(AnimationUtils.loadInterpolator(SearchActivity.this,android.R.interpolator.fast_out_slow_in));
  shrink.addListener(new AnimatorListenerAdapter(){
    @Override public void onAnimationEnd(    Animator animation){
      searchPanel.setVisibility(View.INVISIBLE);
      ActivityCompat.finishAfterTransition(SearchActivity.this);
    }
  }
);
  shrink.start();
  findViewById(R.id.scrim).animate().alpha(0f).setDuration(200L).setInterpolator(AnimationUtils.loadInterpolator(SearchActivity.this,android.R.interpolator.fast_out_slow_in)).start();
}","/** 
 * On Lollipop+ perform a circular animation (a contracting circular mask) when hiding the search panel.
 */
@TargetApi(Build.VERSION_CODES.LOLLIPOP) private void doExitAnim(){
  final View searchPanel=findViewById(R.id.search_panel);
  final int revealRadius=(int)Math.hypot(searchPanel.getWidth(),searchPanel.getHeight());
  Animator shrink=ViewAnimationUtils.createCircularReveal(searchPanel,searchPanel.getRight(),searchPanel.getTop(),revealRadius,0f);
  shrink.setDuration(200L);
  shrink.setInterpolator(AnimationUtils.loadInterpolator(SearchActivity.this,android.R.interpolator.fast_out_slow_in));
  shrink.addListener(new AnimatorListenerAdapter(){
    @Override public void onAnimationEnd(    Animator animation){
      searchPanel.setVisibility(View.INVISIBLE);
      ActivityCompat.finishAfterTransition(SearchActivity.this);
    }
  }
);
  shrink.start();
  findViewById(R.id.scrim).animate().alpha(0f).setDuration(200L).setInterpolator(AnimationUtils.loadInterpolator(SearchActivity.this,android.R.interpolator.fast_out_slow_in)).start();
}",0.9807962529274004
19123,"/** 
 * On Lollipop+ perform a circular reveal animation (an expanding circular mask) when showing the search panel.
 */
@TargetApi(Build.VERSION_CODES.LOLLIPOP) private void doEnterAnim(){
  View scrim=findViewById(R.id.scrim);
  scrim.animate().alpha(1f).setDuration(500L).setInterpolator(AnimationUtils.loadInterpolator(this,android.R.interpolator.fast_out_slow_in)).start();
  final View searchPanel=findViewById(R.id.search_panel);
  if (searchPanel != null) {
    searchPanel.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener(){
      @Override public boolean onPreDraw(){
        searchPanel.getViewTreeObserver().removeOnPreDrawListener(this);
        int revealRadius=((ViewGroup)searchPanel.getParent()).getHeight();
        Animator show=ViewAnimationUtils.createCircularReveal(searchPanel,searchPanel.getRight(),searchPanel.getTop(),0f,revealRadius);
        show.setDuration(250L);
        show.setInterpolator(AnimationUtils.loadInterpolator(SearchActivity.this,android.R.interpolator.fast_out_slow_in));
        show.start();
        return false;
      }
    }
);
  }
}","/** 
 * On Lollipop+ perform a circular reveal animation (an expanding circular mask) when showing the search panel.
 */
@TargetApi(Build.VERSION_CODES.LOLLIPOP) private void doEnterAnim(){
  View scrim=findViewById(R.id.scrim);
  scrim.animate().alpha(1f).setDuration(500L).setInterpolator(AnimationUtils.loadInterpolator(this,android.R.interpolator.fast_out_slow_in)).start();
  final View searchPanel=findViewById(R.id.search_panel);
  if (searchPanel != null) {
    searchPanel.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener(){
      @Override public boolean onPreDraw(){
        searchPanel.getViewTreeObserver().removeOnPreDrawListener(this);
        final ViewGroup searchPanelParent=(ViewGroup)searchPanel.getParent();
        final int revealRadius=(int)Math.hypot(searchPanelParent.getWidth(),searchPanelParent.getHeight());
        Animator show=ViewAnimationUtils.createCircularReveal(searchPanel,searchPanel.getRight(),searchPanel.getTop(),0f,revealRadius);
        show.setDuration(250L);
        show.setInterpolator(AnimationUtils.loadInterpolator(SearchActivity.this,android.R.interpolator.fast_out_slow_in));
        show.start();
        return false;
      }
    }
);
  }
}",0.926226012793177
19124,"@Override public boolean onPreDraw(){
  searchPanel.getViewTreeObserver().removeOnPreDrawListener(this);
  int revealRadius=((ViewGroup)searchPanel.getParent()).getHeight();
  Animator show=ViewAnimationUtils.createCircularReveal(searchPanel,searchPanel.getRight(),searchPanel.getTop(),0f,revealRadius);
  show.setDuration(250L);
  show.setInterpolator(AnimationUtils.loadInterpolator(SearchActivity.this,android.R.interpolator.fast_out_slow_in));
  show.start();
  return false;
}","@Override public boolean onPreDraw(){
  searchPanel.getViewTreeObserver().removeOnPreDrawListener(this);
  final ViewGroup searchPanelParent=(ViewGroup)searchPanel.getParent();
  final int revealRadius=(int)Math.hypot(searchPanelParent.getWidth(),searchPanelParent.getHeight());
  Animator show=ViewAnimationUtils.createCircularReveal(searchPanel,searchPanel.getRight(),searchPanel.getTop(),0f,revealRadius);
  show.setDuration(250L);
  show.setInterpolator(AnimationUtils.loadInterpolator(SearchActivity.this,android.R.interpolator.fast_out_slow_in));
  show.start();
  return false;
}",0.8359887535145267
19125,"/** 
 * On Lollipop+ perform a circular animation (a contracting circular mask) when hiding the search panel.
 */
@TargetApi(Build.VERSION_CODES.LOLLIPOP) private void doExitAnim(){
  final View searchPanel=findViewById(R.id.search_panel);
  int revealRadius=(int)Math.sqrt(Math.pow(searchPanel.getWidth(),2) + Math.pow(searchPanel.getHeight(),2));
  Animator shrink=ViewAnimationUtils.createCircularReveal(searchPanel,searchPanel.getRight(),searchPanel.getTop(),revealRadius,0f);
  shrink.setDuration(200L);
  shrink.setInterpolator(AnimationUtils.loadInterpolator(SearchActivity.this,android.R.interpolator.fast_out_slow_in));
  shrink.addListener(new AnimatorListenerAdapter(){
    @Override public void onAnimationEnd(    Animator animation){
      searchPanel.setVisibility(View.INVISIBLE);
      ActivityCompat.finishAfterTransition(SearchActivity.this);
    }
  }
);
  shrink.start();
  findViewById(R.id.scrim).animate().alpha(0f).setDuration(200L).setInterpolator(AnimationUtils.loadInterpolator(SearchActivity.this,android.R.interpolator.fast_out_slow_in)).start();
}","/** 
 * On Lollipop+ perform a circular animation (a contracting circular mask) when hiding the search panel.
 */
@TargetApi(Build.VERSION_CODES.LOLLIPOP) private void doExitAnim(){
  final View searchPanel=findViewById(R.id.search_panel);
  final int revealRadius=(int)Math.hypot(searchPanel.getWidth(),searchPanel.getHeight());
  Animator shrink=ViewAnimationUtils.createCircularReveal(searchPanel,searchPanel.getRight(),searchPanel.getTop(),revealRadius,0f);
  shrink.setDuration(200L);
  shrink.setInterpolator(AnimationUtils.loadInterpolator(SearchActivity.this,android.R.interpolator.fast_out_slow_in));
  shrink.addListener(new AnimatorListenerAdapter(){
    @Override public void onAnimationEnd(    Animator animation){
      searchPanel.setVisibility(View.INVISIBLE);
      ActivityCompat.finishAfterTransition(SearchActivity.this);
    }
  }
);
  shrink.start();
  findViewById(R.id.scrim).animate().alpha(0f).setDuration(200L).setInterpolator(AnimationUtils.loadInterpolator(SearchActivity.this,android.R.interpolator.fast_out_slow_in)).start();
}",0.9807962529274004
19126,"@Test public void accountName_IsDisplayed(){
  NavigationUtils.showNavigation();
  onView(withText(ACCOUNT_NAME)).check(matches(isDisplayed()));
}","@Test public void accountName_IsDisplayed(){
  NavigationUtils.showNavigation();
  onView(withText(mAccountName)).check(matches(isDisplayed()));
}",0.9315068493150684
19127,"@Override protected void beforeActivityLaunched(){
  SettingsUtils.markTosAccepted(InstrumentationRegistry.getTargetContext(),true);
  AccountUtils.setActiveAccount(InstrumentationRegistry.getTargetContext(),ACCOUNT_NAME);
  mStubLoginAndAuth=new StubLoginAndAuth(ACCOUNT_NAME,true,true);
  LoginAndAuthProvider.setStubLoginAndAuth(mStubLoginAndAuth);
}","@Override protected void beforeActivityLaunched(){
  SettingsUtils.markTosAccepted(InstrumentationRegistry.getTargetContext(),true);
  mAccountName=LoginUtils.setFirstAvailableAccountAsActive(InstrumentationRegistry.getTargetContext());
  mStubLoginAndAuth=new StubLoginAndAuth(mAccountName,true,true);
  LoginAndAuthProvider.setStubLoginAndAuth(mStubLoginAndAuth);
}",0.5472222222222223
19128,"@Test public void accountName_IsDisplayed(){
  NavigationUtils.showNavigation();
  onView(withText(ACCOUNT_NAME)).check(matches(isDisplayed()));
}","/** 
 * This will fail if there is no available account on the device
 */
@FlakyTest @Test public void accountName_IsDisplayed(){
  NavigationUtils.showNavigation();
  onView(withText(mAccountName)).check(matches(isDisplayed()));
}",0.7161803713527851
19129,"@Override protected void beforeActivityLaunched(){
  SettingsUtils.markTosAccepted(InstrumentationRegistry.getTargetContext(),true);
  AccountUtils.setActiveAccount(InstrumentationRegistry.getTargetContext(),ACCOUNT_NAME);
  mStubLoginAndAuth=new StubLoginAndAuth(ACCOUNT_NAME,false,true);
  LoginAndAuthProvider.setStubLoginAndAuth(mStubLoginAndAuth);
}","@Override protected void beforeActivityLaunched(){
  SettingsUtils.markTosAccepted(InstrumentationRegistry.getTargetContext(),true);
  mAccountName=LoginUtils.setFirstAvailableAccountAsActive(InstrumentationRegistry.getTargetContext());
  mStubLoginAndAuth=new StubLoginAndAuth(mAccountName,false,true);
  LoginAndAuthProvider.setStubLoginAndAuth(mStubLoginAndAuth);
}",0.7368421052631579
19130,"@Test public void accountName_IsDisplayed(){
  NavigationUtils.showNavigation();
  onView(withText(ACCOUNT_NAME)).check(matches(isDisplayed()));
}","@Test public void accountName_IsDisplayed(){
  NavigationUtils.showNavigation();
  onView(withText(mAccountName)).check(matches(isDisplayed()));
}",0.9315068493150684
19131,"@Override protected void beforeActivityLaunched(){
  SettingsUtils.markTosAccepted(InstrumentationRegistry.getTargetContext(),true);
  SettingsUtils.setAttendeeAtVenue(InstrumentationRegistry.getTargetContext(),true);
  AccountUtils.setActiveAccount(InstrumentationRegistry.getTargetContext(),ACCOUNT_NAME);
}","@Override protected void beforeActivityLaunched(){
  SettingsUtils.markTosAccepted(InstrumentationRegistry.getTargetContext(),true);
  SettingsUtils.setAttendeeAtVenue(InstrumentationRegistry.getTargetContext(),true);
  mAccountName=LoginUtils.setFirstAvailableAccountAsActive(InstrumentationRegistry.getTargetContext());
}",0.8734177215189873
19132,"@Test public void accountName_IsDisplayed(){
  NavigationUtils.showNavigation();
  onView(withText(ACCOUNT_NAME)).check(matches(isDisplayed()));
}","@Test public void accountName_IsDisplayed(){
  NavigationUtils.showNavigation();
  onView(withText(mAccountName)).check(matches(isDisplayed()));
}",0.9315068493150684
19133,"@Override protected void beforeActivityLaunched(){
  SettingsUtils.markTosAccepted(InstrumentationRegistry.getTargetContext(),true);
  SettingsUtils.setAttendeeAtVenue(InstrumentationRegistry.getTargetContext(),false);
  AccountUtils.setActiveAccount(InstrumentationRegistry.getTargetContext(),ACCOUNT_NAME);
}","@Override protected void beforeActivityLaunched(){
  SettingsUtils.markTosAccepted(InstrumentationRegistry.getTargetContext(),true);
  SettingsUtils.setAttendeeAtVenue(InstrumentationRegistry.getTargetContext(),false);
  mAccountName=LoginUtils.setFirstAvailableAccountAsActive(InstrumentationRegistry.getTargetContext());
}",0.8738170347003155
19134,"@Override public void onAuthFailure(String accountName){
  LOGD(TAG,""String_Node_Str"" + accountName);
  refreshAccountDependantData();
}","@Override public void onAuthFailure(String accountName){
  LOGD(TAG,""String_Node_Str"" + accountName);
  refreshAccountDependantData();
  mAppNavigationViewAsDrawer.updateNavigationItems();
}",0.8343558282208589
19135,"@Override public boolean canSwipeRefreshChildScrollUp(){
  if (mWideMode) {
    return ViewCompat.canScrollVertically(mScrollViewWide,-1);
  }
  if (mViewPagerScrollState == ViewPager.SCROLL_STATE_DRAGGING) {
    return true;
  }
  for (  MyScheduleSingleDayFragment fragment : mMyScheduleSingleDayFragments) {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1) {
      if (!fragment.getUserVisibleHint()) {
        continue;
      }
    }
    return ViewCompat.canScrollVertically(fragment.getListView(),-1);
  }
  return false;
}","@Override public boolean canSwipeRefreshChildScrollUp(){
  if (mWideMode) {
    return ViewCompat.canScrollVertically(mScrollViewWide,-1);
  }
  for (  MyScheduleSingleDayFragment fragment : mMyScheduleSingleDayFragments) {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1) {
      if (!fragment.getUserVisibleHint()) {
        continue;
      }
    }
    return ViewCompat.canScrollVertically(fragment.getListView(),-1);
  }
  return false;
}",0.9152872444011684
19136,"@Test public void accountName_IsDisplayed(){
  NavigationUtils.showNavigation();
  onView(withText(ACCOUNT_NAME)).check(matches(isDisplayed()));
}","@Test public void accountName_IsDisplayed(){
  NavigationUtils.showNavigation();
  onView(withText(mAccountName)).check(matches(isDisplayed()));
}",0.9315068493150684
19137,"@Override protected void beforeActivityLaunched(){
  SettingsUtils.markTosAccepted(InstrumentationRegistry.getTargetContext(),true);
  AccountUtils.setActiveAccount(InstrumentationRegistry.getTargetContext(),ACCOUNT_NAME);
  mStubLoginAndAuth=new StubLoginAndAuth(ACCOUNT_NAME,true,true);
  LoginAndAuthProvider.setStubLoginAndAuth(mStubLoginAndAuth);
}","@Override protected void beforeActivityLaunched(){
  SettingsUtils.markTosAccepted(InstrumentationRegistry.getTargetContext(),true);
  mAccountName=LoginUtils.setFirstAvailableAccountAsActive(InstrumentationRegistry.getTargetContext());
  mStubLoginAndAuth=new StubLoginAndAuth(mAccountName,true,true);
  LoginAndAuthProvider.setStubLoginAndAuth(mStubLoginAndAuth);
}",0.5472222222222223
19138,"@Test public void accountName_IsDisplayed(){
  NavigationUtils.showNavigation();
  onView(withText(ACCOUNT_NAME)).check(matches(isDisplayed()));
}","/** 
 * This will fail if there is no available account on the device
 */
@FlakyTest @Test public void accountName_IsDisplayed(){
  NavigationUtils.showNavigation();
  onView(withText(mAccountName)).check(matches(isDisplayed()));
}",0.7161803713527851
19139,"@Override protected void beforeActivityLaunched(){
  SettingsUtils.markTosAccepted(InstrumentationRegistry.getTargetContext(),true);
  AccountUtils.setActiveAccount(InstrumentationRegistry.getTargetContext(),ACCOUNT_NAME);
  mStubLoginAndAuth=new StubLoginAndAuth(ACCOUNT_NAME,false,true);
  LoginAndAuthProvider.setStubLoginAndAuth(mStubLoginAndAuth);
}","@Override protected void beforeActivityLaunched(){
  SettingsUtils.markTosAccepted(InstrumentationRegistry.getTargetContext(),true);
  mAccountName=LoginUtils.setFirstAvailableAccountAsActive(InstrumentationRegistry.getTargetContext());
  mStubLoginAndAuth=new StubLoginAndAuth(mAccountName,false,true);
  LoginAndAuthProvider.setStubLoginAndAuth(mStubLoginAndAuth);
}",0.7368421052631579
19140,"@Test public void accountName_IsDisplayed(){
  NavigationUtils.showNavigation();
  onView(withText(ACCOUNT_NAME)).check(matches(isDisplayed()));
}","@Test public void accountName_IsDisplayed(){
  NavigationUtils.showNavigation();
  onView(withText(mAccountName)).check(matches(isDisplayed()));
}",0.9315068493150684
19141,"@Override protected void beforeActivityLaunched(){
  SettingsUtils.markTosAccepted(InstrumentationRegistry.getTargetContext(),true);
  SettingsUtils.setAttendeeAtVenue(InstrumentationRegistry.getTargetContext(),true);
  AccountUtils.setActiveAccount(InstrumentationRegistry.getTargetContext(),ACCOUNT_NAME);
}","@Override protected void beforeActivityLaunched(){
  SettingsUtils.markTosAccepted(InstrumentationRegistry.getTargetContext(),true);
  SettingsUtils.setAttendeeAtVenue(InstrumentationRegistry.getTargetContext(),true);
  mAccountName=LoginUtils.setFirstAvailableAccountAsActive(InstrumentationRegistry.getTargetContext());
}",0.8734177215189873
19142,"@Test public void accountName_IsDisplayed(){
  NavigationUtils.showNavigation();
  onView(withText(ACCOUNT_NAME)).check(matches(isDisplayed()));
}","@Test public void accountName_IsDisplayed(){
  NavigationUtils.showNavigation();
  onView(withText(mAccountName)).check(matches(isDisplayed()));
}",0.9315068493150684
19143,"@Override protected void beforeActivityLaunched(){
  SettingsUtils.markTosAccepted(InstrumentationRegistry.getTargetContext(),true);
  SettingsUtils.setAttendeeAtVenue(InstrumentationRegistry.getTargetContext(),false);
  AccountUtils.setActiveAccount(InstrumentationRegistry.getTargetContext(),ACCOUNT_NAME);
}","@Override protected void beforeActivityLaunched(){
  SettingsUtils.markTosAccepted(InstrumentationRegistry.getTargetContext(),true);
  SettingsUtils.setAttendeeAtVenue(InstrumentationRegistry.getTargetContext(),false);
  mAccountName=LoginUtils.setFirstAvailableAccountAsActive(InstrumentationRegistry.getTargetContext());
}",0.8738170347003155
19144,"@Override public void onAuthFailure(String accountName){
  LOGD(TAG,""String_Node_Str"" + accountName);
  refreshAccountDependantData();
}","@Override public void onAuthFailure(String accountName){
  LOGD(TAG,""String_Node_Str"" + accountName);
  refreshAccountDependantData();
  mAppNavigationViewAsDrawer.updateNavigationItems();
}",0.8343558282208589
19145,"@Override public boolean canSwipeRefreshChildScrollUp(){
  if (mWideMode) {
    return ViewCompat.canScrollVertically(mScrollViewWide,-1);
  }
  if (mViewPagerScrollState == ViewPager.SCROLL_STATE_DRAGGING) {
    return true;
  }
  for (  MyScheduleSingleDayFragment fragment : mMyScheduleSingleDayFragments) {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1) {
      if (!fragment.getUserVisibleHint()) {
        continue;
      }
    }
    return ViewCompat.canScrollVertically(fragment.getListView(),-1);
  }
  return false;
}","@Override public boolean canSwipeRefreshChildScrollUp(){
  if (mWideMode) {
    return ViewCompat.canScrollVertically(mScrollViewWide,-1);
  }
  for (  MyScheduleSingleDayFragment fragment : mMyScheduleSingleDayFragments) {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1) {
      if (!fragment.getUserVisibleHint()) {
        continue;
      }
    }
    return ViewCompat.canScrollVertically(fragment.getListView(),-1);
  }
  return false;
}",0.9152872444011684
19146,"@Override public void deregisterHideableHeaderView(View hideableHeaderView){
  mHeaderViewImpl.deregisterHideableHeaderView(hideableHeaderView);
}","@Override public void deregisterHideableHeaderView(View hideableHeaderView){
  if (mHeaderViewImpl != null) {
    mHeaderViewImpl.deregisterHideableHeaderView(hideableHeaderView);
  }
}",0.8821752265861027
19147,"@Override public Toolbar getActionBarToolbar(){
  return mHeaderViewImpl.getActionBarToolbar();
}","@Override public Toolbar getActionBarToolbar(){
  if (mHeaderViewImpl != null) {
    return mHeaderViewImpl.getActionBarToolbar();
  }
 else {
    return null;
  }
}",0.7404580152671756
19148,"@Override public void registerHideableHeaderView(View hideableHeaderView){
  mHeaderViewImpl.registerHideableHeaderView(hideableHeaderView);
}","@Override public void registerHideableHeaderView(View hideableHeaderView){
  if (mHeaderViewImpl != null) {
    mHeaderViewImpl.registerHideableHeaderView(hideableHeaderView);
  }
}",0.8792569659442725
19149,"private void updateSwipeRefreshProgressBarTop(){
  if (mSwipeRefreshLayout == null) {
    return;
  }
  if (mActionBarShown) {
    mSwipeRefreshLayout.setProgressBarTop(mProgressBarTopWhenActionBarShown);
  }
 else {
    mSwipeRefreshLayout.setProgressBarTop(0);
  }
}","private void updateSwipeRefreshProgressBarTop(){
  if (mSwipeRefreshLayout == null) {
    return;
  }
  int progressBarStartMargin=getResources().getDimensionPixelSize(R.dimen.swipe_refresh_progress_bar_start_margin);
  int progressBarEndMargin=getResources().getDimensionPixelSize(R.dimen.swipe_refresh_progress_bar_end_margin);
  int top=mActionBarShown ? mProgressBarTopWhenActionBarShown : 0;
  mSwipeRefreshLayout.setProgressViewOffset(false,top + progressBarStartMargin,top + progressBarEndMargin);
}",0.4082687338501292
19150,"private void trySetupSwipeRefresh(){
  mSwipeRefreshLayout=(SwipeRefreshLayout)findViewById(R.id.swipe_refresh_layout);
  if (mSwipeRefreshLayout != null) {
    mSwipeRefreshLayout.setColorScheme(R.color.refresh_progress_1,R.color.refresh_progress_2,R.color.refresh_progress_3,R.color.refresh_progress_4);
    mSwipeRefreshLayout.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener(){
      @Override public void onRefresh(){
        requestDataRefresh();
      }
    }
);
    if (mSwipeRefreshLayout instanceof MultiSwipeRefreshLayout) {
      MultiSwipeRefreshLayout mswrl=(MultiSwipeRefreshLayout)mSwipeRefreshLayout;
      mswrl.setCanChildScrollUpCallback(this);
    }
  }
}","private void trySetupSwipeRefresh(){
  mSwipeRefreshLayout=(SwipeRefreshLayout)findViewById(R.id.swipe_refresh_layout);
  if (mSwipeRefreshLayout != null) {
    mSwipeRefreshLayout.setColorSchemeResources(R.color.refresh_progress_1,R.color.refresh_progress_2,R.color.refresh_progress_3);
    mSwipeRefreshLayout.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener(){
      @Override public void onRefresh(){
        requestDataRefresh();
      }
    }
);
    if (mSwipeRefreshLayout instanceof MultiSwipeRefreshLayout) {
      MultiSwipeRefreshLayout mswrl=(MultiSwipeRefreshLayout)mSwipeRefreshLayout;
      mswrl.setCanChildScrollUpCallback(this);
    }
  }
}",0.973529411764706
19151,"public static void showWiFiDialog(Activity activity){
  FragmentManager fm=activity.getFragmentManager();
  FragmentTransaction ft=fm.beginTransaction();
  Fragment prev=fm.findFragmentByTag(""String_Node_Str"");
  if (prev != null) {
    ft.remove(prev);
  }
  ft.addToBackStack(null);
  new WiFiDialog(isWiFiEnabled(activity)).show(ft,""String_Node_Str"");
}","public static void showWiFiDialog(Activity activity){
  FragmentManager fm=activity.getFragmentManager();
  FragmentTransaction ft=fm.beginTransaction();
  Fragment prev=fm.findFragmentByTag(""String_Node_Str"");
  if (prev != null) {
    ft.remove(prev);
  }
  ft.addToBackStack(null);
  WiFiDialog.newInstance(isWiFiEnabled(activity)).show(ft,""String_Node_Str"");
}",0.9583333333333334
19152,"@Override public Dialog onCreateDialog(Bundle savedInstanceState){
  final int padding=getResources().getDimensionPixelSize(R.dimen.content_padding_normal);
  final TextView wifiTextView=new TextView(getActivity());
  int dialogCallToActionText;
  int dialogPositiveButtonText;
  if (mWiFiEnabled) {
    dialogCallToActionText=R.string.calltoaction_wifi_configure;
    dialogPositiveButtonText=R.string.wifi_dialog_button_configure;
  }
 else {
    dialogCallToActionText=R.string.calltoaction_wifi_settings;
    dialogPositiveButtonText=R.string.wifi_dialog_button_settings;
  }
  wifiTextView.setText(Html.fromHtml(getString(R.string.description_setup_wifi_body) + getString(dialogCallToActionText)));
  wifiTextView.setMovementMethod(LinkMovementMethod.getInstance());
  wifiTextView.setPadding(padding,padding,padding,padding);
  final Context context=getActivity();
  return new AlertDialog.Builder(context).setTitle(R.string.description_configure_wifi).setView(wifiTextView).setPositiveButton(dialogPositiveButtonText,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int whichButton){
      if (mWiFiEnabled) {
        installConferenceWiFi(context);
        if (WiFiUtils.isWiFiApConfigured(context)) {
          WiFiUtils.setWiFiConfigStatus(context,WiFiUtils.WIFI_CONFIG_DONE);
        }
      }
 else {
        WiFiUtils.setWiFiConfigStatus(context,WiFiUtils.WIFI_CONFIG_REQUESTED);
        final Intent wifiIntent=new Intent(Settings.ACTION_WIFI_SETTINGS);
        wifiIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
        startActivity(wifiIntent);
      }
      dialog.dismiss();
    }
  }
).create();
}","@Override public Dialog onCreateDialog(Bundle savedInstanceState){
  final int padding=getResources().getDimensionPixelSize(R.dimen.content_padding_normal);
  final TextView wifiTextView=new TextView(getActivity());
  int dialogCallToActionText;
  int dialogPositiveButtonText;
  mWiFiEnabled=getArguments().getBoolean(ARG_WIFI_ENABLED);
  if (mWiFiEnabled) {
    dialogCallToActionText=R.string.calltoaction_wifi_configure;
    dialogPositiveButtonText=R.string.wifi_dialog_button_configure;
  }
 else {
    dialogCallToActionText=R.string.calltoaction_wifi_settings;
    dialogPositiveButtonText=R.string.wifi_dialog_button_settings;
  }
  wifiTextView.setText(Html.fromHtml(getString(R.string.description_setup_wifi_body) + getString(dialogCallToActionText)));
  wifiTextView.setMovementMethod(LinkMovementMethod.getInstance());
  wifiTextView.setPadding(padding,padding,padding,padding);
  final Context context=getActivity();
  return new AlertDialog.Builder(context).setTitle(R.string.description_configure_wifi).setView(wifiTextView).setPositiveButton(dialogPositiveButtonText,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int whichButton){
      if (mWiFiEnabled) {
        installConferenceWiFi(context);
        if (WiFiUtils.isWiFiApConfigured(context)) {
          WiFiUtils.setWiFiConfigStatus(context,WiFiUtils.WIFI_CONFIG_DONE);
        }
      }
 else {
        WiFiUtils.setWiFiConfigStatus(context,WiFiUtils.WIFI_CONFIG_REQUESTED);
        final Intent wifiIntent=new Intent(Settings.ACTION_WIFI_SETTINGS);
        wifiIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
        startActivity(wifiIntent);
      }
      dialog.dismiss();
    }
  }
).create();
}",0.9824150058616647
19153,"@Override protected void onCancelled(Bitmap bitmap){
  super.onCancelled(bitmap);
synchronized (mPauseWorkLock) {
    mPauseWorkLock.notifyAll();
  }
}","@Override protected void onCancelled(){
  super.onCancelled();
synchronized (mPauseWorkLock) {
    mPauseWorkLock.notifyAll();
  }
}",0.9328621908127208
19154,"public void isEqualTo(Node node){
  check(""String_Node_Str"",node).that(actual().checkTreeEquals(node)).isNull();
}","@Override public void isEqualTo(Object o){
  check().that(actual()).isInstanceOf(Node.class);
  Node node=(Node)o;
  check(""String_Node_Str"",node).that(actual().checkTreeEquals(node)).isNull();
}",0.7313915857605178
19155,"private void validateExpressionType(Node n){
switch (n.getToken()) {
case NAME:
    validateNameType(n);
  break;
case CALL:
if (!n.getFirstChild().isSuper()) {
  validateCallType(n);
}
break;
default :
expectSomeTypeInformation(n);
}
}","private void validateExpressionType(Node n){
switch (n.getToken()) {
case NAME:
    validateNameType(n);
  break;
case CALL:
if (!n.getFirstChild().isSuper()) {
  validateCallType(n);
}
break;
case SPREAD:
break;
default :
expectSomeTypeInformation(n);
}
}",0.959349593495935
19156,"/** 
 * Infers all of a function's parameters if their types aren't declared. 
 */
@SuppressWarnings(""String_Node_Str"") private void inferParameters(TypedScope functionScope){
  Node functionNode=functionScope.getRootNode();
  Node astParameters=functionNode.getSecondChild();
  Node iifeArgumentNode=null;
  if (NodeUtil.isInvocationTarget(functionNode)) {
    iifeArgumentNode=functionNode.getNext();
  }
  FunctionType functionType=JSType.toMaybeFunctionType(functionNode.getJSType());
  if (functionType != null) {
    Node parameterTypes=functionType.getParametersNode();
    if (parameterTypes != null) {
      Node parameterTypeNode=parameterTypes.getFirstChild();
      for (      Node astParameter : astParameters.children()) {
        if (astParameter.isDefaultValue()) {
          astParameter=astParameter.getFirstChild();
        }
        if (astParameter.isRest()) {
          astParameter=astParameter.getOnlyChild();
        }
        if (!astParameter.isName()) {
          continue;
        }
        TypedVar var=functionScope.getVar(astParameter.getString());
        checkNotNull(var);
        if (var.isTypeInferred() && var.getType() == unknownType) {
          JSType newType=null;
          if (iifeArgumentNode != null) {
            newType=iifeArgumentNode.getJSType();
          }
 else           if (parameterTypeNode != null) {
            newType=parameterTypeNode.getJSType();
          }
          if (newType != null) {
            var.setType(newType);
            astParameter.setJSType(newType);
          }
        }
        if (parameterTypeNode != null) {
          parameterTypeNode=parameterTypeNode.getNext();
        }
        if (iifeArgumentNode != null) {
          iifeArgumentNode=iifeArgumentNode.getNext();
        }
      }
    }
  }
}","/** 
 * Infers all of a function's parameters if their types aren't declared. 
 */
@SuppressWarnings(""String_Node_Str"") private void inferParameters(TypedScope functionScope){
  Node functionNode=functionScope.getRootNode();
  Node astParameters=functionNode.getSecondChild();
  Node iifeArgumentNode=null;
  if (NodeUtil.isInvocationTarget(functionNode)) {
    iifeArgumentNode=functionNode.getNext();
  }
  FunctionType functionType=JSType.toMaybeFunctionType(functionNode.getJSType());
  if (functionType != null) {
    Node parameterTypes=functionType.getParametersNode();
    if (parameterTypes != null) {
      Node parameterTypeNode=parameterTypes.getFirstChild();
      for (      Node astParameter : astParameters.children()) {
        boolean isRest=false;
        if (astParameter.isDefaultValue()) {
          astParameter=astParameter.getFirstChild();
        }
        if (astParameter.isRest()) {
          astParameter=astParameter.getOnlyChild();
          isRest=true;
        }
        if (!astParameter.isName()) {
          continue;
        }
        if (iifeArgumentNode != null && iifeArgumentNode.isSpread()) {
          iifeArgumentNode=null;
        }
        TypedVar var=functionScope.getVar(astParameter.getString());
        checkNotNull(var);
        if (var.isTypeInferred() && (var.getType() == unknownType || isRest)) {
          JSType newType=null;
          if (iifeArgumentNode != null) {
            newType=iifeArgumentNode.getJSType();
          }
 else           if (parameterTypeNode != null) {
            newType=parameterTypeNode.getJSType();
          }
          if (newType != null) {
            if (isRest) {
              newType=registry.createTemplatizedType(registry.getNativeObjectType(ARRAY_TYPE),newType);
            }
            var.setType(newType);
            astParameter.setJSType(newType);
          }
        }
        if (parameterTypeNode != null) {
          parameterTypeNode=parameterTypeNode.getNext();
        }
        if (iifeArgumentNode != null) {
          iifeArgumentNode=iifeArgumentNode.getNext();
        }
      }
    }
  }
}",0.8474750064086132
19157,"/** 
 * Declares all of a function's parameters inside the function's scope. 
 */
void declareParameters(){
  Node functionNode=currentScope.getRootNode();
  Node astParameters=functionNode.getSecondChild();
  Node iifeArgumentNode=null;
  if (NodeUtil.isInvocationTarget(functionNode)) {
    iifeArgumentNode=functionNode.getNext();
  }
  FunctionType functionType=JSType.toMaybeFunctionType(functionNode.getJSType());
  if (functionType != null) {
    Node jsDocParameters=functionType.getParametersNode();
    if (jsDocParameters != null) {
      Node jsDocParameter=jsDocParameters.getFirstChild();
      for (      Node astParameter : astParameters.children()) {
        JSType declaredType=jsDocParameter == null ? unknownType : jsDocParameter.getJSType();
        declareNamesInPositionalParameter(astParameter,declaredType,iifeArgumentNode);
        if (jsDocParameter != null) {
          jsDocParameter=jsDocParameter.getNext();
        }
        if (iifeArgumentNode != null) {
          iifeArgumentNode=iifeArgumentNode.getNext();
        }
      }
    }
    JSDocInfo info=NodeUtil.getBestJSDocInfo(functionNode);
    if (info != null) {
      Iterable<String> templateNames=Iterables.concat(info.getTemplateTypeNames(),info.getTypeTransformations().keySet());
      if (!Iterables.isEmpty(templateNames)) {
        CompilerInput input=getCompilerInput();
        JSType voidType=typeRegistry.getNativeType(VOID_TYPE);
        for (        String name : templateNames) {
          if (!currentScope.canDeclare(name)) {
            validator.expectUndeclaredVariable(NodeUtil.getSourceName(functionNode),input,functionNode,functionNode.getParent(),currentScope.getVar(name),name,voidType);
          }
          currentScope.declare(name,functionNode,voidType,input,false);
        }
      }
    }
  }
}","/** 
 * Declares all of a function's parameters inside the function's scope. 
 */
void declareParameters(){
  Node functionNode=currentScope.getRootNode();
  Node astParameters=functionNode.getSecondChild();
  Node iifeArgumentNode=null;
  if (NodeUtil.isInvocationTarget(functionNode)) {
    iifeArgumentNode=functionNode.getNext();
  }
  FunctionType functionType=JSType.toMaybeFunctionType(functionNode.getJSType());
  if (functionType != null) {
    Node jsDocParameters=functionType.getParametersNode();
    if (jsDocParameters != null) {
      Node jsDocParameter=jsDocParameters.getFirstChild();
      for (      Node astParameter : astParameters.children()) {
        if (iifeArgumentNode != null && iifeArgumentNode.isSpread()) {
          iifeArgumentNode=null;
        }
        JSType declaredType=jsDocParameter == null ? unknownType : jsDocParameter.getJSType();
        declareNamesInPositionalParameter(astParameter,declaredType,iifeArgumentNode);
        if (jsDocParameter != null) {
          jsDocParameter=jsDocParameter.getNext();
        }
        if (iifeArgumentNode != null) {
          iifeArgumentNode=iifeArgumentNode.getNext();
        }
      }
    }
    JSDocInfo info=NodeUtil.getBestJSDocInfo(functionNode);
    if (info != null) {
      Iterable<String> templateNames=Iterables.concat(info.getTemplateTypeNames(),info.getTypeTransformations().keySet());
      if (!Iterables.isEmpty(templateNames)) {
        CompilerInput input=getCompilerInput();
        JSType voidType=typeRegistry.getNativeType(VOID_TYPE);
        for (        String name : templateNames) {
          if (!currentScope.canDeclare(name)) {
            validator.expectUndeclaredVariable(NodeUtil.getSourceName(functionNode),input,functionNode,functionNode.getParent(),currentScope.getVar(name),name,voidType);
          }
          currentScope.declare(name,functionNode,voidType,input,false);
        }
      }
    }
  }
}",0.9695675387079552
19158,"/** 
 * Look at the   {@code extends} clause to find the instance type being extended.Returns  {@code null} if there is no such clause, and unknown if the type cannotbe determined.
 */
@Nullable private ObjectType findSuperClassFromNodes(Node extendsNode,@Nullable JSDocInfo info){
  if (extendsNode.isEmpty()) {
    return null;
  }
  JSType ctorType=extendsNode.getJSType();
  if (ctorType == null) {
    if (extendsNode.isQualifiedName()) {
      TypedVar var=currentScope.getVar(extendsNode.getQualifiedName());
      if (var != null) {
        ctorType=var.getType();
      }
    }
 else {
      if (info == null || !info.hasBaseType()) {
        report(JSError.make(extendsNode,DYNAMIC_EXTENDS_WITHOUT_JSDOC));
      }
    }
  }
  if (ctorType != null && (ctorType.isConstructor() || ctorType.isInterface())) {
    return ctorType.toMaybeFunctionType().getInstanceType();
  }
  return null;
}","/** 
 * Look at the   {@code extends} clause to find the instance type being extended.Returns  {@code null} if there is no such clause, and unknown if the type cannotbe determined.
 */
@Nullable private ObjectType findSuperClassFromNodes(Node extendsNode,@Nullable JSDocInfo info){
  if (extendsNode.isEmpty()) {
    return null;
  }
  JSType ctorType=extendsNode.getJSType();
  if (ctorType == null) {
    if (extendsNode.isQualifiedName()) {
      TypedVar var=currentScope.getVar(extendsNode.getQualifiedName());
      if (var != null) {
        ctorType=var.getType();
      }
      if (ctorType == null) {
        return ObjectType.cast(typeRegistry.getType(currentScope,extendsNode.getQualifiedName(),extendsNode.getSourceFileName(),extendsNode.getLineno(),extendsNode.getCharno()));
      }
    }
 else {
      if (info == null || !info.hasBaseType()) {
        report(JSError.make(extendsNode,DYNAMIC_EXTENDS_WITHOUT_JSDOC));
      }
    }
  }
  if (ctorType != null && (ctorType.isConstructor() || ctorType.isInterface())) {
    return ctorType.toMaybeFunctionType().getInstanceType();
  }
  return null;
}",0.892200695479384
19159,"/** 
 * Given a constructor type and a property name, check that the property has the JSDoc annotation @override iff the property is declared on a superclass. Several checks regarding inheritance correctness are also performed.
 */
private void checkDeclaredPropertyInheritance(NodeTraversal t,Node n,FunctionType ctorType,String propertyName,JSDocInfo info,JSType propertyType){
  if (hasUnknownOrEmptySupertype(ctorType)) {
    return;
  }
  FunctionType superClass=ctorType.getSuperClassConstructor();
  boolean superClassHasProperty=superClass != null && superClass.getInstanceType().hasProperty(propertyName);
  boolean superClassHasDeclaredProperty=superClass != null && superClass.getInstanceType().isPropertyTypeDeclared(propertyName);
  boolean superInterfaceHasProperty=false;
  boolean superInterfaceHasDeclaredProperty=false;
  if (ctorType.isInterface()) {
    for (    ObjectType interfaceType : ctorType.getExtendedInterfaces()) {
      superInterfaceHasProperty=superInterfaceHasProperty || interfaceType.hasProperty(propertyName);
      superInterfaceHasDeclaredProperty=superInterfaceHasDeclaredProperty || interfaceType.isPropertyTypeDeclared(propertyName);
    }
  }
  boolean declaredOverride=info != null && info.isOverride();
  boolean foundInterfaceProperty=false;
  if (ctorType.isConstructor()) {
    for (    JSType implementedInterface : ctorType.getAllImplementedInterfaces()) {
      if (implementedInterface.isUnknownType() || implementedInterface.isEmptyType()) {
        continue;
      }
      FunctionType interfaceType=implementedInterface.toObjectType().getConstructor();
      checkNotNull(interfaceType);
      boolean interfaceHasProperty=interfaceType.getPrototype().hasProperty(propertyName);
      foundInterfaceProperty=foundInterfaceProperty || interfaceHasProperty;
      if (!declaredOverride && interfaceHasProperty && !""String_Node_Str"".equals(propertyName)) {
        compiler.report(t.makeError(n,HIDDEN_INTERFACE_PROPERTY,propertyName,interfaceType.getTopMostDefiningType(propertyName).toString()));
      }
    }
  }
  if (!declaredOverride && !superClassHasProperty && !superInterfaceHasProperty) {
    return;
  }
  ObjectType topInstanceType=superClassHasDeclaredProperty ? superClass.getTopMostDefiningType(propertyName) : null;
  boolean declaredLocally=ctorType.isConstructor() && (ctorType.getPrototype().hasOwnProperty(propertyName) || ctorType.getInstanceType().hasOwnProperty(propertyName));
  if (!declaredOverride && superClassHasDeclaredProperty && declaredLocally&& !""String_Node_Str"".equals(propertyName)) {
    compiler.report(t.makeError(n,HIDDEN_SUPERCLASS_PROPERTY,propertyName,topInstanceType.toString()));
  }
  if (superClassHasDeclaredProperty) {
    JSType superClassPropType=superClass.getInstanceType().getPropertyType(propertyName);
    TemplateTypeMap ctorTypeMap=ctorType.getTypeOfThis().getTemplateTypeMap();
    if (!ctorTypeMap.isEmpty()) {
      superClassPropType=superClassPropType.visit(new TemplateTypeMapReplacer(typeRegistry,ctorTypeMap));
    }
    if (!propertyType.isSubtype(superClassPropType,this.subtypingMode)) {
      compiler.report(t.makeError(n,HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,propertyName,topInstanceType.toString(),superClassPropType.toString(),propertyType.toString()));
    }
  }
 else   if (superInterfaceHasDeclaredProperty) {
    for (    ObjectType interfaceType : ctorType.getExtendedInterfaces()) {
      if (interfaceType.hasProperty(propertyName)) {
        JSType superPropertyType=interfaceType.getPropertyType(propertyName);
        if (!propertyType.isSubtype(superPropertyType,this.subtypingMode)) {
          topInstanceType=interfaceType.getConstructor().getTopMostDefiningType(propertyName);
          compiler.report(t.makeError(n,HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,propertyName,topInstanceType.toString(),superPropertyType.toString(),propertyType.toString()));
        }
      }
    }
  }
 else   if (!foundInterfaceProperty && !superClassHasProperty && !superInterfaceHasProperty) {
    compiler.report(t.makeError(n,UNKNOWN_OVERRIDE,propertyName,ctorType.getInstanceType().toString()));
  }
}","/** 
 * Given a constructor type and a property name, check that the property has the JSDoc annotation @override iff the property is declared on a superclass. Several checks regarding inheritance correctness are also performed.
 */
private void checkDeclaredPropertyInheritance(NodeTraversal t,Node n,FunctionType ctorType,String propertyName,JSDocInfo info,JSType propertyType){
  if (hasUnknownOrEmptySupertype(ctorType)) {
    return;
  }
  FunctionType superClass=ctorType.getSuperClassConstructor();
  boolean superClassHasProperty=superClass != null && superClass.getInstanceType().hasProperty(propertyName);
  boolean superClassHasDeclaredProperty=superClass != null && superClass.getInstanceType().isPropertyTypeDeclared(propertyName);
  boolean superInterfaceHasProperty=false;
  boolean superInterfaceHasDeclaredProperty=false;
  if (ctorType.isInterface()) {
    for (    ObjectType interfaceType : ctorType.getExtendedInterfaces()) {
      superInterfaceHasProperty=superInterfaceHasProperty || interfaceType.hasProperty(propertyName);
      superInterfaceHasDeclaredProperty=superInterfaceHasDeclaredProperty || interfaceType.isPropertyTypeDeclared(propertyName);
    }
  }
  boolean declaredOverride=info != null && info.isOverride();
  boolean foundInterfaceProperty=false;
  if (ctorType.isConstructor()) {
    for (    JSType implementedInterface : ctorType.getAllImplementedInterfaces()) {
      if (implementedInterface.isUnknownType() || implementedInterface.isEmptyType()) {
        continue;
      }
      FunctionType interfaceType=implementedInterface.toObjectType().getConstructor();
      checkNotNull(interfaceType);
      boolean interfaceHasProperty=interfaceType.getPrototype().hasProperty(propertyName);
      foundInterfaceProperty=foundInterfaceProperty || interfaceHasProperty;
      if (!declaredOverride && interfaceHasProperty && !""String_Node_Str"".equals(propertyName)&& !""String_Node_Str"".equals(propertyName)) {
        compiler.report(t.makeError(n,HIDDEN_INTERFACE_PROPERTY,propertyName,interfaceType.getTopMostDefiningType(propertyName).toString()));
      }
    }
  }
  if (!declaredOverride && !superClassHasProperty && !superInterfaceHasProperty) {
    return;
  }
  ObjectType topInstanceType=superClassHasDeclaredProperty ? superClass.getTopMostDefiningType(propertyName) : null;
  boolean declaredLocally=ctorType.isConstructor() && (ctorType.getPrototype().hasOwnProperty(propertyName) || ctorType.getInstanceType().hasOwnProperty(propertyName));
  if (!declaredOverride && superClassHasDeclaredProperty && declaredLocally&& !""String_Node_Str"".equals(propertyName)) {
    compiler.report(t.makeError(n,HIDDEN_SUPERCLASS_PROPERTY,propertyName,topInstanceType.toString()));
  }
  if (superClassHasDeclaredProperty) {
    JSType superClassPropType=superClass.getInstanceType().getPropertyType(propertyName);
    TemplateTypeMap ctorTypeMap=ctorType.getTypeOfThis().getTemplateTypeMap();
    if (!ctorTypeMap.isEmpty()) {
      superClassPropType=superClassPropType.visit(new TemplateTypeMapReplacer(typeRegistry,ctorTypeMap));
    }
    if (!propertyType.isSubtype(superClassPropType,this.subtypingMode)) {
      compiler.report(t.makeError(n,HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,propertyName,topInstanceType.toString(),superClassPropType.toString(),propertyType.toString()));
    }
  }
 else   if (superInterfaceHasDeclaredProperty) {
    for (    ObjectType interfaceType : ctorType.getExtendedInterfaces()) {
      if (interfaceType.hasProperty(propertyName)) {
        JSType superPropertyType=interfaceType.getPropertyType(propertyName);
        if (!propertyType.isSubtype(superPropertyType,this.subtypingMode)) {
          topInstanceType=interfaceType.getConstructor().getTopMostDefiningType(propertyName);
          compiler.report(t.makeError(n,HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,propertyName,topInstanceType.toString(),superPropertyType.toString(),propertyType.toString()));
        }
      }
    }
  }
 else   if (!foundInterfaceProperty && !superClassHasProperty && !superInterfaceHasProperty) {
    compiler.report(t.makeError(n,UNKNOWN_OVERRIDE,propertyName,ctorType.getInstanceType().toString()));
  }
}",0.9949336550060314
19160,"public void testClassSuperConstructorParameterMismatch(){
  testTypes(lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"" + ""String_Node_Str"");
}","public void testClassSuperConstructorParameterMismatch(){
  testTypes(lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.7318982387475538
19161,"/** 
 * Returns true if this is a global this type. 
 */
public final boolean isGlobalThisType(){
  return this == registry.getNativeType(JSTypeNative.GLOBAL_THIS);
}","/** 
 * Returns true if this is a global this type. 
 */
public final boolean isGlobalThisType(){
  return areIdentical(this,registry.getNativeType(JSTypeNative.GLOBAL_THIS));
}",0.9446064139941692
19162,"/** 
 * A generic implementation meant to be used as a helper for common getLeastSupertype implementations.
 */
static JSType getLeastSupertype(JSType thisType,JSType thatType){
  boolean areEquivalent=thisType.isEquivalentTo(thatType);
  return areEquivalent ? thisType : filterNoResolvedType(thisType.registry.createUnionType(thisType,thatType));
}","/** 
 * A generic implementation meant to be used as a helper for common getLeastSupertype implementations.
 */
@SuppressWarnings(""String_Node_Str"") static JSType getLeastSupertype(JSType thisType,JSType thatType){
  boolean areEquivalent=thisType.isEquivalentTo(thatType);
  return areEquivalent ? thisType : filterNoResolvedType(thisType.registry.createUnionType(thisType,thatType));
}",0.949796472184532
19163,"/** 
 * Null-safe version of toMaybeFunctionType().
 */
public static FunctionType toMaybeFunctionType(JSType type){
  return type == null ? null : type.toMaybeFunctionType();
}","/** 
 * Null-safe version of toMaybeFunctionType(). 
 */
@SuppressWarnings(""String_Node_Str"") public static FunctionType toMaybeFunctionType(JSType type){
  return type == null ? null : type.toMaybeFunctionType();
}",0.903061224489796
19164,"/** 
 * Tests whether   {@code this} and {@code that} are meaningfullycomparable using shallow comparison. By meaningfully, we mean compatible types that are not rejected by step 1 of the definition of the Strict Equality Comparison Algorithm (11.9.6, page 56&ndash;57) of the ECMA-262 specification.<p>
 */
public final boolean canTestForShallowEqualityWith(JSType that){
  if (isEmptyType() || that.isEmptyType()) {
    return isSubtypeOf(that) || that.isSubtypeOf(this);
  }
  JSType inf=getGreatestSubtype(that);
  return !inf.isEmptyType() || inf == registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);
}","/** 
 * Tests whether   {@code this} and {@code that} are meaningfullycomparable using shallow comparison. By meaningfully, we mean compatible types that are not rejected by step 1 of the definition of the Strict Equality Comparison Algorithm (11.9.6, page 56&ndash;57) of the ECMA-262 specification.<p>
 */
public final boolean canTestForShallowEqualityWith(JSType that){
  if (isEmptyType() || that.isEmptyType()) {
    return isSubtypeOf(that) || that.isSubtypeOf(this);
  }
  JSType inf=getGreatestSubtype(that);
  return !inf.isEmptyType() || areIdentical(inf,registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE));
}",0.979822437449556
19165,"public final boolean isEmptyType(){
  return isNoType() || isNoObjectType() || isNoResolvedType()|| (registry.getNativeFunctionType(JSTypeNative.LEAST_FUNCTION_TYPE) == this);
}","public final boolean isEmptyType(){
  return isNoType() || isNoObjectType() || isNoResolvedType()|| areIdentical(this,registry.getNativeFunctionType(JSTypeNative.LEAST_FUNCTION_TYPE));
}",0.931129476584022
19166,"/** 
 * A generic implementation meant to be used as a helper for common getGreatestSubtype implementations.
 */
static JSType getGreatestSubtype(JSType thisType,JSType thatType){
  if (thisType.isFunctionType() && thatType.isFunctionType()) {
    return thisType.toMaybeFunctionType().supAndInfHelper(thatType.toMaybeFunctionType(),false);
  }
 else   if (thisType.isEquivalentTo(thatType)) {
    return thisType;
  }
 else   if (thisType.isUnknownType() || thatType.isUnknownType()) {
    return thisType.isEquivalentTo(thatType) ? thisType : thisType.getNativeType(JSTypeNative.UNKNOWN_TYPE);
  }
 else   if (thisType.isUnionType()) {
    return thisType.toMaybeUnionType().meet(thatType);
  }
 else   if (thatType.isUnionType()) {
    return thatType.toMaybeUnionType().meet(thisType);
  }
 else   if (thisType.isTemplatizedType()) {
    return thisType.toMaybeTemplatizedType().getGreatestSubtypeHelper(thatType);
  }
 else   if (thatType.isTemplatizedType()) {
    return thatType.toMaybeTemplatizedType().getGreatestSubtypeHelper(thisType);
  }
 else   if (thisType.isSubtypeOf(thatType)) {
    return filterNoResolvedType(thisType);
  }
 else   if (thatType.isSubtypeOf(thisType)) {
    return filterNoResolvedType(thatType);
  }
 else   if (thisType.isRecordType()) {
    return thisType.toMaybeRecordType().getGreatestSubtypeHelper(thatType);
  }
 else   if (thatType.isRecordType()) {
    return thatType.toMaybeRecordType().getGreatestSubtypeHelper(thisType);
  }
  if (thisType.isEnumElementType()) {
    JSType inf=thisType.toMaybeEnumElementType().meet(thatType);
    if (inf != null) {
      return inf;
    }
  }
 else   if (thatType.isEnumElementType()) {
    JSType inf=thatType.toMaybeEnumElementType().meet(thisType);
    if (inf != null) {
      return inf;
    }
  }
  if (thisType.isObject() && thatType.isObject()) {
    return thisType.getNativeType(JSTypeNative.NO_OBJECT_TYPE);
  }
  return thisType.getNativeType(JSTypeNative.NO_TYPE);
}","/** 
 * A generic implementation meant to be used as a helper for common getGreatestSubtype implementations.
 */
@SuppressWarnings(""String_Node_Str"") static JSType getGreatestSubtype(JSType thisType,JSType thatType){
  if (thisType.isFunctionType() && thatType.isFunctionType()) {
    return thisType.toMaybeFunctionType().supAndInfHelper(thatType.toMaybeFunctionType(),false);
  }
 else   if (thisType.isEquivalentTo(thatType)) {
    return thisType;
  }
 else   if (thisType.isUnknownType() || thatType.isUnknownType()) {
    return thisType.isEquivalentTo(thatType) ? thisType : thisType.getNativeType(JSTypeNative.UNKNOWN_TYPE);
  }
 else   if (thisType.isUnionType()) {
    return thisType.toMaybeUnionType().meet(thatType);
  }
 else   if (thatType.isUnionType()) {
    return thatType.toMaybeUnionType().meet(thisType);
  }
 else   if (thisType.isTemplatizedType()) {
    return thisType.toMaybeTemplatizedType().getGreatestSubtypeHelper(thatType);
  }
 else   if (thatType.isTemplatizedType()) {
    return thatType.toMaybeTemplatizedType().getGreatestSubtypeHelper(thisType);
  }
 else   if (thisType.isSubtypeOf(thatType)) {
    return filterNoResolvedType(thisType);
  }
 else   if (thatType.isSubtypeOf(thisType)) {
    return filterNoResolvedType(thatType);
  }
 else   if (thisType.isRecordType()) {
    return thisType.toMaybeRecordType().getGreatestSubtypeHelper(thatType);
  }
 else   if (thatType.isRecordType()) {
    return thatType.toMaybeRecordType().getGreatestSubtypeHelper(thisType);
  }
  if (thisType.isEnumElementType()) {
    JSType inf=thisType.toMaybeEnumElementType().meet(thatType);
    if (inf != null) {
      return inf;
    }
  }
 else   if (thatType.isEnumElementType()) {
    JSType inf=thatType.toMaybeEnumElementType().meet(thisType);
    if (inf != null) {
      return inf;
    }
  }
  if (thisType.isObject() && thatType.isObject()) {
    return thisType.getNativeType(JSTypeNative.NO_OBJECT_TYPE);
  }
  return thisType.getNativeType(JSTypeNative.NO_TYPE);
}",0.9906777525825144
19167,"/** 
 * Computes the restricted type of this type knowing that the  {@code ToBoolean} predicate has a specific value. For more informationabout the  {@code ToBoolean} predicate, see{@link #getPossibleToBooleanOutcomes}.
 * @param outcome the value of the {@code ToBoolean} predicate
 * @return the restricted type, or the Any Type if the underlying type couldnot have yielded this ToBoolean value TODO(user): Move this method to the SemanticRAI and use the visit method of types to get the restricted type.
 */
public JSType getRestrictedTypeGivenToBooleanOutcome(boolean outcome){
  if (outcome && this == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {
    return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
  }
  BooleanLiteralSet literals=getPossibleToBooleanOutcomes();
  if (literals.contains(outcome)) {
    return this;
  }
 else {
    return getNativeType(JSTypeNative.NO_TYPE);
  }
}","/** 
 * Computes the restricted type of this type knowing that the  {@code ToBoolean} predicate has a specific value. For more informationabout the  {@code ToBoolean} predicate, see{@link #getPossibleToBooleanOutcomes}.
 * @param outcome the value of the {@code ToBoolean} predicate
 * @return the restricted type, or the Any Type if the underlying type couldnot have yielded this ToBoolean value TODO(user): Move this method to the SemanticRAI and use the visit method of types to get the restricted type.
 */
public JSType getRestrictedTypeGivenToBooleanOutcome(boolean outcome){
  if (outcome && areIdentical(this,getNativeType(JSTypeNative.UNKNOWN_TYPE))) {
    return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
  }
  BooleanLiteralSet literals=getPossibleToBooleanOutcomes();
  if (literals.contains(outcome)) {
    return this;
  }
 else {
    return getNativeType(JSTypeNative.NO_TYPE);
  }
}",0.9850083287062744
19168,"/** 
 * Computes the subset of   {@code this} and {@code that} types undershallow inequality.
 * @return A pair containing the restricted type of {@code this} as the firstcomponent and the restricted type of  {@code that} as the secondelement. The returned pair is never  {@code null} even though itscomponents may be  {@code null}
 */
public TypePair getTypesUnderShallowInequality(JSType that){
  if (that.isUnionType()) {
    TypePair p=that.toMaybeUnionType().getTypesUnderShallowInequality(this);
    return new TypePair(p.typeB,p.typeA);
  }
  if (isNullType() && that.isNullType() || isVoidType() && that.isVoidType()) {
    return new TypePair(null,null);
  }
 else {
    return new TypePair(this,that);
  }
}","/** 
 * Computes the subset of   {@code this} and {@code that} types undershallow inequality.
 * @return A pair containing the restricted type of {@code this} as the firstcomponent and the restricted type of  {@code that} as the secondelement. The returned pair is never  {@code null} even though itscomponents may be  {@code null}
 */
public TypePair getTypesUnderShallowInequality(JSType that){
  if (that.isUnionType()) {
    TypePair p=that.toMaybeUnionType().getTypesUnderShallowInequality(this);
    return new TypePair(p.typeB,p.typeA);
  }
  if ((isNullType() && that.isNullType()) || (isVoidType() && that.isVoidType())) {
    return new TypePair(null,null);
  }
 else {
    return new TypePair(this,that);
  }
}",0.9972183588317108
19169,"boolean checkEquivalenceHelper(final JSType that,EquivalenceMethod eqMethod,EqCache eqCache){
  if (this == that) {
    return true;
  }
  if (this.isNoResolvedType() && that.isNoResolvedType()) {
    if (this.isNamedType() && that.isNamedType()) {
      return Objects.equals(((NamedType)this).getReferenceName(),((NamedType)that).getReferenceName());
    }
 else {
      return true;
    }
  }
  boolean thisUnknown=isUnknownType();
  boolean thatUnknown=that.isUnknownType();
  if (thisUnknown || thatUnknown) {
    if (eqMethod == EquivalenceMethod.INVARIANT) {
      return true;
    }
 else     if (eqMethod == EquivalenceMethod.DATA_FLOW) {
      return thisUnknown && thatUnknown;
    }
 else     if (thisUnknown && thatUnknown && (isNominalType() ^ that.isNominalType())) {
      return false;
    }
  }
  if (isUnionType() && that.isUnionType()) {
    return toMaybeUnionType().checkUnionEquivalenceHelper(that.toMaybeUnionType(),eqMethod,eqCache);
  }
  if (isFunctionType() && that.isFunctionType()) {
    return toMaybeFunctionType().checkFunctionEquivalenceHelper(that.toMaybeFunctionType(),eqMethod,eqCache);
  }
  if (!getTemplateTypeMap().checkEquivalenceHelper(that.getTemplateTypeMap(),eqMethod,eqCache,SubtypingMode.NORMAL)) {
    return false;
  }
  if (eqCache.isStructuralTyping() && this.isStructuralType() && that.isStructuralType()) {
    return toMaybeObjectType().checkStructuralEquivalenceHelper(that.toMaybeObjectType(),eqMethod,eqCache);
  }
  if (isNominalType() && that.isNominalType()) {
    return getConcreteNominalTypeName(this.toObjectType()).equals(getConcreteNominalTypeName(that.toObjectType()));
  }
  if (isTemplateType() && that.isTemplateType()) {
    return false;
  }
  if (this instanceof ProxyObjectType) {
    return ((ProxyObjectType)this).getReferencedTypeInternal().checkEquivalenceHelper(that,eqMethod,eqCache);
  }
  if (that instanceof ProxyObjectType) {
    return checkEquivalenceHelper(((ProxyObjectType)that).getReferencedTypeInternal(),eqMethod,eqCache);
  }
  return false;
}","boolean checkEquivalenceHelper(final JSType that,EquivalenceMethod eqMethod,EqCache eqCache){
  if (areIdentical(this,that)) {
    return true;
  }
  if (this.isNoResolvedType() && that.isNoResolvedType()) {
    if (this.isNamedType() && that.isNamedType()) {
      return Objects.equals(((NamedType)this).getReferenceName(),((NamedType)that).getReferenceName());
    }
 else {
      return true;
    }
  }
  boolean thisUnknown=isUnknownType();
  boolean thatUnknown=that.isUnknownType();
  if (thisUnknown || thatUnknown) {
    if (eqMethod == EquivalenceMethod.INVARIANT) {
      return true;
    }
 else     if (eqMethod == EquivalenceMethod.DATA_FLOW) {
      return thisUnknown && thatUnknown;
    }
 else     if (thisUnknown && thatUnknown && (isNominalType() ^ that.isNominalType())) {
      return false;
    }
  }
  if (isUnionType() && that.isUnionType()) {
    return toMaybeUnionType().checkUnionEquivalenceHelper(that.toMaybeUnionType(),eqMethod,eqCache);
  }
  if (isFunctionType() && that.isFunctionType()) {
    return toMaybeFunctionType().checkFunctionEquivalenceHelper(that.toMaybeFunctionType(),eqMethod,eqCache);
  }
  if (!getTemplateTypeMap().checkEquivalenceHelper(that.getTemplateTypeMap(),eqMethod,eqCache,SubtypingMode.NORMAL)) {
    return false;
  }
  if (eqCache.isStructuralTyping() && this.isStructuralType() && that.isStructuralType()) {
    return toMaybeObjectType().checkStructuralEquivalenceHelper(that.toMaybeObjectType(),eqMethod,eqCache);
  }
  if (isNominalType() && that.isNominalType()) {
    return getConcreteNominalTypeName(this.toObjectType()).equals(getConcreteNominalTypeName(that.toObjectType()));
  }
  if (isTemplateType() && that.isTemplateType()) {
    return false;
  }
  if (this instanceof ProxyObjectType) {
    return ((ProxyObjectType)this).getReferencedTypeInternal().checkEquivalenceHelper(that,eqMethod,eqCache);
  }
  if (that instanceof ProxyObjectType) {
    return checkEquivalenceHelper(((ProxyObjectType)that).getReferencedTypeInternal(),eqMethod,eqCache);
  }
  return false;
}",0.9914320685434516
19170,"public static boolean isEquivalent(JSType typeA,JSType typeB){
  return (typeA == null || typeB == null) ? typeA == typeB : typeA.isEquivalentTo(typeB);
}","public static boolean isEquivalent(JSType typeA,JSType typeB){
  return (typeA == null || typeB == null) ? areIdentical(typeA,typeB) : typeA.isEquivalentTo(typeB);
}",0.9404388714733544
19171,"public final boolean isUnresolvedOrResolvedUnknown(){
  return isNoResolvedType() || isNamedType() && isUnknownType();
}","public final boolean isUnresolvedOrResolvedUnknown(){
  return isNoResolvedType() || (isNamedType() && isUnknownType());
}",0.9917355371900828
19172,"private void checkProtoCycle(ErrorReporter reporter){
  JSType referencedType=getReferencedType();
  if (referencedType == this) {
    handleTypeCycle(reporter);
  }
}","private void checkProtoCycle(ErrorReporter reporter){
  JSType referencedType=getReferencedType();
  if (areIdentical(referencedType,this)) {
    handleTypeCycle(reporter);
  }
}",0.944927536231884
19173,"private void checkEnumElementCycle(ErrorReporter reporter){
  JSType referencedType=getReferencedType();
  if (referencedType instanceof EnumElementType && ((EnumElementType)referencedType).getPrimitiveType() == this) {
    handleTypeCycle(reporter);
  }
}","private void checkEnumElementCycle(ErrorReporter reporter){
  JSType referencedType=getReferencedType();
  if (referencedType instanceof EnumElementType && areIdentical(this,((EnumElementType)referencedType).getPrimitiveType())) {
    handleTypeCycle(reporter);
  }
}",0.9177820267686424
19174,"/** 
 * Tests object types.
 */
public void testObjectType() throws Exception {
  PrototypeObjectType objectType=new PrototypeObjectType(registry,null,null);
  assertFalse(objectType.isAllType());
  assertFalse(objectType.isArrayType());
  assertFalse(objectType.isDateType());
  assertFalse(objectType.isFunctionPrototypeType());
  assertTrue(objectType.getImplicitPrototype() == OBJECT_TYPE);
  assertTrue(objectType.isSubtypeOf(ALL_TYPE));
  assertFalse(objectType.isSubtypeOf(STRING_OBJECT_TYPE));
  assertFalse(objectType.isSubtypeOf(NUMBER_TYPE));
  assertFalse(objectType.isSubtypeOf(functionType));
  assertFalse(objectType.isSubtypeOf(NULL_TYPE));
  assertFalse(objectType.isSubtypeOf(DATE_TYPE));
  assertTrue(objectType.isSubtypeOf(OBJECT_TYPE));
  assertTrue(objectType.isSubtypeOf(unresolvedNamedType));
  assertFalse(objectType.isSubtypeOf(namedGoogBar));
  assertFalse(objectType.isSubtypeOf(REGEXP_TYPE));
  assertNull(objectType.autoboxesTo());
  assertCanTestForEqualityWith(objectType,NUMBER_TYPE);
  assertFalse(objectType.matchesNumberContext());
  assertFalse(objectType.matchesNumberContext());
  assertTrue(objectType.matchesObjectContext());
  assertFalse(objectType.matchesStringContext());
  assertFalse(objectType.matchesNumberContext());
  assertFalse(objectType.isNullable());
  assertFalse(objectType.isVoidable());
  assertTrue(createNullableType(objectType).isNullable());
  assertTrue(createUnionType(objectType,VOID_TYPE).isVoidable());
  assertEquals(""String_Node_Str"",objectType.toString());
  assertEquals(null,objectType.getDisplayName());
  assertFalse(objectType.hasReferenceName());
  assertEquals(""String_Node_Str"",new PrototypeObjectType(registry,""String_Node_Str"",null).getDisplayName());
  Asserts.assertResolvesToSame(objectType);
}","/** 
 * Tests object types.
 */
public void testObjectType() throws Exception {
  PrototypeObjectType objectType=new PrototypeObjectType(registry,null,null);
  assertFalse(objectType.isAllType());
  assertFalse(objectType.isArrayType());
  assertFalse(objectType.isDateType());
  assertFalse(objectType.isFunctionPrototypeType());
  assertSame(objectType.getImplicitPrototype(),OBJECT_TYPE);
  assertTrue(objectType.isSubtypeOf(ALL_TYPE));
  assertFalse(objectType.isSubtypeOf(STRING_OBJECT_TYPE));
  assertFalse(objectType.isSubtypeOf(NUMBER_TYPE));
  assertFalse(objectType.isSubtypeOf(functionType));
  assertFalse(objectType.isSubtypeOf(NULL_TYPE));
  assertFalse(objectType.isSubtypeOf(DATE_TYPE));
  assertTrue(objectType.isSubtypeOf(OBJECT_TYPE));
  assertTrue(objectType.isSubtypeOf(unresolvedNamedType));
  assertFalse(objectType.isSubtypeOf(namedGoogBar));
  assertFalse(objectType.isSubtypeOf(REGEXP_TYPE));
  assertNull(objectType.autoboxesTo());
  assertCanTestForEqualityWith(objectType,NUMBER_TYPE);
  assertFalse(objectType.matchesNumberContext());
  assertFalse(objectType.matchesNumberContext());
  assertTrue(objectType.matchesObjectContext());
  assertFalse(objectType.matchesStringContext());
  assertFalse(objectType.matchesNumberContext());
  assertFalse(objectType.isNullable());
  assertFalse(objectType.isVoidable());
  assertTrue(createNullableType(objectType).isNullable());
  assertTrue(createUnionType(objectType,VOID_TYPE).isVoidable());
  assertEquals(""String_Node_Str"",objectType.toString());
  assertEquals(null,objectType.getDisplayName());
  assertFalse(objectType.hasReferenceName());
  assertEquals(""String_Node_Str"",new PrototypeObjectType(registry,""String_Node_Str"",null).getDisplayName());
  Asserts.assertResolvesToSame(objectType);
}",0.9969057665260196
19175,"/** 
 * @return Whether the given property access is on 'this' or a static property on a class. 
 */
private boolean isCandidatePropertyDefinition(Node n){
  Node target=n.getFirstChild();
  return target.isThis() || isConstructor(target);
}","/** 
 * @return Whether the given node is a @private property declaration that is not marked constant.
 */
private boolean isCandidatePropertyDefinition(Node n){
  if (!NodeUtil.isLhsOfAssign(n)) {
    return false;
  }
  Node target=n.getFirstChild();
  if (!(target.isThis() || isConstructor(target))) {
    return false;
  }
  JSDocInfo info=NodeUtil.getBestJSDocInfo(n);
  return info != null && info.getVisibility() == Visibility.PRIVATE && !info.isConstant() && !info.hasTypedefType() && !info.hasEnumParameterType() && !info.isInterface() && !isFunctionProperty(n);
}",0.4220858895705521
19176,"@Override public void visit(NodeTraversal t,Node n,Node parent){
switch (n.getToken()) {
case SCRIPT:
    reportMissingConst(t);
  break;
case GETELEM:
case GETPROP:
Node lastChild=n.getLastChild();
if (!lastChild.isString()) {
return;
}
String propName=lastChild.getString();
if (isCandidatePropertyDefinition(n) && isNonConstCheckablePrivatePropDecl(n)) {
candidates.add(n);
}
 else if (isModificationOp(n)) {
modified.add(propName);
}
break;
default :
break;
}
}","@Override public void visit(NodeTraversal t,Node n,Node parent){
switch (n.getToken()) {
case SCRIPT:
    reportMissingConst(t);
  break;
case GETELEM:
case GETPROP:
Node lastChild=n.getLastChild();
if (!lastChild.isString()) {
return;
}
String propName=lastChild.getString();
if (isCandidatePropertyDefinition(n)) {
candidates.add(n);
}
 else if (isModificationOp(n)) {
modified.add(propName);
}
break;
default :
break;
}
}",0.7199100112485939
19177,"private void processAllFiles(Deque<ScriptDescription> scriptDescriptions,Iterable<Node> scriptNodes){
  for (  Node c : scriptNodes) {
    checkState(c.isScript(),c);
    NodeTraversal.traverse(compiler,c,new UnwrapGoogLoadModule());
    pushScript(new ScriptDescription());
    currentScript.rootNode=c;
    scriptDescriptions.addLast(currentScript);
    NodeTraversal.traverse(compiler,c,new ScriptPreprocessor());
    NodeTraversal.traverse(compiler,c,new ScriptRecorder());
    popScript();
  }
  reportUnrecognizedRequires();
  if (compiler.hasHaltingErrors()) {
    return;
  }
  for (  Node c : scriptNodes) {
    pushScript(scriptDescriptions.removeFirst());
    NodeTraversal.traverse(compiler,c,new ScriptUpdater());
    popScript();
  }
}","private void processAllFiles(Deque<ScriptDescription> scriptDescriptions,Iterable<Node> scriptNodes){
  for (  Node c : scriptNodes) {
    checkState(c.isScript(),c);
    if (c.isFromExterns() && !NodeUtil.isFromTypeSummary(c)) {
      continue;
    }
    NodeTraversal.traverse(compiler,c,new UnwrapGoogLoadModule());
    pushScript(new ScriptDescription());
    currentScript.rootNode=c;
    scriptDescriptions.addLast(currentScript);
    NodeTraversal.traverse(compiler,c,new ScriptPreprocessor());
    NodeTraversal.traverse(compiler,c,new ScriptRecorder());
    popScript();
  }
  reportUnrecognizedRequires();
  if (compiler.hasHaltingErrors()) {
    return;
  }
  for (  Node c : scriptNodes) {
    if (c.isFromExterns() && !NodeUtil.isFromTypeSummary(c)) {
      continue;
    }
    pushScript(scriptDescriptions.removeFirst());
    NodeTraversal.traverse(compiler,c,new ScriptUpdater());
    popScript();
  }
}",0.8980815347721822
19178,"public void testIjsModule(){
  allowExternsChanges();
  test(externs(""String_Node_Str""),srcs(""String_Node_Str""),expected(lines(""String_Node_Str"",""String_Node_Str"")));
}","public void testIjsModule(){
  allowExternsChanges();
  test(new String[]{lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")},new String[]{lines(""String_Node_Str"",""String_Node_Str"")});
}",0.2934537246049661
19179,"public void testExternsReferencesToGoogModuleTypesAreRewritten(){
  CompilerOptions options=createCompilerOptions();
  options.setClosurePass(true);
  options.setCheckTypes(true);
  test(options,new String[]{LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")},(String[])null);
}","public void testExternsReferencesToGoogModuleTypesAreRewritten(){
  CompilerOptions options=createCompilerOptions();
  options.setClosurePass(true);
  options.setCheckTypes(true);
  test(options,new String[]{LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")},(String[])null);
}",0.9783653846153846
19180,"Node processAstRoot(ProgramTree rootNode){
  Node scriptNode=newNode(Token.SCRIPT);
  for (  ParseTree child : rootNode.sourceElements) {
    scriptNode.addChildToBack(transform(child));
  }
  parseDirectives(scriptNode);
  boolean isGoogModule=isGoogModuleFile(scriptNode);
  if (isGoogModule || features.has(Feature.MODULES)) {
    Node moduleNode=newNode(Token.MODULE_BODY);
    setSourceInfo(moduleNode,rootNode);
    moduleNode.addChildrenToBack(scriptNode.removeChildren());
    scriptNode.addChildToBack(moduleNode);
    if (isGoogModule) {
      scriptNode.putBooleanProp(Node.GOOG_MODULE,true);
    }
  }
  return scriptNode;
}","Node processAstRoot(ProgramTree rootNode){
  Node scriptNode=newNode(Token.SCRIPT);
  for (  ParseTree child : rootNode.sourceElements) {
    scriptNode.addChildToBack(transform(child));
  }
  parseDirectives(scriptNode);
  boolean isGoogModule=isGoogModuleFile(scriptNode);
  if (isGoogModule || features.has(Feature.MODULES)) {
    Node moduleNode=newNode(Token.MODULE_BODY);
    setSourceInfo(moduleNode,rootNode);
    moduleNode.addChildrenToBack(scriptNode.removeChildren());
    scriptNode.addChildToBack(moduleNode);
    if (isGoogModule) {
      scriptNode.putBooleanProp(Node.GOOG_MODULE,true);
    }
 else {
      scriptNode.putBooleanProp(Node.ES6_MODULE,true);
    }
  }
  return scriptNode;
}",0.9202087994034304
19181,"private static final String propToString(byte propType){
switch (propType) {
case VAR_ARGS_NAME:
    return ""String_Node_Str"";
case JSDOC_INFO_PROP:
  return ""String_Node_Str"";
case INCRDECR_PROP:
return ""String_Node_Str"";
case QUOTED_PROP:
return ""String_Node_Str"";
case OPT_ARG_NAME:
return ""String_Node_Str"";
case SYNTHETIC_BLOCK_PROP:
return ""String_Node_Str"";
case ADDED_BLOCK:
return ""String_Node_Str"";
case ORIGINALNAME_PROP:
return ""String_Node_Str"";
case SIDE_EFFECT_FLAGS:
return ""String_Node_Str"";
case IS_CONSTANT_NAME:
return ""String_Node_Str"";
case IS_NAMESPACE:
return ""String_Node_Str"";
case DIRECTIVES:
return ""String_Node_Str"";
case DIRECT_EVAL:
return ""String_Node_Str"";
case FREE_CALL:
return ""String_Node_Str"";
case STATIC_SOURCE_FILE:
return ""String_Node_Str"";
case INPUT_ID:
return ""String_Node_Str"";
case SLASH_V:
return ""String_Node_Str"";
case INFERRED_FUNCTION:
return ""String_Node_Str"";
case CHANGE_TIME:
return ""String_Node_Str"";
case REFLECTED_OBJECT:
return ""String_Node_Str"";
case STATIC_MEMBER:
return ""String_Node_Str"";
case GENERATOR_FN:
return ""String_Node_Str"";
case ARROW_FN:
return ""String_Node_Str"";
case ASYNC_FN:
return ""String_Node_Str"";
case YIELD_ALL:
return ""String_Node_Str"";
case EXPORT_DEFAULT:
return ""String_Node_Str"";
case EXPORT_ALL_FROM:
return ""String_Node_Str"";
case IS_CONSTANT_VAR:
return ""String_Node_Str"";
case GENERATOR_MARKER:
return ""String_Node_Str"";
case GENERATOR_SAFE:
return ""String_Node_Str"";
case RAW_STRING_VALUE:
return ""String_Node_Str"";
case COMPUTED_PROP_METHOD:
return ""String_Node_Str"";
case COMPUTED_PROP_GETTER:
return ""String_Node_Str"";
case COMPUTED_PROP_SETTER:
return ""String_Node_Str"";
case COMPUTED_PROP_VARIABLE:
return ""String_Node_Str"";
case ANALYZED_DURING_GTI:
return ""String_Node_Str"";
case CONSTANT_PROPERTY_DEF:
return ""String_Node_Str"";
case DECLARED_TYPE_EXPR:
return ""String_Node_Str"";
case TYPE_BEFORE_CAST:
return ""String_Node_Str"";
case OPT_ES6_TYPED:
return ""String_Node_Str"";
case GENERIC_TYPE_LIST:
return ""String_Node_Str"";
case IMPLEMENTS:
return ""String_Node_Str"";
case CONSTRUCT_SIGNATURE:
return ""String_Node_Str"";
case ACCESS_MODIFIER:
return ""String_Node_Str"";
case NON_INDEXABLE:
return ""String_Node_Str"";
case PARSE_RESULTS:
return ""String_Node_Str"";
case GOOG_MODULE:
return ""String_Node_Str"";
case GOOG_MODULE_REQUIRE:
return ""String_Node_Str"";
case FEATURE_SET:
return ""String_Node_Str"";
case IS_MODULE_NAME:
return ""String_Node_Str"";
case WAS_PREVIOUSLY_PROVIDED:
return ""String_Node_Str"";
case IS_ES6_CLASS:
return ""String_Node_Str"";
case TRANSPILED:
return ""String_Node_Str"";
case DELETED:
return ""String_Node_Str"";
case MODULE_ALIAS:
return ""String_Node_Str"";
case IS_UNUSED_PARAMETER:
return ""String_Node_Str"";
case MODULE_EXPORT:
return ""String_Node_Str"";
case IS_SHORTHAND_PROPERTY:
return ""String_Node_Str"";
default :
throw new IllegalStateException(""String_Node_Str"" + propType);
}
}","private static final String propToString(byte propType){
switch (propType) {
case VAR_ARGS_NAME:
    return ""String_Node_Str"";
case JSDOC_INFO_PROP:
  return ""String_Node_Str"";
case INCRDECR_PROP:
return ""String_Node_Str"";
case QUOTED_PROP:
return ""String_Node_Str"";
case OPT_ARG_NAME:
return ""String_Node_Str"";
case SYNTHETIC_BLOCK_PROP:
return ""String_Node_Str"";
case ADDED_BLOCK:
return ""String_Node_Str"";
case ORIGINALNAME_PROP:
return ""String_Node_Str"";
case SIDE_EFFECT_FLAGS:
return ""String_Node_Str"";
case IS_CONSTANT_NAME:
return ""String_Node_Str"";
case IS_NAMESPACE:
return ""String_Node_Str"";
case DIRECTIVES:
return ""String_Node_Str"";
case DIRECT_EVAL:
return ""String_Node_Str"";
case FREE_CALL:
return ""String_Node_Str"";
case STATIC_SOURCE_FILE:
return ""String_Node_Str"";
case INPUT_ID:
return ""String_Node_Str"";
case SLASH_V:
return ""String_Node_Str"";
case INFERRED_FUNCTION:
return ""String_Node_Str"";
case CHANGE_TIME:
return ""String_Node_Str"";
case REFLECTED_OBJECT:
return ""String_Node_Str"";
case STATIC_MEMBER:
return ""String_Node_Str"";
case GENERATOR_FN:
return ""String_Node_Str"";
case ARROW_FN:
return ""String_Node_Str"";
case ASYNC_FN:
return ""String_Node_Str"";
case YIELD_ALL:
return ""String_Node_Str"";
case EXPORT_DEFAULT:
return ""String_Node_Str"";
case EXPORT_ALL_FROM:
return ""String_Node_Str"";
case IS_CONSTANT_VAR:
return ""String_Node_Str"";
case GENERATOR_MARKER:
return ""String_Node_Str"";
case GENERATOR_SAFE:
return ""String_Node_Str"";
case RAW_STRING_VALUE:
return ""String_Node_Str"";
case COMPUTED_PROP_METHOD:
return ""String_Node_Str"";
case COMPUTED_PROP_GETTER:
return ""String_Node_Str"";
case COMPUTED_PROP_SETTER:
return ""String_Node_Str"";
case COMPUTED_PROP_VARIABLE:
return ""String_Node_Str"";
case ANALYZED_DURING_GTI:
return ""String_Node_Str"";
case CONSTANT_PROPERTY_DEF:
return ""String_Node_Str"";
case DECLARED_TYPE_EXPR:
return ""String_Node_Str"";
case TYPE_BEFORE_CAST:
return ""String_Node_Str"";
case OPT_ES6_TYPED:
return ""String_Node_Str"";
case GENERIC_TYPE_LIST:
return ""String_Node_Str"";
case IMPLEMENTS:
return ""String_Node_Str"";
case CONSTRUCT_SIGNATURE:
return ""String_Node_Str"";
case ACCESS_MODIFIER:
return ""String_Node_Str"";
case NON_INDEXABLE:
return ""String_Node_Str"";
case PARSE_RESULTS:
return ""String_Node_Str"";
case GOOG_MODULE:
return ""String_Node_Str"";
case GOOG_MODULE_REQUIRE:
return ""String_Node_Str"";
case FEATURE_SET:
return ""String_Node_Str"";
case IS_MODULE_NAME:
return ""String_Node_Str"";
case WAS_PREVIOUSLY_PROVIDED:
return ""String_Node_Str"";
case IS_ES6_CLASS:
return ""String_Node_Str"";
case TRANSPILED:
return ""String_Node_Str"";
case DELETED:
return ""String_Node_Str"";
case MODULE_ALIAS:
return ""String_Node_Str"";
case IS_UNUSED_PARAMETER:
return ""String_Node_Str"";
case MODULE_EXPORT:
return ""String_Node_Str"";
case IS_SHORTHAND_PROPERTY:
return ""String_Node_Str"";
case ES6_MODULE:
return ""String_Node_Str"";
default :
throw new IllegalStateException(""String_Node_Str"" + propType);
}
}",0.9926533401674354
19182,"@Override protected void setUp() throws Exception {
  super.setUp();
  enableTypeCheck();
  enableClosurePass();
  enableClosurePassForExpected();
  enableRewriteClosureCode();
  setLanguage(LanguageMode.ECMASCRIPT_2015,LanguageMode.ECMASCRIPT5_STRICT);
  enableClosurePass();
  configuration=DEFAULT_CONFORMANCE;
  ignoreWarnings(DiagnosticGroups.MISSING_PROPERTIES);
}","@Override protected void setUp() throws Exception {
  super.setUp();
  enableTypeCheck();
  enableClosurePass();
  enableClosurePassForExpected();
  enableRewriteClosureCode();
  setLanguage(LanguageMode.ECMASCRIPT_2015,LanguageMode.ECMASCRIPT5_STRICT);
  configuration=DEFAULT_CONFORMANCE;
  ignoreWarnings(DiagnosticGroups.MISSING_PROPERTIES);
}",0.9679218967921897
19183,"/** 
 * This is the meat of the type checking.  It is basically one big switch, with each case representing one type of parse tree node.  The individual cases are usually pretty straightforward.
 * @param t The node traversal object that supplies context, such as thescope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */
@Override public void visit(NodeTraversal t,Node n,Node parent){
  JSType childType;
  JSType leftType;
  JSType rightType;
  Node left;
  Node right;
  boolean typeable=true;
switch (n.getToken()) {
case CAST:
    Node expr=n.getFirstChild();
  JSType exprType=getJSType(expr);
JSType castType=getJSType(n);
if (!expr.isObjectLit()) {
validator.expectCanCast(t,n,castType,exprType);
}
ensureTyped(t,n,castType);
expr.putProp(Node.TYPE_BEFORE_CAST,exprType);
if (castType.restrictByNotNullOrUndefined().isSubtypeOf(exprType) || expr.isObjectLit()) {
expr.setJSType(castType);
}
break;
case NAME:
typeable=visitName(t,n,parent);
break;
case COMMA:
ensureTyped(t,n,getJSType(n.getLastChild()));
break;
case THIS:
ensureTyped(t,n,t.getTypedScope().getTypeOfThis());
break;
case SUPER:
ensureTyped(t,n);
break;
case NULL:
ensureTyped(t,n,NULL_TYPE);
break;
case NUMBER:
ensureTyped(t,n,NUMBER_TYPE);
break;
case GETTER_DEF:
case SETTER_DEF:
break;
case ARRAYLIT:
ensureTyped(t,n,ARRAY_TYPE);
break;
case REGEXP:
ensureTyped(t,n,REGEXP_TYPE);
break;
case GETPROP:
visitGetProp(t,n);
typeable=!(parent.isAssign() && parent.getFirstChild() == n);
break;
case GETELEM:
visitGetElem(t,n);
typeable=false;
break;
case VAR:
case LET:
case CONST:
visitVar(t,n);
typeable=false;
break;
case NEW:
visitNew(t,n);
break;
case CALL:
visitCall(t,n);
typeable=!parent.isExprResult();
break;
case RETURN:
visitReturn(t,n);
typeable=false;
break;
case YIELD:
visitYield(t,n);
typeable=false;
break;
case DEC:
case INC:
left=n.getFirstChild();
checkPropCreation(t,left);
validator.expectNumber(t,left,getJSType(left),""String_Node_Str"");
ensureTyped(t,n,NUMBER_TYPE);
break;
case VOID:
ensureTyped(t,n,VOID_TYPE);
break;
case STRING:
case TYPEOF:
ensureTyped(t,n,STRING_TYPE);
break;
case BITNOT:
childType=getJSType(n.getFirstChild());
if (!childType.matchesNumberContext()) {
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getToken()),childType.toString());
}
 else if (this.strictOperatorChecks) {
this.validator.expectNumberStrict(n,childType,""String_Node_Str"");
}
ensureTyped(t,n,NUMBER_TYPE);
break;
case POS:
case NEG:
left=n.getFirstChild();
if (n.getToken() == Token.NEG) {
validator.expectNumber(t,left,getJSType(left),""String_Node_Str"");
}
ensureTyped(t,n,NUMBER_TYPE);
break;
case EQ:
case NE:
case SHEQ:
case SHNE:
{
left=n.getFirstChild();
right=n.getLastChild();
if (left.isTypeOf()) {
if (right.isString()) {
checkTypeofString(t,right,right.getString());
}
}
 else if (right.isTypeOf() && left.isString()) {
checkTypeofString(t,left,left.getString());
}
leftType=getJSType(left);
rightType=getJSType(right);
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=TernaryValue.UNKNOWN;
if (n.getToken() == Token.EQ || n.isNE()) {
result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if (n.isNE()) {
result=result.not();
}
}
 else {
if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
result=n.getToken() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
}
}
if (result != TernaryValue.UNKNOWN) {
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case LT:
case LE:
case GT:
case GE:
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
if (rightType.isUnknownType()) {
validator.expectStringOrNumber(t,n,leftType,""String_Node_Str"");
}
 else if (leftType.isUnknownType()) {
validator.expectStringOrNumber(t,n,leftType,""String_Node_Str"");
}
 else if (rightType.isNumber()) {
validator.expectNumber(t,n,leftType,""String_Node_Str"");
}
 else if (leftType.isNumber()) {
validator.expectNumber(t,n,rightType,""String_Node_Str"");
}
 else if (this.strictOperatorChecks) {
String errorMsg=""String_Node_Str"";
this.validator.expectMatchingTypes(n,leftType,rightType,errorMsg);
}
 else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
}
 else {
String message=""String_Node_Str"";
validator.expectString(t,n,leftType,message);
validator.expectNotNullOrUndefined(t,n,leftType,message,getNativeType(STRING_TYPE));
message=""String_Node_Str"";
validator.expectString(t,n,rightType,message);
validator.expectNotNullOrUndefined(t,n,rightType,message,getNativeType(STRING_TYPE));
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case IN:
left=n.getFirstChild();
right=n.getLastChild();
rightType=getJSType(right);
validator.expectString(t,left,getJSType(left),""String_Node_Str"");
validator.expectObject(t,n,rightType,""String_Node_Str"");
if (rightType.isStruct()) {
report(t,right,IN_USED_WITH_STRUCT);
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case INSTANCEOF:
left=n.getFirstChild();
right=n.getLastChild();
rightType=getJSType(right).restrictByNotNullOrUndefined();
validator.expectAnyObject(t,left,getJSType(left),""String_Node_Str"");
validator.expectActualObject(t,right,rightType,""String_Node_Str"");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case ASSIGN:
visitAssign(t,n);
typeable=false;
break;
case ASSIGN_LSH:
case ASSIGN_RSH:
case ASSIGN_URSH:
case ASSIGN_DIV:
case ASSIGN_MOD:
case ASSIGN_BITOR:
case ASSIGN_BITXOR:
case ASSIGN_BITAND:
case ASSIGN_SUB:
case ASSIGN_ADD:
case ASSIGN_MUL:
checkPropCreation(t,n.getFirstChild());
case LSH:
case RSH:
case URSH:
case DIV:
case MOD:
case BITOR:
case BITXOR:
case BITAND:
case SUB:
case ADD:
case MUL:
visitBinaryOperator(n.getToken(),t,n);
break;
case TRUE:
case FALSE:
case NOT:
case DELPROP:
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case CASE:
JSType switchType=getJSType(parent.getFirstChild());
JSType caseType=getJSType(n.getFirstChild());
validator.expectSwitchMatchesCase(t,n,switchType,caseType);
typeable=false;
break;
case WITH:
{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,""String_Node_Str"");
typeable=false;
break;
}
case MEMBER_FUNCTION_DEF:
ensureTyped(t,n,getJSType(n.getFirstChild()));
break;
case FUNCTION:
visitFunction(t,n);
break;
case PARAM_LIST:
case STRING_KEY:
case LABEL:
case LABEL_NAME:
case SWITCH:
case BREAK:
case CATCH:
case TRY:
case SCRIPT:
case EXPR_RESULT:
case BLOCK:
case ROOT:
case EMPTY:
case DEFAULT_CASE:
case CONTINUE:
case DEBUGGER:
case THROW:
case DO:
case IF:
case WHILE:
case FOR:
typeable=false;
break;
case FOR_IN:
Node obj=n.getSecondChild();
if (getJSType(obj).isStruct()) {
report(t,obj,IN_USED_WITH_STRUCT);
}
typeable=false;
break;
case FOR_OF:
ensureTyped(t,n.getSecondChild());
JSType iterable=getJSType(n.getSecondChild());
JSType autoboxedIterable=iterable.autoboxesTo();
iterable=autoboxedIterable != null ? autoboxedIterable : iterable;
validator.expectIterable(t,n.getSecondChild(),iterable,""String_Node_Str"");
typeable=false;
Node loopVarNode=NodeUtil.isNameDeclaration(n.getFirstChild()) ? n.getFirstFirstChild() : n.getFirstChild();
JSType declaredType=loopVarNode.getJSType();
if (declaredType != null) {
JSType actualType=iterable.getTemplateTypeMap().getResolvedTemplateType(typeRegistry.getIterableTemplate());
validator.expectCanAssignTo(t,loopVarNode,declaredType,actualType,""String_Node_Str"");
}
break;
case AND:
case HOOK:
case OBJECTLIT:
case OR:
if (n.getJSType() != null) {
ensureTyped(t,n);
}
 else {
if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
ensureTyped(t,n,parent.getJSType());
}
 else {
ensureTyped(t,n);
}
}
if (n.isObjectLit()) {
JSType typ=getJSType(n);
for (Node key : n.children()) {
visitObjLitKey(t,key,n,typ);
}
}
break;
default :
report(t,n,UNEXPECTED_TOKEN,n.getToken().toString());
ensureTyped(t,n);
break;
}
typeable=typeable && !inExterns;
if (typeable) {
doPercentTypedAccounting(t,n);
}
checkJsdocInfoContainsObjectWithBadKey(t,n);
}","/** 
 * This is the meat of the type checking.  It is basically one big switch, with each case representing one type of parse tree node.  The individual cases are usually pretty straightforward.
 * @param t The node traversal object that supplies context, such as thescope chain to use in name lookups as well as error reporting.
 * @param n The node being visited.
 * @param parent The parent of the node n.
 */
@Override public void visit(NodeTraversal t,Node n,Node parent){
  JSType childType;
  JSType leftType;
  JSType rightType;
  Node left;
  Node right;
  boolean typeable=true;
switch (n.getToken()) {
case CAST:
    Node expr=n.getFirstChild();
  JSType exprType=getJSType(expr);
JSType castType=getJSType(n);
if (!expr.isObjectLit()) {
validator.expectCanCast(t,n,castType,exprType);
}
ensureTyped(t,n,castType);
expr.putProp(Node.TYPE_BEFORE_CAST,exprType);
if (castType.restrictByNotNullOrUndefined().isSubtypeOf(exprType) || expr.isObjectLit()) {
expr.setJSType(castType);
}
break;
case NAME:
typeable=visitName(t,n,parent);
break;
case COMMA:
ensureTyped(t,n,getJSType(n.getLastChild()));
break;
case THIS:
ensureTyped(t,n,t.getTypedScope().getTypeOfThis());
break;
case SUPER:
ensureTyped(t,n);
break;
case NULL:
ensureTyped(t,n,NULL_TYPE);
break;
case NUMBER:
ensureTyped(t,n,NUMBER_TYPE);
break;
case GETTER_DEF:
case SETTER_DEF:
break;
case ARRAYLIT:
ensureTyped(t,n,ARRAY_TYPE);
break;
case REGEXP:
ensureTyped(t,n,REGEXP_TYPE);
break;
case GETPROP:
visitGetProp(t,n);
typeable=!(parent.isAssign() && parent.getFirstChild() == n);
break;
case GETELEM:
visitGetElem(t,n);
typeable=false;
break;
case VAR:
case LET:
case CONST:
visitVar(t,n);
typeable=false;
break;
case NEW:
visitNew(t,n);
break;
case CALL:
visitCall(t,n);
typeable=!parent.isExprResult();
break;
case RETURN:
visitReturn(t,n);
typeable=false;
break;
case YIELD:
visitYield(t,n);
typeable=false;
break;
case DEC:
case INC:
left=n.getFirstChild();
checkPropCreation(t,left);
validator.expectNumber(t,left,getJSType(left),""String_Node_Str"");
ensureTyped(t,n,NUMBER_TYPE);
break;
case VOID:
ensureTyped(t,n,VOID_TYPE);
break;
case STRING:
case TYPEOF:
ensureTyped(t,n,STRING_TYPE);
break;
case BITNOT:
childType=getJSType(n.getFirstChild());
if (!childType.matchesNumberContext()) {
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getToken()),childType.toString());
}
 else if (this.strictOperatorChecks) {
this.validator.expectNumberStrict(n,childType,""String_Node_Str"");
}
ensureTyped(t,n,NUMBER_TYPE);
break;
case POS:
case NEG:
left=n.getFirstChild();
if (n.getToken() == Token.NEG) {
validator.expectNumber(t,left,getJSType(left),""String_Node_Str"");
}
ensureTyped(t,n,NUMBER_TYPE);
break;
case EQ:
case NE:
case SHEQ:
case SHNE:
{
left=n.getFirstChild();
right=n.getLastChild();
if (left.isTypeOf()) {
if (right.isString()) {
checkTypeofString(t,right,right.getString());
}
}
 else if (right.isTypeOf() && left.isString()) {
checkTypeofString(t,left,left.getString());
}
leftType=getJSType(left);
rightType=getJSType(right);
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=TernaryValue.UNKNOWN;
if (n.getToken() == Token.EQ || n.isNE()) {
result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if (n.isNE()) {
result=result.not();
}
}
 else {
if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {
result=n.getToken() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE;
}
}
if (result != TernaryValue.UNKNOWN) {
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case LT:
case LE:
case GT:
case GE:
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
if (rightType.isUnknownType()) {
validator.expectStringOrNumber(t,n,leftType,""String_Node_Str"");
}
 else if (leftType.isUnknownType()) {
validator.expectStringOrNumber(t,n,leftType,""String_Node_Str"");
}
 else if (rightType.isNumber()) {
validator.expectNumber(t,n,leftType,""String_Node_Str"");
}
 else if (leftType.isNumber()) {
validator.expectNumber(t,n,rightType,""String_Node_Str"");
}
 else if (this.strictOperatorChecks) {
String errorMsg=""String_Node_Str"";
this.validator.expectMatchingTypes(n,leftType,rightType,errorMsg);
}
 else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {
}
 else {
String message=""String_Node_Str"";
validator.expectString(t,n,leftType,message);
validator.expectNotNullOrUndefined(t,n,leftType,message,getNativeType(STRING_TYPE));
message=""String_Node_Str"";
validator.expectString(t,n,rightType,message);
validator.expectNotNullOrUndefined(t,n,rightType,message,getNativeType(STRING_TYPE));
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case IN:
left=n.getFirstChild();
right=n.getLastChild();
rightType=getJSType(right);
validator.expectString(t,left,getJSType(left),""String_Node_Str"");
validator.expectObject(t,n,rightType,""String_Node_Str"");
if (rightType.isStruct()) {
report(t,right,IN_USED_WITH_STRUCT);
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case INSTANCEOF:
left=n.getFirstChild();
right=n.getLastChild();
rightType=getJSType(right).restrictByNotNullOrUndefined();
validator.expectAnyObject(t,left,getJSType(left),""String_Node_Str"");
validator.expectActualObject(t,right,rightType,""String_Node_Str"");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case ASSIGN:
visitAssign(t,n);
typeable=false;
break;
case ASSIGN_LSH:
case ASSIGN_RSH:
case ASSIGN_URSH:
case ASSIGN_DIV:
case ASSIGN_MOD:
case ASSIGN_BITOR:
case ASSIGN_BITXOR:
case ASSIGN_BITAND:
case ASSIGN_SUB:
case ASSIGN_ADD:
case ASSIGN_MUL:
checkPropCreation(t,n.getFirstChild());
case LSH:
case RSH:
case URSH:
case DIV:
case MOD:
case BITOR:
case BITXOR:
case BITAND:
case SUB:
case ADD:
case MUL:
visitBinaryOperator(n.getToken(),t,n);
break;
case TRUE:
case FALSE:
case NOT:
case DELPROP:
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case CASE:
JSType switchType=getJSType(parent.getFirstChild());
JSType caseType=getJSType(n.getFirstChild());
validator.expectSwitchMatchesCase(t,n,switchType,caseType);
typeable=false;
break;
case WITH:
{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,""String_Node_Str"");
typeable=false;
break;
}
case MEMBER_FUNCTION_DEF:
ensureTyped(t,n,getJSType(n.getFirstChild()));
break;
case FUNCTION:
visitFunction(t,n);
break;
case PARAM_LIST:
case STRING_KEY:
case LABEL:
case LABEL_NAME:
case SWITCH:
case BREAK:
case CATCH:
case TRY:
case SCRIPT:
case EXPR_RESULT:
case BLOCK:
case ROOT:
case EMPTY:
case DEFAULT_CASE:
case CONTINUE:
case DEBUGGER:
case THROW:
case DO:
case IF:
case WHILE:
case FOR:
typeable=false;
break;
case FOR_IN:
Node obj=n.getSecondChild();
if (getJSType(obj).isStruct()) {
report(t,obj,IN_USED_WITH_STRUCT);
}
typeable=false;
break;
case FOR_OF:
ensureTyped(t,n.getSecondChild());
JSType iterable=getJSType(n.getSecondChild());
JSType autoboxedIterable=iterable.autoboxesTo();
iterable=autoboxedIterable != null ? autoboxedIterable : iterable;
validator.expectIterable(t,n.getSecondChild(),iterable,""String_Node_Str"");
typeable=false;
Node loopVarNode=NodeUtil.isNameDeclaration(n.getFirstChild()) ? n.getFirstFirstChild() : n.getFirstChild();
JSType declaredType=loopVarNode.getJSType();
if (declaredType != null) {
JSType actualType=iterable.getTemplateTypeMap().getResolvedTemplateType(typeRegistry.getIterableTemplate());
validator.expectCanAssignTo(t,loopVarNode,actualType,declaredType,""String_Node_Str"");
}
break;
case AND:
case HOOK:
case OBJECTLIT:
case OR:
if (n.getJSType() != null) {
ensureTyped(t,n);
}
 else {
if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) {
ensureTyped(t,n,parent.getJSType());
}
 else {
ensureTyped(t,n);
}
}
if (n.isObjectLit()) {
JSType typ=getJSType(n);
for (Node key : n.children()) {
visitObjLitKey(t,key,n,typ);
}
}
break;
default :
report(t,n,UNEXPECTED_TOKEN,n.getToken().toString());
ensureTyped(t,n);
break;
}
typeable=typeable && !inExterns;
if (typeable) {
doPercentTypedAccounting(t,n);
}
checkJsdocInfoContainsObjectWithBadKey(t,n);
}",0.9976546105419084
19184,"protected void initTypes(){
  ALL_TYPE=registry.getNativeType(JSTypeNative.ALL_TYPE);
  NO_OBJECT_TYPE=registry.getNativeObjectType(JSTypeNative.NO_OBJECT_TYPE);
  NO_TYPE=registry.getNativeObjectType(JSTypeNative.NO_TYPE);
  NO_RESOLVED_TYPE=registry.getNativeObjectType(JSTypeNative.NO_RESOLVED_TYPE);
  ARRAY_FUNCTION_TYPE=registry.getNativeFunctionType(JSTypeNative.ARRAY_FUNCTION_TYPE);
  ARRAY_TYPE=registry.getNativeObjectType(JSTypeNative.ARRAY_TYPE);
  BOOLEAN_OBJECT_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE);
  BOOLEAN_OBJECT_TYPE=registry.getNativeObjectType(JSTypeNative.BOOLEAN_OBJECT_TYPE);
  BOOLEAN_TYPE=registry.getNativeType(JSTypeNative.BOOLEAN_TYPE);
  CHECKED_UNKNOWN_TYPE=registry.getNativeObjectType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
  DATE_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.DATE_FUNCTION_TYPE);
  DATE_TYPE=registry.getNativeObjectType(JSTypeNative.DATE_TYPE);
  ERROR_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.ERROR_FUNCTION_TYPE);
  ERROR_TYPE=registry.getNativeObjectType(JSTypeNative.ERROR_TYPE);
  EVAL_ERROR_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.EVAL_ERROR_FUNCTION_TYPE);
  EVAL_ERROR_TYPE=registry.getNativeObjectType(JSTypeNative.EVAL_ERROR_TYPE);
  FUNCTION_FUNCTION_TYPE=registry.getNativeFunctionType(JSTypeNative.FUNCTION_FUNCTION_TYPE);
  FUNCTION_INSTANCE_TYPE=registry.getNativeFunctionType(JSTypeNative.FUNCTION_INSTANCE_TYPE);
  FUNCTION_PROTOTYPE=registry.getNativeObjectType(JSTypeNative.FUNCTION_PROTOTYPE);
  GREATEST_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.GREATEST_FUNCTION_TYPE);
  LEAST_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);
  NULL_TYPE=registry.getNativeType(JSTypeNative.NULL_TYPE);
  NUMBER_OBJECT_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE);
  NUMBER_OBJECT_TYPE=registry.getNativeObjectType(JSTypeNative.NUMBER_OBJECT_TYPE);
  NUMBER_STRING_BOOLEAN=registry.getNativeType(JSTypeNative.NUMBER_STRING_BOOLEAN);
  NUMBER_STRING_BOOLEAN_SYMBOL=registry.getNativeType(JSTypeNative.NUMBER_STRING_BOOLEAN_SYMBOL);
  NUMBER_TYPE=registry.getNativeType(JSTypeNative.NUMBER_TYPE);
  OBJECT_FUNCTION_TYPE=registry.getNativeFunctionType(JSTypeNative.OBJECT_FUNCTION_TYPE);
  NULL_VOID=registry.getNativeType(JSTypeNative.NULL_VOID);
  OBJECT_NUMBER_STRING=registry.getNativeType(JSTypeNative.OBJECT_NUMBER_STRING);
  OBJECT_NUMBER_STRING_BOOLEAN=registry.getNativeType(JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN);
  OBJECT_NUMBER_STRING_BOOLEAN_SYMBOL=registry.getNativeType(JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN_SYMBOL);
  OBJECT_PROTOTYPE=registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE);
  OBJECT_TYPE=registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);
  RANGE_ERROR_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.RANGE_ERROR_FUNCTION_TYPE);
  RANGE_ERROR_TYPE=registry.getNativeObjectType(JSTypeNative.RANGE_ERROR_TYPE);
  REFERENCE_ERROR_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.REFERENCE_ERROR_FUNCTION_TYPE);
  REFERENCE_ERROR_TYPE=registry.getNativeObjectType(JSTypeNative.REFERENCE_ERROR_TYPE);
  REGEXP_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.REGEXP_FUNCTION_TYPE);
  REGEXP_TYPE=registry.getNativeObjectType(JSTypeNative.REGEXP_TYPE);
  STRING_OBJECT_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.STRING_OBJECT_FUNCTION_TYPE);
  STRING_OBJECT_TYPE=registry.getNativeObjectType(JSTypeNative.STRING_OBJECT_TYPE);
  STRING_TYPE=registry.getNativeType(JSTypeNative.STRING_TYPE);
  SYMBOL_OBJECT_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.SYMBOL_OBJECT_FUNCTION_TYPE);
  SYMBOL_OBJECT_TYPE=registry.getNativeObjectType(JSTypeNative.SYMBOL_OBJECT_TYPE);
  SYMBOL_TYPE=registry.getNativeType(JSTypeNative.SYMBOL_TYPE);
  SYNTAX_ERROR_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.SYNTAX_ERROR_FUNCTION_TYPE);
  SYNTAX_ERROR_TYPE=registry.getNativeObjectType(JSTypeNative.SYNTAX_ERROR_TYPE);
  TYPE_ERROR_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.TYPE_ERROR_FUNCTION_TYPE);
  TYPE_ERROR_TYPE=registry.getNativeObjectType(JSTypeNative.TYPE_ERROR_TYPE);
  U2U_CONSTRUCTOR_TYPE=registry.getNativeFunctionType(JSTypeNative.U2U_CONSTRUCTOR_TYPE);
  U2U_FUNCTION_TYPE=registry.getNativeFunctionType(JSTypeNative.U2U_FUNCTION_TYPE);
  UNKNOWN_TYPE=registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE);
  URI_ERROR_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.URI_ERROR_FUNCTION_TYPE);
  URI_ERROR_TYPE=registry.getNativeObjectType(JSTypeNative.URI_ERROR_TYPE);
  VOID_TYPE=registry.getNativeType(JSTypeNative.VOID_TYPE);
  addNativeProperties(registry);
  NATIVE_PROPERTIES_COUNT=OBJECT_TYPE.getPropertiesCount();
}","protected void initTypes(){
  ALL_TYPE=registry.getNativeType(JSTypeNative.ALL_TYPE);
  NO_OBJECT_TYPE=registry.getNativeObjectType(JSTypeNative.NO_OBJECT_TYPE);
  NO_TYPE=registry.getNativeObjectType(JSTypeNative.NO_TYPE);
  NO_RESOLVED_TYPE=registry.getNativeObjectType(JSTypeNative.NO_RESOLVED_TYPE);
  ARRAY_FUNCTION_TYPE=registry.getNativeFunctionType(JSTypeNative.ARRAY_FUNCTION_TYPE);
  ARRAY_TYPE=registry.getNativeObjectType(JSTypeNative.ARRAY_TYPE);
  BOOLEAN_OBJECT_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE);
  BOOLEAN_OBJECT_TYPE=registry.getNativeObjectType(JSTypeNative.BOOLEAN_OBJECT_TYPE);
  BOOLEAN_TYPE=registry.getNativeType(JSTypeNative.BOOLEAN_TYPE);
  CHECKED_UNKNOWN_TYPE=registry.getNativeObjectType(JSTypeNative.CHECKED_UNKNOWN_TYPE);
  DATE_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.DATE_FUNCTION_TYPE);
  DATE_TYPE=registry.getNativeObjectType(JSTypeNative.DATE_TYPE);
  ERROR_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.ERROR_FUNCTION_TYPE);
  ERROR_TYPE=registry.getNativeObjectType(JSTypeNative.ERROR_TYPE);
  EVAL_ERROR_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.EVAL_ERROR_FUNCTION_TYPE);
  EVAL_ERROR_TYPE=registry.getNativeObjectType(JSTypeNative.EVAL_ERROR_TYPE);
  FUNCTION_FUNCTION_TYPE=registry.getNativeFunctionType(JSTypeNative.FUNCTION_FUNCTION_TYPE);
  FUNCTION_INSTANCE_TYPE=registry.getNativeFunctionType(JSTypeNative.FUNCTION_INSTANCE_TYPE);
  FUNCTION_PROTOTYPE=registry.getNativeObjectType(JSTypeNative.FUNCTION_PROTOTYPE);
  GREATEST_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.GREATEST_FUNCTION_TYPE);
  LEAST_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE);
  NULL_TYPE=registry.getNativeType(JSTypeNative.NULL_TYPE);
  NUMBER_OBJECT_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE);
  NUMBER_OBJECT_TYPE=registry.getNativeObjectType(JSTypeNative.NUMBER_OBJECT_TYPE);
  NUMBER_STRING_BOOLEAN=registry.getNativeType(JSTypeNative.NUMBER_STRING_BOOLEAN);
  NUMBER_TYPE=registry.getNativeType(JSTypeNative.NUMBER_TYPE);
  OBJECT_FUNCTION_TYPE=registry.getNativeFunctionType(JSTypeNative.OBJECT_FUNCTION_TYPE);
  NULL_VOID=registry.getNativeType(JSTypeNative.NULL_VOID);
  OBJECT_NUMBER_STRING=registry.getNativeType(JSTypeNative.OBJECT_NUMBER_STRING);
  OBJECT_NUMBER_STRING_BOOLEAN=registry.getNativeType(JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN);
  OBJECT_PROTOTYPE=registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE);
  OBJECT_TYPE=registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);
  RANGE_ERROR_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.RANGE_ERROR_FUNCTION_TYPE);
  RANGE_ERROR_TYPE=registry.getNativeObjectType(JSTypeNative.RANGE_ERROR_TYPE);
  REFERENCE_ERROR_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.REFERENCE_ERROR_FUNCTION_TYPE);
  REFERENCE_ERROR_TYPE=registry.getNativeObjectType(JSTypeNative.REFERENCE_ERROR_TYPE);
  REGEXP_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.REGEXP_FUNCTION_TYPE);
  REGEXP_TYPE=registry.getNativeObjectType(JSTypeNative.REGEXP_TYPE);
  STRING_OBJECT_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.STRING_OBJECT_FUNCTION_TYPE);
  STRING_OBJECT_TYPE=registry.getNativeObjectType(JSTypeNative.STRING_OBJECT_TYPE);
  STRING_TYPE=registry.getNativeType(JSTypeNative.STRING_TYPE);
  SYMBOL_OBJECT_TYPE=registry.getNativeObjectType(JSTypeNative.SYMBOL_OBJECT_TYPE);
  SYMBOL_TYPE=registry.getNativeType(JSTypeNative.SYMBOL_TYPE);
  SYNTAX_ERROR_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.SYNTAX_ERROR_FUNCTION_TYPE);
  SYNTAX_ERROR_TYPE=registry.getNativeObjectType(JSTypeNative.SYNTAX_ERROR_TYPE);
  TYPE_ERROR_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.TYPE_ERROR_FUNCTION_TYPE);
  TYPE_ERROR_TYPE=registry.getNativeObjectType(JSTypeNative.TYPE_ERROR_TYPE);
  U2U_CONSTRUCTOR_TYPE=registry.getNativeFunctionType(JSTypeNative.U2U_CONSTRUCTOR_TYPE);
  U2U_FUNCTION_TYPE=registry.getNativeFunctionType(JSTypeNative.U2U_FUNCTION_TYPE);
  UNKNOWN_TYPE=registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE);
  URI_ERROR_FUNCTION_TYPE=registry.getNativeType(JSTypeNative.URI_ERROR_FUNCTION_TYPE);
  URI_ERROR_TYPE=registry.getNativeObjectType(JSTypeNative.URI_ERROR_TYPE);
  VOID_TYPE=registry.getNativeType(JSTypeNative.VOID_TYPE);
  addNativeProperties(registry);
  NATIVE_PROPERTIES_COUNT=OBJECT_TYPE.getPropertiesCount();
}",0.9661728940968384
19185,"protected final void assertTypeNotEquals(String msg,JSType a,JSType b){
  Asserts.assertTypeNotEquals(msg,a,b);
}","protected final void assertTypeNotEquals(JSType a,JSType b){
  Asserts.assertTypeNotEquals(a,b);
}",0.9289099526066352
19186,"/** 
 * Walk the AST from the call site to the expression root and verify that the portions of the expression that are evaluated before the call: 1) are unaffected by the side-effects, if any, of the call. 2) have no side-effects, that may influence the call. For example, if x has side-effects: a = 1 + x(); the call to x can be moved because the final value of ""a"" can not be influenced by x(), but in: a = b + x(); the call to x cannot be moved because the value of ""b"" may be modified by the call to x. If x is without side-effects in: a = b + x(); the call to x can be moved, but in: a = (b.foo = c) + x(); the call to x can not be moved because the value of b.foo may be referenced by x().  Note: this is true even if b is a local variable; the object that b refers to may have a global alias.
 * @return UNDECOMPOSABLE if the expression cannot be moved, DECOMPOSABLE ifdecomposition is required before the expression can be moved, otherwise MOVABLE.
 */
private DecompositionType isSubexpressionMovable(Node expressionRoot,Node subExpression){
  boolean requiresDecomposition=false;
  boolean seenSideEffects=NodeUtil.mayHaveSideEffects(subExpression,compiler);
  Node child=subExpression;
  for (  Node parent : child.getAncestors()) {
    if (parent == expressionRoot) {
      return requiresDecomposition ? DecompositionType.DECOMPOSABLE : DecompositionType.MOVABLE;
    }
    if (isConditionalOp(parent)) {
      if (child != parent.getFirstChild()) {
        requiresDecomposition=true;
      }
    }
 else {
      if (isSafeAssign(parent,seenSideEffects)) {
      }
 else {
        for (        Node n : parent.children()) {
          if (n == child) {
            break;
          }
          if (isExpressionTreeUnsafe(n,seenSideEffects)) {
            seenSideEffects=true;
            requiresDecomposition=true;
          }
        }
        Node first=parent.getFirstChild();
        if (requiresDecomposition && parent.isCall() && NodeUtil.isGet(first)) {
          if (allowMethodCallDecomposing) {
            return DecompositionType.DECOMPOSABLE;
          }
 else {
            return DecompositionType.UNDECOMPOSABLE;
          }
        }
      }
    }
    child=parent;
  }
  throw new IllegalStateException(""String_Node_Str"");
}","/** 
 * Walk the AST from the call site to the expression root and verify that the portions of the expression that are evaluated before the call: 1) are unaffected by the side-effects, if any, of the call. 2) have no side-effects, that may influence the call. For example, if x has side-effects: a = 1 + x(); the call to x can be moved because the final value of ""a"" can not be influenced by x(), but in: a = b + x(); the call to x cannot be moved because the value of ""b"" may be modified by the call to x. If x is without side-effects in: a = b + x(); the call to x can be moved, but in: a = (b.foo = c) + x(); the call to x can not be moved because the value of b.foo may be referenced by x().  Note: this is true even if b is a local variable; the object that b refers to may have a global alias.
 * @return UNDECOMPOSABLE if the expression cannot be moved, DECOMPOSABLE ifdecomposition is required before the expression can be moved, otherwise MOVABLE.
 */
private DecompositionType isSubexpressionMovable(Node expressionRoot,Node subExpression){
  boolean requiresDecomposition=false;
  boolean seenSideEffects=NodeUtil.mayHaveSideEffects(subExpression,compiler);
  Node child=subExpression;
  for (  Node parent : child.getAncestors()) {
    if (parent == expressionRoot) {
      return requiresDecomposition ? DecompositionType.DECOMPOSABLE : DecompositionType.MOVABLE;
    }
    if (isConditionalOp(parent)) {
      if (child != parent.getFirstChild()) {
        requiresDecomposition=true;
      }
    }
 else {
      if (isSafeAssign(parent,seenSideEffects)) {
      }
 else {
        EvaluationDirection direction=getEvaluationDirection(parent);
        for (Node n=getFirstEvaluatedChild(parent,direction); n != null; n=getNextEvaluatedSibling(n,direction)) {
          if (n == child) {
            break;
          }
          if (isExpressionTreeUnsafe(n,seenSideEffects)) {
            seenSideEffects=true;
            requiresDecomposition=true;
          }
        }
        Node first=parent.getFirstChild();
        if (requiresDecomposition && parent.isCall() && NodeUtil.isGet(first)) {
          if (allowMethodCallDecomposing) {
            return DecompositionType.DECOMPOSABLE;
          }
 else {
            return DecompositionType.UNDECOMPOSABLE;
          }
        }
      }
    }
    child=parent;
  }
  throw new IllegalStateException(""String_Node_Str"");
}",0.9574010327022376
19187,"/** 
 * Gets a   {@link Property} given the node that references it; the {@link Property} is createdif it does not already exist.
 * @return A {@link Property}, or null if the provided node is not a qualified name.
 */
private Property getOrCreateProperty(Node propNode){
  if (!propNode.isQualifiedName()) {
    return null;
  }
  String propName=propNode.isGetProp() ? propNode.getLastChild().getString() : propNode.getQualifiedName();
  if (propertyMap.containsKey(propName)) {
    return propertyMap.get(propName);
  }
  Property property=new Property(propName);
  propertyMap.put(propName,property);
  if (propNode.isGetProp()) {
    Property parentProperty=getOrCreateProperty(propNode.getFirstChild());
    if (parentProperty != null) {
      parentProperty.children.add(property);
    }
  }
  return property;
}","/** 
 * Gets a   {@link Property} given the node that references it; the {@link Property} is createdif it does not already exist.
 * @return A {@link Property}, or null if the provided node is not a qualified name.
 */
private Property getOrCreateProperty(Node propNode){
  if (!propNode.isQualifiedName()) {
    return null;
  }
  String propName=propNode.isGetProp() ? propNode.getLastChild().getString() : propNode.getQualifiedName();
  Property property=propertyMap.computeIfAbsent(propName,name -> new Property(name));
  if (propNode.isGetProp()) {
    Property parentProperty=getOrCreateProperty(propNode.getFirstChild());
    if (parentProperty != null) {
      parentProperty.children.add(property);
    }
  }
  return property;
}",0.8978805394990366
19188,"private void replaceSymbol(NodeTraversal t,Node node,String name,CompilerInput input){
  Node parent=node.getParent();
  boolean isCrossModule=isCrossModuleName(name);
  if (!isCrossModule) {
    if (!NodeUtil.isNameDeclaration(parent)) {
      return;
    }
    boolean hasInterestingChildren=false;
    for (    Node c : parent.children()) {
      if (!c.isName() || isCrossModuleName(c.getString()) || isExternVar(c.getString(),t)) {
        hasInterestingChildren=true;
        break;
      }
    }
    if (!hasInterestingChildren) {
      return;
    }
  }
  Node replacement=isCrossModule ? IR.getprop(IR.name(globalSymbolNamespace).srcref(node),IR.string(name).srcref(node)) : IR.name(name).srcref(node);
  replacement.srcref(node);
  if (node.hasChildren()) {
    Node assign=IR.assign(replacement,node.removeFirstChild());
    parent.replaceChild(node,assign);
    compiler.reportChangeToEnclosingScope(assign);
  }
 else   if (isCrossModule) {
    parent.replaceChild(node,replacement);
    compiler.reportChangeToEnclosingScope(replacement);
    if (parent.isCall() && !maybeReferencesThis.contains(name)) {
      parent.putBooleanProp(Node.FREE_CALL,false);
    }
  }
  if (!isCrossModule && NodeUtil.isNameDeclaration(parent)) {
    preDeclarations.add(new ModuleGlobal(input.getAstRoot(compiler),IR.name(name).srcref(node)));
  }
  compiler.reportChangeToEnclosingScope(parent);
}","/** 
 * Replaces a global cross-module name with an access on the global namespace symbol 
 */
private void replaceSymbol(Node node,String name){
  Node parent=node.getParent();
  Node replacement=IR.getprop(IR.name(globalSymbolNamespace),IR.string(name));
  replacement.useSourceInfoFromForTree(node);
  parent.replaceChild(node,replacement);
  compiler.reportChangeToEnclosingScope(replacement);
  if (parent.isCall() && !maybeReferencesThis.contains(name)) {
    parent.putBooleanProp(Node.FREE_CALL,false);
  }
  compiler.reportChangeToEnclosingScope(parent);
}",0.3481368044920878
19189,"/** 
 * Rewrites extern names to be explicit children of window instead of only implicitly referencing it. This enables injecting window into a scope and make all global symbols depend on the injected object.
 */
private void visitExtern(Node nameNode,Node parent){
  String name=nameNode.getString();
  if (globalSymbolNamespace.equals(name) || SPECIAL_EXTERNS.contains(name)) {
    return;
  }
  Node windowPropAccess=IR.getprop(IR.name(WINDOW),IR.string(name));
  if (NodeUtil.isNameDeclaration(parent) && nameNode.hasOneChild()) {
    Node assign=IR.assign(windowPropAccess,nameNode.removeFirstChild());
    assign.setJSDocInfo(parent.getJSDocInfo());
    parent.replaceChild(nameNode,assign.srcrefTree(parent));
  }
 else {
    parent.replaceChild(nameNode,windowPropAccess.srcrefTree(nameNode));
  }
  compiler.reportChangeToEnclosingScope(parent);
}","/** 
 * Rewrites extern names to be explicit children of window instead of only implicitly referencing it. This enables injecting window into a scope and make all global symbols depend on the injected object.
 */
private void visitExtern(Node nameNode,Node parent){
  String name=nameNode.getString();
  if (globalSymbolNamespace.equals(name) || SPECIAL_EXTERNS.contains(name)) {
    return;
  }
  Node windowPropAccess=IR.getprop(IR.name(WINDOW),IR.string(name));
  parent.replaceChild(nameNode,windowPropAccess.srcrefTree(nameNode));
  compiler.reportChangeToEnclosingScope(parent);
}",0.6893203883495146
19190,"private void visitName(NodeTraversal t,Node n,Node parent){
  String name=n.getString();
  if (parent.isFunction() && name.isEmpty()) {
    return;
  }
  if (isExternVar(name,t)) {
    visitExtern(n,parent);
    return;
  }
  Var var=t.getScope().getVar(name);
  if (!var.isGlobal() && (name.equals(globalSymbolNamespace) || name.startsWith(globalSymbolNamespace + DISAMBIGUATION_SUFFIX))) {
    n.setString(name + DISAMBIGUATION_SUFFIX);
    compiler.reportChangeToEnclosingScope(n);
  }
  if (!var.isGlobal()) {
    return;
  }
  replaceSymbol(t,n,name,t.getInput());
}","private void visitName(NodeTraversal t,Node n,Node parent){
  String name=n.getString();
  if (parent.isFunction() && name.isEmpty()) {
    return;
  }
  if (isExternVar(name,t)) {
    visitExtern(n,parent);
    return;
  }
  Var var=t.getScope().getVar(name);
  if (!var.isGlobal() && (name.equals(globalSymbolNamespace) || name.startsWith(globalSymbolNamespace + DISAMBIGUATION_SUFFIX))) {
    n.setString(name + DISAMBIGUATION_SUFFIX);
    compiler.reportChangeToEnclosingScope(n);
  }
  if (!(var.isGlobal() && isCrossModuleName(name))) {
    return;
  }
  replaceSymbol(n,name);
}",0.9550173010380624
19191,"public void testObjectDestructuringDeclarations(){
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
}","public void testObjectDestructuringDeclarations(){
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
}",0.948216340621404
19192,"public void testSameVarDeclaredInExternsAndSource(){
  test(externs(""String_Node_Str""),srcs(""String_Node_Str""),expected(""String_Node_Str""));
  test(externs(""String_Node_Str""),srcs(""String_Node_Str""),expected(""String_Node_Str""));
  test(externs(""String_Node_Str""),srcs(""String_Node_Str""),expected(""String_Node_Str""));
  test(externs(""String_Node_Str""),srcs(""String_Node_Str""),expected(""String_Node_Str""));
  test(externs(""String_Node_Str""),srcs(""String_Node_Str""),expected(""String_Node_Str""));
  test(externs(""String_Node_Str""),srcs(""String_Node_Str""),expected(""String_Node_Str""));
  test(externs(""String_Node_Str""),srcs(""String_Node_Str""),expected(""String_Node_Str""));
  test(externs(""String_Node_Str""),srcs(""String_Node_Str""),expected(""String_Node_Str""));
  test(externs(""String_Node_Str""),srcs(""String_Node_Str""),expected(""String_Node_Str""));
  test(externs(""String_Node_Str""),srcs(""String_Node_Str""),expected(""String_Node_Str""));
  test(externs(""String_Node_Str""),srcs(""String_Node_Str""),expected(""String_Node_Str""));
}","public void testSameVarDeclaredInExternsAndSource(){
  test(externs(""String_Node_Str""),srcs(""String_Node_Str""),expected(""String_Node_Str""));
  test(externs(""String_Node_Str""),srcs(""String_Node_Str""),expected(""String_Node_Str""));
  test(externs(""String_Node_Str""),srcs(""String_Node_Str""),expected(""String_Node_Str""));
  test(externs(""String_Node_Str""),srcs(""String_Node_Str""),expected(""String_Node_Str""));
  test(externs(""String_Node_Str""),srcs(""String_Node_Str""),expected(""String_Node_Str""));
  test(externs(""String_Node_Str""),srcs(""String_Node_Str""),expected(""String_Node_Str""));
  test(externs(""String_Node_Str""),srcs(""String_Node_Str""),expected(""String_Node_Str""));
  test(externs(""String_Node_Str""),srcs(""String_Node_Str""),expected(""String_Node_Str""));
  test(externs(""String_Node_Str""),srcs(""String_Node_Str""),expected(""String_Node_Str""));
  test(externs(""String_Node_Str""),srcs(""String_Node_Str""),expected(""String_Node_Str""));
  test(externs(""String_Node_Str""),srcs(""String_Node_Str""),expected(""String_Node_Str""));
  test(externs(""String_Node_Str""),srcs(""String_Node_Str""),expected(""String_Node_Str""));
}",0.9587242026266416
19193,"public void testObjectDestructuringDeclarations_acrossModules(){
  assumeCrossModuleNames=false;
  test(createModules(""String_Node_Str"",""String_Node_Str""),new String[]{""String_Node_Str"",""String_Node_Str""});
  test(createModules(""String_Node_Str"",""String_Node_Str""),new String[]{""String_Node_Str"",""String_Node_Str""});
  test(createModules(""String_Node_Str"",""String_Node_Str""),new String[]{""String_Node_Str"",""String_Node_Str""});
  test(createModules(""String_Node_Str"",""String_Node_Str""),new String[]{""String_Node_Str"",""String_Node_Str""});
}","public void testObjectDestructuringDeclarations_acrossModules(){
  assumeCrossModuleNames=false;
  test(createModules(""String_Node_Str"",""String_Node_Str""),new String[]{""String_Node_Str"",""String_Node_Str""});
  test(createModules(""String_Node_Str"",""String_Node_Str""),new String[]{""String_Node_Str"",""String_Node_Str""});
  test(createModules(""String_Node_Str"",""String_Node_Str""),new String[]{""String_Node_Str"",""String_Node_Str""});
  test(createModules(""String_Node_Str"",""String_Node_Str""),new String[]{""String_Node_Str"",""String_Node_Str""});
  test(createModules(""String_Node_Str"",""String_Node_Str""),new String[]{""String_Node_Str"",""String_Node_Str""});
  test(createModules(""String_Node_Str"",""String_Node_Str""),new String[]{""String_Node_Str"",""String_Node_Str""});
}",0.8302469135802469
19194,"public void testObjectDestructuringDeclarations_allSameModule(){
  assumeCrossModuleNames=false;
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
}","public void testObjectDestructuringDeclarations_allSameModule(){
  assumeCrossModuleNames=false;
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
}",0.8815286624203822
19195,"public AbstractScope<?,?> getClosestHoistScope(){
  for (int i=scopeRoots.size(); i > 0; i--) {
    if (isHoistScopeRootNode(scopeRoots.get(i - 1))) {
      return instantiateScopes(i);
    }
  }
  return (AbstractScope<?,?>)scopes.peek().getClosestHoistScope();
}","public AbstractScope<?,?> getClosestHoistScope(){
  for (int i=scopeRoots.size(); i > 0; i--) {
    if (isHoistScopeRootNode(scopeRoots.get(i - 1))) {
      return instantiateScopes(i);
    }
  }
  return scopes.peek().getClosestHoistScope();
}",0.9606299212598424
19196,"/** 
 * Keep applying fixes to the given file until no more fixes can be found, or until fixes have been applied   {@code MAX_FIXES} times.
 */
static void fixRepeatedly(String filename) throws IOException {
  for (int i=0; i < MAX_FIXES; i++) {
    if (!fix(filename)) {
      break;
    }
  }
}","/** 
 * Keep applying fixes to the given file until no more fixes can be found, or until fixes have been applied   {@code MAX_FIXES} times.
 */
static void fixRepeatedly(String filename,ImmutableSet<DiagnosticType> unfixableErrors) throws IOException {
  for (int i=0; i < MAX_FIXES; i++) {
    if (!fix(filename,unfixableErrors)) {
      break;
    }
  }
}",0.906584992343032
19197,"/** 
 * @return Whether any fixes were applied. 
 */
private static boolean fix(String filename) throws IOException {
  Compiler compiler=new Compiler(System.out);
  FixingErrorManager errorManager=new FixingErrorManager();
  compiler.setErrorManager(errorManager);
  errorManager.setCompiler(compiler);
  lint(Paths.get(filename),compiler);
  Collection<SuggestedFix> fixes=errorManager.getAllFixes();
  if (!fixes.isEmpty()) {
    ApplySuggestedFixes.applySuggestedFixesToFiles(fixes);
    return true;
  }
  return false;
}","/** 
 * @return Whether any fixes were applied. 
 */
private static boolean fix(String filename,ImmutableSet<DiagnosticType> unfixableErrors) throws IOException {
  Compiler compiler=new Compiler(System.out);
  FixingErrorManager errorManager=new FixingErrorManager(unfixableErrors);
  compiler.setErrorManager(errorManager);
  errorManager.setCompiler(compiler);
  lint(Paths.get(filename),compiler);
  Collection<SuggestedFix> fixes=errorManager.getAllFixes();
  if (!fixes.isEmpty()) {
    ApplySuggestedFixes.applySuggestedFixesToFiles(fixes);
    return true;
  }
  return false;
}",0.946043165467626
19198,"public FixingErrorManager(){
}","public FixingErrorManager(ImmutableSet<DiagnosticType> unfixableErrors){
  this.unfixableErrors=unfixableErrors;
}",0.4166666666666667
19199,"@Override public void report(CheckLevel level,JSError error){
  super.report(level,error);
  fixes.putAll(error,ErrorToFixMapper.getFixesForJsError(error,compiler));
}","@Override public void report(CheckLevel level,JSError error){
  super.report(level,error);
  if (!unfixableErrors.contains(error.getType())) {
    fixes.putAll(error,ErrorToFixMapper.getFixesForJsError(error,compiler));
  }
}",0.8520408163265306
19200,"/** 
 * Expect that the given variable has not been declared with a type.
 * @param sourceName The name of the source file we're in.
 * @param n The node where warnings should point to.
 * @param parent The parent of {@code n}.
 * @param var The variable that we're checking.
 * @param variableName The name of the variable.
 * @param newType The type being applied to the variable. Mostly just herefor the benefit of the warning.
 * @return The variable we end up with. Most of the time, this will justbe  {@code var}, but in some rare cases we will need to declare a new var with new source info.
 */
TypedVar expectUndeclaredVariable(String sourceName,CompilerInput input,Node n,Node parent,TypedVar var,String variableName,JSType newType){
  TypedVar newVar=var;
  JSType varType=var.getType();
  if (varType != null && varType != typeRegistry.getNativeType(UNKNOWN_TYPE) && newType != null && newType != typeRegistry.getNativeType(UNKNOWN_TYPE)) {
    if (var.input == null) {
      TypedScope s=var.getScope();
      s.undeclare(var);
      newVar=s.declare(variableName,n,varType,input,false);
      n.setJSType(varType);
      if (parent.isVar()) {
        if (n.hasChildren()) {
          n.getFirstChild().setJSType(varType);
        }
      }
 else {
        checkState(parent.isFunction());
        parent.setJSType(varType);
      }
    }
 else {
      boolean allowDupe=hasDuplicateDeclarationSuppression(compiler,var.getNameNode());
      if (!allowDupe) {
        if (!newType.isEquivalentTo(varType)) {
          report(JSError.make(n,DUP_VAR_DECLARATION_TYPE_MISMATCH,variableName,newType.toString(),var.getInputName(),String.valueOf(var.nameNode.getLineno()),varType.toString()));
        }
 else         if (!var.getParentNode().isExprResult()) {
          report(JSError.make(n,DUP_VAR_DECLARATION,variableName,var.getInputName(),String.valueOf(var.nameNode.getLineno())));
        }
      }
    }
  }
  return newVar;
}","/** 
 * Expect that the given variable has not been declared with a type.
 * @param sourceName The name of the source file we're in.
 * @param n The node where warnings should point to.
 * @param parent The parent of {@code n}.
 * @param var The variable that we're checking.
 * @param variableName The name of the variable.
 * @param newType The type being applied to the variable. Mostly just herefor the benefit of the warning.
 * @return The variable we end up with. Most of the time, this will justbe  {@code var}, but in some rare cases we will need to declare a new var with new source info.
 */
TypedVar expectUndeclaredVariable(String sourceName,CompilerInput input,Node n,Node parent,TypedVar var,String variableName,JSType newType){
  TypedVar newVar=var;
  JSType varType=var.getType();
  if (varType != null && varType != typeRegistry.getNativeType(UNKNOWN_TYPE) && newType != null && newType != typeRegistry.getNativeType(UNKNOWN_TYPE)) {
    if (var.input == null) {
      TypedScope s=var.getScope();
      s.undeclare(var);
      newVar=s.declare(variableName,n,varType,input,false);
      n.setJSType(varType);
      if (parent.isVar()) {
        if (n.hasChildren()) {
          n.getFirstChild().setJSType(varType);
        }
      }
 else {
        checkState(parent.isFunction());
        parent.setJSType(varType);
      }
    }
 else {
      boolean allowDupe=hasDuplicateDeclarationSuppression(compiler,var.getNameNode());
      if (!allowDupe) {
        if (!newType.isEquivalentTo(varType,true)) {
          report(JSError.make(n,DUP_VAR_DECLARATION_TYPE_MISMATCH,variableName,newType.toString(),var.getInputName(),String.valueOf(var.nameNode.getLineno()),varType.toString()));
        }
 else         if (!var.getParentNode().isExprResult()) {
          report(JSError.make(n,DUP_VAR_DECLARATION,variableName,var.getInputName(),String.valueOf(var.nameNode.getLineno())));
        }
      }
    }
  }
  return newVar;
}",0.9987136609210188
19201,"/** 
 * Whether this type is meaningfully different from   {@code that} type forthe purposes of data flow analysis. This is a trickier check than pure equality, because it has to properly handle unknown types. See  {@code EquivalenceMethod} for more info.
 * @see <a href=""http://www.youtube.com/watch?v=_RpSv3HjpEw"">Unknown unknowns</a>
 */
public final boolean differsFrom(JSType that){
  return !checkEquivalenceHelper(that,EquivalenceMethod.DATA_FLOW);
}","/** 
 * Whether this type is meaningfully different from   {@code that} type forthe purposes of data flow analysis. This is a trickier check than pure equality, because it has to properly handle unknown types. See  {@code EquivalenceMethod} for more info.
 * @see <a href=""http://www.youtube.com/watch?v=_RpSv3HjpEw"">Unknown unknowns</a>
 */
public final boolean differsFrom(JSType that){
  return !checkEquivalenceHelper(that,EquivalenceMethod.DATA_FLOW,EqCache.create());
}",0.9817792068595927
19202,"/** 
 * Detects cycles in either the implicit prototype chain, or the implemented/extended interfaces.<p>
 * @return True iff a cycle was detected.
 */
final boolean detectInheritanceCycle(){
  return detectImplicitPrototypeCycle() || Iterables.contains(this.getCtorImplementedInterfaces(),this) || Iterables.contains(this.getCtorExtendedInterfaces(),this);
}","/** 
 * Detects cycles in either the implicit prototype chain, or the implemented/extended interfaces.<p>
 * @return True iff a cycle was detected.
 */
final boolean detectInheritanceCycle(){
  if (detectImplicitPrototypeCycle() || Iterables.contains(this.getCtorImplementedInterfaces(),this)) {
    return true;
  }
  FunctionType fnType=this.getConstructor();
  return fnType != null && fnType.checkExtendsLoop() != null;
}",0.7806122448979592
19203,"public static void assertTypeEquals(String message,JSType a,JSType b){
  checkNotNull(a);
  checkNotNull(b);
  Assert.assertTrue(message + (message.isEmpty() ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ a+ ""String_Node_Str""+ ""String_Node_Str""+ b,a.isEquivalentTo(b));
  Assert.assertTrue(message + ""String_Node_Str"" + ""String_Node_Str""+ b+ ""String_Node_Str""+ ""String_Node_Str""+ a,b.isEquivalentTo(a));
}","public static void assertTypeEquals(String message,JSType a,JSType b){
  checkNotNull(a);
  checkNotNull(b);
  Assert.assertTrue(message + (message.isEmpty() ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ a+ ""String_Node_Str""+ ""String_Node_Str""+ b,a.isEquivalentTo(b,true));
  Assert.assertTrue(message + ""String_Node_Str"" + ""String_Node_Str""+ b+ ""String_Node_Str""+ ""String_Node_Str""+ a,b.isEquivalentTo(a,true));
}",0.9882352941176472
19204,"public void verifySubtypeChain(List<JSType> typeChain,boolean checkSubtyping) throws Exception {
  for (int i=0; i < typeChain.size(); i++) {
    for (int j=0; j < typeChain.size(); j++) {
      JSType typeI=typeChain.get(i);
      JSType typeJ=typeChain.get(j);
      JSType namedTypeI=getNamedWrapper(""String_Node_Str"",typeI);
      JSType namedTypeJ=getNamedWrapper(""String_Node_Str"",typeJ);
      JSType proxyTypeI=new ProxyObjectType(registry,typeI);
      JSType proxyTypeJ=new ProxyObjectType(registry,typeJ);
      if (i == j) {
        assertTrue(typeI + ""String_Node_Str"",typeI.isEquivalentTo(typeI));
        assertTrue(""String_Node_Str"" + typeI + ""String_Node_Str"",namedTypeI.isEquivalentTo(namedTypeI));
        assertTrue(""String_Node_Str"" + typeI + ""String_Node_Str"",proxyTypeI.isEquivalentTo(proxyTypeI));
      }
 else {
        boolean shouldCheck=true;
        ObjectType objectI=typeI.toObjectType();
        ObjectType objectJ=typeJ.toObjectType();
        if (objectI != null && objectJ != null) {
          FunctionType constructorI=objectI.getConstructor();
          FunctionType constructorJ=objectJ.getConstructor();
          if (constructorI != null && constructorJ != null && constructorI.isStructuralInterface() && constructorJ.isStructuralInterface()) {
            if (constructorI.checkEquivalenceHelper(constructorJ,EquivalenceMethod.IDENTITY)) {
              shouldCheck=false;
            }
          }
        }
        if (shouldCheck) {
          assertFalse(typeI + ""String_Node_Str"" + typeJ,typeI.isEquivalentTo(typeJ));
          assertFalse(""String_Node_Str"" + typeI + ""String_Node_Str""+ typeJ,namedTypeI.isEquivalentTo(namedTypeJ));
          assertFalse(""String_Node_Str"" + typeI + ""String_Node_Str""+ typeJ,proxyTypeI.isEquivalentTo(proxyTypeJ));
        }
      }
      assertTrue(typeJ + ""String_Node_Str"" + typeI,typeJ.canCastTo(typeI));
      assertTrue(typeJ + ""String_Node_Str"" + namedTypeI,typeJ.canCastTo(namedTypeI));
      assertTrue(typeJ + ""String_Node_Str"" + proxyTypeI,typeJ.canCastTo(proxyTypeI));
      assertTrue(""String_Node_Str"" + typeJ + ""String_Node_Str""+ typeI,namedTypeJ.canCastTo(typeI));
      assertTrue(""String_Node_Str"" + typeJ + ""String_Node_Str""+ typeI,namedTypeJ.canCastTo(namedTypeI));
      assertTrue(""String_Node_Str"" + typeJ + ""String_Node_Str""+ typeI,namedTypeJ.canCastTo(proxyTypeI));
      assertTrue(""String_Node_Str"" + typeJ + ""String_Node_Str""+ typeI,proxyTypeJ.canCastTo(typeI));
      assertTrue(""String_Node_Str"" + typeJ + ""String_Node_Str""+ typeI,proxyTypeJ.canCastTo(namedTypeI));
      assertTrue(""String_Node_Str"" + typeJ + ""String_Node_Str""+ typeI,proxyTypeJ.canCastTo(proxyTypeI));
      if (typeI.isSubtypeOf(typeJ) && typeJ.isSubtypeOf(typeI)) {
        continue;
      }
      if (checkSubtyping) {
        if (i <= j) {
          assertTrue(typeJ + ""String_Node_Str"" + typeI,typeJ.isSubtypeOf(typeI));
          assertTrue(""String_Node_Str"" + typeJ + ""String_Node_Str""+ typeI,namedTypeJ.isSubtypeOf(namedTypeI));
          assertTrue(""String_Node_Str"" + typeJ + ""String_Node_Str""+ typeI,proxyTypeJ.isSubtypeOf(proxyTypeI));
        }
 else {
          assertFalse(typeJ + ""String_Node_Str"" + typeI,typeJ.isSubtypeOf(typeI));
          assertFalse(""String_Node_Str"" + typeJ + ""String_Node_Str""+ typeI,namedTypeJ.isSubtypeOf(namedTypeI));
          assertFalse(""String_Node_Str"" + typeJ + ""String_Node_Str""+ typeI,proxyTypeJ.isSubtypeOf(proxyTypeI));
        }
        JSType expectedSupremum=i < j ? typeI : typeJ;
        JSType expectedInfimum=i > j ? typeI : typeJ;
        assertTypeEquals(expectedSupremum + ""String_Node_Str"" + typeI+ ""String_Node_Str""+ typeJ,expectedSupremum,typeI.getLeastSupertype(typeJ));
        assertTypeEquals(expectedInfimum + ""String_Node_Str"" + typeI+ ""String_Node_Str""+ typeJ,expectedInfimum,typeI.getGreatestSubtype(typeJ));
      }
    }
  }
}","public void verifySubtypeChain(List<JSType> typeChain,boolean checkSubtyping) throws Exception {
  for (int i=0; i < typeChain.size(); i++) {
    for (int j=0; j < typeChain.size(); j++) {
      JSType typeI=typeChain.get(i);
      JSType typeJ=typeChain.get(j);
      JSType namedTypeI=getNamedWrapper(""String_Node_Str"",typeI);
      JSType namedTypeJ=getNamedWrapper(""String_Node_Str"",typeJ);
      JSType proxyTypeI=new ProxyObjectType(registry,typeI);
      JSType proxyTypeJ=new ProxyObjectType(registry,typeJ);
      if (i == j) {
        assertTrue(typeI + ""String_Node_Str"",typeI.isEquivalentTo(typeI));
        assertTrue(""String_Node_Str"" + typeI + ""String_Node_Str"",namedTypeI.isEquivalentTo(namedTypeI));
        assertTrue(""String_Node_Str"" + typeI + ""String_Node_Str"",proxyTypeI.isEquivalentTo(proxyTypeI));
      }
 else {
        boolean shouldCheck=true;
        ObjectType objectI=typeI.toObjectType();
        ObjectType objectJ=typeJ.toObjectType();
        if (objectI != null && objectJ != null) {
          FunctionType constructorI=objectI.getConstructor();
          FunctionType constructorJ=objectJ.getConstructor();
          if (constructorI != null && constructorJ != null && constructorI.isStructuralInterface() && constructorJ.isStructuralInterface()) {
            if (constructorI.isEquivalentTo(constructorJ)) {
              shouldCheck=false;
            }
          }
        }
        if (shouldCheck) {
          assertFalse(typeI + ""String_Node_Str"" + typeJ,typeI.isEquivalentTo(typeJ));
          assertFalse(""String_Node_Str"" + typeI + ""String_Node_Str""+ typeJ,namedTypeI.isEquivalentTo(namedTypeJ));
          assertFalse(""String_Node_Str"" + typeI + ""String_Node_Str""+ typeJ,proxyTypeI.isEquivalentTo(proxyTypeJ));
        }
      }
      assertTrue(typeJ + ""String_Node_Str"" + typeI,typeJ.canCastTo(typeI));
      assertTrue(typeJ + ""String_Node_Str"" + namedTypeI,typeJ.canCastTo(namedTypeI));
      assertTrue(typeJ + ""String_Node_Str"" + proxyTypeI,typeJ.canCastTo(proxyTypeI));
      assertTrue(""String_Node_Str"" + typeJ + ""String_Node_Str""+ typeI,namedTypeJ.canCastTo(typeI));
      assertTrue(""String_Node_Str"" + typeJ + ""String_Node_Str""+ typeI,namedTypeJ.canCastTo(namedTypeI));
      assertTrue(""String_Node_Str"" + typeJ + ""String_Node_Str""+ typeI,namedTypeJ.canCastTo(proxyTypeI));
      assertTrue(""String_Node_Str"" + typeJ + ""String_Node_Str""+ typeI,proxyTypeJ.canCastTo(typeI));
      assertTrue(""String_Node_Str"" + typeJ + ""String_Node_Str""+ typeI,proxyTypeJ.canCastTo(namedTypeI));
      assertTrue(""String_Node_Str"" + typeJ + ""String_Node_Str""+ typeI,proxyTypeJ.canCastTo(proxyTypeI));
      if (typeI.isSubtypeOf(typeJ) && typeJ.isSubtypeOf(typeI)) {
        continue;
      }
      if (checkSubtyping) {
        if (i <= j) {
          assertTrue(typeJ + ""String_Node_Str"" + typeI,typeJ.isSubtypeOf(typeI));
          assertTrue(""String_Node_Str"" + typeJ + ""String_Node_Str""+ typeI,namedTypeJ.isSubtypeOf(namedTypeI));
          assertTrue(""String_Node_Str"" + typeJ + ""String_Node_Str""+ typeI,proxyTypeJ.isSubtypeOf(proxyTypeI));
        }
 else {
          assertFalse(typeJ + ""String_Node_Str"" + typeI,typeJ.isSubtypeOf(typeI));
          assertFalse(""String_Node_Str"" + typeJ + ""String_Node_Str""+ typeI,namedTypeJ.isSubtypeOf(namedTypeI));
          assertFalse(""String_Node_Str"" + typeJ + ""String_Node_Str""+ typeI,proxyTypeJ.isSubtypeOf(proxyTypeI));
        }
        JSType expectedSupremum=i < j ? typeI : typeJ;
        JSType expectedInfimum=i > j ? typeI : typeJ;
        assertTypeEquals(expectedSupremum + ""String_Node_Str"" + typeI+ ""String_Node_Str""+ typeJ,expectedSupremum,typeI.getLeastSupertype(typeJ));
        assertTypeEquals(expectedInfimum + ""String_Node_Str"" + typeI+ ""String_Node_Str""+ typeJ,expectedInfimum,typeI.getGreatestSubtype(typeJ));
      }
    }
  }
}",0.9908090614886732
19205,"@Override @SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) List<FlowScope> branchedFlowThrough(Node source,FlowScope input){
  FlowScope output=flowThrough(source,input);
  Node condition=null;
  FlowScope conditionFlowScope=null;
  BooleanOutcomePair conditionOutcomes=null;
  List<DiGraphEdge<Node,Branch>> branchEdges=getCfg().getOutEdges(source);
  List<FlowScope> result=new ArrayList<>(branchEdges.size());
  for (  DiGraphEdge<Node,Branch> branchEdge : branchEdges) {
    Branch branch=branchEdge.getValue();
    FlowScope newScope=output;
switch (branch) {
case ON_TRUE:
      if (source.isForIn() || source.isForOf()) {
        Node item=source.getFirstChild();
        Node obj=item.getNext();
        FlowScope informed=traverse(obj,output.createChildFlowScope());
        if (item.isVar()) {
          item=item.getFirstChild();
        }
        if (source.isForIn()) {
          if (item.isName()) {
            JSType iterKeyType=getNativeType(STRING_TYPE);
            ObjectType objType=getJSType(obj).dereference();
            JSType objIndexType=objType == null ? null : objType.getTemplateTypeMap().getResolvedTemplateType(registry.getObjectIndexKey());
            if (objIndexType != null && !objIndexType.isUnknownType()) {
              JSType narrowedKeyType=iterKeyType.getGreatestSubtype(objIndexType);
              if (!narrowedKeyType.isEmptyType()) {
                iterKeyType=narrowedKeyType;
              }
            }
            redeclareSimpleVar(informed,item,iterKeyType);
          }
        }
 else {
          ObjectType objType=getJSType(obj).dereference();
          if (objType.isSubtypeOf(getNativeType(JSTypeNative.ITERABLE_TYPE))) {
            if (objType.isTemplatizedType()) {
              JSType newType=objType.getTemplateTypes().get(0);
              redeclareSimpleVar(informed,item,newType);
            }
          }
        }
        newScope=informed;
        break;
      }
case ON_FALSE:
    if (condition == null) {
      condition=NodeUtil.getConditionExpression(source);
      if (condition == null && source.isCase()) {
        condition=source;
        if (conditionFlowScope == null) {
          conditionFlowScope=traverse(condition.getFirstChild(),output.createChildFlowScope());
        }
      }
    }
  if (condition != null) {
    if (condition.isAnd() || condition.isOr()) {
      if (conditionOutcomes == null) {
        conditionOutcomes=condition.isAnd() ? traverseAnd(condition,output.createChildFlowScope()) : traverseOr(condition,output.createChildFlowScope());
      }
      newScope=reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition,conditionOutcomes.getOutcomeFlowScope(condition.getToken(),branch == Branch.ON_TRUE),branch == Branch.ON_TRUE);
    }
 else {
      if (conditionFlowScope == null) {
        conditionFlowScope=traverse(condition,output.createChildFlowScope());
      }
      newScope=reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition,conditionFlowScope,branch == Branch.ON_TRUE);
    }
  }
break;
default :
break;
}
result.add(newScope.optimize());
}
return result;
}","@Override @SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) List<FlowScope> branchedFlowThrough(Node source,FlowScope input){
  FlowScope output=flowThrough(source,input);
  Node condition=null;
  FlowScope conditionFlowScope=null;
  BooleanOutcomePair conditionOutcomes=null;
  List<DiGraphEdge<Node,Branch>> branchEdges=getCfg().getOutEdges(source);
  List<FlowScope> result=new ArrayList<>(branchEdges.size());
  for (  DiGraphEdge<Node,Branch> branchEdge : branchEdges) {
    Branch branch=branchEdge.getValue();
    FlowScope newScope=output;
switch (branch) {
case ON_TRUE:
      if (source.isForIn() || source.isForOf()) {
        Node item=source.getFirstChild();
        Node obj=item.getNext();
        FlowScope informed=traverse(obj,output.createChildFlowScope());
        if (item.isVar()) {
          item=item.getFirstChild();
        }
        if (source.isForIn()) {
          if (item.isName()) {
            JSType iterKeyType=getNativeType(STRING_TYPE);
            ObjectType objType=getJSType(obj).dereference();
            JSType objIndexType=objType == null ? null : objType.getTemplateTypeMap().getResolvedTemplateType(registry.getObjectIndexKey());
            if (objIndexType != null && !objIndexType.isUnknownType()) {
              JSType narrowedKeyType=iterKeyType.getGreatestSubtype(objIndexType);
              if (!narrowedKeyType.isEmptyType()) {
                iterKeyType=narrowedKeyType;
              }
            }
            redeclareSimpleVar(informed,item,iterKeyType);
          }
        }
 else {
          ObjectType objType=getJSType(obj).dereference();
          if (objType.isSubtypeOf(getNativeType(JSTypeNative.ITERABLE_TYPE))) {
            if (objType.isTemplatizedType()) {
              JSType newType=objType.getTemplateTypeMap().getResolvedTemplateType(registry.getIterableTemplate());
              redeclareSimpleVar(informed,item,newType);
            }
          }
        }
        newScope=informed;
        break;
      }
case ON_FALSE:
    if (condition == null) {
      condition=NodeUtil.getConditionExpression(source);
      if (condition == null && source.isCase()) {
        condition=source;
        if (conditionFlowScope == null) {
          conditionFlowScope=traverse(condition.getFirstChild(),output.createChildFlowScope());
        }
      }
    }
  if (condition != null) {
    if (condition.isAnd() || condition.isOr()) {
      if (conditionOutcomes == null) {
        conditionOutcomes=condition.isAnd() ? traverseAnd(condition,output.createChildFlowScope()) : traverseOr(condition,output.createChildFlowScope());
      }
      newScope=reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition,conditionOutcomes.getOutcomeFlowScope(condition.getToken(),branch == Branch.ON_TRUE),branch == Branch.ON_TRUE);
    }
 else {
      if (conditionFlowScope == null) {
        conditionFlowScope=traverse(condition,output.createChildFlowScope());
      }
      newScope=reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition,conditionFlowScope,branch == Branch.ON_TRUE);
    }
  }
break;
default :
break;
}
result.add(newScope.optimize());
}
return result;
}",0.9890214797136038
19206,"static boolean isPrototypeAssignment(Node getProp){
  if (!getProp.isGetProp()) {
    return false;
  }
  Node parent=getProp.getParent();
  return parent.isAssign() && parent.getFirstChild() == getProp && parent.getFirstChild().getLastChild().getString().equals(""String_Node_Str"");
}","static boolean isPrototypeAssignment(Node getProp){
  if (!getProp.isGetProp()) {
    return false;
  }
  Node parent=getProp.getParent();
  return parent.isAssign() && parent.getFirstChild() == getProp && getProp.getLastChild().getString().equals(""String_Node_Str"");
}",0.9258589511754068
19207,"/** 
 * Updates the scope according to the result of a type change, like an assignment or a type cast.
 */
private void updateScopeForTypeChange(FlowScope scope,Node left,JSType leftType,JSType resultType){
  checkNotNull(resultType);
  Node right=NodeUtil.getRValueOfLValue(left);
  if (isPossibleMixinApplication(left,right)) {
    addMissingInterfaceProperties(leftType);
  }
switch (left.getToken()) {
case NAME:
    String varName=left.getString();
  TypedVar var=syntacticScope.getVar(varName);
JSType varType=var == null ? null : var.getType();
boolean isVarDeclaration=left.hasChildren() && varType != null && !var.isTypeInferred();
boolean isTypelessConstDecl=isVarDeclaration && NodeUtil.isConstantDeclaration(compiler.getCodingConvention(),var.getJSDocInfo(),var.getNameNode()) && !(var.getJSDocInfo() != null && var.getJSDocInfo().hasType());
boolean isVarTypeBetter=isVarDeclaration && !resultType.isNullType() && !resultType.isVoidType()&& !isTypelessConstDecl;
if (isVarTypeBetter) {
redeclareSimpleVar(scope,left,varType);
}
 else {
redeclareSimpleVar(scope,left,resultType);
}
left.setJSType(resultType);
if (var != null && var.isTypeInferred()) {
JSType oldType=var.getType();
var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType));
}
 else if (isTypelessConstDecl) {
var.setType(resultType);
}
break;
case GETPROP:
if (left.isQualifiedName()) {
String qualifiedName=left.getQualifiedName();
boolean declaredSlotType=false;
JSType rawObjType=left.getFirstChild().getJSType();
if (rawObjType != null) {
ObjectType objType=ObjectType.cast(rawObjType.restrictByNotNullOrUndefined());
if (objType != null) {
String propName=left.getLastChild().getString();
declaredSlotType=objType.isPropertyTypeDeclared(propName);
}
}
JSType safeLeftType=leftType == null ? unknownType : leftType;
scope.inferQualifiedSlot(left,qualifiedName,safeLeftType,resultType,declaredSlotType);
}
left.setJSType(resultType);
ensurePropertyDefined(left,resultType);
break;
default :
break;
}
}","/** 
 * Updates the scope according to the result of a type change, like an assignment or a type cast.
 */
private void updateScopeForTypeChange(FlowScope scope,Node left,JSType leftType,JSType resultType){
  checkNotNull(resultType);
  Node right=NodeUtil.getRValueOfLValue(left);
  if (isPossibleMixinApplication(left,right)) {
    addMissingInterfaceProperties(leftType);
  }
  if (isLooseAssignmentToPrototype(left,leftType,resultType)) {
    return;
  }
switch (left.getToken()) {
case NAME:
    String varName=left.getString();
  TypedVar var=syntacticScope.getVar(varName);
JSType varType=var == null ? null : var.getType();
boolean isVarDeclaration=left.hasChildren() && varType != null && !var.isTypeInferred();
boolean isTypelessConstDecl=isVarDeclaration && NodeUtil.isConstantDeclaration(compiler.getCodingConvention(),var.getJSDocInfo(),var.getNameNode()) && !(var.getJSDocInfo() != null && var.getJSDocInfo().hasType());
boolean isVarTypeBetter=isVarDeclaration && !resultType.isNullType() && !resultType.isVoidType()&& !isTypelessConstDecl;
if (isVarTypeBetter) {
redeclareSimpleVar(scope,left,varType);
}
 else {
redeclareSimpleVar(scope,left,resultType);
}
left.setJSType(resultType);
if (var != null && var.isTypeInferred()) {
JSType oldType=var.getType();
var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType));
}
 else if (isTypelessConstDecl) {
var.setType(resultType);
}
break;
case GETPROP:
if (left.isQualifiedName()) {
String qualifiedName=left.getQualifiedName();
boolean declaredSlotType=false;
JSType rawObjType=left.getFirstChild().getJSType();
if (rawObjType != null) {
ObjectType objType=ObjectType.cast(rawObjType.restrictByNotNullOrUndefined());
if (objType != null) {
String propName=left.getLastChild().getString();
declaredSlotType=objType.isPropertyTypeDeclared(propName);
}
}
JSType safeLeftType=leftType == null ? unknownType : leftType;
scope.inferQualifiedSlot(left,qualifiedName,safeLeftType,resultType,declaredSlotType);
}
left.setJSType(resultType);
ensurePropertyDefined(left,resultType);
break;
default :
break;
}
}",0.98046875
19208,"public void testConstructorType9(){
  testTypes(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","public void testConstructorType9(){
  testTypes(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"");
}",0.9688581314878892
19209,"public void testDirectPrototypeAssign(){
  testTypes(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
}","public void testDirectPrototypeAssign(){
  testTypes(lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"" + ""String_Node_Str"");
}",0.8252788104089219
19210,"private void computeMayUse(Node n,Node cfgNode,ReachingUses output,boolean conditional){
switch (n.getToken()) {
case BLOCK:
case ROOT:
case FUNCTION:
    return;
case NAME:
  if (NodeUtil.isLhsByDestructuring(n)) {
    if (!conditional) {
      removeFromUseIfLocal(n.getString(),output);
    }
  }
 else {
    addToUseIfLocal(n.getString(),cfgNode,output);
  }
return;
case WHILE:
case DO:
case IF:
computeMayUse(NodeUtil.getConditionExpression(n),cfgNode,output,conditional);
return;
case FOR:
computeMayUse(NodeUtil.getConditionExpression(n),cfgNode,output,conditional);
return;
case FOR_IN:
case FOR_OF:
Node lhs=n.getFirstChild();
Node rhs=lhs.getNext();
if (NodeUtil.isNameDeclaration(lhs)) {
lhs=lhs.getLastChild();
if (lhs.isDestructuringLhs()) {
lhs=lhs.getFirstChild();
}
}
if (lhs.isName() && !conditional) {
removeFromUseIfLocal(lhs.getString(),output);
}
 else if (lhs.isDestructuringPattern()) {
computeMayUse(lhs,cfgNode,output,true);
}
computeMayUse(rhs,cfgNode,output,conditional);
return;
case AND:
case OR:
computeMayUse(n.getLastChild(),cfgNode,output,true);
computeMayUse(n.getFirstChild(),cfgNode,output,conditional);
return;
case HOOK:
computeMayUse(n.getLastChild(),cfgNode,output,true);
computeMayUse(n.getSecondChild(),cfgNode,output,true);
computeMayUse(n.getFirstChild(),cfgNode,output,conditional);
return;
case VAR:
case LET:
case CONST:
Node varName=n.getFirstChild();
checkState(n.hasChildren(),""String_Node_Str"",n);
if (varName.isDestructuringLhs()) {
computeMayUse(varName.getFirstChild(),cfgNode,output,conditional);
computeMayUse(varName.getSecondChild(),cfgNode,output,conditional);
}
 else if (varName.hasChildren()) {
computeMayUse(varName.getFirstChild(),cfgNode,output,conditional);
if (!conditional) {
removeFromUseIfLocal(varName.getString(),output);
}
}
return;
default :
if (NodeUtil.isAssignmentOp(n) && n.getFirstChild().isName()) {
Node name=n.getFirstChild();
if (!conditional) {
removeFromUseIfLocal(name.getString(),output);
}
if (!n.isAssign()) {
addToUseIfLocal(name.getString(),cfgNode,output);
}
computeMayUse(name.getNext(),cfgNode,output,conditional);
}
 else {
for (Node c=n.getLastChild(); c != null; c=c.getPrevious()) {
computeMayUse(c,cfgNode,output,conditional);
}
}
}
}","/** 
 * @param conditional Whether {@code n} is only conditionally evaluated given that {@code cfgNode}is evaluated. Do not remove conditionally redefined variables from the reaching uses set.
 */
private void computeMayUse(Node n,Node cfgNode,ReachingUses output,boolean conditional){
switch (n.getToken()) {
case BLOCK:
case ROOT:
case FUNCTION:
    return;
case NAME:
  if (NodeUtil.isLhsByDestructuring(n)) {
    if (!conditional) {
      removeFromUseIfLocal(n.getString(),output);
    }
  }
 else {
    addToUseIfLocal(n.getString(),cfgNode,output);
  }
return;
case WHILE:
case DO:
case IF:
computeMayUse(NodeUtil.getConditionExpression(n),cfgNode,output,conditional);
return;
case FOR:
computeMayUse(NodeUtil.getConditionExpression(n),cfgNode,output,conditional);
return;
case FOR_IN:
case FOR_OF:
Node lhs=n.getFirstChild();
Node rhs=lhs.getNext();
if (NodeUtil.isNameDeclaration(lhs)) {
lhs=lhs.getLastChild();
if (lhs.isDestructuringLhs()) {
lhs=lhs.getFirstChild();
}
}
if (lhs.isName() && !conditional) {
removeFromUseIfLocal(lhs.getString(),output);
}
 else if (lhs.isDestructuringPattern()) {
computeMayUse(lhs,cfgNode,output,true);
}
computeMayUse(rhs,cfgNode,output,conditional);
return;
case AND:
case OR:
computeMayUse(n.getLastChild(),cfgNode,output,true);
computeMayUse(n.getFirstChild(),cfgNode,output,conditional);
return;
case HOOK:
computeMayUse(n.getLastChild(),cfgNode,output,true);
computeMayUse(n.getSecondChild(),cfgNode,output,true);
computeMayUse(n.getFirstChild(),cfgNode,output,conditional);
return;
case VAR:
case LET:
case CONST:
Node varName=n.getFirstChild();
checkState(n.hasChildren(),""String_Node_Str"",n);
if (varName.isDestructuringLhs()) {
computeMayUse(varName.getFirstChild(),cfgNode,output,conditional);
computeMayUse(varName.getSecondChild(),cfgNode,output,conditional);
}
 else if (varName.hasChildren()) {
computeMayUse(varName.getFirstChild(),cfgNode,output,conditional);
if (!conditional) {
removeFromUseIfLocal(varName.getString(),output);
}
}
return;
case DEFAULT_VALUE:
if (n.getFirstChild().isDestructuringPattern()) {
computeMayUse(n.getFirstChild(),cfgNode,output,conditional);
computeMayUse(n.getSecondChild(),cfgNode,output,true);
}
 else if (n.getFirstChild().isName()) {
if (!conditional) {
removeFromUseIfLocal(n.getFirstChild().getString(),output);
}
computeMayUse(n.getSecondChild(),cfgNode,output,true);
}
 else {
computeMayUse(n.getSecondChild(),cfgNode,output,true);
computeMayUse(n.getFirstChild(),cfgNode,output,conditional);
}
break;
default :
if (NodeUtil.isAssignmentOp(n) && n.getFirstChild().isName()) {
Node name=n.getFirstChild();
if (!conditional) {
removeFromUseIfLocal(name.getString(),output);
}
if (!n.isAssign()) {
addToUseIfLocal(name.getString(),cfgNode,output);
}
computeMayUse(name.getNext(),cfgNode,output,conditional);
}
 else if (n.isAssign() && n.getFirstChild().isDestructuringPattern()) {
computeMayUse(n.getFirstChild(),cfgNode,output,conditional);
computeMayUse(n.getSecondChild(),cfgNode,output,conditional);
}
 else {
for (Node c=n.getLastChild(); c != null; c=c.getPrevious()) {
computeMayUse(c,cfgNode,output,conditional);
}
}
}
}",0.8332711674748229
19211,"public void testDestructuringEvaluationOrder(){
  noInline(""String_Node_Str"");
  noInline(""String_Node_Str"");
  noInline(""String_Node_Str"");
  noInline(""String_Node_Str"");
  noInline(""String_Node_Str"");
  noInline(""String_Node_Str"");
  inline(""String_Node_Str"",""String_Node_Str"");
}","public void testDestructuringEvaluationOrder(){
  noInline(""String_Node_Str"");
  noInline(""String_Node_Str"");
  noInline(""String_Node_Str"");
  noInline(""String_Node_Str"");
  noInline(""String_Node_Str"");
  noInline(""String_Node_Str"");
  noInline(""String_Node_Str"");
  noInline(""String_Node_Str"");
  inline(""String_Node_Str"",""String_Node_Str"");
}",0.9009584664536742
19212,"public void testDestructuringDefaultValue(){
  inline(""String_Node_Str"",""String_Node_Str"");
  inline(""String_Node_Str"",""String_Node_Str"");
  inline(""String_Node_Str"",""String_Node_Str"");
  noInline(""String_Node_Str"");
  noInline(""String_Node_Str"");
  noInline(""String_Node_Str"");
  inline(""String_Node_Str"",""String_Node_Str"");
  inline(""String_Node_Str"",""String_Node_Str"");
  inline(""String_Node_Str"",""String_Node_Str"");
}","public void testDestructuringDefaultValue(){
  inline(""String_Node_Str"",""String_Node_Str"");
  inline(""String_Node_Str"",""String_Node_Str"");
  inline(""String_Node_Str"",""String_Node_Str"");
  noInline(""String_Node_Str"");
  noInline(""String_Node_Str"");
  noInline(""String_Node_Str"");
  noInline(""String_Node_Str"");
  inline(""String_Node_Str"",""String_Node_Str"");
  noInline(""String_Node_Str"");
  noInline(""String_Node_Str"");
  noInline(""String_Node_Str"");
}",0.8004587155963303
19213,"public void testGithubIssue2818(){
  noInline(""String_Node_Str"");
  noInline(""String_Node_Str"");
  inline(""String_Node_Str"",""String_Node_Str"");
}","public void testGithubIssue2818(){
  noInline(""String_Node_Str"");
  noInline(""String_Node_Str"");
  noInline(""String_Node_Str"");
}",0.9197080291970804
19214,"public void testDestructuringComputedProperty(){
  inline(""String_Node_Str"",""String_Node_Str"");
  noInline(""String_Node_Str"");
}","public void testDestructuringComputedProperty(){
  inline(""String_Node_Str"",""String_Node_Str"");
  noInline(""String_Node_Str"");
  noInline(""String_Node_Str"");
  inline(""String_Node_Str"",""String_Node_Str"");
}",0.7664670658682635
19215,"/** 
 * @return The statement containing the expression or null if the subExpressionis not contain in a Node where inlining is known to be possible. For example, a WHILE node condition expression.
 */
@Nullable static Node findExpressionRoot(Node subExpression){
  Node child=subExpression;
  for (  Node parent : child.getAncestors()) {
    Token parentType=parent.getToken();
switch (parentType) {
case EXPR_RESULT:
case IF:
case SWITCH:
case RETURN:
case THROW:
      Preconditions.checkState(child == parent.getFirstChild());
    return parent;
case VAR:
case CONST:
case LET:
  Preconditions.checkState(child == parent.getFirstChild());
if (parent.getParent().isVanillaFor() && parent == parent.getParent().getFirstChild()) {
  return null;
}
 else {
  return parent;
}
case FOR:
if (child == parent.getFirstChild()) {
return parent;
}
case FOR_IN:
case FOR_OF:
case SCRIPT:
case BLOCK:
case LABEL:
case CASE:
case DEFAULT_CASE:
return null;
default :
break;
}
child=parent;
}
throw new IllegalStateException(""String_Node_Str"");
}","/** 
 * @return The statement containing the expression or null if the subExpressionis not contain in a Node where inlining is known to be possible. For example, a WHILE node condition expression.
 */
@Nullable static Node findExpressionRoot(Node subExpression){
  Node child=subExpression;
  for (  Node parent : child.getAncestors()) {
    Token parentType=parent.getToken();
switch (parentType) {
case EXPR_RESULT:
case IF:
case SWITCH:
case RETURN:
case THROW:
      Preconditions.checkState(child == parent.getFirstChild());
    return parent;
case VAR:
case CONST:
case LET:
  Preconditions.checkState(child == parent.getFirstChild());
if (parent.getParent().isVanillaFor() && parent == parent.getParent().getFirstChild()) {
  return parent.getParent();
}
 else {
  return parent;
}
case FOR:
if (child == parent.getFirstChild()) {
return parent;
}
case FOR_IN:
case FOR_OF:
case SCRIPT:
case BLOCK:
case LABEL:
case CASE:
case DEFAULT_CASE:
return null;
default :
break;
}
child=parent;
}
throw new IllegalStateException(""String_Node_Str"");
}",0.989443378119002
19216,"/** 
 * Determine which, if any, of the supported types the call site is. Constant vars are treated differently so that we don't break their const-ness when we decompose the expression. Once the CONSTANT_VAR annotation is used everywhere instead of coding conventions, we should just teach this pass how to remove the annotation.
 */
private CallSiteType classifyCallSite(Reference ref){
  Node callNode=ref.callNode;
  Node parent=callNode.getParent();
  Node grandParent=parent.getParent();
  if (NodeUtil.isExprCall(parent)) {
    return CallSiteType.SIMPLE_CALL;
  }
 else   if (NodeUtil.isExprAssign(grandParent) && !NodeUtil.isNameDeclOrSimpleAssignLhs(callNode,parent) && parent.getFirstChild().isName()&& !NodeUtil.isConstantName(parent.getFirstChild())) {
    return CallSiteType.SIMPLE_ASSIGNMENT;
  }
 else   if (parent.isName() && !NodeUtil.isConstantName(parent) && (grandParent.isVar() || grandParent.isLet())&& grandParent.hasOneChild()) {
    return CallSiteType.VAR_DECL_SIMPLE_ASSIGNMENT;
  }
 else {
    Node expressionRoot=ExpressionDecomposer.findExpressionRoot(callNode);
    if (expressionRoot != null) {
      ExpressionDecomposer decomposer=getDecomposer(ref.scope);
      DecompositionType type=decomposer.canExposeExpression(callNode);
      if (type == DecompositionType.MOVABLE) {
        return CallSiteType.EXPRESSION;
      }
 else       if (type == DecompositionType.DECOMPOSABLE) {
        return CallSiteType.DECOMPOSABLE_EXPRESSION;
      }
 else {
        checkState(type == DecompositionType.UNDECOMPOSABLE);
      }
    }
  }
  return CallSiteType.UNSUPPORTED;
}","/** 
 * Determine which, if any, of the supported types the call site is. Constant vars are treated differently so that we don't break their const-ness when we decompose the expression. Once the CONSTANT_VAR annotation is used everywhere instead of coding conventions, we should just teach this pass how to remove the annotation.
 */
private CallSiteType classifyCallSite(Reference ref){
  Node callNode=ref.callNode;
  Node parent=callNode.getParent();
  Node grandParent=parent.getParent();
  if (NodeUtil.isExprCall(parent)) {
    return CallSiteType.SIMPLE_CALL;
  }
 else   if (NodeUtil.isExprAssign(grandParent) && !NodeUtil.isNameDeclOrSimpleAssignLhs(callNode,parent) && parent.getFirstChild().isName()&& !NodeUtil.isConstantName(parent.getFirstChild())) {
    return CallSiteType.SIMPLE_ASSIGNMENT;
  }
 else   if (parent.isName() && !NodeUtil.isConstantName(parent) && grandParent.isVar()&& grandParent.hasOneChild()) {
    return CallSiteType.VAR_DECL_SIMPLE_ASSIGNMENT;
  }
 else {
    Node expressionRoot=ExpressionDecomposer.findExpressionRoot(callNode);
    if (expressionRoot != null) {
      ExpressionDecomposer decomposer=getDecomposer(ref.scope);
      DecompositionType type=decomposer.canExposeExpression(callNode);
      if (type == DecompositionType.MOVABLE) {
        return CallSiteType.EXPRESSION;
      }
 else       if (type == DecompositionType.DECOMPOSABLE) {
        return CallSiteType.DECOMPOSABLE_EXPRESSION;
      }
 else {
        checkState(type == DecompositionType.UNDECOMPOSABLE);
      }
    }
  }
  return CallSiteType.UNSUPPORTED;
}",0.9921309411394396
19217,"public void testFindExpressionRoot5(){
  assertThat(findExpressionRoot(""String_Node_Str"",""String_Node_Str"")).isNull();
}","public void testFindExpressionRoot5(){
  assertNode(findExpressionRoot(""String_Node_Str"",""String_Node_Str"")).hasType(Token.FOR);
}",0.888
19218,"/** 
 * @return The result of calling {@link ExpressionDecomposer#findExpressionRoot} on the CALLnode in  {@code js} whose callee is a NAME matching {@code name}.
 */
@Nullable private Node findExpressionRoot(String js,String name){
  Compiler compiler=getCompiler();
  Node tree=parse(compiler,js);
  Node call=findCall(tree,name);
  checkNotNull(call);
  return ExpressionDecomposer.findExpressionRoot(call);
}","/** 
 * @return The result of calling {@link ExpressionDecomposer#findExpressionRoot} on the CALLnode in  {@code js} whose callee is a NAME matching {@code name}.
 */
@Nullable private Node findExpressionRoot(String js,String name){
  Compiler compiler=getCompiler();
  Node tree=parse(compiler,js);
  Node call=findCall(tree,name);
  checkNotNull(call);
  Node root=ExpressionDecomposer.findExpressionRoot(call);
  if (root != null) {
    checkState(NodeUtil.isStatement(root),root);
  }
  return root;
}",0.8833151581243184
19219,"public void testShadowVariables19(){
  test(lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testShadowVariables19(){
  test(lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.9703947368421052
19220,"private boolean canInline(final Scope scope){
  if (getDefCfgNode().isFunction()) {
    return false;
  }
  getDefinition(getDefCfgNode());
  getNumUseInUseCfgNode(useCfgNode);
  if (def == null) {
    return false;
  }
  if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {
    return false;
  }
  if (checkRightOf(def,getDefCfgNode(),SIDE_EFFECT_PREDICATE)) {
    return false;
  }
  if (checkLeftOf(use,useCfgNode,SIDE_EFFECT_PREDICATE)) {
    return false;
  }
  if (NodeUtil.mayHaveSideEffects(def.getLastChild(),compiler)) {
    return false;
  }
  if (numUsesWithinCfgNode != 1) {
    return false;
  }
  if (NodeUtil.isWithinLoop(use)) {
    return false;
  }
  Collection<Node> uses=reachingUses.getUses(varName,getDefCfgNode());
  if (uses.size() != 1) {
    return false;
  }
  if (NodeUtil.has(def.getLastChild(),new Predicate<Node>(){
    @Override public boolean apply(    Node input){
switch (input.getToken()) {
case GETELEM:
case GETPROP:
case ARRAYLIT:
case OBJECTLIT:
case REGEXP:
case NEW:
        return true;
case NAME:
      Var var=scope.getOwnSlot(input.getString());
    if (var != null && var.getParentNode().isCatch()) {
      return true;
    }
default :
  break;
}
return false;
}
}
,new Predicate<Node>(){
@Override public boolean apply(Node input){
return !input.isFunction();
}
}
)) {
return false;
}
if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {
CheckPathsBetweenNodes<Node,ControlFlowGraph.Branch> pathCheck=new CheckPathsBetweenNodes<>(cfg,cfg.getDirectedGraphNode(getDefCfgNode()),cfg.getDirectedGraphNode(useCfgNode),SIDE_EFFECT_PREDICATE,Predicates.<DiGraphEdge<Node,ControlFlowGraph.Branch>>alwaysTrue(),false);
if (pathCheck.somePathsSatisfyPredicate()) {
return false;
}
}
return true;
}","private boolean canInline(final Scope scope){
  if (getDefCfgNode().isFunction()) {
    return false;
  }
  getDefinition(getDefCfgNode());
  getNumUseInUseCfgNode(useCfgNode);
  if (def == null) {
    return false;
  }
  if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {
    return false;
  }
  if (checkPostExpressions(def,getDefCfgNode(),SIDE_EFFECT_PREDICATE)) {
    return false;
  }
  if (checkPreExpressions(use,useCfgNode,SIDE_EFFECT_PREDICATE)) {
    return false;
  }
  if (NodeUtil.mayHaveSideEffects(def.getLastChild(),compiler)) {
    return false;
  }
  if (numUsesWithinCfgNode != 1) {
    return false;
  }
  if (NodeUtil.isWithinLoop(use)) {
    return false;
  }
  Collection<Node> uses=reachingUses.getUses(varName,getDefCfgNode());
  if (uses.size() != 1) {
    return false;
  }
  if (NodeUtil.has(def.getLastChild(),new Predicate<Node>(){
    @Override public boolean apply(    Node input){
switch (input.getToken()) {
case GETELEM:
case GETPROP:
case ARRAYLIT:
case OBJECTLIT:
case REGEXP:
case NEW:
        return true;
case NAME:
      Var var=scope.getOwnSlot(input.getString());
    if (var != null && var.getParentNode().isCatch()) {
      return true;
    }
default :
  break;
}
return false;
}
}
,new Predicate<Node>(){
@Override public boolean apply(Node input){
return !input.isFunction();
}
}
)) {
return false;
}
if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {
CheckPathsBetweenNodes<Node,ControlFlowGraph.Branch> pathCheck=new CheckPathsBetweenNodes<>(cfg,cfg.getDirectedGraphNode(getDefCfgNode()),cfg.getDirectedGraphNode(useCfgNode),SIDE_EFFECT_PREDICATE,Predicates.<DiGraphEdge<Node,ControlFlowGraph.Branch>>alwaysTrue(),false);
if (pathCheck.somePathsSatisfyPredicate()) {
return false;
}
}
return true;
}",0.9883849557522124
19221,"private void computeMayUse(Node n,Node cfgNode,ReachingUses output,boolean conditional){
switch (n.getToken()) {
case BLOCK:
case ROOT:
case FUNCTION:
    return;
case NAME:
  addToUseIfLocal(n.getString(),cfgNode,output);
return;
case WHILE:
case DO:
case IF:
computeMayUse(NodeUtil.getConditionExpression(n),cfgNode,output,conditional);
return;
case FOR:
computeMayUse(NodeUtil.getConditionExpression(n),cfgNode,output,conditional);
return;
case FOR_IN:
Node lhs=n.getFirstChild();
Node rhs=lhs.getNext();
if (lhs.isVar()) {
lhs=lhs.getLastChild();
}
if (lhs.isName() && !conditional) {
removeFromUseIfLocal(lhs.getString(),output);
}
computeMayUse(rhs,cfgNode,output,conditional);
return;
case AND:
case OR:
computeMayUse(n.getLastChild(),cfgNode,output,true);
computeMayUse(n.getFirstChild(),cfgNode,output,conditional);
return;
case HOOK:
computeMayUse(n.getLastChild(),cfgNode,output,true);
computeMayUse(n.getSecondChild(),cfgNode,output,true);
computeMayUse(n.getFirstChild(),cfgNode,output,conditional);
return;
case VAR:
Node varName=n.getFirstChild();
Preconditions.checkState(n.hasChildren(),""String_Node_Str"",n);
if (varName.hasChildren()) {
computeMayUse(varName.getFirstChild(),cfgNode,output,conditional);
if (!conditional) {
removeFromUseIfLocal(varName.getString(),output);
}
}
return;
default :
if (NodeUtil.isAssignmentOp(n) && n.getFirstChild().isName()) {
Node name=n.getFirstChild();
if (!conditional) {
removeFromUseIfLocal(name.getString(),output);
}
if (!n.isAssign()) {
addToUseIfLocal(name.getString(),cfgNode,output);
}
computeMayUse(name.getNext(),cfgNode,output,conditional);
}
 else {
for (Node c=n.getLastChild(); c != null; c=c.getPrevious()) {
computeMayUse(c,cfgNode,output,conditional);
}
}
}
}","private void computeMayUse(Node n,Node cfgNode,ReachingUses output,boolean conditional){
switch (n.getToken()) {
case BLOCK:
case ROOT:
case FUNCTION:
    return;
case NAME:
  if (NodeUtil.isLhsByDestructuring(n)) {
    if (!conditional) {
      removeFromUseIfLocal(n.getString(),output);
    }
  }
 else {
    addToUseIfLocal(n.getString(),cfgNode,output);
  }
return;
case WHILE:
case DO:
case IF:
computeMayUse(NodeUtil.getConditionExpression(n),cfgNode,output,conditional);
return;
case FOR:
computeMayUse(NodeUtil.getConditionExpression(n),cfgNode,output,conditional);
return;
case FOR_IN:
Node lhs=n.getFirstChild();
Node rhs=lhs.getNext();
if (lhs.isVar()) {
lhs=lhs.getLastChild();
}
if (lhs.isName() && !conditional) {
removeFromUseIfLocal(lhs.getString(),output);
}
computeMayUse(rhs,cfgNode,output,conditional);
return;
case AND:
case OR:
computeMayUse(n.getLastChild(),cfgNode,output,true);
computeMayUse(n.getFirstChild(),cfgNode,output,conditional);
return;
case HOOK:
computeMayUse(n.getLastChild(),cfgNode,output,true);
computeMayUse(n.getSecondChild(),cfgNode,output,true);
computeMayUse(n.getFirstChild(),cfgNode,output,conditional);
return;
case VAR:
Node varName=n.getFirstChild();
checkState(n.hasChildren(),""String_Node_Str"",n);
if (varName.isDestructuringLhs()) {
computeMayUse(varName.getFirstChild(),cfgNode,output,conditional);
computeMayUse(varName.getSecondChild(),cfgNode,output,conditional);
}
 else if (varName.hasChildren()) {
computeMayUse(varName.getFirstChild(),cfgNode,output,conditional);
if (!conditional) {
removeFromUseIfLocal(varName.getString(),output);
}
}
return;
default :
if (NodeUtil.isAssignmentOp(n) && n.getFirstChild().isName()) {
Node name=n.getFirstChild();
if (!conditional) {
removeFromUseIfLocal(name.getString(),output);
}
if (!n.isAssign()) {
addToUseIfLocal(name.getString(),cfgNode,output);
}
computeMayUse(name.getNext(),cfgNode,output,conditional);
}
 else {
for (Node c=n.getLastChild(); c != null; c=c.getPrevious()) {
computeMayUse(c,cfgNode,output,conditional);
}
}
}
}",0.9116007432970532
19222,"/** 
 * Resolve any stub declarations to unknown types if we could not find types for them during traversal.
 */
void resolveStubDeclarations(){
  for (  StubDeclaration stub : stubDeclarations) {
    Node n=stub.node;
    Node parent=n.getParent();
    String qName=n.getQualifiedName();
    String propName=n.getLastChild().getString();
    String ownerName=stub.ownerName;
    boolean isExtern=stub.isExtern;
    if (scope.isDeclared(qName,false)) {
      continue;
    }
    ObjectType ownerType=getObjectSlot(ownerName);
    defineSlot(n,parent,unknownType,true);
    if (ownerType != null && (isExtern || ownerType.isFunctionPrototypeType())) {
      ownerType.defineInferredProperty(propName,unknownType,n);
    }
 else {
      typeRegistry.registerPropertyOnType(propName,ownerType == null ? unknownType : ownerType);
    }
  }
}","/** 
 * Resolve any stub declarations to unknown types if we could not find types for them during traversal.
 */
void resolveStubDeclarations(){
  for (  StubDeclaration stub : stubDeclarations) {
    Node n=stub.node;
    Node parent=n.getParent();
    String qName=n.getQualifiedName();
    String propName=n.getLastChild().getString();
    String ownerName=stub.ownerName;
    boolean isExtern=stub.isExtern;
    if (scope.isDeclared(qName,false)) {
      continue;
    }
    ObjectType ownerType=getObjectSlot(ownerName);
    JSType inheritedType=getInheritedInterfacePropertyType(ownerType,propName);
    JSType stubType=inheritedType == null ? unknownType : inheritedType;
    defineSlot(n,parent,stubType,true);
    if (ownerType != null && (isExtern || ownerType.isFunctionPrototypeType())) {
      ownerType.defineInferredProperty(propName,stubType,n);
    }
 else {
      typeRegistry.registerPropertyOnType(propName,ownerType == null ? stubType : ownerType);
    }
  }
}",0.8800880088008801
19223,"private ObjectType getThisTypeForCollectingProperties(){
  Node rootNode=scope.getRootNode();
  if (rootNode.isFromExterns())   return null;
  JSType type=rootNode.getJSType();
  if (type == null || !type.isFunctionType())   return null;
  FunctionType fnType=type.toMaybeFunctionType();
  JSType fnThisType=fnType.getTypeOfThis();
  return fnThisType.isUnknownType() ? null : fnThisType.toObjectType();
}","private ObjectType getThisTypeForCollectingProperties(){
  Node rootNode=scope.getRootNode();
  if (rootNode.isFromExterns()) {
    return null;
  }
  JSType type=rootNode.getJSType();
  if (type == null || !type.isFunctionType()) {
    return null;
  }
  FunctionType fnType=type.toMaybeFunctionType();
  JSType fnThisType=fnType.getTypeOfThis();
  return fnThisType.isUnknownType() ? null : fnThisType.toObjectType();
}",0.9128329297820824
19224,"private ParseTree parseMultiplicativeExpression(){
  SourcePosition start=getTreeStartLocation();
  ParseTree left=parseExponentiationExpression();
  while (peekMultiplicativeOperator()) {
    Token operator=nextToken();
    ParseTree right=parseUnaryExpression();
    left=new BinaryOperatorTree(getTreeLocation(start),left,operator,right);
  }
  return left;
}","private ParseTree parseMultiplicativeExpression(){
  SourcePosition start=getTreeStartLocation();
  ParseTree left=parseExponentiationExpression();
  while (peekMultiplicativeOperator()) {
    Token operator=nextToken();
    ParseTree right=parseExponentiationExpression();
    left=new BinaryOperatorTree(getTreeLocation(start),left,operator,right);
  }
  return left;
}",0.9740791268758526
19225,"public void testExponentiationOperator(){
  languageMode=LanguageMode.ECMASCRIPT_2016;
  assertPrintSame(""String_Node_Str"");
  assertPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrintSame(""String_Node_Str"");
  assertPrintSame(""String_Node_Str"");
  assertPrintSame(""String_Node_Str"");
  assertPrint(""String_Node_Str"",""String_Node_Str"");
}","public void testExponentiationOperator(){
  languageMode=LanguageMode.ECMASCRIPT_2016;
  assertPrintSame(""String_Node_Str"");
  assertPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrintSame(""String_Node_Str"");
  assertPrintSame(""String_Node_Str"");
  assertPrintSame(""String_Node_Str"");
  assertPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrint(""String_Node_Str"",""String_Node_Str"");
  assertPrintSame(""String_Node_Str"");
}",0.884318766066838
19226,"public void testExponentOperator(){
  mode=LanguageMode.ECMASCRIPT7;
  strictMode=STRICT;
  parseError(""String_Node_Str"",""String_Node_Str"");
  expectFeatures(Feature.EXPONENT_OP);
  parse(""String_Node_Str"");
  parse(""String_Node_Str"");
  parse(""String_Node_Str"");
  parse(""String_Node_Str"");
  mode=LanguageMode.ECMASCRIPT6;
  strictMode=SLOPPY;
  parseWarning(""String_Node_Str"",requiresLanguageModeMessage(LanguageMode.ECMASCRIPT7,Feature.EXPONENT_OP));
}","public void testExponentOperator(){
  mode=LanguageMode.ECMASCRIPT7;
  strictMode=STRICT;
  parseError(""String_Node_Str"",""String_Node_Str"");
  expectFeatures(Feature.EXPONENT_OP);
  parse(""String_Node_Str"");
  parse(""String_Node_Str"");
  parse(""String_Node_Str"");
  parse(""String_Node_Str"");
  parse(""String_Node_Str"");
  mode=LanguageMode.ECMASCRIPT6;
  strictMode=SLOPPY;
  parseWarning(""String_Node_Str"",requiresLanguageModeMessage(LanguageMode.ECMASCRIPT7,Feature.EXPONENT_OP));
}",0.9702127659574468
19227,"/** 
 * Called for the usual style of prototype-property definitions, but also for @lends and for direct assignments of object literals to prototypes.
 */
private void mayAddPropToPrototype(RawNominalType rawType,String pname,Node defSite,Node initializer){
  NTIScope methodScope=null;
  DeclaredFunctionType methodType=null;
  JSType propDeclType=null;
  JSDocInfo jsdoc=NodeUtil.getBestJSDocInfo(defSite);
  if (initializer != null && initializer.isFunction()) {
    methodScope=visitFunctionLate(initializer,rawType);
    methodType=methodScope.getDeclaredFunctionType();
    if (defSite.isGetterDef()) {
      pname=getCommonTypes().createGetterPropName(pname);
    }
 else     if (defSite.isSetterDef()) {
      pname=getCommonTypes().createSetterPropName(pname);
    }
  }
 else   if (jsdoc != null && jsdoc.containsFunctionDeclaration() && !defSite.isStringKey()) {
    methodType=computeFnDeclaredType(jsdoc,pname,defSite,rawType,currentScope);
  }
  if (jsdoc != null && jsdoc.hasType()) {
    propDeclType=getTypeParser().getDeclaredTypeOfNode(jsdoc,rawType,currentScope);
  }
 else   if (methodType != null) {
    propDeclType=getCommonTypes().fromFunctionType(methodType.toFunctionType());
  }
  if (defSite.isGetterDef()) {
    FunctionType ft=propDeclType.getFunTypeIfSingletonObj();
    if (ft != null) {
      propDeclType=ft.getReturnType();
    }
  }
  PropertyDef def=new PropertyDef(defSite,methodType,methodScope);
  propertyDefs.put(rawType,pname,def);
  if (methodType != null && methodType.isAbstract() && !rawType.isAbstractClass()) {
    if (rawType.isClass()) {
      warnings.add(JSError.make(defSite,ABSTRACT_METHOD_IN_CONCRETE_CLASS,rawType.getName()));
    }
 else     if (rawType.isInterface()) {
      warnings.add(JSError.make(defSite,ABSTRACT_METHOD_IN_INTERFACE));
    }
  }
  boolean isConst=isConst(defSite);
  if (propDeclType != null || isConst) {
    if (mayWarnAboutExistingProp(rawType,pname,defSite,propDeclType)) {
      return;
    }
    if (propDeclType == null) {
      propDeclType=mayInferFromRhsIfConst(defSite);
    }
    rawType.addProtoProperty(pname,defSite,propDeclType,isConst);
    if (defSite.isGetProp()) {
      defSite.putBooleanProp(Node.ANALYZED_DURING_GTI,true);
      if (isConst) {
        defSite.putBooleanProp(Node.CONSTANT_PROPERTY_DEF,true);
      }
    }
  }
 else {
    JSType inferredType=null;
    if (initializer != null) {
      inferredType=simpleInferExpr(initializer,this.currentScope);
    }
    if (inferredType == null) {
      inferredType=getCommonTypes().UNKNOWN;
    }
    rawType.addUndeclaredProtoProperty(pname,defSite,inferredType);
  }
}","/** 
 * Called for the usual style of prototype-property definitions, but also for @lends and for direct assignments of object literals to prototypes.
 */
private void mayAddPropToPrototype(RawNominalType rawType,String pname,Node defSite,Node initializer){
  NTIScope methodScope=null;
  DeclaredFunctionType methodType=null;
  JSType propDeclType=null;
  JSDocInfo jsdoc=NodeUtil.getBestJSDocInfo(defSite);
  if (initializer != null && initializer.isFunction()) {
    methodScope=visitFunctionLate(initializer,rawType);
    methodType=methodScope.getDeclaredFunctionType();
    if (defSite.isGetterDef()) {
      pname=getCommonTypes().createGetterPropName(pname);
    }
 else     if (defSite.isSetterDef()) {
      pname=getCommonTypes().createSetterPropName(pname);
    }
  }
 else   if (jsdoc != null && jsdoc.containsFunctionDeclaration() && !defSite.isStringKey()) {
    methodType=computeFnDeclaredType(jsdoc,pname,defSite,rawType,currentScope);
  }
  if (jsdoc != null && jsdoc.hasType()) {
    propDeclType=getTypeParser().getDeclaredTypeOfNode(jsdoc,rawType,currentScope);
    if ((defSite.isGetterDef() || defSite.isSetterDef()) && propDeclType != null && !propDeclType.isFunctionType()) {
      propDeclType=null;
    }
  }
 else   if (methodType != null) {
    propDeclType=getCommonTypes().fromFunctionType(methodType.toFunctionType());
  }
  if (defSite.isGetterDef() && propDeclType != null) {
    FunctionType ft=propDeclType.getFunTypeIfSingletonObj();
    if (ft != null) {
      propDeclType=ft.getReturnType();
    }
  }
  PropertyDef def=new PropertyDef(defSite,methodType,methodScope);
  propertyDefs.put(rawType,pname,def);
  if (methodType != null && methodType.isAbstract() && !rawType.isAbstractClass()) {
    if (rawType.isClass()) {
      warnings.add(JSError.make(defSite,ABSTRACT_METHOD_IN_CONCRETE_CLASS,rawType.getName()));
    }
 else     if (rawType.isInterface()) {
      warnings.add(JSError.make(defSite,ABSTRACT_METHOD_IN_INTERFACE));
    }
  }
  boolean isConst=isConst(defSite);
  if (propDeclType != null || isConst) {
    if (mayWarnAboutExistingProp(rawType,pname,defSite,propDeclType)) {
      return;
    }
    if (propDeclType == null) {
      propDeclType=mayInferFromRhsIfConst(defSite);
    }
    rawType.addProtoProperty(pname,defSite,propDeclType,isConst);
    if (defSite.isGetProp()) {
      defSite.putBooleanProp(Node.ANALYZED_DURING_GTI,true);
      if (isConst) {
        defSite.putBooleanProp(Node.CONSTANT_PROPERTY_DEF,true);
      }
    }
  }
 else {
    JSType inferredType=null;
    if (initializer != null) {
      inferredType=simpleInferExpr(initializer,this.currentScope);
    }
    if (inferredType == null) {
      inferredType=getCommonTypes().UNKNOWN;
    }
    rawType.addUndeclaredProtoProperty(pname,defSite,inferredType);
  }
}",0.9681692732290708
19228,"public void testSetters(){
  typeCheck(""String_Node_Str"",GlobalTypeInfoCollector.SETTER_WITH_RETURN);
  typeCheck(""String_Node_Str"",GlobalTypeInfoCollector.SETTER_WITH_RETURN);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),JSTypeCreatorFromJSDoc.TEMPLATED_GETTER_SETTER);
  typeCheck(""String_Node_Str"",NewTypeInference.RETURN_NONDECLARED_TYPE);
  typeCheck(""String_Node_Str"",JSTypeCreatorFromJSDoc.FUNCTION_WITH_NONFUNC_JSDOC);
  typeCheck(""String_Node_Str"",NewTypeInference.ILLEGAL_OBJLIT_KEY);
  typeCheck(""String_Node_Str"",NewTypeInference.ILLEGAL_OBJLIT_KEY);
  typeCheck(""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"",NewTypeInference.INEXISTENT_PROPERTY);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
}","public void testSetters(){
  typeCheck(""String_Node_Str"",GlobalTypeInfoCollector.SETTER_WITH_RETURN);
  typeCheck(""String_Node_Str"",GlobalTypeInfoCollector.SETTER_WITH_RETURN);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),JSTypeCreatorFromJSDoc.TEMPLATED_GETTER_SETTER);
  typeCheck(""String_Node_Str"",NewTypeInference.RETURN_NONDECLARED_TYPE);
  typeCheck(""String_Node_Str"",JSTypeCreatorFromJSDoc.FUNCTION_WITH_NONFUNC_JSDOC);
  typeCheck(""String_Node_Str"",NewTypeInference.ILLEGAL_OBJLIT_KEY);
  typeCheck(""String_Node_Str"",NewTypeInference.ILLEGAL_OBJLIT_KEY);
  typeCheck(""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"",NewTypeInference.INEXISTENT_PROPERTY);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),JSTypeCreatorFromJSDoc.FUNCTION_WITH_NONFUNC_JSDOC);
}",0.895676318921063
19229,"/** 
 * Computes the GEN and KILL set.
 * @param n Root node.
 * @param gen Local variables that are live because of the instruction at {@code n} will be addedto this set.
 * @param kill Local variables that are killed because of the instruction at {@code n} will beadded to this set.
 * @param conditional {@code true} if any assignments encountered are conditionally executed.These assignments might not kill a variable.
 */
private void computeGenKill(Node n,BitSet gen,BitSet kill,boolean conditional){
switch (n.getToken()) {
case SCRIPT:
case ROOT:
case FUNCTION:
case BLOCK:
    return;
case WHILE:
case DO:
case IF:
case FOR:
  computeGenKill(NodeUtil.getConditionExpression(n),gen,kill,conditional);
return;
case FOR_OF:
case FOR_IN:
{
Node lhs=n.getFirstChild();
if (NodeUtil.isNameDeclaration(lhs)) {
  lhs=lhs.getLastChild();
}
if (lhs.isName()) {
  addToSetIfLocal(lhs,kill);
  addToSetIfLocal(lhs,gen);
}
 else {
  computeGenKill(lhs,gen,kill,conditional);
}
return;
}
case LET:
case CONST:
case VAR:
for (Node c=n.getFirstChild(); c != null; c=c.getNext()) {
if (c.isName()) {
if (c.hasChildren()) {
  computeGenKill(c.getFirstChild(),gen,kill,conditional);
  if (!conditional) {
    addToSetIfLocal(c,kill);
  }
}
}
 else {
computeGenKill(c,gen,kill,conditional);
}
}
return;
case DESTRUCTURING_LHS:
if (n.hasTwoChildren()) {
computeGenKill(n.getSecondChild(),gen,kill,conditional);
if (!conditional) {
Iterable<Node> allVars=NodeUtil.findLhsNodesInNode(n);
for (Node child : allVars) {
addToSetIfLocal(child,kill);
}
}
}
return;
case AND:
case OR:
computeGenKill(n.getFirstChild(),gen,kill,conditional);
computeGenKill(n.getLastChild(),gen,kill,true);
return;
case HOOK:
computeGenKill(n.getFirstChild(),gen,kill,conditional);
computeGenKill(n.getSecondChild(),gen,kill,true);
computeGenKill(n.getLastChild(),gen,kill,true);
return;
case NAME:
if (isArgumentsName(n)) {
markAllParametersEscaped();
}
 else {
addToSetIfLocal(n,gen);
}
return;
default :
if (NodeUtil.isAssignmentOp(n) && n.getFirstChild().isName()) {
Node lhs=n.getFirstChild();
if (!conditional) {
addToSetIfLocal(lhs,kill);
}
if (!n.isAssign()) {
addToSetIfLocal(lhs,gen);
}
computeGenKill(lhs.getNext(),gen,kill,conditional);
}
 else {
for (Node c=n.getFirstChild(); c != null; c=c.getNext()) {
computeGenKill(c,gen,kill,conditional);
}
}
return;
}
}","/** 
 * Computes the GEN and KILL set.
 * @param n Root node.
 * @param gen Local variables that are live because of the instruction at {@code n} will be addedto this set.
 * @param kill Local variables that are killed because of the instruction at {@code n} will beadded to this set.
 * @param conditional {@code true} if any assignments encountered are conditionally executed.These assignments might not kill a variable.
 */
private void computeGenKill(Node n,BitSet gen,BitSet kill,boolean conditional){
switch (n.getToken()) {
case SCRIPT:
case ROOT:
case FUNCTION:
case BLOCK:
    return;
case WHILE:
case DO:
case IF:
case FOR:
  computeGenKill(NodeUtil.getConditionExpression(n),gen,kill,conditional);
return;
case FOR_OF:
case FOR_IN:
{
Node lhs=n.getFirstChild();
if (NodeUtil.isNameDeclaration(lhs)) {
  lhs=lhs.getLastChild();
}
computeGenKill(lhs,gen,kill,conditional);
return;
}
case LET:
case CONST:
case VAR:
for (Node c=n.getFirstChild(); c != null; c=c.getNext()) {
if (c.isName()) {
if (c.hasChildren()) {
  computeGenKill(c.getFirstChild(),gen,kill,conditional);
  if (!conditional) {
    addToSetIfLocal(c,kill);
  }
}
}
 else {
checkState(c.isDestructuringLhs(),c);
if (!conditional) {
  Iterable<Node> allVars=NodeUtil.findLhsNodesInNode(c);
  for (  Node lhsNode : allVars) {
    addToSetIfLocal(lhsNode,kill);
  }
}
computeGenKill(c.getFirstChild(),gen,kill,conditional);
computeGenKill(c.getSecondChild(),gen,kill,conditional);
}
}
return;
case AND:
case OR:
computeGenKill(n.getFirstChild(),gen,kill,conditional);
computeGenKill(n.getLastChild(),gen,kill,true);
return;
case HOOK:
computeGenKill(n.getFirstChild(),gen,kill,conditional);
computeGenKill(n.getSecondChild(),gen,kill,true);
computeGenKill(n.getLastChild(),gen,kill,true);
return;
case NAME:
if (isArgumentsName(n)) {
markAllParametersEscaped();
}
 else if (!NodeUtil.isLhsByDestructuring(n)) {
addToSetIfLocal(n,gen);
}
return;
default :
if (NodeUtil.isAssignmentOp(n) && n.getFirstChild().isName()) {
Node lhs=n.getFirstChild();
if (!conditional) {
addToSetIfLocal(lhs,kill);
}
if (!n.isAssign()) {
addToSetIfLocal(lhs,gen);
}
computeGenKill(lhs.getNext(),gen,kill,conditional);
}
 else if (n.isAssign() && n.getFirstChild().isDestructuringPattern()) {
if (!conditional) {
Iterable<Node> allVars=NodeUtil.findLhsNodesInNode(n);
for (Node child : allVars) {
if (child.isName()) {
addToSetIfLocal(child,kill);
}
}
}
computeGenKill(n.getFirstChild(),gen,kill,conditional);
computeGenKill(n.getSecondChild(),gen,kill,conditional);
}
 else {
for (Node c=n.getFirstChild(); c != null; c=c.getNext()) {
computeGenKill(c,gen,kill,conditional);
}
}
return;
}
}",0.7982315112540193
19230,"public void testReferenceInDestructuringPatternComputedProperty(){
  inFunction(lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testReferenceInDestructuringPatternComputedProperty(){
  inFunction(""String_Node_Str"");
  inFunction(lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.7929515418502202
19231,"public void testDestructuring(){
  inFunction(""String_Node_Str"");
  inFunction(""String_Node_Str"");
}","public void testDestructuring(){
  inFunction(""String_Node_Str"");
  inFunction(""String_Node_Str"");
  inFunction(""String_Node_Str"",""String_Node_Str"");
  inFunction(""String_Node_Str"");
}",0.704225352112676
19232,"public void testReferenceInDestructuringPatternDefaultValue(){
  inFunction(lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  inFunction(lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  inFunction(lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testReferenceInDestructuringPatternDefaultValue(){
  inFunction(lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  inFunction(lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  inFunction(""String_Node_Str"");
  inFunction(""String_Node_Str"");
}",0.6361323155216285
19233,"public void testForOfWithDestructuring(){
  inFunction(lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  inFunction(lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testForOfWithDestructuring(){
  inFunction(lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  inFunction(lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  inFunction(""String_Node_Str"");
  inFunction(""String_Node_Str"");
  inFunction(""String_Node_Str"",""String_Node_Str"");
}",0.721875
19234,"/** 
 * For each node, update the block stack and reference collection as appropriate.
 */
@Override public void visit(NodeTraversal t,Node n,Node parent){
  if (n.isName() || n.isImportStar() || (n.isStringKey() && !n.hasChildren())) {
    Var v=t.getScope().getVar(n.getString());
    if (v != null) {
      if (varFilter.apply(v)) {
        addReference(v,new Reference(n,t,peek(blockStack)));
      }
      if (v.getParentNode() != null && NodeUtil.isHoistedFunctionDeclaration(v.getParentNode()) && (narrowScope == null || narrowScope.getDepth() <= v.getScope().getDepth())) {
        outOfBandTraversal(v);
      }
    }
  }
  if (isBlockBoundary(n,parent)) {
    pop(blockStack);
  }
}","/** 
 * For each node, update the block stack and reference collection as appropriate.
 */
@Override public void visit(NodeTraversal t,Node n,Node parent){
  if (n.isName() || n.isImportStar() || (n.isStringKey() && !n.hasChildren())) {
    if ((parent.isImportSpec() && n != parent.getLastChild()) || (parent.isExportSpec() && n != parent.getFirstChild())) {
      return;
    }
    Var v=t.getScope().getVar(n.getString());
    if (v != null) {
      if (varFilter.apply(v)) {
        addReference(v,new Reference(n,t,peek(blockStack)));
      }
      if (v.getParentNode() != null && NodeUtil.isHoistedFunctionDeclaration(v.getParentNode()) && (narrowScope == null || narrowScope.getDepth() <= v.getScope().getDepth())) {
        outOfBandTraversal(v);
      }
    }
  }
  if (isBlockBoundary(n,parent)) {
    pop(blockStack);
  }
}",0.6614276358873609
19235,"public void testFailModule(){
  testError(""String_Node_Str"",EXTRA_REQUIRE_WARNING);
  testError(lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),EXTRA_REQUIRE_WARNING);
}","public void testFailModule(){
  testError(""String_Node_Str"",EXTRA_REQUIRE_WARNING);
  testError(""String_Node_Str"",EXTRA_REQUIRE_WARNING);
  testError(""String_Node_Str"",EXTRA_REQUIRE_WARNING);
  testError(lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),EXTRA_REQUIRE_WARNING);
}",0.7711864406779662
19236,"public void testES6ModuleWithDestructuringRequire(){
  testError(lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),EXTRA_REQUIRE_WARNING);
}","public void testES6ModuleWithDestructuringRequire(){
  testError(lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),EXTRA_REQUIRE_WARNING);
  testError(lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),EXTRA_REQUIRE_WARNING);
  testError(lines(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),EXTRA_REQUIRE_WARNING);
}",0.5688775510204082
19237,"public void testRedeclareVariableFromImport(){
  assertRedeclareError(""String_Node_Str"");
  assertRedeclareError(""String_Node_Str"");
  assertRedeclareError(""String_Node_Str"");
  assertRedeclareError(""String_Node_Str"");
  assertRedeclareError(""String_Node_Str"");
  assertRedeclareError(""String_Node_Str"");
  assertRedeclareError(""String_Node_Str"");
  assertRedeclareError(""String_Node_Str"");
  assertRedeclareError(""String_Node_Str"");
  assertRedeclareError(""String_Node_Str"");
  testSame(""String_Node_Str"");
}","public void testRedeclareVariableFromImport(){
  assertRedeclareError(""String_Node_Str"");
  assertRedeclareError(""String_Node_Str"");
  assertRedeclareError(""String_Node_Str"");
  assertRedeclareError(""String_Node_Str"");
  assertRedeclareError(""String_Node_Str"");
  assertRedeclareError(""String_Node_Str"");
  assertRedeclareError(""String_Node_Str"");
  assertRedeclareError(""String_Node_Str"");
  assertRedeclareError(""String_Node_Str"");
  assertRedeclareError(""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
}",0.9425925925925924
19238,"public void testES6Module_destructuring(){
  enableUnusedLocalAssignmentCheck=true;
  assertNoWarning(""String_Node_Str"");
}","public void testES6Module_destructuring(){
  enableUnusedLocalAssignmentCheck=true;
  assertNoWarning(""String_Node_Str"");
  assertNoWarning(""String_Node_Str"");
  assertNoWarning(""String_Node_Str"");
}",0.7639751552795031
19239,"/** 
 * Computes the GEN and KILL set.
 * @param n Root node.
 * @param gen Local variables that are live because of the instruction at {@code n} will be addedto this set.
 * @param kill Local variables that are killed because of the instruction at {@code n} will beadded to this set.
 * @param conditional {@code true} if any assignments encountered are conditionally executed.These assignments might not kill a variable.
 */
private void computeGenKill(Node n,BitSet gen,BitSet kill,boolean conditional){
switch (n.getToken()) {
case SCRIPT:
case ROOT:
case FUNCTION:
case BLOCK:
    return;
case WHILE:
case DO:
case IF:
case FOR:
  computeGenKill(NodeUtil.getConditionExpression(n),gen,kill,conditional);
return;
case FOR_OF:
case FOR_IN:
{
Node lhs=n.getFirstChild();
if (NodeUtil.isNameDeclaration(lhs)) {
  lhs=lhs.getLastChild();
}
if (lhs.isName()) {
  addToSetIfLocal(lhs,kill);
  addToSetIfLocal(lhs,gen);
}
 else {
  computeGenKill(lhs,gen,kill,conditional);
}
return;
}
case LET:
case CONST:
case VAR:
for (Node c=n.getFirstChild(); c != null; c=c.getNext()) {
if (c.isName()) {
if (c.hasChildren()) {
  computeGenKill(c.getFirstChild(),gen,kill,conditional);
  if (!conditional) {
    addToSetIfLocal(c,kill);
  }
}
}
 else {
Iterable<Node> allVars=NodeUtil.findLhsNodesInNode(n);
for (Node child : allVars) {
  addToSetIfLocal(child,kill);
}
}
}
return;
case AND:
case OR:
computeGenKill(n.getFirstChild(),gen,kill,conditional);
computeGenKill(n.getLastChild(),gen,kill,true);
return;
case HOOK:
computeGenKill(n.getFirstChild(),gen,kill,conditional);
computeGenKill(n.getSecondChild(),gen,kill,true);
computeGenKill(n.getLastChild(),gen,kill,true);
return;
case NAME:
if (isArgumentsName(n)) {
markAllParametersEscaped();
}
 else {
addToSetIfLocal(n,gen);
}
return;
default :
if (NodeUtil.isAssignmentOp(n) && n.getFirstChild().isName()) {
Node lhs=n.getFirstChild();
if (!conditional) {
addToSetIfLocal(lhs,kill);
}
if (!n.isAssign()) {
addToSetIfLocal(lhs,gen);
}
computeGenKill(lhs.getNext(),gen,kill,conditional);
}
 else {
for (Node c=n.getFirstChild(); c != null; c=c.getNext()) {
computeGenKill(c,gen,kill,conditional);
}
}
return;
}
}","/** 
 * Computes the GEN and KILL set.
 * @param n Root node.
 * @param gen Local variables that are live because of the instruction at {@code n} will be addedto this set.
 * @param kill Local variables that are killed because of the instruction at {@code n} will beadded to this set.
 * @param conditional {@code true} if any assignments encountered are conditionally executed.These assignments might not kill a variable.
 */
private void computeGenKill(Node n,BitSet gen,BitSet kill,boolean conditional){
switch (n.getToken()) {
case SCRIPT:
case ROOT:
case FUNCTION:
case BLOCK:
    return;
case WHILE:
case DO:
case IF:
case FOR:
  computeGenKill(NodeUtil.getConditionExpression(n),gen,kill,conditional);
return;
case FOR_OF:
case FOR_IN:
{
Node lhs=n.getFirstChild();
if (NodeUtil.isNameDeclaration(lhs)) {
  lhs=lhs.getLastChild();
}
if (lhs.isName()) {
  addToSetIfLocal(lhs,kill);
  addToSetIfLocal(lhs,gen);
}
 else {
  computeGenKill(lhs,gen,kill,conditional);
}
return;
}
case LET:
case CONST:
case VAR:
for (Node c=n.getFirstChild(); c != null; c=c.getNext()) {
if (c.isName()) {
if (c.hasChildren()) {
  computeGenKill(c.getFirstChild(),gen,kill,conditional);
  if (!conditional) {
    addToSetIfLocal(c,kill);
  }
}
}
 else {
computeGenKill(c,gen,kill,conditional);
}
}
return;
case DESTRUCTURING_LHS:
if (n.hasTwoChildren()) {
computeGenKill(n.getSecondChild(),gen,kill,conditional);
if (!conditional) {
Iterable<Node> allVars=NodeUtil.findLhsNodesInNode(n);
for (Node child : allVars) {
addToSetIfLocal(child,kill);
}
}
}
return;
case AND:
case OR:
computeGenKill(n.getFirstChild(),gen,kill,conditional);
computeGenKill(n.getLastChild(),gen,kill,true);
return;
case HOOK:
computeGenKill(n.getFirstChild(),gen,kill,conditional);
computeGenKill(n.getSecondChild(),gen,kill,true);
computeGenKill(n.getLastChild(),gen,kill,true);
return;
case NAME:
if (isArgumentsName(n)) {
markAllParametersEscaped();
}
 else {
addToSetIfLocal(n,gen);
}
return;
default :
if (NodeUtil.isAssignmentOp(n) && n.getFirstChild().isName()) {
Node lhs=n.getFirstChild();
if (!conditional) {
addToSetIfLocal(lhs,kill);
}
if (!n.isAssign()) {
addToSetIfLocal(lhs,gen);
}
computeGenKill(lhs.getNext(),gen,kill,conditional);
}
 else {
for (Node c=n.getFirstChild(); c != null; c=c.getNext()) {
computeGenKill(c,gen,kill,conditional);
}
}
return;
}
}",0.959715112397062
19240,"public NameDeclarationStatement(RemovableBuilder builder,Node declarationStatement){
  super(builder);
  this.declarationStatement=declarationStatement;
}","public NameDeclarationStatement(RemovableBuilder builder,Node declarationStatement){
  super(builder);
  checkArgument(NodeUtil.isNameDeclaration(declarationStatement),declarationStatement);
  this.declarationStatement=declarationStatement;
}",0.7777777777777778
19241,"Assign(RemovableBuilder builder,Node assignNode,Kind kind,@Nullable Node propertyNode){
  super(builder);
  checkState(NodeUtil.isAssignmentOp(assignNode));
  if (kind == Kind.VARIABLE) {
    checkArgument(propertyNode == null,""String_Node_Str"",propertyNode);
  }
 else {
    checkArgument(propertyNode != null,""String_Node_Str"");
    if (kind == Kind.NAMED_PROPERTY) {
      checkArgument(propertyNode.isString(),""String_Node_Str"",propertyNode);
    }
  }
  this.assignNode=assignNode;
  this.kind=kind;
  this.propertyNode=propertyNode;
  this.maybeAliased=NodeUtil.isExpressionResultUsed(assignNode);
}","Assign(RemovableBuilder builder,Node assignNode,Kind kind,@Nullable Node propertyNode){
  super(builder);
  checkArgument(NodeUtil.isAssignmentOp(assignNode),assignNode);
  if (kind == Kind.VARIABLE) {
    checkArgument(propertyNode == null,""String_Node_Str"",propertyNode);
  }
 else {
    checkArgument(propertyNode != null,""String_Node_Str"");
    if (kind == Kind.NAMED_PROPERTY) {
      checkArgument(propertyNode.isString(),""String_Node_Str"",propertyNode);
    }
  }
  this.assignNode=assignNode;
  this.kind=kind;
  this.propertyNode=propertyNode;
  this.maybeAliased=NodeUtil.isExpressionResultUsed(assignNode);
}",0.9803921568627452
19242,"@Override protected void setUp() throws Exception {
  super.setUp();
  options=new CompilerOptions();
  options.setErrorHandler(new BlackHoleErrorManager());
  options.setLanguageIn(LanguageMode.ECMASCRIPT_2017);
  options.setLanguageOut(LanguageMode.ECMASCRIPT5);
  options.setCodingConvention(new ClosureCodingConvention());
  CompilationLevel.SIMPLE_OPTIMIZATIONS.setOptionsForCompilationLevel(options);
  WarningLevel.VERBOSE.setOptionsForWarningLevel(options);
  options.setChecksOnly(true);
  options.setPreserveDetailedSourceInfo(true);
  options.setContinueAfterErrors(true);
  options.setAllowHotswapReplaceScript(true);
  options.setParseJsDocDocumentation(INCLUDE_DESCRIPTIONS_NO_WHITESPACE);
}","@Override protected void setUp() throws Exception {
  super.setUp();
  options=new CompilerOptions();
  options.setLanguageIn(LanguageMode.ECMASCRIPT_2017);
  options.setLanguageOut(LanguageMode.ECMASCRIPT5);
  options.setCodingConvention(new ClosureCodingConvention());
  CompilationLevel.SIMPLE_OPTIMIZATIONS.setOptionsForCompilationLevel(options);
  WarningLevel.VERBOSE.setOptionsForWarningLevel(options);
  options.setChecksOnly(true);
  options.setPreserveDetailedSourceInfo(true);
  options.setContinueAfterErrors(true);
  options.setAllowHotswapReplaceScript(true);
  options.setParseJsDocDocumentation(INCLUDE_DESCRIPTIONS_NO_WHITESPACE);
}",0.9586410635155096
19243,"private SymbolTable createSymbolTable(String input){
  List<SourceFile> inputs=ImmutableList.of(SourceFile.fromCode(""String_Node_Str"",input));
  List<SourceFile> externs=ImmutableList.of(SourceFile.fromCode(""String_Node_Str"",EXTERNS));
  Compiler compiler=new Compiler();
  compiler.compile(externs,inputs,options);
  return assertSymbolTableValid(compiler.buildKnownSymbolTable());
}","private SymbolTable createSymbolTable(String input){
  List<SourceFile> inputs=ImmutableList.of(SourceFile.fromCode(""String_Node_Str"",input));
  List<SourceFile> externs=ImmutableList.of(SourceFile.fromCode(""String_Node_Str"",EXTERNS));
  Compiler compiler=new Compiler(new BlackHoleErrorManager());
  compiler.compile(externs,inputs,options);
  return assertSymbolTableValid(compiler.buildKnownSymbolTable());
}",0.9660377358490566
19244,"private static Compiler getCompiler(String externs,String jsInput){
  Compiler compiler=new Compiler();
  compiler.disableThreads();
  CompilerOptions options=RefactoringDriver.getCompilerOptions();
  options.setErrorHandler(new BlackHoleErrorManager());
  compiler.compile(ImmutableList.of(SourceFile.fromCode(""String_Node_Str"",externs)),ImmutableList.of(SourceFile.fromCode(""String_Node_Str"",jsInput)),options);
  return compiler;
}","private static Compiler getCompiler(String externs,String jsInput){
  Compiler compiler=new Compiler(new BlackHoleErrorManager());
  compiler.disableThreads();
  CompilerOptions options=RefactoringDriver.getCompilerOptions();
  compiler.compile(ImmutableList.of(SourceFile.fromCode(""String_Node_Str"",externs)),ImmutableList.of(SourceFile.fromCode(""String_Node_Str"",jsInput)),options);
  return compiler;
}",0.901072705601907
19245,"private void addSyntheticConstructor(Node classNode){
  Node superClass=classNode.getSecondChild();
  Node classMembers=classNode.getLastChild();
  Node memberDef;
  if (superClass.isEmpty()) {
    Node function=NodeUtil.emptyFunction();
    compiler.reportChangeToChangeScope(function);
    memberDef=IR.memberFunctionDef(""String_Node_Str"",function);
  }
 else {
    if (!superClass.isQualifiedName()) {
      return;
    }
    Node body=IR.block();
    if (!classNode.isFromExterns() && !isInterface(classNode)) {
      Node exprResult=IR.exprResult(IR.call(IR.getprop(IR.superNode(),IR.string(""String_Node_Str"")),IR.thisNode(),IR.name(""String_Node_Str"")));
      body.addChildToFront(exprResult);
    }
    Node constructor=IR.function(IR.name(""String_Node_Str""),IR.paramList(IR.name(""String_Node_Str"")),body);
    compiler.reportChangeToChangeScope(constructor);
    memberDef=IR.memberFunctionDef(""String_Node_Str"",constructor);
    JSDocInfoBuilder info=new JSDocInfoBuilder(false);
    info.recordParameter(""String_Node_Str"",new JSTypeExpression(new Node(Token.ELLIPSIS,new Node(Token.QMARK)),""String_Node_Str""));
    memberDef.setJSDocInfo(info.build());
  }
  memberDef.useSourceInfoIfMissingFromForTree(classNode);
  classMembers.addChildToFront(memberDef);
  compiler.reportChangeToEnclosingScope(memberDef);
}","private void addSyntheticConstructor(Node classNode){
  Node superClass=classNode.getSecondChild();
  Node classMembers=classNode.getLastChild();
  Node memberDef;
  if (superClass.isEmpty()) {
    Node function=NodeUtil.emptyFunction();
    compiler.reportChangeToChangeScope(function);
    memberDef=IR.memberFunctionDef(""String_Node_Str"",function);
  }
 else {
    if (!superClass.isQualifiedName()) {
      return;
    }
    Node body=IR.block();
    if (!classNode.isFromExterns() && !isInterface(classNode)) {
      Node exprResult=IR.exprResult(IR.call(IR.getprop(IR.superNode(),IR.string(""String_Node_Str"")),IR.thisNode(),IR.name(""String_Node_Str"")));
      body.addChildToFront(exprResult);
    }
    Node constructor=IR.function(IR.name(""String_Node_Str""),IR.paramList(IR.name(""String_Node_Str"")),body);
    compiler.reportChangeToChangeScope(constructor);
    memberDef=IR.memberFunctionDef(""String_Node_Str"",constructor);
    JSDocInfoBuilder info=new JSDocInfoBuilder(false);
    info.recordParameter(""String_Node_Str"",new JSTypeExpression(new Node(Token.ELLIPSIS,new Node(Token.QMARK)),""String_Node_Str""));
    memberDef.setJSDocInfo(info.build());
  }
  memberDef.useSourceInfoIfMissingFromForTree(classNode);
  memberDef.makeNonIndexableRecursive();
  classMembers.addChildToFront(memberDef);
  compiler.reportChangeToEnclosingScope(memberDef);
}",0.9847185985836748
19246,"/** 
 * Classes are processed in 3 phases: <ol> <li>The class name is extracted. <li>Class members are processed and rewritten. <li>The constructor is built. </ol>
 */
private void visitClass(final NodeTraversal t,final Node classNode,final Node parent){
  checkClassReassignment(classNode);
  ClassDeclarationMetadata metadata=ClassDeclarationMetadata.create(classNode,parent);
  if (metadata == null || metadata.fullClassName == null) {
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + classNode);
  }
  if (metadata.hasSuperClass() && !metadata.superClassNameNode.isQualifiedName()) {
    compiler.report(JSError.make(metadata.superClassNameNode,DYNAMIC_EXTENDS_TYPE));
    return;
  }
  Preconditions.checkState(NodeUtil.isStatement(metadata.insertionPoint),""String_Node_Str"",metadata.insertionPoint);
  Node constructor=null;
  JSDocInfo ctorJSDocInfo=null;
  Node classMembers=classNode.getLastChild();
  for (  Node member : classMembers.children()) {
    if ((member.isComputedProp() && (member.getBooleanProp(Node.COMPUTED_PROP_GETTER) || member.getBooleanProp(Node.COMPUTED_PROP_SETTER))) || (member.isGetterDef() || member.isSetterDef())) {
      visitNonMethodMember(member,metadata);
    }
 else     if (member.isMemberFunctionDef() && member.getString().equals(""String_Node_Str"")) {
      ctorJSDocInfo=member.getJSDocInfo();
      constructor=member.getFirstChild().detach();
      if (!metadata.anonymous) {
        constructor.replaceChild(constructor.getFirstChild(),metadata.classNameNode.cloneNode());
      }
    }
 else     if (member.isEmpty()) {
    }
 else {
      Preconditions.checkState(member.isMemberFunctionDef() || member.isComputedProp(),""String_Node_Str"",member);
      Preconditions.checkState(!member.getBooleanProp(Node.COMPUTED_PROP_VARIABLE),""String_Node_Str"",member);
      visitMethod(member,metadata);
    }
  }
  if (metadata.definePropertiesObjForPrototype.hasChildren()) {
    compiler.ensureLibraryInjected(""String_Node_Str"",false);
    Node definePropsCall=IR.exprResult(IR.call(NodeUtil.newQName(compiler,""String_Node_Str""),NodeUtil.newQName(compiler,metadata.fullClassName + ""String_Node_Str""),metadata.definePropertiesObjForPrototype));
    definePropsCall.useSourceInfoIfMissingFromForTree(classNode);
    metadata.insertNodeAndAdvance(definePropsCall);
  }
  if (metadata.definePropertiesObjForClass.hasChildren()) {
    compiler.ensureLibraryInjected(""String_Node_Str"",false);
    Node definePropsCall=IR.exprResult(IR.call(NodeUtil.newQName(compiler,""String_Node_Str""),NodeUtil.newQName(compiler,metadata.fullClassName),metadata.definePropertiesObjForClass));
    definePropsCall.useSourceInfoIfMissingFromForTree(classNode);
    metadata.insertNodeAndAdvance(definePropsCall);
  }
  checkNotNull(constructor);
  JSDocInfo classJSDoc=NodeUtil.getBestJSDocInfo(classNode);
  JSDocInfoBuilder newInfo=JSDocInfoBuilder.maybeCopyFrom(classJSDoc);
  newInfo.recordConstructor();
  Node enclosingStatement=NodeUtil.getEnclosingStatement(classNode);
  if (metadata.hasSuperClass()) {
    String superClassString=metadata.superClassNameNode.getQualifiedName();
    if (newInfo.isInterfaceRecorded()) {
      newInfo.recordExtendedInterface(new JSTypeExpression(new Node(Token.BANG,IR.string(superClassString)),metadata.superClassNameNode.getSourceFileName()));
    }
 else {
      if (shouldAddInheritsPolyfill && !classNode.isFromExterns()) {
        Node classNameNode=NodeUtil.newQName(compiler,metadata.fullClassName).useSourceInfoIfMissingFrom(metadata.classNameNode);
        Node superClassNameNode=NodeUtil.newQName(compiler,superClassString).useSourceInfoIfMissingFrom(metadata.superClassNameNode);
        Node inherits=IR.call(NodeUtil.newQName(compiler,INHERITS),classNameNode,superClassNameNode);
        Node inheritsCall=IR.exprResult(inherits);
        compiler.ensureLibraryInjected(""String_Node_Str"",false);
        inheritsCall.useSourceInfoIfMissingFromForTree(metadata.superClassNameNode);
        enclosingStatement.getParent().addChildAfter(inheritsCall,enclosingStatement);
      }
      newInfo.recordBaseType(new JSTypeExpression(new Node(Token.BANG,IR.string(superClassString)),metadata.superClassNameNode.getSourceFileName()));
    }
  }
  addTypeDeclarations(metadata,enclosingStatement);
  updateClassJsDoc(ctorJSDocInfo,newInfo);
  if (NodeUtil.isStatement(classNode)) {
    constructor.getFirstChild().setString(""String_Node_Str"");
    Node ctorVar=IR.let(metadata.classNameNode.cloneNode(),constructor);
    ctorVar.useSourceInfoIfMissingFromForTree(classNode);
    parent.replaceChild(classNode,ctorVar);
  }
 else {
    parent.replaceChild(classNode,constructor);
  }
  NodeUtil.markFunctionsDeleted(classNode,compiler);
  if (NodeUtil.isStatement(constructor)) {
    constructor.setJSDocInfo(newInfo.build());
  }
 else   if (parent.isName()) {
    Node var=parent.getParent();
    var.setJSDocInfo(newInfo.build());
  }
 else   if (constructor.getParent().isName()) {
    Node var=constructor.getGrandparent();
    var.setJSDocInfo(newInfo.build());
  }
 else   if (parent.isAssign()) {
    parent.setJSDocInfo(newInfo.build());
  }
 else {
    throw new IllegalStateException(""String_Node_Str"" + parent);
  }
  constructor.putBooleanProp(Node.IS_ES6_CLASS,true);
  t.reportCodeChange();
}","/** 
 * Classes are processed in 3 phases: <ol> <li>The class name is extracted. <li>Class members are processed and rewritten. <li>The constructor is built. </ol>
 */
private void visitClass(final NodeTraversal t,final Node classNode,final Node parent){
  checkClassReassignment(classNode);
  ClassDeclarationMetadata metadata=ClassDeclarationMetadata.create(classNode,parent);
  if (metadata == null || metadata.fullClassName == null) {
    throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"" + classNode);
  }
  if (metadata.hasSuperClass() && !metadata.superClassNameNode.isQualifiedName()) {
    compiler.report(JSError.make(metadata.superClassNameNode,DYNAMIC_EXTENDS_TYPE));
    return;
  }
  Preconditions.checkState(NodeUtil.isStatement(metadata.insertionPoint),""String_Node_Str"",metadata.insertionPoint);
  Node constructor=null;
  JSDocInfo ctorJSDocInfo=null;
  Node classMembers=classNode.getLastChild();
  for (  Node member : classMembers.children()) {
    if ((member.isComputedProp() && (member.getBooleanProp(Node.COMPUTED_PROP_GETTER) || member.getBooleanProp(Node.COMPUTED_PROP_SETTER))) || (member.isGetterDef() || member.isSetterDef())) {
      visitNonMethodMember(member,metadata);
    }
 else     if (member.isMemberFunctionDef() && member.getString().equals(""String_Node_Str"")) {
      ctorJSDocInfo=member.getJSDocInfo();
      constructor=member.getFirstChild().detach();
      if (!metadata.anonymous) {
        constructor.replaceChild(constructor.getFirstChild(),metadata.classNameNode.cloneNode());
      }
    }
 else     if (member.isEmpty()) {
    }
 else {
      Preconditions.checkState(member.isMemberFunctionDef() || member.isComputedProp(),""String_Node_Str"",member);
      Preconditions.checkState(!member.getBooleanProp(Node.COMPUTED_PROP_VARIABLE),""String_Node_Str"",member);
      visitMethod(member,metadata);
    }
  }
  if (metadata.definePropertiesObjForPrototype.hasChildren()) {
    compiler.ensureLibraryInjected(""String_Node_Str"",false);
    Node definePropsCall=IR.exprResult(IR.call(NodeUtil.newQName(compiler,""String_Node_Str""),NodeUtil.newQName(compiler,metadata.fullClassName + ""String_Node_Str""),metadata.definePropertiesObjForPrototype));
    definePropsCall.useSourceInfoIfMissingFromForTree(classNode);
    metadata.insertNodeAndAdvance(definePropsCall);
  }
  if (metadata.definePropertiesObjForClass.hasChildren()) {
    compiler.ensureLibraryInjected(""String_Node_Str"",false);
    Node definePropsCall=IR.exprResult(IR.call(NodeUtil.newQName(compiler,""String_Node_Str""),NodeUtil.newQName(compiler,metadata.fullClassName),metadata.definePropertiesObjForClass));
    definePropsCall.useSourceInfoIfMissingFromForTree(classNode);
    metadata.insertNodeAndAdvance(definePropsCall);
  }
  checkNotNull(constructor);
  JSDocInfo classJSDoc=NodeUtil.getBestJSDocInfo(classNode);
  JSDocInfoBuilder newInfo=JSDocInfoBuilder.maybeCopyFrom(classJSDoc);
  newInfo.recordConstructor();
  Node enclosingStatement=NodeUtil.getEnclosingStatement(classNode);
  if (metadata.hasSuperClass()) {
    String superClassString=metadata.superClassNameNode.getQualifiedName();
    if (newInfo.isInterfaceRecorded()) {
      newInfo.recordExtendedInterface(new JSTypeExpression(new Node(Token.BANG,IR.string(superClassString)),metadata.superClassNameNode.getSourceFileName()));
    }
 else {
      if (shouldAddInheritsPolyfill && !classNode.isFromExterns()) {
        Node classNameNode=NodeUtil.newQName(compiler,metadata.fullClassName).useSourceInfoIfMissingFrom(metadata.classNameNode);
        Node superClassNameNode=metadata.superClassNameNode.cloneTree();
        Node inherits=IR.call(NodeUtil.newQName(compiler,INHERITS),classNameNode,superClassNameNode);
        Node inheritsCall=IR.exprResult(inherits);
        compiler.ensureLibraryInjected(""String_Node_Str"",false);
        inheritsCall.useSourceInfoIfMissingFromForTree(metadata.superClassNameNode);
        enclosingStatement.getParent().addChildAfter(inheritsCall,enclosingStatement);
      }
      newInfo.recordBaseType(new JSTypeExpression(new Node(Token.BANG,IR.string(superClassString)),metadata.superClassNameNode.getSourceFileName()));
    }
  }
  addTypeDeclarations(metadata,enclosingStatement);
  updateClassJsDoc(ctorJSDocInfo,newInfo);
  if (NodeUtil.isStatement(classNode)) {
    constructor.getFirstChild().setString(""String_Node_Str"");
    Node ctorVar=IR.let(metadata.classNameNode.cloneNode(),constructor);
    ctorVar.useSourceInfoIfMissingFromForTree(classNode);
    parent.replaceChild(classNode,ctorVar);
  }
 else {
    parent.replaceChild(classNode,constructor);
  }
  NodeUtil.markFunctionsDeleted(classNode,compiler);
  if (NodeUtil.isStatement(constructor)) {
    constructor.setJSDocInfo(newInfo.build());
  }
 else   if (parent.isName()) {
    Node var=parent.getParent();
    var.setJSDocInfo(newInfo.build());
  }
 else   if (constructor.getParent().isName()) {
    Node var=constructor.getGrandparent();
    var.setJSDocInfo(newInfo.build());
  }
 else   if (parent.isAssign()) {
    parent.setJSDocInfo(newInfo.build());
  }
 else {
    throw new IllegalStateException(""String_Node_Str"" + parent);
  }
  constructor.putBooleanProp(Node.IS_ES6_CLASS,true);
  t.reportCodeChange();
}",0.9869981968302172
19247,"protected Compiler compile(CompilerOptions options,String[] original){
  Compiler compiler=useNoninjectingCompiler ? new NoninjectingCompiler() : new Compiler();
  lastCompiler=compiler;
  options.setErrorHandler(new BlackHoleErrorManager());
  compiler.compileModules(externs,ImmutableList.copyOf(CompilerTestCase.createModuleChain(ImmutableList.copyOf(original),inputFileNamePrefix,inputFileNameSuffix)),options);
  return compiler;
}","protected Compiler compile(CompilerOptions options,String[] original){
  Compiler compiler=useNoninjectingCompiler ? new NoninjectingCompiler(new BlackHoleErrorManager()) : new Compiler(new BlackHoleErrorManager());
  lastCompiler=compiler;
  compiler.compileModules(externs,ImmutableList.copyOf(CompilerTestCase.createModuleChain(ImmutableList.copyOf(original),inputFileNamePrefix,inputFileNameSuffix)),options);
  return compiler;
}",0.8735632183908046
19248,"public void assertHasEncounteredAllErrors(){
  assertThat(errors).hasLength(errorsIndex);
}","public void assertHasEncounteredAllErrors(){
  if (errors.length != errorsIndex) {
    Assert.fail(""String_Node_Str"" + Arrays.asList(errors).subList(errorsIndex,errors.length));
  }
}",0.5985401459854015
19249,"public void assertHasEncounteredAllWarnings(){
  assertThat(warnings).hasLength(warningsIndex);
}","public void assertHasEncounteredAllWarnings(){
  if (warnings.length != warningsIndex) {
    Assert.fail(""String_Node_Str"" + Arrays.asList(warnings).subList(warningsIndex,warnings.length));
  }
}",0.6095890410958904
19250,"private boolean inlineAliasIfPossible(Name name,Ref alias,GlobalNamespace namespace){
  Node aliasParent=alias.node.getParent();
  if (aliasParent.isName() || aliasParent.isAssign()) {
    Node aliasLhsNode=aliasParent.isName() ? aliasParent : aliasParent.getFirstChild();
    String aliasVarName=aliasLhsNode.getString();
    Var aliasVar=alias.scope.getVar(aliasVarName);
    checkState(aliasVar != null,""String_Node_Str"",aliasVarName);
    Node aliasDeclarationParent=aliasVar.getParentNode();
    Scope scope=aliasDeclarationParent.isVar() ? alias.scope.getClosestHoistScope() : alias.scope;
    ReferenceCollectingCallback collector=new ReferenceCollectingCallback(compiler,ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,new Es6SyntacticScopeCreator(compiler),Predicates.equalTo(aliasVar));
    collector.processScope(scope);
    ReferenceCollection aliasRefs=collector.getReferences(aliasVar);
    Set<AstChange> newNodes=new LinkedHashSet<>();
    if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration()) {
      if (!aliasRefs.isAssignedOnceInLifetime()) {
        if (name.isConstructor() && referencesCollapsibleProperty(aliasRefs,name,namespace)) {
          compiler.report(JSError.make(aliasParent,UNSAFE_CTOR_ALIASING,aliasVarName));
        }
        return false;
      }
      int size=aliasRefs.references.size();
      for (int i=1; i < size; i++) {
        Reference aliasRef=aliasRefs.references.get(i);
        newNodes.add(replaceAliasReference(alias,aliasRef));
      }
      aliasParent.replaceChild(alias.node,IR.nullNode());
      codeChanged=true;
      compiler.reportChangeToEnclosingScope(aliasParent);
      namespace.scanNewNodes(newNodes);
      return true;
    }
    if (name.isConstructor()) {
      return partiallyInlineAlias(alias,namespace,aliasRefs,aliasLhsNode);
    }
  }
  return false;
}","private boolean inlineAliasIfPossible(Name name,Ref alias,GlobalNamespace namespace){
  Node aliasParent=alias.node.getParent();
  if (aliasParent.isName() || aliasParent.isAssign()) {
    Node aliasLhsNode=aliasParent.isName() ? aliasParent : aliasParent.getFirstChild();
    String aliasVarName=aliasLhsNode.getString();
    Var aliasVar=alias.scope.getVar(aliasVarName);
    checkState(aliasVar != null,""String_Node_Str"",aliasVarName);
    ReferenceCollectingCallback collector=new ReferenceCollectingCallback(compiler,ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,new Es6SyntacticScopeCreator(compiler),Predicates.equalTo(aliasVar));
    Scope aliasScope=aliasVar.getScope();
    collector.processScope(aliasScope);
    ReferenceCollection aliasRefs=collector.getReferences(aliasVar);
    Set<AstChange> newNodes=new LinkedHashSet<>();
    if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration()) {
      if (!aliasRefs.isAssignedOnceInLifetime()) {
        if (name.isConstructor() && referencesCollapsibleProperty(aliasRefs,name,namespace)) {
          compiler.report(JSError.make(aliasParent,UNSAFE_CTOR_ALIASING,aliasVarName));
        }
        return false;
      }
      int size=aliasRefs.references.size();
      for (int i=1; i < size; i++) {
        Reference aliasRef=aliasRefs.references.get(i);
        newNodes.add(replaceAliasReference(alias,aliasRef));
      }
      aliasParent.replaceChild(alias.node,IR.nullNode());
      codeChanged=true;
      compiler.reportChangeToEnclosingScope(aliasParent);
      namespace.scanNewNodes(newNodes);
      return true;
    }
    if (name.isConstructor()) {
      return partiallyInlineAlias(alias,namespace,aliasRefs,aliasLhsNode);
    }
  }
  return false;
}",0.9329639889196676
19251,"/** 
 * For each qualified name N in the global scope, we check if: (a) No ancestor of N is ever aliased or assigned an unknown value type. (If N = ""a.b.c"", ""a"" and ""a.b"" are never aliased). (b) N has exactly one write, and it lives in the global scope. (c) N is aliased in a local scope. (d) N is aliased in global scope <p>If (a) is true, then GlobalNamespace must know all the writes to N. If (a) and (b) are true, then N cannot change during the execution of a local scope. If (a) and (b) and (c) are true, then the alias can be inlined if the alias obeys the usual rules for how we decide whether a variable is inlineable. If (a) and (b) and (d) are true, then inline the alias if possible (if it is assigned exactly once unconditionally). <p>For (a), (b), and (c) are true and the alias is of a constructor, we may also partially inline the alias - i.e. replace some references with the constructor but not all - since constructor properties are always collapsed, so we want to be more aggressive about removing aliases.
 * @see InlineVariables
 */
private void inlineAliases(GlobalNamespace namespace){
  Deque<Name> workList=new ArrayDeque<>(namespace.getNameForest());
  while (!workList.isEmpty()) {
    Name name=workList.pop();
    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {
      continue;
    }
    if (!name.inExterns && name.globalSets == 1 && name.localSets == 0 && name.aliasingGets > 0) {
      List<Ref> refs=new ArrayList<>(name.getRefs());
      for (      Ref ref : refs) {
        Scope hoistScope=ref.scope.getClosestHoistScope();
        if (ref.type == Type.ALIASING_GET && !mayBeGlobalAlias(ref)) {
          if (inlineAliasIfPossible(name,ref,namespace)) {
            name.removeRef(ref);
          }
        }
 else         if (ref.type == Type.ALIASING_GET && hoistScope.isGlobal() && ref.getTwin() == null) {
          if (inlineGlobalAliasIfPossible(name,ref,namespace)) {
            name.removeRef(ref);
          }
        }
      }
    }
    if (!name.inExterns && name.type == Name.Type.CLASS) {
      List<Name> subclasses=name.subclasses;
      if (subclasses != null && name.props != null) {
        for (        Name subclass : subclasses) {
          for (          Name prop : name.props) {
            rewriteAllSubclassInheritedAccesses(name,subclass,prop,namespace);
          }
        }
      }
    }
    if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION || name.type == Name.Type.CLASS) && name.aliasingGets == 0 && name.props != null) {
      workList.addAll(name.props);
    }
  }
}","/** 
 * For each qualified name N in the global scope, we check if: (a) No ancestor of N is ever aliased or assigned an unknown value type. (If N = ""a.b.c"", ""a"" and ""a.b"" are never aliased). (b) N has exactly one write, and it lives in the global scope. (c) N is aliased in a local scope. (d) N is aliased in global scope <p>If (a) is true, then GlobalNamespace must know all the writes to N. If (a) and (b) are true, then N cannot change during the execution of a local scope. If (a) and (b) and (c) are true, then the alias can be inlined if the alias obeys the usual rules for how we decide whether a variable is inlineable. If (a) and (b) and (d) are true, then inline the alias if possible (if it is assigned exactly once unconditionally). <p>For (a), (b), and (c) are true and the alias is of a constructor, we may also partially inline the alias - i.e. replace some references with the constructor but not all - since constructor properties are always collapsed, so we want to be more aggressive about removing aliases.
 * @see InlineVariables
 */
private void inlineAliases(GlobalNamespace namespace){
  Deque<Name> workList=new ArrayDeque<>(namespace.getNameForest());
  while (!workList.isEmpty()) {
    Name name=workList.pop();
    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {
      continue;
    }
    if (!name.inExterns && name.globalSets == 1 && name.localSets == 0 && name.aliasingGets > 0) {
      List<Ref> refs=new ArrayList<>(name.getRefs());
      for (      Ref ref : refs) {
        Scope hoistScope=ref.scope.getClosestHoistScope();
        if (ref.type == Type.ALIASING_GET && !mayBeGlobalAlias(ref)) {
          if (inlineAliasIfPossible(name,ref,namespace)) {
            name.removeRef(ref);
          }
        }
 else         if (ref.type == Type.ALIASING_GET && hoistScope.isGlobal() && ref.getTwin() == null) {
          if (inlineGlobalAliasIfPossible(name,ref,namespace)) {
            name.removeRef(ref);
          }
        }
      }
    }
    if (!name.inExterns && name.type == Name.Type.CLASS) {
      List<Name> subclasses=name.subclasses;
      if (subclasses != null && name.props != null) {
        for (        Name subclass : subclasses) {
          for (          Name prop : name.props) {
            rewriteAllSubclassInheritedAccesses(name,subclass,prop,namespace);
          }
        }
      }
    }
    if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION) && name.aliasingGets == 0 && name.props != null) {
      workList.addAll(name.props);
    }
  }
}",0.9937573156457276
19252,"private boolean inlineAliasIfPossible(Name name,Ref alias,GlobalNamespace namespace){
  Node aliasParent=alias.node.getParent();
  if (aliasParent.isName() || aliasParent.isAssign()) {
    Node aliasLhsNode=aliasParent.isName() ? aliasParent : aliasParent.getFirstChild();
    String aliasVarName=aliasLhsNode.getString();
    Var aliasVar=alias.scope.getVar(aliasVarName);
    checkState(aliasVar != null,""String_Node_Str"",aliasVarName);
    ReferenceCollectingCallback collector=new ReferenceCollectingCallback(compiler,ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,new Es6SyntacticScopeCreator(compiler),Predicates.equalTo(aliasVar));
    collector.processScope(aliasVar.getScope());
    ReferenceCollection aliasRefs=collector.getReferences(aliasVar);
    Set<AstChange> newNodes=new LinkedHashSet<>();
    if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration()) {
      if (!aliasRefs.isAssignedOnceInLifetime()) {
        if (name.isConstructor()) {
          boolean accessPropsAfterAliasing=false;
          for (          Reference ref : aliasRefs.references) {
            if (ref.getNode().getParent().isGetProp()) {
              accessPropsAfterAliasing=true;
              break;
            }
          }
          if (accessPropsAfterAliasing) {
            compiler.report(JSError.make(aliasParent,UNSAFE_CTOR_ALIASING,aliasVarName));
          }
        }
        return false;
      }
      int size=aliasRefs.references.size();
      for (int i=1; i < size; i++) {
        Reference aliasRef=aliasRefs.references.get(i);
        newNodes.add(replaceAliasReference(alias,aliasRef));
      }
      aliasParent.replaceChild(alias.node,IR.nullNode());
      codeChanged=true;
      compiler.reportChangeToEnclosingScope(aliasParent);
      namespace.scanNewNodes(newNodes);
      return true;
    }
    if (name.isConstructor()) {
      return partiallyInlineAlias(alias,namespace,aliasRefs,aliasLhsNode);
    }
  }
  return false;
}","private boolean inlineAliasIfPossible(Name name,Ref alias,GlobalNamespace namespace){
  Node aliasParent=alias.node.getParent();
  if (aliasParent.isName() || aliasParent.isAssign()) {
    Node aliasLhsNode=aliasParent.isName() ? aliasParent : aliasParent.getFirstChild();
    String aliasVarName=aliasLhsNode.getString();
    Var aliasVar=alias.scope.getVar(aliasVarName);
    checkState(aliasVar != null,""String_Node_Str"",aliasVarName);
    Node aliasDeclarationParent=aliasVar.getParentNode();
    Scope scope=aliasDeclarationParent.isVar() ? alias.scope.getClosestHoistScope() : alias.scope;
    ReferenceCollectingCallback collector=new ReferenceCollectingCallback(compiler,ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,new Es6SyntacticScopeCreator(compiler),Predicates.equalTo(aliasVar));
    collector.processScope(scope);
    ReferenceCollection aliasRefs=collector.getReferences(aliasVar);
    Set<AstChange> newNodes=new LinkedHashSet<>();
    if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration()) {
      if (!aliasRefs.isAssignedOnceInLifetime()) {
        if (name.isConstructor()) {
          boolean accessPropsAfterAliasing=false;
          for (          Reference ref : aliasRefs.references) {
            if (ref.getNode().getParent().isGetProp()) {
              accessPropsAfterAliasing=true;
              break;
            }
          }
          if (accessPropsAfterAliasing) {
            compiler.report(JSError.make(aliasParent,UNSAFE_CTOR_ALIASING,aliasVarName));
          }
        }
        return false;
      }
      int size=aliasRefs.references.size();
      for (int i=1; i < size; i++) {
        Reference aliasRef=aliasRefs.references.get(i);
        newNodes.add(replaceAliasReference(alias,aliasRef));
      }
      aliasParent.replaceChild(alias.node,IR.nullNode());
      codeChanged=true;
      compiler.reportChangeToEnclosingScope(aliasParent);
      namespace.scanNewNodes(newNodes);
      return true;
    }
    if (name.isConstructor()) {
      return partiallyInlineAlias(alias,namespace,aliasRefs,aliasLhsNode);
    }
  }
  return false;
}",0.9558428885093926
19253,"/** 
 * @param value The value to use when rewriting.
 * @param depth The chain depth.
 * @param newNodes Expression nodes that have been updated.
 * @param prop The property to rewrite with value.
 */
private void rewriteAliasProp(Node value,int depth,Set<AstChange> newNodes,Name prop){
  rewriteAliasProps(prop,value,depth + 1,newNodes);
  List<Ref> refs=new ArrayList<>(prop.getRefs());
  for (  Ref ref : refs) {
    Node target=ref.node;
    for (int i=0; i <= depth; i++) {
      if (target.isGetProp()) {
        target=target.getFirstChild();
      }
 else       if (NodeUtil.isObjectLitKey(target)) {
        Node gparent=target.getGrandparent();
        if (gparent.isAssign()) {
          target=gparent.getFirstChild();
        }
 else {
          checkState(NodeUtil.isObjectLitKey(gparent));
          target=gparent;
        }
      }
 else {
        throw new IllegalStateException(""String_Node_Str"" + target);
      }
    }
    checkState(target.isGetProp() || target.isName());
    Node newValue=value.cloneTree();
    target.replaceWith(newValue);
    compiler.reportChangeToEnclosingScope(newValue);
    prop.removeRef(ref);
    newNodes.add(new AstChange(ref.module,ref.scope,ref.node));
    codeChanged=true;
  }
}","/** 
 * @param value The value to use when rewriting.
 * @param depth The chain depth.
 * @param newNodes Expression nodes that have been updated.
 * @param prop The property to rewrite with value.
 */
private void rewriteAliasProp(Node value,int depth,Set<AstChange> newNodes,Name prop){
  rewriteAliasProps(prop,value,depth + 1,newNodes);
  List<Ref> refs=new ArrayList<>(prop.getRefs());
  for (  Ref ref : refs) {
    Node target=ref.node;
    for (int i=0; i <= depth; i++) {
      if (target.isGetProp()) {
        target=target.getFirstChild();
      }
 else       if (NodeUtil.isObjectLitKey(target)) {
        Node gparent=target.getGrandparent();
        if (gparent.isAssign()) {
          target=gparent.getFirstChild();
        }
 else {
          checkState(NodeUtil.isObjectLitKey(gparent));
          target=gparent;
        }
      }
 else {
        throw new IllegalStateException(""String_Node_Str"" + target);
      }
    }
    checkState(target.isGetProp() || target.isName());
    Node newValue=value.cloneTree();
    target.replaceWith(newValue);
    compiler.reportChangeToEnclosingScope(newValue);
    prop.removeRef(ref);
    newNodes.add(new AstChange(ref.module,ref.scope,ref.node));
  }
}",0.9910277324632952
19254,"/** 
 * For each qualified name N in the global scope, we check if: (a) No ancestor of N is ever aliased or assigned an unknown value type. (If N = ""a.b.c"", ""a"" and ""a.b"" are never aliased). (b) N has exactly one write, and it lives in the global scope. (c) N is aliased in a local scope. (d) N is aliased in global scope <p>If (a) is true, then GlobalNamespace must know all the writes to N. If (a) and (b) are true, then N cannot change during the execution of a local scope. If (a) and (b) and (c) are true, then the alias can be inlined if the alias obeys the usual rules for how we decide whether a variable is inlineable. If (a) and (b) and (d) are true, then inline the alias if possible (if it is assigned exactly once unconditionally). <p>For (a), (b), and (c) are true and the alias is of a constructor, we may also partially inline the alias - i.e. replace some references with the constructor but not all - since constructor properties are always collapsed, so we want to be more aggressive about removing aliases.
 * @see InlineVariables
 */
private void inlineAliases(GlobalNamespace namespace){
  Deque<Name> workList=new ArrayDeque<>(namespace.getNameForest());
  while (!workList.isEmpty()) {
    Name name=workList.pop();
    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {
      continue;
    }
    if (!name.inExterns && name.globalSets == 1 && name.localSets == 0 && name.aliasingGets > 0) {
      List<Ref> refs=new ArrayList<>(name.getRefs());
      for (      Ref ref : refs) {
        Scope hoistScope=ref.scope.getClosestHoistScope();
        if (ref.type == Type.ALIASING_GET && !mayBeGlobalAlias(ref)) {
          if (inlineAliasIfPossible(name,ref,namespace)) {
            name.removeRef(ref);
          }
        }
 else         if (ref.type == Type.ALIASING_GET && hoistScope.isGlobal() && ref.getTwin() == null) {
          if (inlineGlobalAliasIfPossible(name,ref,namespace)) {
            name.removeRef(ref);
          }
        }
      }
    }
    if (!name.inExterns && name.type == Name.Type.CLASS) {
      List<Name> subclasses=name.subclasses;
      if (subclasses != null && name.props != null) {
        for (        Name subclass : subclasses) {
          for (          Name prop : name.props) {
            rewriteAllSubclassInheritedAccesses(name,subclass,prop,namespace);
          }
        }
      }
    }
    if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION) && name.aliasingGets == 0 && name.props != null) {
      workList.addAll(name.props);
    }
  }
}","/** 
 * For each qualified name N in the global scope, we check if: (a) No ancestor of N is ever aliased or assigned an unknown value type. (If N = ""a.b.c"", ""a"" and ""a.b"" are never aliased). (b) N has exactly one write, and it lives in the global scope. (c) N is aliased in a local scope. (d) N is aliased in global scope <p>If (a) is true, then GlobalNamespace must know all the writes to N. If (a) and (b) are true, then N cannot change during the execution of a local scope. If (a) and (b) and (c) are true, then the alias can be inlined if the alias obeys the usual rules for how we decide whether a variable is inlineable. If (a) and (b) and (d) are true, then inline the alias if possible (if it is assigned exactly once unconditionally). <p>For (a), (b), and (c) are true and the alias is of a constructor, we may also partially inline the alias - i.e. replace some references with the constructor but not all - since constructor properties are always collapsed, so we want to be more aggressive about removing aliases.
 * @see InlineVariables
 */
private void inlineAliases(GlobalNamespace namespace){
  Deque<Name> workList=new ArrayDeque<>(namespace.getNameForest());
  while (!workList.isEmpty()) {
    Name name=workList.pop();
    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {
      continue;
    }
    if (!name.inExterns && name.globalSets == 1 && name.localSets == 0 && name.aliasingGets > 0) {
      List<Ref> refs=new ArrayList<>(name.getRefs());
      for (      Ref ref : refs) {
        Scope hoistScope=ref.scope.getClosestHoistScope();
        if (ref.type == Type.ALIASING_GET && !mayBeGlobalAlias(ref)) {
          if (inlineAliasIfPossible(name,ref,namespace)) {
            name.removeRef(ref);
          }
        }
 else         if (ref.type == Type.ALIASING_GET && hoistScope.isGlobal() && ref.getTwin() == null) {
          if (inlineGlobalAliasIfPossible(name,ref,namespace)) {
            name.removeRef(ref);
          }
        }
      }
    }
    if (!name.inExterns && name.type == Name.Type.CLASS) {
      List<Name> subclasses=name.subclasses;
      if (subclasses != null && name.props != null) {
        for (        Name subclass : subclasses) {
          for (          Name prop : name.props) {
            rewriteAllSubclassInheritedAccesses(name,subclass,prop,namespace);
          }
        }
      }
    }
    if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION || name.type == Name.Type.CLASS) && name.aliasingGets == 0 && name.props != null) {
      workList.addAll(name.props);
    }
  }
}",0.9937573156457276
19255,"private boolean inlineAliasIfPossible(Name name,Ref alias,GlobalNamespace namespace){
  Node aliasParent=alias.node.getParent();
  if (aliasParent.isName() || aliasParent.isAssign()) {
    Node aliasLhsNode=aliasParent.isName() ? aliasParent : aliasParent.getFirstChild();
    String aliasVarName=aliasLhsNode.getString();
    Var aliasVar=alias.scope.getVar(aliasVarName);
    checkState(aliasVar != null,""String_Node_Str"",aliasVarName);
    Node aliasDeclarationParent=aliasVar.getParentNode();
    Scope scope=aliasDeclarationParent.isVar() ? alias.scope.getClosestHoistScope() : alias.scope;
    ReferenceCollectingCallback collector=new ReferenceCollectingCallback(compiler,ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,new Es6SyntacticScopeCreator(compiler),Predicates.equalTo(aliasVar));
    collector.processScope(scope);
    ReferenceCollection aliasRefs=collector.getReferences(aliasVar);
    Set<AstChange> newNodes=new LinkedHashSet<>();
    if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration()) {
      if (!aliasRefs.isAssignedOnceInLifetime()) {
        if (name.isConstructor()) {
          boolean accessPropsAfterAliasing=false;
          for (          Reference ref : aliasRefs.references) {
            if (ref.getNode().getParent().isGetProp()) {
              accessPropsAfterAliasing=true;
              break;
            }
          }
          if (accessPropsAfterAliasing) {
            compiler.report(JSError.make(aliasParent,UNSAFE_CTOR_ALIASING,aliasVarName));
          }
        }
        return false;
      }
      int size=aliasRefs.references.size();
      for (int i=1; i < size; i++) {
        Reference aliasRef=aliasRefs.references.get(i);
        newNodes.add(replaceAliasReference(alias,aliasRef));
      }
      aliasParent.replaceChild(alias.node,IR.nullNode());
      codeChanged=true;
      compiler.reportChangeToEnclosingScope(aliasParent);
      namespace.scanNewNodes(newNodes);
      return true;
    }
    if (name.isConstructor()) {
      return partiallyInlineAlias(alias,namespace,aliasRefs,aliasLhsNode);
    }
  }
  return false;
}","private boolean inlineAliasIfPossible(Name name,Ref alias,GlobalNamespace namespace){
  Node aliasParent=alias.node.getParent();
  if (aliasParent.isName() || aliasParent.isAssign()) {
    Node aliasLhsNode=aliasParent.isName() ? aliasParent : aliasParent.getFirstChild();
    String aliasVarName=aliasLhsNode.getString();
    Var aliasVar=alias.scope.getVar(aliasVarName);
    checkState(aliasVar != null,""String_Node_Str"",aliasVarName);
    ReferenceCollectingCallback collector=new ReferenceCollectingCallback(compiler,ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR,new Es6SyntacticScopeCreator(compiler),Predicates.equalTo(aliasVar));
    collector.processScope(aliasVar.getScope());
    ReferenceCollection aliasRefs=collector.getReferences(aliasVar);
    Set<AstChange> newNodes=new LinkedHashSet<>();
    if (aliasRefs.isWellDefined() && aliasRefs.firstReferenceIsAssigningDeclaration()) {
      if (!aliasRefs.isAssignedOnceInLifetime()) {
        if (name.isConstructor()) {
          boolean accessPropsAfterAliasing=false;
          for (          Reference ref : aliasRefs.references) {
            if (ref.getNode().getParent().isGetProp()) {
              accessPropsAfterAliasing=true;
              break;
            }
          }
          if (accessPropsAfterAliasing) {
            compiler.report(JSError.make(aliasParent,UNSAFE_CTOR_ALIASING,aliasVarName));
          }
        }
        return false;
      }
      int size=aliasRefs.references.size();
      for (int i=1; i < size; i++) {
        Reference aliasRef=aliasRefs.references.get(i);
        newNodes.add(replaceAliasReference(alias,aliasRef));
      }
      aliasParent.replaceChild(alias.node,IR.nullNode());
      codeChanged=true;
      compiler.reportChangeToEnclosingScope(aliasParent);
      namespace.scanNewNodes(newNodes);
      return true;
    }
    if (name.isConstructor()) {
      return partiallyInlineAlias(alias,namespace,aliasRefs,aliasLhsNode);
    }
  }
  return false;
}",0.9558428885093926
19256,"/** 
 * @param value The value to use when rewriting.
 * @param depth The chain depth.
 * @param newNodes Expression nodes that have been updated.
 * @param prop The property to rewrite with value.
 */
private void rewriteAliasProp(Node value,int depth,Set<AstChange> newNodes,Name prop){
  rewriteAliasProps(prop,value,depth + 1,newNodes);
  List<Ref> refs=new ArrayList<>(prop.getRefs());
  for (  Ref ref : refs) {
    Node target=ref.node;
    for (int i=0; i <= depth; i++) {
      if (target.isGetProp()) {
        target=target.getFirstChild();
      }
 else       if (NodeUtil.isObjectLitKey(target)) {
        Node gparent=target.getGrandparent();
        if (gparent.isAssign()) {
          target=gparent.getFirstChild();
        }
 else {
          checkState(NodeUtil.isObjectLitKey(gparent));
          target=gparent;
        }
      }
 else {
        throw new IllegalStateException(""String_Node_Str"" + target);
      }
    }
    checkState(target.isGetProp() || target.isName());
    Node newValue=value.cloneTree();
    target.replaceWith(newValue);
    compiler.reportChangeToEnclosingScope(newValue);
    prop.removeRef(ref);
    newNodes.add(new AstChange(ref.module,ref.scope,ref.node));
  }
}","/** 
 * @param value The value to use when rewriting.
 * @param depth The chain depth.
 * @param newNodes Expression nodes that have been updated.
 * @param prop The property to rewrite with value.
 */
private void rewriteAliasProp(Node value,int depth,Set<AstChange> newNodes,Name prop){
  rewriteAliasProps(prop,value,depth + 1,newNodes);
  List<Ref> refs=new ArrayList<>(prop.getRefs());
  for (  Ref ref : refs) {
    Node target=ref.node;
    for (int i=0; i <= depth; i++) {
      if (target.isGetProp()) {
        target=target.getFirstChild();
      }
 else       if (NodeUtil.isObjectLitKey(target)) {
        Node gparent=target.getGrandparent();
        if (gparent.isAssign()) {
          target=gparent.getFirstChild();
        }
 else {
          checkState(NodeUtil.isObjectLitKey(gparent));
          target=gparent;
        }
      }
 else {
        throw new IllegalStateException(""String_Node_Str"" + target);
      }
    }
    checkState(target.isGetProp() || target.isName());
    Node newValue=value.cloneTree();
    target.replaceWith(newValue);
    compiler.reportChangeToEnclosingScope(newValue);
    prop.removeRef(ref);
    newNodes.add(new AstChange(ref.module,ref.scope,ref.node));
    codeChanged=true;
  }
}",0.9910277324632952
19257,"private void safeSetMaybeQualifiedString(Node nameNode,String newString){
  if (!newString.contains(""String_Node_Str"")) {
    safeSetString(nameNode,newString);
    return;
  }
  Node nameParent=nameNode.getParent();
  JSDocInfo jsdoc=nameParent.getJSDocInfo();
switch (nameParent.getToken()) {
case FUNCTION:
case CLASS:
    if (NodeUtil.isStatement(nameParent) && nameParent.getFirstChild() == nameNode) {
      Node statementParent=nameParent.getParent();
      Node placeholder=IR.empty();
      statementParent.replaceChild(nameParent,placeholder);
      Node newStatement=NodeUtil.newQNameDeclaration(compiler,newString,nameParent,jsdoc);
      nameParent.setJSDocInfo(null);
      newStatement.useSourceInfoIfMissingFromForTree(nameParent);
      replaceStringNodeLocationForExportedTopLevelVariable(newStatement,nameNode.getSourcePosition(),nameNode.getLength());
      statementParent.replaceChild(placeholder,newStatement);
      NodeUtil.removeName(nameParent);
      return;
    }
  break;
case VAR:
case LET:
case CONST:
{
  Node rhs=nameNode.hasChildren() ? nameNode.getLastChild().detach() : null;
  Node newStatement=NodeUtil.newQNameDeclaration(compiler,newString,rhs,jsdoc);
  newStatement.useSourceInfoIfMissingFromForTree(nameParent);
  int nameLength=nameNode.getOriginalName() != null ? nameNode.getOriginalName().length() : nameNode.getString().length();
  replaceStringNodeLocationForExportedTopLevelVariable(newStatement,nameNode.getSourcePosition(),nameLength);
  NodeUtil.replaceDeclarationChild(nameNode,newStatement);
  return;
}
case OBJECT_PATTERN:
case ARRAY_PATTERN:
case PARAM_LIST:
throw new RuntimeException(""String_Node_Str"");
default :
break;
}
Node newQualifiedNameNode=NodeUtil.newQName(compiler,newString);
newQualifiedNameNode.srcrefTree(nameNode);
nameParent.replaceChild(nameNode,newQualifiedNameNode);
compiler.reportChangeToEnclosingScope(newQualifiedNameNode);
}","private void safeSetMaybeQualifiedString(Node nameNode,String newString){
  if (!newString.contains(""String_Node_Str"")) {
    safeSetString(nameNode,newString);
    return;
  }
  Node nameParent=nameNode.getParent();
  JSDocInfo jsdoc=nameParent.getJSDocInfo();
switch (nameParent.getToken()) {
case FUNCTION:
case CLASS:
    if (NodeUtil.isStatement(nameParent) && nameParent.getFirstChild() == nameNode) {
      Node statementParent=nameParent.getParent();
      Node placeholder=IR.empty();
      statementParent.replaceChild(nameParent,placeholder);
      Node newStatement=NodeUtil.newQNameDeclaration(compiler,newString,nameParent,jsdoc);
      nameParent.setJSDocInfo(null);
      newStatement.useSourceInfoIfMissingFromForTree(nameParent);
      replaceStringNodeLocationForExportedTopLevelVariable(newStatement,nameNode.getSourcePosition(),nameNode.getLength());
      statementParent.replaceChild(placeholder,newStatement);
      NodeUtil.removeName(nameParent);
      return;
    }
  break;
case VAR:
case LET:
case CONST:
{
  Node rhs=nameNode.hasChildren() ? nameNode.getLastChild().detach() : null;
  Node newStatement=NodeUtil.newQNameDeclaration(compiler,newString,rhs,jsdoc);
  newStatement.useSourceInfoIfMissingFromForTree(nameParent);
  int nameLength=nameNode.getOriginalName() != null ? nameNode.getOriginalName().length() : nameNode.getString().length();
  replaceStringNodeLocationForExportedTopLevelVariable(newStatement,nameNode.getSourcePosition(),nameLength);
  NodeUtil.replaceDeclarationChild(nameNode,newStatement);
  return;
}
case OBJECT_PATTERN:
case ARRAY_PATTERN:
case PARAM_LIST:
throw new RuntimeException(""String_Node_Str"");
default :
break;
}
Node newQualifiedNameNode=NodeUtil.newQName(compiler,newString);
newQualifiedNameNode.srcrefTree(nameNode);
nameParent.replaceChild(nameNode,newQualifiedNameNode);
if (newQualifiedNameNode.getFirstChild() != null) {
newQualifiedNameNode.getFirstChild().makeNonIndexableRecursive();
}
compiler.reportChangeToEnclosingScope(newQualifiedNameNode);
}",0.9624174707973592
19258,"@Override public ObjectTypeI withoutStrayProperties(){
  ObjectType obj=getObjTypeIfSingletonObj();
  NominalType nt=getNominalTypeIfSingletonObj();
  return nt.isLiteralObject() || obj.isPrototypeObject() || obj.isNamespace() ? this : nt.getInstanceAsJSType();
}","@Override public ObjectTypeI withoutStrayProperties(){
  ObjectType obj=getObjTypeIfSingletonObj();
  NominalType nt=getNominalTypeIfSingletonObj();
  if (nt.isLiteralObject()) {
    return this;
  }
  if (obj.isPrototypeObject()) {
    return obj.getOwnerFunction().getInstanceTypeOfCtor().getPrototypeObject();
  }
  if (obj.isNamespace()) {
    return obj.getNamespaceType();
  }
  return nt.getInstanceAsJSType();
}",0.7008797653958945
19259,"private void addNonUnionType(TypeI newType){
  if (skipAmbiguating || invalidatingTypes.isInvalidating(newType)) {
    skipAmbiguating=true;
    return;
  }
  if (!relatedTypes.get(getIntForType(newType))) {
    computeRelatedTypes(newType);
    relatedTypes.or(getRelatedTypesOnNonUnion(newType));
  }
}","private void addNonUnionType(TypeI newType){
  if (skipAmbiguating || invalidatingTypes.isInvalidating(newType)) {
    skipAmbiguating=true;
    return;
  }
  ObjectTypeI maybeObj=newType.toMaybeObjectType();
  if (maybeObj != null) {
    newType=maybeObj.withoutStrayProperties();
  }
  if (!relatedTypes.get(getIntForType(newType))) {
    computeRelatedTypes(newType);
    relatedTypes.or(getRelatedTypesOnNonUnion(newType));
  }
}",0.7924016282225237
19260,"private static boolean canMergeObjectsInJoin(ObjectType obj1,ObjectType obj2){
  if (obj1.isTopObject() || obj2.isTopObject()) {
    return true;
  }
  NominalType nt1=obj1.nominalType;
  NominalType nt2=obj2.nominalType;
  if ((nt1.isBuiltinObject() || nt1.isLiteralObject()) && (nt2.isBuiltinObject() || nt2.isLiteralObject())) {
    return true;
  }
  if (nt1.isBuiltinObject()) {
    return obj1.isLoose && obj2.isSubtypeOf(obj1,SubtypeCache.create());
  }
  if (nt2.isBuiltinObject()) {
    return obj2.isLoose && obj1.isSubtypeOf(obj2,SubtypeCache.create());
  }
  return areRelatedNominalTypes(nt1,nt2) || NominalType.equalRawTypes(nt1,nt2);
}","private static boolean canMergeObjectsInJoin(ObjectType obj1,ObjectType obj2){
  if (obj1.isTopObject() || obj2.isTopObject() || obj1.equals(obj2)) {
    return true;
  }
  NominalType nt1=obj1.nominalType;
  NominalType nt2=obj2.nominalType;
  if (!obj1.isPrototypeObject() && (nt1.isBuiltinObject() || nt1.isLiteralObject()) && !obj2.isPrototypeObject()&& (nt2.isBuiltinObject() || nt2.isLiteralObject())) {
    return true;
  }
  if (nt1.isBuiltinObject()) {
    return obj1.isLoose && obj2.isSubtypeOf(obj1,SubtypeCache.create());
  }
  if (nt2.isBuiltinObject()) {
    return obj2.isLoose && obj1.isSubtypeOf(obj2,SubtypeCache.create());
  }
  return !obj1.isPrototypeObject() && !obj2.isPrototypeObject() && (areRelatedNominalTypes(nt1,nt2) || NominalType.equalRawTypes(nt1,nt2));
}",0.9040333796940194
19261,"Set<JSType> getSubtypesWithProperty(String pname){
  if (mayHaveProp(pname)) {
    if (this.protoProps.containsKey(pname)) {
      return ImmutableSet.of(this.protoObject);
    }
 else {
      return ImmutableSet.of(getInstanceAsJSType());
    }
  }
  HashSet<JSType> typesWithProp=new HashSet<>();
  for (  RawNominalType subtype : this.subtypes) {
    typesWithProp.addAll(subtype.getSubtypesWithProperty(pname));
  }
  return typesWithProp;
}","Set<JSType> getSubtypesWithProperty(String pname){
  if (mayHaveProp(pname)) {
    if (this.protoProps.containsKey(pname)) {
      return ImmutableSet.of(this.protoObject);
    }
    return ImmutableSet.of(getInstanceAsJSType());
  }
  HashSet<JSType> typesWithProp=new HashSet<>();
  for (  RawNominalType subtype : this.subtypes) {
    typesWithProp.addAll(subtype.getSubtypesWithProperty(pname));
  }
  return typesWithProp;
}",0.9176201372997712
19262,"public void testGetAllVars2(){
  String fnString=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  Compiler compiler=new Compiler();
  compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);
  ScopeCreator scopeCreator=new Es6SyntacticScopeCreator(compiler);
  Node ast=parse(fnString);
  Node functionNode=getFunctionNode(fnString);
  Scope globalScope=Scope.createGlobalScope(ast);
  Scope functionScope=scopeCreator.createScope(functionNode,globalScope);
  Map<String,Var> allVariables=new HashMap<>();
  List<Var> orderedVars=new LinkedList<>();
  NodeUtil.getAllVarsDeclaredInFunction(allVariables,orderedVars,compiler,scopeCreator,functionScope);
  Set<String> keySet=new HashSet<>(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  assertEquals(keySet,allVariables.keySet());
}","public void testGetAllVars2(){
  String fnString=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  Compiler compiler=new Compiler();
  compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);
  ScopeCreator scopeCreator=new Es6SyntacticScopeCreator(compiler);
  Node ast=parse(fnString);
  Node functionNode=getFunctionNode(fnString);
  Scope globalScope=Scope.createGlobalScope(ast);
  Scope functionScope=scopeCreator.createScope(functionNode,globalScope);
  Map<String,Var> allVariables=new HashMap<>();
  List<Var> orderedVars=new ArrayList<>();
  NodeUtil.getAllVarsDeclaredInFunction(allVariables,orderedVars,compiler,scopeCreator,functionScope);
  Set<String> keySet=new HashSet<>(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  assertEquals(keySet,allVariables.keySet());
}",0.9940636805180788
19263,"public void testGetAllVars1(){
  String fnString=""String_Node_Str"";
  Compiler compiler=new Compiler();
  compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);
  ScopeCreator scopeCreator=new Es6SyntacticScopeCreator(compiler);
  Node ast=parse(fnString);
  Node functionNode=getFunctionNode(fnString);
  Scope globalScope=Scope.createGlobalScope(ast);
  Scope functionScope=scopeCreator.createScope(functionNode,globalScope);
  Map<String,Var> allVariables=new HashMap<>();
  List<Var> orderedVars=new LinkedList<>();
  NodeUtil.getAllVarsDeclaredInFunction(allVariables,orderedVars,compiler,scopeCreator,functionScope);
  Set<String> keySet=new HashSet<>(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  assertEquals(keySet,allVariables.keySet());
}","public void testGetAllVars1(){
  String fnString=""String_Node_Str"";
  Compiler compiler=new Compiler();
  compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);
  ScopeCreator scopeCreator=new Es6SyntacticScopeCreator(compiler);
  Node ast=parse(fnString);
  Node functionNode=getFunctionNode(fnString);
  Scope globalScope=Scope.createGlobalScope(ast);
  Scope functionScope=scopeCreator.createScope(functionNode,globalScope);
  Map<String,Var> allVariables=new HashMap<>();
  List<Var> orderedVars=new ArrayList<>();
  NodeUtil.getAllVarsDeclaredInFunction(allVariables,orderedVars,compiler,scopeCreator,functionScope);
  Set<String> keySet=new HashSet<>(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  assertEquals(keySet,allVariables.keySet());
}",0.9933694996986135
19264,"private void maybeProcessClassBaseCall(NodeTraversal t,Node n){
  Node callTarget=n.getFirstChild();
  Node baseContainerNode=callTarget.getFirstChild();
  if (!baseContainerNode.isUnscopedQualifiedName()) {
    return;
  }
  String baseContainer=callTarget.getFirstChild().getQualifiedName();
  Node enclosingFnNameNode=getEnclosingDeclNameNode(n);
  if (enclosingFnNameNode == null || !enclosingFnNameNode.isUnscopedQualifiedName()) {
    if (knownClosureSubclasses.contains(baseContainer)) {
      reportBadBaseMethodUse(t,n,baseContainer,""String_Node_Str"");
    }
 else     if (baseUsedInClass(n)) {
      Node clazz=NodeUtil.getEnclosingClass(n);
      if ((clazz.getFirstChild().isName() && clazz.getFirstChild().getString().equals(baseContainer)) || (clazz.getSecondChild().isName() && clazz.getSecondChild().getString().equals(baseContainer))) {
        reportBadGoogBaseUse(t,n,""String_Node_Str"");
      }
    }
    return;
  }
  if (baseUsedInClass(n)) {
    reportBadGoogBaseUse(t,n,""String_Node_Str"");
    return;
  }
  String enclosingQname=enclosingFnNameNode.getQualifiedName();
  if (!enclosingQname.contains(""String_Node_Str"")) {
    if (!enclosingQname.equals(baseContainer)) {
      if (knownClosureSubclasses.contains(baseContainer)) {
        reportBadBaseMethodUse(t,n,baseContainer,""String_Node_Str"" + baseContainer + ""String_Node_Str"");
      }
      return;
    }
    Node enclosingParent=enclosingFnNameNode.getParent();
    Node maybeInheritsExpr=(enclosingParent.isAssign() ? enclosingParent.getParent() : enclosingParent).getNext();
    while (maybeInheritsExpr != null && maybeInheritsExpr.isEmpty()) {
      maybeInheritsExpr=maybeInheritsExpr.getNext();
    }
    Node baseClassNode=null;
    if (maybeInheritsExpr != null && maybeInheritsExpr.isExprResult() && maybeInheritsExpr.getFirstChild().isCall()) {
      Node callNode=maybeInheritsExpr.getFirstChild();
      if (callNode.getFirstChild().matchesQualifiedName(""String_Node_Str"") && callNode.getLastChild().isQualifiedName()) {
        baseClassNode=callNode.getLastChild();
      }
    }
    if (baseClassNode == null) {
      return;
    }
    Node callee=n.getFirstChild();
    Node thisArg=callee.getNext();
    if (thisArg == null || !thisArg.isThis()) {
      reportBadBaseMethodUse(t,n,baseContainer,""String_Node_Str"");
      return;
    }
    Node methodNameNode=thisArg.getNext();
    if (methodNameNode == null || !methodNameNode.isString() || !methodNameNode.getString().equals(""String_Node_Str"")) {
      reportBadBaseMethodUse(t,n,baseContainer,""String_Node_Str"");
      return;
    }
    n.replaceChild(callee,NodeUtil.newQName(compiler,baseClassNode.getQualifiedName() + ""String_Node_Str"",callee,enclosingQname + ""String_Node_Str""));
    n.removeChild(methodNameNode);
    compiler.reportChangeToEnclosingScope(n);
  }
 else {
    if (!knownClosureSubclasses.contains(baseContainer)) {
      return;
    }
    boolean misuseOfBase=!enclosingFnNameNode.getFirstFirstChild().matchesQualifiedName(baseContainer);
    if (misuseOfBase) {
      reportBadBaseMethodUse(t,n,baseContainer,""String_Node_Str"" + baseContainer + ""String_Node_Str"");
      return;
    }
    Node callee=n.getFirstChild();
    Node thisArg=callee.getNext();
    if (thisArg == null || !thisArg.isThis()) {
      reportBadBaseMethodUse(t,n,baseContainer,""String_Node_Str"");
      return;
    }
    Node methodNameNode=thisArg.getNext();
    if (methodNameNode == null || !methodNameNode.isString()) {
      reportBadBaseMethodUse(t,n,baseContainer,""String_Node_Str"");
      return;
    }
    String methodName=methodNameNode.getString();
    String ending=""String_Node_Str"" + methodName;
    if (enclosingQname == null || !enclosingQname.endsWith(ending)) {
      reportBadBaseMethodUse(t,n,baseContainer,""String_Node_Str"" + methodName);
      return;
    }
    Node className=enclosingFnNameNode.getFirstFirstChild();
    n.replaceChild(callee,NodeUtil.newQName(compiler,className.getQualifiedName() + ""String_Node_Str"" + methodName+ ""String_Node_Str"",callee,enclosingQname + ""String_Node_Str""));
    n.removeChild(methodNameNode);
    compiler.reportChangeToEnclosingScope(n);
  }
}","private void maybeProcessClassBaseCall(NodeTraversal t,Node n){
  Node callTarget=n.getFirstChild();
  Node baseContainerNode=callTarget.getFirstChild();
  if (!baseContainerNode.isUnscopedQualifiedName()) {
    return;
  }
  String baseContainer=callTarget.getFirstChild().getQualifiedName();
  Node enclosingFnNameNode=getEnclosingDeclNameNode(n);
  if (enclosingFnNameNode == null || !enclosingFnNameNode.isUnscopedQualifiedName()) {
    if (knownClosureSubclasses.contains(baseContainer)) {
      reportBadBaseMethodUse(t,n,baseContainer,""String_Node_Str"");
    }
 else     if (baseUsedInClass(n)) {
      Node clazz=NodeUtil.getEnclosingClass(n);
      if ((clazz.getFirstChild().isName() && clazz.getFirstChild().getString().equals(baseContainer)) || (clazz.getSecondChild().isName() && clazz.getSecondChild().getString().equals(baseContainer))) {
        reportBadBaseMethodUse(t,n,clazz.getFirstChild().getString(),""String_Node_Str"");
      }
    }
    return;
  }
  if (baseUsedInClass(n)) {
    reportBadGoogBaseUse(t,n,""String_Node_Str"");
    return;
  }
  String enclosingQname=enclosingFnNameNode.getQualifiedName();
  if (!enclosingQname.contains(""String_Node_Str"")) {
    if (!enclosingQname.equals(baseContainer)) {
      if (knownClosureSubclasses.contains(baseContainer)) {
        reportBadBaseMethodUse(t,n,baseContainer,""String_Node_Str"" + baseContainer + ""String_Node_Str"");
      }
      return;
    }
    Node enclosingParent=enclosingFnNameNode.getParent();
    Node maybeInheritsExpr=(enclosingParent.isAssign() ? enclosingParent.getParent() : enclosingParent).getNext();
    while (maybeInheritsExpr != null && maybeInheritsExpr.isEmpty()) {
      maybeInheritsExpr=maybeInheritsExpr.getNext();
    }
    Node baseClassNode=null;
    if (maybeInheritsExpr != null && maybeInheritsExpr.isExprResult() && maybeInheritsExpr.getFirstChild().isCall()) {
      Node callNode=maybeInheritsExpr.getFirstChild();
      if (callNode.getFirstChild().matchesQualifiedName(""String_Node_Str"") && callNode.getLastChild().isQualifiedName()) {
        baseClassNode=callNode.getLastChild();
      }
    }
    if (baseClassNode == null) {
      return;
    }
    Node callee=n.getFirstChild();
    Node thisArg=callee.getNext();
    if (thisArg == null || !thisArg.isThis()) {
      reportBadBaseMethodUse(t,n,baseContainer,""String_Node_Str"");
      return;
    }
    Node methodNameNode=thisArg.getNext();
    if (methodNameNode == null || !methodNameNode.isString() || !methodNameNode.getString().equals(""String_Node_Str"")) {
      reportBadBaseMethodUse(t,n,baseContainer,""String_Node_Str"");
      return;
    }
    n.replaceChild(callee,NodeUtil.newQName(compiler,baseClassNode.getQualifiedName() + ""String_Node_Str"",callee,enclosingQname + ""String_Node_Str""));
    n.removeChild(methodNameNode);
    compiler.reportChangeToEnclosingScope(n);
  }
 else {
    if (!knownClosureSubclasses.contains(baseContainer)) {
      return;
    }
    boolean misuseOfBase=!enclosingFnNameNode.getFirstFirstChild().matchesQualifiedName(baseContainer);
    if (misuseOfBase) {
      reportBadBaseMethodUse(t,n,baseContainer,""String_Node_Str"" + baseContainer + ""String_Node_Str"");
      return;
    }
    Node callee=n.getFirstChild();
    Node thisArg=callee.getNext();
    if (thisArg == null || !thisArg.isThis()) {
      reportBadBaseMethodUse(t,n,baseContainer,""String_Node_Str"");
      return;
    }
    Node methodNameNode=thisArg.getNext();
    if (methodNameNode == null || !methodNameNode.isString()) {
      reportBadBaseMethodUse(t,n,baseContainer,""String_Node_Str"");
      return;
    }
    String methodName=methodNameNode.getString();
    String ending=""String_Node_Str"" + methodName;
    if (enclosingQname == null || !enclosingQname.endsWith(ending)) {
      reportBadBaseMethodUse(t,n,baseContainer,""String_Node_Str"" + methodName);
      return;
    }
    Node className=enclosingFnNameNode.getFirstFirstChild();
    n.replaceChild(callee,NodeUtil.newQName(compiler,className.getQualifiedName() + ""String_Node_Str"" + methodName+ ""String_Node_Str"",callee,enclosingQname + ""String_Node_Str""));
    n.removeChild(methodNameNode);
    compiler.reportChangeToEnclosingScope(n);
  }
}",0.9947305389221556
19265,"public void testInvalidGoogBase14(){
  testError(""String_Node_Str"",GOOG_BASE_CLASS_ERROR);
}","public void testInvalidGoogBase14(){
  testError(""String_Node_Str"",BASE_CLASS_ERROR);
}",0.9720670391061452
19266,"public void testInvalidGoogBase14b(){
  testError(""String_Node_Str"",GOOG_BASE_CLASS_ERROR);
}","public void testInvalidGoogBase14b(){
  testError(""String_Node_Str"",BASE_CLASS_ERROR);
}",0.9723756906077348
19267,"private void visitNamespacePropertyDeclaration(Node declNode,Node recv,String pname){
  checkArgument(declNode.isGetProp() || NodeUtil.isObjLitProperty(declNode),declNode);
  checkArgument(currentScope.isNamespace(recv));
  if (declNode.isGetterDef()) {
    pname=getCommonTypes().createGetterPropName(pname);
  }
 else   if (declNode.isSetterDef()) {
    pname=getCommonTypes().createSetterPropName(pname);
  }
  if (declNode.isStringKey() && currentScope.isNamespace(declNode.getFirstChild())) {
    return;
  }
  EnumType et=currentScope.getEnum(QualifiedName.fromNode(recv));
  if (et != null && et.enumLiteralHasKey(pname)) {
    return;
  }
  Namespace ns=currentScope.getNamespace(QualifiedName.fromNode(recv));
  JSDocInfo jsdoc=NodeUtil.getBestJSDocInfo(declNode);
  PropertyType pt=getPropTypeHelper(jsdoc,declNode,null);
  JSType propDeclType=pt.declType;
  JSType propInferredFunType=pt.inferredFunType;
  boolean isConst=isConst(declNode);
  if (propDeclType != null || isConst) {
    JSType previousPropType=ns.getPropDeclaredType(pname);
    if (ns.hasSubnamespace(new QualifiedName(pname)) || (ns.hasStaticProp(pname) && previousPropType != null && !suppressDupPropWarning(jsdoc,propDeclType,previousPropType))) {
      warnings.add(JSError.make(declNode,REDECLARED_PROPERTY,pname,""String_Node_Str"" + ns));
      declNode.getParent().putBooleanProp(Node.ANALYZED_DURING_GTI,true);
      return;
    }
    if (propDeclType == null) {
      propDeclType=mayInferFromRhsIfConst(declNode);
    }
    ns.addProperty(pname,declNode,propDeclType,isConst);
    declNode.putBooleanProp(Node.ANALYZED_DURING_GTI,true);
    if (declNode.isGetProp() && isConst) {
      declNode.putBooleanProp(Node.CONSTANT_PROPERTY_DEF,true);
    }
  }
 else   if (propInferredFunType != null) {
    ns.addUndeclaredProperty(pname,declNode,propInferredFunType,false);
  }
 else {
    Node initializer=NodeUtil.getRValueOfLValue(declNode);
    JSType t=initializer == null ? null : simpleInferExprType(initializer);
    if (t == null) {
      t=getCommonTypes().UNKNOWN;
    }
    ns.addUndeclaredProperty(pname,declNode,t,false);
  }
}","private void visitNamespacePropertyDeclaration(Node declNode,Node recv,String pname){
  checkArgument(declNode.isGetProp() || NodeUtil.isObjLitProperty(declNode),declNode);
  checkArgument(currentScope.isNamespace(recv));
  if (declNode.isGetterDef()) {
    pname=getCommonTypes().createGetterPropName(pname);
  }
 else   if (declNode.isSetterDef()) {
    pname=getCommonTypes().createSetterPropName(pname);
  }
  if (declNode.isStringKey() && currentScope.isNamespace(declNode.getFirstChild())) {
    return;
  }
  EnumType et=currentScope.getEnum(QualifiedName.fromNode(recv));
  if (et != null && et.enumLiteralHasKey(pname)) {
    return;
  }
  Namespace ns=currentScope.getNamespace(QualifiedName.fromNode(recv));
  JSDocInfo jsdoc=NodeUtil.getBestJSDocInfo(declNode);
  PropertyType pt=getPropTypeHelper(jsdoc,declNode,null);
  JSType propDeclType=pt.declType;
  JSType propInferredFunType=pt.inferredFunType;
  boolean isConst=isConst(declNode);
  if (propDeclType != null || isConst) {
    JSType previousPropType=ns.getPropDeclaredType(pname);
    declNode.putBooleanProp(Node.ANALYZED_DURING_GTI,true);
    if (ns.hasSubnamespace(new QualifiedName(pname)) || (ns.hasStaticProp(pname) && previousPropType != null && !suppressDupPropWarning(jsdoc,propDeclType,previousPropType))) {
      warnings.add(JSError.make(declNode,REDECLARED_PROPERTY,pname,""String_Node_Str"" + ns));
      declNode.getParent().putBooleanProp(Node.ANALYZED_DURING_GTI,true);
      return;
    }
    if (propDeclType == null) {
      propDeclType=mayInferFromRhsIfConst(declNode);
    }
    ns.addProperty(pname,declNode,propDeclType,isConst);
    if (declNode.isGetProp() && isConst) {
      declNode.putBooleanProp(Node.CONSTANT_PROPERTY_DEF,true);
    }
  }
 else   if (propInferredFunType != null) {
    ns.addUndeclaredProperty(pname,declNode,propInferredFunType,false);
  }
 else {
    Node initializer=NodeUtil.getRValueOfLValue(declNode);
    JSType t=initializer == null ? null : simpleInferExprType(initializer);
    if (t == null) {
      t=getCommonTypes().UNKNOWN;
    }
    ns.addUndeclaredProperty(pname,declNode,t,false);
  }
}",0.9717514124293786
19268,"private void analyzeFunctionFwd(NTIWorkset workset){
  for (  DiGraphNode<Node,ControlFlowGraph.Branch> dn : workset.forward()) {
    Node n=dn.getValue();
    Node parent=n.getParent();
    checkState(n != null,""String_Node_Str"");
    TypeEnv inEnv=getInEnv(dn);
    TypeEnv outEnv=null;
    if (parent.isScript() || (parent.isNormalBlock() && parent.getParent().isFunction())) {
      inEnv=inEnv.clearChangeLog();
    }
    println(""String_Node_Str"",n);
    println(""String_Node_Str"",inEnv);
    boolean conditional=false;
switch (n.getToken()) {
case BLOCK:
case ROOT:
case BREAK:
case CONTINUE:
case DEFAULT_CASE:
case DEBUGGER:
case EMPTY:
case FUNCTION:
case SCRIPT:
case TRY:
case WITH:
      outEnv=inEnv;
    break;
case CATCH:
  String catchVarname=n.getFirstChild().getString();
outEnv=envPutType(inEnv,catchVarname,UNKNOWN);
break;
case EXPR_RESULT:
println(""String_Node_Str"",n.getFirstChild().getToken());
if (n.getBooleanProp(Node.ANALYZED_DURING_GTI)) {
n.removeProp(Node.ANALYZED_DURING_GTI);
outEnv=inEnv;
}
 else {
outEnv=analyzeExprFwd(n.getFirstChild(),inEnv,UNKNOWN).env;
}
break;
case RETURN:
outEnv=analyzeReturnFwd(n,inEnv);
break;
case DO:
case IF:
case FOR:
case WHILE:
conditional=true;
analyzeConditionalStmFwd(dn,NodeUtil.getConditionExpression(n),inEnv);
break;
case FOR_IN:
outEnv=analyzeForInFwd(n,inEnv);
break;
case FOR_OF:
outEnv=analyzeForOfFwd(n,inEnv);
break;
case CASE:
{
conditional=true;
analyzeConditionalStmFwd(dn,n,inEnv);
break;
}
case VAR:
outEnv=inEnv;
if (NodeUtil.isTypedefDecl(n)) {
break;
}
for (Node nameNode : n.children()) {
outEnv=analyzeVarDeclFwd(nameNode,outEnv);
}
break;
case SWITCH:
outEnv=analyzeExprFwd(n.getFirstChild(),inEnv).env;
break;
case THROW:
{
outEnv=analyzeExprFwd(n.getFirstChild(),inEnv).env;
exitEnvs.add(outEnv);
break;
}
default :
if (NodeUtil.isStatement(n)) {
throw new RuntimeException(""String_Node_Str"" + n.getToken());
}
 else {
outEnv=analyzeExprFwd(n,inEnv,UNKNOWN).env;
break;
}
}
if (!conditional) {
println(""String_Node_Str"",outEnv);
setOutEnv(dn,outEnv);
}
}
}","private void analyzeFunctionFwd(NTIWorkset workset){
  for (  DiGraphNode<Node,ControlFlowGraph.Branch> dn : workset.forward()) {
    Node n=dn.getValue();
    Node parent=n.getParent();
    checkState(n != null,""String_Node_Str"");
    TypeEnv inEnv=getInEnv(dn);
    TypeEnv outEnv=null;
    if (parent.isScript() || (parent.isNormalBlock() && parent.getParent().isFunction())) {
      inEnv=inEnv.clearChangeLog();
    }
    println(""String_Node_Str"",n);
    println(""String_Node_Str"",inEnv);
    boolean conditional=false;
switch (n.getToken()) {
case BLOCK:
case ROOT:
case BREAK:
case CONTINUE:
case DEFAULT_CASE:
case DEBUGGER:
case EMPTY:
case FUNCTION:
case SCRIPT:
case TRY:
case WITH:
      outEnv=inEnv;
    break;
case CATCH:
  Node catchVar=n.getFirstChild();
String catchVarname=catchVar.getString();
outEnv=envPutType(inEnv,catchVarname,UNKNOWN);
maybeSetTypeI(catchVar,UNKNOWN);
break;
case EXPR_RESULT:
println(""String_Node_Str"",n.getFirstChild().getToken());
if (n.getBooleanProp(Node.ANALYZED_DURING_GTI)) {
n.removeProp(Node.ANALYZED_DURING_GTI);
outEnv=inEnv;
}
 else {
outEnv=analyzeExprFwd(n.getFirstChild(),inEnv,UNKNOWN).env;
}
break;
case RETURN:
outEnv=analyzeReturnFwd(n,inEnv);
break;
case DO:
case IF:
case FOR:
case WHILE:
conditional=true;
analyzeConditionalStmFwd(dn,NodeUtil.getConditionExpression(n),inEnv);
break;
case FOR_IN:
outEnv=analyzeForInFwd(n,inEnv);
break;
case FOR_OF:
outEnv=analyzeForOfFwd(n,inEnv);
break;
case CASE:
{
conditional=true;
analyzeConditionalStmFwd(dn,n,inEnv);
break;
}
case VAR:
outEnv=inEnv;
if (NodeUtil.isTypedefDecl(n)) {
maybeSetTypeI(n.getFirstChild(),UNDEFINED);
break;
}
for (Node nameNode : n.children()) {
outEnv=analyzeVarDeclFwd(nameNode,outEnv);
}
break;
case SWITCH:
outEnv=analyzeExprFwd(n.getFirstChild(),inEnv).env;
break;
case THROW:
{
outEnv=analyzeExprFwd(n.getFirstChild(),inEnv).env;
exitEnvs.add(outEnv);
break;
}
default :
if (NodeUtil.isStatement(n)) {
throw new RuntimeException(""String_Node_Str"" + n.getToken());
}
 else {
outEnv=analyzeExprFwd(n,inEnv,UNKNOWN).env;
break;
}
}
if (!conditional) {
println(""String_Node_Str"",outEnv);
setOutEnv(dn,outEnv);
}
}
}",0.953128717582679
19269,"private EnvTypePair analyzePropertyTestCallFwd(Node call,TypeEnv inEnv,JSType specializedType){
  return analyzeTypePredicate(call,call.getFirstChild().getLastChild().getString(),inEnv,specializedType);
}","private EnvTypePair analyzePropertyTestCallFwd(Node call,TypeEnv inEnv,JSType specializedType){
  analyzeExprFwdIgnoreResult(call.getFirstChild(),inEnv);
  return analyzeTypePredicate(call,call.getFirstChild().getLastChild().getString(),inEnv,specializedType);
}",0.8755364806866953
19270,"private EnvTypePair analyzeTypePredicate(Node call,String typeHint,TypeEnv inEnv,JSType specializedType){
  int numArgs=call.getChildCount() - 1;
  if (numArgs != 1) {
    warnings.add(JSError.make(call,WRONG_ARGUMENT_COUNT,call.getFirstChild().getQualifiedName(),Integer.toString(numArgs),""String_Node_Str"",""String_Node_Str""));
    return analyzeInvocationArgsFwdWhenError(call,inEnv);
  }
  EnvTypePair pair=analyzeExprFwd(call.getLastChild(),inEnv);
  if (specializedType.isTrueOrTruthy() || specializedType.isFalseOrFalsy()) {
    pair=analyzeExprFwd(call.getLastChild(),inEnv,UNKNOWN,predicateTransformType(typeHint,specializedType,pair.type));
  }
  pair.type=BOOLEAN;
  return pair;
}","private EnvTypePair analyzeTypePredicate(Node call,String typeHint,TypeEnv inEnv,JSType specializedType){
  analyzeExprFwdIgnoreResult(call.getFirstChild(),inEnv);
  int numArgs=call.getChildCount() - 1;
  if (numArgs != 1) {
    warnings.add(JSError.make(call,WRONG_ARGUMENT_COUNT,call.getFirstChild().getQualifiedName(),Integer.toString(numArgs),""String_Node_Str"",""String_Node_Str""));
    return analyzeInvocationArgsFwdWhenError(call,inEnv);
  }
  EnvTypePair pair=analyzeExprFwd(call.getLastChild(),inEnv);
  if (specializedType.isTrueOrTruthy() || specializedType.isFalseOrFalsy()) {
    pair=analyzeExprFwd(call.getLastChild(),inEnv,UNKNOWN,predicateTransformType(typeHint,specializedType,pair.type));
  }
  pair.type=BOOLEAN;
  return pair;
}",0.9597222222222224
19271,"private EnvTypePair analyzeIncDecFwd(Node expr,TypeEnv inEnv,JSType requiredType){
  mayWarnAboutConst(expr);
  Node ch=expr.getFirstChild();
  if (ch.isGetProp() || (ch.isGetElem() && ch.getLastChild().isString())) {
    Node recv=ch.getFirstChild();
    String pname=ch.getLastChild().getString();
    EnvTypePair pair=analyzeExprFwd(recv,inEnv);
    JSType recvType=pair.type;
    if (mayWarnAboutConstProp(ch,recvType,new QualifiedName(pname))) {
      pair.type=requiredType;
      return pair;
    }
  }
  return analyzeUnaryNumFwd(expr,inEnv);
}","private EnvTypePair analyzeIncDecFwd(Node expr,TypeEnv inEnv,JSType requiredType){
  mayWarnAboutConst(expr);
  Node ch=expr.getFirstChild();
  if (ch.isGetProp() || (ch.isGetElem() && ch.getLastChild().isString())) {
    Node recv=ch.getFirstChild();
    String pname=ch.getLastChild().getString();
    EnvTypePair pair=analyzeExprFwd(recv,inEnv);
    JSType recvType=pair.type;
    if (mayWarnAboutConstProp(ch,recvType,new QualifiedName(pname))) {
      maybeSetTypeI(ch,recvType.getProp(new QualifiedName(pname)));
      pair.type=requiredType;
      return pair;
    }
  }
  return analyzeUnaryNumFwd(expr,inEnv);
}",0.9419795221843004
19272,"private EnvTypePair analyzeAssertionCall(Node callNode,TypeEnv env,AssertionFunctionSpec assertionFunctionSpec){
  Node firstParam=callNode.getSecondChild();
  if (firstParam == null) {
    return new EnvTypePair(env,UNKNOWN);
  }
  Node assertedNode=assertionFunctionSpec.getAssertedParam(firstParam);
  if (assertedNode == null) {
    return new EnvTypePair(env,UNKNOWN);
  }
  JSType assertedType=assertionFunctionSpec.getAssertedNewType(callNode,currentScope);
  if (assertedType.isUnknown()) {
    warnings.add(JSError.make(callNode,UNKNOWN_ASSERTION_TYPE));
  }
  EnvTypePair pair=analyzeExprFwd(assertedNode,env,UNKNOWN,assertedType);
  boolean haveCommonSubtype=JSType.haveCommonSubtype(assertedType,pair.type);
  if (!pair.type.isSubtypeOf(assertedType) && haveCommonSubtype) {
    pair.type=assertedType;
  }
  if (!haveCommonSubtype) {
    JSType t=analyzeExprFwd(assertedNode,env).type.substituteGenericsWithUnknown();
    if (t.isSubtypeOf(assertedType)) {
      pair.type=t;
    }
 else {
      if (!firstParam.isFalse()) {
        warnings.add(JSError.make(assertedNode,ASSERT_FALSE));
      }
      pair.type=UNKNOWN;
      pair.env=env;
    }
  }
  return pair;
}","private EnvTypePair analyzeAssertionCall(Node callNode,TypeEnv env,AssertionFunctionSpec assertionFunctionSpec){
  analyzeExprFwdIgnoreResult(callNode.getFirstChild(),env);
  Node firstParam=callNode.getSecondChild();
  if (firstParam == null) {
    return new EnvTypePair(env,UNKNOWN);
  }
  for (  Node assertionArgument : firstParam.siblings()) {
    analyzeExprFwdIgnoreResult(assertionArgument,env);
  }
  Node assertedNode=assertionFunctionSpec.getAssertedParam(firstParam);
  if (assertedNode == null) {
    return new EnvTypePair(env,UNKNOWN);
  }
  JSType assertedType=assertionFunctionSpec.getAssertedNewType(callNode,currentScope);
  if (assertedType.isUnknown()) {
    warnings.add(JSError.make(callNode,UNKNOWN_ASSERTION_TYPE));
  }
  EnvTypePair pair=analyzeExprFwd(assertedNode,env,UNKNOWN,assertedType);
  boolean haveCommonSubtype=JSType.haveCommonSubtype(assertedType,pair.type);
  if (!pair.type.isSubtypeOf(assertedType) && haveCommonSubtype) {
    pair.type=assertedType;
  }
  if (!haveCommonSubtype) {
    JSType t=analyzeExprFwd(assertedNode,env).type.substituteGenericsWithUnknown();
    if (t.isSubtypeOf(assertedType)) {
      pair.type=t;
    }
 else {
      if (!firstParam.isFalse()) {
        warnings.add(JSError.make(assertedNode,ASSERT_FALSE));
      }
      pair.type=UNKNOWN;
      pair.env=env;
    }
  }
  return pair;
}",0.9038613081166272
19273,"/** 
 * This method processes a single variable declaration in a VAR statement, in the forward phase of the analysis.
 */
private TypeEnv analyzeVarDeclFwd(Node nameNode,TypeEnv inEnv){
  String varName=nameNode.getString();
  JSType declType=this.currentScope.getDeclaredTypeOf(varName);
  if (this.currentScope.isLocalFunDef(varName)) {
    return inEnv;
  }
  Node rhs=nameNode.getFirstChild();
  if (NodeUtil.isNamespaceDecl(nameNode) || (GlobalTypeInfoCollector.isCtorDefinedByCall(nameNode) && !isFunctionBind(rhs.getFirstChild(),inEnv,true)) || nameNode.getParent().getBooleanProp(Node.ANALYZED_DURING_GTI)) {
    Preconditions.checkNotNull(declType,""String_Node_Str"",nameNode);
    maybeSetTypeI(nameNode,declType);
    return envPutType(inEnv,varName,declType);
  }
  TypeEnv outEnv=inEnv;
  JSType rhsType=null;
  if (rhs != null) {
    EnvTypePair pair=analyzeExprFwd(rhs,inEnv,firstNonNull(declType,UNKNOWN));
    outEnv=pair.env;
    rhsType=pair.type;
    if (declType != null) {
      if (rhsType.isSubtypeOf(declType)) {
        registerImplicitUses(rhs,rhsType,declType);
      }
 else {
        registerMismatchAndWarn(JSError.make(rhs,MISTYPED_ASSIGN_RHS,errorMsgWithTypeDiff(declType,rhsType)),rhsType,declType);
      }
    }
  }
  JSType varType=rhsType;
  if (rhs == null) {
    varType=UNDEFINED;
  }
 else   if (declType != null) {
    JSDocInfo jsdoc=NodeUtil.getBestJSDocInfo(nameNode);
    if (jsdoc != null && (!jsdoc.hasConstAnnotation() || jsdoc.hasType())) {
      varType=declType;
    }
  }
  maybeSetTypeI(nameNode,varType);
  return envPutType(outEnv,varName,varType);
}","/** 
 * This method processes a single variable declaration in a VAR statement, in the forward phase of the analysis.
 */
private TypeEnv analyzeVarDeclFwd(Node nameNode,TypeEnv inEnv){
  String varName=nameNode.getString();
  JSType declType=this.currentScope.getDeclaredTypeOf(varName);
  if (this.currentScope.isLocalFunDef(varName)) {
    return inEnv;
  }
  Node rhs=nameNode.getFirstChild();
  if (NodeUtil.isNamespaceDecl(nameNode) || (GlobalTypeInfoCollector.isCtorDefinedByCall(nameNode) && !isFunctionBind(rhs.getFirstChild(),inEnv,true)) || nameNode.getParent().getBooleanProp(Node.ANALYZED_DURING_GTI)) {
    Preconditions.checkNotNull(declType,""String_Node_Str"",nameNode);
    maybeSetTypeI(nameNode,declType);
    maybeSetTypeI(rhs,declType);
    return envPutType(inEnv,varName,declType);
  }
  TypeEnv outEnv=inEnv;
  JSType rhsType=null;
  if (rhs != null) {
    EnvTypePair pair=analyzeExprFwd(rhs,inEnv,firstNonNull(declType,UNKNOWN));
    outEnv=pair.env;
    rhsType=pair.type;
    if (declType != null) {
      if (rhsType.isSubtypeOf(declType)) {
        registerImplicitUses(rhs,rhsType,declType);
      }
 else {
        registerMismatchAndWarn(JSError.make(rhs,MISTYPED_ASSIGN_RHS,errorMsgWithTypeDiff(declType,rhsType)),rhsType,declType);
      }
    }
  }
  JSType varType=rhsType;
  if (rhs == null) {
    varType=UNDEFINED;
  }
 else   if (declType != null) {
    JSDocInfo jsdoc=NodeUtil.getBestJSDocInfo(nameNode);
    if (jsdoc != null && (!jsdoc.hasConstAnnotation() || jsdoc.hasType())) {
      varType=declType;
    }
  }
  maybeSetTypeI(nameNode,varType);
  return envPutType(outEnv,varName,varType);
}",0.9898305084745764
19274,"private boolean isFunctionBind(Node expr,TypeEnv env,boolean isFwd){
  if (NodeUtil.isFunctionBind(expr)) {
    return true;
  }
  if (!expr.isGetProp() || !expr.isQualifiedName() || !expr.getLastChild().getString().equals(""String_Node_Str"")) {
    return false;
  }
  Node recv=expr.getFirstChild();
  JSType recvType=isFwd ? analyzeExprFwd(recv,env).type : analyzeExprBwd(recv,env).type;
  return !recvType.isUnknown() && recvType.isSubtypeOf(commonTypes.topFunction());
}","private boolean isFunctionBind(Node callee,TypeEnv env,boolean isFwd){
  if (NodeUtil.isFunctionBind(callee)) {
    if (isFwd) {
      analyzeExprFwdIgnoreResult(callee,env);
    }
    return true;
  }
  if (!callee.isGetProp() || !callee.isQualifiedName() || !callee.getLastChild().getString().equals(""String_Node_Str"")) {
    return false;
  }
  Node recv=callee.getFirstChild();
  JSType recvType;
  if (isFwd) {
    recvType=analyzeExprFwd(recv,env).type;
    maybeSetTypeI(callee,recvType.getProp(new QualifiedName(""String_Node_Str"")));
  }
 else {
    recvType=analyzeExprBwd(recv,env).type;
  }
  return !recvType.isUnknown() && recvType.isSubtypeOf(commonTypes.topFunction());
}",0.7241379310344828
19275,"private LValueResultFwd analyzeLValueFwd(Node expr,TypeEnv inEnv,JSType requiredType,boolean insideQualifiedName){
  LValueResultFwd lvalResult=null;
switch (expr.getToken()) {
case THIS:
{
      mayWarnAboutGlobalThis(expr);
      if (this.currentScope.hasThis()) {
        lvalResult=new LValueResultFwd(inEnv,envGetType(inEnv,THIS_ID),this.currentScope.getDeclaredTypeOf(THIS_ID),new QualifiedName(THIS_ID));
      }
 else {
        lvalResult=new LValueResultFwd(inEnv,UNKNOWN,null,null);
      }
      break;
    }
case NAME:
{
    String varName=expr.getString();
    JSType varType=analyzeExprFwd(expr,inEnv).type;
    lvalResult=new LValueResultFwd(inEnv,varType,this.currentScope.getDeclaredTypeOf(varName),varType.hasNonScalar() ? new QualifiedName(varName) : null);
    break;
  }
case GETPROP:
case GETELEM:
{
  Node obj=expr.getFirstChild();
  Node prop=expr.getLastChild();
  QualifiedName pname=expr.isGetProp() || prop.isString() ? new QualifiedName(prop.getString()) : null;
  LValueResultFwd recvLvalue=analyzeReceiverLvalFwd(obj,pname,inEnv,requiredType);
  if (!recvLvalue.type.isSubtypeOf(TOP_OBJECT)) {
    EnvTypePair pair=analyzeExprFwd(prop,recvLvalue.env,requiredType);
    lvalResult=new LValueResultFwd(pair.env,requiredType,null,null);
    break;
  }
  JSType indexType=recvLvalue.type.getIndexType();
  if (expr.isGetElem() && indexType != null) {
    lvalResult=analyzeIObjectElmLvalFwd(prop,recvLvalue,indexType);
    break;
  }
  if (expr.isGetProp() || prop.isString()) {
    lvalResult=analyzePropLValFwd(obj,pname,recvLvalue,requiredType,insideQualifiedName);
    break;
  }
  EnvTypePair pair=analyzeExprFwd(expr,recvLvalue.env,requiredType);
  lvalResult=new LValueResultFwd(pair.env,pair.type,null,null);
  break;
}
case VAR:
{
checkState(expr.getParent().isForIn() || expr.getParent().isForOf());
Node vdecl=expr.getFirstChild();
String name=vdecl.getString();
checkState(!vdecl.hasChildren());
if (expr.getParent().isForIn()) {
  return new LValueResultFwd(inEnv,STRING,null,new QualifiedName(name));
}
 else {
  JSType declType=this.currentScope.getDeclaredTypeOf(name);
  return new LValueResultFwd(inEnv,requiredType,declType,new QualifiedName(name));
}
}
default :
{
checkState(insideQualifiedName);
EnvTypePair pair=analyzeExprFwd(expr,inEnv,requiredType);
return new LValueResultFwd(pair.env,pair.type,null,null);
}
}
maybeSetTypeI(expr,lvalResult.type);
mayWarnAboutUnknownType(expr,lvalResult.type);
return lvalResult;
}","private LValueResultFwd analyzeLValueFwd(Node expr,TypeEnv inEnv,JSType requiredType,boolean insideQualifiedName){
  LValueResultFwd lvalResult=null;
switch (expr.getToken()) {
case THIS:
{
      mayWarnAboutGlobalThis(expr);
      if (this.currentScope.hasThis()) {
        lvalResult=new LValueResultFwd(inEnv,envGetType(inEnv,THIS_ID),this.currentScope.getDeclaredTypeOf(THIS_ID),new QualifiedName(THIS_ID));
      }
 else {
        lvalResult=new LValueResultFwd(inEnv,UNKNOWN,null,null);
      }
      break;
    }
case NAME:
{
    String varName=expr.getString();
    JSType varType=analyzeExprFwd(expr,inEnv).type;
    lvalResult=new LValueResultFwd(inEnv,varType,this.currentScope.getDeclaredTypeOf(varName),varType.hasNonScalar() ? new QualifiedName(varName) : null);
    break;
  }
case GETPROP:
case GETELEM:
{
  Node obj=expr.getFirstChild();
  Node prop=expr.getLastChild();
  QualifiedName pname=expr.isGetProp() || prop.isString() ? new QualifiedName(prop.getString()) : null;
  LValueResultFwd recvLvalue=analyzeReceiverLvalFwd(obj,pname,inEnv,requiredType);
  if (!recvLvalue.type.isSubtypeOf(TOP_OBJECT)) {
    EnvTypePair pair=analyzeExprFwd(prop,recvLvalue.env,requiredType);
    lvalResult=new LValueResultFwd(pair.env,requiredType,null,null);
    break;
  }
  JSType indexType=recvLvalue.type.getIndexType();
  if (expr.isGetElem() && indexType != null) {
    lvalResult=analyzeIObjectElmLvalFwd(prop,recvLvalue,indexType);
    break;
  }
  if (expr.isGetProp() || prop.isString()) {
    lvalResult=analyzePropLValFwd(obj,pname,recvLvalue,requiredType,insideQualifiedName);
    break;
  }
  EnvTypePair pair=analyzeExprFwd(expr,recvLvalue.env,requiredType);
  lvalResult=new LValueResultFwd(pair.env,pair.type,null,null);
  break;
}
case VAR:
{
checkState(expr.getParent().isForIn() || expr.getParent().isForOf());
Node nameNode=expr.getFirstChild();
String name=nameNode.getString();
checkState(!nameNode.hasChildren());
maybeSetTypeI(nameNode,requiredType);
if (expr.getParent().isForIn()) {
  return new LValueResultFwd(inEnv,STRING,null,new QualifiedName(name));
}
 else {
  JSType declType=this.currentScope.getDeclaredTypeOf(name);
  return new LValueResultFwd(inEnv,requiredType,declType,new QualifiedName(name));
}
}
default :
{
checkState(insideQualifiedName);
EnvTypePair pair=analyzeExprFwd(expr,inEnv,requiredType);
return new LValueResultFwd(pair.env,pair.type,null,null);
}
}
maybeSetTypeI(expr,lvalResult.type);
mayWarnAboutUnknownType(expr,lvalResult.type);
return lvalResult;
}",0.9845536609829488
19276,"private EnvTypePair analyzeGoogTypeof(Node typeof,Node typeString,TypeEnv inEnv,JSType specializedType){
  return analyzeTypePredicate(typeof,typeString.isString() ? typeString.getString() : ""String_Node_Str"",inEnv,specializedType);
}","private EnvTypePair analyzeGoogTypeof(Node typeof,Node typeString,TypeEnv inEnv,JSType specializedType){
  analyzeExprFwdIgnoreResult(typeString,inEnv);
  return analyzeTypePredicate(typeof,typeString.isString() ? typeString.getString() : ""String_Node_Str"",inEnv,specializedType);
}",0.9069767441860463
19277,"static boolean isFunctionBind(Node expr){
  if (!expr.isGetProp()) {
    return false;
  }
  if (isGoogBind(expr) || isGoogPartial(expr)) {
    return true;
  }
  return expr.getFirstChild().isFunction() && expr.getLastChild().getString().equals(""String_Node_Str"");
}","/** 
 * Does not use type info. For example, it returns false for f.bind(...) because it cannot know whether f is a function.
 */
static boolean isFunctionBind(Node expr){
  if (!expr.isGetProp()) {
    return false;
  }
  if (isGoogBind(expr) || isGoogPartial(expr)) {
    return true;
  }
  return expr.getFirstChild().isFunction() && expr.getLastChild().getString().equals(""String_Node_Str"");
}",0.8042168674698795
19278,"public void testClosureStyleFunctionBind(){
  typeCheck(""String_Node_Str"",NewTypeInference.GOOG_BIND_EXPECTS_FUNCTION);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.WRONG_ARGUMENT_COUNT);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.WRONG_ARGUMENT_COUNT);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_THIS_TYPE_IN_BIND);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(""String_Node_Str"");
  typeCheck(""String_Node_Str"");
}","public void testClosureStyleFunctionBind(){
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str""),NewTypeInference.GOOG_BIND_EXPECTS_FUNCTION);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str""),NewTypeInference.WRONG_ARGUMENT_COUNT);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str""),NewTypeInference.WRONG_ARGUMENT_COUNT);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_THIS_TYPE_IN_BIND);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str""));
}",0.8862370723945903
19279,"public void testSuperClassCtorProperty() throws Exception {
  String CLOSURE_DEFS=LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"");
  typeCheck(CLOSURE_DEFS + LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(CLOSURE_DEFS + LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INEXISTENT_PROPERTY);
  typeCheck(CLOSURE_DEFS + LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(CLOSURE_DEFS + LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(CLOSURE_DEFS + ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(CLOSURE_DEFS + ""String_Node_Str"",NewTypeInference.INEXISTENT_PROPERTY);
  typeCheck(CLOSURE_DEFS + ""String_Node_Str"");
}","public void testSuperClassCtorProperty() throws Exception {
  String CLOSURE_DEFS=LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"");
  typeCheck(CLOSURE_DEFS + LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(CLOSURE_DEFS + LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INEXISTENT_PROPERTY);
  typeCheck(CLOSURE_DEFS + LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(CLOSURE_DEFS + LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(CLOSURE_DEFS + ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(CLOSURE_DEFS + ""String_Node_Str"",NewTypeInference.INEXISTENT_PROPERTY);
  typeCheck(LINE_JOINER.join(CLOSURE_DEFS,""String_Node_Str""));
}",0.9739049394221808
19280,"public void testGoogIsPredicatesNoSpecializedContext(){
  typeCheck(CLOSURE_BASE + ""String_Node_Str"",NewTypeInference.WRONG_ARGUMENT_COUNT);
  typeCheck(CLOSURE_BASE + ""String_Node_Str"",NewTypeInference.WRONG_ARGUMENT_COUNT,NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(CLOSURE_BASE + ""String_Node_Str"");
}","public void testGoogIsPredicatesNoSpecializedContext(){
  typeCheck(CLOSURE_BASE + ""String_Node_Str"",NewTypeInference.WRONG_ARGUMENT_COUNT);
  typeCheck(CLOSURE_BASE + ""String_Node_Str"",NewTypeInference.WRONG_ARGUMENT_COUNT,NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str""));
}",0.965625
19281,"public void testSpecializeTypesAfterNullableDereference(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.NULLABLE_DEREFERENCE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.NULLABLE_DEREFERENCE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.NULLABLE_DEREFERENCE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.NULLABLE_DEREFERENCE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.NULLABLE_DEREFERENCE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.NULLABLE_DEREFERENCE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.NULLABLE_DEREFERENCE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.NULLABLE_DEREFERENCE);
}","public void testSpecializeTypesAfterNullableDereference(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.NULLABLE_DEREFERENCE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.NULLABLE_DEREFERENCE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.NULLABLE_DEREFERENCE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.NULLABLE_DEREFERENCE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.NULLABLE_DEREFERENCE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.NULLABLE_DEREFERENCE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.NULLABLE_DEREFERENCE);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.NULLABLE_DEREFERENCE);
}",0.9951726698848868
19282,"public void testAsserts(){
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.ASSERT_FALSE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.UNKNOWN_ASSERTION_TYPE);
  typeCheck(""String_Node_Str"");
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
}","public void testAsserts(){
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.ASSERT_FALSE);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.UNKNOWN_ASSERTION_TYPE,NewTypeInference.INEXISTENT_PROPERTY);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
}",0.8210125980508676
19283,"public void testInferThisInSimpleInferExprType(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
}","public void testInferThisInSimpleInferExprType(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
}",0.9826897470039948
19284,"public void testGoogIsPredicatesTrue(){
  typeCheck(CLOSURE_BASE + ""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testGoogIsPredicatesTrue(){
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.9849640444541294
19285,"public static QualifiedName fromNode(Node qnameNode){
  if (qnameNode == null || !qnameNode.isQualifiedName()) {
    return null;
  }
  return qnameNode.isName() ? new QualifiedName(qnameNode.getString()) : new QualifiedName(ImmutableList.copyOf(Splitter.on('.').split(qnameNode.getQualifiedName())));
}","public static QualifiedName fromNode(Node qnameNode){
  if (qnameNode == null || !qnameNode.isQualifiedName()) {
    return null;
  }
  if (qnameNode.isGetProp()) {
    String pname=qnameNode.getLastChild().getString();
    return join(fromNode(qnameNode.getFirstChild()),new QualifiedName(pname));
  }
  return new QualifiedName(qnameNode.getQualifiedName());
}",0.5353383458646617
19286,"public final Node cloneTree(boolean cloneTypeExprs){
  Node result=cloneNode(cloneTypeExprs);
  Node firstChild=null;
  Node lastChild=null;
  if (this.hasChildren()) {
    for (Node n2=getFirstChild(); n2 != null; n2=n2.next) {
      Node n2clone=n2.cloneTree(cloneTypeExprs);
      n2clone.parent=result;
      if (firstChild == null) {
        firstChild=n2clone;
        lastChild=firstChild;
      }
 else {
        lastChild.next=n2clone;
        n2clone.previous=lastChild;
        lastChild=n2clone;
      }
    }
    firstChild.previous=lastChild;
    lastChild.next=null;
    result.first=firstChild;
  }
  return result;
}","@CheckReturnValue public final Node cloneTree(boolean cloneTypeExprs){
  Node result=cloneNode(cloneTypeExprs);
  Node firstChild=null;
  Node lastChild=null;
  if (this.hasChildren()) {
    for (Node n2=getFirstChild(); n2 != null; n2=n2.next) {
      Node n2clone=n2.cloneTree(cloneTypeExprs);
      n2clone.parent=result;
      if (firstChild == null) {
        firstChild=n2clone;
        lastChild=firstChild;
      }
 else {
        lastChild.next=n2clone;
        n2clone.previous=lastChild;
        lastChild=n2clone;
      }
    }
    firstChild.previous=lastChild;
    lastChild.next=null;
    result.first=firstChild;
  }
  return result;
}",0.985981308411215
19287,"/** 
 * @return A detached clone of the Node, specifically excluding its children.
 */
protected Node cloneNode(boolean cloneTypeExprs){
  return copyNodeFields(new Node(token),cloneTypeExprs);
}","/** 
 * @return A detached clone of the Node, specifically excluding its children.
 */
@CheckReturnValue protected Node cloneNode(boolean cloneTypeExprs){
  return copyNodeFields(new Node(token),cloneTypeExprs);
}",0.9558823529411764
19288,"public final void addChildToBack(Node child){
  checkArgument(child.parent == null,""String_Node_Str"",child,parent,this);
  checkArgument(child.next == null);
  checkArgument(child.previous == null);
  if (first == null) {
    child.previous=child;
    first=child;
  }
 else {
    Node last=first.previous;
    last.next=child;
    child.previous=last;
    first.previous=child;
  }
  child.parent=this;
}","public final void addChildToBack(Node child){
  checkArgument(child.parent == null,""String_Node_Str"",child,child.parent,this);
  checkArgument(child.next == null);
  checkArgument(child.previous == null);
  if (first == null) {
    child.previous=child;
    first=child;
  }
 else {
    Node last=first.previous;
    last.next=child;
    child.previous=last;
    first.previous=child;
  }
  child.parent=this;
}",0.9926470588235294
19289,"/** 
 * @param fnNode The function to inspect.
 * @return Whether the function has parameters, var, or function declarations.
 */
private static boolean hasLocalNames(Node fnNode){
  Node block=NodeUtil.getFunctionBody(fnNode);
  return NodeUtil.getFunctionParameters(fnNode).hasChildren() || NodeUtil.has(block,new NodeUtil.MatchDeclaration(),new NodeUtil.MatchShallowStatement());
}","/** 
 * @param fnNode The function to inspect.
 * @return Whether the function has parameters, var/const/let, class, or function declarations.
 */
private static boolean hasLocalNames(Node fnNode){
  Node block=NodeUtil.getFunctionBody(fnNode);
  return NodeUtil.getFunctionParameters(fnNode).hasChildren() || NodeUtil.has(block,new NodeUtil.MatchDeclaration(),new NodeUtil.MatchShallowStatement());
}",0.978343949044586
19290,"/** 
 * see   {@link #isClassDeclaration}
 */
public static boolean isClassDeclaration(Node n){
  return n.isClass() && isDeclarationParent(n.getParent());
}","/** 
 * see   {@link #isClassDeclaration}
 */
public static boolean isClassDeclaration(Node n){
  return n.isClass() && isDeclarationParent(n.getParent()) && isNamedClass(n);
}",0.9429429429429428
19291,"private static boolean isDeclarationParent(Node parent){
switch (parent.getToken()) {
case DECLARE:
    return true;
case EXPORT:
  return !parent.getBooleanProp(Node.EXPORT_DEFAULT);
default :
return isStatementParent(parent);
}
}","private static boolean isDeclarationParent(Node parent){
switch (parent.getToken()) {
case DECLARE:
case EXPORT:
    return true;
default :
  return isStatementParent(parent);
}
}",0.8
19292,"/** 
 * Is this node a function declaration? A function declaration is a function that has a name that is added to the current scope (i.e. a function that is not part of a expression; see   {@link #isFunctionExpression}).
 */
public static boolean isFunctionDeclaration(Node n){
  return n.isFunction() && isDeclarationParent(n.getParent());
}","/** 
 * Is this node a function declaration? A function declaration is a function that has a name that is added to the current scope (i.e. a function that is not part of a expression; see   {@link #isFunctionExpression}).
 */
public static boolean isFunctionDeclaration(Node n){
  return n.isFunction() && isDeclarationParent(n.getParent()) && isNamedFunction(n);
}",0.9689265536723164
19293,"/** 
 * Splits ES6 export combined with a variable or function declaration.
 */
private void splitExportDeclaration(Node n){
  Node c=n.getFirstChild();
  if (NodeUtil.isNameDeclaration(c) || c.isClass()) {
    n.removeChild(c);
    Node exportSpecs=new Node(Token.EXPORT_SPECS).srcref(n);
    n.addChildToFront(exportSpecs);
    Iterable<Node> names;
    if (c.isClass()) {
      names=Collections.singleton(c.getFirstChild());
      n.getParent().addChildBefore(c,n);
      n.getParent().addChildBefore(new Node(Token.EMPTY).srcref(n),n);
    }
 else {
      names=NodeUtil.getLhsNodesOfDeclaration(c);
      for (      Node child : c.children()) {
        c.removeChild(child);
        Node newDeclaration=new Node(c.getToken(),child).srcref(n);
        n.getParent().addChildBefore(newDeclaration,n);
      }
    }
    for (    Node name : names) {
      Node exportSpec=new Node(Token.EXPORT_SPEC).srcref(name);
      exportSpec.addChildToFront(name.cloneNode());
      exportSpec.addChildToFront(name.cloneNode());
      exportSpecs.addChildToBack(exportSpec);
    }
    compiler.reportChangeToEnclosingScope(n.getParent());
  }
}","/** 
 * Splits ES6 export combined with a variable or function declaration.
 */
private void splitExportDeclaration(Node n){
  if (n.getBooleanProp(Node.EXPORT_DEFAULT)) {
    return;
  }
  Node c=n.getFirstChild();
  if (NodeUtil.isDeclaration(c)) {
    n.removeChild(c);
    Node exportSpecs=new Node(Token.EXPORT_SPECS).srcref(n);
    n.addChildToFront(exportSpecs);
    Iterable<Node> names;
    if (c.isClass() || c.isFunction()) {
      names=Collections.singleton(c.getFirstChild());
      n.getParent().addChildBefore(c,n);
      if (c.isClass()) {
        n.getParent().addChildBefore(new Node(Token.EMPTY).srcref(n),n);
      }
    }
 else {
      names=NodeUtil.getLhsNodesOfDeclaration(c);
      for (      Node child : c.children()) {
        c.removeChild(child);
        Node newDeclaration=new Node(c.getToken(),child).srcref(n);
        n.getParent().addChildBefore(newDeclaration,n);
      }
    }
    for (    Node name : names) {
      Node exportSpec=new Node(Token.EXPORT_SPEC).srcref(name);
      exportSpec.addChildToFront(name.cloneNode());
      exportSpec.addChildToFront(name.cloneNode());
      exportSpecs.addChildToBack(exportSpec);
    }
    compiler.reportChangeToEnclosingScope(n.getParent());
  }
}",0.340227944280287
19294,"/** 
 * Rewrite named unhoisted functions declarations to a known consistent behavior so we don't to different logic paths for the same code. From: function f() {} to: var f = function () {}; and move it to the top of the block. This actually breaks semantics, but the semantics are also not well-defined cross-browser.
 * @see https://github.com/google/closure-compiler/pull/429
 */
static boolean visitFunction(Node n,AbstractCompiler compiler){
  checkState(n.isFunction(),n);
  if (NodeUtil.isFunctionDeclaration(n) && !NodeUtil.isHoistedFunctionDeclaration(n)) {
    rewriteFunctionDeclaration(n,compiler);
    return true;
  }
 else   if (n.isFunction() && !NodeUtil.getFunctionBody(n).isNormalBlock()) {
    Node returnValue=NodeUtil.getFunctionBody(n);
    Node body=IR.block(IR.returnNode(returnValue.detach()));
    body.useSourceInfoIfMissingFromForTree(returnValue);
    n.addChildToBack(body);
    compiler.reportChangeToEnclosingScope(body);
  }
  return false;
}","/** 
 * Rewrite named unhoisted functions declarations to a known consistent behavior so we don't to different logic paths for the same code. From: function f() {} to: var f = function () {}; and move it to the top of the block. This actually breaks semantics, but the semantics are also not well-defined cross-browser.
 * @see https://github.com/google/closure-compiler/pull/429
 */
static boolean visitFunction(Node n,AbstractCompiler compiler){
  checkState(n.isFunction(),n);
  if (NodeUtil.isFunctionDeclaration(n) && !NodeUtil.isHoistedFunctionDeclaration(n) && !n.getParent().isExport()) {
    rewriteFunctionDeclaration(n,compiler);
    return true;
  }
 else   if (n.isFunction() && !NodeUtil.getFunctionBody(n).isNormalBlock()) {
    Node returnValue=NodeUtil.getFunctionBody(n);
    Node body=IR.block(IR.returnNode(returnValue.detach()));
    body.useSourceInfoIfMissingFromForTree(returnValue);
    n.addChildToBack(body);
    compiler.reportChangeToEnclosingScope(body);
  }
  return false;
}",0.9853756933938476
19295,"public void testIsFunctionDeclaration(){
  assertTrue(NodeUtil.isFunctionDeclaration(getFunctionNode(""String_Node_Str"")));
  assertFalse(NodeUtil.isFunctionDeclaration(getFunctionNode(""String_Node_Str"")));
  assertFalse(NodeUtil.isFunctionDeclaration(getFunctionNode(""String_Node_Str"")));
  assertTrue(NodeUtil.isFunctionDeclaration(getFunctionNode(""String_Node_Str"")));
  assertFalse(NodeUtil.isFunctionDeclaration(getFunctionNode(""String_Node_Str"")));
  assertFalse(NodeUtil.isFunctionDeclaration(getFunctionNode(""String_Node_Str"")));
  assertFalse(NodeUtil.isFunctionDeclaration(getFunctionNode(""String_Node_Str"")));
}","public void testIsFunctionDeclaration(){
  assertTrue(NodeUtil.isFunctionDeclaration(getFunctionNode(""String_Node_Str"")));
  assertFalse(NodeUtil.isFunctionDeclaration(getFunctionNode(""String_Node_Str"")));
  assertFalse(NodeUtil.isFunctionDeclaration(getFunctionNode(""String_Node_Str"")));
  assertTrue(NodeUtil.isFunctionDeclaration(getFunctionNode(""String_Node_Str"")));
  assertFalse(NodeUtil.isFunctionDeclaration(getFunctionNode(""String_Node_Str"")));
  assertTrue(NodeUtil.isFunctionDeclaration(getFunctionNode(""String_Node_Str"")));
  assertFalse(NodeUtil.isFunctionDeclaration(getFunctionNode(""String_Node_Str"")));
}",0.9943593875906528
19296,"public void testIsClassDeclaration(){
  assertTrue(NodeUtil.isClassDeclaration(getClassNode(""String_Node_Str"")));
  assertFalse(NodeUtil.isClassDeclaration(getClassNode(""String_Node_Str"")));
  assertFalse(NodeUtil.isClassDeclaration(getClassNode(""String_Node_Str"")));
  assertFalse(NodeUtil.isClassDeclaration(getClassNode(""String_Node_Str"")));
  assertTrue(NodeUtil.isClassDeclaration(getClassNode(""String_Node_Str"")));
}","public void testIsClassDeclaration(){
  assertTrue(NodeUtil.isClassDeclaration(getClassNode(""String_Node_Str"")));
  assertFalse(NodeUtil.isClassDeclaration(getClassNode(""String_Node_Str"")));
  assertFalse(NodeUtil.isClassDeclaration(getClassNode(""String_Node_Str"")));
  assertTrue(NodeUtil.isClassDeclaration(getClassNode(""String_Node_Str"")));
  assertTrue(NodeUtil.isClassDeclaration(getClassNode(""String_Node_Str"")));
  assertFalse(NodeUtil.isClassDeclaration(getClassNode(""String_Node_Str"")));
}",0.7521739130434782
19297,"public void testSplitExportDeclarationOfClass(){
  test(""String_Node_Str"",""String_Node_Str"");
}","public void testSplitExportDeclarationOfClass(){
  test(""String_Node_Str"",""String_Node_Str"");
  testSame(""String_Node_Str"");
  testSame(""String_Node_Str"");
}",0.753968253968254
19298,"public void testSplitExportDeclarationOfFunction(){
  test(""String_Node_Str"",LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""));
}","public void testSplitExportDeclarationOfFunction(){
  test(""String_Node_Str"",LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""));
  testSame(""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
}",0.7790697674418605
19299,"/** 
 * Given an object literal to export, create an object lit with all its string properties. We don't care what the values of those properties are because they are not checked.
 */
private Node createExternObjectLit(Node exportedObjectLit){
  Node lit=IR.objectlit();
  lit.setJSType(exportedObjectLit.getJSType());
  lit.setJSDocInfo(buildEmptyJSDoc());
  int index=1;
  for (Node child=exportedObjectLit.getFirstChild(); child != null; child=child.getNext()) {
    if (child.isStringKey()) {
      lit.addChildToBack(IR.propdef(IR.stringKey(child.getString()),IR.number(index++)));
    }
  }
  return lit;
}","/** 
 * Given an object literal to export, create an object lit with all its string properties. We don't care what the values of those properties are because they are not checked.
 */
private Node createExternObjectLit(Node exportedObjectLit){
  Node lit=IR.objectlit();
  lit.setTypeI(exportedObjectLit.getTypeI());
  lit.setJSDocInfo(buildEmptyJSDoc());
  int index=1;
  for (Node child=exportedObjectLit.getFirstChild(); child != null; child=child.getNext()) {
    if (child.isStringKey()) {
      lit.addChildToBack(IR.propdef(IR.stringKey(child.getString()),IR.number(index++)));
    }
  }
  return lit;
}",0.995090016366612
19300,"/** 
 * Given a function to export, create the empty function that will be put in the externs file. This extern function should have the same type as the original function and the same parameter name but no function body. We create a warning here if the the function to export is missing parameter or return types.
 */
private Node createExternFunction(Node exportedFunction){
  Node paramList=NodeUtil.getFunctionParameters(exportedFunction).cloneTree();
  Node param=paramList.getFirstChild();
  while (param != null && param.isName()) {
    String originalName=param.getOriginalName();
    if (originalName != null) {
      param.setString(originalName);
    }
    param=param.getNext();
  }
  Node externFunction=IR.function(IR.name(""String_Node_Str""),paramList,IR.block());
  if (exportedFunction.getJSType() != null) {
    externFunction.setJSType(exportedFunction.getJSType());
    deleteInlineJsdocs(externFunction);
  }
  return externFunction;
}","/** 
 * Given a function to export, create the empty function that will be put in the externs file. This extern function should have the same type as the original function and the same parameter name but no function body. We create a warning here if the the function to export is missing parameter or return types.
 */
private Node createExternFunction(Node exportedFunction){
  Node paramList=NodeUtil.getFunctionParameters(exportedFunction).cloneTree();
  Node param=paramList.getFirstChild();
  while (param != null && param.isName()) {
    String originalName=param.getOriginalName();
    if (originalName != null) {
      param.setString(originalName);
    }
    param=param.getNext();
  }
  Node externFunction=IR.function(IR.name(""String_Node_Str""),paramList,IR.block());
  if (exportedFunction.getTypeI() != null) {
    externFunction.setTypeI(exportedFunction.getTypeI());
    deleteInlineJsdocs(externFunction);
  }
  return externFunction;
}",0.97325642370215
19301,"StringBuilder appendTo(StringBuilder builder,ToStringContext ctx){
  if (isPrototypeObject()) {
    return builder.append(getOwnerFunction().getThisType()).append(""String_Node_Str"");
  }
  if (!hasNonPrototypeProperties()) {
    if (fn != null) {
      return fn.appendTo(builder,ctx);
    }
    return this.nominalType.appendTo(builder,ctx);
  }
  if (!nominalType.isFunction() && !nominalType.isBuiltinObject() && !nominalType.isLiteralObject()) {
    nominalType.appendTo(builder,ctx);
  }
 else   if (isStruct()) {
    builder.append(""String_Node_Str"");
  }
 else   if (isDict()) {
    builder.append(""String_Node_Str"");
  }
 else   if (this.ns != null) {
    builder.append(this.ns);
  }
  if (this.fn != null) {
    builder.append(""String_Node_Str"");
    fn.appendTo(builder,ctx);
    builder.append(""String_Node_Str"");
  }
  if (ns == null || !props.isEmpty()) {
    builder.append('{');
    boolean firstIteration=true;
    for (    String pname : new TreeSet<>(props.keySet())) {
      if (firstIteration) {
        firstIteration=false;
      }
 else {
        builder.append(""String_Node_Str"");
      }
      builder.append(pname);
      builder.append(""String_Node_Str"");
      props.get(pname).appendTo(builder,ctx);
    }
    builder.append('}');
  }
  if (isLoose) {
    builder.append(""String_Node_Str"");
  }
  return builder;
}","StringBuilder appendTo(StringBuilder builder,ToStringContext ctx){
  if (isPrototypeObject()) {
    return builder.append(getOwnerFunction().getThisType()).append(""String_Node_Str"");
  }
  if (ctx.forAnnotation()) {
    if (fn != null) {
      fn.appendTo(builder,ctx);
    }
 else     if (!props.isEmpty()) {
      appendPropsTo(builder,ctx);
    }
 else     if (nominalType.isLiteralObject()) {
      builder.append(""String_Node_Str"");
    }
 else {
      nominalType.appendTo(builder,ctx);
    }
    return builder;
  }
  if (!hasNonPrototypeProperties()) {
    if (fn != null) {
      return fn.appendTo(builder,ctx);
    }
    return this.nominalType.appendTo(builder,ctx);
  }
  if (!nominalType.isFunction() && !nominalType.isBuiltinObject() && !nominalType.isLiteralObject()) {
    nominalType.appendTo(builder,ctx);
  }
 else   if (isStruct()) {
    builder.append(""String_Node_Str"");
  }
 else   if (isDict()) {
    builder.append(""String_Node_Str"");
  }
 else   if (this.ns != null) {
    builder.append(this.ns);
  }
  if (this.fn != null) {
    builder.append(""String_Node_Str"");
    fn.appendTo(builder,ctx);
    builder.append(""String_Node_Str"");
  }
  if (ns == null || !props.isEmpty()) {
    appendPropsTo(builder,ctx);
  }
  if (isLoose) {
    builder.append(""String_Node_Str"");
  }
  return builder;
}",0.4330206378986866
19302,"private void createSummary(NTIScope fn){
  Node fnRoot=fn.getRoot();
  checkArgument(!fnRoot.isFromExterns());
  FunctionTypeBuilder builder=new FunctionTypeBuilder(this.commonTypes);
  TypeEnv entryEnv=getEntryTypeEnv();
  TypeEnv exitEnv=getExitTypeEnv();
  if (exitEnv == null) {
    exitEnv=envPutType(new TypeEnv(),RETVAL_ID,BOTTOM);
  }
  DeclaredFunctionType declType=fn.getDeclaredFunctionType();
  int reqArity=declType.getRequiredArity();
  int optArity=declType.getOptionalArity();
  if (declType.isGeneric()) {
    builder.addTypeParameters(declType.getTypeParameters());
  }
  List<String> formals=fn.getFormals();
  for (int i=reqArity - 1; i >= 0; i--) {
    JSType formalType=declType.getFormalType(i);
    if (formalType != null) {
      break;
    }
    String formalName=formals.get(i);
    formalType=getTypeAfterFwd(formalName,entryEnv,exitEnv);
    if (formalType.isUnknown() || UNDEFINED.isSubtypeOf(formalType)) {
      reqArity--;
    }
 else {
      break;
    }
  }
  int i=0;
  for (  String formalName : formals) {
    JSType formalType=declType.getFormalType(i);
    if (formalType == null) {
      formalType=getTypeAfterFwd(formalName,entryEnv,exitEnv);
    }
    if (i < reqArity) {
      builder.addReqFormal(formalType);
    }
 else     if (i < optArity) {
      builder.addOptFormal(formalType);
    }
    i++;
  }
  if (declType.hasRestFormals()) {
    builder.addRestFormals(declType.getFormalType(i));
  }
  for (  String outer : fn.getOuterVars()) {
    println(""String_Node_Str"",outer,""String_Node_Str"");
    builder.addOuterVarPrecondition(outer,envGetType(entryEnv,outer));
  }
  builder.addNominalType(declType.getNominalType());
  builder.addReceiverType(declType.getReceiverType());
  builder.addAbstract(declType.isAbstract());
  addRetTypeAndWarn(fn,exitEnv,declType,builder);
  JSType summary=commonTypes.fromFunctionType(builder.buildFunction());
  println(""String_Node_Str"",fn.getReadableName());
  println(""String_Node_Str"",summary);
  summary=changeTypeIfFunctionNamespace(fn,summary);
  summaries.put(fn,summary);
  maybeSetTypeI(fnRoot,summary);
  Node fnNameNode=NodeUtil.getNameNode(fnRoot);
  if (fnNameNode != null) {
    maybeSetTypeI(fnNameNode,summary);
  }
}","private void createSummary(NTIScope fn){
  Node fnRoot=fn.getRoot();
  checkArgument(!fnRoot.isFromExterns());
  FunctionTypeBuilder builder=new FunctionTypeBuilder(this.commonTypes);
  TypeEnv entryEnv=getEntryTypeEnv();
  TypeEnv exitEnv=getExitTypeEnv();
  DeclaredFunctionType declType=fn.getDeclaredFunctionType();
  int reqArity=declType.getRequiredArity();
  int optArity=declType.getOptionalArity();
  if (declType.isGeneric()) {
    builder.addTypeParameters(declType.getTypeParameters());
  }
  List<String> formals=fn.getFormals();
  for (int i=reqArity - 1; i >= 0; i--) {
    JSType formalType=declType.getFormalType(i);
    if (formalType != null) {
      break;
    }
    String formalName=formals.get(i);
    formalType=getTypeAfterFwd(formalName,entryEnv,exitEnv);
    if (formalType.isUnknown() || UNDEFINED.isSubtypeOf(formalType)) {
      reqArity--;
    }
 else {
      break;
    }
  }
  int i=0;
  for (  String formalName : formals) {
    JSType formalType=declType.getFormalType(i);
    if (formalType == null) {
      formalType=getTypeAfterFwd(formalName,entryEnv,exitEnv);
    }
    if (i < reqArity) {
      builder.addReqFormal(formalType);
    }
 else     if (i < optArity) {
      builder.addOptFormal(formalType);
    }
    i++;
  }
  if (declType.hasRestFormals()) {
    builder.addRestFormals(declType.getFormalType(i));
  }
  for (  String outer : fn.getOuterVars()) {
    println(""String_Node_Str"",outer,""String_Node_Str"");
    builder.addOuterVarPrecondition(outer,envGetType(entryEnv,outer));
  }
  builder.addNominalType(declType.getNominalType());
  builder.addReceiverType(declType.getReceiverType());
  builder.addAbstract(declType.isAbstract());
  addRetTypeAndWarn(fn,exitEnv,declType,builder);
  JSType summary=commonTypes.fromFunctionType(builder.buildFunction());
  println(""String_Node_Str"",fn.getReadableName());
  println(""String_Node_Str"",summary);
  summary=changeTypeIfFunctionNamespace(fn,summary);
  summaries.put(fn,summary);
  maybeSetTypeI(fnRoot,summary);
  Node fnNameNode=NodeUtil.getNameNode(fnRoot);
  if (fnNameNode != null) {
    maybeSetTypeI(fnNameNode,summary);
  }
}",0.9804911636447096
19303,"private void addRetTypeAndWarn(NTIScope fn,TypeEnv exitEnv,DeclaredFunctionType declType,FunctionTypeBuilder builder){
  Node fnRoot=fn.getRoot();
  JSType declRetType=declType.getReturnType();
  JSType actualRetType=checkNotNull(envGetType(exitEnv,RETVAL_ID));
  if (declRetType != null) {
    if (fnRoot.isGeneratorFunction()) {
      JSType generator=this.commonTypes.getGeneratorInstance(UNKNOWN);
      if (!generator.isSubtypeOf(declRetType)) {
        registerMismatchAndWarn(JSError.make(fnRoot,INVALID_DECLARED_RETURN_TYPE_OF_GENERATOR_FUNCTION,errorMsgWithTypeDiff(generator,declRetType)),declRetType,generator);
        builder.addRetType(UNKNOWN);
      }
 else {
        builder.addRetType(declRetType);
      }
    }
 else {
      builder.addRetType(declRetType);
      if (!isAllowedToNotReturn(fn) && !UNDEFINED.isSubtypeOf(declRetType) && hasPathWithNoReturn(this.cfg)) {
        warnings.add(JSError.make(fnRoot,MISSING_RETURN_STATEMENT,declRetType.toString()));
      }
    }
  }
 else   if (fnRoot.isGeneratorFunction()) {
    JSType yieldType=envGetType(exitEnv,YIELDVAL_ID);
    builder.addRetType(this.commonTypes.getGeneratorInstance(firstNonNull(yieldType,UNKNOWN)));
  }
 else   if (declType.getNominalType() == null) {
    builder.addRetType(firstNonBottom(actualRetType,TOP));
  }
 else {
    builder.addRetType(UNDEFINED);
  }
}","private void addRetTypeAndWarn(NTIScope fn,TypeEnv exitEnv,DeclaredFunctionType declType,FunctionTypeBuilder builder){
  Node fnRoot=fn.getRoot();
  JSType declRetType=declType.getReturnType();
  JSType actualRetType=checkNotNull(envGetType(exitEnv,RETVAL_ID));
  if (declRetType != null) {
    if (fnRoot.isGeneratorFunction()) {
      JSType generator=this.commonTypes.getGeneratorInstance(UNKNOWN);
      if (!generator.isSubtypeOf(declRetType)) {
        registerMismatchAndWarn(JSError.make(fnRoot,INVALID_DECLARED_RETURN_TYPE_OF_GENERATOR_FUNCTION,errorMsgWithTypeDiff(generator,declRetType)),declRetType,generator);
        builder.addRetType(UNKNOWN);
      }
 else {
        builder.addRetType(declRetType);
      }
    }
 else {
      builder.addRetType(declRetType);
      if (!isAllowedToNotReturn(fn) && !UNDEFINED.isSubtypeOf(declRetType) && hasPathWithNoReturn(this.cfg)) {
        warnings.add(JSError.make(fnRoot,MISSING_RETURN_STATEMENT,declRetType.toString()));
      }
    }
  }
 else   if (fnRoot.isGeneratorFunction()) {
    JSType yieldType=envGetType(exitEnv,YIELDVAL_ID);
    builder.addRetType(this.commonTypes.getGeneratorInstance(firstNonNull(yieldType,UNKNOWN)));
  }
 else   if (declType.getNominalType() == null) {
    builder.addRetType(firstNonBottom(actualRetType,UNKNOWN));
  }
 else {
    builder.addRetType(UNDEFINED);
  }
}",0.9970566593083148
19304,"private TypeEnv getExitTypeEnv(){
  if (!this.cfg.getImplicitReturn().getInEdges().isEmpty()) {
    exitEnvs.add(getInEnv(this.cfg.getImplicitReturn()));
  }
  checkState(!exitEnvs.isEmpty(),""String_Node_Str"");
  return TypeEnv.join(exitEnvs);
}","private TypeEnv getExitTypeEnv(){
  for (int i=0; i < exitEnvs.size(); i++) {
    TypeEnv env=exitEnvs.get(i);
    exitEnvs.set(i,envPutType(env,RETVAL_ID,BOTTOM));
  }
  if (!this.cfg.getImplicitReturn().getInEdges().isEmpty()) {
    exitEnvs.add(getInEnv(this.cfg.getImplicitReturn()));
  }
  checkState(!exitEnvs.isEmpty(),""String_Node_Str"");
  return TypeEnv.join(exitEnvs);
}",0.784
19305,"public void testFunctionsWithAbnormalExit(){
  typeCheck(""String_Node_Str"");
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
}","public void testFunctionsWithAbnormalExit(){
  typeCheck(""String_Node_Str"");
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""));
}",0.8413284132841329
19306,"private boolean evalTypePredicate(Node ttlAst,NameResolver nameResolver){
  TypeI[] params=evalTypeParams(ttlAst,nameResolver);
  String name=getCallName(ttlAst);
  Keywords keyword=nameToKeyword(name);
  TypeI type=params[0];
switch (keyword) {
case EQ:
    return type.isEquivalentTo(params[1]);
case SUB:
  return type.isSubtypeOf(params[1]);
case ISCTOR:
return type.isConstructor();
case ISTEMPLATIZED:
return type.isObjectType() && type.toMaybeObjectType().isGenericObjectType() && !type.hasUninstantiatedTypeVariables();
case ISRECORD:
return type.isRecordType();
case ISUNKNOWN:
return type.isSomeUnknownType();
default :
throw new IllegalStateException(""String_Node_Str"");
}
}","private boolean evalTypePredicate(Node ttlAst,NameResolver nameResolver){
  TypeI[] params=evalTypeParams(ttlAst,nameResolver);
  String name=getCallName(ttlAst);
  Keywords keyword=nameToKeyword(name);
  TypeI type=params[0];
switch (keyword) {
case EQ:
    return type.isEquivalentTo(params[1]);
case SUB:
  return type.isSubtypeOf(params[1]);
case ISCTOR:
return type.isConstructor();
case ISTEMPLATIZED:
return type.isObjectType() && type.toMaybeObjectType().isGenericObjectType();
case ISRECORD:
return type.isRecordType();
case ISUNKNOWN:
return type.isSomeUnknownType();
default :
throw new IllegalStateException(""String_Node_Str"");
}
}",0.9683734939759036
19307,"private TypeI evalTemplatizedType(Node ttlAst,NameResolver nameResolver){
  ImmutableList<Node> params=getCallParams(ttlAst);
  TypeI firstParam=evalInternal(params.get(0),nameResolver);
  if (!firstParam.hasUninstantiatedTypeVariables()) {
    reportWarning(ttlAst,BASETYPE_INVALID,firstParam.toString());
    return getUnknownType();
  }
  TypeI[] templatizedTypes=new TypeI[params.size() - 1];
  for (int i=0; i < templatizedTypes.length; i++) {
    templatizedTypes[i]=evalInternal(params.get(i + 1),nameResolver);
  }
  ObjectTypeI baseType=firstParam.toMaybeObjectType();
  return createTemplatizedType(baseType,templatizedTypes);
}","private TypeI evalTemplatizedType(Node ttlAst,NameResolver nameResolver){
  ImmutableList<Node> params=getCallParams(ttlAst);
  TypeI firstParam=evalInternal(params.get(0),nameResolver);
  if (firstParam.isFullyInstantiated()) {
    reportWarning(ttlAst,BASETYPE_INVALID,firstParam.toString());
    return getUnknownType();
  }
  TypeI[] templatizedTypes=new TypeI[params.size() - 1];
  for (int i=0; i < templatizedTypes.length; i++) {
    templatizedTypes[i]=evalInternal(params.get(i + 1),nameResolver);
  }
  ObjectTypeI baseType=firstParam.toMaybeObjectType();
  return createTemplatizedType(baseType,templatizedTypes);
}",0.9604430379746836
19308,"private boolean evalTypePredicate(Node ttlAst,NameResolver nameResolver){
  TypeI[] params=evalTypeParams(ttlAst,nameResolver);
  String name=getCallName(ttlAst);
  Keywords keyword=nameToKeyword(name);
  TypeI type=params[0];
switch (keyword) {
case EQ:
    return type.isEquivalentTo(params[1]);
case SUB:
  return type.isSubtypeOf(params[1]);
case ISCTOR:
return type.isConstructor();
case ISTEMPLATIZED:
return type.isObjectType() && type.toMaybeObjectType().isGenericObjectType();
case ISRECORD:
return type.isRecordType();
case ISUNKNOWN:
return type.isSomeUnknownType();
default :
throw new IllegalStateException(""String_Node_Str"");
}
}","private boolean evalTypePredicate(Node ttlAst,NameResolver nameResolver){
  TypeI[] params=evalTypeParams(ttlAst,nameResolver);
  String name=getCallName(ttlAst);
  Keywords keyword=nameToKeyword(name);
  TypeI type=params[0];
switch (keyword) {
case EQ:
    return type.isEquivalentTo(params[1]);
case SUB:
  return type.isSubtypeOf(params[1]);
case ISCTOR:
return type.isConstructor();
case ISTEMPLATIZED:
return type.isObjectType() && type.toMaybeObjectType().isGenericObjectType() && type.isPartiallyInstantiated();
case ISRECORD:
return type.isRecordType();
case ISUNKNOWN:
return type.isSomeUnknownType();
default :
throw new IllegalStateException(""String_Node_Str"");
}
}",0.9742424242424242
19309,"@Override public void process(Node externs,Node root){
  NodeTraversal.traverseRootsEs6(compiler,new AbstractPostOrderCallback(){
    @Override public void visit(    NodeTraversal t,    Node n,    Node parent){
      if (n.isName() && !parent.isFunction() && !parent.isLabel()) {
        assertTrue(""String_Node_Str"" + n.getString() + ""String_Node_Str"",t.getScope().isDeclared(n.getString(),true));
      }
    }
  }
,externs,root);
}","@Override public void process(Node externs,Node root){
  NodeTraversal.traverseRootsEs6(compiler,new AbstractPostOrderCallback(){
    @Override public void visit(    NodeTraversal t,    Node n,    Node parent){
      if (n.isName() && !parent.isFunction() && !parent.isLabel()) {
        assertWithMessage(""String_Node_Str"",n).that(t.getScope().isDeclared(n.getString(),true)).isTrue();
      }
    }
  }
,externs,root);
}",0.866822429906542
19310,"@Override public void visit(NodeTraversal t,Node n,Node parent){
  if (n.isName() && !parent.isFunction() && !parent.isLabel()) {
    assertTrue(""String_Node_Str"" + n.getString() + ""String_Node_Str"",t.getScope().isDeclared(n.getString(),true));
  }
}","@Override public void visit(NodeTraversal t,Node n,Node parent){
  if (n.isName() && !parent.isFunction() && !parent.isLabel()) {
    assertWithMessage(""String_Node_Str"",n).that(t.getScope().isDeclared(n.getString(),true)).isTrue();
  }
}",0.6270491803278688
19311,"private void exportClass(Node scriptNode,Node classNode){
  Node classMembers=classNode.getLastChild();
  for (  Node maybeMemberFunctionDef : classMembers.children()) {
    if (maybeMemberFunctionDef.isMemberFunctionDef()) {
      String methodName=maybeMemberFunctionDef.getString();
      if (TEST_FUNCTIONS_NAME_PATTERN.matcher(methodName).matches()) {
        String functionRef=NodeUtil.getName(classNode) + ""String_Node_Str"" + methodName;
        String classRef=NodeUtil.getName(classNode) + ""String_Node_Str"";
        Node exportCallTarget=NodeUtil.newQName(compiler,exportPropertyFunction,maybeMemberFunctionDef,methodName);
        Node call=IR.call(exportCallTarget);
        if (exportCallTarget.isName()) {
          call.putBooleanProp(Node.FREE_CALL,true);
        }
        call.addChildToBack(NodeUtil.newQName(compiler,classRef,maybeMemberFunctionDef,classRef));
        call.addChildToBack(IR.string(methodName));
        call.addChildToBack(NodeUtil.newQName(compiler,functionRef,maybeMemberFunctionDef,functionRef));
        Node expression=IR.exprResult(call);
        scriptNode.addChildAfter(expression,classNode);
        compiler.reportChangeToEnclosingScope(expression);
      }
    }
  }
}","private void exportClass(Node scriptNode,Node classNode,String className,Node baseNode){
  Node classMembers=classNode.getLastChild();
  for (  Node maybeMemberFunctionDef : classMembers.children()) {
    if (maybeMemberFunctionDef.isMemberFunctionDef()) {
      String methodName=maybeMemberFunctionDef.getString();
      if (isTestFunction(methodName)) {
        String functionRef=className + ""String_Node_Str"" + methodName;
        String classRef=className + ""String_Node_Str"";
        Node exportCallTarget=NodeUtil.newQName(compiler,exportPropertyFunction,maybeMemberFunctionDef,methodName);
        Node call=IR.call(exportCallTarget);
        if (exportCallTarget.isName()) {
          call.putBooleanProp(Node.FREE_CALL,true);
        }
        call.addChildToBack(NodeUtil.newQName(compiler,classRef,maybeMemberFunctionDef,classRef));
        call.addChildToBack(IR.string(methodName));
        call.addChildToBack(NodeUtil.newQName(compiler,functionRef,maybeMemberFunctionDef,functionRef));
        Node expression=IR.exprResult(call);
        scriptNode.addChildAfter(expression,baseNode);
        compiler.reportChangeToEnclosingScope(expression);
      }
    }
  }
}",0.8978741142142559
19312,"/** 
 * Whether node corresponds to a function expression declared with var, let or const which is of the form: <pre> var/let/const functionName = function() { // Implementation }; </pre> This has the AST structure VAR/LET/CONST -> NAME -> FUNCTION
 * @param node
 */
private boolean isNameDeclaredFunction(Node node){
  if (!NodeUtil.isNameDeclaration(node)) {
    return false;
  }
  Node grandchild=node.getFirstFirstChild();
  return grandchild != null && grandchild.isFunction();
}","/** 
 * Whether node corresponds to a function expression declared with var, let or const which is of the form: <pre> var/let/const functionName = function() { // Implementation }; </pre> This has the AST structure VAR/LET/CONST -> NAME -> FUNCTION
 * @param node
 */
private boolean isNameDeclaredFunction(Node node){
  Node grandchild=getNameDeclaredGrandchild(node);
  return grandchild != null && grandchild.isFunction();
}",0.7272727272727273
19313,"@Override public void visit(NodeTraversal t,Node n,Node parent){
  if (parent == null) {
    return;
  }
  if (parent.isScript()) {
    if (NodeUtil.isFunctionDeclaration(n)) {
      String functionName=NodeUtil.getName(n);
      if (isTestFunction(functionName)) {
        exportTestFunctionAsSymbol(functionName,n,parent);
      }
    }
 else     if (isNameDeclaredFunction(n)) {
      Node functionNode=n.getFirstFirstChild();
      String functionName=NodeUtil.getName(functionNode);
      if (isTestFunction(functionName)) {
        exportTestFunctionAsSymbol(functionName,n,parent);
      }
    }
 else     if (n.isClass()) {
      exportClass(parent,n);
    }
  }
 else   if (NodeUtil.isExprAssign(parent) && !n.getLastChild().isAssign()) {
    Node grandparent=parent.getParent();
    if (grandparent != null && grandparent.isScript()) {
      String functionName=n.getFirstChild().getQualifiedName();
      if (isTestFunction(functionName)) {
        if (n.getFirstChild().isName()) {
          exportTestFunctionAsSymbol(functionName,parent,grandparent);
        }
 else {
          exportTestFunctionAsProperty(functionName,parent,n,grandparent);
        }
      }
    }
  }
 else   if (n.isObjectLit() && isCallTargetQName(n.getParent(),""String_Node_Str"")) {
    for (    Node c : n.children()) {
      if (c.isStringKey() && !c.isQuotedString()) {
        c.setQuotedString();
        compiler.reportChangeToEnclosingScope(c);
      }
 else       if (c.isMemberFunctionDef()) {
        rewriteMemberDefInObjLit(c,n);
      }
    }
  }
}","@Override public void visit(NodeTraversal t,Node n,Node parent){
  if (parent == null) {
    return;
  }
  if (parent.isScript()) {
    if (NodeUtil.isFunctionDeclaration(n)) {
      String functionName=NodeUtil.getName(n);
      if (isTestFunction(functionName)) {
        exportTestFunctionAsSymbol(functionName,n,parent);
      }
    }
 else     if (isNameDeclaredFunction(n)) {
      Node functionNode=n.getFirstFirstChild();
      String functionName=NodeUtil.getName(functionNode);
      if (isTestFunction(functionName)) {
        exportTestFunctionAsSymbol(functionName,n,parent);
      }
    }
 else     if (isNameDeclaredClass(n)) {
      Node classNode=n.getFirstFirstChild();
      String className=NodeUtil.getName(classNode);
      exportClass(parent,classNode,className,n);
    }
 else     if (n.isClass()) {
      exportClass(parent,n);
    }
  }
 else   if (NodeUtil.isExprAssign(parent) && !n.getLastChild().isAssign()) {
    Node grandparent=parent.getParent();
    if (grandparent != null && grandparent.isScript()) {
      Node firstChild=n.getFirstChild();
      Node lastChild=n.getLastChild();
      String nodeName=firstChild.getQualifiedName();
      if (lastChild.isFunction()) {
        if (isTestFunction(nodeName)) {
          if (n.getFirstChild().isName()) {
            exportTestFunctionAsSymbol(nodeName,parent,grandparent);
          }
 else {
            exportTestFunctionAsProperty(nodeName,parent,n,grandparent);
          }
        }
      }
 else       if (lastChild.isClass()) {
        exportClass(grandparent,lastChild,nodeName,parent);
      }
    }
  }
 else   if (n.isObjectLit() && isCallTargetQName(n.getParent(),""String_Node_Str"")) {
    for (    Node c : n.children()) {
      if (c.isStringKey() && !c.isQuotedString()) {
        c.setQuotedString();
        compiler.reportChangeToEnclosingScope(c);
      }
 else       if (c.isMemberFunctionDef()) {
        rewriteMemberDefInObjLit(c,n);
      }
    }
  }
}",0.8103644646924829
19314,"void fillPropertyScopes(){
  List<Symbol> types=new ArrayList<>();
  List<Symbol> googModuleExportTypes=new ArrayList<>();
  for (  Symbol sym : getAllSymbols()) {
    if (needsPropertyScope(sym)) {
      if (sym.getName().startsWith(""String_Node_Str"")) {
        googModuleExportTypes.add(sym);
      }
 else {
        types.add(sym);
      }
    }
  }
  Collections.sort(types,getNaturalSymbolOrdering().reverse());
  Collections.sort(googModuleExportTypes,getNaturalSymbolOrdering().reverse());
  for (  Symbol s : Iterables.concat(googModuleExportTypes,types)) {
    createPropertyScopeFor(s);
  }
  pruneOrphanedNames();
}","@SuppressWarnings(""String_Node_Str"") void fillPropertyScopes(){
  List<Symbol> types=new ArrayList<>();
  List<Symbol> googModuleExportTypes=new ArrayList<>();
  for (  Symbol sym : getAllSymbols()) {
    if (needsPropertyScope(sym)) {
      if (sym.getName().startsWith(""String_Node_Str"")) {
        googModuleExportTypes.add(sym);
      }
 else {
        types.add(sym);
      }
    }
  }
  Collections.sort(types,getNaturalSymbolOrdering().reverse());
  Collections.sort(googModuleExportTypes,getNaturalSymbolOrdering().reverse());
  Iterable<Symbol> allTypes=Iterables.concat(googModuleExportTypes,types);
  Map<JSType,Symbol> symbolThatDeclaresType=new IdentityHashMap<>();
  for (  Symbol s : allTypes) {
    symbolThatDeclaresType.put(s.getType(),s);
  }
  for (  Symbol s : allTypes) {
    if (s.getType() == null || symbolThatDeclaresType.get(s.getType()).equals(s)) {
      createPropertyScopeFor(s);
    }
  }
  for (  Symbol s : allTypes) {
    if (s.getType() != null) {
      s.propertyScope=symbolThatDeclaresType.get(s.getType()).getPropertyScope();
    }
  }
  pruneOrphanedNames();
}",0.7025462962962963
19315,"private void removeSymbol(Symbol s){
  SymbolScope scope=getScope(s);
  if (scope.ownSymbols.remove(s.getName()) != s) {
    throw new IllegalStateException(""String_Node_Str"" + s);
  }
  if (symbols.remove(s.getDeclaration().getNode(),s.getName()) != s) {
    throw new IllegalStateException(""String_Node_Str"" + s);
  }
}","private void removeSymbol(Symbol s){
  SymbolScope scope=getScope(s);
  if (!scope.ownSymbols.remove(s.getName()).equals(s)) {
    throw new IllegalStateException(""String_Node_Str"" + s);
  }
  if (!symbols.remove(s.getDeclaration().getNode(),s.getName()).equals(s)) {
    throw new IllegalStateException(""String_Node_Str"" + s);
  }
}",0.8440366972477065
19316,"/** 
 * Build a property scope for the given symbol. Any properties of the symbol will be added to the property scope. It is important that property scopes are created in order from the leaves up to the root, so this should only be called from #fillPropertyScopes. If you try to create a property scope for a parent before its leaf, then the leaf will get cut and re-added to the parent property scope, and weird things will happen.
 */
private void createPropertyScopeFor(Symbol s){
  if (s.propertyScope != null) {
    return;
  }
  SymbolScope parentPropertyScope=null;
  ObjectType type=getType(s) == null ? null : getType(s).toObjectType();
  if (type == null) {
    return;
  }
  ObjectType proto=type.getParentScope();
  if (proto != null && proto != type && proto.getConstructor() != null) {
    Symbol parentSymbol=getSymbolForInstancesOf(proto.getConstructor());
    if (parentSymbol != null) {
      createPropertyScopeFor(parentSymbol);
      parentPropertyScope=parentSymbol.getPropertyScope();
    }
  }
  ObjectType instanceType=type;
  Iterable<String> propNames=type.getOwnPropertyNames();
  if (instanceType.isFunctionPrototypeType()) {
    if (instanceType.getOwnerFunction().hasInstanceType()) {
      instanceType=instanceType.getOwnerFunction().getInstanceType();
      propNames=Iterables.concat(propNames,instanceType.getOwnPropertyNames());
    }
  }
  s.setPropertyScope(new SymbolScope(null,parentPropertyScope,type,s));
  for (  String propName : propNames) {
    StaticSlot newProp=instanceType.getSlot(propName);
    if (newProp.getDeclaration() == null) {
      continue;
    }
    Symbol oldProp=symbols.get(newProp.getDeclaration().getNode(),s.getName() + ""String_Node_Str"" + propName);
    if (oldProp != null) {
      removeSymbol(oldProp);
    }
    if (symbols.get(newProp.getDeclaration().getNode(),newProp.getName()) != null) {
      if (logger.isLoggable(Level.FINE)) {
        logger.fine(""String_Node_Str"" + newProp);
      }
      continue;
    }
    Symbol newSym=copySymbolTo(newProp,s.propertyScope);
    if (oldProp != null) {
      if (newSym.getJSDocInfo() == null) {
        newSym.setJSDocInfo(oldProp.getJSDocInfo());
      }
      newSym.setPropertyScope(oldProp.propertyScope);
      for (      Reference ref : oldProp.references.values()) {
        newSym.defineReferenceAt(ref.getNode());
      }
    }
  }
}","/** 
 * Build a property scope for the given symbol. Any properties of the symbol will be added to the property scope. <p>It is important that property scopes are created in order from the leaves up to the root, so this should only be called from #fillPropertyScopes. If you try to create a property scope for a parent before its leaf, then the leaf will get cut and re-added to the parent property scope, and weird things will happen.
 */
@SuppressWarnings(""String_Node_Str"") private void createPropertyScopeFor(Symbol s){
  if (s.propertyScope != null) {
    return;
  }
  SymbolScope parentPropertyScope=null;
  ObjectType type=getType(s) == null ? null : getType(s).toObjectType();
  if (type == null) {
    return;
  }
  ObjectType proto=type.getParentScope();
  if (proto != null && proto != type && proto.getConstructor() != null) {
    Symbol parentSymbol=getSymbolForInstancesOf(proto.getConstructor());
    if (parentSymbol != null) {
      createPropertyScopeFor(parentSymbol);
      parentPropertyScope=parentSymbol.getPropertyScope();
    }
  }
  ObjectType instanceType=type;
  Iterable<String> propNames=type.getOwnPropertyNames();
  if (instanceType.isFunctionPrototypeType()) {
    if (instanceType.getOwnerFunction().hasInstanceType()) {
      instanceType=instanceType.getOwnerFunction().getInstanceType();
      propNames=Iterables.concat(propNames,instanceType.getOwnPropertyNames());
    }
  }
  s.setPropertyScope(new SymbolScope(null,parentPropertyScope,type,s));
  for (  String propName : propNames) {
    StaticSlot newProp=instanceType.getSlot(propName);
    if (newProp.getDeclaration() == null) {
      continue;
    }
    Symbol oldProp=symbols.get(newProp.getDeclaration().getNode(),s.getName() + ""String_Node_Str"" + propName);
    if (oldProp != null) {
      removeSymbol(oldProp);
    }
    if (symbols.get(newProp.getDeclaration().getNode(),newProp.getName()) != null) {
      if (logger.isLoggable(Level.FINE)) {
        logger.fine(""String_Node_Str"" + newProp);
      }
      continue;
    }
    Symbol newSym=copySymbolTo(newProp,s.propertyScope);
    if (oldProp != null) {
      if (newSym.getJSDocInfo() == null) {
        newSym.setJSDocInfo(oldProp.getJSDocInfo());
      }
      newSym.setPropertyScope(oldProp.propertyScope);
      for (      Reference ref : oldProp.references.values()) {
        newSym.defineReferenceAt(ref.getNode());
      }
    }
  }
}",0.9916107382550337
19317,"private boolean isSubtypeOfHelper(boolean keepLoosenessOfThis,JSType other,SubtypeCache subSuperMap,MismatchInfo[] boxedInfo){
  if (isUnknown() || other.isUnknown() || other.isTop()) {
    return true;
  }
  if (isTheTruthyType()) {
    return !other.makeTruthy().isBottom();
  }
  if (isTheFalsyType()) {
    return !other.makeFalsy().isBottom();
  }
  if (!EnumType.areSubtypes(this,other,subSuperMap)) {
    return false;
  }
  int mask=getMask() & ~ENUM_MASK;
  if ((mask | other.getMask()) != other.getMask()) {
    if (boxedInfo != null && isUnion()) {
      whyNotUnionSubtypes(this,other,boxedInfo);
    }
    return false;
  }
  if (getTypeVar() != null && !getTypeVar().equals(other.getTypeVar())) {
    return false;
  }
  if (getObjs().isEmpty()) {
    return true;
  }
  boolean result=ObjectType.isUnionSubtype(keepLoosenessOfThis,getObjs(),other.getObjs(),subSuperMap);
  if (boxedInfo != null) {
    ObjectType.whyNotUnionSubtypes(keepLoosenessOfThis,getObjs(),other.getObjs(),subSuperMap,boxedInfo);
  }
  return result;
}","private boolean isSubtypeOfHelper(boolean keepLoosenessOfThis,JSType other,SubtypeCache subSuperMap,MismatchInfo[] boxedInfo){
  if (isUnknown() || other.isUnknown() || other.isTop()) {
    return true;
  }
  if (isTheTruthyType()) {
    return !other.makeTruthy().isBottom();
  }
  if (isTheFalsyType()) {
    return !other.makeFalsy().isBottom();
  }
  if (other.isTheTruthyType()) {
    return isAnyTruthyType();
  }
  if (!EnumType.areSubtypes(this,other,subSuperMap)) {
    return false;
  }
  int mask=getMask() & ~ENUM_MASK;
  if ((mask | other.getMask()) != other.getMask()) {
    if (boxedInfo != null && isUnion()) {
      whyNotUnionSubtypes(this,other,boxedInfo);
    }
    return false;
  }
  if (getTypeVar() != null && !getTypeVar().equals(other.getTypeVar())) {
    return false;
  }
  if (getObjs().isEmpty()) {
    return true;
  }
  boolean result=ObjectType.isUnionSubtype(keepLoosenessOfThis,getObjs(),other.getObjs(),subSuperMap);
  if (boxedInfo != null) {
    ObjectType.whyNotUnionSubtypes(keepLoosenessOfThis,getObjs(),other.getObjs(),subSuperMap,boxedInfo);
  }
  return result;
}",0.9687936655798788
19318,"public void testAsserts(){
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.ASSERT_FALSE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.UNKNOWN_ASSERTION_TYPE);
  typeCheck(""String_Node_Str"");
}","public void testAsserts(){
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.ASSERT_FALSE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.UNKNOWN_ASSERTION_TYPE);
  typeCheck(""String_Node_Str"");
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
}",0.9146131805157592
19319,"public void testExports(){
  CompilerOptions options=createCompilerOptions();
  CompilationLevel level=CompilationLevel.ADVANCED_OPTIMIZATIONS;
  level.setOptionsForCompilationLevel(options);
  WarningLevel warnings=WarningLevel.DEFAULT;
  warnings.setOptionsForWarningLevel(options);
  options.setRemoveUnusedPrototypePropertiesInExterns(true);
  String code=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  test(options,code,""String_Node_Str"" + ""String_Node_Str"");
  options.setGenerateExports(true);
  test(options,""String_Node_Str"" + ""String_Node_Str"",FindExportableNodes.NON_GLOBAL_ERROR);
  options.exportLocalPropertyDefinitions=true;
  options.setRemoveUnusedPrototypePropertiesInExterns(false);
  test(options,code,""String_Node_Str"" + ""String_Node_Str"");
  test(options,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
  options.setCheckTypes(true);
  options.setDisambiguateProperties(true);
  options.setAmbiguateProperties(true);
  options.propertyInvalidationErrors=ImmutableMap.of(""String_Node_Str"",CheckLevel.ERROR);
  test(options,code,""String_Node_Str"" + ""String_Node_Str"");
  test(options,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"");
}","public void testExports(){
  CompilerOptions options=createCompilerOptions();
  CompilationLevel level=CompilationLevel.ADVANCED_OPTIMIZATIONS;
  level.setOptionsForCompilationLevel(options);
  WarningLevel warnings=WarningLevel.DEFAULT;
  warnings.setOptionsForWarningLevel(options);
  options.setRemoveUnusedPrototypePropertiesInExterns(true);
  String code=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  test(options,code,""String_Node_Str"" + ""String_Node_Str"");
  options.setGenerateExports(true);
  test(options,""String_Node_Str"" + ""String_Node_Str"",FindExportableNodes.NON_GLOBAL_ERROR);
  options.exportLocalPropertyDefinitions=true;
  options.setRemoveUnusedPrototypePropertiesInExterns(false);
  test(options,code,""String_Node_Str"");
  test(options,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  options.setCheckTypes(true);
  options.setDisambiguateProperties(true);
  options.setAmbiguateProperties(true);
  options.propertyInvalidationErrors=ImmutableMap.of(""String_Node_Str"",CheckLevel.ERROR);
  test(options,code,""String_Node_Str"");
  test(options,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"");
}",0.8377331925378388
19320,"public void testIssue724(){
  CompilerOptions options=createCompilerOptions();
  CompilationLevel.ADVANCED_OPTIMIZATIONS.setOptionsForCompilationLevel(options);
  options.setCheckSymbols(false);
  options.setCheckTypes(false);
  String code=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String result=""String_Node_Str"" + ""String_Node_Str"";
  test(options,code,result);
}","public void testIssue724(){
  CompilerOptions options=createCompilerOptions();
  CompilationLevel.ADVANCED_OPTIMIZATIONS.setOptionsForCompilationLevel(options);
  options.setCheckSymbols(false);
  options.setCheckTypes(false);
  String code=LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  String result=""String_Node_Str"";
  test(options,code,result);
}",0.7187864644107351
19321,"private EnvTypePair analyzeLooseCallNodeBwd(Node callNode,TypeEnv outEnv,JSType retType){
  Preconditions.checkArgument(callNode.isCall() || callNode.isNew());
  Preconditions.checkNotNull(retType);
  Node callee=callNode.getFirstChild();
  TypeEnv tmpEnv=outEnv;
  FunctionTypeBuilder builder=new FunctionTypeBuilder(this.commonTypes);
  for (Node arg=callee.getNext(); arg != null; arg=arg.getNext()) {
    EnvTypePair pair=analyzeExprBwd(arg,tmpEnv);
    JSType argType=pair.type;
    tmpEnv=pair.env;
    builder.addReqFormal(isImpreciseType(argType) ? BOTTOM : argType);
  }
  JSType looseRetType=retType.isUnknown() ? BOTTOM : retType;
  JSType looseFunctionType=commonTypes.fromFunctionType(builder.addRetType(looseRetType).addLoose().buildFunction());
  println(""String_Node_Str"",looseFunctionType);
  EnvTypePair calleePair=analyzeExprBwd(callee,tmpEnv,looseFunctionType);
  return new EnvTypePair(calleePair.env,retType);
}","private EnvTypePair analyzeLooseCallNodeBwd(Node callNode,TypeEnv outEnv,JSType retType){
  Preconditions.checkArgument(callNode.isCall() || callNode.isNew());
  Preconditions.checkNotNull(retType);
  Node callee=callNode.getFirstChild();
  TypeEnv tmpEnv=outEnv;
  FunctionTypeBuilder builder=new FunctionTypeBuilder(this.commonTypes);
  Node target=callNode.getFirstChild();
  for (Node arg=callNode.getLastChild(); arg != target; arg=arg.getPrevious()) {
    EnvTypePair pair=analyzeExprBwd(arg,tmpEnv);
    JSType argType=pair.type;
    tmpEnv=pair.env;
    builder.addReqFormalToFront(isImpreciseType(argType) ? BOTTOM : argType);
  }
  JSType looseRetType=retType.isUnknown() ? BOTTOM : retType;
  JSType looseFunctionType=commonTypes.fromFunctionType(builder.addRetType(looseRetType).addLoose().buildFunction());
  println(""String_Node_Str"",looseFunctionType);
  EnvTypePair calleePair=analyzeExprBwd(callee,tmpEnv,looseFunctionType);
  return new EnvTypePair(calleePair.env,retType);
}",0.936656282450675
19322,"public void testBackwardAnalyzedLooseFunctionParametersInRightOrder(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testBackwardAnalyzedLooseFunctionParametersInRightOrder(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.901818181818182
19323,"private EnvTypePair analyzeThisFwd(Node expr,TypeEnv inEnv,JSType requiredType,JSType specializedType){
  mayWarnAboutGlobalThis(expr,currentScope);
  if (!this.currentScope.hasThis()) {
    return new EnvTypePair(inEnv,UNKNOWN);
  }
  JSType inferredType=envGetType(inEnv,THIS_ID);
  if (!inferredType.isSubtypeOf(requiredType)) {
    return new EnvTypePair(inEnv,inferredType);
  }
  JSType preciseType=inferredType.specialize(specializedType);
  if (preciseType.isBottom()) {
    preciseType=pickFallbackTypeAfterBottom(THIS_ID,inferredType,specializedType);
  }
  return EnvTypePair.addBinding(inEnv,THIS_ID,preciseType);
}","private EnvTypePair analyzeThisFwd(Node expr,TypeEnv inEnv,JSType requiredType,JSType specializedType){
  mayWarnAboutGlobalThis(expr);
  if (!this.currentScope.hasThis()) {
    return new EnvTypePair(inEnv,UNKNOWN);
  }
  JSType inferredType=envGetType(inEnv,THIS_ID);
  if (!inferredType.isSubtypeOf(requiredType)) {
    return new EnvTypePair(inEnv,inferredType);
  }
  JSType preciseType=inferredType.specialize(specializedType);
  if (preciseType.isBottom()) {
    preciseType=pickFallbackTypeAfterBottom(THIS_ID,inferredType,specializedType);
  }
  return EnvTypePair.addBinding(inEnv,THIS_ID,preciseType);
}",0.9895245769540691
19324,"private EnvTypePair analyzeFunctionBindFwd(Node call,TypeEnv inEnv){
  Preconditions.checkArgument(call.isCall());
  Bind bindComponents=this.convention.describeFunctionBind(call,true,false);
  Node boundFunNode=bindComponents.target;
  EnvTypePair pair=analyzeExprFwd(boundFunNode,inEnv);
  TypeEnv env=pair.env;
  FunctionType boundFunType=pair.type.getFunTypeIfSingletonObj();
  if (!pair.type.isSubtypeOf(commonTypes.topFunction())) {
    warnings.add(JSError.make(boundFunNode,GOOG_BIND_EXPECTS_FUNCTION,pair.type.toString()));
  }
  if (boundFunType == null || boundFunType.isTopFunction() || boundFunType.isQmarkFunction() || boundFunType.isLoose()) {
    return analyzeCallNodeArgsFwdWhenError(call,env);
  }
  if (boundFunType.isSomeConstructorOrInterface()) {
    warnings.add(JSError.make(call,CANNOT_BIND_CTOR));
    return new EnvTypePair(env,UNKNOWN);
  }
  int callChildCount=call.getChildCount();
  if (NodeUtil.isGoogBind(call.getFirstChild()) && callChildCount <= 2 || !NodeUtil.isGoogPartial(call.getFirstChild()) && callChildCount == 1) {
    warnings.add(JSError.make(call,WRONG_ARGUMENT_COUNT,getReadableCalleeName(call.getFirstChild()),""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  int maxArity=boundFunType.hasRestFormals() ? Integer.MAX_VALUE : boundFunType.getMaxArity();
  int numArgs=bindComponents.getBoundParameterCount();
  if (numArgs > maxArity) {
    warnings.add(JSError.make(call,WRONG_ARGUMENT_COUNT,getReadableCalleeName(call.getFirstChild()),Integer.toString(numArgs),""String_Node_Str"",""String_Node_Str"" + maxArity));
    return analyzeCallNodeArgsFwdWhenError(call,inEnv);
  }
  Node receiver=bindComponents.thisValue;
  if (boundFunType.isGeneric()) {
    Map<String,JSType> typeMap=calcTypeInstantiationFwd(call,receiver,bindComponents.parameters,boundFunType,env);
    boundFunType=boundFunType.instantiateGenerics(typeMap);
  }
  FunctionTypeBuilder builder=new FunctionTypeBuilder(this.commonTypes);
  if (receiver != null) {
    JSType reqThisType=boundFunType.getThisType();
    if (reqThisType == null || boundFunType.isSomeConstructorOrInterface()) {
      reqThisType=JSType.join(NULL,TOP_OBJECT);
    }
    pair=analyzeExprFwd(receiver,env,reqThisType);
    env=pair.env;
    if (!pair.type.isSubtypeOf(reqThisType)) {
      warnings.add(JSError.make(call,INVALID_THIS_TYPE_IN_BIND,errorMsgWithTypeDiff(reqThisType,pair.type)));
    }
  }
  env=analyzeCallNodeArgumentsFwd(call,bindComponents.parameters,boundFunType,new ArrayList<JSType>(),env);
  for (int j=numArgs; j < boundFunType.getMaxArityWithoutRestFormals(); j++) {
    JSType formalType=boundFunType.getFormalType(j);
    if (boundFunType.isRequiredArg(j)) {
      builder.addReqFormal(formalType);
    }
 else {
      builder.addOptFormal(formalType);
    }
  }
  if (boundFunType.hasRestFormals()) {
    builder.addRestFormals(boundFunType.getRestFormalsType());
  }
  return new EnvTypePair(env,commonTypes.fromFunctionType(builder.addRetType(boundFunType.getReturnType()).buildFunction()));
}","private EnvTypePair analyzeFunctionBindFwd(Node call,TypeEnv inEnv){
  Preconditions.checkArgument(call.isCall());
  Bind bindComponents=this.convention.describeFunctionBind(call,true,false);
  Node boundFunNode=bindComponents.target;
  EnvTypePair pair=analyzeExprFwd(boundFunNode,inEnv);
  TypeEnv env=pair.env;
  FunctionType boundFunType=pair.type.getFunTypeIfSingletonObj();
  if (!pair.type.isSubtypeOf(commonTypes.topFunction())) {
    warnings.add(JSError.make(boundFunNode,GOOG_BIND_EXPECTS_FUNCTION,pair.type.toString()));
  }
  if (boundFunType == null || boundFunType.isTopFunction() || boundFunType.isQmarkFunction() || boundFunType.isLoose()) {
    return analyzeCallNodeArgsFwdWhenError(call,env);
  }
  if (boundFunType.isSomeConstructorOrInterface()) {
    warnings.add(JSError.make(call,CANNOT_BIND_CTOR));
    return new EnvTypePair(env,UNKNOWN);
  }
  int callChildCount=call.getChildCount();
  if ((NodeUtil.isGoogBind(call.getFirstChild()) && callChildCount <= 2) || (!NodeUtil.isGoogPartial(call.getFirstChild()) && callChildCount == 1)) {
    warnings.add(JSError.make(call,WRONG_ARGUMENT_COUNT,getReadableCalleeName(call.getFirstChild()),""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  }
  int maxArity=boundFunType.hasRestFormals() ? Integer.MAX_VALUE : boundFunType.getMaxArity();
  int numArgs=bindComponents.getBoundParameterCount();
  if (numArgs > maxArity) {
    warnings.add(JSError.make(call,WRONG_ARGUMENT_COUNT,getReadableCalleeName(call.getFirstChild()),Integer.toString(numArgs),""String_Node_Str"",""String_Node_Str"" + maxArity));
    return analyzeCallNodeArgsFwdWhenError(call,inEnv);
  }
  Node receiver=bindComponents.thisValue;
  if (boundFunType.isGeneric()) {
    Map<String,JSType> typeMap=calcTypeInstantiationFwd(call,receiver,bindComponents.parameters,boundFunType,env);
    boundFunType=boundFunType.instantiateGenerics(typeMap);
  }
  FunctionTypeBuilder builder=new FunctionTypeBuilder(this.commonTypes);
  if (receiver != null) {
    JSType reqThisType=boundFunType.getThisType();
    if (reqThisType == null || boundFunType.isSomeConstructorOrInterface()) {
      reqThisType=JSType.join(NULL,TOP_OBJECT);
    }
    pair=analyzeExprFwd(receiver,env,reqThisType);
    env=pair.env;
    if (!pair.type.isSubtypeOf(reqThisType)) {
      warnings.add(JSError.make(call,INVALID_THIS_TYPE_IN_BIND,errorMsgWithTypeDiff(reqThisType,pair.type)));
    }
  }
  env=analyzeCallNodeArgumentsFwd(call,bindComponents.parameters,boundFunType,new ArrayList<JSType>(),env);
  for (int j=numArgs; j < boundFunType.getMaxArityWithoutRestFormals(); j++) {
    JSType formalType=boundFunType.getFormalType(j);
    if (boundFunType.isRequiredArg(j)) {
      builder.addReqFormal(formalType);
    }
 else {
      builder.addOptFormal(formalType);
    }
  }
  if (boundFunType.hasRestFormals()) {
    builder.addRestFormals(boundFunType.getRestFormalsType());
  }
  return new EnvTypePair(env,commonTypes.fromFunctionType(builder.addRetType(boundFunType.getReturnType()).buildFunction()));
}",0.9993392798149984
19325,"private EnvTypePair analyzeIncDecFwd(Node expr,TypeEnv inEnv,JSType requiredType){
  mayWarnAboutConst(expr);
  Node ch=expr.getFirstChild();
  if (ch.isGetProp() || ch.isGetElem() && ch.getLastChild().isString()) {
    Node recv=ch.getFirstChild();
    String pname=ch.getLastChild().getString();
    EnvTypePair pair=analyzeExprFwd(recv,inEnv);
    JSType recvType=pair.type;
    if (mayWarnAboutConstProp(ch,recvType,new QualifiedName(pname))) {
      pair.type=requiredType;
      return pair;
    }
  }
  return analyzeUnaryNumFwd(expr,inEnv);
}","private EnvTypePair analyzeIncDecFwd(Node expr,TypeEnv inEnv,JSType requiredType){
  mayWarnAboutConst(expr);
  Node ch=expr.getFirstChild();
  if (ch.isGetProp() || (ch.isGetElem() && ch.getLastChild().isString())) {
    Node recv=ch.getFirstChild();
    String pname=ch.getLastChild().getString();
    EnvTypePair pair=analyzeExprFwd(recv,inEnv);
    JSType recvType=pair.type;
    if (mayWarnAboutConstProp(ch,recvType,new QualifiedName(pname))) {
      pair.type=requiredType;
      return pair;
    }
  }
  return analyzeUnaryNumFwd(expr,inEnv);
}",0.998185117967332
19326,"private EnvTypePair analyzeNonStrictComparisonFwd(Node expr,TypeEnv inEnv,JSType specializedType){
  Token tokenType=expr.getToken();
  Node lhs=expr.getFirstChild();
  Node rhs=expr.getLastChild();
  if (specializedType.isTrueOrTruthy() || specializedType.isFalseOrFalsy()) {
    if (lhs.isTypeOf()) {
      return analyzeSpecializedTypeof(lhs,rhs,tokenType,inEnv,specializedType);
    }
 else     if (rhs.isTypeOf()) {
      return analyzeSpecializedTypeof(rhs,lhs,tokenType,inEnv,specializedType);
    }
 else     if (isGoogTypeof(lhs)) {
      return analyzeGoogTypeof(lhs,rhs,inEnv,specializedType);
    }
 else     if (isGoogTypeof(rhs)) {
      return analyzeGoogTypeof(rhs,lhs,inEnv,specializedType);
    }
  }
  EnvTypePair lhsPair=analyzeExprFwd(lhs,inEnv);
  EnvTypePair rhsPair=analyzeExprFwd(rhs,lhsPair.env);
  TypeEnv preciseEnv=rhsPair.env;
  JSType lhsType=lhsPair.type;
  JSType rhsType=rhsPair.type;
  if (tokenType == Token.EQ && specializedType.isTrueOrTruthy() || tokenType == Token.NE && specializedType.isFalseOrFalsy()) {
    if (lhsType.isNullOrUndef()) {
      rhsPair=analyzeExprFwd(rhs,preciseEnv,UNKNOWN,NULL_OR_UNDEFINED);
    }
 else     if (rhsType.isNullOrUndef()) {
      lhsPair=analyzeExprFwd(lhs,preciseEnv,UNKNOWN,NULL_OR_UNDEFINED);
      rhsPair=analyzeExprFwd(rhs,lhsPair.env);
    }
 else     if (!NULL.isSubtypeOf(lhsType) && !UNDEFINED.isSubtypeOf(lhsType)) {
      rhsType=rhsType.removeType(NULL_OR_UNDEFINED);
      rhsPair=analyzeExprFwd(rhs,preciseEnv,UNKNOWN,rhsType);
    }
 else     if (!NULL.isSubtypeOf(rhsType) && !UNDEFINED.isSubtypeOf(rhsType)) {
      lhsType=lhsType.removeType(NULL_OR_UNDEFINED);
      lhsPair=analyzeExprFwd(lhs,preciseEnv,UNKNOWN,lhsType);
      rhsPair=analyzeExprFwd(rhs,lhsPair.env);
    }
  }
 else   if (tokenType == Token.EQ && specializedType.isFalseOrFalsy() || tokenType == Token.NE && specializedType.isTrueOrTruthy()) {
    if (lhsType.isNullOrUndef()) {
      rhsType=rhsType.removeType(NULL_OR_UNDEFINED);
      rhsPair=analyzeExprFwd(rhs,preciseEnv,UNKNOWN,rhsType);
    }
 else     if (rhsType.isNullOrUndef()) {
      lhsType=lhsType.removeType(NULL_OR_UNDEFINED);
      lhsPair=analyzeExprFwd(lhs,preciseEnv,UNKNOWN,lhsType);
      rhsPair=analyzeExprFwd(rhs,lhsPair.env);
    }
  }
  rhsPair.type=BOOLEAN;
  return rhsPair;
}","private EnvTypePair analyzeNonStrictComparisonFwd(Node expr,TypeEnv inEnv,JSType specializedType){
  Token tokenType=expr.getToken();
  Node lhs=expr.getFirstChild();
  Node rhs=expr.getLastChild();
  if (specializedType.isTrueOrTruthy() || specializedType.isFalseOrFalsy()) {
    if (lhs.isTypeOf()) {
      return analyzeSpecializedTypeof(lhs,rhs,tokenType,inEnv,specializedType);
    }
 else     if (rhs.isTypeOf()) {
      return analyzeSpecializedTypeof(rhs,lhs,tokenType,inEnv,specializedType);
    }
 else     if (isGoogTypeof(lhs)) {
      return analyzeGoogTypeof(lhs,rhs,inEnv,specializedType);
    }
 else     if (isGoogTypeof(rhs)) {
      return analyzeGoogTypeof(rhs,lhs,inEnv,specializedType);
    }
  }
  EnvTypePair lhsPair=analyzeExprFwd(lhs,inEnv);
  EnvTypePair rhsPair=analyzeExprFwd(rhs,lhsPair.env);
  TypeEnv preciseEnv=rhsPair.env;
  JSType lhsType=lhsPair.type;
  JSType rhsType=rhsPair.type;
  if ((tokenType == Token.EQ && specializedType.isTrueOrTruthy()) || (tokenType == Token.NE && specializedType.isFalseOrFalsy())) {
    if (lhsType.isNullOrUndef()) {
      rhsPair=analyzeExprFwd(rhs,preciseEnv,UNKNOWN,NULL_OR_UNDEFINED);
    }
 else     if (rhsType.isNullOrUndef()) {
      lhsPair=analyzeExprFwd(lhs,preciseEnv,UNKNOWN,NULL_OR_UNDEFINED);
      rhsPair=analyzeExprFwd(rhs,lhsPair.env);
    }
 else     if (!NULL.isSubtypeOf(lhsType) && !UNDEFINED.isSubtypeOf(lhsType)) {
      rhsType=rhsType.removeType(NULL_OR_UNDEFINED);
      rhsPair=analyzeExprFwd(rhs,preciseEnv,UNKNOWN,rhsType);
    }
 else     if (!NULL.isSubtypeOf(rhsType) && !UNDEFINED.isSubtypeOf(rhsType)) {
      lhsType=lhsType.removeType(NULL_OR_UNDEFINED);
      lhsPair=analyzeExprFwd(lhs,preciseEnv,UNKNOWN,lhsType);
      rhsPair=analyzeExprFwd(rhs,lhsPair.env);
    }
  }
 else   if ((tokenType == Token.EQ && specializedType.isFalseOrFalsy()) || (tokenType == Token.NE && specializedType.isTrueOrTruthy())) {
    if (lhsType.isNullOrUndef()) {
      rhsType=rhsType.removeType(NULL_OR_UNDEFINED);
      rhsPair=analyzeExprFwd(rhs,preciseEnv,UNKNOWN,rhsType);
    }
 else     if (rhsType.isNullOrUndef()) {
      lhsType=lhsType.removeType(NULL_OR_UNDEFINED);
      lhsPair=analyzeExprFwd(lhs,preciseEnv,UNKNOWN,lhsType);
      rhsPair=analyzeExprFwd(rhs,lhsPair.env);
    }
  }
  rhsPair.type=BOOLEAN;
  return rhsPair;
}",0.998281048560378
19327,"private EnvTypePair analyzeInstanceofFwd(Node expr,TypeEnv inEnv,JSType specializedType){
  Node obj=expr.getFirstChild();
  Node ctor=expr.getLastChild();
  EnvTypePair objPair, ctorPair;
  objPair=analyzeExprFwd(obj,inEnv);
  JSType objType=objPair.type;
  if (!objType.isTop() && !objType.isUnknown() && !objType.isTrueOrTruthy()&& !objType.hasNonScalar()&& !objType.hasTypeVariable()) {
    warnInvalidOperand(obj,Token.INSTANCEOF,""String_Node_Str"",objPair.type);
  }
  ctorPair=analyzeExprFwd(ctor,objPair.env,commonTypes.topFunction());
  JSType ctorType=ctorPair.type;
  FunctionType ctorFunType=ctorType.getFunType();
  boolean mayBeConstructorFunction=ctorFunType != null && (ctorFunType.isLoose() || ctorFunType.isQmarkFunction() || ctorFunType.isSomeConstructorOrInterface());
  if (!(ctorType.isUnknown() || mayBeConstructorFunction)) {
    warnInvalidOperand(ctor,Token.INSTANCEOF,""String_Node_Str"",ctorType);
  }
  if (ctorFunType == null || !ctorFunType.isUniqueConstructor() || (!specializedType.isTrueOrTruthy() && !specializedType.isFalseOrFalsy())) {
    ctorPair.type=BOOLEAN;
    return ctorPair;
  }
  JSType instanceType=ctorFunType.getInstanceTypeOfCtor();
  JSType instanceSpecType;
  if (specializedType.isTrueOrTruthy()) {
    instanceSpecType=objType.specialize(instanceType);
  }
 else   if (objType.isTop()) {
    instanceSpecType=objType;
  }
 else {
    instanceSpecType=objType.removeType(instanceType);
  }
  if (!instanceSpecType.isBottom()) {
    objPair=analyzeExprFwd(obj,inEnv,UNKNOWN,instanceSpecType);
    ctorPair=analyzeExprFwd(ctor,objPair.env,commonTypes.topFunction());
  }
  ctorPair.type=BOOLEAN;
  return ctorPair;
}","private EnvTypePair analyzeInstanceofFwd(Node expr,TypeEnv inEnv,JSType specializedType){
  Node obj=expr.getFirstChild();
  Node ctor=expr.getLastChild();
  EnvTypePair objPair;
  EnvTypePair ctorPair;
  objPair=analyzeExprFwd(obj,inEnv);
  JSType objType=objPair.type;
  if (!objType.isTop() && !objType.isUnknown() && !objType.isTrueOrTruthy()&& !objType.hasNonScalar()&& !objType.hasTypeVariable()) {
    warnInvalidOperand(obj,Token.INSTANCEOF,""String_Node_Str"",objPair.type);
  }
  ctorPair=analyzeExprFwd(ctor,objPair.env,commonTypes.topFunction());
  JSType ctorType=ctorPair.type;
  FunctionType ctorFunType=ctorType.getFunType();
  boolean mayBeConstructorFunction=ctorFunType != null && (ctorFunType.isLoose() || ctorFunType.isQmarkFunction() || ctorFunType.isSomeConstructorOrInterface());
  if (!(ctorType.isUnknown() || mayBeConstructorFunction)) {
    warnInvalidOperand(ctor,Token.INSTANCEOF,""String_Node_Str"",ctorType);
  }
  if (ctorFunType == null || !ctorFunType.isUniqueConstructor() || (!specializedType.isTrueOrTruthy() && !specializedType.isFalseOrFalsy())) {
    ctorPair.type=BOOLEAN;
    return ctorPair;
  }
  JSType instanceType=ctorFunType.getInstanceTypeOfCtor();
  JSType instanceSpecType;
  if (specializedType.isTrueOrTruthy()) {
    instanceSpecType=objType.specialize(instanceType);
  }
 else   if (objType.isTop()) {
    instanceSpecType=objType;
  }
 else {
    instanceSpecType=objType.removeType(instanceType);
  }
  if (!instanceSpecType.isBottom()) {
    objPair=analyzeExprFwd(obj,inEnv,UNKNOWN,instanceSpecType);
    ctorPair=analyzeExprFwd(ctor,objPair.env,commonTypes.topFunction());
  }
  ctorPair.type=BOOLEAN;
  return ctorPair;
}",0.9952153110047848
19328,"private boolean mayWarnAboutInexistentProp(Node propAccessNode,JSType recvType,QualifiedName propQname){
  Preconditions.checkState(propAccessNode.isGetProp() || propAccessNode.isGetElem());
  String pname=propQname.toString();
  if (propAccessNode.isGetElem() || !recvType.isLoose() && recvType.hasProp(propQname)) {
    return false;
  }
  if (recvType.isUnknown() || recvType.isTrueOrTruthy() || recvType.isLoose()|| (allowPropertyOnSubtypes && (recvType.mayContainUnknownObject() || recvType.isIObject()))) {
    if (symbolTable.isPropertyDefined(pname)) {
      return false;
    }
    warnings.add(JSError.make(propAccessNode,INEXISTENT_PROPERTY,pname,""String_Node_Str""));
    return true;
  }
  if (allowPropertyOnSubtypes && !recvType.isStruct() && recvType.isPropDefinedOnSubtype(propQname)) {
    return false;
  }
  String recvTypeAsString=recvType.toString();
  Node recv=propAccessNode.getFirstChild();
  String errorMsg;
  if (!recv.isQualifiedName()) {
    errorMsg=recvTypeAsString;
  }
 else   if (recvTypeAsString.length() > 100) {
    errorMsg=recv.getQualifiedName();
  }
 else {
    errorMsg=recv.getQualifiedName() + ""String_Node_Str"" + recvTypeAsString;
  }
  DiagnosticType warningType=recvType.mayHaveProp(propQname) ? POSSIBLY_INEXISTENT_PROPERTY : INEXISTENT_PROPERTY;
  warnings.add(JSError.make(propAccessNode,warningType,pname,errorMsg));
  return true;
}","private boolean mayWarnAboutInexistentProp(Node propAccessNode,JSType recvType,QualifiedName propQname){
  Preconditions.checkState(propAccessNode.isGetProp() || propAccessNode.isGetElem());
  String pname=propQname.toString();
  if (propAccessNode.isGetElem() || (!recvType.isLoose() && recvType.hasProp(propQname))) {
    return false;
  }
  if (recvType.isUnknown() || recvType.isTrueOrTruthy() || recvType.isLoose()|| (allowPropertyOnSubtypes && (recvType.mayContainUnknownObject() || recvType.isIObject()))) {
    if (symbolTable.isPropertyDefined(pname)) {
      return false;
    }
    warnings.add(JSError.make(propAccessNode,INEXISTENT_PROPERTY,pname,""String_Node_Str""));
    return true;
  }
  if (allowPropertyOnSubtypes && !recvType.isStruct() && recvType.isPropDefinedOnSubtype(propQname)) {
    return false;
  }
  String recvTypeAsString=recvType.toString();
  Node recv=propAccessNode.getFirstChild();
  String errorMsg;
  if (!recv.isQualifiedName()) {
    errorMsg=recvTypeAsString;
  }
 else   if (recvTypeAsString.length() > 100) {
    errorMsg=recv.getQualifiedName();
  }
 else {
    errorMsg=recv.getQualifiedName() + ""String_Node_Str"" + recvTypeAsString;
  }
  DiagnosticType warningType=recvType.mayHaveProp(propQname) ? POSSIBLY_INEXISTENT_PROPERTY : INEXISTENT_PROPERTY;
  warnings.add(JSError.make(propAccessNode,warningType,pname,errorMsg));
  return true;
}",0.9992784992784992
19329,"private void mayWarnAboutGlobalThis(Node thisExpr,NTIScope currentScope){
  Preconditions.checkArgument(thisExpr.isThis());
  if (this.currentScope.isTopLevel() || !this.currentScope.hasThis()) {
    Node parent=thisExpr.getParent();
    if ((parent.isGetProp() || parent.isGetElem()) && !NodeUtil.isCallOrNewArgument(this.currentScope.getRoot())) {
      warnings.add(JSError.make(thisExpr,GLOBAL_THIS));
    }
  }
}","private void mayWarnAboutGlobalThis(Node thisExpr){
  Preconditions.checkArgument(thisExpr.isThis());
  if (this.currentScope.isTopLevel() || !this.currentScope.hasThis()) {
    Node parent=thisExpr.getParent();
    if ((parent.isGetProp() || parent.isGetElem()) && !NodeUtil.isCallOrNewArgument(this.currentScope.getRoot())) {
      warnings.add(JSError.make(thisExpr,GLOBAL_THIS));
    }
  }
}",0.9729064039408868
19330,"private void warnInvalidOperand(Node expr,Token operatorType,Object expected,Object actual){
  Preconditions.checkArgument((expected instanceof String) || (expected instanceof JSType));
  Preconditions.checkArgument((actual instanceof String) || (actual instanceof JSType));
  if (expected instanceof JSType && actual instanceof JSType) {
    warnings.add(JSError.make(expr,INVALID_OPERAND_TYPE,operatorType.toString(),errorMsgWithTypeDiff((JSType)expected,(JSType)actual)));
  }
 else {
    warnings.add(JSError.make(expr,INVALID_OPERAND_TYPE,operatorType.toString(),""String_Node_Str"" + expected.toString() + ""String_Node_Str""+ ""String_Node_Str""+ actual.toString()+ ""String_Node_Str""));
  }
}","private void warnInvalidOperand(Node expr,Token operatorType,Object expected,Object actual){
  Preconditions.checkArgument((expected instanceof String) || (expected instanceof JSType));
  Preconditions.checkArgument((actual instanceof String) || (actual instanceof JSType));
  if (expected instanceof JSType && actual instanceof JSType) {
    warnings.add(JSError.make(expr,INVALID_OPERAND_TYPE,operatorType.toString(),errorMsgWithTypeDiff((JSType)expected,(JSType)actual)));
  }
 else {
    warnings.add(JSError.make(expr,INVALID_OPERAND_TYPE,operatorType.toString(),""String_Node_Str"" + expected + ""String_Node_Str""+ ""String_Node_Str""+ actual+ ""String_Node_Str""));
  }
}",0.9838709677419356
19331,"private EnvTypePair analyzePropAccessFwd(Node receiver,String pname,TypeEnv inEnv,JSType requiredType,JSType specializedType){
  QualifiedName propQname=new QualifiedName(pname);
  Node propAccessNode=receiver.getParent();
  EnvTypePair pair;
  JSType reqObjType=pickReqObjType(propAccessNode);
  JSType recvReqType, recvSpecType;
  if ((NodeUtil.isPropertyTest(compiler,propAccessNode) && !specializedType.isFalseOrFalsy()) || (NodeUtil.isPropertyAbsenceTest(propAccessNode) && !specializedType.isTrueOrTruthy()) || specializedType.isTrueOrTruthy()) {
    recvReqType=reqObjType;
    pair=analyzeExprFwd(receiver,inEnv,recvReqType);
    JSType subtypeWithProp=pair.type.findSubtypeWithProp(propQname);
    if (subtypeWithProp.isBottom()) {
      recvSpecType=reqObjType;
    }
 else {
      recvSpecType=subtypeWithProp;
    }
    if (specializedType.isTrueOrTruthy()) {
      recvSpecType=recvSpecType.withLoose().withProperty(propQname,specializedType);
    }
 else {
      recvSpecType=recvSpecType.withProperty(propQname,specializedType);
    }
  }
 else   if (specializedType.isFalseOrFalsy()) {
    recvReqType=recvSpecType=reqObjType;
  }
 else {
    recvReqType=reqObjType.withProperty(propQname,requiredType);
    recvSpecType=reqObjType.withProperty(propQname,specializedType);
  }
  pair=analyzeExprFwd(receiver,inEnv,recvReqType,recvSpecType);
  pair=mayWarnAboutNullableReferenceAndTighten(receiver,pair.type,recvSpecType,pair.env);
  JSType recvType=pair.type.autobox();
  if (recvType.isUnknown() || recvType.isTrueOrTruthy()) {
    mayWarnAboutInexistentProp(propAccessNode,recvType,propQname);
    return new EnvTypePair(pair.env,requiredType);
  }
  if (mayWarnAboutNonObject(receiver,recvType,specializedType)) {
    return new EnvTypePair(pair.env,requiredType);
  }
  FunctionType ft=recvType.getFunTypeIfSingletonObj();
  if (ft != null && (pname.equals(""String_Node_Str"") || pname.equals(""String_Node_Str""))) {
    if (ft.isAbstract()) {
      String funName=receiver.isQualifiedName() ? receiver.getQualifiedName() : ""String_Node_Str"";
      warnings.add(JSError.make(propAccessNode,ABSTRACT_SUPER_METHOD_NOT_CALLABLE,funName));
    }
    return new EnvTypePair(pair.env,pname.equals(""String_Node_Str"") ? commonTypes.fromFunctionType(ft.transformByCallProperty()) : commonTypes.fromFunctionType(ft.transformByApplyProperty()));
  }
  if (this.convention.isSuperClassReference(pname)) {
    if (ft != null && ft.isUniqueConstructor()) {
      JSType result=ft.getSuperPrototype();
      pair.type=result != null ? result : UNDEFINED;
      return pair;
    }
  }
  if (propAccessNode.isGetProp() && mayWarnAboutDictPropAccess(receiver,recvType)) {
    return new EnvTypePair(pair.env,requiredType);
  }
  if (recvType.isTop()) {
    recvType=TOP_OBJECT;
  }
  if (propAccessNode.getParent().isDelProp() && recvType.hasConstantProp(propQname)) {
    warnings.add(JSError.make(propAccessNode.getParent(),CONST_PROPERTY_DELETED,pname));
  }
  QualifiedName getterPname=new QualifiedName(JSType.createGetterPropName(pname));
  if (recvType.hasProp(getterPname)) {
    return new EnvTypePair(pair.env,recvType.getProp(getterPname));
  }
  JSType resultType=recvType.getProp(propQname);
  if (resultType != null && resultType.isBottom()) {
    warnings.add(JSError.make(propAccessNode,BOTTOM_PROP,pname,recvType.toString()));
    return new EnvTypePair(pair.env,UNKNOWN);
  }
  if (!propAccessNode.getParent().isExprResult() && !specializedType.isTrueOrTruthy() && !specializedType.isFalseOrFalsy()&& !recvType.mayBeDict()&& !mayWarnAboutInexistentProp(propAccessNode,recvType,propQname)&& recvType.hasProp(propQname)&& !resultType.isSubtypeOf(requiredType)&& tightenPropertyTypeAndDontWarn(receiver.isName() ? receiver.getString() : null,propAccessNode,recvType,recvType.getDeclaredProp(propQname),resultType,requiredType)) {
    resultType=resultType.specialize(requiredType);
    LValueResultFwd lvr=analyzeLValueFwd(propAccessNode,inEnv,resultType);
    TypeEnv updatedEnv=updateLvalueTypeInEnv(lvr.env,propAccessNode,lvr.ptr,resultType);
    return new EnvTypePair(updatedEnv,resultType);
  }
  if (resultType == null) {
    resultType=UNKNOWN;
  }
  return new EnvTypePair(pair.env,resultType);
}","private EnvTypePair analyzePropAccessFwd(Node receiver,String pname,TypeEnv inEnv,JSType requiredType,JSType specializedType){
  QualifiedName propQname=new QualifiedName(pname);
  Node propAccessNode=receiver.getParent();
  EnvTypePair pair;
  JSType reqObjType=pickReqObjType(propAccessNode);
  JSType recvReqType;
  JSType recvSpecType;
  if ((NodeUtil.isPropertyTest(compiler,propAccessNode) && !specializedType.isFalseOrFalsy()) || (NodeUtil.isPropertyAbsenceTest(propAccessNode) && !specializedType.isTrueOrTruthy()) || specializedType.isTrueOrTruthy()) {
    recvReqType=reqObjType;
    pair=analyzeExprFwd(receiver,inEnv,recvReqType);
    JSType subtypeWithProp=pair.type.findSubtypeWithProp(propQname);
    if (subtypeWithProp.isBottom()) {
      recvSpecType=reqObjType;
    }
 else {
      recvSpecType=subtypeWithProp;
    }
    if (specializedType.isTrueOrTruthy()) {
      recvSpecType=recvSpecType.withLoose().withProperty(propQname,specializedType);
    }
 else {
      recvSpecType=recvSpecType.withProperty(propQname,specializedType);
    }
  }
 else   if (specializedType.isFalseOrFalsy()) {
    recvReqType=recvSpecType=reqObjType;
  }
 else {
    recvReqType=reqObjType.withProperty(propQname,requiredType);
    recvSpecType=reqObjType.withProperty(propQname,specializedType);
  }
  pair=analyzeExprFwd(receiver,inEnv,recvReqType,recvSpecType);
  pair=mayWarnAboutNullableReferenceAndTighten(receiver,pair.type,recvSpecType,pair.env);
  JSType recvType=pair.type.autobox();
  if (recvType.isUnknown() || recvType.isTrueOrTruthy()) {
    mayWarnAboutInexistentProp(propAccessNode,recvType,propQname);
    return new EnvTypePair(pair.env,requiredType);
  }
  if (mayWarnAboutNonObject(receiver,recvType,specializedType)) {
    return new EnvTypePair(pair.env,requiredType);
  }
  FunctionType ft=recvType.getFunTypeIfSingletonObj();
  if (ft != null && (pname.equals(""String_Node_Str"") || pname.equals(""String_Node_Str""))) {
    if (ft.isAbstract()) {
      String funName=receiver.isQualifiedName() ? receiver.getQualifiedName() : ""String_Node_Str"";
      warnings.add(JSError.make(propAccessNode,ABSTRACT_SUPER_METHOD_NOT_CALLABLE,funName));
    }
    return new EnvTypePair(pair.env,pname.equals(""String_Node_Str"") ? commonTypes.fromFunctionType(ft.transformByCallProperty()) : commonTypes.fromFunctionType(ft.transformByApplyProperty()));
  }
  if (this.convention.isSuperClassReference(pname)) {
    if (ft != null && ft.isUniqueConstructor()) {
      JSType result=ft.getSuperPrototype();
      pair.type=result != null ? result : UNDEFINED;
      return pair;
    }
  }
  if (propAccessNode.isGetProp() && mayWarnAboutDictPropAccess(receiver,recvType)) {
    return new EnvTypePair(pair.env,requiredType);
  }
  if (recvType.isTop()) {
    recvType=TOP_OBJECT;
  }
  if (propAccessNode.getParent().isDelProp() && recvType.hasConstantProp(propQname)) {
    warnings.add(JSError.make(propAccessNode.getParent(),CONST_PROPERTY_DELETED,pname));
  }
  QualifiedName getterPname=new QualifiedName(JSType.createGetterPropName(pname));
  if (recvType.hasProp(getterPname)) {
    return new EnvTypePair(pair.env,recvType.getProp(getterPname));
  }
  JSType resultType=recvType.getProp(propQname);
  if (resultType != null && resultType.isBottom()) {
    warnings.add(JSError.make(propAccessNode,BOTTOM_PROP,pname,recvType.toString()));
    return new EnvTypePair(pair.env,UNKNOWN);
  }
  if (!propAccessNode.getParent().isExprResult() && !specializedType.isTrueOrTruthy() && !specializedType.isFalseOrFalsy()&& !recvType.mayBeDict()&& !mayWarnAboutInexistentProp(propAccessNode,recvType,propQname)&& recvType.hasProp(propQname)&& !resultType.isSubtypeOf(requiredType)&& tightenPropertyTypeAndDontWarn(receiver.isName() ? receiver.getString() : null,propAccessNode,recvType,recvType.getDeclaredProp(propQname),resultType,requiredType)) {
    resultType=resultType.specialize(requiredType);
    LValueResultFwd lvr=analyzeLValueFwd(propAccessNode,inEnv,resultType);
    TypeEnv updatedEnv=updateLvalueTypeInEnv(lvr.env,propAccessNode,lvr.ptr,resultType);
    return new EnvTypePair(updatedEnv,resultType);
  }
  if (resultType == null) {
    resultType=UNKNOWN;
  }
  return new EnvTypePair(pair.env,resultType);
}",0.9986980707776068
19332,"private EnvTypePair analyzeObjLitFwd(Node objLit,TypeEnv inEnv,JSType requiredType,JSType specializedType){
  if (NodeUtil.isEnumDecl(objLit.getParent())) {
    return analyzeEnumObjLitFwd(objLit,inEnv,requiredType);
  }
  JSDocInfo jsdoc=objLit.getJSDocInfo();
  boolean isStruct=jsdoc != null && jsdoc.makesStructs();
  boolean isDict=jsdoc != null && jsdoc.makesDicts();
  TypeEnv env=inEnv;
  JSType result=pickReqObjType(objLit);
  for (  Node prop : objLit.children()) {
    if (isStruct && prop.isQuotedString()) {
      warnings.add(JSError.make(prop,ILLEGAL_OBJLIT_KEY,""String_Node_Str""));
    }
 else     if (isDict && !prop.isQuotedString()) {
      warnings.add(JSError.make(prop,ILLEGAL_OBJLIT_KEY,""String_Node_Str""));
    }
    String pname=NodeUtil.getObjectLitKeyName(prop);
    if (prop.isGetterDef() || prop.isSetterDef()) {
      EnvTypePair pair=analyzeExprFwd(prop.getFirstChild(),env);
      FunctionType funType=pair.type.getFunType();
      Preconditions.checkNotNull(funType);
      String specialPropName;
      JSType propType;
      if (prop.isGetterDef()) {
        specialPropName=JSType.createGetterPropName(pname);
        propType=funType.getReturnType();
      }
 else {
        specialPropName=JSType.createSetterPropName(pname);
        propType=pair.type;
      }
      result=result.withProperty(new QualifiedName(specialPropName),propType);
      env=pair.env;
    }
 else {
      QualifiedName qname=new QualifiedName(pname);
      JSType jsdocType=symbolTable.getPropDeclaredType(prop);
      JSType reqPtype, specPtype;
      if (jsdocType != null) {
        reqPtype=specPtype=jsdocType;
      }
 else       if (requiredType.mayHaveProp(qname)) {
        reqPtype=specPtype=requiredType.getProp(qname);
        if (specializedType.mayHaveProp(qname)) {
          specPtype=specializedType.getProp(qname);
        }
      }
 else {
        reqPtype=specPtype=UNKNOWN;
      }
      EnvTypePair pair=analyzeExprFwd(prop.getFirstChild(),env,reqPtype,specPtype);
      if (jsdocType != null) {
        result=result.withDeclaredProperty(qname,jsdocType,false);
        if (!pair.type.isSubtypeOf(jsdocType)) {
          warnings.add(JSError.make(prop,INVALID_OBJLIT_PROPERTY_TYPE,errorMsgWithTypeDiff(jsdocType,pair.type)));
          pair.type=jsdocType;
        }
      }
      result=result.withProperty(qname,pair.type);
      env=pair.env;
    }
  }
  result=mayAdjustObjLitType(objLit,jsdoc,inEnv,result);
  return new EnvTypePair(env,result);
}","private EnvTypePair analyzeObjLitFwd(Node objLit,TypeEnv inEnv,JSType requiredType,JSType specializedType){
  if (NodeUtil.isEnumDecl(objLit.getParent())) {
    return analyzeEnumObjLitFwd(objLit,inEnv,requiredType);
  }
  JSDocInfo jsdoc=objLit.getJSDocInfo();
  boolean isStruct=jsdoc != null && jsdoc.makesStructs();
  boolean isDict=jsdoc != null && jsdoc.makesDicts();
  TypeEnv env=inEnv;
  JSType result=pickReqObjType(objLit);
  for (  Node prop : objLit.children()) {
    if (isStruct && prop.isQuotedString()) {
      warnings.add(JSError.make(prop,ILLEGAL_OBJLIT_KEY,""String_Node_Str""));
    }
 else     if (isDict && !prop.isQuotedString()) {
      warnings.add(JSError.make(prop,ILLEGAL_OBJLIT_KEY,""String_Node_Str""));
    }
    String pname=NodeUtil.getObjectLitKeyName(prop);
    if (prop.isGetterDef() || prop.isSetterDef()) {
      EnvTypePair pair=analyzeExprFwd(prop.getFirstChild(),env);
      FunctionType funType=pair.type.getFunType();
      Preconditions.checkNotNull(funType);
      String specialPropName;
      JSType propType;
      if (prop.isGetterDef()) {
        specialPropName=JSType.createGetterPropName(pname);
        propType=funType.getReturnType();
      }
 else {
        specialPropName=JSType.createSetterPropName(pname);
        propType=pair.type;
      }
      result=result.withProperty(new QualifiedName(specialPropName),propType);
      env=pair.env;
    }
 else {
      QualifiedName qname=new QualifiedName(pname);
      JSType jsdocType=symbolTable.getPropDeclaredType(prop);
      JSType reqPtype;
      JSType specPtype;
      if (jsdocType != null) {
        reqPtype=specPtype=jsdocType;
      }
 else       if (requiredType.mayHaveProp(qname)) {
        reqPtype=specPtype=requiredType.getProp(qname);
        if (specializedType.mayHaveProp(qname)) {
          specPtype=specializedType.getProp(qname);
        }
      }
 else {
        reqPtype=specPtype=UNKNOWN;
      }
      EnvTypePair pair=analyzeExprFwd(prop.getFirstChild(),env,reqPtype,specPtype);
      if (jsdocType != null) {
        result=result.withDeclaredProperty(qname,jsdocType,false);
        if (!pair.type.isSubtypeOf(jsdocType)) {
          warnings.add(JSError.make(prop,INVALID_OBJLIT_PROPERTY_TYPE,errorMsgWithTypeDiff(jsdocType,pair.type)));
          pair.type=jsdocType;
        }
      }
      result=result.withProperty(qname,pair.type);
      env=pair.env;
    }
  }
  result=mayAdjustObjLitType(objLit,jsdoc,inEnv,result);
  return new EnvTypePair(env,result);
}",0.9969957941117564
19333,"void add(JSError warning){
  String filename=warning.node.getSourceFileName();
  if (filename != null && filename.startsWith(""String_Node_Str"") || JSType.mockToString) {
    return;
  }
  compiler.report(warning);
}","void add(JSError warning){
  String filename=warning.node.getSourceFileName();
  if ((filename != null && filename.startsWith(""String_Node_Str"")) || JSType.mockToString) {
    return;
  }
  compiler.report(warning);
}",0.9953703703703703
19334,"private TypeEnv collectTypesForFreeVarsFwd(Node n,TypeEnv env){
  Preconditions.checkArgument(n.isFunction() || n.isName() && NodeUtil.isCallOrNewTarget(n));
  String fnName=n.isFunction() ? symbolTable.getFunInternalName(n) : n.getString();
  NTIScope innerScope=this.currentScope.getScope(fnName);
  for (  String freeVar : innerScope.getOuterVars()) {
    if (innerScope.getDeclaredTypeOf(freeVar) == null) {
      FunctionType summary=summaries.get(innerScope).getFunType();
      JSType outerType=envGetType(env,freeVar);
      if (outerType == null) {
        outerType=UNKNOWN;
      }
      JSType innerType=summary.getOuterVarPrecondition(freeVar);
      if (!innerType.isLoose() && (n.isName() || n.isFunction() && !outerType.isUndefined()) && !JSType.haveCommonSubtype(outerType,innerType)) {
        warnings.add(JSError.make(n,CROSS_SCOPE_GOTCHA,freeVar,outerType.toString(),innerType.toString()));
      }
      env=envPutType(env,freeVar,n.isFunction() ? JSType.join(innerType,outerType) : innerType);
    }
  }
  return env;
}","private TypeEnv collectTypesForFreeVarsFwd(Node n,TypeEnv env){
  Preconditions.checkArgument(n.isFunction() || (n.isName() && NodeUtil.isCallOrNewTarget(n)));
  String fnName=n.isFunction() ? symbolTable.getFunInternalName(n) : n.getString();
  NTIScope innerScope=this.currentScope.getScope(fnName);
  for (  String freeVar : innerScope.getOuterVars()) {
    if (innerScope.getDeclaredTypeOf(freeVar) == null) {
      FunctionType summary=summaries.get(innerScope).getFunType();
      JSType outerType=envGetType(env,freeVar);
      if (outerType == null) {
        outerType=UNKNOWN;
      }
      JSType innerType=summary.getOuterVarPrecondition(freeVar);
      if (!innerType.isLoose() && (n.isName() || (n.isFunction() && !outerType.isUndefined())) && !JSType.haveCommonSubtype(outerType,innerType)) {
        warnings.add(JSError.make(n,CROSS_SCOPE_GOTCHA,freeVar,outerType.toString(),innerType.toString()));
      }
      env=envPutType(env,freeVar,n.isFunction() ? JSType.join(innerType,outerType) : innerType);
    }
  }
  return env;
}",0.9980842911877394
19335,"private LValueResultFwd analyzeLValueFwd(Node expr,TypeEnv inEnv,JSType type,boolean insideQualifiedName){
  LValueResultFwd lvalResult=null;
switch (expr.getToken()) {
case THIS:
{
      mayWarnAboutGlobalThis(expr,currentScope);
      if (this.currentScope.hasThis()) {
        lvalResult=new LValueResultFwd(inEnv,envGetType(inEnv,THIS_ID),this.currentScope.getDeclaredTypeOf(THIS_ID),new QualifiedName(THIS_ID));
      }
 else {
        lvalResult=new LValueResultFwd(inEnv,UNKNOWN,null,null);
      }
      break;
    }
case NAME:
{
    String varName=expr.getString();
    JSType varType=analyzeExprFwd(expr,inEnv).type;
    lvalResult=new LValueResultFwd(inEnv,varType,this.currentScope.getDeclaredTypeOf(varName),varType.hasNonScalar() ? new QualifiedName(varName) : null);
    break;
  }
case GETPROP:
case GETELEM:
{
  Node obj=expr.getFirstChild();
  Node prop=expr.getLastChild();
  QualifiedName pname=expr.isGetProp() || prop.isString() ? new QualifiedName(prop.getString()) : null;
  LValueResultFwd recvLvalue=analyzeReceiverLvalFwd(obj,pname,inEnv,type);
  if (!recvLvalue.type.isSubtypeOf(TOP_OBJECT)) {
    EnvTypePair pair=analyzeExprFwd(prop,recvLvalue.env,type);
    lvalResult=new LValueResultFwd(pair.env,type,null,null);
    break;
  }
  JSType indexType=recvLvalue.type.getIndexType();
  if (expr.isGetElem() && indexType != null) {
    lvalResult=analyzeIObjectElmLvalFwd(prop,recvLvalue,indexType);
    break;
  }
  if (expr.isGetProp() || prop.isString()) {
    lvalResult=analyzePropLValFwd(obj,pname,recvLvalue,type,insideQualifiedName);
    break;
  }
  EnvTypePair pair=analyzeExprFwd(expr,recvLvalue.env,type);
  lvalResult=new LValueResultFwd(pair.env,pair.type,null,null);
  break;
}
case VAR:
{
Preconditions.checkState(expr.getParent().isForIn());
Node vdecl=expr.getFirstChild();
String name=vdecl.getString();
Preconditions.checkState(!vdecl.hasChildren());
return new LValueResultFwd(inEnv,STRING,null,new QualifiedName(name));
}
default :
{
Preconditions.checkState(insideQualifiedName);
EnvTypePair pair=analyzeExprFwd(expr,inEnv,type);
return new LValueResultFwd(pair.env,pair.type,null,null);
}
}
maybeSetTypeI(expr,lvalResult.type);
mayWarnAboutUnknownType(expr,lvalResult.type);
return lvalResult;
}","private LValueResultFwd analyzeLValueFwd(Node expr,TypeEnv inEnv,JSType type,boolean insideQualifiedName){
  LValueResultFwd lvalResult=null;
switch (expr.getToken()) {
case THIS:
{
      mayWarnAboutGlobalThis(expr);
      if (this.currentScope.hasThis()) {
        lvalResult=new LValueResultFwd(inEnv,envGetType(inEnv,THIS_ID),this.currentScope.getDeclaredTypeOf(THIS_ID),new QualifiedName(THIS_ID));
      }
 else {
        lvalResult=new LValueResultFwd(inEnv,UNKNOWN,null,null);
      }
      break;
    }
case NAME:
{
    String varName=expr.getString();
    JSType varType=analyzeExprFwd(expr,inEnv).type;
    lvalResult=new LValueResultFwd(inEnv,varType,this.currentScope.getDeclaredTypeOf(varName),varType.hasNonScalar() ? new QualifiedName(varName) : null);
    break;
  }
case GETPROP:
case GETELEM:
{
  Node obj=expr.getFirstChild();
  Node prop=expr.getLastChild();
  QualifiedName pname=expr.isGetProp() || prop.isString() ? new QualifiedName(prop.getString()) : null;
  LValueResultFwd recvLvalue=analyzeReceiverLvalFwd(obj,pname,inEnv,type);
  if (!recvLvalue.type.isSubtypeOf(TOP_OBJECT)) {
    EnvTypePair pair=analyzeExprFwd(prop,recvLvalue.env,type);
    lvalResult=new LValueResultFwd(pair.env,type,null,null);
    break;
  }
  JSType indexType=recvLvalue.type.getIndexType();
  if (expr.isGetElem() && indexType != null) {
    lvalResult=analyzeIObjectElmLvalFwd(prop,recvLvalue,indexType);
    break;
  }
  if (expr.isGetProp() || prop.isString()) {
    lvalResult=analyzePropLValFwd(obj,pname,recvLvalue,type,insideQualifiedName);
    break;
  }
  EnvTypePair pair=analyzeExprFwd(expr,recvLvalue.env,type);
  lvalResult=new LValueResultFwd(pair.env,pair.type,null,null);
  break;
}
case VAR:
{
Preconditions.checkState(expr.getParent().isForIn());
Node vdecl=expr.getFirstChild();
String name=vdecl.getString();
Preconditions.checkState(!vdecl.hasChildren());
return new LValueResultFwd(inEnv,STRING,null,new QualifiedName(name));
}
default :
{
Preconditions.checkState(insideQualifiedName);
EnvTypePair pair=analyzeExprFwd(expr,inEnv,type);
return new LValueResultFwd(pair.env,pair.type,null,null);
}
}
maybeSetTypeI(expr,lvalResult.type);
mayWarnAboutUnknownType(expr,lvalResult.type);
return lvalResult;
}",0.9970975664210762
19336,"private EnvTypePair analyzeCallNewBwd(Node expr,TypeEnv outEnv,JSType requiredType){
  Preconditions.checkArgument(expr.isNew() || expr.isCall());
  Node callee=expr.getFirstChild();
  EnvTypePair pair=analyzeExprBwd(callee,outEnv,commonTypes.topFunction());
  TypeEnv envAfterCallee=pair.env;
  FunctionType funType=pair.type.getFunType();
  if (funType == null) {
    return analyzeCallNodeArgumentsBwd(expr,envAfterCallee);
  }
 else   if (funType.isLoose()) {
    return analyzeLooseCallNodeBwd(expr,envAfterCallee,requiredType);
  }
 else   if (expr.isCall() && funType.isSomeConstructorOrInterface() || expr.isNew() && !funType.isSomeConstructorOrInterface()) {
    return analyzeCallNodeArgumentsBwd(expr,envAfterCallee);
  }
 else   if (funType.isTopFunction()) {
    return analyzeCallNodeArgumentsBwd(expr,envAfterCallee);
  }
  if (callee.isName() && !funType.isGeneric() && expr.isCall()) {
    createDeferredCheckBwd(expr,requiredType);
  }
  int numArgs=expr.getChildCount() - 1;
  if (numArgs < funType.getMinArity() || numArgs > funType.getMaxArity()) {
    return analyzeCallNodeArgumentsBwd(expr,envAfterCallee);
  }
  if (funType.isGeneric()) {
    Map<String,JSType> typeMap=calcTypeInstantiationBwd(expr,funType,envAfterCallee);
    funType=funType.instantiateGenerics(typeMap);
  }
  TypeEnv tmpEnv=envAfterCallee;
  Node target=expr.getFirstChild();
  int i=expr.getChildCount() - 1;
  for (Node arg=expr.getLastChild(); arg != target; arg=arg.getPrevious()) {
    i--;
    JSType formalType=funType.getFormalType(i);
    if (formalType.isBottom()) {
      formalType=UNKNOWN;
    }
    tmpEnv=analyzeExprBwd(arg,tmpEnv,formalType).env;
  }
  JSType retType=expr.isNew() ? funType.getThisType() : funType.getReturnType();
  return new EnvTypePair(tmpEnv,retType);
}","private EnvTypePair analyzeCallNewBwd(Node expr,TypeEnv outEnv,JSType requiredType){
  Preconditions.checkArgument(expr.isNew() || expr.isCall());
  Node callee=expr.getFirstChild();
  EnvTypePair pair=analyzeExprBwd(callee,outEnv,commonTypes.topFunction());
  TypeEnv envAfterCallee=pair.env;
  FunctionType funType=pair.type.getFunType();
  if (funType == null) {
    return analyzeCallNodeArgumentsBwd(expr,envAfterCallee);
  }
 else   if (funType.isLoose()) {
    return analyzeLooseCallNodeBwd(expr,envAfterCallee,requiredType);
  }
 else   if ((expr.isCall() && funType.isSomeConstructorOrInterface()) || (expr.isNew() && !funType.isSomeConstructorOrInterface())) {
    return analyzeCallNodeArgumentsBwd(expr,envAfterCallee);
  }
 else   if (funType.isTopFunction()) {
    return analyzeCallNodeArgumentsBwd(expr,envAfterCallee);
  }
  if (callee.isName() && !funType.isGeneric() && expr.isCall()) {
    createDeferredCheckBwd(expr,requiredType);
  }
  int numArgs=expr.getChildCount() - 1;
  if (numArgs < funType.getMinArity() || numArgs > funType.getMaxArity()) {
    return analyzeCallNodeArgumentsBwd(expr,envAfterCallee);
  }
  if (funType.isGeneric()) {
    Map<String,JSType> typeMap=calcTypeInstantiationBwd(expr,funType,envAfterCallee);
    funType=funType.instantiateGenerics(typeMap);
  }
  TypeEnv tmpEnv=envAfterCallee;
  Node target=expr.getFirstChild();
  int i=expr.getChildCount() - 1;
  for (Node arg=expr.getLastChild(); arg != target; arg=arg.getPrevious()) {
    i--;
    JSType formalType=funType.getFormalType(i);
    if (formalType.isBottom()) {
      formalType=UNKNOWN;
    }
    tmpEnv=analyzeExprBwd(arg,tmpEnv,formalType).env;
  }
  JSType retType=expr.isNew() ? funType.getThisType() : funType.getReturnType();
  return new EnvTypePair(tmpEnv,retType);
}",0.9988826815642458
19337,"private void validateCatch(Node n){
  validateNodeType(Token.CATCH,n);
  validateChildCount(n);
  Node caught=n.getFirstChild();
  if (caught.isName()) {
    validateName(caught);
  }
 else   if (n.isArrayPattern()) {
    validateArrayPattern(Token.CATCH,caught);
  }
 else {
    validateObjectPattern(Token.CATCH,caught);
  }
  validateBlock(n.getLastChild());
}","private void validateCatch(Node n){
  validateNodeType(Token.CATCH,n);
  validateChildCount(n);
  Node caught=n.getFirstChild();
  if (caught.isName()) {
    validateName(caught);
  }
 else   if (caught.isArrayPattern()) {
    validateArrayPattern(Token.CATCH,caught);
  }
 else {
    validateObjectPattern(Token.CATCH,caught);
  }
  validateBlock(n.getLastChild());
}",0.9904240766073872
19338,"/** 
 * Gets the outcome scope if we do know the outcome of the entire expression.
 */
FlowScope getOutcomeFlowScope(Token nodeType,boolean outcome){
  if (nodeType == Token.AND && outcome || nodeType == Token.OR && !outcome) {
    return rightScope;
  }
 else {
    return getJoinedFlowScope();
  }
}","/** 
 * Gets the outcome scope if we do know the outcome of the entire expression.
 */
FlowScope getOutcomeFlowScope(Token nodeType,boolean outcome){
  if ((nodeType == Token.AND && outcome) || (nodeType == Token.OR && !outcome)) {
    return rightScope;
  }
 else {
    return getJoinedFlowScope();
  }
}",0.9933993399339934
19339,"/** 
 * @return Whether the alias was recorded.
 */
private boolean maybeRecordAlias(String name,Node parent,@Nullable NameInformation referring,String referringName){
  boolean isPrototypePropAssignment=parent.isAssign() && NodeUtil.isPrototypeProperty(parent.getFirstChild());
  if ((parent.isName() || parent.isAssign()) && !isPrototypePropAssignment && referring != null && scopes.containsEntry(parent,referring)) {
    recordAlias(referringName,name);
    return true;
  }
  return false;
}","/** 
 * @return Whether the alias was recorded.
 */
private boolean maybeRecordAlias(String name,Node n,@Nullable NameInformation referring,String referringName){
  Node consumer=getConsumingExpression(n);
  boolean isPrototypePropAssignment=consumer.isAssign() && NodeUtil.isPrototypeProperty(consumer.getFirstChild());
  if ((consumer.isName() || consumer.isAssign()) && !isPrototypePropAssignment && referring != null && scopes.containsEntry(consumer,referring)) {
    recordAlias(referringName,name);
    return true;
  }
  return false;
}",0.884393063583815
19340,"private void maybeRecordReferenceOrAlias(NodeTraversal t,Node n,Node parent,NameInformation nameInfo,@Nullable NameInformation referring){
  String referringName=""String_Node_Str"";
  if (referring != null) {
    referringName=referring.isPrototype ? referring.prototypeClass : referring.name;
  }
  String name=nameInfo.name;
  if (maybeHiddenAlias(n)) {
    recordAlias(name,WINDOW);
  }
  if (nameInfo.isExternallyReferenceable) {
    recordReference(WINDOW,name,RefType.REGULAR);
    maybeRecordAlias(name,parent,referring,referringName);
    return;
  }
  if (NodeUtil.isVarOrSimpleAssignLhs(n,parent)) {
    if (referring != null) {
      recordReference(referringName,name,RefType.REGULAR);
    }
    return;
  }
  if (nodesToKeep.contains(n)) {
    List<NameInformation> functionScopes=getEnclosingFunctionDependencyScope(t);
    if (!functionScopes.isEmpty()) {
      for (      NameInformation functionScope : functionScopes) {
        recordReference(functionScope.name,name,RefType.REGULAR);
      }
    }
 else {
      recordReference(WINDOW,name,RefType.REGULAR);
      if (referring != null) {
        maybeRecordAlias(name,parent,referring,referringName);
      }
    }
  }
 else   if (referring != null) {
    if (!maybeRecordAlias(name,parent,referring,referringName)) {
      RefType depType=referring.onlyAffectsClassDef ? RefType.INHERITANCE : RefType.REGULAR;
      recordReference(referringName,name,depType);
    }
  }
 else {
    for (    Node ancestor : n.getAncestors()) {
      if (NodeUtil.isAssignmentOp(ancestor) || ancestor.isFunction()) {
        recordReference(WINDOW,name,RefType.REGULAR);
        break;
      }
    }
  }
}","private void maybeRecordReferenceOrAlias(NodeTraversal t,Node n,Node parent,NameInformation nameInfo,@Nullable NameInformation referring){
  String referringName=""String_Node_Str"";
  if (referring != null) {
    referringName=referring.isPrototype ? referring.prototypeClass : referring.name;
  }
  String name=nameInfo.name;
  if (maybeHiddenAlias(n)) {
    recordAlias(name,WINDOW);
  }
  if (nameInfo.isExternallyReferenceable) {
    recordReference(WINDOW,name,RefType.REGULAR);
    maybeRecordAlias(name,n,referring,referringName);
    return;
  }
  if (NodeUtil.isVarOrSimpleAssignLhs(n,parent)) {
    if (referring != null) {
      recordReference(referringName,name,RefType.REGULAR);
    }
    return;
  }
  if (nodesToKeep.contains(n)) {
    List<NameInformation> functionScopes=getEnclosingFunctionDependencyScope(t);
    if (!functionScopes.isEmpty()) {
      for (      NameInformation functionScope : functionScopes) {
        recordReference(functionScope.name,name,RefType.REGULAR);
      }
    }
 else {
      recordReference(WINDOW,name,RefType.REGULAR);
      if (referring != null) {
        maybeRecordAlias(name,n,referring,referringName);
      }
    }
  }
 else   if (referring != null) {
    if (!maybeRecordAlias(name,n,referring,referringName)) {
      RefType depType=referring.onlyAffectsClassDef ? RefType.INHERITANCE : RefType.REGULAR;
      recordReference(referringName,name,depType);
    }
  }
 else {
    for (    Node ancestor : n.getAncestors()) {
      if (NodeUtil.isAssignmentOp(ancestor) || ancestor.isFunction()) {
        recordReference(WINDOW,name,RefType.REGULAR);
        break;
      }
    }
  }
}",0.9936421435059036
19341,"public void testNoRemoveWindowPropertyAlias4(){
  test(""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"");
}","public void testNoRemoveWindowPropertyAlias4(){
  testSame(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""));
}",0.8347826086956521
19342,"public void testNoRemoveWindowPropertyAlias5(){
  test(""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"");
}","public void testNoRemoveWindowPropertyAlias5(){
  testSame(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""));
}",0.8347826086956521
19343,"public void testNoRemoveWindowPropertyAlias4a(){
  test(""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"");
}","public void testNoRemoveWindowPropertyAlias4a(){
  testSame(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""));
}",0.8362068965517241
19344,"public void testNoRemoveWindowPropertyAlias5a(){
  test(""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"");
}","public void testNoRemoveWindowPropertyAlias5a(){
  testSame(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""));
}",0.8362068965517241
19345,"public void testAliasInstanceof5(){
  test(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
}","public void testAliasInstanceof5(){
  testSame(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.659217877094972
19346,"boolean isGlobalVar(String varName){
  NTIScope s=this;
  while (s.parent != null) {
    if (isDefinedLocally(varName,false)) {
      return false;
    }
    s=s.parent;
  }
  return true;
}","boolean isGlobalVar(String varName){
  NTIScope s=this;
  while (s.parent != null) {
    if (s.isDefinedLocally(varName,false)) {
      return false;
    }
    s=s.parent;
  }
  return true;
}",0.9947643979057592
19347,"void addNamespace(Node qnameNode,Namespace ns){
  if (ns instanceof EnumType) {
    this.localEnums.add((EnumType)ns);
  }
  if (qnameNode.isName()) {
    String varName=qnameNode.getString();
    Preconditions.checkState(!this.localNamespaces.containsKey(varName));
    this.localNamespaces.put(varName,ns);
    if (qnameNode.isFromExterns() && !this.externs.containsKey(varName)) {
      this.externs.put(qnameNode.getString(),null);
    }
  }
 else {
    Preconditions.checkState(!isDefined(qnameNode));
    QualifiedName qname=QualifiedName.fromNode(qnameNode);
    Namespace rootns=getNamespace(qname.getLeftmostName());
    rootns.addNamespace(qname.getAllButLeftmost(),ns);
  }
}","void addNamespace(Node qnameNode,Namespace ns){
  if (ns instanceof EnumType) {
    this.localEnums.add((EnumType)ns);
  }
  if (qnameNode.isName()) {
    String varName=qnameNode.getString();
    Preconditions.checkState(!this.localNamespaces.containsKey(varName),""String_Node_Str"",varName);
    this.localNamespaces.put(varName,ns);
    if (qnameNode.isFromExterns() && !this.externs.containsKey(varName)) {
      this.externs.put(qnameNode.getString(),null);
    }
  }
 else {
    Preconditions.checkState(!isDefined(qnameNode));
    QualifiedName qname=QualifiedName.fromNode(qnameNode);
    Namespace rootns=getNamespace(qname.getLeftmostName());
    rootns.addNamespace(qname.getAllButLeftmost(),ns);
  }
}",0.9814020028612304
19348,"static NominalType join(NominalType c1,NominalType c2){
  if (c1 == null || c2 == null) {
    return null;
  }
  if (c1.isNominalSubtypeOf(c2)) {
    return c2;
  }
  if (c1.isRawSubtypeOf(c2)) {
    return new NominalType(joinTypeMaps(c2.typeMap.keySet(),c1.typeMap,c2.typeMap),c2.rawType);
  }
  if (c2.isNominalSubtypeOf(c1)) {
    return c1;
  }
  if (c2.isRawSubtypeOf(c1)) {
    return new NominalType(joinTypeMaps(c1.typeMap.keySet(),c1.typeMap,c2.typeMap),c1.rawType);
  }
  return null;
}","static NominalType join(NominalType c1,NominalType c2){
  if (c1 == null || c2 == null) {
    return null;
  }
  if (c1.isNominalSubtypeOf(c2)) {
    return c2;
  }
  if (c2.isNominalSubtypeOf(c1)) {
    return c1;
  }
  if (c1.rawType.equals(c2.rawType)) {
    return c1.isGeneric() ? new NominalType(joinTypeMaps(c1,c2),c1.rawType) : c1;
  }
  Preconditions.checkState(!c1.isRawSubtypeOf(c2) && !c2.isRawSubtypeOf(c1));
  return null;
}",0.4149732620320855
19349,"private static ImmutableMap<String,JSType> joinTypeMaps(Set<String> domain,ImmutableMap<String,JSType> m1,ImmutableMap<String,JSType> m2){
  ImmutableMap.Builder<String,JSType> builder=ImmutableMap.builder();
  for (  String typevar : domain) {
    JSType t1=m1.get(typevar);
    JSType t2=m2.get(typevar);
    if (t1 == null) {
      builder.put(typevar,Preconditions.checkNotNull(t2));
    }
 else     if (t2 == null) {
      builder.put(typevar,t1);
    }
 else {
      builder.put(typevar,JSType.join(t1,t2));
    }
  }
  return builder.build();
}","private static ImmutableMap<String,JSType> joinTypeMaps(NominalType nt1,NominalType nt2){
  Preconditions.checkState(nt1.rawType.equals(nt2.rawType));
  ImmutableMap.Builder<String,JSType> builder=ImmutableMap.builder();
  if (nt1.isIObject()) {
    String indexTypevar=nt1.rawType.getTypeParameters().get(0);
    builder.put(indexTypevar,JSType.meet(nt1.getIndexType(),nt2.getIndexType()));
    String indexedTypevar=nt1.rawType.getTypeParameters().get(1);
    builder.put(indexedTypevar,JSType.join(nt1.getIndexedType(),nt2.getIndexedType()));
    return builder.build();
  }
  for (  String typevar : nt1.typeMap.keySet()) {
    builder.put(typevar,JSType.join(nt1.typeMap.get(typevar),nt2.typeMap.get(typevar)));
  }
  return builder.build();
}",0.3187066974595843
19350,"static ObjectType join(ObjectType obj1,ObjectType obj2){
  if (obj1.isTopObject() || obj2.isTopObject()) {
    return obj1.commonTypes.getTopObjectType();
  }
  if (obj1.equals(obj2)) {
    return obj1;
  }
 else   if (obj1.isPrototypeObject() && obj2.isPrototypeObject()) {
    return join(obj1.getNominalType().getInstanceAsObjectType(),obj2.getNominalType().getInstanceAsObjectType());
  }
  NominalType nt1=obj1.nominalType;
  NominalType nt2=obj2.nominalType;
  Preconditions.checkState(nt1.isRawSubtypeOf(nt2) || nt2.isRawSubtypeOf(nt1));
  JSTypes commonTypes=obj1.commonTypes;
  boolean isLoose=obj1.isLoose || obj2.isLoose;
  FunctionType fn=FunctionType.join(obj1.fn,obj2.fn);
  PersistentMap<String,Property> props;
  if (isLoose) {
    fn=fn == null ? null : fn.withLoose();
    props=joinPropsLoosely(commonTypes,obj1.props,obj2.props);
  }
 else {
    props=joinProps(obj1.props,obj2.props,nt1,nt2);
  }
  NominalType nominal=NominalType.join(nt1,nt2);
  if (nominal.isBuiltinObject() && fn != null) {
    if (isLoose) {
      nominal=obj1.commonTypes.getFunctionType();
    }
 else {
      fn=null;
    }
  }
  Namespace ns=Objects.equals(obj1.ns,obj2.ns) ? obj1.ns : null;
  return makeObjectType(commonTypes,nominal,props,fn,ns,isLoose,ObjectKind.join(obj1.objectKind,obj2.objectKind));
}","static ObjectType join(ObjectType obj1,ObjectType obj2){
  if (obj1.isTopObject() || obj2.isTopObject()) {
    return obj1.commonTypes.getTopObjectType();
  }
  if (obj1.equals(obj2)) {
    return obj1;
  }
  if (obj1.isPrototypeObject() && obj2.isPrototypeObject()) {
    return join(obj1.getNominalType().getInstanceAsObjectType(),obj2.getNominalType().getInstanceAsObjectType());
  }
  NominalType nt1=obj1.nominalType;
  NominalType nt2=obj2.nominalType;
  Preconditions.checkState(nt1.isRawSubtypeOf(nt2) || nt2.isRawSubtypeOf(nt1));
  JSTypes commonTypes=obj1.commonTypes;
  boolean isLoose=obj1.isLoose || obj2.isLoose;
  FunctionType fn=FunctionType.join(obj1.fn,obj2.fn);
  PersistentMap<String,Property> props;
  if (isLoose) {
    fn=fn == null ? null : fn.withLoose();
    props=joinPropsLoosely(commonTypes,obj1.props,obj2.props);
  }
 else {
    props=joinProps(obj1.props,obj2.props,nt1,nt2);
  }
  NominalType nominal=NominalType.join(nt1,nt2);
  if (nominal.isBuiltinObject() && fn != null) {
    if (isLoose) {
      nominal=obj1.commonTypes.getFunctionType();
    }
 else {
      fn=null;
    }
  }
  Namespace ns=Objects.equals(obj1.ns,obj2.ns) ? obj1.ns : null;
  return makeObjectType(commonTypes,nominal,props,fn,ns,isLoose,ObjectKind.join(obj1.objectKind,obj2.objectKind));
}",0.9976958525345622
19351,"static ImmutableSet<ObjectType> meetSetsHelper(boolean specializeObjs1,Set<ObjectType> objs1,Set<ObjectType> objs2){
  ObjectsBuilder newObjs=new ObjectsBuilder(ResolveConflictsBy.MEET);
  for (  ObjectType obj2 : objs2) {
    for (    ObjectType obj1 : objs1) {
      if (areRelatedNominalTypes(obj1.nominalType,obj2.nominalType)) {
        ObjectType newObj;
        if (specializeObjs1) {
          newObj=obj1.specialize(obj2);
          if (newObj == null) {
            continue;
          }
        }
 else {
          newObj=meet(obj1,obj2);
        }
        newObjs.add(newObj);
      }
 else       if (obj1.nominalType.isStructuralInterface() && obj2.isSubtypeOf(obj1,SubtypeCache.create())) {
        newObjs.add(obj2);
      }
 else       if (obj2.nominalType.isStructuralInterface() && obj1.isSubtypeOf(obj2,SubtypeCache.create())) {
        newObjs.add(obj1);
      }
    }
  }
  return newObjs.build();
}","static ImmutableSet<ObjectType> meetSetsHelper(boolean specializeObjs1,Set<ObjectType> objs1,Set<ObjectType> objs2){
  ObjectsBuilder newObjs=new ObjectsBuilder();
  for (  ObjectType obj2 : objs2) {
    for (    ObjectType obj1 : objs1) {
      if (areRelatedNominalTypes(obj1.nominalType,obj2.nominalType)) {
        ObjectType newObj;
        if (specializeObjs1) {
          newObj=obj1.specialize(obj2);
          if (newObj == null) {
            continue;
          }
        }
 else {
          newObj=meet(obj1,obj2);
        }
        newObjs.add(newObj);
      }
 else       if (obj1.nominalType.isStructuralInterface() && obj2.isSubtypeOf(obj1,SubtypeCache.create())) {
        newObjs.add(obj2);
      }
 else       if (obj2.nominalType.isStructuralInterface() && obj1.isSubtypeOf(obj2,SubtypeCache.create())) {
        newObjs.add(obj1);
      }
    }
  }
  return newObjs.build();
}",0.9873417721518988
19352,"static ImmutableSet<ObjectType> joinSets(ImmutableSet<ObjectType> objs1,ImmutableSet<ObjectType> objs2){
  if (objs1.isEmpty()) {
    return objs2;
  }
 else   if (objs2.isEmpty()) {
    return objs1;
  }
  ObjectType[] objs1Arr=objs1.toArray(new ObjectType[0]);
  ObjectType[] keptFrom1=Arrays.copyOf(objs1Arr,objs1Arr.length);
  ObjectsBuilder newObjs=new ObjectsBuilder(ResolveConflictsBy.JOIN);
  for (  ObjectType obj2 : objs2) {
    boolean addedObj2=false;
    for (int i=0; i < objs1Arr.length; i++) {
      ObjectType obj1=objs1Arr[i];
      NominalType nt1=obj1.nominalType;
      NominalType nt2=obj2.nominalType;
      if (areRelatedNominalTypes(nt1,nt2)) {
        if ((nt2.isBuiltinObject() && nt1 != null && !obj1.isSubtypeOf(obj2,SubtypeCache.create())) || (nt1.isBuiltinObject() && nt2 != null && !obj2.isSubtypeOf(obj1,SubtypeCache.create()))) {
          break;
        }
        keptFrom1[i]=null;
        addedObj2=true;
        newObjs.add(join(obj1,obj2));
        break;
      }
    }
    if (!addedObj2) {
      newObjs.add(obj2);
    }
  }
  for (  ObjectType o : keptFrom1) {
    if (o != null) {
      newObjs.add(o);
    }
  }
  return newObjs.build();
}","static ImmutableSet<ObjectType> joinSets(ImmutableSet<ObjectType> objs1,ImmutableSet<ObjectType> objs2){
  if (objs1.isEmpty()) {
    return objs2;
  }
 else   if (objs2.isEmpty()) {
    return objs1;
  }
  List<ObjectType> objs=new ArrayList<>(objs1);
  objs.addAll(objs2);
  for (int i=0; i < objs.size() - 1; i++) {
    ObjectType obj1=objs.get(i);
    NominalType nt1=obj1.nominalType;
    for (int j=i + 1; j < objs.size(); j++) {
      ObjectType obj2=objs.get(j);
      NominalType nt2=obj2.nominalType;
      if (nt1.isBuiltinObject() && nt2.isBuiltinObject()) {
        objs.set(i,null);
        objs.set(j,join(obj1,obj2));
      }
 else       if ((areRelatedNominalTypes(nt1,nt2) || NominalType.equalRawTypes(nt1,nt2)) && (!nt1.isBuiltinObject() || obj2.isSubtypeOf(obj1,SubtypeCache.create())) && (!nt2.isBuiltinObject() || obj1.isSubtypeOf(obj2,SubtypeCache.create()))) {
        objs.set(i,null);
        objs.set(j,join(obj1,obj2));
      }
    }
  }
  ImmutableSet.Builder<ObjectType> builder=ImmutableSet.builder();
  for (  ObjectType obj : objs) {
    if (obj != null) {
      builder.add(obj);
    }
  }
  return builder.build();
}",0.3581833761782348
19353,"static ObjectType meet(ObjectType obj1,ObjectType obj2){
  Preconditions.checkState(areRelatedNominalTypes(obj1.nominalType,obj2.nominalType));
  if (obj1.isTopObject() || obj2.isBottomObject()) {
    return obj2;
  }
 else   if (obj2.isTopObject() || obj1.isBottomObject()) {
    return obj1;
  }
  JSTypes commonTypes=obj1.commonTypes;
  NominalType resultNomType=NominalType.pickSubclass(obj1.nominalType,obj2.nominalType);
  FunctionType fn=FunctionType.meet(obj1.fn,obj2.fn);
  if (!FunctionType.isInhabitable(fn)) {
    return commonTypes.getBottomObject();
  }
  boolean isLoose=(obj1.isLoose && obj2.isLoose) || fn != null && fn.isLoose();
  if (resultNomType.isFunction() && fn == null) {
    fn=obj1.fn == null ? obj2.fn : obj1.fn;
    isLoose=fn.isLoose();
  }
  PersistentMap<String,Property> props;
  if (isLoose) {
    props=joinPropsLoosely(commonTypes,obj1.props,obj2.props);
  }
 else {
    props=meetPropsHelper(commonTypes,false,resultNomType,obj1.props,obj2.props);
  }
  if (props == commonTypes.BOTTOM_PROPERTY_MAP) {
    return commonTypes.getBottomObject();
  }
  ObjectKind ok=ObjectKind.meet(obj1.objectKind,obj2.objectKind);
  Namespace resultNs=Objects.equals(obj1.ns,obj2.ns) ? obj1.ns : null;
  return new ObjectType(commonTypes,resultNomType,props,fn,resultNs,isLoose,ok);
}","static ObjectType meet(ObjectType obj1,ObjectType obj2){
  NominalType nt1=obj1.nominalType;
  NominalType nt2=obj2.nominalType;
  Preconditions.checkState(areRelatedNominalTypes(nt1,nt2),""String_Node_Str"",nt1,nt2);
  if (obj1.isTopObject() || obj2.isBottomObject()) {
    return obj2;
  }
 else   if (obj2.isTopObject() || obj1.isBottomObject()) {
    return obj1;
  }
  JSTypes commonTypes=obj1.commonTypes;
  NominalType resultNomType=NominalType.pickSubclass(nt1,nt2);
  FunctionType fn=FunctionType.meet(obj1.fn,obj2.fn);
  if (!FunctionType.isInhabitable(fn)) {
    return commonTypes.getBottomObject();
  }
  boolean isLoose=(obj1.isLoose && obj2.isLoose) || fn != null && fn.isLoose();
  if (resultNomType.isFunction() && fn == null) {
    fn=obj1.fn == null ? obj2.fn : obj1.fn;
    isLoose=fn.isLoose();
  }
  PersistentMap<String,Property> props;
  if (isLoose) {
    props=joinPropsLoosely(commonTypes,obj1.props,obj2.props);
  }
 else {
    props=meetPropsHelper(commonTypes,false,resultNomType,obj1.props,obj2.props);
  }
  if (props == commonTypes.BOTTOM_PROPERTY_MAP) {
    return commonTypes.getBottomObject();
  }
  ObjectKind ok=ObjectKind.meet(obj1.objectKind,obj2.objectKind);
  Namespace resultNs=Objects.equals(obj1.ns,obj2.ns) ? obj1.ns : null;
  return new ObjectType(commonTypes,resultNomType,props,fn,resultNs,isLoose,ok);
}",0.9322289156626506
19354,"void add(ObjectType newObj){
  boolean addedObj=false;
  for (int i=0; i < this.objs.size(); i++) {
    ObjectType oldObj=this.objs.get(i);
    if (NominalType.equalRawTypes(oldObj.getNominalType(),newObj.getNominalType())) {
      addedObj=true;
      if (this.resolution == ResolveConflictsBy.JOIN) {
        this.objs.set(i,ObjectType.join(oldObj,newObj));
      }
 else {
        this.objs.set(i,ObjectType.meet(oldObj,newObj));
      }
    }
  }
  if (!addedObj) {
    this.objs.add(newObj);
  }
}","void add(ObjectType newObj){
  boolean addedObj=false;
  for (int i=0; i < this.objs.size(); i++) {
    ObjectType oldObj=this.objs.get(i);
    if (NominalType.equalRawTypes(oldObj.getNominalType(),newObj.getNominalType())) {
      addedObj=true;
      this.objs.set(i,ObjectType.meet(oldObj,newObj));
    }
  }
  if (!addedObj) {
    this.objs.add(newObj);
  }
}",0.6173410404624278
19355,"ObjectsBuilder(ResolveConflictsBy resolution){
  this.resolution=resolution;
  this.objs=new ArrayList<>();
}","ObjectsBuilder(){
  this.objs=new ArrayList<>();
}",0.6289308176100629
19356,"public void testIObjectBracketAccesses(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_INDEX_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_INDEX_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.BOTTOM_INDEX_TYPE,NewTypeInference.BOTTOM_INDEX_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS,NewTypeInference.MISTYPED_ASSIGN_RHS,NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.BOTTOM_INDEX_TYPE,NewTypeInference.BOTTOM_INDEX_TYPE);
}","public void testIObjectBracketAccesses(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_INDEX_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_INDEX_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.BOTTOM_INDEX_TYPE,NewTypeInference.BOTTOM_INDEX_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS,NewTypeInference.MISTYPED_ASSIGN_RHS,NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.BOTTOM_INDEX_TYPE,NewTypeInference.BOTTOM_INDEX_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.BOTTOM_INDEX_TYPE,NewTypeInference.BOTTOM_INDEX_TYPE);
}",0.9630331753554502
19357,"/** 
 * Updates the FunctionState object for the given function. Checks if the given function matches the criteria for an inlinable function.
 */
private void maybeAddFunction(Function fn,JSModule module){
  String name=fn.getName();
  FunctionState fs=getOrCreateFunctionState(name);
  if (fs.hasExistingFunctionDefinition()) {
    fs.setInline(false);
    return;
  }
  Node fnNode=fn.getFunctionNode();
  if (enforceMaxSizeAfterInlining && !isAlwaysInlinable(fnNode) && maxSizeAfterInlining <= NodeUtil.countAstSizeUpToLimit(fnNode,maxSizeAfterInlining)) {
    fs.setInline(false);
    return;
  }
  if (fs.canInline()) {
    fs.setFn(fn);
    if (FunctionInjector.isDirectCallNodeReplacementPossible(fn.getFunctionNode())) {
      fs.inlineDirectly(true);
    }
    if (!isCandidateFunction(fn)) {
      fs.setInline(false);
    }
    if (fs.canInline()) {
      fs.setModule(module);
      Set<String> namesToAlias=FunctionArgumentInjector.findModifiedParameters(fnNode);
      if (!namesToAlias.isEmpty()) {
        fs.inlineDirectly(false);
        fs.setNamesToAlias(namesToAlias);
      }
      Node block=NodeUtil.getFunctionBody(fnNode);
      if (NodeUtil.referencesThis(block)) {
        fs.setReferencesThis(true);
      }
      if (NodeUtil.containsFunction(block)) {
        fs.setHasInnerFunctions(true);
        if (!assumeMinimumCapture && hasLocalNames(fnNode) && !NodeUtil.isIIFE(fnNode)) {
          fs.setInline(false);
        }
      }
    }
    if (fs.canInline() && !fs.canInlineDirectly() && !blockFunctionInliningEnabled) {
      fs.setInline(false);
    }
  }
}","/** 
 * Updates the FunctionState object for the given function. Checks if the given function matches the criteria for an inlinable function.
 */
private void maybeAddFunction(Function fn,JSModule module){
  String name=fn.getName();
  FunctionState fs=getOrCreateFunctionState(name);
  if (fs.hasExistingFunctionDefinition()) {
    fs.setInline(false);
    return;
  }
  Node fnNode=fn.getFunctionNode();
  if (enforceMaxSizeAfterInlining && !isAlwaysInlinable(fnNode) && maxSizeAfterInlining <= NodeUtil.countAstSizeUpToLimit(fnNode,maxSizeAfterInlining)) {
    fs.setInline(false);
    return;
  }
  if (fs.canInline()) {
    fs.setFn(fn);
    if (FunctionInjector.isDirectCallNodeReplacementPossible(fn.getFunctionNode())) {
      fs.inlineDirectly(true);
    }
    if (!isCandidateFunction(fn)) {
      fs.setInline(false);
    }
    if (fs.canInline()) {
      fs.setModule(module);
      Set<String> namesToAlias=FunctionArgumentInjector.findModifiedParameters(fnNode);
      if (!namesToAlias.isEmpty()) {
        fs.inlineDirectly(false);
        fs.setNamesToAlias(namesToAlias);
      }
      Node block=NodeUtil.getFunctionBody(fnNode);
      if (NodeUtil.referencesThis(block)) {
        fs.setReferencesThis(true);
      }
      if (NodeUtil.containsFunction(block)) {
        fs.setHasInnerFunctions(true);
        if (!assumeMinimumCapture && hasLocalNames(fnNode)) {
          fs.setInline(false);
        }
      }
    }
    if (fs.canInline() && !fs.canInlineDirectly() && !blockFunctionInliningEnabled) {
      fs.setInline(false);
    }
  }
}",0.9270767279644896
19358,"public void testComplexFunctionWithFunctionDefinition2a(){
  assumeMinimumCapture=false;
  test(""String_Node_Str"",LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  assumeMinimumCapture=true;
  test(""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"");
}","public void testComplexFunctionWithFunctionDefinition2a(){
  assumeMinimumCapture=false;
  testSame(""String_Node_Str"" + ""String_Node_Str"");
  assumeMinimumCapture=true;
  test(""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"");
}",0.472027972027972
19359,"public void testShadowVariables16(){
  assumeMinimumCapture=false;
  test(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assumeMinimumCapture=true;
  test(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
}","public void testShadowVariables16(){
  assumeMinimumCapture=false;
  test(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
  assumeMinimumCapture=true;
  test(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
}",0.7342192691029901
19360,"public void testAnonymous3(){
  assumeMinimumCapture=false;
  test(""String_Node_Str"",""String_Node_Str"");
  assumeMinimumCapture=true;
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
}","public void testAnonymous3(){
  assumeMinimumCapture=false;
  testSame(""String_Node_Str"");
  assumeMinimumCapture=true;
  test(""String_Node_Str"",""String_Node_Str"");
  test(""String_Node_Str"",""String_Node_Str"");
}",0.6926605504587156
19361,"public void testAnonymous1(){
  assumeMinimumCapture=false;
  test(""String_Node_Str"",LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  assumeMinimumCapture=true;
  test(""String_Node_Str"",LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testAnonymous1(){
  assumeMinimumCapture=false;
  test(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  assumeMinimumCapture=true;
  test(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
}",0.3901098901098901
19362,"public void testShadowVariables7(){
  assumeMinimumCapture=false;
  test(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
  assumeMinimumCapture=true;
  test(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),""String_Node_Str"");
}","public void testShadowVariables7(){
  assumeMinimumCapture=false;
  test(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
  assumeMinimumCapture=true;
  test(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
}",0.7333333333333333
19363,"public void testAddFunctionProperties3() throws Exception {
  String source=LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  String expected=""String_Node_Str"";
  CompilerOptions options=createCompilerOptions();
  CompilationLevel.ADVANCED_OPTIMIZATIONS.setOptionsForCompilationLevel(options);
  options.setRenamingPolicy(VariableRenamingPolicy.OFF,PropertyRenamingPolicy.OFF);
  options.setCheckTypes(false);
  test(options,source,expected);
}","public void testAddFunctionProperties3() throws Exception {
  String source=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  String expected=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
  CompilerOptions options=createCompilerOptions();
  CompilationLevel.ADVANCED_OPTIMIZATIONS.setOptionsForCompilationLevel(options);
  options.setRenamingPolicy(VariableRenamingPolicy.OFF,PropertyRenamingPolicy.OFF);
  options.setCheckTypes(false);
  test(options,source,expected);
}",0.7276051188299817
19364,"/** 
 * We don't use the requiredType of the context to unify with the return type. There are several difficulties: 1) A polymorphic function is allowed to return ANY subtype of the requiredType, so we would need to use a heuristic to determine the type to unify with. 2) It's hard to give good error messages in cases like: id('str') - 5 We want an invalid-operand-type, not a not-unique-instantiation. We don't take the arg evaluation order into account during instantiation. When calculating the instantiation, when do we use the receiver type? See the following snippet: / * @constructor * @template T * @param {T} x * / function Foo(x) {} / * @template T * @param {T} x * / Foo.prototype.f = function(x) {}; Foo.prototype.f.bind(new Foo(123), 'asdf'); Here, the receiver type of f is Foo<T>, but the T is the class's T, not the T of f's template declaration. OTOH, if f had a @this annotation that contained T, T would refer to f's T. There is no way of knowing what's the scope of the type variables in the receiver of the function type. But when THIS comes from the class, it is always a singleton object. So, we use a heuristic: if THIS is not a singleton obj, we know it comes from and we use it for the instantiation.
 */
private ImmutableMap<String,JSType> calcTypeInstantiation(Node callNode,Node receiver,Node firstArg,FunctionType funType,TypeEnv typeEnv,boolean isFwd){
  Preconditions.checkState(receiver == null || isFwd);
  List<String> typeParameters=funType.getTypeParameters();
  Multimap<String,JSType> typeMultimap=LinkedHashMultimap.create();
  JSType funRecvType=funType.getThisType();
  if (receiver != null && funRecvType != null && !funRecvType.isSingletonObj()) {
    EnvTypePair pair=analyzeExprFwd(receiver,typeEnv);
    unifyWithSubtypeWarnIfFail(funRecvType,pair.type,typeParameters,typeMultimap,receiver,isFwd);
    typeEnv=pair.env;
  }
  Node arg=firstArg;
  int i=0;
  while (arg != null) {
    EnvTypePair pair=isFwd ? analyzeExprFwd(arg,typeEnv) : analyzeExprBwd(arg,typeEnv);
    unifyWithSubtypeWarnIfFail(funType.getFormalType(i),pair.type,typeParameters,typeMultimap,arg,isFwd);
    arg=arg.getNext();
    typeEnv=pair.env;
    i++;
  }
  ImmutableMap.Builder<String,JSType> builder=ImmutableMap.builder();
  for (  String typeParam : typeParameters) {
    Collection<JSType> types=typeMultimap.get(typeParam);
    if (types.size() > 1) {
      if (isFwd) {
        warnings.add(JSError.make(callNode,NOT_UNIQUE_INSTANTIATION,Integer.toString(types.size()),UniqueNameGenerator.getOriginalName(typeParam),types.toString(),funType.toString()));
      }
      if (joinTypesWhenInstantiatingGenerics) {
        JSType joinedType=BOTTOM;
        for (        JSType t : types) {
          joinedType=JSType.join(joinedType,t);
        }
        builder.put(typeParam,joinedType);
      }
 else {
        builder.put(typeParam,UNKNOWN);
      }
    }
 else     if (types.size() == 1) {
      JSType t=Iterables.getOnlyElement(types);
      builder.put(typeParam,t.isBottom() ? UNKNOWN : t);
    }
 else {
      builder.put(typeParam,UNKNOWN);
    }
  }
  return builder.build();
}","/** 
 * We don't use the requiredType of the context to unify with the return type. There are several difficulties: 1) A polymorphic function is allowed to return ANY subtype of the requiredType, so we would need to use a heuristic to determine the type to unify with. 2) It's hard to give good error messages in cases like: id('str') - 5 We want an invalid-operand-type, not a not-unique-instantiation. We don't take the arg evaluation order into account during instantiation. When calculating the instantiation, when do we use the receiver type? See the following snippet: / * @constructor * @template T * @param {T} x * / function Foo(x) {} / * @template T * @param {T} x * / Foo.prototype.f = function(x) {}; Foo.prototype.f.bind(new Foo(123), 'asdf'); Here, the receiver type of f is Foo<T>, but the T is the class's T, not the T of f's template declaration. OTOH, if f had a @this annotation that contained T, T would refer to f's T. There is no way of knowing what's the scope of the type variables in the receiver of the function type. But when THIS comes from the class, it is always a singleton object. So, we use a heuristic: if THIS is not a singleton obj, we know it comes from and we use it for the instantiation.
 */
private ImmutableMap<String,JSType> calcTypeInstantiation(Node callNode,Node receiver,Node firstArg,FunctionType funType,TypeEnv typeEnv,boolean isFwd){
  Preconditions.checkState(receiver == null || isFwd);
  List<String> typeParameters=funType.getTypeParameters();
  Multimap<String,JSType> typeMultimap=LinkedHashMultimap.create();
  JSType funRecvType=funType.getThisType();
  if (receiver != null && funRecvType != null && !funRecvType.isSingletonObj()) {
    JSType recvType=(JSType)receiver.getTypeI();
    if (recvType == null) {
      EnvTypePair pair=analyzeExprFwd(receiver,typeEnv);
      recvType=pair.type;
      typeEnv=pair.env;
    }
    unifyWithSubtypeWarnIfFail(funRecvType,recvType,typeParameters,typeMultimap,receiver,isFwd);
  }
  Node arg=firstArg;
  int i=0;
  while (arg != null) {
    EnvTypePair pair=isFwd ? analyzeExprFwd(arg,typeEnv) : analyzeExprBwd(arg,typeEnv);
    unifyWithSubtypeWarnIfFail(funType.getFormalType(i),pair.type,typeParameters,typeMultimap,arg,isFwd);
    arg=arg.getNext();
    typeEnv=pair.env;
    i++;
  }
  ImmutableMap.Builder<String,JSType> builder=ImmutableMap.builder();
  for (  String typeParam : typeParameters) {
    Collection<JSType> types=typeMultimap.get(typeParam);
    if (types.size() > 1) {
      if (isFwd) {
        warnings.add(JSError.make(callNode,NOT_UNIQUE_INSTANTIATION,Integer.toString(types.size()),UniqueNameGenerator.getOriginalName(typeParam),types.toString(),funType.toString()));
      }
      if (joinTypesWhenInstantiatingGenerics) {
        JSType joinedType=BOTTOM;
        for (        JSType t : types) {
          joinedType=JSType.join(joinedType,t);
        }
        builder.put(typeParam,joinedType);
      }
 else {
        builder.put(typeParam,UNKNOWN);
      }
    }
 else     if (types.size() == 1) {
      JSType t=Iterables.getOnlyElement(types);
      builder.put(typeParam,t.isBottom() ? UNKNOWN : t);
    }
 else {
      builder.put(typeParam,UNKNOWN);
    }
  }
  return builder.build();
}",0.973526630948629
19365,"private EnvTypePair analyzeCallNewFwd(Node expr,TypeEnv inEnv,JSType requiredType,JSType specializedType){
  if (isPropertyTestCall(expr)) {
    return analyzePropertyTestCallFwd(expr,inEnv,specializedType);
  }
  Node callee=expr.getFirstChild();
  if (isFunctionBind(callee,inEnv,true)) {
    return analyzeFunctionBindFwd(expr,inEnv);
  }
  AssertionFunctionSpec assertionFunctionSpec=assertionFunctionsMap.get(callee.getQualifiedName());
  if (assertionFunctionSpec != null) {
    return analyzeAssertionCall(expr,inEnv,assertionFunctionSpec);
  }
  EnvTypePair calleePair=analyzeExprFwd(callee,inEnv,commonTypes.topFunction());
  TypeEnv envAfterCallee=calleePair.env;
  calleePair=mayWarnAboutNullableReferenceAndTighten(callee,calleePair.type,null,envAfterCallee);
  JSType calleeType=calleePair.type;
  if (calleeType.isBottom() || !calleeType.isSubtypeOf(commonTypes.topFunction())) {
    warnings.add(JSError.make(expr,NOT_CALLABLE,calleeType.toString()));
  }
  FunctionType funType=calleeType.getFunTypeIfSingletonObj();
  if (funType == null || funType.isTopFunction() || funType.isQmarkFunction()) {
    return analyzeCallNodeArgsFwdWhenError(expr,envAfterCallee);
  }
 else   if (funType.isLoose()) {
    return analyzeLooseCallNodeFwd(expr,envAfterCallee,requiredType);
  }
 else   if (!isConstructorCall(expr) && funType.isSomeConstructorOrInterface() && (funType.getReturnType().isUnknown() || funType.getReturnType().isUndefined())) {
    warnings.add(JSError.make(expr,CONSTRUCTOR_NOT_CALLABLE,funType.toString()));
    return analyzeCallNodeArgsFwdWhenError(expr,envAfterCallee);
  }
 else   if (expr.isNew()) {
    if (!funType.isSomeConstructorOrInterface() || funType.isInterfaceDefinition()) {
      warnings.add(JSError.make(expr,NOT_A_CONSTRUCTOR,funType.toString()));
      return analyzeCallNodeArgsFwdWhenError(expr,envAfterCallee);
    }
 else     if (funType.isConstructorOfAbstractClass()) {
      warnings.add(JSError.make(expr,CANNOT_INSTANTIATE_ABSTRACT_CLASS,funType.toString()));
      return analyzeCallNodeArgsFwdWhenError(expr,envAfterCallee);
    }
  }
  int maxArity=funType.getMaxArity();
  int minArity=funType.getMinArity();
  int numArgs=expr.getChildCount() - 1;
  if (numArgs < minArity || numArgs > maxArity) {
    warnings.add(JSError.make(expr,WRONG_ARGUMENT_COUNT,getReadableCalleeName(callee),Integer.toString(numArgs),Integer.toString(minArity),""String_Node_Str"" + maxArity));
    return analyzeCallNodeArgsFwdWhenError(expr,envAfterCallee);
  }
  FunctionType origFunType=funType;
  if (funType.isGeneric()) {
    Map<String,JSType> typeMap=calcTypeInstantiationFwd(expr,callee.isGetProp() ? callee.getFirstChild() : null,expr.getSecondChild(),funType,envAfterCallee);
    funType=funType.instantiateGenerics(typeMap);
    println(""String_Node_Str"" + funType);
  }
  List<JSType> argTypes=new ArrayList<>();
  TypeEnv tmpEnv=analyzeCallNodeArgumentsFwd(expr,expr.getSecondChild(),funType,argTypes,envAfterCallee);
  if (callee.isName()) {
    String calleeName=callee.getString();
    if (currentScope.isKnownFunction(calleeName) && !currentScope.isExternalFunction(calleeName)) {
      if (currentScope.isLocalFunDef(calleeName)) {
        tmpEnv=collectTypesForFreeVarsFwd(callee,tmpEnv);
      }
 else       if (!origFunType.isGeneric()) {
        JSType expectedRetType=requiredType;
        println(""String_Node_Str"",expectedRetType,""String_Node_Str"",argTypes);
        DeferredCheck dc;
        if (isConstructorCall(expr)) {
          dc=new DeferredCheck(expr,null,currentScope,currentScope.getScope(calleeName));
          deferredChecks.put(expr,dc);
        }
 else {
          dc=deferredChecks.get(expr);
          if (dc != null) {
            dc.updateReturn(expectedRetType);
          }
 else {
            Preconditions.checkState(!currentScope.hasUndeclaredFormalsOrOuters(),""String_Node_Str"",expr);
          }
        }
        if (dc != null) {
          dc.updateArgTypes(argTypes);
        }
      }
    }
  }
  JSType retType=expr.isNew() ? funType.getThisType() : funType.getReturnType();
  if (retType.isSubtypeOf(requiredType)) {
    retType=retType.specialize(specializedType);
  }
  return new EnvTypePair(tmpEnv,retType);
}","private EnvTypePair analyzeCallNewFwd(Node expr,TypeEnv inEnv,JSType requiredType,JSType specializedType){
  if (isPropertyTestCall(expr)) {
    return analyzePropertyTestCallFwd(expr,inEnv,specializedType);
  }
  Node callee=expr.getFirstChild();
  if (isFunctionBind(callee,inEnv,true)) {
    return analyzeFunctionBindFwd(expr,inEnv);
  }
  AssertionFunctionSpec assertionFunctionSpec=assertionFunctionsMap.get(callee.getQualifiedName());
  if (assertionFunctionSpec != null) {
    return analyzeAssertionCall(expr,inEnv,assertionFunctionSpec);
  }
  EnvTypePair calleePair=analyzeExprFwd(callee,inEnv,commonTypes.topFunction());
  TypeEnv envAfterCallee=calleePair.env;
  calleePair=mayWarnAboutNullableReferenceAndTighten(callee,calleePair.type,null,envAfterCallee);
  JSType calleeType=calleePair.type;
  if (calleeType.isBottom() || !calleeType.isSubtypeOf(commonTypes.topFunction())) {
    warnings.add(JSError.make(expr,NOT_CALLABLE,calleeType.toString()));
  }
  FunctionType funType=calleeType.getFunTypeIfSingletonObj();
  if (funType == null || funType.isTopFunction() || funType.isQmarkFunction()) {
    return analyzeCallNodeArgsFwdWhenError(expr,envAfterCallee);
  }
 else   if (funType.isLoose()) {
    return analyzeLooseCallNodeFwd(expr,envAfterCallee,requiredType);
  }
 else   if (!isConstructorCall(expr) && funType.isSomeConstructorOrInterface() && (funType.getReturnType().isUnknown() || funType.getReturnType().isUndefined())) {
    warnings.add(JSError.make(expr,CONSTRUCTOR_NOT_CALLABLE,funType.toString()));
    return analyzeCallNodeArgsFwdWhenError(expr,envAfterCallee);
  }
 else   if (expr.isNew()) {
    if (!funType.isSomeConstructorOrInterface() || funType.isInterfaceDefinition()) {
      warnings.add(JSError.make(expr,NOT_A_CONSTRUCTOR,funType.toString()));
      return analyzeCallNodeArgsFwdWhenError(expr,envAfterCallee);
    }
 else     if (funType.isConstructorOfAbstractClass()) {
      warnings.add(JSError.make(expr,CANNOT_INSTANTIATE_ABSTRACT_CLASS,funType.toString()));
      return analyzeCallNodeArgsFwdWhenError(expr,envAfterCallee);
    }
  }
  int maxArity=funType.getMaxArity();
  int minArity=funType.getMinArity();
  int numArgs=expr.getChildCount() - 1;
  if (numArgs < minArity || numArgs > maxArity) {
    warnings.add(JSError.make(expr,WRONG_ARGUMENT_COUNT,getReadableCalleeName(callee),Integer.toString(numArgs),Integer.toString(minArity),""String_Node_Str"" + maxArity));
    return analyzeCallNodeArgsFwdWhenError(expr,envAfterCallee);
  }
  FunctionType origFunType=funType;
  if (funType.isGeneric()) {
    Map<String,JSType> typeMap=calcTypeInstantiationFwd(expr,callee.isGetProp() ? callee.getFirstChild() : null,expr.getSecondChild(),funType,envAfterCallee);
    funType=funType.instantiateGenerics(typeMap);
    println(""String_Node_Str"",funType);
  }
  List<JSType> argTypes=new ArrayList<>();
  TypeEnv tmpEnv=analyzeCallNodeArgumentsFwd(expr,expr.getSecondChild(),funType,argTypes,envAfterCallee);
  if (callee.isName()) {
    String calleeName=callee.getString();
    if (currentScope.isKnownFunction(calleeName) && !currentScope.isExternalFunction(calleeName)) {
      if (currentScope.isLocalFunDef(calleeName)) {
        tmpEnv=collectTypesForFreeVarsFwd(callee,tmpEnv);
      }
 else       if (!origFunType.isGeneric()) {
        JSType expectedRetType=requiredType;
        println(""String_Node_Str"",expectedRetType,""String_Node_Str"",argTypes);
        DeferredCheck dc;
        if (isConstructorCall(expr)) {
          dc=new DeferredCheck(expr,null,currentScope,currentScope.getScope(calleeName));
          deferredChecks.put(expr,dc);
        }
 else {
          dc=deferredChecks.get(expr);
          if (dc != null) {
            dc.updateReturn(expectedRetType);
          }
 else {
            Preconditions.checkState(!currentScope.hasUndeclaredFormalsOrOuters(),""String_Node_Str"",expr);
          }
        }
        if (dc != null) {
          dc.updateArgTypes(argTypes);
        }
      }
    }
  }
  JSType retType=expr.isNew() ? funType.getThisType() : funType.getReturnType();
  if (retType.isSubtypeOf(requiredType)) {
    retType=retType.specialize(specializedType);
  }
  return new EnvTypePair(tmpEnv,retType);
}",0.9995248277500594
19366,"public static MismatchInfo whyNotSubtypeOf(JSType t1,JSType t2){
  if (t1.isSingletonObj() && t2.isSingletonObj()) {
    MismatchInfo[] boxedInfo=new MismatchInfo[1];
    ObjectType.whyNotSubtypeOf(t1.getObjTypeIfSingletonObj(),t2.getObjTypeIfSingletonObj(),boxedInfo);
    return boxedInfo[0];
  }
  if (t1.isUnion()) {
    MismatchInfo[] boxedInfo=new MismatchInfo[1];
    boolean areSubtypes=t1.isSubtypeOfHelper(true,t2,SubtypeCache.create(),boxedInfo);
    Preconditions.checkState(!areSubtypes);
    return boxedInfo[0];
  }
  return null;
}","public static MismatchInfo whyNotSubtypeOf(JSType found,JSType expected){
  if (found.isSingletonObj() && expected.isSingletonObj()) {
    MismatchInfo[] boxedInfo=new MismatchInfo[1];
    ObjectType.whyNotSubtypeOf(found.getObjTypeIfSingletonObj(),expected.getObjTypeIfSingletonObj(),boxedInfo);
    return boxedInfo[0];
  }
  if (found.isUnion()) {
    MismatchInfo[] boxedInfo=new MismatchInfo[1];
    boolean areSubtypes=found.isSubtypeOfHelper(true,expected,SubtypeCache.create(),boxedInfo);
    Preconditions.checkState(!areSubtypes);
    return boxedInfo[0];
  }
  return null;
}",0.9338040600176524
19367,"private ObjectType withLoose(){
  if (isTopObject()) {
    return this.commonTypes.getLooseTopObjectType();
  }
  if (isLoose() || this.nominalType != null && this.nominalType.isClassy() || this.ns != null) {
    return this;
  }
  FunctionType fn=this.fn == null ? null : this.fn.withLoose();
  PersistentMap<String,Property> newProps=PersistentMap.create();
  for (  Map.Entry<String,Property> propsEntry : this.props.entrySet()) {
    String pname=propsEntry.getKey();
    Property prop=propsEntry.getValue();
    newProps=newProps.with(pname,prop.withRequired());
  }
  return new ObjectType(this.commonTypes,this.nominalType,newProps,fn,null,true,this.objectKind);
}","private ObjectType withLoose(){
  if (isTopObject()) {
    return this.commonTypes.getLooseTopObjectType();
  }
  if (isLoose() || (!this.nominalType.isBuiltinObject() && !this.nominalType.isFunction()) || this.ns != null) {
    return this;
  }
  FunctionType fn=this.fn == null ? null : this.fn.withLoose();
  PersistentMap<String,Property> newProps=PersistentMap.create();
  for (  Map.Entry<String,Property> propsEntry : this.props.entrySet()) {
    String pname=propsEntry.getKey();
    Property prop=propsEntry.getValue();
    newProps=newProps.with(pname,prop.withRequired());
  }
  return new ObjectType(this.commonTypes,this.nominalType,newProps,fn,null,true,this.objectKind);
}",0.2253313696612665
19368,"private ObjectType(JSTypes commonTypes,NominalType nominalType,PersistentMap<String,Property> props,FunctionType fn,Namespace ns,boolean isLoose,ObjectKind objectKind){
  Preconditions.checkNotNull(commonTypes);
  Preconditions.checkNotNull(nominalType);
  Preconditions.checkArgument(fn == null || fn.isQmarkFunction() || fn.isLoose() == isLoose,""String_Node_Str"",isLoose,fn);
  Preconditions.checkArgument(FunctionType.isInhabitable(fn));
  if (ns != null) {
    String name=nominalType.getName();
    Preconditions.checkArgument(name.equals(JSTypes.OBJLIT_CLASS_NAME) || name.equals(""String_Node_Str"") || name.equals(""String_Node_Str""),""String_Node_Str"",name);
  }
  Preconditions.checkArgument(!nominalType.isClassy() || !isLoose,""String_Node_Str"",nominalType);
  Preconditions.checkArgument(fn == null || nominalType.isFunction(),""String_Node_Str"",nominalType,fn);
  this.commonTypes=commonTypes;
  this.nominalType=nominalType;
  this.props=isLoose ? loosenProps(props) : props;
  this.fn=fn;
  this.ns=ns;
  this.isLoose=isLoose;
  this.objectKind=isLoose ? ObjectKind.UNRESTRICTED : objectKind;
}","private ObjectType(JSTypes commonTypes,NominalType nominalType,PersistentMap<String,Property> props,FunctionType fn,Namespace ns,boolean isLoose,ObjectKind objectKind){
  Preconditions.checkNotNull(commonTypes);
  Preconditions.checkNotNull(nominalType);
  Preconditions.checkArgument(fn == null || fn.isQmarkFunction() || fn.isLoose() == isLoose,""String_Node_Str"",isLoose,fn);
  Preconditions.checkArgument(FunctionType.isInhabitable(fn));
  if (ns != null) {
    String name=nominalType.getName();
    Preconditions.checkArgument(name.equals(JSTypes.OBJLIT_CLASS_NAME) || name.equals(""String_Node_Str"") || name.equals(""String_Node_Str""),""String_Node_Str"",name);
  }
  if (isLoose) {
    Preconditions.checkArgument(nominalType.isBuiltinObject() || nominalType.isFunction(),""String_Node_Str"",nominalType);
  }
  Preconditions.checkArgument(fn == null || nominalType.isFunction(),""String_Node_Str"",nominalType,fn);
  this.commonTypes=commonTypes;
  this.nominalType=nominalType;
  this.props=isLoose ? loosenProps(props) : props;
  this.fn=fn;
  this.ns=ns;
  this.isLoose=isLoose;
  this.objectKind=isLoose ? ObjectKind.UNRESTRICTED : objectKind;
}",0.6542387927208166
19369,"StringBuilder appendTo(StringBuilder builder){
  if (isPrototypeObject()) {
    return builder.append(getOwnerFunction().getThisType()).append(""String_Node_Str"");
  }
  if (!hasNonPrototypeProperties()) {
    if (fn != null) {
      return fn.appendTo(builder);
    }
 else     if (this.nominalType != null) {
      return this.nominalType.appendTo(builder);
    }
  }
  if (!nominalType.getName().equals(""String_Node_Str"") && !nominalType.getName().equals(""String_Node_Str"") && !nominalType.getName().equals(JSTypes.OBJLIT_CLASS_NAME)) {
    nominalType.appendTo(builder);
  }
 else   if (isStruct()) {
    builder.append(""String_Node_Str"");
  }
 else   if (isDict()) {
    builder.append(""String_Node_Str"");
  }
 else   if (this.ns != null) {
    builder.append(this.ns);
  }
  if (this.fn != null) {
    builder.append(""String_Node_Str"");
    fn.appendTo(builder);
    builder.append(""String_Node_Str"");
  }
  if (ns == null || !props.isEmpty()) {
    builder.append('{');
    boolean firstIteration=true;
    for (    String pname : new TreeSet<>(props.keySet())) {
      if (firstIteration) {
        firstIteration=false;
      }
 else {
        builder.append(""String_Node_Str"");
      }
      builder.append(pname);
      builder.append(':');
      props.get(pname).appendTo(builder);
    }
    builder.append('}');
  }
  if (isLoose) {
    builder.append(""String_Node_Str"");
  }
  return builder;
}","StringBuilder appendTo(StringBuilder builder){
  if (isPrototypeObject()) {
    return builder.append(getOwnerFunction().getThisType()).append(""String_Node_Str"");
  }
  if (!hasNonPrototypeProperties()) {
    if (fn != null) {
      return fn.appendTo(builder);
    }
    return this.nominalType.appendTo(builder);
  }
  if (!nominalType.getName().equals(""String_Node_Str"") && !nominalType.getName().equals(""String_Node_Str"") && !nominalType.getName().equals(JSTypes.OBJLIT_CLASS_NAME)) {
    nominalType.appendTo(builder);
  }
 else   if (isStruct()) {
    builder.append(""String_Node_Str"");
  }
 else   if (isDict()) {
    builder.append(""String_Node_Str"");
  }
 else   if (this.ns != null) {
    builder.append(this.ns);
  }
  if (this.fn != null) {
    builder.append(""String_Node_Str"");
    fn.appendTo(builder);
    builder.append(""String_Node_Str"");
  }
  if (ns == null || !props.isEmpty()) {
    builder.append('{');
    boolean firstIteration=true;
    for (    String pname : new TreeSet<>(props.keySet())) {
      if (firstIteration) {
        firstIteration=false;
      }
 else {
        builder.append(""String_Node_Str"");
      }
      builder.append(pname);
      builder.append(':');
      props.get(pname).appendTo(builder);
    }
    builder.append('}');
  }
  if (isLoose) {
    builder.append(""String_Node_Str"");
  }
  return builder;
}",0.9609261939218524
19370,"private Property getLeftmostProp(QualifiedName qname){
  String pname=qname.getLeftmostName();
  Property p=props.get(pname);
  if (p != null) {
    return p;
  }
  if (this.ns != null) {
    p=this.ns.getNsProp(pname);
    if (p != null) {
      return p;
    }
  }
  if (this.nominalType != null) {
    return this.nominalType.getProp(pname);
  }
  if (this.commonTypes.getObjectType() != null) {
    return this.commonTypes.getObjectType().getProp(pname);
  }
  return null;
}","private Property getLeftmostProp(QualifiedName qname){
  String pname=qname.getLeftmostName();
  Property p=props.get(pname);
  if (p != null) {
    return p;
  }
  if (this.ns != null) {
    p=this.ns.getNsProp(pname);
    if (p != null) {
      return p;
    }
  }
  return this.nominalType.getProp(pname);
}",0.7249683143219265
19371,"static void whyNotSubtypeOf(ObjectType obj1,ObjectType obj2,MismatchInfo[] boxedInfo){
  Preconditions.checkArgument(boxedInfo.length == 1);
  boolean areSubtypes=obj1.isSubtypeOfHelper(true,obj2,SubtypeCache.create(),boxedInfo);
  Preconditions.checkState(!areSubtypes);
}","static void whyNotSubtypeOf(ObjectType obj1,ObjectType obj2,MismatchInfo[] boxedInfo){
  Preconditions.checkArgument(boxedInfo.length == 1);
  boolean areSubtypes=obj1.isSubtypeOfHelper(true,obj2,SubtypeCache.create(),boxedInfo);
  Preconditions.checkState(!areSubtypes,""String_Node_Str"",obj1,obj2);
}",0.951219512195122
19372,"boolean isInterfaceInstance(){
  return this.nominalType != null && this.nominalType.isInterface();
}","boolean isInterfaceInstance(){
  return this.nominalType.isInterface();
}",0.8390804597701149
19373,"static ObjectType meet(ObjectType obj1,ObjectType obj2){
  Preconditions.checkState(areRelatedNominalTypes(obj1.nominalType,obj2.nominalType));
  if (obj1.isTopObject() || obj2.isBottomObject()) {
    return obj2;
  }
 else   if (obj2.isTopObject() || obj1.isBottomObject()) {
    return obj1;
  }
  JSTypes commonTypes=obj1.commonTypes;
  NominalType resultNomType=NominalType.pickSubclass(obj1.nominalType,obj2.nominalType);
  FunctionType fn=FunctionType.meet(obj1.fn,obj2.fn);
  if (!FunctionType.isInhabitable(fn)) {
    return commonTypes.getBottomObject();
  }
  boolean isLoose=obj1.isLoose && obj2.isLoose || fn != null && fn.isLoose();
  if (resultNomType.isFunction() && fn == null) {
    fn=obj1.fn == null ? obj2.fn : obj1.fn;
    isLoose=fn.isLoose();
  }
  PersistentMap<String,Property> props;
  if (isLoose) {
    props=joinPropsLoosely(commonTypes,obj1.props,obj2.props);
  }
 else {
    props=meetPropsHelper(commonTypes,false,resultNomType,obj1.props,obj2.props);
  }
  if (props == commonTypes.BOTTOM_PROPERTY_MAP) {
    return commonTypes.getBottomObject();
  }
  ObjectKind ok=ObjectKind.meet(obj1.objectKind,obj2.objectKind);
  Namespace resultNs=Objects.equals(obj1.ns,obj2.ns) ? obj1.ns : null;
  return new ObjectType(commonTypes,resultNomType,props,fn,resultNs,isLoose,ok);
}","static ObjectType meet(ObjectType obj1,ObjectType obj2){
  Preconditions.checkState(areRelatedNominalTypes(obj1.nominalType,obj2.nominalType));
  if (obj1.isTopObject() || obj2.isBottomObject()) {
    return obj2;
  }
 else   if (obj2.isTopObject() || obj1.isBottomObject()) {
    return obj1;
  }
  JSTypes commonTypes=obj1.commonTypes;
  NominalType resultNomType=NominalType.pickSubclass(obj1.nominalType,obj2.nominalType);
  FunctionType fn=FunctionType.meet(obj1.fn,obj2.fn);
  if (!FunctionType.isInhabitable(fn)) {
    return commonTypes.getBottomObject();
  }
  boolean isLoose=(obj1.isLoose && obj2.isLoose) || fn != null && fn.isLoose();
  if (resultNomType.isFunction() && fn == null) {
    fn=obj1.fn == null ? obj2.fn : obj1.fn;
    isLoose=fn.isLoose();
  }
  PersistentMap<String,Property> props;
  if (isLoose) {
    props=joinPropsLoosely(commonTypes,obj1.props,obj2.props);
  }
 else {
    props=meetPropsHelper(commonTypes,false,resultNomType,obj1.props,obj2.props);
  }
  if (props == commonTypes.BOTTOM_PROPERTY_MAP) {
    return commonTypes.getBottomObject();
  }
  ObjectKind ok=ObjectKind.meet(obj1.objectKind,obj2.objectKind);
  Namespace resultNs=Objects.equals(obj1.ns,obj2.ns) ? obj1.ns : null;
  return new ObjectType(commonTypes,resultNomType,props,fn,resultNs,isLoose,ok);
}",0.9992331288343558
19374,"ObjectType specialize(ObjectType other){
  Preconditions.checkState(areRelatedNominalTypes(this.nominalType,other.nominalType));
  if (isTopObject() && other.objectKind.isUnrestricted()) {
    return other;
  }
  if (this.ns != null) {
    return specializeNamespace(other);
  }
  NominalType resultNomType;
  if (this.nominalType.isBuiltinObject() && other.nominalType.isStructuralInterface()) {
    resultNomType=this.nominalType;
  }
 else {
    resultNomType=NominalType.pickSubclass(this.nominalType,other.nominalType);
  }
  if (resultNomType.isClassy()) {
    Preconditions.checkState(this.fn == null && other.fn == null);
    PersistentMap<String,Property> newProps=meetPropsHelper(this.commonTypes,true,resultNomType,this.props,other.props);
    if (newProps == this.commonTypes.BOTTOM_PROPERTY_MAP) {
      return this.commonTypes.getBottomObject();
    }
    return new ObjectType(this.commonTypes,resultNomType,newProps,null,this.ns,false,this.objectKind);
  }
  FunctionType thisFn=this.fn;
  boolean isLoose=this.isLoose;
  if (resultNomType.isFunction() && this.fn == null) {
    thisFn=other.fn;
    isLoose=other.fn.isLoose();
  }
  PersistentMap<String,Property> newProps=meetPropsHelper(this.commonTypes,true,resultNomType,this.props,other.props);
  if (newProps == this.commonTypes.BOTTOM_PROPERTY_MAP) {
    return this.commonTypes.getBottomObject();
  }
  FunctionType newFn=thisFn == null ? null : thisFn.specialize(other.fn);
  if (!FunctionType.isInhabitable(newFn)) {
    return this.commonTypes.getBottomObject();
  }
  return new ObjectType(this.commonTypes,resultNomType,newProps,newFn,this.ns,isLoose,this.objectKind);
}","ObjectType specialize(ObjectType other){
  Preconditions.checkState(areRelatedNominalTypes(this.nominalType,other.nominalType));
  if (isTopObject() && other.objectKind.isUnrestricted()) {
    return other;
  }
  if (this.ns != null) {
    return specializeNamespace(other);
  }
  NominalType resultNomType;
  if (this.nominalType.isBuiltinObject() && other.nominalType.isStructuralInterface()) {
    resultNomType=this.nominalType;
  }
 else {
    resultNomType=NominalType.pickSubclass(this.nominalType,other.nominalType);
  }
  if (resultNomType.isClassy()) {
    Preconditions.checkState(this.fn == null && other.fn == null);
    PersistentMap<String,Property> newProps=meetPropsHelper(this.commonTypes,true,resultNomType,this.props,other.props);
    if (newProps == this.commonTypes.BOTTOM_PROPERTY_MAP) {
      return this.commonTypes.getBottomObject();
    }
    return new ObjectType(this.commonTypes,resultNomType,newProps,null,this.ns,false,this.objectKind);
  }
  FunctionType thisFn=this.fn;
  boolean isLoose=this.isLoose;
  if (resultNomType.isFunction() && this.fn == null) {
    thisFn=other.fn;
    isLoose=other.fn.isLoose();
  }
  if (isLoose && resultNomType.isLiteralObject()) {
    resultNomType=this.commonTypes.getObjectType();
  }
  PersistentMap<String,Property> newProps=meetPropsHelper(this.commonTypes,true,resultNomType,this.props,other.props);
  if (newProps == this.commonTypes.BOTTOM_PROPERTY_MAP) {
    return this.commonTypes.getBottomObject();
  }
  FunctionType newFn=thisFn == null ? null : thisFn.specialize(other.fn);
  if (!FunctionType.isInhabitable(newFn)) {
    return this.commonTypes.getBottomObject();
  }
  return new ObjectType(this.commonTypes,resultNomType,newProps,newFn,this.ns,isLoose,this.objectKind);
}",0.9683098591549296
19375,"private static JSType joinNominalTypes(JSType nt1,JSType nt2){
  if (nt1 == null || nt2 == null) {
    return null;
  }
  NominalType n1=getNominalTypeIfSingletonObj(nt1);
  NominalType n2=getNominalTypeIfSingletonObj(nt2);
  if (n1 != null && n2 != null) {
    NominalType tmp=NominalType.pickSuperclass(n1,n2);
    if (tmp != null) {
      return tmp.getInstanceAsJSType();
    }
  }
  return JSType.join(nt1,nt2);
}","private static JSType joinNominalTypes(JSType nt1,JSType nt2){
  if (nt1 == null || nt2 == null) {
    return null;
  }
  NominalType n1=getNominalTypeIfSingletonObj(nt1);
  NominalType n2=getNominalTypeIfSingletonObj(nt2);
  if (n1 != null && n2 != null) {
    NominalType tmp=NominalType.join(n1,n2);
    if (tmp != null) {
      return tmp.getInstanceAsJSType();
    }
  }
  return JSType.join(nt1,nt2);
}",0.9782082324455206
19376,"static ObjectType join(ObjectType obj1,ObjectType obj2){
  if (obj1.isTopObject() || obj2.isTopObject()) {
    return obj1.commonTypes.getTopObjectType();
  }
  if (obj1.equals(obj2)) {
    return obj1;
  }
  NominalType nt1=obj1.nominalType;
  NominalType nt2=obj2.nominalType;
  Preconditions.checkState(nt1.isRawSubtypeOf(nt2) || nt2.isRawSubtypeOf(nt1));
  JSTypes commonTypes=obj1.commonTypes;
  boolean isLoose=obj1.isLoose || obj2.isLoose;
  FunctionType fn=FunctionType.join(obj1.fn,obj2.fn);
  PersistentMap<String,Property> props;
  if (isLoose) {
    fn=fn == null ? null : fn.withLoose();
    props=joinPropsLoosely(commonTypes,obj1.props,obj2.props);
  }
 else {
    props=joinProps(obj1.props,obj2.props,nt1,nt2);
  }
  NominalType nominal=NominalType.pickSuperclass(nt1,nt2);
  if (nominal.isBuiltinObject() && fn != null) {
    if (isLoose) {
      nominal=obj1.commonTypes.getFunctionType();
    }
 else {
      fn=null;
    }
  }
  Namespace ns=Objects.equals(obj1.ns,obj2.ns) ? obj1.ns : null;
  return makeObjectType(commonTypes,nominal,props,fn,ns,isLoose,ObjectKind.join(obj1.objectKind,obj2.objectKind));
}","static ObjectType join(ObjectType obj1,ObjectType obj2){
  if (obj1.isTopObject() || obj2.isTopObject()) {
    return obj1.commonTypes.getTopObjectType();
  }
  if (obj1.equals(obj2)) {
    return obj1;
  }
  NominalType nt1=obj1.nominalType;
  NominalType nt2=obj2.nominalType;
  Preconditions.checkState(nt1.isRawSubtypeOf(nt2) || nt2.isRawSubtypeOf(nt1));
  JSTypes commonTypes=obj1.commonTypes;
  boolean isLoose=obj1.isLoose || obj2.isLoose;
  FunctionType fn=FunctionType.join(obj1.fn,obj2.fn);
  PersistentMap<String,Property> props;
  if (isLoose) {
    fn=fn == null ? null : fn.withLoose();
    props=joinPropsLoosely(commonTypes,obj1.props,obj2.props);
  }
 else {
    props=joinProps(obj1.props,obj2.props,nt1,nt2);
  }
  NominalType nominal=NominalType.join(nt1,nt2);
  if (nominal.isBuiltinObject() && fn != null) {
    if (isLoose) {
      nominal=obj1.commonTypes.getFunctionType();
    }
 else {
      fn=null;
    }
  }
  Namespace ns=Objects.equals(obj1.ns,obj2.ns) ? obj1.ns : null;
  return makeObjectType(commonTypes,nominal,props,fn,ns,isLoose,ObjectKind.join(obj1.objectKind,obj2.objectKind));
}",0.9919928825622776
19377,"public void testOnlyOneInstanceOfEachClassInUnion(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testOnlyOneInstanceOfEachClassInUnion(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.8380545163014431
19378,"/** 
 * This may start a new line if the current line is longer than the line length threshold.
 */
@Override void maybeCutLine(){
  if (lineLength > lineLengthThreshold) {
    if (preferredBreakPosition > lineStartPosition && preferredBreakPosition < lineStartPosition + lineLength) {
      int position=preferredBreakPosition;
      code.insert(position,'\n');
      prevCutPosition=position;
      reportLineCut(lineIndex,position - lineStartPosition,true);
      lineIndex++;
      lineLength-=(position - lineStartPosition);
      lineStartPosition=position + 1;
    }
 else {
      startNewLine();
    }
  }
}","/** 
 * This may start a new line if the current line is longer than the line length threshold.
 */
@Override void maybeCutLine(){
  if (lineLength > lineLengthThreshold) {
    if (preferredBreakPosition > lineStartPosition && preferredBreakPosition < lineStartPosition + lineLength) {
      int position=preferredBreakPosition;
      code.insert(position,'\n');
      prevCutPosition=position;
      reportLineCut(lineIndex,position - lineStartPosition,true);
      lineIndex++;
      lineLength-=(position - lineStartPosition);
      prevLineStartPosition=lineStartPosition;
      lineStartPosition=position + 1;
    }
 else {
      startNewLine();
    }
  }
}",0.9631949882537196
19379,"@Override void endFile(){
  super.endFile();
  if (!preferLineBreakAtEndOfFile) {
    return;
  }
  if (lineLength > lineLengthThreshold / 2) {
    append(""String_Node_Str"");
    startNewLine();
  }
 else   if (prevCutPosition > 0) {
    code.setCharAt(prevCutPosition,' ');
    lineStartPosition=prevLineStartPosition;
    lineLength=code.length() - lineStartPosition;
    reportLineCut(lineIndex,prevCutPosition + 1,false);
    lineIndex--;
    prevCutPosition=0;
    prevLineStartPosition=0;
    append(""String_Node_Str"");
    startNewLine();
  }
 else {
  }
}","@Override void endFile(){
  super.endFile();
  if (!preferLineBreakAtEndOfFile) {
    return;
  }
  if (lineLength > lineLengthThreshold / 2) {
    append(""String_Node_Str"");
    startNewLine();
  }
 else   if (prevCutPosition > 0) {
    code.setCharAt(prevCutPosition,' ');
    lineStartPosition=prevLineStartPosition;
    lineLength=code.length() - lineStartPosition;
    int prevLineEndPosition=prevCutPosition - prevLineStartPosition + 1;
    reportLineCut(lineIndex,prevLineEndPosition,false);
    lineIndex--;
    prevCutPosition=0;
    prevLineStartPosition=0;
    append(""String_Node_Str"");
    startNewLine();
  }
 else {
  }
}",0.8974145120934112
19380,"private JSType evalTemplateTypeOf(Node ttlAst,NameResolver nameResolver){
  ImmutableList<Node> params=getCallParams(ttlAst);
  JSType type=evalInternal(params.get(0),nameResolver);
  if (!type.isTemplatizedType()) {
    reportWarning(ttlAst,TEMPTYPE_INVALID,""String_Node_Str"",type.toString());
    return getUnknownType();
  }
  int index=(int)params.get(1).getDouble();
  ImmutableList<JSType> templateTypes=((TemplatizedType)type).getTemplateTypes();
  if (index > templateTypes.size()) {
    reportWarning(ttlAst,INDEX_OUTOFBOUNDS,Integer.toString(index),Integer.toString(templateTypes.size()));
    return getUnknownType();
  }
  return templateTypes.get(index);
}","private JSType evalTemplateTypeOf(Node ttlAst,NameResolver nameResolver){
  ImmutableList<Node> params=getCallParams(ttlAst);
  JSType type=evalInternal(params.get(0),nameResolver);
  if (!type.isTemplatizedType()) {
    reportWarning(ttlAst,TEMPTYPE_INVALID,""String_Node_Str"",type.toString());
    return getUnknownType();
  }
  int index=(int)params.get(1).getDouble();
  ImmutableList<JSType> templateTypes=((TemplatizedType)type).getTemplateTypes();
  if (index >= templateTypes.size()) {
    reportWarning(ttlAst,INDEX_OUTOFBOUNDS,Integer.toString(index),Integer.toString(templateTypes.size()));
    return getUnknownType();
  }
  return templateTypes.get(index);
}",0.9992531740104555
19381,"/** 
 * Invalidates the given type, so that no properties on it will be renamed.
 */
private void recordInvalidatingType(JSType type,JSError error){
  type=type.restrictByNotNullOrUndefined();
  if (type.isUnionType()) {
    for (    JSType alt : type.toMaybeUnionType().getAlternatesWithoutStructuralTyping()) {
      recordInvalidatingType(alt,error);
    }
  }
 else   if (type.isEnumElementType()) {
    recordInvalidatingType(type.toMaybeEnumElementType().getPrimitiveType(),error);
  }
 else {
    addInvalidatingType(type);
    recordInvalidationError(type,error);
    ObjectType objType=ObjectType.cast(type);
    if (objType != null && objType.getImplicitPrototype() != null) {
      addInvalidatingType(objType.getImplicitPrototype());
      recordInvalidationError(objType.getImplicitPrototype(),error);
    }
    if (objType != null && objType.isConstructor() && objType.isFunctionType()) {
      addInvalidatingType(objType.toMaybeFunctionType().getInstanceType());
    }
  }
}","/** 
 * Invalidates the given type, so that no properties on it will be renamed.
 */
private void recordInvalidatingType(JSType type,TypeMismatch mis){
  type=type.restrictByNotNullOrUndefined();
  if (type.isUnionType()) {
    for (    JSType alt : type.toMaybeUnionType().getAlternatesWithoutStructuralTyping()) {
      recordInvalidatingType(alt,mis);
    }
  }
 else   if (type.isEnumElementType()) {
    recordInvalidatingType(type.toMaybeEnumElementType().getPrimitiveType(),mis);
  }
 else {
    addInvalidatingType(type);
    recordInvalidationError(type,mis);
    ObjectType objType=ObjectType.cast(type);
    if (objType != null && objType.getImplicitPrototype() != null) {
      addInvalidatingType(objType.getImplicitPrototype());
      recordInvalidationError(objType.getImplicitPrototype(),mis);
    }
    if (objType != null && objType.isConstructor() && objType.isFunctionType()) {
      addInvalidatingType(objType.toMaybeFunctionType().getInstanceType());
    }
  }
}",0.5762025316455697
19382,"@Override public void process(Node externs,Node root){
  Preconditions.checkState(compiler.getLifeCycleStage() == LifeCycleStage.NORMALIZED);
  this.ancestorInterfaces=new HashMap<>();
  this.gtwpCache=new HashMap<>();
  for (  TypeMismatch mis : compiler.getTypeMismatches()) {
    recordInvalidatingType(mis.typeA,mis.src);
    recordInvalidatingType(mis.typeB,mis.src);
  }
  for (  TypeMismatch mis : compiler.getImplicitInterfaceUses()) {
    recordInvalidatingType(mis.typeA,mis.src);
    recordInvalidatingType(mis.typeB,mis.src);
  }
  NodeTraversal.traverseEs6(compiler,externs,new FindExternProperties());
  NodeTraversal.traverseEs6(compiler,root,new FindRenameableProperties());
  renameProperties();
}","@Override public void process(Node externs,Node root){
  Preconditions.checkState(compiler.getLifeCycleStage() == LifeCycleStage.NORMALIZED);
  this.ancestorInterfaces=new HashMap<>();
  this.gtwpCache=new HashMap<>();
  for (  TypeMismatch mis : compiler.getTypeMismatches()) {
    recordInvalidatingType(mis.typeA,mis);
    recordInvalidatingType(mis.typeB,mis);
  }
  for (  TypeMismatch mis : compiler.getImplicitInterfaceUses()) {
    recordInvalidatingType(mis.typeA,mis);
    recordInvalidatingType(mis.typeB,mis);
  }
  NodeTraversal.traverseEs6(compiler,externs,new FindExternProperties());
  NodeTraversal.traverseEs6(compiler,root,new FindRenameableProperties());
  renameProperties();
}",0.9886685552407932
19383,"private void recordInvalidationError(JSType t,JSError error){
  if (!t.isObject()) {
    return;
  }
  if (invalidationMap != null) {
    Collection<JSError> errors=this.invalidationMap.get(t);
    if (errors.size() < MAX_INVALIDATION_WARNINGS_PER_PROPERTY) {
      errors.add(error);
    }
  }
}","private void recordInvalidationError(JSType t,TypeMismatch mis){
  if (!t.isObject()) {
    return;
  }
  if (invalidationMap != null) {
    Collection<JSError> errors=this.invalidationMap.get(t);
    if (errors.size() < MAX_INVALIDATION_WARNINGS_PER_PROPERTY) {
      JSError error=mis.src;
      if (error.getType().equals(TypeValidator.TYPE_MISMATCH_WARNING) && error.description.isEmpty()) {
        String msg=""String_Node_Str"" + mis.typeA + ""String_Node_Str""+ mis.typeB;
        error=JSError.make(error.node,TypeValidator.TYPE_MISMATCH_WARNING,msg);
      }
      errors.add(error);
    }
  }
}",0.5930880713489409
19384,"private void recordImplicitInterfaceUses(Node src,JSType sourceType,JSType targetType){
  sourceType=removeNullUndefinedAndTemplates(sourceType);
  targetType=removeNullUndefinedAndTemplates(targetType);
  boolean strictMismatch=!sourceType.isSubtypeWithoutStructuralTyping(targetType) && !targetType.isSubtypeWithoutStructuralTyping(sourceType);
  boolean mismatch=!sourceType.isSubtype(targetType) && !targetType.isSubtype(sourceType);
  if (strictMismatch || mismatch) {
    String msg;
    if (numImplicitUses < 10) {
      msg=""String_Node_Str"" + sourceType + ""String_Node_Str""+ targetType;
    }
 else {
      msg=""String_Node_Str"";
    }
    numImplicitUses++;
    JSError err=JSError.make(src,TYPE_MISMATCH_WARNING,msg);
    implicitInterfaceUses.add(new TypeMismatch(sourceType,targetType,err));
  }
}","private void recordImplicitInterfaceUses(Node src,JSType sourceType,JSType targetType){
  sourceType=removeNullUndefinedAndTemplates(sourceType);
  targetType=removeNullUndefinedAndTemplates(targetType);
  boolean strictMismatch=!sourceType.isSubtypeWithoutStructuralTyping(targetType) && !targetType.isSubtypeWithoutStructuralTyping(sourceType);
  boolean mismatch=!sourceType.isSubtype(targetType) && !targetType.isSubtype(sourceType);
  if (strictMismatch || mismatch) {
    JSError err=JSError.make(src,TYPE_MISMATCH_WARNING,""String_Node_Str"");
    implicitInterfaceUses.add(new TypeMismatch(sourceType,targetType,err));
  }
}",0.8513888888888889
19385,"/** 
 * Converts a tree to JS code
 */
private static String toSource(Node root,Format outputFormat,CompilerOptions options,SourceMap sourceMap,boolean tagAsExterns,boolean tagAsStrict,boolean lineBreak,CodeGeneratorFactory codeGeneratorFactory){
  Preconditions.checkState(options.sourceMapDetailLevel != null);
  boolean createSourceMap=(sourceMap != null);
  MappedCodePrinter mcp=outputFormat == Format.COMPACT ? new CompactCodePrinter(lineBreak,options.preferLineBreakAtEndOfFile,options.lineLengthThreshold,createSourceMap,options.sourceMapDetailLevel) : new PrettyCodePrinter(options.lineLengthThreshold,createSourceMap,options.sourceMapDetailLevel);
  CodeGenerator cg=codeGeneratorFactory.getCodeGenerator(outputFormat,mcp);
  if (tagAsExterns) {
    cg.tagAsExterns();
  }
  if (tagAsStrict) {
    cg.tagAsStrict();
  }
  cg.add(root);
  mcp.endFile();
  String code=mcp.getCode();
  if (createSourceMap) {
    mcp.generateSourceMap(sourceMap);
  }
  return code;
}","/** 
 * Converts a tree to JS code
 */
private static String toSource(Node root,Format outputFormat,CompilerOptions options,SourceMap sourceMap,boolean tagAsExterns,boolean tagAsStrict,boolean lineBreak,CodeGeneratorFactory codeGeneratorFactory){
  Preconditions.checkState(options.sourceMapDetailLevel != null);
  boolean createSourceMap=(sourceMap != null);
  MappedCodePrinter mcp=outputFormat == Format.COMPACT ? new CompactCodePrinter(lineBreak,options.preferLineBreakAtEndOfFile,options.lineLengthThreshold,createSourceMap,options.sourceMapDetailLevel) : new PrettyCodePrinter(options.lineLengthThreshold,createSourceMap,options.sourceMapDetailLevel);
  CodeGenerator cg=codeGeneratorFactory.getCodeGenerator(outputFormat,mcp);
  if (tagAsExterns) {
    cg.tagAsExterns();
  }
  if (tagAsStrict) {
    cg.tagAsStrict();
  }
  cg.add(root);
  mcp.endFile();
  String code=mcp.getCode();
  if (createSourceMap) {
    mcp.generateSourceMap(code,sourceMap);
  }
  return code;
}",0.9974424552429668
19386,"/** 
 * Generates the source map from the given code consumer, appending the information it saved to the SourceMap object given.
 */
void generateSourceMap(SourceMap map){
  if (createSrcMap) {
    for (    Mapping mapping : allMappings) {
      map.addMapping(mapping.node,mapping.start,mapping.end);
    }
  }
}","/** 
 * Generates the source map from the given code consumer, appending the information it saved to the SourceMap object given.
 */
void generateSourceMap(String code,SourceMap map){
  if (createSrcMap) {
    List<Integer> lineLengths=computeLineLengths(code);
    for (    Mapping mapping : allMappings) {
      map.addMapping(mapping.node,mapping.start,adjustEndPosition(lineLengths,mapping.end));
    }
  }
}",0.863448275862069
19387,"@Override SourceFile getSourceFileByName(String sourceName){
  if (sourceName != null) {
    CompilerInput input=inputsById.get(new InputId(sourceName));
    if (input != null) {
      return input.getSourceFile();
    }
    return sourceMapOriginalSources.get(sourceName);
  }
  return null;
}","@Override public SourceFile getSourceFileByName(String sourceName){
  if (sourceName != null) {
    CompilerInput input=inputsById.get(new InputId(sourceName));
    if (input != null) {
      return input.getSourceFile();
    }
    return sourceMapOriginalSources.get(sourceName);
  }
  return null;
}",0.9882352941176472
19388,"/** 
 * Applies the provided set of code replacements to the code and returns the transformed code. The code replacements may not have any overlap.
 */
public static String applyCodeReplacements(Iterable<CodeReplacement> replacements,String code){
  List<CodeReplacement> sortedReplacements=ORDER_CODE_REPLACEMENTS.sortedCopy(replacements);
  validateNoOverlaps(sortedReplacements);
  StringBuilder sb=new StringBuilder();
  int lastIndex=0;
  for (  CodeReplacement replacement : sortedReplacements) {
    sb.append(code,lastIndex,replacement.getStartPosition());
    sb.append(replacement.getNewContent());
    lastIndex=replacement.getStartPosition() + replacement.getLength();
  }
  if (lastIndex <= code.length()) {
    sb.append(code,lastIndex,code.length());
  }
  return sb.toString();
}","/** 
 * Applies the provided set of code replacements to the code and returns the transformed code. The code replacements may not have any overlap.
 */
public static String applyCodeReplacements(Iterable<CodeReplacement> replacements,String code){
  List<CodeReplacement> sortedReplacements=ORDER_CODE_REPLACEMENTS.sortedCopy(replacements);
  validateNoOverlaps(sortedReplacements);
  StringBuilder sb=new StringBuilder();
  int lastIndex=0;
  for (  CodeReplacement replacement : sortedReplacements) {
    sb.append(code,lastIndex,replacement.getStartPosition());
    sb.append(replacement.getNewContent());
    lastIndex=replacement.getEndPosition();
  }
  if (lastIndex <= code.length()) {
    sb.append(code,lastIndex,code.length());
  }
  return sb.toString();
}",0.9782330345710628
19389,"/** 
 * Checks whether the CodeReplacements have any overlap. The replacements must be provided in order sorted by start position, as sorted by ORDER_CODE_REPLACEMENTS.
 */
private static boolean containsOverlaps(List<CodeReplacement> replacements){
  Preconditions.checkState(ORDER_CODE_REPLACEMENTS.isOrdered(replacements));
  int start=-1;
  for (  CodeReplacement replacement : replacements) {
    if (replacement.getStartPosition() < start) {
      return true;
    }
    start=Math.max(start,replacement.getStartPosition() + replacement.getLength());
  }
  return false;
}","/** 
 * Checks whether the CodeReplacements have any overlap. The replacements must be provided in order sorted by start position, as sorted by ORDER_CODE_REPLACEMENTS.
 */
private static boolean containsOverlaps(List<CodeReplacement> replacements){
  Preconditions.checkState(ORDER_CODE_REPLACEMENTS.isOrdered(replacements));
  int start=-1;
  for (  CodeReplacement replacement : replacements) {
    if (replacement.getStartPosition() < start) {
      return true;
    }
    start=Math.max(start,replacement.getEndPosition());
  }
  return false;
}",0.9698581560283688
19390,"/** 
 * Returns how many bytes the new content should replace in the original content.
 */
public int getLength(){
  return length;
}","/** 
 * Returns how many characters the new content should replace in the original content.
 */
public int getLength(){
  return length;
}",0.966789667896679
19391,"public DeclaredFunctionType withTypeInfoFromSuper(DeclaredFunctionType superType,boolean getsTypeInfoFromParentMethod){
  if (getsTypeInfoFromParentMethod && getSyntacticArity() == superType.getSyntacticArity()) {
    NominalType nt=superType.nominalType == null ? null : superType.nominalType.getNominalTypeIfSingletonObj();
    NominalType rt=this.receiverType == null ? null : this.receiverType.getNominalTypeIfSingletonObj();
    return new DeclaredFunctionType(this.commonTypes,superType.requiredFormals,superType.optionalFormals,superType.restFormals,superType.returnType,nt == null ? null : nt.getInstanceAsJSType(),rt == null ? null : rt.getInstanceAsJSType(),superType.typeParameters,false);
  }
  FunctionTypeBuilder builder=new FunctionTypeBuilder(this.commonTypes);
  int i=0;
  for (  JSType formal : this.requiredFormals) {
    builder.addReqFormal(formal != null ? formal : superType.getFormalType(i));
    i++;
  }
  for (  JSType formal : this.optionalFormals) {
    builder.addOptFormal(formal != null ? formal : superType.getFormalType(i));
    i++;
  }
  if (this.restFormals != null) {
    builder.addRestFormals(this.restFormals);
  }
 else   if (superType.hasRestFormals()) {
    builder.addRestFormals(superType.restFormals);
  }
  builder.addRetType(this.returnType != null ? this.returnType : superType.returnType);
  builder.addNominalType(this.nominalType);
  builder.addReceiverType(this.receiverType);
  if (!this.typeParameters.isEmpty()) {
    builder.addTypeParameters(this.typeParameters);
  }
 else   if (!superType.typeParameters.isEmpty()) {
    builder.addTypeParameters(superType.typeParameters);
  }
  return builder.buildDeclaration();
}","public DeclaredFunctionType withTypeInfoFromSuper(DeclaredFunctionType superType,boolean getsTypeInfoFromParentMethod){
  if (getsTypeInfoFromParentMethod && getSyntacticArity() == superType.getSyntacticArity()) {
    NominalType nt=superType.nominalType == null ? null : superType.nominalType.getNominalTypeIfSingletonObj();
    NominalType rt=this.receiverType == null ? null : this.receiverType.getNominalTypeIfSingletonObj();
    return new DeclaredFunctionType(this.commonTypes,superType.requiredFormals,superType.optionalFormals,superType.restFormals,superType.returnType,nt == null ? null : nt.getInstanceAsJSType(),rt == null ? null : rt.getInstanceAsJSType(),superType.typeParameters,false);
  }
  FunctionTypeBuilder builder=new FunctionTypeBuilder(this.commonTypes);
  int i=0;
  for (  JSType formal : this.requiredFormals) {
    builder.addReqFormal(formal != null ? formal : superType.getFormalType(i));
    i++;
  }
  for (  JSType formal : this.optionalFormals) {
    builder.addOptFormal(formal != null ? formal : superType.getFormalType(i));
    i++;
  }
  if (this.restFormals != null) {
    builder.addRestFormals(this.restFormals);
  }
 else   if (superType.hasRestFormals()) {
    builder.addRestFormals(superType.restFormals);
  }
  builder.addRetType(this.returnType != null ? this.returnType : superType.returnType);
  builder.addNominalType(this.nominalType);
  builder.addReceiverType(this.receiverType);
  if (!this.typeParameters.isEmpty()) {
    builder.addTypeParameters(this.typeParameters);
  }
 else   if (!superType.typeParameters.isEmpty()) {
    builder.addTypeParameters(superType.typeParameters);
  }
  builder.addAbstract(this.isAbstract);
  return builder.buildDeclaration();
}",0.988221436984688
19392,"public void testAbstractDeclarations(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.CANNOT_INSTANTIATE_ABSTRACT_CLASS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),GlobalTypeInfo.ABSTRACT_METHOD_IN_CONCRETE_CLASS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),GlobalTypeInfo.ABSTRACT_METHOD_IN_INTERFACE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),GlobalTypeInfo.ABSTRACT_METHOD_NOT_IMPLEMENTED_IN_CONCRETE_CLASS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),GlobalTypeInfo.ABSTRACT_METHOD_NOT_IMPLEMENTED_IN_CONCRETE_CLASS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),GlobalTypeInfo.INTERFACE_METHOD_NOT_IMPLEMENTED);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testAbstractDeclarations(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.CANNOT_INSTANTIATE_ABSTRACT_CLASS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),GlobalTypeInfo.ABSTRACT_METHOD_IN_CONCRETE_CLASS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),GlobalTypeInfo.ABSTRACT_METHOD_IN_INTERFACE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),GlobalTypeInfo.ABSTRACT_METHOD_NOT_IMPLEMENTED_IN_CONCRETE_CLASS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),GlobalTypeInfo.ABSTRACT_METHOD_NOT_IMPLEMENTED_IN_CONCRETE_CLASS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),GlobalTypeInfo.INTERFACE_METHOD_NOT_IMPLEMENTED);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.9345646437994723
19393,"/** 
 * Returns the type in the chain from the given type that contains the given field or null if it is not found anywhere. Can return a subtype of the input type.
 */
@VisibleForTesting ObjectType getTypeWithProperty(String field,JSType type){
  if (type == null) {
    return null;
  }
  ObjectType foundType=gtwpCacheGet(field,type);
  if (foundType != null) {
    return foundType.equals(BOTTOM_OBJECT) ? null : foundType;
  }
  if (type.isEnumElementType()) {
    foundType=getTypeWithProperty(field,type.toMaybeEnumElementType().getPrimitiveType());
    gtwpCachePut(field,type,foundType == null ? BOTTOM_OBJECT : foundType);
    return foundType;
  }
  if (!(type instanceof ObjectType)) {
    if (type.autoboxesTo() != null) {
      foundType=getTypeWithProperty(field,type.autoboxesTo());
      gtwpCachePut(field,type,foundType == null ? BOTTOM_OBJECT : foundType);
      return foundType;
    }
 else {
      gtwpCachePut(field,type,BOTTOM_OBJECT);
      return null;
    }
  }
  if (""String_Node_Str"".equals(field)) {
    gtwpCachePut(field,type,BOTTOM_OBJECT);
    return null;
  }
  ObjectType objType=ObjectType.cast(type);
  if (objType != null && objType.getConstructor() != null && objType.getConstructor().isInterface()) {
    ObjectType topInterface=FunctionType.getTopDefiningInterface(objType,field);
    if (topInterface != null && topInterface.getConstructor() != null) {
      foundType=topInterface.getConstructor().getPrototype();
    }
  }
 else {
    while (objType != null && !Objects.equals(objType.getImplicitPrototype(),objType)) {
      if (objType.hasOwnProperty(field)) {
        foundType=objType;
      }
      objType=objType.getImplicitPrototype();
    }
  }
  if (foundType == null) {
    ObjectType maybeType=ObjectType.cast(registry.getGreatestSubtypeWithProperty(type,field));
    if (maybeType != null && maybeType.hasOwnProperty(field)) {
      foundType=maybeType;
    }
  }
  if (foundType != null && foundType.isTemplatizedType()) {
    foundType=foundType.toMaybeTemplatizedType().getReferencedType();
  }
  if (foundType != null && foundType.isNamedType()) {
    foundType=foundType.toMaybeNamedType().getReferencedType().toMaybeObjectType();
  }
  gtwpCachePut(field,type,foundType == null ? BOTTOM_OBJECT : foundType);
  return foundType;
}","/** 
 * Returns the type in the chain from the given type that contains the given field or null if it is not found anywhere. Can return a subtype of the input type.
 */
private ObjectType getTypeWithProperty(String field,JSType type){
  if (type == null) {
    return null;
  }
  ObjectType foundType=gtwpCacheGet(field,type);
  if (foundType != null) {
    return foundType.equals(BOTTOM_OBJECT) ? null : foundType;
  }
  if (type.isEnumElementType()) {
    foundType=getTypeWithProperty(field,type.toMaybeEnumElementType().getPrimitiveType());
    gtwpCachePut(field,type,foundType == null ? BOTTOM_OBJECT : foundType);
    return foundType;
  }
  if (!(type instanceof ObjectType)) {
    if (type.autoboxesTo() != null) {
      foundType=getTypeWithProperty(field,type.autoboxesTo());
      gtwpCachePut(field,type,foundType == null ? BOTTOM_OBJECT : foundType);
      return foundType;
    }
 else {
      gtwpCachePut(field,type,BOTTOM_OBJECT);
      return null;
    }
  }
  if (""String_Node_Str"".equals(field)) {
    gtwpCachePut(field,type,BOTTOM_OBJECT);
    return null;
  }
  ObjectType objType=ObjectType.cast(type);
  if (objType != null && objType.getConstructor() != null && objType.getConstructor().isInterface()) {
    ObjectType topInterface=FunctionType.getTopDefiningInterface(objType,field);
    if (topInterface != null && topInterface.getConstructor() != null) {
      foundType=topInterface.getConstructor().getPrototype();
    }
  }
 else {
    while (objType != null && !Objects.equals(objType.getImplicitPrototype(),objType)) {
      if (objType.hasOwnProperty(field)) {
        foundType=objType;
      }
      objType=objType.getImplicitPrototype();
    }
  }
  if (foundType == null) {
    ObjectType maybeType=ObjectType.cast(registry.getGreatestSubtypeWithProperty(type,field));
    if (maybeType != null && maybeType.hasOwnProperty(field)) {
      foundType=maybeType;
    }
  }
  if (foundType != null && foundType.isTemplatizedType()) {
    foundType=foundType.toMaybeTemplatizedType().getReferencedType();
  }
  if (foundType != null && foundType.isNamedType()) {
    foundType=foundType.toMaybeNamedType().getReferencedType().toMaybeObjectType();
  }
  gtwpCachePut(field,type,foundType == null ? BOTTOM_OBJECT : foundType);
  return foundType;
}",0.994537906925934
19394,"/** 
 * Records that this property could be referenced from any interface that this type, or any type in its superclass chain, implements. If the property p is defined only on a subtype of constructor, then this method has no effect. But we tried modifying getTypeWithProperty to tell us when the returned type is a subtype, and then skip those calls to recordInterface, and there was no speed-up. And it made the code harder to understand, so we don't do it.
 */
private void recordInterfaces(FunctionType constructor,JSType relatedType,DisambiguateProperties.Property p){
  Preconditions.checkArgument(constructor.isConstructor());
  Iterable<ObjectType> interfaces=implementedInterfaces.get(constructor);
  if (interfaces == null) {
    interfaces=constructor.getImplementedInterfaces();
    implementedInterfaces.put(constructor,interfaces);
  }
  for (  ObjectType itype : interfaces) {
    JSType top=getTypeWithProperty(p.name,itype);
    if (top != null) {
      p.addType(itype,relatedType);
    }
    if (p.skipRenaming) {
      return;
    }
  }
}","/** 
 * Records that this property could be referenced from any interface that this type inherits from. If the property p is defined only on a subtype of constructor, then this method has no effect. But we tried modifying getTypeWithProperty to tell us when the returned type is a subtype, and then skip those calls to recordInterface, and there was no speed-up. And it made the code harder to understand, so we don't do it.
 */
private void recordInterfaces(FunctionType constructor,JSType relatedType,Property p){
  Iterable<ObjectType> interfaces=ancestorInterfaces.get(constructor);
  if (interfaces == null) {
    interfaces=constructor.isConstructor() ? constructor.getImplementedInterfaces() : constructor.getExtendedInterfaces();
    ancestorInterfaces.put(constructor,interfaces);
  }
  for (  ObjectType itype : interfaces) {
    JSType top=getTypeWithProperty(p.name,itype);
    if (top != null) {
      p.addType(itype,relatedType);
    }
    if (p.skipRenaming) {
      return;
    }
  }
}",0.8786407766990292
19395,"@Override public void process(Node externs,Node root){
  Preconditions.checkState(compiler.getLifeCycleStage() == LifeCycleStage.NORMALIZED);
  this.implementedInterfaces=new HashMap<>();
  this.gtwpCache=new HashMap<>();
  for (  TypeMismatch mis : compiler.getTypeMismatches()) {
    recordInvalidatingType(mis.typeA,mis.src);
    recordInvalidatingType(mis.typeB,mis.src);
  }
  for (  TypeMismatch mis : compiler.getImplicitInterfaceUses()) {
    recordInvalidatingType(mis.typeA,mis.src);
    recordInvalidatingType(mis.typeB,mis.src);
  }
  NodeTraversal.traverseEs6(compiler,externs,new FindExternProperties());
  NodeTraversal.traverseEs6(compiler,root,new FindRenameableProperties());
  renameProperties();
}","@Override public void process(Node externs,Node root){
  Preconditions.checkState(compiler.getLifeCycleStage() == LifeCycleStage.NORMALIZED);
  this.ancestorInterfaces=new HashMap<>();
  this.gtwpCache=new HashMap<>();
  for (  TypeMismatch mis : compiler.getTypeMismatches()) {
    recordInvalidatingType(mis.typeA,mis.src);
    recordInvalidatingType(mis.typeB,mis.src);
  }
  for (  TypeMismatch mis : compiler.getImplicitInterfaceUses()) {
    recordInvalidatingType(mis.typeA,mis.src);
    recordInvalidatingType(mis.typeB,mis.src);
  }
  NodeTraversal.traverseEs6(compiler,externs,new FindExternProperties());
  NodeTraversal.traverseEs6(compiler,root,new FindRenameableProperties());
  renameProperties();
}",0.986722571628232
19396,"private FunctionType getConstructor(JSType type){
  ObjectType objType=ObjectType.cast(type);
  if (objType == null) {
    return null;
  }
  FunctionType constructor=null;
  if (objType.isFunctionType()) {
    constructor=objType.toMaybeFunctionType();
  }
 else   if (objType.isFunctionPrototypeType()) {
    constructor=objType.getOwnerFunction();
  }
 else {
    constructor=objType.getConstructor();
  }
  return constructor != null && constructor.isConstructor() ? constructor : null;
}","private FunctionType getConstructor(JSType type){
  ObjectType objType=ObjectType.cast(type);
  if (objType == null) {
    return null;
  }
  FunctionType constructor=null;
  if (objType.isFunctionType()) {
    constructor=objType.toMaybeFunctionType();
  }
 else   if (objType.isFunctionPrototypeType()) {
    constructor=objType.getOwnerFunction();
  }
 else {
    constructor=objType.getConstructor();
  }
  return constructor;
}",0.935064935064935
19397,"/** 
 * Returns the alternatives if this is a type that represents multiple types, and null if not. Union and interface types can correspond to multiple other types.
 */
private Iterable<JSType> getTypeAlternatives(JSType type){
  if (type.isUnionType()) {
    return type.toMaybeUnionType().getAlternatesWithoutStructuralTyping();
  }
 else {
    ObjectType objType=type.toObjectType();
    if (objType != null && objType.getConstructor() != null && objType.getConstructor().isInterface()) {
      List<JSType> list=new ArrayList<>();
      for (      FunctionType impl : registry.getDirectImplementors(objType)) {
        list.add(impl.getInstanceType());
      }
      return list;
    }
 else {
      return null;
    }
  }
}","/** 
 * Returns the alternatives if this is a type that represents multiple types, and null if not. Union and interface types can correspond to multiple other types.
 */
private Iterable<JSType> getTypeAlternatives(JSType type){
  if (type.isUnionType()) {
    return type.toMaybeUnionType().getAlternatesWithoutStructuralTyping();
  }
 else {
    ObjectType objType=type.toObjectType();
    if (objType != null && objType.getConstructor() != null && objType.getConstructor().isInterface()) {
      List<JSType> list=new ArrayList<>();
      for (      FunctionType impl : registry.getDirectImplementors(objType)) {
        list.add(impl.getInstanceType());
      }
      return list.isEmpty() ? null : list;
    }
 else {
      return null;
    }
  }
}",0.9838056680161944
19398,"/** 
 * Traverse a node and its children and remove any references to from the structures.
 */
void removeReferences(Node node){
  if (DefinitionsRemover.isDefinitionNode(node)) {
    DefinitionSite defSite=definitionNodeByDefinitionSite.get(node);
    if (defSite != null) {
      Definition def=defSite.definition;
      String name=getSimplifiedName(def.getLValue());
      if (name != null) {
        this.definitionNodeByDefinitionSite.remove(node);
        this.nameDefinitionMultimap.remove(name,node);
      }
    }
  }
 else {
    Node useSite=node;
    if (useSite.isGetProp()) {
      String propName=useSite.getLastChild().getString();
      if (propName.equals(""String_Node_Str"") || propName.equals(""String_Node_Str"")) {
        useSite=useSite.getFirstChild();
      }
    }
    String name=getSimplifiedName(useSite);
    if (name != null) {
      this.nameUseSiteMultimap.remove(name,new UseSite(useSite,null,null));
    }
  }
  for (  Node child : node.children()) {
    removeReferences(child);
  }
}","/** 
 * Traverse a node and its children and remove any references to from the structures.
 */
void removeReferences(Node node){
  if (DefinitionsRemover.isDefinitionNode(node)) {
    DefinitionSite defSite=definitionNodeByDefinitionSite.get(node);
    if (defSite != null) {
      Definition def=defSite.definition;
      String name=getSimplifiedName(def.getLValue());
      if (name != null) {
        this.definitionNodeByDefinitionSite.remove(node);
        this.nameDefinitionMultimap.remove(name,def);
      }
    }
  }
 else {
    Node useSite=node;
    if (useSite.isGetProp()) {
      String propName=useSite.getLastChild().getString();
      if (propName.equals(""String_Node_Str"") || propName.equals(""String_Node_Str"")) {
        useSite=useSite.getFirstChild();
      }
    }
    String name=getSimplifiedName(useSite);
    if (name != null) {
      this.nameUseSiteMultimap.remove(name,new UseSite(useSite,null,null));
    }
  }
  for (  Node child : node.children()) {
    removeReferences(child);
  }
}",0.9965601965601966
19399,"private void maybeRecordNominalType(Node defSite,Node nameNode,JSDocInfo fnDoc,boolean isRedeclaration){
  Preconditions.checkState(nameNode == null || nameNode.isQualifiedName());
  if (fnDoc == null) {
    return;
  }
  if (fnDoc.isConstructorOrInterface()) {
    if (nameNode == null) {
      warnings.add(JSError.make(defSite,ANONYMOUS_NOMINAL_TYPE));
      nameNode=IR.name(ANON_FUN_PREFIX + funNameGen.generateNextName());
      nameNode.useSourceInfoFrom(defSite);
    }
    String qname=nameNode.getQualifiedName();
    ImmutableList.Builder<String> builder=ImmutableList.builder();
    for (    String typeParam : fnDoc.getTemplateTypeNames()) {
      builder.add(varNameGen.getNextName(typeParam));
    }
    ImmutableList<String> typeParameters=builder.build();
    RawNominalType rawType;
    if (fnDoc.usesImplicitMatch()) {
      rawType=RawNominalType.makeStructuralInterface(commonTypes,defSite,qname,typeParameters);
    }
 else     if (fnDoc.isInterface()) {
      rawType=RawNominalType.makeNominalInterface(commonTypes,defSite,qname,typeParameters);
    }
 else     if (fnDoc.makesStructs()) {
      rawType=RawNominalType.makeStructClass(commonTypes,defSite,qname,typeParameters);
    }
 else     if (fnDoc.makesDicts()) {
      rawType=RawNominalType.makeDictClass(commonTypes,defSite,qname,typeParameters);
    }
 else {
      rawType=RawNominalType.makeUnrestrictedClass(commonTypes,defSite,qname,typeParameters);
    }
    nominaltypesByNode.put(defSite,rawType);
    if (isRedeclaration) {
      return;
    }
    Node firstChild=nameNode.getFirstChild();
    if (nameNode.isName() || currentScope.isNamespace(firstChild) || mayCreateFunctionNamespace(firstChild)|| mayCreateWindowNamespace(firstChild)) {
      if (nameNode.isGetProp()) {
        defSite.getParent().getFirstChild().putBooleanProp(Node.ANALYZED_DURING_GTI,true);
      }
 else       if (currentScope.isTopLevel()) {
        maybeRecordBuiltinType(qname,rawType);
      }
      currentScope.addNamespace(nameNode,rawType);
    }
  }
 else   if (fnDoc.makesStructs()) {
    warnings.add(JSError.make(defSite,STRUCTDICT_WITHOUT_CTOR,""String_Node_Str""));
  }
 else   if (fnDoc.makesDicts()) {
    warnings.add(JSError.make(defSite,STRUCTDICT_WITHOUT_CTOR,""String_Node_Str""));
  }
}","private void maybeRecordNominalType(Node defSite,Node nameNode,JSDocInfo fnDoc,boolean isRedeclaration){
  Preconditions.checkState(nameNode == null || nameNode.isQualifiedName());
  if (fnDoc == null) {
    return;
  }
  if (fnDoc.isConstructorOrInterface()) {
    if (nameNode == null) {
      warnings.add(JSError.make(defSite,ANONYMOUS_NOMINAL_TYPE));
      nameNode=IR.name(ANON_FUN_PREFIX + funNameGen.generateNextName());
      nameNode.useSourceInfoFrom(defSite);
    }
    String qname=nameNode.getQualifiedName();
    ImmutableList.Builder<String> builder=ImmutableList.builder();
    for (    String typeParam : fnDoc.getTemplateTypeNames()) {
      builder.add(varNameGen.getNextName(typeParam));
    }
    ImmutableList<String> typeParameters=builder.build();
    RawNominalType rawType;
    ObjectKind objKind=fnDoc.makesStructs() ? ObjectKind.STRUCT : (fnDoc.makesDicts() ? ObjectKind.DICT : ObjectKind.UNRESTRICTED);
    if (fnDoc.isConstructor()) {
      rawType=RawNominalType.makeClass(commonTypes,defSite,qname,typeParameters,objKind);
    }
 else     if (fnDoc.usesImplicitMatch()) {
      rawType=RawNominalType.makeStructuralInterface(commonTypes,defSite,qname,typeParameters,objKind);
    }
 else {
      Preconditions.checkState(fnDoc.isInterface());
      rawType=RawNominalType.makeNominalInterface(commonTypes,defSite,qname,typeParameters,objKind);
    }
    nominaltypesByNode.put(defSite,rawType);
    if (isRedeclaration) {
      return;
    }
    Node firstChild=nameNode.getFirstChild();
    if (nameNode.isName() || currentScope.isNamespace(firstChild) || mayCreateFunctionNamespace(firstChild)|| mayCreateWindowNamespace(firstChild)) {
      if (nameNode.isGetProp()) {
        defSite.getParent().getFirstChild().putBooleanProp(Node.ANALYZED_DURING_GTI,true);
      }
 else       if (currentScope.isTopLevel()) {
        maybeRecordBuiltinType(qname,rawType);
      }
      currentScope.addNamespace(nameNode,rawType);
    }
  }
 else   if (fnDoc.makesStructs()) {
    warnings.add(JSError.make(defSite,STRUCT_WITHOUT_CTOR_OR_INTERF));
  }
  if (fnDoc.makesDicts() && !fnDoc.isConstructor()) {
    warnings.add(JSError.make(defSite,DICT_WITHOUT_CTOR));
  }
}",0.8103023516237402
19400,"public static RawNominalType makeStructuralInterface(JSTypes commonTypes,Node defSite,String name,ImmutableList<String> typeParameters){
  return new RawNominalType(commonTypes,defSite,name,typeParameters,Kind.RECORD,ObjectKind.UNRESTRICTED);
}","public static RawNominalType makeStructuralInterface(JSTypes commonTypes,Node defSite,String name,ImmutableList<String> typeParameters,ObjectKind objKind){
  if (objKind == ObjectKind.DICT) {
    objKind=ObjectKind.UNRESTRICTED;
  }
  return new RawNominalType(commonTypes,defSite,name,typeParameters,Kind.RECORD,objKind);
}",0.778169014084507
19401,"public static RawNominalType makeNominalInterface(JSTypes commonTypes,Node defSite,String name,ImmutableList<String> typeParameters){
  return new RawNominalType(commonTypes,defSite,name,typeParameters,Kind.INTERFACE,ObjectKind.UNRESTRICTED);
}","public static RawNominalType makeNominalInterface(JSTypes commonTypes,Node defSite,String name,ImmutableList<String> typeParameters,ObjectKind objKind){
  if (objKind == ObjectKind.DICT) {
    objKind=ObjectKind.UNRESTRICTED;
  }
  return new RawNominalType(commonTypes,defSite,name,typeParameters,Kind.INTERFACE,objKind);
}",0.778169014084507
19402,"public void testMisplacedStructDictAnnotation(){
  typeCheck(""String_Node_Str"",GlobalTypeInfo.STRUCTDICT_WITHOUT_CTOR);
  typeCheck(""String_Node_Str"",GlobalTypeInfo.STRUCTDICT_WITHOUT_CTOR);
}","public void testMisplacedStructDictAnnotation(){
  typeCheck(""String_Node_Str"",GlobalTypeInfo.STRUCT_WITHOUT_CTOR_OR_INTERF);
  typeCheck(""String_Node_Str"",GlobalTypeInfo.DICT_WITHOUT_CTOR);
  typeCheck(""String_Node_Str"",GlobalTypeInfo.DICT_WITHOUT_CTOR);
}",0.8106904231625836
19403,"public void testStructPropAccess(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(""String_Node_Str"",NewTypeInference.ILLEGAL_OBJLIT_KEY);
  typeCheck(""String_Node_Str"",NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
}","public void testStructPropAccess(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(""String_Node_Str"",NewTypeInference.ILLEGAL_OBJLIT_KEY);
  typeCheck(""String_Node_Str"",NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.ILLEGAL_PROPERTY_ACCESS);
}",0.9523809523809524
19404,"static ObjectType join(ObjectType obj1,ObjectType obj2){
  if (obj1.isTopObject() || obj2.isTopObject()) {
    return obj1.commonTypes.TOP_OBJECTTYPE;
  }
  NominalType nom1=obj1.nominalType;
  NominalType nom2=obj2.nominalType;
  Preconditions.checkState(nom1 == null || nom2 == null || nom1.isRawSubtypeOf(nom2) || nom2.isRawSubtypeOf(nom1));
  if (obj1.equals(obj2)) {
    return obj1;
  }
  JSTypes commonTypes=obj1.commonTypes;
  boolean isLoose=obj1.isLoose || obj2.isLoose;
  FunctionType fn=FunctionType.join(obj1.fn,obj2.fn);
  PersistentMap<String,Property> props;
  if (isLoose) {
    fn=fn == null ? null : fn.withLoose();
    props=joinPropsLoosely(commonTypes,obj1.props,obj2.props);
  }
 else {
    props=joinProps(obj1.props,obj2.props,nom1,nom2);
  }
  NominalType nominal=NominalType.pickSuperclass(nom1,nom2);
  if (nominal == null || !nominal.isFunction()) {
    fn=null;
  }
  Namespace ns=Objects.equals(obj1.ns,obj2.ns) ? obj1.ns : null;
  return makeObjectType(commonTypes,nominal,props,fn,ns,isLoose,ObjectKind.join(obj1.objectKind,obj2.objectKind));
}","static ObjectType join(ObjectType obj1,ObjectType obj2){
  if ((obj1.isTopObject() && obj2.props.isEmpty()) || (obj2.isTopObject() && obj1.props.isEmpty())) {
    return obj1.commonTypes.TOP_OBJECTTYPE;
  }
  NominalType nom1=obj1.nominalType;
  NominalType nom2=obj2.nominalType;
  Preconditions.checkState(nom1 == null || nom2 == null || nom1.isRawSubtypeOf(nom2) || nom2.isRawSubtypeOf(nom1));
  if (obj1.equals(obj2)) {
    return obj1;
  }
  JSTypes commonTypes=obj1.commonTypes;
  boolean isLoose=obj1.isLoose || obj2.isLoose;
  FunctionType fn=FunctionType.join(obj1.fn,obj2.fn);
  PersistentMap<String,Property> props;
  if (isLoose) {
    fn=fn == null ? null : fn.withLoose();
    props=joinPropsLoosely(commonTypes,obj1.props,obj2.props);
  }
 else {
    props=joinProps(obj1.props,obj2.props,nom1,nom2);
  }
  NominalType nominal=NominalType.pickSuperclass(nom1,nom2);
  if (nominal == null || !nominal.isFunction()) {
    fn=null;
  }
  Namespace ns=Objects.equals(obj1.ns,obj2.ns) ? obj1.ns : null;
  return makeObjectType(commonTypes,nominal,props,fn,ns,isLoose,ObjectKind.join(obj1.objectKind,obj2.objectKind));
}",0.9764279238440616
19405,"public void testJoinWithTopObject(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testJoinWithTopObject(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.5610859728506787
19406,"@Override public final void visit(NodeTraversal nodeTraversal,Node n,Node parent){
  if (n.isCall() && parent.isExprResult() && n.getFirstChild().matchesQualifiedName(closureFunction)) {
    calls.add(parent);
  }
 else   if (NodeUtil.isNameDeclaration(parent) && n.getLastChild().getFirstChild().matchesQualifiedName(closureFunction)) {
    Preconditions.checkState(n.isName() || n.isDestructuringLhs());
    calls.add(parent);
  }
}","@Override public final void visit(NodeTraversal nodeTraversal,Node n,Node parent){
  if (n.isCall() && parent.isExprResult() && n.getFirstChild().matchesQualifiedName(closureFunction)) {
    calls.add(parent);
  }
 else   if (NodeUtil.isNameDeclaration(parent) && n.hasChildren() && n.getLastChild().isCall()&& n.getLastChild().getFirstChild().matchesQualifiedName(closureFunction)) {
    Preconditions.checkState(n.isName() || n.isDestructuringLhs());
    calls.add(parent);
  }
}",0.9486338797814208
19407,"public void testDoWhileLoopBranch() throws Exception {
  compareDoWhileLoopBranch(LanguageMode.ECMASCRIPT6);
}","public void testDoWhileLoopBranch() throws Exception {
  compareDoWhileLoopBranch(LanguageMode.ECMASCRIPT5);
  compareDoWhileLoopBranch(LanguageMode.ECMASCRIPT6);
}",0.8029197080291971
19408,"public void testDoWhileLoopMultiLineBranch() throws Exception {
  compareDoWhileLoopBranch(LanguageMode.ECMASCRIPT6);
}","public void testDoWhileLoopMultiLineBranch() throws Exception {
  compareDoWhileLoopMultiLineBranch(LanguageMode.ECMASCRIPT5);
  compareDoWhileLoopMultiLineBranch(LanguageMode.ECMASCRIPT6);
}",0.7677419354838709
19409,"/** 
 * Normalize the type of a constructor, its instance, and its prototype all down to the same type (the instance type).
 */
private static TypeI normalizeClassType(TypeI type){
  if (type == null || type.isUnknownType()) {
    return type;
  }
 else   if (type.isConstructor() || type.isInterface()) {
    return type.toMaybeFunctionType().getInstanceType();
  }
 else   if (type.isPrototypeObject()) {
    Preconditions.checkState(type instanceof ObjectType);
    FunctionType owner=((ObjectType)type).getOwnerFunction();
    if (owner.isConstructor()) {
      return owner.getInstanceType();
    }
  }
  return type;
}","/** 
 * Normalize the type of a constructor, its instance, and its prototype all down to the same type (the instance type).
 */
private static TypeI normalizeClassType(TypeI type){
  if (type == null || type.isUnknownType()) {
    return type;
  }
 else   if (type.isConstructor() || type.isInterface()) {
    return type.toMaybeFunctionType().getInstanceType();
  }
 else {
    ObjectTypeI obj=type.toMaybeObjectType();
    if (obj != null) {
      return obj.normalizeObjectForCheckAccessControls();
    }
  }
  return type;
}",0.6944444444444444
19410,"private void fixLineNumbers(Node expr){
  expr.setLineno(expr.getLineno() + templateLineno - 1);
  for (  Node child : expr.children()) {
    fixLineNumbers(child);
  }
}","private void fixLineNumbers(Node expr){
  expr.setLineno(expr.getLineno() + templateLineno);
  for (  Node child : expr.children()) {
    fixLineNumbers(child);
  }
}",0.988095238095238
19411,"private ParseTree parseCoverParenthesizedExpressionAndArrowParameterList(){
  if (peekType(1) == TokenType.FOR) {
    return parseGeneratorComprehension();
  }
  SourcePosition start=getTreeStartLocation();
  eat(TokenType.OPEN_PAREN);
  if (peek(TokenType.CLOSE_PAREN)) {
    eat(TokenType.CLOSE_PAREN);
    return new FormalParameterListTree(getTreeLocation(start),ImmutableList.<ParseTree>of());
  }
  if (peek(TokenType.SPREAD)) {
    ParseTree result=new FormalParameterListTree(getTreeLocation(start),ImmutableList.of(parseParameter(ParamContext.IMPLEMENTATION)));
    eat(TokenType.CLOSE_PAREN);
    return result;
  }
  ParseTree result=parseExpression();
  if (peek(TokenType.COMMA)) {
    eat(TokenType.COMMA);
    result=new CommaExpressionTree(getTreeLocation(start),ImmutableList.of(result,parseParameter(ParamContext.IMPLEMENTATION)));
  }
  eat(TokenType.CLOSE_PAREN);
  return new ParenExpressionTree(getTreeLocation(start),result);
}","private ParseTree parseCoverParenthesizedExpressionAndArrowParameterList(){
  if (peekType(1) == TokenType.FOR) {
    return parseGeneratorComprehension();
  }
  SourcePosition start=getTreeStartLocation();
  eat(TokenType.OPEN_PAREN);
  if (peek(TokenType.CLOSE_PAREN)) {
    eat(TokenType.CLOSE_PAREN);
    if (peek(TokenType.ARROW)) {
      return new FormalParameterListTree(getTreeLocation(start),ImmutableList.<ParseTree>of());
    }
 else {
      reportError(""String_Node_Str"");
      return new MissingPrimaryExpressionTree(getTreeLocation(start));
    }
  }
  if (peek(TokenType.SPREAD)) {
    ImmutableList<ParseTree> params=ImmutableList.of(parseParameter(ParamContext.IMPLEMENTATION));
    eat(TokenType.CLOSE_PAREN);
    if (peek(TokenType.ARROW)) {
      return new FormalParameterListTree(getTreeLocation(start),params);
    }
 else {
      reportError(""String_Node_Str"");
      return new MissingPrimaryExpressionTree(getTreeLocation(start));
    }
  }
  ParseTree result=parseExpression();
  if (peek(TokenType.COMMA)) {
    eat(TokenType.COMMA);
    result=new CommaExpressionTree(getTreeLocation(start),ImmutableList.of(result,parseParameter(ParamContext.IMPLEMENTATION)));
  }
  eat(TokenType.CLOSE_PAREN);
  return new ParenExpressionTree(getTreeLocation(start),result);
}",0.7757467677218012
19412,"private ParseTree parseAssignment(Expression expressionIn){
  if (peek(TokenType.YIELD) && inGeneratorContext()) {
    return parseYield(expressionIn);
  }
  SourcePosition start=getTreeStartLocation();
  ParseTree left=parseConditional(expressionIn);
  if (peek(TokenType.ARROW)) {
    return completeAssignmentExpressionParseAtArrow(left,expressionIn);
  }
  if (left.type == ParseTreeType.FORMAL_PARAMETER_LIST) {
    reportError(""String_Node_Str"");
  }
  if (peekAssignmentOperator()) {
    left=transformLeftHandSideExpression(left);
    if (!left.isValidAssignmentTarget()) {
      reportError(""String_Node_Str"");
    }
    Token operator=nextToken();
    if (TokenType.STAR_STAR_EQUAL.equals(operator.type)) {
      features=features.require(Feature.EXPONENT_OP);
    }
    ParseTree right=parseAssignment(expressionIn);
    return new BinaryOperatorTree(getTreeLocation(start),left,operator,right);
  }
  return left;
}","private ParseTree parseAssignment(Expression expressionIn){
  if (peek(TokenType.YIELD) && inGeneratorContext()) {
    return parseYield(expressionIn);
  }
  SourcePosition start=getTreeStartLocation();
  ParseTree left=parseConditional(expressionIn);
  if (peek(TokenType.ARROW)) {
    return completeAssignmentExpressionParseAtArrow(left,expressionIn);
  }
  if (peekAssignmentOperator()) {
    left=transformLeftHandSideExpression(left);
    if (!left.isValidAssignmentTarget()) {
      reportError(""String_Node_Str"");
    }
    Token operator=nextToken();
    if (TokenType.STAR_STAR_EQUAL.equals(operator.type)) {
      features=features.require(Feature.EXPONENT_OP);
    }
    ParseTree right=parseAssignment(expressionIn);
    return new BinaryOperatorTree(getTreeLocation(start),left,operator,right);
  }
  return left;
}",0.9441913439635536
19413,"protected void add(Node n,Context context){
  if (!cc.continueProcessing()) {
    return;
  }
  if (preserveTypeAnnotations && n.getJSDocInfo() != null) {
    String jsdocAsString=JSDocInfoPrinter.print(n.getJSDocInfo());
    if (!jsdocAsString.equals(""String_Node_Str"")) {
      add(jsdocAsString);
    }
  }
  Token type=n.getToken();
  String opstr=NodeUtil.opToStr(type);
  int childCount=n.getChildCount();
  Node first=n.getFirstChild();
  Node last=n.getLastChild();
  if (opstr != null && first != last) {
    Preconditions.checkState(childCount == 2,""String_Node_Str"",opstr,childCount);
    int p=NodeUtil.precedence(type);
    Context rhsContext=getContextForNoInOperator(context);
    boolean needsParens=(context == Context.START_OF_EXPR) && first.isObjectPattern();
    if (n.isAssign() && needsParens) {
      add(""String_Node_Str"");
    }
    if (NodeUtil.isAssignmentOp(n) || type == Token.EXPONENT) {
      addExpr(first,p + 1,context);
      cc.addOp(opstr,true);
      addExpr(last,p,rhsContext);
    }
 else {
      unrollBinaryOperator(n,type,opstr,context,rhsContext,p,p + 1);
    }
    if (n.isAssign() && needsParens) {
      add(""String_Node_Str"");
    }
    return;
  }
  cc.startSourceMapping(n);
switch (type) {
case TRY:
{
      Preconditions.checkState(first.getNext().isBlock() && !first.getNext().hasMoreThanOneChild());
      Preconditions.checkState(childCount >= 2 && childCount <= 3);
      add(""String_Node_Str"");
      add(first,Context.PRESERVE_BLOCK);
      Node catchblock=first.getNext().getFirstChild();
      if (catchblock != null) {
        add(catchblock);
      }
      if (childCount == 3) {
        cc.maybeInsertSpace();
        add(""String_Node_Str"");
        add(last,Context.PRESERVE_BLOCK);
      }
      break;
    }
case CATCH:
  Preconditions.checkState(childCount == 2);
cc.maybeInsertSpace();
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
add(last,Context.PRESERVE_BLOCK);
break;
case THROW:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(first);
cc.endStatement(true);
break;
case RETURN:
add(""String_Node_Str"");
if (childCount == 1) {
cc.maybeInsertSpace();
add(first);
}
 else {
Preconditions.checkState(childCount == 0);
}
cc.endStatement();
break;
case VAR:
if (first != null) {
add(""String_Node_Str"");
addList(first,false,getContextForNoInOperator(context),""String_Node_Str"");
}
break;
case CONST:
add(""String_Node_Str"");
addList(first,false,getContextForNoInOperator(context),""String_Node_Str"");
break;
case LET:
add(""String_Node_Str"");
addList(first,false,getContextForNoInOperator(context),""String_Node_Str"");
break;
case LABEL_NAME:
Preconditions.checkState(!n.getString().isEmpty());
addIdentifier(n.getString());
break;
case DESTRUCTURING_LHS:
add(first);
if (first != last) {
Preconditions.checkState(childCount == 2);
cc.addOp(""String_Node_Str"",true);
add(last);
}
break;
case NAME:
if (useOriginalName && n.getOriginalName() != null) {
addIdentifier(n.getOriginalName());
}
 else {
addIdentifier(n.getString());
}
maybeAddOptional(n);
maybeAddTypeDecl(n);
if (first != null && !first.isEmpty()) {
Preconditions.checkState(childCount == 1);
cc.addOp(""String_Node_Str"",true);
if (first.isComma()) {
addExpr(first,NodeUtil.precedence(Token.ASSIGN),Context.OTHER);
}
 else {
addExpr(first,0,getContextForNoInOperator(context));
}
}
break;
case ARRAYLIT:
add(""String_Node_Str"");
addArrayList(first);
add(""String_Node_Str"");
break;
case ARRAY_PATTERN:
add(""String_Node_Str"");
addArrayList(first);
add(""String_Node_Str"");
maybeAddTypeDecl(n);
break;
case PARAM_LIST:
add(""String_Node_Str"");
addList(first);
add(""String_Node_Str"");
break;
case DEFAULT_VALUE:
add(first);
maybeAddTypeDecl(n);
cc.addOp(""String_Node_Str"",true);
add(first.getNext());
break;
case COMMA:
Preconditions.checkState(childCount == 2);
unrollBinaryOperator(n,Token.COMMA,""String_Node_Str"",context,getContextForNoInOperator(context),0,0);
break;
case NUMBER:
Preconditions.checkState(childCount == 0);
cc.addNumber(n.getDouble());
break;
case TYPEOF:
case VOID:
case NOT:
case BITNOT:
case POS:
{
Preconditions.checkState(childCount == 1);
cc.addOp(NodeUtil.opToStrNoFail(type),false);
addExpr(first,NodeUtil.precedence(type),Context.OTHER);
break;
}
case NEG:
{
Preconditions.checkState(childCount == 1);
if (n.getFirstChild().isNumber()) {
cc.addNumber(-n.getFirstChild().getDouble());
}
 else {
cc.addOp(NodeUtil.opToStrNoFail(type),false);
addExpr(first,NodeUtil.precedence(type),Context.OTHER);
}
break;
}
case HOOK:
{
Preconditions.checkState(childCount == 3);
int p=NodeUtil.precedence(type);
Context rhsContext=getContextForNoInOperator(context);
addExpr(first,p + 1,context);
cc.addOp(""String_Node_Str"",true);
addExpr(first.getNext(),1,rhsContext);
cc.addOp(""String_Node_Str"",true);
addExpr(last,1,rhsContext);
break;
}
case REGEXP:
if (!first.isString() || !last.isString()) {
throw new Error(""String_Node_Str"");
}
String regexp=regexpEscape(first.getString());
if (childCount == 2) {
add(regexp + last.getString());
}
 else {
Preconditions.checkState(childCount == 1);
add(regexp);
}
break;
case FUNCTION:
{
if (n.getClass() != Node.class) {
throw new Error(""String_Node_Str"");
}
Preconditions.checkState(childCount == 3);
if (n.isArrowFunction()) {
addArrowFunction(n,first,last,context);
}
 else {
addFunction(n,first,last,context);
}
break;
}
case REST:
add(""String_Node_Str"");
add(first);
maybeAddTypeDecl(n);
break;
case SPREAD:
add(""String_Node_Str"");
add(n.getFirstChild());
break;
case EXPORT:
add(""String_Node_Str"");
if (n.getBooleanProp(Node.EXPORT_DEFAULT)) {
add(""String_Node_Str"");
}
if (n.getBooleanProp(Node.EXPORT_ALL_FROM)) {
add(""String_Node_Str"");
Preconditions.checkState(first != null && first.isEmpty());
}
 else {
add(first);
}
if (childCount == 2) {
add(""String_Node_Str"");
add(last);
}
processEnd(first,context);
break;
case IMPORT:
add(""String_Node_Str"");
Node second=first.getNext();
if (!first.isEmpty()) {
add(first);
if (!second.isEmpty()) {
cc.listSeparator();
}
}
if (!second.isEmpty()) {
add(second);
}
if (!first.isEmpty() || !second.isEmpty()) {
add(""String_Node_Str"");
}
add(last);
cc.endStatement();
break;
case EXPORT_SPECS:
case IMPORT_SPECS:
add(""String_Node_Str"");
for (Node c=first; c != null; c=c.getNext()) {
if (c != first) {
cc.listSeparator();
}
add(c);
}
add(""String_Node_Str"");
break;
case EXPORT_SPEC:
case IMPORT_SPEC:
add(first);
if (first != last) {
add(""String_Node_Str"");
add(last);
}
break;
case IMPORT_STAR:
add(""String_Node_Str"");
add(""String_Node_Str"");
add(n.getString());
break;
case CLASS:
{
Preconditions.checkState(childCount == 3);
boolean classNeedsParens=(context == Context.START_OF_EXPR);
if (classNeedsParens) {
add(""String_Node_Str"");
}
Node name=first;
Node superClass=first.getNext();
Node members=last;
add(""String_Node_Str"");
if (!name.isEmpty()) {
add(name);
}
maybeAddGenericTypes(first);
if (!superClass.isEmpty()) {
add(""String_Node_Str"");
add(superClass);
}
Node interfaces=(Node)n.getProp(Node.IMPLEMENTS);
if (interfaces != null) {
add(""String_Node_Str"");
Node child=interfaces.getFirstChild();
add(child);
while ((child=child.getNext()) != null) {
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(child);
}
}
add(members);
cc.endClass(context == Context.STATEMENT);
if (classNeedsParens) {
add(""String_Node_Str"");
}
}
break;
case CLASS_MEMBERS:
case INTERFACE_MEMBERS:
case NAMESPACE_ELEMENTS:
cc.beginBlock();
for (Node c=first; c != null; c=c.getNext()) {
add(c);
processEnd(c,context);
cc.endLine();
}
cc.endBlock(false);
break;
case ENUM_MEMBERS:
cc.beginBlock();
for (Node c=first; c != null; c=c.getNext()) {
add(c);
if (c.getNext() != null) {
add(""String_Node_Str"");
}
cc.endLine();
}
cc.endBlock(false);
break;
case GETTER_DEF:
case SETTER_DEF:
case MEMBER_FUNCTION_DEF:
case MEMBER_VARIABLE_DEF:
{
n.getParent().toStringTree();
Preconditions.checkState(n.getParent().isObjectLit() || n.getParent().isClassMembers() || n.getParent().isInterfaceMembers()|| n.getParent().isRecordType()|| n.getParent().isIndexSignature());
maybeAddAccessibilityModifier(n);
if (n.isStaticMember()) {
add(""String_Node_Str"");
}
if (!n.isMemberVariableDef() && n.getFirstChild().isGeneratorFunction()) {
Preconditions.checkState(type == Token.MEMBER_FUNCTION_DEF);
add(""String_Node_Str"");
}
if (n.isMemberFunctionDef() && n.getFirstChild().isAsyncFunction()) {
add(""String_Node_Str"");
}
switch (type) {
case GETTER_DEF:
Preconditions.checkState(!first.getSecondChild().hasChildren());
add(""String_Node_Str"");
break;
case SETTER_DEF:
Preconditions.checkState(first.getSecondChild().hasOneChild());
add(""String_Node_Str"");
break;
case MEMBER_FUNCTION_DEF:
case MEMBER_VARIABLE_DEF:
break;
default :
break;
}
String name=n.getString();
if (n.isMemberVariableDef()) {
add(n.getString());
maybeAddOptional(n);
maybeAddTypeDecl(n);
}
 else {
Preconditions.checkState(childCount == 1);
Preconditions.checkState(first.isFunction());
Preconditions.checkState(first.getFirstChild().getString().isEmpty());
Node fn=first;
Node parameters=fn.getSecondChild();
Node body=fn.getLastChild();
if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) && NodeUtil.isLatin(name)) {
add(name);
maybeAddGenericTypes(fn.getFirstChild());
}
 else {
double d=getSimpleNumber(name);
if (!Double.isNaN(d)) {
cc.addNumber(d);
}
 else {
addJsString(n);
}
}
maybeAddOptional(fn);
add(parameters);
maybeAddTypeDecl(fn);
add(body,Context.PRESERVE_BLOCK);
}
break;
}
case SCRIPT:
case MODULE_BODY:
case BLOCK:
{
if (n.getClass() != Node.class) {
throw new Error(""String_Node_Str"");
}
boolean preserveBlock=context == Context.PRESERVE_BLOCK;
if (preserveBlock) {
cc.beginBlock();
}
boolean preferLineBreaks=type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().isScript());
for (Node c=first; c != null; c=c.getNext()) {
add(c,Context.STATEMENT);
if (NodeUtil.isNameDeclaration(c)) {
cc.endStatement();
}
if (c.isFunction() || c.isClass()) {
cc.maybeLineBreak();
}
if (preferLineBreaks) {
cc.notePreferredLineBreak();
}
}
if (preserveBlock) {
cc.endBlock(cc.breakAfterBlockFor(n,context == Context.STATEMENT));
}
break;
}
case FOR:
if (childCount == 4) {
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
if (NodeUtil.isNameDeclaration(first)) {
add(first,Context.IN_FOR_INIT_CLAUSE);
}
 else {
addExpr(first,0,Context.IN_FOR_INIT_CLAUSE);
}
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
add(first.getNext().getNext());
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
}
 else {
Preconditions.checkState(childCount == 3);
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
}
break;
case FOR_OF:
Preconditions.checkState(childCount == 3);
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
break;
case DO:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
addNonEmptyStatement(first,Context.OTHER,false);
cc.maybeInsertSpace();
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(last);
add(""String_Node_Str"");
cc.endStatement();
break;
case WHILE:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
break;
case EMPTY:
Preconditions.checkState(childCount == 0);
break;
case GETPROP:
{
Preconditions.checkState(childCount == 2,""String_Node_Str"",childCount);
Preconditions.checkState(last.isString(),""String_Node_Str"");
boolean needsParens=(first.isNumber());
if (needsParens) {
add(""String_Node_Str"");
}
addExpr(first,NodeUtil.precedence(type),context);
if (needsParens) {
add(""String_Node_Str"");
}
if (quoteKeywordProperties && TokenStream.isKeyword(last.getString())) {
add(""String_Node_Str"");
add(last);
add(""String_Node_Str"");
}
 else {
add(""String_Node_Str"");
addIdentifier(last.getString());
}
break;
}
case GETELEM:
Preconditions.checkState(childCount == 2,""String_Node_Str"",childCount,n);
addExpr(first,NodeUtil.precedence(type),context);
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
break;
case WITH:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
break;
case INC:
case DEC:
{
Preconditions.checkState(childCount == 1);
String o=type == Token.INC ? ""String_Node_Str"" : ""String_Node_Str"";
boolean postProp=n.getBooleanProp(Node.INCRDECR_PROP);
if (postProp) {
addExpr(first,NodeUtil.precedence(type),context);
cc.addOp(o,false);
}
 else {
cc.addOp(o,false);
add(first);
}
break;
}
case CALL:
if (isIndirectEval(first) || (n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first))) {
add(""String_Node_Str"");
addExpr(first,NodeUtil.precedence(Token.COMMA),Context.OTHER);
add(""String_Node_Str"");
}
 else {
addExpr(first,NodeUtil.precedence(type),context);
}
Node args=first.getNext();
add(""String_Node_Str"");
addList(args);
add(""String_Node_Str"");
break;
case IF:
boolean hasElse=childCount == 3;
boolean ambiguousElseClause=context == Context.BEFORE_DANGLING_ELSE && !hasElse;
if (ambiguousElseClause) {
cc.beginBlock();
}
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
if (childCount == 1) {
break;
}
if (hasElse) {
addNonEmptyStatement(first.getNext(),Context.BEFORE_DANGLING_ELSE,false);
cc.maybeInsertSpace();
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
}
 else {
addNonEmptyStatement(first.getNext(),Context.OTHER,false);
Preconditions.checkState(childCount == 2);
}
if (ambiguousElseClause) {
cc.endBlock();
}
break;
case NULL:
Preconditions.checkState(childCount == 0);
cc.addConstant(""String_Node_Str"");
break;
case THIS:
Preconditions.checkState(childCount == 0);
add(""String_Node_Str"");
break;
case SUPER:
Preconditions.checkState(childCount == 0);
add(""String_Node_Str"");
break;
case NEW_TARGET:
Preconditions.checkState(childCount == 0);
add(""String_Node_Str"");
break;
case YIELD:
add(""String_Node_Str"");
if (n.isYieldFor()) {
Preconditions.checkNotNull(first);
add(""String_Node_Str"");
}
if (first != null) {
cc.maybeInsertSpace();
addExpr(first,NodeUtil.precedence(type),Context.OTHER);
}
break;
case AWAIT:
add(""String_Node_Str"");
addExpr(first,NodeUtil.precedence(type),Context.OTHER);
break;
case FALSE:
Preconditions.checkState(childCount == 0);
cc.addConstant(""String_Node_Str"");
break;
case TRUE:
Preconditions.checkState(childCount == 0);
cc.addConstant(""String_Node_Str"");
break;
case CONTINUE:
Preconditions.checkState(childCount <= 1);
add(""String_Node_Str"");
if (childCount == 1) {
if (!first.isLabelName()) {
throw new Error(""String_Node_Str"");
}
add(""String_Node_Str"");
add(first);
}
cc.endStatement();
break;
case DEBUGGER:
Preconditions.checkState(childCount == 0);
add(""String_Node_Str"");
cc.endStatement();
break;
case BREAK:
Preconditions.checkState(childCount <= 1);
add(""String_Node_Str"");
if (childCount == 1) {
if (!first.isLabelName()) {
throw new Error(""String_Node_Str"");
}
add(""String_Node_Str"");
add(first);
}
cc.endStatement();
break;
case EXPR_RESULT:
Preconditions.checkState(childCount == 1);
add(first,Context.START_OF_EXPR);
cc.endStatement();
break;
case NEW:
add(""String_Node_Str"");
int precedence=NodeUtil.precedence(type);
if (NodeUtil.containsType(first,Token.CALL,NodeUtil.MATCH_NOT_FUNCTION)) {
precedence=NodeUtil.precedence(first.getToken()) + 1;
}
addExpr(first,precedence,Context.OTHER);
Node next=first.getNext();
if (next != null) {
add(""String_Node_Str"");
addList(next);
add(""String_Node_Str"");
}
break;
case STRING_KEY:
addStringKey(n);
break;
case STRING:
Preconditions.checkState(childCount == 0,""String_Node_Str"");
addJsString(n);
break;
case DELPROP:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
add(first);
break;
case OBJECTLIT:
{
boolean needsParens=(context == Context.START_OF_EXPR);
if (needsParens) {
add(""String_Node_Str"");
}
add(""String_Node_Str"");
for (Node c=first; c != null; c=c.getNext()) {
if (c != first) {
cc.listSeparator();
}
Preconditions.checkState(c.isComputedProp() || c.isGetterDef() || c.isSetterDef()|| c.isStringKey()|| c.isMemberFunctionDef());
add(c);
}
add(""String_Node_Str"");
if (needsParens) {
add(""String_Node_Str"");
}
break;
}
case COMPUTED_PROP:
maybeAddAccessibilityModifier(n);
if (n.getBooleanProp(Node.STATIC_MEMBER)) {
add(""String_Node_Str"");
}
if (n.getBooleanProp(Node.COMPUTED_PROP_GETTER)) {
add(""String_Node_Str"");
}
 else if (n.getBooleanProp(Node.COMPUTED_PROP_SETTER)) {
add(""String_Node_Str"");
}
 else if (last.getBooleanProp(Node.GENERATOR_FN)) {
add(""String_Node_Str"");
}
 else if (last.isAsyncFunction()) {
add(""String_Node_Str"");
}
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
maybeAddTypeDecl(n);
if (n.getBooleanProp(Node.COMPUTED_PROP_METHOD) || n.getBooleanProp(Node.COMPUTED_PROP_GETTER) || n.getBooleanProp(Node.COMPUTED_PROP_SETTER)) {
Node function=first.getNext();
Node params=function.getSecondChild();
Node body=function.getLastChild();
add(params);
add(body,Context.PRESERVE_BLOCK);
}
 else {
boolean isInClass=n.getParent().getToken() == Token.CLASS_MEMBERS;
Node initializer=first.getNext();
if (initializer != null) {
Preconditions.checkState(!isInClass,""String_Node_Str"");
cc.addOp(""String_Node_Str"",false);
add(initializer);
}
 else {
Preconditions.checkState(n.getBooleanProp(Node.COMPUTED_PROP_VARIABLE),n);
}
}
break;
case OBJECT_PATTERN:
addObjectPattern(n);
maybeAddTypeDecl(n);
break;
case SWITCH:
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
cc.beginBlock();
addAllSiblings(first.getNext());
cc.endBlock(context == Context.STATEMENT);
break;
case CASE:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
add(first);
addCaseBody(last);
break;
case DEFAULT_CASE:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
addCaseBody(first);
break;
case LABEL:
Preconditions.checkState(childCount == 2);
if (!first.isLabelName()) {
throw new Error(""String_Node_Str"");
}
add(first);
add(""String_Node_Str"");
if (!last.isBlock()) {
cc.maybeInsertSpace();
}
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),true);
break;
case CAST:
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
break;
case TAGGED_TEMPLATELIT:
add(first,Context.START_OF_EXPR);
add(first.getNext());
break;
case TEMPLATELIT:
add(""String_Node_Str"");
for (Node c=first; c != null; c=c.getNext()) {
if (c.isString()) {
add(strEscape(c.getString(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false,false));
}
 else {
cc.append(""String_Node_Str"");
add(c.getFirstChild(),Context.START_OF_EXPR);
add(""String_Node_Str"");
}
}
add(""String_Node_Str"");
break;
case STRING_TYPE:
add(""String_Node_Str"");
break;
case BOOLEAN_TYPE:
add(""String_Node_Str"");
break;
case NUMBER_TYPE:
add(""String_Node_Str"");
break;
case ANY_TYPE:
add(""String_Node_Str"");
break;
case VOID_TYPE:
add(""String_Node_Str"");
break;
case NAMED_TYPE:
add(first);
break;
case ARRAY_TYPE:
addExpr(first,NodeUtil.precedence(Token.ARRAY_TYPE),context);
add(""String_Node_Str"");
break;
case FUNCTION_TYPE:
Node returnType=first;
add(""String_Node_Str"");
addList(first.getNext());
add(""String_Node_Str"");
cc.addOp(""String_Node_Str"",true);
add(returnType);
break;
case UNION_TYPE:
addList(first,""String_Node_Str"");
break;
case RECORD_TYPE:
add(""String_Node_Str"");
addList(first,false,Context.OTHER,""String_Node_Str"");
add(""String_Node_Str"");
break;
case PARAMETERIZED_TYPE:
add(first);
add(""String_Node_Str"");
addList(first.getNext());
add(""String_Node_Str"");
break;
case GENERIC_TYPE_LIST:
add(""String_Node_Str"");
addList(first,false,Context.STATEMENT,""String_Node_Str"");
add(""String_Node_Str"");
break;
case GENERIC_TYPE:
addIdentifier(n.getString());
if (n.hasChildren()) {
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(n.getFirstChild());
}
break;
case INTERFACE:
{
Preconditions.checkState(childCount == 3);
Node name=first;
Node superTypes=first.getNext();
Node members=last;
add(""String_Node_Str"");
add(name);
maybeAddGenericTypes(name);
if (!superTypes.isEmpty()) {
add(""String_Node_Str"");
Node superType=superTypes.getFirstChild();
add(superType);
while ((superType=superType.getNext()) != null) {
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(superType);
}
}
add(members);
}
break;
case ENUM:
{
Preconditions.checkState(childCount == 2);
Node name=first;
Node members=last;
add(""String_Node_Str"");
add(name);
add(members);
break;
}
case NAMESPACE:
{
Preconditions.checkState(childCount == 2);
Node name=first;
Node elements=last;
add(""String_Node_Str"");
add(name);
add(elements);
break;
}
case TYPE_ALIAS:
add(""String_Node_Str"");
add(n.getString());
cc.addOp(""String_Node_Str"",true);
add(last);
cc.endStatement(true);
break;
case DECLARE:
add(""String_Node_Str"");
add(first);
processEnd(n,context);
break;
case INDEX_SIGNATURE:
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
maybeAddTypeDecl(n);
cc.endStatement(true);
break;
case CALL_SIGNATURE:
if (n.getBooleanProp(Node.CONSTRUCT_SIGNATURE)) {
add(""String_Node_Str"");
}
maybeAddGenericTypes(n);
add(first);
maybeAddTypeDecl(n);
cc.endStatement(true);
break;
default :
throw new RuntimeException(""String_Node_Str"" + type + ""String_Node_Str""+ n.toStringTree());
}
cc.endSourceMapping(n);
}","protected void add(Node n,Context context){
  if (!cc.continueProcessing()) {
    return;
  }
  if (preserveTypeAnnotations && n.getJSDocInfo() != null) {
    String jsdocAsString=jsDocInfoPrinter.print(n.getJSDocInfo());
    if (!jsdocAsString.equals(""String_Node_Str"")) {
      add(jsdocAsString);
    }
  }
  Token type=n.getToken();
  String opstr=NodeUtil.opToStr(type);
  int childCount=n.getChildCount();
  Node first=n.getFirstChild();
  Node last=n.getLastChild();
  if (opstr != null && first != last) {
    Preconditions.checkState(childCount == 2,""String_Node_Str"",opstr,childCount);
    int p=NodeUtil.precedence(type);
    Context rhsContext=getContextForNoInOperator(context);
    boolean needsParens=(context == Context.START_OF_EXPR) && first.isObjectPattern();
    if (n.isAssign() && needsParens) {
      add(""String_Node_Str"");
    }
    if (NodeUtil.isAssignmentOp(n) || type == Token.EXPONENT) {
      addExpr(first,p + 1,context);
      cc.addOp(opstr,true);
      addExpr(last,p,rhsContext);
    }
 else {
      unrollBinaryOperator(n,type,opstr,context,rhsContext,p,p + 1);
    }
    if (n.isAssign() && needsParens) {
      add(""String_Node_Str"");
    }
    return;
  }
  cc.startSourceMapping(n);
switch (type) {
case TRY:
{
      Preconditions.checkState(first.getNext().isBlock() && !first.getNext().hasMoreThanOneChild());
      Preconditions.checkState(childCount >= 2 && childCount <= 3);
      add(""String_Node_Str"");
      add(first,Context.PRESERVE_BLOCK);
      Node catchblock=first.getNext().getFirstChild();
      if (catchblock != null) {
        add(catchblock);
      }
      if (childCount == 3) {
        cc.maybeInsertSpace();
        add(""String_Node_Str"");
        add(last,Context.PRESERVE_BLOCK);
      }
      break;
    }
case CATCH:
  Preconditions.checkState(childCount == 2);
cc.maybeInsertSpace();
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
add(last,Context.PRESERVE_BLOCK);
break;
case THROW:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(first);
cc.endStatement(true);
break;
case RETURN:
add(""String_Node_Str"");
if (childCount == 1) {
cc.maybeInsertSpace();
add(first);
}
 else {
Preconditions.checkState(childCount == 0);
}
cc.endStatement();
break;
case VAR:
if (first != null) {
add(""String_Node_Str"");
addList(first,false,getContextForNoInOperator(context),""String_Node_Str"");
}
break;
case CONST:
add(""String_Node_Str"");
addList(first,false,getContextForNoInOperator(context),""String_Node_Str"");
break;
case LET:
add(""String_Node_Str"");
addList(first,false,getContextForNoInOperator(context),""String_Node_Str"");
break;
case LABEL_NAME:
Preconditions.checkState(!n.getString().isEmpty());
addIdentifier(n.getString());
break;
case DESTRUCTURING_LHS:
add(first);
if (first != last) {
Preconditions.checkState(childCount == 2);
cc.addOp(""String_Node_Str"",true);
add(last);
}
break;
case NAME:
if (useOriginalName && n.getOriginalName() != null) {
addIdentifier(n.getOriginalName());
}
 else {
addIdentifier(n.getString());
}
maybeAddOptional(n);
maybeAddTypeDecl(n);
if (first != null && !first.isEmpty()) {
Preconditions.checkState(childCount == 1);
cc.addOp(""String_Node_Str"",true);
if (first.isComma()) {
addExpr(first,NodeUtil.precedence(Token.ASSIGN),Context.OTHER);
}
 else {
addExpr(first,0,getContextForNoInOperator(context));
}
}
break;
case ARRAYLIT:
add(""String_Node_Str"");
addArrayList(first);
add(""String_Node_Str"");
break;
case ARRAY_PATTERN:
add(""String_Node_Str"");
addArrayList(first);
add(""String_Node_Str"");
maybeAddTypeDecl(n);
break;
case PARAM_LIST:
add(""String_Node_Str"");
addList(first);
add(""String_Node_Str"");
break;
case DEFAULT_VALUE:
add(first);
maybeAddTypeDecl(n);
cc.addOp(""String_Node_Str"",true);
add(first.getNext());
break;
case COMMA:
Preconditions.checkState(childCount == 2);
unrollBinaryOperator(n,Token.COMMA,""String_Node_Str"",context,getContextForNoInOperator(context),0,0);
break;
case NUMBER:
Preconditions.checkState(childCount == 0);
cc.addNumber(n.getDouble());
break;
case TYPEOF:
case VOID:
case NOT:
case BITNOT:
case POS:
{
Preconditions.checkState(childCount == 1);
cc.addOp(NodeUtil.opToStrNoFail(type),false);
addExpr(first,NodeUtil.precedence(type),Context.OTHER);
break;
}
case NEG:
{
Preconditions.checkState(childCount == 1);
if (n.getFirstChild().isNumber()) {
cc.addNumber(-n.getFirstChild().getDouble());
}
 else {
cc.addOp(NodeUtil.opToStrNoFail(type),false);
addExpr(first,NodeUtil.precedence(type),Context.OTHER);
}
break;
}
case HOOK:
{
Preconditions.checkState(childCount == 3);
int p=NodeUtil.precedence(type);
Context rhsContext=getContextForNoInOperator(context);
addExpr(first,p + 1,context);
cc.addOp(""String_Node_Str"",true);
addExpr(first.getNext(),1,rhsContext);
cc.addOp(""String_Node_Str"",true);
addExpr(last,1,rhsContext);
break;
}
case REGEXP:
if (!first.isString() || !last.isString()) {
throw new Error(""String_Node_Str"");
}
String regexp=regexpEscape(first.getString());
if (childCount == 2) {
add(regexp + last.getString());
}
 else {
Preconditions.checkState(childCount == 1);
add(regexp);
}
break;
case FUNCTION:
{
if (n.getClass() != Node.class) {
throw new Error(""String_Node_Str"");
}
Preconditions.checkState(childCount == 3);
if (n.isArrowFunction()) {
addArrowFunction(n,first,last,context);
}
 else {
addFunction(n,first,last,context);
}
break;
}
case REST:
add(""String_Node_Str"");
add(first);
maybeAddTypeDecl(n);
break;
case SPREAD:
add(""String_Node_Str"");
add(n.getFirstChild());
break;
case EXPORT:
add(""String_Node_Str"");
if (n.getBooleanProp(Node.EXPORT_DEFAULT)) {
add(""String_Node_Str"");
}
if (n.getBooleanProp(Node.EXPORT_ALL_FROM)) {
add(""String_Node_Str"");
Preconditions.checkState(first != null && first.isEmpty());
}
 else {
add(first);
}
if (childCount == 2) {
add(""String_Node_Str"");
add(last);
}
processEnd(first,context);
break;
case IMPORT:
add(""String_Node_Str"");
Node second=first.getNext();
if (!first.isEmpty()) {
add(first);
if (!second.isEmpty()) {
cc.listSeparator();
}
}
if (!second.isEmpty()) {
add(second);
}
if (!first.isEmpty() || !second.isEmpty()) {
add(""String_Node_Str"");
}
add(last);
cc.endStatement();
break;
case EXPORT_SPECS:
case IMPORT_SPECS:
add(""String_Node_Str"");
for (Node c=first; c != null; c=c.getNext()) {
if (c != first) {
cc.listSeparator();
}
add(c);
}
add(""String_Node_Str"");
break;
case EXPORT_SPEC:
case IMPORT_SPEC:
add(first);
if (first != last) {
add(""String_Node_Str"");
add(last);
}
break;
case IMPORT_STAR:
add(""String_Node_Str"");
add(""String_Node_Str"");
add(n.getString());
break;
case CLASS:
{
Preconditions.checkState(childCount == 3);
boolean classNeedsParens=(context == Context.START_OF_EXPR);
if (classNeedsParens) {
add(""String_Node_Str"");
}
Node name=first;
Node superClass=first.getNext();
Node members=last;
add(""String_Node_Str"");
if (!name.isEmpty()) {
add(name);
}
maybeAddGenericTypes(first);
if (!superClass.isEmpty()) {
add(""String_Node_Str"");
add(superClass);
}
Node interfaces=(Node)n.getProp(Node.IMPLEMENTS);
if (interfaces != null) {
add(""String_Node_Str"");
Node child=interfaces.getFirstChild();
add(child);
while ((child=child.getNext()) != null) {
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(child);
}
}
add(members);
cc.endClass(context == Context.STATEMENT);
if (classNeedsParens) {
add(""String_Node_Str"");
}
}
break;
case CLASS_MEMBERS:
case INTERFACE_MEMBERS:
case NAMESPACE_ELEMENTS:
cc.beginBlock();
for (Node c=first; c != null; c=c.getNext()) {
add(c);
processEnd(c,context);
cc.endLine();
}
cc.endBlock(false);
break;
case ENUM_MEMBERS:
cc.beginBlock();
for (Node c=first; c != null; c=c.getNext()) {
add(c);
if (c.getNext() != null) {
add(""String_Node_Str"");
}
cc.endLine();
}
cc.endBlock(false);
break;
case GETTER_DEF:
case SETTER_DEF:
case MEMBER_FUNCTION_DEF:
case MEMBER_VARIABLE_DEF:
{
n.getParent().toStringTree();
Preconditions.checkState(n.getParent().isObjectLit() || n.getParent().isClassMembers() || n.getParent().isInterfaceMembers()|| n.getParent().isRecordType()|| n.getParent().isIndexSignature());
maybeAddAccessibilityModifier(n);
if (n.isStaticMember()) {
add(""String_Node_Str"");
}
if (!n.isMemberVariableDef() && n.getFirstChild().isGeneratorFunction()) {
Preconditions.checkState(type == Token.MEMBER_FUNCTION_DEF);
add(""String_Node_Str"");
}
if (n.isMemberFunctionDef() && n.getFirstChild().isAsyncFunction()) {
add(""String_Node_Str"");
}
switch (type) {
case GETTER_DEF:
Preconditions.checkState(!first.getSecondChild().hasChildren());
add(""String_Node_Str"");
break;
case SETTER_DEF:
Preconditions.checkState(first.getSecondChild().hasOneChild());
add(""String_Node_Str"");
break;
case MEMBER_FUNCTION_DEF:
case MEMBER_VARIABLE_DEF:
break;
default :
break;
}
String name=n.getString();
if (n.isMemberVariableDef()) {
add(n.getString());
maybeAddOptional(n);
maybeAddTypeDecl(n);
}
 else {
Preconditions.checkState(childCount == 1);
Preconditions.checkState(first.isFunction());
Preconditions.checkState(first.getFirstChild().getString().isEmpty());
Node fn=first;
Node parameters=fn.getSecondChild();
Node body=fn.getLastChild();
if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) && NodeUtil.isLatin(name)) {
add(name);
maybeAddGenericTypes(fn.getFirstChild());
}
 else {
double d=getSimpleNumber(name);
if (!Double.isNaN(d)) {
cc.addNumber(d);
}
 else {
addJsString(n);
}
}
maybeAddOptional(fn);
add(parameters);
maybeAddTypeDecl(fn);
add(body,Context.PRESERVE_BLOCK);
}
break;
}
case SCRIPT:
case MODULE_BODY:
case BLOCK:
{
if (n.getClass() != Node.class) {
throw new Error(""String_Node_Str"");
}
boolean preserveBlock=context == Context.PRESERVE_BLOCK;
if (preserveBlock) {
cc.beginBlock();
}
boolean preferLineBreaks=type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().isScript());
for (Node c=first; c != null; c=c.getNext()) {
add(c,Context.STATEMENT);
if (NodeUtil.isNameDeclaration(c)) {
cc.endStatement();
}
if (c.isFunction() || c.isClass()) {
cc.maybeLineBreak();
}
if (preferLineBreaks) {
cc.notePreferredLineBreak();
}
}
if (preserveBlock) {
cc.endBlock(cc.breakAfterBlockFor(n,context == Context.STATEMENT));
}
break;
}
case FOR:
if (childCount == 4) {
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
if (NodeUtil.isNameDeclaration(first)) {
add(first,Context.IN_FOR_INIT_CLAUSE);
}
 else {
addExpr(first,0,Context.IN_FOR_INIT_CLAUSE);
}
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
add(first.getNext().getNext());
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
}
 else {
Preconditions.checkState(childCount == 3);
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
}
break;
case FOR_OF:
Preconditions.checkState(childCount == 3);
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
break;
case DO:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
addNonEmptyStatement(first,Context.OTHER,false);
cc.maybeInsertSpace();
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(last);
add(""String_Node_Str"");
cc.endStatement();
break;
case WHILE:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
break;
case EMPTY:
Preconditions.checkState(childCount == 0);
break;
case GETPROP:
{
if (useOriginalName && n.getOriginalName() != null) {
if (n.getFirstChild().matchesQualifiedName(""String_Node_Str"") && n.getParent().isAssign()) {
add(""String_Node_Str"");
}
addIdentifier(n.getOriginalName());
break;
}
Preconditions.checkState(childCount == 2,""String_Node_Str"",childCount);
Preconditions.checkState(last.isString(),""String_Node_Str"");
boolean needsParens=(first.isNumber());
if (needsParens) {
add(""String_Node_Str"");
}
addExpr(first,NodeUtil.precedence(type),context);
if (needsParens) {
add(""String_Node_Str"");
}
if (quoteKeywordProperties && TokenStream.isKeyword(last.getString())) {
add(""String_Node_Str"");
add(last);
add(""String_Node_Str"");
}
 else {
add(""String_Node_Str"");
addIdentifier(last.getString());
}
break;
}
case GETELEM:
Preconditions.checkState(childCount == 2,""String_Node_Str"",childCount,n);
addExpr(first,NodeUtil.precedence(type),context);
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
break;
case WITH:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
break;
case INC:
case DEC:
{
Preconditions.checkState(childCount == 1);
String o=type == Token.INC ? ""String_Node_Str"" : ""String_Node_Str"";
boolean postProp=n.getBooleanProp(Node.INCRDECR_PROP);
if (postProp) {
addExpr(first,NodeUtil.precedence(type),context);
cc.addOp(o,false);
}
 else {
cc.addOp(o,false);
add(first);
}
break;
}
case CALL:
if (isIndirectEval(first) || (n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first))) {
add(""String_Node_Str"");
addExpr(first,NodeUtil.precedence(Token.COMMA),Context.OTHER);
add(""String_Node_Str"");
}
 else {
addExpr(first,NodeUtil.precedence(type),context);
}
Node args=first.getNext();
add(""String_Node_Str"");
addList(args);
add(""String_Node_Str"");
break;
case IF:
boolean hasElse=childCount == 3;
boolean ambiguousElseClause=context == Context.BEFORE_DANGLING_ELSE && !hasElse;
if (ambiguousElseClause) {
cc.beginBlock();
}
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
if (childCount == 1) {
break;
}
if (hasElse) {
addNonEmptyStatement(first.getNext(),Context.BEFORE_DANGLING_ELSE,false);
cc.maybeInsertSpace();
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
}
 else {
addNonEmptyStatement(first.getNext(),Context.OTHER,false);
Preconditions.checkState(childCount == 2);
}
if (ambiguousElseClause) {
cc.endBlock();
}
break;
case NULL:
Preconditions.checkState(childCount == 0);
cc.addConstant(""String_Node_Str"");
break;
case THIS:
Preconditions.checkState(childCount == 0);
add(""String_Node_Str"");
break;
case SUPER:
Preconditions.checkState(childCount == 0);
add(""String_Node_Str"");
break;
case NEW_TARGET:
Preconditions.checkState(childCount == 0);
add(""String_Node_Str"");
break;
case YIELD:
add(""String_Node_Str"");
if (n.isYieldFor()) {
Preconditions.checkNotNull(first);
add(""String_Node_Str"");
}
if (first != null) {
cc.maybeInsertSpace();
addExpr(first,NodeUtil.precedence(type),Context.OTHER);
}
break;
case AWAIT:
add(""String_Node_Str"");
addExpr(first,NodeUtil.precedence(type),Context.OTHER);
break;
case FALSE:
Preconditions.checkState(childCount == 0);
cc.addConstant(""String_Node_Str"");
break;
case TRUE:
Preconditions.checkState(childCount == 0);
cc.addConstant(""String_Node_Str"");
break;
case CONTINUE:
Preconditions.checkState(childCount <= 1);
add(""String_Node_Str"");
if (childCount == 1) {
if (!first.isLabelName()) {
throw new Error(""String_Node_Str"");
}
add(""String_Node_Str"");
add(first);
}
cc.endStatement();
break;
case DEBUGGER:
Preconditions.checkState(childCount == 0);
add(""String_Node_Str"");
cc.endStatement();
break;
case BREAK:
Preconditions.checkState(childCount <= 1);
add(""String_Node_Str"");
if (childCount == 1) {
if (!first.isLabelName()) {
throw new Error(""String_Node_Str"");
}
add(""String_Node_Str"");
add(first);
}
cc.endStatement();
break;
case EXPR_RESULT:
Preconditions.checkState(childCount == 1);
add(first,Context.START_OF_EXPR);
cc.endStatement();
break;
case NEW:
add(""String_Node_Str"");
int precedence=NodeUtil.precedence(type);
if (NodeUtil.containsType(first,Token.CALL,NodeUtil.MATCH_NOT_FUNCTION)) {
precedence=NodeUtil.precedence(first.getToken()) + 1;
}
addExpr(first,precedence,Context.OTHER);
Node next=first.getNext();
if (next != null) {
add(""String_Node_Str"");
addList(next);
add(""String_Node_Str"");
}
break;
case STRING_KEY:
addStringKey(n);
break;
case STRING:
Preconditions.checkState(childCount == 0,""String_Node_Str"");
addJsString(n);
break;
case DELPROP:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
add(first);
break;
case OBJECTLIT:
{
boolean needsParens=(context == Context.START_OF_EXPR);
if (needsParens) {
add(""String_Node_Str"");
}
add(""String_Node_Str"");
for (Node c=first; c != null; c=c.getNext()) {
if (c != first) {
cc.listSeparator();
}
Preconditions.checkState(c.isComputedProp() || c.isGetterDef() || c.isSetterDef()|| c.isStringKey()|| c.isMemberFunctionDef());
add(c);
}
add(""String_Node_Str"");
if (needsParens) {
add(""String_Node_Str"");
}
break;
}
case COMPUTED_PROP:
maybeAddAccessibilityModifier(n);
if (n.getBooleanProp(Node.STATIC_MEMBER)) {
add(""String_Node_Str"");
}
if (n.getBooleanProp(Node.COMPUTED_PROP_GETTER)) {
add(""String_Node_Str"");
}
 else if (n.getBooleanProp(Node.COMPUTED_PROP_SETTER)) {
add(""String_Node_Str"");
}
 else if (last.getBooleanProp(Node.GENERATOR_FN)) {
add(""String_Node_Str"");
}
 else if (last.isAsyncFunction()) {
add(""String_Node_Str"");
}
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
maybeAddTypeDecl(n);
if (n.getBooleanProp(Node.COMPUTED_PROP_METHOD) || n.getBooleanProp(Node.COMPUTED_PROP_GETTER) || n.getBooleanProp(Node.COMPUTED_PROP_SETTER)) {
Node function=first.getNext();
Node params=function.getSecondChild();
Node body=function.getLastChild();
add(params);
add(body,Context.PRESERVE_BLOCK);
}
 else {
boolean isInClass=n.getParent().getToken() == Token.CLASS_MEMBERS;
Node initializer=first.getNext();
if (initializer != null) {
Preconditions.checkState(!isInClass,""String_Node_Str"");
cc.addOp(""String_Node_Str"",false);
add(initializer);
}
 else {
Preconditions.checkState(n.getBooleanProp(Node.COMPUTED_PROP_VARIABLE),n);
}
}
break;
case OBJECT_PATTERN:
addObjectPattern(n);
maybeAddTypeDecl(n);
break;
case SWITCH:
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
cc.beginBlock();
addAllSiblings(first.getNext());
cc.endBlock(context == Context.STATEMENT);
break;
case CASE:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
add(first);
addCaseBody(last);
break;
case DEFAULT_CASE:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
addCaseBody(first);
break;
case LABEL:
Preconditions.checkState(childCount == 2);
if (!first.isLabelName()) {
throw new Error(""String_Node_Str"");
}
add(first);
add(""String_Node_Str"");
if (!last.isBlock()) {
cc.maybeInsertSpace();
}
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),true);
break;
case CAST:
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
break;
case TAGGED_TEMPLATELIT:
add(first,Context.START_OF_EXPR);
add(first.getNext());
break;
case TEMPLATELIT:
add(""String_Node_Str"");
for (Node c=first; c != null; c=c.getNext()) {
if (c.isString()) {
add(strEscape(c.getString(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",false,false));
}
 else {
cc.append(""String_Node_Str"");
add(c.getFirstChild(),Context.START_OF_EXPR);
add(""String_Node_Str"");
}
}
add(""String_Node_Str"");
break;
case STRING_TYPE:
add(""String_Node_Str"");
break;
case BOOLEAN_TYPE:
add(""String_Node_Str"");
break;
case NUMBER_TYPE:
add(""String_Node_Str"");
break;
case ANY_TYPE:
add(""String_Node_Str"");
break;
case VOID_TYPE:
add(""String_Node_Str"");
break;
case NAMED_TYPE:
add(first);
break;
case ARRAY_TYPE:
addExpr(first,NodeUtil.precedence(Token.ARRAY_TYPE),context);
add(""String_Node_Str"");
break;
case FUNCTION_TYPE:
Node returnType=first;
add(""String_Node_Str"");
addList(first.getNext());
add(""String_Node_Str"");
cc.addOp(""String_Node_Str"",true);
add(returnType);
break;
case UNION_TYPE:
addList(first,""String_Node_Str"");
break;
case RECORD_TYPE:
add(""String_Node_Str"");
addList(first,false,Context.OTHER,""String_Node_Str"");
add(""String_Node_Str"");
break;
case PARAMETERIZED_TYPE:
add(first);
add(""String_Node_Str"");
addList(first.getNext());
add(""String_Node_Str"");
break;
case GENERIC_TYPE_LIST:
add(""String_Node_Str"");
addList(first,false,Context.STATEMENT,""String_Node_Str"");
add(""String_Node_Str"");
break;
case GENERIC_TYPE:
addIdentifier(n.getString());
if (n.hasChildren()) {
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(n.getFirstChild());
}
break;
case INTERFACE:
{
Preconditions.checkState(childCount == 3);
Node name=first;
Node superTypes=first.getNext();
Node members=last;
add(""String_Node_Str"");
add(name);
maybeAddGenericTypes(name);
if (!superTypes.isEmpty()) {
add(""String_Node_Str"");
Node superType=superTypes.getFirstChild();
add(superType);
while ((superType=superType.getNext()) != null) {
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(superType);
}
}
add(members);
}
break;
case ENUM:
{
Preconditions.checkState(childCount == 2);
Node name=first;
Node members=last;
add(""String_Node_Str"");
add(name);
add(members);
break;
}
case NAMESPACE:
{
Preconditions.checkState(childCount == 2);
Node name=first;
Node elements=last;
add(""String_Node_Str"");
add(name);
add(elements);
break;
}
case TYPE_ALIAS:
add(""String_Node_Str"");
add(n.getString());
cc.addOp(""String_Node_Str"",true);
add(last);
cc.endStatement(true);
break;
case DECLARE:
add(""String_Node_Str"");
add(first);
processEnd(n,context);
break;
case INDEX_SIGNATURE:
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
maybeAddTypeDecl(n);
cc.endStatement(true);
break;
case CALL_SIGNATURE:
if (n.getBooleanProp(Node.CONSTRUCT_SIGNATURE)) {
add(""String_Node_Str"");
}
maybeAddGenericTypes(n);
add(first);
maybeAddTypeDecl(n);
cc.endStatement(true);
break;
default :
throw new RuntimeException(""String_Node_Str"" + type + ""String_Node_Str""+ n.toStringTree());
}
cc.endSourceMapping(n);
}",0.9949213030746704
19414,"protected CodeGenerator(CodeConsumer consumer,CompilerOptions options){
  cc=consumer;
  this.outputCharsetEncoder=new OutputCharsetEncoder(options.getOutputCharset());
  this.preferSingleQuotes=options.preferSingleQuotes;
  this.trustedStrings=options.trustedStrings;
  this.preserveTypeAnnotations=options.preserveTypeAnnotations;
  this.quoteKeywordProperties=options.quoteKeywordProperties;
  this.outputAsExterns=options.shouldGenerateTypedExterns();
  this.useOriginalName=options.getUseOriginalNamesInOutput();
}","protected CodeGenerator(CodeConsumer consumer,CompilerOptions options){
  cc=consumer;
  this.outputCharsetEncoder=new OutputCharsetEncoder(options.getOutputCharset());
  this.preferSingleQuotes=options.preferSingleQuotes;
  this.trustedStrings=options.trustedStrings;
  this.preserveTypeAnnotations=options.preserveTypeAnnotations;
  this.quoteKeywordProperties=options.quoteKeywordProperties;
  this.outputAsExterns=options.shouldGenerateTypedExterns();
  this.useOriginalName=options.getUseOriginalNamesInOutput();
  this.jsDocInfoPrinter=new JSDocInfoPrinter(useOriginalName);
}",0.9427792915531336
19415,"private static String buildAnnotationWithType(String annotation,Node type){
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"");
  sb.append(annotation);
  sb.append(""String_Node_Str"");
  appendTypeNode(sb,type);
  sb.append(""String_Node_Str"");
  return sb.toString();
}","private String buildAnnotationWithType(String annotation,Node type){
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"");
  sb.append(annotation);
  sb.append(""String_Node_Str"");
  appendTypeNode(sb,type);
  sb.append(""String_Node_Str"");
  return sb.toString();
}",0.9877408056042032
19416,"private static String typeNode(Node typeNode){
  StringBuilder sb=new StringBuilder();
  appendTypeNode(sb,typeNode);
  return sb.toString();
}","private String typeNode(Node typeNode){
  StringBuilder sb=new StringBuilder();
  appendTypeNode(sb,typeNode);
  return sb.toString();
}",0.974910394265233
19417,"public static String print(JSDocInfo info){
  boolean multiline=false;
  List<String> parts=new ArrayList<>();
  parts.add(""String_Node_Str"");
  if (info.isExport()) {
    parts.add(""String_Node_Str"");
  }
 else   if (info.getVisibility() != null && info.getVisibility() != Visibility.INHERITED) {
    parts.add(""String_Node_Str"" + info.getVisibility().toString().toLowerCase());
  }
  if (info.isConstant() && !info.isDefine() && !info.isFinal()) {
    parts.add(""String_Node_Str"");
  }
  if (info.isFinal()) {
    parts.add(""String_Node_Str"");
  }
  if (info.makesDicts()) {
    parts.add(""String_Node_Str"");
  }
  if (info.makesStructs()) {
    parts.add(""String_Node_Str"");
  }
  if (info.makesUnrestricted()) {
    parts.add(""String_Node_Str"");
  }
  if (info.isConstructor()) {
    parts.add(""String_Node_Str"");
  }
  if (info.isInterface() && !info.usesImplicitMatch()) {
    parts.add(""String_Node_Str"");
  }
  if (info.isInterface() && info.usesImplicitMatch()) {
    parts.add(""String_Node_Str"");
  }
  if (info.hasBaseType()) {
    multiline=true;
    Node typeNode=stripBang(info.getBaseType().getRoot());
    parts.add(buildAnnotationWithType(""String_Node_Str"",typeNode));
  }
  for (  JSTypeExpression type : info.getExtendedInterfaces()) {
    multiline=true;
    Node typeNode=stripBang(type.getRoot());
    parts.add(buildAnnotationWithType(""String_Node_Str"",typeNode));
  }
  for (  JSTypeExpression type : info.getImplementedInterfaces()) {
    multiline=true;
    Node typeNode=stripBang(type.getRoot());
    parts.add(buildAnnotationWithType(""String_Node_Str"",typeNode));
  }
  if (info.hasThisType()) {
    multiline=true;
    Node typeNode=stripBang(info.getThisType().getRoot());
    parts.add(buildAnnotationWithType(""String_Node_Str"",typeNode));
  }
  if (info.getParameterCount() > 0) {
    multiline=true;
    for (    String name : info.getParameterNames()) {
      parts.add(""String_Node_Str"" + buildParamType(name,info.getParameterType(name)));
    }
  }
  if (info.hasReturnType()) {
    multiline=true;
    parts.add(buildAnnotationWithType(""String_Node_Str"",info.getReturnType()));
  }
  if (!info.getThrownTypes().isEmpty()) {
    parts.add(buildAnnotationWithType(""String_Node_Str"",info.getThrownTypes().get(0)));
  }
  ImmutableList<String> names=info.getTemplateTypeNames();
  if (!names.isEmpty()) {
    parts.add(""String_Node_Str"" + Joiner.on(',').join(names));
    multiline=true;
  }
  if (info.isOverride()) {
    parts.add(""String_Node_Str"");
  }
  if (info.hasType() && !info.isDefine()) {
    if (info.isInlineType()) {
      parts.add(typeNode(info.getType().getRoot()));
    }
 else {
      parts.add(buildAnnotationWithType(""String_Node_Str"",info.getType()));
    }
  }
  if (info.isDefine()) {
    parts.add(buildAnnotationWithType(""String_Node_Str"",info.getType()));
  }
  if (info.hasTypedefType()) {
    parts.add(buildAnnotationWithType(""String_Node_Str"",info.getTypedefType()));
  }
  if (info.hasEnumParameterType()) {
    parts.add(buildAnnotationWithType(""String_Node_Str"",info.getEnumParameterType()));
  }
  Set<String> suppressions=info.getSuppressions();
  if (!suppressions.isEmpty()) {
    String[] arr=suppressions.toArray(new String[0]);
    Arrays.sort(arr,Ordering.<String>natural());
    parts.add(""String_Node_Str"" + Joiner.on(',').join(arr) + ""String_Node_Str"");
    multiline=true;
  }
  if (info.isDeprecated()) {
    parts.add(""String_Node_Str"" + info.getDeprecationReason());
    multiline=true;
  }
  parts.add(""String_Node_Str"");
  StringBuilder sb=new StringBuilder();
  if (multiline) {
    Joiner.on(""String_Node_Str"").appendTo(sb,parts);
  }
 else {
    Joiner.on(""String_Node_Str"").appendTo(sb,parts);
  }
  sb.append((multiline) ? ""String_Node_Str"" : ""String_Node_Str"");
  return sb.toString();
}","public String print(JSDocInfo info){
  boolean multiline=false;
  List<String> parts=new ArrayList<>();
  parts.add(""String_Node_Str"");
  if (info.isExport()) {
    parts.add(""String_Node_Str"");
  }
 else   if (info.getVisibility() != null && info.getVisibility() != Visibility.INHERITED) {
    parts.add(""String_Node_Str"" + info.getVisibility().toString().toLowerCase());
  }
  if (info.isConstant() && !info.isDefine() && !info.isFinal()) {
    parts.add(""String_Node_Str"");
  }
  if (info.isFinal()) {
    parts.add(""String_Node_Str"");
  }
  if (info.makesDicts()) {
    parts.add(""String_Node_Str"");
  }
  if (info.makesStructs()) {
    parts.add(""String_Node_Str"");
  }
  if (info.makesUnrestricted()) {
    parts.add(""String_Node_Str"");
  }
  if (info.isConstructor()) {
    parts.add(""String_Node_Str"");
  }
  if (info.isInterface() && !info.usesImplicitMatch()) {
    parts.add(""String_Node_Str"");
  }
  if (info.isInterface() && info.usesImplicitMatch()) {
    parts.add(""String_Node_Str"");
  }
  if (info.hasBaseType()) {
    multiline=true;
    Node typeNode=stripBang(info.getBaseType().getRoot());
    parts.add(buildAnnotationWithType(""String_Node_Str"",typeNode));
  }
  for (  JSTypeExpression type : info.getExtendedInterfaces()) {
    multiline=true;
    Node typeNode=stripBang(type.getRoot());
    parts.add(buildAnnotationWithType(""String_Node_Str"",typeNode));
  }
  for (  JSTypeExpression type : info.getImplementedInterfaces()) {
    multiline=true;
    Node typeNode=stripBang(type.getRoot());
    parts.add(buildAnnotationWithType(""String_Node_Str"",typeNode));
  }
  if (info.hasThisType()) {
    multiline=true;
    Node typeNode=stripBang(info.getThisType().getRoot());
    parts.add(buildAnnotationWithType(""String_Node_Str"",typeNode));
  }
  if (info.getParameterCount() > 0) {
    multiline=true;
    for (    String name : info.getParameterNames()) {
      parts.add(""String_Node_Str"" + buildParamType(name,info.getParameterType(name)));
    }
  }
  if (info.hasReturnType()) {
    multiline=true;
    parts.add(buildAnnotationWithType(""String_Node_Str"",info.getReturnType()));
  }
  if (!info.getThrownTypes().isEmpty()) {
    parts.add(buildAnnotationWithType(""String_Node_Str"",info.getThrownTypes().get(0)));
  }
  ImmutableList<String> names=info.getTemplateTypeNames();
  if (!names.isEmpty()) {
    parts.add(""String_Node_Str"" + Joiner.on(',').join(names));
    multiline=true;
  }
  if (info.isOverride()) {
    parts.add(""String_Node_Str"");
  }
  if (info.hasType() && !info.isDefine()) {
    if (info.isInlineType()) {
      parts.add(typeNode(info.getType().getRoot()));
    }
 else {
      parts.add(buildAnnotationWithType(""String_Node_Str"",info.getType()));
    }
  }
  if (info.isDefine()) {
    parts.add(buildAnnotationWithType(""String_Node_Str"",info.getType()));
  }
  if (info.hasTypedefType()) {
    parts.add(buildAnnotationWithType(""String_Node_Str"",info.getTypedefType()));
  }
  if (info.hasEnumParameterType()) {
    parts.add(buildAnnotationWithType(""String_Node_Str"",info.getEnumParameterType()));
  }
  Set<String> suppressions=info.getSuppressions();
  if (!suppressions.isEmpty()) {
    String[] arr=suppressions.toArray(new String[0]);
    Arrays.sort(arr,Ordering.<String>natural());
    parts.add(""String_Node_Str"" + Joiner.on(',').join(arr) + ""String_Node_Str"");
    multiline=true;
  }
  if (info.isDeprecated()) {
    parts.add(""String_Node_Str"" + info.getDeprecationReason());
    multiline=true;
  }
  parts.add(""String_Node_Str"");
  StringBuilder sb=new StringBuilder();
  if (multiline) {
    Joiner.on(""String_Node_Str"").appendTo(sb,parts);
  }
 else {
    Joiner.on(""String_Node_Str"").appendTo(sb,parts);
  }
  sb.append((multiline) ? ""String_Node_Str"" : ""String_Node_Str"");
  return sb.toString();
}",0.9990729704674878
19418,"private static Node stripBang(Node typeNode){
  if (typeNode.getToken() == Token.BANG) {
    typeNode=typeNode.getFirstChild();
  }
  return typeNode;
}","private Node stripBang(Node typeNode){
  if (typeNode.getToken() == Token.BANG) {
    typeNode=typeNode.getFirstChild();
  }
  return typeNode;
}",0.9764309764309764
19419,"private static String buildParamType(String name,JSTypeExpression type){
  if (type != null) {
    return ""String_Node_Str"" + typeNode(type.getRoot()) + ""String_Node_Str""+ name;
  }
 else {
    return name;
  }
}","private String buildParamType(String name,JSTypeExpression type){
  if (type != null) {
    return ""String_Node_Str"" + typeNode(type.getRoot()) + ""String_Node_Str""+ name;
  }
 else {
    return name;
  }
}",0.9832134292565948
19420,"private static void appendFunctionNode(StringBuilder sb,Node function){
  boolean hasNewOrThis=false;
  sb.append(""String_Node_Str"");
  Node first=function.getFirstChild();
  if (first.isNew()) {
    sb.append(""String_Node_Str"");
    appendTypeNode(sb,first.getFirstChild());
    hasNewOrThis=true;
  }
 else   if (first.isThis()) {
    sb.append(""String_Node_Str"");
    appendTypeNode(sb,first.getFirstChild());
    hasNewOrThis=true;
  }
 else   if (first.isEmpty()) {
    sb.append(""String_Node_Str"");
    return;
  }
 else   if (!first.isParamList()) {
    sb.append(""String_Node_Str"");
    appendTypeNode(sb,first);
    return;
  }
  Node paramList=null;
  if (first.isParamList()) {
    paramList=first;
  }
 else   if (first.getNext().isParamList()) {
    paramList=first.getNext();
  }
  if (paramList != null) {
    boolean firstParam=true;
    for (    Node param : paramList.children()) {
      if (!firstParam || hasNewOrThis) {
        sb.append(""String_Node_Str"");
      }
      appendTypeNode(sb,param);
      firstParam=false;
    }
  }
  sb.append(""String_Node_Str"");
  Node returnType=function.getLastChild();
  if (!returnType.isEmpty()) {
    sb.append(""String_Node_Str"");
    appendTypeNode(sb,returnType);
  }
}","private void appendFunctionNode(StringBuilder sb,Node function){
  boolean hasNewOrThis=false;
  sb.append(""String_Node_Str"");
  Node first=function.getFirstChild();
  if (first.isNew()) {
    sb.append(""String_Node_Str"");
    appendTypeNode(sb,first.getFirstChild());
    hasNewOrThis=true;
  }
 else   if (first.isThis()) {
    sb.append(""String_Node_Str"");
    appendTypeNode(sb,first.getFirstChild());
    hasNewOrThis=true;
  }
 else   if (first.isEmpty()) {
    sb.append(""String_Node_Str"");
    return;
  }
 else   if (!first.isParamList()) {
    sb.append(""String_Node_Str"");
    appendTypeNode(sb,first);
    return;
  }
  Node paramList=null;
  if (first.isParamList()) {
    paramList=first;
  }
 else   if (first.getNext().isParamList()) {
    paramList=first.getNext();
  }
  if (paramList != null) {
    boolean firstParam=true;
    for (    Node param : paramList.children()) {
      if (!firstParam || hasNewOrThis) {
        sb.append(""String_Node_Str"");
      }
      appendTypeNode(sb,param);
      firstParam=false;
    }
  }
  sb.append(""String_Node_Str"");
  Node returnType=function.getLastChild();
  if (!returnType.isEmpty()) {
    sb.append(""String_Node_Str"");
    appendTypeNode(sb,returnType);
  }
}",0.9971533143554292
19421,"private static void appendTypeNode(StringBuilder sb,Node typeNode){
  if (typeNode.getToken() == Token.BANG) {
    sb.append(""String_Node_Str"");
    appendTypeNode(sb,typeNode.getFirstChild());
  }
 else   if (typeNode.getToken() == Token.EQUALS) {
    appendTypeNode(sb,typeNode.getFirstChild());
    sb.append(""String_Node_Str"");
  }
 else   if (typeNode.getToken() == Token.PIPE) {
    sb.append(""String_Node_Str"");
    for (int i=0; i < typeNode.getChildCount() - 1; i++) {
      appendTypeNode(sb,typeNode.getChildAtIndex(i));
      sb.append(""String_Node_Str"");
    }
    appendTypeNode(sb,typeNode.getLastChild());
    sb.append(""String_Node_Str"");
  }
 else   if (typeNode.getToken() == Token.ELLIPSIS) {
    sb.append(""String_Node_Str"");
    if (typeNode.hasChildren() && !typeNode.getFirstChild().isEmpty()) {
      appendTypeNode(sb,typeNode.getFirstChild());
    }
  }
 else   if (typeNode.getToken() == Token.STAR) {
    sb.append(""String_Node_Str"");
  }
 else   if (typeNode.getToken() == Token.QMARK) {
    sb.append(""String_Node_Str"");
    if (typeNode.hasChildren()) {
      appendTypeNode(sb,typeNode.getFirstChild());
    }
  }
 else   if (typeNode.isFunction()) {
    appendFunctionNode(sb,typeNode);
  }
 else   if (typeNode.getToken() == Token.LC) {
    sb.append(""String_Node_Str"");
    Node lb=typeNode.getFirstChild();
    for (int i=0; i < lb.getChildCount() - 1; i++) {
      Node colon=lb.getChildAtIndex(i);
      if (colon.hasChildren()) {
        sb.append(colon.getFirstChild().getString()).append(""String_Node_Str"");
        appendTypeNode(sb,colon.getLastChild());
      }
 else {
        sb.append(colon.getString());
      }
      sb.append(""String_Node_Str"");
    }
    Node lastColon=lb.getLastChild();
    if (lastColon.hasChildren()) {
      sb.append(lastColon.getFirstChild().getString()).append(""String_Node_Str"");
      appendTypeNode(sb,lastColon.getLastChild());
    }
 else {
      sb.append(lastColon.getString());
    }
    sb.append(""String_Node_Str"");
  }
 else   if (typeNode.getToken() == Token.VOID) {
    sb.append(""String_Node_Str"");
  }
 else {
    if (typeNode.hasChildren()) {
      sb.append(typeNode.getString()).append(""String_Node_Str"");
      Node child=typeNode.getFirstChild();
      appendTypeNode(sb,child.getFirstChild());
      for (int i=1; i < child.getChildCount(); i++) {
        sb.append(""String_Node_Str"");
        appendTypeNode(sb,child.getChildAtIndex(i));
      }
      sb.append(""String_Node_Str"");
    }
 else {
      sb.append(typeNode.getString());
    }
  }
}","private void appendTypeNode(StringBuilder sb,Node typeNode){
  if (useOriginalName && typeNode.getOriginalName() != null) {
    sb.append(typeNode.getOriginalName());
    return;
  }
  if (typeNode.getToken() == Token.BANG) {
    sb.append(""String_Node_Str"");
    appendTypeNode(sb,typeNode.getFirstChild());
  }
 else   if (typeNode.getToken() == Token.EQUALS) {
    appendTypeNode(sb,typeNode.getFirstChild());
    sb.append(""String_Node_Str"");
  }
 else   if (typeNode.getToken() == Token.PIPE) {
    sb.append(""String_Node_Str"");
    for (int i=0; i < typeNode.getChildCount() - 1; i++) {
      appendTypeNode(sb,typeNode.getChildAtIndex(i));
      sb.append(""String_Node_Str"");
    }
    appendTypeNode(sb,typeNode.getLastChild());
    sb.append(""String_Node_Str"");
  }
 else   if (typeNode.getToken() == Token.ELLIPSIS) {
    sb.append(""String_Node_Str"");
    if (typeNode.hasChildren() && !typeNode.getFirstChild().isEmpty()) {
      appendTypeNode(sb,typeNode.getFirstChild());
    }
  }
 else   if (typeNode.getToken() == Token.STAR) {
    sb.append(""String_Node_Str"");
  }
 else   if (typeNode.getToken() == Token.QMARK) {
    sb.append(""String_Node_Str"");
    if (typeNode.hasChildren()) {
      appendTypeNode(sb,typeNode.getFirstChild());
    }
  }
 else   if (typeNode.isFunction()) {
    appendFunctionNode(sb,typeNode);
  }
 else   if (typeNode.getToken() == Token.LC) {
    sb.append(""String_Node_Str"");
    Node lb=typeNode.getFirstChild();
    for (int i=0; i < lb.getChildCount() - 1; i++) {
      Node colon=lb.getChildAtIndex(i);
      if (colon.hasChildren()) {
        sb.append(colon.getFirstChild().getString()).append(""String_Node_Str"");
        appendTypeNode(sb,colon.getLastChild());
      }
 else {
        sb.append(colon.getString());
      }
      sb.append(""String_Node_Str"");
    }
    Node lastColon=lb.getLastChild();
    if (lastColon.hasChildren()) {
      sb.append(lastColon.getFirstChild().getString()).append(""String_Node_Str"");
      appendTypeNode(sb,lastColon.getLastChild());
    }
 else {
      sb.append(lastColon.getString());
    }
    sb.append(""String_Node_Str"");
  }
 else   if (typeNode.getToken() == Token.VOID) {
    sb.append(""String_Node_Str"");
  }
 else {
    if (typeNode.hasChildren()) {
      sb.append(typeNode.getString()).append(""String_Node_Str"");
      Node child=typeNode.getFirstChild();
      appendTypeNode(sb,child.getFirstChild());
      for (int i=1; i < child.getChildCount(); i++) {
        sb.append(""String_Node_Str"");
        appendTypeNode(sb,child.getChildAtIndex(i));
      }
      sb.append(""String_Node_Str"");
    }
 else {
      sb.append(typeNode.getString());
    }
  }
}",0.9752161383285304
19422,"private void fixTypeNode(Node typeNode){
  if (typeNode.isString()) {
    String name=typeNode.getString();
    int endIndex=name.indexOf('.');
    if (endIndex == -1) {
      endIndex=name.length();
    }
    String baseName=name.substring(0,endIndex);
    Var aliasVar=aliases.get(baseName);
    if (aliasVar != null) {
      aliasUsages.add(new AliasedTypeNode(aliasVar,typeNode));
    }
  }
  for (Node child=typeNode.getFirstChild(); child != null; child=child.getNext()) {
    fixTypeNode(child);
  }
}","private void fixTypeNode(Node typeNode){
  if (typeNode.isString()) {
    String name=typeNode.getString();
    int endIndex=name.indexOf('.');
    if (endIndex == -1) {
      endIndex=name.length();
    }
    String baseName=name.substring(0,endIndex);
    Var aliasVar=aliases.get(baseName);
    if (aliasVar != null) {
      aliasUsages.add(new AliasedTypeNode(aliasVar,typeNode));
    }
    if (compiler.getOptions().preservesDetailedSourceInfo()) {
      typeNode.setOriginalName(name);
    }
  }
  for (Node child=typeNode.getFirstChild(); child != null; child=child.getNext()) {
    fixTypeNode(child);
  }
}",0.904719501335708
19423,"@Override public void visit(NodeTraversal t,Node n,Node parent){
  if (isCallToScopeMethod(n)) {
    validateScopeCall(t,n,n.getParent());
  }
  if (!inGoogScopeBody()) {
    return;
  }
  Token type=n.getToken();
  boolean isObjLitShorthand=type == Token.STRING_KEY && !n.hasChildren();
  Var aliasVar=null;
  if (type == Token.NAME || isObjLitShorthand) {
    String name=n.getString();
    Var lexicalVar=t.getScope().getVar(name);
    if (lexicalVar != null && lexicalVar == aliases.get(name)) {
      aliasVar=lexicalVar;
    }
  }
  if (isGoogScopeFunctionBody(t.getEnclosingFunction().getLastChild())) {
    if (aliasVar != null && !isObjLitShorthand && NodeUtil.isLValue(n)) {
      if (aliasVar.getNode() == n) {
        aliasDefinitionsInOrder.add(n);
        return;
      }
 else {
        report(t,n,GOOG_SCOPE_ALIAS_REDEFINED,n.getString());
      }
    }
    if (type == Token.RETURN) {
      report(t,n,GOOG_SCOPE_USES_RETURN);
    }
 else     if (type == Token.THIS) {
      report(t,n,GOOG_SCOPE_REFERENCES_THIS);
    }
 else     if (type == Token.THROW) {
      report(t,n,GOOG_SCOPE_USES_THROW);
    }
  }
  if (inGoogScopeBody()) {
    if (aliasVar != null) {
      aliasUsages.add(new AliasedNode(aliasVar,n));
    }
    JSDocInfo info=n.getJSDocInfo();
    if (info != null && !injectedDecls.contains(n)) {
      for (      Node node : info.getTypeNodes()) {
        fixTypeNode(node);
      }
    }
  }
}","@Override public void visit(NodeTraversal t,Node n,Node parent){
  if (isCallToScopeMethod(n)) {
    validateScopeCall(t,n,n.getParent());
  }
  if (!inGoogScopeBody()) {
    return;
  }
  Token type=n.getToken();
  boolean isObjLitShorthand=type == Token.STRING_KEY && !n.hasChildren();
  Var aliasVar=null;
  if (type == Token.NAME || isObjLitShorthand) {
    String name=n.getString();
    Var lexicalVar=t.getScope().getVar(name);
    if (lexicalVar != null && lexicalVar == aliases.get(name)) {
      aliasVar=lexicalVar;
      if (compiler.getOptions().preservesDetailedSourceInfo() && n.isName()) {
        n.setOriginalName(name);
      }
    }
  }
  if (isGoogScopeFunctionBody(t.getEnclosingFunction().getLastChild())) {
    if (aliasVar != null && !isObjLitShorthand && NodeUtil.isLValue(n)) {
      if (aliasVar.getNode() == n) {
        aliasDefinitionsInOrder.add(n);
        return;
      }
 else {
        report(t,n,GOOG_SCOPE_ALIAS_REDEFINED,n.getString());
      }
    }
    if (type == Token.RETURN) {
      report(t,n,GOOG_SCOPE_USES_RETURN);
    }
 else     if (type == Token.THIS) {
      report(t,n,GOOG_SCOPE_REFERENCES_THIS);
    }
 else     if (type == Token.THROW) {
      report(t,n,GOOG_SCOPE_USES_THROW);
    }
  }
  if (inGoogScopeBody()) {
    if (aliasVar != null) {
      aliasUsages.add(new AliasedNode(aliasVar,n));
    }
    JSDocInfo info=n.getJSDocInfo();
    if (info != null && !injectedDecls.contains(n)) {
      for (      Node node : info.getTypeNodes()) {
        fixTypeNode(node);
      }
    }
  }
}",0.9596774193548387
19424,"@Override protected void add(Node n,Context context){
  Node parent=n.getParent();
  if (parent != null && (parent.isBlock() || parent.isScript())) {
    if (n.isFunction()) {
      add(getFunctionAnnotation(n));
    }
 else     if (n.isExprResult() && n.getFirstChild().isAssign()) {
      Node assign=n.getFirstChild();
      if (NodeUtil.isNamespaceDecl(assign.getFirstChild())) {
        add(JSDocInfoPrinter.print(assign.getJSDocInfo()));
      }
 else {
        Node rhs=assign.getLastChild();
        add(getTypeAnnotation(rhs));
      }
    }
 else     if (n.isVar() && n.getFirstFirstChild() != null) {
      if (NodeUtil.isNamespaceDecl(n.getFirstChild())) {
        add(JSDocInfoPrinter.print(n.getJSDocInfo()));
      }
 else {
        add(getTypeAnnotation(n.getFirstFirstChild()));
      }
    }
  }
  super.add(n,context);
}","@Override protected void add(Node n,Context context){
  Node parent=n.getParent();
  if (parent != null && (parent.isBlock() || parent.isScript())) {
    if (n.isFunction()) {
      add(getFunctionAnnotation(n));
    }
 else     if (n.isExprResult() && n.getFirstChild().isAssign()) {
      Node assign=n.getFirstChild();
      if (NodeUtil.isNamespaceDecl(assign.getFirstChild())) {
        add(jsDocInfoPrinter.print(assign.getJSDocInfo()));
      }
 else {
        Node rhs=assign.getLastChild();
        add(getTypeAnnotation(rhs));
      }
    }
 else     if (n.isVar() && n.getFirstFirstChild() != null) {
      if (NodeUtil.isNamespaceDecl(n.getFirstChild())) {
        add(jsDocInfoPrinter.print(n.getJSDocInfo()));
      }
 else {
        add(getTypeAnnotation(n.getFirstFirstChild()));
      }
    }
  }
  super.add(n,context);
}",0.5768772348033373
19425,"TypedCodeGenerator(CodeConsumer consumer,CompilerOptions options,TypeIRegistry registry){
  super(consumer,options);
  Preconditions.checkNotNull(registry);
  this.registry=registry;
}","TypedCodeGenerator(CodeConsumer consumer,CompilerOptions options,TypeIRegistry registry){
  super(consumer,options);
  Preconditions.checkNotNull(registry);
  this.registry=registry;
  this.jsDocInfoPrinter=new JSDocInfoPrinter(options.getUseOriginalNamesInOutput());
}",0.8123620309050773
19426,"@Override public boolean isUnresolved(){
  return isUnknown();
}","@Override public boolean isUnresolved(){
  return false;
}",0.8852459016393442
19427,"public void testCustomBanUnresolvedType(){
  configuration=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  this.mode=TypeInferenceMode.OTI_ONLY;
  testSame(EXTERNS,""String_Node_Str"" + ""String_Node_Str"",CheckConformance.CONFORMANCE_VIOLATION,""String_Node_Str"");
}","public void testCustomBanUnresolvedType(){
  configuration=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  this.mode=TypeInferenceMode.OTI_ONLY;
  testSame(EXTERNS,""String_Node_Str"" + ""String_Node_Str"",CheckConformance.CONFORMANCE_VIOLATION,""String_Node_Str"");
  this.mode=TypeInferenceMode.BOTH;
  testSame(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.7815230961298377
19428,"/** 
 * Creates a SuggestedFix for the given error. Note that some errors have multiple fixes so getFixesForJsError should often be used instead of this.
 */
public static SuggestedFix getFixForJsError(JSError error,AbstractCompiler compiler){
switch (error.getType().key) {
case ""String_Node_Str"":
    return getFixForMissingSemicolon(error,compiler);
case ""String_Node_Str"":
  return getFixForUnsortedRequiresOrProvides(""String_Node_Str"",error,compiler);
case ""String_Node_Str"":
return getFixForUnsortedRequiresOrProvides(""String_Node_Str"",error,compiler);
case ""String_Node_Str"":
case ""String_Node_Str"":
return removeNode(error,compiler);
case ""String_Node_Str"":
return getFixForInexistentProperty(error,compiler);
case ""String_Node_Str"":
return getFixForMissingSuper(error,compiler);
case ""String_Node_Str"":
return getFixForInvalidSuper(error,compiler);
case ""String_Node_Str"":
case ""String_Node_Str"":
return getFixForMissingRequire(error,compiler);
case ""String_Node_Str"":
return getFixForExtraRequire(error,compiler,DUPLICATE_REQUIRE);
case ""String_Node_Str"":
return getFixForExtraRequire(error,compiler,EXTRA_REQUIRE);
default :
return null;
}
}","/** 
 * Creates a SuggestedFix for the given error. Note that some errors have multiple fixes so getFixesForJsError should often be used instead of this.
 */
public static SuggestedFix getFixForJsError(JSError error,AbstractCompiler compiler){
switch (error.getType().key) {
case ""String_Node_Str"":
    return getFixForMissingSemicolon(error,compiler);
case ""String_Node_Str"":
  return getFixForUnsortedRequiresOrProvides(""String_Node_Str"",error,compiler);
case ""String_Node_Str"":
return getFixForUnsortedRequiresOrProvides(""String_Node_Str"",error,compiler);
case ""String_Node_Str"":
case ""String_Node_Str"":
return removeNode(error,compiler);
case ""String_Node_Str"":
return getFixForInexistentProperty(error,compiler);
case ""String_Node_Str"":
return getFixForMissingSuper(error,compiler);
case ""String_Node_Str"":
return getFixForInvalidSuper(error,compiler);
case ""String_Node_Str"":
case ""String_Node_Str"":
return getFixForMissingRequire(error,compiler);
case ""String_Node_Str"":
return getFixForExtraRequire(error,compiler,DUPLICATE_REQUIRE);
case ""String_Node_Str"":
return getFixForExtraRequire(error,compiler,EXTRA_REQUIRE);
case ""String_Node_Str"":
return getFixForReferenceToShortImportByLongName(error,compiler);
default :
return null;
}
}",0.946532999164578
19429,"@Override public void visit(NodeTraversal t,Node n,Node parent){
switch (n.getType()) {
case FUNCTION:
    Node grandparent=parent.getParent();
  if (grandparent == null || (!isPrototypePropertyDeclaration(grandparent) && !isClassPropertyDeclaration(parent.getFirstChild(),currentScope))) {
    RawNominalType ownerType=maybeGetOwnerType(n,parent);
    visitFunctionLate(n,ownerType);
  }
break;
case NAME:
{
String name=n.getString();
if (name == null || parent.isFunction()) {
  return;
}
if (parent.isVar() || parent.isCatch()) {
  visitVar(n,parent);
}
 else if (currentScope.isOuterVarEarly(name)) {
  currentScope.addOuterVar(name);
}
 else if (currentScope.getTypedef(name) != null || !name.equals(currentScope.getName()) && !currentScope.isDefinedLocally(name,false)) {
}
break;
}
case GETPROP:
if (NodeUtil.isPropertyTest(compiler,n) || isPropertyAbsentTest(n)) {
allPropertyNames.add(n.getLastChild().getString());
}
if (parent.isExprResult() && n.isQualifiedName()) {
visitPropertyDeclaration(n);
}
break;
case ASSIGN:
{
Node lvalue=n.getFirstChild();
if (lvalue.isGetProp() && lvalue.isQualifiedName() && parent.isExprResult()) {
visitPropertyDeclaration(lvalue);
}
break;
}
case CAST:
castTypes.put(n,getDeclaredTypeOfNode(n.getJSDocInfo(),currentScope));
break;
case OBJECTLIT:
visitObjectLit(n,parent);
break;
case CALL:
visitCall(n);
break;
default :
break;
}
}","@Override public void visit(NodeTraversal t,Node n,Node parent){
switch (n.getType()) {
case FUNCTION:
    Node grandparent=parent.getParent();
  if (grandparent == null || (!isPrototypePropertyDeclaration(grandparent) && !isClassPropertyDeclaration(parent.getFirstChild(),currentScope))) {
    RawNominalType ownerType=maybeGetOwnerType(n,parent);
    visitFunctionLate(n,ownerType);
  }
break;
case NAME:
{
String name=n.getString();
if (name == null || parent.isFunction()) {
  return;
}
if (parent.isVar() || parent.isCatch()) {
  visitVar(n,parent);
}
 else if (currentScope.isOuterVarEarly(name)) {
  currentScope.addOuterVar(name);
}
 else if (currentScope.getTypedef(name) != null || !name.equals(currentScope.getName()) && !currentScope.isDefinedLocally(name,false)) {
}
break;
}
case GETPROP:
if (NodeUtil.isPropertyTest(compiler,n) || isPropertyAbsentTest(n)) {
allPropertyNames.add(n.getLastChild().getString());
}
if (parent.isExprResult() && n.isQualifiedName()) {
visitPropertyDeclaration(n);
}
break;
case ASSIGN:
{
Node lvalue=n.getFirstChild();
if (lvalue.isGetProp() && lvalue.isQualifiedName()) {
visitPropertyDeclaration(lvalue);
}
break;
}
case CAST:
castTypes.put(n,getDeclaredTypeOfNode(n.getJSDocInfo(),currentScope));
break;
case OBJECTLIT:
visitObjectLit(n,parent);
break;
case CALL:
visitCall(n);
break;
default :
break;
}
}",0.9908391352143644
19430,"boolean isPropDefinedOnSubtype(QualifiedName pname){
  Preconditions.checkArgument(pname.isIdentifier());
  return this.rawType.isPropDefinedOnSubtype(this,pname);
}","boolean isPropDefinedOnSubtype(QualifiedName pname){
  Preconditions.checkArgument(pname.isIdentifier());
  return this.rawType.isPropDefinedOnSubtype(pname.getLeftmostName());
}",0.932944606413994
19431,"boolean isPropDefinedOnSubtype(QualifiedName pname){
  Preconditions.checkArgument(pname.isIdentifier());
  NominalType nt=getNominalType();
  Preconditions.checkState(!nt.isBuiltinObject());
  return nt.isPropDefinedOnSubtype(pname);
}","boolean isPropDefinedOnSubtype(QualifiedName pname){
  Preconditions.checkArgument(pname.isIdentifier());
  NominalType nt=getNominalType();
  return nt.isBuiltinObject() ? false : nt.isPropDefinedOnSubtype(pname);
}",0.6637168141592921
19432,"/** 
 * @return Whether the superclass can be added without creating a cycle. 
 */
public boolean addSuperClass(NominalType superclass){
  Preconditions.checkState(!this.isFinalized);
  Preconditions.checkState(this.superclass == null);
  if (superclass.hasAncestorClass(this)) {
    return false;
  }
  this.superclass=superclass;
  addSubtypeTo(superclass,this);
  return true;
}","/** 
 * @return Whether the superclass can be added without creating a cycle. 
 */
public boolean addSuperClass(NominalType superclass){
  Preconditions.checkState(!this.isFinalized);
  Preconditions.checkState(this.superclass == null);
  if (superclass.hasAncestorClass(this)) {
    return false;
  }
  this.superclass=superclass;
  superclass.getRawNominalType().addSubtype(this);
  return true;
}",0.941025641025641
19433,"/** 
 * @return Whether the interface can be added without creating a cycle. 
 */
public boolean addInterfaces(ImmutableSet<NominalType> interfaces){
  Preconditions.checkState(!this.isFinalized);
  Preconditions.checkState(this.interfaces == null);
  Preconditions.checkNotNull(interfaces);
  if (this.isInterface()) {
    for (    NominalType interf : interfaces) {
      if (interf.hasAncestorInterface(this)) {
        this.interfaces=ImmutableSet.of();
        return false;
      }
    }
  }
  for (  NominalType interf : interfaces) {
    if (interf.getRawNominalType().inheritsFromIObjectReflexive()) {
      this.objectKind=ObjectKind.UNRESTRICTED;
    }
    addSubtypeTo(interf,this);
  }
  this.interfaces=interfaces;
  return true;
}","/** 
 * @return Whether the interface can be added without creating a cycle. 
 */
public boolean addInterfaces(ImmutableSet<NominalType> interfaces){
  Preconditions.checkState(!this.isFinalized);
  Preconditions.checkState(this.interfaces == null);
  Preconditions.checkNotNull(interfaces);
  if (this.isInterface()) {
    for (    NominalType interf : interfaces) {
      if (interf.hasAncestorInterface(this)) {
        this.interfaces=ImmutableSet.of();
        return false;
      }
    }
  }
  for (  NominalType interf : interfaces) {
    if (interf.getRawNominalType().inheritsFromIObjectReflexive()) {
      this.objectKind=ObjectKind.UNRESTRICTED;
    }
    interf.getRawNominalType().addSubtype(this);
  }
  this.interfaces=interfaces;
  return true;
}",0.9655172413793104
19434,"boolean isPropDefinedOnSubtype(NominalType thisAsNominal,QualifiedName qname){
  Preconditions.checkArgument(qname.isIdentifier());
  String pname=qname.getLeftmostName();
  for (  RawNominalType subtype : this.subtypes.get(thisAsNominal)) {
    if (subtype.mayHaveProp(pname)) {
      return true;
    }
  }
  return false;
}","boolean isPropDefinedOnSubtype(String pname){
  if (mayHaveProp(pname)) {
    return true;
  }
  for (  RawNominalType subtype : this.subtypes) {
    if (subtype.isPropDefinedOnSubtype(pname)) {
      return true;
    }
  }
  return false;
}",0.1798941798941798
19435,"public void testPropertyCheckingCompatibility(){
  compilerOptions.setWarningLevel(DiagnosticGroups.NEW_CHECK_TYPES_EXTRA_CHECKS,CheckLevel.OFF);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INEXISTENT_PROPERTY);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testPropertyCheckingCompatibility(){
  compilerOptions.setWarningLevel(DiagnosticGroups.NEW_CHECK_TYPES_EXTRA_CHECKS,CheckLevel.OFF);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INEXISTENT_PROPERTY);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INEXISTENT_PROPERTY);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.7586007516623302
19436,"/** 
 * Returns whether two nodes are equivalent, taking into account the template parameters that were provided to this matcher. If the template comparison node is a parameter node, then only the types of the node must match. Otherwise, the node must be equal and the child nodes must be equivalent according to the same function. This differs from the built in Node equivalence function with the special comparison.
 */
private boolean matchesNode(Node template,Node ast){
  if (isTemplateParameterNode(template)) {
    int paramIndex=(int)(template.getDouble());
    Node previousMatch=paramNodeMatches.get(paramIndex);
    if (previousMatch != null) {
      return ast.isEquivalentTo(previousMatch);
    }
    JSType templateType=template.getJSType();
    Preconditions.checkNotNull(templateType,""String_Node_Str"");
    if (templateType.isNoResolvedType()) {
      return false;
    }
    MatchResult matchResult=typeMatchingStrategy.match(templateType,ast.getJSType());
    isLooseMatch=matchResult.isLooseMatch();
    boolean isMatch=matchResult.isMatch();
    if (isMatch && previousMatch == null) {
      paramNodeMatches.set(paramIndex,ast);
    }
    return isMatch;
  }
 else   if (isTemplateLocalNameNode(template)) {
    int paramIndex=(int)(template.getDouble());
    boolean previouslyMatched=this.localVarMatches.get(paramIndex) != null;
    if (previouslyMatched) {
      return ast.getString().equals(this.localVarMatches.get(paramIndex));
    }
 else {
      this.localVarMatches.set(paramIndex,ast.getString());
    }
  }
  Node templateChild=template.getFirstChild();
  Node astChild=ast.getFirstChild();
  while (templateChild != null) {
    if (!matchesNode(templateChild,astChild)) {
      return false;
    }
    templateChild=templateChild.getNext();
    astChild=astChild.getNext();
  }
  return true;
}","/** 
 * Returns whether two nodes are equivalent, taking into account the template parameters that were provided to this matcher. If the template comparison node is a parameter node, then only the types of the node must match. Otherwise, the node must be equal and the child nodes must be equivalent according to the same function. This differs from the built in Node equivalence function with the special comparison.
 */
private boolean matchesNode(Node template,Node ast){
  if (isTemplateParameterNode(template)) {
    int paramIndex=(int)(template.getDouble());
    Node previousMatch=paramNodeMatches.get(paramIndex);
    if (previousMatch != null) {
      return ast.isEquivalentTo(previousMatch);
    }
    JSType templateType=template.getJSType();
    Preconditions.checkNotNull(templateType,""String_Node_Str"");
    if (isUnresolvedType(templateType)) {
      return false;
    }
    MatchResult matchResult=typeMatchingStrategy.match(templateType,ast.getJSType());
    isLooseMatch=matchResult.isLooseMatch();
    boolean isMatch=matchResult.isMatch();
    if (isMatch && previousMatch == null) {
      paramNodeMatches.set(paramIndex,ast);
    }
    return isMatch;
  }
 else   if (isTemplateLocalNameNode(template)) {
    int paramIndex=(int)(template.getDouble());
    boolean previouslyMatched=this.localVarMatches.get(paramIndex) != null;
    if (previouslyMatched) {
      return ast.getString().equals(this.localVarMatches.get(paramIndex));
    }
 else {
      this.localVarMatches.set(paramIndex,ast.getString());
    }
  }
  Node templateChild=template.getFirstChild();
  Node astChild=ast.getFirstChild();
  while (templateChild != null) {
    if (!matchesNode(templateChild,astChild)) {
      return false;
    }
    templateChild=templateChild.getNext();
    astChild=astChild.getNext();
  }
  return true;
}",0.9882481552336704
19437,"@Override protected List<PassFactory> getOptimizations(){
  List<PassFactory> passes=new ArrayList<>();
  if (options.skipNonTranspilationPasses) {
    return passes;
  }
  passes.add(gatherExternProperties);
  passes.add(garbageCollectChecks);
  if (options.instrumentForCoverage) {
    passes.add(instrumentForCodeCoverage);
  }
  if (options.runtimeTypeCheck) {
    passes.add(runtimeTypeCheck);
  }
  if (options.j2clPassMode.shouldAddJ2clPasses()) {
    passes.add(j2clPass);
    passes.add(j2clPropertyInlinerPass);
  }
  passes.add(createEmptyPass(""String_Node_Str""));
  if (options.replaceIdGenerators) {
    passes.add(replaceIdGenerators);
  }
  if (options.optimizeArgumentsArray) {
    passes.add(optimizeArgumentsArray);
  }
  if (options.closurePass && (options.removeAbstractMethods || options.removeClosureAsserts)) {
    passes.add(closureCodeRemoval);
  }
  if (options.disambiguatePrivateProperties) {
    passes.add(disambiguatePrivateProperties);
  }
  if (options.collapseProperties) {
    passes.add(collapseProperties);
  }
  if (options.inferConsts) {
    passes.add(inferConsts);
  }
  if (options.reportPath != null && options.smartNameRemoval) {
    passes.add(initNameAnalyzeReport);
  }
  if (options.extraSmartNameRemoval && options.smartNameRemoval) {
    if (options.foldConstants && (options.inlineVariables || options.inlineLocalVariables)) {
      passes.add(earlyInlineVariables);
      passes.add(earlyPeepholeOptimizations);
    }
    passes.add(extraSmartNamePass);
  }
  if (options.rewritePolyfills) {
    passes.add(removeUnusedPolyfills);
  }
  if (options.shouldDisambiguateProperties()) {
    passes.add(disambiguateProperties);
  }
  if (options.computeFunctionSideEffects) {
    passes.add(markPureFunctions);
  }
 else   if (options.markNoSideEffectCalls) {
    passes.add(markNoSideEffectCalls);
  }
  if (options.chainCalls) {
    passes.add(chainCalls);
  }
  passes.add(checkConstParams);
  assertAllOneTimePasses(passes);
  if (options.smartNameRemoval || options.reportPath != null) {
    passes.addAll(getCodeRemovingPasses());
    passes.add(smartNamePass);
  }
  if (options.closurePass) {
    passes.add(closureOptimizePrimitives);
  }
  if (!options.replaceStringsFunctionDescriptions.isEmpty()) {
    passes.add(replaceStrings);
  }
  if (options.crossModuleCodeMotion) {
    passes.add(crossModuleCodeMotion);
  }
  if (options.devirtualizePrototypeMethods) {
    passes.add(devirtualizePrototypeMethods);
  }
  if (options.customPasses != null) {
    passes.add(getCustomPasses(CustomPassExecutionTime.BEFORE_OPTIMIZATION_LOOP));
  }
  passes.add(createEmptyPass(""String_Node_Str""));
  if (options.inlineVariables || options.inlineLocalVariables) {
    passes.add(flowSensitiveInlineVariables);
  }
  passes.addAll(getMainOptimizationLoop());
  passes.add(createEmptyPass(""String_Node_Str""));
  passes.add(createEmptyPass(""String_Node_Str""));
  if (options.crossModuleCodeMotion) {
    passes.add(crossModuleCodeMotion);
  }
  if (options.crossModuleMethodMotion) {
    passes.add(crossModuleMethodMotion);
  }
  passes.add(createEmptyPass(""String_Node_Str""));
  if (options.customPasses != null) {
    passes.add(getCustomPasses(CustomPassExecutionTime.AFTER_OPTIMIZATION_LOOP));
  }
  if (options.inlineVariables || options.inlineLocalVariables) {
    passes.add(flowSensitiveInlineVariables);
    if (options.removeUnusedVars || options.removeUnusedLocalVars) {
      passes.add(getRemoveUnusedVars(""String_Node_Str"",false));
    }
  }
  if (options.smartNameRemoval) {
    passes.add(smartNamePass2);
  }
  if (options.collapseAnonymousFunctions) {
    passes.add(collapseAnonymousFunctions);
  }
  if (options.moveFunctionDeclarations || options.renamePrefixNamespace != null) {
    passes.add(moveFunctionDeclarations);
  }
  if (options.anonymousFunctionNaming == AnonymousFunctionNamingPolicy.MAPPED) {
    passes.add(nameMappedAnonymousFunctions);
  }
  if (options.extractPrototypeMemberDeclarations != ExtractPrototypeMemberDeclarationsMode.OFF) {
    passes.add(extractPrototypeMemberDeclarations);
  }
  if (options.shouldAmbiguateProperties() && (options.propertyRenaming == PropertyRenamingPolicy.ALL_UNQUOTED)) {
    passes.add(ambiguateProperties);
  }
  if (options.propertyRenaming == PropertyRenamingPolicy.ALL_UNQUOTED) {
    passes.add(renameProperties);
  }
  if (options.reserveRawExports) {
    passes.add(gatherRawExports);
  }
  if (options.convertToDottedProperties) {
    passes.add(convertToDottedProperties);
  }
  if (options.rewriteFunctionExpressions) {
    passes.add(rewriteFunctionExpressions);
  }
  if (!options.aliasableStrings.isEmpty() || options.aliasAllStrings) {
    passes.add(aliasStrings);
  }
  passes.add(markUnnormalized);
  if (options.coalesceVariableNames) {
    passes.add(coalesceVariableNames);
    if (options.foldConstants) {
      passes.add(peepholeOptimizations);
    }
  }
  if (options.collapseVariableDeclarations) {
    passes.add(exploitAssign);
    passes.add(collapseVariableDeclarations);
  }
  passes.add(denormalize);
  if (options.instrumentationTemplate != null) {
    passes.add(instrumentFunctions);
  }
  if (options.variableRenaming != VariableRenamingPolicy.ALL) {
    passes.add(invertContextualRenaming);
  }
  if (options.variableRenaming != VariableRenamingPolicy.OFF) {
    passes.add(renameVars);
  }
  if (options.processObjectPropertyString) {
    passes.add(objectPropertyStringPostprocess);
  }
  if (options.labelRenaming) {
    passes.add(renameLabels);
  }
  if (options.foldConstants) {
    passes.add(latePeepholeOptimizations);
  }
  if (options.anonymousFunctionNaming == AnonymousFunctionNamingPolicy.UNMAPPED) {
    passes.add(nameUnmappedAnonymousFunctions);
  }
  if (protectHiddenSideEffects) {
    passes.add(stripSideEffectProtection);
  }
  if (options.renamePrefixNamespace != null) {
    if (!GLOBAL_SYMBOL_NAMESPACE_PATTERN.matcher(options.renamePrefixNamespace).matches()) {
      throw new IllegalArgumentException(""String_Node_Str"" + options.renamePrefixNamespace);
    }
    passes.add(rescopeGlobalSymbols);
  }
  passes.add(sanityCheckAst);
  passes.add(sanityCheckVars);
  if (options.getLanguageOut().isEs6OrHigher()) {
    passes.add(optimizeToEs6);
    passes.add(rewriteBindThis);
  }
  return passes;
}","@Override protected List<PassFactory> getOptimizations(){
  List<PassFactory> passes=new ArrayList<>();
  if (options.skipNonTranspilationPasses) {
    return passes;
  }
  passes.add(gatherExternProperties);
  passes.add(garbageCollectChecks);
  if (options.instrumentForCoverage) {
    passes.add(instrumentForCodeCoverage);
  }
  if (options.runtimeTypeCheck) {
    passes.add(runtimeTypeCheck);
  }
  if (options.j2clPassMode.shouldAddJ2clPasses()) {
    passes.add(j2clPass);
    passes.add(j2clPropertyInlinerPass);
  }
  passes.add(createEmptyPass(""String_Node_Str""));
  if (options.replaceIdGenerators) {
    passes.add(replaceIdGenerators);
  }
  if (options.optimizeArgumentsArray) {
    passes.add(optimizeArgumentsArray);
  }
  if (options.closurePass && (options.removeAbstractMethods || options.removeClosureAsserts)) {
    passes.add(closureCodeRemoval);
  }
  if (options.disambiguatePrivateProperties) {
    passes.add(disambiguatePrivateProperties);
  }
  if (options.collapseProperties) {
    passes.add(collapseProperties);
  }
  if (options.inferConsts) {
    passes.add(inferConsts);
  }
  if (options.reportPath != null && options.smartNameRemoval) {
    passes.add(initNameAnalyzeReport);
  }
  if (options.extraSmartNameRemoval && options.smartNameRemoval) {
    if (options.foldConstants && (options.inlineVariables || options.inlineLocalVariables)) {
      passes.add(earlyInlineVariables);
      passes.add(earlyPeepholeOptimizations);
    }
    passes.add(extraSmartNamePass);
  }
  if (options.shouldDisambiguateProperties()) {
    passes.add(disambiguateProperties);
  }
  if (options.computeFunctionSideEffects) {
    passes.add(markPureFunctions);
  }
 else   if (options.markNoSideEffectCalls) {
    passes.add(markNoSideEffectCalls);
  }
  if (options.chainCalls) {
    passes.add(chainCalls);
  }
  passes.add(checkConstParams);
  assertAllOneTimePasses(passes);
  if (options.smartNameRemoval || options.reportPath != null) {
    passes.addAll(getCodeRemovingPasses());
    passes.add(smartNamePass);
  }
  if (options.closurePass) {
    passes.add(closureOptimizePrimitives);
  }
  if (!options.replaceStringsFunctionDescriptions.isEmpty()) {
    passes.add(replaceStrings);
  }
  if (options.crossModuleCodeMotion) {
    passes.add(crossModuleCodeMotion);
  }
  if (options.devirtualizePrototypeMethods) {
    passes.add(devirtualizePrototypeMethods);
  }
  if (options.customPasses != null) {
    passes.add(getCustomPasses(CustomPassExecutionTime.BEFORE_OPTIMIZATION_LOOP));
  }
  passes.add(createEmptyPass(""String_Node_Str""));
  if (options.inlineVariables || options.inlineLocalVariables) {
    passes.add(flowSensitiveInlineVariables);
  }
  passes.addAll(getMainOptimizationLoop());
  passes.add(createEmptyPass(""String_Node_Str""));
  passes.add(createEmptyPass(""String_Node_Str""));
  if (options.crossModuleCodeMotion) {
    passes.add(crossModuleCodeMotion);
  }
  if (options.crossModuleMethodMotion) {
    passes.add(crossModuleMethodMotion);
  }
  passes.add(createEmptyPass(""String_Node_Str""));
  if (options.customPasses != null) {
    passes.add(getCustomPasses(CustomPassExecutionTime.AFTER_OPTIMIZATION_LOOP));
  }
  if (options.inlineVariables || options.inlineLocalVariables) {
    passes.add(flowSensitiveInlineVariables);
    if (options.removeUnusedVars || options.removeUnusedLocalVars) {
      passes.add(getRemoveUnusedVars(""String_Node_Str"",false));
    }
  }
  if (options.smartNameRemoval) {
    passes.add(smartNamePass2);
  }
  if (options.collapseAnonymousFunctions) {
    passes.add(collapseAnonymousFunctions);
  }
  if (options.moveFunctionDeclarations || options.renamePrefixNamespace != null) {
    passes.add(moveFunctionDeclarations);
  }
  if (options.anonymousFunctionNaming == AnonymousFunctionNamingPolicy.MAPPED) {
    passes.add(nameMappedAnonymousFunctions);
  }
  if (options.extractPrototypeMemberDeclarations != ExtractPrototypeMemberDeclarationsMode.OFF) {
    passes.add(extractPrototypeMemberDeclarations);
  }
  if (options.shouldAmbiguateProperties() && (options.propertyRenaming == PropertyRenamingPolicy.ALL_UNQUOTED)) {
    passes.add(ambiguateProperties);
  }
  if (options.propertyRenaming == PropertyRenamingPolicy.ALL_UNQUOTED) {
    passes.add(renameProperties);
  }
  if (options.reserveRawExports) {
    passes.add(gatherRawExports);
  }
  if (options.convertToDottedProperties) {
    passes.add(convertToDottedProperties);
  }
  if (options.rewriteFunctionExpressions) {
    passes.add(rewriteFunctionExpressions);
  }
  if (!options.aliasableStrings.isEmpty() || options.aliasAllStrings) {
    passes.add(aliasStrings);
  }
  passes.add(markUnnormalized);
  if (options.coalesceVariableNames) {
    passes.add(coalesceVariableNames);
    if (options.foldConstants) {
      passes.add(peepholeOptimizations);
    }
  }
  if (options.collapseVariableDeclarations) {
    passes.add(exploitAssign);
    passes.add(collapseVariableDeclarations);
  }
  passes.add(denormalize);
  if (options.instrumentationTemplate != null) {
    passes.add(instrumentFunctions);
  }
  if (options.variableRenaming != VariableRenamingPolicy.ALL) {
    passes.add(invertContextualRenaming);
  }
  if (options.variableRenaming != VariableRenamingPolicy.OFF) {
    passes.add(renameVars);
  }
  if (options.processObjectPropertyString) {
    passes.add(objectPropertyStringPostprocess);
  }
  if (options.labelRenaming) {
    passes.add(renameLabels);
  }
  if (options.foldConstants) {
    passes.add(latePeepholeOptimizations);
  }
  if (options.anonymousFunctionNaming == AnonymousFunctionNamingPolicy.UNMAPPED) {
    passes.add(nameUnmappedAnonymousFunctions);
  }
  if (protectHiddenSideEffects) {
    passes.add(stripSideEffectProtection);
  }
  if (options.renamePrefixNamespace != null) {
    if (!GLOBAL_SYMBOL_NAMESPACE_PATTERN.matcher(options.renamePrefixNamespace).matches()) {
      throw new IllegalArgumentException(""String_Node_Str"" + options.renamePrefixNamespace);
    }
    passes.add(rescopeGlobalSymbols);
  }
  passes.add(sanityCheckAst);
  passes.add(sanityCheckVars);
  if (options.getLanguageOut().isEs6OrHigher()) {
    passes.add(optimizeToEs6);
    passes.add(rewriteBindThis);
  }
  return passes;
}",0.9938355616043552
19438,"void collectPropertyNames(Set<String> props){
  Set<PropertyMap> identitySet=Sets.newIdentityHashSet();
  collectPropertyNamesHelper(props,identitySet);
}","void collectPropertyNames(Set<String> props){
  props.addAll(properties.keySet());
  PropertyMap primaryParent=getPrimaryParent();
  if (primaryParent != null) {
    primaryParent.collectPropertyNames(props);
  }
  for (  PropertyMap p : getSecondaryParents()) {
    if (p != null) {
      p.collectPropertyNames(props);
    }
  }
}",0.2921810699588477
19439,"public void testInterfaceExtendsLoop2(){
  testClosureTypes(suppressMissingProperty(""String_Node_Str"") + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"");
}","public void testInterfaceExtendsLoop2(){
  testClosureTypesMultipleWarnings(suppressMissingProperty(""String_Node_Str"") + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",ImmutableList.of(""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""));
}",0.7096774193548387
19440,"void collectPropertyNames(Set<String> props){
  props.addAll(properties.keySet());
  PropertyMap primaryParent=getPrimaryParent();
  if (primaryParent != null) {
    primaryParent.collectPropertyNames(props);
  }
  for (  PropertyMap p : getSecondaryParents()) {
    if (p != null) {
      p.collectPropertyNames(props);
    }
  }
}","void collectPropertyNames(Set<String> props){
  Set<PropertyMap> identitySet=Sets.newIdentityHashSet();
  collectPropertyNamesHelper(props,identitySet);
}",0.4444444444444444
19441,"public void testInterfaceExtendsLoop2(){
  testClosureTypesMultipleWarnings(suppressMissingProperty(""String_Node_Str"") + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",ImmutableList.of(""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""));
}","public void testInterfaceExtendsLoop2(){
  testClosureTypes(suppressMissingProperty(""String_Node_Str"") + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"");
}",0.7459677419354839
19442,"@Override public void visit(NodeTraversal t,Node n,Node parent){
  if (n.isExprResult()) {
    Node expr=n.getFirstChild();
    Node name=expr.isAssign() ? expr.getFirstChild() : expr;
    if (!name.isGetProp() || !name.getFirstChild().isThis()) {
      return;
    }
    JSType type=name.getJSType();
    String pname=name.getLastChild().getString();
    JSDocInfo jsdoc=NodeUtil.getBestJSDocInfo(name);
    Node initializer=null;
    if (type == null) {
      initializer=NodeUtil.getRValueOfLValue(name).detachFromParent();
    }
 else     if (isInferrableConst(jsdoc,name)) {
      jsdoc=maybeUpdateJSDocInfoWithType(jsdoc,name);
    }
    Node newProtoAssignStmt=NodeUtil.newQNameDeclaration(compiler,className + ""String_Node_Str"" + pname,initializer,jsdoc);
    newProtoAssignStmt.useSourceInfoIfMissingFromForTree(expr);
    insertionPoint.getParent().addChildAfter(newProtoAssignStmt,insertionPoint);
    compiler.reportCodeChange();
  }
}","@Override public void visit(NodeTraversal t,Node n,Node parent){
  if (n.isExprResult()) {
    Node expr=n.getFirstChild();
    Node name=expr.isAssign() ? expr.getFirstChild() : expr;
    if (!name.isGetProp() || !name.getFirstChild().isThis()) {
      return;
    }
    String pname=name.getLastChild().getString();
    String fullyQualifiedName=className + ""String_Node_Str"" + pname;
    if (seenNames.contains(fullyQualifiedName)) {
      return;
    }
    JSType type=name.getJSType();
    JSDocInfo jsdoc=NodeUtil.getBestJSDocInfo(name);
    if (jsdoc == null) {
      jsdoc=getAllTypeJSDoc();
    }
 else     if (isInferrableConst(jsdoc,name)) {
      jsdoc=maybeUpdateJSDocInfoWithType(jsdoc,name);
      if (type == null) {
        compiler.report(JSError.make(name,CONSTANT_WITHOUT_EXPLICIT_TYPE));
        return;
      }
    }
    Node newProtoAssignStmt=NodeUtil.newQNameDeclaration(compiler,fullyQualifiedName,null,jsdoc);
    newProtoAssignStmt.useSourceInfoIfMissingFromForTree(expr);
    insertionPoint.getParent().addChildAfter(newProtoAssignStmt,insertionPoint);
    compiler.reportCodeChange();
    seenNames.add(fullyQualifiedName);
  }
}",0.7188983855650523
19443,"private void processConstructor(final Node function){
  final String className=getClassName(function);
  if (className == null) {
    return;
  }
  final Node insertionPoint=NodeUtil.getEnclosingStatement(function);
  NodeTraversal.traverseEs6(compiler,function.getLastChild(),new AbstractShallowStatementCallback(){
    @Override public void visit(    NodeTraversal t,    Node n,    Node parent){
      if (n.isExprResult()) {
        Node expr=n.getFirstChild();
        Node name=expr.isAssign() ? expr.getFirstChild() : expr;
        if (!name.isGetProp() || !name.getFirstChild().isThis()) {
          return;
        }
        JSType type=name.getJSType();
        String pname=name.getLastChild().getString();
        JSDocInfo jsdoc=NodeUtil.getBestJSDocInfo(name);
        Node initializer=null;
        if (type == null) {
          initializer=NodeUtil.getRValueOfLValue(name).detachFromParent();
        }
 else         if (isInferrableConst(jsdoc,name)) {
          jsdoc=maybeUpdateJSDocInfoWithType(jsdoc,name);
        }
        Node newProtoAssignStmt=NodeUtil.newQNameDeclaration(compiler,className + ""String_Node_Str"" + pname,initializer,jsdoc);
        newProtoAssignStmt.useSourceInfoIfMissingFromForTree(expr);
        insertionPoint.getParent().addChildAfter(newProtoAssignStmt,insertionPoint);
        compiler.reportCodeChange();
      }
    }
  }
);
}","private void processConstructor(final Node function){
  final String className=getClassName(function);
  if (className == null) {
    return;
  }
  final Node insertionPoint=NodeUtil.getEnclosingStatement(function);
  NodeTraversal.traverseEs6(compiler,function.getLastChild(),new AbstractShallowStatementCallback(){
    @Override public void visit(    NodeTraversal t,    Node n,    Node parent){
      if (n.isExprResult()) {
        Node expr=n.getFirstChild();
        Node name=expr.isAssign() ? expr.getFirstChild() : expr;
        if (!name.isGetProp() || !name.getFirstChild().isThis()) {
          return;
        }
        String pname=name.getLastChild().getString();
        String fullyQualifiedName=className + ""String_Node_Str"" + pname;
        if (seenNames.contains(fullyQualifiedName)) {
          return;
        }
        JSType type=name.getJSType();
        JSDocInfo jsdoc=NodeUtil.getBestJSDocInfo(name);
        if (jsdoc == null) {
          jsdoc=getAllTypeJSDoc();
        }
 else         if (isInferrableConst(jsdoc,name)) {
          jsdoc=maybeUpdateJSDocInfoWithType(jsdoc,name);
          if (type == null) {
            compiler.report(JSError.make(name,CONSTANT_WITHOUT_EXPLICIT_TYPE));
            return;
          }
        }
        Node newProtoAssignStmt=NodeUtil.newQNameDeclaration(compiler,fullyQualifiedName,null,jsdoc);
        newProtoAssignStmt.useSourceInfoIfMissingFromForTree(expr);
        insertionPoint.getParent().addChildAfter(newProtoAssignStmt,insertionPoint);
        compiler.reportCodeChange();
        seenNames.add(fullyQualifiedName);
      }
    }
  }
);
}",0.7585056704469646
19444,"private static boolean isUnknownType(JSType jsType){
  return jsType == null || jsType.isUnknownType() || jsType.isNoType();
}","private static boolean isUnknownType(JSType jsType){
  return jsType == null || jsType.isUnknownType() || jsType.isNoType() || jsType.isAllType();
}",0.9197080291970804
19445,"private static boolean isObjectType(Node n){
  JSType jsType=n.getJSType();
  if (jsType == null) {
    return false;
  }
  jsType=jsType.restrictByNotNullOrUndefined();
  return !jsType.isUnknownType() && !jsType.isNoType() && jsType.isObject();
}","private static boolean isObjectType(Node n){
  JSType jsType=n.getJSType();
  if (jsType == null) {
    return false;
  }
  jsType=jsType.restrictByNotNullOrUndefined();
  return !jsType.isUnknownType() && !jsType.isNoType() && !jsType.isAllType()&& jsType.isObject();
}",0.9575289575289576
19446,"private static boolean isNumberType(Node n){
  JSType jsType=n.getJSType();
  if (jsType == null) {
    return false;
  }
  return !jsType.isUnknownType() && !jsType.isNoType() && jsType.isNumberValueType();
}","private static boolean isNumberType(Node n){
  JSType jsType=n.getJSType();
  if (jsType == null) {
    return false;
  }
  return !jsType.isUnknownType() && !jsType.isNoType() && !jsType.isAllType()&& jsType.isNumberValueType();
}",0.95
19447,"private EnvTypePair analyzePropAccessFwd(Node receiver,String pname,TypeEnv inEnv,JSType requiredType,JSType specializedType){
  QualifiedName propQname=new QualifiedName(pname);
  Node propAccessNode=receiver.getParent();
  EnvTypePair pair;
  JSType reqObjType=pickReqObjType(propAccessNode);
  JSType recvReqType, recvSpecType;
  if (NodeUtil.isPropertyTest(compiler,propAccessNode) && !specializedType.isFalseOrFalsy() || specializedType.isTrueOrTruthy()) {
    recvReqType=reqObjType;
    pair=analyzeExprFwd(receiver,inEnv,recvReqType);
    JSType subtypeWithProp=pair.type.findSubtypeWithProp(propQname);
    if (subtypeWithProp.isBottom()) {
      recvSpecType=reqObjType;
    }
 else {
      recvSpecType=subtypeWithProp;
    }
    if (specializedType.isTrueOrTruthy()) {
      recvSpecType=recvSpecType.withLoose().withProperty(propQname,specializedType);
    }
 else {
      recvSpecType=recvSpecType.withProperty(propQname,specializedType);
    }
  }
 else   if (specializedType.isFalseOrFalsy()) {
    recvReqType=recvSpecType=reqObjType;
  }
 else {
    recvReqType=reqObjType.withProperty(propQname,requiredType);
    recvSpecType=reqObjType.withProperty(propQname,specializedType);
  }
  pair=analyzeExprFwd(receiver,inEnv,recvReqType,recvSpecType);
  pair=mayWarnAboutNullableReferenceAndTighten(receiver,pair.type,recvSpecType,pair.env);
  JSType recvType=pair.type.autobox();
  if (recvType.isUnknown() || mayWarnAboutNonObject(receiver,recvType,specializedType)) {
    return new EnvTypePair(pair.env,requiredType);
  }
  FunctionType ft=recvType.getFunTypeIfSingletonObj();
  if (ft != null && pname.equals(""String_Node_Str"")) {
    return new EnvTypePair(pair.env,commonTypes.fromFunctionType(ft.transformByCallProperty()));
  }
  if (ft != null && pname.equals(""String_Node_Str"")) {
    return new EnvTypePair(pair.env,commonTypes.fromFunctionType(ft.transformByApplyProperty(commonTypes)));
  }
  if (this.convention.isSuperClassReference(pname)) {
    if (ft != null && ft.isUniqueConstructor()) {
      JSType result=ft.getSuperPrototype();
      pair.type=result != null ? result : JSType.UNDEFINED;
      return pair;
    }
  }
  if (propAccessNode.isGetProp() && mayWarnAboutDictPropAccess(receiver,recvType)) {
    return new EnvTypePair(pair.env,requiredType);
  }
  if (recvType.isTop()) {
    recvType=JSType.TOP_OBJECT;
  }
  QualifiedName getterPname=new QualifiedName(createGetterPropName(pname));
  if (recvType.hasProp(getterPname)) {
    return new EnvTypePair(pair.env,recvType.getProp(getterPname));
  }
  JSType resultType=recvType.getProp(propQname);
  if (resultType != null && resultType.isBottom()) {
    warnings.add(JSError.make(propAccessNode,BOTTOM_PROP,pname,recvType.toString()));
    return new EnvTypePair(pair.env,JSType.UNKNOWN);
  }
  if (!propAccessNode.getParent().isExprResult() && !specializedType.isTrueOrTruthy() && !specializedType.isFalseOrFalsy()&& !recvType.mayBeDict()&& !mayWarnAboutInexistentProp(propAccessNode,recvType,propQname,pair.env)&& recvType.hasProp(propQname)&& !resultType.isSubtypeOf(requiredType)&& tightenTypeAndDontWarn(receiver.isName() ? receiver.getString() : null,receiver,recvType.getDeclaredProp(propQname),resultType,requiredType)) {
    resultType=resultType.specialize(requiredType);
    LValueResultFwd lvr=analyzeLValueFwd(propAccessNode,inEnv,resultType);
    TypeEnv updatedEnv=updateLvalueTypeInEnv(lvr.env,propAccessNode,lvr.ptr,resultType);
    return new EnvTypePair(updatedEnv,resultType);
  }
  if (resultType == null) {
    resultType=JSType.UNKNOWN;
  }
  return new EnvTypePair(pair.env,resultType);
}","private EnvTypePair analyzePropAccessFwd(Node receiver,String pname,TypeEnv inEnv,JSType requiredType,JSType specializedType){
  QualifiedName propQname=new QualifiedName(pname);
  Node propAccessNode=receiver.getParent();
  EnvTypePair pair;
  JSType reqObjType=pickReqObjType(propAccessNode);
  JSType recvReqType, recvSpecType;
  if (NodeUtil.isPropertyTest(compiler,propAccessNode) && !specializedType.isFalseOrFalsy() || specializedType.isTrueOrTruthy()) {
    recvReqType=reqObjType;
    pair=analyzeExprFwd(receiver,inEnv,recvReqType);
    JSType subtypeWithProp=pair.type.findSubtypeWithProp(propQname);
    if (subtypeWithProp.isBottom()) {
      recvSpecType=reqObjType;
    }
 else {
      recvSpecType=subtypeWithProp;
    }
    if (specializedType.isTrueOrTruthy()) {
      recvSpecType=recvSpecType.withLoose().withProperty(propQname,specializedType);
    }
 else {
      recvSpecType=recvSpecType.withProperty(propQname,specializedType);
    }
  }
 else   if (specializedType.isFalseOrFalsy()) {
    recvReqType=recvSpecType=reqObjType;
  }
 else {
    recvReqType=reqObjType.withProperty(propQname,requiredType);
    recvSpecType=reqObjType.withProperty(propQname,specializedType);
  }
  pair=analyzeExprFwd(receiver,inEnv,recvReqType,recvSpecType);
  pair=mayWarnAboutNullableReferenceAndTighten(receiver,pair.type,recvSpecType,pair.env);
  JSType recvType=pair.type.autobox();
  if (recvType.isUnknown() || recvType.isTrueOrTruthy() || mayWarnAboutNonObject(receiver,recvType,specializedType)) {
    return new EnvTypePair(pair.env,requiredType);
  }
  FunctionType ft=recvType.getFunTypeIfSingletonObj();
  if (ft != null && pname.equals(""String_Node_Str"")) {
    return new EnvTypePair(pair.env,commonTypes.fromFunctionType(ft.transformByCallProperty()));
  }
  if (ft != null && pname.equals(""String_Node_Str"")) {
    return new EnvTypePair(pair.env,commonTypes.fromFunctionType(ft.transformByApplyProperty(commonTypes)));
  }
  if (this.convention.isSuperClassReference(pname)) {
    if (ft != null && ft.isUniqueConstructor()) {
      JSType result=ft.getSuperPrototype();
      pair.type=result != null ? result : JSType.UNDEFINED;
      return pair;
    }
  }
  if (propAccessNode.isGetProp() && mayWarnAboutDictPropAccess(receiver,recvType)) {
    return new EnvTypePair(pair.env,requiredType);
  }
  if (recvType.isTop()) {
    recvType=JSType.TOP_OBJECT;
  }
  QualifiedName getterPname=new QualifiedName(createGetterPropName(pname));
  if (recvType.hasProp(getterPname)) {
    return new EnvTypePair(pair.env,recvType.getProp(getterPname));
  }
  JSType resultType=recvType.getProp(propQname);
  if (resultType != null && resultType.isBottom()) {
    warnings.add(JSError.make(propAccessNode,BOTTOM_PROP,pname,recvType.toString()));
    return new EnvTypePair(pair.env,JSType.UNKNOWN);
  }
  if (!propAccessNode.getParent().isExprResult() && !specializedType.isTrueOrTruthy() && !specializedType.isFalseOrFalsy()&& !recvType.mayBeDict()&& !mayWarnAboutInexistentProp(propAccessNode,recvType,propQname,pair.env)&& recvType.hasProp(propQname)&& !resultType.isSubtypeOf(requiredType)&& tightenTypeAndDontWarn(receiver.isName() ? receiver.getString() : null,receiver,recvType.getDeclaredProp(propQname),resultType,requiredType)) {
    resultType=resultType.specialize(requiredType);
    LValueResultFwd lvr=analyzeLValueFwd(propAccessNode,inEnv,resultType);
    TypeEnv updatedEnv=updateLvalueTypeInEnv(lvr.env,propAccessNode,lvr.ptr,resultType);
    return new EnvTypePair(updatedEnv,resultType);
  }
  if (resultType == null) {
    resultType=JSType.UNKNOWN;
  }
  return new EnvTypePair(pair.env,resultType);
}",0.9959983441424036
19448,"public JSType getProp(QualifiedName qname){
  if (isBottom() || isUnknown()) {
    return UNKNOWN;
  }
  Preconditions.checkState(!getObjs().isEmpty() || !getEnums().isEmpty(),""String_Node_Str"",this);
  return nullAcceptingJoin(TypeWithPropertiesStatics.getProp(getObjs(),qname),TypeWithPropertiesStatics.getProp(getEnums(),qname));
}","public JSType getProp(QualifiedName qname){
  if (isBottom() || isUnknown() || hasTruthyMask()) {
    return UNKNOWN;
  }
  Preconditions.checkState(!getObjs().isEmpty() || !getEnums().isEmpty(),""String_Node_Str"",qname,this);
  return nullAcceptingJoin(TypeWithPropertiesStatics.getProp(getObjs(),qname),TypeWithPropertiesStatics.getProp(getEnums(),qname));
}",0.963924963924964
19449,"private static JSType meetHelper(JSType lhs,JSType rhs){
  if (lhs.isTop()) {
    return rhs;
  }
 else   if (rhs.isTop()) {
    return lhs;
  }
 else   if (lhs.isUnknown()) {
    return rhs;
  }
 else   if (rhs.isUnknown()) {
    return lhs;
  }
 else   if (lhs.isBottom() || rhs.isBottom()) {
    return BOTTOM;
  }
  int newMask=lhs.getMask() & rhs.getMask();
  String newTypevar;
  if (Objects.equals(lhs.getTypeVar(),rhs.getTypeVar())) {
    newTypevar=lhs.getTypeVar();
  }
 else {
    newTypevar=null;
    newMask=newMask & ~TYPEVAR_MASK;
  }
  return meetEnums(newMask,lhs.getMask() | rhs.getMask(),ObjectType.meetSets(lhs.getObjs(),rhs.getObjs()),newTypevar,lhs.getObjs(),rhs.getObjs(),lhs.getEnums(),rhs.getEnums());
}","private static JSType meetHelper(JSType lhs,JSType rhs){
  if (lhs.isTop()) {
    return rhs;
  }
  if (rhs.isTop()) {
    return lhs;
  }
  if (lhs.isUnknown()) {
    return rhs;
  }
  if (rhs.isUnknown()) {
    return lhs;
  }
  if (lhs.isBottom() || rhs.isBottom()) {
    return BOTTOM;
  }
  if (lhs.hasTruthyMask()) {
    return rhs.makeTruthy();
  }
  if (lhs.hasFalsyMask()) {
    return rhs.makeFalsy();
  }
  if (rhs.hasTruthyMask()) {
    return lhs.makeTruthy();
  }
  if (rhs.hasFalsyMask()) {
    return lhs.makeFalsy();
  }
  int newMask=lhs.getMask() & rhs.getMask();
  String newTypevar;
  if (Objects.equals(lhs.getTypeVar(),rhs.getTypeVar())) {
    newTypevar=lhs.getTypeVar();
  }
 else {
    newTypevar=null;
    newMask=newMask & ~TYPEVAR_MASK;
  }
  return meetEnums(newMask,lhs.getMask() | rhs.getMask(),ObjectType.meetSets(lhs.getObjs(),rhs.getObjs()),newTypevar,lhs.getObjs(),rhs.getObjs(),lhs.getEnums(),rhs.getEnums());
}",0.8400954653937948
19450,"/** 
 * Tries to apply our various peephole minimizations on the passed in node.
 */
@Override @SuppressWarnings(""String_Node_Str"") public Node optimizeSubtree(Node node){
switch (node.getType()) {
case THROW:
case RETURN:
{
      Node result=tryRemoveRedundantExit(node);
      if (result != node) {
        return result;
      }
      return tryReplaceExitWithBreak(node);
    }
case NOT:
  tryMinimizeCondition(node.getFirstChild());
return tryMinimizeNot(node);
case IF:
performCoercionSubstitutions(node.getFirstChild());
performConditionSubstitutions(node.getFirstChild());
return tryMinimizeIf(node);
case EXPR_RESULT:
performConditionSubstitutions(node.getFirstChild());
return tryMinimizeExprResult(node);
case HOOK:
performCoercionSubstitutions(node.getFirstChild());
performConditionSubstitutions(node.getFirstChild());
return tryMinimizeHook(node);
case WHILE:
case DO:
tryMinimizeCondition(NodeUtil.getConditionExpression(node));
return node;
case FOR:
if (!NodeUtil.isForIn(node)) {
tryJoinForCondition(node);
tryMinimizeCondition(NodeUtil.getConditionExpression(node));
}
return node;
case BLOCK:
return tryReplaceIf(node);
default :
return node;
}
}","/** 
 * Tries to apply our various peephole minimizations on the passed in node.
 */
@Override @SuppressWarnings(""String_Node_Str"") public Node optimizeSubtree(Node node){
switch (node.getType()) {
case THROW:
case RETURN:
{
      Node result=tryRemoveRedundantExit(node);
      if (result != node) {
        return result;
      }
      return tryReplaceExitWithBreak(node);
    }
case NOT:
  tryMinimizeCondition(node.getFirstChild());
return tryMinimizeNot(node);
case IF:
performCoercionSubstitutions(node.getFirstChild());
performConditionSubstitutions(node.getFirstChild());
return tryMinimizeIf(node);
case EXPR_RESULT:
performCoercionSubstitutions(node.getFirstChild());
performConditionSubstitutions(node.getFirstChild());
return tryMinimizeExprResult(node);
case HOOK:
performCoercionSubstitutions(node.getFirstChild());
performConditionSubstitutions(node.getFirstChild());
return tryMinimizeHook(node);
case WHILE:
case DO:
tryMinimizeCondition(NodeUtil.getConditionExpression(node));
return node;
case FOR:
if (!NodeUtil.isForIn(node)) {
tryJoinForCondition(node);
tryMinimizeCondition(NodeUtil.getConditionExpression(node));
}
return node;
case BLOCK:
return tryReplaceIf(node);
default :
return node;
}
}",0.9781879194630873
19451,"private static boolean isObjectType(Node n){
  JSType jsType=n.getJSType();
  if (jsType == null) {
    return false;
  }
  return !jsType.isUnknownType() && jsType.isObject();
}","private static boolean isObjectType(Node n){
  JSType jsType=n.getJSType();
  if (jsType == null) {
    return false;
  }
  jsType=jsType.restrictByNotNullOrUndefined();
  return !jsType.isUnknownType() && !jsType.isNoType() && jsType.isObject();
}",0.8356807511737089
19452,"/** 
 * Given a source file, line, and column, return the reverse mapping (source --> target). A collection is returned as in some cases (like a function being inlined), one source line may map to more then one target location. An empty collection is returned if there were no matches.
 * @param originalFile the source file
 * @param line the source line
 * @param column the source column
 * @return the reverse mapping (source --> target)
 */
public Collection<OriginalMapping> getReverseMapping(String originalFile,int line,int column);","/** 
 * Given a source file, line, and column, return the reverse mapping (source → target). A collection is returned as in some cases (like a function being inlined), one source line may map to more then one target location. An empty collection is returned if there were no matches.
 * @param originalFile the source file
 * @param line the source line
 * @param column the source column
 * @return the reverse mapping (source → target)
 */
public Collection<OriginalMapping> getReverseMapping(String originalFile,int line,int column);",0.9925650557620818
19453,"/** 
 * Prefix for filenames of compiled JS modules. <module-name>.js will be appended to this prefix. Directories will be created as needed. Use with --module
 */
public CommandLineConfig setModuleOutputPathPrefix(String moduleOutputPathPrefix){
  this.moduleOutputPathPrefix=moduleOutputPathPrefix;
  return this;
}","/** 
 * Prefix for filenames of compiled JS modules.  {@code <module-name>.js} will be appended to this prefix. Directorieswill be created as needed. Use with --module
 */
public CommandLineConfig setModuleOutputPathPrefix(String moduleOutputPathPrefix){
  this.moduleOutputPathPrefix=moduleOutputPathPrefix;
  return this;
}",0.9844236760124612
19454,"/** 
 * Decodes an encoded string from the JS Compiler ReplaceStrings pass. <p>An original string with args might look like this: <pre>  Error('Some ' + arg1 + ' error ' + arg2 + ' message.');</pre> Which gets replaced with: <pre>  Error('key' + '`' + arg1 + '`' + arg2);</pre> Where ` is the argument place holder. The replacement mapping would be: <pre>  key -> 'Some ` error ` message.'</pre> Where key is some arbitrary replacement string. An encoded string, with args, from the client will look like: <pre>  'key`arg1`arg2'</pre>
 * @param encodedStr An encoded string.
 * @return The decoded string, or the encoded string if it fails to decode.
 * @see com.google.javascript.jscomp.ReplaceStrings
 */
public String decode(String encodedStr){
  String[] suppliedBits=encodedStr.split(ARGUMENT_PLACE_HOLDER,-1);
  String originalStr=originalToNewNameMap.get(suppliedBits[0]);
  if (originalStr == null) {
    return encodedStr;
  }
  String[] originalBits=originalStr.split(ARGUMENT_PLACE_HOLDER,-1);
  StringBuilder sb=new StringBuilder(originalBits[0]);
  for (int i=1; i < Math.max(originalBits.length,suppliedBits.length); i++) {
    sb.append(i < suppliedBits.length ? suppliedBits[i] : ""String_Node_Str"");
    sb.append(i < originalBits.length ? originalBits[i] : ""String_Node_Str"");
  }
  return sb.toString();
}","/** 
 * Decodes an encoded string from the JS Compiler ReplaceStrings pass. <p>An original string with args might look like this: <pre>  Error('Some ' + arg1 + ' error ' + arg2 + ' message.');</pre> Which gets replaced with: <pre>  Error('key' + '`' + arg1 + '`' + arg2);</pre> Where ` is the argument place holder. The replacement mapping would be: <pre>  key → 'Some ` error ` message.'</pre> Where key is some arbitrary replacement string. An encoded string, with args, from the client will look like: <pre>  'key`arg1`arg2'</pre>
 * @param encodedStr An encoded string.
 * @return The decoded string, or the encoded string if it fails to decode.
 * @see com.google.javascript.jscomp.ReplaceStrings
 */
public String decode(String encodedStr){
  String[] suppliedBits=encodedStr.split(ARGUMENT_PLACE_HOLDER,-1);
  String originalStr=originalToNewNameMap.get(suppliedBits[0]);
  if (originalStr == null) {
    return encodedStr;
  }
  String[] originalBits=originalStr.split(ARGUMENT_PLACE_HOLDER,-1);
  StringBuilder sb=new StringBuilder(originalBits[0]);
  for (int i=1; i < Math.max(originalBits.length,suppliedBits.length); i++) {
    sb.append(i < suppliedBits.length ? suppliedBits[i] : ""String_Node_Str"");
    sb.append(i < originalBits.length ? originalBits[i] : ""String_Node_Str"");
  }
  return sb.toString();
}",0.9988657844990548
19455,"/** 
 * Adds a <path/> entry.
 */
public void addPath(Path list){
  this.sourcePaths.add(list);
}","/** 
 * Adds a   {@code <path/>} entry.
 */
public void addPath(Path list){
  this.sourcePaths.add(list);
}",0.9509803921568628
19456,"@Override public void process(Node externs,Node root){
  NodeTraversal.traverseEs6(compiler,root,this);
}","@Override public void process(Node externs,Node root){
  GetterSetterCollector getterSetterCollector=new GetterSetterCollector();
  NodeTraversal.traverseEs6(compiler,root,getterSetterCollector);
  NodeTraversal.traverseEs6(compiler,root,new FunctionVisitor(compiler,getterSetterCollector.propNames));
}",0.4950980392156863
19457,"private boolean visitNode(Node n,Node parent){
switch (n.getType()) {
case Token.GETPROP:
    if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) {
      return false;
    }
  Property property=getOrCreateProperty(n);
if (property != null) {
  property.markLastWriteRead();
  property.markChildrenRead();
}
return true;
case Token.CALL:
if (ASSUME_CONSTRUCTORS_HAVENT_ESCAPED && isConstructor && !NodeUtil.referencesThis(n)&& NodeUtil.getEnclosingType(n,Token.TRY) == null) {
markAllPropsReadExceptThisProps();
}
 else {
markAllPropsRead();
}
return false;
case Token.THIS:
case Token.NAME:
Property nameProp=Preconditions.checkNotNull(getOrCreateProperty(n));
nameProp.markLastWriteRead();
nameProp.markChildrenRead();
return true;
case Token.THROW:
case Token.FOR:
case Token.SWITCH:
markAllPropsRead();
return false;
case Token.BLOCK:
visitBlock(n);
return true;
default :
if (isConditionalExpression(n)) {
markAllPropsRead();
return false;
}
return true;
}
}","private boolean visitNode(Node n,Node parent){
switch (n.getType()) {
case Token.GETPROP:
    if (n.isGetProp() && n.getLastChild().isString() && getterSetterNames.contains(n.getLastChild().getString())) {
      markAllPropsRead();
      return true;
    }
  if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) {
    return false;
  }
Property property=getOrCreateProperty(n);
if (property != null) {
property.markLastWriteRead();
if (!parent.isGetProp()) {
  property.markChildrenRead();
}
}
return true;
case Token.CALL:
if (ASSUME_CONSTRUCTORS_HAVENT_ESCAPED && isConstructor && !NodeUtil.referencesThis(n)&& NodeUtil.getEnclosingType(n,Token.TRY) == null) {
markAllPropsReadExceptThisProps();
}
 else {
markAllPropsRead();
}
return false;
case Token.THIS:
case Token.NAME:
Property nameProp=Preconditions.checkNotNull(getOrCreateProperty(n));
nameProp.markLastWriteRead();
if (!parent.isGetProp()) {
nameProp.markChildrenRead();
}
return true;
case Token.THROW:
case Token.FOR:
case Token.SWITCH:
markAllPropsRead();
return false;
case Token.BLOCK:
visitBlock(n);
return true;
default :
if (isConditionalExpression(n)) {
markAllPropsRead();
return false;
}
return true;
}
}",0.8530631045601106
19458,"@Override public void visit(NodeTraversal t,Node n,Node parent){
  if (NodeUtil.isAssignmentOp(n)) {
    visitAssignmentLhs(n.getFirstChild());
  }
  if (n.isBlock()) {
    visitBlock(n);
  }
}","@Override public void visit(NodeTraversal t,Node n,Node parent){
  if (NodeUtil.isGetterOrSetter(n)) {
    Node grandparent=parent.getParent();
    if (NodeUtil.isGetOrSetKey(n) && n.getString() != null) {
      propNames.add(n.getString());
    }
 else     if (NodeUtil.isObjectDefinePropertyDefinition(grandparent)) {
      Node propNode=grandparent.getChildAtIndex(2);
      if (propNode.isString()) {
        propNames.add(propNode.getString());
      }
    }
 else     if (grandparent.isStringKey() && NodeUtil.isObjectDefinePropertiesDefinition(grandparent.getParent().getParent())) {
      propNames.add(grandparent.getString());
    }
  }
}",0.3020214030915576
19459,"FindCandidateAssignmentTraversal(boolean isConstructor){
  this.isConstructor=isConstructor;
}","FindCandidateAssignmentTraversal(Set<String> getterSetterNames,boolean isConstructor){
  this.getterSetterNames=getterSetterNames;
  this.isConstructor=isConstructor;
}",0.7175572519083969
19460,"static boolean isNegativeZero(double x){
  return x == 0.0 && Math.copySign(1,x) == -1.0;
}","static boolean isNegativeZero(double x){
  return x == 0.0 && 1 / x < 0;
}",0.8484848484848485
19461,"private EnvTypePair analyzeAssignFwd(Node expr,TypeEnv inEnv,JSType requiredType,JSType specializedType){
  if (expr.getBooleanProp(Node.ANALYZED_DURING_GTI)) {
    expr.removeProp(Node.ANALYZED_DURING_GTI);
    return new EnvTypePair(inEnv,requiredType);
  }
  mayWarnAboutConst(expr);
  Node lhs=expr.getFirstChild();
  Node rhs=expr.getLastChild();
  if (lhs.getBooleanProp(Node.ANALYZED_DURING_GTI)) {
    lhs.removeProp(Node.ANALYZED_DURING_GTI);
    JSType declType=markAndGetTypeOfPreanalyzedNode(lhs,inEnv,true);
    if (rhs.matchesQualifiedName(ABSTRACT_METHOD_NAME)) {
      return new EnvTypePair(inEnv,requiredType);
    }
    EnvTypePair rhsPair=analyzeExprFwd(rhs,inEnv,declType);
    if (!rhsPair.type.isSubtypeOf(declType) && !NodeUtil.isPrototypeAssignment(lhs)) {
      warnings.add(JSError.make(expr,MISTYPED_ASSIGN_RHS,declType.toString(),rhsPair.type.toString()));
    }
    return rhsPair;
  }
  LValueResultFwd lvalue=analyzeLValueFwd(lhs,inEnv,requiredType);
  JSType declType=lvalue.declType;
  EnvTypePair rhsPair=analyzeExprFwd(rhs,lvalue.env,requiredType,specializedType);
  if (declType != null && !rhsPair.type.isSubtypeOf(declType)) {
    warnings.add(JSError.make(expr,MISTYPED_ASSIGN_RHS,declType.toString(),rhsPair.type.toString()));
  }
 else {
    rhsPair.env=updateLvalueTypeInEnv(rhsPair.env,lhs,lvalue.ptr,rhsPair.type);
  }
  return rhsPair;
}","private EnvTypePair analyzeAssignFwd(Node expr,TypeEnv inEnv,JSType requiredType,JSType specializedType){
  if (expr.getBooleanProp(Node.ANALYZED_DURING_GTI)) {
    expr.removeProp(Node.ANALYZED_DURING_GTI);
    return new EnvTypePair(inEnv,requiredType);
  }
  mayWarnAboutConst(expr);
  Node lhs=expr.getFirstChild();
  Node rhs=expr.getLastChild();
  if (lhs.getBooleanProp(Node.ANALYZED_DURING_GTI)) {
    lhs.removeProp(Node.ANALYZED_DURING_GTI);
    JSType declType=markAndGetTypeOfPreanalyzedNode(lhs,inEnv,true);
    if (rhs.matchesQualifiedName(ABSTRACT_METHOD_NAME)) {
      return new EnvTypePair(inEnv,requiredType);
    }
    EnvTypePair rhsPair=analyzeExprFwd(rhs,inEnv,declType);
    if (!rhsPair.type.isSubtypeOf(declType) && !NodeUtil.isPrototypeAssignment(lhs)) {
      warnings.add(JSError.make(expr,MISTYPED_ASSIGN_RHS,errorMsgWithTypeDiff(declType,rhsPair.type)));
    }
    return rhsPair;
  }
  LValueResultFwd lvalue=analyzeLValueFwd(lhs,inEnv,requiredType);
  JSType declType=lvalue.declType;
  EnvTypePair rhsPair=analyzeExprFwd(rhs,lvalue.env,requiredType,specializedType);
  if (declType != null && !rhsPair.type.isSubtypeOf(declType)) {
    warnings.add(JSError.make(expr,MISTYPED_ASSIGN_RHS,errorMsgWithTypeDiff(declType,rhsPair.type)));
  }
 else {
    rhsPair.env=updateLvalueTypeInEnv(rhsPair.env,lhs,lvalue.ptr,rhsPair.type);
  }
  return rhsPair;
}",0.950831525668836
19462,"public void testPinpointTypeDiffWhenMismatch(){
  typeCheckMessageContents(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheckMessageContents(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheckMessageContents(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheckMessageContents(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheckMessageContents(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheckMessageContents(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheckMessageContents(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheckMessageContents(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""));
  typeCheckMessageContents(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""));
}","public void testPinpointTypeDiffWhenMismatch(){
  typeCheckMessageContents(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheckMessageContents(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheckMessageContents(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheckMessageContents(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheckMessageContents(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheckMessageContents(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheckMessageContents(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheckMessageContents(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""));
  typeCheckMessageContents(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str""));
  typeCheckMessageContents(""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS,LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.957351290684624
19463,"private EnvTypePair analyzeAssertionCall(Node callNode,TypeEnv env,AssertionFunctionSpec assertionFunctionSpec){
  Node firstParam=callNode.getSecondChild();
  if (firstParam == null) {
    return new EnvTypePair(env,JSType.UNKNOWN);
  }
  Node assertedNode=assertionFunctionSpec.getAssertedParam(firstParam);
  if (assertedNode == null) {
    return new EnvTypePair(env,JSType.UNKNOWN);
  }
  JSType assertedType=assertionFunctionSpec.getAssertedNewType(callNode,currentScope);
  if (assertedType.isUnknown()) {
    warnings.add(JSError.make(callNode,NewTypeInference.UNKNOWN_ASSERTION_TYPE));
  }
  EnvTypePair pair=analyzeExprFwd(assertedNode,env,JSType.UNKNOWN,assertedType);
  if (pair.type.isBottom()) {
    JSType t=analyzeExprFwd(assertedNode,env).type.substituteGenericsWithUnknown();
    if (t.isSubtypeOf(assertedType)) {
      pair.type=t;
    }
 else {
      warnings.add(JSError.make(assertedNode,NewTypeInference.ASSERT_FALSE));
      pair.type=JSType.UNKNOWN;
      pair.env=env;
    }
  }
  return pair;
}","private EnvTypePair analyzeAssertionCall(Node callNode,TypeEnv env,AssertionFunctionSpec assertionFunctionSpec){
  Node firstParam=callNode.getSecondChild();
  if (firstParam == null) {
    return new EnvTypePair(env,JSType.UNKNOWN);
  }
  Node assertedNode=assertionFunctionSpec.getAssertedParam(firstParam);
  if (assertedNode == null) {
    return new EnvTypePair(env,JSType.UNKNOWN);
  }
  JSType assertedType=assertionFunctionSpec.getAssertedNewType(callNode,currentScope);
  if (assertedType.isUnknown()) {
    warnings.add(JSError.make(callNode,NewTypeInference.UNKNOWN_ASSERTION_TYPE));
  }
  EnvTypePair pair=analyzeExprFwd(assertedNode,env,JSType.UNKNOWN,assertedType);
  if (!pair.type.isSubtypeOf(assertedType) && JSType.haveCommonSubtype(assertedType,pair.type)) {
    pair.type=assertedType;
  }
  if (pair.type.isBottom()) {
    JSType t=analyzeExprFwd(assertedNode,env).type.substituteGenericsWithUnknown();
    if (t.isSubtypeOf(assertedType)) {
      pair.type=t;
    }
 else {
      warnings.add(JSError.make(assertedNode,NewTypeInference.ASSERT_FALSE));
      pair.type=JSType.UNKNOWN;
      pair.env=env;
    }
  }
  return pair;
}",0.940202391904324
19464,"public void testAsserts(){
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testAsserts(){
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(CLOSURE_BASE,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
}",0.9003660024400163
19465,"void fillPropertyScopes(){
  List<Symbol> types=new ArrayList<>();
  for (  Symbol sym : getAllSymbols()) {
    if (needsPropertyScope(sym)) {
      types.add(sym);
    }
  }
  Collections.sort(types,getNaturalSymbolOrdering().reverse());
  for (  Symbol s : types) {
    createPropertyScopeFor(s);
  }
  pruneOrphanedNames();
}","void fillPropertyScopes(){
  List<Symbol> types=new ArrayList<>();
  List<Symbol> googModuleExportTypes=new ArrayList<>();
  for (  Symbol sym : getAllSymbols()) {
    if (needsPropertyScope(sym)) {
      if (sym.getName().startsWith(""String_Node_Str"")) {
        googModuleExportTypes.add(sym);
      }
 else {
        types.add(sym);
      }
    }
  }
  Collections.sort(types,getNaturalSymbolOrdering().reverse());
  Collections.sort(googModuleExportTypes,getNaturalSymbolOrdering().reverse());
  for (  Symbol s : Iterables.concat(googModuleExportTypes,types)) {
    createPropertyScopeFor(s);
  }
  pruneOrphanedNames();
}",0.6429319371727749
19466,"@Override public void enterScope(NodeTraversal t){
  Scope scope=t.getScope();
  if (!shouldOptimizeScope(scope)) {
    return;
  }
  Preconditions.checkState(scope.isFunctionScope(),scope);
  ControlFlowGraph<Node> cfg=t.getControlFlowGraph();
  LiveVariablesAnalysis liveness=new LiveVariablesAnalysis(cfg,scope,compiler);
  if (NodeUtil.getFunctionParameters(scope.getRootNode()).getChildCount() == 2) {
    liveness.markAllParametersEscaped();
  }
  liveness.analyze();
  UndiGraph<Var,Void> interferenceGraph=computeVariableNamesInterferenceGraph(t,cfg,(Set<Var>)liveness.getEscapedLocals());
  GraphColoring<Var,Void> coloring=new GreedyGraphColoring<>(interferenceGraph,coloringTieBreaker);
  coloring.color();
  colorings.push(coloring);
}","@Override public void enterScope(NodeTraversal t){
  Scope scope=t.getScope();
  if (!shouldOptimizeScope(scope)) {
    return;
  }
  Preconditions.checkState(scope.isFunctionScope(),scope);
  ControlFlowGraph<Node> cfg=t.getControlFlowGraph();
  LiveVariablesAnalysis liveness=new LiveVariablesAnalysis(cfg,scope,compiler);
  if (compiler.getOptions().getLanguageOut() == CompilerOptions.LanguageMode.ECMASCRIPT3) {
    if (NodeUtil.getFunctionParameters(scope.getRootNode()).getChildCount() == 2) {
      liveness.markAllParametersEscaped();
    }
  }
  liveness.analyze();
  UndiGraph<Var,Void> interferenceGraph=computeVariableNamesInterferenceGraph(t,cfg,(Set<Var>)liveness.getEscapedLocals());
  GraphColoring<Var,Void> coloring=new GreedyGraphColoring<>(interferenceGraph,coloringTieBreaker);
  coloring.color();
  colorings.push(coloring);
}",0.8571428571428571
19467,"public void testParameter4b(){
  test(""String_Node_Str"",""String_Node_Str"");
}","public void testParameter4b(){
  setLanguageOut(LanguageMode.ECMASCRIPT5);
  test(""String_Node_Str"",""String_Node_Str"");
}",0.7777777777777778
19468,"void add(Node n,Context context){
  if (!cc.continueProcessing()) {
    return;
  }
  if (preserveTypeAnnotations && n.getJSDocInfo() != null) {
    add(JSDocInfoPrinter.print(n.getJSDocInfo()));
  }
  int type=n.getType();
  String opstr=NodeUtil.opToStr(type);
  int childCount=n.getChildCount();
  Node first=n.getFirstChild();
  Node last=n.getLastChild();
  if (opstr != null && first != last) {
    Preconditions.checkState(childCount == 2,""String_Node_Str"",opstr,childCount);
    int p=NodeUtil.precedence(type);
    Context rhsContext=getContextForNoInOperator(context);
    boolean needsParens=(context == Context.START_OF_EXPR) && first.isObjectPattern();
    if (n.isAssign() && needsParens) {
      add(""String_Node_Str"");
    }
    if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
      addExpr(first,p,context);
      cc.addOp(opstr,true);
      addExpr(last,p,rhsContext);
    }
 else {
      unrollBinaryOperator(n,type,opstr,context,rhsContext,p,p + 1);
    }
    if (n.isAssign() && needsParens) {
      add(""String_Node_Str"");
    }
    return;
  }
  cc.startSourceMapping(n);
switch (type) {
case Token.TRY:
{
      Preconditions.checkState(first.getNext().isBlock() && !first.getNext().hasMoreThanOneChild());
      Preconditions.checkState(childCount >= 2 && childCount <= 3);
      add(""String_Node_Str"");
      add(first,Context.PRESERVE_BLOCK);
      Node catchblock=first.getNext().getFirstChild();
      if (catchblock != null) {
        add(catchblock);
      }
      if (childCount == 3) {
        cc.maybeInsertSpace();
        add(""String_Node_Str"");
        add(last,Context.PRESERVE_BLOCK);
      }
      break;
    }
case Token.CATCH:
  Preconditions.checkState(childCount == 2);
cc.maybeInsertSpace();
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
add(last,Context.PRESERVE_BLOCK);
break;
case Token.THROW:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(first);
cc.endStatement(true);
break;
case Token.RETURN:
add(""String_Node_Str"");
if (childCount == 1) {
cc.maybeInsertSpace();
add(first);
}
 else {
Preconditions.checkState(childCount == 0);
}
cc.endStatement();
break;
case Token.VAR:
if (first != null) {
add(""String_Node_Str"");
addList(first,false,getContextForNoInOperator(context),""String_Node_Str"");
}
break;
case Token.CONST:
add(""String_Node_Str"");
addList(first,false,getContextForNoInOperator(context),""String_Node_Str"");
break;
case Token.LET:
add(""String_Node_Str"");
addList(first,false,getContextForNoInOperator(context),""String_Node_Str"");
break;
case Token.LABEL_NAME:
Preconditions.checkState(!n.getString().isEmpty());
addIdentifier(n.getString());
break;
case Token.DESTRUCTURING_LHS:
add(first);
if (first != last) {
Preconditions.checkState(childCount == 2);
cc.addOp(""String_Node_Str"",true);
add(last);
}
break;
case Token.NAME:
addIdentifier(n.getString());
maybeAddOptional(n);
maybeAddTypeDecl(n);
if (first != null && !first.isEmpty()) {
Preconditions.checkState(childCount == 1);
cc.addOp(""String_Node_Str"",true);
if (first.isComma()) {
addExpr(first,NodeUtil.precedence(Token.ASSIGN),Context.OTHER);
}
 else {
addExpr(first,0,getContextForNoInOperator(context));
}
}
break;
case Token.ARRAYLIT:
add(""String_Node_Str"");
addArrayList(first);
add(""String_Node_Str"");
break;
case Token.ARRAY_PATTERN:
add(""String_Node_Str"");
addArrayList(first);
add(""String_Node_Str"");
maybeAddTypeDecl(n);
break;
case Token.PARAM_LIST:
add(""String_Node_Str"");
addList(first);
add(""String_Node_Str"");
break;
case Token.DEFAULT_VALUE:
add(first);
maybeAddTypeDecl(n);
cc.addOp(""String_Node_Str"",true);
add(first.getNext());
break;
case Token.COMMA:
Preconditions.checkState(childCount == 2);
unrollBinaryOperator(n,Token.COMMA,""String_Node_Str"",context,getContextForNoInOperator(context),0,0);
break;
case Token.NUMBER:
Preconditions.checkState(childCount == 0);
cc.addNumber(n.getDouble());
break;
case Token.TYPEOF:
case Token.VOID:
case Token.NOT:
case Token.BITNOT:
case Token.POS:
{
Preconditions.checkState(childCount == 1);
cc.addOp(NodeUtil.opToStrNoFail(type),false);
addExpr(first,NodeUtil.precedence(type),Context.OTHER);
break;
}
case Token.NEG:
{
Preconditions.checkState(childCount == 1);
if (n.getFirstChild().isNumber()) {
cc.addNumber(-n.getFirstChild().getDouble());
}
 else {
cc.addOp(NodeUtil.opToStrNoFail(type),false);
addExpr(first,NodeUtil.precedence(type),Context.OTHER);
}
break;
}
case Token.HOOK:
{
Preconditions.checkState(childCount == 3);
int p=NodeUtil.precedence(type);
Context rhsContext=getContextForNoInOperator(context);
addExpr(first,p + 1,context);
cc.addOp(""String_Node_Str"",true);
addExpr(first.getNext(),1,rhsContext);
cc.addOp(""String_Node_Str"",true);
addExpr(last,1,rhsContext);
break;
}
case Token.REGEXP:
if (!first.isString() || !last.isString()) {
throw new Error(""String_Node_Str"");
}
String regexp=regexpEscape(first.getString(),outputCharsetEncoder);
if (childCount == 2) {
add(regexp + last.getString());
}
 else {
Preconditions.checkState(childCount == 1);
add(regexp);
}
break;
case Token.FUNCTION:
{
if (n.getClass() != Node.class) {
throw new Error(""String_Node_Str"");
}
Preconditions.checkState(childCount == 3);
if (n.isArrowFunction()) {
addArrowFunction(n,first,last,context);
}
 else {
addFunction(n,first,last,context);
}
break;
}
case Token.REST:
add(""String_Node_Str"");
add(first.getString());
maybeAddTypeDecl(n);
break;
case Token.SPREAD:
add(""String_Node_Str"");
add(n.getFirstChild());
break;
case Token.EXPORT:
add(""String_Node_Str"");
if (n.getBooleanProp(Node.EXPORT_DEFAULT)) {
add(""String_Node_Str"");
}
if (n.getBooleanProp(Node.EXPORT_ALL_FROM)) {
add(""String_Node_Str"");
Preconditions.checkState(first != null && first.isEmpty());
}
 else {
add(first);
}
if (childCount == 2) {
add(""String_Node_Str"");
add(last);
}
processEnd(first,context);
break;
case Token.IMPORT:
add(""String_Node_Str"");
Node second=first.getNext();
if (!first.isEmpty()) {
add(first);
if (!second.isEmpty()) {
cc.listSeparator();
}
}
if (!second.isEmpty()) {
add(second);
}
if (!first.isEmpty() || !second.isEmpty()) {
add(""String_Node_Str"");
}
add(last);
cc.endStatement();
break;
case Token.EXPORT_SPECS:
case Token.IMPORT_SPECS:
add(""String_Node_Str"");
for (Node c=first; c != null; c=c.getNext()) {
if (c != first) {
cc.listSeparator();
}
add(c);
}
add(""String_Node_Str"");
break;
case Token.EXPORT_SPEC:
case Token.IMPORT_SPEC:
add(first);
if (first != last) {
add(""String_Node_Str"");
add(last);
}
break;
case Token.IMPORT_STAR:
add(""String_Node_Str"");
add(""String_Node_Str"");
add(n.getString());
break;
case Token.CLASS:
{
Preconditions.checkState(childCount == 3);
boolean classNeedsParens=(context == Context.START_OF_EXPR);
if (classNeedsParens) {
add(""String_Node_Str"");
}
Node name=first;
Node superClass=first.getNext();
Node members=last;
add(""String_Node_Str"");
if (!name.isEmpty()) {
add(name);
}
maybeAddGenericTypes(first);
if (!superClass.isEmpty()) {
add(""String_Node_Str"");
add(superClass);
}
Node interfaces=(Node)n.getProp(Node.IMPLEMENTS);
if (interfaces != null) {
add(""String_Node_Str"");
Node child=interfaces.getFirstChild();
add(child);
while ((child=child.getNext()) != null) {
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(child);
}
}
add(members);
cc.endClass(context == Context.STATEMENT);
if (classNeedsParens) {
add(""String_Node_Str"");
}
}
break;
case Token.CLASS_MEMBERS:
case Token.INTERFACE_MEMBERS:
case Token.NAMESPACE_ELEMENTS:
cc.beginBlock();
for (Node c=first; c != null; c=c.getNext()) {
add(c);
processEnd(c,context);
cc.endLine();
}
cc.endBlock(false);
break;
case Token.ENUM_MEMBERS:
cc.beginBlock();
for (Node c=first; c != null; c=c.getNext()) {
add(c);
if (c.getNext() != null) {
add(""String_Node_Str"");
}
cc.endLine();
}
cc.endBlock(false);
break;
case Token.GETTER_DEF:
case Token.SETTER_DEF:
case Token.MEMBER_FUNCTION_DEF:
case Token.MEMBER_VARIABLE_DEF:
{
n.getParent().toStringTree();
Preconditions.checkState(n.getParent().isObjectLit() || n.getParent().isClassMembers() || n.getParent().isInterfaceMembers()|| n.getParent().isRecordType()|| n.getParent().isIndexSignature());
maybeAddAccessibilityModifier(n);
if (n.isStaticMember()) {
add(""String_Node_Str"");
}
if (!n.isMemberVariableDef() && n.getFirstChild().isGeneratorFunction()) {
Preconditions.checkState(type == Token.MEMBER_FUNCTION_DEF);
add(""String_Node_Str"");
}
switch (type) {
case Token.GETTER_DEF:
Preconditions.checkState(!first.getSecondChild().hasChildren());
add(""String_Node_Str"");
break;
case Token.SETTER_DEF:
Preconditions.checkState(first.getSecondChild().hasOneChild());
add(""String_Node_Str"");
break;
case Token.MEMBER_FUNCTION_DEF:
case Token.MEMBER_VARIABLE_DEF:
break;
}
String name=n.getString();
if (n.isMemberVariableDef()) {
add(n.getString());
maybeAddOptional(n);
maybeAddTypeDecl(n);
}
 else {
Preconditions.checkState(childCount == 1);
Preconditions.checkState(first.isFunction());
Preconditions.checkState(first.getFirstChild().getString().isEmpty());
Node fn=first;
Node parameters=fn.getSecondChild();
Node body=fn.getLastChild();
if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) && NodeUtil.isLatin(name)) {
add(name);
maybeAddGenericTypes(fn.getFirstChild());
}
 else {
double d=getSimpleNumber(name);
if (!Double.isNaN(d)) {
cc.addNumber(d);
}
 else {
addJsString(n);
}
}
maybeAddOptional(fn);
add(parameters);
maybeAddTypeDecl(fn);
add(body,Context.PRESERVE_BLOCK);
}
break;
}
case Token.SCRIPT:
case Token.BLOCK:
{
if (n.getClass() != Node.class) {
throw new Error(""String_Node_Str"");
}
boolean preserveBlock=context == Context.PRESERVE_BLOCK;
if (preserveBlock) {
cc.beginBlock();
}
boolean preferLineBreaks=type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().isScript());
for (Node c=first; c != null; c=c.getNext()) {
add(c,Context.STATEMENT);
if (NodeUtil.isNameDeclaration(c)) {
cc.endStatement();
}
if (c.isFunction() || c.isClass()) {
cc.maybeLineBreak();
}
if (preferLineBreaks) {
cc.notePreferredLineBreak();
}
}
if (preserveBlock) {
cc.endBlock(cc.breakAfterBlockFor(n,context == Context.STATEMENT));
}
break;
}
case Token.FOR:
if (childCount == 4) {
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
if (NodeUtil.isNameDeclaration(first)) {
add(first,Context.IN_FOR_INIT_CLAUSE);
}
 else {
addExpr(first,0,Context.IN_FOR_INIT_CLAUSE);
}
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
add(first.getNext().getNext());
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
}
 else {
Preconditions.checkState(childCount == 3);
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
}
break;
case Token.FOR_OF:
Preconditions.checkState(childCount == 3);
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
break;
case Token.DO:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
addNonEmptyStatement(first,Context.OTHER,false);
cc.maybeInsertSpace();
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(last);
add(""String_Node_Str"");
cc.endStatement();
break;
case Token.WHILE:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
break;
case Token.EMPTY:
Preconditions.checkState(childCount == 0);
break;
case Token.GETPROP:
{
Preconditions.checkState(childCount == 2,""String_Node_Str"",childCount);
Preconditions.checkState(last.isString(),""String_Node_Str"");
boolean needsParens=(first.isNumber());
if (needsParens) {
add(""String_Node_Str"");
}
addExpr(first,NodeUtil.precedence(type),context);
if (needsParens) {
add(""String_Node_Str"");
}
if (quoteKeywordProperties && TokenStream.isKeyword(last.getString())) {
add(""String_Node_Str"");
add(last);
add(""String_Node_Str"");
}
 else {
add(""String_Node_Str"");
addIdentifier(last.getString());
}
break;
}
case Token.GETELEM:
Preconditions.checkState(childCount == 2,""String_Node_Str"",childCount,n);
addExpr(first,NodeUtil.precedence(type),context);
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
break;
case Token.WITH:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
break;
case Token.INC:
case Token.DEC:
{
Preconditions.checkState(childCount == 1);
String o=type == Token.INC ? ""String_Node_Str"" : ""String_Node_Str"";
boolean postProp=n.getBooleanProp(Node.INCRDECR_PROP);
if (postProp) {
addExpr(first,NodeUtil.precedence(type),context);
cc.addOp(o,false);
}
 else {
cc.addOp(o,false);
add(first);
}
break;
}
case Token.CALL:
if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
add(""String_Node_Str"");
addExpr(first,NodeUtil.precedence(Token.COMMA),Context.OTHER);
add(""String_Node_Str"");
}
 else {
addExpr(first,NodeUtil.precedence(type),context);
}
Node args=first.getNext();
add(""String_Node_Str"");
addList(args);
add(""String_Node_Str"");
break;
case Token.IF:
boolean hasElse=childCount == 3;
boolean ambiguousElseClause=context == Context.BEFORE_DANGLING_ELSE && !hasElse;
if (ambiguousElseClause) {
cc.beginBlock();
}
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
if (childCount == 1) {
break;
}
if (hasElse) {
addNonEmptyStatement(first.getNext(),Context.BEFORE_DANGLING_ELSE,false);
cc.maybeInsertSpace();
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
}
 else {
addNonEmptyStatement(first.getNext(),Context.OTHER,false);
Preconditions.checkState(childCount == 2);
}
if (ambiguousElseClause) {
cc.endBlock();
}
break;
case Token.NULL:
Preconditions.checkState(childCount == 0);
cc.addConstant(""String_Node_Str"");
break;
case Token.THIS:
Preconditions.checkState(childCount == 0);
add(""String_Node_Str"");
break;
case Token.SUPER:
Preconditions.checkState(childCount == 0);
add(""String_Node_Str"");
break;
case Token.YIELD:
add(""String_Node_Str"");
if (n.isYieldFor()) {
Preconditions.checkNotNull(first);
add(""String_Node_Str"");
}
if (first != null) {
cc.maybeInsertSpace();
addExpr(first,NodeUtil.precedence(type),Context.OTHER);
}
break;
case Token.FALSE:
Preconditions.checkState(childCount == 0);
cc.addConstant(""String_Node_Str"");
break;
case Token.TRUE:
Preconditions.checkState(childCount == 0);
cc.addConstant(""String_Node_Str"");
break;
case Token.CONTINUE:
Preconditions.checkState(childCount <= 1);
add(""String_Node_Str"");
if (childCount == 1) {
if (!first.isLabelName()) {
throw new Error(""String_Node_Str"");
}
add(""String_Node_Str"");
add(first);
}
cc.endStatement();
break;
case Token.DEBUGGER:
Preconditions.checkState(childCount == 0);
add(""String_Node_Str"");
cc.endStatement();
break;
case Token.BREAK:
Preconditions.checkState(childCount <= 1);
add(""String_Node_Str"");
if (childCount == 1) {
if (!first.isLabelName()) {
throw new Error(""String_Node_Str"");
}
add(""String_Node_Str"");
add(first);
}
cc.endStatement();
break;
case Token.EXPR_RESULT:
Preconditions.checkState(childCount == 1);
add(first,Context.START_OF_EXPR);
cc.endStatement();
break;
case Token.NEW:
add(""String_Node_Str"");
int precedence=NodeUtil.precedence(type);
if (NodeUtil.containsType(first,Token.CALL,NodeUtil.MATCH_NOT_FUNCTION)) {
precedence=NodeUtil.precedence(first.getType()) + 1;
}
addExpr(first,precedence,Context.OTHER);
Node next=first.getNext();
if (next != null) {
add(""String_Node_Str"");
addList(next);
add(""String_Node_Str"");
}
break;
case Token.STRING_KEY:
addStringKey(n);
break;
case Token.STRING:
Preconditions.checkState(childCount == 0,""String_Node_Str"");
addJsString(n);
break;
case Token.DELPROP:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
add(first);
break;
case Token.OBJECTLIT:
{
boolean needsParens=(context == Context.START_OF_EXPR);
if (needsParens) {
add(""String_Node_Str"");
}
add(""String_Node_Str"");
for (Node c=first; c != null; c=c.getNext()) {
if (c != first) {
cc.listSeparator();
}
Preconditions.checkState(c.isComputedProp() || c.isGetterDef() || c.isSetterDef()|| c.isStringKey()|| c.isMemberFunctionDef());
add(c);
}
add(""String_Node_Str"");
if (needsParens) {
add(""String_Node_Str"");
}
break;
}
case Token.COMPUTED_PROP:
maybeAddAccessibilityModifier(n);
if (n.getBooleanProp(Node.STATIC_MEMBER)) {
add(""String_Node_Str"");
}
if (n.getBooleanProp(Node.COMPUTED_PROP_GETTER)) {
add(""String_Node_Str"");
}
 else if (n.getBooleanProp(Node.COMPUTED_PROP_SETTER)) {
add(""String_Node_Str"");
}
 else if (last.getBooleanProp(Node.GENERATOR_FN)) {
add(""String_Node_Str"");
}
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
maybeAddTypeDecl(n);
if (n.getBooleanProp(Node.COMPUTED_PROP_METHOD) || n.getBooleanProp(Node.COMPUTED_PROP_GETTER) || n.getBooleanProp(Node.COMPUTED_PROP_SETTER)) {
Node function=first.getNext();
Node params=function.getSecondChild();
Node body=function.getLastChild();
add(params);
add(body,Context.PRESERVE_BLOCK);
}
 else {
boolean isInClass=n.getParent().getType() == Token.CLASS_MEMBERS;
Node initializer=first.getNext();
if (initializer != null) {
Preconditions.checkState(!isInClass,""String_Node_Str"");
cc.addOp(""String_Node_Str"",false);
add(initializer);
}
 else {
Preconditions.checkState(n.getBooleanProp(Node.COMPUTED_PROP_VARIABLE),n);
}
}
break;
case Token.OBJECT_PATTERN:
addObjectPattern(n);
maybeAddTypeDecl(n);
break;
case Token.SWITCH:
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
cc.beginBlock();
addAllSiblings(first.getNext());
cc.endBlock(context == Context.STATEMENT);
break;
case Token.CASE:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
add(first);
addCaseBody(last);
break;
case Token.DEFAULT_CASE:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
addCaseBody(first);
break;
case Token.LABEL:
Preconditions.checkState(childCount == 2);
if (!first.isLabelName()) {
throw new Error(""String_Node_Str"");
}
add(first);
add(""String_Node_Str"");
if (!last.isBlock()) {
cc.maybeInsertSpace();
}
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),true);
break;
case Token.CAST:
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
break;
case Token.TAGGED_TEMPLATELIT:
add(first,Context.START_OF_EXPR);
add(first.getNext());
break;
case Token.TEMPLATELIT:
add(""String_Node_Str"");
for (Node c=first; c != null; c=c.getNext()) {
if (c.isString()) {
add(c.getString());
}
 else {
cc.append(""String_Node_Str"");
add(c.getFirstChild(),Context.START_OF_EXPR);
add(""String_Node_Str"");
}
}
add(""String_Node_Str"");
break;
case Token.STRING_TYPE:
add(""String_Node_Str"");
break;
case Token.BOOLEAN_TYPE:
add(""String_Node_Str"");
break;
case Token.NUMBER_TYPE:
add(""String_Node_Str"");
break;
case Token.ANY_TYPE:
add(""String_Node_Str"");
break;
case Token.VOID_TYPE:
add(""String_Node_Str"");
break;
case Token.NAMED_TYPE:
add(first);
break;
case Token.ARRAY_TYPE:
addExpr(first,NodeUtil.precedence(Token.ARRAY_TYPE),context);
add(""String_Node_Str"");
break;
case Token.FUNCTION_TYPE:
Node returnType=first;
add(""String_Node_Str"");
addList(first.getNext());
add(""String_Node_Str"");
cc.addOp(""String_Node_Str"",true);
add(returnType);
break;
case Token.UNION_TYPE:
addList(first,""String_Node_Str"");
break;
case Token.RECORD_TYPE:
add(""String_Node_Str"");
addList(first,false,Context.OTHER,""String_Node_Str"");
add(""String_Node_Str"");
break;
case Token.PARAMETERIZED_TYPE:
add(first);
add(""String_Node_Str"");
addList(first.getNext());
add(""String_Node_Str"");
break;
case Token.GENERIC_TYPE_LIST:
add(""String_Node_Str"");
addList(first,false,Context.STATEMENT,""String_Node_Str"");
add(""String_Node_Str"");
break;
case Token.GENERIC_TYPE:
addIdentifier(n.getString());
if (n.hasChildren()) {
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(n.getFirstChild());
}
break;
case Token.INTERFACE:
{
Preconditions.checkState(childCount == 3);
Node name=first;
Node superTypes=first.getNext();
Node members=last;
add(""String_Node_Str"");
add(name);
maybeAddGenericTypes(name);
if (!superTypes.isEmpty()) {
add(""String_Node_Str"");
Node superType=superTypes.getFirstChild();
add(superType);
while ((superType=superType.getNext()) != null) {
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(superType);
}
}
add(members);
}
break;
case Token.ENUM:
{
Preconditions.checkState(childCount == 2);
Node name=first;
Node members=last;
add(""String_Node_Str"");
add(name);
add(members);
break;
}
case Token.NAMESPACE:
{
Preconditions.checkState(childCount == 2);
Node name=first;
Node elements=last;
add(""String_Node_Str"");
add(name);
add(elements);
break;
}
case Token.TYPE_ALIAS:
add(""String_Node_Str"");
add(n.getString());
cc.addOp(""String_Node_Str"",true);
add(last);
cc.endStatement(true);
break;
case Token.DECLARE:
add(""String_Node_Str"");
add(first);
processEnd(n,context);
break;
case Token.INDEX_SIGNATURE:
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
maybeAddTypeDecl(n);
cc.endStatement(true);
break;
case Token.CALL_SIGNATURE:
if (n.getBooleanProp(Node.CONSTRUCT_SIGNATURE)) {
add(""String_Node_Str"");
}
maybeAddGenericTypes(n);
add(first);
maybeAddTypeDecl(n);
cc.endStatement(true);
break;
default :
throw new RuntimeException(""String_Node_Str"" + Token.name(type) + ""String_Node_Str""+ n.toStringTree());
}
cc.endSourceMapping(n);
}","void add(Node n,Context context){
  if (!cc.continueProcessing()) {
    return;
  }
  if (preserveTypeAnnotations && n.getJSDocInfo() != null) {
    String jsdocAsString=JSDocInfoPrinter.print(n.getJSDocInfo());
    if (!jsdocAsString.equals(""String_Node_Str"")) {
      add(jsdocAsString);
    }
  }
  int type=n.getType();
  String opstr=NodeUtil.opToStr(type);
  int childCount=n.getChildCount();
  Node first=n.getFirstChild();
  Node last=n.getLastChild();
  if (opstr != null && first != last) {
    Preconditions.checkState(childCount == 2,""String_Node_Str"",opstr,childCount);
    int p=NodeUtil.precedence(type);
    Context rhsContext=getContextForNoInOperator(context);
    boolean needsParens=(context == Context.START_OF_EXPR) && first.isObjectPattern();
    if (n.isAssign() && needsParens) {
      add(""String_Node_Str"");
    }
    if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
      addExpr(first,p,context);
      cc.addOp(opstr,true);
      addExpr(last,p,rhsContext);
    }
 else {
      unrollBinaryOperator(n,type,opstr,context,rhsContext,p,p + 1);
    }
    if (n.isAssign() && needsParens) {
      add(""String_Node_Str"");
    }
    return;
  }
  cc.startSourceMapping(n);
switch (type) {
case Token.TRY:
{
      Preconditions.checkState(first.getNext().isBlock() && !first.getNext().hasMoreThanOneChild());
      Preconditions.checkState(childCount >= 2 && childCount <= 3);
      add(""String_Node_Str"");
      add(first,Context.PRESERVE_BLOCK);
      Node catchblock=first.getNext().getFirstChild();
      if (catchblock != null) {
        add(catchblock);
      }
      if (childCount == 3) {
        cc.maybeInsertSpace();
        add(""String_Node_Str"");
        add(last,Context.PRESERVE_BLOCK);
      }
      break;
    }
case Token.CATCH:
  Preconditions.checkState(childCount == 2);
cc.maybeInsertSpace();
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
add(last,Context.PRESERVE_BLOCK);
break;
case Token.THROW:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(first);
cc.endStatement(true);
break;
case Token.RETURN:
add(""String_Node_Str"");
if (childCount == 1) {
cc.maybeInsertSpace();
add(first);
}
 else {
Preconditions.checkState(childCount == 0);
}
cc.endStatement();
break;
case Token.VAR:
if (first != null) {
add(""String_Node_Str"");
addList(first,false,getContextForNoInOperator(context),""String_Node_Str"");
}
break;
case Token.CONST:
add(""String_Node_Str"");
addList(first,false,getContextForNoInOperator(context),""String_Node_Str"");
break;
case Token.LET:
add(""String_Node_Str"");
addList(first,false,getContextForNoInOperator(context),""String_Node_Str"");
break;
case Token.LABEL_NAME:
Preconditions.checkState(!n.getString().isEmpty());
addIdentifier(n.getString());
break;
case Token.DESTRUCTURING_LHS:
add(first);
if (first != last) {
Preconditions.checkState(childCount == 2);
cc.addOp(""String_Node_Str"",true);
add(last);
}
break;
case Token.NAME:
addIdentifier(n.getString());
maybeAddOptional(n);
maybeAddTypeDecl(n);
if (first != null && !first.isEmpty()) {
Preconditions.checkState(childCount == 1);
cc.addOp(""String_Node_Str"",true);
if (first.isComma()) {
addExpr(first,NodeUtil.precedence(Token.ASSIGN),Context.OTHER);
}
 else {
addExpr(first,0,getContextForNoInOperator(context));
}
}
break;
case Token.ARRAYLIT:
add(""String_Node_Str"");
addArrayList(first);
add(""String_Node_Str"");
break;
case Token.ARRAY_PATTERN:
add(""String_Node_Str"");
addArrayList(first);
add(""String_Node_Str"");
maybeAddTypeDecl(n);
break;
case Token.PARAM_LIST:
add(""String_Node_Str"");
addList(first);
add(""String_Node_Str"");
break;
case Token.DEFAULT_VALUE:
add(first);
maybeAddTypeDecl(n);
cc.addOp(""String_Node_Str"",true);
add(first.getNext());
break;
case Token.COMMA:
Preconditions.checkState(childCount == 2);
unrollBinaryOperator(n,Token.COMMA,""String_Node_Str"",context,getContextForNoInOperator(context),0,0);
break;
case Token.NUMBER:
Preconditions.checkState(childCount == 0);
cc.addNumber(n.getDouble());
break;
case Token.TYPEOF:
case Token.VOID:
case Token.NOT:
case Token.BITNOT:
case Token.POS:
{
Preconditions.checkState(childCount == 1);
cc.addOp(NodeUtil.opToStrNoFail(type),false);
addExpr(first,NodeUtil.precedence(type),Context.OTHER);
break;
}
case Token.NEG:
{
Preconditions.checkState(childCount == 1);
if (n.getFirstChild().isNumber()) {
cc.addNumber(-n.getFirstChild().getDouble());
}
 else {
cc.addOp(NodeUtil.opToStrNoFail(type),false);
addExpr(first,NodeUtil.precedence(type),Context.OTHER);
}
break;
}
case Token.HOOK:
{
Preconditions.checkState(childCount == 3);
int p=NodeUtil.precedence(type);
Context rhsContext=getContextForNoInOperator(context);
addExpr(first,p + 1,context);
cc.addOp(""String_Node_Str"",true);
addExpr(first.getNext(),1,rhsContext);
cc.addOp(""String_Node_Str"",true);
addExpr(last,1,rhsContext);
break;
}
case Token.REGEXP:
if (!first.isString() || !last.isString()) {
throw new Error(""String_Node_Str"");
}
String regexp=regexpEscape(first.getString(),outputCharsetEncoder);
if (childCount == 2) {
add(regexp + last.getString());
}
 else {
Preconditions.checkState(childCount == 1);
add(regexp);
}
break;
case Token.FUNCTION:
{
if (n.getClass() != Node.class) {
throw new Error(""String_Node_Str"");
}
Preconditions.checkState(childCount == 3);
if (n.isArrowFunction()) {
addArrowFunction(n,first,last,context);
}
 else {
addFunction(n,first,last,context);
}
break;
}
case Token.REST:
add(""String_Node_Str"");
add(first.getString());
maybeAddTypeDecl(n);
break;
case Token.SPREAD:
add(""String_Node_Str"");
add(n.getFirstChild());
break;
case Token.EXPORT:
add(""String_Node_Str"");
if (n.getBooleanProp(Node.EXPORT_DEFAULT)) {
add(""String_Node_Str"");
}
if (n.getBooleanProp(Node.EXPORT_ALL_FROM)) {
add(""String_Node_Str"");
Preconditions.checkState(first != null && first.isEmpty());
}
 else {
add(first);
}
if (childCount == 2) {
add(""String_Node_Str"");
add(last);
}
processEnd(first,context);
break;
case Token.IMPORT:
add(""String_Node_Str"");
Node second=first.getNext();
if (!first.isEmpty()) {
add(first);
if (!second.isEmpty()) {
cc.listSeparator();
}
}
if (!second.isEmpty()) {
add(second);
}
if (!first.isEmpty() || !second.isEmpty()) {
add(""String_Node_Str"");
}
add(last);
cc.endStatement();
break;
case Token.EXPORT_SPECS:
case Token.IMPORT_SPECS:
add(""String_Node_Str"");
for (Node c=first; c != null; c=c.getNext()) {
if (c != first) {
cc.listSeparator();
}
add(c);
}
add(""String_Node_Str"");
break;
case Token.EXPORT_SPEC:
case Token.IMPORT_SPEC:
add(first);
if (first != last) {
add(""String_Node_Str"");
add(last);
}
break;
case Token.IMPORT_STAR:
add(""String_Node_Str"");
add(""String_Node_Str"");
add(n.getString());
break;
case Token.CLASS:
{
Preconditions.checkState(childCount == 3);
boolean classNeedsParens=(context == Context.START_OF_EXPR);
if (classNeedsParens) {
add(""String_Node_Str"");
}
Node name=first;
Node superClass=first.getNext();
Node members=last;
add(""String_Node_Str"");
if (!name.isEmpty()) {
add(name);
}
maybeAddGenericTypes(first);
if (!superClass.isEmpty()) {
add(""String_Node_Str"");
add(superClass);
}
Node interfaces=(Node)n.getProp(Node.IMPLEMENTS);
if (interfaces != null) {
add(""String_Node_Str"");
Node child=interfaces.getFirstChild();
add(child);
while ((child=child.getNext()) != null) {
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(child);
}
}
add(members);
cc.endClass(context == Context.STATEMENT);
if (classNeedsParens) {
add(""String_Node_Str"");
}
}
break;
case Token.CLASS_MEMBERS:
case Token.INTERFACE_MEMBERS:
case Token.NAMESPACE_ELEMENTS:
cc.beginBlock();
for (Node c=first; c != null; c=c.getNext()) {
add(c);
processEnd(c,context);
cc.endLine();
}
cc.endBlock(false);
break;
case Token.ENUM_MEMBERS:
cc.beginBlock();
for (Node c=first; c != null; c=c.getNext()) {
add(c);
if (c.getNext() != null) {
add(""String_Node_Str"");
}
cc.endLine();
}
cc.endBlock(false);
break;
case Token.GETTER_DEF:
case Token.SETTER_DEF:
case Token.MEMBER_FUNCTION_DEF:
case Token.MEMBER_VARIABLE_DEF:
{
n.getParent().toStringTree();
Preconditions.checkState(n.getParent().isObjectLit() || n.getParent().isClassMembers() || n.getParent().isInterfaceMembers()|| n.getParent().isRecordType()|| n.getParent().isIndexSignature());
maybeAddAccessibilityModifier(n);
if (n.isStaticMember()) {
add(""String_Node_Str"");
}
if (!n.isMemberVariableDef() && n.getFirstChild().isGeneratorFunction()) {
Preconditions.checkState(type == Token.MEMBER_FUNCTION_DEF);
add(""String_Node_Str"");
}
switch (type) {
case Token.GETTER_DEF:
Preconditions.checkState(!first.getSecondChild().hasChildren());
add(""String_Node_Str"");
break;
case Token.SETTER_DEF:
Preconditions.checkState(first.getSecondChild().hasOneChild());
add(""String_Node_Str"");
break;
case Token.MEMBER_FUNCTION_DEF:
case Token.MEMBER_VARIABLE_DEF:
break;
}
String name=n.getString();
if (n.isMemberVariableDef()) {
add(n.getString());
maybeAddOptional(n);
maybeAddTypeDecl(n);
}
 else {
Preconditions.checkState(childCount == 1);
Preconditions.checkState(first.isFunction());
Preconditions.checkState(first.getFirstChild().getString().isEmpty());
Node fn=first;
Node parameters=fn.getSecondChild();
Node body=fn.getLastChild();
if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) && NodeUtil.isLatin(name)) {
add(name);
maybeAddGenericTypes(fn.getFirstChild());
}
 else {
double d=getSimpleNumber(name);
if (!Double.isNaN(d)) {
cc.addNumber(d);
}
 else {
addJsString(n);
}
}
maybeAddOptional(fn);
add(parameters);
maybeAddTypeDecl(fn);
add(body,Context.PRESERVE_BLOCK);
}
break;
}
case Token.SCRIPT:
case Token.BLOCK:
{
if (n.getClass() != Node.class) {
throw new Error(""String_Node_Str"");
}
boolean preserveBlock=context == Context.PRESERVE_BLOCK;
if (preserveBlock) {
cc.beginBlock();
}
boolean preferLineBreaks=type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().isScript());
for (Node c=first; c != null; c=c.getNext()) {
add(c,Context.STATEMENT);
if (NodeUtil.isNameDeclaration(c)) {
cc.endStatement();
}
if (c.isFunction() || c.isClass()) {
cc.maybeLineBreak();
}
if (preferLineBreaks) {
cc.notePreferredLineBreak();
}
}
if (preserveBlock) {
cc.endBlock(cc.breakAfterBlockFor(n,context == Context.STATEMENT));
}
break;
}
case Token.FOR:
if (childCount == 4) {
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
if (NodeUtil.isNameDeclaration(first)) {
add(first,Context.IN_FOR_INIT_CLAUSE);
}
 else {
addExpr(first,0,Context.IN_FOR_INIT_CLAUSE);
}
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
add(first.getNext().getNext());
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
}
 else {
Preconditions.checkState(childCount == 3);
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
}
break;
case Token.FOR_OF:
Preconditions.checkState(childCount == 3);
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
break;
case Token.DO:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
addNonEmptyStatement(first,Context.OTHER,false);
cc.maybeInsertSpace();
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(last);
add(""String_Node_Str"");
cc.endStatement();
break;
case Token.WHILE:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
break;
case Token.EMPTY:
Preconditions.checkState(childCount == 0);
break;
case Token.GETPROP:
{
Preconditions.checkState(childCount == 2,""String_Node_Str"",childCount);
Preconditions.checkState(last.isString(),""String_Node_Str"");
boolean needsParens=(first.isNumber());
if (needsParens) {
add(""String_Node_Str"");
}
addExpr(first,NodeUtil.precedence(type),context);
if (needsParens) {
add(""String_Node_Str"");
}
if (quoteKeywordProperties && TokenStream.isKeyword(last.getString())) {
add(""String_Node_Str"");
add(last);
add(""String_Node_Str"");
}
 else {
add(""String_Node_Str"");
addIdentifier(last.getString());
}
break;
}
case Token.GETELEM:
Preconditions.checkState(childCount == 2,""String_Node_Str"",childCount,n);
addExpr(first,NodeUtil.precedence(type),context);
add(""String_Node_Str"");
add(first.getNext());
add(""String_Node_Str"");
break;
case Token.WITH:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
break;
case Token.INC:
case Token.DEC:
{
Preconditions.checkState(childCount == 1);
String o=type == Token.INC ? ""String_Node_Str"" : ""String_Node_Str"";
boolean postProp=n.getBooleanProp(Node.INCRDECR_PROP);
if (postProp) {
addExpr(first,NodeUtil.precedence(type),context);
cc.addOp(o,false);
}
 else {
cc.addOp(o,false);
add(first);
}
break;
}
case Token.CALL:
if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
add(""String_Node_Str"");
addExpr(first,NodeUtil.precedence(Token.COMMA),Context.OTHER);
add(""String_Node_Str"");
}
 else {
addExpr(first,NodeUtil.precedence(type),context);
}
Node args=first.getNext();
add(""String_Node_Str"");
addList(args);
add(""String_Node_Str"");
break;
case Token.IF:
boolean hasElse=childCount == 3;
boolean ambiguousElseClause=context == Context.BEFORE_DANGLING_ELSE && !hasElse;
if (ambiguousElseClause) {
cc.beginBlock();
}
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
if (childCount == 1) {
break;
}
if (hasElse) {
addNonEmptyStatement(first.getNext(),Context.BEFORE_DANGLING_ELSE,false);
cc.maybeInsertSpace();
add(""String_Node_Str"");
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),false);
}
 else {
addNonEmptyStatement(first.getNext(),Context.OTHER,false);
Preconditions.checkState(childCount == 2);
}
if (ambiguousElseClause) {
cc.endBlock();
}
break;
case Token.NULL:
Preconditions.checkState(childCount == 0);
cc.addConstant(""String_Node_Str"");
break;
case Token.THIS:
Preconditions.checkState(childCount == 0);
add(""String_Node_Str"");
break;
case Token.SUPER:
Preconditions.checkState(childCount == 0);
add(""String_Node_Str"");
break;
case Token.YIELD:
add(""String_Node_Str"");
if (n.isYieldFor()) {
Preconditions.checkNotNull(first);
add(""String_Node_Str"");
}
if (first != null) {
cc.maybeInsertSpace();
addExpr(first,NodeUtil.precedence(type),Context.OTHER);
}
break;
case Token.FALSE:
Preconditions.checkState(childCount == 0);
cc.addConstant(""String_Node_Str"");
break;
case Token.TRUE:
Preconditions.checkState(childCount == 0);
cc.addConstant(""String_Node_Str"");
break;
case Token.CONTINUE:
Preconditions.checkState(childCount <= 1);
add(""String_Node_Str"");
if (childCount == 1) {
if (!first.isLabelName()) {
throw new Error(""String_Node_Str"");
}
add(""String_Node_Str"");
add(first);
}
cc.endStatement();
break;
case Token.DEBUGGER:
Preconditions.checkState(childCount == 0);
add(""String_Node_Str"");
cc.endStatement();
break;
case Token.BREAK:
Preconditions.checkState(childCount <= 1);
add(""String_Node_Str"");
if (childCount == 1) {
if (!first.isLabelName()) {
throw new Error(""String_Node_Str"");
}
add(""String_Node_Str"");
add(first);
}
cc.endStatement();
break;
case Token.EXPR_RESULT:
Preconditions.checkState(childCount == 1);
add(first,Context.START_OF_EXPR);
cc.endStatement();
break;
case Token.NEW:
add(""String_Node_Str"");
int precedence=NodeUtil.precedence(type);
if (NodeUtil.containsType(first,Token.CALL,NodeUtil.MATCH_NOT_FUNCTION)) {
precedence=NodeUtil.precedence(first.getType()) + 1;
}
addExpr(first,precedence,Context.OTHER);
Node next=first.getNext();
if (next != null) {
add(""String_Node_Str"");
addList(next);
add(""String_Node_Str"");
}
break;
case Token.STRING_KEY:
addStringKey(n);
break;
case Token.STRING:
Preconditions.checkState(childCount == 0,""String_Node_Str"");
addJsString(n);
break;
case Token.DELPROP:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
add(first);
break;
case Token.OBJECTLIT:
{
boolean needsParens=(context == Context.START_OF_EXPR);
if (needsParens) {
add(""String_Node_Str"");
}
add(""String_Node_Str"");
for (Node c=first; c != null; c=c.getNext()) {
if (c != first) {
cc.listSeparator();
}
Preconditions.checkState(c.isComputedProp() || c.isGetterDef() || c.isSetterDef()|| c.isStringKey()|| c.isMemberFunctionDef());
add(c);
}
add(""String_Node_Str"");
if (needsParens) {
add(""String_Node_Str"");
}
break;
}
case Token.COMPUTED_PROP:
maybeAddAccessibilityModifier(n);
if (n.getBooleanProp(Node.STATIC_MEMBER)) {
add(""String_Node_Str"");
}
if (n.getBooleanProp(Node.COMPUTED_PROP_GETTER)) {
add(""String_Node_Str"");
}
 else if (n.getBooleanProp(Node.COMPUTED_PROP_SETTER)) {
add(""String_Node_Str"");
}
 else if (last.getBooleanProp(Node.GENERATOR_FN)) {
add(""String_Node_Str"");
}
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
maybeAddTypeDecl(n);
if (n.getBooleanProp(Node.COMPUTED_PROP_METHOD) || n.getBooleanProp(Node.COMPUTED_PROP_GETTER) || n.getBooleanProp(Node.COMPUTED_PROP_SETTER)) {
Node function=first.getNext();
Node params=function.getSecondChild();
Node body=function.getLastChild();
add(params);
add(body,Context.PRESERVE_BLOCK);
}
 else {
boolean isInClass=n.getParent().getType() == Token.CLASS_MEMBERS;
Node initializer=first.getNext();
if (initializer != null) {
Preconditions.checkState(!isInClass,""String_Node_Str"");
cc.addOp(""String_Node_Str"",false);
add(initializer);
}
 else {
Preconditions.checkState(n.getBooleanProp(Node.COMPUTED_PROP_VARIABLE),n);
}
}
break;
case Token.OBJECT_PATTERN:
addObjectPattern(n);
maybeAddTypeDecl(n);
break;
case Token.SWITCH:
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
cc.beginBlock();
addAllSiblings(first.getNext());
cc.endBlock(context == Context.STATEMENT);
break;
case Token.CASE:
Preconditions.checkState(childCount == 2);
add(""String_Node_Str"");
add(first);
addCaseBody(last);
break;
case Token.DEFAULT_CASE:
Preconditions.checkState(childCount == 1);
add(""String_Node_Str"");
addCaseBody(first);
break;
case Token.LABEL:
Preconditions.checkState(childCount == 2);
if (!first.isLabelName()) {
throw new Error(""String_Node_Str"");
}
add(first);
add(""String_Node_Str"");
if (!last.isBlock()) {
cc.maybeInsertSpace();
}
addNonEmptyStatement(last,getContextForNonEmptyExpression(context),true);
break;
case Token.CAST:
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
break;
case Token.TAGGED_TEMPLATELIT:
add(first,Context.START_OF_EXPR);
add(first.getNext());
break;
case Token.TEMPLATELIT:
add(""String_Node_Str"");
for (Node c=first; c != null; c=c.getNext()) {
if (c.isString()) {
add(c.getString());
}
 else {
cc.append(""String_Node_Str"");
add(c.getFirstChild(),Context.START_OF_EXPR);
add(""String_Node_Str"");
}
}
add(""String_Node_Str"");
break;
case Token.STRING_TYPE:
add(""String_Node_Str"");
break;
case Token.BOOLEAN_TYPE:
add(""String_Node_Str"");
break;
case Token.NUMBER_TYPE:
add(""String_Node_Str"");
break;
case Token.ANY_TYPE:
add(""String_Node_Str"");
break;
case Token.VOID_TYPE:
add(""String_Node_Str"");
break;
case Token.NAMED_TYPE:
add(first);
break;
case Token.ARRAY_TYPE:
addExpr(first,NodeUtil.precedence(Token.ARRAY_TYPE),context);
add(""String_Node_Str"");
break;
case Token.FUNCTION_TYPE:
Node returnType=first;
add(""String_Node_Str"");
addList(first.getNext());
add(""String_Node_Str"");
cc.addOp(""String_Node_Str"",true);
add(returnType);
break;
case Token.UNION_TYPE:
addList(first,""String_Node_Str"");
break;
case Token.RECORD_TYPE:
add(""String_Node_Str"");
addList(first,false,Context.OTHER,""String_Node_Str"");
add(""String_Node_Str"");
break;
case Token.PARAMETERIZED_TYPE:
add(first);
add(""String_Node_Str"");
addList(first.getNext());
add(""String_Node_Str"");
break;
case Token.GENERIC_TYPE_LIST:
add(""String_Node_Str"");
addList(first,false,Context.STATEMENT,""String_Node_Str"");
add(""String_Node_Str"");
break;
case Token.GENERIC_TYPE:
addIdentifier(n.getString());
if (n.hasChildren()) {
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(n.getFirstChild());
}
break;
case Token.INTERFACE:
{
Preconditions.checkState(childCount == 3);
Node name=first;
Node superTypes=first.getNext();
Node members=last;
add(""String_Node_Str"");
add(name);
maybeAddGenericTypes(name);
if (!superTypes.isEmpty()) {
add(""String_Node_Str"");
Node superType=superTypes.getFirstChild();
add(superType);
while ((superType=superType.getNext()) != null) {
add(""String_Node_Str"");
cc.maybeInsertSpace();
add(superType);
}
}
add(members);
}
break;
case Token.ENUM:
{
Preconditions.checkState(childCount == 2);
Node name=first;
Node members=last;
add(""String_Node_Str"");
add(name);
add(members);
break;
}
case Token.NAMESPACE:
{
Preconditions.checkState(childCount == 2);
Node name=first;
Node elements=last;
add(""String_Node_Str"");
add(name);
add(elements);
break;
}
case Token.TYPE_ALIAS:
add(""String_Node_Str"");
add(n.getString());
cc.addOp(""String_Node_Str"",true);
add(last);
cc.endStatement(true);
break;
case Token.DECLARE:
add(""String_Node_Str"");
add(first);
processEnd(n,context);
break;
case Token.INDEX_SIGNATURE:
add(""String_Node_Str"");
add(first);
add(""String_Node_Str"");
maybeAddTypeDecl(n);
cc.endStatement(true);
break;
case Token.CALL_SIGNATURE:
if (n.getBooleanProp(Node.CONSTRUCT_SIGNATURE)) {
add(""String_Node_Str"");
}
maybeAddGenericTypes(n);
add(first);
maybeAddTypeDecl(n);
cc.endStatement(true);
break;
default :
throw new RuntimeException(""String_Node_Str"" + Token.name(type) + ""String_Node_Str""+ n.toStringTree());
}
cc.endSourceMapping(n);
}",0.9974285976673708
19469,"/** 
 * Appends the exported function and all paths necessary for the path to be declared. For example, for a property ""a.b.c"", the initializers for paths ""a"", ""a.b"" will be appended (if they have not already) and a.b.c will be initialized with the exported version of the function: <pre> var a = {}; a.b = {}; a.b.c = function(x,y) { } </pre>
 */
void appendExtern(String path,Node valueToExport){
  List<String> pathPrefixes=computePathPrefixes(path);
  for (int i=0; i < pathPrefixes.size(); ++i) {
    String pathPrefix=pathPrefixes.get(i);
    boolean isCompletePathPrefix=(i == pathPrefixes.size() - 1);
    boolean skipPathPrefix=pathPrefix.endsWith(""String_Node_Str"") || (alreadyExportedPaths.contains(pathPrefix) && !isCompletePathPrefix);
    if (!skipPathPrefix) {
      Node initializer;
      if (isCompletePathPrefix && valueToExport != null) {
        if (valueToExport.isFunction()) {
          initializer=createExternFunction(valueToExport);
        }
 else {
          Preconditions.checkState(valueToExport.isObjectLit());
          initializer=createExternObjectLit(valueToExport);
        }
      }
 else {
        initializer=IR.empty();
      }
      appendPathDefinition(pathPrefix,initializer);
    }
  }
}","/** 
 * Appends the exported function and all paths necessary for the path to be declared. For example, for a property ""a.b.c"", the initializers for paths ""a"", ""a.b"" will be appended (if they have not already) and a.b.c will be initialized with the exported version of the function: <pre> var a = {}; a.b = {}; a.b.c = function(x,y) { } </pre>
 */
void appendExtern(String path,Node valueToExport){
  List<String> pathPrefixes=computePathPrefixes(path);
  for (int i=0; i < pathPrefixes.size(); ++i) {
    String pathPrefix=pathPrefixes.get(i);
    boolean isCompletePathPrefix=(i == pathPrefixes.size() - 1);
    boolean skipPathPrefix=pathPrefix.endsWith(""String_Node_Str"") || (alreadyExportedPaths.contains(pathPrefix) && !isCompletePathPrefix);
    boolean exportedValueDefinesNewType=false;
    if (valueToExport != null) {
      JSDocInfo jsdoc=NodeUtil.getBestJSDocInfo(valueToExport);
      if (jsdoc != null && jsdoc.containsTypeDefinition()) {
        exportedValueDefinesNewType=true;
      }
    }
    if (!skipPathPrefix) {
      Node initializer;
      JSDocInfo jsdoc=null;
      if (isCompletePathPrefix && valueToExport != null) {
        if (valueToExport.isFunction()) {
          initializer=createExternFunction(valueToExport);
        }
 else {
          Preconditions.checkState(valueToExport.isObjectLit());
          initializer=createExternObjectLit(valueToExport);
        }
      }
 else       if (!isCompletePathPrefix && exportedValueDefinesNewType) {
        jsdoc=buildNamespaceJSDoc();
        initializer=createExternObjectLit(IR.objectlit());
        initializer.setJSDocInfo(null);
      }
 else {
        initializer=IR.empty();
      }
      appendPathDefinition(pathPrefix,initializer,jsdoc);
    }
  }
}",0.825546218487395
19470,"/** 
 * Given a function to export, create the empty function that will be put in the externs file. This extern function should have the same type as the original function and the same parameter name but no function body. We create a warning here if the the function to export is missing parameter or return types.
 */
private Node createExternFunction(Node exportedFunction){
  Node paramList=NodeUtil.getFunctionParameters(exportedFunction).cloneTree();
  Node param=paramList.getFirstChild();
  while (param != null && param.isName()) {
    String originalName=param.getOriginalName();
    if (originalName != null) {
      param.setString(originalName);
    }
    param=param.getNext();
  }
  Node externFunction=IR.function(IR.name(""String_Node_Str""),paramList,IR.block());
  externFunction.setJSType(exportedFunction.getJSType());
  return externFunction;
}","/** 
 * Given a function to export, create the empty function that will be put in the externs file. This extern function should have the same type as the original function and the same parameter name but no function body. We create a warning here if the the function to export is missing parameter or return types.
 */
private Node createExternFunction(Node exportedFunction){
  Node paramList=NodeUtil.getFunctionParameters(exportedFunction).cloneTree();
  Node param=paramList.getFirstChild();
  while (param != null && param.isName()) {
    String originalName=param.getOriginalName();
    if (originalName != null) {
      param.setString(originalName);
    }
    param=param.getNext();
  }
  Node externFunction=IR.function(IR.name(""String_Node_Str""),paramList,IR.block());
  if (exportedFunction.getJSType() != null) {
    externFunction.setJSType(exportedFunction.getJSType());
    deleteInlineJsdocs(externFunction);
  }
  return externFunction;
}",0.8888888888888888
19471,"private void appendPathDefinition(String path,Node initializer){
  Node pathDefinition;
  if (!path.contains(""String_Node_Str"")) {
    if (initializer.isEmpty()) {
      pathDefinition=IR.var(IR.name(path));
    }
 else {
      pathDefinition=NodeUtil.newVarNode(path,initializer);
    }
  }
 else {
    Node qualifiedPath=NodeUtil.newQName(compiler,path);
    if (initializer.isEmpty()) {
      pathDefinition=NodeUtil.newExpr(qualifiedPath);
    }
 else {
      pathDefinition=NodeUtil.newExpr(IR.assign(qualifiedPath,initializer));
    }
  }
  externsRoot.addChildToBack(pathDefinition);
  alreadyExportedPaths.add(path);
}","private void appendPathDefinition(String path,Node initializer,JSDocInfo jsdoc){
  Node pathDefinition;
  if (!path.contains(""String_Node_Str"")) {
    if (initializer.isEmpty()) {
      pathDefinition=IR.var(IR.name(path));
    }
 else {
      pathDefinition=NodeUtil.newVarNode(path,initializer);
    }
  }
 else {
    Node qualifiedPath=NodeUtil.newQName(compiler,path);
    if (initializer.isEmpty()) {
      pathDefinition=NodeUtil.newExpr(qualifiedPath);
    }
 else {
      pathDefinition=NodeUtil.newExpr(IR.assign(qualifiedPath,initializer));
    }
  }
  if (jsdoc != null) {
    if (pathDefinition.isExprResult()) {
      pathDefinition.getFirstChild().setJSDocInfo(jsdoc);
    }
 else {
      Preconditions.checkState(pathDefinition.isVar());
      pathDefinition.setJSDocInfo(jsdoc);
    }
  }
  externsRoot.addChildToBack(pathDefinition);
  alreadyExportedPaths.add(path);
}",0.828042328042328
19472,"public static String print(JSDocInfo info){
  boolean multiline=false;
  List<String> parts=new ArrayList<>();
  parts.add(""String_Node_Str"");
  if (info.isExport()) {
    parts.add(""String_Node_Str"");
  }
 else   if (info.getVisibility() != null && info.getVisibility() != Visibility.INHERITED) {
    parts.add(""String_Node_Str"" + info.getVisibility().toString().toLowerCase());
  }
  if (info.isConstant() && !info.isDefine()) {
    parts.add(""String_Node_Str"");
  }
  if (info.makesDicts()) {
    parts.add(""String_Node_Str"");
  }
  if (info.makesStructs()) {
    parts.add(""String_Node_Str"");
  }
  if (info.makesUnrestricted()) {
    parts.add(""String_Node_Str"");
  }
  if (info.isConstructor()) {
    parts.add(""String_Node_Str"");
  }
  if (info.isInterface() && !info.usesImplicitMatch()) {
    parts.add(""String_Node_Str"");
  }
  if (info.isInterface() && info.usesImplicitMatch()) {
    parts.add(""String_Node_Str"");
  }
  if (info.hasBaseType()) {
    multiline=true;
    Node typeNode=stripBang(info.getBaseType().getRoot());
    parts.add(buildAnnotationWithType(""String_Node_Str"",typeNode));
  }
  for (  JSTypeExpression type : info.getExtendedInterfaces()) {
    multiline=true;
    Node typeNode=stripBang(type.getRoot());
    parts.add(buildAnnotationWithType(""String_Node_Str"",typeNode));
  }
  for (  JSTypeExpression type : info.getImplementedInterfaces()) {
    multiline=true;
    Node typeNode=stripBang(type.getRoot());
    parts.add(buildAnnotationWithType(""String_Node_Str"",typeNode));
  }
  if (info.hasThisType()) {
    multiline=true;
    Node typeNode=stripBang(info.getThisType().getRoot());
    parts.add(buildAnnotationWithType(""String_Node_Str"",typeNode));
  }
  if (info.getParameterCount() > 0) {
    multiline=true;
    for (    String name : info.getParameterNames()) {
      parts.add(""String_Node_Str"" + buildParamType(name,info.getParameterType(name)));
    }
  }
  if (info.hasReturnType()) {
    multiline=true;
    parts.add(buildAnnotationWithType(""String_Node_Str"",info.getReturnType()));
  }
  if (!info.getThrownTypes().isEmpty()) {
    parts.add(buildAnnotationWithType(""String_Node_Str"",info.getThrownTypes().get(0)));
  }
  ImmutableList<String> names=info.getTemplateTypeNames();
  if (!names.isEmpty()) {
    parts.add(""String_Node_Str"" + Joiner.on(',').join(names));
    multiline=true;
  }
  if (info.isOverride()) {
    parts.add(""String_Node_Str"");
  }
  if (info.hasType() && !info.isDefine()) {
    if (info.isInlineType()) {
      parts.add(typeNode(info.getType().getRoot()));
    }
 else {
      parts.add(buildAnnotationWithType(""String_Node_Str"",info.getType()));
    }
  }
  if (info.isDefine()) {
    parts.add(buildAnnotationWithType(""String_Node_Str"",info.getType()));
  }
  if (info.hasTypedefType()) {
    parts.add(buildAnnotationWithType(""String_Node_Str"",info.getTypedefType()));
  }
  if (info.hasEnumParameterType()) {
    parts.add(buildAnnotationWithType(""String_Node_Str"",info.getEnumParameterType()));
  }
  Set<String> suppressions=info.getSuppressions();
  if (!suppressions.isEmpty()) {
    parts.add(""String_Node_Str"" + Joiner.on(',').join(suppressions) + ""String_Node_Str"");
    multiline=true;
  }
  if (info.isDeprecated()) {
    parts.add(""String_Node_Str"" + info.getDeprecationReason());
    multiline=true;
  }
  parts.add(""String_Node_Str"");
  StringBuilder sb=new StringBuilder();
  if (multiline) {
    Joiner.on(""String_Node_Str"").appendTo(sb,parts);
  }
 else {
    Joiner.on(""String_Node_Str"").appendTo(sb,parts);
  }
  sb.append((multiline) ? ""String_Node_Str"" : ""String_Node_Str"");
  return sb.toString();
}","public static String print(JSDocInfo info){
  boolean multiline=false;
  List<String> parts=new ArrayList<>();
  parts.add(""String_Node_Str"");
  if (info.isExport()) {
    parts.add(""String_Node_Str"");
  }
 else   if (info.getVisibility() != null && info.getVisibility() != Visibility.INHERITED) {
    parts.add(""String_Node_Str"" + info.getVisibility().toString().toLowerCase());
  }
  if (info.isConstant() && !info.isDefine()) {
    parts.add(""String_Node_Str"");
  }
  if (info.makesDicts()) {
    parts.add(""String_Node_Str"");
  }
  if (info.makesStructs()) {
    parts.add(""String_Node_Str"");
  }
  if (info.makesUnrestricted()) {
    parts.add(""String_Node_Str"");
  }
  if (info.isConstructor()) {
    parts.add(""String_Node_Str"");
  }
  if (info.isInterface() && !info.usesImplicitMatch()) {
    parts.add(""String_Node_Str"");
  }
  if (info.isInterface() && info.usesImplicitMatch()) {
    parts.add(""String_Node_Str"");
  }
  if (info.hasBaseType()) {
    multiline=true;
    Node typeNode=stripBang(info.getBaseType().getRoot());
    parts.add(buildAnnotationWithType(""String_Node_Str"",typeNode));
  }
  for (  JSTypeExpression type : info.getExtendedInterfaces()) {
    multiline=true;
    Node typeNode=stripBang(type.getRoot());
    parts.add(buildAnnotationWithType(""String_Node_Str"",typeNode));
  }
  for (  JSTypeExpression type : info.getImplementedInterfaces()) {
    multiline=true;
    Node typeNode=stripBang(type.getRoot());
    parts.add(buildAnnotationWithType(""String_Node_Str"",typeNode));
  }
  if (info.hasThisType()) {
    multiline=true;
    Node typeNode=stripBang(info.getThisType().getRoot());
    parts.add(buildAnnotationWithType(""String_Node_Str"",typeNode));
  }
  if (info.getParameterCount() > 0) {
    multiline=true;
    for (    String name : info.getParameterNames()) {
      parts.add(""String_Node_Str"" + buildParamType(name,info.getParameterType(name)));
    }
  }
  if (info.hasReturnType()) {
    multiline=true;
    parts.add(buildAnnotationWithType(""String_Node_Str"",info.getReturnType()));
  }
  if (!info.getThrownTypes().isEmpty()) {
    parts.add(buildAnnotationWithType(""String_Node_Str"",info.getThrownTypes().get(0)));
  }
  ImmutableList<String> names=info.getTemplateTypeNames();
  if (!names.isEmpty()) {
    parts.add(""String_Node_Str"" + Joiner.on(',').join(names));
    multiline=true;
  }
  if (info.isOverride()) {
    parts.add(""String_Node_Str"");
  }
  if (info.hasType() && !info.isDefine()) {
    if (info.isInlineType()) {
      parts.add(typeNode(info.getType().getRoot()));
    }
 else {
      parts.add(buildAnnotationWithType(""String_Node_Str"",info.getType()));
    }
  }
  if (info.isDefine()) {
    parts.add(buildAnnotationWithType(""String_Node_Str"",info.getType()));
  }
  if (info.hasTypedefType()) {
    parts.add(buildAnnotationWithType(""String_Node_Str"",info.getTypedefType()));
  }
  if (info.hasEnumParameterType()) {
    parts.add(buildAnnotationWithType(""String_Node_Str"",info.getEnumParameterType()));
  }
  Set<String> suppressions=info.getSuppressions();
  if (!suppressions.isEmpty()) {
    String[] arr=suppressions.toArray(new String[0]);
    Arrays.sort(arr,Ordering.<String>natural());
    parts.add(""String_Node_Str"" + Joiner.on(',').join(Arrays.asList(arr)) + ""String_Node_Str"");
    multiline=true;
  }
  if (info.isDeprecated()) {
    parts.add(""String_Node_Str"" + info.getDeprecationReason());
    multiline=true;
  }
  parts.add(""String_Node_Str"");
  StringBuilder sb=new StringBuilder();
  if (multiline) {
    Joiner.on(""String_Node_Str"").appendTo(sb,parts);
  }
 else {
    Joiner.on(""String_Node_Str"").appendTo(sb,parts);
  }
  sb.append((multiline) ? ""String_Node_Str"" : ""String_Node_Str"");
  return sb.toString();
}",0.981823151564849
19473,"@Override void add(Node n,Context context){
  Node parent=n.getParent();
  if (parent != null && (parent.isBlock() || parent.isScript())) {
    if (n.isFunction()) {
      add(getFunctionAnnotation(n));
    }
 else     if (n.isExprResult() && n.getFirstChild().isAssign()) {
      Node rhs=n.getFirstChild().getLastChild();
      add(getTypeAnnotation(rhs));
    }
 else     if (n.isVar() && n.getFirstFirstChild() != null) {
      add(getTypeAnnotation(n.getFirstFirstChild()));
    }
  }
  super.add(n,context);
}","@Override void add(Node n,Context context){
  Node parent=n.getParent();
  if (parent != null && (parent.isBlock() || parent.isScript())) {
    if (n.isFunction()) {
      add(getFunctionAnnotation(n));
    }
 else     if (n.isExprResult() && n.getFirstChild().isAssign()) {
      Node assign=n.getFirstChild();
      if (NodeUtil.isNamespaceDecl(assign.getFirstChild())) {
        add(JSDocInfoPrinter.print(assign.getJSDocInfo()));
      }
 else {
        Node rhs=assign.getLastChild();
        add(getTypeAnnotation(rhs));
      }
    }
 else     if (n.isVar() && n.getFirstFirstChild() != null) {
      if (NodeUtil.isNamespaceDecl(n.getFirstChild())) {
        add(JSDocInfoPrinter.print(n.getJSDocInfo()));
      }
 else {
        add(getTypeAnnotation(n.getFirstFirstChild()));
      }
    }
  }
  super.add(n,context);
}",0.7529761904761905
19474,"void recordPassStart(String passName,boolean isOneTime){
  currentPass.push(new Stats(passName,isOneTime));
  codeChange.reset();
}","void recordPassStart(String passName,boolean isOneTime){
  currentPass.push(new Stats(passName,isOneTime));
  if (!passName.equals(""String_Node_Str"")) {
    codeChange.reset();
  }
}",0.8370607028753994
19475,"/** 
 * Gets the r-value (or intializer) of a node returned by getBestLValue. 
 */
static Node getRValueOfLValue(Node n){
  Node parent=n.getParent();
switch (parent.getType()) {
case Token.ASSIGN:
    return n.getNext();
case Token.VAR:
case Token.LET:
case Token.CONST:
case Token.OBJECTLIT:
  return n.getFirstChild();
case Token.FUNCTION:
case Token.CLASS:
return parent;
}
return null;
}","/** 
 * Gets the r-value (or intializer) of a node returned by getBestLValue. 
 */
static Node getRValueOfLValue(Node n){
  Node parent=n.getParent();
switch (parent.getType()) {
case Token.ASSIGN:
case Token.ASSIGN_BITOR:
case Token.ASSIGN_BITXOR:
case Token.ASSIGN_BITAND:
case Token.ASSIGN_LSH:
case Token.ASSIGN_RSH:
case Token.ASSIGN_URSH:
case Token.ASSIGN_ADD:
case Token.ASSIGN_SUB:
case Token.ASSIGN_MUL:
case Token.ASSIGN_DIV:
case Token.ASSIGN_MOD:
    return n.getNext();
case Token.VAR:
case Token.LET:
case Token.CONST:
case Token.OBJECTLIT:
  return n.getFirstChild();
case Token.FUNCTION:
case Token.CLASS:
return parent;
}
return null;
}",0.7495219885277247
19476,"/** 
 * Verifies that the compiler pass's JS output matches the expected output and (optionally) that an expected warning is issued. Or, if an error is expected, this method just verifies that the error is encountered.
 * @param compiler A compiler that has been initialized via{@link Compiler#init}
 * @param expected Expected output, or null if an error is expected
 * @param error Expected error, or null if no error is expected
 * @param warning Expected warning, or null if no warning is expected
 * @param description The description of the expected warning,or null if no warning is expected or if the warning's description should not be examined
 */
private void test(Compiler compiler,List<SourceFile> expected,DiagnosticType error,DiagnosticType warning,String description){
  RecentChange recentChange=new RecentChange();
  compiler.addChangeHandler(recentChange);
  Node root=compiler.parseInputs();
  String errorMsg=LINE_JOINER.join(compiler.getErrors());
  if (root == null && expected == null && error != null) {
    assert_().withFailureMessage(""String_Node_Str"" + errorMsg).that(compiler.getErrorCount()).isEqualTo(1);
    JSError actualError=compiler.getErrors()[0];
    assert_().withFailureMessage(""String_Node_Str"" + errorMsg).that(actualError.getType()).isEqualTo(error);
    if (description != null) {
      assertThat(actualError.description).isEqualTo(description);
    }
    return;
  }
  assert_().withFailureMessage(""String_Node_Str"" + errorMsg).that(root).isNotNull();
  if (!expectParseWarningsThisTest) {
    assertEquals(""String_Node_Str"" + LINE_JOINER.join(compiler.getWarnings()),0,compiler.getWarnings().length);
  }
  if (astValidationEnabled) {
    (new AstValidator(compiler)).validateRoot(root);
  }
  Node externsRoot=root.getFirstChild();
  Node mainRoot=root.getLastChild();
  Node rootClone=root.cloneTree();
  Node externsRootClone=rootClone.getFirstChild();
  Node mainRootClone=rootClone.getLastChild();
  Map<Node,Node> mtoc=NodeUtil.mapMainToClone(mainRoot,mainRootClone);
  int numRepetitions=getNumRepetitions();
  ErrorManager[] errorManagers=new ErrorManager[numRepetitions];
  int aggregateWarningCount=0;
  List<JSError> aggregateWarnings=new ArrayList<>();
  boolean hasCodeChanged=false;
  for (int i=0; i < numRepetitions; ++i) {
    if (compiler.getErrorCount() == 0) {
      errorManagers[i]=new BlackHoleErrorManager();
      compiler.setErrorManager(errorManagers[i]);
      if (rewriteClosureCode && i == 0) {
        new ClosureRewriteClass(compiler).process(null,mainRoot);
        new ClosureRewriteModule(compiler).process(null,mainRoot);
        new ScopedAliases(compiler,null,CompilerOptions.NULL_ALIAS_TRANSFORMATION_HANDLER).process(null,mainRoot);
        hasCodeChanged=hasCodeChanged || recentChange.hasCodeChanged();
      }
      if (closurePassEnabled && i == 0) {
        recentChange.reset();
        new ProcessClosurePrimitives(compiler,null,CheckLevel.ERROR,false).process(null,mainRoot);
        hasCodeChanged=hasCodeChanged || recentChange.hasCodeChanged();
      }
      if (transpileEnabled && i == 0) {
        recentChange.reset();
        transpileToEs5(compiler,externsRoot,mainRoot);
        hasCodeChanged=hasCodeChanged || recentChange.hasCodeChanged();
      }
      if (!runTypeCheckAfterProcessing && typeCheckEnabled && i == 0) {
        TypeCheck check=createTypeCheck(compiler,reportMissingOverrideCheckLevel);
        check.processForTesting(externsRoot,mainRoot);
      }
 else       if (!this.runNTIAfterProcessing && this.newTypeInferenceEnabled && i == 0) {
        runNewTypeInference(compiler,externsRoot,mainRoot);
      }
      if (normalizeEnabled && i == 0) {
        normalizeActualCode(compiler,externsRoot,mainRoot);
      }
      if (enableInferConsts && i == 0) {
        new InferConsts(compiler).process(externsRoot,mainRoot);
      }
      if (computeSideEffects && i == 0) {
        PureFunctionIdentifier.Driver mark=new PureFunctionIdentifier.Driver(compiler,null,false);
        mark.process(externsRoot,mainRoot);
      }
      if (markNoSideEffects && i == 0) {
        MarkNoSideEffectCalls mark=new MarkNoSideEffectCalls(compiler);
        mark.process(externsRoot,mainRoot);
      }
      if (gatherExternPropertiesEnabled && i == 0) {
        (new GatherExternProperties(compiler)).process(externsRoot,mainRoot);
      }
      recentChange.reset();
      getProcessor(compiler).process(externsRoot,mainRoot);
      if (astValidationEnabled) {
        (new AstValidator(compiler)).validateRoot(root);
      }
      if (checkLineNumbers) {
        (new LineNumberCheck(compiler)).process(externsRoot,mainRoot);
      }
      if (runTypeCheckAfterProcessing && typeCheckEnabled && i == 0) {
        TypeCheck check=createTypeCheck(compiler,reportMissingOverrideCheckLevel);
        check.processForTesting(externsRoot,mainRoot);
      }
 else       if (this.runNTIAfterProcessing && this.newTypeInferenceEnabled && i == 0) {
        runNewTypeInference(compiler,externsRoot,mainRoot);
      }
      hasCodeChanged=hasCodeChanged || recentChange.hasCodeChanged();
      aggregateWarningCount+=errorManagers[i].getWarningCount();
      Collections.addAll(aggregateWarnings,compiler.getWarnings());
      if (normalizeEnabled) {
        boolean verifyDeclaredConstants=true;
        new Normalize.VerifyConstants(compiler,verifyDeclaredConstants).process(externsRoot,mainRoot);
      }
    }
  }
  if (error == null) {
    assertEquals(""String_Node_Str"" + LINE_JOINER.join(compiler.getErrors()),0,compiler.getErrorCount());
    ErrorManager symbolTableErrorManager=new BlackHoleErrorManager();
    compiler.setErrorManager(symbolTableErrorManager);
    Node expectedRoot=null;
    if (expected != null) {
      expectedRoot=parseExpectedJs(expected);
      expectedRoot.detachFromParent();
    }
    JSError[] stErrors=symbolTableErrorManager.getErrors();
    if (expectedSymbolTableError != null) {
      assertEquals(""String_Node_Str"",1,stErrors.length);
      assertThat(stErrors[0].getType()).isEqualTo(expectedSymbolTableError);
    }
 else {
      assertEquals(""String_Node_Str"" + LINE_JOINER.join(stErrors),0,stErrors.length);
    }
    if (warning == null) {
      assertEquals(""String_Node_Str"" + LINE_JOINER.join(aggregateWarnings),0,aggregateWarningCount);
    }
 else {
      assertEquals(""String_Node_Str"" + numRepetitions + ""String_Node_Str""+ LINE_JOINER.join(aggregateWarnings),numRepetitions,aggregateWarningCount);
      for (int i=0; i < numRepetitions; ++i) {
        JSError[] warnings=errorManagers[i].getWarnings();
        JSError actual=warnings[0];
        assertThat(actual.getType()).isEqualTo(warning);
        validateSourceLocation(actual);
        if (description != null) {
          assertThat(actual.description).isEqualTo(description);
        }
      }
    }
    if (normalizeEnabled) {
      normalizeActualCode(compiler,externsRootClone,mainRootClone);
    }
    boolean codeChange=!mainRootClone.isEquivalentTo(mainRoot);
    boolean externsChange=!externsRootClone.isEquivalentTo(externsRoot);
    if (externsChange && !allowExternsChanges) {
      String explanation=externsRootClone.checkTreeEquals(externsRoot);
      fail(""String_Node_Str"" + ""String_Node_Str"" + compiler.toSource(externsRootClone) + ""String_Node_Str""+ compiler.toSource(externsRoot)+ ""String_Node_Str""+ explanation);
    }
    if (!codeChange && !externsChange) {
      assertFalse(""String_Node_Str"" + ""String_Node_Str"",hasCodeChanged);
    }
 else {
      assertTrue(""String_Node_Str"" + ""String_Node_Str"" + mainRootClone.toStringTree() + ""String_Node_Str""+ mainRoot.toStringTree(),hasCodeChanged);
    }
    NodeUtil.verifyScopeChanges(mtoc,mainRoot,false);
    if (expected != null) {
      if (compareAsTree) {
        String explanation;
        if (compareJsDoc) {
          explanation=expectedRoot.checkTreeEqualsIncludingJsDoc(mainRoot);
        }
 else {
          explanation=expectedRoot.checkTreeEquals(mainRoot);
        }
        if (explanation != null) {
          String expectedAsSource=compiler.toSource(expectedRoot);
          String mainAsSource=compiler.toSource(mainRoot);
          if (expectedAsSource.equals(mainAsSource)) {
            fail(""String_Node_Str"" + expectedAsSource + ""String_Node_Str""+ explanation);
          }
 else {
            fail(""String_Node_Str"" + expectedAsSource + ""String_Node_Str""+ mainAsSource+ ""String_Node_Str""+ explanation);
          }
        }
      }
 else       if (expected != null) {
        String[] expectedSources=new String[expected.size()];
        for (int i=0; i < expected.size(); ++i) {
          try {
            expectedSources[i]=expected.get(i).getCode();
          }
 catch (          IOException e) {
            throw new RuntimeException(""String_Node_Str"",e);
          }
        }
        assertThat(compiler.toSource(mainRoot)).isEqualTo(Joiner.on(""String_Node_Str"").join(expectedSources));
      }
    }
    Node normalizeCheckRootClone=root.cloneTree();
    Node normalizeCheckExternsRootClone=normalizeCheckRootClone.getFirstChild();
    Node normalizeCheckMainRootClone=normalizeCheckRootClone.getLastChild();
    new PrepareAst(compiler).process(normalizeCheckExternsRootClone,normalizeCheckMainRootClone);
    String explanation=normalizeCheckMainRootClone.checkTreeEquals(mainRoot);
    assertNull(""String_Node_Str"" + ""String_Node_Str"" + compiler.toSource(normalizeCheckMainRootClone) + ""String_Node_Str""+ compiler.toSource(mainRoot)+ ""String_Node_Str""+ explanation,explanation);
    if (normalizeEnabled) {
      new Normalize(compiler,true).process(normalizeCheckExternsRootClone,normalizeCheckMainRootClone);
      explanation=normalizeCheckMainRootClone.checkTreeEquals(mainRoot);
      assertNull(""String_Node_Str"" + ""String_Node_Str"" + compiler.toSource(normalizeCheckMainRootClone) + ""String_Node_Str""+ compiler.toSource(mainRoot)+ ""String_Node_Str""+ explanation,explanation);
    }
  }
 else {
    assertNull(""String_Node_Str"",expected);
    assertEquals(""String_Node_Str"" + errorMsg + ""String_Node_Str""+ Arrays.toString(compiler.getErrors()),1,compiler.getErrorCount());
    JSError actualError=compiler.getErrors()[0];
    assertEquals(errorMsg,error,actualError.getType());
    validateSourceLocation(actualError);
    if (description != null) {
      assertThat(actualError.description).isEqualTo(description);
    }
    assert_().withFailureMessage(""String_Node_Str"").that(actualError.description).doesNotContainMatch(""String_Node_Str"");
    if (warning != null) {
      String warnings=""String_Node_Str"";
      for (      JSError actualWarning : compiler.getWarnings()) {
        warnings+=actualWarning.description + ""String_Node_Str"";
        assert_().withFailureMessage(""String_Node_Str"").that(actualWarning.description).doesNotContainMatch(""String_Node_Str"");
      }
      assertEquals(""String_Node_Str"" + warnings,1,compiler.getWarningCount());
      assertEquals(warnings,warning,compiler.getWarnings()[0].getType());
    }
  }
}","/** 
 * Verifies that the compiler pass's JS output matches the expected output and (optionally) that an expected warning is issued. Or, if an error is expected, this method just verifies that the error is encountered.
 * @param compiler A compiler that has been initialized via{@link Compiler#init}
 * @param expected Expected output, or null if an error is expected
 * @param error Expected error, or null if no error is expected
 * @param warning Expected warning, or null if no warning is expected
 * @param description The description of the expected warning,or null if no warning is expected or if the warning's description should not be examined
 */
private void test(Compiler compiler,List<SourceFile> expected,DiagnosticType error,DiagnosticType warning,String description){
  RecentChange recentChange=new RecentChange();
  compiler.addChangeHandler(recentChange);
  Node root=compiler.parseInputs();
  String errorMsg=LINE_JOINER.join(compiler.getErrors());
  if (root == null && expected == null && error != null) {
    assert_().withFailureMessage(""String_Node_Str"" + errorMsg).that(compiler.getErrorCount()).isEqualTo(1);
    JSError actualError=compiler.getErrors()[0];
    assert_().withFailureMessage(""String_Node_Str"" + errorMsg).that(actualError.getType()).isEqualTo(error);
    if (description != null) {
      assertThat(actualError.description).isEqualTo(description);
    }
    return;
  }
  assert_().withFailureMessage(""String_Node_Str"" + errorMsg).that(root).isNotNull();
  if (!expectParseWarningsThisTest) {
    assertEquals(""String_Node_Str"" + LINE_JOINER.join(compiler.getWarnings()),0,compiler.getWarnings().length);
  }
  if (astValidationEnabled) {
    (new AstValidator(compiler)).validateRoot(root);
  }
  Node externsRoot=root.getFirstChild();
  Node mainRoot=root.getLastChild();
  Node rootClone=root.cloneTree();
  Node externsRootClone=rootClone.getFirstChild();
  Node mainRootClone=rootClone.getLastChild();
  Map<Node,Node> mtoc=NodeUtil.mapMainToClone(mainRoot,mainRootClone);
  int numRepetitions=getNumRepetitions();
  ErrorManager[] errorManagers=new ErrorManager[numRepetitions];
  int aggregateWarningCount=0;
  List<JSError> aggregateWarnings=new ArrayList<>();
  boolean hasCodeChanged=false;
  for (int i=0; i < numRepetitions; ++i) {
    if (compiler.getErrorCount() == 0) {
      errorManagers[i]=new BlackHoleErrorManager();
      compiler.setErrorManager(errorManagers[i]);
      if (rewriteClosureCode && i == 0) {
        new ClosureRewriteClass(compiler).process(null,mainRoot);
        new ClosureRewriteModule(compiler).process(null,mainRoot);
        new ScopedAliases(compiler,null,CompilerOptions.NULL_ALIAS_TRANSFORMATION_HANDLER).process(null,mainRoot);
        hasCodeChanged=hasCodeChanged || recentChange.hasCodeChanged();
      }
      if (closurePassEnabled && i == 0) {
        recentChange.reset();
        new ProcessClosurePrimitives(compiler,null,CheckLevel.ERROR,false).process(null,mainRoot);
        hasCodeChanged=hasCodeChanged || recentChange.hasCodeChanged();
      }
      if (transpileEnabled && i == 0) {
        recentChange.reset();
        transpileToEs5(compiler,externsRoot,mainRoot);
        hasCodeChanged=hasCodeChanged || recentChange.hasCodeChanged();
      }
      if (!runTypeCheckAfterProcessing && typeCheckEnabled && i == 0) {
        TypeCheck check=createTypeCheck(compiler,reportMissingOverrideCheckLevel);
        check.processForTesting(externsRoot,mainRoot);
      }
 else       if (!this.runNTIAfterProcessing && this.newTypeInferenceEnabled && i == 0) {
        runNewTypeInference(compiler,externsRoot,mainRoot);
      }
      if (normalizeEnabled && i == 0) {
        normalizeActualCode(compiler,externsRoot,mainRoot);
      }
      if (enableInferConsts && i == 0) {
        new InferConsts(compiler).process(externsRoot,mainRoot);
      }
      if (computeSideEffects && i == 0) {
        PureFunctionIdentifier.Driver mark=new PureFunctionIdentifier.Driver(compiler,null,false);
        mark.process(externsRoot,mainRoot);
      }
      if (markNoSideEffects && i == 0) {
        MarkNoSideEffectCalls mark=new MarkNoSideEffectCalls(compiler);
        mark.process(externsRoot,mainRoot);
      }
      if (gatherExternPropertiesEnabled && i == 0) {
        (new GatherExternProperties(compiler)).process(externsRoot,mainRoot);
      }
      recentChange.reset();
      getProcessor(compiler).process(externsRoot,mainRoot);
      if (astValidationEnabled) {
        (new AstValidator(compiler)).validateRoot(root);
      }
      if (checkLineNumbers) {
        (new LineNumberCheck(compiler)).process(externsRoot,mainRoot);
      }
      if (runTypeCheckAfterProcessing && typeCheckEnabled && i == 0) {
        TypeCheck check=createTypeCheck(compiler,reportMissingOverrideCheckLevel);
        check.processForTesting(externsRoot,mainRoot);
      }
 else       if (this.runNTIAfterProcessing && this.newTypeInferenceEnabled && i == 0) {
        runNewTypeInference(compiler,externsRoot,mainRoot);
      }
      hasCodeChanged=hasCodeChanged || recentChange.hasCodeChanged();
      aggregateWarningCount+=errorManagers[i].getWarningCount();
      Collections.addAll(aggregateWarnings,compiler.getWarnings());
      if (normalizeEnabled) {
        boolean verifyDeclaredConstants=true;
        new Normalize.VerifyConstants(compiler,verifyDeclaredConstants).process(externsRoot,mainRoot);
      }
    }
  }
  if (error == null) {
    assertEquals(""String_Node_Str"" + LINE_JOINER.join(compiler.getErrors()),0,compiler.getErrorCount());
    ErrorManager symbolTableErrorManager=new BlackHoleErrorManager();
    compiler.setErrorManager(symbolTableErrorManager);
    Node expectedRoot=null;
    if (expected != null) {
      expectedRoot=parseExpectedJs(expected);
      expectedRoot.detachFromParent();
    }
    JSError[] stErrors=symbolTableErrorManager.getErrors();
    if (expectedSymbolTableError != null) {
      assertEquals(""String_Node_Str"",1,stErrors.length);
      assertThat(stErrors[0].getType()).isEqualTo(expectedSymbolTableError);
    }
 else {
      assertEquals(""String_Node_Str"" + LINE_JOINER.join(stErrors),0,stErrors.length);
    }
    if (warning == null) {
      assertEquals(""String_Node_Str"" + LINE_JOINER.join(aggregateWarnings),0,aggregateWarningCount);
    }
 else {
      assertEquals(""String_Node_Str"" + numRepetitions + ""String_Node_Str""+ LINE_JOINER.join(aggregateWarnings),numRepetitions,aggregateWarningCount);
      for (int i=0; i < numRepetitions; ++i) {
        JSError[] warnings=errorManagers[i].getWarnings();
        JSError actual=warnings[0];
        assertThat(actual.getType()).isEqualTo(warning);
        validateSourceLocation(actual);
        if (description != null) {
          assertThat(actual.description).isEqualTo(description);
        }
      }
    }
    if (normalizeEnabled) {
      normalizeActualCode(compiler,externsRootClone,mainRootClone);
    }
    boolean codeChange=!mainRootClone.isEquivalentTo(mainRoot);
    boolean externsChange=!externsRootClone.isEquivalentTo(externsRoot);
    if (externsChange && !allowExternsChanges) {
      String explanation=externsRootClone.checkTreeEquals(externsRoot);
      fail(""String_Node_Str"" + ""String_Node_Str"" + compiler.toSource(externsRootClone) + ""String_Node_Str""+ compiler.toSource(externsRoot)+ ""String_Node_Str""+ explanation);
    }
    if (!codeChange && !externsChange) {
      assertFalse(""String_Node_Str"" + ""String_Node_Str"",hasCodeChanged);
    }
 else {
      assertTrue(""String_Node_Str"" + ""String_Node_Str"" + mainRootClone.toStringTree() + ""String_Node_Str""+ mainRoot.toStringTree(),hasCodeChanged);
    }
    NodeUtil.verifyScopeChanges(mtoc,mainRoot,false);
    if (expected != null) {
      if (compareAsTree) {
        String explanation;
        if (compareJsDoc) {
          explanation=expectedRoot.checkTreeEqualsIncludingJsDoc(mainRoot);
        }
 else {
          explanation=expectedRoot.checkTreeEquals(mainRoot);
        }
        if (explanation != null) {
          String expectedAsSource=compiler.toSource(expectedRoot);
          String mainAsSource=compiler.toSource(mainRoot);
          if (expectedAsSource.equals(mainAsSource)) {
            fail(""String_Node_Str"" + expectedAsSource + ""String_Node_Str""+ explanation);
          }
 else {
            fail(""String_Node_Str"" + expectedAsSource + ""String_Node_Str""+ mainAsSource+ ""String_Node_Str""+ explanation);
          }
        }
      }
 else       if (expected != null) {
        String[] expectedSources=new String[expected.size()];
        for (int i=0; i < expected.size(); ++i) {
          try {
            expectedSources[i]=expected.get(i).getCode();
          }
 catch (          IOException e) {
            throw new RuntimeException(""String_Node_Str"",e);
          }
        }
        assertThat(compiler.toSource(mainRoot)).isEqualTo(Joiner.on(""String_Node_Str"").join(expectedSources));
      }
    }
    Node normalizeCheckRootClone=root.cloneTree();
    Node normalizeCheckExternsRootClone=normalizeCheckRootClone.getFirstChild();
    Node normalizeCheckMainRootClone=normalizeCheckRootClone.getLastChild();
    new PrepareAst(compiler).process(normalizeCheckExternsRootClone,normalizeCheckMainRootClone);
    String explanation=normalizeCheckMainRootClone.checkTreeEquals(mainRoot);
    assertNull(""String_Node_Str"" + ""String_Node_Str"" + compiler.toSource(normalizeCheckMainRootClone) + ""String_Node_Str""+ compiler.toSource(mainRoot)+ ""String_Node_Str""+ explanation,explanation);
    if (normalizeEnabled) {
      new Normalize(compiler,true).process(normalizeCheckExternsRootClone,normalizeCheckMainRootClone);
      explanation=normalizeCheckMainRootClone.checkTreeEquals(mainRoot);
      assertNull(""String_Node_Str"" + ""String_Node_Str"" + compiler.toSource(normalizeCheckMainRootClone) + ""String_Node_Str""+ compiler.toSource(mainRoot)+ ""String_Node_Str""+ explanation,explanation);
    }
  }
 else {
    assertNull(""String_Node_Str"",expected);
    assertEquals(""String_Node_Str"" + error.key + ""String_Node_Str""+ Arrays.toString(compiler.getErrors()),1,compiler.getErrorCount());
    JSError actualError=compiler.getErrors()[0];
    assertEquals(errorMsg,error,actualError.getType());
    validateSourceLocation(actualError);
    if (description != null) {
      assertThat(actualError.description).isEqualTo(description);
    }
    assert_().withFailureMessage(""String_Node_Str"").that(actualError.description).doesNotContainMatch(""String_Node_Str"");
    if (warning != null) {
      String warnings=""String_Node_Str"";
      for (      JSError actualWarning : compiler.getWarnings()) {
        warnings+=actualWarning.description + ""String_Node_Str"";
        assert_().withFailureMessage(""String_Node_Str"").that(actualWarning.description).doesNotContainMatch(""String_Node_Str"");
      }
      assertEquals(""String_Node_Str"" + warnings,1,compiler.getWarningCount());
      assertEquals(warnings,warning,compiler.getWarnings()[0].getType());
    }
  }
}",0.9996811660214074
19477,"@Override public void visit(NodeTraversal t,Node n,Node parent){
switch (n.getType()) {
case Token.CALL:
    Node callee=n.getFirstChild();
  if (callee.matchesQualifiedName(""String_Node_Str"")) {
    if (currentModuleName == null) {
      currentModuleName=extractFirstArgumentName(n);
    }
 else {
      t.report(n,MULTIPLE_MODULES_IN_FILE);
    }
  }
 else   if (callee.matchesQualifiedName(""String_Node_Str"")) {
    t.report(n,MODULE_AND_PROVIDES);
  }
 else   if (callee.matchesQualifiedName(""String_Node_Str"")) {
    checkRequireCall(t,n,parent);
  }
break;
case Token.THIS:
if (t.inGlobalHoistScope()) {
t.report(n,GOOG_MODULE_REFERENCES_THIS);
}
break;
case Token.THROW:
if (t.inGlobalHoistScope()) {
t.report(n,GOOG_MODULE_USES_THROW);
}
break;
case Token.GETPROP:
if (currentModuleName != null && n.matchesQualifiedName(currentModuleName)) {
t.report(n,REFERENCE_TO_MODULE_GLOBAL_NAME);
}
 else if (shortRequiredNamespaces.contains(n.getQualifiedName())) {
t.report(n,REFERENCE_TO_SHORT_IMPORT_BY_LONG_NAME);
}
break;
case Token.SCRIPT:
currentModuleName=null;
shortRequiredNamespaces.clear();
break;
}
}","@Override public void visit(NodeTraversal t,Node n,Node parent){
switch (n.getType()) {
case Token.CALL:
    Node callee=n.getFirstChild();
  if (callee.matchesQualifiedName(""String_Node_Str"")) {
    if (currentModuleName == null) {
      currentModuleName=extractFirstArgumentName(n);
    }
 else {
      t.report(n,MULTIPLE_MODULES_IN_FILE);
    }
  }
 else   if (callee.matchesQualifiedName(""String_Node_Str"")) {
    t.report(n,MODULE_AND_PROVIDES);
  }
 else   if (callee.matchesQualifiedName(""String_Node_Str"")) {
    checkRequireCall(t,n,parent);
  }
break;
case Token.THIS:
if (t.inGlobalHoistScope()) {
t.report(n,GOOG_MODULE_REFERENCES_THIS);
}
break;
case Token.THROW:
if (t.inGlobalHoistScope()) {
t.report(n,GOOG_MODULE_USES_THROW);
}
break;
case Token.GETPROP:
if (currentModuleName != null && n.matchesQualifiedName(currentModuleName)) {
t.report(n,REFERENCE_TO_MODULE_GLOBAL_NAME);
}
 else if (shortRequiredNamespaces.contains(n.getQualifiedName())) {
t.report(n,REFERENCE_TO_SHORT_IMPORT_BY_LONG_NAME,n.getQualifiedName());
}
break;
case Token.SCRIPT:
currentModuleName=null;
shortRequiredNamespaces.clear();
break;
}
}",0.9906625166740772
19478,"/** 
 * If the variable is declared more than once in a basic block, generate a warning. Also check if a variable is used in a given scope before it is declared, which suggest a likely error. Relies on the fact that references is in parse-tree order.
 */
private void checkVar(Var v,List<Reference> references){
  blocksWithDeclarations.clear();
  boolean isDeclaredInScope=false;
  boolean isUnhoistedNamedFunction=false;
  boolean hasErrors=false;
  boolean isRead=false;
  Reference hoistedFn=null;
  Reference unusedAssignment=null;
  for (  Reference reference : references) {
    if (reference.isHoistedFunction()) {
      blocksWithDeclarations.add(reference.getBasicBlock());
      isDeclaredInScope=true;
      hoistedFn=reference;
      break;
    }
 else     if (NodeUtil.isFunctionDeclaration(reference.getNode().getParent())) {
      isUnhoistedNamedFunction=true;
    }
  }
  for (  Reference reference : references) {
    if (reference == hoistedFn) {
      continue;
    }
    BasicBlock basicBlock=reference.getBasicBlock();
    boolean isDeclaration=reference.isDeclaration();
    Node referenceNode=reference.getNode();
    boolean isAssignment=isDeclaration || reference.isLvalue();
    boolean allowDupe=VarCheck.hasDuplicateDeclarationSuppression(referenceNode,v);
    boolean letConstShadowsVar=v.getParentNode().isVar() && (reference.isLetDeclaration() || reference.isConstDeclaration());
    boolean isVarNodeSameAsReferenceNode=v.getNode() == reference.getNode();
    boolean shadowCatchVar=isDeclaration && compiler.getLanguageMode().isEs6OrHigher() && v.getParentNode().isCatch()&& !isVarNodeSameAsReferenceNode;
    boolean shadowParam=isDeclaration && v.isParam() && NodeUtil.isBlockScopedDeclaration(referenceNode)&& v.getScope() == reference.getScope().getParent();
    boolean shadowDetected=false;
    if (isDeclaration && !allowDupe) {
      for (      BasicBlock declaredBlock : blocksWithDeclarations) {
        if (declaredBlock.provablyExecutesBefore(basicBlock)) {
          shadowDetected=true;
          DiagnosticType diagnosticType;
          Node warningNode=referenceNode;
          if (v.isLet() || v.isConst() || v.isClass()|| letConstShadowsVar|| shadowCatchVar|| shadowParam) {
            diagnosticType=REDECLARED_VARIABLE_ERROR;
          }
 else           if (reference.getNode().getParent().isCatch() || allowDupe) {
            return;
          }
 else {
            diagnosticType=v.getScope().isGlobal() ? VarCheck.VAR_MULTIPLY_DECLARED_ERROR : REDECLARED_VARIABLE;
            if (isVarNodeSameAsReferenceNode && hoistedFn != null && v.name.equals(hoistedFn.getNode().getString())) {
              warningNode=hoistedFn.getNode();
            }
          }
          compiler.report(JSError.make(warningNode,diagnosticType,v.name,v.input != null ? v.input.getName() : ""String_Node_Str""));
          hasErrors=true;
          break;
        }
      }
    }
    if (!shadowDetected && isDeclaration && (letConstShadowsVar || shadowCatchVar)&& v.getScope() == reference.getScope()) {
      compiler.report(JSError.make(referenceNode,REDECLARED_VARIABLE_ERROR,v.name));
    }
    if (isAssignment) {
      Reference decl=references.get(0);
      Node declNode=decl.getNode();
      boolean lhsOfForInLoop=(NodeUtil.isForIn(declNode.getParent()) && declNode == declNode.getParent().getFirstChild()) || (NodeUtil.isForIn(declNode.getGrandparent()) && declNode.getParent().getParent().getFirstChild().getFirstChild() == declNode);
      if (decl.getScope().isLocal() && (decl.isVarDeclaration() || decl.isLetDeclaration() || decl.isConstDeclaration()) && !decl.getNode().isFromExterns()&& !lhsOfForInLoop) {
        unusedAssignment=reference;
      }
      if ((reference.getParent().isDec() || reference.getParent().isInc()) && NodeUtil.isExpressionResultUsed(reference.getNode())) {
        isRead=true;
      }
    }
 else {
      isRead=true;
    }
    if (isUnhoistedNamedFunction && !isDeclaration && isDeclaredInScope) {
      for (      BasicBlock declaredBlock : blocksWithDeclarations) {
        if (!declaredBlock.provablyExecutesBefore(basicBlock)) {
          compiler.report(JSError.make(referenceNode,AMBIGUOUS_FUNCTION_DECL,v.name));
          hasErrors=true;
          break;
        }
      }
    }
    boolean isUndeclaredReference=false;
    if (!isDeclaration && !isDeclaredInScope) {
      if (!referenceNode.isFromExterns()) {
        Node grandparent=reference.getGrandparent();
        if ((v.isVar() && grandparent.isName() && grandparent.getString().equals(v.name))) {
          continue;
        }
        if (reference.getScope() == v.scope && !v.getName().equals(""String_Node_Str"")) {
          isUndeclaredReference=true;
          compiler.report(JSError.make(reference.getNode(),(v.isLet() || v.isConst() || v.isClass()|| v.isParam()) ? EARLY_REFERENCE_ERROR : EARLY_REFERENCE,v.name));
          hasErrors=true;
        }
      }
    }
    if (!isDeclaration && !isUndeclaredReference && v.isConst()&& reference.isLvalue()) {
      compiler.report(JSError.make(referenceNode,REASSIGNED_CONSTANT,v.name));
    }
    if (isDeclaration && !reference.isVarDeclaration() && reference.getGrandparent().isAddedBlock()) {
      compiler.report(JSError.make(referenceNode,DECLARATION_NOT_DIRECTLY_IN_BLOCK,v.name));
    }
    if (isDeclaration) {
      blocksWithDeclarations.add(basicBlock);
      isDeclaredInScope=true;
    }
  }
  if (unusedAssignment != null && !isRead && !hasErrors) {
    boolean inGoogScope=false;
    Scope s=v.getScope();
    Node function=null;
    if (s.isFunctionBlockScope()) {
      function=s.getRootNode().getParent();
    }
 else     if (s.isFunctionScope()) {
      function=s.getRootNode();
    }
    if (function != null) {
      Node callee=function.getParent().getChildBefore(function);
      inGoogScope=callee != null && callee.matchesQualifiedName(""String_Node_Str"");
    }
    if (!inGoogScope) {
      compiler.report(JSError.make(unusedAssignment.getNode(),UNUSED_LOCAL_ASSIGNMENT,v.name));
    }
  }
}","/** 
 * If the variable is declared more than once in a basic block, generate a warning. Also check if a variable is used in a given scope before it is declared, which suggest a likely error. Relies on the fact that references is in parse-tree order.
 */
private void checkVar(Var v,List<Reference> references){
  blocksWithDeclarations.clear();
  boolean isDeclaredInScope=false;
  boolean isUnhoistedNamedFunction=false;
  boolean hasErrors=false;
  boolean isRead=false;
  Reference hoistedFn=null;
  Reference unusedAssignment=null;
  for (  Reference reference : references) {
    if (reference.isHoistedFunction()) {
      blocksWithDeclarations.add(reference.getBasicBlock());
      isDeclaredInScope=true;
      hoistedFn=reference;
      break;
    }
 else     if (NodeUtil.isFunctionDeclaration(reference.getNode().getParent())) {
      isUnhoistedNamedFunction=true;
    }
  }
  for (  Reference reference : references) {
    if (reference == hoistedFn) {
      continue;
    }
    BasicBlock basicBlock=reference.getBasicBlock();
    boolean isDeclaration=reference.isDeclaration();
    Node referenceNode=reference.getNode();
    boolean isAssignment=isDeclaration || reference.isLvalue();
    boolean allowDupe=VarCheck.hasDuplicateDeclarationSuppression(referenceNode,v);
    boolean letConstShadowsVar=v.getParentNode().isVar() && (reference.isLetDeclaration() || reference.isConstDeclaration());
    boolean isVarNodeSameAsReferenceNode=v.getNode() == reference.getNode();
    boolean shadowCatchVar=isDeclaration && compiler.getLanguageMode().isEs6OrHigher() && v.getParentNode().isCatch()&& !isVarNodeSameAsReferenceNode;
    boolean shadowParam=isDeclaration && v.isParam() && NodeUtil.isBlockScopedDeclaration(referenceNode)&& v.getScope() == reference.getScope().getParent();
    boolean shadowDetected=false;
    if (isDeclaration && !allowDupe) {
      for (      BasicBlock declaredBlock : blocksWithDeclarations) {
        if (declaredBlock.provablyExecutesBefore(basicBlock)) {
          shadowDetected=true;
          DiagnosticType diagnosticType;
          Node warningNode=referenceNode;
          if (v.isLet() || v.isConst() || v.isClass()|| letConstShadowsVar|| shadowCatchVar|| shadowParam) {
            diagnosticType=REDECLARED_VARIABLE_ERROR;
          }
 else           if (reference.getNode().getParent().isCatch() || allowDupe) {
            return;
          }
 else {
            diagnosticType=v.getScope().isGlobal() ? VarCheck.VAR_MULTIPLY_DECLARED_ERROR : REDECLARED_VARIABLE;
            if (isVarNodeSameAsReferenceNode && hoistedFn != null && v.name.equals(hoistedFn.getNode().getString())) {
              warningNode=hoistedFn.getNode();
            }
          }
          compiler.report(JSError.make(warningNode,diagnosticType,v.name,v.input != null ? v.input.getName() : ""String_Node_Str""));
          hasErrors=true;
          break;
        }
      }
    }
    if (!shadowDetected && isDeclaration && (letConstShadowsVar || shadowCatchVar)&& v.getScope() == reference.getScope()) {
      compiler.report(JSError.make(referenceNode,REDECLARED_VARIABLE_ERROR,v.name));
    }
    if (isAssignment) {
      Reference decl=references.get(0);
      Node declNode=decl.getNode();
      Node gp=declNode.getGrandparent();
      boolean lhsOfForInLoop=NodeUtil.isForIn(gp) && gp.getFirstFirstChild() == declNode;
      if (decl.getScope().isLocal() && (decl.isVarDeclaration() || decl.isLetDeclaration() || decl.isConstDeclaration()) && !decl.getNode().isFromExterns()&& !lhsOfForInLoop) {
        unusedAssignment=reference;
      }
      if ((reference.getParent().isDec() || reference.getParent().isInc()) && NodeUtil.isExpressionResultUsed(reference.getNode())) {
        isRead=true;
      }
    }
 else {
      isRead=true;
    }
    if (isUnhoistedNamedFunction && !isDeclaration && isDeclaredInScope) {
      for (      BasicBlock declaredBlock : blocksWithDeclarations) {
        if (!declaredBlock.provablyExecutesBefore(basicBlock)) {
          compiler.report(JSError.make(referenceNode,AMBIGUOUS_FUNCTION_DECL,v.name));
          hasErrors=true;
          break;
        }
      }
    }
    boolean isUndeclaredReference=false;
    if (!isDeclaration && !isDeclaredInScope) {
      if (!referenceNode.isFromExterns()) {
        Node grandparent=reference.getGrandparent();
        if ((v.isVar() && grandparent.isName() && grandparent.getString().equals(v.name))) {
          continue;
        }
        if (reference.getScope() == v.scope && !v.getName().equals(""String_Node_Str"")) {
          isUndeclaredReference=true;
          compiler.report(JSError.make(reference.getNode(),(v.isLet() || v.isConst() || v.isClass()|| v.isParam()) ? EARLY_REFERENCE_ERROR : EARLY_REFERENCE,v.name));
          hasErrors=true;
        }
      }
    }
    if (!isDeclaration && !isUndeclaredReference && v.isConst()&& reference.isLvalue()) {
      compiler.report(JSError.make(referenceNode,REASSIGNED_CONSTANT,v.name));
    }
    if (isDeclaration && !reference.isVarDeclaration() && reference.getGrandparent().isAddedBlock()) {
      compiler.report(JSError.make(referenceNode,DECLARATION_NOT_DIRECTLY_IN_BLOCK,v.name));
    }
    if (isDeclaration) {
      blocksWithDeclarations.add(basicBlock);
      isDeclaredInScope=true;
    }
  }
  if (unusedAssignment != null && !isRead && !hasErrors) {
    boolean inGoogScope=false;
    Scope s=v.getScope();
    Node function=null;
    if (s.isFunctionBlockScope()) {
      function=s.getRootNode().getParent();
    }
 else     if (s.isFunctionScope()) {
      function=s.getRootNode();
    }
    if (function != null) {
      Node callee=function.getParent().getChildBefore(function);
      inGoogScope=callee != null && callee.matchesQualifiedName(""String_Node_Str"");
    }
    if (!inGoogScope) {
      compiler.report(JSError.make(unusedAssignment.getNode(),UNUSED_LOCAL_ASSIGNMENT,v.name));
    }
  }
}",0.9781278806670576
19479,"public void testForIn(){
  enableUnusedLocalAssignmentCheck=true;
  assertNoWarning(""String_Node_Str"");
}","public void testForIn(){
  enableUnusedLocalAssignmentCheck=true;
  assertNoWarning(""String_Node_Str"");
  assertNoWarning(""String_Node_Str"");
  assertNoWarning(""String_Node_Str"");
}",0.7342657342657343
19480,"public void testTestTypes(){
  try {
    testTypes(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  AssertionError expected) {
  }
}","public void testTestTypes(){
  try {
    testTypes(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    throw new Error(""String_Node_Str"");
  }
 catch (  AssertionError expected) {
  }
}",0.6682577565632458
19481,"private static void lint(Path path,boolean fix) throws IOException {
  SourceFile file=SourceFile.fromFile(path.toString());
  Compiler compiler=new Compiler(System.out);
  CompilerOptions options=new CompilerOptions();
  options.setLanguage(LanguageMode.ECMASCRIPT6_STRICT);
  options.setSkipTranspilationAndCrash(true);
  options.setIdeMode(true);
  options.setCodingConvention(new GoogleCodingConvention());
  options.setWarningLevel(DiagnosticGroups.CHECK_TYPES,CheckLevel.WARNING);
  options.setWarningLevel(DiagnosticGroups.LINT_CHECKS,CheckLevel.WARNING);
  options.setWarningLevel(DiagnosticGroups.MISSING_REQUIRE,CheckLevel.WARNING);
  options.setWarningLevel(DiagnosticGroups.EXTRA_REQUIRE,CheckLevel.WARNING);
  compiler.setPassConfig(new LintPassConfig(options));
  compiler.disableThreads();
  SourceFile externs=SourceFile.fromCode(""String_Node_Str"",""String_Node_Str"");
  compiler.compile(ImmutableList.<SourceFile>of(externs),ImmutableList.of(file),options);
  if (fix) {
    List<SuggestedFix> fixes=new ArrayList<>();
    for (    JSError warning : compiler.getWarnings()) {
      SuggestedFix suggestedFix=ErrorToFixMapper.getFixForJsError(warning,compiler);
      if (suggestedFix != null) {
        fixes.add(suggestedFix);
      }
    }
    ApplySuggestedFixes.applySuggestedFixesToFiles(fixes);
  }
}","private static void lint(Path path,boolean fix) throws IOException {
  SourceFile file=SourceFile.fromFile(path.toString());
  Compiler compiler=new Compiler(System.out);
  CompilerOptions options=new CompilerOptions();
  options.setLanguage(LanguageMode.ECMASCRIPT6_STRICT);
  options.setSkipTranspilationAndCrash(true);
  options.setIdeMode(true);
  options.setCodingConvention(new GoogleCodingConvention());
  options.setWarningLevel(DiagnosticGroups.CHECK_TYPES,CheckLevel.WARNING);
  options.setWarningLevel(DiagnosticGroups.LINT_CHECKS,CheckLevel.WARNING);
  options.setWarningLevel(DiagnosticGroups.MISSING_REQUIRE,CheckLevel.WARNING);
  options.setWarningLevel(DiagnosticGroups.EXTRA_REQUIRE,CheckLevel.WARNING);
  compiler.setPassConfig(new LintPassConfig(options));
  compiler.disableThreads();
  SourceFile externs=SourceFile.fromCode(""String_Node_Str"",""String_Node_Str"");
  compiler.compile(ImmutableList.<SourceFile>of(externs),ImmutableList.of(file),options);
  if (fix) {
    List<SuggestedFix> fixes=new ArrayList<>();
    for (    JSError warning : concat(compiler.getErrors(),compiler.getWarnings(),JSError.class)) {
      SuggestedFix suggestedFix=ErrorToFixMapper.getFixForJsError(warning,compiler);
      if (suggestedFix != null) {
        fixes.add(suggestedFix);
      }
    }
    ApplySuggestedFixes.applySuggestedFixesToFiles(fixes);
  }
}",0.983997022701898
19482,"@Override public JSType caseTemplateType(TemplateType type){
  if (replacements.hasTemplateKey(type)) {
    if (hasVisitedType(type) || !replacements.hasTemplateType(type)) {
      return type;
    }
 else {
      JSType replacement=replacements.getUnresolvedOriginalTemplateType(type);
      JSType restrictedReplacement=replacement.restrictByNotNullOrUndefined();
      if (restrictedReplacement.isTemplatizedType() && restrictedReplacement.toMaybeTemplatizedType().getTemplateTypes().contains(type)) {
        return type;
      }
      visitedTypes.push(type);
      JSType visitedReplacement=replacement.visit(this);
      visitedTypes.pop();
      return visitedReplacement;
    }
  }
 else {
    return type;
  }
}","@Override public JSType caseTemplateType(TemplateType type){
  if (replacements.hasTemplateKey(type)) {
    if (hasVisitedType(type) || !replacements.hasTemplateType(type)) {
      return type;
    }
 else {
      JSType replacement=replacements.getUnresolvedOriginalTemplateType(type);
      JSType restrictedReplacement=replacement.restrictByNotNullOrUndefined();
      if (restrictedReplacement.isTemplatizedType()) {
        Iterable<JSType> replacementTemplateTypes=restrictedReplacement.toMaybeTemplatizedType().getTemplateTypes();
        for (        JSType replacementTemplateType : replacementTemplateTypes) {
          if (!replacementTemplateType.differsFrom(type)) {
            return type;
          }
        }
      }
      visitedTypes.push(type);
      JSType visitedReplacement=replacement.visit(this);
      visitedTypes.pop();
      return visitedReplacement;
    }
  }
 else {
    return type;
  }
}",0.7778454047474133
19483,"@Override public JSType caseTemplateType(TemplateType type){
  if (replacements.hasTemplateKey(type)) {
    if (hasVisitedType(type) || !replacements.hasTemplateType(type)) {
      return type;
    }
 else {
      JSType replacement=replacements.getUnresolvedOriginalTemplateType(type);
      visitedTypes.push(type);
      JSType visitedReplacement=replacement.visit(this);
      visitedTypes.pop();
      return visitedReplacement;
    }
  }
 else {
    return type;
  }
}","@Override public JSType caseTemplateType(TemplateType type){
  if (replacements.hasTemplateKey(type)) {
    if (hasVisitedType(type) || !replacements.hasTemplateType(type)) {
      return type;
    }
 else {
      JSType replacement=replacements.getUnresolvedOriginalTemplateType(type);
      JSType restrictedReplacement=replacement.restrictByNotNullOrUndefined();
      if (restrictedReplacement.isTemplatizedType() && restrictedReplacement.toMaybeTemplatizedType().getTemplateTypes().contains(type)) {
        return type;
      }
      visitedTypes.push(type);
      JSType visitedReplacement=replacement.visit(this);
      visitedTypes.pop();
      return visitedReplacement;
    }
  }
 else {
    return type;
  }
}",0.7414225941422594
19484,"private FlagEntry<JsSourceType> createJsFile(String filename,String fileContent) throws IOException {
  File tempJsFile=File.createTempFile(filename,""String_Node_Str"",Files.createTempDirectory(""String_Node_Str"").toFile());
  try (FileOutputStream fileOutputStream=new FileOutputStream(tempJsFile)){
    fileOutputStream.write(fileContent.getBytes(java.nio.charset.StandardCharsets.UTF_8));
  }
   return new FlagEntry<>(JsSourceType.JS,tempJsFile.getAbsolutePath());
}","private FlagEntry<JsSourceType> createJsFile(String filename,String fileContent) throws IOException {
  File tempJsFile=File.createTempFile(filename,""String_Node_Str"",java.nio.file.Files.createTempDirectory(""String_Node_Str"").toFile());
  try (FileOutputStream fileOutputStream=new FileOutputStream(tempJsFile)){
    fileOutputStream.write(fileContent.getBytes(java.nio.charset.StandardCharsets.UTF_8));
  }
   return new FlagEntry<>(JsSourceType.JS,tempJsFile.getAbsolutePath());
}",0.9852631578947368
19485,"public void testGlobJs2() throws IOException, FlagUsageException {
  FlagEntry<JsSourceType> jsFile1=createJsFile(""String_Node_Str"",""String_Node_Str"");
  FlagEntry<JsSourceType> jsFile2=createJsFile(""String_Node_Str"",""String_Node_Str"");
  new File(jsFile2.value).renameTo(new File(new File(jsFile1.value).getParentFile() + File.separator + ""String_Node_Str""));
  String glob=new File(jsFile1.value).getParent() + File.separator + ""String_Node_Str"";
  compileFiles(""String_Node_Str"",new FlagEntry<>(JsSourceType.JS,glob));
}","public void testGlobJs2() throws IOException {
  try {
    FlagEntry<JsSourceType> jsFile1=createJsFile(""String_Node_Str"",""String_Node_Str"");
    FlagEntry<JsSourceType> jsFile2=createJsFile(""String_Node_Str"",""String_Node_Str"");
    new File(jsFile2.value).renameTo(new File(new File(jsFile1.value).getParentFile() + File.separator + ""String_Node_Str""));
    String glob=new File(jsFile1.value).getParent() + File.separator + ""String_Node_Str"";
    compileFiles(""String_Node_Str"",new FlagEntry<>(JsSourceType.JS,glob));
  }
 catch (  FlagUsageException e) {
    fail(""String_Node_Str"" + e);
  }
}",0.1340482573726541
19486,"private static FlagEntry<JsSourceType> createZipFile(Map<String,String> entryContentsByName) throws IOException {
  File tempZipFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"",Files.createTempDirectory(""String_Node_Str"").toFile());
  try (ZipOutputStream zipOutputStream=new ZipOutputStream(new FileOutputStream(tempZipFile))){
    for (    Entry<String,String> entry : entryContentsByName.entrySet()) {
      zipOutputStream.putNextEntry(new ZipEntry(entry.getKey()));
      zipOutputStream.write(entry.getValue().getBytes(java.nio.charset.StandardCharsets.UTF_8));
    }
  }
   return new FlagEntry<>(JsSourceType.JS_ZIP,tempZipFile.getAbsolutePath());
}","private static FlagEntry<JsSourceType> createZipFile(Map<String,String> entryContentsByName) throws IOException {
  File tempZipFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"",java.nio.file.Files.createTempDirectory(""String_Node_Str"").toFile());
  try (ZipOutputStream zipOutputStream=new ZipOutputStream(new FileOutputStream(tempZipFile))){
    for (    Entry<String,String> entry : entryContentsByName.entrySet()) {
      zipOutputStream.putNextEntry(new ZipEntry(entry.getKey()));
      zipOutputStream.write(entry.getValue().getBytes(java.nio.charset.StandardCharsets.UTF_8));
    }
  }
   return new FlagEntry<>(JsSourceType.JS_ZIP,tempZipFile.getAbsolutePath());
}",0.9896449704142012
19487,"public static JSType plus(JSType lhs,JSType rhs){
  if (lhs.equals(STRING) || rhs.equals(STRING)) {
    return STRING;
  }
  if (lhs.isUnknown() || lhs.isTop() || rhs.isUnknown()|| rhs.isTop()) {
    return UNKNOWN;
  }
  int newtype=(lhs.getMask() | rhs.getMask()) & STRING_MASK;
  if ((lhs.getMask() & ~STRING_MASK) != 0 && (rhs.getMask() & ~STRING_MASK) != 0) {
    newtype|=NUMBER_MASK;
  }
  return makeType(newtype);
}","public static JSType plus(JSType lhs,JSType rhs){
  if (!lhs.isUnknown() && !lhs.isBottom() && lhs.isSubtypeOf(STRING) || !rhs.isUnknown() && !rhs.isBottom() && rhs.isSubtypeOf(STRING)) {
    return STRING;
  }
  if (lhs.isUnknown() || lhs.isTop() || rhs.isUnknown()|| rhs.isTop()) {
    return UNKNOWN;
  }
  int newtype=(lhs.getMask() | rhs.getMask()) & STRING_MASK;
  if ((lhs.getMask() & ~STRING_MASK) != 0 && (rhs.getMask() & ~STRING_MASK) != 0) {
    newtype|=NUMBER_MASK;
  }
  return makeType(newtype);
}",0.8632478632478633
19488,"public void testEnumBasicTyping(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INEXISTENT_PROPERTY);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
}","public void testEnumBasicTyping(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INEXISTENT_PROPERTY);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.9660615627466456
19489,"/** 
 * Creates inputs from a list of source files, zips and json files. Can be overridden by subclasses who want to pull files from different places.
 * @param files A list of flag entries indicates js and zip file names
 * @param jsonFiles A list of json encoded files.
 * @param allowStdIn Whether '-' is allowed appear as a filename to representstdin. If true, '-' is only allowed to appear once.
 * @return An array of inputs
 */
protected List<SourceFile> createInputs(List<FlagEntry<JsSourceType>> files,List<JsonFileSpec> jsonFiles,boolean allowStdIn) throws FlagUsageException, IOException {
  List<SourceFile> inputs=new ArrayList<>(files.size());
  boolean usingStdin=false;
  for (  FlagEntry<JsSourceType> file : files) {
    String filename=file.value;
    if (file.flag == JsSourceType.JS_ZIP) {
      if (!""String_Node_Str"".equals(filename)) {
        List<SourceFile> newFiles=SourceFile.fromZipFile(filename,inputCharset);
        inputs.addAll(newFiles);
      }
    }
 else     if (!""String_Node_Str"".equals(filename)) {
      SourceFile newFile=SourceFile.fromFile(filename,inputCharset);
      inputs.add(newFile);
    }
 else {
      if (!allowStdIn) {
        throw new FlagUsageException(""String_Node_Str"");
      }
      if (usingStdin) {
        throw new FlagUsageException(""String_Node_Str"");
      }
      if (!config.outputManifests.isEmpty()) {
        throw new FlagUsageException(""String_Node_Str"" + ""String_Node_Str"");
      }
      if (!config.outputBundles.isEmpty()) {
        throw new FlagUsageException(""String_Node_Str"" + ""String_Node_Str"");
      }
      this.err.println(WAITING_FOR_INPUT_WARNING);
      inputs.add(SourceFile.fromInputStream(""String_Node_Str"",this.in,inputCharset));
      usingStdin=true;
    }
  }
  if (jsonFiles != null) {
    for (    JsonFileSpec jsonFile : jsonFiles) {
      inputs.add(SourceFile.fromCode(jsonFile.getPath(),jsonFile.getSrc()));
    }
  }
  return inputs;
}","/** 
 * Creates inputs from a list of source files, zips and json files. Can be overridden by subclasses who want to pull files from different places.
 * @param files A list of flag entries indicates js and zip file names
 * @param jsonFiles A list of json encoded files.
 * @param allowStdIn Whether '-' is allowed appear as a filename to representstdin. If true, '-' is only allowed to appear once.
 * @param jsModuleSpecs A list js module specs.
 * @return An array of inputs
 */
protected List<SourceFile> createInputs(List<FlagEntry<JsSourceType>> files,List<JsonFileSpec> jsonFiles,boolean allowStdIn,List<JsModuleSpec> jsModuleSpecs) throws FlagUsageException, IOException {
  List<SourceFile> inputs=new ArrayList<>(files.size());
  boolean usingStdin=false;
  int jsModuleIndex=0;
  JsModuleSpec jsModuleSpec=jsModuleSpecs.isEmpty() ? null : jsModuleSpecs.get(0);
  int cumulatedInputFilesExpected=jsModuleSpec == null ? Integer.MAX_VALUE : jsModuleSpec.numInputs;
  for (int i=0; i < files.size(); i++) {
    FlagEntry<JsSourceType> file=files.get(i);
    String filename=file.value;
    if (file.flag == JsSourceType.JS_ZIP) {
      if (!""String_Node_Str"".equals(filename)) {
        List<SourceFile> newFiles=SourceFile.fromZipFile(filename,inputCharset);
        inputs.addAll(newFiles);
        if (jsModuleSpec != null) {
          jsModuleSpec.numJsFiles+=newFiles.size() - 1;
        }
      }
    }
 else     if (!""String_Node_Str"".equals(filename)) {
      SourceFile newFile=SourceFile.fromFile(filename,inputCharset);
      inputs.add(newFile);
    }
 else {
      if (!allowStdIn) {
        throw new FlagUsageException(""String_Node_Str"");
      }
      if (usingStdin) {
        throw new FlagUsageException(""String_Node_Str"");
      }
      if (!config.outputManifests.isEmpty()) {
        throw new FlagUsageException(""String_Node_Str"" + ""String_Node_Str"");
      }
      if (!config.outputBundles.isEmpty()) {
        throw new FlagUsageException(""String_Node_Str"" + ""String_Node_Str"");
      }
      this.err.println(WAITING_FOR_INPUT_WARNING);
      inputs.add(SourceFile.fromInputStream(""String_Node_Str"",this.in,inputCharset));
      usingStdin=true;
    }
    if (i >= cumulatedInputFilesExpected - 1) {
      jsModuleIndex++;
      if (jsModuleIndex < jsModuleSpecs.size()) {
        jsModuleSpec=jsModuleSpecs.get(jsModuleIndex);
        cumulatedInputFilesExpected+=jsModuleSpec.numInputs;
      }
    }
  }
  if (jsonFiles != null) {
    for (    JsonFileSpec jsonFile : jsonFiles) {
      inputs.add(SourceFile.fromCode(jsonFile.getPath(),jsonFile.getSrc()));
    }
  }
  return inputs;
}",0.8441330998248686
19490,"/** 
 * Creates JS source code inputs from a list of files.
 */
private List<SourceFile> createSourceInputs(List<FlagEntry<JsSourceType>> files,List<JsonFileSpec> jsonFiles) throws FlagUsageException, IOException {
  if (isInTestMode()) {
    return inputsSupplierForTesting != null ? inputsSupplierForTesting.get() : null;
  }
  if (files.isEmpty() && jsonFiles == null) {
    files=Collections.singletonList(new FlagEntry<JsSourceType>(JsSourceType.JS,""String_Node_Str""));
  }
  try {
    if (jsonFiles != null) {
      return createInputs(files,jsonFiles);
    }
 else {
      return createInputs(files,true);
    }
  }
 catch (  FlagUsageException e) {
    throw new FlagUsageException(""String_Node_Str"" + e.getMessage());
  }
}","/** 
 * Creates JS source code inputs from a list of files.
 */
private List<SourceFile> createSourceInputs(List<JsModuleSpec> jsModuleSpecs,List<FlagEntry<JsSourceType>> files,List<JsonFileSpec> jsonFiles) throws FlagUsageException, IOException {
  if (isInTestMode()) {
    return inputsSupplierForTesting != null ? inputsSupplierForTesting.get() : null;
  }
  if (files.isEmpty() && jsonFiles == null) {
    files=Collections.singletonList(new FlagEntry<JsSourceType>(JsSourceType.JS,""String_Node_Str""));
  }
  try {
    if (jsonFiles != null) {
      return createInputs(files,jsonFiles,jsModuleSpecs);
    }
 else {
      return createInputs(files,true,jsModuleSpecs);
    }
  }
 catch (  FlagUsageException e) {
    throw new FlagUsageException(""String_Node_Str"" + e.getMessage());
  }
}",0.96
19491,"/** 
 * Creates JS extern inputs from a list of files.
 */
private List<SourceFile> createExternInputs(List<String> files) throws FlagUsageException, IOException {
  if (files.isEmpty()) {
    return ImmutableList.of(SourceFile.fromCode(""String_Node_Str"",""String_Node_Str""));
  }
  List<FlagEntry<JsSourceType>> externFiles=new ArrayList<>();
  for (  String file : files) {
    externFiles.add(new FlagEntry<JsSourceType>(JsSourceType.EXTERN,file));
  }
  try {
    return createInputs(externFiles,false);
  }
 catch (  FlagUsageException e) {
    throw new FlagUsageException(""String_Node_Str"" + e.getMessage());
  }
}","/** 
 * Creates JS extern inputs from a list of files.
 */
private List<SourceFile> createExternInputs(List<String> files) throws FlagUsageException, IOException {
  if (files.isEmpty()) {
    return ImmutableList.of(SourceFile.fromCode(""String_Node_Str"",""String_Node_Str""));
  }
  List<FlagEntry<JsSourceType>> externFiles=new ArrayList<>();
  for (  String file : files) {
    externFiles.add(new FlagEntry<JsSourceType>(JsSourceType.EXTERN,file));
  }
  try {
    return createInputs(externFiles,false,new ArrayList<JsModuleSpec>());
  }
 catch (  FlagUsageException e) {
    throw new FlagUsageException(""String_Node_Str"" + e.getMessage());
  }
}",0.9763779527559056
19492,"/** 
 * Parses command-line arguments and runs the compiler.
 * @return system exit status
 */
protected int doRun() throws FlagUsageException, IOException {
  Compiler.setLoggingLevel(Level.parse(config.loggingLevel));
  compiler=createCompiler();
  B options=createOptions();
  List<SourceFile> externs=createExterns(options);
  List<JSModule> modules=null;
  Result result=null;
  setRunOptions(options);
  boolean writeOutputToFile=!config.jsOutputFile.isEmpty();
  List<String> outputFileNames=new ArrayList<>();
  if (writeOutputToFile) {
    outputFileNames.add(config.jsOutputFile);
  }
  List<String> moduleSpecs=config.module;
  List<JsonFileSpec> jsonFiles=null;
  if (config.jsonStreamMode == JsonStreamMode.IN || config.jsonStreamMode == JsonStreamMode.BOTH) {
    jsonFiles=parseJsonFilesFromInputStream();
    ImmutableMap.Builder<String,SourceMapInput> inputSourceMaps=new ImmutableMap.Builder<>();
    boolean foundJsonInputSourceMap=false;
    for (    JsonFileSpec jsonFile : jsonFiles) {
      if (jsonFile.getSourceMap() != null && jsonFile.getSourceMap().length() > 0) {
        String sourceMapPath=jsonFile.getPath() + ""String_Node_Str"";
        SourceFile sourceMap=SourceFile.fromCode(sourceMapPath,jsonFile.getSourceMap());
        inputSourceMaps.put(sourceMapPath,new SourceMapInput(sourceMap));
        foundJsonInputSourceMap=true;
      }
    }
    if (foundJsonInputSourceMap) {
      inputSourceMaps.putAll(options.inputSourceMaps);
      options.inputSourceMaps=inputSourceMaps.build();
    }
  }
  boolean createCommonJsModules=false;
  if (options.processCommonJSModules && (moduleSpecs.size() == 1 && ""String_Node_Str"".equals(moduleSpecs.get(0)))) {
    createCommonJsModules=true;
    moduleSpecs.remove(0);
  }
  List<SourceFile> inputs=createSourceInputs(config.mixedJsSources,jsonFiles);
  if (!moduleSpecs.isEmpty()) {
    modules=createJsModules(moduleSpecs,inputs);
    for (    JSModule m : modules) {
      outputFileNames.add(getModuleOutputFileName(m));
    }
    if (config.skipNormalOutputs) {
      compiler.initModules(externs,modules,options);
    }
 else {
      result=compiler.compileModules(externs,modules,options);
    }
  }
 else {
    if (config.skipNormalOutputs) {
      compiler.init(externs,inputs,options);
      compiler.hoistExterns();
    }
 else {
      result=compiler.compile(externs,inputs,options);
    }
  }
  if (createCommonJsModules) {
    modules=ImmutableList.copyOf(compiler.getDegenerateModuleGraph().getAllModules());
    for (    JSModule m : modules) {
      outputFileNames.add(getModuleOutputFileName(m));
    }
  }
  for (  String outputFileName : outputFileNames) {
    if (compiler.getSourceFileByName(outputFileName) != null) {
      compiler.report(JSError.make(OUTPUT_SAME_AS_INPUT_ERROR,outputFileName));
      return 1;
    }
  }
  return processResults(result,modules,options);
}","/** 
 * Parses command-line arguments and runs the compiler.
 * @return system exit status
 */
protected int doRun() throws FlagUsageException, IOException {
  Compiler.setLoggingLevel(Level.parse(config.loggingLevel));
  compiler=createCompiler();
  B options=createOptions();
  List<SourceFile> externs=createExterns(options);
  List<JSModule> modules=null;
  Result result=null;
  setRunOptions(options);
  boolean writeOutputToFile=!config.jsOutputFile.isEmpty();
  List<String> outputFileNames=new ArrayList<>();
  if (writeOutputToFile) {
    outputFileNames.add(config.jsOutputFile);
  }
  boolean createCommonJsModules=false;
  if (options.processCommonJSModules && (config.module.size() == 1 && ""String_Node_Str"".equals(config.module.get(0)))) {
    createCommonJsModules=true;
    config.module.remove(0);
  }
  List<JsModuleSpec> jsModuleSpecs=new ArrayList<>();
  for (int i=0; i < config.module.size(); i++) {
    jsModuleSpecs.add(JsModuleSpec.create(config.module.get(i),i == 0));
  }
  List<JsonFileSpec> jsonFiles=null;
  if (config.jsonStreamMode == JsonStreamMode.IN || config.jsonStreamMode == JsonStreamMode.BOTH) {
    jsonFiles=parseJsonFilesFromInputStream();
    ImmutableMap.Builder<String,SourceMapInput> inputSourceMaps=new ImmutableMap.Builder<>();
    boolean foundJsonInputSourceMap=false;
    for (    JsonFileSpec jsonFile : jsonFiles) {
      if (jsonFile.getSourceMap() != null && jsonFile.getSourceMap().length() > 0) {
        String sourceMapPath=jsonFile.getPath() + ""String_Node_Str"";
        SourceFile sourceMap=SourceFile.fromCode(sourceMapPath,jsonFile.getSourceMap());
        inputSourceMaps.put(sourceMapPath,new SourceMapInput(sourceMap));
        foundJsonInputSourceMap=true;
      }
    }
    if (foundJsonInputSourceMap) {
      inputSourceMaps.putAll(options.inputSourceMaps);
      options.inputSourceMaps=inputSourceMaps.build();
    }
  }
  List<SourceFile> inputs=createSourceInputs(jsModuleSpecs,config.mixedJsSources,jsonFiles);
  if (!jsModuleSpecs.isEmpty()) {
    modules=createJsModules(jsModuleSpecs,inputs);
    for (    JSModule m : modules) {
      outputFileNames.add(getModuleOutputFileName(m));
    }
    if (config.skipNormalOutputs) {
      compiler.initModules(externs,modules,options);
    }
 else {
      result=compiler.compileModules(externs,modules,options);
    }
  }
 else {
    if (config.skipNormalOutputs) {
      compiler.init(externs,inputs,options);
      compiler.hoistExterns();
    }
 else {
      result=compiler.compile(externs,inputs,options);
    }
  }
  if (createCommonJsModules) {
    modules=ImmutableList.copyOf(compiler.getDegenerateModuleGraph().getAllModules());
    for (    JSModule m : modules) {
      outputFileNames.add(getModuleOutputFileName(m));
    }
  }
  for (  String outputFileName : outputFileNames) {
    if (compiler.getSourceFileByName(outputFileName) != null) {
      compiler.report(JSError.make(OUTPUT_SAME_AS_INPUT_ERROR,outputFileName));
      return 1;
    }
  }
  return processResults(result,modules,options);
}",0.8870476834629692
19493,"/** 
 * Creates module objects from a list of module specifications.
 * @param specs A list of module specifications, not null or empty. The specformat is: <code>name:num-js-files[:[dep,...][:]]</code>. Module names must not contain the ':' character.
 * @param inputs A list of JS file paths, not null
 * @return An array of module objects
 */
List<JSModule> createJsModules(List<String> specs,List<SourceFile> inputs) throws FlagUsageException, IOException {
  if (isInTestMode()) {
    return modulesSupplierForTesting.get();
  }
  Preconditions.checkState(specs != null);
  Preconditions.checkState(!specs.isEmpty());
  Preconditions.checkState(inputs != null);
  List<String> moduleNames=new ArrayList<>(specs.size());
  Map<String,JSModule> modulesByName=new LinkedHashMap<>();
  Map<String,Integer> modulesFileCountMap=new LinkedHashMap<>();
  int numJsFilesExpected=0, minJsFilesRequired=0;
  boolean isFirstModule=true;
  for (  String spec : specs) {
    String[] parts=spec.split(""String_Node_Str"");
    if (parts.length < 2 || parts.length > 4) {
      throw new FlagUsageException(""String_Node_Str"" + ""String_Node_Str"" + spec);
    }
    String name=parts[0];
    checkModuleName(name);
    if (modulesByName.containsKey(name)) {
      throw new FlagUsageException(""String_Node_Str"" + name);
    }
    JSModule module=new JSModule(name);
    if (parts.length > 2) {
      String depList=parts[2];
      if (depList.length() > 0) {
        String[] deps=depList.split(""String_Node_Str"");
        for (        String dep : deps) {
          JSModule other=modulesByName.get(dep);
          if (other == null) {
            throw new FlagUsageException(""String_Node_Str"" + name + ""String_Node_Str""+ dep+ ""String_Node_Str"");
          }
          module.addDependency(other);
        }
      }
    }
    int numJsFiles=-1;
    try {
      numJsFiles=Integer.parseInt(parts[1]);
    }
 catch (    NumberFormatException ignored) {
      numJsFiles=-1;
    }
    if (numJsFiles < 0) {
      if (parts.length == 2 && ""String_Node_Str"".equals(parts[1])) {
        if (isFirstModule) {
          numJsFilesExpected=-1;
        }
 else {
          throw new FlagUsageException(""String_Node_Str"" + parts[1] + ""String_Node_Str""+ name+ ""String_Node_Str""+ ""String_Node_Str"");
        }
      }
 else {
        throw new FlagUsageException(""String_Node_Str"" + parts[1] + ""String_Node_Str""+ name);
      }
    }
 else {
      minJsFilesRequired+=numJsFiles;
    }
    if (numJsFilesExpected >= 0) {
      numJsFilesExpected+=numJsFiles;
    }
    moduleNames.add(0,name);
    modulesFileCountMap.put(name,numJsFiles);
    modulesByName.put(name,module);
  }
  final int totalNumJsFiles=inputs.size();
  if (numJsFilesExpected >= 0 || minJsFilesRequired > totalNumJsFiles) {
    if (minJsFilesRequired > totalNumJsFiles) {
      numJsFilesExpected=minJsFilesRequired;
    }
    if (numJsFilesExpected > totalNumJsFiles) {
      throw new FlagUsageException(""String_Node_Str"" + numJsFilesExpected + ""String_Node_Str""+ totalNumJsFiles);
    }
 else     if (numJsFilesExpected < totalNumJsFiles) {
      throw new FlagUsageException(""String_Node_Str"" + numJsFilesExpected + ""String_Node_Str""+ totalNumJsFiles);
    }
  }
  int numJsFilesLeft=totalNumJsFiles, moduleIndex=0;
  for (  String moduleName : moduleNames) {
    int numJsFiles=modulesFileCountMap.get(moduleName);
    JSModule module=modulesByName.get(moduleName);
    if (moduleIndex == moduleNames.size() - 1 && numJsFiles == -1) {
      numJsFiles=numJsFilesLeft;
    }
    List<SourceFile> moduleFiles=inputs.subList(numJsFilesLeft - numJsFiles,numJsFilesLeft);
    for (    SourceFile input : moduleFiles) {
      module.add(input);
    }
    numJsFilesLeft-=numJsFiles;
    moduleIndex++;
  }
  return new ArrayList<>(modulesByName.values());
}","/** 
 * Creates module objects from a list of js module specifications.
 * @param specs A list of js module specifications, not null or empty.
 * @param inputs A list of JS file paths, not null
 * @return An array of module objects
 */
List<JSModule> createJsModules(List<JsModuleSpec> specs,List<SourceFile> inputs) throws FlagUsageException, IOException {
  if (isInTestMode()) {
    return modulesSupplierForTesting.get();
  }
  Preconditions.checkState(specs != null);
  Preconditions.checkState(!specs.isEmpty());
  Preconditions.checkState(inputs != null);
  List<String> moduleNames=new ArrayList<>(specs.size());
  Map<String,JSModule> modulesByName=new LinkedHashMap<>();
  Map<String,Integer> modulesFileCountMap=new LinkedHashMap<>();
  int numJsFilesExpected=0, minJsFilesRequired=0;
  for (  JsModuleSpec spec : specs) {
    checkModuleName(spec.name);
    if (modulesByName.containsKey(spec.name)) {
      throw new FlagUsageException(""String_Node_Str"" + spec.name);
    }
    JSModule module=new JSModule(spec.name);
    for (    String dep : spec.deps) {
      JSModule other=modulesByName.get(dep);
      if (other == null) {
        throw new FlagUsageException(""String_Node_Str"" + spec.name + ""String_Node_Str""+ dep+ ""String_Node_Str"");
      }
      module.addDependency(other);
    }
    if (spec.numJsFiles < 0) {
      numJsFilesExpected=-1;
    }
 else {
      minJsFilesRequired+=spec.numJsFiles;
    }
    if (numJsFilesExpected >= 0) {
      numJsFilesExpected+=spec.numJsFiles;
    }
    moduleNames.add(0,spec.name);
    modulesFileCountMap.put(spec.name,spec.numJsFiles);
    modulesByName.put(spec.name,module);
  }
  final int totalNumJsFiles=inputs.size();
  if (numJsFilesExpected >= 0 || minJsFilesRequired > totalNumJsFiles) {
    if (minJsFilesRequired > totalNumJsFiles) {
      numJsFilesExpected=minJsFilesRequired;
    }
    if (numJsFilesExpected > totalNumJsFiles) {
      throw new FlagUsageException(""String_Node_Str"" + numJsFilesExpected + ""String_Node_Str""+ totalNumJsFiles);
    }
 else     if (numJsFilesExpected < totalNumJsFiles) {
      throw new FlagUsageException(""String_Node_Str"" + numJsFilesExpected + ""String_Node_Str""+ totalNumJsFiles);
    }
  }
  int numJsFilesLeft=totalNumJsFiles, moduleIndex=0;
  for (  String moduleName : moduleNames) {
    int numJsFiles=modulesFileCountMap.get(moduleName);
    JSModule module=modulesByName.get(moduleName);
    if (moduleIndex == moduleNames.size() - 1 && numJsFiles == -1) {
      numJsFiles=numJsFilesLeft;
    }
    List<SourceFile> moduleFiles=inputs.subList(numJsFilesLeft - numJsFiles,numJsFilesLeft);
    for (    SourceFile input : moduleFiles) {
      module.add(input);
    }
    numJsFilesLeft-=numJsFiles;
    moduleIndex++;
  }
  return new ArrayList<>(modulesByName.values());
}",0.6442322267697438
19494,"private ImmutableMap<String,JSType> calcTypeInstantiation(Node callNode,Node receiver,Node firstArg,FunctionType funType,TypeEnv typeEnv,boolean isFwd){
  Preconditions.checkState(receiver == null || isFwd);
  List<String> typeParameters=funType.getTypeParameters();
  Multimap<String,JSType> typeMultimap=LinkedHashMultimap.create();
  JSType funRecvType=funType.getThisType();
  if (receiver != null && funRecvType != null && !funRecvType.isSingletonObj()) {
    EnvTypePair pair=analyzeExprFwd(receiver,typeEnv);
    unifyWithSubtypeWarnIfFail(funRecvType,pair.type,typeParameters,typeMultimap,receiver,isFwd);
    typeEnv=pair.env;
  }
  Node arg=firstArg;
  int i=0;
  while (arg != null) {
    EnvTypePair pair=isFwd ? analyzeExprFwd(arg,typeEnv) : analyzeExprBwd(arg,typeEnv);
    unifyWithSubtypeWarnIfFail(funType.getFormalType(i),pair.type,typeParameters,typeMultimap,arg,isFwd);
    arg=arg.getNext();
    typeEnv=pair.env;
    i++;
  }
  ImmutableMap.Builder<String,JSType> builder=ImmutableMap.builder();
  for (  String typeParam : typeParameters) {
    Collection<JSType> types=typeMultimap.get(typeParam);
    if (types.size() > 1) {
      if (isFwd) {
        warnings.add(JSError.make(callNode,NOT_UNIQUE_INSTANTIATION,funType.toString(),typeParam,types.toString()));
      }
      builder.put(typeParam,JSType.UNKNOWN);
    }
 else     if (types.size() == 1) {
      JSType t=Iterables.getOnlyElement(types);
      builder.put(typeParam,t.isBottom() ? JSType.UNKNOWN : t);
    }
 else {
      builder.put(typeParam,JSType.UNKNOWN);
    }
  }
  return builder.build();
}","/** 
 * We don't use the requiredType of the context to unify with the return type. There are several difficulties: 1) A polymorphic function is allowed to return ANY subtype of the requiredType, so we would need to use a heuristic to determine the type to unify with. 2) It's hard to give good error messages in cases like: id('str') - 5 We want an invalid-operand-type, not a not-unique-instantiation. We don't take the arg evaluation order into account during instantiation. When calculating the instantiation, when do we use the receiver type? See the following snippet: / * @constructor * @template T * @param {T} x * / function Foo(x) {} / * @template T * @param {T} x * / Foo.prototype.f = function(x) {}; Foo.prototype.f.bind(new Foo(123), 'asdf'); Here, the receiver type of f is Foo<T>, but the T is the class's T, not the T of f's template declaration. OTOH, if f had a @this annotation that contained T, T would refer to f's T. There is no way of knowing what's the scope of the type variables in the receiver of the function type. But when THIS comes from the class, it is always a singleton object. So, we use a heuristic: if THIS is not a singleton obj, we know it comes from and we use it for the instantiation.
 */
private ImmutableMap<String,JSType> calcTypeInstantiation(Node callNode,Node receiver,Node firstArg,FunctionType funType,TypeEnv typeEnv,boolean isFwd){
  Preconditions.checkState(receiver == null || isFwd);
  List<String> typeParameters=funType.getTypeParameters();
  Multimap<String,JSType> typeMultimap=LinkedHashMultimap.create();
  JSType funRecvType=funType.getThisType();
  if (receiver != null && funRecvType != null && !funRecvType.isSingletonObj()) {
    EnvTypePair pair=analyzeExprFwd(receiver,typeEnv);
    unifyWithSubtypeWarnIfFail(funRecvType,pair.type,typeParameters,typeMultimap,receiver,isFwd);
    typeEnv=pair.env;
  }
  Node arg=firstArg;
  int i=0;
  while (arg != null) {
    EnvTypePair pair=isFwd ? analyzeExprFwd(arg,typeEnv) : analyzeExprBwd(arg,typeEnv);
    unifyWithSubtypeWarnIfFail(funType.getFormalType(i),pair.type,typeParameters,typeMultimap,arg,isFwd);
    arg=arg.getNext();
    typeEnv=pair.env;
    i++;
  }
  ImmutableMap.Builder<String,JSType> builder=ImmutableMap.builder();
  for (  String typeParam : typeParameters) {
    Collection<JSType> types=typeMultimap.get(typeParam);
    if (types.size() > 1) {
      if (isFwd) {
        warnings.add(JSError.make(callNode,NOT_UNIQUE_INSTANTIATION,funType.toString(),typeParam,types.toString()));
      }
      builder.put(typeParam,JSType.UNKNOWN);
    }
 else     if (types.size() == 1) {
      JSType t=Iterables.getOnlyElement(types);
      builder.put(typeParam,t.isBottom() ? JSType.UNKNOWN : t);
    }
 else {
      builder.put(typeParam,JSType.UNKNOWN);
    }
  }
  return builder.build();
}",0.720508166969147
19495,"@Override public boolean isSubtypeOf(TypeI other){
  JSType type2=(JSType)other;
  if (isLoose() || type2.isLoose()) {
    return autobox().isSubtypeOfHelper(true,type2.autobox());
  }
 else {
    return isSubtypeOfHelper(true,type2);
  }
}","@Override public boolean isSubtypeOf(TypeI other){
  if (this == other) {
    return true;
  }
  JSType type2=(JSType)other;
  if (isLoose() || type2.isLoose()) {
    return autobox().isSubtypeOfHelper(true,type2.autobox());
  }
 else {
    return isSubtypeOfHelper(true,type2);
  }
}",0.916030534351145
19496,"private boolean isInvariantWith(Multimap<String,JSType> typeMultimap,NominalType other){
  Preconditions.checkState(isGeneric());
  Preconditions.checkState(this.rawType == other.rawType);
  Map<String,JSType> newTypeMap=new LinkedHashMap<>();
  for (  String typeVar : typeMultimap.keySet()) {
    Collection<JSType> c=typeMultimap.get(typeVar);
    if (c.size() != 1) {
      return false;
    }
    newTypeMap.put(typeVar,Preconditions.checkNotNull(Iterables.getOnlyElement(c)));
  }
  NominalType instantiated=instantiateGenerics(newTypeMap);
  return Objects.equals(instantiated.typeMap,other.typeMap);
}","private boolean isInvariantWith(Multimap<String,JSType> typeMultimap,NominalType other){
  Preconditions.checkState(isGeneric());
  Preconditions.checkState(this.rawType == other.rawType);
  Map<String,JSType> newTypeMap=new LinkedHashMap<>();
  for (  String typeVar : typeMultimap.keySet()) {
    Collection<JSType> c=typeMultimap.get(typeVar);
    if (c.size() != 1) {
      return false;
    }
    newTypeMap.put(typeVar,Preconditions.checkNotNull(Iterables.getOnlyElement(c)));
  }
  NominalType instantiated=instantiateGenerics(newTypeMap);
  Map<String,JSType> otherMap=other.typeMap;
  for (  Map.Entry<String,JSType> entry : instantiated.typeMap.entrySet()) {
    JSType t1=entry.getValue();
    JSType t2=otherMap.get(entry.getKey());
    if (!t1.isSubtypeOf(t2) || !t2.isSubtypeOf(t1)) {
      return false;
    }
  }
  return true;
}",0.7592847317744154
19497,"public void testDifficultClassGenericsInstantiation(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.RETURN_NONDECLARED_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testDifficultClassGenericsInstantiation(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.RETURN_NONDECLARED_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.8665554628857381
19498,"/** 
 * Creates inputs from a list of source files, zips and json files. Can be overridden by subclasses who want to pull files from different places.
 * @param files A list of filenames.
 * @param zips A list of zip filenames.
 * @param jsonFiles A list of json encoded files.
 * @param allowStdIn Whether '-' is allowed appear as a filename to representstdin. If true, '-' is only allowed to appear once.
 * @return An array of inputs
 */
protected List<SourceFile> createInputs(List<String> files,List<String> zips,List<JsonFileSpec> jsonFiles,boolean allowStdIn) throws FlagUsageException, IOException {
  List<SourceFile> inputs=new ArrayList<>(files.size());
  boolean usingStdin=false;
  for (  String filename : files) {
    if (!""String_Node_Str"".equals(filename)) {
      SourceFile newFile=SourceFile.fromFile(filename,inputCharset);
      inputs.add(newFile);
    }
 else {
      if (!allowStdIn) {
        throw new FlagUsageException(""String_Node_Str"");
      }
      if (usingStdin) {
        throw new FlagUsageException(""String_Node_Str"");
      }
      if (!config.outputManifests.isEmpty()) {
        throw new FlagUsageException(""String_Node_Str"" + ""String_Node_Str"");
      }
      if (!config.outputBundles.isEmpty()) {
        throw new FlagUsageException(""String_Node_Str"" + ""String_Node_Str"");
      }
      this.err.println(WAITING_FOR_INPUT_WARNING);
      inputs.add(SourceFile.fromInputStream(""String_Node_Str"",this.in,inputCharset));
      usingStdin=true;
    }
  }
  for (  String zipName : zips) {
    if (!""String_Node_Str"".equals(zipName)) {
      List<SourceFile> newFiles=SourceFile.fromZipFile(zipName,inputCharset);
      inputs.addAll(newFiles);
    }
  }
  if (jsonFiles != null) {
    for (    JsonFileSpec jsonFile : jsonFiles) {
      inputs.add(SourceFile.fromCode(jsonFile.getPath(),jsonFile.getSrc()));
    }
  }
  return inputs;
}","/** 
 * Creates inputs from a list of source files, zips and json files. Can be overridden by subclasses who want to pull files from different places.
 * @param files A list of flag entries indicates js and zip file names
 * @param jsonFiles A list of json encoded files.
 * @param allowStdIn Whether '-' is allowed appear as a filename to representstdin. If true, '-' is only allowed to appear once.
 * @return An array of inputs
 */
protected List<SourceFile> createInputs(List<FlagEntry<JsSourceType>> files,List<JsonFileSpec> jsonFiles,boolean allowStdIn) throws FlagUsageException, IOException {
  List<SourceFile> inputs=new ArrayList<>(files.size());
  boolean usingStdin=false;
  for (  FlagEntry<JsSourceType> file : files) {
    String filename=file.value;
    if (file.flag == JsSourceType.JS_ZIP) {
      if (!""String_Node_Str"".equals(filename)) {
        List<SourceFile> newFiles=SourceFile.fromZipFile(filename,inputCharset);
        inputs.addAll(newFiles);
      }
    }
 else     if (!""String_Node_Str"".equals(filename)) {
      SourceFile newFile=SourceFile.fromFile(filename,inputCharset);
      inputs.add(newFile);
    }
 else {
      if (!allowStdIn) {
        throw new FlagUsageException(""String_Node_Str"");
      }
      if (usingStdin) {
        throw new FlagUsageException(""String_Node_Str"");
      }
      if (!config.outputManifests.isEmpty()) {
        throw new FlagUsageException(""String_Node_Str"" + ""String_Node_Str"");
      }
      if (!config.outputBundles.isEmpty()) {
        throw new FlagUsageException(""String_Node_Str"" + ""String_Node_Str"");
      }
      this.err.println(WAITING_FOR_INPUT_WARNING);
      inputs.add(SourceFile.fromInputStream(""String_Node_Str"",this.in,inputCharset));
      usingStdin=true;
    }
  }
  if (jsonFiles != null) {
    for (    JsonFileSpec jsonFile : jsonFiles) {
      inputs.add(SourceFile.fromCode(jsonFile.getPath(),jsonFile.getSrc()));
    }
  }
  return inputs;
}",0.837257980115123
19499,"/** 
 * Sets options based on the configurations set flags API. Called during the run() run() method. If you want to ignore the flags API, or interpret flags your own way, then you should override this method.
 */
protected void setRunOptions(CompilerOptions options) throws FlagUsageException, IOException {
  DiagnosticGroups diagnosticGroups=getDiagnosticGroups();
  if (config.warningGuards != null) {
    for (    WarningGuardSpec.Entry entry : config.warningGuards.entries) {
      if (""String_Node_Str"".equals(entry.groupName)) {
        Set<String> groupNames=diagnosticGroups.getRegisteredGroups().keySet();
        for (        String groupName : groupNames) {
          if (!DiagnosticGroups.wildcardExcludedGroups.contains(groupName)) {
            diagnosticGroups.setWarningLevel(options,groupName,entry.level);
          }
        }
      }
 else {
        diagnosticGroups.setWarningLevel(options,entry.groupName,entry.level);
      }
    }
  }
  if (!config.warningsWhitelistFile.isEmpty()) {
    addWhitelistWarningsGuard(options,new File(config.warningsWhitelistFile));
  }
  if (!config.hideWarningsFor.isEmpty()) {
    options.addWarningsGuard(new ShowByPathWarningsGuard(config.hideWarningsFor.toArray(new String[]{}),ShowByPathWarningsGuard.ShowType.EXCLUDE));
  }
  createDefineOrTweakReplacements(config.define,options,false);
  options.setTweakProcessing(config.tweakProcessing);
  createDefineOrTweakReplacements(config.tweak,options,true);
  DependencyOptions depOptions=createDependencyOptions(config.manageClosureDependencies,config.onlyClosureDependencies,config.processCommonJSModules,config.closureEntryPoints);
  if (depOptions != null) {
    options.setDependencyOptions(depOptions);
  }
  options.devMode=config.jscompDevMode;
  options.setCodingConvention(config.codingConvention);
  options.setSummaryDetailLevel(config.summaryDetailLevel);
  options.setTrustedStrings(true);
  legacyOutputCharset=options.outputCharset=getLegacyOutputCharset();
  outputCharset2=getOutputCharset2();
  inputCharset=getInputCharset();
  if (config.jsOutputFile.length() > 0) {
    if (config.skipNormalOutputs) {
      throw new FlagUsageException(""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  if (config.skipNormalOutputs && config.printAst) {
    throw new FlagUsageException(""String_Node_Str"" + ""String_Node_Str"");
  }
  if (config.skipNormalOutputs && config.printTree) {
    throw new FlagUsageException(""String_Node_Str"" + ""String_Node_Str"");
  }
  if (config.createSourceMap.length() > 0) {
    options.sourceMapOutputPath=config.createSourceMap;
  }
 else   if (isOutputInJson()) {
    options.sourceMapOutputPath=""String_Node_Str"";
  }
  options.sourceMapDetailLevel=config.sourceMapDetailLevel;
  options.sourceMapFormat=config.sourceMapFormat;
  options.sourceMapLocationMappings=config.sourceMapLocationMappings;
  ImmutableMap.Builder<String,SourceMapInput> inputSourceMaps=new ImmutableMap.Builder<>();
  for (  Map.Entry<String,String> files : config.sourceMapInputFiles.entrySet()) {
    SourceFile sourceMap=SourceFile.fromFile(files.getValue());
    inputSourceMaps.put(files.getKey(),new SourceMapInput(sourceMap));
  }
  options.inputSourceMaps=inputSourceMaps.build();
  if (!config.variableMapInputFile.isEmpty()) {
    options.inputVariableMap=VariableMap.load(config.variableMapInputFile);
  }
  if (!config.propertyMapInputFile.isEmpty()) {
    options.inputPropertyMap=VariableMap.load(config.propertyMapInputFile);
  }
  if (config.languageIn.length() > 0) {
    CompilerOptions.LanguageMode languageMode=CompilerOptions.LanguageMode.fromString(config.languageIn);
    if (languageMode != null) {
      options.setLanguageIn(languageMode);
    }
 else {
      throw new FlagUsageException(""String_Node_Str"" + config.languageIn + ""String_Node_Str"");
    }
  }
  if (config.languageOut.isEmpty()) {
    options.setLanguageOut(options.getLanguageIn());
  }
 else {
    CompilerOptions.LanguageMode languageMode=CompilerOptions.LanguageMode.fromString(config.languageOut);
    if (languageMode != null) {
      options.setLanguageOut(languageMode);
    }
 else {
      throw new FlagUsageException(""String_Node_Str"" + config.languageOut + ""String_Node_Str"");
    }
  }
  if (!config.outputManifests.isEmpty()) {
    Set<String> uniqueNames=new HashSet<>();
    for (    String filename : config.outputManifests) {
      if (!uniqueNames.add(filename)) {
        throw new FlagUsageException(""String_Node_Str"" + ""String_Node_Str"" + filename);
      }
    }
  }
  if (!config.outputBundles.isEmpty()) {
    Set<String> uniqueNames=new HashSet<>();
    for (    String filename : config.outputBundles) {
      if (!uniqueNames.add(filename)) {
        throw new FlagUsageException(""String_Node_Str"" + ""String_Node_Str"" + filename);
      }
    }
  }
  options.transformAMDToCJSModules=config.transformAMDToCJSModules;
  options.processCommonJSModules=config.processCommonJSModules;
  options.moduleRoots=config.moduleRoots;
  options.angularPass=config.angularPass;
  options.tracer=config.tracerMode;
  options.setNewTypeInference(config.useNewTypeInference);
  options.instrumentationTemplateFile=config.instrumentationTemplateFile;
}","/** 
 * Sets options based on the configurations set flags API. Called during the run() run() method. If you want to ignore the flags API, or interpret flags your own way, then you should override this method.
 */
protected void setRunOptions(CompilerOptions options) throws FlagUsageException, IOException {
  DiagnosticGroups diagnosticGroups=getDiagnosticGroups();
  if (config.warningGuards != null) {
    for (    FlagEntry<CheckLevel> entry : config.warningGuards) {
      if (""String_Node_Str"".equals(entry.value)) {
        Set<String> groupNames=diagnosticGroups.getRegisteredGroups().keySet();
        for (        String groupName : groupNames) {
          if (!DiagnosticGroups.wildcardExcludedGroups.contains(groupName)) {
            diagnosticGroups.setWarningLevel(options,groupName,entry.flag);
          }
        }
      }
 else {
        diagnosticGroups.setWarningLevel(options,entry.value,entry.flag);
      }
    }
  }
  if (!config.warningsWhitelistFile.isEmpty()) {
    addWhitelistWarningsGuard(options,new File(config.warningsWhitelistFile));
  }
  if (!config.hideWarningsFor.isEmpty()) {
    options.addWarningsGuard(new ShowByPathWarningsGuard(config.hideWarningsFor.toArray(new String[]{}),ShowByPathWarningsGuard.ShowType.EXCLUDE));
  }
  createDefineOrTweakReplacements(config.define,options,false);
  options.setTweakProcessing(config.tweakProcessing);
  createDefineOrTweakReplacements(config.tweak,options,true);
  DependencyOptions depOptions=createDependencyOptions(config.manageClosureDependencies,config.onlyClosureDependencies,config.processCommonJSModules,config.closureEntryPoints);
  if (depOptions != null) {
    options.setDependencyOptions(depOptions);
  }
  options.devMode=config.jscompDevMode;
  options.setCodingConvention(config.codingConvention);
  options.setSummaryDetailLevel(config.summaryDetailLevel);
  options.setTrustedStrings(true);
  legacyOutputCharset=options.outputCharset=getLegacyOutputCharset();
  outputCharset2=getOutputCharset2();
  inputCharset=getInputCharset();
  if (config.jsOutputFile.length() > 0) {
    if (config.skipNormalOutputs) {
      throw new FlagUsageException(""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  if (config.skipNormalOutputs && config.printAst) {
    throw new FlagUsageException(""String_Node_Str"" + ""String_Node_Str"");
  }
  if (config.skipNormalOutputs && config.printTree) {
    throw new FlagUsageException(""String_Node_Str"" + ""String_Node_Str"");
  }
  if (config.createSourceMap.length() > 0) {
    options.sourceMapOutputPath=config.createSourceMap;
  }
 else   if (isOutputInJson()) {
    options.sourceMapOutputPath=""String_Node_Str"";
  }
  options.sourceMapDetailLevel=config.sourceMapDetailLevel;
  options.sourceMapFormat=config.sourceMapFormat;
  options.sourceMapLocationMappings=config.sourceMapLocationMappings;
  ImmutableMap.Builder<String,SourceMapInput> inputSourceMaps=new ImmutableMap.Builder<>();
  for (  Map.Entry<String,String> files : config.sourceMapInputFiles.entrySet()) {
    SourceFile sourceMap=SourceFile.fromFile(files.getValue());
    inputSourceMaps.put(files.getKey(),new SourceMapInput(sourceMap));
  }
  options.inputSourceMaps=inputSourceMaps.build();
  if (!config.variableMapInputFile.isEmpty()) {
    options.inputVariableMap=VariableMap.load(config.variableMapInputFile);
  }
  if (!config.propertyMapInputFile.isEmpty()) {
    options.inputPropertyMap=VariableMap.load(config.propertyMapInputFile);
  }
  if (config.languageIn.length() > 0) {
    CompilerOptions.LanguageMode languageMode=CompilerOptions.LanguageMode.fromString(config.languageIn);
    if (languageMode != null) {
      options.setLanguageIn(languageMode);
    }
 else {
      throw new FlagUsageException(""String_Node_Str"" + config.languageIn + ""String_Node_Str"");
    }
  }
  if (config.languageOut.isEmpty()) {
    options.setLanguageOut(options.getLanguageIn());
  }
 else {
    CompilerOptions.LanguageMode languageMode=CompilerOptions.LanguageMode.fromString(config.languageOut);
    if (languageMode != null) {
      options.setLanguageOut(languageMode);
    }
 else {
      throw new FlagUsageException(""String_Node_Str"" + config.languageOut + ""String_Node_Str"");
    }
  }
  if (!config.outputManifests.isEmpty()) {
    Set<String> uniqueNames=new HashSet<>();
    for (    String filename : config.outputManifests) {
      if (!uniqueNames.add(filename)) {
        throw new FlagUsageException(""String_Node_Str"" + ""String_Node_Str"" + filename);
      }
    }
  }
  if (!config.outputBundles.isEmpty()) {
    Set<String> uniqueNames=new HashSet<>();
    for (    String filename : config.outputBundles) {
      if (!uniqueNames.add(filename)) {
        throw new FlagUsageException(""String_Node_Str"" + ""String_Node_Str"" + filename);
      }
    }
  }
  options.transformAMDToCJSModules=config.transformAMDToCJSModules;
  options.processCommonJSModules=config.processCommonJSModules;
  options.moduleRoots=config.moduleRoots;
  options.angularPass=config.angularPass;
  options.tracer=config.tracerMode;
  options.setNewTypeInference(config.useNewTypeInference);
  options.instrumentationTemplateFile=config.instrumentationTemplateFile;
}",0.969942978641152
19500,"/** 
 * Creates JS source code inputs from a list of files.
 */
private List<SourceFile> createSourceInputs(List<String> files,List<String> zips,List<JsonFileSpec> jsonFiles) throws FlagUsageException, IOException {
  if (isInTestMode()) {
    return inputsSupplierForTesting != null ? inputsSupplierForTesting.get() : null;
  }
  if (files.isEmpty() && zips.isEmpty() && jsonFiles == null) {
    files=Collections.singletonList(""String_Node_Str"");
  }
  try {
    if (jsonFiles != null) {
      return createInputs(files,jsonFiles);
    }
 else {
      return createInputs(files,zips,true);
    }
  }
 catch (  FlagUsageException e) {
    throw new FlagUsageException(""String_Node_Str"" + e.getMessage());
  }
}","/** 
 * Creates JS source code inputs from a list of files.
 */
private List<SourceFile> createSourceInputs(List<FlagEntry<JsSourceType>> files,List<JsonFileSpec> jsonFiles) throws FlagUsageException, IOException {
  if (isInTestMode()) {
    return inputsSupplierForTesting != null ? inputsSupplierForTesting.get() : null;
  }
  if (files.isEmpty() && jsonFiles == null) {
    files=Collections.singletonList(new FlagEntry<JsSourceType>(JsSourceType.JS,""String_Node_Str""));
  }
  try {
    if (jsonFiles != null) {
      return createInputs(files,jsonFiles);
    }
 else {
      return createInputs(files,true);
    }
  }
 catch (  FlagUsageException e) {
    throw new FlagUsageException(""String_Node_Str"" + e.getMessage());
  }
}",0.916146916146916
19501,"/** 
 * Creates JS extern inputs from a list of files.
 */
private List<SourceFile> createExternInputs(List<String> files) throws FlagUsageException, IOException {
  if (files.isEmpty()) {
    return ImmutableList.of(SourceFile.fromCode(""String_Node_Str"",""String_Node_Str""));
  }
  try {
    return createInputs(files,false);
  }
 catch (  FlagUsageException e) {
    throw new FlagUsageException(""String_Node_Str"" + e.getMessage());
  }
}","/** 
 * Creates JS extern inputs from a list of files.
 */
private List<SourceFile> createExternInputs(List<String> files) throws FlagUsageException, IOException {
  if (files.isEmpty()) {
    return ImmutableList.of(SourceFile.fromCode(""String_Node_Str"",""String_Node_Str""));
  }
  List<FlagEntry<JsSourceType>> externFiles=new ArrayList<>();
  for (  String file : files) {
    externFiles.add(new FlagEntry<JsSourceType>(JsSourceType.EXTERN,file));
  }
  try {
    return createInputs(externFiles,false);
  }
 catch (  FlagUsageException e) {
    throw new FlagUsageException(""String_Node_Str"" + e.getMessage());
  }
}",0.8215297450424929
19502,"/** 
 * Parses command-line arguments and runs the compiler.
 * @return system exit status
 */
protected int doRun() throws FlagUsageException, IOException {
  Compiler.setLoggingLevel(Level.parse(config.loggingLevel));
  compiler=createCompiler();
  B options=createOptions();
  List<SourceFile> externs=createExterns(options);
  List<JSModule> modules=null;
  Result result=null;
  setRunOptions(options);
  boolean writeOutputToFile=!config.jsOutputFile.isEmpty();
  List<String> outputFileNames=new ArrayList<>();
  if (writeOutputToFile) {
    outputFileNames.add(config.jsOutputFile);
  }
  List<String> jsFiles=config.js;
  List<String> moduleSpecs=config.module;
  List<JsonFileSpec> jsonFiles=null;
  if (config.jsonStreamMode == JsonStreamMode.IN || config.jsonStreamMode == JsonStreamMode.BOTH) {
    jsonFiles=parseJsonFilesFromInputStream();
    ImmutableMap.Builder<String,SourceMapInput> inputSourceMaps=new ImmutableMap.Builder<>();
    boolean foundJsonInputSourceMap=false;
    for (    JsonFileSpec jsonFile : jsonFiles) {
      if (jsonFile.getSourceMap() != null && jsonFile.getSourceMap().length() > 0) {
        String sourceMapPath=jsonFile.getPath() + ""String_Node_Str"";
        SourceFile sourceMap=SourceFile.fromCode(sourceMapPath,jsonFile.getSourceMap());
        inputSourceMaps.put(sourceMapPath,new SourceMapInput(sourceMap));
        foundJsonInputSourceMap=true;
      }
    }
    if (foundJsonInputSourceMap) {
      inputSourceMaps.putAll(options.inputSourceMaps);
      options.inputSourceMaps=inputSourceMaps.build();
    }
  }
  boolean createCommonJsModules=false;
  if (options.processCommonJSModules && (moduleSpecs.size() == 1 && ""String_Node_Str"".equals(moduleSpecs.get(0)))) {
    createCommonJsModules=true;
    moduleSpecs.remove(0);
  }
  List<SourceFile> inputs=createSourceInputs(jsFiles,config.jsZip,jsonFiles);
  if (!moduleSpecs.isEmpty()) {
    modules=createJsModules(moduleSpecs,inputs);
    for (    JSModule m : modules) {
      outputFileNames.add(getModuleOutputFileName(m));
    }
    if (config.skipNormalOutputs) {
      compiler.initModules(externs,modules,options);
    }
 else {
      result=compiler.compileModules(externs,modules,options);
    }
  }
 else {
    if (config.skipNormalOutputs) {
      compiler.init(externs,inputs,options);
      compiler.hoistExterns();
    }
 else {
      result=compiler.compile(externs,inputs,options);
    }
  }
  if (createCommonJsModules) {
    modules=ImmutableList.copyOf(compiler.getDegenerateModuleGraph().getAllModules());
    for (    JSModule m : modules) {
      outputFileNames.add(getModuleOutputFileName(m));
    }
  }
  for (  String outputFileName : outputFileNames) {
    if (compiler.getSourceFileByName(outputFileName) != null) {
      compiler.report(JSError.make(OUTPUT_SAME_AS_INPUT_ERROR,outputFileName));
      return 1;
    }
  }
  return processResults(result,modules,options);
}","/** 
 * Parses command-line arguments and runs the compiler.
 * @return system exit status
 */
protected int doRun() throws FlagUsageException, IOException {
  Compiler.setLoggingLevel(Level.parse(config.loggingLevel));
  compiler=createCompiler();
  B options=createOptions();
  List<SourceFile> externs=createExterns(options);
  List<JSModule> modules=null;
  Result result=null;
  setRunOptions(options);
  boolean writeOutputToFile=!config.jsOutputFile.isEmpty();
  List<String> outputFileNames=new ArrayList<>();
  if (writeOutputToFile) {
    outputFileNames.add(config.jsOutputFile);
  }
  List<String> moduleSpecs=config.module;
  List<JsonFileSpec> jsonFiles=null;
  if (config.jsonStreamMode == JsonStreamMode.IN || config.jsonStreamMode == JsonStreamMode.BOTH) {
    jsonFiles=parseJsonFilesFromInputStream();
    ImmutableMap.Builder<String,SourceMapInput> inputSourceMaps=new ImmutableMap.Builder<>();
    boolean foundJsonInputSourceMap=false;
    for (    JsonFileSpec jsonFile : jsonFiles) {
      if (jsonFile.getSourceMap() != null && jsonFile.getSourceMap().length() > 0) {
        String sourceMapPath=jsonFile.getPath() + ""String_Node_Str"";
        SourceFile sourceMap=SourceFile.fromCode(sourceMapPath,jsonFile.getSourceMap());
        inputSourceMaps.put(sourceMapPath,new SourceMapInput(sourceMap));
        foundJsonInputSourceMap=true;
      }
    }
    if (foundJsonInputSourceMap) {
      inputSourceMaps.putAll(options.inputSourceMaps);
      options.inputSourceMaps=inputSourceMaps.build();
    }
  }
  boolean createCommonJsModules=false;
  if (options.processCommonJSModules && (moduleSpecs.size() == 1 && ""String_Node_Str"".equals(moduleSpecs.get(0)))) {
    createCommonJsModules=true;
    moduleSpecs.remove(0);
  }
  List<SourceFile> inputs=createSourceInputs(config.mixedJsSources,jsonFiles);
  if (!moduleSpecs.isEmpty()) {
    modules=createJsModules(moduleSpecs,inputs);
    for (    JSModule m : modules) {
      outputFileNames.add(getModuleOutputFileName(m));
    }
    if (config.skipNormalOutputs) {
      compiler.initModules(externs,modules,options);
    }
 else {
      result=compiler.compileModules(externs,modules,options);
    }
  }
 else {
    if (config.skipNormalOutputs) {
      compiler.init(externs,inputs,options);
      compiler.hoistExterns();
    }
 else {
      result=compiler.compile(externs,inputs,options);
    }
  }
  if (createCommonJsModules) {
    modules=ImmutableList.copyOf(compiler.getDegenerateModuleGraph().getAllModules());
    for (    JSModule m : modules) {
      outputFileNames.add(getModuleOutputFileName(m));
    }
  }
  for (  String outputFileName : outputFileNames) {
    if (compiler.getSourceFileByName(outputFileName) != null) {
      compiler.report(JSError.make(OUTPUT_SAME_AS_INPUT_ERROR,outputFileName));
      return 1;
    }
  }
  return processResults(result,modules,options);
}",0.9870354364736388
19503,"/** 
 * @param name Closure namespace used as an entry point. May start""goog:"" when provided as a flag from the command line. Closure entry points may also be formatted as: 'moduleName:name.space' which specifies that the module name and provided namespace are different
 */
public static ModuleIdentifier forClosure(String name){
  String normalizedName=name;
  if (normalizedName.startsWith(""String_Node_Str"")) {
    normalizedName=normalizedName.substring(5);
  }
  String namespace=normalizedName;
  String moduleName=normalizedName;
  int splitPoint=normalizedName.indexOf(':');
  if (splitPoint != -1) {
    moduleName=normalizedName.substring(0,splitPoint);
    namespace=normalizedName.substring(Math.min(splitPoint + 1,normalizedName.length() - 1));
  }
  return new ModuleIdentifier(normalizedName,namespace,moduleName);
}","/** 
 * @param name Closure namespace used as an entry point. May start""goog:"" when provided as a flag from the command line. Closure entry points may also be formatted as: 'goog:moduleName:name.space' which specifies that the module name and provided namespace are different
 */
public static ModuleIdentifier forClosure(String name){
  String normalizedName=name;
  if (normalizedName.startsWith(""String_Node_Str"")) {
    normalizedName=normalizedName.substring(""String_Node_Str"".length());
  }
  String namespace=normalizedName;
  String moduleName=normalizedName;
  int splitPoint=normalizedName.indexOf(':');
  if (splitPoint != -1) {
    moduleName=normalizedName.substring(0,splitPoint);
    namespace=normalizedName.substring(Math.min(splitPoint + 1,normalizedName.length() - 1));
  }
  return new ModuleIdentifier(normalizedName,namespace,moduleName);
}",0.9811097992916176
19504,"/** 
 * Enables or disables the preservation of all whitespace and formatting within a JSDoc comment. By default, whitespace is collapsed for all comments except @license and
 * @preserve blocks,<p>Setting this option has no effect if  {@link #isParseJsDocDocumentation()}returns false.
 * @param preserveJsDocWhitespace True to preserve whitespace in text extracted from JSDoc comments.
 */
public void setPreserveJsDocWhitespace(boolean preserveJsDocWhitespace){
  this.preserveJsDocWhitespace=preserveJsDocWhitespace;
}","/** 
 * Enables or disables the preservation of all whitespace and formatting within a JSDoc comment. By default, whitespace is collapsed for all comments except   {@literal @license} and{@literal @preserve} blocks,<p>Setting this option has no effect if  {@link #isParseJsDocDocumentation()}returns false.
 * @param preserveJsDocWhitespace True to preserve whitespace in text extracted from JSDoc comments.
 */
public void setPreserveJsDocWhitespace(boolean preserveJsDocWhitespace){
  this.preserveJsDocWhitespace=preserveJsDocWhitespace;
}",0.943609022556391
19505,"/** 
 * The expected format looks like this: <p>[generatorName1] someId1:someFile:theLine:theColumn ... <p>[[generatorName2] someId2:someFile:theLine:theColumn] ... <p>The returned data is grouped by generator name (the map key). The inner map provides mappings from id to content (file, line and column info). In a glimpse, the structure is Map<geneartor name, BiMap<id, value>>. <p>@throws IllegalArgumentException malformed input where there it 1) has duplicate generator name, or 2) the line has no ':' for id and its content.
 */
public static Map<String,BiMap<String,String>> parseSerializedIdMappings(String idMappings){
  if (Strings.isNullOrEmpty(idMappings)) {
    return Collections.emptyMap();
  }
  Map<String,BiMap<String,String>> resultMap=new HashMap<>();
  BiMap<String,String> currentSectionMap=null;
  int lineIndex=0;
  for (  String line : LINE_SPLITTER.split(idMappings)) {
    lineIndex++;
    if (line.isEmpty()) {
      continue;
    }
    if (line.charAt(0) == '[') {
      String currentSection=line.substring(1,line.length() - 1);
      currentSectionMap=resultMap.get(currentSection);
      if (currentSectionMap == null) {
        currentSectionMap=HashBiMap.create();
        resultMap.put(currentSection,currentSectionMap);
      }
 else {
        throw new IllegalArgumentException(SimpleFormat.format(""String_Node_Str"",idMappings,line,lineIndex));
      }
    }
 else {
      int split=line.indexOf(':');
      if (split != -1) {
        String name=line.substring(0,split);
        String location=line.substring(split + 1,line.length());
        currentSectionMap.put(name,location);
      }
 else {
        throw new IllegalArgumentException(SimpleFormat.format(""String_Node_Str"",idMappings,line,lineIndex));
      }
    }
  }
  return resultMap;
}","/** 
 * The expected format looks like this: <p>[generatorName1] someId1:someFile:theLine:theColumn ... <p>[[generatorName2] someId2:someFile:theLine:theColumn] ... <p>The returned data is grouped by generator name (the map key). The inner map provides mappings from id to content (file, line and column info). In a glimpse, the structure is  {@code Map<generator name, BiMap<id, value>>}. <p>@throws IllegalArgumentException malformed input where there it 1) has duplicate generator name, or 2) the line has no ':' for id and its content.
 */
public static Map<String,BiMap<String,String>> parseSerializedIdMappings(String idMappings){
  if (Strings.isNullOrEmpty(idMappings)) {
    return Collections.emptyMap();
  }
  Map<String,BiMap<String,String>> resultMap=new HashMap<>();
  BiMap<String,String> currentSectionMap=null;
  int lineIndex=0;
  for (  String line : LINE_SPLITTER.split(idMappings)) {
    lineIndex++;
    if (line.isEmpty()) {
      continue;
    }
    if (line.charAt(0) == '[') {
      String currentSection=line.substring(1,line.length() - 1);
      currentSectionMap=resultMap.get(currentSection);
      if (currentSectionMap == null) {
        currentSectionMap=HashBiMap.create();
        resultMap.put(currentSection,currentSectionMap);
      }
 else {
        throw new IllegalArgumentException(SimpleFormat.format(""String_Node_Str"",idMappings,line,lineIndex));
      }
    }
 else {
      int split=line.indexOf(':');
      if (split != -1) {
        String name=line.substring(0,split);
        String location=line.substring(split + 1,line.length());
        currentSectionMap.put(name,location);
      }
 else {
        throw new IllegalArgumentException(SimpleFormat.format(""String_Node_Str"",idMappings,line,lineIndex));
      }
    }
  }
  return resultMap;
}",0.996367700474993
19506,"/** 
 * Get a region around the indicated line number. The exact definition of a region is implementation specific, but it must contain the line indicated by the line number. A region must not start or end by a carriage return.
 * @param lineNumber the line number, 1 being the first line of the file
 * @return the region around the line number indicated, or <code>null</null>if it does not exist
 */
Region getSourceRegion(String sourceName,int lineNumber);","/** 
 * Get a region around the indicated line number. The exact definition of a region is implementation specific, but it must contain the line indicated by the line number. A region must not start or end by a carriage return.
 * @param lineNumber the line number, 1 being the first line of the file
 * @return the region around the line number indicated, or {@code null}if it does not exist
 */
Region getSourceRegion(String sourceName,int lineNumber);",0.968236582694414
19507,"/** 
 * This class depends on an input set that contains the white-list. The format of each white-list string is: <file-name>:<line-number>?  <warning-description> # <optional-comment>
 * @param whitelist The set of JS-warnings that are white-listed. This isexpected to have similar format as  {@code formatWarning(JSError)}.
 */
public WhitelistWarningsGuard(Set<String> whitelist){
  Preconditions.checkNotNull(whitelist);
  this.whitelist=normalizeWhitelist(whitelist);
}","/** 
 * This class depends on an input set that contains the white-list. The format of each white-list string is:  {@code <file-name>:<line-number>?  <warning-description>}{@code # <optional-comment>}
 * @param whitelist The set of JS-warnings that are white-listed. This isexpected to have similar format as  {@code formatWarning(JSError)}.
 */
public WhitelistWarningsGuard(Set<String> whitelist){
  Preconditions.checkNotNull(whitelist);
  this.whitelist=normalizeWhitelist(whitelist);
}",0.983402489626556
19508,"/** 
 * Adds a <entrypoint/> entry Each entrypoint entry must have one attribute, name.
 */
public void addEntryPoint(Parameter entrypoint){
  this.entryPointParams.add(entrypoint);
}","/** 
 * Adds a   {@code <entrypoint/>} entryEach entrypoint entry must have one attribute, name.
 */
public void addEntryPoint(Parameter entrypoint){
  this.entryPointParams.add(entrypoint);
}",0.9706666666666668
19509,"/** 
 * Adds a <warning/> entry Each warning entry must have two attributes, group and level. Group must contain one of the constants from DiagnosticGroups (e.g., ""ACCESS_CONTROLS""), while level must contain one of the CheckLevel constants (""ERROR"", ""WARNING"" or ""OFF"").
 */
public void addWarning(Warning warning){
  this.warnings.add(warning);
}","/** 
 * Adds a   {@code <warning/>} entryEach warning entry must have two attributes, group and level. Group must contain one of the constants from DiagnosticGroups (e.g., ""ACCESS_CONTROLS""), while level must contain one of the CheckLevel constants (""ERROR"", ""WARNING"" or ""OFF"").
 */
public void addWarning(Warning warning){
  this.warnings.add(warning);
}",0.984352773826458
19510,"/** 
 * Constructs a DependencyInfo object with the given list of provides & requires. This does *not* copy the given lists, but uses them directly.
 * @param srcPathRelativeToClosure The closure-relative path of the fileassociated with this DependencyInfo.
 * @param pathOfDefiningFile The path to the file from which this dependencyinformation was extracted.
 * @param provides List of provided symbols.
 * @param requires List of required symbols.
 */
public SimpleDependencyInfo(String srcPathRelativeToClosure,String pathOfDefiningFile,List<String> provides,List<String> requires,boolean isModule){
  this.srcPathRelativeToClosure=srcPathRelativeToClosure;
  this.pathOfDefiningFile=pathOfDefiningFile;
  this.provides=provides;
  this.requires=requires;
  this.isModule=isModule;
}","/** 
 * Constructs a DependencyInfo object with the given list of provides and requires. This does *not* copy the given lists, but uses them directly.
 * @param srcPathRelativeToClosure The closure-relative path of the fileassociated with this DependencyInfo.
 * @param pathOfDefiningFile The path to the file from which this dependencyinformation was extracted.
 * @param provides List of provided symbols.
 * @param requires List of required symbols.
 */
public SimpleDependencyInfo(String srcPathRelativeToClosure,String pathOfDefiningFile,List<String> provides,List<String> requires,boolean isModule){
  this.srcPathRelativeToClosure=srcPathRelativeToClosure;
  this.pathOfDefiningFile=pathOfDefiningFile;
  this.provides=provides;
  this.requires=requires;
  this.isModule=isModule;
}",0.9974619289340102
19511,"/** 
 * Unify   {@code this}, which may contain free type variables, with   {@code other}, a concrete type, modifying the supplied  {@code typeMultimap} to add any new template varaible type bindings.
 * @return Whether unification succeeded
 */
boolean unifyWithSubtype(ObjectType other,List<String> typeParameters,Multimap<String,JSType> typeMultimap){
  if (fn != null) {
    if (other.fn == null || !fn.unifyWithSubtype(other.fn,typeParameters,typeMultimap)) {
      return false;
    }
  }
  if (nominalType != null && other.nominalType != null) {
    return nominalType.unifyWithSubtype(other.nominalType,typeParameters,typeMultimap);
  }
  if (nominalType != null || other.nominalType != null) {
    return false;
  }
  for (  String propName : this.props.keySet()) {
    Property thisProp=props.get(propName);
    Property otherProp=other.props.get(propName);
    if (otherProp != null && !thisProp.unifyWithSubtype(otherProp,typeParameters,typeMultimap)) {
      return false;
    }
  }
  return true;
}","/** 
 * Unify   {@code this}, which may contain free type variables, with   {@code other}, a concrete type, modifying the supplied  {@code typeMultimap} to add any new template varaible type bindings.
 * @return Whether unification succeeded
 */
boolean unifyWithSubtype(ObjectType other,List<String> typeParameters,Multimap<String,JSType> typeMultimap){
  if (fn != null) {
    if (other.fn == null || !fn.unifyWithSubtype(other.fn,typeParameters,typeMultimap)) {
      return false;
    }
  }
  if (nominalType != null && other.nominalType != null) {
    return nominalType.unifyWithSubtype(other.nominalType,typeParameters,typeMultimap);
  }
  if (nominalType != null && other.nominalType == null) {
    return false;
  }
  for (  String propName : this.props.keySet()) {
    Property thisProp=props.get(propName);
    Property otherProp=other.props.get(propName);
    if (otherProp != null && !thisProp.unifyWithSubtype(otherProp,typeParameters,typeMultimap)) {
      return false;
    }
  }
  return true;
}",0.8063241106719368
19512,"public void testUnificationWithSubtyping(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testUnificationWithSubtyping(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.9380191693290736
19513,"/** 
 * Unify the two types symmetrically, given that we have already instantiated the type variables of interest in   {@code t1} and {@code t2}, treating JSType.UNKNOWN as a ""hole"" to be filled.
 * @return The unified type, or null if unification fails
 */
static ObjectType unifyUnknowns(ObjectType t1,ObjectType t2){
  if (!Objects.equals(t1.nominalType,t2.nominalType)) {
    return null;
  }
  FunctionType newFn=null;
  if (t1.fn != null || t2.fn != null) {
    newFn=FunctionType.unifyUnknowns(t1.fn,t2.fn);
    if (newFn == null) {
      return null;
    }
  }
  PersistentMap<String,Property> newProps=PersistentMap.create();
  for (  String propName : t1.props.keySet()) {
    Property prop1=t1.props.get(propName);
    Property prop2=t2.props.get(propName);
    if (prop2 == null) {
      return null;
    }
    Property p=Property.unifyUnknowns(prop1,prop2);
    if (p == null) {
      return null;
    }
    newProps=newProps.with(propName,p);
  }
  return makeObjectType(t1.nominalType,newProps,newFn,t1.isLoose || t2.isLoose,ObjectKind.join(t1.objectKind,t2.objectKind));
}","/** 
 * Unify the two types symmetrically, given that we have already instantiated the type variables of interest in   {@code t1} and {@code t2}, treating JSType.UNKNOWN as a ""hole"" to be filled.
 * @return The unified type, or null if unification fails
 */
static ObjectType unifyUnknowns(ObjectType t1,ObjectType t2){
  NominalType nt1=t1.nominalType;
  NominalType nt2=t2.nominalType;
  NominalType nt;
  if (nt1 == null && nt2 == null) {
    nt=null;
  }
 else   if (nt1 == null || nt2 == null) {
    return null;
  }
 else {
    nt=NominalType.unifyUnknowns(nt1,nt2);
    if (nt == null) {
      return null;
    }
  }
  FunctionType newFn=null;
  if (t1.fn != null || t2.fn != null) {
    newFn=FunctionType.unifyUnknowns(t1.fn,t2.fn);
    if (newFn == null) {
      return null;
    }
  }
  PersistentMap<String,Property> newProps=PersistentMap.create();
  for (  String propName : t1.props.keySet()) {
    Property prop1=t1.props.get(propName);
    Property prop2=t2.props.get(propName);
    if (prop2 == null) {
      return null;
    }
    Property p=Property.unifyUnknowns(prop1,prop2);
    if (p == null) {
      return null;
    }
    newProps=newProps.with(propName,p);
  }
  return makeObjectType(nt,newProps,newFn,t1.isLoose || t2.isLoose,ObjectKind.join(t1.objectKind,t2.objectKind));
}",0.3529903805938937
19514,"public void testFunctionTypeUnifyUnknowns(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.NOT_UNIQUE_INSTANTIATION);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.NOT_UNIQUE_INSTANTIATION);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.NOT_UNIQUE_INSTANTIATION);
}","public void testFunctionTypeUnifyUnknowns(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.NOT_UNIQUE_INSTANTIATION);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.NOT_UNIQUE_INSTANTIATION);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.NOT_UNIQUE_INSTANTIATION);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.9198396793587176
19515,"public void testGenericsSubtyping(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),GlobalTypeInfo.INVALID_PROP_OVERRIDE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),GlobalTypeInfo.INVALID_PROP_OVERRIDE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),GlobalTypeInfo.INVALID_PROP_OVERRIDE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),GlobalTypeInfo.INVALID_PROP_OVERRIDE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),GlobalTypeInfo.INVALID_PROP_OVERRIDE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),GlobalTypeInfo.INVALID_PROP_OVERRIDE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public void testGenericsSubtyping(){
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),GlobalTypeInfo.INVALID_PROP_OVERRIDE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),GlobalTypeInfo.INVALID_PROP_OVERRIDE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),GlobalTypeInfo.INVALID_PROP_OVERRIDE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),GlobalTypeInfo.INVALID_PROP_OVERRIDE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),GlobalTypeInfo.INVALID_PROP_OVERRIDE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),GlobalTypeInfo.INVALID_PROP_OVERRIDE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  typeCheck(LINE_JOINER.join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.9726554977854804
19516,"private void visitVar(Node nameNode,Node parent){
  String name=nameNode.getString();
  if (this.currentScope.isNamespace(name) || NodeUtil.isTypedefDecl(nameNode) || NodeUtil.isEnumDecl(nameNode)) {
    if (!this.currentScope.isDefinedLocally(name,false)) {
      this.currentScope.addLocal(name,JSType.UNKNOWN,false,nameNode.isFromExterns());
    }
    return;
  }
  Node initializer=nameNode.getFirstChild();
  if (initializer != null && initializer.isFunction()) {
    return;
  }
 else   if (this.currentScope.isDefinedLocally(name,false)) {
    return;
  }
  if (parent.isCatch()) {
    this.currentScope.addLocal(name,JSType.UNKNOWN,false,false);
  }
 else {
    boolean isConst=isConst(nameNode);
    JSType declType=getVarTypeFromAnnotation(nameNode,this.currentScope);
    if (declType == null) {
      declType=mayInferFromRhsIfConst(nameNode);
    }
    this.currentScope.addLocal(name,declType,isConst,nameNode.isFromExterns());
  }
}","private void visitVar(Node nameNode,Node parent){
  String name=nameNode.getString();
  boolean isDefinedLocally=this.currentScope.isDefinedLocally(name,false);
  if (isDefinedLocally && this.currentScope.isNamespace(name)) {
    return;
  }
  if (NodeUtil.isTypedefDecl(nameNode) || NodeUtil.isEnumDecl(nameNode)) {
    if (!isDefinedLocally) {
      this.currentScope.addLocal(name,JSType.UNKNOWN,false,nameNode.isFromExterns());
    }
    return;
  }
  Node initializer=nameNode.getFirstChild();
  if (initializer != null && initializer.isFunction()) {
    return;
  }
  if (parent.isCatch()) {
    this.currentScope.addLocal(name,JSType.UNKNOWN,false,false);
  }
 else {
    boolean isConst=isConst(nameNode);
    JSType declType=getVarTypeFromAnnotation(nameNode,this.currentScope);
    if (declType == null) {
      declType=mayInferFromRhsIfConst(nameNode);
    }
    this.currentScope.addLocal(name,declType,isConst,nameNode.isFromExterns());
  }
}",0.8060956384655806
19517,"private DeclaredFunctionType computeFnDeclaredType(JSDocInfo fnDoc,String functionName,Node declNode,RawNominalType ownerType,NTIScope parentScope){
  Preconditions.checkArgument(declNode.isFunction() || declNode.isGetProp());
  if (fnDoc == null && !NodeUtil.functionHasInlineJsdocs(declNode)) {
    DeclaredFunctionType t=getDeclaredFunctionTypeFromContext(functionName,declNode,parentScope);
    if (t != null) {
      return t;
    }
  }
  RawNominalType ctorType=declNode.isFunction() ? nominaltypesByNode.get(declNode) : null;
  FunctionAndSlotType result=typeParser.getFunctionType(fnDoc,functionName,declNode,ctorType,ownerType,parentScope);
  Node qnameNode=declNode.isGetProp() ? declNode : NodeUtil.getFunctionNameNode(declNode);
  if (result.slotType != null && qnameNode != null && qnameNode.isName()) {
    parentScope.addSimpleType(qnameNode,result.slotType);
  }
  if (ctorType != null) {
    ctorType.setCtorFunction(result.functionType.toFunctionType(),commonTypes);
  }
  if (declNode.isFunction()) {
    maybeWarnFunctionDeclaration(declNode,result.functionType);
  }
  return result.functionType;
}","private DeclaredFunctionType computeFnDeclaredType(JSDocInfo fnDoc,String functionName,Node declNode,RawNominalType ownerType,NTIScope parentScope){
  Preconditions.checkArgument(declNode.isFunction() || declNode.isGetProp());
  if (fnDoc == null && !NodeUtil.functionHasInlineJsdocs(declNode)) {
    DeclaredFunctionType t=getDeclaredFunctionTypeFromContext(functionName,declNode,parentScope);
    if (t != null) {
      return t;
    }
  }
  RawNominalType ctorType=declNode.isFunction() ? nominaltypesByNode.get(declNode) : null;
  FunctionAndSlotType result=typeParser.getFunctionType(fnDoc,functionName,declNode,ctorType,ownerType,parentScope);
  Node qnameNode=declNode.isGetProp() ? declNode : NodeUtil.getFunctionNameNode(declNode);
  if (result.slotType != null && qnameNode != null && qnameNode.isName()) {
    parentScope.addLocal(qnameNode.getString(),result.slotType,false,qnameNode.isFromExterns());
  }
  if (ctorType != null) {
    ctorType.setCtorFunction(result.functionType.toFunctionType(),commonTypes);
  }
  if (declNode.isFunction()) {
    maybeWarnFunctionDeclaration(declNode,result.functionType);
  }
  return result.functionType;
}",0.9600351339481774
19518,"void addLocal(String name,JSType declType,boolean isConstant,boolean isFromExterns){
  Preconditions.checkArgument(!name.contains(""String_Node_Str""));
  Preconditions.checkArgument(!isDefinedLocally(name,false));
  if (isConstant) {
    constVars.add(name);
  }
  if (isFromExterns) {
    externs.put(name,declType);
  }
 else {
    locals.put(name,declType);
  }
}","void addLocal(String name,JSType declType,boolean isConstant,boolean isFromExterns){
  Preconditions.checkArgument(!name.contains(""String_Node_Str""));
  if (isConstant) {
    constVars.add(name);
  }
  if (isFromExterns) {
    externs.put(name,declType);
  }
 else {
    locals.put(name,declType);
  }
}",0.907185628742515
19519,"private void addNamespaceLit(Node qnameNode,NamespaceLit nslit){
  Preconditions.checkArgument(!isNamespace(qnameNode));
  if (qnameNode.isName()) {
    String varName=qnameNode.getString();
    localNamespaces.put(varName,nslit);
    if (qnameNode.isFromExterns() && !externs.containsKey(varName)) {
      externs.put(qnameNode.getString(),null);
    }
  }
 else {
    QualifiedName qname=QualifiedName.fromNode(qnameNode);
    Namespace ns=getNamespace(qname.getLeftmostName());
    ns.addSubnamespace(qname.getAllButLeftmost(),nslit);
  }
}","private void addNamespaceLit(Node qnameNode,NamespaceLit nslit){
  if (qnameNode.isName()) {
    String varName=qnameNode.getString();
    Preconditions.checkArgument(!isDefinedLocally(varName,false) || !isNamespace(qnameNode));
    localNamespaces.put(varName,nslit);
    if (qnameNode.isFromExterns() && !externs.containsKey(varName)) {
      externs.put(qnameNode.getString(),null);
    }
  }
 else {
    Preconditions.checkArgument(!isNamespace(qnameNode));
    QualifiedName qname=QualifiedName.fromNode(qnameNode);
    Namespace ns=getNamespace(qname.getLeftmostName());
    ns.addSubnamespace(qname.getAllButLeftmost(),nslit);
  }
}",0.7783417935702199
19520,"public void testVarDefinitionsInExterns(){
  typeCheckCustomExterns(DEFAULT_EXTERNS + ""String_Node_Str"",""String_Node_Str"");
  typeCheckCustomExterns(DEFAULT_EXTERNS + ""String_Node_Str"",""String_Node_Str"");
  typeCheckCustomExterns(DEFAULT_EXTERNS + ""String_Node_Str"",""String_Node_Str"");
  typeCheckCustomExterns(DEFAULT_EXTERNS + ""String_Node_Str"",""String_Node_Str"");
  typeCheckCustomExterns(DEFAULT_EXTERNS + ""String_Node_Str"",""String_Node_Str"");
  typeCheckCustomExterns(DEFAULT_EXTERNS + ""String_Node_Str"",""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheckCustomExterns(DEFAULT_EXTERNS + ""String_Node_Str"",""String_Node_Str"");
  typeCheckCustomExterns(DEFAULT_EXTERNS + ""String_Node_Str"",""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheckCustomExterns(DEFAULT_EXTERNS + ""String_Node_Str"",Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
}","public void testVarDefinitionsInExterns(){
  typeCheckCustomExterns(DEFAULT_EXTERNS + ""String_Node_Str"",""String_Node_Str"");
  typeCheckCustomExterns(DEFAULT_EXTERNS + ""String_Node_Str"",""String_Node_Str"");
  typeCheckCustomExterns(DEFAULT_EXTERNS + ""String_Node_Str"",""String_Node_Str"");
  typeCheckCustomExterns(DEFAULT_EXTERNS + ""String_Node_Str"",""String_Node_Str"");
  typeCheckCustomExterns(DEFAULT_EXTERNS + ""String_Node_Str"",""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheckCustomExterns(DEFAULT_EXTERNS + ""String_Node_Str"",""String_Node_Str"",NewTypeInference.INVALID_OPERAND_TYPE);
  typeCheckCustomExterns(DEFAULT_EXTERNS + ""String_Node_Str"",""String_Node_Str"");
  typeCheckCustomExterns(DEFAULT_EXTERNS + ""String_Node_Str"",""String_Node_Str"",NewTypeInference.MISTYPED_ASSIGN_RHS);
  typeCheckCustomExterns(DEFAULT_EXTERNS + ""String_Node_Str"",Joiner.on('\n').join(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),NewTypeInference.INVALID_ARGUMENT_TYPE);
}",0.981
19521,"public static SuggestedFix getFixForJsError(JSError error,AbstractCompiler compiler){
switch (error.getType().key) {
case ""String_Node_Str"":
    return getFixForDebuggerStatement(error);
case ""String_Node_Str"":
  return getFixForInexistentProperty(error);
case ""String_Node_Str"":
return getFixForMissingRequire(error,compiler);
case ""String_Node_Str"":
case ""String_Node_Str"":
return getFixForExtraRequire(error,compiler);
case ""String_Node_Str"":
return getFixForUnnecessaryCast(error,compiler);
default :
return null;
}
}","/** 
 * Creates a SuggestedFix for the given error. Note that some errors have multiple fixes so getFixesForJsError should often be used instead of this.
 */
public static SuggestedFix getFixForJsError(JSError error,AbstractCompiler compiler){
switch (error.getType().key) {
case ""String_Node_Str"":
    return getFixForDebuggerStatement(error);
case ""String_Node_Str"":
  return getFixForInexistentProperty(error);
case ""String_Node_Str"":
return getFixForMissingRequire(error,compiler);
case ""String_Node_Str"":
case ""String_Node_Str"":
return getFixForExtraRequire(error,compiler);
case ""String_Node_Str"":
return getFixForUnnecessaryCast(error,compiler);
default :
return null;
}
}",0.8683333333333333
19522,"private static JSType pickReqObjType(Node expr){
  int exprKind=expr.getType();
switch (exprKind) {
case Token.GETPROP:
    return JSType.TOP_STRUCT;
case Token.GETELEM:
case Token.IN:
  return JSType.TOP_DICT;
case Token.FOR:
Preconditions.checkState(NodeUtil.isForIn(expr));
return JSType.TOP_DICT;
case Token.OBJECTLIT:
{
JSDocInfo jsdoc=expr.getJSDocInfo();
if (jsdoc != null && jsdoc.makesStructs()) {
return JSType.TOP_STRUCT;
}
if (jsdoc != null && jsdoc.makesDicts()) {
return JSType.TOP_DICT;
}
return JSType.TOP_OBJECT;
}
default :
throw new RuntimeException(""String_Node_Str"" + Token.name(exprKind));
}
}","private static JSType pickReqObjType(Node expr){
  int exprKind=expr.getType();
switch (exprKind) {
case Token.GETPROP:
    return JSType.TOP_STRUCT;
case Token.GETELEM:
  return JSType.TOP_DICT;
case Token.OBJECTLIT:
{
  JSDocInfo jsdoc=expr.getJSDocInfo();
  if (jsdoc != null && jsdoc.makesStructs()) {
    return JSType.TOP_STRUCT;
  }
  if (jsdoc != null && jsdoc.makesDicts()) {
    return JSType.TOP_DICT;
  }
  return JSType.TOP_OBJECT;
}
case Token.FOR:
Preconditions.checkState(NodeUtil.isForIn(expr));
return JSType.TOP_OBJECT;
case Token.IN:
return JSType.TOP_OBJECT;
default :
throw new RuntimeException(""String_Node_Str"" + Token.name(exprKind));
}
}",0.3067292644757433
19523,"/** 
 * Dump the CART tree as a dot file. <p> The dot tool is part of the graphviz distribution at <a href=""http://www.graphviz.org/"">http://www.graphviz.org/</a>. If installed, call it as ""dot -O -Tpdf *.dot"" from the console to generate pdfs. </p>
 * @param out The PrintWriter to write to.
 */
public void dumpDot(PrintWriter out){
  out.write(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  out.write(""String_Node_Str"");
  for (  Node n : cart) {
    out.println(""String_Node_Str"" + Math.abs(n.hashCode()) + ""String_Node_Str""+ n.toString()+ ""String_Node_Str""+ dumpDotNodeColor(n)+ ""String_Node_Str""+ dumpDotNodeShape(n)+ ""String_Node_Str"");
    if (n instanceof DecisionNode) {
      DecisionNode dn=(DecisionNode)n;
      if (dn.qtrue < cart.length && cart[dn.qtrue] != null) {
        out.write(""String_Node_Str"" + Math.abs(n.hashCode()) + ""String_Node_Str""+ Math.abs(cart[dn.qtrue].hashCode())+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
      if (dn.qfalse < cart.length && cart[dn.qfalse] != null) {
        out.write(""String_Node_Str"" + Math.abs(n.hashCode()) + ""String_Node_Str""+ Math.abs(cart[dn.qfalse].hashCode())+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
    }
  }
  out.write(""String_Node_Str"");
  out.close();
}","/** 
 * Dump the CART tree as a dot file. <p> The dot tool is part of the graphviz distribution at <a href=""http://www.graphviz.org/"">http://www.graphviz.org/</a>. If installed, call it as ""dot -O -Tpdf *.dot"" from the console to generate pdfs. </p>
 * @param out The PrintWriter to write to.
 */
public void dumpDot(PrintWriter out){
  out.write(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  out.write(""String_Node_Str"");
  for (  Node n : cart) {
    out.println(""String_Node_Str"" + n.hashCode() + ""String_Node_Str""+ n.toString()+ ""String_Node_Str""+ dumpDotNodeColor(n)+ ""String_Node_Str""+ dumpDotNodeShape(n)+ ""String_Node_Str"");
    if (n instanceof DecisionNode) {
      DecisionNode dn=(DecisionNode)n;
      if (dn.qtrue < cart.length && cart[dn.qtrue] != null) {
        out.write(""String_Node_Str"" + n.hashCode() + ""String_Node_Str""+ cart[dn.qtrue].hashCode()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
      if (dn.qfalse < cart.length && cart[dn.qfalse] != null) {
        out.write(""String_Node_Str"" + n.hashCode() + ""String_Node_Str""+ cart[dn.qfalse].hashCode()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
    }
  }
  out.write(""String_Node_Str"");
  out.close();
}",0.9454545454545454
19524,"/** 
 * Imports an openfst text format Several files are imported as follows: - basename.input.syms - basename.output.syms - basename.fst.txt
 * @param basename the files' base name
 * @param semiring the fst's semiring
 * @return imported FST
 * @throws IOException IO went wrong
 * @throws NumberFormatException load failed due to data format issues
 */
public static Fst importFst(String basename,Semiring semiring) throws NumberFormatException, IOException {
  Fst fst=new Fst(semiring);
  HashMap<String,Integer> isyms=importSymbols(basename + ""String_Node_Str"");
  if (isyms == null) {
    isyms=new HashMap<String,Integer>();
    isyms.put(""String_Node_Str"",0);
  }
  HashMap<String,Integer> osyms=importSymbols(basename + ""String_Node_Str"");
  if (osyms == null) {
    osyms=new HashMap<String,Integer>();
    osyms.put(""String_Node_Str"",0);
  }
  HashMap<String,Integer> ssyms=importSymbols(basename + ""String_Node_Str"");
  FileInputStream fis=new FileInputStream(basename + ""String_Node_Str"");
  DataInputStream dis=new DataInputStream(fis);
  BufferedReader br=new BufferedReader(new InputStreamReader(dis));
  boolean firstLine=true;
  String strLine;
  HashMap<Integer,State> stateMap=new HashMap<Integer,State>();
  while ((strLine=br.readLine()) != null) {
    String[] tokens=strLine.split(""String_Node_Str"");
    Integer inputStateId;
    if (ssyms == null) {
      inputStateId=Integer.parseInt(tokens[0]);
    }
 else {
      inputStateId=ssyms.get(tokens[0]);
    }
    State inputState=stateMap.get(inputStateId);
    if (inputState == null) {
      inputState=new State(semiring.zero());
      fst.addState(inputState);
      stateMap.put(inputStateId,inputState);
    }
    if (firstLine) {
      firstLine=false;
      fst.setStart(inputState);
    }
    if (tokens.length > 2) {
      Integer nextStateId;
      if (ssyms == null) {
        nextStateId=Integer.parseInt(tokens[1]);
      }
 else {
        nextStateId=ssyms.get(tokens[1]);
      }
      State nextState=stateMap.get(nextStateId);
      if (nextState == null) {
        nextState=new State(semiring.zero());
        fst.addState(nextState);
        stateMap.put(nextStateId,nextState);
      }
      if (isyms.get(tokens[2]) == null) {
        isyms.put(tokens[2],isyms.size());
      }
      int iLabel=isyms.get(tokens[2]);
      if (osyms.get(tokens[3]) == null) {
        osyms.put(tokens[3],osyms.size());
      }
      int oLabel=osyms.get(tokens[3]);
      float arcWeight;
      if (tokens.length > 4) {
        arcWeight=Float.parseFloat(tokens[4]);
      }
 else {
        arcWeight=0;
      }
      Arc arc=new Arc(iLabel,oLabel,arcWeight,nextState);
      inputState.addArc(arc);
    }
 else {
      if (tokens.length > 1) {
        float finalWeight=Float.parseFloat(tokens[1]);
        inputState.setFinalWeight(finalWeight);
      }
 else {
        inputState.setFinalWeight(0.0f);
      }
    }
  }
  dis.close();
  fst.setIsyms(Utils.toStringArray(isyms));
  fst.setOsyms(Utils.toStringArray(osyms));
  return fst;
}","/** 
 * Imports an openfst text format Several files are imported as follows: - basename.input.syms - basename.output.syms - basename.fst.txt
 * @param basename the files' base name
 * @param semiring the fst's semiring
 * @return imported FST
 * @throws IOException IO went wrong
 * @throws NumberFormatException load failed due to data format issues
 */
public static Fst importFst(String basename,Semiring semiring) throws NumberFormatException, IOException {
  Fst fst=new Fst(semiring);
  HashMap<String,Integer> isyms=importSymbols(basename + ""String_Node_Str"");
  if (isyms == null) {
    isyms=new HashMap<String,Integer>();
    isyms.put(""String_Node_Str"",0);
  }
  HashMap<String,Integer> osyms=importSymbols(basename + ""String_Node_Str"");
  if (osyms == null) {
    osyms=new HashMap<String,Integer>();
    osyms.put(""String_Node_Str"",0);
  }
  HashMap<String,Integer> ssyms=importSymbols(basename + ""String_Node_Str"");
  FileInputStream fis=new FileInputStream(basename + ""String_Node_Str"");
  DataInputStream dis=new DataInputStream(fis);
  BufferedReader br=new BufferedReader(new InputStreamReader(dis,""String_Node_Str""));
  boolean firstLine=true;
  String strLine;
  HashMap<Integer,State> stateMap=new HashMap<Integer,State>();
  while ((strLine=br.readLine()) != null) {
    String[] tokens=strLine.split(""String_Node_Str"");
    Integer inputStateId;
    if (ssyms == null) {
      inputStateId=Integer.parseInt(tokens[0]);
    }
 else {
      inputStateId=ssyms.get(tokens[0]);
    }
    State inputState=stateMap.get(inputStateId);
    if (inputState == null) {
      inputState=new State(semiring.zero());
      fst.addState(inputState);
      stateMap.put(inputStateId,inputState);
    }
    if (firstLine) {
      firstLine=false;
      fst.setStart(inputState);
    }
    if (tokens.length > 2) {
      Integer nextStateId;
      if (ssyms == null) {
        nextStateId=Integer.parseInt(tokens[1]);
      }
 else {
        nextStateId=ssyms.get(tokens[1]);
      }
      State nextState=stateMap.get(nextStateId);
      if (nextState == null) {
        nextState=new State(semiring.zero());
        fst.addState(nextState);
        stateMap.put(nextStateId,nextState);
      }
      if (isyms.get(tokens[2]) == null) {
        isyms.put(tokens[2],isyms.size());
      }
      int iLabel=isyms.get(tokens[2]);
      if (osyms.get(tokens[3]) == null) {
        osyms.put(tokens[3],osyms.size());
      }
      int oLabel=osyms.get(tokens[3]);
      float arcWeight;
      if (tokens.length > 4) {
        arcWeight=Float.parseFloat(tokens[4]);
      }
 else {
        arcWeight=0;
      }
      Arc arc=new Arc(iLabel,oLabel,arcWeight,nextState);
      inputState.addArc(arc);
    }
 else {
      if (tokens.length > 1) {
        float finalWeight=Float.parseFloat(tokens[1]);
        inputState.setFinalWeight(finalWeight);
      }
 else {
        inputState.setFinalWeight(0.0f);
      }
    }
  }
  dis.close();
  fst.setIsyms(Utils.toStringArray(isyms));
  fst.setOsyms(Utils.toStringArray(osyms));
  return fst;
}",0.9970326409495548
19525,"@Override public String toString(){
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"" + start + ""String_Node_Str""+ isyms+ ""String_Node_Str""+ osyms+ ""String_Node_Str""+ semiring+ ""String_Node_Str"");
  int numStates=states.size();
  for (int i=0; i < numStates; i++) {
    State s=states.get(i);
    sb.append(""String_Node_Str"" + s + ""String_Node_Str"");
    int numArcs=s.getNumArcs();
    for (int j=0; j < numArcs; j++) {
      Arc a=s.getArc(j);
      sb.append(""String_Node_Str"" + a + ""String_Node_Str"");
    }
  }
  return sb.toString();
}","@Override public String toString(){
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"" + start + ""String_Node_Str""+ Arrays.toString(isyms)+ ""String_Node_Str""+ Arrays.toString(osyms)+ ""String_Node_Str""+ semiring+ ""String_Node_Str"");
  int numStates=states.size();
  for (int i=0; i < numStates; i++) {
    State s=states.get(i);
    sb.append(""String_Node_Str"" + s + ""String_Node_Str"");
    int numArcs=s.getNumArcs();
    for (int j=0; j < numArcs; j++) {
      Arc a=s.getArc(j);
      sb.append(""String_Node_Str"" + a + ""String_Node_Str"");
    }
  }
  return sb.toString();
}",0.92560553633218
19526,"@Override public String toString(){
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"" + start + ""String_Node_Str""+ isyms+ ""String_Node_Str""+ osyms+ ""String_Node_Str""+ semiring+ ""String_Node_Str"");
  int numStates=states.length;
  for (int i=0; i < numStates; i++) {
    State s=states[i];
    sb.append(""String_Node_Str"" + s + ""String_Node_Str"");
    int numArcs=s.getNumArcs();
    for (int j=0; j < numArcs; j++) {
      Arc a=s.getArc(j);
      sb.append(""String_Node_Str"" + a + ""String_Node_Str"");
    }
  }
  return sb.toString();
}","@Override public String toString(){
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"" + start + ""String_Node_Str""+ Arrays.toString(isyms)+ ""String_Node_Str""+ Arrays.toString(osyms)+ ""String_Node_Str""+ semiring+ ""String_Node_Str"");
  int numStates=states.length;
  for (int i=0; i < numStates; i++) {
    State s=states[i];
    sb.append(""String_Node_Str"" + s + ""String_Node_Str"");
    int numArcs=s.getNumArcs();
    for (int j=0; j < numArcs; j++) {
      Arc a=s.getArc(j);
      sb.append(""String_Node_Str"" + a + ""String_Node_Str"");
    }
  }
  return sb.toString();
}",0.9250871080139372
19527,"/** 
 * Determinizes an fst. The result will be an equivalent fst that has the property that no state has two transitions with the same input label. For this algorithm, epsilon transitions are treated as regular symbols.
 * @param fst the fst to determinize
 * @return the determinized fst
 */
public static Fst get(Fst fst){
  if (fst.getSemiring() == null) {
    return null;
  }
  Semiring semiring=fst.getSemiring();
  Fst res=new Fst(semiring);
  res.setIsyms(fst.getIsyms());
  res.setOsyms(fst.getOsyms());
  Queue<ArrayList<Pair<State,Float>>> queue=new LinkedList<ArrayList<Pair<State,Float>>>();
  HashMap<String,State> stateMapper=new HashMap<String,State>();
  State s=new State(semiring.zero());
  String stateString=""String_Node_Str"" + fst.getStart() + ""String_Node_Str""+ semiring.one()+ ""String_Node_Str"";
  queue.add(new ArrayList<Pair<State,Float>>());
  queue.peek().add(new Pair<State,Float>(fst.getStart(),semiring.one()));
  res.addState(s);
  stateMapper.put(stateString,s);
  res.setStart(s);
  while (!queue.isEmpty()) {
    ArrayList<Pair<State,Float>> p=queue.remove();
    State pnew=getStateLabel(p,stateMapper);
    queue.remove(0);
    ArrayList<Integer> labels=getUniqueLabels(fst,p);
    for (    int label : labels) {
      Float wnew=semiring.zero();
      for (      Pair<State,Float> ps : p) {
        State old=ps.getLeft();
        Float u=ps.getRight();
        int numArcs=old.getNumArcs();
        for (int j=0; j < numArcs; j++) {
          Arc arc=old.getArc(j);
          if (label == arc.getIlabel()) {
            wnew=semiring.plus(wnew,semiring.times(u,arc.getWeight()));
          }
        }
      }
      ArrayList<Pair<State,Float>> forQueue=new ArrayList<Pair<State,Float>>();
      for (      Pair<State,Float> ps : p) {
        State old=ps.getLeft();
        Float u=ps.getRight();
        Float wnewRevert=semiring.divide(semiring.one(),wnew);
        int numArcs=old.getNumArcs();
        for (int j=0; j < numArcs; j++) {
          Arc arc=old.getArc(j);
          if (label == arc.getIlabel()) {
            State oldstate=arc.getNextState();
            Pair<State,Float> pair=getPair(forQueue,oldstate,semiring.zero());
            pair.setRight(semiring.plus(pair.getRight(),semiring.times(wnewRevert,semiring.times(u,arc.getWeight()))));
          }
        }
      }
      String qnewid=""String_Node_Str"";
      for (      Pair<State,Float> ps : forQueue) {
        State old=ps.getLeft();
        Float unew=ps.getRight();
        if (!qnewid.equals(""String_Node_Str"")) {
          qnewid=qnewid + ""String_Node_Str"";
        }
        qnewid=qnewid + ""String_Node_Str"" + old+ ""String_Node_Str""+ unew+ ""String_Node_Str"";
      }
      if (stateMapper.get(qnewid) == null) {
        State qnew=new State(semiring.zero());
        res.addState(qnew);
        stateMapper.put(qnewid,qnew);
        Float fw=qnew.getFinalWeight();
        for (        Pair<State,Float> ps : forQueue) {
          fw=semiring.plus(fw,semiring.times(ps.getLeft().getFinalWeight(),ps.getRight()));
        }
        qnew.setFinalWeight(fw);
        queue.add(forQueue);
      }
      pnew.addArc(new Arc(label,label,wnew,stateMapper.get(qnewid)));
    }
  }
  return res;
}","/** 
 * Determinizes an fst. The result will be an equivalent fst that has the property that no state has two transitions with the same input label. For this algorithm, epsilon transitions are treated as regular symbols.
 * @param fst the fst to determinize
 * @return the determinized fst
 */
public static Fst get(Fst fst){
  if (fst.getSemiring() == null) {
    return null;
  }
  Semiring semiring=fst.getSemiring();
  Fst res=new Fst(semiring);
  res.setIsyms(fst.getIsyms());
  res.setOsyms(fst.getOsyms());
  Queue<ArrayList<Pair<State,Float>>> queue=new LinkedList<ArrayList<Pair<State,Float>>>();
  HashMap<String,State> stateMapper=new HashMap<String,State>();
  State s=new State(semiring.zero());
  String stateString=""String_Node_Str"" + fst.getStart() + ""String_Node_Str""+ semiring.one()+ ""String_Node_Str"";
  queue.add(new ArrayList<Pair<State,Float>>());
  queue.peek().add(new Pair<State,Float>(fst.getStart(),semiring.one()));
  res.addState(s);
  stateMapper.put(stateString,s);
  res.setStart(s);
  while (!queue.isEmpty()) {
    ArrayList<Pair<State,Float>> p=queue.remove();
    State pnew=getStateLabel(p,stateMapper);
    ArrayList<Integer> labels=getUniqueLabels(fst,p);
    for (    int label : labels) {
      Float wnew=semiring.zero();
      for (      Pair<State,Float> ps : p) {
        State old=ps.getLeft();
        Float u=ps.getRight();
        int numArcs=old.getNumArcs();
        for (int j=0; j < numArcs; j++) {
          Arc arc=old.getArc(j);
          if (label == arc.getIlabel()) {
            wnew=semiring.plus(wnew,semiring.times(u,arc.getWeight()));
          }
        }
      }
      ArrayList<Pair<State,Float>> forQueue=new ArrayList<Pair<State,Float>>();
      for (      Pair<State,Float> ps : p) {
        State old=ps.getLeft();
        Float u=ps.getRight();
        Float wnewRevert=semiring.divide(semiring.one(),wnew);
        int numArcs=old.getNumArcs();
        for (int j=0; j < numArcs; j++) {
          Arc arc=old.getArc(j);
          if (label == arc.getIlabel()) {
            State oldstate=arc.getNextState();
            Pair<State,Float> pair=getPair(forQueue,oldstate,semiring.zero());
            pair.setRight(semiring.plus(pair.getRight(),semiring.times(wnewRevert,semiring.times(u,arc.getWeight()))));
          }
        }
      }
      String qnewid=""String_Node_Str"";
      for (      Pair<State,Float> ps : forQueue) {
        State old=ps.getLeft();
        Float unew=ps.getRight();
        if (!qnewid.equals(""String_Node_Str"")) {
          qnewid=qnewid + ""String_Node_Str"";
        }
        qnewid=qnewid + ""String_Node_Str"" + old+ ""String_Node_Str""+ unew+ ""String_Node_Str"";
      }
      if (stateMapper.get(qnewid) == null) {
        State qnew=new State(semiring.zero());
        res.addState(qnew);
        stateMapper.put(qnewid,qnew);
        Float fw=qnew.getFinalWeight();
        for (        Pair<State,Float> ps : forQueue) {
          fw=semiring.plus(fw,semiring.times(ps.getLeft().getFinalWeight(),ps.getRight()));
        }
        qnew.setFinalWeight(fw);
        queue.add(forQueue);
      }
      pnew.addArc(new Arc(label,label,wnew,stateMapper.get(qnewid)));
    }
  }
  return res;
}",0.9967233577781244
19528,"/** 
 * Calculates the shortest distances from each state to the final
 * @param fst the fst to calculate the shortest distances
 * @return the array containing the shortest distances
 */
public static float[] shortestDistance(Fst fst){
  Fst reversed=Reverse.get(fst);
  float[] d=new float[reversed.getNumStates()];
  float[] r=new float[reversed.getNumStates()];
  Semiring semiring=reversed.getSemiring();
  Arrays.fill(d,semiring.zero());
  Arrays.fill(r,semiring.zero());
  LinkedHashSet<State> queue=new LinkedHashSet<State>();
  queue.add(reversed.getStart());
  d[reversed.getStart().getId()]=semiring.one();
  r[reversed.getStart().getId()]=semiring.one();
  while (!queue.isEmpty()) {
    State q=queue.iterator().next();
    queue.remove(q);
    float rnew=r[q.getId()];
    r[q.getId()]=semiring.zero();
    for (int i=0; i < q.getNumArcs(); i++) {
      Arc a=q.getArc(i);
      State nextState=a.getNextState();
      float dnext=d[a.getNextState().getId()];
      float dnextnew=semiring.plus(dnext,semiring.times(rnew,a.getWeight()));
      if (dnext != dnextnew) {
        d[a.getNextState().getId()]=dnextnew;
        r[a.getNextState().getId()]=semiring.plus(r[a.getNextState().getId()],semiring.times(rnew,a.getWeight()));
        if (!queue.contains(nextState.getId())) {
          queue.add(nextState);
        }
      }
    }
  }
  return d;
}","/** 
 * Calculates the shortest distances from each state to the final
 * @param fst the fst to calculate the shortest distances
 * @return the array containing the shortest distances
 */
public static float[] shortestDistance(Fst fst){
  Fst reversed=Reverse.get(fst);
  float[] d=new float[reversed.getNumStates()];
  float[] r=new float[reversed.getNumStates()];
  Semiring semiring=reversed.getSemiring();
  Arrays.fill(d,semiring.zero());
  Arrays.fill(r,semiring.zero());
  LinkedHashSet<State> queue=new LinkedHashSet<State>();
  queue.add(reversed.getStart());
  d[reversed.getStart().getId()]=semiring.one();
  r[reversed.getStart().getId()]=semiring.one();
  while (!queue.isEmpty()) {
    State q=queue.iterator().next();
    queue.remove(q);
    float rnew=r[q.getId()];
    r[q.getId()]=semiring.zero();
    for (int i=0; i < q.getNumArcs(); i++) {
      Arc a=q.getArc(i);
      State nextState=a.getNextState();
      float dnext=d[a.getNextState().getId()];
      float dnextnew=semiring.plus(dnext,semiring.times(rnew,a.getWeight()));
      if (dnext != dnextnew) {
        d[a.getNextState().getId()]=dnextnew;
        r[a.getNextState().getId()]=semiring.plus(r[a.getNextState().getId()],semiring.times(rnew,a.getWeight()));
        if (!queue.contains(nextState)) {
          queue.add(nextState);
        }
      }
    }
  }
  return d;
}",0.9970652971386648
19529,"/** 
 * Calculate the score for this mixture against the given feature. We model the output distributions using a mixture of Gaussians, therefore the current implementation is simply the computation of a multi-dimensional Gaussian. <p> <b>Normal(x) = exp{-0.5 * (x-m)'  inv(Var) * (x-m)} / {sqrt((2 * PI) ^ N) * det(Var))}</b></p> <p> where <b>x</b> and <b>m</b> are the incoming cepstra and mean vector respectively, <b>Var</b> is the Covariance matrix, <b>det()</b> is the determinant of a matrix, <b>inv()</b> is its inverse, <b>exp</b> is the exponential operator, <b>x'</b> is the transposed vector of <b>x</b> and <b>N</b> is the dimension of the vectors <b>x</b> and <b>m</b>.
 * @param feature the feature to score
 * @return the score, in log, for the given feature
 */
public float getScore(float[] feature){
  float logDval=logPreComputedGaussianFactor;
  for (int i=0; i < feature.length; i++) {
    float logDiff=feature[i] - meanTransformed[i];
    logDval+=logDiff * logDiff * precisionTransformed[i];
  }
  logDval=logMath.lnToLog(logDval);
  if (Float.isNaN(logDval)) {
    System.out.println(""String_Node_Str"");
    logDval=LogMath.LOG_ZERO;
  }
  if (logDval < distFloor) {
    logDval=distFloor;
  }
  return logDval;
}","/** 
 * Calculate the score for this mixture against the given feature. We model the output distributions using a mixture of Gaussians, therefore the current implementation is simply the computation of a multi-dimensional Gaussian. <p> <b>Normal(x) = exp{-0.5 * (x-m)'  inv(Var) * (x-m)} / {sqrt((2 * PI) ^ N) * det(Var))}</b></p> <p> where <b>x</b> and <b>m</b> are the incoming cepstra and mean vector respectively, <b>Var</b> is the Covariance matrix, <b>det()</b> is the determinant of a matrix, <b>inv()</b> is its inverse, <b>exp</b> is the exponential operator, <b>x'</b> is the transposed vector of <b>x</b> and <b>N</b> is the dimension of the vectors <b>x</b> and <b>m</b>.
 * @param feature the feature to score
 * @return the score, in log, for the given feature
 */
public float getScore(float[] feature){
  float logDval=logPreComputedGaussianFactor;
  for (int i=0; i < feature.length; i++) {
    float logDiff=feature[i] - meanTransformed[i];
    logDval+=logDiff * logDiff * precisionTransformed[i];
  }
  logDval=LogMath.getLogMath().lnToLog(logDval);
  if (Float.isNaN(logDval)) {
    System.out.println(""String_Node_Str"");
    logDval=LogMath.LOG_ZERO;
  }
  if (logDval < distFloor) {
    logDval=distFloor;
  }
  return logDval;
}",0.9939783219590526
19530,"/** 
 * Returns the properties of this acoustic model.
 * @return the properties of this acoustic model
 */
public Properties getProperties(){
  if (properties == null) {
    properties=new Properties();
    try {
      properties.load(getClass().getResource(""String_Node_Str"").openStream());
    }
 catch (    IOException ioe) {
      ioe.printStackTrace();
    }
  }
  return properties;
}","/** 
 * Returns the properties of this acoustic model.
 * @return the properties of this acoustic model
 */
public Properties getProperties(){
  if (properties == null) {
    properties=new Properties();
    try {
      properties.load(TiedStateAcousticModel.class.getResource(""String_Node_Str"").openStream());
    }
 catch (    IOException ioe) {
      ioe.printStackTrace();
    }
  }
  return properties;
}",0.9525
19531,"private float convertScore(float val){
  val=logMath.lnToLog(val);
  if (Float.isNaN(val)) {
    System.out.println(""String_Node_Str"");
    val=LogMath.LOG_ZERO;
  }
  if (val < distFloor) {
    val=distFloor;
  }
  return val;
}","private float convertScore(float val){
  val=LogMath.getLogMath().lnToLog(val);
  if (Float.isNaN(val)) {
    System.out.println(""String_Node_Str"");
    val=LogMath.LOG_ZERO;
  }
  if (val < distFloor) {
    val=distFloor;
  }
  return val;
}",0.9681528662420382
19532,"/** 
 * remove the given arc from the set of succors
 * @param arc the arc to remove
 */
void deleteSuccessor(SentenceHMMStateArc arc){
  arcs.remove(arc);
}","/** 
 * remove the given arc from the set of succors
 * @param arc the arc to remove
 */
void deleteSuccessor(SentenceHMMStateArc arc){
  arcs.values().remove(arc);
}",0.9721362229102168
19533,"/** 
 * Reads the LM file header
 * @param stream the data stream of the LM file
 * @throws java.io.IOException
 */
private void readHeader(DataInputStream stream) throws IOException {
  int headerLength=readInt(stream,bigEndian);
  if ((headerLength != DARPA_TG_HEADER.length() + 1) && (headerLength != DARPA_QG_HEADER.length() + 1) && (headerLength != DARPA_NG_HEADER.length() - 1)) {
    headerLength=Utilities.swapInteger(headerLength);
    if (headerLength == (DARPA_TG_HEADER.length() + 1) || headerLength == (DARPA_QG_HEADER.length() + 1) || headerLength == (DARPA_NG_HEADER.length() - 1)) {
      bigEndian=false;
    }
 else {
      throw new Error(""String_Node_Str"" + headerLength + ""String_Node_Str"");
    }
  }
 else {
  }
  String header=readString(stream,headerLength - 1);
  stream.readByte();
  bytesRead++;
  if (!header.equals(DARPA_TG_HEADER) & !header.equals(DARPA_QG_HEADER) & !Pattern.matches(DARPA_NG_HEADER,header)) {
    throw new Error(""String_Node_Str"" + header);
  }
 else {
    if (header.equals(DARPA_TG_HEADER))     maxNGram=3;
 else     if (header.equals(DARPA_QG_HEADER))     maxNGram=4;
 else {
      Pattern p=Pattern.compile(""String_Node_Str"");
      Matcher m=p.matcher(header);
      maxNGram=Integer.parseInt(m.group());
    }
  }
  int fileNameLength=readInt(stream,bigEndian);
  skipStreamBytes(stream,fileNameLength);
  numberNGrams=new int[maxNGram];
  NGramOffset=new long[maxNGram];
  NGramProbTable=new float[maxNGram][];
  NGramBackoffTable=new float[maxNGram][];
  NGramSegmentTable=new int[maxNGram][];
  numberNGrams[0]=0;
  logNGramSegmentSize=LOG2_NGRAM_SEGMENT_SIZE;
  int version=readInt(stream,bigEndian);
  bytesPerField=2;
  if (version <= 0) {
    readInt(stream,bigEndian);
    if (version <= -3)     bytesPerField=4;
    int formatLength;
    for (; ; ) {
      if ((formatLength=readInt(stream,bigEndian)) == 0) {
        break;
      }
      bytesRead+=stream.skipBytes(formatLength);
    }
    if (version == -2) {
      logNGramSegmentSize=readInt(stream,bigEndian);
      if (logNGramSegmentSize < 1 || logNGramSegmentSize > 15) {
        throw new Error(""String_Node_Str"");
      }
    }
    numberNGrams[0]=readInt(stream,bigEndian);
  }
 else {
    numberNGrams[0]=version;
  }
  if (numberNGrams[0] <= 0) {
    throw new Error(""String_Node_Str"" + numberNGrams[0] + ""String_Node_Str"");
  }
  for (int i=1; i < maxNGram; i++) {
    if ((numberNGrams[i]=readInt(stream,bigEndian)) < 0) {
      throw new Error(""String_Node_Str"" + String.valueOf(i) + ""String_Node_Str""+ numberNGrams[i]);
    }
  }
}","/** 
 * Reads the LM file header
 * @param stream the data stream of the LM file
 * @throws java.io.IOException
 */
private void readHeader(DataInputStream stream) throws IOException {
  int headerLength=readInt(stream,bigEndian);
  if ((headerLength != DARPA_TG_HEADER.length() + 1) && (headerLength != DARPA_QG_HEADER.length() + 1) && (headerLength != DARPA_NG_HEADER.length() - 1)) {
    headerLength=Utilities.swapInteger(headerLength);
    if (headerLength == (DARPA_TG_HEADER.length() + 1) || headerLength == (DARPA_QG_HEADER.length() + 1) || headerLength == (DARPA_NG_HEADER.length() - 1)) {
      bigEndian=false;
    }
 else {
      throw new Error(""String_Node_Str"" + headerLength + ""String_Node_Str"");
    }
  }
 else {
  }
  String header=readString(stream,headerLength - 1);
  stream.readByte();
  bytesRead++;
  if (!header.equals(DARPA_TG_HEADER) && !header.equals(DARPA_QG_HEADER) && !Pattern.matches(DARPA_NG_HEADER,header)) {
    throw new Error(""String_Node_Str"" + header);
  }
 else {
    if (header.equals(DARPA_TG_HEADER))     maxNGram=3;
 else     if (header.equals(DARPA_QG_HEADER))     maxNGram=4;
 else {
      Pattern p=Pattern.compile(""String_Node_Str"");
      Matcher m=p.matcher(header);
      maxNGram=Integer.parseInt(m.group());
    }
  }
  int fileNameLength=readInt(stream,bigEndian);
  skipStreamBytes(stream,fileNameLength);
  numberNGrams=new int[maxNGram];
  NGramOffset=new long[maxNGram];
  NGramProbTable=new float[maxNGram][];
  NGramBackoffTable=new float[maxNGram][];
  NGramSegmentTable=new int[maxNGram][];
  numberNGrams[0]=0;
  logNGramSegmentSize=LOG2_NGRAM_SEGMENT_SIZE;
  int version=readInt(stream,bigEndian);
  bytesPerField=2;
  if (version <= 0) {
    readInt(stream,bigEndian);
    if (version <= -3)     bytesPerField=4;
    int formatLength;
    for (; ; ) {
      if ((formatLength=readInt(stream,bigEndian)) == 0) {
        break;
      }
      bytesRead+=stream.skipBytes(formatLength);
    }
    if (version == -2) {
      logNGramSegmentSize=readInt(stream,bigEndian);
      if (logNGramSegmentSize < 1 || logNGramSegmentSize > 15) {
        throw new Error(""String_Node_Str"");
      }
    }
    numberNGrams[0]=readInt(stream,bigEndian);
  }
 else {
    numberNGrams[0]=version;
  }
  if (numberNGrams[0] <= 0) {
    throw new Error(""String_Node_Str"" + numberNGrams[0] + ""String_Node_Str"");
  }
  for (int i=1; i < maxNGram; i++) {
    if ((numberNGrams[i]=readInt(stream,bigEndian)) < 0) {
      throw new Error(""String_Node_Str"" + String.valueOf(i) + ""String_Node_Str""+ numberNGrams[i]);
    }
  }
}",0.9996101364522416
19534,"/** 
 * Check if an edge is in the graph. 
 * @param edge edge to check
 * @return if edge in the graph
 */
public boolean isEdgeInGraph(Node edge){
  return edges.contains(edge);
}","/** 
 * Check if an edge is in the graph. 
 * @param edge edge to check
 * @return if edge in the graph
 */
public boolean isEdgeInGraph(Edge edge){
  return edges.contains(edge);
}",0.988950276243094
19535,"public static void setProperty(ConfigurationManager cm,String componentName,String propName,String propValue){
  PropertySheet ps=cm.getPropertySheet(componentName);
  if (ps == null)   throw new RuntimeException(""String_Node_Str"" + propName + ""String_Node_Str"");
  if (propValue.equals(""String_Node_Str""))   propValue=null;
switch (ps.getType(propName)) {
case BOOLEAN:
    ps.setBoolean(propName,Boolean.valueOf(propValue));
  break;
case DOUBLE:
ps.setDouble(propName,new Double(propValue));
break;
case INT:
ps.setInt(propName,new Integer(propValue));
break;
case STRING:
ps.setString(propName,propValue);
break;
case COMPONENT:
ps.setComponent(propName,propValue,null);
break;
case COMPONENT_LIST:
List<String> compNames=new ArrayList<String>();
for (String component : propValue.split(""String_Node_Str"")) {
compNames.add(component.trim());
}
ps.setComponentList(propName,compNames,null);
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
}","public static void setProperty(ConfigurationManager cm,String componentName,String propName,String propValue){
  PropertySheet ps=cm.getPropertySheet(componentName);
  if (ps == null)   throw new RuntimeException(""String_Node_Str"" + propName + ""String_Node_Str"");
  if (propValue.equals(""String_Node_Str""))   propValue=null;
switch (ps.getType(propName)) {
case BOOLEAN:
    ps.setBoolean(propName,Boolean.parseBoolean(propValue));
  break;
case DOUBLE:
ps.setDouble(propName,Double.parseDouble(propValue));
break;
case INT:
ps.setInt(propName,Integer.parseInt(propValue));
break;
case STRING:
ps.setString(propName,propValue);
break;
case COMPONENT:
ps.setComponent(propName,propValue,null);
break;
case COMPONENT_LIST:
List<String> compNames=new ArrayList<String>();
for (String component : propValue.split(""String_Node_Str"")) {
compNames.add(component.trim());
}
ps.setComponentList(propName,compNames,null);
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
}",0.9752577319587628
19536,"/** 
 * Resets this SpeechMarker to a starting state.
 */
private void reset(){
  inSpeech=false;
  speechCount=0;
  silenceCount=0;
  startSpeechFrames=startSpeechTime / 10;
  endSilenceFrames=endSilenceTime / 10;
  speechLeaderFrames=speechLeader / 10;
  this.inputQueue=new ArrayList<Data>();
  this.outputQueue=new ArrayList<Data>();
}","/** 
 * Resets this SpeechMarker to a starting state.
 */
private void reset(){
  inSpeech=false;
  speechCount=0;
  silenceCount=0;
  startSpeechFrames=startSpeechTime / 10;
  endSilenceFrames=endSilenceTime / 10;
  speechLeaderFrames=speechLeader / 10;
  this.inputQueue=new LinkedList<Data>();
  this.outputQueue=new LinkedList<Data>();
}",0.9676470588235294
19537,"/** 
 * Returns the next Data object.
 * @return the next Data object, or null if none available
 * @throws DataProcessingException if a data processing error occurs
 */
@Override public Data getData() throws DataProcessingException {
  while (outputQueue.isEmpty()) {
    Data data=getPredecessor().getData();
    if (data == null)     break;
    if (data instanceof DataStartSignal) {
      reset();
      outputQueue.add(data);
      break;
    }
    if (data instanceof DataEndSignal) {
      if (inSpeech) {
        outputQueue.add(new SpeechEndSignal());
      }
      outputQueue.add(data);
      break;
    }
    if (data instanceof SpeechClassifiedData) {
      SpeechClassifiedData cdata=(SpeechClassifiedData)data;
      if (cdata.isSpeech()) {
        speechCount++;
        silenceCount=0;
      }
 else {
        speechCount=0;
        silenceCount++;
      }
      if (inSpeech) {
        outputQueue.add(data);
      }
 else {
        inputQueue.add(data);
      }
      if (!inSpeech && speechCount == startSpeechFrames) {
        inSpeech=true;
        outputQueue.add(new SpeechStartSignal(cdata.getCollectTime() - speechLeader - startSpeechFrames));
        outputQueue.addAll(inputQueue.subList(Math.max(0,inputQueue.size() - startSpeechFrames - speechLeaderFrames),inputQueue.size()));
        inputQueue.clear();
      }
      if (inSpeech && silenceCount == endSilenceFrames) {
        inSpeech=false;
        outputQueue.add(new SpeechEndSignal(cdata.getCollectTime()));
      }
    }
  }
  if (!outputQueue.isEmpty()) {
    Data audio=outputQueue.remove(0);
    if (audio instanceof SpeechClassifiedData) {
      SpeechClassifiedData data=(SpeechClassifiedData)audio;
      audio=data.getDoubleData();
    }
    return audio;
  }
 else {
    return null;
  }
}","/** 
 * Returns the next Data object.
 * @return the next Data object, or null if none available
 * @throws DataProcessingException if a data processing error occurs
 */
@Override public Data getData() throws DataProcessingException {
  while (outputQueue.isEmpty()) {
    Data data=getPredecessor().getData();
    if (data == null)     break;
    if (data instanceof DataStartSignal) {
      reset();
      outputQueue.add(data);
      break;
    }
    if (data instanceof DataEndSignal) {
      if (inSpeech) {
        outputQueue.add(new SpeechEndSignal());
      }
      outputQueue.add(data);
      break;
    }
    if (data instanceof SpeechClassifiedData) {
      SpeechClassifiedData cdata=(SpeechClassifiedData)data;
      if (cdata.isSpeech()) {
        speechCount++;
        silenceCount=0;
      }
 else {
        speechCount=0;
        silenceCount++;
      }
      if (inSpeech) {
        outputQueue.add(data);
      }
 else {
        inputQueue.add(data);
        if (inputQueue.size() > startSpeechFrames + speechLeaderFrames) {
          inputQueue.remove(0);
        }
      }
      if (!inSpeech && speechCount == startSpeechFrames) {
        inSpeech=true;
        outputQueue.add(new SpeechStartSignal(cdata.getCollectTime() - speechLeader - startSpeechFrames));
        outputQueue.addAll(inputQueue.subList(Math.max(0,inputQueue.size() - startSpeechFrames - speechLeaderFrames),inputQueue.size()));
        inputQueue.clear();
      }
      if (inSpeech && silenceCount == endSilenceFrames) {
        inSpeech=false;
        outputQueue.add(new SpeechEndSignal(cdata.getCollectTime()));
      }
    }
  }
  if (!outputQueue.isEmpty()) {
    Data audio=outputQueue.remove(0);
    if (audio instanceof SpeechClassifiedData) {
      SpeechClassifiedData data=(SpeechClassifiedData)audio;
      audio=data.getDoubleData();
    }
    return audio;
  }
 else {
    return null;
  }
}",0.9685466377440348
19538,"private void checkedOffer(List<String> transcript,Queue<List<String>> texts,Queue<TimeFrame> timeFrames,Queue<Range<Integer>> ranges,int start,int end,long timeStart,long timeEnd){
  double wordDensity=((double)(timeEnd - timeStart)) / (end - start);
  System.out.println(""String_Node_Str"" + wordDensity + ""String_Node_Str""+ timeEnd+ ""String_Node_Str""+ timeStart+ ""String_Node_Str""+ end+ ""String_Node_Str""+ start+ ""String_Node_Str""+ transcript.subList(start,end).toString());
  if (wordDensity < 10.0) {
    logger.info(""String_Node_Str"" + transcript.subList(start,end).toString());
    return;
  }
  texts.offer(transcript.subList(start,end));
  timeFrames.offer(new TimeFrame(timeStart,timeEnd));
  ranges.offer(Range.closed(start,end - 1));
}","private void checkedOffer(List<String> transcript,Queue<List<String>> texts,Queue<TimeFrame> timeFrames,Queue<Range<Integer>> ranges,int start,int end,long timeStart,long timeEnd){
  double wordDensity=((double)(timeEnd - timeStart)) / (end - start);
  System.out.println(""String_Node_Str"" + wordDensity + ""String_Node_Str""+ timeEnd+ ""String_Node_Str""+ timeStart+ ""String_Node_Str""+ end+ ""String_Node_Str""+ start+ ""String_Node_Str""+ transcript.subList(start,end).toString());
  if (wordDensity < 10.0) {
    logger.info(""String_Node_Str"",transcript.subList(start,end));
    return;
  }
  texts.offer(transcript.subList(start,end));
  timeFrames.offer(new TimeFrame(timeStart,timeEnd));
  ranges.offer(Range.closed(start,end - 1));
}",0.989844278943805
19539,"/** 
 * Returns the WordResult in this ConfusionSet for the given word.
 * @param word the word to look for
 * @return the WordResult for the given word, or null if no WordResult for the given word is found
 */
public WordResult getWordResult(String word){
  for (  Set<WordResult> wordSet : values()) {
    for (    WordResult wordResult : wordSet) {
      String resultSpelling=wordResult.toString();
      if (resultSpelling.equals(word)) {
        return wordResult;
      }
    }
  }
  return null;
}","/** 
 * Returns the WordResult in this ConfusionSet for the given word.
 * @param word the word to look for
 * @return the WordResult for the given word, or null if no WordResult for the given word is found
 */
public WordResult getWordResult(String word){
  for (  Set<WordResult> wordSet : values()) {
    for (    WordResult wordResult : wordSet) {
      String resultSpelling=wordResult.getPronunciation().getWord().getSpelling();
      if (resultSpelling.equals(word)) {
        return wordResult;
      }
    }
  }
  return null;
}",0.9596928982725528
19540,"@Override public void logInfo(){
  logger.info(""String_Node_Str"");
  meansPool.logInfo(logger);
  variancePool.logInfo(logger);
  transitionsPool.logInfo(logger);
  senonePool.logInfo(logger);
  if (meanTransformationMatrixPool != null)   meanTransformationMatrixPool.logInfo(logger);
  if (meanTransformationVectorPool != null)   meanTransformationVectorPool.logInfo(logger);
  if (varianceTransformationMatrixPool != null)   varianceTransformationMatrixPool.logInfo(logger);
  if (varianceTransformationVectorPool != null)   varianceTransformationVectorPool.logInfo(logger);
  mixtureWeightsPool.logInfo(logger);
  senonePool.logInfo(logger);
  logger.info(""String_Node_Str"" + contextIndependentUnits.size());
  hmmManager.logInfo(logger);
}","@Override public void logInfo(){
  logger.info(""String_Node_Str"" + location);
  meansPool.logInfo(logger);
  variancePool.logInfo(logger);
  transitionsPool.logInfo(logger);
  senonePool.logInfo(logger);
  if (meanTransformationMatrixPool != null)   meanTransformationMatrixPool.logInfo(logger);
  if (meanTransformationVectorPool != null)   meanTransformationVectorPool.logInfo(logger);
  if (varianceTransformationMatrixPool != null)   varianceTransformationMatrixPool.logInfo(logger);
  if (varianceTransformationVectorPool != null)   varianceTransformationVectorPool.logInfo(logger);
  mixtureWeightsPool.logInfo(logger);
  senonePool.logInfo(logger);
  logger.info(""String_Node_Str"" + contextIndependentUnits.size());
  hmmManager.logInfo(logger);
}",0.9926519706078824
19541,"/** 
 * Loads the dictionary with a list of URLs to custom dictionary resources
 * @param addenda the list of custom dictionary URLs to be loaded
 * @throws IOException if there is an error reading the resource URL
 */
private void loadCustomDictionaries(List<URL> addenda) throws IOException {
  if (addenda != null) {
    for (    URL addendumUrl : addenda) {
      loadDictionary(addendumUrl.openStream(),false);
    }
  }
}","/** 
 * Loads the dictionary with a list of URLs to custom dictionary resources
 * @param addenda the list of custom dictionary URLs to be loaded
 * @throws IOException if there is an error reading the resource URL
 */
private void loadCustomDictionaries(List<URL> addenda) throws IOException {
  if (addenda != null) {
    for (    URL addendumUrl : addenda) {
      logger.info(""String_Node_Str"" + addendumUrl);
      loadDictionary(addendumUrl.openStream(),false);
    }
  }
}",0.9426048565121412
19542,"/** 
 * Loads the dictionary with a list of URLs to custom dictionary resources
 * @param addenda the list of custom dictionary URLs to be loaded
 * @throws IOException if there is an error reading the resource URL
 */
private void loadCustomDictionaries(List<URL> addenda) throws IOException {
  if (addenda != null) {
    for (    URL addendumUrl : addenda) {
      loadDictionary(addendumUrl.openStream(),false);
    }
  }
}","/** 
 * Loads the dictionary with a list of URLs to custom dictionary resources
 * @param addenda the list of custom dictionary URLs to be loaded
 * @throws IOException if there is an error reading the resource URL
 */
private void loadCustomDictionaries(List<URL> addenda) throws IOException {
  if (addenda != null) {
    for (    URL addendumUrl : addenda) {
      logger.info(""String_Node_Str"" + addendumUrl);
      loadDictionary(addendumUrl.openStream(),false);
    }
  }
}",0.9426048565121412
19543,"@Override @SuppressWarnings(""String_Node_Str"") public void allocate() throws IOException {
  TimerPool.getTimer(this,""String_Node_Str"").start();
  if (ngramLogFile != null)   logFile=new PrintWriter(new FileOutputStream(ngramLogFile));
  if (location.getProtocol() == null || location.getProtocol().equals(""String_Node_Str"")) {
    loader=new BinaryLoader(new File(location.getFile()),format,applyLanguageWeightAndWip,logMath,languageWeight,wip,unigramWeight);
  }
 else {
    loader=new BinaryStreamLoader(location,format,applyLanguageWeightAndWip,logMath,languageWeight,wip,unigramWeight);
  }
  unigramIDMap=new HashMap<Word,UnigramProbability>();
  unigrams=loader.getUnigrams();
  loadedNGramBuffers=new Map[loader.getMaxDepth()];
  ngramProbTable=new float[loader.getMaxDepth()][];
  ngramBackoffTable=new float[loader.getMaxDepth()][];
  ngramSegmentTable=new int[loader.getMaxDepth()][];
  for (int i=1; i <= loader.getMaxDepth(); i++) {
    loadedNGramBuffers[i - 1]=new HashMap<WordSequence,NGramBuffer>();
    if (i >= 2)     ngramProbTable[i - 1]=loader.getNGramProbabilities(i);
    if (i > 2) {
      ngramBackoffTable[i - 1]=loader.getNGramBackoffWeights(i);
      ngramSegmentTable[i - 1]=loader.getNGramSegments(i);
    }
  }
  ngramDepthCache=new LRUCache<WordSequence,ProbDepth>(ngramCacheSize);
  buildUnigramIDMap(dictionary);
  loadedBigramBuffers=new NGramBuffer[unigrams.length];
  if (maxDepth <= 0 || maxDepth > loader.getMaxDepth())   maxDepth=loader.getMaxDepth();
  for (int i=1; i <= loader.getMaxDepth(); i++)   logger.info(Integer.toString(i) + ""String_Node_Str"" + loader.getNumberNGrams(i));
  if (fullSmear) {
    System.out.println(""String_Node_Str"");
    try {
      System.out.println(""String_Node_Str"");
      readSmearInfo(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
    }
 catch (    IOException e) {
      System.out.println(""String_Node_Str"" + e);
      System.out.println(""String_Node_Str"");
      buildSmearInfo();
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
    }
  }
  TimerPool.getTimer(this,""String_Node_Str"").stop();
}","@Override @SuppressWarnings(""String_Node_Str"") public void allocate() throws IOException {
  TimerPool.getTimer(this,""String_Node_Str"").start();
  logger.info(""String_Node_Str"" + location);
  if (ngramLogFile != null)   logFile=new PrintWriter(new FileOutputStream(ngramLogFile));
  if (location.getProtocol() == null || location.getProtocol().equals(""String_Node_Str"")) {
    loader=new BinaryLoader(new File(location.getFile()),format,applyLanguageWeightAndWip,logMath,languageWeight,wip,unigramWeight);
  }
 else {
    loader=new BinaryStreamLoader(location,format,applyLanguageWeightAndWip,logMath,languageWeight,wip,unigramWeight);
  }
  unigramIDMap=new HashMap<Word,UnigramProbability>();
  unigrams=loader.getUnigrams();
  loadedNGramBuffers=new Map[loader.getMaxDepth()];
  ngramProbTable=new float[loader.getMaxDepth()][];
  ngramBackoffTable=new float[loader.getMaxDepth()][];
  ngramSegmentTable=new int[loader.getMaxDepth()][];
  for (int i=1; i <= loader.getMaxDepth(); i++) {
    loadedNGramBuffers[i - 1]=new HashMap<WordSequence,NGramBuffer>();
    if (i >= 2)     ngramProbTable[i - 1]=loader.getNGramProbabilities(i);
    if (i > 2) {
      ngramBackoffTable[i - 1]=loader.getNGramBackoffWeights(i);
      ngramSegmentTable[i - 1]=loader.getNGramSegments(i);
    }
  }
  ngramDepthCache=new LRUCache<WordSequence,ProbDepth>(ngramCacheSize);
  buildUnigramIDMap(dictionary);
  loadedBigramBuffers=new NGramBuffer[unigrams.length];
  if (maxDepth <= 0 || maxDepth > loader.getMaxDepth())   maxDepth=loader.getMaxDepth();
  for (int i=1; i <= loader.getMaxDepth(); i++)   logger.info(Integer.toString(i) + ""String_Node_Str"" + loader.getNumberNGrams(i));
  if (fullSmear) {
    System.out.println(""String_Node_Str"");
    try {
      System.out.println(""String_Node_Str"");
      readSmearInfo(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
    }
 catch (    IOException e) {
      System.out.println(""String_Node_Str"" + e);
      System.out.println(""String_Node_Str"");
      buildSmearInfo();
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
    }
  }
  TimerPool.getTimer(this,""String_Node_Str"").stop();
}",0.989566427080918
19544,"/** 
 * Retain only the pronunciations that start with the unit indicated by nextBase
 * @param p        the set of pronunciations to filter
 * @param nextBase the ID of the desired initial unit
 */
Pronunciation[] filter(Pronunciation[] p,int nextBase){
  return p;
}","/** 
 * Retain only the pronunciations that start with the unit indicated by nextBase. This method can be used instead of filter to reduce search space. It's not used by default but could potentially lead to a decoding speedup.
 * @param p the set of pronunciations to filter
 * @param nextBase the ID of the desired initial unit
 */
Pronunciation[] filter(Pronunciation[] pronunciations,int nextBase){
  if (nextBase == ANY) {
    return pronunciations;
  }
  ArrayList<Pronunciation> filteredPronunciation=new ArrayList<Pronunciation>(pronunciations.length);
  for (  Pronunciation pronunciation : pronunciations) {
    if (pronunciation.getUnits()[0].getBaseID() == nextBase) {
      filteredPronunciation.add(pronunciation);
    }
  }
  return filteredPronunciation.toArray(new Pronunciation[filteredPronunciation.size()]);
}",0.4612579762989973
19545,"/** 
 * Reads the next line from the LM file. Keeps track of line number.
 * @throws IOException if an error occurs while reading the input or an EOF is encountered.
 */
private String readLine() throws IOException {
  String line;
  lineNumber++;
  line=reader.readLine();
  if (line == null) {
    corrupt(""String_Node_Str"");
  }
  return line;
}","/** 
 * Reads the next line from the LM file. Keeps track of line number.
 * @throws IOException if an error occurs while reading the input or an EOF is encountered.
 */
private String readLine() throws IOException {
  String line;
  lineNumber++;
  line=reader.readLine();
  if (line == null) {
    corrupt(""String_Node_Str"");
  }
  return line.trim();
}",0.9900426742532006
19546,"/** 
 * Partitions the given array of tokens in place, so that the highest scoring n token will be at the beginning of the array, not in any order.
 * @param tokens the array of tokens to partition
 * @param size   the number of tokens to partition
 * @param n      the number of tokens in the final partition
 * @return the index of the last element in the partition
 */
public int partition(Token[] tokens,int size,int n){
  if (tokens.length > n) {
    return midPointSelect(tokens,0,size - 1,n);
  }
 else {
    int r=-1;
    float lowestScore=Float.MAX_VALUE;
    for (int i=0; i < tokens.length; i++) {
      Token current=tokens[i];
      float currentScore=current.getScore();
      if (currentScore <= lowestScore) {
        lowestScore=currentScore;
        r=i;
      }
    }
    int last=size - 1;
    if (last >= 0) {
      Token lastToken=tokens[last];
      setToken(tokens,last,tokens[r]);
      setToken(tokens,r,lastToken);
    }
    return last;
  }
}","/** 
 * Partitions the given array of tokens in place, so that the highest scoring n token will be at the beginning of the array, not in any order.
 * @param tokens the array of tokens to partition
 * @param size   the number of tokens to partition
 * @param n      the number of tokens in the final partition
 * @return the index of the last element in the partition
 */
public int partition(Token[] tokens,int size,int n){
  if (tokens.length > n) {
    return midPointSelect(tokens,0,size - 1,n,0);
  }
 else {
    return findBest(tokens,size);
  }
}",0.6894287590282338
19547,"/** 
 * Partitions sub-array of tokens around the x-th token by selecting the midpoint of the token array as the pivot.
 * @param tokens the token array to partition
 * @param p      the starting index of the subarray
 * @param r      the ending index of the subarray, inclusive
 * @return the index of the element around which the array is partitioned
 */
private int midPointPartition(Token[] tokens,int p,int r){
  int i=(p + r) >>> 1;
  Token temp=tokens[r];
  setToken(tokens,r,tokens[i]);
  setToken(tokens,i,temp);
  return partitions(tokens,p,r);
}","/** 
 * Partitions sub-array of tokens around the x-th token by selecting the midpoint of the token array as the pivot. Partially solves issues with slow performance on already sorted arrays.
 * @param tokens the token array to partition
 * @param start      the starting index of the subarray
 * @param end      the ending index of the subarray, inclusive
 * @return the index of the element around which the array is partitioned
 */
private int midPointPartition(Token[] tokens,int start,int end){
  int middle=(start + end) >>> 1;
  Token temp=tokens[end];
  setToken(tokens,end,tokens[middle]);
  setToken(tokens,middle,temp);
  return endPointPartition(tokens,start,end);
}",0.8541329011345219
19548,"/** 
 * Selects the token with the ith largest token score.
 * @param tokens the token array to partition
 * @param p      the starting index of the subarray
 * @param r      the ending index of the subarray, inclusive
 * @param i      the token with the i-th largest score
 * @return the index of the token with the ith largest score
 */
private int midPointSelect(Token[] tokens,int p,int r,int i){
  if (p == r) {
    return p;
  }
  int q=midPointPartition(tokens,p,r);
  int k=q - p + 1;
  if (i == k) {
    return q;
  }
 else   if (i < k) {
    return midPointSelect(tokens,p,q - 1,i);
  }
 else {
    return midPointSelect(tokens,q + 1,r,i - k);
  }
}","/** 
 * Selects the token with the ith largest token score.
 * @param tokens       the token array to partition
 * @param start        the starting index of the subarray
 * @param end          the ending index of the subarray, inclusive
 * @param targetSize   target size of the partition
 * @param depth        recursion depth to avoid stack overflow and fall back to simple partition.
 * @return the index of the token with the ith largest score
 */
private int midPointSelect(Token[] tokens,int start,int end,int targetSize,int depth){
  if (depth > MAX_DEPTH) {
    return simplePointSelect(tokens,start,end,targetSize);
  }
  if (start == end) {
    return start;
  }
  int partitionToken=midPointPartition(tokens,start,end);
  int newSize=partitionToken - start + 1;
  if (targetSize == newSize) {
    return partitionToken;
  }
 else   if (targetSize < newSize) {
    return midPointSelect(tokens,start,partitionToken - 1,targetSize,depth + 1);
  }
 else {
    return midPointSelect(tokens,partitionToken + 1,end,targetSize - newSize,depth + 1);
  }
}",0.6732673267326733
19549,"@Override public void deallocate(){
  scorer.deallocate();
  pruner.deallocate();
  linguist.deallocate();
}","@Override public void deallocate(){
  try {
    scorer.deallocate();
    pruner.deallocate();
    linguist.deallocate();
  }
 catch (  IOException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}",0.6792452830188679
19550,"@Override public void deallocate(){
  scorer.deallocate();
  pruner.deallocate();
  linguist.deallocate();
}","@Override public void deallocate(){
  try {
    scorer.deallocate();
    pruner.deallocate();
    linguist.deallocate();
  }
 catch (  IOException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}",0.6792452830188679
19551,"/** 
 * Deallocates the linguist. Any resources allocated by this linguist are released. <p/> <p/> Implementor's Note - if the linguist is being shared by multiple searches, the deallocate should only actually deallocate things when the last call to deallocate is made. Two approaches for dealing with this: <p/> (1) Keep an allocation counter that is incremented during allocate and decremented during deallocate. Only when the counter reaches zero should the actually deallocation be performed. <p/> (2) Do nothing in dellocate - just the the GC take care of things
 */
public void deallocate();","/** 
 * Deallocates the linguist. Any resources allocated by this linguist are released. <p/> <p/> Implementor's Note - if the linguist is being shared by multiple searches, the deallocate should only actually deallocate things when the last call to deallocate is made. Two approaches for dealing with this: <p/> (1) Keep an allocation counter that is incremented during allocate and decremented during deallocate. Only when the counter reaches zero should the actually deallocation be performed. <p/> (2) Do nothing in dellocate - just the the GC take care of things
 */
public void deallocate() throws IOException ;",0.9835255354200988
19552,"@Override public void deallocate(){
  allocated=false;
  classLM.deallocate();
  classMap.deallocate();
  vocabulary=null;
}","@Override public void deallocate() throws IOException {
  allocated=false;
  classLM.deallocate();
  classMap.deallocate();
  vocabulary=null;
}",0.9253731343283582
19553,"@Override public void deallocate(){
  allocated=false;
  for (  LanguageModel model : languageModels) {
    model.deallocate();
  }
}","@Override public void deallocate() throws IOException {
  allocated=false;
  for (  LanguageModel model : languageModels) {
    model.deallocate();
  }
}",0.93006993006993
19554,"@Override public void deallocate(){
  parent.deallocate();
}","@Override public void deallocate() throws IOException {
  parent.deallocate();
}",0.8571428571428571
19555,"/** 
 * Retrieves the rule parse for the given result
 * @param the recognition result
 * @return the rule parse for the result
 * @throws GrammarException if there is an error while parsing theresult
 */
RuleParse getRuleParse(Result result) throws GrammarException {
  String resultText=result.getBestFinalResultNoFiller();
  BaseRecognizer jsapiRecognizer=new BaseRecognizer(getGrammar().getGrammarManager());
  RuleGrammar ruleGrammar=new BaseRuleGrammar(jsapiRecognizer,getGrammar().getRuleGrammar());
  RuleParse ruleParse=ruleGrammar.parse(resultText,null);
  return ruleParse;
}","/** 
 * Retrieves the rule parse for the given result
 * @param the recognition result
 * @return the rule parse for the result
 * @throws GrammarException if there is an error while parsing theresult
 */
RuleParse getRuleParse(Result result) throws GrammarException {
  String resultText=result.getBestFinalResultNoFiller();
  BaseRecognizer jsapiRecognizer=new BaseRecognizer(getGrammar().getGrammarManager());
  try {
    jsapiRecognizer.allocate();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  RuleGrammar ruleGrammar=new BaseRuleGrammar(jsapiRecognizer,getGrammar().getRuleGrammar());
  RuleParse ruleParse=ruleGrammar.parse(resultText,null);
  return ruleParse;
}",0.9228346456692912
19556,"/** 
 * Convenience method that throws an <code>EngineStateError</code> if any of the bits in the passed state are set in the <code>state</code>.
 * @param state the <code>Engine</code> state to check
 * @throws EngineStateError if any of the bits in the passed state are set in the <code>state</code>
 */
protected void checkEngineState(long state) throws EngineStateError {
  long currentState=getEngineState();
  if ((currentState & state) != 0) {
    throw new EngineStateError(""String_Node_Str"" + stateToString(state) + ""String_Node_Str""+ stateToString(currentState)+ ')');
  }
}","/** 
 * Convenience method that throws an <code>EngineStateError</code> if any of the bits in the passed state are set in the <code>state</code>.
 * @param state the <code>Engine</code> state to check
 * @throws EngineStateError if any of the bits in the passed state are set in the <code>state</code>
 */
protected void checkEngineState(long state) throws EngineStateError {
  long currentState=getEngineState();
  if ((currentState & state) != 0) {
    throw new EngineStateError(""String_Node_Str"" + stateToString(currentState));
  }
}",0.943800178412132
19557,"/** 
 * Returns the number of unigrams
 * @return the nubmer of unigrams
 */
public int getNumberUnigrams(){
  return getNumberNGrams(1);
}","/** 
 * Returns the number of unigrams
 * @return the number of unigrams
 */
public int getNumberUnigrams(){
  return getNumberNGrams(1);
}",0.9928057553956836
19558,"/** 
 * Reads the LM file header
 * @param stream the data stream of the LM file
 * @throws java.io.IOException
 */
private void readHeader(DataInputStream stream) throws IOException {
  int headerLength=readInt(stream,bigEndian);
  if ((headerLength != DARPA_TG_HEADER.length() + 1) && (headerLength != DARPA_QG_HEADER.length() + 1) && (headerLength != DARPA_NG_HEADER.length() - 1)) {
    headerLength=Utilities.swapInteger(headerLength);
    if (headerLength == (DARPA_TG_HEADER.length() + 1) || headerLength == (DARPA_QG_HEADER.length() + 1) || headerLength == (DARPA_NG_HEADER.length() - 1)) {
      bigEndian=false;
    }
 else {
      throw new Error(""String_Node_Str"" + headerLength + ""String_Node_Str"");
    }
  }
 else {
  }
  String header=readString(stream,headerLength - 1);
  readByte(stream);
  if (!header.equals(DARPA_TG_HEADER) & !header.equals(DARPA_QG_HEADER) & !Pattern.matches(DARPA_NG_HEADER,header)) {
    throw new Error(""String_Node_Str"" + header);
  }
 else {
    if (header.equals(DARPA_TG_HEADER))     maxNGram=3;
 else     if (header.equals(DARPA_QG_HEADER))     maxNGram=4;
 else {
      Pattern p=Pattern.compile(""String_Node_Str"");
      Matcher m=p.matcher(header);
      maxNGram=Integer.parseInt(m.group());
    }
  }
  int fileNameLength=readInt(stream,bigEndian);
  bytesRead+=(long)stream.skipBytes(fileNameLength);
  numberNGrams=new int[maxNGram];
  NGramOffset=new long[maxNGram];
  NGramProbTable=new float[maxNGram][];
  NGramBackoffTable=new float[maxNGram][];
  NGramSegmentTable=new int[maxNGram][];
  numberNGrams[0]=0;
  logNGramSegmentSize=LOG2_NGRAM_SEGMENT_SIZE;
  int version=readInt(stream,bigEndian);
  bytesPerField=2;
  if (version <= 0) {
    readInt(stream,bigEndian);
    if (version <= -3)     bytesPerField=4;
    int formatLength;
    for (; ; ) {
      if ((formatLength=readInt(stream,bigEndian)) == 0) {
        break;
      }
      bytesRead+=(long)stream.skipBytes(formatLength);
    }
    if (version == -2) {
      logNGramSegmentSize=readInt(stream,bigEndian);
      if (logNGramSegmentSize < 1 || logNGramSegmentSize > 15) {
        throw new Error(""String_Node_Str"");
      }
    }
    numberNGrams[0]=readInt(stream,bigEndian);
  }
 else {
    numberNGrams[0]=version;
  }
  if (numberNGrams[0] <= 0) {
    throw new Error(""String_Node_Str"" + numberNGrams[0] + ""String_Node_Str"");
  }
  for (int i=1; i < maxNGram; i++) {
    if ((numberNGrams[i]=readInt(stream,bigEndian)) < 0) {
      throw new Error(""String_Node_Str"" + String.valueOf(i) + ""String_Node_Str""+ numberNGrams[i]);
    }
  }
}","/** 
 * Reads the LM file header
 * @param stream the data stream of the LM file
 * @throws java.io.IOException
 */
private void readHeader(DataInputStream stream) throws IOException {
  int headerLength=readInt(stream,bigEndian);
  if ((headerLength != DARPA_TG_HEADER.length() + 1) && (headerLength != DARPA_QG_HEADER.length() + 1) && (headerLength != DARPA_NG_HEADER.length() - 1)) {
    headerLength=Utilities.swapInteger(headerLength);
    if (headerLength == (DARPA_TG_HEADER.length() + 1) || headerLength == (DARPA_QG_HEADER.length() + 1) || headerLength == (DARPA_NG_HEADER.length() - 1)) {
      bigEndian=false;
    }
 else {
      throw new Error(""String_Node_Str"" + headerLength + ""String_Node_Str"");
    }
  }
 else {
  }
  String header=readString(stream,headerLength - 1);
  readByte(stream);
  if (!header.equals(DARPA_TG_HEADER) & !header.equals(DARPA_QG_HEADER) & !Pattern.matches(DARPA_NG_HEADER,header)) {
    throw new Error(""String_Node_Str"" + header);
  }
 else {
    if (header.equals(DARPA_TG_HEADER))     maxNGram=3;
 else     if (header.equals(DARPA_QG_HEADER))     maxNGram=4;
 else {
      Pattern p=Pattern.compile(""String_Node_Str"");
      Matcher m=p.matcher(header);
      maxNGram=Integer.parseInt(m.group());
    }
  }
  int fileNameLength=readInt(stream,bigEndian);
  skipStreamBytes(stream,fileNameLength);
  numberNGrams=new int[maxNGram];
  NGramOffset=new long[maxNGram];
  NGramProbTable=new float[maxNGram][];
  NGramBackoffTable=new float[maxNGram][];
  NGramSegmentTable=new int[maxNGram][];
  numberNGrams[0]=0;
  logNGramSegmentSize=LOG2_NGRAM_SEGMENT_SIZE;
  int version=readInt(stream,bigEndian);
  bytesPerField=2;
  if (version <= 0) {
    readInt(stream,bigEndian);
    if (version <= -3)     bytesPerField=4;
    int formatLength;
    for (; ; ) {
      if ((formatLength=readInt(stream,bigEndian)) == 0) {
        break;
      }
      bytesRead+=(long)stream.skipBytes(formatLength);
    }
    if (version == -2) {
      logNGramSegmentSize=readInt(stream,bigEndian);
      if (logNGramSegmentSize < 1 || logNGramSegmentSize > 15) {
        throw new Error(""String_Node_Str"");
      }
    }
    numberNGrams[0]=readInt(stream,bigEndian);
  }
 else {
    numberNGrams[0]=version;
  }
  if (numberNGrams[0] <= 0) {
    throw new Error(""String_Node_Str"" + numberNGrams[0] + ""String_Node_Str"");
  }
  for (int i=1; i < maxNGram; i++) {
    if ((numberNGrams[i]=readInt(stream,bigEndian)) < 0) {
      throw new Error(""String_Node_Str"" + String.valueOf(i) + ""String_Node_Str""+ numberNGrams[i]);
    }
  }
}",0.6630201211174057
19559,"/** 
 * Returns the number of bigrams
 * @return the nubmer of bigrams
 */
public int getNumberBigrams(){
  return getNumberNGrams(2);
}","/** 
 * Returns the number of bigrams
 * @return the number of bigrams
 */
public int getNumberBigrams(){
  return getNumberNGrams(2);
}",0.9926470588235294
19560,"/** 
 * Returns the maximum depth of the language model
 * @return the maximum depth of the language mdoel
 */
public int getMaxDepth(){
  return maxNGram;
}","/** 
 * Returns the maximum depth of the language model
 * @return the maximum depth of the language model
 */
public int getMaxDepth(){
  return maxNGram;
}",0.9936305732484076
19561,"/** 
 * Skips the NGrams of the LM.
 * @param stream the source of data
 * @throws java.io.IOException
 */
private void skipNGrams(DataInputStream stream) throws IOException {
  NGramOffset[1]=bytesRead;
  int bytesToSkip=(numberNGrams[1] + 1) * LargeNGramModel.BYTES_PER_NGRAM * getBytesPerField();
  stream.skipBytes(bytesToSkip);
  bytesRead+=bytesToSkip;
  for (int i=2; i < maxNGram; i++) {
    if (numberNGrams[i] > 0 && i < maxNGram - 1) {
      NGramOffset[i]=bytesRead;
      long bToSkip=(long)(numberNGrams[i] + 1) * (long)LargeNGramModel.BYTES_PER_NGRAM * (long)getBytesPerField();
      stream.skip(bToSkip);
      bytesRead+=bToSkip;
    }
 else     if (numberNGrams[i] > 0 && i == maxNGram - 1) {
      NGramOffset[i]=bytesRead;
      long bToSkip=(long)(numberNGrams[i]) * (long)LargeNGramModel.BYTES_PER_NMAXGRAM * (long)getBytesPerField();
      stream.skip(bToSkip);
      bytesRead+=bToSkip;
    }
  }
}","/** 
 * Skips the NGrams of the LM.
 * @param stream the source of data
 * @throws java.io.IOException
 */
private void skipNGrams(DataInputStream stream) throws IOException {
  long bytesToSkip;
  NGramOffset[1]=bytesRead;
  bytesToSkip=(numberNGrams[1] + 1) * LargeNGramModel.BYTES_PER_NGRAM * getBytesPerField();
  skipStreamBytes(stream,bytesToSkip);
  for (int i=2; i < maxNGram; i++) {
    if (numberNGrams[i] > 0 && i < maxNGram - 1) {
      NGramOffset[i]=bytesRead;
      bytesToSkip=(long)(numberNGrams[i] + 1) * (long)LargeNGramModel.BYTES_PER_NGRAM * (long)getBytesPerField();
      skipStreamBytes(stream,bytesToSkip);
    }
 else     if (numberNGrams[i] > 0 && i == maxNGram - 1) {
      NGramOffset[i]=bytesRead;
      bytesToSkip=(long)(numberNGrams[i]) * (long)LargeNGramModel.BYTES_PER_NMAXGRAM * (long)getBytesPerField();
      skipStreamBytes(stream,bytesToSkip);
    }
  }
}",0.845984598459846
19562,"/** 
 * Returns the number of trigrams
 * @return the nubmer of trigrams
 */
public int getNumberTrigrams(){
  return getNumberNGrams(3);
}","/** 
 * Returns the number of trigrams
 * @return the number of trigrams
 */
public int getNumberTrigrams(){
  return getNumberNGrams(3);
}",0.9928057553956836
19563,"/** 
 * Initializes the binary loader
 * @param format                    the file format
 * @param location                  the location of the model
 * @param applyLanguageWeightAndWip if true apply lw and wip
 * @param logMath                   the logmath to sue
 * @param languageWeight            the language weight
 * @param wip                       the word insertion probability
 * @param unigramWeight             the unigram weight
 * @throws IOException if an I/O error occurs
 */
public BinaryLoader(String format,File location,boolean applyLanguageWeightAndWip,LogMath logMath,float languageWeight,double wip,float unigramWeight) throws IOException {
  startWordID=-1;
  endWordID=-1;
  this.applyLanguageWeightAndWip=applyLanguageWeightAndWip;
  this.logMath=logMath;
  this.languageWeight=languageWeight;
  this.wip=wip;
  this.unigramWeight=unigramWeight;
  loadBinary(location);
}","/** 
 * Initializes the binary loader
 * @param format                    the file format
 * @param location                  the location of the model
 * @param applyLanguageWeightAndWip if true apply language weight and word insertion penalty
 * @param logMath                   the logmath to sue
 * @param languageWeight            the language weight
 * @param wip                       the word insertion probability
 * @param unigramWeight             the unigram weight
 * @throws IOException if an I/O error occurs
 */
public BinaryLoader(String format,File location,boolean applyLanguageWeightAndWip,LogMath logMath,float languageWeight,double wip,float unigramWeight) throws IOException {
  startWordID=-1;
  endWordID=-1;
  this.applyLanguageWeightAndWip=applyLanguageWeightAndWip;
  this.logMath=logMath;
  this.languageWeight=languageWeight;
  this.wip=wip;
  this.unigramWeight=unigramWeight;
  loadBinary(location);
}",0.9727371864776444
19564,"/** 
 * Keeps track of and reports all of the active word histories for the given active list
 * @param activeList the active list to track
 */
private void monitorWords(ActiveList activeList){
  WordTracker tracker=new WordTracker(currentFrameNumber);
  for (  Token t : activeList) {
    tracker.add(t);
  }
  tracker.dump();
}","/** 
 * Keeps track of and reports all of the active word histories for the given active list
 * @param activeList the active list to track
 */
@SuppressWarnings(""String_Node_Str"") private void monitorWords(ActiveList activeList){
  WordTracker tracker=new WordTracker(currentFrameNumber);
  for (  Token t : activeList) {
    tracker.add(t);
  }
  tracker.dump();
}",0.9467625899280576
19565,"/** 
 * Collects the next set of emitting tokens from a token and accumulates them in the active or result lists
 * @param token the token to collect successors from be immediately expanded are placed. Null if we should alwaysexpand all nodes.
 */
protected void collectSuccessorTokens(Token token){
  if (token.isFinal()) {
    resultList.add(getWordPredecessor(token));
    return;
  }
  if (!token.isEmitting() && (keepAllTokens && isVisited(token))) {
    return;
  }
  SearchState state=token.getSearchState();
  SearchStateArc[] arcs=state.getSuccessors();
  Token predecessor=getWordPredecessor(token);
  for (  SearchStateArc arc : arcs) {
    SearchState nextState=arc.getState();
    if (checkStateOrder) {
      checkStateOrder(state,nextState);
    }
    float logEntryScore=token.getScore() + arc.getProbability();
    Token bestToken=getBestToken(nextState);
    boolean firstToken=bestToken == null;
    if (firstToken || bestToken.getScore() < logEntryScore) {
      Token newBestToken=new Token(predecessor,nextState,logEntryScore,arc.getLanguageProbability(),arc.getInsertionProbability(),currentFrameNumber);
      tokensCreated.value++;
      setBestToken(newBestToken,nextState);
      if (firstToken) {
        activeListAdd(newBestToken);
      }
 else {
        activeListReplace(bestToken,newBestToken);
        if (buildWordLattice && newBestToken.isWord()) {
          loserManager.changeSuccessor(newBestToken,bestToken);
          loserManager.addAlternatePredecessor(newBestToken,bestToken.getPredecessor());
        }
      }
    }
 else {
      if (buildWordLattice && nextState instanceof WordSearchState) {
        if (predecessor != null) {
          loserManager.addAlternatePredecessor(bestToken,predecessor);
        }
      }
    }
  }
}","/** 
 * Collects the next set of emitting tokens from a token and accumulates them in the active or result lists
 * @param token the token to collect successors from be immediately expanded are placed. Null if we should alwaysexpand all nodes.
 */
protected void collectSuccessorTokens(Token token){
  if (token.isFinal()) {
    resultList.add(getResultListPredecessor(token));
    return;
  }
  if (!token.isEmitting() && (keepAllTokens && isVisited(token))) {
    return;
  }
  SearchState state=token.getSearchState();
  SearchStateArc[] arcs=state.getSuccessors();
  Token predecessor=getResultListPredecessor(token);
  for (  SearchStateArc arc : arcs) {
    SearchState nextState=arc.getState();
    if (checkStateOrder) {
      checkStateOrder(state,nextState);
    }
    float logEntryScore=token.getScore() + arc.getProbability();
    Token bestToken=getBestToken(nextState);
    boolean firstToken=bestToken == null;
    if (firstToken || bestToken.getScore() < logEntryScore) {
      Token newBestToken=new Token(predecessor,nextState,logEntryScore,arc.getLanguageProbability(),arc.getInsertionProbability(),currentFrameNumber);
      tokensCreated.value++;
      setBestToken(newBestToken,nextState);
      if (firstToken) {
        activeListAdd(newBestToken);
      }
 else {
        activeListReplace(bestToken,newBestToken);
        if (buildWordLattice && newBestToken.isWord()) {
          loserManager.changeSuccessor(newBestToken,bestToken);
          loserManager.addAlternatePredecessor(newBestToken,bestToken.getPredecessor());
        }
      }
    }
 else {
      if (buildWordLattice && nextState instanceof WordSearchState) {
        if (predecessor != null) {
          loserManager.addAlternatePredecessor(bestToken,predecessor);
        }
      }
    }
  }
}",0.9921436588103256
19566,"@Override public void newProperties(PropertySheet ps) throws PropertyException {
  logger=ps.getLogger();
  logBase=ps.getFloat(PROP_LOG_BASE);
  useAddTable=ps.getBoolean(PROP_USE_ADD_TABLE);
  init();
  if (lastInstance != null)   System.err.println(""String_Node_Str"");
  lastInstance=this;
}","@Override public void newProperties(PropertySheet ps) throws PropertyException {
  logger=ps.getLogger();
  logBase=ps.getFloat(PROP_LOG_BASE);
  useAddTable=ps.getBoolean(PROP_USE_ADD_TABLE);
  init();
}",0.8192771084337349
19567,"/** 
 * Self test for Lattices. Test loading, saving, dynamically creating and optimizing Lattices
 * @param args
 */
@Test public void testLattice(){
  Lattice lattice=null;
  System.err.println(""String_Node_Str"");
  lattice=new Lattice(LogMath.getInstance());
  Node n0=lattice.addNode(""String_Node_Str"",""String_Node_Str"",0,0);
  Node n1=lattice.addNode(""String_Node_Str"",""String_Node_Str"",0,0);
  Node n1a=lattice.addNode(""String_Node_Str"",""String_Node_Str"",0,0);
  Node n2=lattice.addNode(""String_Node_Str"",""String_Node_Str"",0,0);
  Node n2a=lattice.addNode(""String_Node_Str"",""String_Node_Str"",0,0);
  Node n3=lattice.addNode(""String_Node_Str"",""String_Node_Str"",0,0);
  Node n4=lattice.addNode(""String_Node_Str"",""String_Node_Str"",0,0);
  lattice.addEdge(n0,n1,-1,0);
  lattice.addEdge(n0,n1a,-1,0);
  lattice.addEdge(n1,n4,-1,0);
  lattice.addEdge(n1a,n2a,-1,0);
  lattice.addEdge(n2a,n4,-1,0);
  lattice.addEdge(n0,n2,-1,0);
  lattice.addEdge(n2,n3,-1,0);
  lattice.addEdge(n1,n3,-1,0);
  lattice.addEdge(n3,n4,-1,0);
  lattice.setInitialNode(n0);
  lattice.setTerminalNode(n4);
  System.err.println(""String_Node_Str"" + lattice.getNodes().size() + ""String_Node_Str""+ lattice.getEdges().size()+ ""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  lattice.dump(""String_Node_Str"");
  lattice.dumpAllPaths();
  LatticeOptimizer lo=new LatticeOptimizer(lattice);
  lo.optimize();
  lattice.dumpAllPaths();
}","/** 
 * Self test for Lattices. Test loading, saving, dynamically creating and optimizing Lattices
 * @param args
 */
@Test public void testLattice(){
  Lattice lattice=null;
  System.err.println(""String_Node_Str"");
  lattice=new Lattice(new LogMath(1.0001f,true));
  Node n0=lattice.addNode(""String_Node_Str"",""String_Node_Str"",0,0);
  Node n1=lattice.addNode(""String_Node_Str"",""String_Node_Str"",0,0);
  Node n1a=lattice.addNode(""String_Node_Str"",""String_Node_Str"",0,0);
  Node n2=lattice.addNode(""String_Node_Str"",""String_Node_Str"",0,0);
  Node n2a=lattice.addNode(""String_Node_Str"",""String_Node_Str"",0,0);
  Node n3=lattice.addNode(""String_Node_Str"",""String_Node_Str"",0,0);
  Node n4=lattice.addNode(""String_Node_Str"",""String_Node_Str"",0,0);
  lattice.addEdge(n0,n1,-1,0);
  lattice.addEdge(n0,n1a,-1,0);
  lattice.addEdge(n1,n4,-1,0);
  lattice.addEdge(n1a,n2a,-1,0);
  lattice.addEdge(n2a,n4,-1,0);
  lattice.addEdge(n0,n2,-1,0);
  lattice.addEdge(n2,n3,-1,0);
  lattice.addEdge(n1,n3,-1,0);
  lattice.addEdge(n3,n4,-1,0);
  lattice.setInitialNode(n0);
  lattice.setTerminalNode(n4);
  System.err.println(""String_Node_Str"" + lattice.getNodes().size() + ""String_Node_Str""+ lattice.getEdges().size()+ ""String_Node_Str"");
  System.err.println(""String_Node_Str"");
  lattice.dump(""String_Node_Str"");
  lattice.dumpAllPaths();
  LatticeOptimizer lo=new LatticeOptimizer(lattice);
  lo.optimize();
  lattice.dumpAllPaths();
}",0.98943661971831
19568,"/** 
 * Gets the cached score for this senone based upon the given feature. If the score was not cached, it is calculated using   {@link #calculateScore}, cached, and then returned.  
 */
@Override public float getScore(Data feature){
  Float score=scoreCache.get(feature);
  if (score == null) {
    score=calculateScore(feature);
    scoreCache.putIfAbsent(feature,score);
  }
  return score;
}","/** 
 * Gets the cached score for this senone based upon the given feature. If the score was not cached, it is calculated using   {@link #calculateScore}, cached, and then returned.  
 */
@Override public float getScore(Data feature){
  ScoreCache cached=scoreCache;
  if (feature != cached.feature) {
    cached=new ScoreCache(feature,calculateScore(feature));
    scoreCache=cached;
  }
  return cached.score;
}",0.6699629171817059
19569,"@Override public void allocate(){
  super.allocate();
  if (executorService == null) {
    logger.fine(numThreads > 1 ? ""String_Node_Str"" + numThreads : ""String_Node_Str"");
    executorService=numThreads > 1 ? Executors.newFixedThreadPool(numThreads) : null;
  }
}","@Override public void allocate(){
  super.allocate();
  if (executorService == null) {
    if (numThreads > 1) {
      logger.fine(""String_Node_Str"" + numThreads);
      executorService=Executors.newFixedThreadPool(numThreads,new CustomThreadFactory(className,true,Thread.NORM_PRIORITY));
    }
 else {
      logger.fine(""String_Node_Str"");
    }
  }
}",0.6688311688311688
19570,"/** 
 * Compute the utterance-level posterior for every node in the lattice, i.e. the probability that this node occurs on any path through the lattice. Uses a forward-backward algorithm specific to the nature of non-looping left-to-right lattice structures. <p/> Node posteriors can be retrieved by calling getPosterior() on Node objects.
 * @param languageModelWeight   the language model weight that was used in generating the scores in the lattice
 * @param useAcousticScoresOnly use only the acoustic scores to compute the posteriors, ignore the language weightand scores
 */
public void computeNodePosteriors(float languageModelWeight,boolean useAcousticScoresOnly){
}","/** 
 * Compute the utterance-level posterior for every node in the lattice, i.e. the probability that this node occurs on any path through the lattice. Uses a forward-backward algorithm specific to the nature of non-looping left-to-right lattice structures. <p/> Node posteriors can be retrieved by calling getPosterior() on Node objects.
 * @param languageModelWeightAdjustment   the weight multiplier that will be applied to language score already scaled by language weight
 * @param useAcousticScoresOnly use only the acoustic scores to compute the posteriors, ignore the language weightand scores
 */
public void computeNodePosteriors(float languageModelWeightAdjustment,boolean useAcousticScoresOnly){
}",0.8763557483731019
19571,"/** 
 * Computes the score of an edge.
 * @param edge                the edge which score we want to compute
 * @param languageModelWeight the language model weight to use
 * @return the score of an edge
 */
private double computeEdgeScore(Edge edge,float languageModelWeight,boolean useAcousticScoresOnly){
  if (useAcousticScoresOnly) {
    return edge.getAcousticScore();
  }
 else {
    return (edge.getAcousticScore() + edge.getLMScore()) / languageModelWeight;
  }
}","/** 
 * Computes the score of an edge. It multiplies on adjustment since language model score is already scaled by language model weight in linguist.
 * @param edge                the edge which score we want to compute
 * @param languageModelWeightAdjustment the weight multiplier that will be applied to language score already scaled by language weight
 * @return the score of an edge
 */
private double computeEdgeScore(Edge edge,float languageModelWeightAdjustment,boolean useAcousticScoresOnly){
  if (useAcousticScoresOnly) {
    return edge.getAcousticScore();
  }
 else {
    return edge.getAcousticScore() + edge.getLMScore() * languageModelWeightAdjustment;
  }
}",0.7737991266375546
19572,"/** 
 * Computes confidences for a Result and returns a ConfidenceResult, a compact representation of all the hypothesis contained in the result together with their per-word and per-path confidences.
 * @param result the result to compute confidences for
 * @return a confidence result
 */
@Override public ConfidenceResult score(Result result){
  Lattice lattice=new Lattice(result);
  LatticeOptimizer lop=new LatticeOptimizer(lattice);
  lop.optimize();
  lattice.computeNodePosteriors(languageWeight);
  SausageMaker sm=new SausageMaker(lattice);
  Sausage s=sm.makeSausage();
  if (dumpLattice) {
    lattice.dumpAISee(""String_Node_Str"",""String_Node_Str"");
  }
  if (dumpSausage) {
    s.dumpAISee(""String_Node_Str"",""String_Node_Str"");
  }
  WordResultPath mapPath=new WordResultPath();
  List<Token> wordTokens=getWordTokens(result.getBestToken());
  int slot=0;
  for (  Token wordToken : wordTokens) {
    String word=wordToken.getWord().getSpelling();
    WordResult wr=null;
    ConfusionSet cs=null;
    while (slot < s.size() && wr == null) {
      cs=s.getConfusionSet(slot);
      wr=cs.getWordResult(word);
      if (wr == null) {
        slot++;
      }
    }
    if (wr != null) {
      mapPath.add(wr);
    }
 else {
      cs.dump(""String_Node_Str"" + slot);
      throw new Error(""String_Node_Str"" + slot + ""String_Node_Str""+ word);
    }
    slot++;
  }
  return (new MAPConfidenceResult(s,mapPath));
}","/** 
 * Computes confidences for a Result and returns a ConfidenceResult, a compact representation of all the hypothesis contained in the result together with their per-word and per-path confidences.
 * @param result the result to compute confidences for
 * @return a confidence result
 */
@Override public ConfidenceResult score(Result result){
  Lattice lattice=new Lattice(result);
  LatticeOptimizer lop=new LatticeOptimizer(lattice);
  lop.optimize();
  lattice.computeNodePosteriors(languageWeightAdjustment);
  SausageMaker sm=new SausageMaker(lattice);
  Sausage s=sm.makeSausage();
  if (dumpLattice) {
    lattice.dumpAISee(""String_Node_Str"",""String_Node_Str"");
  }
  if (dumpSausage) {
    s.dumpAISee(""String_Node_Str"",""String_Node_Str"");
  }
  WordResultPath mapPath=new WordResultPath();
  List<Token> wordTokens=getWordTokens(result.getBestToken());
  int slot=0;
  for (  Token wordToken : wordTokens) {
    String word=wordToken.getWord().getSpelling();
    WordResult wr=null;
    ConfusionSet cs=null;
    while (slot < s.size() && wr == null) {
      cs=s.getConfusionSet(slot);
      wr=cs.getWordResult(word);
      if (wr == null) {
        slot++;
      }
    }
    if (wr != null) {
      mapPath.add(wr);
    }
 else {
      cs.dump(""String_Node_Str"" + slot);
      throw new Error(""String_Node_Str"" + slot + ""String_Node_Str""+ word);
    }
    slot++;
  }
  return (new MAPConfidenceResult(s,mapPath));
}",0.9964936886395512
19573,"@Override public void newProperties(PropertySheet ps) throws PropertyException {
  languageWeight=ps.getFloat(PROP_LANGUAGE_WEIGHT);
  dumpLattice=ps.getBoolean(PROP_DUMP_LATTICE);
  dumpSausage=ps.getBoolean(PROP_DUMP_SAUSAGE);
}","@Override public void newProperties(PropertySheet ps) throws PropertyException {
  languageWeightAdjustment=ps.getFloat(PROP_LANGUAGE_WEIGHT_ADJUSTMENT);
  dumpLattice=ps.getBoolean(PROP_DUMP_LATTICE);
  dumpSausage=ps.getBoolean(PROP_DUMP_SAUSAGE);
}",0.9563409563409564
19574,"public static URL resourceToURL(String location) throws MalformedURLException, ClassNotFoundException {
  Matcher jarMatcher=jarPattern.matcher(location);
  if (jarMatcher.matches()) {
    String resourceName=jarMatcher.group(1);
    return Object.class.getResource(resourceName);
  }
 else {
    if (location.indexOf(':') == -1) {
      location=""String_Node_Str"" + location;
    }
    return new URL(location);
  }
}","public static URL resourceToURL(String location) throws MalformedURLException, ClassNotFoundException {
  Matcher jarMatcher=jarPattern.matcher(location);
  if (jarMatcher.matches()) {
    String resourceName=jarMatcher.group(1);
    return ConfigurationManagerUtils.class.getResource(resourceName);
  }
 else {
    if (location.indexOf(':') == -1) {
      location=""String_Node_Str"" + location;
    }
    return new URL(location);
  }
}",0.9637426900584796
19575,"public static void run(String[] args) throws MalformedURLException {
  System.out.println(""String_Node_Str"");
  if (args.length < 1) {
    throw new Error(""String_Node_Str"");
  }
  String root=args[0];
  URL audioURL=(args.length > 1) ? new File(args[0]).toURI().toURL() : new URL(""String_Node_Str"" + root + ""String_Node_Str"");
  TranscriberConfiguration config=new TranscriberConfiguration(root);
  Recognizer recognizer=config.getRecognizer();
  recognizer.allocate();
  AudioFileDataSource audioSource=config.getAudioFileDataSource();
  audioSource.setAudioFile(audioURL,null);
  Result result;
  while ((result=recognizer.recognize()) != null) {
    String resultText=result.getBestResultNoFiller();
    System.out.println(resultText);
  }
}","public static void run(String[] args) throws MalformedURLException {
  System.out.println(""String_Node_Str"");
  if (args.length < 1) {
    throw new Error(""String_Node_Str"");
  }
  String root=args[0];
  URL audioURL=(args.length > 1) ? new File(args[1]).toURI().toURL() : new URL(""String_Node_Str"" + root + ""String_Node_Str"");
  TranscriberConfiguration config=new TranscriberConfiguration(root);
  Recognizer recognizer=config.getRecognizer();
  recognizer.allocate();
  AudioFileDataSource audioSource=config.getAudioFileDataSource();
  audioSource.setAudioFile(audioURL,null);
  Result result;
  while ((result=recognizer.recognize()) != null) {
    String resultText=result.getBestResultNoFiller();
    System.out.println(resultText);
  }
}",0.9986577181208054
19576,"/** 
 * Returns the next Data object, which is a normalized Data produced by this class. Signals are returned unmodified.
 * @return the next available Data object, returns null if no Data object is available
 * @throws DataProcessingException if there is a data processing error
 */
@Override public Data getData() throws DataProcessingException {
  Data input=getPredecessor().getData();
  if (input instanceof DataStartSignal)   sum=null;
  getTimer().start();
  if (input != null) {
    if (input instanceof DoubleData) {
      DoubleData data=(DoubleData)input;
      if (sum == null) {
        initMeansSums(data.getValues().length);
      }
      normalize(data);
    }
 else     if (input instanceof DataEndSignal) {
      updateMeanSumBuffers();
    }
  }
  getTimer().stop();
  return input;
}","/** 
 * Returns the next Data object, which is a normalized Data produced by this class. Signals are returned unmodified.
 * @return the next available Data object, returns null if no Data object is available
 * @throws DataProcessingException if there is a data processing error
 */
@Override public Data getData() throws DataProcessingException {
  Data input=getPredecessor().getData();
  if (input instanceof DataStartSignal) {
    sum=null;
    numberFrame=0;
  }
  getTimer().start();
  if (input != null) {
    if (input instanceof DoubleData) {
      DoubleData data=(DoubleData)input;
      if (sum == null) {
        initMeansSums(data.getValues().length);
      }
      normalize(data);
    }
 else     if (input instanceof DataEndSignal) {
      updateMeanSumBuffers();
    }
  }
  getTimer().stop();
  return input;
}",0.9834660134721372
19577,"/** 
 * Scores a a list of <code>Scoreable</code>s given a <code>Data</code>-object.
 * @param scoreableList The list of Scoreables to be scored
 * @param data          The <code>Data</code>-object to be used for scoring.
 * @return the best scoring <code>Scoreable</code> or <code>null</code> if the list of scoreables was empty.
 */
protected <T extends Scoreable>T doScoring(List<T> scoreableList,Data data){
  Iterator<T> i=scoreableList.iterator();
  T best=i.next();
  while (i.hasNext()) {
    T scoreable=i.next();
    if (scoreable.calculateScore(data) > best.getScore())     best=scoreable;
  }
  return best;
}","/** 
 * Scores a a list of <code>Scoreable</code>s given a <code>Data</code>-object.
 * @param scoreableList The list of Scoreables to be scored
 * @param data          The <code>Data</code>-object to be used for scoring.
 * @return the best scoring <code>Scoreable</code> or <code>null</code> if the list of scoreables was empty.
 */
protected <T extends Scoreable>T doScoring(List<T> scoreableList,Data data){
  Iterator<T> i=scoreableList.iterator();
  T best=i.next();
  best.calculateScore(data);
  while (i.hasNext()) {
    T scoreable=i.next();
    if (scoreable.calculateScore(data) > best.getScore())     best=scoreable;
  }
  return best;
}",0.977183320220299
19578,"/** 
 * Scores the given set of Tokens. All Tokens in the given list are assumed to belong to the same acoustic model.
 * @param scoreableList a list containing StateToken objects to be scored
 * @return the best scoring scorable, or null if there are no more frames to score
 */
public Data calculateScores(List<? extends Scoreable> scoreableList){
  frontEnd=getFrontEnd((List<ParallelToken>)scoreableList);
  return super.calculateScores(scoreableList);
}","/** 
 * Scores the given set of Tokens. All Tokens in the given list are assumed to belong to the same acoustic model.
 * @param scoreableList a list containing StateToken objects to be scored
 * @return the best scoring scorable, or null if there are no more frames to score
 */
public Data calculateScores(List<? extends Scoreable> scoreableList){
  frontEnd=getFrontEnd(scoreableList);
  return super.calculateScores(scoreableList);
}",0.976536312849162
19579,"/** 
 * Returns the acoustic model name of the Tokens in the given list .
 * @return the acoustic model name of the Tokens
 */
private FrontEnd getFrontEnd(List<ParallelToken> activeList){
  return activeList.isEmpty() ? null : activeList.get(0).getFeatureStream().getFrontEnd();
}","/** 
 * Returns the acoustic model name of the Tokens in the given list .
 * @return the acoustic model name of the Tokens
 */
private FrontEnd getFrontEnd(List<? extends Scoreable> activeList){
  Scoreable scoreable=activeList.isEmpty() ? null : activeList.get(0);
  if (scoreable == null || !(scoreable instanceof ParallelToken))   throw new RuntimeException(""String_Node_Str"");
  return ((ParallelToken)scoreable).getFeatureStream().getFrontEnd();
}",0.4993178717598908
19580,"/** 
 * Returns a the next <code>DataProcessor</code> of type <code>predecClass</code> which preceeds <code>dp</code>
 * @param dp
 * @param predecClass
 */
public static <T extends DataProcessor>T getFrontEndProcessor(DataProcessor dp,Class<T> predecClass){
  while (!predecClass.isInstance(dp)) {
    if (dp instanceof FrontEnd)     dp=((FrontEnd)dp).getLastDataProcessor();
 else     dp=dp.getPredecessor();
    if (dp == null)     return null;
  }
  return (T)dp;
}","/** 
 * Returns a the next <code>DataProcessor</code> of type <code>predecClass</code> which preceeds <code>dp</code>
 * @param dp
 * @param predecClass
 */
public static <T extends DataProcessor>T getFrontEndProcessor(DataProcessor dp,Class<T> predecClass){
  while (!predecClass.isInstance(dp)) {
    if (dp instanceof FrontEnd)     dp=((FrontEnd)dp).getLastDataProcessor();
 else     dp=dp.getPredecessor();
    if (dp == null)     return null;
  }
  return predecClass.cast(dp);
}",0.9737670514165792
19581,"@Override public void allocate() throws IOException {
  if (!allocated) {
    dictionary=new HashMap<String,Object>();
    Timer loadTimer=TimerPool.getTimer(this,""String_Node_Str"");
    fillerWords=new HashSet<String>();
    loadTimer.start();
    logger.info(""String_Node_Str"" + wordDictionaryFile);
    loadDictionary(wordDictionaryFile.openStream(),false);
    loadCustomDictionaries(addendaUrlList);
    logger.info(""String_Node_Str"" + fillerDictionaryFile);
    loadDictionary(fillerDictionaryFile.openStream(),true);
    loadTimer.stop();
  }
}","@Override public void allocate() throws IOException {
  if (!allocated) {
    dictionary=new HashMap<String,String>();
    Timer loadTimer=TimerPool.getTimer(this,""String_Node_Str"");
    fillerWords=new HashSet<String>();
    loadTimer.start();
    logger.info(""String_Node_Str"" + wordDictionaryFile);
    loadDictionary(wordDictionaryFile.openStream(),false);
    loadCustomDictionaries(addendaUrlList);
    logger.info(""String_Node_Str"" + fillerDictionaryFile);
    loadDictionary(fillerDictionaryFile.openStream(),true);
    loadTimer.stop();
  }
}",0.9891107078039928
19582,"/** 
 * Returns a string representation of this FastDictionary in alphabetical order.
 * @return a string representation of this FastDictionary
 */
@Override public String toString(){
  SortedMap<String,Object> sorted=new TreeMap<String,Object>(dictionary);
  StringBuilder result=new StringBuilder();
  for (  Map.Entry<String,Object> entry : sorted.entrySet()) {
    result.append(entry.getKey()).append('\n');
    for (    Pronunciation pronunciation : (List<Pronunciation>)entry.getValue()) {
      result.append(""String_Node_Str"").append(pronunciation).append('\n');
    }
  }
  return result.toString();
}","/** 
 * Returns a string representation of this FastDictionary in alphabetical order.
 * @return a string representation of this FastDictionary
 */
@Override public String toString(){
  SortedMap<String,String> sorted=new TreeMap<String,String>(dictionary);
  StringBuilder result=new StringBuilder();
  for (  Map.Entry<String,String> entry : sorted.entrySet()) {
    result.append(entry.getKey());
    result.append(""String_Node_Str"").append(entry.getValue()).append('\n');
  }
  return result.toString();
}",0.4214285714285714
19583,"/** 
 * Create a Word object with the given spelling and pronunciations, and insert it into the dictionary.
 * @param text          the spelling of the word
 * @param pronunciation the pronunciation of the word
 * @param isFiller      if <code>true</code> this is a filler word
 * @return the word
 */
private Word createWord(String text,Pronunciation[] pronunciation,boolean isFiller){
  Word word=new Word(text,pronunciation,isFiller);
  dictionary.put(text,word);
  return word;
}","/** 
 * Create a Word object with the given spelling and pronunciations, and insert it into the dictionary.
 * @param text          the spelling of the word
 * @param pronunciation the pronunciation of the word
 * @param isFiller      if <code>true</code> this is a filler word
 * @return the word
 */
private Word createWord(String text,Pronunciation[] pronunciation,boolean isFiller){
  Word word=new Word(text,pronunciation,isFiller);
  dictionary.put(text,word.toString());
  return word;
}",0.9887410440122824
19584,"private Rule convert(JSGFRule rule){
  if (rule instanceof JSGFRuleName) {
    JSGFRuleName ruleName=(JSGFRuleName)rule;
    return new RuleName(ruleName.getRuleName());
  }
  if (rule instanceof JSGFRuleAlternatives) {
    JSGFRuleAlternatives ruleAlternatives=(JSGFRuleAlternatives)rule;
    Rule[] subrules=new Rule[ruleAlternatives.getRules().size()];
    int i=0;
    for (    JSGFRule subrule : ruleAlternatives.getRules()) {
      subrules[i]=convert(subrule);
      i++;
    }
    float[] weights=null;
    if (ruleAlternatives.getWeights() != null) {
      weights=new float[ruleAlternatives.getWeights().size()];
      i=0;
      for (      Float f : ruleAlternatives.getWeights()) {
        weights[i]=f;
        i++;
      }
    }
    return new RuleAlternatives(subrules,weights);
  }
  if (rule instanceof JSGFRuleSequence) {
    JSGFRuleSequence ruleSequence=(JSGFRuleSequence)rule;
    Rule[] subrules=new Rule[ruleSequence.getRules().size()];
    int i=0;
    for (    JSGFRule subrule : ruleSequence.getRules()) {
      subrules[i]=convert(subrule);
      i++;
    }
    return new RuleSequence(subrules);
  }
  if (rule instanceof JSGFRuleCount) {
    JSGFRuleCount ruleCount=(JSGFRuleCount)rule;
    return new RuleCount(convert(ruleCount.getRule()),ruleCount.getCount());
  }
  if (rule instanceof JSGFRuleTag) {
    JSGFRuleTag ruleTag=(JSGFRuleTag)rule;
    return new RuleTag(convert(ruleTag.getRule()),ruleTag.getTag());
  }
  if (rule instanceof JSGFRuleToken) {
    JSGFRuleToken ruleToken=(JSGFRuleToken)rule;
    return new RuleToken(ruleToken.getText());
  }
  System.out.println(""String_Node_Str"" + rule.getClass());
  return null;
}","private Rule convert(JSGFRule rule){
  if (rule == null)   return null;
  if (rule instanceof JSGFRuleName) {
    if (rule == JSGFRuleName.NULL)     return RuleName.NULL;
    if (rule == JSGFRuleName.VOID)     return RuleName.NULL;
    JSGFRuleName ruleName=(JSGFRuleName)rule;
    return new RuleName(ruleName.getRuleName());
  }
  if (rule instanceof JSGFRuleAlternatives) {
    JSGFRuleAlternatives ruleAlternatives=(JSGFRuleAlternatives)rule;
    Rule[] subrules=new Rule[ruleAlternatives.getRules().size()];
    int i=0;
    for (    JSGFRule subrule : ruleAlternatives.getRules()) {
      subrules[i]=convert(subrule);
      i++;
    }
    float[] weights=null;
    if (ruleAlternatives.getWeights() != null) {
      weights=new float[ruleAlternatives.getWeights().size()];
      i=0;
      for (      Float f : ruleAlternatives.getWeights()) {
        weights[i]=f;
        i++;
      }
    }
    return new RuleAlternatives(subrules,weights);
  }
  if (rule instanceof JSGFRuleSequence) {
    JSGFRuleSequence ruleSequence=(JSGFRuleSequence)rule;
    Rule[] subrules=new Rule[ruleSequence.getRules().size()];
    int i=0;
    for (    JSGFRule subrule : ruleSequence.getRules()) {
      subrules[i]=convert(subrule);
      i++;
    }
    return new RuleSequence(subrules);
  }
  if (rule instanceof JSGFRuleCount) {
    JSGFRuleCount ruleCount=(JSGFRuleCount)rule;
    return new RuleCount(convert(ruleCount.getRule()),ruleCount.getCount());
  }
  if (rule instanceof JSGFRuleTag) {
    JSGFRuleTag ruleTag=(JSGFRuleTag)rule;
    return new RuleTag(convert(ruleTag.getRule()),ruleTag.getTag());
  }
  if (rule instanceof JSGFRuleToken) {
    JSGFRuleToken ruleToken=(JSGFRuleToken)rule;
    return new RuleToken(ruleToken.getText());
  }
  System.out.println(""String_Node_Str"" + rule.getClass());
  return null;
}",0.9549497847919656
19585,"@Override public void newProperties(PropertySheet ps) throws PropertyException {
  super.newProperties(ps);
  showFullPath=ps.getBoolean(PROP_SHOW_FULL_PATH);
}","@Override public void newProperties(PropertySheet ps) throws PropertyException {
  super.newProperties(ps);
  showFullPath=ps.getBoolean(PROP_SHOW_FULL_PATH);
  alignSausage=ps.getBoolean(ALIGN_SAUSAGE);
}",0.8767123287671232
19586,"@Override public void newResult(Result result){
  String ref=result.getReferenceText();
  if (result.isFinal() && ref != null) {
    String hyp=result.getBestResultNoFiller();
    getAligner().align(ref,hyp);
    showFullPath(result);
    showDetails(result.toString());
  }
}","@Override public void newResult(Result result){
  String ref=result.getReferenceText();
  if (result.isFinal() && ref != null) {
    if (!alignSausage) {
      String hyp=result.getBestResultNoFiller();
      getAligner().align(ref,hyp);
      showFullPath(result);
      showDetails(result.toString());
    }
 else {
      Lattice lattice=new Lattice(result);
      LatticeOptimizer optimizer=new LatticeOptimizer(lattice);
      optimizer.optimize();
      SausageMaker sausageMaker=new SausageMaker(lattice);
      Sausage sausage=sausageMaker.makeSausage();
      sausage.removeFillers();
      getAligner().alignSausage(ref,sausage);
      showFullPath(result);
      showDetails(result.toString());
    }
  }
}",0.5564516129032258
19587,"/** 
 * Validates checksum in the stream
 * @param dis input stream
 * @param doCheckSum validates
 * @throws IOException on error
 */
private void validateChecksum(DataInputStream dis,boolean doCheckSum) throws IOException {
  int oldCheckSum=(int)calculatedCheckSum;
  int checkSum=readInt(dis);
  if (doCheckSum && checkSum != oldCheckSum) {
    throw new IOException(""String_Node_Str"" + Long.toHexString(calculatedCheckSum) + ""String_Node_Str""+ Integer.toHexString(checkSum));
  }
}","/** 
 * Validates checksum in the stream
 * @param dis input stream
 * @param doCheckSum validates
 * @throws IOException on error
 */
private void validateChecksum(DataInputStream dis,boolean doCheckSum) throws IOException {
  if (!doCheckSum)   return;
  int oldCheckSum=(int)calculatedCheckSum;
  int checkSum=readInt(dis);
  if (checkSum != oldCheckSum) {
    throw new IOException(""String_Node_Str"" + Long.toHexString(calculatedCheckSum) + ""String_Node_Str""+ Integer.toHexString(checkSum));
  }
}",0.9564336372847012
19588,"/** 
 * Collects all of the entry and exit points for the vocabulary. 
 */
private void collectEntryAndExitUnits(){
  Collection<Word> words=getAllWords();
  for (  Word word : words) {
    for (int j=0; j < word.getPronunciations().length; j++) {
      Pronunciation p=word.getPronunciations()[j];
      System.out.println(""String_Node_Str"" + word + ""String_Node_Str""+ j+ ""String_Node_Str""+ p);
      Unit first=p.getUnits()[0];
      Unit last=p.getUnits()[p.getUnits().length - 1];
      entryPoints.add(first);
      exitPoints.add(last);
    }
  }
  if (debug) {
    System.out.println(""String_Node_Str"" + entryPoints.size());
    System.out.println(""String_Node_Str"" + exitPoints.size());
  }
}","/** 
 * Collects all of the entry and exit points for the vocabulary. 
 */
private void collectEntryAndExitUnits(){
  Collection<Word> words=getAllWords();
  for (  Word word : words) {
    for (int j=0; j < word.getPronunciations().length; j++) {
      Pronunciation p=word.getPronunciations()[j];
      Unit first=p.getUnits()[0];
      Unit last=p.getUnits()[p.getUnits().length - 1];
      entryPoints.add(first);
      exitPoints.add(last);
    }
  }
  if (debug) {
    System.out.println(""String_Node_Str"" + entryPoints.size());
    System.out.println(""String_Node_Str"" + exitPoints.size());
  }
}",0.9255564082885648
19589,"@Override public String toString(){
  StringBuilder b=new StringBuilder();
  for (  Map.Entry<Double,Set<WordResult>> entry : entrySet()) {
    b.append(entry.getKey()).append(':');
    for (    WordResult wordResult : entry.getValue())     b.append(wordResult).append(',');
    if (!entry.getValue().isEmpty())     b.setLength(b.length() - 1);
  }
  return b.toString();
}","@Override public String toString(){
  StringBuilder b=new StringBuilder();
  for (  Map.Entry<Double,Set<WordResult>> entry : entrySet()) {
    b.append(entry.getKey()).append(':');
    for (    WordResult wordResult : entry.getValue())     b.append(wordResult).append(',');
    if (!entry.getValue().isEmpty())     b.setLength(b.length() - 1);
    b.append(' ');
  }
  return b.toString();
}",0.9751633986928104
19590,"protected void initRecognizer(){
  this.scorer=new ThreadedAcousticScorer(frontend,null,10,true,0);
  this.pruner=new SimplePruner();
  this.activeListFactory=new PartitionActiveListFactory(absoluteBeamWidth,relativeBeamWidth,logMath);
  this.searchManager=new SimpleBreadthFirstSearchManager(logMath,linguist,pruner,scorer,activeListFactory,false,0.0,0,false);
  this.decoder=new Decoder(searchManager,false,false,new ArrayList<ResultListener>(),100000);
  this.recognizer=new Recognizer(decoder,monitors);
  this.monitors=new ArrayList<ResultListener>();
  this.monitors.add(new BestPathAccuracyTracker(recognizer,false,false,false,false,false,false));
  this.monitors.add(new MemoryTracker(recognizer,false,false));
  this.monitors.add(new SpeedTracker(recognizer,frontend,true,false,false,false));
}","protected void initRecognizer(){
  this.scorer=new ThreadedAcousticScorer(frontend,null,10,true,0);
  this.pruner=new SimplePruner();
  this.activeListFactory=new PartitionActiveListFactory(absoluteBeamWidth,relativeBeamWidth,logMath);
  this.searchManager=new SimpleBreadthFirstSearchManager(logMath,linguist,pruner,scorer,activeListFactory,false,0.0,0,false);
  this.decoder=new Decoder(searchManager,false,false,new ArrayList<ResultListener>(),100000);
  this.recognizer=new Recognizer(decoder,monitors);
  this.monitors=new ArrayList<Monitor>();
  this.monitors.add(new BestPathAccuracyTracker(recognizer,false,false,false,false,false,false));
  this.monitors.add(new MemoryTracker(recognizer,false,false));
  this.monitors.add(new SpeedTracker(recognizer,frontend,true,false,false,false));
}",0.9881175734834272
19591,"/** 
 * Resets the monitors monitoring this recognizer 
 */
public void resetMonitors(){
  for (  ResultListener listener : monitors) {
    if (listener instanceof Resetable)     ((Resetable)listener).reset();
  }
}","/** 
 * Resets the monitors monitoring this recognizer 
 */
public void resetMonitors(){
  for (  Monitor listener : monitors) {
    if (listener instanceof Resetable)     ((Resetable)listener).reset();
  }
}",0.9550827423167848
19592,"@Override public void newProperties(PropertySheet ps) throws PropertyException {
  decoder=(Decoder)ps.getComponent(PROP_DECODER);
  monitors=ps.getComponentList(PROP_MONITORS,ResultListener.class);
  name=ps.getInstanceName();
}","@Override public void newProperties(PropertySheet ps) throws PropertyException {
  decoder=(Decoder)ps.getComponent(PROP_DECODER);
  monitors=ps.getComponentList(PROP_MONITORS,Monitor.class);
  name=ps.getInstanceName();
}",0.9445676274944568
19593,"/** 
 * Creates a pool with a single identity matrix in it.
 * @name the name of the pool
 * @return the pool with the matrix
 */
private Pool<float[][]> createDummyMatrixPool(String name){
  Pool<float[][]> pool=new Pool<float[][]>(name);
  float[][] matrix=new float[vectorLength][vectorLength];
  logger.fine(""String_Node_Str"" + name);
  for (int i=0; i < vectorLength; i++) {
    for (int j=0; j < vectorLength; j++) {
      if (i == j) {
        matrix[i][j]=1.0F;
      }
 else {
        matrix[i][j]=0.0F;
      }
    }
  }
  pool.put(0,matrix);
  return pool;
}","/** 
 * Creates a pool with a single identity matrix in it.
 * @param name the name of the pool
 * @return the pool with the matrix
 */
private Pool<float[][]> createDummyMatrixPool(String name){
  Pool<float[][]> pool=new Pool<float[][]>(name);
  float[][] matrix=new float[vectorLength][vectorLength];
  logger.fine(""String_Node_Str"" + name);
  for (int i=0; i < vectorLength; i++) {
    for (int j=0; j < vectorLength; j++) {
      if (i == j) {
        matrix[i][j]=1.0F;
      }
 else {
        matrix[i][j]=0.0F;
      }
    }
  }
  pool.put(0,matrix);
  return pool;
}",0.9947552447552448
19594,"/** 
 * Loads the model file. A set of density arrays are created and placed in the given pool. if true, loads also the context dependent units the set of HTK models the path to a density file
 * @throws IOException if an error occurs while loading the data
 */
protected void loadHMMPool(boolean useCDUnits,HTKStruct htkmods,String path) throws IOException {
  int numStatePerHMM;
  if (!tie1ph) {
    for (Iterator<SingleHMM> monoPhones=htkmods.hmmsHTK.get1phIt(); monoPhones.hasNext(); ) {
      SingleHMM hmm=monoPhones.next();
      if (hmm == null)       break;
      String name=hmm.getName();
      String attribute;
      if (name.equals(""String_Node_Str"") || name.equals(""String_Node_Str"") || name.equals(""String_Node_Str"")|| name.equals(""String_Node_Str"")|| name.equals(""String_Node_Str""))       attribute=FILLER;
 else       attribute=""String_Node_Str"";
      int tmat=hmm.trIdx;
      numStatePerHMM=hmm.getNstates();
      int[] stid=new int[hmm.getNbEmittingStates()];
      int j=0;
      for (int ii=0; ii < numStatePerHMM; ii++) {
        if (hmm.isEmitting(ii)) {
          HMMState s=hmm.getState(ii);
          stid[j]=htkmods.hmmsHTK.getStateIdx(s);
          j++;
        }
      }
      Unit unit=unitManager.getUnit(name,attribute.equals(FILLER));
      contextIndependentUnits.put(unit.getName(),unit);
      if (logger.isLoggable(Level.FINE)) {
        logger.fine(""String_Node_Str"" + unit);
      }
      if (unit.isFiller() && unit.getName().equals(SILENCE_CIPHONE)) {
        unit=UnitManager.SILENCE;
      }
      float[][] transitionMatrix=matrixPool.get(tmat);
      SenoneSequence ss=getSenoneSequence(stid);
      HMM hmm2=new SenoneHMM(unit,ss,transitionMatrix,HMMPosition.lookup(""String_Node_Str""));
      hmmManager.put(hmm2);
    }
  }
 else {
    for (int i=0; i < htkmods.hmmsHTK.getNhmms(); i++) {
      SingleHMM hmm=htkmods.hmmsHTK.getHMM(i);
      if (hmm == null)       break;
      String name=hmm.getBaseName();
      if (!contextIndependentUnits.containsKey(name)) {
        String attribute;
        if (name.equals(""String_Node_Str"") || name.equals(""String_Node_Str"") || name.equals(""String_Node_Str"")|| name.equals(""String_Node_Str"")|| name.equals(""String_Node_Str""))         attribute=FILLER;
 else         attribute=""String_Node_Str"";
        int tmat=hmm.trIdx;
        numStatePerHMM=hmm.getNstates();
        int[] stid=new int[hmm.getNbEmittingStates()];
        int j=0;
        for (int ii=0; ii < numStatePerHMM; ii++) {
          if (hmm.isEmitting(ii)) {
            HMMState s=hmm.getState(ii);
            stid[j]=htkmods.hmmsHTK.getStateIdx(s);
            j++;
          }
        }
        Unit unit=unitManager.getUnit(name,attribute.equals(FILLER));
        contextIndependentUnits.put(unit.getName(),unit);
        if (logger.isLoggable(Level.FINE)) {
          logger.fine(""String_Node_Str"" + unit);
        }
        if (unit.isFiller() && unit.getName().equals(SILENCE_CIPHONE)) {
          unit=UnitManager.SILENCE;
        }
        float[][] transitionMatrix=matrixPool.get(tmat);
        SenoneSequence ss=getSenoneSequence(stid);
        HMM hmm2=new SenoneHMM(unit,ss,transitionMatrix,HMMPosition.lookup(""String_Node_Str""));
        hmmManager.put(hmm2);
      }
    }
  }
  String lastUnitName=""String_Node_Str"";
  Unit lastUnit=null;
  int[] lastStid=null;
  SenoneSequence lastSenoneSequence=null;
  List<String> HMMdejavu=new ArrayList<String>();
  for (Iterator<SingleHMM> triPhones=htkmods.hmmsHTK.get3phIt(); triPhones.hasNext(); ) {
    SingleHMM hmm=triPhones.next();
    if (hmm == null)     break;
    String name=hmm.getBaseName();
    String left=hmm.getLeft();
    String right=hmm.getRight();
{
      if (left.equals(""String_Node_Str""))       left=""String_Node_Str"";
      if (right.equals(""String_Node_Str""))       right=""String_Node_Str"";
      String s=left + ' ' + name+ ' '+ right;
      if (HMMdejavu.contains(s)) {
        continue;
      }
      HMMdejavu.add(s);
    }
    String position=""String_Node_Str"";
    int tmat=hmm.trIdx;
    numStatePerHMM=hmm.getNstates();
    int[] stid=new int[hmm.getNbEmittingStates()];
    int j=0;
    for (int ii=0; ii < numStatePerHMM; ii++) {
      if (hmm.isEmitting(ii)) {
        HMMState s=hmm.getState(ii);
        stid[j]=htkmods.hmmsHTK.getStateIdx(s);
        j++;
      }
    }
    if (useCDUnits) {
      Unit unit;
      String unitName=(name + ' ' + left+ ' '+ right);
      if (unitName.equals(lastUnitName)) {
        unit=lastUnit;
      }
 else {
        Unit[] leftContext=new Unit[1];
        leftContext[0]=contextIndependentUnits.get(left);
        Unit[] rightContext=new Unit[1];
        rightContext[0]=contextIndependentUnits.get(right);
        Context context=LeftRightContext.get(leftContext,rightContext);
        unit=unitManager.getUnit(name,false,context);
      }
      lastUnitName=unitName;
      lastUnit=unit;
      if (logger.isLoggable(Level.FINE)) {
        logger.fine(""String_Node_Str"" + unit);
      }
      float[][] transitionMatrix=matrixPool.get(tmat);
      SenoneSequence ss=lastSenoneSequence;
      if (ss == null || !sameSenoneSequence(stid,lastStid)) {
        ss=getSenoneSequence(stid);
      }
      lastSenoneSequence=ss;
      lastStid=stid;
      HMM hmm2=new SenoneHMM(unit,ss,transitionMatrix,HMMPosition.lookup(position));
      hmmManager.put(hmm2);
    }
  }
}","/** 
 * Loads the model file. A set of density arrays are created and placed in the given pool.
 * @param useCDUnits if true, loads also the context dependent units
 * @param htkModels the set of HTK models
 * @param path the path to a density file
 * @throws IOException if an error occurs while loading the data
 */
protected void loadHMMPool(boolean useCDUnits,HTKStruct htkModels,String path) throws IOException {
  int numStatePerHMM;
  if (!tie1ph) {
    for (Iterator<SingleHMM> monoPhones=htkModels.hmmsHTK.get1phIt(); monoPhones.hasNext(); ) {
      SingleHMM hmm=monoPhones.next();
      if (hmm == null)       break;
      String name=hmm.getName();
      String attribute;
      if (name.equals(""String_Node_Str"") || name.equals(""String_Node_Str"") || name.equals(""String_Node_Str"")|| name.equals(""String_Node_Str"")|| name.equals(""String_Node_Str""))       attribute=FILLER;
 else       attribute=""String_Node_Str"";
      int tmat=hmm.trIdx;
      numStatePerHMM=hmm.getNstates();
      int[] stid=new int[hmm.getNbEmittingStates()];
      int j=0;
      for (int ii=0; ii < numStatePerHMM; ii++) {
        if (hmm.isEmitting(ii)) {
          HMMState s=hmm.getState(ii);
          stid[j]=htkModels.hmmsHTK.getStateIdx(s);
          j++;
        }
      }
      Unit unit=unitManager.getUnit(name,attribute.equals(FILLER));
      contextIndependentUnits.put(unit.getName(),unit);
      if (logger.isLoggable(Level.FINE)) {
        logger.fine(""String_Node_Str"" + unit);
      }
      if (unit.isFiller() && unit.getName().equals(SILENCE_CIPHONE)) {
        unit=UnitManager.SILENCE;
      }
      float[][] transitionMatrix=matrixPool.get(tmat);
      SenoneSequence ss=getSenoneSequence(stid);
      HMM hmm2=new SenoneHMM(unit,ss,transitionMatrix,HMMPosition.lookup(""String_Node_Str""));
      hmmManager.put(hmm2);
    }
  }
 else {
    for (int i=0; i < htkModels.hmmsHTK.getNhmms(); i++) {
      SingleHMM hmm=htkModels.hmmsHTK.getHMM(i);
      if (hmm == null)       break;
      String name=hmm.getBaseName();
      if (!contextIndependentUnits.containsKey(name)) {
        String attribute;
        if (name.equals(""String_Node_Str"") || name.equals(""String_Node_Str"") || name.equals(""String_Node_Str"")|| name.equals(""String_Node_Str"")|| name.equals(""String_Node_Str""))         attribute=FILLER;
 else         attribute=""String_Node_Str"";
        int tmat=hmm.trIdx;
        numStatePerHMM=hmm.getNstates();
        int[] stid=new int[hmm.getNbEmittingStates()];
        int j=0;
        for (int ii=0; ii < numStatePerHMM; ii++) {
          if (hmm.isEmitting(ii)) {
            HMMState s=hmm.getState(ii);
            stid[j]=htkModels.hmmsHTK.getStateIdx(s);
            j++;
          }
        }
        Unit unit=unitManager.getUnit(name,attribute.equals(FILLER));
        contextIndependentUnits.put(unit.getName(),unit);
        if (logger.isLoggable(Level.FINE)) {
          logger.fine(""String_Node_Str"" + unit);
        }
        if (unit.isFiller() && unit.getName().equals(SILENCE_CIPHONE)) {
          unit=UnitManager.SILENCE;
        }
        float[][] transitionMatrix=matrixPool.get(tmat);
        SenoneSequence ss=getSenoneSequence(stid);
        HMM hmm2=new SenoneHMM(unit,ss,transitionMatrix,HMMPosition.lookup(""String_Node_Str""));
        hmmManager.put(hmm2);
      }
    }
  }
  String lastUnitName=""String_Node_Str"";
  Unit lastUnit=null;
  int[] lastStid=null;
  SenoneSequence lastSenoneSequence=null;
  List<String> HMMdejavu=new ArrayList<String>();
  for (Iterator<SingleHMM> triPhones=htkModels.hmmsHTK.get3phIt(); triPhones.hasNext(); ) {
    SingleHMM hmm=triPhones.next();
    if (hmm == null)     break;
    String name=hmm.getBaseName();
    String left=hmm.getLeft();
    String right=hmm.getRight();
{
      if (left.equals(""String_Node_Str""))       left=""String_Node_Str"";
      if (right.equals(""String_Node_Str""))       right=""String_Node_Str"";
      String s=left + ' ' + name+ ' '+ right;
      if (HMMdejavu.contains(s)) {
        continue;
      }
      HMMdejavu.add(s);
    }
    String position=""String_Node_Str"";
    int tmat=hmm.trIdx;
    numStatePerHMM=hmm.getNstates();
    int[] stid=new int[hmm.getNbEmittingStates()];
    int j=0;
    for (int ii=0; ii < numStatePerHMM; ii++) {
      if (hmm.isEmitting(ii)) {
        HMMState s=hmm.getState(ii);
        stid[j]=htkModels.hmmsHTK.getStateIdx(s);
        j++;
      }
    }
    if (useCDUnits) {
      Unit unit;
      String unitName=(name + ' ' + left+ ' '+ right);
      if (unitName.equals(lastUnitName)) {
        unit=lastUnit;
      }
 else {
        Unit[] leftContext=new Unit[1];
        leftContext[0]=contextIndependentUnits.get(left);
        Unit[] rightContext=new Unit[1];
        rightContext[0]=contextIndependentUnits.get(right);
        Context context=LeftRightContext.get(leftContext,rightContext);
        unit=unitManager.getUnit(name,false,context);
      }
      lastUnitName=unitName;
      lastUnit=unit;
      if (logger.isLoggable(Level.FINE)) {
        logger.fine(""String_Node_Str"" + unit);
      }
      float[][] transitionMatrix=matrixPool.get(tmat);
      SenoneSequence ss=lastSenoneSequence;
      if (ss == null || !sameSenoneSequence(stid,lastStid)) {
        ss=getSenoneSequence(stid);
      }
      lastSenoneSequence=ss;
      lastStid=stid;
      HMM hmm2=new SenoneHMM(unit,ss,transitionMatrix,HMMPosition.lookup(position));
      hmmManager.put(hmm2);
    }
  }
}",0.9888930025916328
19595,"/** 
 * Read a float from the input stream, byte-swapping as necessary. the input stream
 * @return a floating pint value
 * @throws IOException on error
 */
protected float readFloat(DataInputStream dis) throws IOException {
  float val;
  if (swap) {
    val=Utilities.readLittleEndianFloat(dis);
  }
 else {
    val=dis.readFloat();
  }
  return val;
}","/** 
 * Read a float from the input stream, byte-swapping as necessary. the input stream
 * @param dis the input stream
 * @return a floating value
 * @throws IOException on error
 */
protected float readFloat(DataInputStream dis) throws IOException {
  float val;
  if (swap) {
    val=Utilities.readLittleEndianFloat(dis);
  }
 else {
    val=dis.readFloat();
  }
  return val;
}",0.9510869565217392
19596,"/** 
 * Read an integer from the input stream, byte-swapping as necessary. the inputstream
 * @return an integer value
 * @throws IOException on error
 */
protected int readInt(DataInputStream dis) throws IOException {
  if (swap) {
    return Utilities.readLittleEndianInt(dis);
  }
 else {
    return dis.readInt();
  }
}","/** 
 * Read an integer from the input stream, byte-swapping as necessary.
 * @param dis the input stream
 * @return an integer value
 * @throws IOException on error
 */
protected int readInt(DataInputStream dis) throws IOException {
  if (swap) {
    return Utilities.readLittleEndianInt(dis);
  }
 else {
    return dis.readInt();
  }
}",0.9773071104387292
19597,"/** 
 * Gets the senone sequence representing the given senones.
 * @stateid is the array of senone state ids
 * @return the senone sequence associated with the states
 */
protected SenoneSequence getSenoneSequence(int[] stateid){
  Senone[] senones=new Senone[stateid.length];
  for (int i=0; i < stateid.length; i++) {
    senones[i]=senonePool.get(stateid[i]);
  }
  return new SenoneSequence(senones);
}","/** 
 * Gets the senone sequence representing the given senones.
 * @param stateId is the array of senone state ids
 * @return the senone sequence associated with the states
 */
protected SenoneSequence getSenoneSequence(int[] stateId){
  Senone[] senones=new Senone[stateId.length];
  for (int i=0; i < stateId.length; i++) {
    senones[i]=senonePool.get(stateId[i]);
  }
  return new SenoneSequence(senones);
}",0.9682926829268292
19598,"/** 
 * Creates the senone pool from the rest of the pools. assumes the means and variances are in the same order
 * @distFloor the lowest allowed score
 * @varianceFloor the lowest allowed variance
 * @return the senone pool
 */
private Pool<Senone> createSenonePool(float distFloor,float varianceFloor){
}","/** 
 * Creates the senone pool from the rest of the pools. assumes the means and variances are in the same order
 * @param distFloor the lowest allowed score
 * @param varianceFloor the lowest allowed variance
 * @return the senone pool
 */
private Pool<Senone> createSenonePool(float distFloor,float varianceFloor){
}",0.9808306709265175
19599,"/** 
 * Reads the given number of floats from the stream and returns them in an array of floats. the stream to read data from the number of floats to read
 * @return an array of size float elements
 * @throws IOException if an exception occurs
 */
protected float[] readFloatArray(DataInputStream dis,int size) throws IOException {
  float[] data=new float[size];
  for (int i=0; i < size; i++) {
    data[i]=readFloat(dis);
  }
  return data;
}","/** 
 * Reads the given number of floats from the stream and returns them in an array of floats.
 * @param dis the stream to read data from the number of floats to read
 * @param size size of the array
 * @return an array of size float elements
 * @throws IOException if an exception occurs
 */
protected float[] readFloatArray(DataInputStream dis,int size) throws IOException {
  float[] data=new float[size];
  for (int i=0; i < size; i++) {
    data[i]=readFloat(dis);
  }
  return data;
}",0.9498399146211312
19600,"/** 
 * Creates a pool with a single zero vector in it. the name of the pool
 * @return the pool with the vector
 */
private Pool<float[]> createDummyVectorPool(String name){
  logger.fine(""String_Node_Str"" + name);
  Pool<float[]> pool=new Pool<float[]>(name);
  float[] vector=new float[vectorLength];
  for (int i=0; i < vectorLength; i++) {
    vector[i]=0.0f;
  }
  pool.put(0,vector);
  return pool;
}","/** 
 * Creates a pool with a single zero vector in it.
 * @param name the name of the pool
 * @return the pool with the vector
 */
private Pool<float[]> createDummyVectorPool(String name){
  logger.fine(""String_Node_Str"" + name);
  Pool<float[]> pool=new Pool<float[]>(name);
  float[] vector=new float[vectorLength];
  for (int i=0; i < vectorLength; i++) {
    vector[i]=0.0f;
  }
  pool.put(0,vector);
  return pool;
}",0.9819059107358264
19601,"/** 
 * Loads the AcousticModel from an HTK MMF the name of the acoustic model; if null we just load from the default location
 * @throws java.io.IOException
 */
private void loadModelFiles(String MMFname) throws IOException {
  logger.config(""String_Node_Str"" + MMFname);
  logger.config(""String_Node_Str"" + location);
  logger.config(""String_Node_Str"" + model);
  logger.config(""String_Node_Str"" + dataDir);
  HTKStruct htkmods=new HTKStruct();
  htkmods.load(MMFname);
  meansPool=htkmods.htkMeans(MMFname);
  variancePool=htkmods.htkVars(MMFname,varianceFloor);
  mixtureWeightsPool=htkmods.htkWeights(MMFname,mixtureWeightFloor);
  matrixPool=htkmods.htkTrans(MMFname);
  senonePool=createSenonePool(distFloor,varianceFloor);
  loadHMMPool(useCDUnits,htkmods,location + File.separator + model);
}","/** 
 * Loads the AcousticModel from an HTK MMF
 * @param MMFname the name of the acoustic model; if null we just load from the defaultlocation
 * @throws java.io.IOException
 */
private void loadModelFiles(String MMFname) throws IOException {
  logger.config(""String_Node_Str"" + MMFname);
  logger.config(""String_Node_Str"" + location);
  logger.config(""String_Node_Str"" + model);
  logger.config(""String_Node_Str"" + dataDir);
  HTKStruct htkmods=new HTKStruct();
  htkmods.load(MMFname);
  meansPool=htkmods.htkMeans(MMFname);
  variancePool=htkmods.htkVars(MMFname,varianceFloor);
  mixtureWeightsPool=htkmods.htkWeights(MMFname,mixtureWeightFloor);
  matrixPool=htkmods.htkTrans(MMFname);
  senonePool=createSenonePool(distFloor,varianceFloor);
  loadHMMPool(useCDUnits,htkmods,location + File.separator + model);
}",0.9882643607164916
19602,"/** 
 * Validates checksum in the stream
 * @dis input stream
 * @doChecksum validates
 * @throws IOException on error
 */
private void validateChecksum(DataInputStream dis,boolean doCheckSum) throws IOException {
  int oldCheckSum=(int)calculatedCheckSum;
  int checkSum=readInt(dis);
  if (doCheckSum && checkSum != oldCheckSum) {
    throw new IOException(""String_Node_Str"" + Long.toHexString(calculatedCheckSum) + ""String_Node_Str""+ Integer.toHexString(checkSum));
  }
}","/** 
 * Validates checksum in the stream
 * @param dis input stream
 * @param doCheckSum validates
 * @throws IOException on error
 */
private void validateChecksum(DataInputStream dis,boolean doCheckSum) throws IOException {
  int oldCheckSum=(int)calculatedCheckSum;
  int checkSum=readInt(dis);
  if (doCheckSum && checkSum != oldCheckSum) {
    throw new IOException(""String_Node_Str"" + Long.toHexString(calculatedCheckSum) + ""String_Node_Str""+ Integer.toHexString(checkSum));
  }
}",0.9708333333333332
19603,"/** 
 * Normalize the given data.
 * @data the data to normalize
 */
public static void normalize(float[] data){
  float sum=0;
  for (  float val : data) {
    sum+=val;
  }
  if (sum != 0.0f) {
    for (int i=0; i < data.length; i++) {
      data[i]=data[i] / sum;
    }
  }
}","/** 
 * Normalize the given data.
 * @param data the data to normalize
 */
public static void normalize(float[] data){
  float sum=0;
  for (  float val : data) {
    sum+=val;
  }
  if (sum != 0.0f) {
    for (int i=0; i < data.length; i++) {
      data[i]=data[i] / sum;
    }
  }
}",0.98932384341637
19604,"/** 
 * Creates a branch state
 * @param nodeID the grammar node id
 */
public BranchState(String leftContext,String rightContext,int nodeID){
  super('B' + '[' + leftContext+ ','+ rightContext+ ']',null,nodeID);
}","/** 
 * Creates a branch state
 * @param nodeID the grammar node id
 */
public BranchState(String leftContext,String rightContext,int nodeID){
  super(""String_Node_Str"" + leftContext + ""String_Node_Str""+ rightContext+ ""String_Node_Str"",null,nodeID);
}",0.7784946236559139
19605,"/** 
 * extract @xxxx keywords from documention comments
 */
static void extractKeywords(BaseRuleGrammar grammar,String rname,String comment){
  String sample;
  int i=comment.indexOf(""String_Node_Str"");
  while (i > 0) {
    int j=comment.indexOf('\u005cn',i);
    if (j < 0) {
      sample=comment.substring(i + 8);
      i=-1;
    }
 else {
      sample=comment.substring(i + 8,j);
      i=j;
    }
    i=comment.indexOf(""String_Node_Str"",i);
    grammar.addSampleSentence(rname,sample);
  }
}","/** 
 * extract @xxxx keywords from documention comments
 */
static void extractKeywords(BaseRuleGrammar grammar,String rname,String comment){
  int i=0;
  while ((i=comment.indexOf(""String_Node_Str"",i) + 9) > 9) {
    int j=Math.max(comment.indexOf('\u005cr',i),comment.indexOf('\u005cn',i));
    if (j < 0) {
      j=comment.length();
      if (comment.endsWith((""String_Node_Str"")))       j-=2;
    }
    grammar.addSampleSentence(rname,comment.substring(i,j).trim());
    i=j + 1;
  }
}",0.5476673427991886
19606,"/** 
 * Returns the sample rate of the data.
 * @return the sample rate of the data
 */
public int getSampleRate(){
  return sampleRate;
}","/** 
 * @return the sample rate of the data.
 */
public int getSampleRate(){
  return sampleRate;
}",0.8270042194092827
19607,"/** 
 * Returns the position of the first sample in the original data. The very first sample number is zero.
 * @return the position of the first sample in the original data
 */
public long getFirstSampleNumber(){
  return firstSampleNumber;
}","/** 
 * @return the position of the first sample in the original data. The very first sample numberis zero.
 */
public long getFirstSampleNumber(){
  return firstSampleNumber;
}",0.8333333333333334
19608,"/** 
 * Returns a string that describes this DoubleData.
 * @return a string that describes this DoubleData
 */
public String toString(){
  return (""String_Node_Str"" + sampleRate + ""String_Node_Str""+ firstSampleNumber+ ""String_Node_Str""+ collectTime);
}","/** 
 * @return a string that describes the data.
 */
public String toString(){
  return (""String_Node_Str"" + sampleRate + ""String_Node_Str""+ firstSampleNumber+ ""String_Node_Str""+ collectTime);
}",0.8571428571428571
19609,"/** 
 * Returns the values of this DoubleData object.
 * @return the values
 */
public float[] getValues(){
  return values;
}","/** 
 * @return the values of this data.
 */
public float[] getValues(){
  return values;
}",0.7096774193548387
19610,"/** 
 * Returns the sample rate of this data.
 * @return the sample rate of this data
 */
public int getSampleRate(){
  return sampleRate;
}","/** 
 * @return the sample rate of this data.
 */
public int getSampleRate(){
  return sampleRate;
}",0.825
19611,"/** 
 * Returns the position of the first sample in the original data. The very first sample number is zero.
 * @return the position of the first sample in the original data
 */
public long getFirstSampleNumber(){
  return firstSampleNumber;
}","/** 
 * @return the position of the first sample in the original data. The very first sample number is zero.
 */
public long getFirstSampleNumber(){
  return firstSampleNumber;
}",0.836104513064133
19612,"/** 
 * Registers a new listener for <code>Result</code>. 
 */
void addResultListener(ResultListener resultListener);","/** 
 * Registers a new listener for <code>Result</code>.
 * @param resultListener
 */
void addResultListener(ResultListener resultListener);",0.9069767441860463
19613,"/** 
 * Removes a listener from this <code>ResultProducer</code>-instance. 
 */
void removeResultListener(ResultListener resultListener);","/** 
 * Removes a listener from this <code>ResultProducer</code>-instance.
 * @param resultListener
 */
void removeResultListener(ResultListener resultListener);",0.9194630872483222
19614,"/** 
 * Handles the first element in a feature-stream. 
 */
protected void handleDataStartSignal(DataStartSignal dataStartSignal){
  Map<String,Object> dataProps=dataStartSignal.getProps();
  if (dataProps.containsKey(DataStartSignal.SPEECH_TAGGED_FEATURE_STREAM))   useSpeechSignals=(Boolean)dataProps.get(DataStartSignal.SPEECH_TAGGED_FEATURE_STREAM);
 else   useSpeechSignals=false;
}","/** 
 * Handles the first element in a feature-stream.
 * @param dataStartSignal
 */
protected void handleDataStartSignal(DataStartSignal dataStartSignal){
  Map<String,Object> dataProps=dataStartSignal.getProps();
  if (dataProps.containsKey(DataStartSignal.SPEECH_TAGGED_FEATURE_STREAM))   useSpeechSignals=(Boolean)dataProps.get(DataStartSignal.SPEECH_TAGGED_FEATURE_STREAM);
 else   useSpeechSignals=false;
}",0.9662077596996246
19615,"/** 
 * Handles the last element in a feature-stream. 
 */
protected void handleDataEndSignal(DataEndSignal dataEndSignal){
}","/** 
 * Handles the last element in a feature-stream.
 * @param dataEndSignal
 */
protected void handleDataEndSignal(DataEndSignal dataEndSignal){
}",0.9157509157509156
19616,"/** 
 * Normalizes a previously calculated score
 * @return the normalized score
 */
public float normalizeScore(float maxScore);","/** 
 * Normalizes a previously calculated score
 * @param maxScore
 * @return the normalized score
 */
public float normalizeScore(float maxScore);",0.9314079422382672
19617,"/** 
 * Creates an empty active list 
 */
public PartitionActiveList(int absoluteBeamWidth,float logRelativeBeamWidth){
  this.absoluteBeamWidth=absoluteBeamWidth;
  this.logRelativeBeamWidth=logRelativeBeamWidth;
  int listSize=2000;
  if (absoluteBeamWidth > 0) {
    listSize=absoluteBeamWidth / 3;
  }
  this.tokenList=new Token[listSize];
}","/** 
 * Creates an empty active list
 * @param absoluteBeamWidth
 * @param logRelativeBeamWidth
 */
public PartitionActiveList(int absoluteBeamWidth,float logRelativeBeamWidth){
  this.absoluteBeamWidth=absoluteBeamWidth;
  this.logRelativeBeamWidth=logRelativeBeamWidth;
  int listSize=2000;
  if (absoluteBeamWidth > 0) {
    listSize=absoluteBeamWidth / 3;
  }
  this.tokenList=new Token[listSize];
}",0.9197860962566844
19618,"/** 
 * Because the growBranches() is called although no data is left after the last speech frame, the ordering of the active-list might depend on the transition-probs and (penalty-scores) only. Therefore we need to undo the last grow-step up to final states or the last emitting state in order to fix the list..
 */
private ActiveList undoLastGrowStep(){
  ActiveList fixedList=activeList.newInstance();
  for (  Token token : activeList.getTokens()) {
    Token curToken=token.getPredecessor();
    while (curToken.getPredecessor() != null && ((curToken.isFinal() && curToken.getPredecessor() != null && !curToken.getPredecessor().isFinal()) || (curToken.isEmitting() && curToken.getData() == null) || (!curToken.isFinal() && !curToken.isEmitting()))) {
      curToken=curToken.getPredecessor();
    }
    fixedList.add(curToken);
  }
  return fixedList;
}","/** 
 * Because the growBranches() is called although no data is left after the last speech frame, the ordering of the active-list might depend on the transition-probs and (penalty-scores) only. Therefore we need to undo the last grow-step up to final states or the last emitting state in order to fix the list..
 * @return
 */
private ActiveList undoLastGrowStep(){
  ActiveList fixedList=activeList.newInstance();
  for (  Token token : activeList.getTokens()) {
    Token curToken=token.getPredecessor();
    while (curToken.getPredecessor() != null && ((curToken.isFinal() && curToken.getPredecessor() != null && !curToken.getPredecessor().isFinal()) || (curToken.isEmitting() && curToken.getData() == null) || (!curToken.isFinal() && !curToken.isEmitting()))) {
      curToken=curToken.getPredecessor();
    }
    fixedList.add(curToken);
  }
  return fixedList;
}",0.9936305732484076
19619,"/** 
 * Creates an empty active list 
 */
public SortingActiveList(int absoluteBeamWidth,float logRelativeBeamWidth){
  this.absoluteBeamWidth=absoluteBeamWidth;
  this.logRelativeBeamWidth=logRelativeBeamWidth;
  int initListSize=absoluteBeamWidth > 0 ? absoluteBeamWidth : DEFAULT_SIZE;
  this.tokenList=new ArrayList<Token>(initListSize);
}","/** 
 * Creates an empty active list
 * @param absoluteBeamWidth
 * @param logRelativeBeamWidth
 */
public SortingActiveList(int absoluteBeamWidth,float logRelativeBeamWidth){
  this.absoluteBeamWidth=absoluteBeamWidth;
  this.logRelativeBeamWidth=logRelativeBeamWidth;
  int initListSize=absoluteBeamWidth > 0 ? absoluteBeamWidth : DEFAULT_SIZE;
  this.tokenList=new ArrayList<Token>(initListSize);
}",0.9193548387096774
19620,"/** 
 * Returns the acoustic score for this token (in logMath log base) 
 */
public float getAcousticScore(){
  return logAcousticScore;
}","/** 
 * Returns the acoustic score for this token (in logMath log base)
 * @return
 */
public float getAcousticScore(){
  return logAcousticScore;
}",0.965034965034965
19621,"/** 
 * Sets the feature for this Token. 
 */
public void setData(Data data){
  myData=data;
}","/** 
 * Sets the feature for this Token.
 * @param data
 */
public void setData(Data data){
  myData=data;
}",0.9306930693069309
19622,"/** 
 * Constructs a new token that continues the search from the current token. If predessorClasses is null or if the class of the state is a member of predecessorClasses, the predecessor of the new token is set to the current token.  Otherwise it is set to the predecessor of the current token.  This behavior is used to save memory when building lattices.
 * @param state                   the SentenceHMMState associated with this token
 * @param logTotalScore           the total entry score for this token (in LogMath log base)
 * @param logLanguageScore        the language score associated with this token (in LogMath log base)
 * @param logInsertionProbability the insertion probabilty  associated with this token (in LogMath log base)
 * @param frameNumber             the frame number associated with this token
 */
public Token child(SearchState state,float logTotalScore,float logLanguageScore,float logInsertionProbability,int frameNumber){
  if ((predecessorClasses == null) || predecessorClasses.contains(state.getClass())) {
    return new Token(this,state,logTotalScore,logLanguageScore,logInsertionProbability,frameNumber);
  }
 else {
    return new Token(predecessor,state,logTotalScore,logLanguageScore,logInsertionProbability,frameNumber);
  }
}","/** 
 * Constructs a new token that continues the search from the current token. If predessorClasses is null or if the class of the state is a member of predecessorClasses, the predecessor of the new token is set to the current token.  Otherwise it is set to the predecessor of the current token.  This behavior is used to save memory when building lattices.
 * @param state                   the SentenceHMMState associated with this token
 * @param logTotalScore           the total entry score for this token (in LogMath log base)
 * @param logLanguageScore        the language score associated with this token (in LogMath log base)
 * @param logInsertionProbability the insertion probabilty  associated with this token (in LogMath log base)
 * @param frameNumber             the frame number associated with this token
 * @return
 */
public Token child(SearchState state,float logTotalScore,float logLanguageScore,float logInsertionProbability,int frameNumber){
  if ((predecessorClasses == null) || predecessorClasses.contains(state.getClass())) {
    return new Token(this,state,logTotalScore,logLanguageScore,logInsertionProbability,frameNumber);
  }
 else {
    return new Token(predecessor,state,logTotalScore,logLanguageScore,logInsertionProbability,frameNumber);
  }
}",0.9956811935610522
19623,"/** 
 * Adds the given Token to this TokenStack.
 * @return the replaced Token, or null if no Token was replaced
 */
public Token add(Token token);","/** 
 * Adds the given Token to this TokenStack.
 * @param token
 * @return the replaced Token, or null if no Token was replaced
 */
public Token add(Token token);",0.9483870967741936
19624,"/** 
 * Returns true if the given score is higher than the lowest scoring token in this TokenStack.
 * @param score the score the check
 * @return true if the given score is higher than the lowest scoring token, false otherwise
 */
public boolean isInsertable(float score,int frameNumber);","/** 
 * Returns true if the given score is higher than the lowest scoring token in this TokenStack.
 * @param score the score the check
 * @param frameNumber
 * @return true if the given score is higher than the lowest scoring token, false otherwise
 */
public boolean isInsertable(float score,int frameNumber);",0.9633333333333334
19625,"/** 
 * Checks that the given two states are in legitimate order. 
 */
private void checkStateOrder(SearchState fromState,SearchState toState){
  if (fromState.getOrder() == numStateOrder - 1) {
    return;
  }
  if (fromState.getOrder() > toState.getOrder()) {
    throw new Error(""String_Node_Str"" + fromState.getClass().getName() + ' '+ fromState.toPrettyString()+ ""String_Node_Str""+ fromState.getOrder()+ ""String_Node_Str""+ toState.getClass().getName()+ ' '+ toState.toPrettyString()+ ""String_Node_Str""+ toState.getOrder());
  }
}","/** 
 * Checks that the given two states are in legitimate order.
 * @param fromState
 * @param toState
 */
private void checkStateOrder(SearchState fromState,SearchState toState){
  if (fromState.getOrder() == numStateOrder - 1) {
    return;
  }
  if (fromState.getOrder() > toState.getOrder()) {
    throw new Error(""String_Node_Str"" + fromState.getClass().getName() + ' '+ fromState.toPrettyString()+ ""String_Node_Str""+ fromState.getOrder()+ ""String_Node_Str""+ toState.getClass().getName()+ ' '+ toState.toPrettyString()+ ""String_Node_Str""+ toState.getOrder());
  }
}",0.9647058823529412
19626,"/** 
 * Update this state with the given token 
 */
public void update(Token t){
  count++;
  if (t.getScore() > maxScore) {
    maxScore=t.getScore();
  }
  if (t.getScore() < minScore) {
    minScore=t.getScore();
  }
  isHMM=t.getSearchState() instanceof HMMSearchState;
}","/** 
 * Update this state with the given token
 * @param t
 */
public void update(Token t){
  count++;
  if (t.getScore() > maxScore) {
    maxScore=t.getScore();
  }
  if (t.getScore() < minScore) {
    minScore=t.getScore();
  }
  isHMM=t.getSearchState() instanceof HMMSearchState;
}",0.9768270944741532
19627,"/** 
 * Determines whether or not we've visited the state associated with this token since the previous frame.
 * @return true if we've visted the search state since the last frame
 */
private boolean isVisited(Token t){
  SearchState curState=t.getSearchState();
  t=t.getPredecessor();
  while (t != null && !t.isEmitting()) {
    if (curState.equals(t.getSearchState())) {
      System.out.println(""String_Node_Str"" + curState + ""String_Node_Str""+ t.getSearchState());
      return true;
    }
    t=t.getPredecessor();
  }
  return false;
}","/** 
 * Determines whether or not we've visited the state associated with this token since the previous frame.
 * @param t
 * @return true if we've visted the search state since the last frame
 */
private boolean isVisited(Token t){
  SearchState curState=t.getSearchState();
  t=t.getPredecessor();
  while (t != null && !t.isEmitting()) {
    if (curState.equals(t.getSearchState())) {
      System.out.println(""String_Node_Str"" + curState + ""String_Node_Str""+ t.getSearchState());
      return true;
    }
    t=t.getPredecessor();
  }
  return false;
}",0.9890909090909092
19628,"/** 
 * Converts a given Data-object into a <code>FloatData</code> if possible. 
 */
public static FloatData toFloatData(Data data){
  FloatData convertData;
  if (data instanceof FloatData)   convertData=(FloatData)data;
 else   if (data instanceof DoubleData) {
    DoubleData dd=(DoubleData)data;
    convertData=new FloatData(MatrixUtils.double2float(dd.getValues()),dd.getSampleRate(),dd.getCollectTime(),dd.getFirstSampleNumber());
  }
 else   throw new IllegalArgumentException(""String_Node_Str"" + data.getClass() + ""String_Node_Str"");
  return convertData;
}","/** 
 * Converts a given Data-object into a <code>FloatData</code> if possible.
 * @param data
 * @return
 */
public static FloatData toFloatData(Data data){
  FloatData convertData;
  if (data instanceof FloatData)   convertData=(FloatData)data;
 else   if (data instanceof DoubleData) {
    DoubleData dd=(DoubleData)data;
    convertData=new FloatData(MatrixUtils.double2float(dd.getValues()),dd.getSampleRate(),dd.getCollectTime(),dd.getFirstSampleNumber());
  }
 else   throw new IllegalArgumentException(""String_Node_Str"" + data.getClass() + ""String_Node_Str"");
  return convertData;
}",0.9766637856525496
19629,"/** 
 * Returns the last data procssor within the <code>DataProcessor</code> chain of this <code>FrontEnd</code>. 
 */
public DataProcessor getLastDataProcessor(){
  return last;
}","/** 
 * Returns the last data procssor within the <code>DataProcessor</code> chain of this <code>FrontEnd</code>.
 * @return
 */
public DataProcessor getLastDataProcessor(){
  return last;
}",0.972972972972973
19630,"/** 
 * Returns the collection of <code>DataProcessor</code>s which setup this <code>FrontEnd</code>. 
 */
public List<DataProcessor> getElements(){
  return frontEndList;
}","/** 
 * Returns the collection of <code>DataProcessor</code>s which setup this <code>FrontEnd</code>.
 * @return
 */
public List<DataProcessor> getElements(){
  return frontEndList;
}",0.9719101123595506
19631,"/** 
 * Returns the properties associated to this signal. 
 */
public synchronized Map<String,Object> getProps(){
  if (props == null)   props=new HashMap<String,Object>();
  return props;
}","/** 
 * Returns the properties associated to this signal.
 * @return
 */
public synchronized Map<String,Object> getProps(){
  if (props == null)   props=new HashMap<String,Object>();
  return props;
}",0.9692307692307692
19632,"/** 
 * Adds a new listener. 
 */
public void addDataListener(DataListener l){
  if (l == null)   return;
  dataListeners.add(l);
}","/** 
 * Adds a new listener.
 * @param l
 */
public void addDataListener(DataListener l){
  if (l == null)   return;
  dataListeners.add(l);
}",0.9597069597069596
19633,"/** 
 * Removes a listener. 
 */
public void removeDataListener(DataListener l){
  if (l == null)   return;
  dataListeners.remove(l);
}","/** 
 * Removes a listener.
 * @param l
 */
public void removeDataListener(DataListener l){
  if (l == null)   return;
  dataListeners.remove(l);
}",0.96113074204947
19634,"/** 
 * This method is invoked when a new   {@link Data} object becomes available. 
 */
public void processDataFrame(Data data);","/** 
 * This method is invoked when a new   {@link Data} object becomes available.
 * @param data
 */
public void processDataFrame(Data data);",0.9481481481481482
19635,"/** 
 * Registers a new listener for <code>Data</code>s. 
 */
void addDataListener(DataListener l);","/** 
 * Registers a new listener for <code>Data</code>s.
 * @param l
 */
void addDataListener(DataListener l);",0.9473684210526316
19636,"/** 
 * Unregisters a listener fors <code>Data</code>s. 
 */
void removeDataListener(DataListener l);","/** 
 * Unregisters a listener fors <code>Data</code>s.
 * @param l
 */
void removeDataListener(DataListener l);",0.9483568075117372
19637,"/** 
 * Given a non-speech frame, try to read more non-speech frames until we think its the end of utterance.
 * @param audio a non-speech frame
 * @return true if speech has really ended, false if speech has not ended
 */
private boolean readEndFrames(SpeechClassifiedData audio) throws DataProcessingException {
}","/** 
 * Given a non-speech frame, try to read more non-speech frames until we think its the end of utterance.
 * @param audio a non-speech frame
 * @return true if speech has really ended, false if speech has not ended
 * @throws edu.cmu.sphinx.frontend.DataProcessingException
 */
private boolean readEndFrames(SpeechClassifiedData audio) throws DataProcessingException {
}",0.7402031930333817
19638,"/** 
 * Handles an SpeechClassifiedData object that can possibly be the first in an utterance.
 * @param audio the SpeechClassifiedData to handle
 * @return true if utterance/speech has started for real, false otherwise
 */
private boolean handleFirstSpeech(SpeechClassifiedData audio) throws DataProcessingException {
  int speechTime=getAudioTime(audio);
  while (speechTime < startSpeechTime) {
    Data next=readData();
    if (next == null) {
      return false;
    }
    sendToQueue(next);
    if (next instanceof SpeechClassifiedData) {
      if (!((SpeechClassifiedData)next).isSpeech()) {
        return false;
      }
 else {
        speechTime+=getAudioTime(audio);
      }
    }
  }
  return true;
}","/** 
 * Handles an SpeechClassifiedData object that can possibly be the first in an utterance.
 * @param audio the SpeechClassifiedData to handle
 * @return true if utterance/speech has started for real, false otherwise
 * @throws edu.cmu.sphinx.frontend.DataProcessingException
 */
private boolean handleFirstSpeech(SpeechClassifiedData audio) throws DataProcessingException {
  int speechTime=getAudioTime(audio);
  while (speechTime < startSpeechTime) {
    Data next=readData();
    if (next == null) {
      return false;
    }
    sendToQueue(next);
    if (next instanceof SpeechClassifiedData) {
      if (!((SpeechClassifiedData)next).isSpeech()) {
        return false;
      }
 else {
        speechTime+=getAudioTime(audio);
      }
    }
  }
  return true;
}",0.8739042481456507
19639,"/** 
 * Replicate the given cepstrum Data object into the first window+1 number of frames in the cepstraBuffer. This is the first cepstrum in the segment.
 * @param cepstrum the Data to replicate
 * @return the number of Features that can be computed
 */
private int processFirstCepstrum(Data cepstrum) throws DataProcessingException {
  if (cepstrum instanceof DataEndSignal) {
    outputQueue.add(cepstrum);
    return 0;
  }
 else   if (cepstrum instanceof DataStartSignal) {
    throw new Error(""String_Node_Str"");
  }
 else {
    Arrays.fill(cepstraBuffer,0,window + 1,cepstrum);
    bufferPosition=window + 1;
    bufferPosition%=cepstraBufferSize;
    currentPosition=window;
    currentPosition%=cepstraBufferSize;
    int numberFeatures=1;
    pendingSignal=null;
    for (int i=0; i < window; i++) {
      Data next=getNextData();
      if (next != null) {
        if (next instanceof DoubleData) {
          addCepstrum((DoubleData)next);
        }
 else         if (next instanceof DataEndSignal || next instanceof SpeechEndSignal) {
          pendingSignal=(Signal)next;
          replicateLastCepstrum();
          numberFeatures+=i;
          break;
        }
 else         if (next instanceof DataStartSignal) {
          throw new Error(""String_Node_Str"");
        }
      }
    }
    return numberFeatures;
  }
}","/** 
 * Replicate the given cepstrum Data object into the first window+1 number of frames in the cepstraBuffer. This is the first cepstrum in the segment.
 * @param cepstrum the Data to replicate
 * @return the number of Features that can be computed
 * @throws edu.cmu.sphinx.frontend.DataProcessingException
 */
private int processFirstCepstrum(Data cepstrum) throws DataProcessingException {
  if (cepstrum instanceof DataEndSignal) {
    outputQueue.add(cepstrum);
    return 0;
  }
 else   if (cepstrum instanceof DataStartSignal) {
    throw new Error(""String_Node_Str"");
  }
 else {
    Arrays.fill(cepstraBuffer,0,window + 1,cepstrum);
    bufferPosition=window + 1;
    bufferPosition%=cepstraBufferSize;
    currentPosition=window;
    currentPosition%=cepstraBufferSize;
    int numberFeatures=1;
    pendingSignal=null;
    for (int i=0; i < window; i++) {
      Data next=getNextData();
      if (next != null) {
        if (next instanceof DoubleData) {
          addCepstrum((DoubleData)next);
        }
 else         if (next instanceof DataEndSignal || next instanceof SpeechEndSignal) {
          pendingSignal=(Signal)next;
          replicateLastCepstrum();
          numberFeatures+=i;
          break;
        }
 else         if (next instanceof DataStartSignal) {
          throw new Error(""String_Node_Str"");
        }
      }
    }
    return numberFeatures;
  }
}",0.9783008458992276
19640,"/** 
 * Read a Data object from the predecessor DataProcessor, and increment the ID count appropriately.
 * @return the read Data object
 */
private Data readData() throws DataProcessingException {
  Data frame=getPredecessor().getData();
  if (frame != null) {
    id++;
  }
  return frame;
}","/** 
 * Read a Data object from the predecessor DataProcessor, and increment the ID count appropriately.
 * @return the read Data object
 * @throws edu.cmu.sphinx.frontend.DataProcessingException
 */
private Data readData() throws DataProcessingException {
  Data frame=getPredecessor().getData();
  if (frame != null) {
    id++;
  }
  return frame;
}",0.827906976744186
19641,"/** 
 * Routine to compute Linear Prediction Coefficients for a frame of speech. Returns the energy of the frame (alpha in the Levinson recursion) Assumes the following sign convention:<br> prediction(x[t]) = Sum_i {Ar[i] * x[t-i]}
 * @param autocor
 */
public double[] getARFilter(double[] autocor){
  if (autocor[0] == 0) {
    return null;
  }
  reflectionCoeffs=new double[order + 1];
  ARParameters=new double[order + 1];
  double[] backwardPredictor=new double[order + 1];
  alpha=autocor[0];
  reflectionCoeffs[1]=-autocor[1] / autocor[0];
  ARParameters[0]=1.0;
  ARParameters[1]=reflectionCoeffs[1];
  alpha*=(1 - reflectionCoeffs[1] * reflectionCoeffs[1]);
  for (int i=2; i <= order; i++) {
    for (int j=1; j < i; j++) {
      backwardPredictor[j]=ARParameters[i - j];
    }
    reflectionCoeffs[i]=0;
    for (int j=0; j < i; j++) {
      reflectionCoeffs[i]-=ARParameters[j] * autocor[i - j];
    }
    reflectionCoeffs[i]/=alpha;
    for (int j=1; j < i; j++) {
      ARParameters[j]+=reflectionCoeffs[i] * backwardPredictor[j];
    }
    ARParameters[i]=reflectionCoeffs[i];
    alpha*=(1 - reflectionCoeffs[i] * reflectionCoeffs[i]);
    if (alpha <= 0.0) {
      return null;
    }
  }
  return ARParameters;
}","/** 
 * Routine to compute Linear Prediction Coefficients for a frame of speech. Returns the energy of the frame (alpha in the Levinson recursion) Assumes the following sign convention:<br> prediction(x[t]) = Sum_i {Ar[i] * x[t-i]}
 * @param autocor
 * @return
 */
public double[] getARFilter(double[] autocor){
  if (autocor[0] == 0) {
    return null;
  }
  reflectionCoeffs=new double[order + 1];
  ARParameters=new double[order + 1];
  double[] backwardPredictor=new double[order + 1];
  alpha=autocor[0];
  reflectionCoeffs[1]=-autocor[1] / autocor[0];
  ARParameters[0]=1.0;
  ARParameters[1]=reflectionCoeffs[1];
  alpha*=(1 - reflectionCoeffs[1] * reflectionCoeffs[1]);
  for (int i=2; i <= order; i++) {
    for (int j=1; j < i; j++) {
      backwardPredictor[j]=ARParameters[i - j];
    }
    reflectionCoeffs[i]=0;
    for (int j=0; j < i; j++) {
      reflectionCoeffs[i]-=ARParameters[j] * autocor[i - j];
    }
    reflectionCoeffs[i]/=alpha;
    for (int j=1; j < i; j++) {
      ARParameters[j]+=reflectionCoeffs[i] * backwardPredictor[j];
    }
    ARParameters[i]=reflectionCoeffs[i];
    alpha*=(1 - reflectionCoeffs[i] * reflectionCoeffs[i]);
    if (alpha <= 0.0) {
      return null;
    }
  }
  return ARParameters;
}",0.9955447549615228
19642,"/** 
 * Process data, creating the PLP cepstrum from an input audio frame.
 * @param input a PLP Spectrum frame
 * @return a PLP Data frame
 */
private Data process(DoubleData input) throws IllegalArgumentException {
  double[] plpspectrum=input.getValues();
  if (plpspectrum.length != numberPLPFilters) {
    throw new IllegalArgumentException(""String_Node_Str"" + plpspectrum.length + ""String_Node_Str""+ numberPLPFilters);
  }
  double[] compressedspectrum=powerLawCompress(plpspectrum);
  double[] autocor=applyCosine(compressedspectrum);
  LinearPredictor LPC=new LinearPredictor(LPCOrder);
  double[] LPCcoeffs=LPC.getARFilter(autocor);
  double[] cepstrumDouble=LPC.getData(cepstrumSize);
  DoubleData cepstrum=new DoubleData(cepstrumDouble,input.getSampleRate(),input.getCollectTime(),input.getFirstSampleNumber());
  return cepstrum;
}","/** 
 * Process data, creating the PLP cepstrum from an input audio frame.
 * @param input a PLP Spectrum frame
 * @return a PLP Data frame
 * @throws IllegalArgumentException
 */
private Data process(DoubleData input) throws IllegalArgumentException {
  double[] plpspectrum=input.getValues();
  if (plpspectrum.length != numberPLPFilters) {
    throw new IllegalArgumentException(""String_Node_Str"" + plpspectrum.length + ""String_Node_Str""+ numberPLPFilters);
  }
  double[] compressedspectrum=powerLawCompress(plpspectrum);
  double[] autocor=applyCosine(compressedspectrum);
  LinearPredictor LPC=new LinearPredictor(LPCOrder);
  double[] LPCcoeffs=LPC.getARFilter(autocor);
  double[] cepstrumDouble=LPC.getData(cepstrumSize);
  DoubleData cepstrum=new DoubleData(cepstrumDouble,input.getSampleRate(),input.getCollectTime(),input.getFirstSampleNumber());
  return cepstrum;
}",0.9790940766550522
19643,"/** 
 * Applies the intensity loudness power law. This operation is an approximation to the power law of hearing and simulates the non-linear relationship between sound intensity and percieved loudness. Computationally, this operation is used to reduce the spectral amplitude of the critical band to enable all-pole modeling with relatively low order AR filters.
 */
private double[] powerLawCompress(double[] inspectrum){
  double[] compressedspectrum=new double[inspectrum.length];
  for (int i=0; i < inspectrum.length; i++) {
    compressedspectrum[i]=Math.pow(inspectrum[i],1.0 / 3.0);
  }
  return compressedspectrum;
}","/** 
 * Applies the intensity loudness power law. This operation is an approximation to the power law of hearing and simulates the non-linear relationship between sound intensity and percieved loudness. Computationally, this operation is used to reduce the spectral amplitude of the critical band to enable all-pole modeling with relatively low order AR filters.
 * @param inspectrum
 * @return
 */
private double[] powerLawCompress(double[] inspectrum){
  double[] compressedspectrum=new double[inspectrum.length];
  for (int i=0; i < inspectrum.length; i++) {
    compressedspectrum[i]=Math.pow(inspectrum[i],1.0 / 3.0);
  }
  return compressedspectrum;
}",0.9750390015600624
19644,"/** 
 * This function return the equal loudness preemphasis factor at any frequency. The preemphasis function is given by <p/> E(w) = (w^2+56.8e6)*w^4/((w^2+6.3e6)^2(w^2+0.38e9)(w^6+9.58e26)) <p/> where w is frequency in radians/second
 */
private double loudnessScalingFunction(double freq){
  double freqsquared=freq * freq;
  double freqfourth=freqsquared * freqsquared;
  double freqsixth=freqfourth * freqsquared;
  double numerator=(freqsquared + 56.8e6) * freqfourth;
  double denominator=Math.pow((freqsquared + 6.3e6),2) * (freqsquared + 0.38e9) * (freqsixth + 9.58e26);
  return numerator / denominator;
}","/** 
 * This function return the equal loudness preemphasis factor at any frequency. The preemphasis function is given by <p/> E(w) = (w^2+56.8e6)*w^4/((w^2+6.3e6)^2(w^2+0.38e9)(w^6+9.58e26)) <p/> where w is frequency in radians/second
 * @param freq
 * @return
 */
private double loudnessScalingFunction(double freq){
  double freqsquared=freq * freq;
  double freqfourth=freqsquared * freqsquared;
  double freqsixth=freqfourth * freqsquared;
  double numerator=(freqsquared + 56.8e6) * freqfourth;
  double denominator=Math.pow((freqsquared + 6.3e6),2) * (freqsquared + 0.38e9) * (freqsixth + 9.58e26);
  return numerator / denominator;
}",0.9792993630573248
19645,"/** 
 * Process data, creating the mel cepstrum from an input spectrum frame.
 * @param input a MelSpectrum frame
 * @return a mel Cepstrum frame
 */
private DoubleData process(DoubleData input) throws IllegalArgumentException {
  double[] melspectrum=input.getValues();
  if (melcosine == null) {
    numberMelFilters=melspectrum.length;
    computeMelCosine();
  }
 else   if (melspectrum.length != numberMelFilters) {
    throw new IllegalArgumentException(""String_Node_Str"" + melspectrum.length + ""String_Node_Str""+ numberMelFilters);
  }
  for (int i=0; i < melspectrum.length; ++i) {
    if (melspectrum[i] > 0) {
      melspectrum[i]=Math.log(melspectrum[i]);
    }
 else {
      melspectrum[i]=-1.0e+5;
    }
  }
  double[] cepstrum;
  cepstrum=applyMelCosine(melspectrum);
  return new DoubleData(cepstrum,input.getSampleRate(),input.getCollectTime(),input.getFirstSampleNumber());
}","/** 
 * Process data, creating the mel cepstrum from an input spectrum frame.
 * @param input a MelSpectrum frame
 * @return a mel Cepstrum frame
 * @throws IllegalArgumentException
 */
private DoubleData process(DoubleData input) throws IllegalArgumentException {
  double[] melspectrum=input.getValues();
  if (melcosine == null) {
    numberMelFilters=melspectrum.length;
    computeMelCosine();
  }
 else   if (melspectrum.length != numberMelFilters) {
    throw new IllegalArgumentException(""String_Node_Str"" + melspectrum.length + ""String_Node_Str""+ numberMelFilters);
  }
  for (int i=0; i < melspectrum.length; ++i) {
    if (melspectrum[i] > 0) {
      melspectrum[i]=Math.log(melspectrum[i]);
    }
 else {
      melspectrum[i]=-1.0e+5;
    }
  }
  double[] cepstrum;
  cepstrum=applyMelCosine(melspectrum);
  return new DoubleData(cepstrum,input.getSampleRate(),input.getCollectTime(),input.getFirstSampleNumber());
}",0.9802197802197802
19646,"/** 
 * Returns the next Data from the input stream, or null if there is none available
 * @return a Data or null
 * @throws java.io.IOException
 */
private Data readNextFrame() throws DataProcessingException {
  int read;
  int totalRead=0;
  final int bytesToRead=bytesPerRead;
  byte[] samplesBuffer=new byte[bytesPerRead];
  long collectTime=System.currentTimeMillis();
  long firstSample=totalValuesRead;
  try {
    do {
      read=dataStream.read(samplesBuffer,totalRead,bytesToRead - totalRead);
      if (read > 0) {
        totalRead+=read;
      }
    }
 while (read != -1 && totalRead < bytesToRead);
    if (totalRead <= 0) {
      closeDataStream();
      return null;
    }
    totalValuesRead+=(totalRead / bytesPerValue);
    if (totalRead < bytesToRead) {
      totalRead=(totalRead % 2 == 0) ? totalRead + 2 : totalRead + 3;
      byte[] shrinkedBuffer=new byte[totalRead];
      System.arraycopy(samplesBuffer,0,shrinkedBuffer,0,totalRead);
      samplesBuffer=shrinkedBuffer;
      closeDataStream();
    }
  }
 catch (  IOException ioe) {
    ioe.printStackTrace();
    throw new DataProcessingException(""String_Node_Str"");
  }
  double[] doubleData;
  if (bigEndian) {
    doubleData=DataUtil.bytesToValues(samplesBuffer,0,totalRead,bytesPerValue,signedData);
  }
 else {
    doubleData=DataUtil.littleEndianBytesToValues(samplesBuffer,0,totalRead,bytesPerValue,signedData);
  }
  return new DoubleData(doubleData,sampleRate,collectTime,firstSample);
}","/** 
 * Returns the next Data from the input stream, or null if there is none available
 * @return a Data or null
 * @throws edu.cmu.sphinx.frontend.DataProcessingException
 */
private Data readNextFrame() throws DataProcessingException {
  int read;
  int totalRead=0;
  final int bytesToRead=bytesPerRead;
  byte[] samplesBuffer=new byte[bytesPerRead];
  long collectTime=System.currentTimeMillis();
  long firstSample=totalValuesRead;
  try {
    do {
      read=dataStream.read(samplesBuffer,totalRead,bytesToRead - totalRead);
      if (read > 0) {
        totalRead+=read;
      }
    }
 while (read != -1 && totalRead < bytesToRead);
    if (totalRead <= 0) {
      closeDataStream();
      return null;
    }
    totalValuesRead+=(totalRead / bytesPerValue);
    if (totalRead < bytesToRead) {
      totalRead=(totalRead % 2 == 0) ? totalRead + 2 : totalRead + 3;
      byte[] shrinkedBuffer=new byte[totalRead];
      System.arraycopy(samplesBuffer,0,shrinkedBuffer,0,totalRead);
      samplesBuffer=shrinkedBuffer;
      closeDataStream();
    }
  }
 catch (  IOException ioe) {
    ioe.printStackTrace();
    throw new DataProcessingException(""String_Node_Str"");
  }
  double[] doubleData;
  if (bigEndian) {
    doubleData=DataUtil.bytesToValues(samplesBuffer,0,totalRead,bytesPerValue,signedData);
  }
 else {
    doubleData=DataUtil.littleEndianBytesToValues(samplesBuffer,0,totalRead,bytesPerValue,signedData);
  }
  return new DoubleData(doubleData,sampleRate,collectTime,firstSample);
}",0.3492276695768972
19647,"/** 
 * Adds a new listener for new file events. 
 */
public void addNewFileListener(AudioFileProcessListener l){
  if (l == null)   return;
  fileListeners.add(l);
}","/** 
 * Adds a new listener for new file events.
 * @param l
 */
public void addNewFileListener(AudioFileProcessListener l){
  if (l == null)   return;
  fileListeners.add(l);
}",0.967930029154519
19648,"/** 
 * Removes a listener for new file events. 
 */
public void removeNewFileListener(AudioFileProcessListener l){
  if (l == null)   return;
  fileListeners.remove(l);
}","/** 
 * Removes a listener for new file events.
 * @param l
 */
public void removeNewFileListener(AudioFileProcessListener l){
  if (l == null)   return;
  fileListeners.remove(l);
}",0.9688385269121812
19649,"/** 
 * Reads and verifies a driver file. 
 */
private static List<URL> readDriver(String fileName){
}","/** 
 * Reads and verifies a driver file.
 * @param fileName
 * @return
 */
private static List<URL> readDriver(String fileName){
}",0.8755364806866953
19650,"/** 
 * Returns the next Data object being processed by this Preemphasizer, or if it is a Signal, it is returned without modification.
 * @return the next available Data object, returns null if no Data object is available
 * @throws DataProcessingException if there is a processing error
 * @see Data
 */
public Data getData() throws DataProcessingException {
  Data input=getPredecessor().getData();
  getTimer().start();
  if (input != null) {
    if (input instanceof DoubleData) {
      applyPreemphasis(((DoubleData)input).getValues());
    }
 else     if (input instanceof DataEndSignal) {
      prior=0;
    }
  }
  getTimer().stop();
  return input;
}","/** 
 * Returns the next Data object being processed by this Preemphasizer, or if it is a Signal, it is returned without modification.
 * @return the next available Data object, returns null if no Data object is available
 * @throws DataProcessingException if there is a processing error
 * @see Data
 */
public Data getData() throws DataProcessingException {
  Data input=getPredecessor().getData();
  getTimer().start();
  if (input != null) {
    if (input instanceof DoubleData) {
      applyPreemphasis(((DoubleData)input).getValues());
    }
 else     if (input instanceof DataEndSignal || input instanceof SpeechEndSignal) {
      prior=0;
    }
  }
  getTimer().stop();
  return input;
}",0.9734121122599704
19651,"public void newResult(Result result){
  NISTAlign aligner=getAligner();
  String ref=result.getReferenceText();
  if (result.isFinal() && (ref != null)) {
    try {
      Path bestPath=null;
      String hyp=""String_Node_Str"";
      if (result.getBestFinalToken() != null) {
        ConfidenceResult confidenceResult=confidenceScorer.score(result);
        bestPath=confidenceResult.getBestHypothesis();
        hyp=getTranscriptionNoFiller(bestPath);
      }
      aligner.align(ref,hyp);
      if (bestPath != null) {
        showDetails(getTranscriptionRaw(bestPath));
      }
 else {
        showDetails(""String_Node_Str"");
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
}","public void newResult(Result result){
  NISTAlign aligner=getAligner();
  String ref=result.getReferenceText();
  if (result.isFinal() && (ref != null)) {
    try {
      Path bestPath=null;
      String hyp=""String_Node_Str"";
      if (result.getBestFinalToken() != null) {
        ConfidenceResult confidenceResult=confidenceScorer.score(result);
        bestPath=confidenceResult.getBestHypothesis();
        hyp=bestPath.getTranscriptionNoFiller();
      }
      aligner.align(ref,hyp);
      if (bestPath != null) {
        showDetails(bestPath.getTranscription());
      }
 else {
        showDetails(""String_Node_Str"");
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
}",0.9723991507430998
19652,"/** 
 * @see edu.cmu.sphinx.result.Path#getTranscription() 
 */
public String getTranscription(){
  StringBuilder sb=new StringBuilder();
  for (  WordResult wr : path)   sb.append(wr).append(' ');
  if (!path.isEmpty())   sb.setLength(sb.length() - 1);
  return sb.toString();
}","/** 
 * @see edu.cmu.sphinx.result.Path#getTranscription() 
 */
public String getTranscription(){
  StringBuilder sb=new StringBuilder();
  for (  WordResult wr : path)   sb.append(wr).append(' ');
  return sb.toString().trim();
}",0.8055009823182712
19653,"/** 
 * Gets the value associated with this name
 * @param name the name
 * @return the value
 * @throws edu.cmu.sphinx.util.props.PropertyException if the named property is not of this type
 */
public double getDouble(String name) throws PropertyException {
  S4PropWrapper s4PropWrapper=getProperty(name,S4Double.class);
  S4Double s4Double=(S4Double)s4PropWrapper.getAnnotation();
  if (propValues.get(name) == null) {
    boolean isDefDefined=!(s4Double.defaultValue() == S4Double.NOT_DEFINED);
    if (s4Double.mandatory()) {
      if (!isDefDefined)       throw new InternalConfigurationException(getInstanceName(),name,""String_Node_Str"");
    }
 else     if (!isDefDefined)     throw new InternalConfigurationException(getInstanceName(),name,""String_Node_Str"");
    propValues.put(name,s4Double.defaultValue());
  }
  Object propObject=propValues.get(name);
  if (propObject instanceof Integer)   propObject=new Double((Integer)propObject);
  Double propValue=propObject instanceof Double ? (Double)propObject : Double.valueOf(flattenProp(name));
  double[] range=s4Double.range();
  if (range.length != 2)   throw new InternalConfigurationException(getInstanceName(),name,range + ""String_Node_Str"");
  if (propValue < range[0] || propValue > range[1])   throw new InternalConfigurationException(getInstanceName(),name,""String_Node_Str"" + range + ""String_Node_Str"");
  return propValue;
}","/** 
 * Gets the value associated with this name
 * @param name the name
 * @return the value
 * @throws edu.cmu.sphinx.util.props.PropertyException if the named property is not of this type
 */
public double getDouble(String name) throws PropertyException {
  S4PropWrapper s4PropWrapper=getProperty(name,S4Double.class);
  S4Double s4Double=(S4Double)s4PropWrapper.getAnnotation();
  if (propValues.get(name) == null) {
    boolean isDefDefined=!(s4Double.defaultValue() == S4Double.NOT_DEFINED);
    if (s4Double.mandatory()) {
      if (!isDefDefined)       throw new InternalConfigurationException(getInstanceName(),name,""String_Node_Str"");
    }
 else     if (!isDefDefined)     throw new InternalConfigurationException(getInstanceName(),name,""String_Node_Str"");
    propValues.put(name,s4Double.defaultValue());
  }
  Object propObject=propValues.get(name);
  Double propValue;
  if (propObject instanceof Double)   propValue=(Double)propObject;
 else   if (propObject instanceof Integer)   propValue=new Double((Integer)propObject);
 else   propValue=Double.valueOf(flattenProp(name));
  double[] range=s4Double.range();
  if (range.length != 2)   throw new InternalConfigurationException(getInstanceName(),name,range + ""String_Node_Str"");
  if (propValue < range[0] || propValue > range[1])   throw new InternalConfigurationException(getInstanceName(),name,""String_Node_Str"" + range + ""String_Node_Str"");
  return propValue;
}",0.9123674911660776
19654,"/** 
 * Gets the value associated with this name
 * @param name the name
 * @return the value
 * @throws edu.cmu.sphinx.util.props.PropertyException if the named property is not of this type
 */
public Boolean getBoolean(String name) throws PropertyException {
  S4PropWrapper s4PropWrapper=getProperty(name,S4Boolean.class);
  S4Boolean s4Boolean=(S4Boolean)s4PropWrapper.getAnnotation();
  if (propValues.get(name) == null)   propValues.put(name,s4Boolean.defaultValue());
  Object propValue=propValues.get(name);
  if (propValue instanceof String)   propValue=Boolean.valueOf((String)propValue);
  return (Boolean)propValue;
}","/** 
 * Gets the value associated with this name
 * @param name the name
 * @return the value
 * @throws edu.cmu.sphinx.util.props.PropertyException if the named property is not of this type
 */
public Boolean getBoolean(String name) throws PropertyException {
  S4PropWrapper s4PropWrapper=getProperty(name,S4Boolean.class);
  S4Boolean s4Boolean=(S4Boolean)s4PropWrapper.getAnnotation();
  if (propValues.get(name) == null)   propValues.put(name,(Boolean)s4Boolean.defaultValue());
  Object propObject=propValues.get(name);
  Boolean propValue;
  if (propObject instanceof Boolean)   propValue=(Boolean)propObject;
 else   propValue=Boolean.valueOf(flattenProp(name));
  return propValue;
}",0.8402725208175624
19655,"public void newProperties(PropertySheet ps) throws PropertyException {
  frontEnd=(DummyFrontEnd)ps.getComponent(PROP_FRONTEND);
  beamWidth=ps.getInt(PROP_BEAM_WIDTH);
  bestAsr=ps.getString(PROP_BEST_ASR);
  alpha=ps.getDouble(PROP_ALPHA);
  logger=ps.getLogger();
}","public void newProperties(PropertySheet ps) throws PropertyException {
  frontEnd=(DummyFrontEnd)ps.getComponent(PROP_FRONTEND);
  beamWidth=ps.getInt(PROP_BEAM_WIDTH);
  bestAsr=ps.getString(PROP_BEST_ASR);
  alpha=ps.getDouble(PROP_ALPHA);
  useFooBaz=ps.getBoolean(PROP_USE_FOOBAZ);
  logger=ps.getLogger();
}",0.9241379310344828
19656,"@Test public void testGetDefaultInstance() throws PropertyException, InstantiationException {
  DummyComp dc=ConfigurationManager.getInstance(DummyComp.class);
  Assert.assertEquals(4,dc.getBeamWidth());
  Assert.assertEquals(1.3,dc.getAlpha(),1E-10);
  DummyFrontEnd fe=dc.getFrontEnd();
  Assert.assertTrue(fe != null);
  Assert.assertTrue(fe instanceof AnotherDummyFrontEnd);
  Assert.assertTrue(fe.getDataProcs().size() == 3);
  Assert.assertTrue(fe.getDataProcs().get(0) instanceof DummyProcessor);
  Assert.assertTrue(fe.getDataProcs().get(1) instanceof AnotherDummyProcessor);
  Assert.assertTrue(fe.getDataProcs().get(2) instanceof DummyProcessor);
  Assert.assertTrue(dc.getBestASR().equals(""String_Node_Str""));
  Assert.assertTrue(dc.getLogger() != null);
}","@Test public void testGetDefaultInstance() throws PropertyException, InstantiationException {
  DummyComp dc=ConfigurationManager.getInstance(DummyComp.class);
  Assert.assertEquals(4,dc.getBeamWidth());
  Assert.assertEquals(1.3,dc.getAlpha(),1E-10);
  Assert.assertEquals(false,useFooBaz);
  DummyFrontEnd fe=dc.getFrontEnd();
  Assert.assertTrue(fe != null);
  Assert.assertTrue(fe instanceof AnotherDummyFrontEnd);
  Assert.assertTrue(fe.getDataProcs().size() == 3);
  Assert.assertTrue(fe.getDataProcs().get(0) instanceof DummyProcessor);
  Assert.assertTrue(fe.getDataProcs().get(1) instanceof AnotherDummyProcessor);
  Assert.assertTrue(fe.getDataProcs().get(2) instanceof DummyProcessor);
  Assert.assertTrue(dc.getBestASR().equals(""String_Node_Str""));
  Assert.assertTrue(dc.getLogger() != null);
}",0.974587039390089
19657,"/** 
 * Loads the transition matrices
 * @param path the path to the transitions matrices
 * @return a pool of transition matrices
 * @throws FileNotFoundException if a file cannot be found
 * @throws IOException           if an error occurs while loading the data
 */
protected Pool loadTransitionMatricesAscii(String path) throws FileNotFoundException, IOException {
  String location=super.getLocation();
  InputStream inputStream=StreamFactory.getInputStream(location,path);
  LogMath logMath=ConfigurationManager.getInstance(LogMath.class);
  logger.info(""String_Node_Str"");
  logger.info(path);
  int numMatrices;
  int numStates;
  Pool pool=new Pool(path);
  ExtendedStreamTokenizer est=new ExtendedStreamTokenizer(inputStream,'#',false);
  est.expectString(""String_Node_Str"");
  numMatrices=est.getInt(""String_Node_Str"");
  est.expectString(""String_Node_Str"");
  for (int i=0; i < numMatrices; i++) {
    est.expectString(""String_Node_Str"");
    est.expectString(""String_Node_Str"" + i + ""String_Node_Str"");
    est.expectString(""String_Node_Str"");
    numStates=est.getInt(""String_Node_Str"") + 1;
    float[][] tmat=new float[numStates][numStates];
    for (int j=0; j < numStates; j++) {
      for (int k=0; k < numStates; k++) {
        if (j < numStates - 1) {
          if (sparseForm) {
            if (k == j || k == j + 1) {
              tmat[j][k]=est.getFloat(""String_Node_Str"");
            }
          }
 else {
            tmat[j][k]=est.getFloat(""String_Node_Str"");
          }
        }
        tmat[j][k]=logMath.linearToLog(tmat[j][k]);
        if (logger.isLoggable(Level.FINE)) {
          logger.fine(""String_Node_Str"" + j + ""String_Node_Str""+ k+ ""String_Node_Str""+ tmat[j][k]);
        }
      }
    }
    pool.put(i,tmat);
  }
  est.close();
  return pool;
}","/** 
 * Loads the transition matrices
 * @param path the path to the transitions matrices
 * @return a pool of transition matrices
 * @throws FileNotFoundException if a file cannot be found
 * @throws IOException           if an error occurs while loading the data
 */
protected Pool loadTransitionMatricesAscii(String path) throws FileNotFoundException, IOException {
  String location=""String_Node_Str"";
  InputStream inputStream=StreamFactory.getInputStream(location,path);
  LogMath logMath=ConfigurationManager.getInstance(LogMath.class);
  logger.info(""String_Node_Str"");
  logger.info(path);
  int numMatrices;
  int numStates;
  Pool pool=new Pool(path);
  ExtendedStreamTokenizer est=new ExtendedStreamTokenizer(inputStream,'#',false);
  est.expectString(""String_Node_Str"");
  numMatrices=est.getInt(""String_Node_Str"");
  est.expectString(""String_Node_Str"");
  for (int i=0; i < numMatrices; i++) {
    est.expectString(""String_Node_Str"");
    est.expectString(""String_Node_Str"" + i + ""String_Node_Str"");
    est.expectString(""String_Node_Str"");
    numStates=est.getInt(""String_Node_Str"") + 1;
    float[][] tmat=new float[numStates][numStates];
    for (int j=0; j < numStates; j++) {
      for (int k=0; k < numStates; k++) {
        if (j < numStates - 1) {
          if (sparseForm) {
            if (k == j || k == j + 1) {
              tmat[j][k]=est.getFloat(""String_Node_Str"");
            }
          }
 else {
            tmat[j][k]=est.getFloat(""String_Node_Str"");
          }
        }
        tmat[j][k]=logMath.linearToLog(tmat[j][k]);
        if (logger.isLoggable(Level.FINE)) {
          logger.fine(""String_Node_Str"" + j + ""String_Node_Str""+ k+ ""String_Node_Str""+ tmat[j][k]);
        }
      }
    }
    pool.put(i,tmat);
  }
  est.close();
  return pool;
}",0.9899328859060402
19658,"@Override public void newProperties(PropertySheet ps) throws PropertyException {
  super.newProperties(ps);
  logger=ps.getLogger();
  loader=(Loader)ps.getComponent(LOADER);
  saver=(Saver)ps.getComponent(SAVER);
  hmmPoolManager=new HMMPoolManager(loader);
  loadTimer=Timer.getTimer(TIMER_LOAD);
  saveFormat=ps.getString(PROP_FORMAT_SAVE);
  logInfo();
}","@Override public void newProperties(PropertySheet ps) throws PropertyException {
  super.newProperties(ps);
  logger=ps.getLogger();
  loader=(Loader)ps.getComponent(LOADER);
  saver=(Saver)ps.getComponent(SAVER);
  hmmPoolManager=new HMMPoolManager(loader);
  loadTimer=TimerPool.getTimer(TIMER_LOAD);
  saveFormat=ps.getString(PROP_FORMAT_SAVE);
  logInfo();
}",0.9944444444444444
19659,"public void newProperties(PropertySheet ps) throws PropertyException {
  this.batchFile=ps.getString(BATCH_FILE);
  skip=ps.getInt(SKIP);
  clientFrontEnd=(ClientFrontEndImpl)ps.getComponent(CLIENT);
  decodeTimer=Timer.getTimer(""String_Node_Str"");
  aligner=new NISTAlign(true,true);
}","public void newProperties(PropertySheet ps) throws PropertyException {
  this.batchFile=ps.getString(BATCH_FILE);
  skip=ps.getInt(SKIP);
  clientFrontEnd=(ClientFrontEndImpl)ps.getComponent(CLIENT);
  decodeTimer=TimerPool.getTimer(""String_Node_Str"");
  aligner=new NISTAlign(true,true);
}",0.9930555555555556
19660,"/** 
 * Decodes the batch of audio files
 * @throws DataProcessingException if a data processing error occurs
 * @throws IOException             if an I/O error occurs
 */
public void decode() throws DataProcessingException, IOException {
  clientFrontEnd.connect();
  int curCount=skip;
  System.out.println(""String_Node_Str"" + batchFile);
  System.out.println(""String_Node_Str"");
  for (Iterator i=BatchFile.getLines(batchFile).iterator(); i.hasNext(); ) {
    String line=(String)i.next();
    String file=BatchFile.getFilename(line);
    String reference=BatchFile.getReference(line);
    if (++curCount >= skip) {
      curCount=0;
      decodeFile(file,reference);
    }
  }
  System.out.println(""String_Node_Str"");
  Timer.dumpAll();
  clientFrontEnd.close();
}","/** 
 * Decodes the batch of audio files
 * @throws DataProcessingException if a data processing error occurs
 * @throws IOException             if an I/O error occurs
 */
public void decode() throws DataProcessingException, IOException {
  clientFrontEnd.connect();
  int curCount=skip;
  System.out.println(""String_Node_Str"" + batchFile);
  System.out.println(""String_Node_Str"");
  for (Iterator i=BatchFile.getLines(batchFile).iterator(); i.hasNext(); ) {
    String line=(String)i.next();
    String file=BatchFile.getFilename(line);
    String reference=BatchFile.getReference(line);
    if (++curCount >= skip) {
      curCount=0;
      decodeFile(file,reference);
    }
  }
  System.out.println(""String_Node_Str"");
  TimerPool.dumpAll();
  clientFrontEnd.close();
}",0.9974025974025974
19661,"public void allocate(){
  totalTokensScored=StatisticsVariable.getStatisticsVariable(""String_Node_Str"");
  tokensPerSecond=StatisticsVariable.getStatisticsVariable(""String_Node_Str"");
  curTokensScored=StatisticsVariable.getStatisticsVariable(""String_Node_Str"");
  tokensCreated=StatisticsVariable.getStatisticsVariable(""String_Node_Str"");
  viterbiPruned=StatisticsVariable.getStatisticsVariable(""String_Node_Str"");
  beamPruned=StatisticsVariable.getStatisticsVariable(""String_Node_Str"");
  try {
    linguist.allocate();
    pruner.allocate();
    scorer.allocate();
  }
 catch (  IOException e) {
    throw new RuntimeException(toString() + ""String_Node_Str"",e);
  }
  scoreTimer=Timer.getTimer(""String_Node_Str"");
  pruneTimer=Timer.getTimer(""String_Node_Str"");
  growTimer=Timer.getTimer(""String_Node_Str"");
}","public void allocate(){
  totalTokensScored=StatisticsVariable.getStatisticsVariable(""String_Node_Str"");
  tokensPerSecond=StatisticsVariable.getStatisticsVariable(""String_Node_Str"");
  curTokensScored=StatisticsVariable.getStatisticsVariable(""String_Node_Str"");
  tokensCreated=StatisticsVariable.getStatisticsVariable(""String_Node_Str"");
  viterbiPruned=StatisticsVariable.getStatisticsVariable(""String_Node_Str"");
  beamPruned=StatisticsVariable.getStatisticsVariable(""String_Node_Str"");
  try {
    linguist.allocate();
    pruner.allocate();
    scorer.allocate();
  }
 catch (  IOException e) {
    throw new RuntimeException(toString() + ""String_Node_Str"",e);
  }
  scoreTimer=TimerPool.getTimer(""String_Node_Str"");
  pruneTimer=TimerPool.getTimer(""String_Node_Str"");
  growTimer=TimerPool.getTimer(""String_Node_Str"");
}",0.9926918392204628
19662,"public void allocate(){
  scoreTimer=Timer.getTimer(""String_Node_Str"");
  pruneTimer=Timer.getTimer(""String_Node_Str"");
  growTimer=Timer.getTimer(""String_Node_Str"");
  totalTokensScored=StatisticsVariable.getStatisticsVariable(""String_Node_Str"");
  curTokensScored=StatisticsVariable.getStatisticsVariable(""String_Node_Str"");
  tokensCreated=StatisticsVariable.getStatisticsVariable(""String_Node_Str"");
  try {
    linguist.allocate();
    pruner.allocate();
    scorer.allocate();
  }
 catch (  IOException e) {
    throw new RuntimeException(toString() + ""String_Node_Str"",e);
  }
}","public void allocate(){
  scoreTimer=TimerPool.getTimer(""String_Node_Str"");
  pruneTimer=TimerPool.getTimer(""String_Node_Str"");
  growTimer=TimerPool.getTimer(""String_Node_Str"");
  totalTokensScored=StatisticsVariable.getStatisticsVariable(""String_Node_Str"");
  curTokensScored=StatisticsVariable.getStatisticsVariable(""String_Node_Str"");
  tokensCreated=StatisticsVariable.getStatisticsVariable(""String_Node_Str"");
  try {
    linguist.allocate();
    pruner.allocate();
    scorer.allocate();
  }
 catch (  IOException e) {
    throw new RuntimeException(toString() + ""String_Node_Str"",e);
  }
}",0.9898477157360406
19663,"/** 
 * Initializes this DataProcessor. This is typically called after the DataProcessor has been configured. 
 */
public void initialize(){
  this.timer=Timer.getTimer(name);
}","/** 
 * Initializes this DataProcessor. This is typically called after the DataProcessor has been configured. 
 */
public void initialize(){
  this.timer=TimerPool.getTimer(name);
}",0.988826815642458
19664,"public void statusChanged(RecognizerState status){
  if (status == RecognizerState.ALLOCATED) {
    if (showTimers) {
      Timer.dumpAll();
    }
  }
  if (status == RecognizerState.DEALLOCATING) {
    if (showTimers) {
      Timer.dumpAll();
    }
  }
  if (status == RecognizerState.DEALLOCATED) {
    if (showSummary) {
      showAudioSummary();
    }
  }
}","public void statusChanged(RecognizerState status){
  if (status == RecognizerState.ALLOCATED) {
    if (showTimers) {
      TimerPool.dumpAll();
    }
  }
  if (status == RecognizerState.DEALLOCATING) {
    if (showTimers) {
      TimerPool.dumpAll();
    }
  }
  if (status == RecognizerState.DEALLOCATED) {
    if (showSummary) {
      showAudioSummary();
    }
  }
}",0.989041095890411
19665,"/** 
 * initialize this acoustic model with the given name and context.
 * @throws IOException if the model could not be loaded
 */
public void allocate() throws IOException {
  if (!allocated) {
    this.loadTimer=Timer.getTimer(TIMER_LOAD);
    loadTimer.start();
    loader.load();
    loadTimer.stop();
    logInfo();
    allocated=true;
  }
}","/** 
 * initialize this acoustic model with the given name and context.
 * @throws IOException if the model could not be loaded
 */
public void allocate() throws IOException {
  if (!allocated) {
    this.loadTimer=TimerPool.getTimer(TIMER_LOAD);
    loadTimer.start();
    loader.load();
    loadTimer.stop();
    logInfo();
    allocated=true;
  }
}",0.994269340974212
19666,"public void allocate() throws IOException {
  logger.info(""String_Node_Str"");
  allocateAcousticModel();
  grammar.allocate();
  hmmPool=new HMMPool(acousticModel,logger,unitManager);
  nodeToNextUnitArrayMap=new HashMap<GrammarNode,int[]>();
  nodeToUnitSetMap=new HashMap<GrammarNode,Set<Unit>>();
  Timer timer=Timer.getTimer(""String_Node_Str"");
  timer.start();
  compileGrammar();
  timer.stop();
  logger.info(""String_Node_Str"");
}","public void allocate() throws IOException {
  logger.info(""String_Node_Str"");
  allocateAcousticModel();
  grammar.allocate();
  hmmPool=new HMMPool(acousticModel,logger,unitManager);
  nodeToNextUnitArrayMap=new HashMap<GrammarNode,int[]>();
  nodeToUnitSetMap=new HashMap<GrammarNode,Set<Unit>>();
  Timer timer=TimerPool.getTimer(""String_Node_Str"");
  timer.start();
  compileGrammar();
  timer.stop();
  logger.info(""String_Node_Str"");
}",0.9954441913439636
19667,"public void allocate() throws IOException {
  if (!allocated) {
    dictionary=new HashMap<String,Object>();
    Timer loadTimer=Timer.getTimer(""String_Node_Str"");
    fillerWords=new HashSet<String>();
    loadTimer.start();
    logger.info(""String_Node_Str"" + wordDictionaryFile);
    loadDictionary(wordDictionaryFile.openStream(),false);
    loadCustomDictionaries(addendaUrlList);
    logger.info(""String_Node_Str"" + fillerDictionaryFile);
    loadDictionary(fillerDictionaryFile.openStream(),true);
    loadTimer.stop();
  }
}","public void allocate() throws IOException {
  if (!allocated) {
    dictionary=new HashMap<String,Object>();
    Timer loadTimer=TimerPool.getTimer(""String_Node_Str"");
    fillerWords=new HashSet<String>();
    loadTimer.start();
    logger.info(""String_Node_Str"" + wordDictionaryFile);
    loadDictionary(wordDictionaryFile.openStream(),false);
    loadCustomDictionaries(addendaUrlList);
    logger.info(""String_Node_Str"" + fillerDictionaryFile);
    loadDictionary(fillerDictionaryFile.openStream(),true);
    loadTimer.stop();
  }
}",0.99625468164794
19668,"public void allocate() throws IOException {
  if (!allocated) {
    loadTimer=Timer.getTimer(""String_Node_Str"");
    loadTimer.start();
    logger.info(""String_Node_Str"" + wordDictionaryFile);
    wordDictionary=loadDictionary(wordDictionaryFile.openStream(),false);
    logger.info(""String_Node_Str"" + fillerDictionaryFile);
    fillerDictionary=loadDictionary(fillerDictionaryFile.openStream(),true);
    loadTimer.stop();
    allocated=true;
  }
}","public void allocate() throws IOException {
  if (!allocated) {
    loadTimer=TimerPool.getTimer(""String_Node_Str"");
    loadTimer.start();
    logger.info(""String_Node_Str"" + wordDictionaryFile);
    wordDictionary=loadDictionary(wordDictionaryFile.openStream(),false);
    logger.info(""String_Node_Str"" + fillerDictionaryFile);
    fillerDictionary=loadDictionary(fillerDictionaryFile.openStream(),true);
    loadTimer.stop();
    allocated=true;
  }
}",0.995575221238938
19669,"/** 
 * Create the grammar 
 */
public void allocate() throws IOException {
  dictionary.allocate();
  newGrammar();
  Timer timer=Timer.getTimer(""String_Node_Str"");
  timer.start();
  initialNode=createGrammar();
  postProcessGrammar();
  timer.stop();
}","/** 
 * Create the grammar 
 */
public void allocate() throws IOException {
  dictionary.allocate();
  newGrammar();
  Timer timer=TimerPool.getTimer(""String_Node_Str"");
  timer.start();
  initialNode=createGrammar();
  postProcessGrammar();
  timer.stop();
}",0.9922178988326849
19670,"/** 
 * Times the lingust
 * @param numRuns   the number of simulated runs
 * @param numFrames the number of simulated frames
 * @param maxBeam   the size of the beam
 */
public void timeLinguist(int numRuns,int numFrames,int maxBeam){
  Random random=new Random(1000);
  Timer frameTimer=Timer.getTimer(""String_Node_Str"");
  Timer totalTimer=Timer.getTimer(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + numRuns + ""String_Node_Str""+ numFrames+ ""String_Node_Str""+ maxBeam);
  totalTimer.start();
  for (int runs=0; runs < numRuns; runs++) {
    int level=0;
    List activeList=new ArrayList();
    activeList.add(linguist.getSearchGraph().getInitialState());
    linguist.startRecognition();
    for (int i=0; i < numFrames; i++) {
      List oldList=activeList;
      activeList=new ArrayList(maxBeam * 10);
      frameTimer.start();
      for (int j=0; j < oldList.size(); j++) {
        SearchState nextStates=(SearchState)oldList.get(j);
        expandState(level,activeList,nextStates);
      }
      frameTimer.stop();
      Collections.shuffle(activeList,random);
      if (activeList.size() > maxBeam) {
        activeList=activeList.subList(0,maxBeam);
      }
    }
    linguist.stopRecognition();
    frameTimer.dump();
  }
  totalTimer.stop();
  System.out.println(""String_Node_Str"" + maxSuccessors);
  System.out.println(""String_Node_Str"" + totalStates);
  System.out.println(""String_Node_Str"" + totalEmittingStates);
  System.out.println(""String_Node_Str"" + totalNonEmittingStates);
  System.out.println(""String_Node_Str"" + totalFinalStates);
  Timer.dumpAll();
}","/** 
 * Times the lingust
 * @param numRuns   the number of simulated runs
 * @param numFrames the number of simulated frames
 * @param maxBeam   the size of the beam
 */
public void timeLinguist(int numRuns,int numFrames,int maxBeam){
  Random random=new Random(1000);
  Timer frameTimer=TimerPool.getTimer(""String_Node_Str"");
  Timer totalTimer=TimerPool.getTimer(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + numRuns + ""String_Node_Str""+ numFrames+ ""String_Node_Str""+ maxBeam);
  totalTimer.start();
  for (int runs=0; runs < numRuns; runs++) {
    int level=0;
    List activeList=new ArrayList();
    activeList.add(linguist.getSearchGraph().getInitialState());
    linguist.startRecognition();
    for (int i=0; i < numFrames; i++) {
      List oldList=activeList;
      activeList=new ArrayList(maxBeam * 10);
      frameTimer.start();
      for (int j=0; j < oldList.size(); j++) {
        SearchState nextStates=(SearchState)oldList.get(j);
        expandState(level,activeList,nextStates);
      }
      frameTimer.stop();
      Collections.shuffle(activeList,random);
      if (activeList.size() > maxBeam) {
        activeList=activeList.subList(0,maxBeam);
      }
    }
    linguist.stopRecognition();
    frameTimer.dump();
  }
  totalTimer.stop();
  System.out.println(""String_Node_Str"" + maxSuccessors);
  System.out.println(""String_Node_Str"" + totalStates);
  System.out.println(""String_Node_Str"" + totalEmittingStates);
  System.out.println(""String_Node_Str"" + totalNonEmittingStates);
  System.out.println(""String_Node_Str"" + totalFinalStates);
  TimerPool.dumpAll();
}",0.9962453066332916
19671,"/** 
 * Detect gap insertion errors. 
 */
private int detectGapInsertionErrors() throws IOException {
  Timer gapTimer=Timer.getTimer(""String_Node_Str"");
  gapTimer.start();
  GapInsertionDetector gid=new GapInsertionDetector(dataSource.getTranscriptFile(),hypothesisFile,showGapInsertions);
  int gapInsertions=gid.detect();
  gapTimer.stop();
  return gapInsertions;
}","/** 
 * Detect gap insertion errors. 
 */
private int detectGapInsertionErrors() throws IOException {
  Timer gapTimer=TimerPool.getTimer(""String_Node_Str"");
  gapTimer.start();
  GapInsertionDetector gid=new GapInsertionDetector(dataSource.getTranscriptFile(),hypothesisFile,showGapInsertions);
  int gapInsertions=gid.detect();
  gapTimer.stop();
  return gapInsertions;
}",0.9946236559139784
19672,"/** 
 * Return the timer for alignment. 
 */
private Timer getAlignTimer(){
  return Timer.getTimer(""String_Node_Str"");
}","/** 
 * Return the timer for alignment. 
 */
private Timer getAlignTimer(){
  return TimerPool.getTimer(""String_Node_Str"");
}",0.983739837398374
19673,"public Data getData() throws DataProcessingException {
  Data d=getPredecessor().getData();
  if (isRecognizing && (d instanceof FloatData || d instanceof DoubleData || d instanceof SpeechEndSignal)) {
    result=decode(null);
    if (result != null) {
      fireResultListeners(result);
    }
  }
  if (d instanceof SpeechStartSignal) {
    searchManager.startRecognition();
    isRecognizing=true;
    result=null;
  }
  if (d instanceof SpeechEndSignal) {
    searchManager.stopRecognition();
    if (result != null)     fireResultListeners(result);
    isRecognizing=false;
  }
  return d;
}","public Data getData() throws DataProcessingException {
  Data d=getPredecessor().getData();
  if (isRecognizing && (d instanceof FloatData || d instanceof DoubleData || d instanceof SpeechEndSignal)) {
    result=decode(null);
    if (result != null) {
      fireResultListeners(result);
      result=null;
    }
  }
  if (d instanceof SpeechStartSignal) {
    searchManager.startRecognition();
    isRecognizing=true;
    result=null;
  }
  if (d instanceof SpeechEndSignal) {
    searchManager.stopRecognition();
    if (result != null)     fireResultListeners(result);
    isRecognizing=false;
  }
  return d;
}",0.9842845326716294
19674,"/** 
 * Constructs a DataStartSignal at the given time.
 * @param sampleRate  the sampling rate of the started data stream.
 * @param time        the time this DataStartSignal is created
 * @param tagAsVadStream <code>true</code> if this feature stream will contain vad-signals
 */
public DataStartSignal(int sampleRate,long time,boolean tagAsVadStream){
  super(time);
  this.sampleRate=sampleRate;
  if (tagAsVadStream) {
    this.getProps().put(VAD_TAGGED_FEAT_STREAM,null);
  }
}","/** 
 * Constructs a DataStartSignal at the given time.
 * @param sampleRate  the sampling rate of the started data stream.
 * @param time        the time this DataStartSignal is created
 * @param tagAsVadStream <code>true</code> if this feature stream will contain vad-signals
 */
public DataStartSignal(int sampleRate,long time,boolean tagAsVadStream){
  super(time);
  this.sampleRate=sampleRate;
  if (tagAsVadStream) {
    this.getProps().put(VAD_TAGGED_FEAT_STREAM,tagAsVadStream);
  }
}",0.9815573770491804
19675,"/** 
 * Main method for running the HelloDigits demo.
 */
public static void main(String[] args){
  int match=0;
  int noMatch=0;
  if (args.length != 2) {
    System.out.println(""String_Node_Str"");
    System.exit(0);
  }
  try {
    URL url=new File(args[0]).toURI().toURL();
    int count=Integer.parseInt(args[1]);
    ConfigurationManager cm=new ConfigurationManager(url);
    JSGFGrammar jsgfGrammar=(JSGFGrammar)cm.lookup(""String_Node_Str"");
    jsgfGrammar.allocate();
    RuleGrammar rg=jsgfGrammar.getRuleGrammar();
    for (int i=0; i < count; i++) {
      String sentence=jsgfGrammar.getRandomSentence();
      RuleParse rp=rg.parse(sentence,null);
      if (rp == null) {
        noMatch++;
        System.out.println(""String_Node_Str"" + sentence);
      }
 else {
        match++;
      }
    }
    System.out.println(""String_Node_Str"" + match + ""String_Node_Str""+ noMatch);
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
catch (  PropertyException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
catch (  InstantiationException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
catch (  GrammarException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
}","/** 
 * Main method for running the HelloDigits demo.
 */
public static void main(String[] args){
  int match=0;
  int noMatch=0;
  if (args.length != 2) {
    System.out.println(""String_Node_Str"");
    System.exit(0);
  }
  try {
    URL url=new File(args[0]).toURI().toURL();
    int count=Integer.parseInt(args[1]);
    ConfigurationManager cm=new ConfigurationManager(url);
    JSGFGrammar jsgfGrammar=(JSGFGrammar)cm.lookup(""String_Node_Str"");
    jsgfGrammar.allocate();
    RuleGrammar rg=jsgfGrammar.getRuleGrammar();
    for (int i=0; i < count; i++) {
      String sentence=jsgfGrammar.getRandomSentence();
      RuleParse rp=rg.parse(sentence,null);
      if (rp == null) {
        noMatch++;
        System.out.println(""String_Node_Str"" + sentence);
      }
 else {
        match++;
      }
    }
    System.out.println(""String_Node_Str"" + match + ""String_Node_Str""+ noMatch);
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
catch (  PropertyException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
catch (  GrammarException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
}",0.9499408750492708
19676,"/** 
 * Allocates this recognizer
 * @return
 */
boolean allocate(){
  try {
    if (!allocated) {
      URL url=new File(configName).toURI().toURL();
      cm=new ConfigurationManager(url);
      recognizer=(Recognizer)cm.lookup(""String_Node_Str"");
      microphone=(Microphone)cm.lookup(""String_Node_Str"");
      speedTracker=(SpeedTracker)cm.lookup(""String_Node_Str"");
      aligner=((AccuracyTracker)cm.lookup(""String_Node_Str"")).getAligner();
      recognizer.allocate();
      setTestFile(testFile);
      recognizer.addResultListener(new ResultListener(){
        public void newResult(        Result result){
          if (!result.isFinal() && showPartialResults) {
            showPartialResult(result);
          }
          if (result.isFinal()) {
            updateLiveFrame(currentRecognizer.getAligner());
            System.out.println(result.getBestToken().getWordUnitPath());
          }
        }
      }
);
      allocated=true;
    }
  }
 catch (  InstantiationException e) {
    warn(""String_Node_Str"" + configName + ""String_Node_Str""+ e);
  }
catch (  PropertyException pe) {
    warn(""String_Node_Str"" + pe);
  }
catch (  IOException ioe) {
    warn(""String_Node_Str"" + ioe);
  }
  return allocated;
}","/** 
 * Allocates this recognizer
 * @return
 */
boolean allocate(){
  try {
    if (!allocated) {
      URL url=new File(configName).toURI().toURL();
      cm=new ConfigurationManager(url);
      recognizer=(Recognizer)cm.lookup(""String_Node_Str"");
      microphone=(Microphone)cm.lookup(""String_Node_Str"");
      speedTracker=(SpeedTracker)cm.lookup(""String_Node_Str"");
      aligner=((AccuracyTracker)cm.lookup(""String_Node_Str"")).getAligner();
      recognizer.allocate();
      setTestFile(testFile);
      recognizer.addResultListener(new ResultListener(){
        public void newResult(        Result result){
          if (!result.isFinal() && showPartialResults) {
            showPartialResult(result);
          }
          if (result.isFinal()) {
            updateLiveFrame(currentRecognizer.getAligner());
            System.out.println(result.getBestToken().getWordUnitPath());
          }
        }
      }
);
      allocated=true;
    }
  }
 catch (  PropertyException pe) {
    warn(""String_Node_Str"" + pe);
  }
catch (  IOException ioe) {
    warn(""String_Node_Str"" + ioe);
  }
  return allocated;
}",0.9547395388556787
19677,"/** 
 * Main method for running the MAPConfidenceTest demo.
 */
public static void main(String[] args){
  try {
    String latticeGDL;
    if (args.length > 0) {
      latticeGDL=args[0];
    }
 else {
      latticeGDL=""String_Node_Str"";
    }
    URL configURL=new File(""String_Node_Str"").toURI().toURL();
    ConfigurationManager cm=new ConfigurationManager(configURL);
    LogMath logMath=(LogMath)cm.lookup(""String_Node_Str"");
    Dictionary dictionary=(Dictionary)cm.lookup(""String_Node_Str"");
    dictionary.allocate();
    Lattice lattice=GDLLatticeFactory.getLattice(latticeGDL,dictionary);
    lattice.setLogMath(logMath);
    lattice.dumpAISee(""String_Node_Str"",""String_Node_Str"");
    SausageMaker sm=new SausageMaker(lattice);
    Sausage s=sm.makeSausage();
    s.dumpAISee(""String_Node_Str"",""String_Node_Str"");
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
catch (  PropertyException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
catch (  InstantiationException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
}","/** 
 * Main method for running the MAPConfidenceTest demo.
 */
public static void main(String[] args){
  try {
    String latticeGDL;
    if (args.length > 0) {
      latticeGDL=args[0];
    }
 else {
      latticeGDL=""String_Node_Str"";
    }
    URL configURL=new File(""String_Node_Str"").toURI().toURL();
    ConfigurationManager cm=new ConfigurationManager(configURL);
    LogMath logMath=(LogMath)cm.lookup(""String_Node_Str"");
    Dictionary dictionary=(Dictionary)cm.lookup(""String_Node_Str"");
    dictionary.allocate();
    Lattice lattice=GDLLatticeFactory.getLattice(latticeGDL,dictionary);
    lattice.setLogMath(logMath);
    lattice.dumpAISee(""String_Node_Str"",""String_Node_Str"");
    SausageMaker sm=new SausageMaker(lattice);
    Sausage s=sm.makeSausage();
    s.dumpAISee(""String_Node_Str"",""String_Node_Str"");
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
catch (  PropertyException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
}",0.948519362186788
19678,"/** 
 * Main method for running the LatticeCompTest demo.
 */
public static void main(String[] args){
  try {
    URL audioFileURL;
    if (args.length > 0) {
      audioFileURL=new File(args[0]).toURI().toURL();
    }
 else {
      audioFileURL=new File(""String_Node_Str"").toURI().toURL();
    }
    URL configURL=new File(""String_Node_Str"").toURI().toURL();
    System.out.println(""String_Node_Str"");
    ConfigurationManager cm=new ConfigurationManager(configURL);
    Recognizer recognizer=(Recognizer)cm.lookup(""String_Node_Str"");
    StreamDataSource reader=(StreamDataSource)cm.lookup(""String_Node_Str"");
    AudioInputStream ais=AudioSystem.getAudioInputStream(audioFileURL);
    reader.setInputStream(ais,audioFileURL.getFile());
    recognizer.allocate();
    Result result=recognizer.recognize();
    System.out.println(""String_Node_Str"" + result.getBestFinalResultNoFiller() + ""String_Node_Str"");
    Lattice lattice=new Lattice(result);
    lattice.dumpAISee(""String_Node_Str"",""String_Node_Str"");
    URL allConfigURL=new File(""String_Node_Str"").toURI().toURL();
    System.out.println(""String_Node_Str"");
    ConfigurationManager allCM=new ConfigurationManager(allConfigURL);
    Recognizer allRecognizer=(Recognizer)allCM.lookup(""String_Node_Str"");
    allRecognizer.allocate();
    StreamDataSource allReader=(StreamDataSource)allCM.lookup(""String_Node_Str"");
    allReader.setInputStream(AudioSystem.getAudioInputStream(audioFileURL),audioFileURL.getFile());
    Result allResult=allRecognizer.recognize();
    System.out.println(""String_Node_Str"" + allResult.getBestFinalResultNoFiller() + ""String_Node_Str"");
    Lattice allLattice=new Lattice(allResult);
    allLattice.dumpAISee(""String_Node_Str"",""String_Node_Str"");
    if (lattice.isEquivalent(allLattice)) {
      System.out.println(""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"");
    }
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
catch (  PropertyException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
catch (  InstantiationException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
catch (  UnsupportedAudioFileException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
}","/** 
 * Main method for running the LatticeCompTest demo.
 */
public static void main(String[] args){
  try {
    URL audioFileURL;
    if (args.length > 0) {
      audioFileURL=new File(args[0]).toURI().toURL();
    }
 else {
      audioFileURL=new File(""String_Node_Str"").toURI().toURL();
    }
    URL configURL=new File(""String_Node_Str"").toURI().toURL();
    System.out.println(""String_Node_Str"");
    ConfigurationManager cm=new ConfigurationManager(configURL);
    Recognizer recognizer=(Recognizer)cm.lookup(""String_Node_Str"");
    StreamDataSource reader=(StreamDataSource)cm.lookup(""String_Node_Str"");
    AudioInputStream ais=AudioSystem.getAudioInputStream(audioFileURL);
    reader.setInputStream(ais,audioFileURL.getFile());
    recognizer.allocate();
    Result result=recognizer.recognize();
    System.out.println(""String_Node_Str"" + result.getBestFinalResultNoFiller() + ""String_Node_Str"");
    Lattice lattice=new Lattice(result);
    lattice.dumpAISee(""String_Node_Str"",""String_Node_Str"");
    URL allConfigURL=new File(""String_Node_Str"").toURI().toURL();
    System.out.println(""String_Node_Str"");
    ConfigurationManager allCM=new ConfigurationManager(allConfigURL);
    Recognizer allRecognizer=(Recognizer)allCM.lookup(""String_Node_Str"");
    allRecognizer.allocate();
    StreamDataSource allReader=(StreamDataSource)allCM.lookup(""String_Node_Str"");
    allReader.setInputStream(AudioSystem.getAudioInputStream(audioFileURL),audioFileURL.getFile());
    Result allResult=allRecognizer.recognize();
    System.out.println(""String_Node_Str"" + allResult.getBestFinalResultNoFiller() + ""String_Node_Str"");
    Lattice allLattice=new Lattice(allResult);
    allLattice.dumpAISee(""String_Node_Str"",""String_Node_Str"");
    if (lattice.isEquivalent(allLattice)) {
      System.out.println(""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"");
    }
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
catch (  PropertyException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
catch (  UnsupportedAudioFileException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
}",0.9665134602757716
19679,"/** 
 * Main method for running the LatticeDumpTest demo.
 */
public static void main(String[] args){
  try {
    URL audioFileURL;
    if (args.length > 0) {
      audioFileURL=new File(args[0]).toURI().toURL();
    }
 else {
      audioFileURL=new File(""String_Node_Str"").toURI().toURL();
    }
    URL configURL=new File(""String_Node_Str"").toURI().toURL();
    System.out.println(""String_Node_Str"");
    ConfigurationManager cm=new ConfigurationManager(configURL);
    Recognizer recognizer=(Recognizer)cm.lookup(""String_Node_Str"");
    recognizer.allocate();
    StreamDataSource reader=(StreamDataSource)cm.lookup(""String_Node_Str"");
    AudioInputStream ais=AudioSystem.getAudioInputStream(audioFileURL);
    reader.setInputStream(ais,audioFileURL.getFile());
    Result result=recognizer.recognize();
    if (result != null) {
      System.out.println(""String_Node_Str"" + result.getBestFinalResultNoFiller() + ""String_Node_Str"");
      Lattice lattice=new Lattice(result);
      LatticeOptimizer lo=new LatticeOptimizer(lattice);
      lo.optimize();
      lattice.dumpAISee(""String_Node_Str"",""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"");
    }
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
catch (  PropertyException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
catch (  InstantiationException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
catch (  UnsupportedAudioFileException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
}","/** 
 * Main method for running the LatticeDumpTest demo.
 */
public static void main(String[] args){
  try {
    URL audioFileURL;
    if (args.length > 0) {
      audioFileURL=new File(args[0]).toURI().toURL();
    }
 else {
      audioFileURL=new File(""String_Node_Str"").toURI().toURL();
    }
    URL configURL=new File(""String_Node_Str"").toURI().toURL();
    System.out.println(""String_Node_Str"");
    ConfigurationManager cm=new ConfigurationManager(configURL);
    Recognizer recognizer=(Recognizer)cm.lookup(""String_Node_Str"");
    recognizer.allocate();
    StreamDataSource reader=(StreamDataSource)cm.lookup(""String_Node_Str"");
    AudioInputStream ais=AudioSystem.getAudioInputStream(audioFileURL);
    reader.setInputStream(ais,audioFileURL.getFile());
    Result result=recognizer.recognize();
    if (result != null) {
      System.out.println(""String_Node_Str"" + result.getBestFinalResultNoFiller() + ""String_Node_Str"");
      Lattice lattice=new Lattice(result);
      LatticeOptimizer lo=new LatticeOptimizer(lattice);
      lo.optimize();
      lattice.dumpAISee(""String_Node_Str"",""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"");
    }
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
catch (  PropertyException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
catch (  UnsupportedAudioFileException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
}",0.9515055467511886
19680,"/** 
 * Main method for running the MAPConfidenceTest demo.
 */
public static void main(String[] args){
  try {
    URL configURL=new File(""String_Node_Str"").toURI().toURL();
    System.out.println(""String_Node_Str"");
    ConfigurationManager cm=new ConfigurationManager(configURL);
    Recognizer recognizer=(Recognizer)cm.lookup(""String_Node_Str"");
    recognizer.allocate();
    Microphone microphone=(Microphone)cm.lookup(""String_Node_Str"");
    if (microphone.startRecording()) {
      while (true) {
        Result result=recognizer.recognize();
        if (result != null) {
          System.out.println(""String_Node_Str"" + result.toString());
          ConfidenceScorer cs=(ConfidenceScorer)cm.lookup(""String_Node_Str"");
          ConfidenceResult cr=cs.score(result);
          Path best=cr.getBestHypothesis();
          WordResult[] words=best.getWords();
          for (int i=0; i < words.length; i++) {
            WordResult wr=words[i];
            System.out.println(wr.getPronunciation().getWord().getSpelling());
            System.out.println(""String_Node_Str"" + wr.getLogMath().logToLinear((float)wr.getConfidence()) + ""String_Node_Str"");
          }
          System.out.println();
          System.out.println(best.getTranscription());
          System.out.println(""String_Node_Str"" + best.getLogMath().logToLinear((float)best.getConfidence()) + ""String_Node_Str"");
          System.out.println();
        }
      }
    }
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
catch (  PropertyException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
catch (  InstantiationException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
}","/** 
 * Main method for running the MAPConfidenceTest demo.
 */
public static void main(String[] args){
  try {
    URL configURL=new File(""String_Node_Str"").toURI().toURL();
    System.out.println(""String_Node_Str"");
    ConfigurationManager cm=new ConfigurationManager(configURL);
    Recognizer recognizer=(Recognizer)cm.lookup(""String_Node_Str"");
    recognizer.allocate();
    Microphone microphone=(Microphone)cm.lookup(""String_Node_Str"");
    if (microphone.startRecording()) {
      while (true) {
        Result result=recognizer.recognize();
        if (result != null) {
          System.out.println(""String_Node_Str"" + result.toString());
          ConfidenceScorer cs=(ConfidenceScorer)cm.lookup(""String_Node_Str"");
          ConfidenceResult cr=cs.score(result);
          Path best=cr.getBestHypothesis();
          WordResult[] words=best.getWords();
          for (int i=0; i < words.length; i++) {
            WordResult wr=words[i];
            System.out.println(wr.getPronunciation().getWord().getSpelling());
            System.out.println(""String_Node_Str"" + wr.getLogMath().logToLinear((float)wr.getConfidence()) + ""String_Node_Str"");
          }
          System.out.println();
          System.out.println(best.getTranscription());
          System.out.println(""String_Node_Str"" + best.getLogMath().logToLinear((float)best.getConfidence()) + ""String_Node_Str"");
          System.out.println();
        }
      }
    }
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
catch (  PropertyException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
}",0.9670841829303816
19681,"/** 
 * Main method for running the MAPConfidenceTest demo.
 */
public static void main(String[] args){
  try {
    URL audioFileURL;
    if (args.length > 0) {
      audioFileURL=new File(args[0]).toURI().toURL();
    }
 else {
      audioFileURL=new File(""String_Node_Str"").toURI().toURL();
    }
    URL configURL=new File(""String_Node_Str"").toURI().toURL();
    System.out.println(""String_Node_Str"");
    ConfigurationManager cm=new ConfigurationManager(configURL);
    Recognizer recognizer=(Recognizer)cm.lookup(""String_Node_Str"");
    recognizer.allocate();
    StreamDataSource reader=(StreamDataSource)cm.lookup(""String_Node_Str"");
    reader.setInputStream(AudioSystem.getAudioInputStream(audioFileURL),audioFileURL.getFile());
    Result result=recognizer.recognize();
    if (result != null) {
      ConfidenceScorer cs=(ConfidenceScorer)cm.lookup(""String_Node_Str"");
      ConfidenceResult cr=cs.score(result);
      Path best=cr.getBestHypothesis();
      WordResult[] words=best.getWords();
      for (int i=0; i < words.length; i++) {
        WordResult wr=words[i];
        System.out.println(wr.getPronunciation().getWord().getSpelling());
        System.out.println(""String_Node_Str"" + wr.getLogMath().logToLinear((float)wr.getConfidence()) + ""String_Node_Str"");
      }
      System.out.println();
      System.out.println(best.getTranscription());
      System.out.println(""String_Node_Str"" + best.getLogMath().logToLinear((float)best.getConfidence()) + ""String_Node_Str"");
    }
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
catch (  PropertyException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
catch (  InstantiationException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
catch (  UnsupportedAudioFileException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
}","/** 
 * Main method for running the MAPConfidenceTest demo.
 */
public static void main(String[] args){
  try {
    URL audioFileURL;
    if (args.length > 0) {
      audioFileURL=new File(args[0]).toURI().toURL();
    }
 else {
      audioFileURL=new File(""String_Node_Str"").toURI().toURL();
    }
    URL configURL=new File(""String_Node_Str"").toURI().toURL();
    System.out.println(""String_Node_Str"");
    ConfigurationManager cm=new ConfigurationManager(configURL);
    Recognizer recognizer=(Recognizer)cm.lookup(""String_Node_Str"");
    recognizer.allocate();
    StreamDataSource reader=(StreamDataSource)cm.lookup(""String_Node_Str"");
    reader.setInputStream(AudioSystem.getAudioInputStream(audioFileURL),audioFileURL.getFile());
    Result result=recognizer.recognize();
    if (result != null) {
      ConfidenceScorer cs=(ConfidenceScorer)cm.lookup(""String_Node_Str"");
      ConfidenceResult cr=cs.score(result);
      Path best=cr.getBestHypothesis();
      WordResult[] words=best.getWords();
      for (int i=0; i < words.length; i++) {
        WordResult wr=words[i];
        System.out.println(wr.getPronunciation().getWord().getSpelling());
        System.out.println(""String_Node_Str"" + wr.getLogMath().logToLinear((float)wr.getConfidence()) + ""String_Node_Str"");
      }
      System.out.println();
      System.out.println(best.getTranscription());
      System.out.println(""String_Node_Str"" + best.getLogMath().logToLinear((float)best.getConfidence()) + ""String_Node_Str"");
    }
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
catch (  PropertyException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
catch (  UnsupportedAudioFileException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
}",0.9595986268814364
19682,"public static void main(String[] argv){
  try {
    URL configURL=new File(""String_Node_Str"").toURI().toURL();
    ConfigurationManager cm=new ConfigurationManager(configURL);
    LogMath logMath=(LogMath)cm.lookup(""String_Node_Str"");
    Lattice lattice=new Lattice(logMath);
    Node a=lattice.addNode(""String_Node_Str"",0,0);
    Node b=lattice.addNode(""String_Node_Str"",0,0);
    Node c=lattice.addNode(""String_Node_Str"",0,0);
    Node d=lattice.addNode(""String_Node_Str"",0,0);
    double acousticAB=4;
    double acousticAC=6;
    double acousticCB=1;
    double acousticBD=5;
    double acousticCD=2;
    lattice.setInitialNode(a);
    lattice.setTerminalNode(d);
    lattice.addEdge(a,b,logMath.linearToLog(acousticAB),0);
    lattice.addEdge(a,c,logMath.linearToLog(acousticAC),0);
    lattice.addEdge(c,b,logMath.linearToLog(acousticCB),0);
    lattice.addEdge(b,d,logMath.linearToLog(acousticBD),0);
    lattice.addEdge(c,d,logMath.linearToLog(acousticCD),0);
    lattice.computeNodePosteriors(1.0f);
    double pathABD=acousticAB * acousticBD;
    double pathACBD=acousticAC * acousticCB * acousticBD;
    double pathACD=acousticAC * acousticCD;
    double allPaths=pathABD + pathACBD + pathACD;
    double bPosterior=(pathABD + pathACBD) / allPaths;
    double cPosterior=(pathACBD + pathACD) / allPaths;
    System.out.println(""String_Node_Str"" + logMath.logToLinear((float)a.getPosterior()) + ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + logMath.logToLinear((float)b.getPosterior()) + ""String_Node_Str""+ bPosterior+ ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + logMath.logToLinear((float)c.getPosterior()) + ""String_Node_Str""+ cPosterior+ ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + logMath.logToLinear((float)d.getPosterior()) + ""String_Node_Str"");
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
catch (  PropertyException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
catch (  InstantiationException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
}","public static void main(String[] argv){
  try {
    URL configURL=new File(""String_Node_Str"").toURI().toURL();
    ConfigurationManager cm=new ConfigurationManager(configURL);
    LogMath logMath=(LogMath)cm.lookup(""String_Node_Str"");
    Lattice lattice=new Lattice(logMath);
    Node a=lattice.addNode(""String_Node_Str"",0,0);
    Node b=lattice.addNode(""String_Node_Str"",0,0);
    Node c=lattice.addNode(""String_Node_Str"",0,0);
    Node d=lattice.addNode(""String_Node_Str"",0,0);
    double acousticAB=4;
    double acousticAC=6;
    double acousticCB=1;
    double acousticBD=5;
    double acousticCD=2;
    lattice.setInitialNode(a);
    lattice.setTerminalNode(d);
    lattice.addEdge(a,b,logMath.linearToLog(acousticAB),0);
    lattice.addEdge(a,c,logMath.linearToLog(acousticAC),0);
    lattice.addEdge(c,b,logMath.linearToLog(acousticCB),0);
    lattice.addEdge(b,d,logMath.linearToLog(acousticBD),0);
    lattice.addEdge(c,d,logMath.linearToLog(acousticCD),0);
    lattice.computeNodePosteriors(1.0f);
    double pathABD=acousticAB * acousticBD;
    double pathACBD=acousticAC * acousticCB * acousticBD;
    double pathACD=acousticAC * acousticCD;
    double allPaths=pathABD + pathACBD + pathACD;
    double bPosterior=(pathABD + pathACBD) / allPaths;
    double cPosterior=(pathACBD + pathACD) / allPaths;
    System.out.println(""String_Node_Str"" + logMath.logToLinear((float)a.getPosterior()) + ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + logMath.logToLinear((float)b.getPosterior()) + ""String_Node_Str""+ bPosterior+ ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + logMath.logToLinear((float)c.getPosterior()) + ""String_Node_Str""+ cPosterior+ ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + logMath.logToLinear((float)d.getPosterior()) + ""String_Node_Str"");
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
catch (  PropertyException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
}",0.972972972972973
19683,"/** 
 * Main method for running the LatticeDumpTest demo.
 */
public static void main(String[] args){
  try {
    URL audioFileURL;
    if (args.length > 0) {
      audioFileURL=new File(args[0]).toURI().toURL();
    }
 else {
      audioFileURL=new File(""String_Node_Str"").toURI().toURL();
    }
    URL configURL=new File(""String_Node_Str"").toURI().toURL();
    System.out.println(""String_Node_Str"");
    ConfigurationManager cm=new ConfigurationManager(configURL);
    Recognizer recognizer=(Recognizer)cm.lookup(""String_Node_Str"");
    recognizer.allocate();
    StreamDataSource reader=(StreamDataSource)cm.lookup(""String_Node_Str"");
    reader.setInputStream(AudioSystem.getAudioInputStream(audioFileURL),audioFileURL.getFile());
    Result result=recognizer.recognize();
    if (result != null) {
      System.out.println(""String_Node_Str"" + result.getBestFinalResultNoFiller() + ""String_Node_Str"");
      Lattice lattice=new Lattice(result);
      LatticeOptimizer lo=new LatticeOptimizer(lattice);
      lo.optimize();
      lattice.dumpAISee(""String_Node_Str"",""String_Node_Str"");
      float lmw=(float)7.0;
      try {
        lmw=cm.getPropertySheet(""String_Node_Str"").getFloat(""String_Node_Str"",(float)7.0);
      }
 catch (      PropertyException e1) {
        System.err.println(""String_Node_Str"" + lmw);
      }
      lattice.computeNodePosteriors(lmw);
      try {
        SausageMaker sm=new SausageMaker(lattice);
        Sausage sausage=sm.makeSausage();
        System.out.println(""String_Node_Str"" + sausage.getBestHypothesisString() + ""String_Node_Str"");
        sausage.dumpAISee(""String_Node_Str"",""String_Node_Str"");
        System.out.println(""String_Node_Str"");
      }
 catch (      Exception e) {
        System.err.println(""String_Node_Str"");
        e.printStackTrace();
      }
    }
 else {
      System.out.println(""String_Node_Str"");
    }
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
catch (  PropertyException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
catch (  InstantiationException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
catch (  UnsupportedAudioFileException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
}","/** 
 * Main method for running the LatticeDumpTest demo.
 */
public static void main(String[] args){
  try {
    URL audioFileURL;
    if (args.length > 0) {
      audioFileURL=new File(args[0]).toURI().toURL();
    }
 else {
      audioFileURL=new File(""String_Node_Str"").toURI().toURL();
    }
    URL configURL=new File(""String_Node_Str"").toURI().toURL();
    System.out.println(""String_Node_Str"");
    ConfigurationManager cm=new ConfigurationManager(configURL);
    Recognizer recognizer=(Recognizer)cm.lookup(""String_Node_Str"");
    recognizer.allocate();
    StreamDataSource reader=(StreamDataSource)cm.lookup(""String_Node_Str"");
    reader.setInputStream(AudioSystem.getAudioInputStream(audioFileURL),audioFileURL.getFile());
    Result result=recognizer.recognize();
    if (result != null) {
      System.out.println(""String_Node_Str"" + result.getBestFinalResultNoFiller() + ""String_Node_Str"");
      Lattice lattice=new Lattice(result);
      LatticeOptimizer lo=new LatticeOptimizer(lattice);
      lo.optimize();
      lattice.dumpAISee(""String_Node_Str"",""String_Node_Str"");
      float lmw=(float)7.0;
      try {
        lmw=cm.getPropertySheet(""String_Node_Str"").getFloat(""String_Node_Str"");
      }
 catch (      PropertyException e1) {
        System.err.println(""String_Node_Str"" + lmw);
      }
      lattice.computeNodePosteriors(lmw);
      try {
        SausageMaker sm=new SausageMaker(lattice);
        Sausage sausage=sm.makeSausage();
        System.out.println(""String_Node_Str"" + sausage.getBestHypothesisString() + ""String_Node_Str"");
        sausage.dumpAISee(""String_Node_Str"",""String_Node_Str"");
        System.out.println(""String_Node_Str"");
      }
 catch (      Exception e) {
        System.err.println(""String_Node_Str"");
        e.printStackTrace();
      }
    }
 else {
      System.out.println(""String_Node_Str"");
    }
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
catch (  PropertyException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
catch (  UnsupportedAudioFileException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
}",0.9637488947833776
19684,"/** 
 * Main method for running the TokenGraphDumpTest demo.
 */
public static void main(String[] args){
  try {
    URL audioFileURL;
    if (args.length > 0) {
      audioFileURL=new File(args[0]).toURI().toURL();
    }
 else {
      audioFileURL=new File(""String_Node_Str"").toURI().toURL();
    }
    URL configURL=new File(""String_Node_Str"").toURI().toURL();
    System.out.println(""String_Node_Str"");
    ConfigurationManager cm=new ConfigurationManager(configURL);
    Recognizer recognizer=(Recognizer)cm.lookup(""String_Node_Str"");
    recognizer.allocate();
    StreamDataSource reader=(StreamDataSource)cm.lookup(""String_Node_Str"");
    AudioInputStream ais=AudioSystem.getAudioInputStream(audioFileURL);
    reader.setInputStream(ais,audioFileURL.getFile());
    Result result=recognizer.recognize();
    if (result != null) {
      System.out.println(""String_Node_Str"" + result.getBestFinalResultNoFiller() + ""String_Node_Str"");
      TokenGraphDumper dumper=new TokenGraphDumper(result);
      dumper.dumpGDL(""String_Node_Str"",""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"");
    }
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
catch (  PropertyException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
catch (  InstantiationException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
catch (  UnsupportedAudioFileException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
}","/** 
 * Main method for running the TokenGraphDumpTest demo.
 */
public static void main(String[] args){
  try {
    URL audioFileURL;
    if (args.length > 0) {
      audioFileURL=new File(args[0]).toURI().toURL();
    }
 else {
      audioFileURL=new File(""String_Node_Str"").toURI().toURL();
    }
    URL configURL=new File(""String_Node_Str"").toURI().toURL();
    System.out.println(""String_Node_Str"");
    ConfigurationManager cm=new ConfigurationManager(configURL);
    Recognizer recognizer=(Recognizer)cm.lookup(""String_Node_Str"");
    recognizer.allocate();
    StreamDataSource reader=(StreamDataSource)cm.lookup(""String_Node_Str"");
    AudioInputStream ais=AudioSystem.getAudioInputStream(audioFileURL);
    reader.setInputStream(ais,audioFileURL.getFile());
    Result result=recognizer.recognize();
    if (result != null) {
      System.out.println(""String_Node_Str"" + result.getBestFinalResultNoFiller() + ""String_Node_Str"");
      TokenGraphDumper dumper=new TokenGraphDumper(result);
      dumper.dumpGDL(""String_Node_Str"",""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"");
    }
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
catch (  PropertyException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
catch (  UnsupportedAudioFileException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
}",0.9495548961424332
19685,"/** 
 * Creates a ReferenceUtterance from the given line of reference.
 * @param line the line of reference, in the format: [test_name] [category] [speaker_name|""inter_segment_gap""][start_time] [end_time] [<params>] [reference_text]
 */
ReferenceUtterance(String line){
  StringTokenizer st=new StringTokenizer(line);
  st.nextToken();
  st.nextToken();
  String type=st.nextToken();
  if (type.equals(""String_Node_Str"")) {
    isSilenceGap=true;
  }
  startTime=Float.parseFloat(st.nextToken());
  endTime=Float.parseFloat(st.nextToken());
  st.nextToken();
  words=new String[st.countTokens()];
  for (int i=0; i < words.length; i++) {
    words[i]=st.nextToken();
  }
}","/** 
 * Creates a ReferenceUtterance from the given line of reference.
 * @param line the line of reference, in the format: [test_name] [category] [speaker_name|""inter_segment_gap""][start_time] [end_time] [<params>] [reference_text]
 */
ReferenceUtterance(String line){
  StringTokenizer st=new StringTokenizer(line);
  st.nextToken();
  st.nextToken();
  String type=st.nextToken();
  if (type.equals(""String_Node_Str"")) {
    isSilenceGap=true;
  }
  startTime=Float.parseFloat(st.nextToken());
  endTime=Float.parseFloat(st.nextToken());
  if (st.hasMoreTokens()) {
    st.nextToken();
    words=new String[st.countTokens()];
    for (int i=0; i < words.length; i++) {
      words[i]=st.nextToken();
    }
  }
 else {
    words=new String[0];
  }
}",0.944483485593816
19686,"public Data getData() throws DataProcessingException {
  Data d=getPredecessor().getData();
  if (isRecognizing && (d instanceof FloatData || d instanceof DoubleData)) {
    result=decode(null);
    if (result != null && result.isFinal()) {
      fireResultListeners(result);
      result=null;
    }
  }
  if (d instanceof SpeechStartSignal) {
    searchManager.startRecognition();
    isRecognizing=true;
    result=null;
  }
  if (d instanceof SpeechEndSignal) {
    searchManager.stopRecognition();
    if (result != null)     fireResultListeners(result);
    isRecognizing=false;
  }
  return d;
}","public Data getData() throws DataProcessingException {
  Data d=getPredecessor().getData();
  if (isRecognizing && (d instanceof FloatData || d instanceof DoubleData || d instanceof SpeechEndSignal)) {
    result=decode(null);
    if (result != null) {
      if (result.isFinal()) {
        fireResultListeners(result);
        result=null;
      }
    }
  }
  if (d instanceof SpeechStartSignal) {
    searchManager.startRecognition();
    isRecognizing=true;
    result=null;
  }
  if (d instanceof SpeechEndSignal) {
    searchManager.stopRecognition();
    if (result != null)     fireResultListeners(result);
    isRecognizing=false;
  }
  return d;
}",0.724960254372019
19687,"public void startRecognition(){
  int debugCounter=0;
  Data data;
  while (!((data=frontEnd.getData()) instanceof SpeechStartSignal) && !(data instanceof DataEndSignal) && useStreamSignals) {
    debugCounter++;
    if (debugCounter > 100) {
      debugCounter=0;
      logger.finer(""String_Node_Str"");
    }
  }
}","public void startRecognition(){
  int debugCounter=0;
  Data data=frontEnd.getData();
  if (!useStreamSignals)   return;
  while (!(data instanceof SpeechStartSignal) && !(data instanceof DataEndSignal)) {
    data=frontEnd.getData();
    if (data == null)     throw new RuntimeException(""String_Node_Str"");
    debugCounter++;
    if (debugCounter > 100) {
      debugCounter=0;
      logger.finer(""String_Node_Str"");
    }
  }
}",0.7194630872483222
19688,"/** 
 * Calculate the acoustic scores for the active list. The active list should contain only emitting tokens.
 * @return <code>true</code> if there are more frames to score, otherwise, false
 */
protected boolean scoreTokens(){
  boolean moreTokens;
  scoreTimer.start();
  Token bestToken=(Token)scorer.calculateScores(activeList.getTokens());
  scoreTimer.stop();
  moreTokens=(bestToken != null);
  activeList.setBestToken(bestToken);
  curTokensScored.value+=activeList.size();
  totalTokensScored.value+=activeList.size();
  tokensPerSecond.value=totalTokensScored.value / getTotalTime();
  return moreTokens;
}","/** 
 * Calculate the acoustic scores for the active list. The active list should contain only emitting tokens.
 * @return <code>true</code> if there are more frames to score, otherwise, false
 */
protected boolean scoreTokens(){
  boolean isDone=false;
  scoreTimer.start();
  Token bestToken=(Token)scorer.calculateScores(activeList.getTokens());
  scoreTimer.stop();
  if (bestToken != null) {
    isDone=true;
    activeList.setBestToken(bestToken);
  }
  curTokensScored.value+=activeList.size();
  totalTokensScored.value+=activeList.size();
  tokensPerSecond.value=totalTokensScored.value / getTotalTime();
  return isDone;
}",0.7856
19689,"/** 
 * Configure the logger 
 */
public static void configureLogger(ConfigurationManager cm){
  if (wasLogConfigured)   return;
  wasLogConfigured=true;
  if (System.getProperty(""String_Node_Str"") != null || System.getProperty(""String_Node_Str"") != null) {
    return;
  }
  Logger rootLogger=Logger.getLogger(""String_Node_Str"");
  Level rootLevel=rootLogger.getLevel();
  LogManager logManager=LogManager.getLogManager();
  ByteArrayOutputStream bos=new ByteArrayOutputStream();
  Properties props=new Properties();
  props.setProperty(""String_Node_Str"",""String_Node_Str"");
  props.setProperty(""String_Node_Str"",""String_Node_Str"");
  props.setProperty(""String_Node_Str"",""String_Node_Str"");
  props.setProperty(""String_Node_Str"",""String_Node_Str"");
  try {
    props.store(bos,""String_Node_Str"");
    bos.close();
    ByteArrayInputStream bis=new ByteArrayInputStream(bos.toByteArray());
    logManager.readConfiguration(bis);
    bis.close();
  }
 catch (  IOException ioe) {
    System.err.println(""String_Node_Str"");
  }
  String level=cm.getGlobalProperty(GLOBAL_COMMON_LOGLEVEL);
  if (level == null)   level=Level.WARNING.getName();
  Level userLevel=Level.parse(level);
  Level newLevel=userLevel.intValue() < rootLevel.intValue() ? userLevel : rootLevel;
  rootLogger.setLevel(newLevel);
  Handler[] handlers=rootLogger.getHandlers();
  for (  Handler handler : handlers) {
    handler.setFormatter(new SphinxLogFormatter());
  }
}","/** 
 * Configure the logger 
 */
public static void configureLogger(ConfigurationManager cm){
  if (wasLogConfigured)   return;
  wasLogConfigured=true;
  if (System.getProperty(""String_Node_Str"") != null || System.getProperty(""String_Node_Str"") != null) {
    return;
  }
  String cmPrefix=getLogPrefix(cm);
  Logger cmRootLogger=Logger.getLogger(cmPrefix.substring(0,cmPrefix.length() - 1));
  Level rootLevel=Logger.getLogger(""String_Node_Str"").getLevel();
  LogManager logManager=LogManager.getLogManager();
  ByteArrayOutputStream bos=new ByteArrayOutputStream();
  Properties props=new Properties();
  props.setProperty(""String_Node_Str"",""String_Node_Str"");
  props.setProperty(""String_Node_Str"",""String_Node_Str"");
  props.setProperty(""String_Node_Str"",""String_Node_Str"");
  props.setProperty(""String_Node_Str"",""String_Node_Str"");
  try {
    props.store(bos,""String_Node_Str"");
    bos.close();
    ByteArrayInputStream bis=new ByteArrayInputStream(bos.toByteArray());
    logManager.readConfiguration(bis);
    bis.close();
  }
 catch (  IOException ioe) {
    System.err.println(""String_Node_Str"");
  }
  String level=cm.getGlobalProperty(GLOBAL_COMMON_LOGLEVEL);
  if (level == null)   level=Level.WARNING.getName();
  cmRootLogger.setLevel(Level.parse(level));
  Handler[] handlers=cmRootLogger.getHandlers();
  for (  Handler handler : handlers) {
    handler.setFormatter(new SphinxLogFormatter());
  }
  Logger.getLogger(""String_Node_Str"").setLevel(rootLevel);
}",0.8498971898560658
19690,"/** 
 * Returns a logger to use for this configurable component. The logger can be configured with the property: 'logLevel' - The default logLevel value is defined (within the xml configuration file by the global property 'defaultLogLevel' (which defaults to WARNING). <p/> implementation note: the logger became configured within the constructor of the parenting configuration manager.
 * @return the logger for this component
 * @throws edu.cmu.sphinx.util.props.PropertyException if an error occurs
 */
public Logger getLogger(){
  Logger logger;
  if (instanceName != null) {
    logger=Logger.getLogger(ownerClass.getName() + ""String_Node_Str"" + instanceName);
  }
 else   logger=Logger.getLogger(ownerClass.getName());
  Object rawLogLevel=rawProps.get(COMP_LOG_LEVEL);
  if (rawLogLevel != null)   logger.setLevel(rawLogLevel instanceof String ? Level.parse((String)rawLogLevel) : (Level)rawLogLevel);
  return logger;
}","/** 
 * Returns a logger to use for this configurable component. The logger can be configured with the property: 'logLevel' - The default logLevel value is defined (within the xml configuration file by the global property 'defaultLogLevel' (which defaults to WARNING). <p/> implementation note: the logger became configured within the constructor of the parenting configuration manager.
 * @return the logger for this component
 * @throws edu.cmu.sphinx.util.props.PropertyException if an error occurs
 */
public Logger getLogger(){
  Logger logger;
  String baseName=ConfigurationManagerUtils.getLogPrefix(cm) + ownerClass.getName();
  if (instanceName != null) {
    logger=Logger.getLogger(baseName + ""String_Node_Str"" + instanceName);
  }
 else   logger=Logger.getLogger(baseName);
  Object rawLogLevel=rawProps.get(COMP_LOG_LEVEL);
  if (rawLogLevel != null)   logger.setLevel(rawLogLevel instanceof String ? Level.parse((String)rawLogLevel) : (Level)rawLogLevel);
  return logger;
}",0.9347258485639688
19691,"/** 
 * Main method for running the Lattice demo. 
 */
public static void main(String[] args){
  try {
    URL audioURL;
    if (args.length > 0) {
      audioURL=new File(args[0]).toURI().toURL();
    }
 else {
      audioURL=LatticeDemo.class.getResource(""String_Node_Str"");
    }
    URL url;
    if (args.length > 0) {
      url=new File(args[0]).toURI().toURL();
    }
 else {
      url=LatticeDemo.class.getResource(""String_Node_Str"");
    }
    System.out.println(""String_Node_Str"");
    ConfigurationManager cm=new ConfigurationManager(url);
    Recognizer recognizer=(Recognizer)cm.lookup(""String_Node_Str"");
    recognizer.allocate();
    AudioInputStream ais=AudioSystem.getAudioInputStream(audioURL);
    StreamDataSource reader=(StreamDataSource)cm.lookup(""String_Node_Str"");
    reader.setInputStream(ais,audioURL.getFile());
    boolean done=false;
    while (!done) {
      Result result=recognizer.recognize();
      if (result != null) {
        Lattice lattice=new Lattice(result);
        LatticeOptimizer optimizer=new LatticeOptimizer(lattice);
        optimizer.optimize();
        lattice.dumpAllPaths();
        String resultText=result.getBestResultNoFiller();
        System.out.println(""String_Node_Str"" + resultText + ""String_Node_Str"");
      }
 else {
        done=true;
      }
    }
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
catch (  PropertyException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
catch (  UnsupportedAudioFileException e) {
    System.err.println(""String_Node_Str"");
    e.printStackTrace();
  }
}","/** 
 * Main method for running the Lattice demo. 
 */
public static void main(String[] args){
  try {
    URL audioURL;
    if (args.length > 0) {
      audioURL=new File(args[0]).toURI().toURL();
    }
 else {
      audioURL=LatticeDemo.class.getResource(""String_Node_Str"");
    }
    URL url;
    if (args.length > 0) {
      url=new File(args[0]).toURI().toURL();
    }
 else {
      url=LatticeDemo.class.getResource(""String_Node_Str"");
    }
    System.out.println(""String_Node_Str"");
    ConfigurationManager cm=new ConfigurationManager(url);
    Recognizer recognizer=(Recognizer)cm.lookup(""String_Node_Str"");
    recognizer.allocate();
    AudioInputStream ais=AudioSystem.getAudioInputStream(audioURL);
    StreamDataSource reader=(StreamDataSource)cm.lookup(""String_Node_Str"");
    reader.setInputStream(ais,audioURL.getFile());
    boolean done=false;
    while (!done) {
      Result result=recognizer.recognize();
      if (result != null) {
        Lattice lattice=new Lattice(result);
        LatticeOptimizer optimizer=new LatticeOptimizer(lattice);
        optimizer.optimize();
        lattice.dumpAllPaths();
        String resultText=result.getBestResultNoFiller();
        System.out.println(""String_Node_Str"" + resultText + ""String_Node_Str"");
      }
 else {
        done=true;
      }
    }
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"" + e);
    throw new RuntimeException(e);
  }
catch (  PropertyException e) {
    System.err.println(""String_Node_Str"" + e);
    throw new RuntimeException(e);
  }
catch (  UnsupportedAudioFileException e) {
    System.err.println(""String_Node_Str"");
    throw new RuntimeException(e);
  }
}",0.9380637402285028
19692,"/** 
 * Main method for running the HelloDigits demo. 
 */
public static void main(String[] args){
  try {
    URL audioURL;
    if (args.length > 0) {
      audioURL=new File(args[0]).toURI().toURL();
    }
 else {
      audioURL=Transcriber.class.getResource(""String_Node_Str"");
    }
    URL configURL=Transcriber.class.getResource(""String_Node_Str"");
    ConfigurationManager cm=new ConfigurationManager(configURL);
    Recognizer recognizer=(Recognizer)cm.lookup(""String_Node_Str"");
    recognizer.allocate();
    AudioInputStream ais=AudioSystem.getAudioInputStream(audioURL);
    StreamDataSource reader=(StreamDataSource)cm.lookup(""String_Node_Str"");
    reader.setInputStream(ais,audioURL.getFile());
    boolean done=false;
    while (!done) {
      Result result=recognizer.recognize();
      if (result != null) {
        String resultText=result.getBestResultNoFiller();
        System.out.println(resultText);
      }
 else {
        done=true;
      }
    }
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
catch (  PropertyException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
catch (  UnsupportedAudioFileException e) {
    System.err.println(""String_Node_Str"");
    e.printStackTrace();
  }
}","/** 
 * Main method for running the HelloDigits demo. 
 */
public static void main(String[] args){
  try {
    URL audioURL;
    if (args.length > 0) {
      audioURL=new File(args[0]).toURI().toURL();
    }
 else {
      audioURL=Transcriber.class.getResource(""String_Node_Str"");
    }
    URL configURL=Transcriber.class.getResource(""String_Node_Str"");
    ConfigurationManager cm=new ConfigurationManager(configURL);
    Recognizer recognizer=(Recognizer)cm.lookup(""String_Node_Str"");
    recognizer.allocate();
    AudioInputStream ais=AudioSystem.getAudioInputStream(audioURL);
    StreamDataSource reader=(StreamDataSource)cm.lookup(""String_Node_Str"");
    reader.setInputStream(ais,audioURL.getFile());
    boolean done=false;
    while (!done) {
      Result result=recognizer.recognize();
      if (result != null) {
        String resultText=result.getBestResultNoFiller();
        System.out.println(resultText);
        unitTestBuffer.add(result);
      }
 else {
        done=true;
      }
    }
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"" + e);
    throw new RuntimeException(e);
  }
catch (  PropertyException e) {
    System.err.println(""String_Node_Str"" + e);
    throw new RuntimeException(e);
  }
catch (  UnsupportedAudioFileException e) {
    System.err.println(""String_Node_Str"");
    throw new RuntimeException(e);
  }
}",0.9095665171898356
19693,"/** 
 * Converts this demo into a unit-test. 
 */
@Test public void testLatticeDemo(){
  try {
    main(new String[]{});
  }
 catch (  Throwable t) {
    Assert.fail();
  }
}","/** 
 * Converts this demo into a unit-test. 
 */
@Test public void testLatticeDemo(){
  try {
    Transcriber.main(new String[]{});
  }
 catch (  Throwable t) {
    Assert.fail();
  }
  List<String> expResults=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Assert.assertTrue(unitTestBuffer.size() == expResults.size());
  for (int i=0; i < expResults.size(); i++) {
    String recogResult=unitTestBuffer.get(i).getBestResultNoFiller();
    Assert.assertEquals(expResults.get(i),recogResult);
  }
}",0.4992826398852223
19694,"/** 
 * Main method for running the WavFile demo. 
 */
public static void main(String[] args){
  try {
    URL audioFileURL;
    if (args.length > 0) {
      audioFileURL=new File(args[0]).toURI().toURL();
    }
 else {
      audioFileURL=WavFile.class.getResource(""String_Node_Str"");
    }
    URL configURL=WavFile.class.getResource(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    ConfigurationManager cm=new ConfigurationManager(configURL);
    Recognizer recognizer=(Recognizer)cm.lookup(""String_Node_Str"");
    recognizer.allocate();
    System.out.println(""String_Node_Str"" + audioFileURL.getFile());
    System.out.println(AudioSystem.getAudioFileFormat(audioFileURL));
    StreamDataSource reader=(StreamDataSource)cm.lookup(""String_Node_Str"");
    AudioInputStream ais=AudioSystem.getAudioInputStream(audioFileURL);
    reader.setInputStream(ais,audioFileURL.getFile());
    Result result=recognizer.recognize();
    if (result != null) {
      System.out.println(""String_Node_Str"" + result.getBestFinalResultNoFiller() + ""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"");
    }
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
catch (  PropertyException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
catch (  UnsupportedAudioFileException e) {
    System.err.println(""String_Node_Str"" + e);
    e.printStackTrace();
  }
}","/** 
 * Main method for running the WavFile demo. 
 */
public static void main(String[] args){
  try {
    URL audioFileURL;
    if (args.length > 0) {
      audioFileURL=new File(args[0]).toURI().toURL();
    }
 else {
      audioFileURL=WavFile.class.getResource(""String_Node_Str"");
    }
    URL configURL=WavFile.class.getResource(""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    ConfigurationManager cm=new ConfigurationManager(configURL);
    Recognizer recognizer=(Recognizer)cm.lookup(""String_Node_Str"");
    recognizer.allocate();
    System.out.println(""String_Node_Str"" + audioFileURL.getFile());
    System.out.println(AudioSystem.getAudioFileFormat(audioFileURL));
    StreamDataSource reader=(StreamDataSource)cm.lookup(""String_Node_Str"");
    AudioInputStream ais=AudioSystem.getAudioInputStream(audioFileURL);
    reader.setInputStream(ais,audioFileURL.getFile());
    result=recognizer.recognize();
    if (result != null) {
      System.out.println(""String_Node_Str"" + result.getBestFinalResultNoFiller() + ""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"");
    }
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"" + e);
    throw new RuntimeException(e);
  }
catch (  PropertyException e) {
    System.err.println(""String_Node_Str"" + e);
    throw new RuntimeException(e);
  }
catch (  UnsupportedAudioFileException e) {
    System.err.println(""String_Node_Str"" + e);
    throw new RuntimeException(e);
  }
}",0.9281618887015176
19695,"/** 
 * Converts this demo into a unit-test. 
 */
@Test public void testLatticeDemo(){
  try {
    main(new String[]{});
  }
 catch (  Throwable t) {
    Assert.fail();
  }
}","/** 
 * Converts this demo into a unit-test. 
 */
@Test public void testLatticeDemo(){
  try {
    WavFile.main(new String[]{});
  }
 catch (  Throwable t) {
    Assert.fail();
  }
  Assert.assertNotNull(result);
  Assert.assertTrue(result.getBestResultNoFiller().equals(""String_Node_Str""));
}",0.7408993576017131
19696,"public void startRecognition(){
  int debugCounter=0;
  while (!(frontEnd.getData() instanceof SpeechStartSignal) && useStreamSignals) {
    debugCounter++;
    if (debugCounter > 100) {
      debugCounter=0;
      logger.finer(""String_Node_Str"");
    }
  }
}","public void startRecognition(){
  int debugCounter=0;
  Data data;
  while (!((data=frontEnd.getData()) instanceof SpeechStartSignal) && !(data instanceof DataEndSignal) && useStreamSignals) {
    debugCounter++;
    if (debugCounter > 100) {
      debugCounter=0;
      logger.finer(""String_Node_Str"");
    }
  }
}",0.902439024390244
19697,"@Override public void allocate(){
  logger.info(""String_Node_Str"" + numThreads);
  if (numThreads > 1) {
    mailbox=new Mailbox();
    semaphore=new Semaphore();
    for (int i=0; i < (numThreads - 1); i++) {
      Thread t=new ScoringThread();
      t.start();
    }
  }
}","@Override public void allocate(){
  logger.fine(""String_Node_Str"" + numThreads);
  if (numThreads > 1) {
    mailbox=new Mailbox();
    semaphore=new Semaphore();
    for (int i=0; i < (numThreads - 1); i++) {
      Thread t=new ScoringThread();
      t.start();
    }
  }
}",0.9890510948905108
19698,"@Test public void testConcatDataSource() throws DataProcessingException {
  ConcatAudioFileDataSource dataSource=new ConcatAudioFileDataSource();
  dataSource.addNewFileListener(new AudioFileProcessListener(){
    public void audioFileProcStarted(    File audioFile){
      numFileStarts++;
    }
    public void audioFileProcFinished(    File audioFile){
      numFileEnds++;
    }
  }
);
  dataSource.setBatchFile(new File(baseDir + ""String_Node_Str""));
  Assert.assertTrue(dataSource.getData() instanceof DataStartSignal);
  Assert.assertTrue(dataSource.getData() instanceof DoubleData);
  Data d;
  while ((d=dataSource.getData()) instanceof DoubleData)   ;
  Assert.assertTrue(d instanceof DataEndSignal);
  Assert.assertTrue(numFileStarts == 3);
  Assert.assertTrue(numFileEnds == 3);
}","@Test public void testConcatDataSource() throws DataProcessingException {
}",0.1730103806228373
19699,"public void addSubConfiguration(ConfigurationManager subCM){
  Collection<String> compNames=getComponentNames();
  for (  String addCompName : subCM.getComponentNames()) {
    if (compNames.contains(addCompName)) {
      throw new RuntimeException(addCompName + ""String_Node_Str"");
    }
  }
  for (  String globProp : subCM.globalProperties.keySet()) {
    if (globalProperties.keySet().contains(globProp)) {
      throw new IllegalArgumentException(globProp + ""String_Node_Str"");
    }
  }
  globalProperties.putAll(subCM.globalProperties);
  for (  PropertySheet ps : subCM.symbolTable.values()) {
    ps.setCM(this);
  }
  symbolTable.putAll(subCM.symbolTable);
  rawPropertyMap.putAll(subCM.rawPropertyMap);
}","public void addSubConfiguration(ConfigurationManager subCM){
  Collection<String> compNames=getComponentNames();
  for (  String addCompName : subCM.getComponentNames()) {
    if (compNames.contains(addCompName)) {
      throw new RuntimeException(addCompName + ""String_Node_Str"");
    }
  }
  for (  String globProp : subCM.globalProperties.keySet()) {
    if (globalProperties.keySet().contains(globProp) && !System.getProperties().keySet().contains(globProp)) {
      throw new IllegalArgumentException(globProp + ""String_Node_Str"");
    }
  }
  globalProperties.putAll(subCM.globalProperties);
  for (  PropertySheet ps : subCM.symbolTable.values()) {
    ps.setCM(this);
  }
  symbolTable.putAll(subCM.symbolTable);
  rawPropertyMap.putAll(subCM.rawPropertyMap);
}",0.9629130141604856
19700,"public void startElement(String uri,String localName,String qName,Attributes attributes) throws SAXException {
  if (qName.equals(""String_Node_Str"")) {
  }
 else   if (qName.equals(""String_Node_Str"")) {
    String curComponent=attributes.getValue(""String_Node_Str"");
    String curType=attributes.getValue(""String_Node_Str"");
    if (rpdMap.get(curComponent) != null) {
      throw new SAXParseException(""String_Node_Str"" + curComponent,locator);
    }
    rpd=new RawPropertyData(curComponent,curType);
  }
 else   if (qName.equals(""String_Node_Str"")) {
    String name=attributes.getValue(""String_Node_Str"");
    String value=attributes.getValue(""String_Node_Str"");
    if (attributes.getLength() != 2 || name == null || value == null) {
      throw new SAXParseException(""String_Node_Str"" + ""String_Node_Str"",locator);
    }
    if (rpd == null) {
      String symbolName=name;
      globalProperties.setValue(symbolName,value);
    }
 else     if (rpd.contains(name)) {
      throw new SAXParseException(""String_Node_Str"" + name,locator);
    }
 else {
      rpd.add(name,value);
    }
  }
 else   if (qName.equals(""String_Node_Str"")) {
    itemListName=attributes.getValue(""String_Node_Str"");
    if (attributes.getLength() != 1 || itemListName == null) {
      throw new SAXParseException(""String_Node_Str"" + ""String_Node_Str"",locator);
    }
    itemList=new ArrayList<String>();
  }
 else   if (qName.equals(""String_Node_Str"")) {
    if (attributes.getLength() != 0) {
      throw new SAXParseException(""String_Node_Str"",locator);
    }
    curItem=new StringBuffer();
  }
 else {
    throw new SAXParseException(""String_Node_Str"" + qName + ""String_Node_Str"",locator);
  }
}","public void startElement(String uri,String localName,String qName,Attributes attributes) throws SAXException {
  if (qName.equals(""String_Node_Str"")) {
  }
 else   if (qName.equals(""String_Node_Str"")) {
    String curComponent=attributes.getValue(""String_Node_Str"");
    String curType=attributes.getValue(""String_Node_Str"");
    if (rpdMap.get(curComponent) != null) {
      throw new SAXParseException(""String_Node_Str"" + curComponent,locator);
    }
    rpd=new RawPropertyData(curComponent,curType);
  }
 else   if (qName.equals(""String_Node_Str"")) {
    String name=attributes.getValue(""String_Node_Str"");
    String value=attributes.getValue(""String_Node_Str"");
    if (attributes.getLength() != 2 || name == null || value == null) {
      throw new SAXParseException(""String_Node_Str"" + ""String_Node_Str"",locator);
    }
    if (rpd == null) {
      globalProperties.setValue(name,value);
    }
 else     if (rpd.contains(name)) {
      throw new SAXParseException(""String_Node_Str"" + name,locator);
    }
 else {
      rpd.add(name,value);
    }
  }
 else   if (qName.equals(""String_Node_Str"")) {
    itemListName=attributes.getValue(""String_Node_Str"");
    if (attributes.getLength() != 1 || itemListName == null) {
      throw new SAXParseException(""String_Node_Str"" + ""String_Node_Str"",locator);
    }
    itemList=new ArrayList<String>();
  }
 else   if (qName.equals(""String_Node_Str"")) {
    if (attributes.getLength() != 0) {
      throw new SAXParseException(""String_Node_Str"",locator);
    }
    curItem=new StringBuffer();
  }
 else {
    throw new SAXParseException(""String_Node_Str"" + qName + ""String_Node_Str"",locator);
  }
}",0.986778846153846
19701,"public void startElement(String uri,String localName,String qName,Attributes attributes) throws SAXException {
  if (qName.equals(""String_Node_Str"")) {
  }
 else   if (qName.equals(""String_Node_Str"")) {
    String includeFileName=attributes.getValue(""String_Node_Str"");
    try {
      URL fileURL=new File(includeFileName).toURI().toURL();
      SaxLoader saxLoader=new SaxLoader(fileURL,globalProperties,rpdMap);
      saxLoader.load();
    }
 catch (    IOException e) {
      throw new RuntimeException(""String_Node_Str"" + includeFileName + ""String_Node_Str"");
    }
  }
 else   if (qName.equals(""String_Node_Str"")) {
    String curComponent=attributes.getValue(""String_Node_Str"");
    String curType=attributes.getValue(""String_Node_Str"");
    if (rpdMap.get(curComponent) != null) {
      throw new SAXParseException(""String_Node_Str"" + curComponent,locator);
    }
    rpd=new RawPropertyData(curComponent,curType);
  }
 else   if (qName.equals(""String_Node_Str"")) {
    String name=attributes.getValue(""String_Node_Str"");
    String value=attributes.getValue(""String_Node_Str"");
    if (attributes.getLength() != 2 || name == null || value == null) {
      throw new SAXParseException(""String_Node_Str"" + ""String_Node_Str"",locator);
    }
    if (rpd == null) {
      String symbolName=name;
      globalProperties.setValue(symbolName,value);
    }
 else     if (rpd.contains(name)) {
      throw new SAXParseException(""String_Node_Str"" + name,locator);
    }
 else {
      rpd.add(name,value);
    }
  }
 else   if (qName.equals(""String_Node_Str"")) {
    itemListName=attributes.getValue(""String_Node_Str"");
    if (attributes.getLength() != 1 || itemListName == null) {
      throw new SAXParseException(""String_Node_Str"" + ""String_Node_Str"",locator);
    }
    itemList=new ArrayList<String>();
  }
 else   if (qName.equals(""String_Node_Str"")) {
    if (attributes.getLength() != 0) {
      throw new SAXParseException(""String_Node_Str"",locator);
    }
    curItem=new StringBuffer();
  }
 else {
    throw new SAXParseException(""String_Node_Str"" + qName + ""String_Node_Str"",locator);
  }
}","public void startElement(String uri,String localName,String qName,Attributes attributes) throws SAXException {
  if (qName.equals(""String_Node_Str"")) {
  }
 else   if (qName.equals(""String_Node_Str"")) {
    String includeFileName=attributes.getValue(""String_Node_Str"");
    try {
      URL fileURL=new File(includeFileName).toURI().toURL();
      SaxLoader saxLoader=new SaxLoader(fileURL,globalProperties,rpdMap);
      saxLoader.load();
    }
 catch (    IOException e) {
      throw new RuntimeException(""String_Node_Str"" + includeFileName + ""String_Node_Str"",e);
    }
  }
 else   if (qName.equals(""String_Node_Str"")) {
    String curComponent=attributes.getValue(""String_Node_Str"");
    String curType=attributes.getValue(""String_Node_Str"");
    if (rpdMap.get(curComponent) != null) {
      throw new SAXParseException(""String_Node_Str"" + curComponent,locator);
    }
    rpd=new RawPropertyData(curComponent,curType);
  }
 else   if (qName.equals(""String_Node_Str"")) {
    String name=attributes.getValue(""String_Node_Str"");
    String value=attributes.getValue(""String_Node_Str"");
    if (attributes.getLength() != 2 || name == null || value == null) {
      throw new SAXParseException(""String_Node_Str"" + ""String_Node_Str"",locator);
    }
    if (rpd == null) {
      globalProperties.setValue(name,value);
    }
 else     if (rpd.contains(name)) {
      throw new SAXParseException(""String_Node_Str"" + name,locator);
    }
 else {
      rpd.add(name,value);
    }
  }
 else   if (qName.equals(""String_Node_Str"")) {
    itemListName=attributes.getValue(""String_Node_Str"");
    if (attributes.getLength() != 1 || itemListName == null) {
      throw new SAXParseException(""String_Node_Str"" + ""String_Node_Str"",locator);
    }
    itemList=new ArrayList<String>();
  }
 else   if (qName.equals(""String_Node_Str"")) {
    if (attributes.getLength() != 0) {
      throw new SAXParseException(""String_Node_Str"",locator);
    }
    curItem=new StringBuffer();
  }
 else {
    throw new SAXParseException(""String_Node_Str"" + qName + ""String_Node_Str"",locator);
  }
}",0.9889635316698656
19702,"/** 
 * Class constructor.
 */
public BaseAudioManager(){
  listeners=new Vector();
}","/** 
 * Class constructor. 
 */
public BaseAudioManager(){
  listeners=new Vector();
}",0.9941520467836256
19703,"public Object clone() throws CloneNotSupportedException {
  ConfigurationManager cloneCM=(ConfigurationManager)super.clone();
  cloneCM.changeListeners=new ArrayList<ConfigurationChangeListener>();
  cloneCM.symbolTable=new LinkedHashMap<String,PropertySheet>();
  for (  String compName : symbolTable.keySet()) {
    cloneCM.symbolTable.put(compName,(PropertySheet)symbolTable.get(compName).clone());
  }
  cloneCM.globalProperties=new GlobalProperties(globalProperties);
  cloneCM.rawPropertyMap=new HashMap<String,RawPropertyData>(rawPropertyMap);
  return cloneCM;
}","/** 
 * Creates a deep copy of the given CM instance. 
 */
public Object clone() throws CloneNotSupportedException {
  ConfigurationManager cloneCM=(ConfigurationManager)super.clone();
  cloneCM.changeListeners=new ArrayList<ConfigurationChangeListener>();
  cloneCM.symbolTable=new LinkedHashMap<String,PropertySheet>();
  for (  String compName : symbolTable.keySet()) {
    cloneCM.symbolTable.put(compName,(PropertySheet)symbolTable.get(compName).clone());
  }
  cloneCM.globalProperties=new GlobalProperties(globalProperties);
  cloneCM.rawPropertyMap=new HashMap<String,RawPropertyData>(rawPropertyMap);
  return cloneCM;
}",0.950792326939116
19704,"/** 
 * Creates a new configuration manager. Initial properties are loaded from the given URL. No need to keep the notion of 'context' around anymore we will just pass around this property manager.
 * @param url place to load initial properties from
 * @throws java.io.IOException if an error occurs while loading properties from the URL
 */
public ConfigurationManager(URL url) throws IOException, PropertyException {
  configURL=url;
  SaxLoader saxLoader=new SaxLoader(url,globalProperties);
  rawPropertyMap=saxLoader.load();
  ConfigurationManagerUtils.applySystemProperties(rawPropertyMap,globalProperties);
  ConfigurationManagerUtils.configureLogger(this);
  showCreations=""String_Node_Str"".equals(globalProperties.get(""String_Node_Str""));
}","/** 
 * Creates a new configuration manager. Initial properties are loaded from the given URL. No need to keep the notion of 'context' around anymore we will just pass around this property manager.
 * @param url place to load initial properties from
 * @throws java.io.IOException if an error occurs while loading properties from the URL
 */
public ConfigurationManager(URL url) throws IOException, PropertyException {
  configURL=url;
  SaxLoader saxLoader=new SaxLoader(url,globalProperties);
  rawPropertyMap=saxLoader.load();
  ConfigurationManagerUtils.applySystemProperties(rawPropertyMap,globalProperties);
  ConfigurationManagerUtils.configureLogger(this);
  GlobalProperty showCreations=globalProperties.get(""String_Node_Str"");
  if (showCreations != null)   this.showCreations=""String_Node_Str"".equals(showCreations.getValue());
}",0.8961611076148521
19705,"/** 
 * Returns the next Data object.
 * @return the next Data object, or null if none available
 * @throws DataProcessingException if a data processing error occurs
 */
public Data getData() throws DataProcessingException {
  if (outputQueue.size() == 0) {
    Data audio=readData();
    if (audio != null) {
      if (!inSpeech) {
        sendToQueue(audio);
        if (audio instanceof SpeechClassifiedData) {
          SpeechClassifiedData data=(SpeechClassifiedData)audio;
          if (data.isSpeech()) {
            boolean speechStarted=handleFirstSpeech(data);
            if (speechStarted) {
              addSpeechStart();
              inSpeech=true;
            }
          }
        }
      }
 else {
        if (audio instanceof SpeechClassifiedData) {
          SpeechClassifiedData data=(SpeechClassifiedData)audio;
          sendToQueue(data);
          if (!data.isSpeech()) {
            inSpeech=!(readEndFrames(data));
          }
        }
 else         if (audio instanceof DataEndSignal) {
          sendToQueue(new SpeechStartSignal(((Signal)audio).getTime()));
          sendToQueue(audio);
          inSpeech=false;
        }
 else         if (audio instanceof DataStartSignal) {
          throw new Error(""String_Node_Str"");
        }
      }
    }
  }
  if (outputQueue.size() > 0) {
    Data audio=outputQueue.remove(0);
    if (audio instanceof SpeechClassifiedData) {
      SpeechClassifiedData data=(SpeechClassifiedData)audio;
      audio=data.getDoubleData();
    }
    return audio;
  }
 else {
    return null;
  }
}","/** 
 * Returns the next Data object.
 * @return the next Data object, or null if none available
 * @throws DataProcessingException if a data processing error occurs
 */
public Data getData() throws DataProcessingException {
  if (outputQueue.size() == 0) {
    Data audio=readData();
    if (audio != null) {
      if (!inSpeech) {
        sendToQueue(audio);
        if (audio instanceof SpeechClassifiedData) {
          SpeechClassifiedData data=(SpeechClassifiedData)audio;
          if (data.isSpeech()) {
            boolean speechStarted=handleFirstSpeech(data);
            if (speechStarted) {
              addSpeechStart();
              inSpeech=true;
            }
          }
        }
      }
 else {
        if (audio instanceof SpeechClassifiedData) {
          SpeechClassifiedData data=(SpeechClassifiedData)audio;
          sendToQueue(data);
          if (!data.isSpeech()) {
            inSpeech=!(readEndFrames(data));
          }
        }
 else         if (audio instanceof DataEndSignal) {
          sendToQueue(new SpeechEndSignal(((Signal)audio).getTime()));
          sendToQueue(audio);
          inSpeech=false;
        }
 else         if (audio instanceof DataStartSignal) {
          throw new Error(""String_Node_Str"");
        }
      }
    }
  }
  if (outputQueue.size() > 0) {
    Data audio=outputQueue.remove(0);
    if (audio instanceof SpeechClassifiedData) {
      SpeechClassifiedData data=(SpeechClassifiedData)audio;
      audio=data.getDoubleData();
    }
    return audio;
  }
 else {
    return null;
  }
}",0.997427652733119
19706,"public void newProperties(PropertySheet ps) throws PropertyException {
  super.newProperties(ps);
  this.mergeSpeechSegments=ps.getBoolean(PROP_MERGE_SPEECH_SEGMENTS);
}","public void newProperties(PropertySheet ps) throws PropertyException {
  super.newProperties(ps);
  this.mergeSpeechSegments=ps.getBoolean(PROP_MERGE_SPEECH_SEGMENTS);
  initialize();
}",0.9548022598870056
19707,"@Test public void testDefInstance() throws PropertyException, InstantiationException {
  ComponentPropertyTest cpt=(ComponentPropertyTest)ConfigurationManager.getDefaultInstance(ComponentPropertyTest.class);
  Assert.assertTrue(cpt != null);
  Assert.assertTrue(cpt.dataProc instanceof AnotherDummyProcessor);
}","@Test public void testDefInstance() throws PropertyException, InstantiationException {
  ComponentPropertyTest cpt=(ComponentPropertyTest)ConfigurationManager.getInstance(ComponentPropertyTest.class);
  Assert.assertTrue(cpt != null);
  Assert.assertTrue(cpt.dataProc instanceof AnotherDummyProcessor);
}",0.9886178861788618
19708,"@Test public void testGetDefaultInstance() throws PropertyException, InstantiationException {
  DummyComp dc=(DummyComp)ConfigurationManager.getDefaultInstance(DummyComp.class);
  Assert.assertEquals(4,dc.getBeamWidth());
  Assert.assertEquals(1.3,dc.getAlpha(),1E-10);
  DummyFrontEnd fe=dc.getFrontEnd();
  Assert.assertTrue(fe != null);
  Assert.assertTrue(fe instanceof AnotherDummyFrontEnd);
  Assert.assertTrue(fe.getDataProcs().size() == 3);
  Assert.assertTrue(fe.getDataProcs().get(0) instanceof DummyProcessor);
  Assert.assertTrue(fe.getDataProcs().get(1) instanceof AnotherDummyProcessor);
  Assert.assertTrue(fe.getDataProcs().get(2) instanceof DummyProcessor);
  Assert.assertTrue(dc.getBestASR().equals(""String_Node_Str""));
  Assert.assertTrue(dc.getLogger() != null);
}","@Test public void testGetDefaultInstance() throws PropertyException, InstantiationException {
  DummyComp dc=(DummyComp)ConfigurationManager.getInstance(DummyComp.class);
  Assert.assertEquals(4,dc.getBeamWidth());
  Assert.assertEquals(1.3,dc.getAlpha(),1E-10);
  DummyFrontEnd fe=dc.getFrontEnd();
  Assert.assertTrue(fe != null);
  Assert.assertTrue(fe instanceof AnotherDummyFrontEnd);
  Assert.assertTrue(fe.getDataProcs().size() == 3);
  Assert.assertTrue(fe.getDataProcs().get(0) instanceof DummyProcessor);
  Assert.assertTrue(fe.getDataProcs().get(1) instanceof AnotherDummyProcessor);
  Assert.assertTrue(fe.getDataProcs().get(2) instanceof DummyProcessor);
  Assert.assertTrue(dc.getBestASR().equals(""String_Node_Str""));
  Assert.assertTrue(dc.getLogger() != null);
}",0.9955214331413949
19709,"/** 
 * Applies the system properties to the raw property map. System properties should be of the form compName[paramName]=paramValue <p/> List types cannot currently be set from system properties.
 * @param rawMap the map of raw property values
 * @param global global properies
 * @throws PropertyException if an attempt is made to set a parameter for an unknown component.
 */
static void applySystemProperties(Map<String,RawPropertyData> rawMap,Map<String,String> global) throws PropertyException {
  Properties props=System.getProperties();
  for (Enumeration e=props.keys(); e.hasMoreElements(); ) {
    String param=(String)e.nextElement();
    String value=props.getProperty(param);
    int lb=param.indexOf('[');
    int rb=param.indexOf(']');
    if (lb > 0 && rb > lb) {
      String compName=param.substring(0,lb);
      String paramName=param.substring(lb + 1,rb);
      RawPropertyData rpd=rawMap.get(compName);
      if (rpd != null) {
        rpd.add(paramName,value);
      }
 else {
        throw new PropertyException(compName,param,""String_Node_Str"" + ""String_Node_Str"" + compName + ""String_Node_Str""+ param+ ""String_Node_Str"");
      }
    }
 else     if (param.indexOf('.') == -1) {
      String symbolName=""String_Node_Str"" + param + ""String_Node_Str"";
      global.put(symbolName,value);
    }
  }
}","/** 
 * Applies the system properties to the raw property map. System properties should be of the form compName[paramName]=paramValue <p/> List types cannot currently be set from system properties.
 * @param rawMap the map of raw property values
 * @param global global properies
 * @throws PropertyException if an attempt is made to set a parameter for an unknown component.
 */
static void applySystemProperties(Map<String,RawPropertyData> rawMap,Map<String,String> global) throws PropertyException {
  Properties props=System.getProperties();
  for (Enumeration e=props.keys(); e.hasMoreElements(); ) {
    String param=(String)e.nextElement();
    String value=props.getProperty(param);
    int lb=param.indexOf('[');
    int rb=param.indexOf(']');
    if (lb > 0 && rb > lb) {
      String compName=param.substring(0,lb);
      String paramName=param.substring(lb + 1,rb);
      RawPropertyData rpd=rawMap.get(compName);
      if (rpd != null) {
        rpd.add(paramName,value);
      }
 else {
        throw new PropertyException(compName,param,""String_Node_Str"" + ""String_Node_Str"" + compName + ""String_Node_Str""+ param+ ""String_Node_Str"");
      }
    }
 else     if (param.indexOf('.') == -1) {
      global.put(param,value);
    }
  }
}",0.9665369649805448
19710,"/** 
 * @param global Set the global Map to this Map 
 */
public void setGlobal(Map global){
  _globalProperties=global;
}","/** 
 * @param global Set the global Map to this Map
 */
public void setGlobal(Map global){
  _globalProperties=global;
}",0.9958847736625516
19711,"/** 
 * @return get the Map of component properties / configuration set with classname as the Map key 
 */
public Map getOtherProp(){
  return _otherPropMap;
}","/** 
 * @return get the Map of component properties / configuration setwith classname as the Map key
 */
public Map getOtherProp(){
  return _otherPropMap;
}",0.9936708860759492
19712,"/** 
 * @return the configuration set/component properties with configuration name as Map key 
 */
public Map getProperty(){
  return _propertyMap;
}","/** 
 * @return the configuration set/component propertieswith configuration name as Map key
 */
public Map getProperty(){
  return _propertyMap;
}",0.9932432432432432
19713,"/** 
 * @param c Set the component properties to this one 
 */
public void setProperty(Map c){
  _propertyMap=c;
  if (_otherPropMap == null)   _otherPropMap=new HashMap();
 else   _otherPropMap.clear();
  copyPropertiesToOtherMap(_propertyMap);
}","/** 
 * @param c Set the component properties to this one
 */
public void setProperty(Map c){
  _propertyMap=c;
  if (_otherPropMap == null)   _otherPropMap=new HashMap();
 else   _otherPropMap.clear();
  copyPropertiesToOtherMap(_propertyMap);
}",0.9979716024340772
19714,"/** 
 * @return get the Map of Global properties 
 */
public Map getGlobal(){
  return _globalProperties;
}","/** 
 * @return get the Map of Global properties
 */
public Map getGlobal(){
  return _globalProperties;
}",0.9953051643192488
19715,"/** 
 * copy all the data in the input Map into the Other Map 
 */
private void copyPropertiesToOtherMap(Map from){
  if (from != null && !from.isEmpty()) {
    if (_otherPropMap == null) {
      _otherPropMap=new HashMap();
    }
    Map classmap;
    for (Iterator it=from.values().iterator(); it.hasNext(); ) {
      RawPropertyData rpd=(RawPropertyData)it.next();
      String classname=rpd.getClassName();
      if (_otherPropMap.containsKey(classname)) {
        classmap=(Map)_otherPropMap.get(classname);
        if (!classmap.containsKey(rpd.getName()))         classmap.put(rpd.getName(),rpd);
      }
 else {
        classmap=new HashMap();
        classmap.put(rpd.getName(),rpd);
        _otherPropMap.put(classname,classmap);
      }
    }
  }
}","/** 
 * copy all the data in the input Map into the Other Map
 */
private void copyPropertiesToOtherMap(Map from){
  if (from != null && !from.isEmpty()) {
    if (_otherPropMap == null) {
      _otherPropMap=new HashMap();
    }
    Map classmap;
    for (Iterator it=from.values().iterator(); it.hasNext(); ) {
      RawPropertyData rpd=(RawPropertyData)it.next();
      String classname=rpd.getClassName();
      if (_otherPropMap.containsKey(classname)) {
        classmap=(Map)_otherPropMap.get(classname);
        if (!classmap.containsKey(rpd.getName()))         classmap.put(rpd.getName(),rpd);
      }
 else {
        classmap=new HashMap();
        classmap.put(rpd.getName(),rpd);
        _otherPropMap.put(classname,classmap);
      }
    }
  }
}",0.999340804218853
19716,"/** 
 * model has just been reloaded 
 */
public void modelRefresh() throws ConfigurableUtilException ;","/** 
 * model has just been reloaded
 */
public void modelRefresh() throws ConfigurableUtilException ;",0.9951219512195122
19717,"/** 
 * save the data from GUI
 * @param cp the holder of new data
 */
public void saveData(ConfigProperties cp) throws GUIOperationException ;","/** 
 * save the data from GUI 
 * @param cp the holder of new data
 */
public void saveData(ConfigProperties cp) throws GUIOperationException ;",0.9965156794425089
19718,"/** 
 * update GUI with new data
 * @param cp <code>ConfigProperties</code> with new data
 */
public void update(ConfigProperties cp);","/** 
 * update GUI with new data 
 * @param cp <code>ConfigProperties</code> with new data
 */
public void update(ConfigProperties cp);",0.9962825278810408
19719,"/** 
 * clear all data in the GUI 
 */
public void clearAll();","/** 
 * clear all data in the GUI
 */
public void clearAll();",0.991869918699187
19720,"/** 
 * @param args the command line arguments 
 */
public static void main(String args[]){
  java.awt.EventQueue.invokeLater(new Runnable(){
    public void run(){
      try {
        new GUIMediator().execute();
      }
 catch (      Exception e) {
        System.out.println(""String_Node_Str"" + e.getMessage());
      }
    }
  }
);
}","/** 
 * @param args the command line arguments
 */
public static void main(String args[]){
  java.awt.EventQueue.invokeLater(new Runnable(){
    public void run(){
      try {
        new GUIMediator().execute();
      }
 catch (      Exception e) {
        System.out.println(""String_Node_Str"" + e.getMessage());
      }
    }
  }
);
}",0.99851411589896
19721,"public void newProperties(PropertySheet ps) throws PropertyException {
}","public void newProperties(PropertySheet ps) throws PropertyException {
  name=ps.getInstanceName();
}",0.8323699421965318
19722,"/** 
 * Collect all states starting from the given start state
 * @param start the state to start the search from
 * @return the set of collected state
 */
static public Set collectStates(SentenceHMMState start){
  Set visitedStates=new HashSet();
  List queue=new LinkedList();
  queue.add(start);
  while (queue.size() > 0) {
    SentenceHMMState state=(SentenceHMMState)queue.remove(0);
    visitedStates.add(state);
    SentenceHMMStateArc[] successors=state.getSuccessorArray();
    for (int i=0; i < successors.length; i++) {
      SentenceHMMStateArc arc=successors[i];
      SentenceHMMState nextState=(SentenceHMMState)arc.getState();
      if (!visitedStates.contains(nextState)) {
        queue.add(nextState);
      }
    }
  }
  return visitedStates;
}","/** 
 * Collect all states starting from the given start state
 * @param start the state to start the search from
 * @return the set of collected state
 */
public static Set collectStates(SentenceHMMState start){
  Set visitedStates=new HashSet();
  List queue=new LinkedList();
  queue.add(start);
  while (queue.size() > 0) {
    SentenceHMMState state=(SentenceHMMState)queue.remove(0);
    visitedStates.add(state);
    SentenceHMMStateArc[] successors=state.getSuccessorArray();
    for (int i=0; i < successors.length; i++) {
      SentenceHMMStateArc arc=successors[i];
      SentenceHMMState nextState=(SentenceHMMState)arc.getState();
      if (!visitedStates.contains(nextState)) {
        queue.add(nextState);
      }
    }
  }
  return visitedStates;
}",0.9908496732026144
19723,"/** 
 * Returns the property names <code>name</code> which is still wrapped into the annotation instance. 
 */
S4PropWrapper getProperty(String name,Class propertyClass) throws PropertyException {
  if (!propValues.containsKey(name))   throw new PropertyException(owner,name,""String_Node_Str"");
  S4PropWrapper s4PropWrapper=registeredProperties.get(name);
  try {
    propertyClass.cast(s4PropWrapper.getAnnotation());
  }
 catch (  Exception e) {
    throw new PropertyException(owner,name,name + ""String_Node_Str"" + owner.getClass().getName());
  }
  return s4PropWrapper;
}","/** 
 * Returns the property names <code>name</code> which is still wrapped into the annotation instance. 
 */
public S4PropWrapper getProperty(String name,Class propertyClass) throws PropertyException {
  if (!propValues.containsKey(name))   throw new PropertyException(owner,name,""String_Node_Str"" + name + ""String_Node_Str"");
  S4PropWrapper s4PropWrapper=registeredProperties.get(name);
  try {
    propertyClass.cast(s4PropWrapper.getAnnotation());
  }
 catch (  Exception e) {
    throw new PropertyException(owner,name,name + ""String_Node_Str"" + owner.getClass().getName()+ ""String_Node_Str"");
  }
  return s4PropWrapper;
}",0.956089478044739
19724,"/** 
 * Multiplies each element of the given array by the multiplier.
 * @param array the array to multiply
 * @param multiplier the amount to multiply by
 */
private static final void multiplyArray(double[] array,double multiplier){
  for (int i=0; i < array.length; i++) {
    array[i]*=multiplier;
  }
}","/** 
 * Multiplies each element of the given array by the multiplier.
 * @param array      the array to multiply
 * @param multiplier the amount to multiply by
 */
private static void multiplyArray(double[] array,double multiplier){
  for (int i=0; i < array.length; i++) {
    array[i]*=multiplier;
  }
}",0.9819967266775778
19725,"public static Map getConfigurationInfo(){
  Map info=new HashMap();
  info.put(new String(""String_Node_Str""),new String(""String_Node_Str""));
  info.put(new String(""String_Node_Str""),new String(""String_Node_Str""));
  info.put(new String(""String_Node_Str""),new String(""String_Node_Str""));
  return info;
}","public static Map getConfigurationInfo(){
  Map<String,String> info=new HashMap<String,String>();
  info.put(""String_Node_Str"",""String_Node_Str"");
  info.put(""String_Node_Str"",""String_Node_Str"");
  info.put(""String_Node_Str"",""String_Node_Str"");
  return info;
}",0.4468085106382978
19726,"/** 
 * Initializes this LiveCMN.
 */
public void initialize(){
  super.initialize();
}","/** 
 * Initializes this LiveCMN. 
 */
public void initialize(){
  super.initialize();
}",0.9942857142857144
19727,"/** 
 * Returns the next Data object, which is a normalized Data produced by this class. Signals are returned unmodified.
 * @return the next available Data object, returns null if noData object is available
 * @throws DataProcessingException if there is a data processing error
 */
public Data getData() throws DataProcessingException {
  Data input=getPredecessor().getData();
  getTimer().start();
  if (input != null) {
    if (input instanceof DoubleData) {
      DoubleData data=(DoubleData)input;
      if (sum == null) {
        initMeansSums(data.getValues().length);
      }
      normalize(data);
    }
 else     if (input instanceof DataEndSignal) {
      updateMeanSumBuffers();
    }
  }
  getTimer().stop();
  return input;
}","/** 
 * Returns the next Data object, which is a normalized Data produced by this class. Signals are returned unmodified.
 * @return the next available Data object, returns null if no Data object is available
 * @throws DataProcessingException if there is a data processing error
 */
public Data getData() throws DataProcessingException {
  Data input=getPredecessor().getData();
  if (input instanceof DataStartSignal)   sum=null;
  getTimer().start();
  if (input != null) {
    if (input instanceof DoubleData) {
      DoubleData data=(DoubleData)input;
      if (sum == null) {
        initMeansSums(data.getValues().length);
      }
      normalize(data);
    }
 else     if (input instanceof DataEndSignal) {
      updateMeanSumBuffers();
    }
  }
  getTimer().stop();
  return input;
}",0.9654272667971298
19728,"/** 
 * Returns the next element of this enumeration if this enumeration object has at least one more element to provide.
 * @return the next element of this enumeration.
 */
public Object nextElement(){
  Object stream=null;
  if (nextFile == null) {
    nextFile=readNext();
  }
 else {
    for (int i=0; i < fileListeners.size(); i++)     fileListeners.get(i).audioFileProcFinished(new File(nextFile));
  }
  if (nextFile != null) {
    try {
      AudioInputStream ais=AudioSystem.getAudioInputStream(new File(nextFile).toURI().toURL());
      AudioFormat format=ais.getFormat();
      if (!isInitialized) {
        isInitialized=true;
        bigEndian=format.isBigEndian();
        sampleRate=(int)format.getSampleRate();
        signedData=format.getEncoding().equals(AudioFormat.Encoding.PCM_SIGNED);
        bytesPerValue=format.getSampleSizeInBits() / 8;
      }
      if (format.getSampleRate() != sampleRate || format.getChannels() != 1 || format.isBigEndian() != bigEndian) {
        throw new RuntimeException(""String_Node_Str"");
      }
      stream=ais;
      for (int i=0; i < fileListeners.size(); i++)       fileListeners.get(i).audioFileProcStarted(new File(nextFile));
      nextFile=null;
    }
 catch (    IOException ioe) {
      ioe.printStackTrace();
      throw new Error(""String_Node_Str"" + nextFile + ""String_Node_Str"");
    }
catch (    UnsupportedAudioFileException e) {
      e.printStackTrace();
    }
  }
  return stream;
}","/** 
 * Returns the next element of this enumeration if this enumeration object has at least one more element to provide.
 * @return the next element of this enumeration.
 */
public Object nextElement(){
  Object stream=null;
  if (nextFile == null) {
    nextFile=readNext();
  }
 else   if (isInitialized) {
    for (int i=0; i < fileListeners.size(); i++)     fileListeners.get(i).audioFileProcFinished(new File(nextFile));
  }
  if (nextFile != null) {
    try {
      AudioInputStream ais=AudioSystem.getAudioInputStream(new File(nextFile).toURI().toURL());
      AudioFormat format=ais.getFormat();
      if (!isInitialized) {
        isInitialized=true;
        bigEndian=format.isBigEndian();
        sampleRate=(int)format.getSampleRate();
        signedData=format.getEncoding().equals(AudioFormat.Encoding.PCM_SIGNED);
        bytesPerValue=format.getSampleSizeInBits() / 8;
      }
      if (format.getSampleRate() != sampleRate || format.getChannels() != 1 || format.isBigEndian() != bigEndian) {
        throw new RuntimeException(""String_Node_Str"");
      }
      stream=ais;
      for (int i=0; i < fileListeners.size(); i++)       fileListeners.get(i).audioFileProcStarted(new File(nextFile));
      nextFile=null;
    }
 catch (    IOException ioe) {
      ioe.printStackTrace();
      throw new Error(""String_Node_Str"" + nextFile + ""String_Node_Str"");
    }
catch (    UnsupportedAudioFileException e) {
      e.printStackTrace();
    }
  }
  return stream;
}",0.9928449744463372
19729,"public URL getResource(String name) throws PropertyException {
  throw new NotImplementedException();
}","public URL getResource(String name) throws PropertyException {
  throw new RuntimeException(""String_Node_Str"");
}",0.8518518518518519
19730,"public String[] getNames(){
  throw new NotImplementedException();
}","public String[] getNames(){
  throw new RuntimeException(""String_Node_Str"");
}",0.7808219178082192
19731,"public List getComponentList(String name,Class type) throws PropertyException {
  throw new NotImplementedException();
}","public List getComponentList(String name,Class type) throws PropertyException {
  throw new RuntimeException(""String_Node_Str"");
}",0.872
19732,"public void dump(PrintStream out){
  throw new NotImplementedException();
}","public void dump(PrintStream out){
  throw new RuntimeException(""String_Node_Str"");
}",0.8
19733,"public void setRaw(String key,Object val) throws PropertyException {
  throw new NotImplementedException();
}","public void setRaw(String key,Object val) throws PropertyException {
  throw new RuntimeException(""String_Node_Str"");
}",0.8596491228070176
19734,"public Object getRawNoReplacement(String name){
  throw new NotImplementedException();
}","public Object getRawNoReplacement(String name){
  throw new RuntimeException(""String_Node_Str"");
}",0.8279569892473119
19735,"public ConfigurationManager getPropertyManager() throws PropertyException {
  throw new NotImplementedException();
}","public ConfigurationManager getPropertyManager() throws PropertyException {
  throw new RuntimeException(""String_Node_Str"");
}",0.8677685950413223
19736,"public Object getRaw(String name) throws PropertyException {
  throw new NotImplementedException();
}","public Object getRaw(String name) throws PropertyException {
  throw new RuntimeException(""String_Node_Str"");
}",0.8490566037735849
19737,"public void newProperties(PropertySheet ps) throws PropertyException {
  super.newProperties(ps);
  outPattern=ps.getString(WavWriter.PROP_OUT_FILE_NAME_PATTERN,null);
  bitsPerSample=ps.getInt(PROP_BITS_PER_SAMPLE,bitsPerSample);
  if (bitsPerSample % 8 != 0) {
    throw new Error(""String_Node_Str"");
  }
  isBigEndian=ps.getBoolean(PROP_BIG_ENDIAN_DATA,isBigEndian);
  isSigned=ps.getBoolean(PROP_SIGNED_DATA,isSigned);
  captureUtts=ps.getBoolean(PROP_SIGNED_DATA,captureUtts);
  initialize();
}","public void newProperties(PropertySheet ps) throws PropertyException {
  super.newProperties(ps);
  outPattern=ps.getString(WavWriter.PROP_OUT_FILE_NAME_PATTERN,null);
  bitsPerSample=ps.getInt(PROP_BITS_PER_SAMPLE,bitsPerSample);
  if (bitsPerSample % 8 != 0) {
    throw new Error(""String_Node_Str"");
  }
  isBigEndian=ps.getBoolean(PROP_BIG_ENDIAN_DATA,isBigEndian);
  isSigned=ps.getBoolean(PROP_SIGNED_DATA,isSigned);
  captureUtts=ps.getBoolean(PROP_CAPTURE_UTTERANCES,captureUtts);
  initialize();
}",0.9711442786069652
19738,"public Data getData() throws DataProcessingException {
  Data data=getPredecessor().getData();
  if (data instanceof DataStartSignal) {
    baos=new ByteArrayOutputStream();
    dos=new DataOutputStream(baos);
    sampleRate=((DataStartSignal)data).getSampleRate();
  }
  if ((data instanceof DataEndSignal && !captureUtts) || (data instanceof SpeechEndSignal && captureUtts)) {
    AudioFormat wavFormat=new AudioFormat(sampleRate,bitsPerSample,1,isSigned,true);
    AudioFileFormat.Type outputType=getTargetType(""String_Node_Str"");
    String wavName=outPattern + getNextFreeIndex(outPattern) + ""String_Node_Str"";
    byte[] abAudioData=baos.toByteArray();
    ByteArrayInputStream bais=new ByteArrayInputStream(abAudioData);
    AudioInputStream ais=new AudioInputStream(bais,wavFormat,abAudioData.length / wavFormat.getFrameSize());
    File outWavFile=new File(wavName);
    if (AudioSystem.isFileTypeSupported(outputType,ais)) {
      try {
        AudioSystem.write(ais,outputType,outWavFile);
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
    isInSpeech=false;
  }
  if (data instanceof SpeechStartSignal)   isInSpeech=true;
  if (isInSpeech || !captureUtts) {
    DoubleData dd=data instanceof DoubleData ? (DoubleData)data : DataUtil.FloatData2DoubleData((FloatData)data);
    double[] values=dd.getValues();
    for (    double value : values) {
      try {
        dos.writeShort(new Short((short)value));
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
    if (data instanceof FloatData) {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
  return data;
}","public Data getData() throws DataProcessingException {
  Data data=getPredecessor().getData();
  if (data instanceof DataStartSignal)   sampleRate=((DataStartSignal)data).getSampleRate();
  if (data instanceof DataStartSignal || (data instanceof SpeechStartSignal && captureUtts)) {
    baos=new ByteArrayOutputStream();
    dos=new DataOutputStream(baos);
  }
  if ((data instanceof DataEndSignal && !captureUtts) || (data instanceof SpeechEndSignal && captureUtts)) {
    AudioFormat wavFormat=new AudioFormat(sampleRate,bitsPerSample,1,isSigned,true);
    AudioFileFormat.Type outputType=getTargetType(""String_Node_Str"");
    String wavName=outPattern + getNextFreeIndex(outPattern) + ""String_Node_Str"";
    byte[] abAudioData=baos.toByteArray();
    ByteArrayInputStream bais=new ByteArrayInputStream(abAudioData);
    AudioInputStream ais=new AudioInputStream(bais,wavFormat,abAudioData.length / wavFormat.getFrameSize());
    File outWavFile=new File(wavName);
    if (AudioSystem.isFileTypeSupported(outputType,ais)) {
      try {
        AudioSystem.write(ais,outputType,outWavFile);
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
    isInSpeech=false;
  }
  if (data instanceof SpeechStartSignal)   isInSpeech=true;
  if ((data instanceof DoubleData || data instanceof FloatData) && (isInSpeech || !captureUtts)) {
    DoubleData dd=data instanceof DoubleData ? (DoubleData)data : DataUtil.FloatData2DoubleData((FloatData)data);
    double[] values=dd.getValues();
    for (    double value : values) {
      try {
        dos.writeShort(new Short((short)value));
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
  return data;
}",0.8786436644854253
19739,"/** 
 * Get a composite senone sequence given the unit The unit should have a LeftRightContext, where one or two of 'left' or 'right' may be null to indicate that the match should succeed on any context.
 * @param unit the unit
 */
public SenoneSequence getCompositeSenoneSequence(Unit unit,HMMPosition position){
  Context context=unit.getContext();
  SenoneSequence compositeSenoneSequence=null;
  compositeSenoneSequence=(SenoneSequence)compositeSenoneSequenceCache.get(unit.toString());
  if (logger.isLoggable(Level.FINE)) {
    logger.fine(""String_Node_Str"" + unit.toString() + ((compositeSenoneSequence != null) ? ""String_Node_Str"" : ""String_Node_Str""));
  }
  if (compositeSenoneSequence != null) {
    return compositeSenoneSequence;
  }
  List senoneSequenceList=new ArrayList();
  for (Iterator i=getHMMIterator(); i.hasNext(); ) {
    SenoneHMM hmm=(SenoneHMM)i.next();
    if (hmm.getPosition() == position) {
      Unit hmmUnit=hmm.getUnit();
      if (hmmUnit.isPartialMatch(unit.getName(),context)) {
        if (logger.isLoggable(Level.FINE)) {
          logger.fine(""String_Node_Str"" + hmm.getUnit().toString());
        }
        senoneSequenceList.add(hmm.getSenoneSequence());
      }
    }
  }
  if (senoneSequenceList.size() == 0) {
    Unit ciUnit=unitManager.getUnit(unit.getName(),unit.isFiller());
    SenoneHMM baseHMM=lookupHMM(ciUnit,HMMPosition.UNDEFINED);
    senoneSequenceList.add(baseHMM.getSenoneSequence());
  }
  int longestSequence=0;
  for (int i=0; i < senoneSequenceList.size(); i++) {
    SenoneSequence ss=(SenoneSequence)senoneSequenceList.get(i);
    if (ss.getSenones().length > longestSequence) {
      longestSequence=ss.getSenones().length;
    }
  }
  List compositeSenones=new ArrayList();
  float logWeight=0.0f;
  for (int i=0; i < longestSequence; i++) {
    Set compositeSenoneSet=new HashSet();
    for (int j=0; j < senoneSequenceList.size(); j++) {
      SenoneSequence senoneSequence=(SenoneSequence)senoneSequenceList.get(j);
      if (i < senoneSequence.getSenones().length) {
        Senone senone=senoneSequence.getSenones()[i];
        compositeSenoneSet.add(senone);
      }
    }
    compositeSenones.add(CompositeSenone.create(compositeSenoneSet,logWeight));
  }
  compositeSenoneSequence=SenoneSequence.create(compositeSenones);
  compositeSenoneSequenceCache.put(unit.toString(),compositeSenoneSequence);
  if (logger.isLoggable(Level.FINE)) {
    logger.fine(unit.toString() + ""String_Node_Str"" + compositeSenones.size()+ ""String_Node_Str"");
    if (logger.isLoggable(Level.FINEST)) {
      compositeSenoneSequence.dump(""String_Node_Str"");
    }
  }
  return compositeSenoneSequence;
}","/** 
 * Get a composite senone sequence given the unit The unit should have a LeftRightContext, where one or two of 'left' or 'right' may be null to indicate that the match should succeed on any context.
 * @param unit the unit
 */
public SenoneSequence getCompositeSenoneSequence(Unit unit,HMMPosition position){
  Context context=unit.getContext();
  SenoneSequence compositeSenoneSequence=null;
  compositeSenoneSequence=compositeSenoneSequenceCache.get(unit.toString());
  if (logger.isLoggable(Level.FINE)) {
    logger.fine(""String_Node_Str"" + unit.toString() + ((compositeSenoneSequence != null) ? ""String_Node_Str"" : ""String_Node_Str""));
  }
  if (compositeSenoneSequence != null) {
    return compositeSenoneSequence;
  }
  List<SenoneSequence> senoneSequenceList=new ArrayList<SenoneSequence>();
  for (Iterator i=getHMMIterator(); i.hasNext(); ) {
    SenoneHMM hmm=(SenoneHMM)i.next();
    if (hmm.getPosition() == position) {
      Unit hmmUnit=hmm.getUnit();
      if (hmmUnit.isPartialMatch(unit.getName(),context)) {
        if (logger.isLoggable(Level.FINE)) {
          logger.fine(""String_Node_Str"" + hmm.getUnit().toString());
        }
        senoneSequenceList.add(hmm.getSenoneSequence());
      }
    }
  }
  if (senoneSequenceList.size() == 0) {
    Unit ciUnit=unitManager.getUnit(unit.getName(),unit.isFiller());
    SenoneHMM baseHMM=lookupHMM(ciUnit,HMMPosition.UNDEFINED);
    senoneSequenceList.add(baseHMM.getSenoneSequence());
  }
  int longestSequence=0;
  for (int i=0; i < senoneSequenceList.size(); i++) {
    SenoneSequence ss=senoneSequenceList.get(i);
    if (ss.getSenones().length > longestSequence) {
      longestSequence=ss.getSenones().length;
    }
  }
  List<CompositeSenone> compositeSenones=new ArrayList<CompositeSenone>();
  float logWeight=0.0f;
  for (int i=0; i < longestSequence; i++) {
    Set<Senone> compositeSenoneSet=new HashSet<Senone>();
    for (int j=0; j < senoneSequenceList.size(); j++) {
      SenoneSequence senoneSequence=senoneSequenceList.get(j);
      if (i < senoneSequence.getSenones().length) {
        Senone senone=senoneSequence.getSenones()[i];
        compositeSenoneSet.add(senone);
      }
    }
    compositeSenones.add(CompositeSenone.create(compositeSenoneSet,logWeight));
  }
  compositeSenoneSequence=SenoneSequence.create(compositeSenones);
  compositeSenoneSequenceCache.put(unit.toString(),compositeSenoneSequence);
  if (logger.isLoggable(Level.FINE)) {
    logger.fine(unit.toString() + ""String_Node_Str"" + compositeSenones.size()+ ""String_Node_Str"");
    if (logger.isLoggable(Level.FINEST)) {
      compositeSenoneSequence.dump(""String_Node_Str"");
    }
  }
  return compositeSenoneSequence;
}",0.9756827534605312
19740,"public float getScore(float[] data){
  float logDval=0.0f;
  for (int i=0; i < data.length; i++) {
    float logDiff=data[i] - meanTransformed[i];
    logDval+=logDiff * logDiff * precisionTransformed[i];
  }
  logDval=logMath.lnToLog(logDval);
  logDval-=logPreComputedGaussianFactor;
  if (Float.isNaN(logDval)) {
    System.out.println(""String_Node_Str"");
    logDval=LogMath.getLogZero();
  }
  if (logDval < distFloor) {
    logDval=distFloor;
  }
  return logDval;
}","/** 
 * Calculate the score for this mixture against the given feature. We model the output distributions using a mixture of Gaussians, therefore the current implementation is simply the computation of a multi-dimensional Gaussian. <p/> <p><b>Normal(x) = exp{-0.5 * (x-m)' * inv(Var) * (x-m)} / {sqrt((2 * PI) ^ N) * det(Var))}</b></p> <p/> where <b>x</b> and <b>m</b> are the incoming cepstra and mean vector respectivally, <b>Var</b> is the Covariance matrix, <b>det()</b> is the determinant of a matrix, <b>inv()</b> is its inverse, <b>exp</b> is the exponential operator, <b>x'</b> is the transposed vector of <b>x</b> and <b>N</b> is the dimension of the vectors <b>x</b> and <b>m</b>.
 * @param feature the feature to score
 * @return the score, in log, for the given feature
 */
public float getScore(float[] feature){
  float logDval=0.0f;
  for (int i=0; i < feature.length; i++) {
    float logDiff=feature[i] - meanTransformed[i];
    logDval+=logDiff * logDiff * precisionTransformed[i];
  }
  logDval=logMath.lnToLog(logDval);
  logDval-=logPreComputedGaussianFactor;
  if (Float.isNaN(logDval)) {
    System.out.println(""String_Node_Str"");
    logDval=LogMath.getLogZero();
  }
  if (logDval < distFloor) {
    logDval=distFloor;
  }
  return logDval;
}",0.5290396779758482
19741,"/** 
 * Adds the given word into the given string buffer with the start and end times from the given features.
 * @param sb the StringBuffer into which the word is added
 * @param word the word to add
 * @param startFeature the starting feature
 * @param endFeature tne ending feature
 */
private void addWord(StringBuffer sb,Word word,FloatData startFeature,FloatData endFeature){
  float startTime=((float)startFeature.getFirstSampleNumber() / startFeature.getSampleRate());
  float endTime=((float)endFeature.getFirstSampleNumber() / endFeature.getSampleRate());
  if (sb.length() > 0) {
    sb.insert(0,""String_Node_Str"");
  }
  sb.insert(0,(word.getSpelling() + ""String_Node_Str"" + startTime+ ""String_Node_Str""+ endTime+ ""String_Node_Str""));
}","/** 
 * Adds the given word into the given string buffer with the start and end times from the given features.
 * @param sb the StringBuffer into which the word is added
 * @param word the word to add
 * @param startFeature the starting feature
 * @param endFeature tne ending feature
 */
private void addWord(StringBuffer sb,Word word,FloatData startFeature,FloatData endFeature){
  float startTime=startFeature == null ? -1 : ((float)startFeature.getFirstSampleNumber() / startFeature.getSampleRate());
  float endTime=endFeature == null ? -1 : ((float)endFeature.getFirstSampleNumber() / endFeature.getSampleRate());
  if (sb.length() > 0) {
    sb.insert(0,""String_Node_Str"");
  }
  sb.insert(0,(word.getSpelling() + ""String_Node_Str"" + startTime+ ""String_Node_Str""+ endTime+ ""String_Node_Str""));
}",0.9651612903225808
19742,"/** 
 * Replicate the last frame into the last window number of frames in the cepstraBuffer.
 * @return the number of replicated Cepstrum
 */
private int replicateLastCepstrum(){
  DoubleData last=null;
  if (bufferPosition > 0) {
    last=this.cepstraBuffer[bufferPosition - 1];
  }
 else   if (bufferPosition == 0) {
    last=cepstraBuffer[cepstraBuffer.length - 1];
  }
 else {
    throw new Error(""String_Node_Str"");
  }
  for (int i=0; i < window; i++) {
    addCepstrum(last);
  }
  return window;
}","/** 
 * Replicate the last frame into the last window number of frames in the cepstraBuffer.
 * @return the number of replicated Cepstrum
 */
private int replicateLastCepstrum(){
  DoubleData last;
  if (bufferPosition > 0) {
    last=this.cepstraBuffer[bufferPosition - 1];
  }
 else   if (bufferPosition == 0) {
    last=cepstraBuffer[cepstraBuffer.length - 1];
  }
 else {
    throw new Error(""String_Node_Str"");
  }
  for (int i=0; i < window; i++) {
    addCepstrum(last);
  }
  return window;
}",0.9950248756218906
19743,"private Data getNextData() throws DataProcessingException {
  Data d=getPredecessor().getData();
  while (!(d instanceof DoubleData || d instanceof DataEndSignal || d instanceof DataStartSignal)) {
    outputQueue.add(d);
    d=getPredecessor().getData();
  }
  return d;
}","private Data getNextData() throws DataProcessingException {
  Data d=getPredecessor().getData();
  while (d != null && !(d instanceof DoubleData || d instanceof DataEndSignal || d instanceof DataStartSignal)) {
    outputQueue.add(d);
    d=getPredecessor().getData();
  }
  return d;
}",0.9767441860465116
19744,"/** 
 * Returns the next Data object produced by this SocketDataSource. The Cepstra objects of an Utterance should be preceded by a Data object with Signal.DATA_START and ended by a Data object with Signal.DATA_END.
 * @return the next available Data object, returns null if noData object is available
 * @throws DataProcessingException if a data processing error occurs
 */
public Data getData() throws DataProcessingException {
  try {
    double firstValue=dataReader.readDouble();
    if (!inUtterance) {
      if (firstValue == DATA_START) {
        inUtterance=true;
        return (new DataStartSignal());
      }
 else {
        throw new IllegalStateException(""String_Node_Str"" + firstValue + ""String_Node_Str""+ DATA_START);
      }
    }
 else {
      if (firstValue == DATA_END) {
        inUtterance=false;
        return (new DataEndSignal(-1));
      }
 else       if (firstValue == DATA_START) {
        throw new IllegalStateException(""String_Node_Str"");
      }
 else {
        double[] data=new double[cepstrumLength];
        data[0]=firstValue;
        long timeStamp=System.currentTimeMillis();
        for (int i=1; i < cepstrumLength; i++) {
          data[i]=dataReader.readDouble();
        }
        return (new DoubleData(data,sampleRate,timeStamp,firstSampleNumber));
      }
    }
  }
 catch (  IOException ioe) {
    throw new DataProcessingException(""String_Node_Str"");
  }
}","/** 
 * Returns the next Data object produced by this SocketDataSource. The Cepstra objects of an Utterance should be preceded by a Data object with Signal.DATA_START and ended by a Data object with Signal.DATA_END.
 * @return the next available Data object, returns null if noData object is available
 * @throws DataProcessingException if a data processing error occurs
 */
public Data getData() throws DataProcessingException {
  try {
    double firstValue=dataReader.readDouble();
    if (!inUtterance) {
      if (firstValue == DATA_START) {
        inUtterance=true;
        return (new DataStartSignal(sampleRate));
      }
 else {
        throw new IllegalStateException(""String_Node_Str"" + firstValue + ""String_Node_Str""+ DATA_START);
      }
    }
 else {
      if (firstValue == DATA_END) {
        inUtterance=false;
        return (new DataEndSignal(-1));
      }
 else       if (firstValue == DATA_START) {
        throw new IllegalStateException(""String_Node_Str"");
      }
 else {
        double[] data=new double[cepstrumLength];
        data[0]=firstValue;
        long timeStamp=System.currentTimeMillis();
        for (int i=1; i < cepstrumLength; i++) {
          data[i]=dataReader.readDouble();
        }
        return (new DoubleData(data,sampleRate,timeStamp,firstSampleNumber));
      }
    }
  }
 catch (  IOException ioe) {
    throw new DataProcessingException(""String_Node_Str"");
  }
}",0.9964564138908576
19745,"/** 
 * Constructs a DataStartSignal at the given time.
 * @param time the time this DataStartSignal is created
 */
public DataStartSignal(long time){
  super(time);
}","/** 
 * Constructs a DataStartSignal at the given time.
 * @param sampleRate the sampling rate of the started data stream.
 * @param time       the time this DataStartSignal is created
 */
public DataStartSignal(int sampleRate,long time){
  super(time);
  this.sampleRate=sampleRate;
}",0.7212389380530974
19746,"/** 
 * Handles the given Data in the case when mergeSpeechSegment is false.
 * @param audio the Data object to handle
 * @throws DataProcessingException if a data processor error occurs
 */
private Data handleNonMergingData(Data audio) throws DataProcessingException {
  Data next=audio;
  if (audio != null) {
    if (audio instanceof SpeechStartSignal) {
      numberSpeechSamples=0;
      if (inSpeech) {
        message(""String_Node_Str"" + ""String_Node_Str"");
        do {
          next=readData();
        }
 while (next != null && next instanceof SpeechStartSignal);
        if (next != null) {
          next=handleNonMergingData(next);
        }
      }
 else {
        inSpeech=true;
        discardMode=false;
        next=new DataStartSignal(((Signal)audio).getTime());
      }
    }
 else     if (audio instanceof SpeechEndSignal) {
      if (!inSpeech) {
        message(""String_Node_Str"" + ""String_Node_Str"");
        do {
          next=readData();
        }
 while (next != null && next instanceof SpeechEndSignal);
        if (next != null) {
          next=handleNonMergingData(next);
        }
      }
 else {
        inSpeech=false;
        discardMode=true;
        next=new DataEndSignal(getDuration(),((Signal)audio).getTime());
      }
    }
 else     if (discardMode) {
      while (next != null && !(next instanceof SpeechStartSignal) && !(next instanceof SpeechEndSignal)) {
        next=readData();
      }
      next=handleNonMergingData(next);
    }
 else     if (audio instanceof DoubleData) {
      DoubleData realData=(DoubleData)audio;
      numberSpeechSamples+=realData.getValues().length;
      sampleRate=realData.getSampleRate();
    }
  }
  return next;
}","/** 
 * Handles the given Data in the case when mergeSpeechSegment is false.
 * @param audio the Data object to handle
 * @throws DataProcessingException if a data processor error occurs
 */
private Data handleNonMergingData(Data audio) throws DataProcessingException {
  Data next=audio;
  if (audio != null) {
    if (audio instanceof SpeechStartSignal) {
      numberSpeechSamples=0;
      if (inSpeech) {
        message(""String_Node_Str"" + ""String_Node_Str"");
        do {
          next=readData();
        }
 while (next != null && next instanceof SpeechStartSignal);
        if (next != null) {
          next=handleNonMergingData(next);
        }
      }
 else {
        inSpeech=true;
        discardMode=false;
        next=new DataStartSignal(sampleRate,((Signal)audio).getTime());
      }
    }
 else     if (audio instanceof SpeechEndSignal) {
      if (!inSpeech) {
        message(""String_Node_Str"" + ""String_Node_Str"");
        do {
          next=readData();
        }
 while (next != null && next instanceof SpeechEndSignal);
        if (next != null) {
          next=handleNonMergingData(next);
        }
      }
 else {
        inSpeech=false;
        discardMode=true;
        next=new DataEndSignal(getDuration(),((Signal)audio).getTime());
      }
    }
 else     if (discardMode) {
      while (next != null && !(next instanceof SpeechStartSignal) && !(next instanceof SpeechEndSignal)) {
        next=readData();
      }
      next=handleNonMergingData(next);
    }
 else     if (audio instanceof DoubleData) {
      DoubleData realData=(DoubleData)audio;
      numberSpeechSamples+=realData.getValues().length;
      sampleRate=realData.getSampleRate();
    }
  }
  return next;
}",0.996769456681351
19747,"/** 
 * Implements the run() method of the Thread class. Records audio, and cache them in the audio buffer.
 */
public void run(){
  totalSamplesRead=0;
  logger.info(""String_Node_Str"");
  if (keepDataReference) {
    currentUtterance=new Utterance(""String_Node_Str"",audioStream.getFormat());
  }
  audioList.add(new DataStartSignal());
  logger.info(""String_Node_Str"");
  try {
    audioLine.start();
    while (!done) {
      Data data=readData(currentUtterance);
      if (data == null) {
        done=true;
        break;
      }
      audioList.add(data);
    }
    audioLine.flush();
    if (closeBetweenUtterances) {
      audioStream.close();
      audioLine.close();
      audioLine=null;
    }
  }
 catch (  IOException ioe) {
    logger.warning(""String_Node_Str"" + ioe.getMessage());
    ioe.printStackTrace();
  }
  long duration=(long)(((double)totalSamplesRead / (double)audioStream.getFormat().getSampleRate()) * 1000.0);
  audioList.add(new DataEndSignal(duration));
  logger.info(""String_Node_Str"");
  logger.info(""String_Node_Str"");
synchronized (lock) {
    lock.notify();
  }
}","/** 
 * Implements the run() method of the Thread class. Records audio, and cache them in the audio buffer.
 */
public void run(){
  totalSamplesRead=0;
  logger.info(""String_Node_Str"");
  if (keepDataReference) {
    currentUtterance=new Utterance(""String_Node_Str"",audioStream.getFormat());
  }
  audioList.add(new DataStartSignal(sampleRate));
  logger.info(""String_Node_Str"");
  try {
    audioLine.start();
    while (!done) {
      Data data=readData(currentUtterance);
      if (data == null) {
        done=true;
        break;
      }
      audioList.add(data);
    }
    audioLine.flush();
    if (closeBetweenUtterances) {
      audioStream.close();
      audioLine.close();
      audioLine=null;
    }
  }
 catch (  IOException ioe) {
    logger.warning(""String_Node_Str"" + ioe.getMessage());
    ioe.printStackTrace();
  }
  long duration=(long)(((double)totalSamplesRead / (double)audioStream.getFormat().getSampleRate()) * 1000.0);
  audioList.add(new DataEndSignal(duration));
  logger.info(""String_Node_Str"");
  logger.info(""String_Node_Str"");
synchronized (lock) {
    lock.notify();
  }
}",0.9954627949183305
19748,"public void newProperties(PropertySheet ps) throws PropertyException {
  super.newProperties(ps);
  logger=ps.getLogger();
  int sampleRate=ps.getInt(PROP_SAMPLE_RATE,PROP_SAMPLE_RATE_DEFAULT);
  int sampleSizeInBits=ps.getInt(PROP_BITS_PER_SAMPLE,PROP_BITS_PER_SAMPLE_DEFAULT);
  int channels=ps.getInt(PROP_CHANNELS,PROP_CHANNELS_DEFAULT);
  boolean bigEndian=ps.getBoolean(PROP_BIG_ENDIAN,PROP_BIG_ENDIAN_DEFAULT);
  signed=ps.getBoolean(PROP_SIGNED,PROP_SIGNED_DEFAULT);
  desiredFormat=new AudioFormat((float)sampleRate,sampleSizeInBits,channels,signed,bigEndian);
  closeBetweenUtterances=ps.getBoolean(PROP_CLOSE_BETWEEN_UTTERANCES,PROP_CLOSE_BETWEEN_UTTERANCES_DEFAULT);
  msecPerRead=ps.getInt(PROP_MSEC_PER_READ,PROP_MSEC_PER_READ_DEFAULT);
  keepDataReference=ps.getBoolean(PROP_KEEP_LAST_AUDIO,PROP_KEEP_LAST_AUDIO_DEFAULT);
  stereoToMono=ps.getString(PROP_STEREO_TO_MONO,PROP_STEREO_TO_MONO_DEFAULT);
  selectedChannel=ps.getInt(PROP_SELECT_CHANNEL,PROP_SELECT_CHANNEL_DEFAULT);
  selectedMixerIndex=ps.getString(PROP_SELECT_MIXER,PROP_SELECT_MIXER_DEFAULT);
}","public void newProperties(PropertySheet ps) throws PropertyException {
  super.newProperties(ps);
  logger=ps.getLogger();
  sampleRate=ps.getInt(PROP_SAMPLE_RATE,PROP_SAMPLE_RATE_DEFAULT);
  int sampleSizeInBits=ps.getInt(PROP_BITS_PER_SAMPLE,PROP_BITS_PER_SAMPLE_DEFAULT);
  int channels=ps.getInt(PROP_CHANNELS,PROP_CHANNELS_DEFAULT);
  boolean bigEndian=ps.getBoolean(PROP_BIG_ENDIAN,PROP_BIG_ENDIAN_DEFAULT);
  signed=ps.getBoolean(PROP_SIGNED,PROP_SIGNED_DEFAULT);
  desiredFormat=new AudioFormat((float)sampleRate,sampleSizeInBits,channels,signed,bigEndian);
  closeBetweenUtterances=ps.getBoolean(PROP_CLOSE_BETWEEN_UTTERANCES,PROP_CLOSE_BETWEEN_UTTERANCES_DEFAULT);
  msecPerRead=ps.getInt(PROP_MSEC_PER_READ,PROP_MSEC_PER_READ_DEFAULT);
  keepDataReference=ps.getBoolean(PROP_KEEP_LAST_AUDIO,PROP_KEEP_LAST_AUDIO_DEFAULT);
  stereoToMono=ps.getString(PROP_STEREO_TO_MONO,PROP_STEREO_TO_MONO_DEFAULT);
  selectedChannel=ps.getInt(PROP_SELECT_CHANNEL,PROP_SELECT_CHANNEL_DEFAULT);
  selectedMixerIndex=ps.getString(PROP_SELECT_MIXER,PROP_SELECT_MIXER_DEFAULT);
}",0.9981343283582088
19749,"/** 
 * Constructs a Microphone with the given InputStream.
 * @throws IOException if an I/O error occurs
 */
public void initialize(){
  super.initialize();
  audioList=new DataList();
  DataLine.Info info=new DataLine.Info(TargetDataLine.class,desiredFormat);
  if (!AudioSystem.isLineSupported(info)) {
    logger.info(desiredFormat + ""String_Node_Str"");
    AudioFormat nativeFormat=DataUtil.getNativeAudioFormat(desiredFormat,getSelectedMixer());
    if (nativeFormat == null) {
      logger.severe(""String_Node_Str"");
      return;
    }
 else {
      finalFormat=nativeFormat;
      doConversion=AudioSystem.isConversionSupported(desiredFormat,nativeFormat);
      if (doConversion) {
        logger.info(""String_Node_Str"" + finalFormat.getSampleRate() + ""String_Node_Str""+ desiredFormat.getSampleRate()+ ""String_Node_Str"");
      }
 else {
        logger.info(""String_Node_Str"" + finalFormat.getSampleRate() + ""String_Node_Str""+ desiredFormat.getSampleRate()+ ""String_Node_Str"");
      }
    }
  }
 else {
    logger.info(""String_Node_Str"" + desiredFormat + ""String_Node_Str"");
    finalFormat=desiredFormat;
  }
}","/** 
 * Constructs a Microphone with the given InputStream.
 * @throws IOException if an I/O error occurs
 */
public void initialize(){
  super.initialize();
  audioList=new DataList();
  DataLine.Info info=new DataLine.Info(TargetDataLine.class,desiredFormat);
  if (!AudioSystem.isLineSupported(info)) {
    logger.info(desiredFormat + ""String_Node_Str"");
    AudioFormat nativeFormat=DataUtil.getNativeAudioFormat(desiredFormat,getSelectedMixer());
    if (nativeFormat == null) {
      logger.severe(""String_Node_Str"");
    }
 else {
      finalFormat=nativeFormat;
      doConversion=AudioSystem.isConversionSupported(desiredFormat,nativeFormat);
      if (doConversion) {
        logger.info(""String_Node_Str"" + finalFormat.getSampleRate() + ""String_Node_Str""+ desiredFormat.getSampleRate()+ ""String_Node_Str"");
      }
 else {
        logger.info(""String_Node_Str"" + finalFormat.getSampleRate() + ""String_Node_Str""+ desiredFormat.getSampleRate()+ ""String_Node_Str"");
      }
    }
  }
 else {
    logger.info(""String_Node_Str"" + desiredFormat + ""String_Node_Str"");
    finalFormat=desiredFormat;
  }
}",0.9937219730941704
19750,"/** 
 * Returns the next Data object, which is the mel cepstrum of the input frame. However, it can also be other Data objects like DataStartSignal.
 * @return the next available Data object, returns null if noData object is available
 * @throws DataProcessingException if a data processing error occurs
 */
public Data getData() throws DataProcessingException {
  Data data=null;
  if (curPoint == -1) {
    data=new DataStartSignal();
    curPoint++;
  }
 else   if (curPoint == numPoints) {
    if (numPoints > 0) {
      firstSampleNumber=(firstSampleNumber - frameShift + frameSize - 1);
    }
    int numberFrames=curPoint / frameSize;
    int totalSamples=(numberFrames - 1) * frameShift + frameSize;
    long duration=(long)(((double)totalSamples / (double)sampleRate) * 1000.0);
    data=new DataEndSignal(duration);
    try {
      if (binary) {
        binaryStream.close();
      }
 else {
        est.close();
      }
      curPoint++;
    }
 catch (    IOException ioe) {
      throw new DataProcessingException(""String_Node_Str"");
    }
  }
 else   if (curPoint > numPoints) {
    data=null;
  }
 else {
    double[] vectorData=new double[cepstrumLength];
    long collectTime=System.currentTimeMillis();
    for (int i=0; i < cepstrumLength; i++) {
      try {
        if (binary) {
          if (bigEndian) {
            vectorData[i]=(double)binaryStream.readFloat();
          }
 else {
            vectorData[i]=(double)Utilities.readLittleEndianFloat(binaryStream);
          }
        }
 else {
          vectorData[i]=(double)est.getFloat(""String_Node_Str"");
        }
        curPoint++;
      }
 catch (      IOException ioe) {
        throw new DataProcessingException(""String_Node_Str"");
      }
    }
    data=new DoubleData(vectorData,sampleRate,collectTime,firstSampleNumber);
    firstSampleNumber+=frameShift;
  }
  return data;
}","/** 
 * Returns the next Data object, which is the mel cepstrum of the input frame. However, it can also be other Data objects like DataStartSignal.
 * @return the next available Data object, returns null if noData object is available
 * @throws DataProcessingException if a data processing error occurs
 */
public Data getData() throws DataProcessingException {
  Data data;
  if (curPoint == -1) {
    data=new DataStartSignal(sampleRate);
    curPoint++;
  }
 else   if (curPoint == numPoints) {
    if (numPoints > 0) {
      firstSampleNumber=(firstSampleNumber - frameShift + frameSize - 1);
    }
    int numberFrames=curPoint / frameSize;
    int totalSamples=(numberFrames - 1) * frameShift + frameSize;
    long duration=(long)(((double)totalSamples / (double)sampleRate) * 1000.0);
    data=new DataEndSignal(duration);
    try {
      if (binary) {
        binaryStream.close();
      }
 else {
        est.close();
      }
      curPoint++;
    }
 catch (    IOException ioe) {
      throw new DataProcessingException(""String_Node_Str"");
    }
  }
 else   if (curPoint > numPoints) {
    data=null;
  }
 else {
    double[] vectorData=new double[cepstrumLength];
    long collectTime=System.currentTimeMillis();
    for (int i=0; i < cepstrumLength; i++) {
      try {
        if (binary) {
          if (bigEndian) {
            vectorData[i]=(double)binaryStream.readFloat();
          }
 else {
            vectorData[i]=(double)Utilities.readLittleEndianFloat(binaryStream);
          }
        }
 else {
          vectorData[i]=(double)est.getFloat(""String_Node_Str"");
        }
        curPoint++;
      }
 catch (      IOException ioe) {
        throw new DataProcessingException(""String_Node_Str"");
      }
    }
    data=new DoubleData(vectorData,sampleRate,collectTime,firstSampleNumber);
    firstSampleNumber+=frameShift;
  }
  return data;
}",0.99597747385358
19751,"/** 
 * Returns the next Data from the input stream, or null if there is none available
 * @return a Data or null
 * @throws java.io.IOException
 */
private Data readNextFrame() throws DataProcessingException {
  int read=0;
  int totalRead=0;
  final int bytesToRead=bytesPerRead;
  byte[] samplesBuffer=new byte[bytesPerRead];
  long collectTime=System.currentTimeMillis();
  long firstSample=totalValuesRead;
  try {
    do {
      read=dataStream.read(samplesBuffer,totalRead,bytesToRead - totalRead);
      if (read > 0) {
        totalRead+=read;
      }
    }
 while (read != -1 && totalRead < bytesToRead);
    if (totalRead <= 0) {
      closeDataStream();
      return null;
    }
    totalValuesRead+=(totalRead / bytesPerValue);
    if (totalRead < bytesToRead) {
      totalRead=(totalRead % 2 == 0) ? totalRead + 2 : totalRead + 3;
      byte[] shrinkedBuffer=new byte[totalRead];
      System.arraycopy(samplesBuffer,0,shrinkedBuffer,0,totalRead);
      samplesBuffer=shrinkedBuffer;
      closeDataStream();
    }
  }
 catch (  IOException ioe) {
    ioe.printStackTrace();
    throw new DataProcessingException(""String_Node_Str"");
  }
  double[] doubleData;
  if (bigEndian) {
    doubleData=DataUtil.bytesToValues(samplesBuffer,0,totalRead,bytesPerValue,signedData);
  }
 else {
    doubleData=DataUtil.littleEndianBytesToValues(samplesBuffer,0,totalRead,bytesPerValue,signedData);
  }
  Data audio=new DoubleData(doubleData,sampleRate,collectTime,firstSample);
  return audio;
}","/** 
 * Returns the next Data from the input stream, or null if there is none available
 * @return a Data or null
 * @throws java.io.IOException
 */
private Data readNextFrame() throws DataProcessingException {
  int read;
  int totalRead=0;
  final int bytesToRead=bytesPerRead;
  byte[] samplesBuffer=new byte[bytesPerRead];
  long collectTime=System.currentTimeMillis();
  long firstSample=totalValuesRead;
  try {
    do {
      read=dataStream.read(samplesBuffer,totalRead,bytesToRead - totalRead);
      if (read > 0) {
        totalRead+=read;
      }
    }
 while (read != -1 && totalRead < bytesToRead);
    if (totalRead <= 0) {
      closeDataStream();
      return null;
    }
    totalValuesRead+=(totalRead / bytesPerValue);
    if (totalRead < bytesToRead) {
      totalRead=(totalRead % 2 == 0) ? totalRead + 2 : totalRead + 3;
      byte[] shrinkedBuffer=new byte[totalRead];
      System.arraycopy(samplesBuffer,0,shrinkedBuffer,0,totalRead);
      samplesBuffer=shrinkedBuffer;
      closeDataStream();
    }
  }
 catch (  IOException ioe) {
    ioe.printStackTrace();
    throw new DataProcessingException(""String_Node_Str"");
  }
  double[] doubleData;
  if (bigEndian) {
    doubleData=DataUtil.bytesToValues(samplesBuffer,0,totalRead,bytesPerValue,signedData);
  }
 else {
    doubleData=DataUtil.littleEndianBytesToValues(samplesBuffer,0,totalRead,bytesPerValue,signedData);
  }
  return new DoubleData(doubleData,sampleRate,collectTime,firstSample);
}",0.9878869448183042
19752,"/** 
 * Reads and returns the next Data from the InputStream of StreamDataSource, return null if no data is read and end of file is reached.
 * @return the next Data or <code>null</code> if none is available
 * @throws DataProcessingException if there is a data processing error
 */
public Data getData() throws DataProcessingException {
  getTimer().start();
  Data output=null;
  if (streamEndReached) {
    if (!utteranceEndSent) {
      output=new DataEndSignal(getDuration());
      utteranceEndSent=true;
    }
  }
 else {
    if (!utteranceStarted) {
      utteranceStarted=true;
      output=new DataStartSignal();
    }
 else {
      if (dataStream != null) {
        output=readNextFrame();
        if (output == null) {
          if (!utteranceEndSent) {
            output=new DataEndSignal(getDuration());
            utteranceEndSent=true;
          }
        }
      }
    }
  }
  getTimer().stop();
  return output;
}","/** 
 * Reads and returns the next Data from the InputStream of StreamDataSource, return null if no data is read and end of file is reached.
 * @return the next Data or <code>null</code> if none is available
 * @throws DataProcessingException if there is a data processing error
 */
public Data getData() throws DataProcessingException {
  getTimer().start();
  Data output=null;
  if (streamEndReached) {
    if (!utteranceEndSent) {
      output=new DataEndSignal(getDuration());
      utteranceEndSent=true;
    }
  }
 else {
    if (!utteranceStarted) {
      utteranceStarted=true;
      output=new DataStartSignal(sampleRate);
    }
 else {
      if (dataStream != null) {
        output=readNextFrame();
        if (output == null) {
          if (!utteranceEndSent) {
            output=new DataEndSignal(getDuration());
            utteranceEndSent=true;
          }
        }
      }
    }
  }
  getTimer().stop();
  return output;
}",0.9946695095948828
19753,"/** 
 * Returns true if this SphinxProperties contains the given property.
 * @return true if it has the given property, false otherwise
 */
public boolean contains(String propertyName){
  String value=System.getProperty(propertyName);
  if (value == null) {
    return props.contains(propertyName);
  }
 else {
    return true;
  }
}","/** 
 * Returns true if this SphinxProperties contains the given property.
 * @return true if it has the given property, false otherwise
 */
public boolean contains(String propertyName){
  String value=System.getProperty(propertyName);
  if (value == null) {
    return props.containsKey(propertyName);
  }
 else {
    return true;
  }
}",0.9955290611028316
19754,"/** 
 * Called whenever the value of the selection changes.
 * @param e the event that characterizes the change.
 */
public void valueChanged(TreeSelectionEvent e){
  DefaultMutableTreeNode n=(DefaultMutableTreeNode)e.getPath().getLastPathComponent();
  if (n.getUserObject() instanceof Word) {
    Word word=(Word)n.getUserObject();
    System.out.println(word);
    final WordBrowser w=new WordBrowser();
    JFrame f=new JFrame(""String_Node_Str"");
    w.spectrogram.setWord(cm,word);
    f.setContentPane(w.mainPane);
    f.setTitle(word.toString());
    f.pack();
    f.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
    f.setVisible(true);
  }
}","/** 
 * Called whenever the value of the selection changes.
 * @param e the event that characterizes the change.
 */
public void valueChanged(TreeSelectionEvent e){
  DefaultMutableTreeNode n=(DefaultMutableTreeNode)e.getPath().getLastPathComponent();
  if (n.getUserObject() instanceof Word) {
    Word word=(Word)n.getUserObject();
    System.out.println(word);
    final WordBrowser w=new WordBrowser(cm,word);
    JFrame f=new JFrame(""String_Node_Str"");
    w.spectrogram.setWord(cm,word);
    f.setContentPane(w.mainPane);
    f.setTitle(word.toString());
    f.pack();
    f.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
    f.setVisible(true);
  }
}",0.9946768060836502
19755,"/** 
 * Returns the next Data object.
 * @return the next Data object, or null if none available
 * @throws DataProcessingException if a data processing error occurs
 */
public Data getData() throws DataProcessingException {
  if (outputQueue.size() == 0) {
    Data audio=getPredecessor().getData();
    if (audio != null) {
      if (audio instanceof DoubleData) {
        DoubleData data=(DoubleData)audio;
        if (data.getValues().length > ((int)(frameLengthSec * data.getSampleRate()))) {
          throw new Error(""String_Node_Str"" + data.getValues().length + ""String_Node_Str""+ (frameLengthSec * data.getSampleRate()));
        }
        classify(data);
      }
 else {
        outputQueue.add(audio);
      }
    }
  }
  if (outputQueue.size() > 0) {
    Data audio=(Data)outputQueue.remove(0);
    return audio;
  }
 else {
    return null;
  }
}","/** 
 * Returns the next Data object.
 * @return the next Data object, or null if none available
 * @throws DataProcessingException if a data processing error occurs
 */
public Data getData() throws DataProcessingException {
  if (outputQueue.size() == 0) {
    Data audio=getPredecessor().getData();
    if (audio != null) {
      if (audio instanceof DoubleData) {
        DoubleData data=(DoubleData)audio;
        if (data.getValues().length > ((int)(frameLengthSec * data.getSampleRate()))) {
          throw new Error(""String_Node_Str"" + data.getValues().length + ""String_Node_Str""+ (frameLengthSec * data.getSampleRate()));
        }
        classify(data);
      }
 else {
        outputQueue.add(audio);
      }
    }
  }
  if (outputQueue.size() > 0) {
    return (Data)outputQueue.remove(0);
  }
 else {
    return null;
  }
}",0.9492924528301888
19756,"public void register(String name,Registry registry) throws PropertyException {
  super.register(name,registry);
  registry.register(PROP_FRAME_LENGTH_MS,PropertyType.INT);
  registry.register(PROP_ADJUSTMENT,PropertyType.DOUBLE);
  registry.register(PROP_THRESHOLD,PropertyType.DOUBLE);
  registry.register(PROP_MIN_SIGNAL,PropertyType.DOUBLE);
  registry.register(PROP_DEBUG,PropertyType.BOOLEAN);
}","public void register(String name,Registry registry) throws PropertyException {
  super.register(name,registry);
  registry.register(PROP_FRAME_LENGTH_MS,PropertyType.INT);
  registry.register(PROP_ADJUSTMENT,PropertyType.DOUBLE);
  registry.register(PROP_THRESHOLD,PropertyType.DOUBLE);
  registry.register(PROP_MIN_SIGNAL,PropertyType.DOUBLE);
  registry.register(PROP_DEBUG,PropertyType.BOOLEAN);
  initialize();
}",0.9803921568627452
19757,"/** 
 * Converts the Cepstrum data in the cepstraBuffer into a FeatureFrame.
 * @param totalFeatures the number of Features that will be produced
 * @return a FeatureFrame
 */
private void computeFeatures(int totalFeatures){
  getTimer().start();
  if (totalFeatures == 1) {
    computeFeature();
  }
 else {
    for (int i=0; i < totalFeatures; i++) {
      computeFeature();
    }
  }
  getTimer().stop();
}","/** 
 * Converts the Cepstrum data in the cepstraBuffer into a FeatureFrame.
 * @param totalFeatures the number of Features that will be produced
 */
private void computeFeatures(int totalFeatures){
  getTimer().start();
  if (totalFeatures == 1) {
    computeFeature();
  }
 else {
    for (int i=0; i < totalFeatures; i++) {
      computeFeature();
    }
  }
  getTimer().stop();
}",0.9671717171717172
19758,"/** 
 * Converts the Cepstrum data in the cepstraBuffer into a FeatureFrame.
 * @param totalFeatures the number of Features that will be produced
 * @return a FeatureFrame
 */
private void computeFeatures(int totalFeatures){
  getTimer().start();
  if (totalFeatures == 1) {
    computeFeature();
  }
 else {
    for (int i=0; i < totalFeatures; i++) {
      computeFeature();
    }
  }
  getTimer().stop();
}","/** 
 * Converts the Cepstrum data in the cepstraBuffer into a FeatureFrame.
 * @param totalFeatures the number of Features that will be produced
 */
private void computeFeatures(int totalFeatures){
  getTimer().start();
  if (totalFeatures == 1) {
    computeFeature();
  }
 else {
    for (int i=0; i < totalFeatures; i++) {
      computeFeature();
    }
  }
  getTimer().stop();
}",0.9671717171717172
19759,"/** 
 * Attaches one SentenceHMMState as a child to another, the transition has the given probability
 * @param prevState the parent state
 * @param nextState the child state
 * @param logAcousticProbability the acoustic probability of transition in the LogMath log domain
 * @param logLanguageProbablity the language probability of transition in the LogMath log domain
 * @param logInsertionProbablity insertion probability of transition in the LogMath log domain
 * @return the state that was attached
 */
protected void attachState(SentenceHMMState prevState,SentenceHMMState nextState,float logAcousticProbability,float logLanguageProbablity,float logInsertionProbablity){
  prevState.connect(getArc(nextState,logAcousticProbability,logLanguageProbablity,logInsertionProbablity));
  if (showCompilationProgress && totalStateCounter++ % 1000 == 0) {
    System.out.print(""String_Node_Str"");
  }
}","/** 
 * Attaches one SentenceHMMState as a child to another, the transition has the given probability
 * @param prevState the parent state
 * @param nextState the child state
 * @param logAcousticProbability the acoustic probability of transition in the LogMath log domain
 * @param logLanguageProbablity the language probability of transition in the LogMath log domain
 * @param logInsertionProbablity insertion probability of transition in the LogMath log domain
 */
protected void attachState(SentenceHMMState prevState,SentenceHMMState nextState,float logAcousticProbability,float logLanguageProbablity,float logInsertionProbablity){
  prevState.connect(getArc(nextState,logAcousticProbability,logLanguageProbablity,logInsertionProbablity));
  if (showCompilationProgress && totalStateCounter++ % 1000 == 0) {
    System.out.print(""String_Node_Str"");
  }
}",0.977828311540648
19760,"/** 
 * Decodes the batch of audio files
 * @throws IOException if there is an I/O error processing the batch file
 */
public void decode(String batchFile){
  BatchItem batchItem;
  int count=0;
  try {
    recognizer.allocate();
    setBatchFile(batchFile);
    batchManager.start();
    logger.info(""String_Node_Str"" + batchManager.getFilename());
    while (count < totalCount && (batchItem=batchManager.getNextItem()) != null) {
      setInputStream(batchItem.getFilename());
      Result result=recognizer.recognize(batchItem.getTranscript());
      logger.info(""String_Node_Str"" + batchItem.getFilename());
      logger.info(""String_Node_Str"" + result);
      count++;
    }
    batchManager.stop();
    recognizer.deallocate();
  }
 catch (  IOException io) {
    logger.severe(""String_Node_Str"" + io.getMessage());
  }
  logger.info(""String_Node_Str"" + count + ""String_Node_Str"");
}","/** 
 * Decodes the batch of audio files
 */
public void decode(String batchFile){
  BatchItem batchItem;
  int count=0;
  try {
    recognizer.allocate();
    setBatchFile(batchFile);
    batchManager.start();
    logger.info(""String_Node_Str"" + batchManager.getFilename());
    while (count < totalCount && (batchItem=batchManager.getNextItem()) != null) {
      setInputStream(batchItem.getFilename());
      Result result=recognizer.recognize(batchItem.getTranscript());
      logger.info(""String_Node_Str"" + batchItem.getFilename());
      logger.info(""String_Node_Str"" + result);
      count++;
    }
    batchManager.stop();
    recognizer.deallocate();
  }
 catch (  IOException io) {
    logger.severe(""String_Node_Str"" + io.getMessage());
  }
  logger.info(""String_Node_Str"" + count + ""String_Node_Str"");
}",0.0973036342321219
19761,"/** 
 * Sets the input stream to the given filename
 * @param filename the filename to set the input stream to
 * @return the InputStream representing the filename
 * @throws IOException if an error occurs
 */
void setInputStream(String filename) throws IOException {
  for (Iterator i=inputDataProcessors.iterator(); i.hasNext(); ) {
    DataProcessor dataSource=(DataProcessor)i.next();
    InputStream is=null;
    try {
      File file=new File(filename);
      logger.info(AudioSystem.getAudioFileFormat(file).toString());
      is=AudioSystem.getAudioInputStream(file);
    }
 catch (    UnsupportedAudioFileException uafe) {
      logger.info(""String_Node_Str"" + filename + ""String_Node_Str"");
      is=new FileInputStream(filename);
    }
    if (dataSource instanceof StreamDataSource) {
      ((StreamDataSource)dataSource).setInputStream(is,filename);
    }
 else     if (dataSource instanceof StreamCepstrumSource) {
      boolean isBigEndian=Utilities.isCepstraFileBigEndian(filename);
      StreamCepstrumSource cepstrumSource=(StreamCepstrumSource)dataSource;
      cepstrumSource.setInputStream(is,isBigEndian);
    }
  }
}","/** 
 * Sets the input stream to the given filename
 * @param filename the filename to set the input stream to
 * @throws IOException if an error occurs
 */
void setInputStream(String filename) throws IOException {
  for (Iterator i=inputDataProcessors.iterator(); i.hasNext(); ) {
    DataProcessor dataSource=(DataProcessor)i.next();
    InputStream is=null;
    try {
      File file=new File(filename);
      logger.info(AudioSystem.getAudioFileFormat(file).toString());
      is=AudioSystem.getAudioInputStream(file);
    }
 catch (    UnsupportedAudioFileException uafe) {
      logger.info(""String_Node_Str"" + filename + ""String_Node_Str"");
      is=new FileInputStream(filename);
    }
    if (dataSource instanceof StreamDataSource) {
      ((StreamDataSource)dataSource).setInputStream(is,filename);
    }
 else     if (dataSource instanceof StreamCepstrumSource) {
      boolean isBigEndian=Utilities.isCepstraFileBigEndian(filename);
      StreamCepstrumSource cepstrumSource=(StreamCepstrumSource)dataSource;
      cepstrumSource.setInputStream(is,isBigEndian);
    }
  }
}",0.9761797752808988
19762,"/** 
 * Converts the Cepstrum data in the cepstraBuffer into a FeatureFrame.
 * @param totalFeatures the number of Features that will be produced
 */
private void computeFeatures(int totalFeatures){
  getTimer().start();
  if (totalFeatures == 1) {
    computeFeature();
  }
 else {
    for (int i=0; i < totalFeatures; i++) {
      computeFeature();
    }
  }
  getTimer().stop();
}","/** 
 * Converts the Cepstrum data in the cepstraBuffer into a FeatureFrame.
 * @param totalFeatures the number of Features that will be produced
 * @return a FeatureFrame
 */
private void computeFeatures(int totalFeatures){
  getTimer().start();
  if (totalFeatures == 1) {
    computeFeature();
  }
 else {
    for (int i=0; i < totalFeatures; i++) {
      computeFeature();
    }
  }
  getTimer().stop();
}",0.9671717171717172
19763,"/** 
 * Converts the Cepstrum data in the cepstraBuffer into a FeatureFrame.
 * @param totalFeatures the number of Features that will be produced
 */
private void computeFeatures(int totalFeatures){
  getTimer().start();
  if (totalFeatures == 1) {
    computeFeature();
  }
 else {
    for (int i=0; i < totalFeatures; i++) {
      computeFeature();
    }
  }
  getTimer().stop();
}","/** 
 * Converts the Cepstrum data in the cepstraBuffer into a FeatureFrame.
 * @param totalFeatures the number of Features that will be produced
 * @return a FeatureFrame
 */
private void computeFeatures(int totalFeatures){
  getTimer().start();
  if (totalFeatures == 1) {
    computeFeature();
  }
 else {
    for (int i=0; i < totalFeatures; i++) {
      computeFeature();
    }
  }
  getTimer().stop();
}",0.9671717171717172
19764,"/** 
 * Dumps the feature to the given ascii output file.
 * @param outputFile the ascii output file
 */
public void dumpAscii(String outputFile) throws IOException {
  PrintStream ps=new PrintStream(new FileOutputStream(outputFile),true);
  ps.print(getNumberDataPoints());
  ps.print(' ');
  for (Iterator i=allFeatures.iterator(); i.hasNext(); ) {
    double[] feature=(double[])i.next();
    for (int d=0; d < feature.length; d++) {
      ps.print(feature[d]);
      ps.print(' ');
    }
  }
  ps.close();
}","/** 
 * Dumps the feature to the given ascii output file.
 * @param outputFile the ascii output file
 */
public void dumpAscii(String outputFile) throws IOException {
  PrintStream ps=new PrintStream(new FileOutputStream(outputFile),true);
  ps.print(getNumberDataPoints());
  ps.print(' ');
  for (Iterator i=allFeatures.iterator(); i.hasNext(); ) {
    Object data=i.next();
    if (data instanceof double[]) {
      double[] feature=(double[])data;
      for (int d=0; d < feature.length; d++) {
        ps.print(feature[d]);
        ps.print(' ');
      }
    }
 else     if (data instanceof float[]) {
      float[] feature=(float[])data;
      for (int d=0; d < feature.length; d++) {
        ps.print(feature[d]);
        ps.print(' ');
      }
    }
  }
  ps.close();
}",0.7406832298136646
19765,"/** 
 * Returns the string of words (with timestamp) for this token. This method assumes that the word tokens come before other types of token.
 * @param wantFiller true if we want filler words, false otherwise
 * @return the string of words
 */
private String getTimedWordPath(Token token,boolean wantFiller){
  StringBuffer sb=new StringBuffer();
  while (token != null & !token.isEmitting()) {
    token=token.getPredecessor();
  }
  if (token != null) {
    Data lastWordFirstFeature=token.getData();
    Data lastFeature=lastWordFirstFeature;
    token=token.getPredecessor();
    while (token != null) {
      if (token.isWord()) {
        Word word=token.getWord();
        if (wantFiller || !word.isFiller()) {
          addWord(sb,word,(FloatData)lastFeature,(FloatData)lastWordFirstFeature);
        }
        lastWordFirstFeature=lastFeature;
      }
      Data feature=token.getData();
      if (feature != null) {
        lastFeature=feature;
      }
      token=token.getPredecessor();
    }
  }
  return sb.toString();
}","/** 
 * Returns the string of words (with timestamp) for this token. This method assumes that the word tokens come before other types of token.
 * @param wantFiller true if we want filler words, false otherwise
 * @return the string of words
 */
private String getTimedWordPath(Token token,boolean wantFiller){
  StringBuffer sb=new StringBuffer();
  while (token != null && !token.isEmitting()) {
    token=token.getPredecessor();
  }
  if (token != null) {
    Data lastWordFirstFeature=token.getData();
    Data lastFeature=lastWordFirstFeature;
    token=token.getPredecessor();
    while (token != null) {
      if (token.isWord()) {
        Word word=token.getWord();
        if (wantFiller || !word.isFiller()) {
          addWord(sb,word,(FloatData)lastFeature,(FloatData)lastWordFirstFeature);
        }
        lastWordFirstFeature=lastFeature;
      }
      Data feature=token.getData();
      if (feature != null) {
        lastFeature=feature;
      }
      token=token.getPredecessor();
    }
  }
  return sb.toString();
}",0.9995171414775472
19766,"/** 
 * Replaces an old token with a new token
 * @param oldToken the token to replace (or null in which case, replace works like add).
 * @param newToken the new token to be placed in the list.
 */
public void replace(Token oldToken,Token newToken){
  if (oldToken != null) {
    int location=oldToken.getLocation();
    if (tokenList[location] != oldToken) {
      System.out.println(""String_Node_Str"" + oldToken + ""String_Node_Str""+ newToken+ ""String_Node_Str""+ location+ ""String_Node_Str""+ tokenList[location]);
    }
    tokenList[location]=newToken;
    newToken.setLocation(location);
    if (bestToken == null || newToken.getScore() > bestToken.getScore()) {
      bestToken=newToken;
    }
  }
 else {
    add(newToken);
  }
}","/** 
 * Replaces an old token with a new token
 * @param oldToken the token to replace (or null in which case, replace works like add).
 * @param newToken the new token to be placed in the list.
 */
public void replace(Token oldToken,Token newToken){
  if (oldToken != null) {
    int location=oldToken.getLocation();
    if (location != -1 && tokenList[location] == oldToken) {
      tokenList[location]=newToken;
      newToken.setLocation(location);
      oldToken.setLocation(-1);
    }
 else {
      add(newToken);
    }
  }
 else {
    add(newToken);
  }
  if (bestToken == null || newToken.getScore() > bestToken.getScore()) {
    bestToken=newToken;
  }
}",0.7052932761087267
19767,"/** 
 * Perform one inter word clustering step of the algorithm
 * @param clusters the current cluster set
 */
protected boolean interWordClusterStep(List clusters){
  List toBeMerged1=null;
  List toBeMerged2=null;
  double maxSim=Double.NEGATIVE_INFINITY;
  ListIterator i=clusters.listIterator();
  while (i.hasNext()) {
    List c1=(List)i.next();
    if (!i.hasNext()) {
      break;
    }
    ListIterator j=clusters.listIterator(i.nextIndex());
    while (j.hasNext()) {
      List c2=(List)j.next();
      double sim=interClusterDistance(c1,c2);
      if (sim > maxSim && hasOverlap(c1,c2)) {
        maxSim=sim;
        toBeMerged1=c1;
        toBeMerged2=c2;
      }
    }
  }
  if (toBeMerged1 != null) {
    clusters.remove(toBeMerged2);
    toBeMerged1.addAll(toBeMerged2);
    System.out.println(""String_Node_Str"");
    printClusters(clusters);
    return true;
  }
  return false;
}","/** 
 * Perform one inter word clustering step of the algorithm
 * @param clusters the current cluster set
 */
protected boolean interWordClusterStep(List clusters){
  List toBeMerged1=null;
  List toBeMerged2=null;
  double maxSim=Double.NEGATIVE_INFINITY;
  ListIterator i=clusters.listIterator();
  while (i.hasNext()) {
    List c1=(List)i.next();
    if (!i.hasNext()) {
      break;
    }
    ListIterator j=clusters.listIterator(i.nextIndex());
    while (j.hasNext()) {
      List c2=(List)j.next();
      double sim=interClusterDistance(c1,c2);
      if (sim > maxSim && hasOverlap(c1,c2)) {
        maxSim=sim;
        toBeMerged1=c1;
        toBeMerged2=c2;
      }
    }
  }
  if (toBeMerged1 != null) {
    clusters.remove(toBeMerged2);
    toBeMerged1.addAll(toBeMerged2);
    return true;
  }
  return false;
}",0.9581881533101044
19768,"/** 
 * Perform a step of the intra word clustering stage
 * @param clusters the current list of clusters
 * @return did two clusters get merged?
 */
protected boolean intraWordClusterStep(List clusters){
  List toBeMerged1=null;
  List toBeMerged2=null;
  double maxSim=Double.NEGATIVE_INFINITY;
  ListIterator i=clusters.listIterator();
  while (i.hasNext()) {
    List c1=(List)i.next();
    if (!i.hasNext()) {
      break;
    }
    ListIterator j=clusters.listIterator(i.nextIndex());
    while (j.hasNext()) {
      List c2=(List)j.next();
      double sim=intraClusterDistance(c1,c2);
      if (sim > maxSim) {
        maxSim=sim;
        toBeMerged1=c1;
        toBeMerged2=c2;
      }
    }
  }
  if (toBeMerged1 != null) {
    clusters.remove(toBeMerged2);
    toBeMerged1.addAll(toBeMerged2);
    System.out.println(""String_Node_Str"");
    printClusters(clusters);
    return true;
  }
  return false;
}","/** 
 * Perform a step of the intra word clustering stage
 * @param clusters the current list of clusters
 * @return did two clusters get merged?
 */
protected boolean intraWordClusterStep(List clusters){
  List toBeMerged1=null;
  List toBeMerged2=null;
  double maxSim=Double.NEGATIVE_INFINITY;
  ListIterator i=clusters.listIterator();
  while (i.hasNext()) {
    List c1=(List)i.next();
    if (!i.hasNext()) {
      break;
    }
    ListIterator j=clusters.listIterator(i.nextIndex());
    while (j.hasNext()) {
      List c2=(List)j.next();
      double sim=intraClusterDistance(c1,c2);
      if (sim > maxSim) {
        maxSim=sim;
        toBeMerged1=c1;
        toBeMerged2=c2;
      }
    }
  }
  if (toBeMerged1 != null) {
    clusters.remove(toBeMerged2);
    toBeMerged1.addAll(toBeMerged2);
    return true;
  }
  return false;
}",0.9590443686006824
19769,"/** 
 * Turn the lattice contained in this sausage maker into a sausage object.
 * @return the sausage producing by collapsing the lattice.
 */
public Sausage makeSausage(){
  Vector clusters=new Vector(lattice.getNodes().size());
  Collection nodes=lattice.nodes.values();
  Iterator i=nodes.iterator();
  while (i.hasNext()) {
    Vector bucket=new Vector(1);
    bucket.add(i.next());
    clusters.add(bucket);
  }
  intraWordCluster(clusters);
  interWordCluster(clusters);
  Collections.sort(clusters,new ClusterComparator());
  printClusters(clusters);
  Sausage sausage=new Sausage(clusters.size());
  ListIterator c1=clusters.listIterator();
  while (c1.hasNext()) {
    HashSet seenWords=new HashSet();
    int index=c1.nextIndex();
    List cluster=((List)c1.next());
    Iterator c2=cluster.iterator();
    while (c2.hasNext()) {
      Node node=(Node)c2.next();
      Word word=node.getWord();
      if (seenWords.contains(word.getSpelling())) {
        continue;
      }
      seenWords.add(word.getSpelling());
      SimpleWordResult swr=new SimpleWordResult(node,wordSubClusterProbability(cluster,word.getSpelling()),lattice.getLogMath());
      sausage.addWordHypothesis(index,swr);
    }
  }
  sausage.fillInBlanks(lattice.getLogMath());
  return sausage;
}","/** 
 * Turn the lattice contained in this sausage maker into a sausage object.
 * @return the sausage producing by collapsing the lattice.
 */
public Sausage makeSausage(){
  Vector clusters=new Vector(lattice.getNodes().size());
  Collection nodes=lattice.nodes.values();
  Iterator i=nodes.iterator();
  while (i.hasNext()) {
    Vector bucket=new Vector(1);
    bucket.add(i.next());
    clusters.add(bucket);
  }
  intraWordCluster(clusters);
  interWordCluster(clusters);
  clusters=topologicalSort(clusters);
  Sausage sausage=new Sausage(clusters.size());
  ListIterator c1=clusters.listIterator();
  while (c1.hasNext()) {
    HashSet seenWords=new HashSet();
    int index=c1.nextIndex();
    List cluster=((List)c1.next());
    Iterator c2=cluster.iterator();
    while (c2.hasNext()) {
      Node node=(Node)c2.next();
      Word word=node.getWord();
      if (seenWords.contains(word.getSpelling())) {
        continue;
      }
      seenWords.add(word.getSpelling());
      SimpleWordResult swr=new SimpleWordResult(node,wordSubClusterProbability(cluster,word.getSpelling()),lattice.getLogMath());
      sausage.addWordHypothesis(index,swr);
    }
  }
  sausage.fillInBlanks(lattice.getLogMath());
  return sausage;
}",0.9644710578842316
19770,"/** 
 * Computes confidences for a Result and returns a ConfidenceResult, a compact representation of all the hypothesis contained in the result together with their per-word and per-path confidences.
 * @param result the result to compute confidences for
 * @return a confidence result
 */
public ConfidenceResult score(Result result){
  Lattice lattice=new Lattice(result);
  LatticeOptimizer lop=new LatticeOptimizer(lattice);
  lop.optimize();
  lattice.computeNodePosteriors(languageWeight);
  SausageMaker sm=new SausageMaker(lattice);
  Sausage s=sm.makeSausage();
  ConfidenceResult sausage=(ConfidenceResult)s;
  WordResultPath mapPath=new WordResultPath();
  Token mapToken=result.getBestToken();
  int slot=sausage.size() - 1;
  while (mapToken != null) {
    while (!mapToken.isWord()) {
      mapToken=mapToken.getPredecessor();
    }
    if (mapToken != null) {
      String word=mapToken.getWord().getSpelling();
      ConfusionSet cs=sausage.getConfusionSet(slot);
      WordResult wr=null;
      while (slot >= 0 && (((wr=cs.getWordResult(word)) == null) && ((wr=cs.getWordResult(""String_Node_Str"")) != null))) {
        slot--;
        cs=sausage.getConfusionSet(slot);
      }
      if (wr != null) {
        mapPath.add(0,wr);
      }
 else {
        throw new Error(""String_Node_Str"" + slot + ""String_Node_Str""+ word);
      }
      slot--;
      mapToken=mapToken.getPredecessor();
    }
 else {
      break;
    }
  }
  return (new MAPConfidenceResult(sausage,mapPath));
}","/** 
 * Computes confidences for a Result and returns a ConfidenceResult, a compact representation of all the hypothesis contained in the result together with their per-word and per-path confidences.
 * @param result the result to compute confidences for
 * @return a confidence result
 */
public ConfidenceResult score(Result result){
  Lattice lattice=new Lattice(result);
  LatticeOptimizer lop=new LatticeOptimizer(lattice);
  lop.optimize();
  lattice.computeNodePosteriors(languageWeight);
  SausageMaker sm=new SausageMaker(lattice);
  Sausage s=sm.makeSausage();
  if (dumpLattice) {
    lattice.dumpAISee(""String_Node_Str"",""String_Node_Str"");
  }
  if (dumpSausage) {
    s.dumpAISee(""String_Node_Str"",""String_Node_Str"");
  }
  ConfidenceResult sausage=(ConfidenceResult)s;
  WordResultPath mapPath=new WordResultPath();
  Token mapToken=result.getBestToken();
  int slot=sausage.size() - 1;
  while (mapToken != null) {
    while (!mapToken.isWord()) {
      mapToken=mapToken.getPredecessor();
    }
    if (mapToken != null) {
      String word=mapToken.getWord().getSpelling();
      ConfusionSet cs=sausage.getConfusionSet(slot);
      WordResult wr=null;
      while (slot >= 0 && (((wr=cs.getWordResult(word)) == null) && (((wr=cs.getWordResult(""String_Node_Str"")) != null) || ((wr=cs.getWordResult(""String_Node_Str"")) != null)))) {
        slot--;
        cs=sausage.getConfusionSet(slot);
      }
      if (wr != null) {
        mapPath.add(0,wr);
      }
 else {
        cs.dump(""String_Node_Str"" + slot);
        throw new Error(""String_Node_Str"" + slot + ""String_Node_Str""+ word);
      }
      slot--;
      mapToken=mapToken.getPredecessor();
    }
 else {
      break;
    }
  }
  return (new MAPConfidenceResult(sausage,mapPath));
}",0.9191018148262072
19771,"public void newProperties(PropertySheet ps) throws PropertyException {
  languageWeight=ps.getFloat(PROP_LANGUAGE_WEIGHT,PROP_LANGUAGE_WEIGHT_DEFAULT);
}","public void newProperties(PropertySheet ps) throws PropertyException {
  languageWeight=ps.getFloat(PROP_LANGUAGE_WEIGHT,PROP_LANGUAGE_WEIGHT_DEFAULT);
  dumpLattice=ps.getBoolean(PROP_DUMP_LATTICE,PROP_DUMP_LATTICE_DEFAULT);
  dumpSausage=ps.getBoolean(PROP_DUMP_SAUSAGE,PROP_DUMP_SAUSAGE_DEFAULT);
}",0.6740088105726872
19772,"public void register(String name,Registry registry) throws PropertyException {
  this.name=name;
  registry.register(PROP_LANGUAGE_WEIGHT,PropertyType.FLOAT);
}","public void register(String name,Registry registry) throws PropertyException {
  this.name=name;
  registry.register(PROP_LANGUAGE_WEIGHT,PropertyType.FLOAT);
  registry.register(PROP_DUMP_LATTICE,PropertyType.BOOLEAN);
  registry.register(PROP_DUMP_SAUSAGE,PropertyType.BOOLEAN);
}",0.7239819004524887
19773,"/** 
 * Computes the score of an edge.
 * @param the edge which score we want to compute
 * @return the score of an edge
 */
private double computeEdgeScore(Edge edge,float languageModelWeight){
  return (edge.getAcousticScore() / languageModelWeight + edge.getLMScore());
}","/** 
 * Computes the score of an edge.
 * @param edge the edge which score we want to compute
 * @param languageModelWeight the language model weight to use
 * @return the score of an edge
 */
private double computeEdgeScore(Edge edge,float languageModelWeight){
  return (edge.getAcousticScore() / languageModelWeight + edge.getLMScore());
}",0.8896103896103896
19774,"/** 
 * Creates a GrammarNode with the word in the given RuleToken.
 * @param ruleToken the RuleToken that contains the word
 * @return a GrammarNode with the word in the given RuleToken
 */
private GrammarGraph parseRuleToken(RuleToken ruleToken){
  debugPrintln(""String_Node_Str"" + ruleToken.toString());
  GrammarNode node=createGrammarNode(ruleToken.getText());
  return new GrammarGraph(node,node);
}","/** 
 * Creates a GrammarNode with the word in the given RuleToken.
 * @param ruleToken the RuleToken that contains the word
 * @return a GrammarNode with the word in the given RuleToken
 */
private GrammarGraph parseRuleToken(RuleToken ruleToken){
  GrammarNode node=createGrammarNode(ruleToken.getText());
  return new GrammarGraph(node,node);
}",0.7021276595744681
19775,"/** 
 * Parses the given RuleName into a network of GrammarNodes.
 * @param initialRuleName the RuleName rule to parse
 * @return a grammar graph
 */
private GrammarGraph parseRuleName(RuleName initialRuleName) throws GrammarException {
  debugPrintln(""String_Node_Str"" + initialRuleName.toString());
  GrammarGraph result=(GrammarGraph)ruleNameStack.get(initialRuleName.getRuleName());
  if (false && result != null) {
    return result;
  }
 else {
    result=new GrammarGraph();
    ruleNameStack.put(initialRuleName.getRuleName(),result);
  }
  RuleName ruleName=ruleGrammar.resolve(initialRuleName);
  if (ruleName == RuleName.NULL) {
    result.getStartNode().add(result.getEndNode(),0.0f);
  }
 else   if (ruleName == RuleName.VOID) {
  }
 else {
    if (ruleName == null) {
      throw new GrammarException(""String_Node_Str"" + initialRuleName + ""String_Node_Str""+ initialRuleName.getFullGrammarName());
    }
    RuleGrammar rg=recognizer.getRuleGrammar(ruleName.getFullGrammarName());
    if (rg == null) {
      throw new GrammarException(""String_Node_Str"" + ruleName.getFullGrammarName());
    }
    Rule rule=rg.getRule(ruleName.getSimpleRuleName());
    if (rule == null) {
      throw new GrammarException(""String_Node_Str"" + ruleName.getRuleName());
    }
    GrammarGraph ruleResult=parseRule(rule);
    result.getStartNode().add(ruleResult.getStartNode(),0.0f);
    ruleResult.getEndNode().add(result.getEndNode(),0.0f);
    ruleNameStack.remove(ruleName.getRuleName());
  }
  return result;
}","/** 
 * Parses the given RuleName into a network of GrammarNodes.
 * @param initialRuleName the RuleName rule to parse
 * @return a grammar graph
 */
private GrammarGraph parseRuleName(RuleName initialRuleName) throws GrammarException {
  debugPrintln(""String_Node_Str"" + initialRuleName.toString());
  GrammarGraph result=(GrammarGraph)ruleStack.contains(initialRuleName.getRuleName());
  if (result != null) {
    return result;
  }
 else {
    result=new GrammarGraph();
    ruleStack.push(initialRuleName.getRuleName(),result);
  }
  RuleName ruleName=ruleGrammar.resolve(initialRuleName);
  if (ruleName == RuleName.NULL) {
    result.getStartNode().add(result.getEndNode(),0.0f);
  }
 else   if (ruleName == RuleName.VOID) {
  }
 else {
    if (ruleName == null) {
      throw new GrammarException(""String_Node_Str"" + initialRuleName + ""String_Node_Str""+ initialRuleName.getFullGrammarName());
    }
    RuleGrammar rg=recognizer.getRuleGrammar(ruleName.getFullGrammarName());
    if (rg == null) {
      throw new GrammarException(""String_Node_Str"" + ruleName.getFullGrammarName());
    }
    Rule rule=rg.getRule(ruleName.getSimpleRuleName());
    if (rule == null) {
      throw new GrammarException(""String_Node_Str"" + ruleName.getRuleName());
    }
    GrammarGraph ruleResult=parseRule(rule);
    if (result != ruleResult) {
      result.getStartNode().add(ruleResult.getStartNode(),0.0f);
      ruleResult.getEndNode().add(result.getEndNode(),0.0f);
    }
  }
  ruleStack.pop();
  return result;
}",0.9463576158940398
19776,"/** 
 * Commit changes to all loaded grammars and all changes of grammar since the last commitChange
 */
public void commitChanges() throws IOException {
  try {
    if (loadGrammar) {
      recognizer=new BaseRecognizer();
      recognizer.allocate();
      ruleGrammar=recognizer.loadJSGF(baseURL,grammarName);
      ruleGrammar.setEnabled(true);
      loadGrammar=false;
    }
    recognizer.commitChanges();
    ruleNameStack=new HashMap();
    newGrammar();
    firstNode=createGrammarNode(""String_Node_Str"");
    GrammarNode finalNode=createGrammarNode(""String_Node_Str"");
    finalNode.setFinalNode(true);
    String[] ruleNames=ruleGrammar.listRuleNames();
    for (int i=0; i < ruleNames.length; i++) {
      String ruleName=ruleNames[i];
      if (ruleGrammar.isRulePublic(ruleName)) {
        debugPrintln(""String_Node_Str"" + ruleName);
        Rule rule=ruleGrammar.getRule(ruleName);
        GrammarGraph graph=parseRule(rule);
        firstNode.add(graph.getStartNode(),0.0f);
        graph.getEndNode().add(finalNode,0.0f);
      }
    }
    postProcessGrammar();
  }
 catch (  EngineException ee) {
    throw new IOException(ee.toString());
  }
catch (  GrammarException ge) {
    dumpGrammarException(ge);
    throw new IOException(""String_Node_Str"" + ge);
  }
catch (  MalformedURLException mue) {
    throw new IOException(""String_Node_Str"" + baseURL + ""String_Node_Str""+ mue);
  }
}","/** 
 * Commit changes to all loaded grammars and all changes of grammar since the last commitChange
 */
public void commitChanges() throws IOException {
  try {
    if (loadGrammar) {
      recognizer=new BaseRecognizer();
      recognizer.allocate();
      ruleGrammar=recognizer.loadJSGF(baseURL,grammarName);
      ruleGrammar.setEnabled(true);
      loadGrammar=false;
    }
    recognizer.commitChanges();
    ruleStack=new RuleStack();
    newGrammar();
    firstNode=createGrammarNode(""String_Node_Str"");
    GrammarNode finalNode=createGrammarNode(""String_Node_Str"");
    finalNode.setFinalNode(true);
    String[] ruleNames=ruleGrammar.listRuleNames();
    for (int i=0; i < ruleNames.length; i++) {
      String ruleName=ruleNames[i];
      if (ruleGrammar.isRulePublic(ruleName)) {
        String fullName=getFullRuleName(ruleName);
        GrammarGraph publicRuleGraph=new GrammarGraph();
        ruleStack.push(fullName,publicRuleGraph);
        Rule rule=ruleGrammar.getRule(ruleName);
        GrammarGraph graph=parseRule(rule);
        ruleStack.pop();
        firstNode.add(publicRuleGraph.getStartNode(),0.0f);
        publicRuleGraph.getEndNode().add(finalNode,0.0f);
        publicRuleGraph.getStartNode().add(graph.getStartNode(),0.0f);
        graph.getEndNode().add(publicRuleGraph.getEndNode(),0.0f);
      }
    }
    postProcessGrammar();
  }
 catch (  EngineException ee) {
    throw new IOException(ee.toString());
  }
catch (  GrammarException ge) {
    dumpGrammarException(ge);
    throw new IOException(""String_Node_Str"" + ge);
  }
catch (  MalformedURLException mue) {
    throw new IOException(""String_Node_Str"" + baseURL + ""String_Node_Str""+ mue);
  }
}",0.8249757360077645
19777,"/** 
 * Adds an arc to the given node 
 * @param node the node that this new arc goes to
 * @param logProbability the log probability of the transition occuring
 */
public void add(GrammarNode node,float logProbability){
  arcList.add(new GrammarArc(node,logProbability));
}","/** 
 * Adds an arc to the given node 
 * @param node the node that this new arc goes to
 * @param logProbability the log probability of the transition occuring
 */
public void add(GrammarNode node,float logProbability){
  if (isEmpty() && this == node) {
    return;
  }
  arcList.add(new GrammarArc(node,logProbability));
}",0.9148580968280468
19778,"/** 
 * Optimize this grammar node.
 */
void optimize(){
  for (int i=0; i < arcList.size(); i++) {
    GrammarArc arc=(GrammarArc)arcList.get(i);
    arcList.set(i,optimizeArc(arc));
  }
}","/** 
 * Optimize this grammar node.
 */
void optimize(){
  for (int i=0; i < arcList.size(); i++) {
    GrammarArc arc=(GrammarArc)arcList.get(i);
    arcList.set(i,optimizeArc(arc));
  }
  if (this.isEmpty()) {
    for (ListIterator i=arcList.listIterator(); i.hasNext(); ) {
      GrammarArc arc=(GrammarArc)i.next();
      if (this == arc.getGrammarNode()) {
        i.remove();
      }
    }
  }
}",0.6406779661016949
19779,"/** 
 * Deallocate the resources for the Engine and put it in the  DEALLOCATED state.
 */
public void deallocate() throws EngineException, EngineStateError {
  if (testEngineState(DEALLOCATED))   return;
  releaseFocus();
  long[] states=setEngineState(CLEAR_ALL_STATE,DEALLOCATING_RESOURCES);
  postEngineDeallocatingResources(states[0],states[1]);
  states=setEngineState(CLEAR_ALL_STATE,DEALLOCATED);
  postEngineDeallocated(states[0],states[1]);
}","/** 
 * Deallocate the resources for the Engine and put it in the  DEALLOCATED state.
 */
public void deallocate() throws EngineException, EngineStateError {
  if (testEngineState(DEALLOCATED))   return;
  releaseFocus();
  long[] states=setEngineState(CLEAR_ALL_STATE,DEALLOCATING_RESOURCES);
  postEngineDeallocatingResources(states[0],states[1]);
  states=setEngineState(CLEAR_ALL_STATE,DEALLOCATED);
  postEngineDeallocated(states[0],states[1]);
  handleDeallocate();
}",0.9761904761904762
19780,"/** 
 * Allocate the resources for the Engine and put it in the ALLOCATED, RESUMED, QUEUE_EMPTY state.
 */
public void allocate() throws EngineException, EngineStateError {
  if (testEngineState(ALLOCATED)) {
    return;
  }
  long[] states=setEngineState(CLEAR_ALL_STATE,ALLOCATING_RESOURCES);
  postEngineAllocatingResources(states[0],states[1]);
synchronized (engineStateLock) {
    long newState=ALLOCATED | RESUMED | LISTENING| FOCUS_ON;
    states=setEngineState(CLEAR_ALL_STATE,newState);
  }
  postEngineAllocated(states[0],states[1]);
}","/** 
 * Allocate the resources for the Engine and put it in the ALLOCATED, RESUMED, QUEUE_EMPTY state.
 */
public void allocate() throws EngineException, EngineStateError {
  if (testEngineState(ALLOCATED)) {
    return;
  }
  long[] states=setEngineState(CLEAR_ALL_STATE,ALLOCATING_RESOURCES);
  postEngineAllocatingResources(states[0],states[1]);
synchronized (engineStateLock) {
    long newState=ALLOCATED | RESUMED | LISTENING| FOCUS_ON;
    states=setEngineState(CLEAR_ALL_STATE,newState);
  }
  postEngineAllocated(states[0],states[1]);
  handleAllocate();
}",0.981981981981982
19781,"/** 
 * Collects the next set of emitting tokens from a token and accumulates them in the active or result lists
 * @param token the token to collect successors from
 */
protected void collectSuccessorTokens(Token token){
  SearchState state=token.getSearchState();
  if (token.isFinal()) {
    resultList.add(token);
  }
  if (token.getScore() < threshold) {
    return;
  }
  if (state instanceof WordSearchState && token.getScore() < wordThreshold) {
    return;
  }
  SearchStateArc[] arcs=state.getSuccessors();
  for (int i=0; i < arcs.length; i++) {
    SearchStateArc arc=arcs[i];
    SearchState nextState=arc.getState();
    float logEntryScore=token.getScore() + arc.getProbability();
    if (wantEntryPruning) {
      if (logEntryScore < threshold) {
        continue;
      }
      if (nextState instanceof WordSearchState && logEntryScore < wordThreshold) {
        continue;
      }
    }
    Token bestToken=getBestToken(nextState);
    boolean firstToken=bestToken == null;
    if (firstToken || bestToken.getScore() <= logEntryScore) {
      Token newToken=token.child(nextState,logEntryScore,arc.getLanguageProbability(),arc.getInsertionProbability(),currentFrameNumber);
      tokensCreated.value++;
      setBestToken(newToken,nextState);
      if (!newToken.isEmitting()) {
        collectSuccessorTokens(newToken);
      }
 else {
        if (firstToken) {
          activeList.add(newToken);
        }
 else {
          activeList.replace(bestToken,newToken);
          viterbiPruned.value++;
        }
      }
    }
 else {
      viterbiPruned.value++;
    }
  }
}","/** 
 * Collects the next set of emitting tokens from a token and accumulates them in the active or result lists
 * @param token the token to collect successors from
 */
protected void collectSuccessorTokens(Token token){
  SearchState state=token.getSearchState();
  if (token.isFinal()) {
    resultList.add(token);
  }
  if (token.getScore() < threshold) {
    return;
  }
  if (state instanceof WordSearchState && token.getScore() < wordThreshold) {
    return;
  }
  SearchStateArc[] arcs=state.getSuccessors();
  for (int i=0; i < arcs.length; i++) {
    SearchStateArc arc=arcs[i];
    SearchState nextState=arc.getState();
    float logEntryScore=token.getScore() + arc.getProbability();
    if (wantEntryPruning) {
      if (logEntryScore < threshold) {
        continue;
      }
      if (nextState instanceof WordSearchState && logEntryScore < wordThreshold) {
        continue;
      }
    }
    Token bestToken=getBestToken(nextState);
    boolean firstToken=bestToken == null;
    if (firstToken || bestToken.getScore() <= logEntryScore) {
      Token newToken=token.child(nextState,logEntryScore,arc.getLanguageProbability(),arc.getInsertionProbability(),currentFrameNumber);
      tokensCreated.value++;
      setBestToken(newToken,nextState);
      if (!newToken.isEmitting()) {
        if (!isVisited(newToken)) {
          collectSuccessorTokens(newToken);
        }
      }
 else {
        if (firstToken) {
          activeList.add(newToken);
        }
 else {
          activeList.replace(bestToken,newToken);
          viterbiPruned.value++;
        }
      }
    }
 else {
      viterbiPruned.value++;
    }
  }
}",0.9708617482951024
19782,"/** 
 * Collects the next set of emitting tokens from a token and accumulates them in the active or result lists
 * @param token the token to collect successors from be immediately expaned are placed. Null if we should always expand all nodes.
 */
protected void collectSuccessorTokens(Token token){
  if (token.isFinal()) {
    resultList.add(getWordPredecessor(token));
    return;
  }
  SearchState state=token.getSearchState();
  SearchStateArc[] arcs=state.getSuccessors();
  Token predecessor=getWordPredecessor(token);
  for (int i=0; i < arcs.length; i++) {
    SearchStateArc arc=arcs[i];
    SearchState nextState=arc.getState();
    if (checkStateOrder) {
      checkStateOrder(state,nextState);
    }
    float logEntryScore=token.getScore() + arc.getProbability();
    Token bestToken=getBestToken(nextState);
    boolean firstToken=bestToken == null;
    if (firstToken || bestToken.getScore() < logEntryScore) {
      Token newBestToken=new Token(predecessor,nextState,logEntryScore,arc.getLanguageProbability(),arc.getInsertionProbability(),currentFrameNumber);
      tokensCreated.value++;
      setBestToken(newBestToken,nextState);
      if (firstToken) {
        activeListAdd(newBestToken);
      }
 else {
        if (false) {
          System.out.println(""String_Node_Str"" + bestToken + ""String_Node_Str""+ newBestToken);
        }
        activeListReplace(bestToken,newBestToken);
        if (buildWordLattice && newBestToken.isWord()) {
          loserManager.changeSuccessor(newBestToken,bestToken);
          loserManager.addAlternatePredecessor(newBestToken,bestToken.getPredecessor());
        }
      }
    }
 else {
      if (buildWordLattice && nextState instanceof WordSearchState) {
        if (predecessor != null) {
          loserManager.addAlternatePredecessor(bestToken,predecessor);
        }
      }
    }
  }
}","/** 
 * Collects the next set of emitting tokens from a token and accumulates them in the active or result lists
 * @param token the token to collect successors from be immediately expaned are placed. Null if we should always expand all nodes.
 */
protected void collectSuccessorTokens(Token token){
  if (token.isFinal()) {
    resultList.add(getWordPredecessor(token));
    return;
  }
  if (!token.isEmitting() && (keepAllTokens && isVisited(token))) {
    return;
  }
  SearchState state=token.getSearchState();
  SearchStateArc[] arcs=state.getSuccessors();
  Token predecessor=getWordPredecessor(token);
  for (int i=0; i < arcs.length; i++) {
    SearchStateArc arc=arcs[i];
    SearchState nextState=arc.getState();
    if (checkStateOrder) {
      checkStateOrder(state,nextState);
    }
    float logEntryScore=token.getScore() + arc.getProbability();
    Token bestToken=getBestToken(nextState);
    boolean firstToken=bestToken == null;
    if (firstToken || bestToken.getScore() < logEntryScore) {
      Token newBestToken=new Token(predecessor,nextState,logEntryScore,arc.getLanguageProbability(),arc.getInsertionProbability(),currentFrameNumber);
      tokensCreated.value++;
      setBestToken(newBestToken,nextState);
      if (firstToken) {
        activeListAdd(newBestToken);
      }
 else {
        if (false) {
          System.out.println(""String_Node_Str"" + bestToken + ""String_Node_Str""+ newBestToken);
        }
        activeListReplace(bestToken,newBestToken);
        if (buildWordLattice && newBestToken.isWord()) {
          loserManager.changeSuccessor(newBestToken,bestToken);
          loserManager.addAlternatePredecessor(newBestToken,bestToken.getPredecessor());
        }
      }
    }
 else {
      if (buildWordLattice && nextState instanceof WordSearchState) {
        if (predecessor != null) {
          loserManager.addAlternatePredecessor(bestToken,predecessor);
        }
      }
    }
  }
}",0.9778247096092924
19783,"/** 
 * Get the Edges from this Node
 * @return Edges from this Node
 */
public Collection getEnteringEdges(){
  return enteringEdges;
}","/** 
 * Get the Edges to this Node
 * @return Edges to this Node
 */
public Collection getEnteringEdges(){
  return enteringEdges;
}",0.9701492537313432
19784,"/** 
 * Get the Edges to this Node
 * @return Edges to this Node
 */
public Collection getLeavingEdges(){
  return leavingEdges;
}","/** 
 * Get the Edges from this Node
 * @return Edges from this Node
 */
public Collection getLeavingEdges(){
  return leavingEdges;
}",0.9696969696969696
19785,"/** 
 * Reads one frame of audio data, and adds it to the given Utterance.
 * @return an Data object containing the audio data
 */
private Data readData(Utterance utterance) throws IOException {
  byte[] data=new byte[frameSizeInBytes];
  int channels=audioStream.getFormat().getChannels();
  long collectTime=System.currentTimeMillis();
  long firstSampleNumber=totalSamplesRead / channels;
  int numBytesRead=audioStream.read(data,0,data.length);
  if (!started) {
synchronized (this) {
      started=true;
      notifyAll();
    }
  }
  if (logger.isLoggable(Level.FINE)) {
    logger.info(""String_Node_Str"" + numBytesRead + ""String_Node_Str"");
  }
  if (numBytesRead <= 0) {
    endOfStream=true;
    return null;
  }
  int sampleSizeInBytes=audioStream.getFormat().getSampleSizeInBits() / 8;
  totalSamplesRead+=(numBytesRead / sampleSizeInBytes);
  if (numBytesRead != frameSizeInBytes) {
    if (numBytesRead % sampleSizeInBytes != 0) {
      throw new Error(""String_Node_Str"");
    }
    byte[] shrinked=new byte[numBytesRead];
    System.arraycopy(data,0,shrinked,0,numBytesRead);
    data=shrinked;
  }
  if (keepDataReference) {
    utterance.add(data);
  }
  double[] samples=DataUtil.bytesToValues(data,0,data.length,sampleSizeInBytes,signed);
  if (channels > 1) {
    samples=convertStereoToMono(samples,channels);
  }
  return (new DoubleData(samples,(int)audioStream.getFormat().getSampleRate(),collectTime,firstSampleNumber));
}","/** 
 * Reads one frame of audio data, and adds it to the given Utterance.
 * @return an Data object containing the audio data
 */
private Data readData(Utterance utterance) throws IOException {
  byte[] data=new byte[frameSizeInBytes];
  int channels=audioStream.getFormat().getChannels();
  long collectTime=System.currentTimeMillis();
  long firstSampleNumber=totalSamplesRead / channels;
  int numBytesRead=audioStream.read(data,0,data.length);
  if (!started) {
synchronized (this) {
      started=true;
      notifyAll();
    }
  }
  if (logger.isLoggable(Level.FINE)) {
    logger.info(""String_Node_Str"" + numBytesRead + ""String_Node_Str"");
  }
  if (numBytesRead <= 0) {
    return null;
  }
  int sampleSizeInBytes=audioStream.getFormat().getSampleSizeInBits() / 8;
  totalSamplesRead+=(numBytesRead / sampleSizeInBytes);
  if (numBytesRead != frameSizeInBytes) {
    if (numBytesRead % sampleSizeInBytes != 0) {
      throw new Error(""String_Node_Str"");
    }
    byte[] shrinked=new byte[numBytesRead];
    System.arraycopy(data,0,shrinked,0,numBytesRead);
    data=shrinked;
  }
  if (keepDataReference) {
    utterance.add(data);
  }
  double[] samples=DataUtil.bytesToValues(data,0,data.length,sampleSizeInBytes,signed);
  if (channels > 1) {
    samples=convertStereoToMono(samples,channels);
  }
  return (new DoubleData(samples,(int)audioStream.getFormat().getSampleRate(),collectTime,firstSampleNumber));
}",0.9923344947735192
19786,"/** 
 * Implements the run() method of the Thread class. Records audio, and cache them in the audio buffer.
 */
public void run(){
  totalSamplesRead=0;
  logger.info(""String_Node_Str"");
  if (keepDataReference) {
    currentUtterance=new Utterance(""String_Node_Str"",audioStream.getFormat());
  }
  audioList.add(new DataStartSignal());
  logger.info(""String_Node_Str"");
  try {
    audioLine.start();
    while (!endOfStream) {
      Data data=readData(currentUtterance);
      if (data == null) {
        break;
      }
      audioList.add(data);
    }
    audioLine.flush();
    if (closeBetweenUtterances) {
      audioStream.close();
    }
  }
 catch (  IOException ioe) {
    logger.warning(""String_Node_Str"" + ioe.getMessage());
  }
  long duration=(long)(((double)totalSamplesRead / (double)audioStream.getFormat().getSampleRate()) * 1000.0);
  audioList.add(new DataEndSignal(duration));
  logger.info(""String_Node_Str"");
  logger.info(""String_Node_Str"");
}","/** 
 * Implements the run() method of the Thread class. Records audio, and cache them in the audio buffer.
 */
public void run(){
  totalSamplesRead=0;
  logger.info(""String_Node_Str"");
  if (keepDataReference) {
    currentUtterance=new Utterance(""String_Node_Str"",audioStream.getFormat());
  }
  audioList.add(new DataStartSignal());
  logger.info(""String_Node_Str"");
  try {
    audioLine.start();
    while (!done) {
      Data data=readData(currentUtterance);
      if (data == null) {
        done=true;
        break;
      }
      audioList.add(data);
    }
    audioLine.flush();
    if (closeBetweenUtterances) {
      audioStream.close();
    }
  }
 catch (  IOException ioe) {
    logger.warning(""String_Node_Str"" + ioe.getMessage());
    ioe.printStackTrace();
  }
  long duration=(long)(((double)totalSamplesRead / (double)audioStream.getFormat().getSampleRate()) * 1000.0);
  audioList.add(new DataEndSignal(duration));
  logger.info(""String_Node_Str"");
  logger.info(""String_Node_Str"");
synchronized (lock) {
    lock.notify();
  }
}",0.9474206349206348
19787,"/** 
 * Starts recording audio. This method will return only when a START event is received, meaning that this Microphone has started capturing audio.
 * @return true if the recording started successfully; false otherwise
 */
public synchronized boolean startRecording(){
  if (recording) {
    return false;
  }
  if (!open()) {
    return false;
  }
  utteranceEndReached=false;
  recording=true;
  if (audioLine.isRunning()) {
    logger.severe(""String_Node_Str"");
  }
  RecordingThread recorder=new RecordingThread(""String_Node_Str"");
  recorder.start();
  return true;
}","/** 
 * Starts recording audio. This method will return only when a START event is received, meaning that this Microphone has started capturing audio.
 * @return true if the recording started successfully; false otherwise
 */
public synchronized boolean startRecording(){
  if (recording) {
    return false;
  }
  if (!open()) {
    return false;
  }
  utteranceEndReached=false;
  if (audioLine.isRunning()) {
    logger.severe(""String_Node_Str"");
  }
  assert(recorder == null);
  recorder=new RecordingThread(""String_Node_Str"");
  recorder.start();
  recording=true;
  return true;
}",0.9328743545611016
19788,"/** 
 * Constructs a Microphone with the given InputStream.
 * @throws IOException if an I/O error occurs
 */
public void initialize(){
  super.initialize();
  audioList=new DataList();
  DataLine.Info info=new DataLine.Info(TargetDataLine.class,desiredFormat);
  if (!AudioSystem.isLineSupported(info)) {
    logger.info(desiredFormat + ""String_Node_Str"");
    AudioFormat nativeFormat=getNativeAudioFormat(desiredFormat);
    if (nativeFormat == null) {
      logger.severe(""String_Node_Str"");
      return;
    }
 else {
      finalFormat=nativeFormat;
      doConversion=AudioSystem.isConversionSupported(desiredFormat,nativeFormat);
      if (doConversion) {
        logger.info(""String_Node_Str"" + finalFormat.getSampleRate() + ""String_Node_Str""+ desiredFormat.getSampleRate()+ ""String_Node_Str"");
      }
 else {
        logger.info(""String_Node_Str"" + finalFormat.getSampleRate() + ""String_Node_Str""+ desiredFormat.getSampleRate()+ ""String_Node_Str"");
      }
    }
  }
 else {
    logger.info(""String_Node_Str"" + desiredFormat + ""String_Node_Str"");
    finalFormat=desiredFormat;
  }
  try {
    logger.info(""String_Node_Str"" + finalFormat);
    info=new DataLine.Info(TargetDataLine.class,finalFormat);
    audioLine=(TargetDataLine)AudioSystem.getLine(info);
    audioLine.addLineListener(new LineListener(){
      public void update(      LineEvent event){
        logger.info(""String_Node_Str"" + event);
      }
    }
);
  }
 catch (  LineUnavailableException e) {
    logger.severe(""String_Node_Str"" + e.getMessage());
  }
}","/** 
 * Constructs a Microphone with the given InputStream.
 * @throws IOException if an I/O error occurs
 */
public void initialize(){
  super.initialize();
  audioList=new DataList();
  DataLine.Info info=new DataLine.Info(TargetDataLine.class,desiredFormat);
  if (!AudioSystem.isLineSupported(info)) {
    logger.info(desiredFormat + ""String_Node_Str"");
    AudioFormat nativeFormat=DataUtil.getNativeAudioFormat(desiredFormat);
    if (nativeFormat == null) {
      logger.severe(""String_Node_Str"");
      return;
    }
 else {
      finalFormat=nativeFormat;
      doConversion=AudioSystem.isConversionSupported(desiredFormat,nativeFormat);
      if (doConversion) {
        logger.info(""String_Node_Str"" + finalFormat.getSampleRate() + ""String_Node_Str""+ desiredFormat.getSampleRate()+ ""String_Node_Str"");
      }
 else {
        logger.info(""String_Node_Str"" + finalFormat.getSampleRate() + ""String_Node_Str""+ desiredFormat.getSampleRate()+ ""String_Node_Str"");
      }
    }
  }
 else {
    logger.info(""String_Node_Str"" + desiredFormat + ""String_Node_Str"");
    finalFormat=desiredFormat;
  }
  try {
    logger.info(""String_Node_Str"" + finalFormat);
    info=new DataLine.Info(TargetDataLine.class,finalFormat);
    audioLine=(TargetDataLine)AudioSystem.getLine(info);
    audioLine.addLineListener(new LineListener(){
      public void update(      LineEvent event){
        logger.info(""String_Node_Str"" + event);
      }
    }
);
  }
 catch (  LineUnavailableException e) {
    logger.severe(""String_Node_Str"" + e.getMessage());
  }
}",0.9970826580226904
19789,"/** 
 * Stops recording audio.
 */
public synchronized void stopRecording(){
  if (audioLine != null) {
    recording=false;
    audioLine.stop();
  }
}","/** 
 * Stops the thread. This method does not return until recording has actually stopped, and all the data has been read from the audio line.
 */
public void stopRecording(){
  audioLine.stop();
  try {
synchronized (lock) {
      while (!done) {
        lock.wait();
      }
    }
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
}",0.2569169960474308
19790,"/** 
 * Parses the given RuleName into a network of GrammarNodes.
 * @param initialRuleName the RuleName rule to parse
 * @return a grammar graph
 */
private GrammarGraph parseRuleName(RuleName initialRuleName) throws GrammarException {
  debugPrintln(""String_Node_Str"" + initialRuleName.toString());
  GrammarGraph result=(GrammarGraph)ruleNameStack.get(initialRuleName.getRuleName());
  if (result != null) {
    return result;
  }
 else {
    result=new GrammarGraph();
    ruleNameStack.put(initialRuleName.getRuleName(),result);
  }
  RuleName ruleName=ruleGrammar.resolve(initialRuleName);
  if (ruleName == RuleName.NULL) {
    result.getStartNode().add(result.getEndNode(),0.0f);
  }
 else   if (ruleName == RuleName.VOID) {
  }
 else {
    if (ruleName == null) {
      throw new GrammarException(""String_Node_Str"" + initialRuleName + ""String_Node_Str""+ initialRuleName.getFullGrammarName());
    }
    RuleGrammar rg=recognizer.getRuleGrammar(ruleName.getFullGrammarName());
    if (rg == null) {
      throw new GrammarException(""String_Node_Str"" + ruleName.getFullGrammarName());
    }
    Rule rule=rg.getRule(ruleName.getSimpleRuleName());
    if (rule == null) {
      throw new GrammarException(""String_Node_Str"" + ruleName.getRuleName());
    }
    GrammarGraph ruleResult=parseRule(rule);
    result.getStartNode().add(ruleResult.getStartNode(),0.0f);
    ruleResult.getEndNode().add(result.getEndNode(),0.0f);
    ruleNameStack.remove(ruleName.getRuleName());
  }
  return result;
}","/** 
 * Parses the given RuleName into a network of GrammarNodes.
 * @param initialRuleName the RuleName rule to parse
 * @return a grammar graph
 */
private GrammarGraph parseRuleName(RuleName initialRuleName) throws GrammarException {
  debugPrintln(""String_Node_Str"" + initialRuleName.toString());
  GrammarGraph result=(GrammarGraph)ruleNameStack.get(initialRuleName.getRuleName());
  if (false && result != null) {
    return result;
  }
 else {
    result=new GrammarGraph();
    ruleNameStack.put(initialRuleName.getRuleName(),result);
  }
  RuleName ruleName=ruleGrammar.resolve(initialRuleName);
  if (ruleName == RuleName.NULL) {
    result.getStartNode().add(result.getEndNode(),0.0f);
  }
 else   if (ruleName == RuleName.VOID) {
  }
 else {
    if (ruleName == null) {
      throw new GrammarException(""String_Node_Str"" + initialRuleName + ""String_Node_Str""+ initialRuleName.getFullGrammarName());
    }
    RuleGrammar rg=recognizer.getRuleGrammar(ruleName.getFullGrammarName());
    if (rg == null) {
      throw new GrammarException(""String_Node_Str"" + ruleName.getFullGrammarName());
    }
    Rule rule=rg.getRule(ruleName.getSimpleRuleName());
    if (rule == null) {
      throw new GrammarException(""String_Node_Str"" + ruleName.getRuleName());
    }
    GrammarGraph ruleResult=parseRule(rule);
    result.getStartNode().add(ruleResult.getStartNode(),0.0f);
    ruleResult.getEndNode().add(result.getEndNode(),0.0f);
    ruleNameStack.remove(ruleName.getRuleName());
  }
  return result;
}",0.9970109598140152
19791,"/** 
 * Saves the current configuration to the given file
 * @param file place to save the configuration
 * @throws IOException if an error occurs while writing to the file
 */
public void save(File file) throws IOException {
  FileOutputStream fos=new FileOutputStream(file);
  PrintWriter writer=new PrintWriter(fos);
  writer.println(""String_Node_Str"");
  writer.println();
  outputHeader(0,writer,""String_Node_Str"");
  writer.println();
  writer.println(""String_Node_Str"");
  outputHeader(2,writer,""String_Node_Str"");
  for (Iterator i=globalProperties.keySet().iterator(); i.hasNext(); ) {
    String name=(String)i.next();
    String value=(String)globalProperties.get(name);
    writer.println(""String_Node_Str"" + stripGlobalSymbol(name) + ""String_Node_Str""+ value+ ""String_Node_Str"");
  }
  writer.println();
  outputHeader(2,writer,""String_Node_Str"");
  String[] allNames=getInstanceNames(Object.class);
  for (int i=0; i < allNames.length; i++) {
    Symbol symbol=(Symbol)symbolTable.get(allNames[i]);
    PropertySheet ps=symbol.getPropertySheet();
    String[] names=ps.getNames();
    outputHeader(4,writer,symbol.getName());
    writer.println(""String_Node_Str"" + symbol.getName() + ""String_Node_Str""+ ""String_Node_Str""+ symbol.getObject().getClass().getName()+ ""String_Node_Str"");
    for (int j=0; j < names.length; j++) {
      Object obj=ps.getRawNoReplacment(names[j]);
      if (obj instanceof String) {
        String value=(String)obj;
        String pad=(value.length() > 25) ? ""String_Node_Str"" : ""String_Node_Str"";
        writer.println(""String_Node_Str"" + names[j] + ""String_Node_Str""+ pad+ ""String_Node_Str""+ value+ ""String_Node_Str"");
      }
 else       if (obj instanceof List) {
        List list=(List)obj;
        writer.println(""String_Node_Str"" + names[j] + ""String_Node_Str"");
        for (int k=0; k < list.size(); k++) {
          writer.println(""String_Node_Str"" + list.get(k) + ""String_Node_Str"");
        }
        writer.println(""String_Node_Str"");
      }
 else {
        throw new IOException(""String_Node_Str"");
      }
    }
    writer.println(""String_Node_Str"");
    writer.println();
  }
  writer.println(""String_Node_Str"");
  writer.println(""String_Node_Str"" + new Date() + ""String_Node_Str"");
  writer.close();
}","/** 
 * Saves the current configuration to the given file
 * @param file place to save the configuration
 * @throws IOException if an error occurs while writing to the file
 */
public void save(File file) throws IOException {
  FileOutputStream fos=new FileOutputStream(file);
  PrintWriter writer=new PrintWriter(fos);
  writer.println(""String_Node_Str"");
  writer.println();
  outputHeader(0,writer,""String_Node_Str"");
  writer.println();
  writer.println(""String_Node_Str"");
  outputHeader(2,writer,""String_Node_Str"");
  for (Iterator i=globalProperties.keySet().iterator(); i.hasNext(); ) {
    String name=(String)i.next();
    String value=(String)globalProperties.get(name);
    value=encodeValue(value);
    writer.println(""String_Node_Str"" + stripGlobalSymbol(name) + ""String_Node_Str""+ value+ ""String_Node_Str"");
  }
  writer.println();
  outputHeader(2,writer,""String_Node_Str"");
  String[] allNames=getInstanceNames(Object.class);
  for (int i=0; i < allNames.length; i++) {
    Symbol symbol=(Symbol)symbolTable.get(allNames[i]);
    PropertySheet ps=symbol.getPropertySheet();
    String[] names=ps.getNames();
    outputHeader(4,writer,symbol.getName());
    writer.println(""String_Node_Str"" + symbol.getName() + ""String_Node_Str""+ ""String_Node_Str""+ symbol.getObject().getClass().getName()+ ""String_Node_Str"");
    for (int j=0; j < names.length; j++) {
      Object obj=ps.getRawNoReplacment(names[j]);
      if (obj instanceof String) {
        String value=(String)obj;
        value=encodeValue(value);
        String pad=(value.length() > 25) ? ""String_Node_Str"" : ""String_Node_Str"";
        writer.println(""String_Node_Str"" + names[j] + ""String_Node_Str""+ pad+ ""String_Node_Str""+ value+ ""String_Node_Str"");
      }
 else       if (obj instanceof List) {
        List list=(List)obj;
        writer.println(""String_Node_Str"" + names[j] + ""String_Node_Str"");
        for (int k=0; k < list.size(); k++) {
          writer.println(""String_Node_Str"" + encodeValue(list.get(k).toString()) + ""String_Node_Str"");
        }
        writer.println(""String_Node_Str"");
      }
 else {
        throw new IOException(""String_Node_Str"");
      }
    }
    writer.println(""String_Node_Str"");
    writer.println();
  }
  writer.println(""String_Node_Str"");
  writer.println(""String_Node_Str"" + new Date() + ""String_Node_Str"");
  writer.close();
}",0.9809358752166378
19792,"/** 
 * Creates an OogHMMState
 * @param hmmState the hmm state associated with this search state
 * @parma logProbability the probability of transitioning to thisstate
 */
OogHMMState(HMMState hmmState,float logProbability){
  this.hmmState=hmmState;
  this.logProbability=logProbability;
}","/** 
 * Creates an OogHMMState
 * @param hmmState the hmm state associated with this search state
 * @param logProbability the probability of transitioning to thisstate
 */
OogHMMState(HMMState hmmState,float logProbability){
  this.hmmState=hmmState;
  this.logProbability=logProbability;
}",0.993127147766323
19793,"public void newProperties(PropertySheet ps) throws PropertyException {
  setupAcousticModel(ps);
  logMath=(LogMath)ps.getComponent(PROP_LOG_MATH,LogMath.class);
  grammar=(Grammar)ps.getComponent(PROP_GRAMMAR,Grammar.class);
  unitManager=(UnitManager)ps.getComponent(PROP_UNIT_MANAGER,UnitManager.class);
  logWordInsertionProbability=logMath.linearToLog(ps.getDouble(PROP_WORD_INSERTION_PROBABILITY,PROP_WORD_INSERTION_PROBABILITY_DEFAULT));
  logSilenceInsertionProbability=logMath.linearToLog(ps.getDouble(PROP_SILENCE_INSERTION_PROBABILITY,PROP_SILENCE_INSERTION_PROBABILITY_DEFAULT));
  logUnitInsertionProbability=logMath.linearToLog(ps.getDouble(PROP_UNIT_INSERTION_PROBABILITY,PROP_UNIT_INSERTION_PROBABILITY_DEFAULT));
  languageWeight=ps.getFloat(Linguist.PROP_LANGUAGE_WEIGHT,PROP_LANGUAGE_WEIGHT_DEFAULT);
  showSentenceHMM=ps.getBoolean(Linguist.PROP_SHOW_SEARCH_SPACE,PROP_SHOW_SEARCH_SPACE_DEFAULT);
  dumpGStates=ps.getBoolean(PROP_DUMP_GSTATES,PROP_DUMP_GSTATES_DEFAULT);
  showCompilationProgress=ps.getBoolean(PROP_SHOW_COMPILATION_PROGRESS,PROP_SHOW_COMPILATION_PROGRESS_DEFAULT);
  spreadWordProbabilitiesAcrossPronunciations=ps.getBoolean(PROP_SPREAD_WORD_PROBABILITIES_ACROSS_PRONUNCIATIONS,PROP_SPREAD_WORD_PROBABILITIES_ACROSS_PRONUNCIATIONS_DEFAULT);
  addOutOfGrammarBranch=ps.getBoolean(PROP_ADD_OUT_OF_GRAMMAR_BRANCH,PROP_ADD_OUT_OF_GRAMMAR_BRANCH_DEFAULT);
  logOutOfGrammarBranchProbability=logMath.linearToLog(ps.getDouble(PROP_OUT_OF_GRAMMAR_PROBABILITY,PROP_OUT_OF_GRAMMAR_PROBABILITY_DEFAULT));
  logPhoneInsertionProbability=logMath.linearToLog(ps.getDouble(PROP_PHONE_INSERTION_PROBABILITY,PROP_PHONE_INSERTION_PROBABILITY_DEFAULT));
}","public void newProperties(PropertySheet ps) throws PropertyException {
  setupAcousticModel(ps);
  logMath=(LogMath)ps.getComponent(PROP_LOG_MATH,LogMath.class);
  grammar=(Grammar)ps.getComponent(PROP_GRAMMAR,Grammar.class);
  unitManager=(UnitManager)ps.getComponent(PROP_UNIT_MANAGER,UnitManager.class);
  logWordInsertionProbability=logMath.linearToLog(ps.getDouble(PROP_WORD_INSERTION_PROBABILITY,PROP_WORD_INSERTION_PROBABILITY_DEFAULT));
  logSilenceInsertionProbability=logMath.linearToLog(ps.getDouble(PROP_SILENCE_INSERTION_PROBABILITY,PROP_SILENCE_INSERTION_PROBABILITY_DEFAULT));
  logUnitInsertionProbability=logMath.linearToLog(ps.getDouble(PROP_UNIT_INSERTION_PROBABILITY,PROP_UNIT_INSERTION_PROBABILITY_DEFAULT));
  languageWeight=ps.getFloat(Linguist.PROP_LANGUAGE_WEIGHT,PROP_LANGUAGE_WEIGHT_DEFAULT);
  showSentenceHMM=ps.getBoolean(Linguist.PROP_SHOW_SEARCH_SPACE,PROP_SHOW_SEARCH_SPACE_DEFAULT);
  dumpGStates=ps.getBoolean(PROP_DUMP_GSTATES,PROP_DUMP_GSTATES_DEFAULT);
  showCompilationProgress=ps.getBoolean(PROP_SHOW_COMPILATION_PROGRESS,PROP_SHOW_COMPILATION_PROGRESS_DEFAULT);
  spreadWordProbabilitiesAcrossPronunciations=ps.getBoolean(PROP_SPREAD_WORD_PROBABILITIES_ACROSS_PRONUNCIATIONS,PROP_SPREAD_WORD_PROBABILITIES_ACROSS_PRONUNCIATIONS_DEFAULT);
  addOutOfGrammarBranch=ps.getBoolean(PROP_ADD_OUT_OF_GRAMMAR_BRANCH,PROP_ADD_OUT_OF_GRAMMAR_BRANCH_DEFAULT);
  if (addOutOfGrammarBranch) {
    logOutOfGrammarBranchProbability=logMath.linearToLog(ps.getDouble(PROP_OUT_OF_GRAMMAR_PROBABILITY,PROP_OUT_OF_GRAMMAR_PROBABILITY_DEFAULT));
    logPhoneInsertionProbability=logMath.linearToLog(ps.getDouble(PROP_PHONE_INSERTION_PROBABILITY,PROP_PHONE_INSERTION_PROBABILITY_DEFAULT));
    phoneLoopAcousticModel=(AcousticModel)ps.getComponent(PROP_PHONE_LOOP_ACOUSTIC_MODEL,AcousticModel.class);
  }
}",0.9554030874785592
19794,"/** 
 * Allocates the acoustic model.
 */
protected void allocateAcousticModel() throws IOException {
  acousticModel.allocate();
}","/** 
 * Allocates the acoustic model.
 */
protected void allocateAcousticModel() throws IOException {
  acousticModel.allocate();
  if (addOutOfGrammarBranch) {
    phoneLoopAcousticModel.allocate();
  }
}",0.7797619047619048
19795,"/** 
 * Compiles the grammar into a sentence hmm. A GrammarJob is created for the initial grammar node and added to the GrammarJob queue. While there are jobs left on the grammar job queue, a job is removed from the queue and the associated grammar node is expanded and attached to the tails. GrammarJobs for the successors are added to the grammar job queue.
 */
protected Collection compileGrammar(){
  List gstateList=new ArrayList();
  Timer.start(""String_Node_Str"");
  Timer.start(""String_Node_Str"");
  for (Iterator i=grammar.getGrammarNodes().iterator(); i.hasNext(); ) {
    GState gstate=createGState((GrammarNode)i.next());
    gstateList.add(gstate);
  }
  Timer.stop(""String_Node_Str"");
  addStartingPath();
  Timer.start(""String_Node_Str"");
  for (Iterator i=gstateList.iterator(); i.hasNext(); ) {
    GState gstate=(GState)i.next();
    gstate.collectContexts();
  }
  Timer.stop(""String_Node_Str"");
  Timer.start(""String_Node_Str"");
  for (Iterator i=gstateList.iterator(); i.hasNext(); ) {
    GState gstate=(GState)i.next();
    gstate.expand();
  }
  Timer.stop(""String_Node_Str"");
  Timer.start(""String_Node_Str"");
  for (Iterator i=gstateList.iterator(); i.hasNext(); ) {
    GState gstate=(GState)i.next();
    gstate.connect();
  }
  Timer.stop(""String_Node_Str"");
  SentenceHMMState initialState=findStartingState();
  if (addOutOfGrammarBranch) {
    CIPhoneLoop phoneLoop=new CIPhoneLoop(acousticModel,logPhoneInsertionProbability);
    SentenceHMMState firstBranchState=(SentenceHMMState)phoneLoop.getSearchGraph().getInitialState();
    initialState.connect(getArc(firstBranchState,logOne,logOne,logOutOfGrammarBranchProbability));
  }
  searchGraph=new FlatSearchGraph(initialState);
  Timer.stop(""String_Node_Str"");
  if (dumpGStates) {
    for (Iterator i=grammar.getGrammarNodes().iterator(); i.hasNext(); ) {
      GState gstate=getGState((GrammarNode)i.next());
      gstate.dumpInfo();
    }
  }
  return SentenceHMMState.collectStates(initialState);
}","/** 
 * Compiles the grammar into a sentence hmm. A GrammarJob is created for the initial grammar node and added to the GrammarJob queue. While there are jobs left on the grammar job queue, a job is removed from the queue and the associated grammar node is expanded and attached to the tails. GrammarJobs for the successors are added to the grammar job queue.
 */
protected Collection compileGrammar(){
  List gstateList=new ArrayList();
  Timer.start(""String_Node_Str"");
  Timer.start(""String_Node_Str"");
  for (Iterator i=grammar.getGrammarNodes().iterator(); i.hasNext(); ) {
    GState gstate=createGState((GrammarNode)i.next());
    gstateList.add(gstate);
  }
  Timer.stop(""String_Node_Str"");
  addStartingPath();
  Timer.start(""String_Node_Str"");
  for (Iterator i=gstateList.iterator(); i.hasNext(); ) {
    GState gstate=(GState)i.next();
    gstate.collectContexts();
  }
  Timer.stop(""String_Node_Str"");
  Timer.start(""String_Node_Str"");
  for (Iterator i=gstateList.iterator(); i.hasNext(); ) {
    GState gstate=(GState)i.next();
    gstate.expand();
  }
  Timer.stop(""String_Node_Str"");
  Timer.start(""String_Node_Str"");
  for (Iterator i=gstateList.iterator(); i.hasNext(); ) {
    GState gstate=(GState)i.next();
    gstate.connect();
  }
  Timer.stop(""String_Node_Str"");
  SentenceHMMState initialState=findStartingState();
  if (addOutOfGrammarBranch) {
    CIPhoneLoop phoneLoop=new CIPhoneLoop(phoneLoopAcousticModel,logPhoneInsertionProbability);
    SentenceHMMState firstBranchState=(SentenceHMMState)phoneLoop.getSearchGraph().getInitialState();
    initialState.connect(getArc(firstBranchState,logOne,logOne,logOutOfGrammarBranchProbability));
  }
  searchGraph=new FlatSearchGraph(initialState);
  Timer.stop(""String_Node_Str"");
  if (dumpGStates) {
    for (Iterator i=grammar.getGrammarNodes().iterator(); i.hasNext(); ) {
      GState gstate=getGState((GrammarNode)i.next());
      gstate.dumpInfo();
    }
  }
  return SentenceHMMState.collectStates(initialState);
}",0.9972382626161184
19796,"public void register(String name,Registry registry) throws PropertyException {
  this.name=name;
  registry.register(PROP_GRAMMAR,PropertyType.COMPONENT);
  registry.register(PROP_ACOUSTIC_MODEL,PropertyType.COMPONENT);
  registry.register(PROP_LOG_MATH,PropertyType.COMPONENT);
  registry.register(PROP_WORD_INSERTION_PROBABILITY,PropertyType.DOUBLE);
  registry.register(PROP_SILENCE_INSERTION_PROBABILITY,PropertyType.DOUBLE);
  registry.register(PROP_UNIT_INSERTION_PROBABILITY,PropertyType.DOUBLE);
  registry.register(PROP_LANGUAGE_WEIGHT,PropertyType.FLOAT);
  registry.register(PROP_SHOW_SEARCH_SPACE,PropertyType.BOOLEAN);
  registry.register(PROP_DUMP_GSTATES,PropertyType.BOOLEAN);
  registry.register(PROP_SHOW_COMPILATION_PROGRESS,PropertyType.BOOLEAN);
  registry.register(PROP_SPREAD_WORD_PROBABILITIES_ACROSS_PRONUNCIATIONS,PropertyType.BOOLEAN);
  registry.register(PROP_UNIT_MANAGER,PropertyType.COMPONENT);
  registry.register(PROP_ADD_OUT_OF_GRAMMAR_BRANCH,PropertyType.BOOLEAN);
  registry.register(PROP_OUT_OF_GRAMMAR_PROBABILITY,PropertyType.DOUBLE);
  registry.register(PROP_PHONE_INSERTION_PROBABILITY,PropertyType.DOUBLE);
}","public void register(String name,Registry registry) throws PropertyException {
  this.name=name;
  registry.register(PROP_GRAMMAR,PropertyType.COMPONENT);
  registry.register(PROP_ACOUSTIC_MODEL,PropertyType.COMPONENT);
  registry.register(PROP_LOG_MATH,PropertyType.COMPONENT);
  registry.register(PROP_WORD_INSERTION_PROBABILITY,PropertyType.DOUBLE);
  registry.register(PROP_SILENCE_INSERTION_PROBABILITY,PropertyType.DOUBLE);
  registry.register(PROP_UNIT_INSERTION_PROBABILITY,PropertyType.DOUBLE);
  registry.register(PROP_LANGUAGE_WEIGHT,PropertyType.FLOAT);
  registry.register(PROP_SHOW_SEARCH_SPACE,PropertyType.BOOLEAN);
  registry.register(PROP_DUMP_GSTATES,PropertyType.BOOLEAN);
  registry.register(PROP_SHOW_COMPILATION_PROGRESS,PropertyType.BOOLEAN);
  registry.register(PROP_SPREAD_WORD_PROBABILITIES_ACROSS_PRONUNCIATIONS,PropertyType.BOOLEAN);
  registry.register(PROP_UNIT_MANAGER,PropertyType.COMPONENT);
  registry.register(PROP_ADD_OUT_OF_GRAMMAR_BRANCH,PropertyType.BOOLEAN);
  registry.register(PROP_OUT_OF_GRAMMAR_PROBABILITY,PropertyType.DOUBLE);
  registry.register(PROP_PHONE_INSERTION_PROBABILITY,PropertyType.DOUBLE);
  registry.register(PROP_PHONE_LOOP_ACOUSTIC_MODEL,PropertyType.COMPONENT);
}",0.968013468013468
19797,"/** 
 * Sets the current recognizer to the one with the given name.
 * @param recognizerName name of the recognizer to use
 */
public void setDecoder(String recognizerName) throws IOException {
  String changeMessage=""String_Node_Str"" + recognizerName + ""String_Node_Str"";
  info(changeMessage);
  liveFrame.setMessage(changeMessage);
  if (currentRecognizer != null) {
    currentRecognizer.deallocate();
    currentRecognizer=null;
  }
  LiveRecognizer nextRecognizer=(LiveRecognizer)recognizers.get(recognizerName);
  if (nextRecognizer.allocate()) {
    currentRecognizer=nextRecognizer;
    liveFrame.setTestFile(currentRecognizer.getTestFile());
    if (!handsFree) {
      liveFrame.setReferenceLabel(currentRecognizer.getNextReference());
    }
 else {
      liveFrame.setReferenceLabel(""String_Node_Str"");
    }
    liveFrame.setRecognitionLabel(""String_Node_Str"");
    liveFrame.setMessage(recognizerName + ""String_Node_Str"");
  }
 else {
    liveFrame.setMessage(""String_Node_Str"" + recognizerName);
  }
  info(""String_Node_Str"");
}","/** 
 * Sets the current recognizer to the one with the given name.
 * @param recognizerName name of the recognizer to use
 */
public void setDecoder(String recognizerName) throws IOException {
  String changeMessage=""String_Node_Str"" + recognizerName + ""String_Node_Str"";
  info(changeMessage);
  liveFrame.setMessage(changeMessage);
  liveFrame.setSpeakButtonEnabled(false);
  liveFrame.setNextButtonEnabled(false);
  if (currentRecognizer != null) {
    currentRecognizer.deallocate();
    currentRecognizer=null;
  }
  LiveRecognizer nextRecognizer=(LiveRecognizer)recognizers.get(recognizerName);
  if (nextRecognizer.allocate()) {
    currentRecognizer=nextRecognizer;
    liveFrame.setTestFile(currentRecognizer.getTestFile());
    if (!handsFree) {
      liveFrame.setReferenceLabel(currentRecognizer.getNextReference());
    }
 else {
      liveFrame.setReferenceLabel(""String_Node_Str"");
    }
    liveFrame.setRecognitionLabel(""String_Node_Str"");
    liveFrame.setSpeakButtonEnabled(true);
    liveFrame.setNextButtonEnabled(true);
    liveFrame.setMessage(recognizerName + ""String_Node_Str"");
  }
 else {
    liveFrame.setMessage(""String_Node_Str"" + recognizerName);
  }
  info(""String_Node_Str"");
}",0.9254658385093169
19798,"public void run(){
  speakButton.setEnabled(!speaking);
  stopButton.setEnabled(speaking);
  playButton.setEnabled(!speaking);
  decoderComboBox.setEnabled(!speaking);
}","public void run(){
  String decoderName=(String)getSelectedItem();
  try {
    live.setDecoder(decoderName);
    lastIndex=getSelectedIndex();
  }
 catch (  IOException ioe) {
    setMessage(""String_Node_Str"" + decoderName);
  }
}",0.1152882205513784
19799,"/** 
 * Invoked when an action is performed on this DecoderComboBox.
 * @param e the ActionEvent performed
 */
public void actionPerformed(ActionEvent e){
  if (getSelectedIndex() != lastIndex) {
    try {
      String decoderName=(String)getSelectedItem();
      live.setDecoder(decoderName);
      lastIndex=getSelectedIndex();
    }
 catch (    IOException ioe) {
      ioe.printStackTrace();
    }
  }
}","/** 
 * Invoked when an action is performed on this DecoderComboBox.
 * @param e the ActionEvent performed
 */
public void actionPerformed(ActionEvent e){
  if (getSelectedIndex() != lastIndex) {
    Thread t=new Thread(){
      public void run(){
        String decoderName=(String)getSelectedItem();
        try {
          live.setDecoder(decoderName);
          lastIndex=getSelectedIndex();
        }
 catch (        IOException ioe) {
          setMessage(""String_Node_Str"" + decoderName);
        }
      }
    }
;
    t.start();
  }
}",0.672286617492097
19800,"/** 
 * Create the Panel where all the buttons are.
 * @return a Panel with buttons on it.
 */
private JPanel createButtonPanel(){
  JPanel buttonPanel=getJPanel(new FlowLayout());
  speakButton=new JButton(""String_Node_Str"");
  speakButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent ae){
      if (speakButton.isEnabled()) {
        enterSpeakingMode();
      }
    }
  }
);
  stopButton=new JButton(""String_Node_Str"");
  stopButton.setEnabled(false);
  stopButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent ae){
      stopButton.setEnabled(false);
      setMessage(""String_Node_Str"");
      live.stopRecording();
    }
  }
);
  if (!handsFree) {
    nextButton=new JButton(""String_Node_Str"");
    nextButton.addActionListener(new ActionListener(){
      public void actionPerformed(      ActionEvent e){
        setReferenceLabel(live.getNextReference());
        setRecognitionLabel(""String_Node_Str"");
      }
    }
);
  }
  playButton=new JButton(""String_Node_Str"");
  playButton.setEnabled(false);
  playButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      setRecognitionLabel(""String_Node_Str"");
      live.playUtterance();
    }
  }
);
  JButton exitButton=new JButton(""String_Node_Str"");
  exitButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      live.terminate();
      System.exit(0);
    }
  }
);
  buttonPanel.add(speakButton);
  buttonPanel.add(stopButton);
  if (nextButton != null) {
    buttonPanel.add(nextButton);
  }
  buttonPanel.add(playButton);
  buttonPanel.add(exitButton);
  return buttonPanel;
}","/** 
 * Create the Panel where all the buttons are.
 * @return a Panel with buttons on it.
 */
private JPanel createButtonPanel(){
  JPanel buttonPanel=getJPanel(new FlowLayout());
  speakButton=new JButton(""String_Node_Str"");
  speakButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent ae){
      if (speakButton.isEnabled()) {
        Thread t=new Thread(){
          public void run(){
            enterSpeakingMode();
          }
        }
;
        t.start();
      }
    }
  }
);
  stopButton=new JButton(""String_Node_Str"");
  stopButton.setEnabled(false);
  stopButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent ae){
      stopButton.setEnabled(false);
      setMessage(""String_Node_Str"");
      live.stopRecording();
    }
  }
);
  if (!handsFree) {
    nextButton=new JButton(""String_Node_Str"");
    nextButton.addActionListener(new ActionListener(){
      public void actionPerformed(      ActionEvent e){
        setReferenceLabel(live.getNextReference());
        setRecognitionLabel(""String_Node_Str"");
      }
    }
);
  }
  playButton=new JButton(""String_Node_Str"");
  playButton.setEnabled(false);
  playButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      setRecognitionLabel(""String_Node_Str"");
      live.playUtterance();
    }
  }
);
  JButton exitButton=new JButton(""String_Node_Str"");
  exitButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      System.exit(0);
    }
  }
);
  buttonPanel.add(speakButton);
  buttonPanel.add(stopButton);
  if (nextButton != null) {
    buttonPanel.add(nextButton);
  }
  buttonPanel.add(playButton);
  buttonPanel.add(exitButton);
  return buttonPanel;
}",0.9627311522048364
19801,"/** 
 * Converts strings like ""thisIsAString"" into ""This Is A String"".
 * @return a readable form of strings like ""thisIsAString""
 */
private String getReadableForm(String original){
  if (original.length() > 0) {
    StringBuffer sb=new StringBuffer(original.length() * 2);
    int i=0;
    sb.append(Character.toUpperCase(original.charAt(i++)));
    for (; i < original.length(); i++) {
      char c=original.charAt(i);
      if (Character.isUpperCase(c)) {
        sb.append(""String_Node_Str"");
      }
      sb.append(c);
    }
    return sb.toString();
  }
 else {
    return original;
  }
}","/** 
 * Converts strings like ""thisIsAString"" into ""This Is A String"".
 * @param original the original string
 * @return a readable form of strings like ""thisIsAString""
 */
private String getReadableForm(String original){
  if (original.length() > 0) {
    StringBuffer sb=new StringBuffer(original.length() * 2);
    int i=0;
    sb.append(Character.toUpperCase(original.charAt(i++)));
    for (; i < original.length(); i++) {
      char c=original.charAt(i);
      if (Character.isUpperCase(c)) {
        sb.append(""String_Node_Str"");
      }
      sb.append(c);
    }
    return sb.toString();
  }
 else {
    return original;
  }
}",0.9683184402924452
19802,"public static void main(String[] argv){
  try {
    PropertiesDumper dumper=new PropertiesDumper(""String_Node_Str"");
    System.out.println();
    System.out.println(dumper.toString());
  }
 catch (  IOException ioe) {
    ioe.printStackTrace();
  }
}","/** 
 * Dumps the properties file 'model.props' that is in the same directory as this class.
 */
public static void main(String[] argv){
  try {
    PropertiesDumper dumper=new PropertiesDumper(""String_Node_Str"");
    System.out.println();
    System.out.println(dumper.toString());
  }
 catch (  IOException ioe) {
    ioe.printStackTrace();
  }
}",0.8380634390651085
19803,"/** 
 * Returns a string that describes this TiedStateAcousticModel.
 */
public String toString(){
  String result=((String)props.get(""String_Node_Str"")) + ""String_Node_Str"";
  for (Enumeration e=props.propertyNames(); e.hasMoreElements(); ) {
    String key=(String)e.nextElement();
    String value=(String)props.get(key);
    result+=(""String_Node_Str"" + getReadableForm(key) + ""String_Node_Str""+ value);
  }
  result+=""String_Node_Str"";
  return result;
}","/** 
 * Returns a string of the properties.
 * @return a string of the properties
 */
public String toString(){
  String result=((String)props.get(""String_Node_Str"")) + ""String_Node_Str"";
  for (Enumeration e=props.propertyNames(); e.hasMoreElements(); ) {
    String key=(String)e.nextElement();
    String value=(String)props.get(key);
    result+=(""String_Node_Str"" + getReadableForm(key) + ""String_Node_Str""+ value);
  }
  result+=""String_Node_Str"";
  return result;
}",0.9044038668098818
19804,"/** 
 * Constructs a PropertiesDumper of the given acoustic model properties.
 */
public PropertiesDumper(Properties properties) throws IOException {
  props=properties;
}","/** 
 * Constructs a PropertiesDumper of the given acoustic model properties.
 * @param properties the Properties object to dump
 */
public PropertiesDumper(Properties properties) throws IOException {
  props=properties;
}",0.8702290076335878
19805,"/** 
 * Expand the pronunciation given the left context
 * @param leftContext the left context
 * @param pronunciation the pronunciation to expand
 * @param which unique ID for this pronunciation
 */
private void expandPronunciation(UnitContext leftContext,Pronunciation pronunciation,int which){
  UnitContext startingContext=getStartingContext(pronunciation);
  String pname=""String_Node_Str"" + pronunciation.getWord() + ""String_Node_Str""+ leftContext+ ""String_Node_Str""+ startingContext+ ""String_Node_Str"";
  PronunciationState ps=new PronunciationState(pname,pronunciation,which);
  T(""String_Node_Str"" + ps.getPronunciation() + ""String_Node_Str""+ leftContext);
  ContextPair cp=ContextPair.get(leftContext,startingContext);
  List epList=(List)entryPoints.get(cp);
  if (epList == null) {
    throw new Error(""String_Node_Str"" + cp);
  }
 else {
    epList.add(ps);
  }
  Unit[] units=pronunciation.getUnits();
  int fanOutPoint=units.length - getRightContextSize();
  if (fanOutPoint < 0) {
    fanOutPoint=0;
  }
  SentenceHMMState tail=ps;
  for (int i=0; tail != null && i < fanOutPoint; i++) {
    tail=attachUnit(ps,tail,units,i,leftContext,UnitContext.EMPTY);
  }
  SentenceHMMState branchTail=tail;
  for (Iterator iter=rightContexts.iterator(); iter.hasNext(); ) {
    UnitContext finalRightContext=(UnitContext)iter.next();
    tail=branchTail;
    for (int i=fanOutPoint; tail != null && i < units.length; i++) {
      tail=attachUnit(ps,tail,units,i,leftContext,finalRightContext);
    }
  }
}","/** 
 * Expand the pronunciation given the left context
 * @param leftContext the left context
 * @param pronunciation the pronunciation to expand
 * @param which unique ID for this pronunciation
 */
private void expandPronunciation(UnitContext leftContext,Pronunciation pronunciation,int which){
  UnitContext startingContext=getStartingContext(pronunciation);
  String pname=""String_Node_Str"" + pronunciation.getWord() + ""String_Node_Str""+ leftContext+ ""String_Node_Str""+ startingContext+ ""String_Node_Str""+ getNode().getID();
  PronunciationState ps=new PronunciationState(pname,pronunciation,which);
  T(""String_Node_Str"" + ps.getPronunciation() + ""String_Node_Str""+ leftContext);
  ContextPair cp=ContextPair.get(leftContext,startingContext);
  List epList=(List)entryPoints.get(cp);
  if (epList == null) {
    throw new Error(""String_Node_Str"" + cp);
  }
 else {
    epList.add(ps);
  }
  Unit[] units=pronunciation.getUnits();
  int fanOutPoint=units.length - getRightContextSize();
  if (fanOutPoint < 0) {
    fanOutPoint=0;
  }
  SentenceHMMState tail=ps;
  for (int i=0; tail != null && i < fanOutPoint; i++) {
    tail=attachUnit(ps,tail,units,i,leftContext,UnitContext.EMPTY);
  }
  SentenceHMMState branchTail=tail;
  for (Iterator iter=rightContexts.iterator(); iter.hasNext(); ) {
    UnitContext finalRightContext=(UnitContext)iter.next();
    tail=branchTail;
    for (int i=fanOutPoint; tail != null && i < units.length; i++) {
      tail=attachUnit(ps,tail,units,i,leftContext,finalRightContext);
    }
  }
}",0.993747943402435
19806,"public void newProperties(PropertySheet ps) throws PropertyException {
  Recognizer newRecognizer=(Recognizer)ps.getComponent(PROP_RECOGNIZER,Recognizer.class);
  if (recognizer == null) {
    recognizer=newRecognizer;
  }
 else   if (recognizer != newRecognizer) {
    recognizer.removeResultListener(this);
    recognizer.removeStateListener(this);
    recognizer=newRecognizer;
  }
  recognizer.addResultListener(this);
  recognizer.addStateListener(this);
  showSummary=ps.getBoolean(PROP_SHOW_SUMMARY,PROP_SHOW_SUMMARY_DEFAULT);
  showDetails=ps.getBoolean(PROP_SHOW_DETAILS,PROP_SHOW_DETAILS_DEFAULT);
  showResults=ps.getBoolean(PROP_SHOW_RESULTS,PROP_SHOW_RESULTS_DEFAULT);
  showAlignedResults=ps.getBoolean(PROP_SHOW_ALIGNED_RESULTS,PROP_SHOW_ALIGNED_RESULTS_DEFAULT);
  showRaw=ps.getBoolean(PROP_SHOW_RAW_RESULTS,PROP_SHOW_RAW_RESULTS_DEFAULT);
  aligner=new NISTAlign(showResults,showAlignedResults);
}","public void newProperties(PropertySheet ps) throws PropertyException {
  Recognizer newRecognizer=(Recognizer)ps.getComponent(PROP_RECOGNIZER,Recognizer.class);
  if (recognizer == null) {
    recognizer=newRecognizer;
    recognizer.addResultListener(this);
    recognizer.addStateListener(this);
  }
 else   if (recognizer != newRecognizer) {
    recognizer.removeResultListener(this);
    recognizer.removeStateListener(this);
    recognizer=newRecognizer;
    recognizer.addResultListener(this);
    recognizer.addStateListener(this);
  }
  showSummary=ps.getBoolean(PROP_SHOW_SUMMARY,PROP_SHOW_SUMMARY_DEFAULT);
  showDetails=ps.getBoolean(PROP_SHOW_DETAILS,PROP_SHOW_DETAILS_DEFAULT);
  showResults=ps.getBoolean(PROP_SHOW_RESULTS,PROP_SHOW_RESULTS_DEFAULT);
  showAlignedResults=ps.getBoolean(PROP_SHOW_ALIGNED_RESULTS,PROP_SHOW_ALIGNED_RESULTS_DEFAULT);
  showRaw=ps.getBoolean(PROP_SHOW_RAW_RESULTS,PROP_SHOW_RAW_RESULTS_DEFAULT);
  aligner=new NISTAlign(showResults,showAlignedResults);
}",0.8782017773131208
19807,"public void newProperties(PropertySheet ps) throws PropertyException {
  Recognizer newRecognizer=(Recognizer)ps.getComponent(PROP_RECOGNIZER,Recognizer.class);
  if (recognizer == null) {
    recognizer=newRecognizer;
  }
 else   if (recognizer != newRecognizer) {
    recognizer.removeResultListener(this);
    recognizer.removeStateListener(this);
    recognizer=newRecognizer;
  }
  recognizer.addResultListener(this);
  recognizer.addStateListener(this);
  logMath=(LogMath)ps.getComponent(PROP_LOG_MATH,LogMath.class);
  showSummary=ps.getBoolean(PROP_SHOW_SUMMARY,PROP_SHOW_SUMMARY_DEFAULT);
  showDetails=ps.getBoolean(PROP_SHOW_DETAILS,PROP_SHOW_DETAILS_DEFAULT);
  enabled=ps.getBoolean(PROP_ENABLED,PROP_ENABLED_DEFAULT);
}","public void newProperties(PropertySheet ps) throws PropertyException {
  Recognizer newRecognizer=(Recognizer)ps.getComponent(PROP_RECOGNIZER,Recognizer.class);
  if (recognizer == null) {
    recognizer=newRecognizer;
    recognizer.addResultListener(this);
    recognizer.addStateListener(this);
  }
 else   if (recognizer != newRecognizer) {
    recognizer.removeResultListener(this);
    recognizer.removeStateListener(this);
    recognizer=newRecognizer;
    recognizer.addResultListener(this);
    recognizer.addStateListener(this);
  }
  logMath=(LogMath)ps.getComponent(PROP_LOG_MATH,LogMath.class);
  showSummary=ps.getBoolean(PROP_SHOW_SUMMARY,PROP_SHOW_SUMMARY_DEFAULT);
  showDetails=ps.getBoolean(PROP_SHOW_DETAILS,PROP_SHOW_DETAILS_DEFAULT);
  enabled=ps.getBoolean(PROP_ENABLED,PROP_ENABLED_DEFAULT);
}",0.8497743391360413
19808,"public void newProperties(PropertySheet ps) throws PropertyException {
  Recognizer newRecognizer=(Recognizer)ps.getComponent(PROP_RECOGNIZER,Recognizer.class);
  if (recognizer == null) {
    recognizer=newRecognizer;
  }
 else   if (recognizer != newRecognizer) {
    recognizer.removeResultListener(this);
    recognizer.removeStateListener(this);
    recognizer=newRecognizer;
  }
  recognizer.addResultListener(this);
  recognizer.addStateListener(this);
  showSummary=ps.getBoolean(PROP_SHOW_SUMMARY,PROP_SHOW_SUMMARY_DEFAULT);
  showDetails=ps.getBoolean(PROP_SHOW_DETAILS,PROP_SHOW_DETAILS_DEFAULT);
}","public void newProperties(PropertySheet ps) throws PropertyException {
  Recognizer newRecognizer=(Recognizer)ps.getComponent(PROP_RECOGNIZER,Recognizer.class);
  if (recognizer == null) {
    recognizer=newRecognizer;
    recognizer.addResultListener(this);
    recognizer.addStateListener(this);
  }
 else   if (recognizer != newRecognizer) {
    recognizer.removeResultListener(this);
    recognizer.removeStateListener(this);
    recognizer=newRecognizer;
    recognizer.addResultListener(this);
    recognizer.addStateListener(this);
  }
  showSummary=ps.getBoolean(PROP_SHOW_SUMMARY,PROP_SHOW_SUMMARY_DEFAULT);
  showDetails=ps.getBoolean(PROP_SHOW_DETAILS,PROP_SHOW_DETAILS_DEFAULT);
}",0.8209069946195234
19809,"public void newProperties(PropertySheet ps) throws PropertyException {
  Recognizer newRecognizer=(Recognizer)ps.getComponent(PROP_RECOGNIZER,Recognizer.class);
  if (recognizer == null) {
    recognizer=newRecognizer;
  }
 else   if (recognizer != newRecognizer) {
    recognizer.removeStateListener(this);
    recognizer=newRecognizer;
  }
  recognizer.addStateListener(this);
  allocatedMonitors=ps.getComponentList(PROP_ALLOCATED_MONITORS,Runnable.class);
  deallocatedMonitors=ps.getComponentList(PROP_DEALLOCATED_MONITORS,Runnable.class);
}","public void newProperties(PropertySheet ps) throws PropertyException {
  Recognizer newRecognizer=(Recognizer)ps.getComponent(PROP_RECOGNIZER,Recognizer.class);
  if (recognizer == null) {
    recognizer=newRecognizer;
    recognizer.addStateListener(this);
  }
 else   if (recognizer != newRecognizer) {
    recognizer.removeStateListener(this);
    recognizer=newRecognizer;
    recognizer.addStateListener(this);
  }
  allocatedMonitors=ps.getComponentList(PROP_ALLOCATED_MONITORS,Runnable.class);
  deallocatedMonitors=ps.getComponentList(PROP_DEALLOCATED_MONITORS,Runnable.class);
}",0.8984995586937334
19810,"public void newProperties(PropertySheet ps) throws PropertyException {
  Recognizer newRecognizer=(Recognizer)ps.getComponent(PROP_RECOGNIZER,Recognizer.class);
  if (recognizer == null) {
    recognizer=newRecognizer;
  }
 else   if (recognizer != newRecognizer) {
    recognizer.removeResultListener(this);
    recognizer.removeStateListener(this);
    recognizer=newRecognizer;
  }
  recognizer.addResultListener(this);
  recognizer.addStateListener(this);
  FrontEnd newFrontEnd=(FrontEnd)ps.getComponent(PROP_FRONTEND,FrontEnd.class);
  if (frontEnd == null) {
    frontEnd=newFrontEnd;
  }
 else   if (frontEnd != newFrontEnd) {
    frontEnd.removeSignalListener(this);
    frontEnd=newFrontEnd;
  }
  frontEnd.addSignalListener(this);
  showSummary=ps.getBoolean(PROP_SHOW_SUMMARY,PROP_SHOW_SUMMARY_DEFAULT);
  showDetails=ps.getBoolean(PROP_SHOW_DETAILS,PROP_SHOW_DETAILS_DEFAULT);
  showResponseTime=ps.getBoolean(PROP_SHOW_RESPONSE_TIME,PROP_SHOW_RESPONSE_TIME_DEFAULT);
  showTimers=ps.getBoolean(PROP_SHOW_TIMERS,PROP_SHOW_TIMERS_DEFAULT);
}","public void newProperties(PropertySheet ps) throws PropertyException {
  Recognizer newRecognizer=(Recognizer)ps.getComponent(PROP_RECOGNIZER,Recognizer.class);
  if (recognizer == null) {
    recognizer=newRecognizer;
    recognizer.addResultListener(this);
    recognizer.addStateListener(this);
  }
 else   if (recognizer != newRecognizer) {
    recognizer.removeResultListener(this);
    recognizer.removeStateListener(this);
    recognizer=newRecognizer;
    recognizer.addResultListener(this);
    recognizer.addStateListener(this);
  }
  FrontEnd newFrontEnd=(FrontEnd)ps.getComponent(PROP_FRONTEND,FrontEnd.class);
  if (frontEnd == null) {
    frontEnd=newFrontEnd;
    frontEnd.addSignalListener(this);
  }
 else   if (frontEnd != newFrontEnd) {
    frontEnd.removeSignalListener(this);
    frontEnd=newFrontEnd;
    frontEnd.addSignalListener(this);
  }
  showSummary=ps.getBoolean(PROP_SHOW_SUMMARY,PROP_SHOW_SUMMARY_DEFAULT);
  showDetails=ps.getBoolean(PROP_SHOW_DETAILS,PROP_SHOW_DETAILS_DEFAULT);
  showResponseTime=ps.getBoolean(PROP_SHOW_RESPONSE_TIME,PROP_SHOW_RESPONSE_TIME_DEFAULT);
  showTimers=ps.getBoolean(PROP_SHOW_TIMERS,PROP_SHOW_TIMERS_DEFAULT);
}",0.845222072678331
19811,"/** 
 * Sets the level of output
 * @param level the output level
 */
public void setTerse(boolean terse){
  this.terse=terse;
}","/** 
 * Sets the level of output
 * @param terse if true, the output level should be terse
 */
public void setTerse(boolean terse){
  this.terse=terse;
}",0.8896797153024911
19812,"/** 
 * Constructs a FeatureFileDumper.
 * @param cm the Sphinx configuration manager
 * @param inputAudioFile the name of the input file 
 * @param inputAudioFile the input audio file
 */
public FeatureFileDumper(ConfigurationManager cm,String frontEndName,String inputAudioFile) throws FileNotFoundException, IOException {
  try {
    frontEnd=(FrontEnd)cm.lookup(frontEndName);
    StreamDataSource audioSource=(StreamDataSource)cm.lookup(""String_Node_Str"");
    audioSource.setInputStream(new FileInputStream(inputAudioFile),""String_Node_Str"");
    allFeatures=new LinkedList();
    getAllFeatures();
    logger.info(""String_Node_Str"" + allFeatures.size());
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","/** 
 * Constructs a FeatureFileDumper.
 * @param cm the Sphinx configuration manager
 * @param inputAudioFile the input audio file
 */
public FeatureFileDumper(ConfigurationManager cm,String frontEndName,String inputAudioFile) throws FileNotFoundException, IOException {
  try {
    frontEnd=(FrontEnd)cm.lookup(frontEndName);
    StreamDataSource audioSource=(StreamDataSource)cm.lookup(""String_Node_Str"");
    audioSource.setInputStream(new FileInputStream(inputAudioFile),""String_Node_Str"");
    allFeatures=new LinkedList();
    getAllFeatures();
    logger.info(""String_Node_Str"" + allFeatures.size());
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.9618430525557956
19813,"/** 
 * Scores the given set of Tokens. All Tokens in the given list are assumed to belong to the same acoustic model.
 * @param scoreableList a list containing StateToken objects tobe scored
 * @return true if there are more features available
 */
public boolean calculateScores(List scoreableList){
}","/** 
 * Scores the given set of Tokens. All Tokens in the given list are assumed to belong to the same acoustic model.
 * @param scoreableList a list containing StateToken objects tobe scored
 * @return the best scoring scorable, or null if there areno more frames to score
 */
public Scoreable calculateScores(List scoreableList){
}",0.8692913385826772
19814,"/** 
 * Initializes this SimpleAcousticScorer with the given context and FrontEnd.
 * @param context the context to use
 * @param frontend the FrontEnd to use
 */
public void initialize(String context,FrontEnd frontend){
  this.frontEnd=frontend;
  this.props=SphinxProperties.getSphinxProperties(context);
}","/** 
 * Initializes this SimpleAcousticScorer with the given context and FrontEnd.
 * @param context the context to use
 * @param frontend the FrontEnd to use
 */
public void initialize(String context,FrontEnd frontend){
  this.props=SphinxProperties.getSphinxProperties(context);
}",0.9559322033898304
19815,"/** 
 * Creates the ActiveLists used for decoding. There is one ActiveList created for each feature stream (or acoustic model), and also an ActiveList to do the overall pruning.
 */
private void createInitialLists(){
  String activeListName=props.getString(PROP_ACTIVE_LIST_TYPE,PROP_ACTIVE_LIST_TYPE_DEFAULT);
  try {
    Class activeListClass=Class.forName(activeListName);
    combinedActiveList=getActiveList(activeListClass,props);
    delayedExpansionList=getActiveList(activeListClass,props);
    SentenceHMMState firstState=(SentenceHMMState)linguist.getInitialSearchState();
    CombineToken firstToken=new CombineToken(null,firstState,currentFrameNumber);
    setBestToken(firstState,firstToken);
    for (Iterator i=FeatureStream.iterator(); i.hasNext(); ) {
      FeatureStream stream=(FeatureStream)i.next();
      stream.setActiveList(getActiveList(activeListClass,props));
      ParallelToken token=new ParallelToken(firstState,stream,currentFrameNumber);
      token.setLastCombineTime(currentFrameNumber);
      firstToken.addParallelToken(stream,token);
    }
    resultList=new LinkedList();
    calculateCombinedScore(firstToken);
    growCombineToken(firstToken);
    printActiveLists();
  }
 catch (  ClassNotFoundException cnfe) {
    throw new Error(""String_Node_Str"" + activeListName + ""String_Node_Str"");
  }
catch (  IllegalAccessException iae) {
    throw new Error(""String_Node_Str"" + activeListName);
  }
catch (  InstantiationException ise) {
    throw new Error(""String_Node_Str"" + activeListName);
  }
}","/** 
 * Creates the ActiveLists used for decoding. There is one ActiveList created for each feature stream (or acoustic model), and also an ActiveList to do the overall pruning.
 */
private void createInitialLists(){
  String activeListName=props.getString(PROP_ACTIVE_LIST_TYPE,PROP_ACTIVE_LIST_TYPE_DEFAULT);
  try {
    Class activeListClass=Class.forName(activeListName);
    combinedActiveList=getActiveList(activeListClass,props);
    delayedExpansionList=getActiveList(activeListClass,props);
    SentenceHMMState firstState=(SentenceHMMState)linguist.getSearchGraph().getInitialState();
    CombineToken firstToken=new CombineToken(null,firstState,currentFrameNumber);
    setBestToken(firstState,firstToken);
    for (Iterator i=FeatureStream.iterator(); i.hasNext(); ) {
      FeatureStream stream=(FeatureStream)i.next();
      stream.setActiveList(getActiveList(activeListClass,props));
      ParallelToken token=new ParallelToken(firstState,stream,currentFrameNumber);
      token.setLastCombineTime(currentFrameNumber);
      firstToken.addParallelToken(stream,token);
    }
    resultList=new LinkedList();
    calculateCombinedScore(firstToken);
    growCombineToken(firstToken);
    printActiveLists();
  }
 catch (  ClassNotFoundException cnfe) {
    throw new Error(""String_Node_Str"" + activeListName + ""String_Node_Str"");
  }
catch (  IllegalAccessException iae) {
    throw new Error(""String_Node_Str"" + activeListName);
  }
catch (  InstantiationException ise) {
    throw new Error(""String_Node_Str"" + activeListName);
  }
}",0.9925397340253
19816,"/** 
 * Calculate the acoustic scores for the active lists for the acoustic models, which should contain only emitting tokens.
 * @return true if there are more tokens, otherwise false
 */
private boolean score(){
  scoreTimer.start();
  debugPrint(""String_Node_Str"");
  boolean moreFeatures=false;
  for (Iterator i=FeatureStream.iterator(); i.hasNext(); ) {
    FeatureStream stream=(FeatureStream)i.next();
    moreFeatures=scorer.calculateScores(stream.getActiveList().getTokens());
  }
  debugPrint(""String_Node_Str"");
  scoreTimer.stop();
  return moreFeatures;
}","/** 
 * Calculate the acoustic scores for the active lists for the acoustic models, which should contain only emitting tokens.
 * @return true if there are more tokens, otherwise false
 */
private boolean score(){
  scoreTimer.start();
  debugPrint(""String_Node_Str"");
  boolean moreFeatures=false;
  for (Iterator i=FeatureStream.iterator(); i.hasNext(); ) {
    FeatureStream stream=(FeatureStream)i.next();
    Scoreable scoreable=scorer.calculateScores(stream.getActiveList().getTokens());
    moreFeatures=(scoreable != null);
  }
  debugPrint(""String_Node_Str"");
  scoreTimer.stop();
  return moreFeatures;
}",0.8655959425190194
19817,"/** 
 * Initializes this ParallelSearchManager with the given context, linguist, scorer, and pruner. Note that the given pruner is unused in this ParallelSearchManager, since we use the FeatureScorePruner and the CombinedScorePruner.
 * @param context the context to use
 * @param linguist the Linguist to use
 * @param scorer the AcousticScorer to use
 * @param pruner the Pruner to use
 */
public void initialize(String context,Linguist linguist,AcousticScorer scorer,Pruner pruner){
  this.props=SphinxProperties.getSphinxProperties(context);
  this.linguist=linguist;
  this.scorer=scorer;
  this.doFeaturePruning=props.getBoolean(PROP_DO_FEATURE_PRUNING,PROP_DO_FEATURE_PRUNING_DEFAULT);
  this.doCombinePruning=props.getBoolean(PROP_DO_COMBINE_PRUNING,PROP_DO_COMBINE_PRUNING_DEFAULT);
  if (doFeaturePruning) {
    this.featureScorePruner=new FeatureScorePruner();
    this.featureScorePruner.initialize(context);
  }
  if (doCombinePruning) {
    this.combinedScorePruner=new CombinedScorePruner();
    this.combinedScorePruner.initialize(context);
  }
  this.featureScoreCombiner=new FeatureScoreCombiner();
  this.scoreTimer=Timer.getTimer(context,""String_Node_Str"");
  this.pruneTimer=Timer.getTimer(context,""String_Node_Str"");
  this.growTimer=Timer.getTimer(context,""String_Node_Str"");
  bestTokenMap=new HashMap();
  List models=AcousticModel.getNames(context);
  assert(models.size() > 0);
  float defaultEta=1.f / models.size();
  for (Iterator i=models.iterator(); i.hasNext(); ) {
    String modelName=(String)i.next();
    float eta=props.getFloat(PROP_PREFIX + modelName + ""String_Node_Str"",defaultEta);
    FeatureStream stream=FeatureStream.getFeatureStream(modelName);
    stream.setEta(eta);
    System.out.println(""String_Node_Str"" + modelName + ""String_Node_Str""+ eta);
  }
}","/** 
 * Initializes this ParallelSearchManager with the given context, linguist, scorer, and pruner. Note that the given pruner is unused in this ParallelSearchManager, since we use the FeatureScorePruner and the CombinedScorePruner.
 * @param context the context to use
 * @param linguist the Linguist to use
 * @param scorer the AcousticScorer to use
 * @param pruner the Pruner to use
 */
public void initialize(String context,Linguist linguist,AcousticScorer scorer,Pruner pruner){
  this.props=SphinxProperties.getSphinxProperties(context);
  this.linguist=linguist;
  this.scorer=scorer;
  this.doFeaturePruning=props.getBoolean(PROP_DO_FEATURE_PRUNING,PROP_DO_FEATURE_PRUNING_DEFAULT);
  this.doCombinePruning=props.getBoolean(PROP_DO_COMBINE_PRUNING,PROP_DO_COMBINE_PRUNING_DEFAULT);
  if (doFeaturePruning) {
    this.featureScorePruner=new FeatureScorePruner();
    this.featureScorePruner.initialize(context);
  }
  if (doCombinePruning) {
    this.combinedScorePruner=new CombinedScorePruner();
    this.combinedScorePruner.initialize(context);
  }
  this.featureScoreCombiner=new FeatureScoreCombiner();
  this.scoreTimer=Timer.getTimer(context,""String_Node_Str"");
  this.pruneTimer=Timer.getTimer(context,""String_Node_Str"");
  this.growTimer=Timer.getTimer(context,""String_Node_Str"");
  bestTokenMap=new HashMap();
  Collection models=AcousticModelFactory.getNames(props);
  assert(models.size() > 0);
  float defaultEta=1.f / models.size();
  for (Iterator i=models.iterator(); i.hasNext(); ) {
    String modelName=(String)i.next();
    float eta=props.getFloat(PROP_PREFIX + modelName + ""String_Node_Str"",defaultEta);
    FeatureStream stream=FeatureStream.getFeatureStream(modelName);
    stream.setEta(eta);
    System.out.println(""String_Node_Str"" + modelName + ""String_Node_Str""+ eta);
  }
}",0.9853307500691946
19818,"/** 
 * Creates a tree linguist associated with the given context
 * @param context the context to associate this linguist with
 * @param languageModel the language model
 * @param grammar the grammar for this linguist
 * @param models the acoustic model used by this linguist
 */
public void initialize(String context,LanguageModel languageModel,Grammar grammar,AcousticModel[] models){
  SphinxProperties props=SphinxProperties.getSphinxProperties(context);
  this.tokenStackCapacity=props.getInt(PROP_STACK_CAPACITY,PROP_STACK_CAPACITY_DEFAULT);
  this.tieLevel=props.getString(PROP_TIE_LEVEL,PROP_TIE_LEVEL_DEFAULT);
  super.initialize(context,languageModel,grammar,models);
  System.out.println(""String_Node_Str"");
}","/** 
 * Creates a tree linguist associated with the given context
 * @param context        the context to associate this linguist with
 * @param languageModel  the language model
 * @param dictionary     the dictionary used
 * @param grammar        the grammar used
 * @param models         the acoustic models used
 */
public void initialize(String context,LanguageModel languageModel,Dictionary dictionary,Grammar grammar,AcousticModel[] models){
  SphinxProperties props=SphinxProperties.getSphinxProperties(context);
  this.tokenStackCapacity=props.getInt(PROP_STACK_CAPACITY,PROP_STACK_CAPACITY_DEFAULT);
  this.tieLevel=props.getString(PROP_TIE_LEVEL,PROP_TIE_LEVEL_DEFAULT);
  super.initialize(context,languageModel,dictionary,grammar,models);
  this.acousticModels=models;
  System.out.println(""String_Node_Str"");
}",0.8251295336787565
19819,"/** 
 * Returns true if the given binary cepstra file is in big-endian format. It assumes that the first 4 bytes of the file tells you how many 4-byte floating point cepstra values are in the file.
 * @param filename the cepstra file name
 * @return true if the given binary cepstra file is big-endian
 */
public static boolean isCepstraFileBigEndian(String filename) throws IOException {
  File cepstraFile=new File(filename);
  int fileSize=(int)cepstraFile.length();
  DataInputStream stream=new DataInputStream(new FileInputStream(filename));
  int numberBytes=stream.readInt() * 4 + 4;
  return (fileSize == numberBytes);
}","/** 
 * Returns true if the given binary cepstra file is in big-endian format. It assumes that the first 4 bytes of the file tells you how many 4-byte floating point cepstra values are in the file.
 * @param filename the cepstra file name
 * @return true if the given binary cepstra file is big-endian
 */
public static boolean isCepstraFileBigEndian(String filename) throws IOException {
  File cepstraFile=new File(filename);
  int fileSize=(int)cepstraFile.length();
  DataInputStream stream=new DataInputStream(new FileInputStream(filename));
  int numberBytes=stream.readInt() * 4 + 4;
  stream.close();
  return (fileSize == numberBytes);
}",0.9858712715855572
19820,"/** 
 * Actually creates the Spectrogram image.
 */
private void computeSpectrogram(){
  try {
    AudioDataInputStream is=new AudioDataInputStream(audio);
    StreamDataSource audioSource=new StreamDataSource();
    audioSource.initialize(""String_Node_Str"",null,props,null);
    audioSource.setInputStream(is,""String_Node_Str"");
    Collection names=FrontEndFactory.getNames(props);
    assert(names.size() == 1);
    String feName=(String)names.iterator().next();
    FrontEnd frontEnd=FrontEndFactory.getFrontEnd(feName,props);
    frontEnd.setDataSource(audioSource);
    ArrayList intensitiesList=new ArrayList();
    double maxIntensity=Double.MIN_VALUE;
    Data spectrum=frontEnd.getData();
    while (!(spectrum instanceof DataEndSignal)) {
      if (spectrum instanceof DoubleData) {
        double[] spectrumData=((DoubleData)spectrum).getValues();
        double[] intensities=new double[spectrumData.length];
        for (int i=0; i < intensities.length; i++) {
          intensities[i]=Math.max(Math.log(spectrumData[i]),0.0);
          if (intensities[i] > maxIntensity) {
            maxIntensity=intensities[i];
          }
        }
        intensitiesList.add(intensities);
      }
      spectrum=frontEnd.getData();
    }
    is.close();
    int width=intensitiesList.size();
    int height=((double[])intensitiesList.get(0)).length;
    int maxYIndex=height - 1;
    Dimension d=new Dimension(width,height);
    setMinimumSize(d);
    setMaximumSize(d);
    setPreferredSize(d);
    spectrogram=new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB);
    double scaleFactor=((0xff + offsetFactor) / maxIntensity);
    for (int i=0; i < width; i++) {
      double[] intensities=(double[])intensitiesList.get(i);
      for (int j=maxYIndex; j >= 0; j--) {
        int grey=(int)(intensities[j] * scaleFactor - offsetFactor);
        grey=Math.max(grey,0);
        grey=0xff - grey;
        int pixel=((grey << 16) & 0xff0000) | ((grey << 8) & 0xff00) | (grey & 0xff);
        spectrogram.setRGB(i,maxYIndex - j,pixel);
      }
    }
    repaint(new Rectangle(width,height));
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","/** 
 * Actually creates the Spectrogram image.
 */
private void computeSpectrogram(){
  try {
    AudioDataInputStream is=new AudioDataInputStream(audio);
    StreamDataSource audioSource=new StreamDataSource();
    audioSource.initialize(""String_Node_Str"",null,props,null);
    audioSource.setInputStream(is,""String_Node_Str"");
    Collection names=FrontEndFactory.getNames(props);
    assert(names.size() == 1);
    String feName=(String)names.iterator().next();
    FrontEnd frontEnd=FrontEndFactory.getFrontEnd(props,feName);
    frontEnd.setDataSource(audioSource);
    ArrayList intensitiesList=new ArrayList();
    double maxIntensity=Double.MIN_VALUE;
    Data spectrum=frontEnd.getData();
    while (!(spectrum instanceof DataEndSignal)) {
      if (spectrum instanceof DoubleData) {
        double[] spectrumData=((DoubleData)spectrum).getValues();
        double[] intensities=new double[spectrumData.length];
        for (int i=0; i < intensities.length; i++) {
          intensities[i]=Math.max(Math.log(spectrumData[i]),0.0);
          if (intensities[i] > maxIntensity) {
            maxIntensity=intensities[i];
          }
        }
        intensitiesList.add(intensities);
      }
      spectrum=frontEnd.getData();
    }
    is.close();
    int width=intensitiesList.size();
    int height=((double[])intensitiesList.get(0)).length;
    int maxYIndex=height - 1;
    Dimension d=new Dimension(width,height);
    setMinimumSize(d);
    setMaximumSize(d);
    setPreferredSize(d);
    spectrogram=new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB);
    double scaleFactor=((0xff + offsetFactor) / maxIntensity);
    for (int i=0; i < width; i++) {
      double[] intensities=(double[])intensitiesList.get(i);
      for (int j=maxYIndex; j >= 0; j--) {
        int grey=(int)(intensities[j] * scaleFactor - offsetFactor);
        grey=Math.max(grey,0);
        grey=0xff - grey;
        int pixel=((grey << 16) & 0xff0000) | ((grey << 8) & 0xff00) | (grey & 0xff);
        spectrogram.setRGB(i,maxYIndex - j,pixel);
      }
    }
    repaint(new Rectangle(width,height));
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.9972183588317108
19821,"/** 
 * Constructs a FeatureFileDumper.
 * @param propsFile the Sphinx properties file
 * @param inputAudioFile the input audio file
 */
public FeatureFileDumper(String propsFile,String inputAudioFile) throws FileNotFoundException, IOException {
  try {
    String context=""String_Node_Str"";
    URL url=new File(propsFile).toURI().toURL();
    SphinxProperties.initContext(context,url);
    SphinxProperties props=SphinxProperties.getSphinxProperties(context);
    StreamDataSource audioSource=new StreamDataSource();
    audioSource.initialize(""String_Node_Str"",context,props,null);
    audioSource.setInputStream(new FileInputStream(inputAudioFile),""String_Node_Str"");
    Collection names=FrontEndFactory.getNames(props);
    assert(names.size() == 1);
    String feName=(String)names.iterator().next();
    frontEnd=FrontEndFactory.getFrontEnd(feName,props);
    frontEnd.setDataSource(audioSource);
    allFeatures=new LinkedList();
    getAllFeatures();
    logger.info(""String_Node_Str"" + allFeatures.size());
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","/** 
 * Constructs a FeatureFileDumper.
 * @param propsFile the Sphinx properties file
 * @param inputAudioFile the input audio file
 */
public FeatureFileDumper(String propsFile,String inputAudioFile) throws FileNotFoundException, IOException {
  try {
    String context=""String_Node_Str"";
    URL url=new File(propsFile).toURI().toURL();
    SphinxProperties.initContext(context,url);
    SphinxProperties props=SphinxProperties.getSphinxProperties(context);
    StreamDataSource audioSource=new StreamDataSource();
    audioSource.initialize(""String_Node_Str"",context,props,null);
    audioSource.setInputStream(new FileInputStream(inputAudioFile),""String_Node_Str"");
    Collection names=FrontEndFactory.getNames(props);
    assert(names.size() == 1);
    String feName=(String)names.iterator().next();
    frontEnd=FrontEndFactory.getFrontEnd(props,feName);
    frontEnd.setDataSource(audioSource);
    allFeatures=new LinkedList();
    getAllFeatures();
    logger.info(""String_Node_Str"" + allFeatures.size());
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.9944289693593314
19822,"/** 
 * Converts a byte array into an array of doubles. Each consecutive bytes in the byte array are converted into a double,  and becomes the next element in the double array. The size of the returned array is (length/bytesPerValue).  Currently, only 1 byte (8-bit) or 2 bytes (16-bit) samples are supported.
 * @param byteArray a byte array
 * @param offset which byte to start from
 * @param length how many bytes to convert
 * @param bytesPerValue the number of bytes per value
 * @param signedData whether the data is signed
 * @return a double array, or <code>null</code> if byteArray is of zerolength
 * @throws java.lang.ArrayIndexOutOfBoundsException
 */
public static final double[] bytesToValues(byte[] byteArray,int offset,int length,int bytesPerValue,boolean signedData) throws ArrayIndexOutOfBoundsException {
  if (0 < length && (offset + length) <= byteArray.length) {
    int doubleLength=length / bytesPerValue;
    double[] doubleArray=new double[doubleLength];
    if (bytesPerValue == 2) {
      if (!signedData) {
        for (int i=offset, j=0; j < doubleLength; j++) {
          int temp=(int)byteArray[i++];
          temp=(temp << 8);
          temp|=(int)(0x000000FF & byteArray[i++]);
          doubleArray[j]=(double)temp;
        }
      }
 else {
        for (int i=offset, j=0; j < doubleLength; j++) {
          short temp=(short)(byteArray[i++] << 8);
          temp|=(short)(0x00FF & byteArray[i++]);
          doubleArray[j]=(double)temp;
        }
      }
    }
 else     if (bytesPerValue == 1) {
      for (int i=offset; i < doubleLength; i++) {
        doubleArray[i]=(double)byteArray[i];
      }
    }
 else {
      throw new Error(""String_Node_Str"" + bytesPerValue);
    }
    return doubleArray;
  }
 else {
    throw new ArrayIndexOutOfBoundsException(""String_Node_Str"" + offset + ""String_Node_Str""+ length+ ""String_Node_Str""+ byteArray.length);
  }
}","/** 
 * Converts a big-endian byte array into an array of doubles. Each consecutive bytes in the byte array are converted into a double,  and becomes the next element in the double array. The size of the returned array is (length/bytesPerValue).  Currently, only 1 byte (8-bit) or 2 bytes (16-bit) samples are supported.
 * @param byteArray a byte array
 * @param offset which byte to start from
 * @param length how many bytes to convert
 * @param bytesPerValue the number of bytes per value
 * @param signedData whether the data is signed
 * @return a double array, or <code>null</code> if byteArray is of zerolength
 * @throws java.lang.ArrayIndexOutOfBoundsException
 */
public static final double[] bytesToValues(byte[] byteArray,int offset,int length,int bytesPerValue,boolean signedData) throws ArrayIndexOutOfBoundsException {
  if (0 < length && (offset + length) <= byteArray.length) {
    assert(length % bytesPerValue == 0);
    double[] doubleArray=new double[length / bytesPerValue];
    int i=offset;
    for (int j=0; j < doubleArray.length; j++) {
      int val=(int)byteArray[i++];
      if (!signedData) {
        val&=0xff;
      }
      for (int c=1; c < bytesPerValue; c++) {
        int temp=(int)byteArray[i++] & 0xff;
        val=(val << 8) + temp;
      }
      doubleArray[j]=(double)val;
    }
    return doubleArray;
  }
 else {
    throw new ArrayIndexOutOfBoundsException(""String_Node_Str"" + offset + ""String_Node_Str""+ length+ ""String_Node_Str""+ byteArray.length);
  }
}",0.6403766921718658
19823,"/** 
 * Converts a little-endian byte array into an array of doubles.  Each consecutive bytes of a float are converted into a double, and becomes the next element in the double array. The number of bytes in the double is specified as an argument. The size of the returned array is (data.length/bytesPerValue).
 * @param data a byte array
 * @param offset which byte to start from
 * @param length how many bytes to convert
 * @param bytesPerValue the number of bytes per value
 * @param signed whether the data is signed
 * @return a double array, or <code>null</code> if byteArray is of zerolength
 * @throws java.lang.ArrayIndexOutOfBoundsException
 */
public static final double[] littleEndianBytesToValues(byte[] data,int offset,int length,int bytesPerValue,boolean signed) throws ArrayIndexOutOfBoundsException {
  if (0 < length && (offset + length) <= data.length) {
    double[] doubleArray=new double[length / bytesPerValue];
    if (bytesPerValue == 2) {
      if (signed) {
        for (int i=offset, j=0; i < length; j++) {
          short temp=(short)((0x000000FF & data[i++]) | (data[i++] << 8));
          doubleArray[j]=(double)temp;
        }
      }
 else {
        for (int i=offset, j=0; i < length; j++) {
          int temp=(int)((0x000000FF & data[i++]) | (data[i++] << 8));
          doubleArray[j]=(double)temp;
        }
      }
    }
 else     if (bytesPerValue == 1) {
      for (int i=0; i < doubleArray.length; i++) {
        doubleArray[i]=data[i];
      }
    }
 else {
      throw new Error(""String_Node_Str"" + bytesPerValue);
    }
    return doubleArray;
  }
 else {
    throw new ArrayIndexOutOfBoundsException(""String_Node_Str"" + offset + ""String_Node_Str""+ length+ ""String_Node_Str""+ data.length);
  }
}","/** 
 * Converts a little-endian byte array into an array of doubles.  Each consecutive bytes of a float are converted into a double, and becomes the next element in the double array. The number of bytes in the double is specified as an argument. The size of the returned array is (data.length/bytesPerValue).
 * @param data a byte array
 * @param offset which byte to start from
 * @param length how many bytes to convert
 * @param bytesPerValue the number of bytes per value
 * @param signed whether the data is signed
 * @return a double array, or <code>null</code> if byteArray is of zerolength
 * @throws java.lang.ArrayIndexOutOfBoundsException
 */
public static final double[] littleEndianBytesToValues(byte[] data,int offset,int length,int bytesPerValue,boolean signedData) throws ArrayIndexOutOfBoundsException {
  if (0 < length && (offset + length) <= data.length) {
    assert(length % bytesPerValue == 0);
    double[] doubleArray=new double[length / bytesPerValue];
    int i=offset + bytesPerValue - 1;
    for (int j=0; j < doubleArray.length; j++) {
      int val=(int)data[i--];
      if (!signedData) {
        val&=0xff;
      }
      for (int c=1; c < bytesPerValue; c++) {
        int temp=(int)data[i--] & 0xff;
        val=(val << 8) + temp;
      }
      i+=(bytesPerValue * 2);
      doubleArray[j]=(double)val;
    }
    return doubleArray;
  }
 else {
    throw new ArrayIndexOutOfBoundsException(""String_Node_Str"" + offset + ""String_Node_Str""+ length+ ""String_Node_Str""+ data.length);
  }
}",0.6460122699386504
19824,"/** 
 * Initialize and return the frontend based on the given sphinx properties.
 */
protected FrontEnd getFrontEnd(){
  String path=null;
  try {
    path=props.getString(PROP_FRONT_END,PROP_FRONT_END_DEFAULT);
    FrontEnd fe=(FrontEnd)Class.forName(path).newInstance();
    fe.initialize(""String_Node_Str"",context,dataSource);
    return fe;
  }
 catch (  ClassNotFoundException fe) {
    throw new Error(""String_Node_Str"" + path,fe);
  }
catch (  InstantiationException ie) {
    throw new Error(""String_Node_Str"" + path,ie);
  }
catch (  IllegalAccessException iea) {
    throw new Error(""String_Node_Str"" + path,iea);
  }
catch (  IOException ioe) {
    throw new Error(""String_Node_Str"" + path + ""String_Node_Str""+ ioe,ioe);
  }
}","/** 
 * Initialize and return the frontend based on the given sphinx properties.
 */
protected FrontEnd getFrontEnd(){
}",0.2800466744457409
19825,"/** 
 * Returns a single frame of speech.
 * @return a feature frame
 * @throws IOException
 */
private boolean getFeature(){
  FeatureFrame ff;
  try {
    ff=frontEnd.getFeatureFrame(1,null);
    if (!hasFeatures(ff)) {
      return false;
    }
    curFeature=ff.getFeatures()[0];
    if (curFeature.getSignal() == Signal.UTTERANCE_START) {
      ff=frontEnd.getFeatureFrame(1,null);
      if (!hasFeatures(ff)) {
        return false;
      }
      curFeature=ff.getFeatures()[0];
    }
    if (curFeature.getSignal() == Signal.UTTERANCE_END) {
      return false;
    }
    if (!curFeature.hasContent()) {
      throw new Error(""String_Node_Str"");
    }
  }
 catch (  IOException ioe) {
    System.out.println(""String_Node_Str"" + ioe);
    ioe.printStackTrace();
    return false;
  }
  return true;
}","/** 
 * Returns a single frame of speech.
 * @return a feature frame
 * @throws IOException
 */
private boolean getFeature(){
  try {
    curFeature=frontEnd.getData();
    if (curFeature == null) {
      return false;
    }
    if (curFeature instanceof DataStartSignal) {
      curFeature=frontEnd.getData();
      if (curFeature == null) {
        return false;
      }
    }
    if (curFeature instanceof DataEndSignal) {
      return false;
    }
    if (curFeature instanceof Signal) {
      throw new Error(""String_Node_Str"");
    }
  }
 catch (  DataProcessingException dpe) {
    System.out.println(""String_Node_Str"" + dpe);
    dpe.printStackTrace();
    return false;
  }
  return true;
}",0.4571428571428571
19826,"/** 
 * Initializes the Learner with the proper context and frontend.
 * @throws IOException
 */
private void initialize() throws IOException {
  inputDataType=props.getString(PROP_INPUT_TYPE,PROP_INPUT_TYPE_DEFAULT);
  if (inputDataType.equals(""String_Node_Str"")) {
    dataSource=new StreamAudioSource(""String_Node_Str"",context,null,null);
  }
 else   if (inputDataType.equals(""String_Node_Str"")) {
    dataSource=new StreamCepstrumSource(""String_Node_Str"",context);
  }
 else {
    throw new Error(""String_Node_Str"" + inputDataType + ""String_Node_Str""+ ""String_Node_Str"");
  }
  frontEnd=getFrontEnd();
}","/** 
 * Initializes the Learner with the proper context and frontend.
 * @throws IOException
 */
private void initialize() throws IOException {
  inputDataType=props.getString(PROP_INPUT_TYPE,PROP_INPUT_TYPE_DEFAULT);
  if (inputDataType.equals(""String_Node_Str"")) {
    dataSource=new StreamDataSource();
    dataSource.initialize(""String_Node_Str"",null,props,null);
  }
 else   if (inputDataType.equals(""String_Node_Str"")) {
    dataSource=new StreamCepstrumSource();
    dataSource.initialize(""String_Node_Str"",null,props,null);
  }
 else {
    throw new Error(""String_Node_Str"" + inputDataType + ""String_Node_Str""+ ""String_Node_Str"");
  }
  frontEnd=getFrontEnd();
}",0.9068128425998434
19827,"/** 
 * Sets the learner to use a utterance.
 * @param utterance the utterance
 * @throws IOException
 */
public void setUtterance(Utterance utterance) throws IOException {
  String file=utterance.toString();
  InputStream is=new FileInputStream(file);
  inputDataType=props.getString(PROP_INPUT_TYPE,PROP_INPUT_TYPE_DEFAULT);
  if (inputDataType.equals(""String_Node_Str"")) {
    ((StreamAudioSource)dataSource).setInputStream(is,file);
  }
 else   if (inputDataType.equals(""String_Node_Str"")) {
    boolean bigEndian=Utilities.isCepstraFileBigEndian(file);
    ((StreamCepstrumSource)dataSource).setInputStream(is,bigEndian);
  }
}","/** 
 * Sets the learner to use a utterance.
 * @param utterance the utterance
 * @throws IOException
 */
public void setUtterance(Utterance utterance) throws IOException {
  String file=utterance.toString();
  InputStream is=new FileInputStream(file);
  inputDataType=props.getString(PROP_INPUT_TYPE,PROP_INPUT_TYPE_DEFAULT);
  if (inputDataType.equals(""String_Node_Str"")) {
    ((StreamDataSource)dataSource).setInputStream(is,file);
  }
 else   if (inputDataType.equals(""String_Node_Str"")) {
    boolean bigEndian=Utilities.isCepstraFileBigEndian(file);
    ((StreamCepstrumSource)dataSource).setInputStream(is,bigEndian);
  }
}",0.992874109263658
19828,"/** 
 * Initializes the Learner with the proper context and frontend.
 * @throws IOException
 */
private void initialize() throws IOException {
  inputDataType=props.getString(PROP_INPUT_TYPE,PROP_INPUT_TYPE_DEFAULT);
  if (inputDataType.equals(""String_Node_Str"")) {
    dataSource=new StreamAudioSource(""String_Node_Str"",context,null,null);
  }
 else   if (inputDataType.equals(""String_Node_Str"")) {
    dataSource=new StreamCepstrumSource(""String_Node_Str"",context);
  }
 else {
    throw new Error(""String_Node_Str"" + inputDataType + ""String_Node_Str""+ ""String_Node_Str"");
  }
  frontEnd=getFrontEnd();
}","/** 
 * Initializes the Learner with the proper context and frontend.
 * @throws IOException
 */
private void initialize() throws IOException {
  inputDataType=props.getString(PROP_INPUT_TYPE,PROP_INPUT_TYPE_DEFAULT);
  if (inputDataType.equals(""String_Node_Str"")) {
    dataSource=new StreamDataSource();
    dataSource.initialize(""String_Node_Str"",null,props,null);
  }
 else   if (inputDataType.equals(""String_Node_Str"")) {
    dataSource=new StreamCepstrumSource();
    dataSource.initialize(""String_Node_Str"",null,props,null);
  }
 else {
    throw new Error(""String_Node_Str"" + inputDataType + ""String_Node_Str""+ ""String_Node_Str"");
  }
  frontEnd=getFrontEnd();
}",0.9068128425998434
19829,"/** 
 * Initialize and return the frontend based on the given sphinx properties.
 */
protected FrontEnd getFrontEnd(){
  String path=null;
  try {
    path=props.getString(PROP_FRONT_END,PROP_FRONT_END_DEFAULT);
    FrontEnd fe=(FrontEnd)Class.forName(path).newInstance();
    fe.initialize(""String_Node_Str"",context,dataSource);
    return fe;
  }
 catch (  ClassNotFoundException fe) {
    throw new Error(""String_Node_Str"" + path,fe);
  }
catch (  InstantiationException ie) {
    throw new Error(""String_Node_Str"" + path,ie);
  }
catch (  IllegalAccessException iea) {
    throw new Error(""String_Node_Str"" + path,iea);
  }
catch (  IOException ioe) {
    throw new Error(""String_Node_Str"" + path + ""String_Node_Str""+ ioe,ioe);
  }
}","/** 
 * Initialize and return the frontend based on the given sphinx properties.
 */
protected FrontEnd getFrontEnd(){
}",0.2800466744457409
19830,"/** 
 * Sets the learner to use a utterance.
 * @param utterance the utterance
 * @throws IOException
 */
public void setUtterance(Utterance utterance) throws IOException {
  String file=utterance.toString();
  InputStream is=new FileInputStream(file);
  inputDataType=props.getString(PROP_INPUT_TYPE,PROP_INPUT_TYPE_DEFAULT);
  if (inputDataType.equals(""String_Node_Str"")) {
    ((StreamAudioSource)dataSource).setInputStream(is,file);
  }
 else   if (inputDataType.equals(""String_Node_Str"")) {
    boolean bigEndian=Utilities.isCepstraFileBigEndian(file);
    ((StreamCepstrumSource)dataSource).setInputStream(is,bigEndian);
  }
}","/** 
 * Sets the learner to use a utterance.
 * @param utterance the utterance
 * @throws IOException
 */
public void setUtterance(Utterance utterance) throws IOException {
  String file=utterance.toString();
  InputStream is=new FileInputStream(file);
  inputDataType=props.getString(PROP_INPUT_TYPE,PROP_INPUT_TYPE_DEFAULT);
  if (inputDataType.equals(""String_Node_Str"")) {
    ((StreamDataSource)dataSource).setInputStream(is,file);
  }
 else   if (inputDataType.equals(""String_Node_Str"")) {
    boolean bigEndian=Utilities.isCepstraFileBigEndian(file);
    ((StreamCepstrumSource)dataSource).setInputStream(is,bigEndian);
  }
}",0.992874109263658
19831,"/** 
 * Returns a single frame of speech.
 * @return a feature frame
 * @throws IOException
 */
private boolean getFeature(){
  FeatureFrame ff;
  try {
    ff=frontEnd.getFeatureFrame(1,null);
    if (!hasFeatures(ff)) {
      return false;
    }
    curFeature=ff.getFeatures()[0];
    if (curFeature.getSignal() == Signal.UTTERANCE_START) {
      ff=frontEnd.getFeatureFrame(1,null);
      if (!hasFeatures(ff)) {
        return false;
      }
      curFeature=ff.getFeatures()[0];
    }
    if (curFeature.getSignal() == Signal.UTTERANCE_END) {
      return false;
    }
    if (!curFeature.hasContent()) {
      throw new Error(""String_Node_Str"");
    }
  }
 catch (  IOException ioe) {
    System.out.println(""String_Node_Str"" + ioe);
    ioe.printStackTrace();
    return false;
  }
  return true;
}","/** 
 * Returns a single frame of speech.
 * @return a feature frame
 * @throws IOException
 */
private boolean getFeature(){
  try {
    curFeature=frontEnd.getData();
    if (curFeature == null) {
      return false;
    }
    if (curFeature instanceof DataStartSignal) {
      curFeature=frontEnd.getData();
      if (curFeature == null) {
        return false;
      }
    }
    if (curFeature instanceof DataEndSignal) {
      return false;
    }
    if (curFeature instanceof Signal) {
      throw new Error(""String_Node_Str"");
    }
  }
 catch (  DataProcessingException dpe) {
    System.out.println(""String_Node_Str"" + dpe);
    dpe.printStackTrace();
    return false;
  }
  return true;
}",0.4571428571428571
19832,"/** 
 * Gets the signature for this state
 * @return the signature
 */
public String getSignature(){
  return getFullName();
}","/** 
 * Gets the signature for this state
 * @return the signature
 */
public String getSignature(){
  return toString();
}",0.931726907630522
19833,"/** 
 * Returns the processed Data output.
 * @return an Data object that has been processed by this DataProcessor 
 */
public abstract Data getData() throws DataProcessingException ;","/** 
 * Returns the processed Data output.
 * @return an Data object that has been processed by this DataProcessor 
 * @throws DataProcessingException if a data processor error occurs
 */
public abstract Data getData() throws DataProcessingException ;",0.6912442396313364
19834,"/** 
 * Constructs a DataProcessingException with the specified detailed message.
 */
public DataProcessingException(String message){
  super(message);
}","/** 
 * Constructs a DataProcessingException with the specified detailed message.
 * @param message the detailed message
 */
public DataProcessingException(String message){
  super(message);
}",0.8869565217391304
19835,"/** 
 * Returns the processed Data output.
 * @return an Data object that has been processed by this DataProcessor 
 */
public abstract Data getData() throws DataProcessingException ;","/** 
 * Returns the processed Data output.
 * @return an Data object that has been processed by this DataProcessor 
 * @throws DataProcessingException if a data processor error occurs
 */
public abstract Data getData() throws DataProcessingException ;",0.6912442396313364
19836,"/** 
 * Constructs a DataStartSignal with the given data name and transcript.
 * @param name   the name of the data stream, can be the name of the file from which the data stream is created
 * @param transcript   the transcript text of the data stream
 */
public DataStartSignal(String name,String transcript){
  this();
  this.name=name;
  this.transcript=transcript;
}","/** 
 * Constructs a DataStartSignal at the given time.
 * @param time the time this DataStartSignal is created
 */
public DataStartSignal(long time){
  super(time);
}",0.5139664804469274
19837,"/** 
 * Returns the processed Data output, basically calls <code>getData()</code> on the last processor.
 * @return an Data object that has been processed by this front end
 */
public Data getData() throws DataProcessingException {
  Data data=last.getData();
  if (data instanceof Signal) {
    fireSignalListeners((Signal)data);
  }
  return data;
}","/** 
 * Returns the processed Data output, basically calls <code>getData()</code> on the last processor.
 * @return an Data object that has been processed by this front end
 * @throws DataProcessingException if a data processor error occurs
 */
public Data getData() throws DataProcessingException {
  Data data=last.getData();
  if (data instanceof Signal) {
    fireSignalListeners((Signal)data);
  }
  return data;
}",0.8493506493506493
19838,"/** 
 * Finds the DataProcessor with the given name.
 * @param name the name of the DataProcessor to find
 */
public DataProcessor findDataProcessor(String processorName){
  DataProcessor current=last;
  while (current != null) {
    if (current.getName().equals(processorName)) {
      return current;
    }
 else {
      current=current.getPredecessor();
    }
  }
  return null;
}","/** 
 * Finds the DataProcessor with the given name.
 * @param name the name of the DataProcessor to find
 * @return the DataProcessor with the given name, or null if noDataProcessor with the given name was found
 */
public DataProcessor findDataProcessor(String processorName){
  DataProcessor current=last;
  while (current != null) {
    if (current.getName().equals(processorName)) {
      return current;
    }
 else {
      current=current.getPredecessor();
    }
  }
  return null;
}",0.8774341351660939
19839,"/** 
 * Returns as a string array the name(s) of the front end(s), as specified in the SphinxProperties by the following: <code> edu.cmu.sphinx.frontend.pipelines = ... ... (e.g., ""mfc plp""); </code>
 * @param props the SphinxProperty to use
 */
private static String[] getFrontEndNames(SphinxProperties props){
  String pipelines=props.getString(PROP_PREFIX + ""String_Node_Str"",""String_Node_Str"");
  return pipelines.split(""String_Node_Str"");
}","/** 
 * Returns as a string array the name(s) of the front end(s), as specified in the SphinxProperties by the following: <code> edu.cmu.sphinx.frontend.pipelines = ... ... (e.g., ""mfc plp""); </code>
 * @param props the SphinxProperty to use
 * @return the name of all available front ends
 */
private static String[] getFrontEndNames(SphinxProperties props){
  String pipelines=props.getString(PROP_PREFIX + ""String_Node_Str"",""String_Node_Str"");
  return pipelines.split(""String_Node_Str"");
}",0.9488272921108742
19840,"/** 
 * Loads the given front end, and returns its last DataProcessor.
 * @param name the name of the front end to load
 * @param props the SphinxProperty to use
 */
private static FrontEnd loadFrontEnd(String frontEndName,SphinxProperties props){
  FrontEnd frontend=(FrontEnd)frontends.get(frontEndName);
  if (frontend == null) {
    int nStages=props.getInt(frontEndName + ""String_Node_Str"" + PROP_PREFIX+ ""String_Node_Str"",0);
    debugMessage(""String_Node_Str"" + frontEndName + ""String_Node_Str""+ nStages+ ""String_Node_Str"");
    DataProcessor firstProcessor=null;
    DataProcessor lastProcessor=null;
    for (int i=1; i <= nStages; i++) {
      String prefix=frontEndName + ""String_Node_Str"" + PROP_PREFIX+ ""String_Node_Str""+ i+ ""String_Node_Str"";
      String className=props.getString(prefix + ""String_Node_Str"",null);
      if (className == null) {
        throw new Error(""String_Node_Str"" + frontEndName + ""String_Node_Str""+ i);
      }
 else {
        try {
          DataProcessor processor=(DataProcessor)Class.forName(className).newInstance();
          processor.initialize(getClassName(className),frontEndName,props,lastProcessor);
          if (firstProcessor == null) {
            firstProcessor=processor;
          }
          lastProcessor=processor;
        }
 catch (        InstantiationException ie) {
          ie.printStackTrace();
          throw new Error(""String_Node_Str"" + className);
        }
catch (        ClassNotFoundException cnfe) {
          cnfe.printStackTrace();
          throw new Error(""String_Node_Str"" + className + ""String_Node_Str"");
        }
catch (        IllegalAccessException iae) {
          iae.printStackTrace();
          throw new Error(""String_Node_Str"" + className);
        }
      }
    }
    frontend=new FrontEnd(firstProcessor,lastProcessor);
    frontend.initialize(frontEndName,frontEndName,props,null);
    frontends.put(frontEndName,frontend);
  }
  return frontend;
}","/** 
 * Loads the given front end, and returns its last DataProcessor.
 * @param name the name of the front end to load
 * @param props the SphinxProperty to use
 * @return the FrontEnd with the given name
 */
private static FrontEnd loadFrontEnd(String frontEndName,SphinxProperties props){
  FrontEnd frontend=(FrontEnd)frontends.get(frontEndName);
  if (frontend == null) {
    int nStages=props.getInt(frontEndName + ""String_Node_Str"" + PROP_PREFIX+ ""String_Node_Str"",0);
    debugMessage(""String_Node_Str"" + frontEndName + ""String_Node_Str""+ nStages+ ""String_Node_Str"");
    DataProcessor firstProcessor=null;
    DataProcessor lastProcessor=null;
    for (int i=1; i <= nStages; i++) {
      String prefix=frontEndName + ""String_Node_Str"" + PROP_PREFIX+ ""String_Node_Str""+ i+ ""String_Node_Str"";
      String className=props.getString(prefix + ""String_Node_Str"",null);
      if (className == null) {
        throw new Error(""String_Node_Str"" + frontEndName + ""String_Node_Str""+ i);
      }
 else {
        try {
          DataProcessor processor=(DataProcessor)Class.forName(className).newInstance();
          processor.initialize(getClassName(className),frontEndName,props,lastProcessor);
          if (firstProcessor == null) {
            firstProcessor=processor;
          }
          lastProcessor=processor;
        }
 catch (        InstantiationException ie) {
          ie.printStackTrace();
          throw new Error(""String_Node_Str"" + className);
        }
catch (        ClassNotFoundException cnfe) {
          cnfe.printStackTrace();
          throw new Error(""String_Node_Str"" + className + ""String_Node_Str"");
        }
catch (        IllegalAccessException iae) {
          iae.printStackTrace();
          throw new Error(""String_Node_Str"" + className);
        }
      }
    }
    frontend=new FrontEnd(firstProcessor,lastProcessor);
    frontend.initialize(frontEndName,frontEndName,props,null);
    frontends.put(frontEndName,frontend);
  }
  return frontend;
}",0.988821138211382
19841,"/** 
 * Returns the class name from a fully-qualified class name.
 */
private static String getClassName(String fullName){
  int periodIndex=fullName.lastIndexOf(""String_Node_Str"");
  if (periodIndex > -1) {
    return fullName.substring(periodIndex + 1);
  }
 else {
    return fullName;
  }
}","/** 
 * Returns the class name from a fully-qualified class name. For example, given ""edu.cmu.sphinx.frontend.FrontEndFactory"", will return ""FrontEndFactory"".
 * @param the fully-qualified class name
 * @return just the class name
 */
private static String getClassName(String fullName){
  int periodIndex=fullName.lastIndexOf(""String_Node_Str"");
  if (periodIndex > -1) {
    return fullName.substring(periodIndex + 1);
  }
 else {
    return fullName;
  }
}",0.7808764940239044
19842,"/** 
 * Sets the properties for this LevelTracker.
 */
private void setProperties(SphinxProperties props){
  frameLength=props.getInt(getFullPropertyName(PROP_FRAME_LENGTH),PROP_FRAME_LENGTH_DEFAULT);
  adjustment=props.getDouble(getFullPropertyName(PROP_ADJUSTMENT),PROP_ADJUSTMENT_DEFAULT);
  threshold=props.getDouble(getFullPropertyName(PROP_THRESHOLD),PROP_THRESHOLD_DEFAULT);
  minSignal=props.getDouble(getFullPropertyName(PROP_MIN_SIGNAL),PROP_MIN_SIGNAL_DEFAULT);
  debug=props.getBoolean(getFullPropertyName(PROP_DEBUG),PROP_DEBUG_DEFAULT);
}","/** 
 * Sets the properties for this LevelTracker.
 * @param props the SphinxProperties to use
 */
private void setProperties(SphinxProperties props){
  frameLength=props.getInt(getFullPropertyName(PROP_FRAME_LENGTH),PROP_FRAME_LENGTH_DEFAULT);
  adjustment=props.getDouble(getFullPropertyName(PROP_ADJUSTMENT),PROP_ADJUSTMENT_DEFAULT);
  threshold=props.getDouble(getFullPropertyName(PROP_THRESHOLD),PROP_THRESHOLD_DEFAULT);
  minSignal=props.getDouble(getFullPropertyName(PROP_MIN_SIGNAL),PROP_MIN_SIGNAL_DEFAULT);
  debug=props.getBoolean(getFullPropertyName(PROP_DEBUG),PROP_DEBUG_DEFAULT);
}",0.9616724738675958
19843,"/** 
 * Returns the next Data, either from the inputBuffer or the predecessor.
 * @return the next available Data
 */
private Data readData() throws DataProcessingException {
  Data audio=null;
  if (inputBuffer.size() > 0) {
    audio=(Data)inputBuffer.remove(0);
  }
 else {
    audio=getPredecessor().getData();
  }
  return audio;
}","/** 
 * Returns the next Data, either from the inputBuffer or the predecessor.
 * @return the next available Data
 * @throws DataProcessingException if a data processor error occurs
 */
private Data readData() throws DataProcessingException {
  Data audio=null;
  if (inputBuffer.size() > 0) {
    audio=(Data)inputBuffer.remove(0);
  }
 else {
    audio=getPredecessor().getData();
  }
  return audio;
}",0.8378378378378378
19844,"/** 
 * Handles the given Data in the case when mergeSpeechSegment is true.
 */
private Data handleMergingData(Data audio) throws DataProcessingException {
  Data next=audio;
  if (audio instanceof DataStartSignal) {
    List audioList=readUntilSpeechStartOrDataEnd();
    Data last=(Data)audioList.get(audioList.size() - 1);
    if (last != null) {
      if (last instanceof DataEndSignal) {
        outputQueue.add(audio);
        next=last;
      }
    }
  }
 else   if (audio instanceof SpeechEndSignal) {
    List audioList=readUntilSpeechStartOrDataEnd();
    Data last=(Data)audioList.get(audioList.size() - 1);
    if (last != null) {
      if (last instanceof SpeechStartSignal) {
        audioList.remove(last);
        inputBuffer.addAll(audioList);
        next=readData();
      }
 else       if (last instanceof DataEndSignal) {
        next=last;
      }
    }
  }
  return next;
}","/** 
 * Handles the given Data in the case when mergeSpeechSegment is true.
 * @param audio the Data object to handle
 * @throws DataProcessingException if a data processor error occurs
 */
private Data handleMergingData(Data audio) throws DataProcessingException {
  Data next=audio;
  if (audio instanceof DataStartSignal) {
    List audioList=readUntilSpeechStartOrDataEnd();
    Data last=(Data)audioList.get(audioList.size() - 1);
    if (last != null) {
      if (last instanceof DataEndSignal) {
        outputQueue.add(audio);
        next=last;
      }
    }
  }
 else   if (audio instanceof SpeechEndSignal) {
    List audioList=readUntilSpeechStartOrDataEnd();
    Data last=(Data)audioList.get(audioList.size() - 1);
    if (last != null) {
      if (last instanceof SpeechStartSignal) {
        audioList.remove(last);
        inputBuffer.addAll(audioList);
        next=readData();
      }
 else       if (last instanceof DataEndSignal) {
        next=last;
      }
    }
  }
  return next;
}",0.8948475289169295
19845,"/** 
 * Handles the given Data in the case when mergeSpeechSegment is false.
 */
private Data handleNonMergingData(Data audio) throws DataProcessingException {
  Data next=audio;
  if (audio != null) {
    if (audio instanceof SpeechStartSignal) {
      if (inSpeech) {
        message(""String_Node_Str"" + ""String_Node_Str"");
        do {
          next=readData();
        }
 while (next != null && next instanceof SpeechStartSignal);
        if (next != null) {
          next=handleNonMergingData(next);
        }
      }
 else {
        inSpeech=true;
        discardMode=false;
        next=new DataStartSignal(((Signal)audio).getTime());
      }
    }
 else     if (audio instanceof SpeechEndSignal) {
      if (!inSpeech) {
        message(""String_Node_Str"" + ""String_Node_Str"");
        do {
          next=readData();
        }
 while (next != null && next instanceof SpeechEndSignal);
        if (next != null) {
          next=handleNonMergingData(next);
        }
      }
 else {
        inSpeech=false;
        discardMode=true;
        next=new DataEndSignal(((Signal)audio).getTime());
      }
    }
 else     if (discardMode) {
      while (next != null && !(next instanceof SpeechStartSignal) && !(next instanceof SpeechEndSignal)) {
        next=readData();
      }
      next=handleNonMergingData(next);
    }
  }
  return next;
}","/** 
 * Handles the given Data in the case when mergeSpeechSegment is false.
 * @param audio the Data object to handle
 * @throws DataProcessingException if a data processor error occurs
 */
private Data handleNonMergingData(Data audio) throws DataProcessingException {
  Data next=audio;
  if (audio != null) {
    if (audio instanceof SpeechStartSignal) {
      if (inSpeech) {
        message(""String_Node_Str"" + ""String_Node_Str"");
        do {
          next=readData();
        }
 while (next != null && next instanceof SpeechStartSignal);
        if (next != null) {
          next=handleNonMergingData(next);
        }
      }
 else {
        inSpeech=true;
        discardMode=false;
        next=new DataStartSignal(((Signal)audio).getTime());
      }
    }
 else     if (audio instanceof SpeechEndSignal) {
      if (!inSpeech) {
        message(""String_Node_Str"" + ""String_Node_Str"");
        do {
          next=readData();
        }
 while (next != null && next instanceof SpeechEndSignal);
        if (next != null) {
          next=handleNonMergingData(next);
        }
      }
 else {
        inSpeech=false;
        discardMode=true;
        next=new DataEndSignal(((Signal)audio).getTime());
      }
    }
 else     if (discardMode) {
      while (next != null && !(next instanceof SpeechStartSignal) && !(next instanceof SpeechEndSignal)) {
        next=readData();
      }
      next=handleNonMergingData(next);
    }
  }
  return next;
}",0.9608262108262108
19846,"/** 
 * Read until we hit a Data of the two given Signal types.
 * @param signal1 the first Signal type
 * @param signal2 the second Signal type
 * @return a list of all the Data read,including the last Data with the Signal
 */
private List readUntilSpeechStartOrDataEnd() throws DataProcessingException {
  List audioList=new LinkedList();
  Data audio=null;
  do {
    audio=readData();
    if (audio != null) {
      audioList.add(audio);
    }
  }
 while (audio != null && !(audio instanceof SpeechStartSignal) && !(audio instanceof DataEndSignal));
  return audioList;
}","/** 
 * Read until we hit a SpeechStartSignal or DataEndSignal.
 * @return a list of all the Data read,including the SpeechStartSignal or DataEndSignal
 */
private List readUntilSpeechStartOrDataEnd() throws DataProcessingException {
  List audioList=new LinkedList();
  Data audio=null;
  do {
    audio=readData();
    if (audio != null) {
      audioList.add(audio);
    }
  }
 while (audio != null && !(audio instanceof SpeechStartSignal) && !(audio instanceof DataEndSignal));
  return audioList;
}",0.7272727272727273
19847,"/** 
 * Returns the amount of audio data in milliseconds in the  given Audio object.
 * @param audio the Audio object
 * @return the amount of audio data in milliseconds
 */
public int getAudioTime(SpeechClassifiedData audio){
  return (int)(audio.getValues().length * 1000.0f / sampleRate);
}","/** 
 * Returns the amount of audio data in milliseconds in the  given SpeechClassifiedData object.
 * @param audio the SpeechClassifiedData object
 * @return the amount of audio data in milliseconds
 */
public int getAudioTime(SpeechClassifiedData audio){
  return (int)(audio.getValues().length * 1000.0f / sampleRate);
}",0.9188311688311688
19848,"/** 
 * Handles an Audio object that can possibly be the first in an utterance. 
 * @param audio the Audio to handle
 * @return true if utterance/speech has started for real, false otherwise
 */
private boolean handleFirstSpeech(SpeechClassifiedData audio) throws DataProcessingException {
  int speechTime=getAudioTime(audio);
  while (speechTime < startSpeechTime) {
    Data next=readData();
    sendToQueue(next);
    if (next instanceof SpeechClassifiedData) {
      if (!((SpeechClassifiedData)next).isSpeech()) {
        return false;
      }
 else {
        speechTime+=getAudioTime(audio);
      }
    }
  }
  return true;
}","/** 
 * Handles an SpeechClassifiedData object that can possibly be the first in an utterance. 
 * @param audio the SpeechClassifiedData to handle
 * @return true if utterance/speech has started for real, false otherwise
 */
private boolean handleFirstSpeech(SpeechClassifiedData audio) throws DataProcessingException {
  int speechTime=getAudioTime(audio);
  while (speechTime < startSpeechTime) {
    Data next=readData();
    sendToQueue(next);
    if (next instanceof SpeechClassifiedData) {
      if (!((SpeechClassifiedData)next).isSpeech()) {
        return false;
      }
 else {
        speechTime+=getAudioTime(audio);
      }
    }
  }
  return true;
}",0.9614197530864198
19849,"/** 
 * Read the starting frames until the utterance has started.
 */
private void readInitialFrames() throws DataProcessingException {
  int nonSpeechTime=0;
  int minSpeechTime=(startSpeechTime > speechLeader) ? startSpeechTime : speechLeader;
  while (!inSpeech) {
    Data audio=readData();
    if (audio == null) {
      return;
    }
 else {
      sendToQueue(audio);
      if (audio instanceof SpeechClassifiedData) {
        nonSpeechTime+=getAudioTime((SpeechClassifiedData)audio);
        SpeechClassifiedData data=(SpeechClassifiedData)audio;
        if (data.isSpeech()) {
          boolean speechStarted=handleFirstSpeech(data);
          if (speechStarted) {
            addSpeechStart();
            inSpeech=true;
            break;
          }
        }
      }
    }
    int i=0;
    while (nonSpeechTime > minSpeechTime) {
      Data next=(Data)outputQueue.get(i);
      if (next instanceof SpeechClassifiedData) {
        int thisAudioTime=getAudioTime((SpeechClassifiedData)next);
        if (nonSpeechTime - thisAudioTime >= minSpeechTime) {
          outputQueue.remove(i);
          nonSpeechTime-=thisAudioTime;
        }
      }
      i++;
    }
  }
}","/** 
 * Read the starting frames until the utterance has started.
 * @throws DataProcessingException if a data processing error occurs
 */
private void readInitialFrames() throws DataProcessingException {
  int nonSpeechTime=0;
  int minSpeechTime=(startSpeechTime > speechLeader) ? startSpeechTime : speechLeader;
  while (!inSpeech) {
    Data audio=readData();
    if (audio == null) {
      return;
    }
 else {
      sendToQueue(audio);
      if (audio instanceof SpeechClassifiedData) {
        nonSpeechTime+=getAudioTime((SpeechClassifiedData)audio);
        SpeechClassifiedData data=(SpeechClassifiedData)audio;
        if (data.isSpeech()) {
          boolean speechStarted=handleFirstSpeech(data);
          if (speechStarted) {
            addSpeechStart();
            inSpeech=true;
            break;
          }
        }
      }
    }
    int i=0;
    while (nonSpeechTime > minSpeechTime) {
      Data next=(Data)outputQueue.get(i);
      if (next instanceof SpeechClassifiedData) {
        int thisAudioTime=getAudioTime((SpeechClassifiedData)next);
        if (nonSpeechTime - thisAudioTime >= minSpeechTime) {
          outputQueue.remove(i);
          nonSpeechTime-=thisAudioTime;
        }
      }
      i++;
    }
  }
}",0.9426330994634752
19850,"/** 
 * Reads the cepstra of the entire Utterance into the cepstraList.
 * @return the number cepstra (with Data) read
 * @throws IOException if an error occurred reading the Data
 */
private int readUtterance() throws DataProcessingException {
  Data input=null;
  do {
    input=getPredecessor().getData();
    if (input != null) {
      if (input instanceof DoubleData) {
        numberDataCepstra++;
        double[] cepstrumData=((DoubleData)input).getValues();
        if (sums == null) {
          sums=new double[cepstrumData.length];
        }
 else {
          if (sums.length != cepstrumData.length) {
            throw new Error(""String_Node_Str"" + sums.length + ""String_Node_Str""+ cepstrumData.length);
          }
        }
        for (int j=0; j < cepstrumData.length; j++) {
          sums[j]+=cepstrumData[j];
        }
        cepstraList.add(input);
      }
 else       if (input instanceof DataEndSignal) {
        cepstraList.add(input);
        break;
      }
 else {
        cepstraList.add(input);
      }
    }
  }
 while (input != null);
  return numberDataCepstra;
}","/** 
 * Reads the cepstra of the entire Utterance into the cepstraList.
 * @return the number cepstra (with Data) read
 * @throws DataProcessingException if an error occurred reading the Data
 */
private int readUtterance() throws DataProcessingException {
  Data input=null;
  do {
    input=getPredecessor().getData();
    if (input != null) {
      if (input instanceof DoubleData) {
        numberDataCepstra++;
        double[] cepstrumData=((DoubleData)input).getValues();
        if (sums == null) {
          sums=new double[cepstrumData.length];
        }
 else {
          if (sums.length != cepstrumData.length) {
            throw new Error(""String_Node_Str"" + sums.length + ""String_Node_Str""+ cepstrumData.length);
          }
        }
        for (int j=0; j < cepstrumData.length; j++) {
          sums[j]+=cepstrumData[j];
        }
        cepstraList.add(input);
      }
 else       if (input instanceof DataEndSignal) {
        cepstraList.add(input);
        break;
      }
 else {
        cepstraList.add(input);
      }
    }
  }
 while (input != null);
  return numberDataCepstra;
}",0.9927272727272728
19851,"private Data readData() throws DataProcessingException {
  Data frame=getPredecessor().getData();
  if (frame != null) {
    id++;
  }
  return frame;
}","/** 
 * Read a Data object from the predecessor DataProcessor, and increment the ID count appropriately.
 * @return the read Data object
 */
private Data readData() throws DataProcessingException {
  Data frame=getPredecessor().getData();
  if (frame != null) {
    id++;
  }
  return frame;
}",0.6831460674157304
19852,"/** 
 * loads the class map. The class map is map that relates acoustic model names to classnames
 * @param props the sphinx properties
 */
private static void loadClassMap(SphinxProperties props){
  if (classMap == null) {
    classMap=new HashMap();
    String modelNames=props.getString(PROP_MODELS,""String_Node_Str"");
    StringTokenizer st=new StringTokenizer(modelNames);
    while (st.hasMoreTokens()) {
      String name=st.nextToken();
      String className=props.getString(name,PROP_CLASS,null);
      if (className != null) {
        if (defaultModelName == null) {
          defaultModelName=name;
        }
        classMap.put(name,className);
      }
 else {
        System.err.println(""String_Node_Str"" + name);
      }
    }
  }
}","/** 
 * loads the class map. The class map is map that relates acoustic model names to classnames
 * @param props the sphinx properties
 */
private static void loadClassMap(SphinxProperties props){
  String modelNames=props.getString(PROP_MODELS,""String_Node_Str"");
  StringTokenizer st=new StringTokenizer(modelNames);
  while (st.hasMoreTokens()) {
    String name=st.nextToken();
    String className=props.getString(name,PROP_CLASS,null);
    if (className != null) {
      if (defaultModelName == null) {
        defaultModelName=name;
      }
      classMap.put(name,className);
    }
 else {
      System.err.println(""String_Node_Str"" + name);
    }
  }
}",0.9390070921985816
19853,"/** 
 * Returns the next N number of Features produced by this BaseFrontEnd as a single FeatureFrame. The number of Features return maybe less than N, in which case the last Feature will contain a Signal.UTTERANCE_END signal. Consequently, the size of the FeatureFrame will be less than N.
 * @param numberFeatures the number of Features to return
 * @return the next N number of Features in a FeatureFrame, or nullif no more FeatureFrames available
 * @see FeatureFrame
 */
public FeatureFrame getFeatureFrame(int numberFeatures,String acousticModelName) throws IOException {
  getTimer().start();
  FeatureFrame featureFrame=null;
  Feature[] features=new Feature[numberFeatures];
  Feature feature=null;
  int i=0;
  do {
    feature=featureSource.getFeature();
    if (feature != null) {
      if (getAcousticModelName() != null) {
        feature.setType(getAcousticModelName());
      }
      features[i++]=feature;
      signalCheck(feature);
    }
 else {
      break;
    }
  }
 while (i < numberFeatures);
  if (i > 0) {
    if (i < numberFeatures) {
      Feature[] lessFeatures=new Feature[i];
      for (i=0; i < lessFeatures.length; i++) {
        lessFeatures[i]=features[i];
      }
      features=lessFeatures;
    }
    featureFrame=new FeatureFrame(features);
  }
  getTimer().stop();
  return featureFrame;
}","/** 
 * Returns the next N number of Features produced by this BaseFrontEnd as a single FeatureFrame. The number of Features return maybe less than N, in which case the last Feature will contain a Signal.UTTERANCE_END signal. Consequently, the size of the FeatureFrame will be less than N.
 * @param numberFeatures the number of Features to return
 * @param acousticModelName the name of the acoustic model for eachthe returned features are for
 * @return the next N number of Features in a FeatureFrame, or nullif no more FeatureFrames available
 * @throws IOException if an I/O error occurs
 * @see FeatureFrame
 */
public FeatureFrame getFeatureFrame(int numberFeatures,String acousticModelName) throws IOException {
  getTimer().start();
  FeatureFrame featureFrame=null;
  Feature[] features=new Feature[numberFeatures];
  Feature feature=null;
  int i=0;
  do {
    feature=featureSource.getFeature();
    if (feature != null) {
      if (getAcousticModelName() != null) {
        feature.setType(getAcousticModelName());
      }
      features[i++]=feature;
      signalCheck(feature);
    }
 else {
      break;
    }
  }
 while (i < numberFeatures);
  if (i > 0) {
    if (i < numberFeatures) {
      Feature[] lessFeatures=new Feature[i];
      for (i=0; i < lessFeatures.length; i++) {
        lessFeatures[i]=features[i];
      }
      features=lessFeatures;
    }
    featureFrame=new FeatureFrame(features);
  }
  getTimer().stop();
  return featureFrame;
}",0.8760271525544837
19854,"/** 
 * Initializes a BaseFrontEnd with the given name, context, acoustic  model name, and DataSource.
 * @param name the name of this BaseFrontEnd
 * @param context the context of interest
 * @param props the SphinxProperties to use
 * @param amName the name of the acoustic model
 * @param dataSource the source of data; can be null, in whichcase the setDataSource() method must be called later
 */
public void initialize(String name,String context,SphinxProperties props,String amName,DataSource dataSource) throws IOException {
  super.initialize(name,context,props,amName,dataSource);
  CepstrumSource lastCepstrumSource=this;
  CepstrumSource cmn=getCMN(lastCepstrumSource);
  if (cmn != null) {
    addProcessor((DataProcessor)cmn);
    lastCepstrumSource=cmn;
  }
  FeatureExtractor extractor=getFeatureExtractor(lastCepstrumSource);
  addProcessor((DataProcessor)extractor);
  FrameDropper frameDropper=getFrameDropper(extractor);
  if (frameDropper == null) {
    this.featureSource=extractor;
  }
 else {
    this.featureSource=frameDropper;
    addProcessor((DataProcessor)frameDropper);
  }
}","/** 
 * Initializes a BaseFrontEnd with the given name, context, acoustic  model name, and DataSource.
 * @param name the name of this BaseFrontEnd
 * @param context the context of interest
 * @param props the SphinxProperties to use
 * @param amName the name of the acoustic model
 * @param dataSource the source of data; can be null, in whichcase the setDataSource() method must be called later
 * @throws IOException if an I/O error occurs
 */
public void initialize(String name,String context,SphinxProperties props,String amName,DataSource dataSource) throws IOException {
  super.initialize(name,context,props,amName,dataSource);
  CepstrumSource lastCepstrumSource=this;
  CepstrumSource cmn=getCMN(lastCepstrumSource);
  if (cmn != null) {
    addProcessor((DataProcessor)cmn);
    lastCepstrumSource=cmn;
  }
  FeatureExtractor extractor=getFeatureExtractor(lastCepstrumSource);
  addProcessor((DataProcessor)extractor);
  FrameDropper frameDropper=getFrameDropper(extractor);
  if (frameDropper == null) {
    this.featureSource=extractor;
  }
 else {
    this.featureSource=frameDropper;
    addProcessor((DataProcessor)frameDropper);
  }
}",0.8803191489361702
19855,"/** 
 * Returns the BaseFrontEnd with the given context, or null  if there is no BaseFrontEnd with that context.
 * @return the BaseFrontEnd with the given context, or null if thereis no BaseFrontEnd with that context
 */
public static FrontEnd getFrontEnd(String context){
  Object frontend=frontends.get(context);
  if (frontend != null) {
    return (FrontEnd)frontend;
  }
 else {
    return null;
  }
}","/** 
 * Returns the BaseFrontEnd with the given context, or null  if there is no BaseFrontEnd with that context.
 * @param context the context of the FrontEnd to get
 * @return the BaseFrontEnd with the given context, or null if thereis no BaseFrontEnd with that context
 * @throws IOException if an I/O error occurs
 */
public static FrontEnd getFrontEnd(String context){
  Object frontend=frontends.get(context);
  if (frontend != null) {
    return (FrontEnd)frontend;
  }
 else {
    return null;
  }
}",0.891566265060241
19856,"/** 
 * Returns the DataProcessor in the CepstrumExtractor with the given name.
 * @return the DataProcessor with the given name, or null if nosuch DataProcessor
 */
public DataProcessor getProcessor(String processorName){
  Object object=processors.get(processorName);
  if (object == null) {
    System.out.println(""String_Node_Str"" + processorName);
    return null;
  }
 else {
    return (DataProcessor)object;
  }
}","/** 
 * Returns the DataProcessor in the CepstrumExtractor with the given name.
 * @param processorName the name of the processor to return
 * @return the DataProcessor with the given name, or null if nosuch DataProcessor
 */
public DataProcessor getProcessor(String processorName){
  Object object=processors.get(processorName);
  if (object == null) {
    System.out.println(""String_Node_Str"" + processorName);
    return null;
  }
 else {
    return (DataProcessor)object;
  }
}",0.933481152993348
19857,"/** 
 * Initializes this CepstrumProducer.
 * @param name the name of this CepstrumProducer
 * @param context the relevant context to use
 * @param props the SphinxProperties to read properties from
 * @param predecessor where to get the Spectrum objects
 */
public void initialize(String name,String context,SphinxProperties props,SpectrumSource predecessor) throws IOException ;","/** 
 * Initializes this CepstrumProducer.
 * @param name the name of this CepstrumProducer
 * @param context the relevant context to use
 * @param props the SphinxProperties to read properties from
 * @param predecessor where to get the Spectrum objects
 * @throws IOException if an I/O error occurs
 */
public void initialize(String name,String context,SphinxProperties props,SpectrumSource predecessor) throws IOException ;",0.6873449131513648
19858,"/** 
 * Returns true if this Data has the given Signal
 * @return true if this Data object has the given Signal,false otherwise
 */
public boolean hasSignal(Signal signal){
  if (getSignal() != null) {
    return (getSignal().equals(signal));
  }
 else {
    return false;
  }
}","/** 
 * Returns true if this Data has the given Signal.
 * @param signal  the Signal type to check
 * @return true if this Data object has the given Signal,false otherwise
 */
public boolean hasSignal(Signal signal){
  if (getSignal() != null) {
    return (getSignal().equals(signal));
  }
 else {
    return false;
  }
}",0.9266666666666666
19859,"/** 
 * Sets the SphinxProperties to use.
 * @param sphinxProperties the SphinxProperties to use
 */
public void setSphinxProperties(SphinxProperties sphinxProperties){
  this.sphinxProperties=sphinxProperties;
}","/** 
 * Sets the SphinxProperties to use.
 * @param sphinxProperties the SphinxProperties to use
 * @see #getSphinxProperties
 */
public void setSphinxProperties(SphinxProperties sphinxProperties){
  this.sphinxProperties=sphinxProperties;
}",0.93598233995585
19860,"/** 
 * Determine whether to dump the output for debug purposes.
 * @return true to dump, false to not dump
 */
public final boolean getDump(){
  return this.dump;
}","/** 
 * Determine whether to dump the output for debug purposes.
 * @return true to dump, false to not dump
 * @see #setDump
 */
public final boolean getDump(){
  return this.dump;
}",0.9510086455331412
19861,"/** 
 * Returns the SphinxProperties used by this DataProcessor.
 * @return the SphinxProperties
 */
public final SphinxProperties getSphinxProperties(){
  if (sphinxProperties != null) {
    return sphinxProperties;
  }
 else {
    return SphinxProperties.getSphinxProperties(getContext());
  }
}","/** 
 * Returns the SphinxProperties used by this DataProcessor.
 * @return the SphinxProperties
 * @see #setSphinxProperties
 */
public final SphinxProperties getSphinxProperties(){
  if (sphinxProperties != null) {
    return sphinxProperties;
  }
 else {
    return SphinxProperties.getSphinxProperties(getContext());
  }
}",0.9534510433386838
19862,"/** 
 * Set whether we should dump the output for debug purposes.
 * @param dump true to dump the output; false otherwise
 */
public void setDump(boolean dump){
  this.dump=dump;
}","/** 
 * Set whether we should dump the output for debug purposes.
 * @param dump true to dump the output; false otherwise
 * @see #getDump
 */
public void setDump(boolean dump){
  this.dump=dump;
}",0.9549071618037136
19863,"/** 
 * Returns the type of this Feature. It should normally be the name of the acoustic model used, because it is used to identify which acoustic model this Feature should be aligned with in the decoder. It can also return null, meaning that it has no type name. This would mean that there is only one acoustic model in the decoder.
 * @return the type name of this Feature, or null if it does nothave a type name.
 */
public String getType(){
  return type;
}","/** 
 * Returns the type of this Feature. It should normally be the name of the acoustic model used, because it is used to identify which acoustic model this Feature should be aligned with in the decoder. It can also return null, meaning that it has no type name. This would mean that there is only one acoustic model in the decoder.
 * @return the type name of this Feature, or null if it does nothave a type name.
 * @see #setType
 */
public String getType(){
  return type;
}",0.9818956336528222
19864,"/** 
 * Generate a hashcode for an object
 * @return the hashcode
 */
public int hashCode(){
  int result=17;
  for (int i=0; i < featureData.length; i++) {
    result=37 * result + Float.floatToIntBits(featureData[i]);
  }
  return result;
}","/** 
 * Generate a hashcode for an object. Overrides Object.hashCode.
 * @return the hashcode
 */
public int hashCode(){
  int result=17;
  for (int i=0; i < featureData.length; i++) {
    result=37 * result + Float.floatToIntBits(featureData[i]);
  }
  return result;
}",0.9453125
19865,"/** 
 * Determines if the given object is equal to this object
 * @param o the object to test
 * @return <code>true</code> if the object is equal to this
 */
public boolean equals(Object o){
  if (o == this) {
    return true;
  }
 else   if (o instanceof Feature) {
    Feature other=(Feature)o;
    return (featureData == other.featureData);
  }
 else {
    return false;
  }
}","/** 
 * Determines if the given object is equal to this object. Overrides Object.equals.
 * @param o the object to test
 * @return <code>true</code> if the object is equal to this
 */
public boolean equals(Object o){
  if (o == this) {
    return true;
  }
 else   if (o instanceof Feature) {
    Feature other=(Feature)o;
    return (featureData == other.featureData);
  }
 else {
    return false;
  }
}",0.9668367346938777
19866,"/** 
 * Sets the ID of this Feature.
 * @param id the ID
 */
public void setID(int id){
  this.ID=id;
}","/** 
 * Sets the ID of this Feature.
 * @param id the ID
 * @see #getID
 */
public void setID(int id){
  this.ID=id;
}",0.9321266968325792
19867,"/** 
 * Returns the ID of this Feature, telling you which Feature it is with respect to the utterance. Feature IDs start at 0.
 * @return the ID
 */
public int getID(){
  return ID;
}","/** 
 * Returns the ID of this Feature, telling you which Feature it is with respect to the utterance. Feature IDs start at 0.
 * @return the ID
 * @see #setID
 */
public int getID(){
  return ID;
}",0.9606299212598424
19868,"/** 
 * Sets the type name of this Feature. It should be the name of the acoustic model used. This is the only mutable field in this class. It can only be set once, subsequent calls to this method have no effect.
 * @param type the type name of this Feature
 */
public void setType(String type){
  if (this.type == null) {
    this.type=type;
  }
}","/** 
 * Sets the type name of this Feature. It should be the name of the acoustic model used. This is the only mutable field in this class. It can only be set once, subsequent calls to this method have no effect.
 * @param type the type name of this Feature
 * @see #getType
 */
public void setType(String type){
  if (this.type == null) {
    this.type=type;
  }
}",0.976157082748948
19869,"/** 
 * Returns the array of Features
 * @return the array of Features
 */
public Feature[] getFeatures(){
  return features;
}","/** 
 * Returns the array of Features.
 * @return the array of Features
 */
public Feature[] getFeatures(){
  return features;
}",0.996078431372549
19870,"/** 
 * Constructs a FeatureFrame with the given array of Features
 * @param features the Feature array
 */
public FeatureFrame(Feature[] features){
  this.features=features;
}","/** 
 * Constructs a FeatureFrame with the given array of Features.
 * @param features the Feature array
 */
public FeatureFrame(Feature[] features){
  this.features=features;
}",0.9971671388101984
19871,"/** 
 * Returns the next N FeatureFrames produced by this FeatureFrameSource.
 * @return the next N FeatureFrames, returns null if noFeatureFrame object is available
 * @throws java.io.IOException
 */
public FeatureFrame getFeatureFrame(int numberFrames) throws IOException ;","/** 
 * Returns the next N FeatureFrames produced by this FeatureFrameSource.
 * @param numberFrames  the number of features to return
 * @return the next N FeatureFrames, returns null if noFeatureFrame object is available
 * @throws java.io.IOException
 */
public FeatureFrame getFeatureFrame(int numberFrames) throws IOException ;",0.9060955518945636
19872,"/** 
 * Initializes this Filterbank.
 * @param name the name of this Filterbank
 * @param context the context
 * @param props the SphinxProperties to read properties from
 * @param predecessor the SpectrumSource from which Spectra to filterare obtained
 */
public void initialize(String name,String context,SphinxProperties props,SpectrumSource predecessor) throws IOException ;","/** 
 * Initializes this Filterbank.
 * @param name the name of this Filterbank
 * @param context the context
 * @param props the SphinxProperties to read properties from
 * @param predecessor the SpectrumSource from which Spectra to filterare obtained
 * @throws IOException if an I/O error occurs
 */
public void initialize(String name,String context,SphinxProperties props,SpectrumSource predecessor) throws IOException ;",0.685785536159601
19873,"/** 
 * Returns the next N feature (of the given acoustic model)  produced by this FrontEnd, in a FeatureFrame object. The number of Features return maybe less than N, in which case the last Feature will contain a Signal.UTTERANCE_END signal.
 * @param numberFeatures the number of FeatureFrames to return
 * @return N number of FeatureFrames, or nullif no more FeatureFrames available
 * @see FeatureFrame
 * @throws java.io.IOException if an I/O error occurred
 */
public FeatureFrame getFeatureFrame(int numberFeatures,String acousticModelName) throws IOException ;","/** 
 * Returns the next N feature (of the given acoustic model)  produced by this FrontEnd, in a FeatureFrame object. The number of Features return maybe less than N, in which case the last Feature will contain a Signal.UTTERANCE_END signal.
 * @param numberFeatures the number of FeatureFrames to return
 * @param acousticModelName the name of the acoustic model for whichfeatures are returned
 * @return N number of FeatureFrames, or nullif no more FeatureFrames available
 * @see FeatureFrame
 * @throws java.io.IOException if an I/O error occurred
 */
public FeatureFrame getFeatureFrame(int numberFeatures,String acousticModelName) throws IOException ;",0.9265905383360522
19874,"/** 
 * Initializes this FrontEnd.
 * @param name the name of this FrontEnd
 * @param context the context of this FrontEnd
 * @param dataSource the place to pull data from, or null if noDataSource yet, in which case it should be set later on by the <code>setDataSource()</code> method
 */
public void initialize(String name,String context,DataSource dataSource) throws IOException ;","/** 
 * Initializes this FrontEnd.
 * @param name the name of this FrontEnd
 * @param context the context of this FrontEnd
 * @param dataSource the place to pull data from, or null if noDataSource yet, in which case it should be set later on by the <code>setDataSource()</code> method
 * @throws IOException if an I/O error occurs
 */
public void initialize(String name,String context,DataSource dataSource) throws IOException ;",0.7580246913580246
19875,"/** 
 * Returns the properties of the relevant acoustic model.
 * @return the properties of the relevant acoustic model
 * @throws java.io.IOException if an I/O error occurred
 */
public SphinxProperties getAcousticProperties(String context,String amName) throws IOException {
  AcousticModel am;
  if (amName != null) {
    am=AcousticModel.getAcousticModel(amName,context);
  }
 else {
    am=AcousticModel.getAcousticModel(context);
  }
  if (am != null) {
    return am.getProperties();
  }
 else {
    return null;
  }
}","/** 
 * Returns the properties of the relevant acoustic model.
 * @param context the context of the acoustic properties
 * @param amName  the acoustic model name of the returned acoustic properties
 * @return the properties of the relevant acoustic model
 * @throws java.io.IOException if an I/O error occurred
 */
public SphinxProperties getAcousticProperties(String context,String amName) throws IOException {
  AcousticModel am;
  if (amName != null) {
    am=AcousticModel.getAcousticModel(amName,context);
  }
 else {
    am=AcousticModel.getAcousticModel(context);
  }
  if (am != null) {
    return am.getProperties();
  }
 else {
    return null;
  }
}",0.8860759493670886
19876,"/** 
 * Constructs a SimpleFrontEnd with the given name, context, acoustic  model name, and DataSource.
 * @param name the name of this SimpleFrontEnd
 * @param context the context of interest
 * @param amName the name of the acoustic model
 * @param dataSource the source of data
 */
public void initialize(String name,String context,String amName,DataSource dataSource) throws IOException {
  SphinxProperties props=SphinxProperties.getSphinxProperties(context);
  boolean useAcousticModelProperties=props.getBoolean(FrontEnd.PROP_USE_ACOUSTIC_MODEL_PROPERTIES,FrontEnd.PROP_USE_ACOUSTIC_MODEL_PROPERTIES_DEFAULT);
  if (useAcousticModelProperties) {
    props=(PropertiesResolver.resolve(props,getAcousticProperties(context,amName),context + ""String_Node_Str"" + name));
  }
  super.initialize(name,context,props,amName,dataSource);
}","/** 
 * Constructs a SimpleFrontEnd with the given name, context, acoustic  model name, and DataSource.
 * @param name the name of this SimpleFrontEnd
 * @param context the context of interest
 * @param amName the name of the acoustic model
 * @param dataSource the source of data
 * @throws IOException if an I/O error occurs
 */
public void initialize(String name,String context,String amName,DataSource dataSource) throws IOException {
  SphinxProperties props=SphinxProperties.getSphinxProperties(context);
  boolean useAcousticModelProperties=props.getBoolean(FrontEnd.PROP_USE_ACOUSTIC_MODEL_PROPERTIES,FrontEnd.PROP_USE_ACOUSTIC_MODEL_PROPERTIES_DEFAULT);
  if (useAcousticModelProperties) {
    props=(PropertiesResolver.resolve(props,getAcousticProperties(context,amName),context + ""String_Node_Str"" + name));
  }
  super.initialize(name,context,props,amName,dataSource);
}",0.9732246798603028
19877,"/** 
 * Reads the next Spectrum object, which is an audio frame from which we'll compute the power spectrum. However, it can also be other Spectrum objects that contain a EndPointSignal.
 * @return the next available Spectrum object, returns null if noSpectrum object is available
 */
public Spectrum getSpectrum() throws IOException {
  Audio input=predecessor.getAudio();
  Spectrum output=null;
  getTimer().start();
  if (input != null) {
    if (input.hasContent()) {
      output=process(input);
    }
 else {
      output=new Spectrum(input.getSignal(),input.getCollectTime(),input.getFirstSampleNumber());
    }
  }
  getTimer().stop();
  return output;
}","/** 
 * Reads the next Spectrum object, which is an audio frame from which we'll compute the power spectrum. However, it can also be other Spectrum objects that contain a EndPointSignal.
 * @return the next available Spectrum object, returns null if noSpectrum object is available
 * @throws IOException if an I/O error occurs
 */
public Spectrum getSpectrum() throws IOException {
  Audio input=predecessor.getAudio();
  Spectrum output=null;
  getTimer().start();
  if (input != null) {
    if (input.hasContent()) {
      output=process(input);
    }
 else {
      output=new Spectrum(input.getSignal(),input.getCollectTime(),input.getFirstSampleNumber());
    }
  }
  getTimer().stop();
  return output;
}",0.9198250728862972
19878,"/** 
 * Returns the amount of time (in seconds) this Utterance lasts
 * @return how long is this utterance
 */
public float getAudioTime(){
  byte[] audio=getAudio();
  return ((float)audio.length) / ((float)sampleRate * (bitsPerSample / 8));
}","/** 
 * Returns the amount of time (in seconds) this Utterance lasts.
 * @return how long is this utterance
 */
public float getAudioTime(){
  byte[] audio=getAudio();
  return ((float)audio.length) / ((float)sampleRate * (bitsPerSample / 8));
}",0.9979550102249488
19879,"/** 
 * Returns the audio samples of the given series of features. The firstFeatureID must be less than or equal to the lastFeatureID, otherwise an <code>IllegalArgumentException</code> will be thrown.
 * @param firstFeatureID the ID of the first feature
 * @param lastFeatureID the ID of the last feature
 * @throws IllegalArgumentException if the firstFeatureID is greaterthan the lastFeatureID
 */
public byte[] getAudio(int firstFeatureID,int lastFeatureID) throws IllegalArgumentException {
  if (lastFeatureID < firstFeatureID) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (firstFeatureID < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + firstFeatureID);
  }
  if (lastFeatureID < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + lastFeatureID);
  }
  int numberBytes=windowSizeInBytes;
  int numberWindows=lastFeatureID - firstFeatureID;
  if (numberWindows > 0) {
    numberBytes+=(numberWindows * windowShiftInBytes);
  }
  byte[] audio=new byte[numberBytes];
  flatten();
  int startByte=firstFeatureID * windowShiftInBytes;
  System.arraycopy(flattenedAudio,startByte,audio,0,audio.length);
  return audio;
}","/** 
 * Returns the audio samples of the given series of features. The firstFeatureID must be less than or equal to the lastFeatureID, otherwise an <code>IllegalArgumentException</code> will be thrown.
 * @param firstFeatureID the ID of the first feature
 * @param lastFeatureID the ID of the last feature
 * @return the audio samples of the feature with the given ID
 * @throws IllegalArgumentException if the firstFeatureID is greaterthan the lastFeatureID
 */
public byte[] getAudio(int firstFeatureID,int lastFeatureID) throws IllegalArgumentException {
  if (lastFeatureID < firstFeatureID) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (firstFeatureID < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + firstFeatureID);
  }
  if (lastFeatureID < 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + lastFeatureID);
  }
  int numberBytes=windowSizeInBytes;
  int numberWindows=lastFeatureID - firstFeatureID;
  if (numberWindows > 0) {
    numberBytes+=(numberWindows * windowShiftInBytes);
  }
  byte[] audio=new byte[numberBytes];
  flatten();
  int startByte=firstFeatureID * windowShiftInBytes;
  System.arraycopy(flattenedAudio,startByte,audio,0,audio.length);
  return audio;
}",0.9743164871582436
19880,"/** 
 * Constructs a default Windower with the specified context.
 * @param context the context of the SphinxProperties this Windower uses
 * @throws IOException if an I/O error occurs
 */
public Windower(String name,String context,SphinxProperties props,AudioSource predecessor) throws IOException {
  super(name,context,props);
  setProperties();
  this.predecessor=predecessor;
  createWindow();
  outputQueue=new LinkedList();
  overflowBuffer=new DoubleBuffer(windowSize);
}","/** 
 * Constructs a default Windower with the specified context.
 * @param name         the name of this Windower
 * @param context      the context of this Windower
 * @param props        the properties of this Windower
 * @param predecessor  the predecessor AudioSource
 * @param context the context of the SphinxProperties this Windower uses
 * @throws IOException if an I/O error occurs
 */
public Windower(String name,String context,SphinxProperties props,AudioSource predecessor) throws IOException {
  super(name,context,props);
  setProperties();
  this.predecessor=predecessor;
  createWindow();
  outputQueue=new LinkedList();
  overflowBuffer=new DoubleBuffer(windowSize);
}",0.8223175965665236
19881,"/** 
 * Constructs an AudioFilter with the given name, context, and AudioSource predecessor.
 * @param name the name of this AudioFilter
 * @param context the context of the SphinxProperties thisAudioFilter uses
 * @param props the SphinxProperties to read properties from
 * @param predecessor the AudioSource where this AudioFiltergets Audio from
 */
public AudioFilter(String name,String context,SphinxProperties props,AudioSource predecessor) throws IOException {
  super(name,context,props);
  this.mergeSpeechSegments=getSphinxProperties().getBoolean(PROP_MERGE_SPEECH_SEGMENTS,PROP_MERGE_SPEECH_SEGMENTS_DEFAULT);
  this.discardMode=true;
  this.inSpeech=false;
  this.predecessor=predecessor;
  this.inputBuffer=new LinkedList();
  this.outputQueue=new LinkedList();
}","/** 
 * Constructs an AudioFilter with the given name, context, and AudioSource predecessor.
 * @param name the name of this AudioFilter
 * @param context the context of the SphinxProperties thisAudioFilter uses
 * @param props the SphinxProperties to read properties from
 * @param predecessor the AudioSource where this AudioFiltergets Audio from
 * @throws IOException if an I/O error occurs
 */
public AudioFilter(String name,String context,SphinxProperties props,AudioSource predecessor) throws IOException {
  super(name,context,props);
  this.mergeSpeechSegments=getSphinxProperties().getBoolean(PROP_MERGE_SPEECH_SEGMENTS,PROP_MERGE_SPEECH_SEGMENTS_DEFAULT);
  this.discardMode=true;
  this.inSpeech=false;
  this.predecessor=predecessor;
  this.inputBuffer=new LinkedList();
  this.outputQueue=new LinkedList();
}",0.9712140175219024
19882,"/** 
 * Constructs an NonSpeechFilter with the given name, context, and CepstrumSource predecessor.
 * @param name the name of this NonSpeechFilter
 * @param context the context of the SphinxProperties thisNonSpeechFilter uses
 * @param props the SphinxProperties to read properties from
 * @param predecessor the CepstrumSource where this NonSpeechFiltergets Cepstrum from
 */
public NonSpeechFilter(String name,String context,SphinxProperties props,CepstrumSource predecessor) throws IOException {
  super(name,context,props);
  this.mergeSpeechSegments=getSphinxProperties().getBoolean(PROP_MERGE_SPEECH_SEGMENTS,PROP_MERGE_SPEECH_SEGMENTS_DEFAULT);
  this.discardMode=true;
  this.inSpeech=false;
  this.predecessor=predecessor;
  this.inputBuffer=new LinkedList();
}","/** 
 * Constructs an NonSpeechFilter with the given name, context, and CepstrumSource predecessor.
 * @param name the name of this NonSpeechFilter
 * @param context the context of the SphinxProperties thisNonSpeechFilter uses
 * @param props the SphinxProperties to read properties from
 * @param predecessor the CepstrumSource where this NonSpeechFiltergets Cepstrum from
 * @throws IOException if an I/O error occurs
 */
public NonSpeechFilter(String name,String context,SphinxProperties props,CepstrumSource predecessor) throws IOException {
  super(name,context,props);
  this.mergeSpeechSegments=getSphinxProperties().getBoolean(PROP_MERGE_SPEECH_SEGMENTS,PROP_MERGE_SPEECH_SEGMENTS_DEFAULT);
  this.discardMode=true;
  this.inSpeech=false;
  this.predecessor=predecessor;
  this.inputBuffer=new LinkedList();
}",0.9710327455919396
19883,"/** 
 * Common intialization code
 * @param props the sphinx properties
 * @param batchFile the batch file
 */
private void init(SphinxProperties props) throws IOException {
  referenceFile=props.getString(PROP_REFERENCE_TRANSCRIPT,PROP_REFERENCE_TRANSCRIPT_DEFAULT);
  hypothesisFile=props.getString(PROP_HYPOTHESIS_TRANSCRIPT,PROP_HYPOTHESIS_TRANSCRIPT_DEFAULT);
  hypothesisTranscript=new FileWriter(hypothesisFile);
  sampleRate=props.getInt(FrontEnd.PROP_SAMPLE_RATE,FrontEnd.PROP_SAMPLE_RATE_DEFAULT);
  alignInterval=props.getInt(PROP_ALIGN_INTERVAL,PROP_ALIGN_INTERVAL_DEFAULT);
  decoder=new Decoder(context,getDataSource());
  maxResponseTime=Long.MIN_VALUE;
  minResponseTime=Long.MAX_VALUE;
  Recognizer recognizer=decoder.getRecognizer();
  recognizer.addSignalFeatureListener(new FeatureListener(){
    public void featureOccurred(    Feature feature){
      if (feature.getSignal() == Signal.UTTERANCE_START) {
        long responseTime=(System.currentTimeMillis() - feature.getCollectTime());
        totalResponseTime+=responseTime;
        if (responseTime > maxResponseTime) {
          maxResponseTime=responseTime;
        }
        if (responseTime < minResponseTime) {
          minResponseTime=responseTime;
        }
        numUtteranceStart++;
      }
    }
  }
);
}","/** 
 * Common intialization code
 * @param props the sphinx properties
 */
private void init(SphinxProperties props) throws IOException {
  referenceFile=props.getString(PROP_REFERENCE_TRANSCRIPT,PROP_REFERENCE_TRANSCRIPT_DEFAULT);
  hypothesisFile=props.getString(PROP_HYPOTHESIS_TRANSCRIPT,PROP_HYPOTHESIS_TRANSCRIPT_DEFAULT);
  hypothesisTranscript=new FileWriter(hypothesisFile);
  sampleRate=props.getInt(FrontEnd.PROP_SAMPLE_RATE,FrontEnd.PROP_SAMPLE_RATE_DEFAULT);
  alignInterval=props.getInt(PROP_ALIGN_INTERVAL,PROP_ALIGN_INTERVAL_DEFAULT);
  decoder=new Decoder(context,getDataSource());
  maxResponseTime=Long.MIN_VALUE;
  minResponseTime=Long.MAX_VALUE;
  Recognizer recognizer=decoder.getRecognizer();
  recognizer.addSignalFeatureListener(new FeatureListener(){
    public void featureOccurred(    Feature feature){
      if (feature.getSignal() == Signal.UTTERANCE_START) {
        long responseTime=(System.currentTimeMillis() - feature.getCollectTime());
        totalResponseTime+=responseTime;
        if (responseTime > maxResponseTime) {
          maxResponseTime=responseTime;
        }
        if (responseTime < minResponseTime) {
          minResponseTime=responseTime;
        }
        numUtteranceStart++;
      }
    }
  }
);
}",0.986279890239122
19884,"/** 
 * Align the list of results with reference text. This method figures out how many words and sentences match, and the different types of errors.
 * @param hypothesisList the list of hypotheses
 * @param referenceLis the list of references
 */
private void alignResults(List hypothesisList,List referenceList){
  System.out.println();
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + hypothesisList.size() + ""String_Node_Str""+ referenceList.size());
  String hypothesis=listToString(hypothesisList);
  String reference=listToString(referenceList);
  saveAlignedText(hypothesis,reference);
  getAlignTimer().start();
  NISTAlign aligner=decoder.getNISTAlign();
  aligner.align(reference,hypothesis);
  getAlignTimer().stop();
  System.out.println(""String_Node_Str"");
  System.out.println();
}","/** 
 * Align the list of results with reference text. This method figures out how many words and sentences match, and the different types of errors.
 * @param hypothesisList the list of hypotheses
 * @param referenceList the list of references
 */
private void alignResults(List hypothesisList,List referenceList){
  System.out.println();
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + hypothesisList.size() + ""String_Node_Str""+ referenceList.size());
  String hypothesis=listToString(hypothesisList);
  String reference=listToString(referenceList);
  saveAlignedText(hypothesis,reference);
  getAlignTimer().start();
  NISTAlign aligner=decoder.getNISTAlign();
  aligner.align(reference,hypothesis);
  getAlignTimer().stop();
  System.out.println(""String_Node_Str"");
  System.out.println();
}",0.9993964996982498
19885,"/** 
 * Creates the HMMTree
 * @param pool the pool of HMMs and units
 * @param dictionary the dictionary containing the pronunciations
 * @param words the set of words to add to the lex tree
 * @param addFillerWords if <code>false</code> add filler words
 */
HMMTree(HMMPool pool,Dictionary dictionary,LanguageModel lm,boolean addFillerWords,float languageWeight){
  this.hmmPool=pool;
  this.dictionary=dictionary;
  this.lm=lm;
  this.endNodeMap=new HashMap();
  this.addFillerWords=addFillerWords;
  this.languageWeight=languageWeight;
  Timer.start(""String_Node_Str"");
  compile();
  Timer.stop(""String_Node_Str"");
  Node.dumpNodeInfo();
  dumpTree();
}","/** 
 * Creates the HMMTree
 * @param pool the pool of HMMs and units
 * @param dictionary the dictionary containing the pronunciations
 * @param lm the source of the set of words to add to the lex tree
 * @param addFillerWords if <code>false</code> add filler words
 * @param languageWeight the languageWeight
 */
HMMTree(HMMPool pool,Dictionary dictionary,LanguageModel lm,boolean addFillerWords,float languageWeight){
  this.hmmPool=pool;
  this.dictionary=dictionary;
  this.lm=lm;
  this.endNodeMap=new HashMap();
  this.addFillerWords=addFillerWords;
  this.languageWeight=languageWeight;
  Timer.start(""String_Node_Str"");
  compile();
  Timer.stop(""String_Node_Str"");
  Node.dumpNodeInfo();
  dumpTree();
}",0.9525893508388038
19886,"/** 
 * Dumps the tree
 * @param level the level of the dump
 * @param node the root of the tree to dump
 * @param map map of visited nodes
 */
private void dumpTree(int level,Node node,Map dupNode){
  if (dupNode.get(node) == null) {
    dupNode.put(node,node);
    System.out.println(Utilities.pad(level * 1) + node);
    if (!(node instanceof WordNode)) {
      Collection next=node.getSuccessors();
      for (Iterator i=next.iterator(); i.hasNext(); ) {
        Node nextNode=(Node)i.next();
        dumpTree(level + 1,nextNode,dupNode);
      }
    }
  }
}","/** 
 * Dumps the tree
 * @param level the level of the dump
 * @param node the root of the tree to dump
 * @param dupNode map of visited nodes
 */
private void dumpTree(int level,Node node,Map dupNode){
  if (dupNode.get(node) == null) {
    dupNode.put(node,node);
    System.out.println(Utilities.pad(level * 1) + node);
    if (!(node instanceof WordNode)) {
      Collection next=node.getSuccessors();
      for (Iterator i=next.iterator(); i.hasNext(); ) {
        Node nextNode=(Node)i.next();
        dumpTree(level + 1,nextNode,dupNode);
      }
    }
  }
}",0.9911347517730495
19887,"/** 
 * Creates the node, wrapping the given hmm
 * @param hmm the hmm to hold
 */
EndNode(Unit baseUnit,Unit lc,float probablilty){
  super(probablilty);
  this.baseUnit=baseUnit;
  this.leftContext=lc;
  key=new Integer(baseUnit.getBaseID() * 121 + leftContext.getBaseID());
}","/** 
 * Creates the node, wrapping the given hmm
 * @param baseUnit  the base unit for this node
 * @param lc the left context
 * @param probablilty  the probability for the transition to thisnode
 */
EndNode(Unit baseUnit,Unit lc,float probablilty){
  super(probablilty);
  this.baseUnit=baseUnit;
  this.leftContext=lc;
  key=new Integer(baseUnit.getBaseID() * 121 + leftContext.getBaseID());
}",0.7685459940652819
19888,"/** 
 * Creates a LexTreeState.
 * @param leftID the id of the unit forming the left context(or 0 if  there is no left context) of a triphone context
 * @param central the unit forming the central portion of atriphone context
 * @param right the unit forming the right portion of atriphone context
 * @param wordSequence the history of words up until this point
 * @param logProbability the probability (in log math domain)of entering this state.  This is a combination of insertion and language probability.
 */
LexTreeState(Node node,WordSequence wordSequence){
  this.node=node;
  this.wordSequence=wordSequence;
}","/** 
 * Creates a LexTreeState.
 * @param node the node associated with this state
 * @param wordSequence the history of words up until this point
 */
LexTreeState(Node node,WordSequence wordSequence){
  this.node=node;
  this.wordSequence=wordSequence;
}",0.3486238532110092
19889,"/** 
 * Constructs a LexTreeWordState
 * @param wordNode the word node
 * @param wordSequence the sequence of wordstriphone context
 * @param logProbability the probability of this word occuring
 */
LexTreeWordState(WordNode wordNode,HMMNode lastNode,WordSequence wordSequence,float logProability){
  super(wordNode,wordSequence);
  this.lastNode=lastNode;
  this.logLanguageProbability=logProability;
}","/** 
 * Constructs a LexTreeWordState
 * @param wordNode the word node
 * @param wordSequence the sequence of wordstriphone context
 * @param logProbability the probability of this word occuring
 */
LexTreeWordState(WordNode wordNode,HMMNode lastNode,WordSequence wordSequence,float logProbability){
  super(wordNode,wordSequence);
  this.lastNode=lastNode;
  this.logLanguageProbability=logProbability;
}",0.9975247524752476
19890,"/** 
 * Constructs a LexTreeWordState
 * @param wordNode the word node
 * @param wordSequence the sequence of wordstriphone context
 * @param logProbability the probability of this word occuring
 */
LexTreeEndWordState(WordNode wordNode,HMMNode lastNode,WordSequence wordSequence,float logProability){
  super(wordNode,lastNode,wordSequence,logProability);
}","/** 
 * Constructs a LexTreeWordState
 * @param wordNode the word node
 * @param lastNode the previous word node
 * @param wordSequence the sequence of wordstriphone context
 * @param logProbability the probability of this word occuring
 */
LexTreeEndWordState(WordNode wordNode,HMMNode lastNode,WordSequence wordSequence,float logProbability){
  super(wordNode,lastNode,wordSequence,logProbability);
}",0.9421052631578948
19891,"/** 
 * Creates a unit search state for the given unit node
 * @param hmmNode the unit node
 * @return the search state
 */
SearchStateArc createEndUnitArc(EndNode endNode,float lastProb){
  float languageProbability=getUnigramSmear(endNode) - lastProb;
  float insertionProbability=calculateInsertionProbability(endNode);
  return new LexTreeEndUnitState(endNode,getWordHistory(),languageProbability,insertionProbability);
}","/** 
 * Creates a unit search state for the given unit node
 * @param endNode the unit node
 * @param lastProb the probability of the previus node
 * @return the search state
 */
SearchStateArc createEndUnitArc(EndNode endNode,float lastProb){
  float languageProbability=getUnigramSmear(endNode) - lastProb;
  float insertionProbability=calculateInsertionProbability(endNode);
  return new LexTreeEndUnitState(endNode,getWordHistory(),languageProbability,insertionProbability);
}",0.9060773480662984
19892,"/** 
 * Determines the insertion probability for the given unit lex node
 * @param hmmNode the unit lex node
 * @return the insertion probability
 */
private float calculateInsertionProbability(UnitNode unitNode){
  float logInsertionProbability=logUnitInsertionProbability;
  if (unitNode.getBaseUnit().isSilence()) {
    logInsertionProbability=logSilenceInsertionProbability;
  }
 else   if (unitNode.getBaseUnit().isFiller()) {
    logInsertionProbability=logFillerInsertionProbability;
  }
 else   if (unitNode.getPosition().isWordBeginning()) {
    logInsertionProbability+=logWordInsertionProbability;
  }
  return logInsertionProbability;
}","/** 
 * Determines the insertion probability for the given unit lex node
 * @param unitNode the unit lex node
 * @return the insertion probability
 */
private float calculateInsertionProbability(UnitNode unitNode){
  float logInsertionProbability=logUnitInsertionProbability;
  if (unitNode.getBaseUnit().isSilence()) {
    logInsertionProbability=logSilenceInsertionProbability;
  }
 else   if (unitNode.getBaseUnit().isFiller()) {
    logInsertionProbability=logFillerInsertionProbability;
  }
 else   if (unitNode.getPosition().isWordBeginning()) {
    logInsertionProbability+=logWordInsertionProbability;
  }
  return logInsertionProbability;
}",0.9946029298380878
19893,"/** 
 * Creates the HMMTree
 * @param pool the pool of HMMs and units
 * @param dictionary the dictionary containing the pronunciations
 * @param words the set of words to add to the lex tree
 * @param addFillerWords if <code>false</code> add filler words
 */
HMMTree(HMMPool pool,Dictionary dictionary,LanguageModel lm,boolean addFillerWords,float languageWeight){
  this.hmmPool=pool;
  this.dictionary=dictionary;
  this.lm=lm;
  this.addFillerWords=addFillerWords;
  this.languageWeight=languageWeight;
  Timer.start(""String_Node_Str"");
  compile();
  Timer.stop(""String_Node_Str"");
  Node.dumpNodeInfo();
  dumpTree();
}","/** 
 * Creates the HMMTree
 * @param pool the pool of HMMs and units
 * @param dictionary the dictionary containing the pronunciations
 * @param lm the source for the set of words
 * @param addFillerWords if <code>false</code> add filler words
 * @param languageWeight the language weight
 */
HMMTree(HMMPool pool,Dictionary dictionary,LanguageModel lm,boolean addFillerWords,float languageWeight){
  this.hmmPool=pool;
  this.dictionary=dictionary;
  this.lm=lm;
  this.addFillerWords=addFillerWords;
  this.languageWeight=languageWeight;
  Timer.start(""String_Node_Str"");
  compile();
  Timer.stop(""String_Node_Str"");
  Node.dumpNodeInfo();
  dumpTree();
}",0.911214953271028
19894,"/** 
 * Dumps the tree
 * @param level the level of the dump
 * @param node the root of the tree to dump
 * @param map map of visited nodes
 */
private void dumpTree(int level,Node node,Map dupNode){
  if (dupNode.get(node) == null) {
    dupNode.put(node,node);
    System.out.println(Utilities.pad(level * 1) + node);
    if (!(node instanceof WordNode)) {
      Collection next=node.getSuccessors();
      for (Iterator i=next.iterator(); i.hasNext(); ) {
        Node nextNode=(Node)i.next();
        dumpTree(level + 1,nextNode,dupNode);
      }
    }
  }
}","/** 
 * Dumps the tree
 * @param level the level of the dump
 * @param node the root of the tree to dump
 * @param dupNode map of visited nodes
 */
private void dumpTree(int level,Node node,Map dupNode){
  if (dupNode.get(node) == null) {
    dupNode.put(node,node);
    System.out.println(Utilities.pad(level * 1) + node);
    if (!(node instanceof WordNode)) {
      Collection next=node.getSuccessors();
      for (Iterator i=next.iterator(); i.hasNext(); ) {
        Node nextNode=(Node)i.next();
        dumpTree(level + 1,nextNode,dupNode);
      }
    }
  }
}",0.9911347517730495
19895,"/** 
 * Creates a LexTreeState.
 * @param leftID the id of the unit forming the left context(or 0 if  there is no left context) of a triphone context
 * @param central the unit forming the central portion of atriphone context
 * @param right the unit forming the right portion of atriphone context
 * @param wordSequence the history of words up until this point
 * @param logProbability the probability (in log math domain)of entering this state.  This is a combination of insertion and language probability.
 */
LexTreeState(Node node,WordSequence wordSequence){
  this.node=node;
  this.wordSequence=wordSequence;
}","/** 
 * Creates a LexTreeState.
 * @param node the associated node
 * @param wordSequence the history of words up until this point
 */
LexTreeState(Node node,WordSequence wordSequence){
  this.node=node;
  this.wordSequence=wordSequence;
}",0.3551401869158878
19896,"/** 
 * Constructs a LexTreeWordState
 * @param wordNode the word node
 * @param wordSequence the sequence of wordstriphone context
 * @param logProbability the probability of this word occuring
 */
LexTreeWordState(WordNode wordNode,HMMNode lastNode,WordSequence wordSequence,float logProability){
  super(wordNode,wordSequence);
  this.lastNode=lastNode;
  this.logLanguageProbability=logProability;
}","/** 
 * Constructs a LexTreeWordState
 * @param wordNode the word node
 * @param lastNode the previous node
 * @param wordSequence the sequence of wordstriphone context
 * @param logProbability the probability of this word occuring
 */
LexTreeWordState(WordNode wordNode,HMMNode lastNode,WordSequence wordSequence,float logProbability){
  super(wordNode,wordSequence);
  this.lastNode=lastNode;
  this.logLanguageProbability=logProbability;
}",0.953846153846154
19897,"/** 
 * Creates a LexTreeState.
 * @param leftID the id of the unit forming the left context(or 0 if  there is no left context) of a triphone context
 * @param central the unit forming the central portion of atriphone context
 * @param right the unit forming the right portion of atriphone context
 * @param wordSequence the history of words up until this point
 * @param logProbability the probability (in log math domain)of entering this state.  This is a combination of insertion and language probability.
 */
LexTreeState(int leftID,LexTree.UnitLexNode central,LexTree.UnitLexNode right,WordSequence wordSequence){
  if (leftID == 0) {
    leftID=silenceID;
  }
  if (central != null && central.getID() == silenceID) {
    leftID=silenceID;
    right=null;
  }
  this.leftID=leftID;
  this.central=central;
  this.right=right;
  this.wordSequence=wordSequence;
}","/** 
 * Creates a LexTreeState.
 * @param leftID the id of the unit forming the left context(or 0 if  there is no left context) of a triphone context
 * @param central the unit forming the central portion of atriphone context
 * @param right the unit forming the right portion of atriphone context
 * @param wordSequence the history of words up until this point
 */
LexTreeState(int leftID,LexTree.UnitLexNode central,LexTree.UnitLexNode right,WordSequence wordSequence){
  if (leftID == 0) {
    leftID=silenceID;
  }
  if (central != null && central.getID() == silenceID) {
    leftID=silenceID;
    right=null;
  }
  this.leftID=leftID;
  this.central=central;
  this.right=right;
  this.wordSequence=wordSequence;
}",0.907255520504732
19898,"private SearchStateArc getEndWord(){
  if (endWord == null) {
    endWord=new LexTreeEndWordState();
  }
  return endWord;
}","/** 
 * returns the sole end word. The probability of transitioning to this  word is fixed (which may be a bug).
 * @return the end word.
 */
private SearchStateArc getEndWord(){
  if (endWord == null) {
    endWord=new LexTreeEndWordState();
  }
  return endWord;
}",0.6358974358974359
19899,"/** 
 * Add a context to a list of contexts after ensuring that no identical contexts exist on the list. When a right context is collected it may contain duplicates in certain cases (when this unit is the last unit in a grammar node, and there is a branch to multiple words in subsequent nodes, for instance)
 * @param context the list of contexts to add the new units to
 * @param units the units to add to the context
 */
private void addContext(List contexts,Unit[] units){
  for (Iterator i=contexts.iterator(); i.hasNext(); ) {
    Unit[] onList=(Unit[])i.next();
    if (Unit.isContextMatch(onList,units)) {
      return;
    }
  }
  contexts.add(units);
}","/** 
 * Add a context to a list of contexts after ensuring that no identical contexts exist on the list. When a right context is collected it may contain duplicates in certain cases (when this unit is the last unit in a grammar node, and there is a branch to multiple words in subsequent nodes, for instance)
 * @param contexts the list of contexts to add the new units to
 * @param units the units to add to the context
 */
private void addContext(List contexts,Unit[] units){
  for (Iterator i=contexts.iterator(); i.hasNext(); ) {
    Unit[] onList=(Unit[])i.next();
    if (Unit.isContextMatch(onList,units)) {
      return;
    }
  }
  contexts.add(units);
}",0.999245283018868
19900,"/** 
 * Gets the unit associated with this point in the grammar. If there is no unit, return filler
 * @param filler the filler to use if the unit is empty
 */
private Unit getUnitOrFill(){
  Unit unit=getUnit();
  if (unit == null) {
    unit=Unit.SILENCE;
  }
  return unit;
}","/** 
 * Gets the unit associated with this point in the grammar. If there is no unit, return filler
 * @return the unit for this grammar node or a filler unit
 */
private Unit getUnitOrFill(){
  Unit unit=getUnit();
  if (unit == null) {
    unit=Unit.SILENCE;
  }
  return unit;
}",0.8121645796064401
19901,"/** 
 * Gets the state number for this state
 * @param stateNumber the state number
 */
private int getStateNumber(){
  return stateNumber;
}","/** 
 * Gets the state number for this state
 * @return  the state number
 */
private int getStateNumber(){
  return stateNumber;
}",0.9264705882352942
19902,"/** 
 * Method called when a state is visited by the vistor
 * @param the state that is being visited
 * @return true if the visiting should be terminated
 */
public boolean visit(SentenceHMMState state);","/** 
 * Method called when a state is visited by the vistor
 * @param state the state that is being visited
 * @return true if the visiting should be terminated
 */
public boolean visit(SentenceHMMState state);",0.9855072463768116
19903,"/** 
 * Attaches the given unit to the given tail, expanding the unit if necessary. If an identical unit is already attached, then this path is folded into the existing path.
 * @param tail the place to attach the unit to
 * @param unitState the new unit to attach
 * @param leftContext the left context for the unit
 * @param righttContext the right context for the unit
 * @return the tail of the added unit (or null if the path wasfolded onto an already expanded path.
 */
private SentenceHMMState attachUnit(PronunciationState parent,SentenceHMMState tail,Unit[] units,int which,UnitContext leftContext,UnitContext rightContext){
  Unit[] lc=getLC(leftContext,units,which);
  Unit[] rc=getRC(units,which,rightContext);
  UnitContext actualRightContext=UnitContext.get(rc);
  LeftRightContext context=LeftRightContext.get(lc,rc);
  Unit cdUnit=Unit.getUnit(units[which].getName(),units[which].isFiller(),context);
  UnitState unitState=new ExtendedUnitState(parent,which,cdUnit);
  float logInsertionProbability;
  if (unitState.getUnit().isFiller()) {
    logInsertionProbability=logSilenceInsertionProbability;
  }
 else   if (unitState.getWhich() == 0) {
    logInsertionProbability=logWordInsertionProbability;
  }
 else {
    logInsertionProbability=logUnitInsertionProbability;
  }
  SentenceHMMState existingState=getExistingState(unitState);
  if (existingState != null) {
    attachState(tail,existingState,logOne,logOne,logInsertionProbability);
    return null;
  }
 else {
    attachState(tail,unitState,logOne,logOne,logInsertionProbability);
    addStateToCache(unitState);
    tail=expandUnit(unitState);
    if (unitState.isLast()) {
      UnitContext nextLeftContext=generateNextLeftContext(leftContext,units[which]);
      ContextPair cp=ContextPair.get(nextLeftContext,actualRightContext);
      addExitPoint(cp,tail);
      if (actualRightContext == UnitContext.SILENCE) {
        SentenceHMMState silTail;
        UnitState silUnit=new ExtendedUnitState(parent,which + 1,Unit.SILENCE);
        SentenceHMMState silExistingState=getExistingState(silUnit);
        if (silExistingState != null) {
          attachState(tail,silExistingState,logOne,logOne,logSilenceInsertionProbability);
        }
 else {
          attachState(tail,silUnit,logOne,logOne,logSilenceInsertionProbability);
          addStateToCache(silUnit);
          silTail=expandUnit(silUnit);
          ContextPair silCP=ContextPair.get(UnitContext.SILENCE,UnitContext.EMPTY);
          addExitPoint(silCP,silTail);
        }
      }
    }
    return tail;
  }
}","/** 
 * Attaches the given unit to the given tail, expanding the unit if necessary. If an identical unit is already attached, then this path is folded into the existing path.
 * @param parent the parent state
 * @param tail the place to attach the unit to
 * @param units the set of units
 * @param which the index into the set of units
 * @param leftContext the left context for the unit
 * @param rightContext the right context for the unit
 * @return the tail of the added unit (or null if the path wasfolded onto an already expanded path.
 */
private SentenceHMMState attachUnit(PronunciationState parent,SentenceHMMState tail,Unit[] units,int which,UnitContext leftContext,UnitContext rightContext){
  Unit[] lc=getLC(leftContext,units,which);
  Unit[] rc=getRC(units,which,rightContext);
  UnitContext actualRightContext=UnitContext.get(rc);
  LeftRightContext context=LeftRightContext.get(lc,rc);
  Unit cdUnit=Unit.getUnit(units[which].getName(),units[which].isFiller(),context);
  UnitState unitState=new ExtendedUnitState(parent,which,cdUnit);
  float logInsertionProbability;
  if (unitState.getUnit().isFiller()) {
    logInsertionProbability=logSilenceInsertionProbability;
  }
 else   if (unitState.getWhich() == 0) {
    logInsertionProbability=logWordInsertionProbability;
  }
 else {
    logInsertionProbability=logUnitInsertionProbability;
  }
  SentenceHMMState existingState=getExistingState(unitState);
  if (existingState != null) {
    attachState(tail,existingState,logOne,logOne,logInsertionProbability);
    return null;
  }
 else {
    attachState(tail,unitState,logOne,logOne,logInsertionProbability);
    addStateToCache(unitState);
    tail=expandUnit(unitState);
    if (unitState.isLast()) {
      UnitContext nextLeftContext=generateNextLeftContext(leftContext,units[which]);
      ContextPair cp=ContextPair.get(nextLeftContext,actualRightContext);
      addExitPoint(cp,tail);
      if (actualRightContext == UnitContext.SILENCE) {
        SentenceHMMState silTail;
        UnitState silUnit=new ExtendedUnitState(parent,which + 1,Unit.SILENCE);
        SentenceHMMState silExistingState=getExistingState(silUnit);
        if (silExistingState != null) {
          attachState(tail,silExistingState,logOne,logOne,logSilenceInsertionProbability);
        }
 else {
          attachState(tail,silUnit,logOne,logOne,logSilenceInsertionProbability);
          addStateToCache(silUnit);
          silTail=expandUnit(silUnit);
          ContextPair silCP=ContextPair.get(UnitContext.SILENCE,UnitContext.EMPTY);
          addExitPoint(silCP,silTail);
        }
      }
    }
    return tail;
  }
}",0.9430391967561306
19904,"/** 
 * Adds an exit point to this gstate
 * @param cp the context tag for the state
 * @param tail the state associated with the tag
 */
private void addExitPoint(ContextPair cp,SentenceHMMState state){
  List list=(List)exitPoints.get(cp);
  if (list == null) {
    list=new ArrayList();
    exitPoints.put(cp,list);
  }
  list.add(state);
}","/** 
 * Adds an exit point to this gstate
 * @param cp the context tag for the state
 * @param state the state associated with the tag
 */
private void addExitPoint(ContextPair cp,SentenceHMMState state){
  List list=(List)exitPoints.get(cp);
  if (list == null) {
    list=new ArrayList();
    exitPoints.put(cp,list);
  }
  list.add(state);
}",0.9868995633187772
19905,"/** 
 * Creates a UnitContext for the given context. This constructor is not directly accessible, use the factory method instead.
 * @param context the context to wrap with this UnitContext
 */
private ContextPair(UnitContext left,UnitContext right){
  this.left=left;
  this.right=right;
  hashCode=99 + left.hashCode() * 113 + right.hashCode();
}","/** 
 * Creates a UnitContext for the given context. This constructor is not directly accessible, use the factory method instead.
 * @param left the left context
 * @param right the right context
 */
private ContextPair(UnitContext left,UnitContext right){
  this.left=left;
  this.right=right;
  hashCode=99 + left.hashCode() * 113 + right.hashCode();
}",0.8717948717948718
19906,"/** 
 * Creates a scoreable job
 * @param scoreableList the list of scoreables
 * @param start the starting point for this job
 * @param size the number of scoreables in this job
 */
ScoreableJob(List scoreables,int start,int size){
  this.scoreables=scoreables;
  this.start=start;
  this.size=size;
}","/** 
 * Creates a scoreable job
 * @param scoreables the list of scoreables
 * @param start the starting point for this job
 * @param size the number of scoreables in this job
 */
ScoreableJob(List scoreables,int start,int size){
  this.scoreables=scoreables;
  this.start=start;
  this.size=size;
}",0.9916805324459236
19907,"/** 
 * Copy the input rule object but change all instances of a  RuleName to a BaseRuleName.  Used by setRule method in BaseRuleGrammar so there is a place to put the fully resolved rule name when linking a Grammar.
 */
public static Rule copyForBaseRuleName(Rule r){
  if (r == null) {
    return null;
  }
  if (r instanceof RuleToken) {
    RuleToken rt=(RuleToken)r;
    return new RuleToken(rt.getText());
  }
  if (r instanceof RuleAlternatives) {
    RuleAlternatives ra=(RuleAlternatives)r;
    Rule array[]=ra.getRules();
    for (int i=0; i < array.length; i++) {
      array[i]=copyForBaseRuleName(array[i]);
    }
    return new RuleAlternatives(array);
  }
  if (r instanceof RuleSequence) {
    RuleSequence rs=(RuleSequence)r;
    Rule array[]=rs.getRules();
    for (int i=0; i < array.length; i++) {
      array[i]=copyForBaseRuleName(array[i]);
    }
    return new RuleSequence(array);
  }
  if (r instanceof RuleCount) {
    RuleCount rc=(RuleCount)r;
    return new RuleCount(copyForBaseRuleName(rc.getRule()),rc.getCount());
  }
  if (r instanceof RuleTag) {
    RuleTag rt=(RuleTag)r;
    return new RuleTag(copyForBaseRuleName(rt.getRule()),rt.getTag());
  }
  if (r instanceof RuleName) {
    RuleName rn=(RuleName)r;
    return new BaseRuleName(rn.getRuleName());
  }
  throw new RuntimeException(""String_Node_Str"");
}","/** 
 * Copy the input rule object but change all instances of a  RuleName to a BaseRuleName.  Used by setRule method in BaseRuleGrammar so there is a place to put the fully resolved rule name when linking a Grammar.
 */
public static Rule copyForBaseRuleName(Rule r){
  if (r == null) {
    return null;
  }
  if (r instanceof RuleToken) {
    RuleToken rt=(RuleToken)r;
    return new RuleToken(rt.getText());
  }
  if (r instanceof RuleAlternatives) {
    RuleAlternatives ra=(RuleAlternatives)r;
    Rule array[]=ra.getRules();
    float[] weights=ra.getWeights();
    for (int i=0; i < array.length; i++) {
      array[i]=copyForBaseRuleName(array[i]);
    }
    return new RuleAlternatives(array,weights);
  }
  if (r instanceof RuleSequence) {
    RuleSequence rs=(RuleSequence)r;
    Rule array[]=rs.getRules();
    for (int i=0; i < array.length; i++) {
      array[i]=copyForBaseRuleName(array[i]);
    }
    return new RuleSequence(array);
  }
  if (r instanceof RuleCount) {
    RuleCount rc=(RuleCount)r;
    return new RuleCount(copyForBaseRuleName(rc.getRule()),rc.getCount());
  }
  if (r instanceof RuleTag) {
    RuleTag rt=(RuleTag)r;
    return new RuleTag(copyForBaseRuleName(rt.getRule()),rt.getTag());
  }
  if (r instanceof RuleName) {
    RuleName rn=(RuleName)r;
    return new BaseRuleName(rn.getRuleName());
  }
  throw new RuntimeException(""String_Node_Str"");
}",0.9835466179159048
19908,"/** 
 * According to the given data format, returns an appropriate InputStream of the given file in the given URL location. The location can be a plain directory or a JAR or ZIP file (these are the only ones supported at this point). Suppose you want the InputStream to the file ""dict/dictionary.txt"" in the ZIP file ""file:/lab/speech/sphinx4/data/wsj.zip"". You will do: <code> StreamFactory.getInputStream(StreamFactory.ZIP_FILE, ""file:/lab/speech/sphinx4/data/wsj.zip"", ""dict/dictionary.txt""); </code> Suppose you want the InputStream to the file ""dict/dictionary.txt"" in the directory ""file:/lab/speech/sphinx4/data/wsj"", you will do: <code> StreamFactory.getInputStream(StreamFactory.DIRECTORY, ""file:/lab/speech/sphinx4/data/wsj"", ""dict/dictionary.txt""); </code>
 * @param format the format of the input data, the currently supportedformats are: <br>StreamFactory.ZIP_FILE <br>StreamFactory.DIRECTORY
 * @param location the URL location of the input data, it can nowbe a directory or a JAR or ZIP file, or null if no location is given, which means that the <code>argument</code> also  specifies the exact location
 * @param file the file in the given location to obtain the InputStream
 * @return an InputStream of the given file in the given location 
 */
public static InputStream getInputStream(String format,String location,String file) throws FileNotFoundException, IOException, ZipException {
  InputStream stream=null;
  String absoluteLocation;
  URI uri=URI.create(location);
  String scheme=uri.getScheme();
  String path=uri.getSchemeSpecificPart();
  File relativeFile=new File(path);
  if (scheme == null) {
    absoluteLocation=relativeFile.getAbsolutePath();
  }
 else {
    absoluteLocation=scheme + ""String_Node_Str"" + relativeFile.getAbsolutePath();
  }
  if (format.equals(ZIP_FILE)) {
    try {
      ZipFile zipFile=new ZipFile(new File(new URI(absoluteLocation)));
      ZipEntry entry=zipFile.getEntry(file);
      if (entry != null) {
        stream=zipFile.getInputStream(entry);
      }
    }
 catch (    URISyntaxException use) {
      use.printStackTrace();
      throw new ZipException(""String_Node_Str"" + use.getMessage());
    }
  }
 else   if (format.equals(DIRECTORY)) {
    if (absoluteLocation != null) {
      stream=new FileInputStream(absoluteLocation + File.separator + file);
    }
 else {
      stream=new FileInputStream(file);
    }
  }
  return stream;
}","/** 
 * According to the given data format, returns an appropriate InputStream of the given file in the given URL location. The location can be a plain directory or a JAR or ZIP file (these are the only ones supported at this point). Suppose you want the InputStream to the file ""dict/dictionary.txt"" in the ZIP file ""file:/lab/speech/sphinx4/data/wsj.zip"". You will do: <code> StreamFactory.getInputStream(StreamFactory.ZIP_FILE, ""file:/lab/speech/sphinx4/data/wsj.zip"", ""dict/dictionary.txt""); </code> Suppose you want the InputStream to the file ""dict/dictionary.txt"" in the directory ""file:/lab/speech/sphinx4/data/wsj"", you will do: <code> StreamFactory.getInputStream(StreamFactory.DIRECTORY, ""file:/lab/speech/sphinx4/data/wsj"", ""dict/dictionary.txt""); </code>
 * @param format the format of the input data, the currently supportedformats are: <br>StreamFactory.ZIP_FILE <br>StreamFactory.DIRECTORY
 * @param location the URL location of the input data, it can nowbe a directory or a JAR or ZIP file, or null if no location is given, which means that the <code>argument</code> also  specifies the exact location
 * @param file the file in the given location to obtain the InputStream
 * @return an InputStream of the given file in the given location 
 */
public static InputStream getInputStream(String format,String location,String file) throws FileNotFoundException, IOException, ZipException {
  InputStream stream=null;
  String absoluteLocation;
  if (location == null) {
    absoluteLocation=null;
  }
 else {
    URI uri=URI.create(location);
    String scheme=uri.getScheme();
    String path=uri.getSchemeSpecificPart();
    File relativeFile=new File(path);
    URI absoluteURI=relativeFile.getAbsoluteFile().toURI();
    if (scheme == null) {
      absoluteLocation=absoluteURI.getSchemeSpecificPart();
    }
 else {
      absoluteLocation=scheme + ""String_Node_Str"" + absoluteURI.getSchemeSpecificPart();
    }
  }
  if (format.equals(ZIP_FILE)) {
    try {
      URI newURI=new URI(absoluteLocation);
      ZipFile zipFile=new ZipFile(new File(new URI(absoluteLocation)));
      ZipEntry entry=zipFile.getEntry(file);
      if (entry != null) {
        stream=zipFile.getInputStream(entry);
      }
    }
 catch (    URISyntaxException use) {
      use.printStackTrace();
      throw new ZipException(""String_Node_Str"" + use.getMessage());
    }
  }
 else   if (format.equals(DIRECTORY)) {
    if (absoluteLocation != null) {
      stream=new FileInputStream(absoluteLocation + File.separator + file);
    }
 else {
      stream=new FileInputStream(file);
    }
  }
  return stream;
}",0.944677451567805
19909,"/** 
 * Constructs a LexTreeHMMState
 * @param hmmNode the hmm state associated with this unit
 * @param wordSequence the word history 
 * @param languageProbability the probability of the transition
 * @param insertionProbability the probability of the transition
 * @param acousticProbability the probability of the transitionoccuring
 */
LexTreeHMMState(HMMNode hmmNode,WordSequence wordSequence,HMMState hmmState,float languageProbability,float insertionProbability,float acousticProbability,Node parentNode){
  super(hmmNode,wordSequence);
  this.hmmState=hmmState;
  this.parentNode=parentNode;
  this.logLanguageProbability=languageProbability;
  this.logAcousticProbability=acousticProbability;
  this.logInsertionProbability=insertionProbability;
}","/** 
 * Constructs a LexTreeHMMState
 * @param hmmNode the hmm state associated with this unit
 * @param wordSequence the word history 
 * @param languageProbability the probability of the transition
 * @param insertionProbability the probability of the transition
 * @param acousticProbability the probability of the transitionoccuring
 */
LexTreeHMMState(HMMNode hmmNode,WordSequence wordSequence,HMMState hmmState,float languageProbability,float insertionProbability,float acousticProbability,Node parentNode){
  super(hmmNode,wordSequence);
  this.hmmState=hmmState;
  this.parentNode=parentNode;
  this.logLanguageProbability=languageProbability;
  this.logInsertionProbability=insertionProbability;
  this.logAcousticProbability=acousticProbability;
}",0.92998678996037
19910,"/** 
 * Compiles the n-gram into a lex tree that is used during the search
 */
protected void compileGrammar(){
  Timer.start(""String_Node_Str"");
  hmmPool=new HMMPool(acousticModel);
  silenceID=hmmPool.getID(Unit.SILENCE);
  hmmTree=new HMMTree(hmmPool,dictionary,languageModel,addFillerWords,languageWeight);
  hmmPool.dumpInfo();
  Timer.stop(""String_Node_Str"");
  Timer.dumpAll();
}","/** 
 * Compiles the n-gram into a lex tree that is used during the search
 */
protected void compileGrammar(){
  Timer.start(""String_Node_Str"");
  hmmPool=new HMMPool(acousticModel);
  hmmTree=new HMMTree(hmmPool,dictionary,languageModel,addFillerWords,languageWeight);
  hmmPool.dumpInfo();
  Timer.stop(""String_Node_Str"");
  Timer.dumpAll();
}",0.9440654843110504
19911,"/** 
 * Runs this DecodingThread.
 */
public void run(){
  Result result=decoder.decode();
  if (doEndpointing) {
    microphone.stopRecording();
  }
  String resultText=result.getBestResultNoSilences();
  String tag=getResultTag(resultText);
  cardMatchFrame.processResults(resultText,tag);
  drain();
}","/** 
 * Runs this DecodingThread.
 */
public void run(){
  Result result=decoder.decode();
  if (doEndpointing) {
    microphone.stopRecording();
  }
  String resultText=result.getBestResultNoFiller();
  String tag=getResultTag(resultText);
  cardMatchFrame.processResults(resultText,tag);
  drain();
}",0.976897689768977
19912,"/** 
 * Goes through the active list of tokens and expands each token, finding the set of successor tokens until all the successor tokens are emitting tokens.
 */
protected void growBranches(){
  growTimer.start();
  bestTokenMap=new HashMap(activeList.size() * 10);
  ActiveList oldActiveList=activeList;
  Iterator oldListIterator=activeList.iterator();
  resultList=new LinkedList();
  activeList=activeList.createNew();
  threshold=oldActiveList.getBeamThreshold();
  wordThreshold=oldActiveList.getBestScore() + logRelativeWordBeamWidth;
  while (oldListIterator.hasNext()) {
    Token token=(Token)oldListIterator.next();
    collectSuccessorTokens(token);
  }
  growTimer.stop();
  if (false) {
    int hmms=activeList.size();
    totalHmms+=hmms;
    System.out.println(""String_Node_Str"" + currentFrameNumber + ""String_Node_Str""+ hmms+ ""String_Node_Str""+ totalHmms);
  }
}","/** 
 * Goes through the active list of tokens and expands each token, finding the set of successor tokens until all the successor tokens are emitting tokens.
 */
protected void growBranches(){
  int mapSize=activeList.size() * 10;
  if (mapSize == 0) {
    mapSize=1;
  }
  growTimer.start();
  bestTokenMap=new HashMap(mapSize);
  ActiveList oldActiveList=activeList;
  Iterator oldListIterator=activeList.iterator();
  resultList=new LinkedList();
  activeList=activeList.createNew();
  threshold=oldActiveList.getBeamThreshold();
  wordThreshold=oldActiveList.getBestScore() + logRelativeWordBeamWidth;
  while (oldListIterator.hasNext()) {
    Token token=(Token)oldListIterator.next();
    collectSuccessorTokens(token);
  }
  growTimer.stop();
  if (false) {
    int hmms=activeList.size();
    totalHmms+=hmms;
    System.out.println(""String_Node_Str"" + currentFrameNumber + ""String_Node_Str""+ hmms+ ""String_Node_Str""+ totalHmms);
  }
}",0.944078947368421
19913,"/** 
 * Replicate the last frame into the last window number of frames in the cepstraBuffer.
 * @return the number of replicated Cepstrum
 */
private int replicateLastCepstrum(){
  float[] last=null;
  if (bufferPosition > 0) {
    last=this.cepstraBuffer[bufferPosition - 1];
  }
 else   if (bufferPosition == 0) {
    last=cepstraBuffer[cepstraBuffer.length - 1];
  }
 else {
    throw new Error(""String_Node_Str"");
  }
  if (bufferPosition + window < cepstraBufferSize) {
    Arrays.fill(cepstraBuffer,bufferPosition,bufferPosition + window,last);
    bufferPosition+=window;
  }
 else {
    for (int i=0; i < window; i++) {
      addCepstrumData(last);
    }
  }
  return window;
}","/** 
 * Replicate the last frame into the last window number of frames in the cepstraBuffer.
 * @return the number of replicated Cepstrum
 */
private int replicateLastCepstrum(){
  float[] last=null;
  if (bufferPosition > 0) {
    last=this.cepstraBuffer[bufferPosition - 1];
  }
 else   if (bufferPosition == 0) {
    last=cepstraBuffer[cepstraBuffer.length - 1];
  }
 else {
    throw new Error(""String_Node_Str"");
  }
  for (int i=0; i < window; i++) {
    addCepstrumData(last);
  }
  return window;
}",0.8245172124265323
19914,"/** 
 * Returns the next Feature object produced by this LiveFeatureExtractor.
 * @return the next available Feature object, returns null if noFeature object is available
 * @throws java.io.IOException if there is an error readingthe Feature objects
 * @see Feature
 * @see FeatureFrame
 */
public Feature getFeature() throws IOException {
  Cepstrum input=predecessor.getCepstrum();
  if (input != null) {
    if (input.hasContent()) {
      addCepstrumData(input.getCepstrumData());
      computeFeatures(1);
    }
 else     if (input.hasSignal(Signal.UTTERANCE_START)) {
      hasUtteranceEnd=false;
      outputQueue.add(new Feature(Signal.UTTERANCE_START,IDGenerator.NON_ID));
      featureID.reset();
      Cepstrum start=predecessor.getCepstrum();
      int n=processFirstCepstrum(start);
      computeFeatures(n);
      if (hasUtteranceEnd) {
        outputQueue.add(getUtteranceEndFeature());
      }
    }
 else     if (input.hasSignal(Signal.UTTERANCE_END)) {
      int n=replicateLastCepstrum();
      computeFeatures(n);
      outputQueue.add(getUtteranceEndFeature());
    }
  }
  if (outputQueue.size() > 0) {
    Feature feature=(Feature)outputQueue.remove(0);
    return feature;
  }
 else {
    return null;
  }
}","/** 
 * Returns the next Feature object produced by this LiveFeatureExtractor.
 * @return the next available Feature object, returns null if noFeature object is available
 * @throws java.io.IOException if there is an error readingthe Feature objects
 * @see Feature
 * @see FeatureFrame
 */
public Feature getFeature() throws IOException {
  if (outputQueue.size() == 0) {
    Cepstrum input=predecessor.getCepstrum();
    if (input != null) {
      if (input.hasContent()) {
        addCepstrumData(input.getCepstrumData());
        computeFeatures(1);
      }
 else       if (input.hasSignal(Signal.UTTERANCE_START)) {
        hasUtteranceEnd=false;
        outputQueue.add(new Feature(Signal.UTTERANCE_START,IDGenerator.NON_ID));
        featureID.reset();
        Cepstrum start=predecessor.getCepstrum();
        int n=processFirstCepstrum(start);
        computeFeatures(n);
        if (hasUtteranceEnd) {
          outputQueue.add(getUtteranceEndFeature());
        }
      }
 else       if (input.hasSignal(Signal.UTTERANCE_END)) {
        int n=replicateLastCepstrum();
        computeFeatures(n);
        outputQueue.add(getUtteranceEndFeature());
      }
    }
  }
  if (outputQueue.size() > 0) {
    Feature feature=(Feature)outputQueue.remove(0);
    return feature;
  }
 else {
    return null;
  }
}",0.9673870333988212
19915,"/** 
 * Returns the next Feature object from this FrameDropper. The Feature objects belonging to a single Utterance should be preceded by a Feature object with the Signal.UTTERANCE_START, and ended by a Feature object wtih the Signal.UTTERANCE_END.
 * @return the next available Feature object, returns null if noFeature object is available
 * @throws java.io.IOException
 */
public Feature getFeature() throws IOException {
  Feature feature=predecessor.getFeature();
  if (feature.hasContent()) {
    if ((feature.getID() % dropEveryNthFrame) == (dropEveryNthFrame - 1)) {
      if (replaceNthWithPrevious) {
        feature=new Feature(lastFeature.getFeatureData(),id++);
      }
 else {
        feature=predecessor.getFeature();
        if (feature.hasContent()) {
          feature.setID(id++);
        }
      }
    }
 else {
      feature.setID(id++);
    }
  }
 else   if (feature.hasSignal(Signal.UTTERANCE_START)) {
    id=0;
  }
  if (feature.hasContent()) {
    lastFeature=feature;
  }
 else {
    lastFeature=null;
  }
  return feature;
}","/** 
 * Returns the next Feature object from this FrameDropper. The Feature objects belonging to a single Utterance should be preceded by a Feature object with the Signal.UTTERANCE_START, and ended by a Feature object wtih the Signal.UTTERANCE_END.
 * @return the next available Feature object, returns null if noFeature object is available
 * @throws java.io.IOException
 */
public Feature getFeature() throws IOException {
  Feature feature=predecessor.getFeature();
  if (feature != null) {
    if (feature.hasContent()) {
      if ((feature.getID() % dropEveryNthFrame) == (dropEveryNthFrame - 1)) {
        if (replaceNthWithPrevious) {
          feature=new Feature(lastFeature.getFeatureData(),id++);
        }
 else {
          feature=predecessor.getFeature();
          if (feature != null && feature.hasContent()) {
            feature.setID(id++);
          }
        }
      }
 else {
        feature.setID(id++);
      }
    }
    if (feature != null) {
      if (feature.hasSignal(Signal.UTTERANCE_START)) {
        id=0;
      }
      if (feature.hasContent()) {
        lastFeature=feature;
      }
 else {
        lastFeature=null;
      }
    }
 else {
      lastFeature=null;
    }
  }
  return feature;
}",0.9046991655687308
19916,"/** 
 * Loads the given sphinx3 style simple dictionary from  the given InputStream. The InputStream is assumed to contain ASCII data.
 * @param inputStream the InputStream of the dictionary
 * @param isFillerDict true if this is a filler dictionary, false otherwise
 * @throws java.io.IOException if there is an error reading the dictionary
 */
private void loadDictionary(InputStream inputStream,boolean isFillerDict) throws IOException {
  InputStreamReader isr=new InputStreamReader(inputStream);
  BufferedReader br=new BufferedReader(isr);
  String line;
  while ((line=br.readLine()) != null) {
    if (line.length() > 0) {
      int spaceIndex=line.indexOf(' ');
      int spaceIndexTab=line.indexOf('\t');
      if (spaceIndex == -1) {
        spaceIndex=spaceIndexTab;
      }
 else       if ((spaceIndexTab >= 0) && (spaceIndexTab < spaceIndex)) {
        spaceIndex=spaceIndexTab;
      }
      if (spaceIndex == -1) {
        throw new Error(""String_Node_Str"" + line);
      }
      String word=line.substring(0,spaceIndex);
      word=word.toLowerCase();
      if (isFillerDict) {
        dictionary.put(word,(FILLER_TAG + line));
      }
 else {
        dictionary.put(word,line);
      }
    }
  }
  br.close();
  isr.close();
  inputStream.close();
}","/** 
 * Loads the given sphinx3 style simple dictionary from  the given InputStream. The InputStream is assumed to contain ASCII data.
 * @param inputStream the InputStream of the dictionary
 * @param isFillerDict true if this is a filler dictionary, false otherwise
 * @throws java.io.IOException if there is an error reading the dictionary
 */
private void loadDictionary(InputStream inputStream,boolean isFillerDict) throws IOException {
  InputStreamReader isr=new InputStreamReader(inputStream);
  BufferedReader br=new BufferedReader(isr);
  String line;
  while ((line=br.readLine()) != null) {
    if (line.length() > 0) {
      int spaceIndex=line.indexOf(' ');
      int spaceIndexTab=line.indexOf('\t');
      if (spaceIndex == -1) {
        spaceIndex=spaceIndexTab;
      }
 else       if ((spaceIndexTab >= 0) && (spaceIndexTab < spaceIndex)) {
        spaceIndex=spaceIndexTab;
      }
      if (spaceIndex == -1) {
        throw new Error(""String_Node_Str"" + line);
      }
      String word=line.substring(0,spaceIndex);
      word=word.toLowerCase();
      if (isFillerDict) {
        dictionary.put(word,(FILLER_TAG + line));
        fillerWords.add(word);
      }
 else {
        dictionary.put(word,line);
      }
    }
  }
  br.close();
  isr.close();
  inputStream.close();
}",0.9879142300194932
19917,"/** 
 * Constructs a FastDictionary using the given context. The context will give you the SphinxProperties that tells you where the word and filler dictionaries are by the following properties: <pre> edu.cmu.sphinx.knowledge.dictionary.Dictionary.dictionaryPath edu.cmu.sphinx.knowledge.dictionary.Dictionary.fillerDictionaryPath  </pre>
 * @param context the context of this FastDictionary
 * @throws java.lang.IllegalArgumentException if the given contextdoes not contain a path to the dictionary
 * @throws java.io.IOException if there is an error reading the dictionary
 */
public FastDictionary(String context) throws IllegalArgumentException, IOException {
  SphinxProperties properties=SphinxProperties.getSphinxProperties(context);
  boolean useAMLocation=properties.getBoolean(Dictionary.PROP_USE_AM_LOCATION,Dictionary.PROP_USE_AM_LOCATION_DEFAULT);
  String location=null;
  if (useAMLocation) {
    location=properties.getString(AcousticModel.PROP_LOCATION,null);
  }
  String wordDictionaryFile=properties.getString(Dictionary.PROP_DICTIONARY,Dictionary.PROP_DICTIONARY_DEFAULT);
  String fillerDictionaryFile=properties.getString(Dictionary.PROP_FILLER_DICTIONARY,Dictionary.PROP_FILLER_DICTIONARY_DEFAULT);
  addSilEndingPronunciation=properties.getBoolean(Dictionary.PROP_ADD_SIL_ENDING_PRONUNCIATION,Dictionary.PROP_ADD_SIL_ENDING_PRONUNCIATION_DEFAULT);
  wordReplacement=properties.getString(Dictionary.PROP_WORD_REPLACEMENT,Dictionary.PROP_WORD_REPLACEMENT_DEFAULT);
  if (wordReplacement != null) {
    wordReplacement=wordReplacement.toLowerCase();
  }
  allowMissingWords=properties.getBoolean(Dictionary.PROP_ALLOW_MISSING_WORDS,Dictionary.PROP_ALLOW_MISSING_WORDS_DEFAULT);
  createMissingWords=properties.getBoolean(PROP_CREATE_MISSING_WORDS,PROP_CREATE_MISSING_WORDS_DEFAULT);
  if (wordDictionaryFile == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + context + ""String_Node_Str""+ ""String_Node_Str""+ PROP_DICTIONARY);
  }
  if (fillerDictionaryFile == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + context + ""String_Node_Str""+ ""String_Node_Str""+ PROP_FILLER_DICTIONARY);
  }
  Timer loadTimer=Timer.getTimer(context,""String_Node_Str"");
  fillerWords=new ArrayList();
  loadTimer.start();
  logger.info(""String_Node_Str"");
  logger.info(location + ""String_Node_Str"" + wordDictionaryFile);
  loadDictionary(StreamFactory.getInputStream(location,wordDictionaryFile),false);
  logger.info(""String_Node_Str"");
  logger.info(location + ""String_Node_Str"" + fillerDictionaryFile);
  loadDictionary(StreamFactory.getInputStream(location,fillerDictionaryFile),true);
  loadTimer.stop();
}","/** 
 * Constructs a FastDictionary using the given context. The context will give you the SphinxProperties that tells you where the word and filler dictionaries are by the following properties: <pre> edu.cmu.sphinx.knowledge.dictionary.Dictionary.dictionaryPath edu.cmu.sphinx.knowledge.dictionary.Dictionary.fillerDictionaryPath  </pre>
 * @param context the context of this FastDictionary
 * @throws java.lang.IllegalArgumentException if the given contextdoes not contain a path to the dictionary
 * @throws java.io.IOException if there is an error reading the dictionary
 */
public FastDictionary(String context) throws IllegalArgumentException, IOException {
  SphinxProperties properties=SphinxProperties.getSphinxProperties(context);
  boolean useAMLocation=properties.getBoolean(Dictionary.PROP_USE_AM_LOCATION,Dictionary.PROP_USE_AM_LOCATION_DEFAULT);
  String location=null;
  if (useAMLocation) {
    location=properties.getString(AcousticModel.PROP_LOCATION,null);
  }
  String wordDictionaryFile=properties.getString(Dictionary.PROP_DICTIONARY,Dictionary.PROP_DICTIONARY_DEFAULT);
  String fillerDictionaryFile=properties.getString(Dictionary.PROP_FILLER_DICTIONARY,Dictionary.PROP_FILLER_DICTIONARY_DEFAULT);
  addSilEndingPronunciation=properties.getBoolean(Dictionary.PROP_ADD_SIL_ENDING_PRONUNCIATION,Dictionary.PROP_ADD_SIL_ENDING_PRONUNCIATION_DEFAULT);
  wordReplacement=properties.getString(Dictionary.PROP_WORD_REPLACEMENT,Dictionary.PROP_WORD_REPLACEMENT_DEFAULT);
  if (wordReplacement != null) {
    wordReplacement=wordReplacement.toLowerCase();
  }
  allowMissingWords=properties.getBoolean(Dictionary.PROP_ALLOW_MISSING_WORDS,Dictionary.PROP_ALLOW_MISSING_WORDS_DEFAULT);
  createMissingWords=properties.getBoolean(PROP_CREATE_MISSING_WORDS,PROP_CREATE_MISSING_WORDS_DEFAULT);
  if (wordDictionaryFile == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + context + ""String_Node_Str""+ ""String_Node_Str""+ PROP_DICTIONARY);
  }
  if (fillerDictionaryFile == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + context + ""String_Node_Str""+ ""String_Node_Str""+ PROP_FILLER_DICTIONARY);
  }
  Timer loadTimer=Timer.getTimer(context,""String_Node_Str"");
  fillerWords=new HashSet();
  loadTimer.start();
  logger.info(""String_Node_Str"");
  logger.info(location + ""String_Node_Str"" + wordDictionaryFile);
  loadDictionary(StreamFactory.getInputStream(location,wordDictionaryFile),false);
  logger.info(""String_Node_Str"");
  logger.info(location + ""String_Node_Str"" + fillerDictionaryFile);
  loadDictionary(StreamFactory.getInputStream(location,fillerDictionaryFile),true);
  loadTimer.stop();
}",0.9973544973544972
19918,"/** 
 * Gets the set of all filler words in the dictionary
 * @return an array (possibly empty) of all filler words
 */
public Word[] getFillerWords(){
  return (Word[])fillerWords.toArray(new Word[fillerWords.size()]);
}","/** 
 * Gets the set of all filler words in the dictionary
 * @return an array (possibly empty) of all filler words
 */
public Word[] getFillerWords(){
  Word[] fillerWordArray=new Word[fillerWords.size()];
  int index=0;
  for (Iterator i=fillerWords.iterator(); i.hasNext(); ) {
    String spelling=(String)i.next();
    fillerWordArray[index++]=getWord(spelling);
  }
  return fillerWordArray;
}",0.5815831987075929
19919,"/** 
 * Create a Word object with the given spelling and pronunciations, and insert it into the dictionary.
 * @param text the spelling of the word
 * @param pronunciation the pronunciation of the word
 * @param isFiller if <code>true</code> this is a filler word
 * @return the word
 */
private Word createWord(String text,Pronunciation[] pronunciation,boolean isFiller){
  Word word=new Word(text,pronunciation,isFiller);
  dictionary.put(text,word);
  if (isFiller) {
    fillerWords.add(word);
  }
  return word;
}","/** 
 * Create a Word object with the given spelling and pronunciations, and insert it into the dictionary.
 * @param text the spelling of the word
 * @param pronunciation the pronunciation of the word
 * @param isFiller if <code>true</code> this is a filler word
 * @return the word
 */
private Word createWord(String text,Pronunciation[] pronunciation,boolean isFiller){
  Word word=new Word(text,pronunciation,isFiller);
  dictionary.put(text,word);
  return word;
}",0.92806484295846
19920,"/** 
 * Handles the given Cepstrum in the case when mergeSpeechSegment is false.
 */
private Cepstrum handleNonMergingCepstrum(Cepstrum cepstrum) throws IOException {
  Cepstrum next=cepstrum;
  if (cepstrum != null) {
    if (cepstrum.hasSignal(Signal.SPEECH_START)) {
      discardMode=false;
      next=new Cepstrum(Signal.UTTERANCE_START);
    }
 else     if (cepstrum.hasSignal(Signal.SPEECH_END)) {
      discardMode=true;
      next=new Cepstrum(Signal.UTTERANCE_END);
    }
 else     if (discardMode) {
      next=handleNonMergingCepstrum(readCepstrum());
    }
  }
  return next;
}","/** 
 * Handles the given Cepstrum in the case when mergeSpeechSegment is false.
 */
private Cepstrum handleNonMergingCepstrum(Cepstrum cepstrum) throws IOException {
  Cepstrum next=cepstrum;
  if (cepstrum != null) {
    if (cepstrum.hasSignal(Signal.SPEECH_START)) {
      discardMode=false;
      next=new Cepstrum(Signal.UTTERANCE_START);
    }
 else     if (cepstrum.hasSignal(Signal.SPEECH_END)) {
      discardMode=true;
      next=new Cepstrum(Signal.UTTERANCE_END);
    }
 else     if (discardMode) {
      while (next.getSignal() != Signal.SPEECH_START && next.getSignal() != Signal.SPEECH_END) {
        next=readCepstrum();
      }
      next=handleNonMergingCepstrum(next);
    }
  }
  return next;
}",0.8834355828220859
19921,"/** 
 * Process the given low energy Cepstrum.
 * @param cepstrum the low energy Cepstrum to process
 */
private void processLowEnergyCepstrum(Cepstrum cepstrum){
  if (inSpeech) {
    if (endLowFrames == endOffset) {
      endOffsetFrame=cepstrum;
    }
 else     if (endLowFrames > endWindow) {
      speechEnd();
    }
    endLowFrames++;
  }
 else {
    if (startLowFrames > 1) {
      startHighFrames=0;
    }
    startLowFrames++;
  }
  if (cepstrum.getEnergy() < startLow) {
    location=BELOW_START_LOW;
  }
}","/** 
 * Process the given low energy Cepstrum.
 * @param cepstrum the low energy Cepstrum to process
 */
private void processLowEnergyCepstrum(Cepstrum cepstrum){
  if (inSpeech) {
    if (endLowFrames == endOffset) {
      endOffsetFrame=cepstrum;
    }
 else     if (endLowFrames > endWindow) {
      speechEnd();
    }
    endLowFrames++;
  }
 else {
    if (startLowFrames > maxDropout) {
      startHighFrames=0;
    }
    startLowFrames++;
  }
  if (cepstrum.getEnergy() < startLow) {
    location=BELOW_START_LOW;
  }
}",0.9894534995206136
19922,"/** 
 * Process the given high energy Cepstrum.
 * @param cepstrum the high energy Cepstrum to process
 */
private void processHighEnergyCepstrum(Cepstrum cepstrum){
  if (location == BELOW_START_LOW) {
    if (outputQueue.size() > 0) {
      setLastStartLowFrame((Cepstrum)outputQueue.getFirst());
    }
  }
  if (startHighFrames > startWindow) {
    if (!inSpeech) {
      speechStart();
    }
 else {
      endLowFrames=0;
      endOffsetFrame=null;
    }
  }
 else {
    startHighFrames++;
  }
  location=ABOVE_START_HIGH;
}","/** 
 * Process the given high energy Cepstrum.
 * @param cepstrum the high energy Cepstrum to process
 */
private void processHighEnergyCepstrum(Cepstrum cepstrum){
  if (location == BELOW_START_LOW) {
    if (outputQueue.size() > 0) {
      setLastStartLowFrame((Cepstrum)outputQueue.getFirst());
    }
  }
  if (startHighFrames > startWindow) {
    if (!inSpeech) {
      speechStart();
    }
 else {
      endLowFrames=0;
      endOffsetFrame=null;
    }
  }
 else {
    startHighFrames++;
  }
  location=ABOVE_START_HIGH;
  endLowFrames=0;
}",0.9813780260707636
19923,"/** 
 * Inserts a SPEECH_START at the appropriate place.
 */
private void insertSpeechStart(){
  int index=outputQueue.indexOf(lastStartLowFrame);
  if (index > -1) {
    int i=0;
    for (ListIterator iterator=outputQueue.listIterator(index); i < startOffset && iterator.hasNext(); i++) {
      Cepstrum cepstrum=(Cepstrum)iterator.next();
      if (cepstrum.hasSignal(Signal.UTTERANCE_START)) {
        break;
      }
    }
    index+=i;
  }
  if (index >= outputQueue.size()) {
    index=outputQueue.size();
  }
 else   if (index < 0) {
    index=0;
    System.out.println(""String_Node_Str"" + ""String_Node_Str"");
    for (ListIterator i=outputQueue.listIterator(); i.hasNext(); ) {
      Cepstrum cepstrum=(Cepstrum)i.next();
      if (cepstrum.hasSignal(Signal.UTTERANCE_START)) {
        index=outputQueue.indexOf(cepstrum);
      }
    }
  }
  outputQueue.add(index,(new Cepstrum(Signal.SPEECH_START)));
}","/** 
 * Inserts a SPEECH_START at the appropriate place.
 */
private void insertSpeechStart(){
  int index=outputQueue.indexOf(lastStartLowFrame);
  if (index > -1) {
    int i=0;
    for (ListIterator iterator=outputQueue.listIterator(index); i < startOffset && iterator.hasNext(); i++) {
      Cepstrum cepstrum=(Cepstrum)iterator.next();
      if (cepstrum.hasSignal(Signal.UTTERANCE_START) || cepstrum.hasSignal(Signal.SPEECH_END)) {
        break;
      }
    }
    index+=i;
  }
  if (index >= outputQueue.size()) {
    index=outputQueue.size();
  }
 else   if (index < 0) {
    index=0;
    System.out.println(""String_Node_Str"" + ""String_Node_Str"");
    for (ListIterator i=outputQueue.listIterator(); i.hasNext(); ) {
      Cepstrum cepstrum=(Cepstrum)i.next();
      if (cepstrum.hasSignal(Signal.UTTERANCE_START)) {
        index=outputQueue.indexOf(cepstrum);
      }
    }
  }
  outputQueue.add(index,(new Cepstrum(Signal.SPEECH_START)));
}",0.977992485238862
19924,"/** 
 * Process the given low energy Cepstrum.
 * @param cepstrum the low energy Cepstrum to process
 */
private void processLowEnergyCepstrum(Cepstrum cepstrum){
  if (inSpeech) {
    if (endLowFrames == endOffset) {
      endOffsetFrame=cepstrum;
    }
 else     if (endLowFrames > endWindow) {
      speechEnd();
    }
    endLowFrames++;
  }
 else {
    startLowFrames++;
  }
  if (cepstrum.getEnergy() < startLow) {
    location=BELOW_START_LOW;
  }
}","/** 
 * Process the given low energy Cepstrum.
 * @param cepstrum the low energy Cepstrum to process
 */
private void processLowEnergyCepstrum(Cepstrum cepstrum){
  if (inSpeech) {
    if (endLowFrames == endOffset) {
      endOffsetFrame=cepstrum;
    }
 else     if (endLowFrames > endWindow) {
      speechEnd();
    }
    endLowFrames++;
  }
 else {
    if (startLowFrames > 1) {
      startHighFrames=0;
    }
    startLowFrames++;
  }
  if (cepstrum.getEnergy() < startLow) {
    location=BELOW_START_LOW;
  }
}",0.9373072970195272
19925,"/** 
 * Scores all of the Scoreables in the ScoreableJob
 * @param job the scoreable job
 * @return the best scoring scoreable in the job
 */
private Scoreable scoreScoreables(ScoreableJob job){
  if (job.getSize() <= 0) {
    return null;
  }
  Scoreable best=job.getFirst();
  List scoreables=job.getScoreables();
  for (int i=job.getStart(); i < job.getSize(); i++) {
    Scoreable scoreable=(Scoreable)scoreables.get(i);
    if (scoreable.getFrameNumber() != curFeature.getID()) {
      throw new Error(""String_Node_Str"" + scoreable.getFrameNumber() + ""String_Node_Str""+ curFeature.getID());
    }
    if (scoreable.calculateScore(curFeature) > best.getScore()) {
      best=scoreable;
    }
  }
  return best;
}","/** 
 * Scores all of the Scoreables in the ScoreableJob
 * @param job the scoreable job
 * @return the best scoring scoreable in the job
 */
private Scoreable scoreScoreables(ScoreableJob job){
  Scoreable best=job.getFirst();
  int listSize=job.getScoreables().size();
  int end=job.getStart() + job.getSize();
  if (end > listSize) {
    end=listSize;
  }
  ListIterator iterator=job.getListIterator();
  for (int i=job.getStart(); i < end; i++) {
    Scoreable scoreable=(Scoreable)iterator.next();
    if (scoreable.getFrameNumber() != curFeature.getID()) {
      throw new Error(""String_Node_Str"" + scoreable.getFrameNumber() + ""String_Node_Str""+ curFeature.getID());
    }
    if (scoreable.calculateScore(curFeature) > best.getScore()) {
      best=scoreable;
    }
  }
  return best;
}",0.7231788079470198
19926,"/** 
 * Creates a scoreable job
 * @param scoreableList the list of scoreables
 * @param start the starting point for this job
 * @param size the number of scoreables in this job
 */
ScoreableJob(List scoreables,int start,int size){
  this.scoreables=scoreables;
  this.start=start;
  if ((start + size) > scoreables.size()) {
    this.size=scoreables.size() - start;
  }
 else {
    this.size=size;
  }
}","/** 
 * Creates a scoreable job
 * @param scoreableList the list of scoreables
 * @param start the starting point for this job
 * @param size the number of scoreables in this job
 */
ScoreableJob(List scoreables,int start,int size){
  this.scoreables=scoreables;
  this.start=start;
  this.size=size;
}",0.8373408769448374
19927,"public void run(){
  if (!handsFree) {
    lastResult=decoder.decode(liveFrame.getReference());
    updateLiveFrame(decoder.getNISTAlign());
    liveFrame.setButtonsEnabled(true);
    liveFrame.setDecoderComboBoxEnabled(true);
  }
 else {
    liveFrame.setNextButtonEnabled(true);
    while (decoder.getMicrophone().getRecording()) {
      try {
        System.out.println(""String_Node_Str"");
        lastResult=decoder.decode(liveFrame.getReference());
        System.out.println(""String_Node_Str"");
        updateLiveFrame(decoder.getNISTAlign());
        System.out.println(""String_Node_Str"");
      }
 catch (      NullPointerException npe) {
        npe.printStackTrace();
      }
    }
  }
  System.out.println(""String_Node_Str"");
}","public void run(){
  if (!handsFree) {
    lastResult=decoder.decode(liveFrame.getReference());
    updateLiveFrame(decoder.getNISTAlign());
    liveFrame.setButtonsEnabled(true);
    liveFrame.setDecoderComboBoxEnabled(true);
  }
 else {
    liveFrame.setNextButtonEnabled(true);
    while (decoder.getMicrophone().getRecording()) {
      try {
        System.out.println(""String_Node_Str"");
        lastResult=decoder.decode();
        decoder.setReferenceText(liveFrame.getReference());
        decoder.showFinalResult(lastResult,decoder.getTimer());
        System.out.println(""String_Node_Str"");
        updateLiveFrame(decoder.getNISTAlign());
      }
 catch (      NullPointerException npe) {
        npe.printStackTrace();
      }
    }
  }
  System.out.println(""String_Node_Str"");
}",0.7822105951602355
19928,"/** 
 * Loads the phone list, which possibly contains the sizes (number of states) of models.
 * @param useCDUnits if true, uses context dependent units
 * @param inputStream the open input stream to use
 * @param path the path to a density file
 * @param props the properties for this set of HMMs
 * @throws FileNotFoundException if a file cannot be found
 * @throws IOException if an error occurs while loading the data
 */
private void loadPhoneList(boolean useCDUnits,InputStream inputStream,String path,SphinxProperties props) throws FileNotFoundException, IOException {
  int token_type;
  int numState=0;
  int numStatePerHMM;
  int numContextIndependentTiedState;
  int numStreams=1;
  int numGaussiansPerState=1;
  String version;
  boolean sameSizedModels;
  boolean tmatSkip;
  ExtendedStreamTokenizer est=new ExtendedStreamTokenizer(inputStream,'#',false);
  meansPool=new Pool(""String_Node_Str"");
  variancePool=new Pool(""String_Node_Str"");
  mixtureWeightsPool=new Pool(""String_Node_Str"");
  matrixPool=new Pool(""String_Node_Str"");
  senonePool=new Pool(""String_Node_Str"");
  float distFloor=props.getFloat(AcousticModel.PROP_MC_FLOOR,AcousticModel.PROP_MC_FLOOR_DEFAULT);
  float mixtureWeightFloor=props.getFloat(AcousticModel.PROP_MW_FLOOR,AcousticModel.PROP_MW_FLOOR_DEFAULT);
  float transitionProbabilityFloor=props.getFloat(AcousticModel.PROP_TP_FLOOR,AcousticModel.PROP_TP_FLOOR_DEFAULT);
  float varianceFloor=props.getFloat(AcousticModel.PROP_VARIANCE_FLOOR,AcousticModel.PROP_VARIANCE_FLOOR_DEFAULT);
  logger.info(""String_Node_Str"");
  logger.info(path);
  version=""String_Node_Str"";
  est.expectString(""String_Node_Str"");
  est.expectString(version);
  est.expectString(""String_Node_Str"");
  sameSizedModels=est.getString().equals(""String_Node_Str"");
  if (sameSizedModels) {
    est.expectString(""String_Node_Str"");
    numState=est.getInt(""String_Node_Str"");
  }
  est.expectString(""String_Node_Str"");
  tmatSkip=est.getString().equals(""String_Node_Str"");
  int stateIndex;
  int unitCount;
  String attribute;
  for (stateIndex=0, unitCount=0; ; ) {
    String phone=est.getString();
    if (est.isEOF()) {
      break;
    }
    int size=numState;
    if (!sameSizedModels) {
      size=est.getInt(""String_Node_Str"");
    }
    phoneList.put(phone,new Integer(size));
    logger.fine(""String_Node_Str"" + phone + ""String_Node_Str""+ size);
    int[] stid=new int[size];
    String position=""String_Node_Str"";
    for (int j=0; j < size; j++, stateIndex++) {
      stid[j]=stateIndex;
    }
    if (phone.equals(SILENCE_CIPHONE)) {
      attribute=FILLER;
    }
 else {
      attribute=""String_Node_Str"";
    }
    Unit unit=Unit.getUnit(phone,attribute.equals(FILLER));
    contextIndependentUnits.put(unit.getName(),unit);
    if (logger.isLoggable(Level.FINE)) {
      logger.fine(""String_Node_Str"" + unit + ""String_Node_Str""+ size+ ""String_Node_Str"");
    }
    if (unit.isFiller() && unit.getName().equals(SILENCE_CIPHONE)) {
      unit=Unit.SILENCE;
    }
    addModelToDensityPool(meansPool,stid,numStreams,numGaussiansPerState);
    addModelToDensityPool(variancePool,stid,numStreams,numGaussiansPerState);
    addModelToMixtureWeightPool(mixtureWeightsPool,stid,numStreams,numGaussiansPerState,mixtureWeightFloor);
    addModelToTransitionMatricesPool(matrixPool,unitCount,stid.length,transitionProbabilityFloor,tmatSkip);
    addModelToSenonePool(senonePool,stid,distFloor);
    float[][] transitionMatrix=(float[][])matrixPool.get(unitCount);
    SenoneSequence ss=getSenoneSequence(stid);
    HMM hmm=new HMM(unit,ss,transitionMatrix,HMMPosition.lookup(position));
    hmmManager.put(hmm);
    unitCount++;
  }
  est.close();
}","/** 
 * Loads the phone list, which possibly contains the sizes (number of states) of models.
 * @param useCDUnits if true, uses context dependent units
 * @param inputStream the open input stream to use
 * @param path the path to a density file
 * @param props the properties for this set of HMMs
 * @throws FileNotFoundException if a file cannot be found
 * @throws IOException if an error occurs while loading the data
 */
private void loadPhoneList(boolean useCDUnits,InputStream inputStream,String path,SphinxProperties props) throws FileNotFoundException, IOException {
  int token_type;
  int numState=0;
  int numStatePerHMM;
  int numContextIndependentTiedState;
  int numStreams=1;
  int numGaussiansPerState=1;
  String version;
  boolean sameSizedModels;
  boolean tmatSkip;
  ExtendedStreamTokenizer est=new ExtendedStreamTokenizer(inputStream,'#',false);
  meansPool=new Pool(""String_Node_Str"");
  variancePool=new Pool(""String_Node_Str"");
  mixtureWeightsPool=new Pool(""String_Node_Str"");
  matrixPool=new Pool(""String_Node_Str"");
  senonePool=new Pool(""String_Node_Str"");
  float distFloor=props.getFloat(AcousticModel.PROP_MC_FLOOR,AcousticModel.PROP_MC_FLOOR_DEFAULT);
  float mixtureWeightFloor=props.getFloat(AcousticModel.PROP_MW_FLOOR,AcousticModel.PROP_MW_FLOOR_DEFAULT);
  float transitionProbabilityFloor=props.getFloat(AcousticModel.PROP_TP_FLOOR,AcousticModel.PROP_TP_FLOOR_DEFAULT);
  float varianceFloor=props.getFloat(AcousticModel.PROP_VARIANCE_FLOOR,AcousticModel.PROP_VARIANCE_FLOOR_DEFAULT);
  logger.info(""String_Node_Str"");
  logger.info(path);
  version=""String_Node_Str"";
  est.expectString(""String_Node_Str"");
  est.expectString(version);
  est.expectString(""String_Node_Str"");
  sameSizedModels=est.getString().equals(""String_Node_Str"");
  if (sameSizedModels) {
    est.expectString(""String_Node_Str"");
    numState=est.getInt(""String_Node_Str"");
  }
  est.expectString(""String_Node_Str"");
  tmatSkip=est.getString().equals(""String_Node_Str"");
  int stateIndex;
  int unitCount;
  String attribute;
  for (stateIndex=0, unitCount=0; ; ) {
    String phone=est.getString();
    if (est.isEOF()) {
      break;
    }
    int size=numState;
    if (!sameSizedModels) {
      size=est.getInt(""String_Node_Str"");
    }
    phoneList.put(phone,new Integer(size));
    logger.fine(""String_Node_Str"" + phone + ""String_Node_Str""+ size);
    int[] stid=new int[size];
    String position=""String_Node_Str"";
    for (int j=0; j < size; j++, stateIndex++) {
      stid[j]=stateIndex;
    }
    if (phone.equals(SILENCE_CIPHONE)) {
      attribute=FILLER;
    }
 else {
      attribute=""String_Node_Str"";
    }
    Unit unit=Unit.createCIUnit(phone,attribute.equals(FILLER));
    contextIndependentUnits.put(unit.getName(),unit);
    if (logger.isLoggable(Level.FINE)) {
      logger.fine(""String_Node_Str"" + unit + ""String_Node_Str""+ size+ ""String_Node_Str"");
    }
    if (unit.isFiller() && unit.getName().equals(SILENCE_CIPHONE)) {
      unit=Unit.SILENCE;
    }
    addModelToDensityPool(meansPool,stid,numStreams,numGaussiansPerState);
    addModelToDensityPool(variancePool,stid,numStreams,numGaussiansPerState);
    addModelToMixtureWeightPool(mixtureWeightsPool,stid,numStreams,numGaussiansPerState,mixtureWeightFloor);
    addModelToTransitionMatricesPool(matrixPool,unitCount,stid.length,transitionProbabilityFloor,tmatSkip);
    addModelToSenonePool(senonePool,stid,distFloor,varianceFloor);
    float[][] transitionMatrix=(float[][])matrixPool.get(unitCount);
    SenoneSequence ss=getSenoneSequence(stid);
    HMM hmm=new HMM(unit,ss,transitionMatrix,HMMPosition.lookup(position));
    hmmManager.put(hmm);
    unitCount++;
  }
  est.close();
}",0.9966000271997824
19929,"/** 
 * Adds transition matrix to the transition matrices pool
 * @param pool the pool to add matrix to
 * @param stid current HMM's id
 * @param numStates number of states in current HMM
 * @param floor the transition probability floor
 * @param skip if true, states can be skipped
 * @throws IOException if an error occurs while loading the data
 */
private void addModelToTransitionMatricesPool(Pool pool,int stid,int numStates,float floor,boolean skip) throws IOException {
}","/** 
 * Adds transition matrix to the transition matrices pool
 * @param pool the pool to add matrix to
 * @param hmmId current HMM's id
 * @param numStates number of states in current HMM
 * @param floor the transition probability floor
 * @param skip if true, states can be skipped
 * @throws IOException if an error occurs while loading the data
 */
private void addModelToTransitionMatricesPool(Pool pool,int hmmId,int numEmittingStates,float floor,boolean skip) throws IOException {
}",0.9772727272727272
19930,"/** 
 * Adds a model to the senone pool.
 * @param pool the senone pool
 * @param stateID vector with senone ID for an HMM
 * @param distFloor the lowest allowed score 
 * @return the senone pool
 */
private void addModelToSenonePool(Pool pool,int[] stateID,float distFloor){
}","/** 
 * Adds a model to the senone pool.
 * @param pool the senone pool
 * @param stateID vector with senone ID for an HMM
 * @param distFloor the lowest allowed score 
 * @param varianceFloor the lowest allowed variance
 * @return the senone pool
 */
private void addModelToSenonePool(Pool pool,int[] stateID,float distFloor,float varianceFloor){
}",0.8849840255591054
19931,"/** 
 * Update the models.
 */
protected void update(){
  updateMeans();
  updateVariances();
  updateMixtureWeights();
  updateTransitionMatrices();
}","/** 
 * Update the models.
 */
protected void update(){
  updateMeans();
  updateVariances();
  recomputeMixtureComponents();
  updateMixtureWeights();
  updateTransitionMatrices();
}",0.9041916167664672
19932,"/** 
 * Accumulate the transition probabilities.
 */
private void accumulateTransition(int indexHmm,TrainerScore score,TrainerScore[] nextScore){
  if (indexHmm == TrainerAcousticModel.ALL_MODELS) {
    for (Iterator i=hmmManager.getIterator(); i.hasNext(); ) {
      HMM hmm=(HMM)i.next();
      for (int j=0; j < hmm.getOrder(); j++) {
        accumulateStateTransition(j,hmm,score.getScore());
      }
    }
  }
 else {
    HMMState state=score.getState();
    accumulateStateTransition(state.getState(),score,nextScore);
  }
}","/** 
 * Accumulate the transition probabilities.
 */
private void accumulateTransition(int indexHmm,int indexScore,TrainerScore[] score,TrainerScore[] nextScore){
  if (indexHmm == TrainerAcousticModel.ALL_MODELS) {
    for (Iterator i=hmmManager.getIterator(); i.hasNext(); ) {
      HMM hmm=(HMM)i.next();
      for (int j=0; j < hmm.getOrder(); j++) {
        accumulateStateTransition(j,hmm,score[indexScore].getScore());
      }
    }
  }
 else {
    if (nextScore != null) {
      accumulateStateTransition(indexScore,score,nextScore);
    }
  }
}",0.8550323176361958
19933,"/** 
 * Accumulate the TrainerScore into the buffers.
 * @param score the TrainerScore
 * @param nextScore the TrainerScore for the next time frame
 */
protected void accumulate(TrainerScore score,TrainerScore[] nextScore){
  int senoneID;
  HMMState state=score.getState();
  if (state == null) {
    senoneID=score.getSenoneID();
  }
 else {
    senoneID=senonePool.indexOf(state.getSenone());
  }
  Feature feature=score.getFeature();
  currentLogLikelihood=score.getLogLikelihood();
  float prob=score.getScore();
  accumulateMean(senoneID,score);
  accumulateVariance(senoneID,score);
  accumulateMixture(senoneID,score);
  accumulateTransition(senoneID,score,nextScore);
}","/** 
 * Accumulate the TrainerScore into the buffers.
 * @param index the current index into the TrainerScore vector
 * @param score the TrainerScore for the current frame
 * @param nextScore the TrainerScore for the next time frame
 */
protected void accumulate(int index,TrainerScore[] score,TrainerScore[] nextScore){
  int senoneID;
  TrainerScore thisScore=score[index];
  Feature feature=thisScore.getFeature();
  currentLogLikelihood=thisScore.getLogLikelihood();
  HMMState state=thisScore.getState();
  if (state == null) {
    senoneID=thisScore.getSenoneID();
    if (senoneID == TrainerAcousticModel.ALL_MODELS) {
      accumulateMean(senoneID,score[index]);
      accumulateVariance(senoneID,score[index]);
      accumulateMixture(senoneID,score[index]);
      accumulateTransition(senoneID,index,score,nextScore);
    }
  }
 else {
    if (state.isEmitting()) {
      senoneID=senonePool.indexOf(state.getSenone());
      accumulateMean(senoneID,score[index]);
      accumulateVariance(senoneID,score[index]);
      accumulateMixture(senoneID,score[index]);
      accumulateTransition(senoneID,index,score,nextScore);
    }
  }
}",0.415156507413509
19934,"/** 
 * Constructor for this pool manager. It gets the pointers to the pools from a loader.
 * @param loader the loader
 */
protected HMMPoolManager(Loader loader,SphinxProperties props){
  hmmManager=loader.getHMMManager();
  meansPool=loader.getMeansPool();
  variancePool=loader.getVariancePool();
  mixtureWeightsPool=loader.getMixtureWeightPool();
  matrixPool=loader.getTransitionMatrixPool();
  senonePool=loader.getSenonePool();
  logMath=LogMath.getLogMath(props.getContext());
  float mixtureWeightFloor=props.getFloat(AcousticModel.PROP_MW_FLOOR,AcousticModel.PROP_MW_FLOOR_DEFAULT);
  logMixtureWeightFloor=logMath.linearToLog(mixtureWeightFloor);
  float transitionProbabilityFloor=props.getFloat(AcousticModel.PROP_TP_FLOOR,AcousticModel.PROP_TP_FLOOR_DEFAULT);
  logTransitionProbabilityFloor=logMath.linearToLog(transitionProbabilityFloor);
  varianceFloor=props.getFloat(AcousticModel.PROP_VARIANCE_FLOOR,AcousticModel.PROP_VARIANCE_FLOOR_DEFAULT);
  createBuffers();
  logLikelihood=LogMath.getLogZero();
}","/** 
 * Constructor for this pool manager. It gets the pointers to the pools from a loader.
 * @param loader the loader
 */
protected HMMPoolManager(Loader loader,SphinxProperties props){
  hmmManager=loader.getHMMManager();
  meansPool=loader.getMeansPool();
  variancePool=loader.getVariancePool();
  mixtureWeightsPool=loader.getMixtureWeightPool();
  matrixPool=loader.getTransitionMatrixPool();
  senonePool=loader.getSenonePool();
  logMath=LogMath.getLogMath(props.getContext());
  float mixtureWeightFloor=props.getFloat(AcousticModel.PROP_MW_FLOOR,AcousticModel.PROP_MW_FLOOR_DEFAULT);
  logMixtureWeightFloor=logMath.linearToLog(mixtureWeightFloor);
  float transitionProbabilityFloor=props.getFloat(AcousticModel.PROP_TP_FLOOR,AcousticModel.PROP_TP_FLOOR_DEFAULT);
  logTransitionProbabilityFloor=logMath.linearToLog(transitionProbabilityFloor);
  varianceFloor=props.getFloat(AcousticModel.PROP_VARIANCE_FLOOR,AcousticModel.PROP_VARIANCE_FLOOR_DEFAULT);
  createBuffers();
  logLikelihood=0.0f;
}",0.9881889763779528
19935,"/** 
 * Construct a FullDictionaryTest with the given SphinxProperties file.
 * @param propertiesFile a SphinxProperties file
 */
public LMGramTest(String propertiesFile) throws Exception {
  LanguageModel languageModel;
  edu.cmu.sphinx.decoder.linguist.Grammar grammar;
  String pwd=System.getProperty(""String_Node_Str"");
  SphinxProperties.initContext(context,new URL(""String_Node_Str"" + pwd + File.separatorChar+ propertiesFile));
  SphinxProperties props=SphinxProperties.getSphinxProperties(context);
  Timer lmTimer=Timer.getTimer(""String_Node_Str"",""String_Node_Str"");
  Timer gramTimer=Timer.getTimer(""String_Node_Str"",""String_Node_Str"");
  lmTimer.start();
  languageModel=LanguageModelFactory.createLanguageModel(context);
  lmTimer.stop();
  Utilities.dumpMemoryInfo(""String_Node_Str"");
  gramTimer.start();
  grammar=new edu.cmu.sphinx.decoder.linguist.LMGrammar();
  grammar.initialize(props.getContext(),languageModel,null);
  gramTimer.stop();
  Utilities.dumpMemoryInfo(""String_Node_Str"");
  Timer.dumpAll();
  grammar.dumpStatistics();
}","/** 
 * Construct a FullDictionaryTest with the given SphinxProperties file.
 * @param propertiesFile a SphinxProperties file
 */
public LMGramTest(String propertiesFile) throws Exception {
  LanguageModel languageModel;
  edu.cmu.sphinx.decoder.linguist.Grammar grammar;
  String pwd=System.getProperty(""String_Node_Str"");
  SphinxProperties.initContext(context,new URL(""String_Node_Str"" + pwd + File.separatorChar+ propertiesFile));
  SphinxProperties props=SphinxProperties.getSphinxProperties(context);
  Timer lmTimer=Timer.getTimer(""String_Node_Str"",""String_Node_Str"");
  Timer gramTimer=Timer.getTimer(""String_Node_Str"",""String_Node_Str"");
  Dictionary dictionary=new FullDictionary(context);
  lmTimer.start();
  languageModel=LanguageModelFactory.createLanguageModel(context,dictionary);
  lmTimer.stop();
  Utilities.dumpMemoryInfo(""String_Node_Str"");
  gramTimer.start();
  grammar=new edu.cmu.sphinx.decoder.linguist.LMGrammar();
  grammar.initialize(props.getContext(),languageModel,null);
  gramTimer.stop();
  Utilities.dumpMemoryInfo(""String_Node_Str"");
  Timer.dumpAll();
  grammar.dumpStatistics();
}",0.9705340699815838
19936,"/** 
 * Creates a new buffer
 * @param size the number of elements in this buffer
 */
Buffer(int size){
  numerator=new float[size];
}","/** 
 * Creates a new buffer. If the values will be in log, the buffer is initialized to all <code>LogMath.getLogZero()</code>.
 * @param size the number of elements in this buffer
 * @param isLog if true, the values in the buffer will be in log
 */
Buffer(int size,boolean isLog){
  this.isLog=isLog;
  numerator=new float[size];
  if (isLog) {
    denominator=LogMath.getLogZero();
    for (int i=0; i < size; i++) {
      numerator[i]=LogMath.getLogZero();
    }
  }
}",0.4132231404958678
19937,"/** 
 * Normalize the buffer in log scale. The normalization is done so that the summation of elements in the buffer is log(1) = 0. In this, we assume that if an element has a value of zero, it won't be updated.
 * @param logMath the logMath to use
 */
void logNormalizeToSum(LogMath logMath){
  float logZero=logMath.getLogZero();
  float den=logZero;
  for (int i=0; i < numerator.length; i++) {
    if (numerator[i] != logZero) {
      den=logMath.addAsLinear(den,numerator[i]);
    }
  }
  for (int i=0; i < numerator.length; i++) {
    if (numerator[i] != logZero) {
      numerator[i]-=den;
    }
  }
  denominator=0.0f;
}","/** 
 * Normalize the buffer in log scale. The normalization is done so that the summation of elements in the buffer is log(1) = 0. In this, we assume that if an element has a value of zero, it won't be updated.
 * @param logMath the logMath to use
 */
void logNormalizeToSum(LogMath logMath){
  assert isLog;
  float logZero=logMath.getLogZero();
  float den=logZero;
  for (int i=0; i < numerator.length; i++) {
    if (numerator[i] != logZero) {
      den=logMath.addAsLinear(den,numerator[i]);
    }
  }
  for (int i=0; i < numerator.length; i++) {
    if (numerator[i] != logZero) {
      numerator[i]-=den;
    }
  }
  denominator=0.0f;
}",0.9874213836477987
19938,"/** 
 * Normalize the buffer. This method divides the numerator by the denominator, storing the result in the numerator, and setting denominator to 1.
 */
void normalize(){
  float invDenominator=1.0f / denominator;
  for (int i=0; i < numerator.length; i++) {
    numerator[i]*=invDenominator;
  }
  denominator=1.0f;
}","/** 
 * Normalize the buffer. This method divides the numerator by the denominator, storing the result in the numerator, and setting denominator to 1.
 */
void normalize(){
}",0.7044534412955465
19939,"/** 
 * Normalize the buffer. The normalization is done so that the summation of elements in the buffer is 1.
 */
void normalizeToSum(){
  float den=0.0f;
  for (int i=0; i < numerator.length; i++) {
    den+=numerator[i];
  }
  float invDenominator=1.0f / den;
  for (int i=0; i < numerator.length; i++) {
    numerator[i]*=invDenominator;
  }
  denominator=1.0f;
}","/** 
 * Normalize the buffer. The normalization is done so that the summation of elements in the buffer is 1.
 */
void normalizeToSum(){
}",0.5476190476190477
19940,"/** 
 * Floor the buffer in log scale.
 * @param logFloor the floor for this buffer, in log scale
 * @return if true, the buffer was modified
 */
protected boolean logFloor(float logFloor){
  boolean wasModified=false;
  for (int i=0; i < numerator.length; i++) {
    if (numerator[i] < logFloor) {
      wasModified=true;
      numerator[i]=logFloor;
    }
  }
  return wasModified;
}","/** 
 * Floor the buffer in log scale.
 * @param logFloor the floor for this buffer, in log scale
 * @return if true, the buffer was modified
 */
protected boolean logFloor(float logFloor){
  assert isLog;
  boolean wasModified=false;
  for (int i=0; i < numerator.length; i++) {
    if (numerator[i] < logFloor) {
      wasModified=true;
      numerator[i]=logFloor;
    }
  }
  return wasModified;
}",0.979643765903308
19941,"/** 
 * Floor the buffer.
 * @param floor the floor for this buffer
 * @return if true, the buffer was modified
 */
protected boolean floor(float floor){
  boolean wasModified=false;
  for (int i=0; i < numerator.length; i++) {
    if (numerator[i] < floor) {
      wasModified=true;
      numerator[i]=floor;
    }
  }
  return wasModified;
}","/** 
 * Floor the buffer.
 * @param floor the floor for this buffer
 * @return if true, the buffer was modified
 */
protected boolean floor(float floor){
}",0.6224899598393574
19942,"/** 
 * Normalize the buffer in log scale. This method divides the numerator by the denominator, storing the result in the numerator, and setting denominator to log(1) = 0.
 */
void logNormalize(){
  for (int i=0; i < numerator.length; i++) {
    numerator[i]-=denominator;
  }
  denominator=0.0f;
}","/** 
 * Normalize the buffer in log scale. This method divides the numerator by the denominator, storing the result in the numerator, and setting denominator to log(1) = 0.
 */
void logNormalize(){
  assert isLog;
  for (int i=0; i < numerator.length; i++) {
    numerator[i]-=denominator;
  }
  denominator=0.0f;
}",0.973941368078176
19943,"/** 
 * Gets the map associated with the given position. Creates the map as necessary.
 * @param position the position of interest
 * @return the map of HMMs for the given position.
 */
private Map getHMMMap(HMMPosition pos){
  Map hmmMap=(Map)hmmsPerPosition[pos.getIndex()];
  if (hmmMap == null) {
    hmmMap=new LinkedHashMap();
    hmmsPerPosition[pos.getIndex()]=hmmMap;
  }
  return hmmMap;
}","/** 
 * Gets the map associated with the given position. Creates the map as necessary.
 * @param pos the position of interest
 * @return the map of HMMs for the given position.
 */
private Map getHMMMap(HMMPosition pos){
  Map hmmMap=(Map)hmmsPerPosition[pos.getIndex()];
  if (hmmMap == null) {
    hmmMap=new LinkedHashMap();
    hmmsPerPosition[pos.getIndex()]=hmmMap;
  }
  return hmmMap;
}",0.9936948297604036
19944,"/** 
 * Create buffers for all pools used by the trainer in this pool manager.
 */
protected void createBuffers(){
  meansBufferPool=create1DPoolBuffer(meansPool);
  varianceBufferPool=create1DPoolBuffer(variancePool);
  matrixBufferPool=create2DPoolBuffer(matrixPool);
  mixtureWeightsBufferPool=create1DPoolBuffer(mixtureWeightsPool);
}","/** 
 * Create buffers for all pools used by the trainer in this pool manager.
 */
protected void createBuffers(){
  meansBufferPool=create1DPoolBuffer(meansPool,false);
  varianceBufferPool=create1DPoolBuffer(variancePool,false);
  matrixBufferPool=create2DPoolBuffer(matrixPool,true);
  mixtureWeightsBufferPool=create1DPoolBuffer(mixtureWeightsPool,true);
}",0.968481375358166
19945,"/** 
 * Create buffers for a given pool.
 */
private Pool create2DPoolBuffer(Pool pool){
  Pool bufferPool=new Pool(pool.getName());
  for (int i=0; i < pool.size(); i++) {
    float[][] element=(float[][])pool.get(i);
    int poolSize=element.length;
    Buffer[] bufferArray=new Buffer[poolSize];
    for (int j=0; j < poolSize; j++) {
      bufferArray[j]=new Buffer(element[j].length);
    }
    bufferPool.put(i,bufferArray);
  }
  return bufferPool;
}","/** 
 * Create buffers for a given pool.
 */
private Pool create2DPoolBuffer(Pool pool,boolean isLog){
  Pool bufferPool=new Pool(pool.getName());
  for (int i=0; i < pool.size(); i++) {
    float[][] element=(float[][])pool.get(i);
    int poolSize=element.length;
    Buffer[] bufferArray=new Buffer[poolSize];
    for (int j=0; j < poolSize; j++) {
      bufferArray[j]=new Buffer(element[j].length,isLog);
    }
    bufferPool.put(i,bufferArray);
  }
  return bufferPool;
}",0.9785867237687366
19946,"/** 
 * Create buffers for a given pool.
 */
private Pool create1DPoolBuffer(Pool pool){
  Pool bufferPool=new Pool(pool.getName());
  for (int i=0; i < pool.size(); i++) {
    float[] element=(float[])pool.get(i);
    Buffer buffer=new Buffer(element.length);
    bufferPool.put(i,buffer);
  }
  return bufferPool;
}","/** 
 * Create buffers for a given pool.
 */
private Pool create1DPoolBuffer(Pool pool,boolean isLog){
  Pool bufferPool=new Pool(pool.getName());
  for (int i=0; i < pool.size(); i++) {
    float[] element=(float[])pool.get(i);
    Buffer buffer=new Buffer(element.length,isLog);
    bufferPool.put(i,buffer);
  }
  return bufferPool;
}",0.8990825688073395
19947,"/** 
 * Normalize the given data
 * @param data the data to normalize
 */
private void normalize(float[] data){
  float sum=0;
  for (int i=0; i < data.length; i++) {
    sum+=data[i];
  }
  if (sum != 0.0f) {
    for (int i=0; i < data.length; i++) {
      data[i]=data[i] / sum;
    }
  }
}","/** 
 * Normalize the given data
 * @param data the data to normalize
 */
private void normalize(float[] data){
  float sum=0;
  for (int i=0; i < data.length; i++) {
    sum+=data[i];
  }
  if (sum != 0.0f) {
    sum=1.0f / sum;
    for (int i=0; i < data.length; i++) {
      data[i]=data[i] * sum;
    }
  }
}",0.9635761589403974
19948,"/** 
 * Loads the phone list, which possibly contains the sizes (number of states) of models.
 * @param path the path to a density file
 * @param name the name of the data
 * @param props the properties for this set of HMMs
 * @throws FileNotFoundException if a file cannot be found
 * @throws IOException if an error occurs while loading the data
 */
private void loadPhoneList(boolean useCDUnits,InputStream inputStream,String path,SphinxProperties props) throws FileNotFoundException, IOException {
  int token_type;
  int numState=0;
  int numStatePerHMM;
  int numContextIndependentTiedState;
  int numStreams=1;
  int numGaussiansPerState=1;
  String version;
  boolean sameSizedModels;
  boolean tmatSkip;
  ExtendedStreamTokenizer est=new ExtendedStreamTokenizer(inputStream,'#',false);
  meansPool=new Pool(""String_Node_Str"");
  variancePool=new Pool(""String_Node_Str"");
  mixtureWeightsPool=new Pool(""String_Node_Str"");
  matrixPool=new Pool(""String_Node_Str"");
  senonePool=new Pool(""String_Node_Str"");
  float distFloor=props.getFloat(AcousticModel.PROP_MC_FLOOR,AcousticModel.PROP_MC_FLOOR_DEFAULT);
  float mixtureWeightFloor=props.getFloat(AcousticModel.PROP_MW_FLOOR,AcousticModel.PROP_MW_FLOOR_DEFAULT);
  float transitionProbabilityFloor=props.getFloat(AcousticModel.PROP_TP_FLOOR,AcousticModel.PROP_TP_FLOOR_DEFAULT);
  float varianceFloor=props.getFloat(AcousticModel.PROP_VARIANCE_FLOOR,AcousticModel.PROP_VARIANCE_FLOOR_DEFAULT);
  logger.info(""String_Node_Str"");
  logger.info(path);
  version=""String_Node_Str"";
  est.expectString(""String_Node_Str"");
  est.expectString(version);
  est.expectString(""String_Node_Str"");
  sameSizedModels=est.getString().equals(""String_Node_Str"");
  if (sameSizedModels) {
    est.expectString(""String_Node_Str"");
    numState=est.getInt(""String_Node_Str"");
  }
  est.expectString(""String_Node_Str"");
  tmatSkip=est.getString().equals(""String_Node_Str"");
  int stateIndex;
  int unitCount;
  String attribute;
  for (stateIndex=0, unitCount=0; ; ) {
    String phone=est.getString();
    if (est.isEOF()) {
      break;
    }
    int size=numState;
    if (!sameSizedModels) {
      size=est.getInt(""String_Node_Str"");
    }
    phoneList.put(phone,new Integer(size));
    logger.fine(""String_Node_Str"" + phone + ""String_Node_Str""+ size);
    int[] stid=new int[size];
    String position=""String_Node_Str"";
    for (int j=0; j < size; j++, stateIndex++) {
      stid[j]=stateIndex;
    }
    if (phone.equals(SILENCE_CIPHONE)) {
      attribute=FILLER;
    }
 else {
      attribute=""String_Node_Str"";
    }
    Unit unit=new Unit(phone,attribute.equals(FILLER));
    contextIndependentUnits.put(unit.getName(),unit);
    if (logger.isLoggable(Level.FINE)) {
      logger.fine(""String_Node_Str"" + unit + ""String_Node_Str""+ size+ ""String_Node_Str"");
    }
    if (unit.isFiller() && unit.getName().equals(SILENCE_CIPHONE)) {
      unit=Unit.SILENCE;
    }
    addModelToDensityPool(meansPool,stid,numStreams,numGaussiansPerState);
    addModelToDensityPool(variancePool,stid,numStreams,numGaussiansPerState);
    addModelToMixtureWeightPool(mixtureWeightsPool,stid,numStreams,numGaussiansPerState,mixtureWeightFloor);
    addModelToTransitionMatricesPool(matrixPool,unitCount,stid.length,transitionProbabilityFloor,tmatSkip);
    addModelToSenonePool(senonePool,stid,distFloor);
    float[][] transitionMatrix=(float[][])matrixPool.get(unitCount);
    SenoneSequence ss=getSenoneSequence(stid);
    HMM hmm=new HMM(unit,ss,transitionMatrix,HMMPosition.lookup(position));
    hmmManager.put(hmm);
    unitCount++;
  }
  est.close();
}","/** 
 * Loads the phone list, which possibly contains the sizes (number of states) of models.
 * @param useCDUnits if true, uses context dependent units
 * @param inputStream the open input stream to use
 * @param path the path to a density file
 * @param props the properties for this set of HMMs
 * @throws FileNotFoundException if a file cannot be found
 * @throws IOException if an error occurs while loading the data
 */
private void loadPhoneList(boolean useCDUnits,InputStream inputStream,String path,SphinxProperties props) throws FileNotFoundException, IOException {
  int token_type;
  int numState=0;
  int numStatePerHMM;
  int numContextIndependentTiedState;
  int numStreams=1;
  int numGaussiansPerState=1;
  String version;
  boolean sameSizedModels;
  boolean tmatSkip;
  ExtendedStreamTokenizer est=new ExtendedStreamTokenizer(inputStream,'#',false);
  meansPool=new Pool(""String_Node_Str"");
  variancePool=new Pool(""String_Node_Str"");
  mixtureWeightsPool=new Pool(""String_Node_Str"");
  matrixPool=new Pool(""String_Node_Str"");
  senonePool=new Pool(""String_Node_Str"");
  float distFloor=props.getFloat(AcousticModel.PROP_MC_FLOOR,AcousticModel.PROP_MC_FLOOR_DEFAULT);
  float mixtureWeightFloor=props.getFloat(AcousticModel.PROP_MW_FLOOR,AcousticModel.PROP_MW_FLOOR_DEFAULT);
  float transitionProbabilityFloor=props.getFloat(AcousticModel.PROP_TP_FLOOR,AcousticModel.PROP_TP_FLOOR_DEFAULT);
  float varianceFloor=props.getFloat(AcousticModel.PROP_VARIANCE_FLOOR,AcousticModel.PROP_VARIANCE_FLOOR_DEFAULT);
  logger.info(""String_Node_Str"");
  logger.info(path);
  version=""String_Node_Str"";
  est.expectString(""String_Node_Str"");
  est.expectString(version);
  est.expectString(""String_Node_Str"");
  sameSizedModels=est.getString().equals(""String_Node_Str"");
  if (sameSizedModels) {
    est.expectString(""String_Node_Str"");
    numState=est.getInt(""String_Node_Str"");
  }
  est.expectString(""String_Node_Str"");
  tmatSkip=est.getString().equals(""String_Node_Str"");
  int stateIndex;
  int unitCount;
  String attribute;
  for (stateIndex=0, unitCount=0; ; ) {
    String phone=est.getString();
    if (est.isEOF()) {
      break;
    }
    int size=numState;
    if (!sameSizedModels) {
      size=est.getInt(""String_Node_Str"");
    }
    phoneList.put(phone,new Integer(size));
    logger.fine(""String_Node_Str"" + phone + ""String_Node_Str""+ size);
    int[] stid=new int[size];
    String position=""String_Node_Str"";
    for (int j=0; j < size; j++, stateIndex++) {
      stid[j]=stateIndex;
    }
    if (phone.equals(SILENCE_CIPHONE)) {
      attribute=FILLER;
    }
 else {
      attribute=""String_Node_Str"";
    }
    Unit unit=new Unit(phone,attribute.equals(FILLER));
    contextIndependentUnits.put(unit.getName(),unit);
    if (logger.isLoggable(Level.FINE)) {
      logger.fine(""String_Node_Str"" + unit + ""String_Node_Str""+ size+ ""String_Node_Str"");
    }
    if (unit.isFiller() && unit.getName().equals(SILENCE_CIPHONE)) {
      unit=Unit.SILENCE;
    }
    addModelToDensityPool(meansPool,stid,numStreams,numGaussiansPerState);
    addModelToDensityPool(variancePool,stid,numStreams,numGaussiansPerState);
    addModelToMixtureWeightPool(mixtureWeightsPool,stid,numStreams,numGaussiansPerState,mixtureWeightFloor);
    addModelToTransitionMatricesPool(matrixPool,unitCount,stid.length,transitionProbabilityFloor,tmatSkip);
    addModelToSenonePool(senonePool,stid,distFloor);
    float[][] transitionMatrix=(float[][])matrixPool.get(unitCount);
    SenoneSequence ss=getSenoneSequence(stid);
    HMM hmm=new HMM(unit,ss,transitionMatrix,HMMPosition.lookup(position));
    hmmManager.put(hmm);
    unitCount++;
  }
  est.close();
}",0.9779371207942636
19949,"/** 
 * Loads the Sphinx 3 acoustic model properties file, which is basically a normal system properties file.
 * @param props the SphinxProperties object 
 * @param path the path to the acoustic properties file
 * @return a SphinxProperty object containing the acoustic properties,or null if there are no acoustic model properties
 * @throws FileNotFoundException if the file cannot be found
 * @throws IOException if an error occurs while loading the data
 */
private SphinxProperties loadAcousticPropertiesFile(String context,String url) throws FileNotFoundException, IOException {
  SphinxProperties.initContext(context,new URL(url));
  return (SphinxProperties.getSphinxProperties(context));
}","/** 
 * Loads the Sphinx 3 acoustic model properties file, which is basically a normal system properties file.
 * @param context this models' context
 * @param url the path to the acoustic properties file
 * @return a SphinxProperty object containing the acoustic properties,or null if there are no acoustic model properties
 * @throws FileNotFoundException if the file cannot be found
 * @throws IOException if an error occurs while loading the data
 */
private SphinxProperties loadAcousticPropertiesFile(String context,String url) throws FileNotFoundException, IOException {
  SphinxProperties.initContext(context,new URL(url));
  return (SphinxProperties.getSphinxProperties(context));
}",0.9503239740820736
19950,"/** 
 * Adds model to the mixture weights
 * @param pool the pool to add models to
 * @param stateID vector containing state ids for hmm
 * @param stream the number of streams
 * @param numGaussiansPerState the number of Gaussians per state
 * @param floor the minimum mixture weight allowed
 * @throws IOException if an error occurs while loading the data
 */
private void addModelToMixtureWeightPool(Pool pool,int[] stateID,int numStreams,int numGaussiansPerState,float floor) throws IOException {
}","/** 
 * Adds model to the mixture weights
 * @param pool the pool to add models to
 * @param stateID vector containing state ids for hmm
 * @param numStreams the number of streams
 * @param numGaussiansPerState the number of Gaussians per state
 * @param floor the minimum mixture weight allowed
 * @throws IOException if an error occurs while loading the data
 */
private void addModelToMixtureWeightPool(Pool pool,int[] stateID,int numStreams,int numGaussiansPerState,float floor) throws IOException {
}",0.9840954274353876
19951,"/** 
 * Loads the sphinx3 densityfile, a set of density arrays are created and placed in the given pool.
 * @param path the path to a density file
 * @param name the name of the data
 * @return a pool of loaded densities
 * @throws FileNotFoundException if a file cannot be found
 * @throws IOException if an error occurs while loading the data
 */
private Pool loadHMMPool(boolean useCDUnits,InputStream inputStream,String path) throws FileNotFoundException, IOException {
}","/** 
 * Loads the sphinx3 densityfile, a set of density arrays are created and placed in the given pool.
 * @param useCDUnits if true, loads also the context dependent units
 * @param inputStream the open input stream to use
 * @param path the path to a density file
 * @return a pool of loaded densities
 * @throws FileNotFoundException if a file cannot be found
 * @throws IOException if an error occurs while loading the data
 */
private Pool loadHMMPool(boolean useCDUnits,InputStream inputStream,String path) throws FileNotFoundException, IOException {
}",0.8491295938104448
19952,"/** 
 * Loads the Sphinx 3 acoustic model properties file, which is basically a normal system properties file.
 * @param props the SphinxProperties object 
 * @param path the path to the acoustic properties file
 * @return a SphinxProperty object containing the acoustic properties,or null if there are no acoustic model properties
 * @throws FileNotFoundException if the file cannot be found
 * @throws IOException if an error occurs while loading the data
 */
private SphinxProperties loadAcousticPropertiesFile(String context,String url) throws FileNotFoundException, IOException {
  SphinxProperties.initContext(context,new URL(url));
  return (SphinxProperties.getSphinxProperties(context));
}","/** 
 * Loads the Sphinx 3 acoustic model properties file, which is basically a normal system properties file.
 * @param context this models' context
 * @param url the path to the acoustic properties file
 * @return a SphinxProperty object containing the acoustic properties,or null if there are no acoustic model properties
 * @throws FileNotFoundException if the file cannot be found
 * @throws IOException if an error occurs while loading the data
 */
private SphinxProperties loadAcousticPropertiesFile(String context,String url) throws FileNotFoundException, IOException {
  SphinxProperties.initContext(context,new URL(url));
  return (SphinxProperties.getSphinxProperties(context));
}",0.9503239740820736
19953,"/** 
 * Loads the Sphinx 3 acoustic model properties file, which is basically a normal system properties file.
 * @param props the SphinxProperties object 
 * @param path the path to the acoustic properties file
 * @param append if true, append to the current file, if ZIP file
 * @throws FileNotFoundException if the file cannot be found
 * @throws IOException if an error occurs while saving the data
 */
private void saveAcousticPropertiesFile(SphinxProperties property,String path,boolean append) throws FileNotFoundException, IOException {
  logger.info(""String_Node_Str"");
  logger.info(path);
  OutputStream outputStream=StreamFactory.getOutputStream(location,path,append);
  if (outputStream == null) {
    throw new IOException(""String_Node_Str"" + path);
  }
  PrintStream ps=new PrintStream(outputStream,true);
  property.list(ps);
  outputStream.close();
}","/** 
 * Loads the Sphinx 3 acoustic model properties file, which is basically a normal system properties file.
 * @param property the SphinxProperties object 
 * @param path the path to the acoustic properties file
 * @param append if true, append to the current file, if ZIP file
 * @throws FileNotFoundException if the file cannot be found
 * @throws IOException if an error occurs while saving the data
 */
private void saveAcousticPropertiesFile(SphinxProperties property,String path,boolean append) throws FileNotFoundException, IOException {
  logger.info(""String_Node_Str"");
  logger.info(path);
  OutputStream outputStream=StreamFactory.getOutputStream(location,path,append);
  if (outputStream == null) {
    throw new IOException(""String_Node_Str"" + path);
  }
  PrintStream ps=new PrintStream(outputStream,true);
  property.list(ps);
  outputStream.close();
}",0.9971214738054116
19954,"/** 
 * Saves the sphinx3 densityfile, a set of density arrays are created and placed in the given pool.
 * @param path the path to a density file
 * @param name the name of the data
 * @throws FileNotFoundException if a file cannot be found
 * @throws IOException if an error occurs while saving the data
 */
private void saveHMMPool(boolean useCDUnits,OutputStream outputStream,String path) throws FileNotFoundException, IOException {
}","/** 
 * Saves the sphinx3 densityfile, a set of density arrays are created and placed in the given pool.
 * @param useCDUnits if true, uses context dependent units
 * @param outputStream the open output stream to use
 * @param path the path to a density file
 * @throws FileNotFoundException if a file cannot be found
 * @throws IOException if an error occurs while saving the data
 */
private void saveHMMPool(boolean useCDUnits,OutputStream outputStream,String path) throws FileNotFoundException, IOException {
}",0.8445378151260504
19955,"/** 
 * Creates a LexTreeState.
 * @param leftID the id of the unit forming the left context(or 0 if  there is no left context) of a triphone context
 * @param central the unit forming the central portion of atriphone context
 * @param right the unit forming the right portion of atriphone context
 * @param wordSequence the history of words up until this point
 * @param logProbability the probability (in log math domain)of entering this state.  This is a combination of insertion and language probability.
 */
LexTreeState(int leftID,LexTree.UnitLexNode central,LexTree.UnitLexNode right,WordSequence wordSequence,float logLanguageProbability,float logAcousticProbability,float logInsertionProbability){
  if (leftID == 0) {
    leftID=silenceID;
  }
  this.leftID=leftID;
  this.central=central;
  this.right=right;
  this.wordSequence=wordSequence;
  this.logLanguageProbability=logLanguageProbability * languageWeight;
  this.logAcousticProbability=logAcousticProbability;
  this.logInsertionProbability=logInsertionProbability;
}","/** 
 * Creates a LexTreeState.
 * @param leftID the id of the unit forming the left context(or 0 if  there is no left context) of a triphone context
 * @param central the unit forming the central portion of atriphone context
 * @param right the unit forming the right portion of atriphone context
 * @param wordSequence the history of words up until this point
 * @param logProbability the probability (in log math domain)of entering this state.  This is a combination of insertion and language probability.
 */
LexTreeState(int leftID,LexTree.UnitLexNode central,LexTree.UnitLexNode right,WordSequence wordSequence,float logLanguageProbability,float logAcousticProbability,float logInsertionProbability){
  if (leftID == 0) {
    leftID=silenceID;
  }
  if (central != null && central.getID() == silenceID) {
    leftID=silenceID;
    right=null;
  }
  this.leftID=leftID;
  this.central=central;
  this.right=right;
  this.wordSequence=wordSequence;
  this.logLanguageProbability=logLanguageProbability * languageWeight;
  this.logAcousticProbability=logAcousticProbability;
  this.logInsertionProbability=logInsertionProbability;
}",0.9424228466144634
19956,"/** 
 * Retrieves the successors for this node
 * @return the list of successor states
 */
public SearchStateArc[] getSuccessors(){
  LexTree.UnitLexNode nextCentral=getRight();
  if (isFinal()) {
    return EMPTY_ARC;
  }
 else   if (nextCentral == null) {
    return getArcsToAllWords(this);
  }
 else {
    int nextLeftID=getCentral().getID();
    LexTree.LexNode[] nextNodes=getNextUnits(nextCentral);
    SearchStateArc[] nextStates=new SearchStateArc[nextNodes.length + 1];
    for (int i=0; i < nextNodes.length; i++) {
      LexTree.LexNode nextRight=nextNodes[i];
      nextStates[i]=new LexTreeUnitState(nextLeftID,nextCentral,(LexTree.UnitLexNode)nextRight,getWordSequence());
    }
    nextStates[nextStates.length - 1]=createNextWordState(this,finalNode);
    return nextStates;
  }
}","/** 
 * Retrieves the successors for this node
 * @return the list of successor states
 */
public SearchStateArc[] getSuccessors(){
  LexTree.UnitLexNode nextCentral=getRight();
  if (isFinal()) {
    return EMPTY_ARC;
  }
 else   if (nextCentral == null) {
    return getArcsToAllWords(this);
  }
 else {
    int nextLeftID=getCentral().getID();
    LexTree.LexNode[] nextNodes=getNextUnits(nextCentral);
    SearchStateArc[] nextStates=new SearchStateArc[nextNodes.length + 1];
    for (int i=0; i < nextNodes.length; i++) {
      LexTree.LexNode nextRight=nextNodes[i];
      nextStates[i]=new LexTreeUnitState(nextLeftID,nextCentral,(LexTree.UnitLexNode)nextRight,getWordSequence());
    }
    nextStates[nextStates.length - 1]=getEndWord();
    return nextStates;
  }
}",0.9764481222151496
19957,"/** 
 * Creates a LexTreeInitialState object
 */
LexTreeInitialState(LexTree.NonLeafLexNode node){
  super(silenceID,null,null,new WordSequence(Dictionary.SENTENCE_START_SPELLING),logOne,logOne,logOne);
  this.node=node;
}","/** 
 * Creates a LexTreeInitialState object
 */
LexTreeInitialState(LexTree.NonLeafLexNode node){
  super(silenceID,null,null,(new WordSequence(Dictionary.SENTENCE_START_SPELLING)).trim(languageModel.getMaxDepth() - 1),logOne,logOne,logOne);
  this.node=node;
}",0.9173553719008264
19958,"/** 
 * Gets the arcs to all of the successor nodes
 * @param state the current state
 * @return an array of arcs to the first units of all the wods
 */
SearchStateArc[] getArcsToAllWords(LexTreeState state){
  WordSequence wordSequence=state.getWordSequence();
  int leftID=state.getCentral() == null ? 0 : state.getCentral().getID();
  List list=new ArrayList();
  LexTree.LexNode[] nodes=lexTree.getInitialNode().getNextNodes();
  for (int i=0; i < nodes.length; i++) {
    LexTree.LexNode node=nodes[i];
    if ((node instanceof LexTree.UnitLexNode)) {
      LexTree.UnitLexNode central=(LexTree.UnitLexNode)node;
      if (central.getUnit().isSilence()) {
        list.add(new LexTreeUnitState(leftID,central,null,wordSequence));
      }
 else {
        LexTree.LexNode[] rightNodes=getNextUnits(central);
        for (int j=0; j < rightNodes.length; j++) {
          list.add(new LexTreeUnitState(leftID,central,(LexTree.UnitLexNode)rightNodes[j],wordSequence));
        }
      }
    }
 else {
      throw new Error(""String_Node_Str"");
    }
  }
  list.add(createNextWordState(state,finalNode));
  return (SearchStateArc[])list.toArray(new SearchStateArc[list.size()]);
}","/** 
 * Gets the arcs to all of the successor nodes
 * @param state the current state
 * @return an array of arcs to the first units of all the wods
 */
SearchStateArc[] getArcsToAllWords(LexTreeState state){
  WordSequence wordSequence=state.getWordSequence();
  int leftID=state.getCentral() == null ? 0 : state.getCentral().getID();
  List list=new ArrayList();
  LexTree.LexNode[] nodes=lexTree.getInitialNode().getNextNodes();
  for (int i=0; i < nodes.length; i++) {
    LexTree.LexNode node=nodes[i];
    if ((node instanceof LexTree.UnitLexNode)) {
      LexTree.UnitLexNode central=(LexTree.UnitLexNode)node;
      if (central.getUnit().isSilence()) {
        list.add(new LexTreeUnitState(leftID,central,null,wordSequence));
      }
 else {
        LexTree.LexNode[] rightNodes=getNextUnits(central);
        for (int j=0; j < rightNodes.length; j++) {
          list.add(new LexTreeUnitState(leftID,central,(LexTree.UnitLexNode)rightNodes[j],wordSequence));
        }
      }
    }
 else {
      throw new Error(""String_Node_Str"");
    }
  }
  list.add(getEndWord());
  return (SearchStateArc[])list.toArray(new SearchStateArc[list.size()]);
}",0.983704974271012
19959,"public String toString(){
  return super.toString() + ""String_Node_Str"" + wordLexNode.getPronunciation();
}","public String toString(){
  return ""String_Node_Str"" + wordLexNode.getPronunciation() + ""String_Node_Str""+ super.toString();
}",0.7553648068669528
19960,"/** 
 * Given a search state and the next lextree node representing a word, create the new search state with the proper probability.
 * @param curState the current search state
 * @param nextWord the next word in the lex tree
 * @return the arc to the search state associated with the next word
 */
private SearchStateArc createNextWordState(LexTreeState curState,LexTree.WordLexNode nextWord){
  WordSequence wordSequence=curState.getWordSequence();
  float logProbability=logOne;
  if (!nextWord.isSilence()) {
    wordSequence=wordSequence.addWord(nextWord.getPronunciation().getWord(),languageModel.getMaxDepth());
    logProbability=languageModel.getProbability(wordSequence);
    if (false) {
      System.out.println(wordSequence + ""String_Node_Str"" + logProbability);
    }
  }
  return new LexTreeWordState(curState.getLeftID(),curState.getCentral(),curState.getRight(),wordSequence.trim(languageModel.getMaxDepth() - 1),nextWord,logProbability);
}","/** 
 * Given a search state and the next lextree node representing a word, create the new search state with the proper probability.
 * @param curState the current search state
 * @param nextWord the next word in the lex tree
 * @return the arc to the search state associated with the next word
 */
private SearchStateArc createNextWordState(LexTreeState curState,LexTree.WordLexNode nextWord){
  WordSequence wordSequence=curState.getWordSequence();
  float logProbability=logOne;
  if (!nextWord.isSilence()) {
    wordSequence=wordSequence.addWord(nextWord.getPronunciation().getWord(),languageModel.getMaxDepth());
    logProbability=languageModel.getProbability(wordSequence);
    if (false) {
      System.out.println(wordSequence + ""String_Node_Str"" + logProbability);
    }
  }
  return new LexTreeWordState(0,curState.getCentral(),curState.getRight(),wordSequence.trim(languageModel.getMaxDepth() - 1),nextWord,logProbability);
}",0.8844327176781003
19961,"/** 
 * Constructs a SimpleFrontEnd with the given name, context, acoustic  model name, and DataSource.
 * @param name the name of this SimpleFrontEnd
 * @param context the context of interest
 * @param amName the name of the acoustic model
 * @param dataSource the source of data
 */
public void initialize(String name,String context,String amName,DataSource dataSource) throws IOException {
  SphinxProperties props=SphinxProperties.getSphinxProperties(context);
  boolean useAcousticModelProperties=props.getBoolean(FrontEnd.PROP_USE_ACOUSTIC_MODEL_PROPERTIES,FrontEnd.PROP_USE_ACOUSTIC_MODEL_PROPERTIES_DEFAULT);
  if (useAcousticModelProperties) {
    props=(PropertiesResolver.resolve(props,getAcousticProperties(context,amName),context + ""String_Node_Str"" + getName()));
  }
  super.initialize(name,context,props,amName,dataSource);
}","/** 
 * Constructs a SimpleFrontEnd with the given name, context, acoustic  model name, and DataSource.
 * @param name the name of this SimpleFrontEnd
 * @param context the context of interest
 * @param amName the name of the acoustic model
 * @param dataSource the source of data
 */
public void initialize(String name,String context,String amName,DataSource dataSource) throws IOException {
  SphinxProperties props=SphinxProperties.getSphinxProperties(context);
  boolean useAcousticModelProperties=props.getBoolean(FrontEnd.PROP_USE_ACOUSTIC_MODEL_PROPERTIES,FrontEnd.PROP_USE_ACOUSTIC_MODEL_PROPERTIES_DEFAULT);
  if (useAcousticModelProperties) {
    props=(PropertiesResolver.resolve(props,getAcousticProperties(context,amName),context + ""String_Node_Str"" + name));
  }
  super.initialize(name,context,props,amName,dataSource);
}",0.992248062015504
19962,"/** 
 * Adds the given token to the list
 * @param token the token to add
 */
public void add(Token token){
  Class type;
  if (token.getSearchState() instanceof HMMStateState && !token.isEmitting()) {
    type=HMMStateStateNE.class;
  }
 else {
    type=token.getSearchState().getClass();
  }
  ActiveList activeList=findListFor(type);
  if (activeList == null) {
    SimpleActiveList simpleActiveList=new SimpleActiveList(props);
    if (!token.isEmitting()) {
      simpleActiveList.absoluteBeamWidth=absoluteWordBeamWidth;
      simpleActiveList.relativeBeamWidth=relativeWordBeamWidth;
    }
    activeList=simpleActiveList;
    listMap.put(type,activeList);
  }
  activeList.add(token);
}","/** 
 * Adds the given token to the list
 * @param token the token to add
 */
public void add(Token token){
}",0.2714819427148194
19963,"/** 
 * Creates active lists with properties
 * @param props the sphinx properties
 */
public SimpleActiveListManager(SphinxProperties props){
  this.props=props;
  absoluteWordBeamWidth=props.getInt(PROP_ABSOLUTE_WORD_BEAM_WIDTH,PROP_ABSOLUTE_WORD_BEAM_WIDTH_DEFAULT);
  double linearRelativeWordBeamWidth=props.getFloat(PROP_RELATIVE_WORD_BEAM_WIDTH,PROP_RELATIVE_WORD_BEAM_WIDTH_DEFAULT);
  LogMath logMath=LogMath.getLogMath(props.getContext());
  relativeWordBeamWidth=logMath.linearToLog(linearRelativeWordBeamWidth);
  listOrder[0]=HMMStateState.class;
  listOrder[1]=HMMStateStateNE.class;
  listOrder[2]=BranchState.class;
  listOrder[3]=PronunciationState.class;
  listOrder[4]=ExtendedUnitState.class;
  listOrder[5]=GrammarState.class;
}","/** 
 * Creates active lists with properties
 * @param props the sphinx properties
 */
public SimpleActiveListManager(SphinxProperties props){
  this.props=props;
  absoluteWordBeamWidth=props.getInt(PROP_ABSOLUTE_WORD_BEAM_WIDTH,PROP_ABSOLUTE_WORD_BEAM_WIDTH_DEFAULT);
  double linearRelativeWordBeamWidth=props.getFloat(PROP_RELATIVE_WORD_BEAM_WIDTH,PROP_RELATIVE_WORD_BEAM_WIDTH_DEFAULT);
  LogMath logMath=LogMath.getLogMath(props.getContext());
  relativeWordBeamWidth=logMath.linearToLog(linearRelativeWordBeamWidth);
}",0.8241758241758241
19964,"public ActiveList getNextList(){
  if (listMap.isEmpty()) {
    return null;
  }
  if (listPtr == 6) {
    listPtr=0;
  }
  ActiveList activeList=findListFor(listOrder[listPtr++]);
  if (activeList == null) {
    return getNextList();
  }
  listMap.remove(listOrder[listPtr - 1]);
  return activeList;
}","public ActiveList getNextList(){
  if (listMap.isEmpty()) {
    return null;
  }
  if (listPtr == listOrder.length) {
    listPtr=0;
  }
  ActiveList activeList=findListFor(listOrder[listPtr++]);
  if (activeList == null) {
    return getNextList();
  }
  listMap.remove(listOrder[listPtr - 1]);
  return activeList;
}",0.9726247987117552
19965,"/** 
 * Loads the language model from the given location. 
 * @param location the location of the language model
 */
private void loadBinary(String location) throws IOException {
  FileInputStream fis=new FileInputStream(location);
  DataInputStream stream=new DataInputStream(new BufferedInputStream(fis));
  readHeader(stream);
  unigrams=readUnigrams(stream,numberUnigrams + 1,bigEndian);
  skipBigramsTrigrams(stream);
  if (numberBigrams > 0) {
    this.bigramProbTable=readFloatTable(stream,bigEndian);
  }
  if (numberTrigrams > 0) {
    trigramBackoffTable=readFloatTable(stream,bigEndian);
    trigramProbTable=readFloatTable(stream,bigEndian);
    int bigramSegmentSize=1 << logBigramSegmentSize;
    int trigramSegTableSize=((numberBigrams + 1) / bigramSegmentSize) + 1;
    trigramSegmentTable=readIntTable(stream,bigEndian,trigramSegTableSize);
  }
  int wordsStringLength=readInt(stream,bigEndian);
  if (wordsStringLength <= 0) {
    throw new Error(""String_Node_Str"" + wordsStringLength);
  }
  this.words=readWords(stream,wordsStringLength,numberUnigrams);
  if (startWordID > -1) {
    UnigramProbability unigram=unigrams[startWordID];
    unigram.setLogProbability(MIN_PROBABILITY);
  }
  if (endWordID > -1) {
    UnigramProbability unigram=unigrams[endWordID];
    unigram.setLogBackoff(MIN_PROBABILITY);
  }
  applyUnigramWeight();
  fis.close();
  stream.close();
  file=new RandomAccessFile(location,""String_Node_Str"");
}","/** 
 * Loads the language model from the given location. 
 * @param location the location of the language model
 */
private void loadBinary(String location) throws IOException {
  FileInputStream fis=new FileInputStream(location);
  DataInputStream stream=new DataInputStream(new BufferedInputStream(fis));
  readHeader(stream);
  unigrams=readUnigrams(stream,numberUnigrams + 1,bigEndian);
  skipBigramsTrigrams(stream);
  if (numberBigrams > 0) {
    this.bigramProbTable=readFloatTable(stream,bigEndian);
    applyLanguageWeight(bigramProbTable,languageWeight);
    applyWip(bigramProbTable,wip);
  }
  if (numberTrigrams > 0) {
    trigramBackoffTable=readFloatTable(stream,bigEndian);
    trigramProbTable=readFloatTable(stream,bigEndian);
    if (applyLanguageWeightAndWip) {
      applyLanguageWeight(trigramProbTable,languageWeight);
      applyWip(trigramProbTable,wip);
      applyLanguageWeight(trigramBackoffTable,languageWeight);
    }
    int bigramSegmentSize=1 << logBigramSegmentSize;
    int trigramSegTableSize=((numberBigrams + 1) / bigramSegmentSize) + 1;
    trigramSegmentTable=readIntTable(stream,bigEndian,trigramSegTableSize);
  }
  int wordsStringLength=readInt(stream,bigEndian);
  if (wordsStringLength <= 0) {
    throw new Error(""String_Node_Str"" + wordsStringLength);
  }
  this.words=readWords(stream,wordsStringLength,numberUnigrams);
  if (startWordID > -1) {
    UnigramProbability unigram=unigrams[startWordID];
    unigram.setLogProbability(MIN_PROBABILITY);
  }
  if (endWordID > -1) {
    UnigramProbability unigram=unigrams[endWordID];
    unigram.setLogBackoff(MIN_PROBABILITY);
  }
  applyUnigramWeight();
  fis.close();
  stream.close();
  file=new RandomAccessFile(location,""String_Node_Str"");
}",0.9070935342121784
19966,"/** 
 * Apply the unigram weight to the set of unigrams
 */
private void applyUnigramWeight(){
  float unigramWeight=props.getFloat(LanguageModel.PROP_UNIGRAM_WEIGHT,LanguageModel.PROP_UNIGRAM_WEIGHT_DEFAULT);
  float logUnigramWeight=logMath.linearToLog(unigramWeight);
  float logNotUnigramWeight=logMath.linearToLog(1.0f - unigramWeight);
  float logUniform=logMath.linearToLog(1.0f / (numberUnigrams));
  float p2=logUniform + logNotUnigramWeight;
  for (int i=0; i < numberUnigrams; i++) {
    UnigramProbability unigram=unigrams[i];
    float p1=unigram.getLogProbability();
    if (i != startWordID) {
      p1+=logUnigramWeight;
      p1=logMath.addAsLinear(p1,p2);
    }
    if (applyLanguageWeightAndWip) {
      p1=p1 * languageWeight + wip;
      unigram.setLogBackoff(unigram.getLogBackoff() * languageWeight);
    }
    unigram.setLogProbability(p1);
  }
}","/** 
 * Apply the unigram weight to the set of unigrams
 */
private void applyUnigramWeight(){
  float unigramWeight=props.getFloat(LanguageModel.PROP_UNIGRAM_WEIGHT,LanguageModel.PROP_UNIGRAM_WEIGHT_DEFAULT);
  float logUnigramWeight=logMath.linearToLog(unigramWeight);
  float logNotUnigramWeight=logMath.linearToLog(1.0f - unigramWeight);
  float logUniform=logMath.linearToLog(1.0f / (numberUnigrams));
  float logWip=logMath.linearToLog(wip);
  float p2=logUniform + logNotUnigramWeight;
  for (int i=0; i < numberUnigrams; i++) {
    UnigramProbability unigram=unigrams[i];
    float p1=unigram.getLogProbability();
    if (i != startWordID) {
      p1+=logUnigramWeight;
      p1=logMath.addAsLinear(p1,p2);
    }
    if (applyLanguageWeightAndWip) {
      p1=p1 * languageWeight + logWip;
      unigram.setLogBackoff(unigram.getLogBackoff() * languageWeight);
    }
    unigram.setLogProbability(p1);
  }
}",0.9742152466367712
19967,"/** 
 * Reads the probability table from the given DataInputStream.
 * @param stream the DataInputStream from which to read the table
 * @param bigEndian true if the given stream is bigEndian, false otherwise
 */
private float[] readFloatTable(DataInputStream stream,boolean bigEndian) throws IOException {
  int numProbs=readInt(stream,bigEndian);
  if (numProbs <= 0 || numProbs > 65536) {
    throw new Error(""String_Node_Str"" + numProbs);
  }
  float[] probTable=new float[numProbs];
  if (applyLanguageWeightAndWip) {
    for (int i=0; i < numProbs; i++) {
      probTable[i]=logMath.log10ToLog(readFloat(stream,bigEndian)) * languageWeight + wip;
    }
  }
 else {
    for (int i=0; i < numProbs; i++) {
      probTable[i]=logMath.log10ToLog(readFloat(stream,bigEndian));
    }
  }
  return probTable;
}","/** 
 * Reads the probability table from the given DataInputStream.
 * @param stream the DataInputStream from which to read the table
 * @param bigEndian true if the given stream is bigEndian, false otherwise
 */
private float[] readFloatTable(DataInputStream stream,boolean bigEndian) throws IOException {
  int numProbs=readInt(stream,bigEndian);
  if (numProbs <= 0 || numProbs > 65536) {
    throw new Error(""String_Node_Str"" + numProbs);
  }
  float[] probTable=new float[numProbs];
  for (int i=0; i < numProbs; i++) {
    probTable[i]=logMath.log10ToLog(readFloat(stream,bigEndian));
  }
  return probTable;
}",0.8392982456140351
19968,"/** 
 * Initializes this LanguageModel
 * @param context the context to associate this linguist with
 */
private void initialize(String context) throws IOException {
  this.props=SphinxProperties.getSphinxProperties(context);
  String format=props.getString(LanguageModel.PROP_FORMAT,LanguageModel.PROP_FORMAT_DEFAULT);
  String location=props.getString(LanguageModel.PROP_LOCATION,LanguageModel.PROP_LOCATION_DEFAULT);
  applyLanguageWeightAndWip=props.getBoolean(PROP_APPLY_LANGUAGE_WEIGHT_AND_WIP,PROP_APPLY_LANGUAGE_WEIGHT_AND_WIP_DEFAULT);
  logMath=LogMath.getLogMath(context);
  languageWeight=9.5f;
  wip=logMath.linearToLog(0.7);
  loadBinary(location);
}","/** 
 * Initializes this LanguageModel
 * @param context the context to associate this linguist with
 */
private void initialize(String context) throws IOException {
  this.props=SphinxProperties.getSphinxProperties(context);
  String format=props.getString(LanguageModel.PROP_FORMAT,LanguageModel.PROP_FORMAT_DEFAULT);
  String location=props.getString(LanguageModel.PROP_LOCATION,LanguageModel.PROP_LOCATION_DEFAULT);
  applyLanguageWeightAndWip=props.getBoolean(PROP_APPLY_LANGUAGE_WEIGHT_AND_WIP,PROP_APPLY_LANGUAGE_WEIGHT_AND_WIP_DEFAULT);
  logMath=LogMath.getLogMath(context);
  languageWeight=props.getFloat(Linguist.PROP_LANGUAGE_WEIGHT,Linguist.PROP_LANGUAGE_WEIGHT_DEFAULT);
  wip=(float)props.getDouble(Linguist.PROP_WORD_INSERTION_PROBABILITY,Linguist.PROP_WORD_INSERTION_PROBABILITY_DEFAULT);
  loadBinary(location);
}",0.8422459893048129
19969,"/** 
 * Loads the language model from the given location. 
 * @param location the location of the language model
 */
private void loadBinary(String location) throws IOException {
  FileInputStream fis=new FileInputStream(location);
  DataInputStream stream=new DataInputStream(new BufferedInputStream(fis));
  readHeader(stream);
  unigrams=readUnigrams(stream,numberUnigrams + 1,bigEndian);
  skipBigramsTrigrams(stream);
  if (numberBigrams > 0) {
    this.bigramProbTable=readFloatTable(stream,bigEndian);
  }
  if (numberTrigrams > 0) {
    trigramBackoffTable=readFloatTable(stream,bigEndian);
    trigramProbTable=readFloatTable(stream,bigEndian);
    int bigramSegmentSize=1 << logBigramSegmentSize;
    int trigramSegTableSize=((numberBigrams + 1) / bigramSegmentSize) + 1;
    trigramSegmentTable=readIntTable(stream,bigEndian,trigramSegTableSize);
  }
  int wordsStringLength=readInt(stream,bigEndian);
  if (wordsStringLength <= 0) {
    throw new Error(""String_Node_Str"" + wordsStringLength);
  }
  this.words=readWords(stream,wordsStringLength,numberUnigrams);
  if (startWordID > -1) {
    UnigramProbability unigram=unigrams[startWordID];
    unigram.setLogProbability(-0.99f);
  }
  if (endWordID > -1) {
    UnigramProbability unigram=unigrams[endWordID];
    unigram.setLogProbability(-0.99f);
  }
  applyUnigramWeight();
  fis.close();
  stream.close();
  file=new RandomAccessFile(location,""String_Node_Str"");
}","/** 
 * Loads the language model from the given location. 
 * @param location the location of the language model
 */
private void loadBinary(String location) throws IOException {
  FileInputStream fis=new FileInputStream(location);
  DataInputStream stream=new DataInputStream(new BufferedInputStream(fis));
  readHeader(stream);
  unigrams=readUnigrams(stream,numberUnigrams + 1,bigEndian);
  skipBigramsTrigrams(stream);
  if (numberBigrams > 0) {
    this.bigramProbTable=readFloatTable(stream,bigEndian);
  }
  if (numberTrigrams > 0) {
    trigramBackoffTable=readFloatTable(stream,bigEndian);
    trigramProbTable=readFloatTable(stream,bigEndian);
    int bigramSegmentSize=1 << logBigramSegmentSize;
    int trigramSegTableSize=((numberBigrams + 1) / bigramSegmentSize) + 1;
    trigramSegmentTable=readIntTable(stream,bigEndian,trigramSegTableSize);
  }
  int wordsStringLength=readInt(stream,bigEndian);
  if (wordsStringLength <= 0) {
    throw new Error(""String_Node_Str"" + wordsStringLength);
  }
  this.words=readWords(stream,wordsStringLength,numberUnigrams);
  if (startWordID > -1) {
    UnigramProbability unigram=unigrams[startWordID];
    unigram.setLogProbability(MIN_PROBABILITY);
  }
  if (endWordID > -1) {
    UnigramProbability unigram=unigrams[endWordID];
    unigram.setLogBackoff(MIN_PROBABILITY);
  }
  applyUnigramWeight();
  fis.close();
  stream.close();
  file=new RandomAccessFile(location,""String_Node_Str"");
}",0.9791376912378305
19970,"/** 
 * Internal routine used when dumping a Lattice as an AiSee file
 * @param f
 * @throws IOException
 */
void dumpAISee(FileWriter f) throws IOException {
  f.write(""String_Node_Str"" + fromNode.getId() + ""String_Node_Str""+ toNode.getId()+ ""String_Node_Str"");
}","/** 
 * Internal routine used when dumping a Lattice as an AiSee file
 * @param f
 * @throws IOException
 */
void dumpAISee(FileWriter f) throws IOException {
  f.write(""String_Node_Str"" + fromNode.getId() + ""String_Node_Str""+ toNode.getId()+ ""String_Node_Str""+ acousticScore+ ""String_Node_Str"");
}",0.9395017793594306
19971,"/** 
 * Internal routine when dumping Lattices as AiSee files
 * @param f
 * @throws IOException
 */
void dumpAISee(FileWriter f) throws IOException {
  f.write(""String_Node_Str"" + id + ""String_Node_Str""+ getWord()+ ""String_Node_Str"");
}","/** 
 * Internal routine when dumping Lattices as AiSee files
 * @param f
 * @throws IOException
 */
void dumpAISee(FileWriter f) throws IOException {
  f.write(""String_Node_Str"" + id + ""String_Node_Str""+ getWord()+ ""String_Node_Str""+ getId()+ ""String_Node_Str""+ getBeginTime()+ ""String_Node_Str""+ getEndTime()+ ""String_Node_Str"");
}",0.8315789473684211
19972,"public static void main(String[] args) throws Exception {
  String propsPath;
  String testFile=null;
  if (args.length == 0) {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"");
  }
  propsPath=args[0];
  if (args.length == 2) {
    testFile=args[1];
  }
  SphinxProperties.initContext(""String_Node_Str"",new URL(propsPath));
  LargeTrigramModel lm=new LargeTrigramModel(""String_Node_Str"");
  Timer.dumpAll();
  LogMath logMath=LogMath.getLogMath(""String_Node_Str"");
  InputStream stream=new FileInputStream(testFile);
  BufferedReader reader=new BufferedReader(new InputStreamReader(stream));
  Timer timer=Timer.getTimer(""String_Node_Str"",""String_Node_Str"");
  String input;
  List wordSequences=new LinkedList();
  while ((input=reader.readLine()) != null) {
    StringTokenizer st=new StringTokenizer(input);
    List list=new ArrayList();
    while (st.hasMoreTokens()) {
      String tok=(String)st.nextToken();
      list.add(tok);
    }
    WordSequence wordSequence=new WordSequence(list);
    wordSequences.add(wordSequence);
  }
  for (Iterator i=wordSequences.iterator(); i.hasNext(); ) {
    WordSequence ws=(WordSequence)i.next();
    timer.start();
    lm.start();
    int logProbability=(int)lm.getProbability(ws);
    timer.stop();
    System.out.println(Utilities.pad(logProbability,10) + ""String_Node_Str"" + getString(ws));
    if (false) {
      long usedMemory=Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
      System.out.println(""String_Node_Str"" + usedMemory + ""String_Node_Str"");
      System.out.print(""String_Node_Str"");
    }
  }
  Timer.dumpAll(""String_Node_Str"");
}","public static void main(String[] args) throws Exception {
  String propsPath;
  String testFile=null;
  if (args.length == 0) {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"");
  }
  propsPath=args[0];
  if (args.length == 2) {
    testFile=args[1];
  }
  SphinxProperties.initContext(""String_Node_Str"",new URL(propsPath));
  LargeTrigramModel lm=new LargeTrigramModel(""String_Node_Str"");
  LogMath logMath=LogMath.getLogMath(""String_Node_Str"");
  InputStream stream=new FileInputStream(testFile);
  BufferedReader reader=new BufferedReader(new InputStreamReader(stream));
  Timer timer=Timer.getTimer(""String_Node_Str"",""String_Node_Str"");
  String input;
  List wordSequences=new LinkedList();
  while ((input=reader.readLine()) != null) {
    StringTokenizer st=new StringTokenizer(input);
    List list=new ArrayList();
    while (st.hasMoreTokens()) {
      String tok=(String)st.nextToken();
      list.add(tok);
    }
    WordSequence wordSequence=new WordSequence(list);
    wordSequences.add(wordSequence);
  }
  int[] logScores=new int[wordSequences.size()];
  int s=0;
  timer.start();
  for (Iterator i=wordSequences.iterator(); i.hasNext(); ) {
    lm.start();
    WordSequence ws=(WordSequence)i.next();
    logScores[s++]=(int)lm.getProbability(ws);
    lm.stop();
  }
  timer.stop();
  s=0;
  for (Iterator i=wordSequences.iterator(); i.hasNext(); ) {
    WordSequence ws=(WordSequence)i.next();
    System.out.println(Utilities.pad(logScores[s++],10) + ""String_Node_Str"" + getString(ws));
  }
  if (true) {
    long usedMemory=Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
    System.out.println(""String_Node_Str"" + usedMemory + ""String_Node_Str"");
  }
  Timer.dumpAll();
}",0.7588462682129051
19973,"/** 
 * Returns the BigramProbability of the nth follower.
 * @param nthFollower which follower
 * @return the BigramProbability of the nth follower
 */
public final BigramProbability getBigramProbability(int nthFollower){
  int nthPosition=nthFollower * LargeTrigramModel.BYTES_PER_BIGRAM;
  getBuffer().position(nthPosition);
  int wordID=readTwoBytesAsInt();
  int probID=readTwoBytesAsInt();
  int backoffID=readTwoBytesAsInt();
  int firstTrigram=readTwoBytesAsInt();
  getBuffer().position(getBuffer().position() + LargeTrigramModel.BYTES_PER_BIGRAM - 2);
  int nextFirstTrigram=readTwoBytesAsInt();
  return (new BigramProbability(nthFollower,wordID,probID,backoffID,firstTrigram,nextFirstTrigram - firstTrigram));
}","/** 
 * Returns the BigramProbability of the nth follower.
 * @param nthFollower which follower
 * @return the BigramProbability of the nth follower
 */
public final BigramProbability getBigramProbability(int nthFollower){
  int nthPosition=nthFollower * LargeTrigramModel.BYTES_PER_BIGRAM;
  getBuffer().position(nthPosition);
  int wordID=readTwoBytesAsInt();
  int probID=readTwoBytesAsInt();
  int backoffID=readTwoBytesAsInt();
  int firstTrigram=readTwoBytesAsInt();
  return (new BigramProbability(nthFollower,wordID,probID,backoffID,firstTrigram));
}",0.8711943793911007
19974,"/** 
 * Constructs a BigramProbability
 * @param which which follower of the first word is this bigram
 * @param wordID the ID of the second word in a bigram
 * @param probabilityID the index into the probability array
 * @param backoffID the index into the backoff probability array
 * @param firstTrigramEntry the first trigram entry
 * @param trigramEntries the number trigram entries for this bigram 
 */
public BigramProbability(int which,int wordID,int probabilityID,int backoffID,int firstTrigramEntry,int trigramEntries){
  this.which=which;
  this.wordID=wordID;
  this.probabilityID=probabilityID;
  this.backoffID=backoffID;
  this.firstTrigramEntry=firstTrigramEntry;
  this.numberTrigramEntries=trigramEntries;
}","/** 
 * Constructs a BigramProbability
 * @param which which follower of the first word is this bigram
 * @param wordID the ID of the second word in a bigram
 * @param probabilityID the index into the probability array
 * @param backoffID the index into the backoff probability array
 * @param firstTrigramEntry the first trigram entry
 * @param trigramEntries the number trigram entries for this bigram 
 */
public BigramProbability(int which,int wordID,int probabilityID,int backoffID,int firstTrigramEntry){
  this.which=which;
  this.wordID=wordID;
  this.probabilityID=probabilityID;
  this.backoffID=backoffID;
  this.firstTrigramEntry=firstTrigramEntry;
}",0.9545782263878876
19975,"/** 
 * Loads the language model from the given location. 
 * @param location the location of the language model
 */
private void loadBinary(String location) throws IOException {
  FileInputStream fis=new FileInputStream(location);
  DataInputStream stream=new DataInputStream(new BufferedInputStream(fis));
  int headerLength=readInt(stream,bigEndian);
  if (headerLength != (DARPA_LM_HEADER.length() + 1)) {
    headerLength=Utilities.swapInteger(headerLength);
    if (headerLength == (DARPA_LM_HEADER.length() + 1)) {
      bigEndian=false;
      System.out.println(""String_Node_Str"");
    }
 else {
      throw new Error(""String_Node_Str"" + headerLength + ""String_Node_Str"");
    }
  }
 else {
    System.out.println(""String_Node_Str"");
  }
  String header=readString(stream,headerLength - 1);
  readByte(stream);
  if (!header.equals(DARPA_LM_HEADER)) {
    throw new Error(""String_Node_Str"" + header);
  }
  int fileNameLength=readInt(stream,bigEndian);
  for (int i=0; i < fileNameLength; i++) {
    readByte(stream);
  }
  numberUnigrams=0;
  logBigramSegmentSize=LOG2_BIGRAM_SEGMENT_SIZE_DEFAULT;
  int version=readInt(stream,bigEndian);
  System.out.println(""String_Node_Str"" + version);
  if (version <= 0) {
    readInt(stream,bigEndian);
    int formatLength;
    for (; ; ) {
      if ((formatLength=readInt(stream,bigEndian)) == 0) {
        break;
      }
      for (int i=0; i < formatLength; i++) {
        readByte(stream);
      }
    }
    if (version <= -2) {
      logBigramSegmentSize=readInt(stream,bigEndian);
      if (logBigramSegmentSize < 1 || logBigramSegmentSize > 15) {
        throw new Error(""String_Node_Str"");
      }
    }
    numberUnigrams=readInt(stream,bigEndian);
  }
 else {
    numberUnigrams=version;
  }
  int bigramSegmentSize=1 << logBigramSegmentSize;
  if (numberUnigrams <= 0) {
    throw new Error(""String_Node_Str"" + numberUnigrams + ""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"" + numberUnigrams);
  numberBigrams=readInt(stream,bigEndian);
  if (numberBigrams < 0) {
    throw new Error(""String_Node_Str"" + numberBigrams);
  }
  System.out.println(""String_Node_Str"" + numberBigrams);
  numberTrigrams=readInt(stream,bigEndian);
  if (numberTrigrams < 0) {
    throw new Error(""String_Node_Str"" + numberTrigrams);
  }
  System.out.println(""String_Node_Str"" + numberTrigrams);
  unigrams=readUnigrams(stream,numberUnigrams + 1,bigEndian);
  if (numberBigrams > 0) {
    bigramOffset=bytesRead;
    int bytesToSkip=(numberBigrams + 1) * LargeTrigramModel.BYTES_PER_BIGRAM;
    stream.skipBytes(bytesToSkip);
    bytesRead+=bytesToSkip;
  }
  if (numberTrigrams > 0) {
    trigramOffset=bytesRead;
    int bytesToSkip=numberTrigrams * LargeTrigramModel.BYTES_PER_TRIGRAM;
    stream.skipBytes(bytesToSkip);
    bytesRead+=bytesToSkip;
  }
  if (numberBigrams > 0) {
    this.bigramProbTable=readFloatTable(stream,bigEndian);
  }
  if (numberTrigrams > 0) {
    trigramBackoffTable=readFloatTable(stream,bigEndian);
    trigramProbTable=readFloatTable(stream,bigEndian);
    int trigramSegTableSize=((numberBigrams + 1) / bigramSegmentSize) + 1;
    trigramSegmentTable=readIntTable(stream,bigEndian,trigramSegTableSize);
  }
  int wordsStringLength=readInt(stream,bigEndian);
  if (wordsStringLength <= 0) {
    throw new Error(""String_Node_Str"" + wordsStringLength);
  }
  String wordsString=readString(stream,wordsStringLength).toLowerCase();
  int numberWords=0;
  for (int i=0; i < wordsStringLength; i++) {
    if (wordsString.charAt(i) == '\0') {
      numberWords++;
    }
  }
  if (numberWords != numberUnigrams) {
    throw new Error(""String_Node_Str"" + numberWords);
  }
  this.words=wordsString.split(""String_Node_Str"");
  applyUnigramWeight();
  applyLanguageWeightAndWip();
  fis.close();
  stream.close();
  is=new FileInputStream(location);
  fileChannel=is.getChannel();
}","/** 
 * Loads the language model from the given location. 
 * @param location the location of the language model
 */
private void loadBinary(String location) throws IOException {
  FileInputStream fis=new FileInputStream(location);
  DataInputStream stream=new DataInputStream(new BufferedInputStream(fis));
  int headerLength=readInt(stream,bigEndian);
  if (headerLength != (DARPA_LM_HEADER.length() + 1)) {
    headerLength=Utilities.swapInteger(headerLength);
    if (headerLength == (DARPA_LM_HEADER.length() + 1)) {
      bigEndian=false;
      System.out.println(""String_Node_Str"");
    }
 else {
      throw new Error(""String_Node_Str"" + headerLength + ""String_Node_Str"");
    }
  }
 else {
    System.out.println(""String_Node_Str"");
  }
  String header=readString(stream,headerLength - 1);
  readByte(stream);
  if (!header.equals(DARPA_LM_HEADER)) {
    throw new Error(""String_Node_Str"" + header);
  }
  int fileNameLength=readInt(stream,bigEndian);
  for (int i=0; i < fileNameLength; i++) {
    readByte(stream);
  }
  numberUnigrams=0;
  logBigramSegmentSize=LOG2_BIGRAM_SEGMENT_SIZE_DEFAULT;
  int version=readInt(stream,bigEndian);
  System.out.println(""String_Node_Str"" + version);
  if (version <= 0) {
    readInt(stream,bigEndian);
    int formatLength;
    for (; ; ) {
      if ((formatLength=readInt(stream,bigEndian)) == 0) {
        break;
      }
      for (int i=0; i < formatLength; i++) {
        readByte(stream);
      }
    }
    if (version <= -2) {
      logBigramSegmentSize=readInt(stream,bigEndian);
      if (logBigramSegmentSize < 1 || logBigramSegmentSize > 15) {
        throw new Error(""String_Node_Str"");
      }
    }
    numberUnigrams=readInt(stream,bigEndian);
  }
 else {
    numberUnigrams=version;
  }
  int bigramSegmentSize=1 << logBigramSegmentSize;
  if (numberUnigrams <= 0) {
    throw new Error(""String_Node_Str"" + numberUnigrams + ""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"" + numberUnigrams);
  numberBigrams=readInt(stream,bigEndian);
  if (numberBigrams < 0) {
    throw new Error(""String_Node_Str"" + numberBigrams);
  }
  System.out.println(""String_Node_Str"" + numberBigrams);
  numberTrigrams=readInt(stream,bigEndian);
  if (numberTrigrams < 0) {
    throw new Error(""String_Node_Str"" + numberTrigrams);
  }
  System.out.println(""String_Node_Str"" + numberTrigrams);
  unigrams=readUnigrams(stream,numberUnigrams + 1,bigEndian);
  if (numberBigrams > 0) {
    bigramOffset=bytesRead;
    int bytesToSkip=(numberBigrams + 1) * LargeTrigramModel.BYTES_PER_BIGRAM;
    stream.skipBytes(bytesToSkip);
    bytesRead+=bytesToSkip;
  }
  if (numberTrigrams > 0) {
    trigramOffset=bytesRead;
    int bytesToSkip=numberTrigrams * LargeTrigramModel.BYTES_PER_TRIGRAM;
    stream.skipBytes(bytesToSkip);
    bytesRead+=bytesToSkip;
  }
  if (numberBigrams > 0) {
    this.bigramProbTable=readFloatTable(stream,bigEndian);
  }
  if (numberTrigrams > 0) {
    trigramBackoffTable=readFloatTable(stream,bigEndian);
    trigramProbTable=readFloatTable(stream,bigEndian);
    int trigramSegTableSize=((numberBigrams + 1) / bigramSegmentSize) + 1;
    trigramSegmentTable=readIntTable(stream,bigEndian,trigramSegTableSize);
  }
  int wordsStringLength=readInt(stream,bigEndian);
  if (wordsStringLength <= 0) {
    throw new Error(""String_Node_Str"" + wordsStringLength);
  }
  String wordsString=readString(stream,wordsStringLength).toLowerCase();
  int numberWords=0;
  for (int i=0; i < wordsStringLength; i++) {
    if (wordsString.charAt(i) == '\0') {
      numberWords++;
    }
  }
  if (numberWords != numberUnigrams) {
    throw new Error(""String_Node_Str"" + numberWords);
  }
  this.words=wordsString.split(""String_Node_Str"");
  applyUnigramWeight();
  if (applyLanguageWeightAndWip) {
    applyLanguageWeightAndWip();
  }
  fis.close();
  stream.close();
  is=new FileInputStream(location);
  fileChannel=is.getChannel();
}",0.9939409565553692
19976,"/** 
 * Initializes this LanguageModel
 * @param context the context to associate this linguist with
 */
private void initialize(String context) throws IOException {
  this.props=SphinxProperties.getSphinxProperties(context);
  String format=props.getString(LanguageModel.PROP_FORMAT,LanguageModel.PROP_FORMAT_DEFAULT);
  String location=props.getString(LanguageModel.PROP_LOCATION,LanguageModel.PROP_LOCATION_DEFAULT);
  logMath=LogMath.getLogMath(context);
  loadBinary(location);
}","/** 
 * Initializes this LanguageModel
 * @param context the context to associate this linguist with
 */
private void initialize(String context) throws IOException {
  this.props=SphinxProperties.getSphinxProperties(context);
  String format=props.getString(LanguageModel.PROP_FORMAT,LanguageModel.PROP_FORMAT_DEFAULT);
  String location=props.getString(LanguageModel.PROP_LOCATION,LanguageModel.PROP_LOCATION_DEFAULT);
  applyLanguageWeightAndWip=props.getBoolean(PROP_APPLY_LANGUAGE_WEIGHT_AND_WIP,PROP_APPLY_LANGUAGE_WEIGHT_AND_WIP_DEFAULT);
  logMath=LogMath.getLogMath(context);
  loadBinary(location);
}",0.8270814272644099
19977,"/** 
 * Returns the ID of the given word.
 * @param word the word to find the ID
 * @return the ID of the word
 */
private final int getWordID(String word){
  Integer integer=(Integer)unigramIDMap.get(word);
  if (integer == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + word);
  }
 else {
    return integer.intValue();
  }
}","/** 
 * Returns the ID of the given word.
 * @param word the word to find the ID
 * @return the ID of the word
 */
private final int getWordID(String word){
  Integer integer=(Integer)unigramIDMap.get(word.toLowerCase());
  if (integer == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + word);
  }
 else {
    return integer.intValue();
  }
}",0.980225988700565
19978,"/** 
 * Called before a recognition
 */
public void start(){
}","/** 
 * Called before a recognition
 */
public void start(){
  loadedBigramBuffer.clear();
  loadedTrigramBuffer.clear();
  trigramCache.clear();
}",0.5933014354066986
19979,"/** 
 * Loads into a buffer all the trigram followers of the given bigram.
 * @param firstWordID the ID of the first word
 * @param secondWordID the ID of the second word
 * @return a TrigramBuffer of all the trigram followers of thegiven two words
 */
private TrigramBuffer loadTrigramBuffer(int firstWordID,int secondWordID){
  TrigramBuffer trigramBuffer=null;
  BigramProbability bigram=findBigram(firstWordID,secondWordID);
  int b=unigrams[firstWordID].getFirstBigramEntry();
  b+=bigram.getWhichFollower();
  int firstTrigramEntry=trigramSegmentTable[b >> loader.getLogBigramSegmentSize()] + bigram.getFirstTrigramEntry();
  long position=(long)(loader.getTrigramOffset() + (firstTrigramEntry * BYTES_PER_TRIGRAM));
  int size=bigram.getNumberTrigramEntries() * BYTES_PER_TRIGRAM;
  try {
    ByteBuffer buffer=loader.loadBuffer(position,size);
    trigramBuffer=new TrigramBuffer(buffer,bigram.getNumberTrigramEntries());
  }
 catch (  IOException ioe) {
    ioe.printStackTrace();
    throw new Error(""String_Node_Str"");
  }
  return trigramBuffer;
}","/** 
 * Loads into a buffer all the trigram followers of the given bigram.
 * @param firstWordID the ID of the first word
 * @param secondWordID the ID of the second word
 * @return a TrigramBuffer of all the trigram followers of thegiven two words
 */
private TrigramBuffer loadTrigramBuffer(int firstWordID,int secondWordID){
  TrigramBuffer trigramBuffer=null;
  BigramProbability bigram=findBigram(firstWordID,secondWordID);
  if (bigram != null) {
    int numberTrigrams=0, size=0;
    long position=0;
    try {
      int b1=unigrams[firstWordID].getFirstBigramEntry();
      b1+=bigram.getWhichFollower();
      int b2=b1 + 1;
      BigramProbability nextBigram=loader.loadBigram(b2).getBigramProbability(0);
      int firstTrigramEntry=trigramSegmentTable[b1 >> loader.getLogBigramSegmentSize()] + bigram.getFirstTrigramEntry();
      int nextFirstTrigramEntry=trigramSegmentTable[b2 >> loader.getLogBigramSegmentSize()] + nextBigram.getFirstTrigramEntry();
      position=(long)(loader.getTrigramOffset() + (firstTrigramEntry * BYTES_PER_TRIGRAM));
      numberTrigrams=nextFirstTrigramEntry - firstTrigramEntry;
      size=numberTrigrams * BYTES_PER_TRIGRAM;
      ByteBuffer buffer=loader.loadBuffer(position,size);
      trigramBuffer=new TrigramBuffer(buffer,numberTrigrams);
    }
 catch (    IOException ioe) {
      ioe.printStackTrace();
      throw new Error(""String_Node_Str"");
    }
catch (    IllegalArgumentException iae) {
      String[] words=loader.getWords();
      System.out.println(words[firstWordID] + ""String_Node_Str"" + words[secondWordID]+ ""String_Node_Str""+ numberTrigrams+ ""String_Node_Str""+ position+ ""String_Node_Str""+ size);
      iae.printStackTrace();
    }
  }
  return trigramBuffer;
}",0.678391959798995
19980,"/** 
 * Finds or loads the trigram probability of the given trigram.
 * @param wordSequence the trigram to load
 * @return a TrigramProbability of the given trigram
 */
private TrigramProbability findTrigram(WordSequence wordSequence){
  WordSequence oldest=wordSequence.getOldest();
  TrigramBuffer trigramBuffer=(TrigramBuffer)loadedTrigramBuffer.get(oldest);
  int thirdWordID=getWordID(wordSequence.getWord(2));
  if (trigramBuffer == null) {
    int firstWordID=getWordID(wordSequence.getWord(0));
    int secondWordID=getWordID(wordSequence.getWord(1));
    trigramBuffer=loadTrigramBuffer(firstWordID,secondWordID);
    loadedTrigramBuffer.put(oldest,trigramBuffer);
  }
  return trigramBuffer.findTrigram(thirdWordID);
}","/** 
 * Finds or loads the trigram probability of the given trigram.
 * @param wordSequence the trigram to load
 * @return a TrigramProbability of the given trigram
 */
private TrigramProbability findTrigram(WordSequence wordSequence){
  WordSequence oldest=wordSequence.getOldest();
  TrigramBuffer trigramBuffer=(TrigramBuffer)loadedTrigramBuffer.get(oldest);
  int thirdWordID=getWordID(wordSequence.getWord(2));
  if (trigramBuffer == null) {
    int firstWordID=getWordID(wordSequence.getWord(0));
    int secondWordID=getWordID(wordSequence.getWord(1));
    trigramBuffer=loadTrigramBuffer(firstWordID,secondWordID);
    if (trigramBuffer != null) {
      loadedTrigramBuffer.put(oldest,trigramBuffer);
    }
 else {
      return null;
    }
  }
  return trigramBuffer.findTrigram(thirdWordID);
}",0.9516339869281044
19981,"/** 
 * Returns the unigram probability of the given unigram.
 * @param wordSequence the unigram word sequence
 * @return the unigram probability
 */
private float getUnigramProbability(WordSequence wordSequence){
  String unigram=wordSequence.getWord(0);
  Integer unigramID=(Integer)unigramIDMap.get(unigram);
  if (unigramID == null) {
    throw new Error(""String_Node_Str"" + unigram);
  }
 else {
    UnigramProbability probability=unigrams[unigramID.intValue()];
    return probability.getLogProbability();
  }
}","/** 
 * Returns the unigram probability of the given unigram.
 * @param wordSequence the unigram word sequence
 * @return the unigram probability
 */
private float getUnigramProbability(WordSequence wordSequence){
  String unigram=wordSequence.getWord(0);
  Integer unigramID=(Integer)unigramIDMap.get(unigram);
  if (unigramID == null) {
    unigram=""String_Node_Str"";
    unigramID=(Integer)unigramIDMap.get(unigram);
    if (unigramID == null) {
      throw new Error(""String_Node_Str"" + unigram);
    }
  }
  UnigramProbability probability=unigrams[unigramID.intValue()];
  return probability.getLogProbability();
}",0.8556338028169014
19982,"public static void main(String[] args) throws Exception {
  String propsPath;
  if (args.length == 0) {
    propsPath=""String_Node_Str"";
  }
 else {
    propsPath=args[0];
  }
  Timer.start(""String_Node_Str"");
  SphinxProperties.initContext(""String_Node_Str"",new URL(propsPath));
  LargeTrigramModel sm=new LargeTrigramModel(""String_Node_Str"");
  Timer.stop(""String_Node_Str"");
  Timer.dumpAll();
  LogMath logMath=LogMath.getLogMath(""String_Node_Str"");
  BufferedReader reader=new BufferedReader(new InputStreamReader(System.in));
  String input;
  System.out.println(""String_Node_Str"" + sm.getMaxDepth());
  System.out.print(""String_Node_Str"");
  while ((input=reader.readLine()) != null) {
    StringTokenizer st=new StringTokenizer(input);
    List list=new ArrayList();
    while (st.hasMoreTokens()) {
      String tok=(String)st.nextToken();
      list.add(tok);
    }
    WordSequence wordSequence=new WordSequence(list);
    float logProbability=sm.getProbability(wordSequence);
    System.out.println(""String_Node_Str"" + wordSequence + ""String_Node_Str""+ logProbability+ ""String_Node_Str""+ LogMath.logToLog(logProbability,logMath.getLogBase(),10.0f)+ ""String_Node_Str"");
    long usedMemory=Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
    System.out.println(""String_Node_Str"" + usedMemory + ""String_Node_Str"");
    System.out.print(""String_Node_Str"");
  }
  Timer timer=Timer.getTimer(""String_Node_Str"",""String_Node_Str"");
  List list1=new ArrayList();
  WordSequence ws1=new WordSequence(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  WordSequence ws2=new WordSequence(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  for (int i=0; i < 1000000; i++) {
    timer.start();
    sm.getProbability(ws1);
    timer.stop();
    timer.start();
    sm.getProbability(ws2);
    timer.stop();
  }
  Timer.dumpAll(""String_Node_Str"");
}","public static void main(String[] args) throws Exception {
  String propsPath;
  String testFile=null;
  if (args.length == 0) {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"");
  }
  propsPath=args[0];
  if (args.length == 2) {
    testFile=args[1];
  }
  SphinxProperties.initContext(""String_Node_Str"",new URL(propsPath));
  LargeTrigramModel lm=new LargeTrigramModel(""String_Node_Str"");
  Timer.dumpAll();
  LogMath logMath=LogMath.getLogMath(""String_Node_Str"");
  InputStream stream=new FileInputStream(testFile);
  BufferedReader reader=new BufferedReader(new InputStreamReader(stream));
  Timer timer=Timer.getTimer(""String_Node_Str"",""String_Node_Str"");
  String input;
  List wordSequences=new LinkedList();
  while ((input=reader.readLine()) != null) {
    StringTokenizer st=new StringTokenizer(input);
    List list=new ArrayList();
    while (st.hasMoreTokens()) {
      String tok=(String)st.nextToken();
      list.add(tok);
    }
    WordSequence wordSequence=new WordSequence(list);
    wordSequences.add(wordSequence);
  }
  for (Iterator i=wordSequences.iterator(); i.hasNext(); ) {
    WordSequence ws=(WordSequence)i.next();
    timer.start();
    lm.start();
    int logProbability=(int)lm.getProbability(ws);
    timer.stop();
    System.out.println(Utilities.pad(logProbability,10) + ""String_Node_Str"" + getString(ws));
    if (false) {
      long usedMemory=Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
      System.out.println(""String_Node_Str"" + usedMemory + ""String_Node_Str"");
      System.out.print(""String_Node_Str"");
    }
  }
  Timer.dumpAll(""String_Node_Str"");
}",0.4891922639362912
19983,"/** 
 * Returns the unigram probability of the given unigram.
 * @param wordSequence the unigram word sequence
 * @return the unigram probability
 */
private float getBigramProbability(WordSequence wordSequence){
  String firstWord=wordSequence.getWord(0);
  String secondWord=wordSequence.getWord(1);
  if (loader.getNumberBigrams() <= 0 || firstWord == null) {
    return getUnigramProbability(wordSequence.getNewest());
  }
  if (!hasUnigram(secondWord)) {
    secondWord=""String_Node_Str"";
  }
  int firstWordID=getWordID(firstWord);
  int secondWordID=getWordID(secondWord);
  BigramProbability bigram=findBigram(firstWordID,secondWordID);
  if (bigram != null) {
    return bigramProbTable[bigram.getProbabilityID()];
  }
 else {
    return (unigrams[firstWordID].getLogBackoff() + unigrams[secondWordID].getLogProbability());
  }
}","/** 
 * Returns the unigram probability of the given unigram.
 * @param wordSequence the unigram word sequence
 * @return the unigram probability
 */
private float getBigramProbability(WordSequence wordSequence){
  String firstWord=wordSequence.getWord(0);
  String secondWord=wordSequence.getWord(1);
  if (loader.getNumberBigrams() <= 0 || firstWord == null) {
    return getUnigramProbability(wordSequence.getNewest());
  }
  if (getUnigram(secondWord) == null) {
    throw new Error(""String_Node_Str"" + secondWord);
  }
  int firstWordID=getWordID(firstWord);
  int secondWordID=getWordID(secondWord);
  BigramProbability bigram=findBigram(firstWordID,secondWordID);
  if (bigram != null) {
    return bigramProbTable[bigram.getProbabilityID()];
  }
 else {
    return (unigrams[firstWordID].getLogBackoff() + unigrams[secondWordID].getLogProbability());
  }
}",0.936545240893067
19984,"/** 
 * Returns the ID of the given word.
 * @param word the word to find the ID
 * @return the ID of the word
 */
private final int getWordID(String word){
  UnigramProbability probability=(UnigramProbability)unigramIDMap.get(word.toLowerCase());
  if (probability == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + word);
  }
 else {
    return probability.getWordID();
  }
}","/** 
 * Returns the ID of the given word.
 * @param word the word to find the ID
 * @return the ID of the word
 */
private final int getWordID(String word){
  UnigramProbability probability=getUnigram(word);
  if (probability == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + word);
  }
 else {
    return probability.getWordID();
  }
}",0.925531914893617
19985,"/** 
 * Returns the unigram probability of the given unigram.
 * @param wordSequence the unigram word sequence
 * @return the unigram probability
 */
private float getUnigramProbability(WordSequence wordSequence){
  String unigram=wordSequence.getWord(0);
  UnigramProbability unigramProb=(UnigramProbability)unigramIDMap.get(unigram);
  if (unigramProb == null) {
    unigram=""String_Node_Str"";
    unigramProb=(UnigramProbability)unigramIDMap.get(unigram);
    if (unigramProb == null) {
      throw new Error(""String_Node_Str"" + unigram);
    }
  }
  return unigramProb.getLogProbability();
}","/** 
 * Returns the unigram probability of the given unigram.
 * @param wordSequence the unigram word sequence
 * @return the unigram probability
 */
private float getUnigramProbability(WordSequence wordSequence){
  String unigram=wordSequence.getWord(0);
  UnigramProbability unigramProb=getUnigram(unigram);
  if (unigramProb == null) {
    throw new Error(""String_Node_Str"" + unigram);
  }
  return unigramProb.getLogProbability();
}",0.7293889427740058
19986,"public static void main(String[] args) throws Exception {
  String propsPath;
  String testFile=null;
  if (args.length == 0) {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"");
  }
  propsPath=args[0];
  if (args.length == 2) {
    testFile=args[1];
  }
  SphinxProperties.initContext(""String_Node_Str"",new URL(propsPath));
  LargeTrigramModel lm=new LargeTrigramModel(""String_Node_Str"");
  LogMath logMath=LogMath.getLogMath(""String_Node_Str"");
  InputStream stream=new FileInputStream(testFile);
  BufferedReader reader=new BufferedReader(new InputStreamReader(stream));
  Timer timer=Timer.getTimer(""String_Node_Str"",""String_Node_Str"");
  String input;
  List wordSequences=new LinkedList();
  while ((input=reader.readLine()) != null) {
    StringTokenizer st=new StringTokenizer(input);
    List list=new ArrayList();
    while (st.hasMoreTokens()) {
      String tok=(String)st.nextToken();
      list.add(tok);
    }
    WordSequence wordSequence=new WordSequence(list);
    wordSequences.add(wordSequence);
  }
  int[] logScores=new int[wordSequences.size()];
  int s=0;
  timer.start();
  for (Iterator i=wordSequences.iterator(); i.hasNext(); ) {
    lm.start();
    WordSequence ws=(WordSequence)i.next();
    logScores[s++]=(int)lm.getProbability(ws);
    lm.stop();
  }
  timer.stop();
  s=0;
  for (Iterator i=wordSequences.iterator(); i.hasNext(); ) {
    WordSequence ws=(WordSequence)i.next();
    System.out.println(Utilities.pad(logScores[s++],10) + ""String_Node_Str"" + getString(ws));
  }
  if (true) {
    long usedMemory=Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
    System.out.println(""String_Node_Str"" + usedMemory + ""String_Node_Str"");
  }
  Timer.dumpAll();
}","public static void main(String[] args) throws Exception {
  String propsPath;
  String testFile=null;
  if (args.length == 0) {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"");
  }
  propsPath=args[0];
  if (args.length == 2) {
    testFile=args[1];
  }
  SphinxProperties.initContext(""String_Node_Str"",new URL(propsPath));
  LargeTrigramModel lm=new LargeTrigramModel(""String_Node_Str"");
  LogMath logMath=LogMath.getLogMath(""String_Node_Str"");
  InputStream stream=new FileInputStream(testFile);
  BufferedReader reader=new BufferedReader(new InputStreamReader(stream));
  Timer timer=Timer.getTimer(""String_Node_Str"",""String_Node_Str"");
  String input;
  List wordSequences=new LinkedList();
  while ((input=reader.readLine()) != null) {
    StringTokenizer st=new StringTokenizer(input);
    List list=new ArrayList();
    while (st.hasMoreTokens()) {
      String tok=(String)st.nextToken();
      list.add(tok.trim());
    }
    WordSequence wordSequence=new WordSequence(list);
    wordSequences.add(wordSequence);
  }
  int[] logScores=new int[wordSequences.size()];
  int s=0;
  timer.start();
  for (Iterator i=wordSequences.iterator(); i.hasNext(); ) {
    lm.start();
    WordSequence ws=(WordSequence)i.next();
    logScores[s++]=(int)lm.getProbability(ws);
    lm.stop();
  }
  timer.stop();
  s=0;
  for (Iterator i=wordSequences.iterator(); i.hasNext(); ) {
    WordSequence ws=(WordSequence)i.next();
    System.out.println(Utilities.pad(logScores[s++],10) + ""String_Node_Str"" + getString(ws));
  }
  if (true) {
    long usedMemory=Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
    System.out.println(""String_Node_Str"" + usedMemory + ""String_Node_Str"");
  }
  Timer.dumpAll();
}",0.997979797979798
19987,"/** 
 * Loads the language model from the given location. 
 * @param location the location of the language model
 */
private void loadBinary(String location) throws IOException {
  boolean bigEndian=true;
  DataInputStream stream=new DataInputStream(new BufferedInputStream(new FileInputStream(location)));
  int headerLength=stream.readInt();
  bytesRead+=4;
  if (headerLength != (DARPA_LM_HEADER.length() + 1)) {
    headerLength=Utilities.swapInteger(headerLength);
    if (headerLength == (DARPA_LM_HEADER.length() + 1)) {
      bigEndian=false;
    }
 else {
      throw new Error(""String_Node_Str"" + headerLength + ""String_Node_Str"");
    }
  }
  String header=readString(stream,headerLength - 1);
  stream.readByte();
  if (!header.equals(DARPA_LM_HEADER)) {
    throw new Error(""String_Node_Str"" + header);
  }
  int fileNameLength=readInt(stream,bigEndian);
  for (int i=0; i < fileNameLength; i++) {
    stream.readByte();
  }
  numberUnigrams=0;
  int logBigramSegmentSize=LOG2_BIGRAM_SEGMENT_SIZE_DEFAULT;
  int version=readInt(stream,bigEndian);
  System.out.println(""String_Node_Str"" + version);
  if (version <= 0) {
    readInt(stream,bigEndian);
    int formatLength;
    for (; ; ) {
      if ((formatLength=readInt(stream,bigEndian)) == 0) {
        break;
      }
      for (int i=0; i < formatLength; i++) {
        stream.readByte();
        bytesRead++;
      }
    }
    if (version <= -2) {
      logBigramSegmentSize=readInt(stream,bigEndian);
      if (logBigramSegmentSize < 1 || logBigramSegmentSize > 15) {
        throw new Error(""String_Node_Str"");
      }
    }
    numberUnigrams=readInt(stream,bigEndian);
  }
 else {
    numberUnigrams=version;
  }
  int bigramSegmentSize=1 << logBigramSegmentSize;
  if (numberUnigrams <= 0) {
    throw new Error(""String_Node_Str"" + numberUnigrams + ""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"" + numberUnigrams);
  numberBigrams=readInt(stream,bigEndian);
  if (numberBigrams < 0) {
    throw new Error(""String_Node_Str"" + numberBigrams);
  }
  System.out.println(""String_Node_Str"" + numberBigrams);
  numberTrigrams=readInt(stream,bigEndian);
  if (numberTrigrams < 0) {
    throw new Error(""String_Node_Str"" + numberTrigrams);
  }
  System.out.println(""String_Node_Str"" + numberTrigrams);
  unigrams=readUnigrams(stream,numberUnigrams,bigEndian);
  if (numberBigrams > 0) {
    bigramOffset=bytesRead;
    int bytesToSkip=(numberBigrams + 1) * 10;
    stream.skipBytes(bytesToSkip);
    bytesRead+=bytesToSkip;
  }
  if (numberTrigrams > 0) {
    trigramOffset=bytesRead;
    int bytesToSkip=numberTrigrams * 6;
    stream.skipBytes(bytesToSkip);
    bytesRead+=bytesToSkip;
  }
  if (numberBigrams > 0) {
    this.bigramProbTable=readProbabilitiesTable(stream,bigEndian);
  }
  if (numberTrigrams > 0) {
    trigramBackoffTable=readProbabilitiesTable(stream,bigEndian);
    trigramProbTable=readProbabilitiesTable(stream,bigEndian);
    int trigramSegTableSize=((numberBigrams + 1) / bigramSegmentSize) + 1;
    trigramSegmentTable=readTrigramSegmentTable(stream,bigEndian,trigramSegTableSize);
  }
  int wordsStringLength=readInt(stream,bigEndian);
  if (wordsStringLength <= 0) {
    throw new Error(""String_Node_Str"" + wordsStringLength);
  }
  String wordsString=readString(stream,wordsStringLength);
  int numberWords=0;
  for (int i=0; i < wordsStringLength; i++) {
    if (wordsString.charAt(i) == '\0') {
      numberWords++;
    }
  }
  if (numberWords != numberUnigrams) {
    throw new Error(""String_Node_Str"" + numberWords);
  }
  this.words=wordsString.split(""String_Node_Str"");
  buildUnigramIDMap();
  applyUnigramWeight();
  stream.close();
  FileInputStream is=new FileInputStream(location);
  fileChannel=is.getChannel();
}","/** 
 * Loads the language model from the given location. 
 * @param location the location of the language model
 */
private void loadBinary(String location) throws IOException {
  boolean bigEndian=true;
  DataInputStream stream=new DataInputStream(new BufferedInputStream(new FileInputStream(location)));
  int headerLength=stream.readInt();
  bytesRead+=4;
  if (headerLength != (DARPA_LM_HEADER.length() + 1)) {
    headerLength=Utilities.swapInteger(headerLength);
    if (headerLength == (DARPA_LM_HEADER.length() + 1)) {
      bigEndian=false;
    }
 else {
      throw new Error(""String_Node_Str"" + headerLength + ""String_Node_Str"");
    }
  }
  String header=readString(stream,headerLength - 1);
  stream.readByte();
  if (!header.equals(DARPA_LM_HEADER)) {
    throw new Error(""String_Node_Str"" + header);
  }
  int fileNameLength=readInt(stream,bigEndian);
  for (int i=0; i < fileNameLength; i++) {
    stream.readByte();
  }
  numberUnigrams=0;
  int logBigramSegmentSize=LOG2_BIGRAM_SEGMENT_SIZE_DEFAULT;
  int version=readInt(stream,bigEndian);
  System.out.println(""String_Node_Str"" + version);
  if (version <= 0) {
    readInt(stream,bigEndian);
    int formatLength;
    for (; ; ) {
      if ((formatLength=readInt(stream,bigEndian)) == 0) {
        break;
      }
      for (int i=0; i < formatLength; i++) {
        stream.readByte();
        bytesRead++;
      }
    }
    if (version <= -2) {
      logBigramSegmentSize=readInt(stream,bigEndian);
      if (logBigramSegmentSize < 1 || logBigramSegmentSize > 15) {
        throw new Error(""String_Node_Str"");
      }
    }
    numberUnigrams=readInt(stream,bigEndian);
  }
 else {
    numberUnigrams=version;
  }
  int bigramSegmentSize=1 << logBigramSegmentSize;
  if (numberUnigrams <= 0) {
    throw new Error(""String_Node_Str"" + numberUnigrams + ""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"" + numberUnigrams);
  numberBigrams=readInt(stream,bigEndian);
  if (numberBigrams < 0) {
    throw new Error(""String_Node_Str"" + numberBigrams);
  }
  System.out.println(""String_Node_Str"" + numberBigrams);
  numberTrigrams=readInt(stream,bigEndian);
  if (numberTrigrams < 0) {
    throw new Error(""String_Node_Str"" + numberTrigrams);
  }
  System.out.println(""String_Node_Str"" + numberTrigrams);
  unigrams=readUnigrams(stream,numberUnigrams + 1,bigEndian);
  if (numberBigrams > 0) {
    bigramOffset=bytesRead;
    int bytesToSkip=(numberBigrams + 1) * 8;
    stream.skipBytes(bytesToSkip);
    bytesRead+=bytesToSkip;
  }
  if (numberTrigrams > 0) {
    trigramOffset=bytesRead;
    int bytesToSkip=numberTrigrams * 4;
    stream.skipBytes(bytesToSkip);
    bytesRead+=bytesToSkip;
  }
  if (numberBigrams > 0) {
    this.bigramProbTable=readProbabilitiesTable(stream,bigEndian);
  }
  if (numberTrigrams > 0) {
    trigramBackoffTable=readProbabilitiesTable(stream,bigEndian);
    trigramProbTable=readProbabilitiesTable(stream,bigEndian);
    int trigramSegTableSize=((numberBigrams + 1) / bigramSegmentSize) + 1;
    trigramSegmentTable=readTrigramSegmentTable(stream,bigEndian,trigramSegTableSize);
  }
  int wordsStringLength=readInt(stream,bigEndian);
  if (wordsStringLength <= 0) {
    throw new Error(""String_Node_Str"" + wordsStringLength);
  }
  String wordsString=readString(stream,wordsStringLength);
  int numberWords=0;
  for (int i=0; i < wordsStringLength; i++) {
    if (wordsString.charAt(i) == '\0') {
      numberWords++;
    }
  }
  if (numberWords != numberUnigrams) {
    throw new Error(""String_Node_Str"" + numberWords);
  }
  this.words=wordsString.split(""String_Node_Str"");
  buildUnigramIDMap();
  applyUnigramWeight();
  stream.close();
  FileInputStream is=new FileInputStream(location);
  fileChannel=is.getChannel();
}",0.9987959866220736
19988,"/** 
 * Returns the unigram probability of the given unigram.
 * @param wordSequence the unigram word sequence
 * @return the unigram probability
 */
private float getUnigramProbability(WordSequence wordSequence){
  String unigram=wordSequence.getWord(0);
  UnigramProbability probability=(UnigramProbability)unigramIDMap.get(unigram);
  if (probability == null) {
    throw new Error(""String_Node_Str"" + unigram);
  }
 else {
    return probability.getLogProbability();
  }
}","/** 
 * Returns the unigram probability of the given unigram.
 * @param wordSequence the unigram word sequence
 * @return the unigram probability
 */
private float getUnigramProbability(WordSequence wordSequence){
  String unigram=wordSequence.getWord(0);
  Integer unigramID=(Integer)unigramIDMap.get(unigram);
  if (unigramID == null) {
    throw new Error(""String_Node_Str"" + unigram);
  }
 else {
    UnigramProbability probability=unigrams[unigramID.intValue()];
    return probability.getLogProbability();
  }
}",0.8036253776435045
19989,"/** 
 * Apply the unigram weight to the set of unigrams
 */
private void applyUnigramWeight(){
  float unigramWeight=props.getFloat(LanguageModel.PROP_UNIGRAM_WEIGHT,LanguageModel.PROP_UNIGRAM_WEIGHT_DEFAULT);
  float logUnigramWeight=logMath.linearToLog(unigramWeight);
  float logNotUnigramWeight=logMath.linearToLog(1.0f - unigrams.length);
  float logUniform=logMath.linearToLog(1.0f / (unigrams.length - 1));
  float p2=logUniform + logNotUnigramWeight;
  for (int i=0; i < unigrams.length; i++) {
    if (!words[i].equals(Dictionary.SENTENCE_START_SPELLING)) {
      float p1=unigrams[i].getLogProbability() + logUnigramWeight;
      unigrams[i].setLogProbability(logMath.addAsLinear(p1,p2));
    }
  }
}","/** 
 * Apply the unigram weight to the set of unigrams
 */
private void applyUnigramWeight(){
  float unigramWeight=props.getFloat(LanguageModel.PROP_UNIGRAM_WEIGHT,LanguageModel.PROP_UNIGRAM_WEIGHT_DEFAULT);
  float logUnigramWeight=logMath.linearToLog(unigramWeight);
  float logNotUnigramWeight=logMath.linearToLog(1.0f - unigramWeight);
  float logUniform=logMath.linearToLog(1.0f / (numberUnigrams));
  float p2=logUniform + logNotUnigramWeight;
  for (int i=0; i < numberUnigrams; i++) {
    if (!words[i].equals(Dictionary.SENTENCE_START_SPELLING)) {
      float p1=unigrams[i].getLogProbability() + logUnigramWeight;
      unigrams[i].setLogProbability(logMath.addAsLinear(p1,p2));
    }
  }
}",0.9461756373937678
19990,"/** 
 * Reads a float from the given DataInputStream.
 * @param stream the DataInputStream to read from
 * @param bigEndian true if the DataInputStream is in bigEndian,false otherwise
 */
private float readFloat(DataInputStream stream,boolean bigEndian) throws IOException {
  float value=stream.readFloat();
  bytesRead+=4;
  if (!bigEndian) {
    value=Utilities.swapFloat(value);
  }
  return value;
}","/** 
 * Reads a float from the given DataInputStream.
 * @param stream the DataInputStream to read from
 * @param bigEndian true if the DataInputStream is in bigEndian,false otherwise
 */
private float readFloat(DataInputStream stream,boolean bigEndian) throws IOException {
  bytesRead+=4;
  if (bigEndian) {
    return stream.readFloat();
  }
 else {
    return Utilities.readLittleEndianFloat(stream);
  }
}",0.8157248157248157
19991,"/** 
 * Reads an integer from the given DataInputStream.
 * @param stream the DataInputStream to read from
 * @param bigEndian true if the DataInputStream is in bigEndian,false otherwise
 */
private int readInt(DataInputStream stream,boolean bigEndian) throws IOException {
  int integer=stream.readInt();
  bytesRead+=4;
  if (!bigEndian) {
    integer=Utilities.swapInteger(integer);
  }
  return integer;
}","/** 
 * Reads an integer from the given DataInputStream.
 * @param stream the DataInputStream to read from
 * @param bigEndian true if the DataInputStream is in bigEndian,false otherwise
 */
private int readInt(DataInputStream stream,boolean bigEndian) throws IOException {
  bytesRead+=4;
  if (bigEndian) {
    return stream.readInt();
  }
 else {
    return Utilities.readLittleEndianInt(stream);
  }
}",0.800982800982801
19992,"/** 
 * Read in the unigrams in the given DataInputStream.
 * @param stream the DataInputStream to read from
 * @param numberUnigrams the number of unigrams to read
 * @param bigEndian true if the DataInputStream is big-endian,false otherwise
 * @return an array of UnigramProbability index by the unigram ID
 */
private UnigramProbability[] readUnigrams(DataInputStream stream,int numberUnigrams,boolean bigEndian) throws IOException {
  UnigramProbability[] unigrams=new UnigramProbability[numberUnigrams];
  for (int i=0; i < numberUnigrams; i++) {
    int unigramID=readInt(stream,bigEndian);
    assert(unigramID == i);
    float unigramProbability=readFloat(stream,bigEndian);
    float unigramBackoff=readFloat(stream,bigEndian);
    int firstBigramEntry=readInt(stream,bigEndian);
    float logProbability=logMath.log10ToLog(unigramProbability);
    float logBackoff=logMath.log10ToLog(unigramBackoff);
    unigrams[i]=new UnigramProbability(logProbability,logBackoff,firstBigramEntry);
    if (false) {
      System.out.println(""String_Node_Str"" + unigramID + ""String_Node_Str""+ unigramProbability+ ""String_Node_Str""+ unigramBackoff+ ""String_Node_Str""+ firstBigramEntry);
    }
  }
  return unigrams;
}","/** 
 * Read in the unigrams in the given DataInputStream.
 * @param stream the DataInputStream to read from
 * @param numberUnigrams the number of unigrams to read
 * @param bigEndian true if the DataInputStream is big-endian,false otherwise
 * @return an array of UnigramProbability index by the unigram ID
 */
private UnigramProbability[] readUnigrams(DataInputStream stream,int numberUnigrams,boolean bigEndian) throws IOException {
  UnigramProbability[] unigrams=new UnigramProbability[numberUnigrams];
  for (int i=0; i < numberUnigrams; i++) {
    int unigramID=readInt(stream,bigEndian);
    if (i != (numberUnigrams - 1)) {
      assert(unigramID == i);
    }
    float unigramProbability=readFloat(stream,bigEndian);
    float unigramBackoff=readFloat(stream,bigEndian);
    int firstBigramEntry=readInt(stream,bigEndian);
    float logProbability=logMath.log10ToLog(unigramProbability);
    float logBackoff=logMath.log10ToLog(unigramBackoff);
    unigrams[i]=new UnigramProbability(logProbability,logBackoff,firstBigramEntry);
    if (false) {
      System.out.println(""String_Node_Str"" + unigramID + ""String_Node_Str""+ unigramProbability+ ""String_Node_Str""+ unigramBackoff+ ""String_Node_Str""+ firstBigramEntry);
    }
  }
  return unigrams;
}",0.9817592217267936
19993,"/** 
 * Loads the language model from the given location. 
 * @param location the location of the language model
 */
private void loadBinary(String location) throws IOException {
  boolean bigEndian=true;
  DataInputStream stream=new DataInputStream(new BufferedInputStream(new FileInputStream(location)));
  int headerLength=stream.readInt();
  bytesRead+=4;
  if (headerLength != (DARPA_LM_HEADER.length() + 1)) {
    headerLength=Utilities.swapInteger(headerLength);
    if (headerLength == (DARPA_LM_HEADER.length() + 1)) {
      bigEndian=false;
    }
 else {
      throw new Error(""String_Node_Str"" + headerLength + ""String_Node_Str"");
    }
  }
  String header=readString(stream,headerLength - 1);
  stream.readByte();
  if (!header.equals(DARPA_LM_HEADER)) {
    throw new Error(""String_Node_Str"" + header);
  }
  int fileNameLength=readInt(stream,bigEndian);
  for (int i=0; i < fileNameLength; i++) {
    stream.readByte();
  }
  numberUnigrams=0;
  int logBigramSegmentSize=LOG2_BIGRAM_SEGMENT_SIZE_DEFAULT;
  int version=readInt(stream,bigEndian);
  System.out.println(""String_Node_Str"" + version);
  if (version <= 0) {
    readInt(stream,bigEndian);
    int formatLength;
    for (; ; ) {
      if ((formatLength=readInt(stream,bigEndian)) == 0) {
        break;
      }
      for (int i=0; i < formatLength; i++) {
        stream.readByte();
        bytesRead++;
      }
    }
    if (version <= -2) {
      logBigramSegmentSize=readInt(stream,bigEndian);
      if (logBigramSegmentSize < 1 || logBigramSegmentSize > 15) {
        throw new Error(""String_Node_Str"");
      }
    }
    numberUnigrams=readInt(stream,bigEndian);
  }
 else {
    numberUnigrams=version;
  }
  int bigramSegmentSize=1 << logBigramSegmentSize;
  if (numberUnigrams <= 0) {
    throw new Error(""String_Node_Str"" + numberUnigrams + ""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"" + numberUnigrams);
  numberBigrams=readInt(stream,bigEndian);
  if (numberBigrams < 0) {
    throw new Error(""String_Node_Str"" + numberBigrams);
  }
  System.out.println(""String_Node_Str"" + numberBigrams);
  numberTrigrams=readInt(stream,bigEndian);
  if (numberTrigrams < 0) {
    throw new Error(""String_Node_Str"" + numberTrigrams);
  }
  System.out.println(""String_Node_Str"" + numberTrigrams);
  unigrams=readUnigrams(stream,numberUnigrams + 1,bigEndian);
  if (numberBigrams > 0) {
    bigramOffset=bytesRead;
    int bytesToSkip=(numberBigrams + 1) * 8;
    stream.skipBytes(bytesToSkip);
    bytesRead+=bytesToSkip;
  }
  if (numberTrigrams > 0) {
    trigramOffset=bytesRead;
    int bytesToSkip=numberTrigrams * 4;
    stream.skipBytes(bytesToSkip);
    bytesRead+=bytesToSkip;
  }
  if (numberBigrams > 0) {
    this.bigramProbTable=readProbabilitiesTable(stream,bigEndian);
  }
  if (numberTrigrams > 0) {
    trigramBackoffTable=readProbabilitiesTable(stream,bigEndian);
    trigramProbTable=readProbabilitiesTable(stream,bigEndian);
    int trigramSegTableSize=((numberBigrams + 1) / bigramSegmentSize) + 1;
    trigramSegmentTable=readTrigramSegmentTable(stream,bigEndian,trigramSegTableSize);
  }
  int wordsStringLength=readInt(stream,bigEndian);
  if (wordsStringLength <= 0) {
    throw new Error(""String_Node_Str"" + wordsStringLength);
  }
  String wordsString=readString(stream,wordsStringLength);
  int numberWords=0;
  for (int i=0; i < wordsStringLength; i++) {
    if (wordsString.charAt(i) == '\0') {
      numberWords++;
    }
  }
  if (numberWords != numberUnigrams) {
    throw new Error(""String_Node_Str"" + numberWords);
  }
  this.words=wordsString.split(""String_Node_Str"");
  buildUnigramIDMap();
  applyUnigramWeight();
  stream.close();
  FileInputStream is=new FileInputStream(location);
  fileChannel=is.getChannel();
}","/** 
 * Loads the language model from the given location. 
 * @param location the location of the language model
 */
private void loadBinary(String location) throws IOException {
  FileInputStream fis=new FileInputStream(location);
  DataInputStream stream=new DataInputStream(new BufferedInputStream(fis));
  int headerLength=readInt(stream,bigEndian);
  if (headerLength != (DARPA_LM_HEADER.length() + 1)) {
    headerLength=Utilities.swapInteger(headerLength);
    if (headerLength == (DARPA_LM_HEADER.length() + 1)) {
      bigEndian=false;
    }
 else {
      throw new Error(""String_Node_Str"" + headerLength + ""String_Node_Str"");
    }
  }
  String header=readString(stream,headerLength - 1);
  readByte(stream);
  if (!header.equals(DARPA_LM_HEADER)) {
    throw new Error(""String_Node_Str"" + header);
  }
  int fileNameLength=readInt(stream,bigEndian);
  for (int i=0; i < fileNameLength; i++) {
    readByte(stream);
  }
  numberUnigrams=0;
  int logBigramSegmentSize=LOG2_BIGRAM_SEGMENT_SIZE_DEFAULT;
  int version=readInt(stream,bigEndian);
  System.out.println(""String_Node_Str"" + version);
  if (version <= 0) {
    readInt(stream,bigEndian);
    int formatLength;
    for (; ; ) {
      if ((formatLength=readInt(stream,bigEndian)) == 0) {
        break;
      }
      for (int i=0; i < formatLength; i++) {
        readByte(stream);
      }
    }
    if (version <= -2) {
      logBigramSegmentSize=readInt(stream,bigEndian);
      if (logBigramSegmentSize < 1 || logBigramSegmentSize > 15) {
        throw new Error(""String_Node_Str"");
      }
    }
    numberUnigrams=readInt(stream,bigEndian);
  }
 else {
    numberUnigrams=version;
  }
  int bigramSegmentSize=1 << logBigramSegmentSize;
  if (numberUnigrams <= 0) {
    throw new Error(""String_Node_Str"" + numberUnigrams + ""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"" + numberUnigrams);
  numberBigrams=readInt(stream,bigEndian);
  if (numberBigrams < 0) {
    throw new Error(""String_Node_Str"" + numberBigrams);
  }
  System.out.println(""String_Node_Str"" + numberBigrams);
  numberTrigrams=readInt(stream,bigEndian);
  if (numberTrigrams < 0) {
    throw new Error(""String_Node_Str"" + numberTrigrams);
  }
  System.out.println(""String_Node_Str"" + numberTrigrams);
  unigrams=readUnigrams(stream,numberUnigrams + 1,bigEndian);
  if (numberBigrams > 0) {
    bigramOffset=bytesRead;
    System.out.println(""String_Node_Str"" + bigramOffset);
    int bytesToSkip=(numberBigrams + 1) * BYTES_PER_BIGRAM;
    stream.skipBytes(bytesToSkip);
    bytesRead+=bytesToSkip;
  }
  if (numberTrigrams > 0) {
    trigramOffset=bytesRead;
    int bytesToSkip=numberTrigrams * BYTES_PER_TRIGRAM;
    stream.skipBytes(bytesToSkip);
    bytesRead+=bytesToSkip;
  }
  if (numberBigrams > 0) {
    this.bigramProbTable=readProbabilitiesTable(stream,bigEndian);
  }
  if (numberTrigrams > 0) {
    trigramBackoffTable=readProbabilitiesTable(stream,bigEndian);
    trigramProbTable=readProbabilitiesTable(stream,bigEndian);
    int trigramSegTableSize=((numberBigrams + 1) / bigramSegmentSize) + 1;
    trigramSegmentTable=readTrigramSegmentTable(stream,bigEndian,trigramSegTableSize);
  }
  int wordsStringLength=readInt(stream,bigEndian);
  if (wordsStringLength <= 0) {
    throw new Error(""String_Node_Str"" + wordsStringLength);
  }
  String wordsString=readString(stream,wordsStringLength);
  int numberWords=0;
  for (int i=0; i < wordsStringLength; i++) {
    if (wordsString.charAt(i) == '\0') {
      numberWords++;
    }
  }
  if (numberWords != numberUnigrams) {
    throw new Error(""String_Node_Str"" + numberWords);
  }
  this.words=wordsString.split(""String_Node_Str"");
  buildUnigramIDMap();
  fis.close();
  stream.close();
  is=new FileInputStream(location);
  fileChannel=is.getChannel();
}",0.9403620873269436
19994,"/** 
 * A test routine
 */
public static void main(String[] args) throws Exception {
  String propsPath;
  if (args.length == 0) {
    propsPath=""String_Node_Str"";
  }
 else {
    propsPath=args[0];
  }
  Timer.start(""String_Node_Str"");
  SphinxProperties.initContext(""String_Node_Str"",new URL(propsPath));
  LargeTrigramModel sm=new LargeTrigramModel(""String_Node_Str"");
  Timer.stop(""String_Node_Str"");
  Timer.dumpAll();
  LogMath logMath=LogMath.getLogMath(""String_Node_Str"");
  BufferedReader reader=new BufferedReader(new InputStreamReader(System.in));
  String input;
  System.out.println(""String_Node_Str"" + sm.getMaxDepth());
  System.out.print(""String_Node_Str"");
  while ((input=reader.readLine()) != null) {
    StringTokenizer st=new StringTokenizer(input);
    List list=new ArrayList();
    while (st.hasMoreTokens()) {
      String tok=(String)st.nextToken();
      list.add(tok);
    }
    WordSequence wordSequence=new WordSequence(list);
    System.out.println(""String_Node_Str"" + wordSequence + ""String_Node_Str""+ sm.getProbability(wordSequence)+ ""String_Node_Str""+ logMath.logToLn(sm.getProbability(wordSequence))+ ""String_Node_Str"");
    System.out.print(""String_Node_Str"");
  }
  Timer timer=Timer.getTimer(""String_Node_Str"",""String_Node_Str"");
  List list1=new ArrayList();
  WordSequence ws1=new WordSequence(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  WordSequence ws2=new WordSequence(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  for (int i=0; i < 1000000; i++) {
    timer.start();
    sm.getProbability(ws1);
    timer.stop();
    timer.start();
    sm.getProbability(ws2);
    timer.stop();
  }
  Timer.dumpAll(""String_Node_Str"");
}","/** 
 * A test routine
 */
public static void main(String[] args) throws Exception {
  String propsPath;
  if (args.length == 0) {
    propsPath=""String_Node_Str"";
  }
 else {
    propsPath=args[0];
  }
  Timer.start(""String_Node_Str"");
  SphinxProperties.initContext(""String_Node_Str"",new URL(propsPath));
  LargeTrigramModel sm=new LargeTrigramModel(""String_Node_Str"");
  Timer.stop(""String_Node_Str"");
  Timer.dumpAll();
  LogMath logMath=LogMath.getLogMath(""String_Node_Str"");
  BufferedReader reader=new BufferedReader(new InputStreamReader(System.in));
  String input;
  System.out.println(""String_Node_Str"" + sm.getMaxDepth());
  System.out.print(""String_Node_Str"");
  while ((input=reader.readLine()) != null) {
    StringTokenizer st=new StringTokenizer(input);
    List list=new ArrayList();
    while (st.hasMoreTokens()) {
      String tok=(String)st.nextToken();
      list.add(tok);
    }
    WordSequence wordSequence=new WordSequence(list);
    float logProbability=sm.getProbability(wordSequence);
    System.out.println(""String_Node_Str"" + wordSequence + ""String_Node_Str""+ logProbability+ ""String_Node_Str""+ LogMath.logToLog(logProbability,logMath.getLogBase(),10.0f)+ ""String_Node_Str"");
    System.out.print(""String_Node_Str"");
  }
  Timer timer=Timer.getTimer(""String_Node_Str"",""String_Node_Str"");
  List list1=new ArrayList();
  WordSequence ws1=new WordSequence(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  WordSequence ws2=new WordSequence(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  for (int i=0; i < 1000000; i++) {
    timer.start();
    sm.getProbability(ws1);
    timer.stop();
    timer.start();
    sm.getProbability(ws2);
    timer.stop();
  }
  Timer.dumpAll(""String_Node_Str"");
}",0.9591836734693876
19995,"/** 
 * Loads the bigram followers of the given first word in a bigram from disk to memory.
 * @param firstWordID ID of the first word
 * @return the bigram followers of the given word
 */
private BigramFollowers loadBigramFollowers(int firstWordID){
  BigramFollowers followers=null;
  if ((followers=isBigramLoaded(firstWordID)) == null) {
    long position=(long)(bigramOffset + unigrams[firstWordID].getFirstBigramEntry());
    int numberFollowers=unigrams[firstWordID + 1].getFirstBigramEntry() - unigrams[firstWordID].getFirstBigramEntry();
    long size=(long)(numberFollowers + 1) * 8;
    try {
      MappedByteBuffer buffer=fileChannel.map(FileChannel.MapMode.READ_ONLY,position,size);
      followers=new BigramFollowers(buffer,numberFollowers);
      followers.load();
    }
 catch (    IOException ioe) {
      ioe.printStackTrace();
      throw new Error(""String_Node_Str"");
    }
    loadedBigramFollowers.put(new Integer(firstWordID),followers);
  }
  return followers;
}","/** 
 * Loads the bigram followers of the given first word in a bigram from disk to memory.
 * @param firstWordID ID of the first word
 * @return the bigram followers of the given word
 */
private BigramFollowers loadBigramFollowers(int firstWordID){
  BigramFollowers followers=null;
  if ((followers=isBigramLoaded(firstWordID)) == null) {
    System.out.println(""String_Node_Str"");
    int firstBigramEntry=unigrams[firstWordID].getFirstBigramEntry();
    int numberFollowers=unigrams[firstWordID + 1].getFirstBigramEntry() - firstBigramEntry;
    if (numberFollowers > 0) {
      long position=(long)(bigramOffset + (firstBigramEntry * BYTES_PER_BIGRAM));
      long size=(long)(numberFollowers + 1) * BYTES_PER_BIGRAM;
      System.out.println(""String_Node_Str"" + position + ""String_Node_Str""+ size);
      try {
        assert((position + size) <= fileChannel.size());
        MappedByteBuffer buffer=fileChannel.map(FileChannel.MapMode.READ_ONLY,position,size);
        if (!bigEndian) {
          buffer.order(ByteOrder.LITTLE_ENDIAN);
        }
        followers=new BigramFollowers(buffer,numberFollowers);
        followers.load();
      }
 catch (      IOException ioe) {
        ioe.printStackTrace();
        throw new Error(""String_Node_Str"");
      }
      loadedBigramFollowers.put(new Integer(firstWordID),followers);
    }
  }
  return followers;
}",0.6983857264231096
19996,"/** 
 * Reads the probability table from the given DataInputStream.
 * @param stream the DataInputStream from which to read the table
 * @param bigEndian true if the given stream is bigEndian, false otherwise
 */
private float[] readProbabilitiesTable(DataInputStream stream,boolean bigEndian) throws IOException {
  int numProbs=readInt(stream,bigEndian);
  if (numProbs <= 0 || numProbs > 65536) {
    throw new Error(""String_Node_Str"" + numProbs);
  }
  float[] probTable=new float[numProbs];
  for (int i=0; i < numProbs; i++) {
    probTable[i]=readFloat(stream,bigEndian);
  }
  return probTable;
}","/** 
 * Reads the probability table from the given DataInputStream.
 * @param stream the DataInputStream from which to read the table
 * @param bigEndian true if the given stream is bigEndian, false otherwise
 */
private float[] readProbabilitiesTable(DataInputStream stream,boolean bigEndian) throws IOException {
  int numProbs=readInt(stream,bigEndian);
  if (numProbs <= 0 || numProbs > 65536) {
    throw new Error(""String_Node_Str"" + numProbs);
  }
  float[] probTable=new float[numProbs];
  for (int i=0; i < numProbs; i++) {
    probTable[i]=logMath.log10ToLog(readFloat(stream,bigEndian));
  }
  return probTable;
}",0.98371335504886
19997,"/** 
 * Reads a float from the given DataInputStream.
 * @param stream the DataInputStream to read from
 * @param bigEndian true if the DataInputStream is in bigEndian,false otherwise
 */
private float readFloat(DataInputStream stream,boolean bigEndian) throws IOException {
  bytesRead+=4;
  if (bigEndian) {
    return stream.readFloat();
  }
 else {
    return Utilities.readLittleEndianFloat(stream);
  }
}","/** 
 * Reads a float from the given DataInputStream.
 * @param stream the DataInputStream to read from
 * @param bigEndian true if the DataInputStream is in bigEndian,false otherwise
 */
private final float readFloat(DataInputStream stream,boolean bigEndian) throws IOException {
  bytesRead+=4;
  if (bigEndian) {
    return stream.readFloat();
  }
 else {
    return Utilities.readLittleEndianFloat(stream);
  }
}",0.9927360774818402
19998,"/** 
 * Reads an integer from the given DataInputStream.
 * @param stream the DataInputStream to read from
 * @param bigEndian true if the DataInputStream is in bigEndian,false otherwise
 */
private int readInt(DataInputStream stream,boolean bigEndian) throws IOException {
  bytesRead+=4;
  if (bigEndian) {
    return stream.readInt();
  }
 else {
    return Utilities.readLittleEndianInt(stream);
  }
}","/** 
 * Reads an integer from the given DataInputStream.
 * @param stream the DataInputStream to read from
 * @param bigEndian true if the DataInputStream is in bigEndian,false otherwise
 */
private final int readInt(DataInputStream stream,boolean bigEndian) throws IOException {
  bytesRead+=4;
  if (bigEndian) {
    return stream.readInt();
  }
 else {
    return Utilities.readLittleEndianInt(stream);
  }
}",0.9926470588235294
19999,"/** 
 * Returns the unigram probability of the given unigram.
 * @param wordSequence the unigram word sequence
 * @return the unigram probability
 */
private float getBigramProbability(WordSequence wordSequence){
  String firstWord=wordSequence.getWord(0);
  if (numberBigrams == 0 || firstWord == null) {
    return getUnigramProbability(wordSequence.getNewest());
  }
  if (!hasUnigram(wordSequence.getWord(1))) {
    throw new Error(""String_Node_Str"" + wordSequence.getWord(1));
  }
  int firstWordID=getWordID(firstWord);
  int numberBigramFollowers=unigrams[firstWordID + 1].getFirstBigramEntry() - unigrams[firstWordID].getFirstBigramEntry();
  int secondWordID=getWordID(wordSequence.getWord(1));
  BigramProbability bigram=null;
  if (numberBigramFollowers > 0) {
    BigramFollowers bigramFollowers=loadBigramFollowers(firstWordID);
    bigram=bigramFollowers.findBigram(secondWordID);
  }
  if (bigram != null) {
    return bigramProbTable[bigram.getProbabilityID()];
  }
 else {
    return (unigrams[firstWordID].getLogBackoff() + unigrams[secondWordID].getLogProbability());
  }
}","/** 
 * Returns the unigram probability of the given unigram.
 * @param wordSequence the unigram word sequence
 * @return the unigram probability
 */
private float getBigramProbability(WordSequence wordSequence){
  String firstWord=wordSequence.getWord(0).toLowerCase();
  String secondWord=wordSequence.getWord(1).toLowerCase();
  System.out.println(""String_Node_Str"" + firstWord + ""String_Node_Str""+ secondWord);
  if (numberBigrams == 0 || firstWord == null) {
    return getUnigramProbability(wordSequence.getNewest());
  }
  if (!hasUnigram(secondWord)) {
    throw new Error(""String_Node_Str"" + secondWord);
  }
  int firstWordID=getWordID(firstWord);
  int numberBigramFollowers=unigrams[firstWordID + 1].getFirstBigramEntry() - unigrams[firstWordID].getFirstBigramEntry();
  System.out.println(unigrams[firstWordID].getFirstBigramEntry() + ""String_Node_Str"" + unigrams[firstWordID + 1].getFirstBigramEntry());
  int secondWordID=getWordID(secondWord);
  BigramProbability bigram=null;
  if (numberBigramFollowers > 0) {
    BigramFollowers bigramFollowers=loadBigramFollowers(firstWordID);
    bigram=bigramFollowers.findBigram(secondWordID);
  }
  if (bigram != null) {
    assert(words[bigram.getWordID()].equals(secondWord));
    return bigramProbTable[bigram.getProbabilityID()];
  }
 else {
    return (unigrams[firstWordID].getLogBackoff() + unigrams[secondWordID].getLogProbability());
  }
}",0.8190552441953562
20000,"/** 
 * Returns the ID of the given word.
 * @param word the word to find the ID
 * @return the ID of the word
 */
private int getWordID(String word){
  Integer integer=(Integer)unigramIDMap.get(word);
  if (integer == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + word);
  }
 else {
    return integer.intValue();
  }
}","/** 
 * Returns the ID of the given word.
 * @param word the word to find the ID
 * @return the ID of the word
 */
private final int getWordID(String word){
  Integer integer=(Integer)unigramIDMap.get(word);
  if (integer == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + word);
  }
 else {
    return integer.intValue();
  }
}",0.9912790697674418
